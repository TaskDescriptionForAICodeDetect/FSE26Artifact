[
  {
    "language": "Crystal",
    "code": "MOD = 1_000_000_007i64\nn, h, d = read_line.split.map(&.to_i64)\nfact = Array.new(n + 1, 1i64)\n1.upto(n) do |i|\n  fact[i] = fact[i - 1] * i % MOD\nend\nfact_sum = (fact.sum + MOD - 1) % MOD\ncount = Array.new(h + 1, 0i64)\ncount[0] = fact[n]\nsum = count[0]\n1.upto(h - 1) do |i|\n  count[i] = sum * fact_sum % MOD\n  sum += count[i]\n  sum += MOD - count[i - d] if i >= d\n  sum %= MOD\nend\nputs sum\n"
  },
  {
    "language": "Crystal",
    "code": "MOD = 1_000_000_007i64\nn, h, d = read_line.split.map(&.to_i64)\nfact = Array.new(n + 1, 1i64)\nfact_sum = Array.new(n + 1, 0i64)\n1.upto(n) do |i|\n  fact[i] = fact[i - 1] * i % MOD\n  fact_sum[i] = (fact_sum[i - 1] + fact[i]) % MOD\nend\ncount = Array.new(h + 1, 0i64)\ncount[0] = fact[n]\nsum = count[0]\n1.upto(h - 1) do |i|\n  count[i] = sum * fact_sum[n] % MOD\n  sum += count[i]\n  if i >= d\n    sum += MOD - count[i - d]\n  end\n  sum %= MOD\nend\nputs sum\n"
  },
  {
    "language": "Fortran",
    "code": "program balanced_piles\n  implicit none\n  integer(8), parameter :: md = 1000000007_8\n  integer :: n, h, d, i\n  integer(8) :: dp(1000000) = 0_8, f = 1_8, k = 0_8, s = 0_8\n  read(*,*) n, h, d\n  do i = 1, n\n    f = mod(int(i,8)*f,md)\n    k = mod(k+f,md)\n  end do\n  do i = 1, d\n    dp(i) = mod(s*k+f,md)\n    s = mod(s+dp(i),md)\n  end do\n  do i = d+1, h\n    dp(i) = mod(s*k,md)\n    s = mod(s+md-dp(i-d)+dp(i),md)\n  end do\n  write(*,'(i0)') dp(h)\nend program balanced_piles"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n\tusing value_type = ::std::uint_fast64_t;\n\tvalue_type n;\npublic:\n\tModInt() : n(0) {}\n\tModInt(value_type n_) : n(n_ % mod) {}\n\tModInt(const ModInt& m) : n(m.n) {}\n\n\ttemplate<typename T>\n\texplicit operator T() const { return static_cast<T>(n); }\n\tvalue_type get() const { return n; }\n\n\tfriend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n\t\treturn os << a.n;\n\t}\n\n\tfriend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n\t\tvalue_type x;\n\t\tis >> x;\n\t\ta = ModInt<mod>(x);\n\t\treturn is;\n\t}\n\n\tbool operator==(const ModInt& m) const { return n == m.n; }\n\tbool operator!=(const ModInt& m) const { return n != m.n; }\n\tModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n\tModInt pow(value_type b) const{\n\t\tModInt ans = 1, m = ModInt(*this);\n\t\twhile(b){\n\t\t\tif(b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tModInt inv() const { return (*this).pow(mod-2); }\n\tModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n\tModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n\tModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n\tModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n\tModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n\tModInt& operator++(){ n += 1; return *this; }\n\tModInt& operator--(){ n -= 1; return *this; }\n\tModInt operator++(int){\n\t\tModInt old(n);\n\t\tn += 1;\n\t\treturn old;\n\t}\n\tModInt operator--(int){\n\t\tModInt old(n);\n\t\tn -= 1;\n\t\treturn old;\n\t}\n\tModInt operator-() const { return ModInt(mod-n); }\n};\n\ntemplate<class ValueMonoid, class OperatorMonoid, class Modifier,\n\ttemplate<class...> class Container=::std::vector>\nclass LazySegTree{\npublic:\n\tusing value_structure = ValueMonoid;\n\tusing value_type = typename value_structure::value_type;\n\tusing operator_structure = OperatorMonoid;\n\tusing operator_type = typename operator_structure::value_type;\n\tusing modifier = Modifier;\n\tusing const_reference = const value_type &;\n\tusing container_value_type = Container<value_type>;\n\tusing container_operator_type = Container<operator_type>;\n\tusing size_type = typename container_value_type::size_type;\n\nprivate:\n\tcontainer_value_type tree;\n\tcontainer_operator_type lazy;\n\tsize_type size_, height;\n\n\tstatic size_type getsize(const size_type x){\n\t\tsize_type ret = 1;\n\t\twhile(ret < x)\n\t\t\tret <<= 1;\n\t\treturn ret;\n\t}\n\n\tstatic size_type getheight(const size_type x){\n\t\tsize_type ret = 0;\n\t\twhile((static_cast<size_type>(1) << ret) < x){\n\t\t\tret++;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tinline static value_type calc(const value_type a, const value_type b){\n\t\treturn value_structure::operation(a, b);\n\t}\n\n\tinline static void apply(operator_type &data, const operator_type a){\n\t\tdata = operator_structure::operation(data, a);\n\t}\n\n\tinline static value_type reflect(const value_type v, const operator_type o){\n\t\treturn modifier::operation(v, o);\n\t}\n\n\tvoid push(const size_type index){\n\t\ttree[index] = reflect(tree[index], lazy[index]);\n\t\tapply(lazy[index << 1], lazy[index]);\n\t\tapply(lazy[index << 1 | 1], lazy[index]);\n\t\tlazy[index] = operator_structure::identity();\n\t}\n\n\tvoid calc_node(const size_type index){\n\t\tif(tree.size() <= (index << 1 | 1)) return;\n\t\tassert(0 < index);\n\t\ttree[index] = calc(reflect(tree[index << 1],  lazy[index << 1]),\n\t\t\t\treflect(tree[index << 1 | 1], lazy[index << 1 | 1]));\n\t}\n\n\tvoid build(size_type index){\n\t\twhile(index >>= 1){\n\t\t\tcalc_node(index);\n\t\t}\n\t}\n\n\tvoid propagate(const size_type index){\n\t\tfor(size_type shift = height; shift ; --shift){\n\t\t\tpush(index >> shift);\n\t\t}\n\t}\n\n\tvoid rebuild(){\n\t\tfor(size_type i = size_-1;i > 0;--i){\n\t\t\tcalc_node(i);\n\t\t}\n\t}\npublic:\n\tLazySegTree() : size_(0), height(0), tree(), lazy(){}\n\tLazySegTree(const size_type size)\n\t\t\t: size_(size), height(getheight(size)),\n\t\t\t\ttree(size << 1, value_structure::initializer()),\n\t\t\t\tlazy(size << 1, operator_structure::identity()){\n\t\trebuild();\n\t}\n\ttemplate<class InputIterator>\n\tLazySegTree(InputIterator first, InputIterator last)\n\t\t\t: size_(::std::distance(first, last)){\n\t\theight = getheight(size_);\n\t\ttree = container_value_type(size_, value_structure::identity());\n\t\tlazy = container_operator_type(size_ << 1, operator_structure::identity());\n\t\ttree.insert(tree.end(), first, last);\n\t\trebuild();\n\t}\n\n\tsize_type size() const { return size_; }\n\tconst_reference operator[](const size_type k){\n\t\tassert(k < size_);\n\t\tpropagate(k+size_);\n\t\ttree[k+size_] = reflect(tree[k+size_], lazy[k+size_]);\n\t\tlazy[k+size_] = operator_structure::identity();\n\t\treturn tree[k+size_];\n\t}\n\n\tvalue_type query(size_type l, size_type r){\n\t\tassert(l <= r);\n\t\tassert(0 <= l && l < size_);\n\t\tassert(0 <= r && r <= size_);\n\t\tvalue_type retl = value_structure::identity(),\n\t\t\t\t\t\t\t retr = value_structure::identity();\n\t\tl += size_;\n\t\tr += size_;\n\t\tpropagate(l);\n\t\tpropagate(r-1);\n\t\tfor(; l < r ; l >>= 1, r >>= 1){\n\t\t\tif(l&1){\n\t\t\t\tretl = calc(retl, reflect(tree[l], lazy[l]));\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif(r&1){\n\t\t\t\tr--;\n\t\t\t\tretr = calc(reflect(tree[r], lazy[r]), retr);\n\t\t\t}\n\t\t}\n\t\treturn calc(retl, retr);\n\t}\n\n\tvoid update(size_type l, size_type r, const operator_type& data){\n\t\tassert(l <= r);\n\t\tassert(0 <= l && l < size_);\n\t\tassert(0 <= r && r <= size_);\n\t\tl += size_;\n\t\tr += size_;\n\t\tpropagate(l);\n\t\tpropagate(r - 1);\n\t\tfor(size_type l_ = l, r_ = r; l_ < r_ ; l_ >>= 1, r_ >>= 1){\n\t\t\tif(l_ & 1) apply(lazy[l_++], data);\n\t\t\tif(r_ & 1) apply(lazy[--r_], data);\n\t\t}\n\t\tbuild(l);\n\t\tbuild(r - 1);\n\t}\n\n\ttemplate<class F>\n\tvoid update(size_type index, const F& f){\n\t\tassert(0 <= index && index < size());\n\t\tindex += size_;\n\t\tpropagate(index);\n\t\ttree[index] = f(::std::move(tree[index]));\n\t\tlazy[index] = operator_structure::identity();\n\t\tbuild(index);\n\t}\n\n\t/*\n\ttemplate<class F>\n\tsize_type search(const F& f) const { // [0, result) is True and [0, result-1) is not.\n\t\tif(f(value_structure::identity()))\n\t\t\treturn 0;\n\t\tif(!f(tree[1]))\n\t\t\treturn size_+1;\n\t\tvalue_type acc = value_structure::identity();\n\t\tsize_type i = 1;\n\t\twhile(i < \n\t}\n\t*/\n};\n\nconst int64 mod = 1e9+7;\nusing Mint = ModInt<mod>;\n\nclass v_monoid {\npublic: \n  using value_type = Mint;\n  static value_type identity() { return 0; }\n  static value_type initializer() { return 0; }\n  static value_type operation(const value_type& a, const value_type& b) {\n    return a + b;\n  }\n};\n\nclass o_monoid {\npublic: \n  using value_type = Mint;\n  static value_type identity() { return 0; }\n  static value_type operation(const value_type &a, const value_type &b) {\n    return a + b;\n  }\n};\n\nclass modifier {\npublic:\n  static Mint operation(const Mint& a, const Mint &b) {\n    return a + b;\n  }\n};\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n  int64 N, H, D;\n  cin >> N >> H >> D;\n  Mint co = 0, a = 1;\n  for (int64 i = 0; i < N; i++) {\n    a *= i+1;\n    co += a;\n  }\n\n  LazySegTree<v_monoid, o_monoid, modifier> dp(H+1);\n  dp.update(1, D+1, 1);\n  FOR(i, 1, H) {\n    Mint now = dp.query(i, i+1);\n    dp.update(i+1, min(i+D+1, H+1), now * co);\n  }\n  co = 1;\n  FOR(i, 1, N+1) co *= i;\n  cout << dp.query(H, H+1)*co << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define eb emplace_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ntypedef vector<T> vt;\ninline int getInt() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\nconst int MX = 1000005;\n\n// Mod int\nconst int mod = 1000000007;\n// const int mod = 998244353;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\n//\n\nmint dp[MX];\n\nint main() {\n  int n,h,d;\n  scanf(\"%d%d%d\",&n,&h,&d);\n  ++d;\n  mint x = 0, f = 1;\n  rrep(i,n) f *= i, x += f;\n  mint ans = 0;\n  dp[0] = 1;\n  rrep(i,h) {\n    mint now = dp[i-1];\n    if (i >= d) now -= dp[i-d];\n    dp[i] = dp[i-1]+now*x;\n    ans = now;\n  }\n  ans *= f;\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nconst ll mod = 1e9 + 7;\nll N, H, D;\n\n// 0-indexed\n// [l, r)\ntemplate <typename T>\nstruct Bit {\n    V<T> data;\n    T id_ele;\n\n    Bit(ll size, T id_ele) : id_ele(id_ele) {\n        ll bsize = 1;\n        while(bsize < size) bsize *= 2;\n        data = V<T>(bsize + 1, id_ele);\n    }\n\n    T sum(ll pos) {\n        T ret = id_ele;\n        for(; 0 < pos; pos -= pos & -pos) (ret += data[pos]) %= mod;\n        return ret;\n    }\n\n    // T sum(ll l, ll r) { return (sum(r) - sum(l) + mod) % mod; }\n\n    void add(ll pos, T delta) {\n        for(++pos; pos < data.size(); pos += pos & -pos) (data[pos] += delta) %= mod;\n    }\n};\n\nll test() {\n    auto dp = make_v<ll>(0, H + 1, H + 1);\n    dp[0][0] = 1;\n    for(ll i = 0; i <= H; i++) for(ll j = 0; j <= H; j++) {\n        if(i == j) {\n            for(ll k = 1; k <= D && i + k <= H; k++) {\n                (dp[i + k][j] += dp[i][j]) %= mod;\n                (dp[i][j + k] += dp[i][j]) %= mod;\n            }\n        } else if(i < j) {\n            for(ll k = j; k <= min(j + D, H); k++) {\n                (dp[k][j] += dp[i][j]) %= mod;\n            }\n        } else {\n            for(ll k = i; k <= min(i + D, H); k++) {\n                (dp[i][k] += dp[i][j]) %= mod;\n            }\n        }\n    }\n    // for(ll i = 0; i <= H; i++) for(ll j = 0; j <= H; j++) printf(\"dp[%ld][%ld] = %ld\\n\", i, j, dp[i][j]);\n    return dp.back().back();\n}\n\nint main() {\n    cin >> N >> H >> D;\n    V<ll> fact(N + 1, 1);\n    for(ll i = 1; i <= N; i++) fact[i] = fact[i - 1] * i % mod;\n    Bit<ll> bt(H + 10, 0);\n    bt.add(0, fact[N]);\n    bt.add(1, (mod - fact[N]) % mod);\n    ll fsum = accumulate(fact.begin() + 1, fact.end(), 0ll) % mod;\n    for(ll i = 0; i <= H - 2; i++) {\n        ll l = i + 1;\n        ll r = min(H, i + D + 1);\n        ll add_v = bt.sum(i + 1) * fsum % mod;\n        // DEBUG(make_tuple(i, add_v));\n        bt.add(l, add_v);\n        bt.add(r, (mod - add_v) % mod);\n    }\n\n    ll ans = 0;\n    for(ll i = H - D; i < H; i++) (ans += bt.sum(i + 1)) %= mod;\n    cout << ans << endl;\n    // cout << test() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iosfwd>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <vector>\n#include <bitset>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\n#include <deque>\n#include <string>\n#include <list>\n#include <iterator>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <algorithm>\n#include <assert.h>\n#include <unordered_map>\n\nusing namespace std;\nconst int N = 1e6 + 500;\nconst int LN = 21;\nconst long long mod = 1e9 + 7;\nconst long long INF = 1LL << 57;\n\nlong long n, m, u, v, k, t, q, a, h, x, d;\n\nlong long fact[N];\nlong long dp[N];\n\nint main() {\n   ios::sync_with_stdio(false);cin.tie(0);\n   cin >> n >> h >> d;\n   \n   fact[0] = 1;\n   long long sum = 0;\n   for (int i = 1; i <= n; ++i) {\n      fact[i] = 1LL * i * fact[i - 1];\n      fact[i] %= mod;\n      sum += fact[i];\n      if (sum >= mod) sum -= mod;\n   }\n   \n   dp[0] = fact[n];\n   for (int i = 1; i <= h - 1; ++i) {\n      long long cur = dp[i - 1];\n      if (i - d - 1>= 0) cur -= dp[i - d - 1];\n      if (cur < 0) cur += mod;\n      dp[i] = (sum * cur) % mod;\n      dp[i] += dp[i - 1];\n      if (dp[i] >= mod) dp[i] -= mod;\n   }\n   \n   long long cur = dp[h - 1];\n   if (h - d - 1 >= 0) cur -= dp[h - d - 1];\n   if (cur < 0) cur += mod;\n   cout << cur << endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\n#define N 500000\nll MOD=1e9+7;\n\nll mat[11][11];\n//遅延評価\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree\n{\n  using F = function< Monoid(Monoid, Monoid) >;\n  using G = function< Monoid(Monoid, OperatorMonoid) >;\n  using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n  using P = function< OperatorMonoid(OperatorMonoid, int) >;\n \n  int sz;\n  vector< Monoid > data;\n  vector< OperatorMonoid > lazy;\n  const F f;\n  const G g;\n  const H h;\n  const P p;\n  const Monoid M1;\n  const OperatorMonoid OM0;\n \n \n  LazySegmentTree(int n, const F f, const G g, const H h, const P p,\n                  const Monoid &M1, const OperatorMonoid OM0)\n      : f(f), g(g), h(h), p(p), M1(M1), OM0(OM0)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    data.assign(2 * sz, M1);\n    lazy.assign(2 * sz, OM0);\n  }\n \n  void set(int k, const Monoid &x)\n  {\n    data[k + sz] = x;\n  }\n \n  void build()\n  {\n    for(int k = sz - 1; k > 0; k--) {\n      data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n    }\n  }\n \n  void propagate(int k, int len)\n  {\n    if(lazy[k] != OM0) {\n      if(k < sz) {\n        lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n        lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      }\n      data[k] = g(data[k], p(lazy[k], len));\n      lazy[k] = OM0;\n    }\n  }\n \n  Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r)\n  {\n    propagate(k, r - l);\n    if(r <= a || b <= l) {\n      return data[k];\n    } else if(a <= l && r <= b) {\n      lazy[k] = h(lazy[k], x);\n      propagate(k, r - l);\n      return data[k];\n    } else {\n      return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n                         update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n    }\n  }\n \n  Monoid update(int a, int b, const OperatorMonoid &x)\n  {\n    return update(a, b, x, 1, 0, sz);\n  }\n \n \n  Monoid query(int a, int b, int k, int l, int r)\n  {\n    propagate(k, r - l);\n    if(r <= a || b <= l) {\n      return M1;\n    } else if(a <= l && r <= b) {\n      return data[k];\n    } else {\n      return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n               query(a, b, 2 * k + 1, (l + r) >> 1, r));\n    }\n  }\n \n  Monoid query(int a, int b)\n  {\n    return query(a, b, 1, 0, sz);\n  }\n \n  Monoid operator[](const int &k)\n  {\n    return query(k, k + 1);\n  }\n};\nauto f=[](ll a,ll b){return (a+b)%MOD;};\nauto g=[](ll a,ll b){return (a*b)%MOD;};\nauto ff=[](ll a,ll b){return b;};\nauto h=[](ll a,ll b){return (ll)max(a,b);};\nauto p=[](ll a,ll b){return a;};\n//例\n//区間add　区間min\nLazySegmentTree<ll> dp(2100000,f,f,f,g,0,0);\n//区間add 区間sum\n//LazySegmentTree<ll> seg(n,f,f,f,g,0,0);\n \n \n//LazySegmentTree(n,f,g,h,p,M1,OM0) \n//サイズnで初期化\n//fは二つの区間の要素をマージする二項演算\n//gは要素と作用素をマージする二項演算(第三因数は区間の長さ)\n//hは作用素同士をマージする二項演算\n//p(value,length)は作用素を下におろした時の演算\n//M1はモノイドの単位元\n//OM0は作用素の単位元\n//update(a,b,x) 区間[a,b)に作用素 x を作用\n//query(a,b) 区間[a,b) の値\nmain(){\n    ll n=in(),h=in(),d=in();\n    //LazySegmentTree<ll> dp(h+d+100,h,f,f,p,LLINF,0ll);\n    ll ans=0;\n    vector<ll> rui(n+100);\n    rui[1]=1;\n    ll r=1;\n    rep2(i,1,n-1){\n        rui[i+1]=r*(i+1)%MOD+rui[i];\n        r=(r*(i+1))%MOD;\n        rui[i+1]%=MOD;\n    }\n    dp.update(0,1,r);\n    rep2(i,0,h-1){\n        if(i+d<h){\n            dp.update(i+1,i+d+1,dp[i]*rui[n]%MOD);\n        }\n        else{\n            dp.update(i+1,i+d+1,dp[i]*rui[n]%MOD);\n            ans=(ans+dp[i])%MOD;\n        }\n        /*rep2(j,i+1,i+d){\n            if(j==h)dp[j]=(dp[j]+dp[i])%MOD;\n            else\n            dp[j]=(dp[j]+dp[i]*((n*(n+1)/2)%MOD)%MOD)%MOD;\n        }*/\n    }\n    cout<<ans%MOD;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#ifdef NON_SUBMIT\n#define TEST(n) (n)\n#define tout cerr\n#else\n#define TEST(n) ((void)0)\n#define tout cin\n#endif\n \nusing namespace std;\n\nconst int MOD=1e9+7;\nint D[1000001];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL); cout.tie(NULL);\n\tTEST(freopen(\"input.txt\",\"r\",stdin));\n\tTEST(freopen(\"output.txt\",\"w\",stdout));\n\tTEST(freopen(\"debug.txt\",\"w\",stderr));\n\tint N, H, P, t=1, m=1;\n\tcin>>N>>H>>P;\n\tfor(int i=2;i<=N;i++) m=(m+(t=(1LL*t*i)%MOD))%MOD;\n\tD[0]=t;\n\tfor(int i=1;i<=P;i++) D[i]=(1LL*(m+1)*D[i-1])%MOD;\n\tfor(int i=P+1;i<H;i++) D[i]=(1LL*m*(MOD+D[i-1]-D[i-P-1])+D[i-1])%MOD;\n\ttout<<D[H-1]<<' '<<D[H-P-1]<<'\\n';\n\tcout<<(MOD+D[H-1]-D[H-P-1])%MOD<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<tuple>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define Per(i,sta,n) for(int i=n-1;i>=sta;i--)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\n\ntemplate<int mod>\nstruct ModInt {\n    long long x;\n \n    ModInt() : x(0) {}\n    ModInt(long long y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n    explicit operator int() const {return x;}\n \n    ModInt &operator+=(const ModInt &p) {\n        if((x += p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator-=(const ModInt &p) {\n        if((x += mod - p.x) >= mod) x -= mod;\n        return *this;\n    }\n    ModInt &operator*=(const ModInt &p) {\n        x = (int)(1LL * x * p.x % mod);\n        return *this;\n    }\n    ModInt &operator/=(const ModInt &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n \n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n \n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n \n    ModInt inverse() const{\n        int a = x, b = mod, u = 1, v = 0, t;\n        while(b > 0) {\n            t = a / b;\n            a -= t * b;\n            swap(a, b);\n            u -= t * v;\n            swap(u, v);\n        }\n        return ModInt(u);\n    }\n\n    ModInt power(long long p) const{\n        int a = x;\n        if (p==0) return 1;\n        if (p==1) return ModInt(a);\n        if (p%2==1) return (ModInt(a)*ModInt(a)).power(p/2)*ModInt(a);\n        else return (ModInt(a)*ModInt(a)).power(p/2);\n    }\n\n    ModInt power(const ModInt p) const{\n        return ((ModInt)x).power(p.x);\n    }\n\n    friend ostream &operator<<(ostream &os, const ModInt<mod> &p) {\n        return os << p.x;\n    }\n    friend istream &operator>>(istream &is, ModInt<mod> &a) {\n        long long x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return (is);\n    }\n};\n\nusing modint = ModInt<mod>;\n\n\nstruct ModFac{\n  public:\n    vector<modint> f,i_f;\n    int n;\n\n    ModFac(int n_){\n      n=n_;\n      f.resize(n+1,1);\n      i_f.resize(n+1,1);\n      for(int i=0;i<n;i++){\n        f[i+1]=f[i]*(modint)(i+1);\n      }\n      i_f[n]=f[n].power(mod-2);\n      for(int i=n-1;i>=0;i--){\n        i_f[i]=i_f[i+1]*(modint)(i+1);\n      }\n    }\n    ModFac(modint n_){\n      n=(int)n_;\n      f.resize(n+1,1);\n      i_f.resize(n+1,1);\n      for(int i=0;i<n;i++){\n        f[i+1]=f[i]*(modint)(i+1);\n      }\n      i_f[n]=f[n].power(mod-2);\n      for(int i=n-1;i>=0;i--){\n        i_f[i]=i_f[i+1]*(modint)(i+1);\n      }\n    }\n    \n    modint factorial(int x){\n      //cout << f.size() << endl;\n      return f[x];\n    }\n        \n    modint inv_factorial(int x){\n      return i_f[x];\n    }\n    \n    modint comb(int m,int k){\n      if (m<0 or k<0) return 0;\n      if (m<k) return 0;\n      return f[m]*i_f[k]*i_f[m-k];\n    }\n};\n\n\nint n,h,d;\nModFac F(2000010);\nmodint dp[2000010],dp_S[2000010];\n\nvoid solve(){\n    cin >> n >> h >> d;\n    modint S=0;\n    Rep(i,1,n+1){\n        S+=F.factorial(i);\n    }\n    modint ans=0;\n    dp[0]=1;dp_S[1]=1;\n    Rep(i,1,h+1){\n        dp[i]=S*(dp_S[i]-dp_S[max(0,i-d)]);\n        dp_S[i+1]=dp[i]+dp_S[i];\n    }\n    cout << F.factorial(n)*dp[h]/S << endl;\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(50);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nconst ll MOD = 1000000007;\n\nll modpow(ll x, ll n, ll mod = MOD) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, H, D;\n    cin >> n >> H >> D;\n\n    ll f = 1;\n    ll sumf = 0;\n    for (int i = 1; i <= n; i++) {\n        f = f * i % MOD;\n        (sumf += f) %= MOD;\n    }\n\n    vector<ll> dp(H, 0);\n    dp[0] = 1;\n    ll s = 1;\n    for (int i = 1; i < H; i++) {\n        dp[i] = s * sumf % MOD;\n        (s += dp[i]) %= MOD;\n        if (i >= D) {\n            s = (s + MOD - dp[i - D]) % MOD;\n        }\n    }\n    ll ans = s * f % MOD;\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\nauto & in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i * i <= N; ++i)\n\t{\n\t\tif (N % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD>& other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD>& other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD>& other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_% MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<1000000007> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\n#if 0\ntemplate<typename RET = mint, typename Integral>\nRET combination(Integral all, Integral get)\n{\n\tassert(all >= get);\n\tget = std::min(all - get, get);\n#if 1\n\t//時間計算量O(1)+初期化O(NlogMOD)\n\tstatic_assert(false, \"\");\n\tstatic const auto fact_v = fact_set_c<要素数 + 1>();\n\tstatic const auto fact_div_v = [&]() {\n\t\tauto tmp = fact_v;\n\t\tfor (auto& i : tmp) { i = ~i; }\n\t\treturn tmp;\n\t}();\n\t//return fact_v[all] / (fact_v[get] * fact_v[all - get]);\n\treturn fact_v[all] * fact_div_v[get] * fact_div_v[all - get];\n#elif 0\n\t//時間計算量O(1)\n\t//空間計算量、初期化時間計算量O(N^2)\n\tconstexpr int32_t ALL_MAX = 要素数;// 10'000;\n\tstatic std::vector<RET> DP_comb[ALL_MAX + 1];\n\tif (!DP_comb[all].empty())\n\t{\n\t\treturn DP_comb[all][get];\n\t}\n\n\tif (DP_comb[0].empty())\n\t{\n\t\tDP_comb[0].resize(1);\n\t\tDP_comb[0][0] = (RET)1;\n\t\tDP_comb[1].resize(1);\n\t\tDP_comb[1][0] = (RET)1;\n\t}\n\tfor (int32_t i = 2; i <= all; i++)\n\t{\n\t\tif (DP_comb[i].empty())\n\t\t{\n\t\t\tint32_t size = i / 2 + 1;\n\t\t\tDP_comb[i].resize(size);\n\t\t\tDP_comb[i][0] = (RET)1;\n\t\t\tfor (int32_t j = 1; j < size - 1; j++)\n\t\t\t{\n\t\t\t\tDP_comb[i][j] = DP_comb[i - 1][j - 1] + DP_comb[i - 1][j];\n\t\t\t}\n\t\t\tDP_comb[i][size - 1] = DP_comb[i - 1][size - 2] + DP_comb[i - 1][(i & 1) ? (size - 1) : (size - 2)];\n\t\t}\n\t}\n\treturn DP_comb[all][get];\n#else\n\t//時間計算量O(get * logMOD)\n\tRET ret = (RET)1;\n\tfor (Integral i = 1; i <= get; ++i)\n\t{\n\t\tret *= all + 1 - i;\n\t\tret /= i;\n\t}\n\treturn ret;\n#endif\n}\n#endif\n\nconst auto fact_v = fact_set_c<2000000>();\nauto fact_sum = fact_v;\n\n\n\nint32_t N,H,D;\n\nmint func(int h);\nmint dp2[1000001];\nbool used2[1000001];\nmint funcsum(int h) {\n\tif (h > H) {\n\t\treturn 0_mi;\n\t}\n\tif (used2[h]) {\n\t\treturn dp2[h];\n\t}\n\tused2[h] = true;\n\treturn dp2[h] = func(h) + funcsum(h + 1);\n}\n\n\nmint dp[1000001];\nbool used[1000001];\nmint func(int h) {\n\tif (h == H) {\n\t\treturn 1_mi;\n\t}\n\tif (used[h]) {\n\t\treturn dp[h];\n\t}\n\tused[h] = true;\n\n\tmint result = 0_mi;\n\t//for (int d = 1; d <= D && h+d <= H; d++)\n\t//{\n\t//\tfor (int32_t add = 1; add <= N; ++add)\n\t//\t{\n\t//\t\tresult += fact_v[add] * func(h + d);\n\t//\t}\n\t//}\n\tresult = fact_sum[N] * (funcsum(h+1) - funcsum(std::min(h + D, H)+1));\n\treturn dp[h] = result;\n}\n\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\tin.tie(nullptr);\n\tout.tie(nullptr);\n\n\tin >> N >> H >> D;\n\tfor (size_t i = 2; i < 2000000; i++)\n\t{\n\t\tfact_sum[i] += fact_sum[i - 1];\n\t}\n\n\tmint result = 0_mi;\n\tfor (int d = 1; d <= D && d <= H; d++)\n\t{\n\t\tresult += fact_v[N] * func(d);\n\t}\n\n\tout << result << endl;\n\n\treturn 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint dp[2000010];\nconst int mod = 1000000007;\nsigned main(){\n    int n,h,d;\n    int x=1,y = 0;\n    cin>>n>>h>>d;\n    for(int i=1 ; i<=n ; i++){\n        (x*=i)%=mod;\n        (y+=x)%=mod;\n    }\ndp[0]=x;\nfor(int i=0 ; i<=h ; i++){\n    if(!i){\n        (dp[i+1]+=dp[i])%=mod;\n        (dp[i+d+1]+=mod-dp[i])%=mod;\n    }\n    if(i) {\n        (dp[i+1]+=dp[i])%=mod;\n        (dp[i+1]+=y*dp[i]%mod)%=mod;\n        (dp[i+d+1]+=(mod-y*dp[i]%mod))%=mod;\n    }\n}\ncout<<dp[h];\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma warning(disable : 4996)\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#define __builtin_popcountll __popcnt64\n#endif\n\n#include <limits.h>\n#include <math.h>\n#include <time.h>\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define REPR(i, n) for (int i = n - 1; i >= 0; --i)\n#define FOR(i, m, n) for (int i = m; i < n; ++i)\n#define FORR(i, m, n) for (int i = m - 1; i >= n; --i)\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v, n) reverse(v, v + n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define print(x) cout << (x) << '\\n'\n#define pe(x) cout << (x) << \" \"\n#define DEBUG(x) cout << #x << \": \" << x << endl\n#define lb(v, n) lower_bound(v.begin(), v.end(), (n))\n#define ub(v, n) upper_bound(v.begin(), v.end(), (n))\n//#define int long long\n#define double long double\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i, v.size()) cout << v[i] << ((i == v.size() - 1) ? \"\\n\" : \" \")\ntemplate <typename T1, typename T2> inline void chmin(T1& a, T2 b) {\n\tif (a > b) a = b;\n}\ntemplate <typename T1, typename T2> inline void chmax(T1& a, T2 b) {\n\tif (a < b) a = b;\n}\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntypedef array<int, 3> arr3;\nstd::random_device rd;\nstd::mt19937 mt(rd());\nconstexpr ll MOD = 998244353;\nconstexpr int MAX = 500050;\nconst double pi = acos(-1);\nconstexpr double EPS = 1e-8;\nconstexpr ll LINF = 1e18 + 1;\nconstexpr int INF = 1e9 + 1;\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\nstruct mint {\n\tll x; // typedef long long ll;\n\tmint(ll x = 0) :x((x%mod + mod) % mod) {}\n\tmint operator-() const { return mint(-x); }\n\tmint& operator+=(const mint a) {\n\t\tif ((x += a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint a) {\n\t\tif ((x += mod - a.x) >= mod) x -= mod;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const mint a) { (x *= a.x) %= mod; return *this; }\n\tmint operator+(const mint a) const { return mint(*this) += a; }\n\tmint operator-(const mint a) const { return mint(*this) -= a; }\n\tmint operator*(const mint a) const { return mint(*this) *= a; }\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime mod\n\tmint inv() const { return pow(mod - 2); }\n\tmint& operator/=(const mint a) { return *this *= a.inv(); }\n\tmint operator/(const mint a) const { return mint(*this) /= a; }\n};\nistream& operator>>(istream& is, const mint& a) { return is >> a.x; }\nostream& operator<<(ostream& os, const mint& a) { return os << a.x; }\n\nvoid solve() {\n\tint N, H, D; cin >> N >> H >> D;\n\tmint f = 1;\n\tmint s = 0;\n\tFOR(i, 1, N + 1) {\n\t\tf *= i;\n\t\ts += f;\n\t}\n\tvector<mint>dp(H + 2);\n\tdp[1] += 1;\n\tdp[D + 1] -= 1;\n\tFOR(i, 1, H) {\n\t\tdp[i + 1] += dp[i];\n\t\tint l = i + 1, r = min(H + 1, i + D + 1);\n\t\tdp[l] += dp[i] * s;\n\t\tdp[r] -= dp[i] * s;\n\t}\n\tmint ans = dp[H] * f;\n\tprint(ans);\n}\n\n\n\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tmt.seed((int)(time(0)));\n\t//int q;\n\t//cin >> q;\n\t//while (q--)\n\tsolve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int p=1e9+7;\n\ninline int power(int x, int y){\n\tint s=1;\n\twhile (y){\n\t\tif (y&1) s=(ll)s*x%p;\n\t\tx=(ll)x*x%p; y>>=1;\n\t}\n\treturn s;\n}\n\nconst int N=1e6+10;\n\nint f[N];\n\nint main(){\n\tint n,h,d;\n\tcin>>n>>h>>d;\n\tint fac=1,sfac=0;\n\tfor (int i=1;i<=n;i++){\n\t\tfac=(ll)fac*i%p;\n\t\tsfac=(sfac+fac)%p;\n\t}\n\tf[0]=fac;\n\tfor (int i=1;i<=h;i++)\n\t\tf[i]=((ll)(f[i-1]-(i-d-1<0?0:f[i-d-1]))*sfac+f[i-1])%p;\n\tcout<<(ll)(f[h]-f[h-1]+p)*power(sfac,p-2)%p;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nstruct BIT { //0-origin!!! update and get just like lazy_segtree\n\tint n; vl bit0, bit1;\n\tvoid init(int mx) {\n\t\tn = mx;\n\t\tbit0 = vl(n + 1, 0); bit1 = vl(n + 1, 0);\n\t}\n\tBIT(int mx = 0) { init(mx); } \n\n\tll ga(vl& bit, int i) {\n\t\tll s = 0;\n\t\twhile(i > 0) { ADD(s, bit[i]); i -= i & -i; }\n\t\treturn s;\n\t}\n\tvoid app(vl& bit, int i, ll x) {\n\t\twhile(i <= n) { ADD(bit[i], x); i += i & -i; }\n\t}\n\tvoid update(int a, int b, ll x) { //[a, b)\n\t\ta++;\n\t\tapp(bit0, a, (mod - x * (a - 1) % mod) % mod);\n\t\tapp(bit1, a, x % mod);\n\t\tapp(bit0, b + 1, x * b % mod);\n\t\tapp(bit1, b + 1, mod - x);\n\t}\n\tll get(int a, int b) { //[a, b)\n\t\ta++;\n\t\treturn ((ga(bit1, b) * b % mod + ga(bit0, b) % mod + 2 * mod) \n\t\t\t- (ga(bit1, a - 1) * (a - 1) % mod + ga(bit0, a - 1) % mod)) % mod;\n\t}\n};\n\nint N, H, D;\nBIT dp;\n\nvoid solve() {\n\tcin >> N >> H >> D;\n\tdp.init(H);\n\tll sf = 0, fac = 1;\n\trep(i, 1, N + 1) {\n\t\tfac = fac * i % mod;\n\t\tADD(sf, fac);\n\t}\n\tdp.update(0, 0 + 1, fac);\n\n\trep(i, 0, H) {\n\t\tif(i != 0) {\n\t\t\tll v = dp.get(i, i + 1);\n\t\t\tdp.update(i, i + 1, (mod + v * sf % mod - v) % mod);\n\t\t}\n\t\tdp.update(i + 1, min(i + D + 1, H), dp.get(i, i + 1));\n\t}\n\t// rep(i, 0, H) debug(i, dp.get(i, i + 1));\n\tcout << dp.get(H - D, H) << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MOD 1000000007\n\n//ａをbで割る\nlong long mod_div(long long a,long long b){\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n\nll dp[1111111];\nll fact[1111111];\nll factAcc[1111111];\n\nvoid calFact(){\n\tfact[0] = 1;\n\tREP(i, 1111110) {\n\t\tfact[i+1] = fact[i] * (i+1) % MOD;\n\t\tfactAcc[i+1] = (factAcc[i] + fact[i+1]) % MOD;\n\t}\n}\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\tcalFact();\n\tll n, d, h;cin >> n >> h >> d;\n\tdp[0] = mod_div(1, factAcc[n]);\n\tll sum = 0;\n\tll l = 0;\n\n\tREP(i, h){\n\t\tsum = (sum + dp[i] * factAcc[n] % MOD) % MOD;\n\t\twhile(l < i && i - l >= d){\n\t\t\tsum = (sum + MOD - dp[l] * factAcc[n] % MOD) % MOD;\n\t\t\tl++;\n\t\t}\n\t\tdp[i+1] = sum;\n\t}\n\n\tcout << dp[h] * fact[n] % MOD << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\ninline ll fastpow(ll bas, ll ex){\n\tregister ll res = 1; bas %= MOD;\n\tfor(; ex; ex >>= 1, bas = bas * bas % MOD) if(ex & 1) res = res * bas % MOD;\n\treturn res;\n}\n\ninline int kazu(int a, const int &b) {return (a += b) >= MOD ? a - MOD : a;}\ninline int hiku(int a, const int &b) {return (a -= b) < 0 ? a + MOD : a;}\n\nint N, H, D, fac[1000005] = {1}, sumfac = 0, isumfac, f[1000005], sumf;\n\nint main(){\n\tgetint(N), getint(H), getint(D);\n\tfor(register int i = 1; i <= N; i++) fac[i] = fac[i - 1] * (ll)i % MOD;\n\tfor(register int i = 1; i <= N; i++) sumfac = kazu(sumfac, fac[i]);\n\tisumfac = fastpow(sumfac, MOD - 2), sumf = f[0] = 1;\n\tfor(register int i = 1; i <= H; i++){\n\t\tif(i > D) sumf = hiku(sumf, f[i - D - 1]);\n\t\tf[i] = sumf * (ll)sumfac % MOD, sumf = kazu(sumf, f[i]);\n\t}\n\treturn printf(\"%d\\n\", f[H] * (ll)fac[N] % MOD * isumfac % MOD), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#ifdef tabr\n#include \"library/debug.cpp\"\n#else\n#define debug(...) 0\n#endif\n\ntemplate <ll mod>\nstruct modular {\n    ll value;\n    modular(ll x = 0) {\n        value = x % mod;\n        if (value < 0) value += mod;\n    }\n\n    modular& operator+=(modular other) {\n        if ((value += other.value) >= mod) value -= mod;\n        return *this;\n    }\n    modular& operator-=(modular other) {\n        if ((value -= other.value) < 0) value += mod;\n        return *this;\n    }\n    modular& operator*=(modular other) {\n        value = value * other.value % mod;\n        return *this;\n    }\n    modular& operator/=(modular other) {\n        ll a = 0, b = 1, c = other.value, m = mod;\n        while (c != 0) {\n            ll t = m / c;\n            m -= t * c;\n            swap(c, m);\n            a -= t * b;\n            swap(a, b);\n        }\n        a %= mod;\n        if (a < 0) a += mod;\n        value = value * a % mod;\n        return *this;\n    }\n    modular& operator^=(modular other) {\n        ll r = 1, x = value, n = other.value;\n        while (n > 0) {\n            if (n & 1) r = r * x % mod;\n            x = x * x % mod;\n            n >>= 1;\n        }\n        value = r;\n        return *this;\n    }\n    modular operator+(modular rhs) {\n        return modular(*this) += rhs;\n    }\n    modular operator-(modular rhs) {\n        return modular(*this) -= rhs;\n    }\n    modular operator*(modular rhs) {\n        return modular(*this) *= rhs;\n    }\n    modular operator/(modular rhs) {\n        return modular(*this) /= rhs;\n    }\n    modular operator^(modular rhs) {\n        return modular(*this) ^= rhs;\n    }\n    bool operator==(modular rhs) {\n        return value == rhs.value;\n    };\n    bool operator!=(modular rhs) {\n        return value != rhs.value;\n    };\n    bool operator<(modular rhs) {\n        return value < rhs.value;\n    }\n};\ntemplate <ll mod>\nstring to_string(modular<mod> x) {\n    return to_string(x.value);\n}\ntemplate <ll mod>\nostream& operator<<(ostream& stream, modular<mod> x) {\n    x.value %= mod;\n    if (x.value < 0) x.value += mod;\n    return stream << x.value;\n}\ntemplate <ll mod>\nistream& operator>>(istream& stream, modular<mod>& x) {\n    stream >> x.value;\n    x.value %= mod;\n    if (x.value < 0) x.value += mod;\n    return stream;\n}\nconst ll mod = 1e9 + 7;\nusing mint = modular<mod>;\n\nvector<mint> fac, finv;\ninline void cinit(int n) {\n    fac.resize(n, 1);\n    finv.resize(n, 1);\n    for (int i = 2; i < n; i++) {\n        fac[i] = fac[i - 1] * i;\n        finv[i] = finv[i - 1] / i;\n    }\n}\ninline mint C(int n, int k) {\n    if (n < k || k < 0 || n < 0) return 0;\n    return fac[n] * finv[k] * finv[n - k];\n}\ninline mint H(int n, int k) {\n    return C(n + k - 1, k);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, h, d;\n    cin >> n >> h >> d;\n    cinit(1001000);\n    mint fsum;\n    rep(i, 1, n + 1) fsum += fac[i];\n    vector<mint> dp(h + 1), sdp(h + 1);\n    dp[0] = sdp[0] = fac[n] / fsum;\n    rep(i, 1, h + 1) {\n        dp[i] = sdp[i - 1];\n        if (i - d > 0) dp[i] -= sdp[i - d - 1];\n        dp[i] *= fsum;\n        sdp[i] = sdp[i - 1] + dp[i];\n    }\n    cout << dp[h] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<unsigned P> struct ModInt {\n  using M = ModInt;\n  unsigned v;\n  ModInt() : v(0) {}\n  ModInt(auto x) : v(x >= 0 ? x % P : (P - -x % P) % P) {}\n  constexpr ModInt(unsigned v, int) : v(v) {}\n  static constexpr unsigned p() { return P; }\n  M operator+() const { return *this; }\n  M operator-() const { return {v ? P - v : 0, 0}; }\n  explicit operator bool() const noexcept { return v; }\n  bool operator!() const noexcept { return !(bool) *this; }\n  M operator*(M r) const { return M(*this) *= r; }\n  M operator/(M r) const { return M(*this) /= r; }\n  M operator+(M r) const { return M(*this) += r; }\n  M operator-(M r) const { return M(*this) -= r; }\n  bool operator==(M r) const { return v == r.v; }\n  bool operator!=(M r) const { return !(*this == r); }\n  M& operator*=(M r) { v = (uint64_t) v * r.v % P; return *this; }\n  M& operator/=(M r) { return *this *= r.inv(); }\n  M& operator+=(M r) { if ((v += r.v) >= P) v -= P; return *this; }\n  M& operator-=(M r) { if ((v += P - r.v) >= P) v -= P; return *this; }\n  M inv() const {\n    int a = v, b = P, x = 1, u = 0;\n    while (b) {\n      int q = a / b;\n      swap(a -= q * b, b);\n      swap(x -= q * u, u);\n    }\n    assert(a == 1);\n    return x;\n  }\n  M pow(auto n) const {\n    if (n < 0) return pow(-n).inv();\n    M res = 1;\n    for (M a = *this; n; a *= a, n >>= 1) if (n & 1) res *= a;\n    return res;\n  }\n  friend M operator*(auto l, M r) { return M(l) *= r; }\n  friend M operator/(auto l, M r) { return M(l) /= r; }\n  friend M operator+(auto l, M r) { return M(l) += r; }\n  friend M operator-(auto l, M r) { return M(l) -= r; }\n  friend ostream& operator<<(ostream& os, M r) { return os << r.v; }\n  friend istream& operator>>(istream& is, M& r) { lint x; is >> x; r = x; return is; }\n  friend bool operator==(auto l, M r) { return M(l) == r; }\n  friend bool operator!=(auto l, M r) { return !(l == r); }\n};\nusing Mint = ModInt<(unsigned) 1e9 + 7>;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, H, D; cin >> n >> H >> D;\n  Mint c, f = 1;\n  for (int i = 1; i <= n; ++i) c += f *= i;\n  V<Mint> dp(H + 1);\n  for (int i = 1; i <= D; ++i) dp[i] = 1;\n  Mint s;\n  for (int i = 0; i < H; ++i) {\n    s += dp[i];\n    if (i >= D) s -= dp[i - D];\n    dp[i + 1] += s * c;\n  }\n  cout << dp.back() * f << '\\n';\n  /*cerr << \"dp(\" << dp.size() << \") = {\"; for (const auto& e : dp) cerr << e << \", \"; cerr << \"} (l.\" << __LINE__ << \")\\n\";\n  {\n    VV<Mint> dp(H + 1, V<Mint>(n + 1));\n    dp[0][n] = 1;\n    for (int m = 0; m <= H; ++m) {\n      for (int c = 1; c <= n; ++c) {\n        for (int i = 1; i <= D and m + i <= H; ++i) dp[m + i][1] += dp[m][c];\n        if (c < n) dp[m][c + 1] += dp[m][c] * (c + 1);\n      }\n    }\n    cerr << \"dp(\" << dp.size() << \", \" << dp[0].size() << \")\\n\"; for (const auto& v : dp) { for (const auto& e : v) cerr << e << '\\t'; cerr << '\\n'; }\n  }*/\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const int MOD = 998244353;\n//const long long int MOD = 998244353;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nlong long int power(long long int x, long long int n, long long int M) {\n\tlong long int ret = 1;\n\tlong long int by = x;\n\twhile (n) {\n\t\tif (n & 1) {\n\t\t\tret *= by;\n\t\t\tret %= M;\n\t\t}\n\t\tby *= by;\n\t\tby %= M;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tcin >> H >> K;\n\tvector<long long int>by(max(N, H) + 1, 1);\n\tvector<long long int>rev_by(max(N, H) + 1, 1);\n\tfor (int i = 1; i <= max(N, H); i++) {\n\t\tby[i] = by[i - 1] * i;\n\t\tby[i] %= MOD;\n\t\trev_by[i] = power(by[i], MOD - 2, MOD);\n\t}\n\tlong long int box = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tbox += by[i];\n\t\tbox %= MOD;\n\t}\n\tvector<long long int>dp(H + 1);\n\tdp[0] = by[N];\n\tfor (int i = 1; i <= K; i++)dp[i] = by[N];\n\tfor (int i = 1; i <= H; i++) {\n\t\tdp[i] = dp[i - 1];\n\t\tif (i - K - 1 >= 0)dp[i] -= dp[i - K - 1];\n\t\tdp[i] += MOD;\n\t\tdp[i] %= MOD;\n\t\tif (i == H)break;\n\t\tdp[i] *= box;\n\t\tdp[i] %= MOD;\n\t\tdp[i] += dp[i - 1];\n\t\tdp[i] %= MOD;\n\t}\n\tcout << dp.back() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nconst int M = 1e9+7;\n\nint dp[1000100];\n\nint mpow(long long a, int n) {\n  if (n % 2) return mpow(a, n-1) * a;\n  if (n == 0) return 1;\n  return mpow(a*a, n/2);\n}\n\nint main()\n{\n  int n, h, d; cin >> n >> h >> d;\n  \n  long long kaijo = 1, kaijo_sum = 0;\n  for (int i = 1; i <= n; ++i) {\n    kaijo = kaijo * i % M;\n    kaijo_sum = (kaijo_sum + kaijo) % M;\n  }\n  \n  long long sum = dp[0] = kaijo;\n  for (int i = 1; i < h; ++i) {\n    dp[i] = sum * kaijo_sum % M;\n    sum = (sum + dp[i]) % M;\n    if (i >= d) sum = (sum - dp[i-d] + M) % M;\n  }\n  \n  cout << sum << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\nconst ll N_MAX = 1000001;\n\nll fac[1000001];\nll dp[1000001];\n\nvoid init(){\n    fac[0] = 1;\n    for(int i = 1; i <= N_MAX; i++) {\n        fac[i] = fac[i-1]*i;\n        fac[i] %= MOD;\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    init();\n    ll N, H, D;\n    cin >> N >> H >> D;\n    ll sum = 0;\n    for(int i = 1; i <= N; i++){\n        sum += fac[i];\n        sum %= MOD;\n    }\n    dp[0] = 1;\n    ll tmp = 0;\n    for(int i = 1; i <= H; i++){\n        if(i-D-1 >= 0) {\n            tmp -= dp[i-D-1];\n            tmp += MOD;\n            tmp %= MOD;\n        }\n        tmp += dp[i-1];\n        tmp %= MOD;\n        if(i != H) dp[i] = (tmp*sum)%MOD;\n        else dp[i] = tmp;\n    }\n    ll ans = (dp[H]*fac[N])%MOD;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define maxn 1000005\nconst int mod=1e9+7;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\n#define mp make_pair\n#define ff first\n#define ss second\n\nint n,d,h;\nint f[maxn];\n\ninline int read(){\n    int x=0,f=1; char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nint power(int a,int k){\n\tint ret=1;\n\tfor (;k;k>>=1,a=1ll*a*a%mod) if (k&1) ret=1ll*ret*a%mod;\n\treturn ret;\n}\n\nint main(){\n\tn=read(),h=read(),d=read(); int fac=1,val=0;\n\tfor (int i=1;i<=n;i++) fac=1ll*fac*i%mod,val=(val+fac)%mod;\n\tf[0]=1; int sum=f[0];\n\tfor (int i=1,j=0;i<=h;i++){\n\t\tf[i]=1ll*sum*val%mod;\n\t\tsum=(sum+f[i])%mod; if (i-j==d) sum=(sum-f[j])%mod,++j;\n\t}\n\tint ans=1ll*f[h]*fac%mod*power(val,mod-2)%mod;\n\tans=(ans+mod)%mod;\n\tcout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nusing ll = long long;\nconst ll MOD = 1e9 + 7;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tll n, h, d;\n\tcin >> n >> h >> d;\n\n\tll raise_sum = 1;\n\tll raise_prod = 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\traise_prod = raise_prod * i % MOD;\n\t\traise_sum = (raise_sum + raise_prod) % MOD;\n\t}\n\n\t// Initially n! sets order\n\t// Selecting k at a level gives k! to setting next order\n\n\tvector<ll> pref_sums = {raise_prod};\n\tfor (int k = 1; k <= h; ++k) {\n\t\tll below = (pref_sums[k-1] - (k > d ? pref_sums[k-(d+1)] : 0)) % MOD;\n\t\tif (below < 0) below += MOD;\n\n\t\tll row_sum = below * raise_sum % MOD;\n\t\tll row_add = (row_sum + pref_sums.back()) % MOD;\n\t\tpref_sums.push_back(row_add);\n\n\t\tif (k == h) {\n\t\t\tcout << below << '\\n';\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\ntemplate <uint32_t Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using max_type = uint64_t;\n\n  static constexpr value_type mod = Modulus;\n  static constexpr value_type mod_min = 1;\n  static constexpr value_type mod_max = 2147483647;\n  static_assert(mod >= mod_min, \"invalid mod :: too small\");\n  static_assert(mod <= mod_max, \"invalid mod :: too big\");\n\n  template <class T>\n  static constexpr value_type normalize(T value_) {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= mod;\n      if (value_ == 0) return 0;\n      return mod - value_;\n    }\n    return value_ % mod;\n  }\n\nprivate:\n  value_type value;\n\npublic:\n  constexpr modular(): value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_): value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() { return static_cast<T>(value); }\n\n  constexpr value_type operator () () const { return value; }\n  constexpr modular operator - () const { return modular(mod - value); }\n  constexpr modular operator ~ () const { return inverse(); }\n\n  constexpr value_type &extract() { return value; }\n  constexpr modular inverse() const { return power(mod - 2); }\n  constexpr modular power(max_type exp) const {\n    modular res(1), mult(*this);\n    while (exp > 0) {\n      if (exp & 1) res *= mult;\n      mult *= mult;\n      exp >>= 1;\n    }\n    return res;\n  }\n\n  constexpr modular operator + (const modular &rhs) const { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) { \n    if ((value += rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator - (const modular &rhs) const { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) { \n    if ((value += mod - rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator * (const modular &rhs) const { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) { \n    value = (max_type) value * rhs.value % mod;\n    return *this;\n  }\n\n  constexpr modular operator / (const modular &rhs) const { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) { return (*this) *= rhs.inverse(); }\n\n  constexpr bool zero() const { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const { return value != rhs.value; }\n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) {\n    return stream << rhs.value;\n  }\n\n};\n\nusing modint = modular<1000000007>;\n\nint main() {\n  int N, H, D;\n  std::cin >> N >> H >> D;\n  std::vector<modint> dp(H);\n  modint coeff, fact(1);\n  for (int i: range(1, N + 1)) {\n    fact *= modint(i);\n    coeff += fact;\n  }\n  std::fill(dp.begin(), dp.begin() + D, fact);\n  modint sum;\n  for (int i: range(1, H)) {\n    sum += dp[i - 1];\n    if (i - D - 1 >= 0) {\n      sum -= dp[i - D - 1];\n    }\n    dp[i] += sum * coeff;\n  }\n  std::cout << dp.back() << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <ctime>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <assert.h>\n#include <iomanip>\n#include <bitset>\nusing namespace std;\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define all(x) x.begin(),x.end()\n#define SZ(x) (int)(x.size())\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,a,b) for(int i=b-1;i>=a;i--)\n#define inf 1000000007\n#define mod 1000000007\n#define x first\n#define y second\n#define pi acos(-1.0)\n#define DBG(x) cerr<<(#x)<<\"=\"<<x<<\"\\n\";\n\n#define FOREACH(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define ull unsigned long long\n#define ll long long\n#define N 1000005\n\ntemplate <class T,class U>inline void Max(T &a,U b){if(a<b)a=b;}\ntemplate <class T,class U>inline void Min(T &a,U b){if(a>b)a=b;}\n\n//FILE* outFile;\n\ninline void add(int &a,int b){a+=b;while(a>=mod)a-=mod;}\ninline int gcd(int a, int b){if(b == 0)return a; return gcd(b, a%b);}\nint pow(int a,int b){\n    int ans=1;\n    while(b){\n        if(b&1)ans=ans*(ll)a%mod;\n        a=(ll)a*a%mod;b>>=1;\n    }\n    return ans;\n}\n\nint dp[N];\nint main(){\n    int j,k,i,T,ca=0, m = 0, K = 0, n;\n    int H, D;\n    scanf(\"%d%d%d\", &n, &H, &D);\n    K = 1;\n    ll sum = 0;\n    rep(i, 1, n+1){\n        K = 1LL * K * i % mod;\n        sum = (sum + K) % mod;\n    }\n    ll q = K;\n    dp[1] = q;\n    rep(i, 2, H+1){\n        K = dp[i-1];\n        if(i-1 > D){\n            K = (K - dp[i-1-D] + mod) % mod;\n        }\n        K = K * sum % mod;\n        if(i <= D){\n            K = (K + q) % mod;\n        }\n        dp[i] = (dp[i-1] + K) % mod;\n    } \n    printf(\"%d\\n\", K);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// queue を考えて, 同じ数字は入れるときに順番を決めて, 出てきた順に値を更新する\n#define mod 1000000007\n#define MAX_N 1000001 // = MAX_H\nll fact[MAX_N]; // iの階乗\nll fact_sum[MAX_N]; // i>0での累積和\n\n// 最大値がi個の時の場合の数\nll dp[MAX_N];\n\nint main() {\n    int N, H, D;\n    cin >> N >> H >> D;\n\n    // 階乗計算\n    fact[0]=1;\n    for(int i = 1; i < MAX_N; ++i) {\n        fact[i] = fact[i-1] * i % mod;\n        fact_sum[i] = (fact_sum[i-1] + fact[i]) % mod;\n    }\n\n    dp[0] = fact[N]; // 0をN個queueに入れる\n    ll sum = 0; // Dの幅でしゃくとり\n    for (int i = 1; i <= H; ++i) {\n        sum += dp[i-1]; // dp[i-D] から dp[i-1] まで\n        if(i > D) sum = sum + mod - dp[i-D-1];\n        sum %= mod;\n        dp[i] = sum * fact_sum[N] % mod; // i個の塔の個数が1からNまで\n    }\n    cout << sum;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst int P = 1e9 + 7;\nconst int maxn = 1e6 + 5;\nint n, d, h;\nll dp[maxn], sum[maxn];\nll power(ll x, ll t) {\n\tll ret = 1;\n\tfor(; t; t >>= 1, x = x * x % P) {\n\t\tif(t & 1) {\n\t\t\tret = ret * x % P;\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n\tcin >> n >> h >> d;\n\tll fac = 1, s = 0;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tfac = fac * i % P;\n\t\ts = (s + fac) % P;\n\t}\n\tdp[0] = sum[0] = 1;\n\tfor(int i = 1; i <= h; ++i) {\n\t\tdp[i] = (sum[i - 1] - (i - d - 1 >= 0 ? sum[i - d - 1] : 0) + P) % P;\n\t\tdp[i] = dp[i] * s % P;\n\t\tsum[i] = (sum[i - 1] + dp[i]) % P;\n\t}\n\tdp[h] = dp[h] * power(s, P - 2) % P * fac % P;\n\tcout << dp[h] << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(V) V.begin(),V.end()\nusing ll = long long;\nconst ll MOD = 1000000007;\n\nll fact[1000010], seg[2097152];\n\nvoid add(int s, int t, ll v, int k = 1, int l = 0, int r = 1048575) {\n\tif (t < l || r < s)return;\n\tif (s <= l && r <= t) {\n\t\tseg[k] += v;\n\t\tseg[k] %= MOD;\n\t\treturn;\n\t}\n\tadd(s, t, v, k * 2, l, (l + r) / 2);\n\tadd(s, t, v, k * 2 + 1, (l + r) / 2 + 1, r);\n}\n\nll gets(int x) {\n\tll ans = 0;\n\tx += 1048576;\n\twhile (x) {\n\t\tans += seg[x];\n\t\tx /= 2;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tfact[0] = 1;\n\tll fr = 0, N, H, D, V;\n\tfor (int i = 0;i < 2097152;i++)seg[i] = 0;\n\tcin >> N >> H >> D;\n\tfor (ll i = 1;i <= N;i++) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tfr += fact[i];fr %= MOD;\n\t}\n\tadd(0, 0, fact[N]);\n\tfor (int i = 0;i < H;i++) {\n\t\tV = gets(i) * fr % MOD;\n\t\tadd(i + 1, min(i + D, H), V);\n\t}\n\tV = 0;\n\tfor (int i = H - D;i < H;i++)V += gets(i), V %= MOD;\n\tcout << V << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=1000005,P=1e9+7;\nint n,H,D,f[N],fac[N],sum[N];\nint fpow(int k1,int k2){int k3=1;for(;k2;k2>>=1,k1=1LL*k1*k1%P)if(k2&1)k3=1LL*k3*k1%P;return k3;}\nint main(){\n\tfac[0]=1;rep(i,1,N-1)fac[i]=1LL*fac[i-1]*i%P;\n\tscanf(\"%d%d%d\",&n,&H,&D);\n\tf[0]=1,sum[0]=1;\n\tint c=0;\n\trep(i,1,n)(c+=fac[i])%=P;\n\trep(i,1,H){\n\t\tint num=sum[i-1];\n\t\tif(i-D>0)(num-=sum[i-D-1])%=P;\n\t\tf[i]=1LL*num*c%P;\n\t\tsum[i]=(sum[i-1]+f[i])%P;\n\t}\n\tf[H]=1LL*f[H]*fac[n]%P*fpow(c,P-2)%P;\n\tprintf(\"%d\\n\",(f[H]+P)%P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);i--)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\n\n#include <cstdint>\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\n  u64 a;\n\npublic:\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 val() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr bool operator==(const modint rhs) const noexcept {\n    return modint(*this).value() == rhs.value();\n  }\n  modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\nusing mint = modint<MOD>;\n\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,d,h;\n  cin >> n >> h >> d;\n\n  vec fact(n+1,1);\n  REP(i,n+1) fact[i+1] = fact[i]*(i+1);\n\n  mat dp(h+10,vec(n+10,0));\n  dp[0][n] = 1;\n\n  REP(i,h+1){\n    REP(j,n+1){\n      if(j != n) dp[i][j+1] += dp[i][j]*(j+1);\n      FOR(k,i+1,min(i+d,h)+1){\n        dp[k][1] += dp[i][j];\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\ntypedef long long ll;\nusing namespace std;\n\nll dp[1000010], mod=1000000007;\n\nint main(void){\n    int N, H, D;\n    cin >> N >> H >> D;\n    ll mult=0;\n    dp[0]=1;\n    for(int i=1; i<=N; ++i){\n        (dp[0] *= i) %= mod;\n        (mult += dp[0]) %= mod;\n    }\n    ll sum=dp[0];\n    for(int i=1; i<H; ++i){\n        dp[i]=(sum*mult)%mod;\n        if(i>=D) (sum += mod-dp[i-D]) %= mod;\n        (sum += dp[i]) %= mod;\n    }\n    cout << sum << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define REP(i, n) FOR(i, 0, (n))\n#define FOR(i, a, b) for(int i=(a); i<(b); i++)\n#define LAR(a, b) ((a)=max((a),(b)))\n#define SML(a, b) ((a)=min((a),(b)))\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pair<int, int>> vpii;\ntypedef pair<int, int> pii;\n#define PB push_back\n#define EB emplace_back\n#ifdef LOCAL_DEBUG\n#define DEBUG(...) printf(__VA_ARGS__)\n#else\n#define DEBUG(...)\n#endif\n#define MOD 1'000'000'007\n\n#define N 2123456\nll a[N]={};\nll fct[N], fctsm[N];\n\nint main(){\n\tfct[0] = 1;\n\tFOR(i, 1, N) fct[i]=fct[i-1]*i%MOD;\n\tfctsm[0]=0;\n\tFOR(i, 1, N) fctsm[i]=(fctsm[i-1]+fct[i]) %MOD;\n\tint n, h, d; scanf(\"%d%d%d\", &n, &h, &d);\n\ta[h] = 1;\n\tll sm = 0;\n\tfor(int i = h-1; i >= 1; i--){\n\t\t// sm = a[i+1 ... i+d]\n\t\t// sm = 0;\n\t\t// for(int j=i+1; j<=i+d; j++) sm = (sm + a[j]) % MOD;\n\t\tsm = (sm + a[i+1] + (MOD-a[i+d+1])) % MOD;\n\t\ta[i] = fctsm[n] * sm % MOD;\n\t}\n\t// sm = a[1 ... d]\n\tsm = 0;\n\tfor(int j=1; j<=d; j++) sm = (sm + a[j]) % MOD;\n\ta[0] = fct[n] * sm % MOD;\n\tprintf(\"%lld\\n\", a[0]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int INF=1000000007;\nint f[1010101];\nint ksm(int w,int x)\n{\n\tint ans=1;\n\twhile(x)\n\t{\n\t\tif(x&1)\n\t\t\tans=(long long)ans*w%INF;\n\t\tx>>=1;\n\t\tw=(long long)w*w%INF;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tint n,h,d,w,all=0,i,now;\n\tscanf(\"%d%d%d\",&n,&h,&d);\n\tw=1;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tw=(long long)w*i%INF;\n\t\tall=(all+w)%INF;\n\t}\n\tf[0]=1;\n\tnow=1;\n\tfor(i=1;i<=h;i++)\n\t{\n\t\tif(i-d-1>=0)\n\t\t\tnow=(now-f[i-d-1]+INF)%INF;\n\t\tf[i]=(f[i]+(long long)all*now)%INF;\n\t\tnow=(now+f[i])%INF;\n\t}\n\tprintf(\"%d\\n\",(long long)f[h]*w%INF*ksm(all,INF-2)%INF);\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\n//constexpr ll mod = 998244353;\nconstexpr ll mod = 1e9+7;\nconst double PI = acos(-1.0);\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\nstruct mint {\n    ll x;\n    mint():x(0){}\n    mint(ll x):x((x%mod+mod)%mod){}\n    mint& fix() { x = (x%mod+mod)%mod; return *this;}\n    mint operator-() const { return mint(0) - *this;}\n    mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n    mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n    mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n    mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n    mint operator+(const mint& a)const{ return mint(*this) += a;}\n    mint operator-(const mint& a)const{ return mint(*this) -= a;}\n    mint operator*(const mint& a)const{ return mint(*this) *= a;}\n    mint operator/(const mint& a)const{ return mint(*this) /= a;}\n    bool operator<(const mint& a)const{ return x < a.x;}\n    bool operator==(const mint& a)const{ return x == a.x;}\n};\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\n\nmint mod_pow(mint a, ll x) {\n  mint res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\nint MAXN = 1000005;\n// factorial\nvector<mint> fact(MAXN+1);\nvoid init() {\n  fact[0] = 1;\n  for(int i=1; i<=MAXN; i++) fact[i] = fact[i-1]*i;\n}\n\n// nCr\nmint comb(int n, int r) {\n  if (n < r || n < 0 || r < 0) return 0;\n  return fact[n]/(fact[r]*fact[n-r]);\n}\n\n// Matrix library\n\n// return a * b where a and b are n * n matrix\nvector<mint> mat_mul(const vector<mint>& a, const vector<mint>& b, int n) {\n  vector<mint> ret(n*n);\n  rep(i, n) rep(j, n) rep(k, n) ret[i*n+j] += a[i*n+k]*b[k*n+j];\n  return ret;\n}\n\n// return identity matrix of size n * n\nvector<mint> id_mat(int n) {\n  vector<mint> ret(n*n);\n  rep(i, n) ret[i*n+i] = 1;\n  return ret;\n}\n\n// return a^x where a is n * n matrix\n// a is changed, so do not use &a\nvector<mint> mat_pow(vector<mint> a, ll x, int n) {\n  vector<mint> ret = id_mat(n);\n  while(x>0) {\n    if (x&1) ret = mat_mul(ret, a, n);\n    a = mat_mul(a, a, n); x>>=1;\n  }\n  return ret;\n}\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n  ll n, h, d; cin >> n >> h >> d;\n  init();\n  mint sum = 0;\n  for(int i=1; i<=n; i++) {\n    sum += fact[i];\n  }\n  debug(sum.x);\n\n  vector<mint> ansa(h);\n  vector<mint> ansb(h);\n  ansa[0] = fact[n];\n  ansb[0] = 0;\n  mint ksum = 0;\n  for(int i=1; i<h; i++) {\n    ansa[i] = (ansa[i-1]+ksum)*sum;\n    ansb[i] = ansa[i-1];\n    ksum += ansb[i];\n    if (i>=d) {\n      ksum -= ansb[i-d+1];\n    }\n  }\n  cout << ansa[h-1] + ksum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\ninline ll fastpow(ll bas, ll ex){\n\tregister ll res = 1; bas %= MOD;\n\tfor(; ex; ex >>= 1, bas = bas * bas % MOD) if(ex & 1) res = res * bas % MOD;\n\treturn res;\n}\n\ninline int kazu(int a, const int &b) {return (a += b) >= MOD ? a - MOD : a;}\ninline int hiku(int a, const int &b) {return (a -= b) < 0 ? a + MOD : a;}\n\nint N, H, D, fac[1000005] = {1}, sumfac = 0, isumfac, f[1000005], sumf;\n\nint main(){\n\tgetint(N), getint(H), getint(D);\n\tfor(register int i = 1; i <= N; i++) fac[i] = fac[i - 1] * (ll)i % MOD;\n\tfor(register int i = 1; i <= N; i++) sumfac = kazu(sumfac, fac[i]);\n\tisumfac = fastpow(sumfac, MOD - 2), sumf = f[0] = 1;\n\tfor(register int i = 1; i <= H; i++){\n\t\tif(i > D) sumf = hiku(sumf, f[i - D - 1]);\n\t\tf[i] = sumf * (ll)sumfac % MOD, sumf = kazu(sumf, f[i]);\n\t}\n\treturn printf(\"%lld\\n\", f[H] * (ll)fac[N] % MOD * isumfac % MOD), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nconst ll mod = 1e9 + 7;\n\nstruct BIT{\n    int n;\n    VL bit;\n\n    BIT(){}\n    BIT(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void init(int x){\n        n = x;\n        bit.assign(n+1, 0);\n    }\n\n    void add(int i, ll x){\n        x %= mod;\n        x = (x + mod) % mod;\n        i++;\n        while (i <= n){\n            (bit[i] += x) %= mod;\n            i += i & -i;\n        }\n    }\n\n    // [0, i]\n    ll sum(int i){\n        i++;\n        ll ret = 0;\n        while (i > 0){\n            (ret += bit[i]) %= mod;\n            i -= i & -i;\n        }\n        return ret;\n    }\n\n    // [l, r)\n    ll sum(int l, int r){\n        if (l >= r) return 0;\n        return (sum(r-1) - sum(l-1) + mod) % mod;\n    }\n};\n\nint main() {\n    ll n, h, d;\n    cin >> n >> h >> d;\n\n    VL fact(n + 1);\n    fact[0] = 1;\n    REP(i,n) fact[i + 1] = (fact[i] * (i + 1)) % mod;\n\n    ll s = 0;\n    FOR(i,1,n) s = (s + fact[i]) % mod;\n\n    VL dp(h + d + 1);\n    BIT bit(h + 2);\n    bit.add(1, fact[n]);\n    bit.add(d + 1, -fact[n]);\n    FOR(i,1,h-1){\n        ll p = bit.sum(i);\n        p = (p * s) % mod;\n        bit.add(i + 1, p);\n        bit.add(i + d + 1, -p);\n    }\n    cout << bit.sum(h) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e6 + 6, mod = 1e9 + 7;\nlong long dp[N];\n\nint main() {\n  int n, h, d;\n  long long sum = 0, fac = 1;\n  scanf(\"%d %d %d\", &n, &h, &d);\n  for (int i = 1; i <= n; ++i) {\n    fac = fac * i % mod;\n    sum = (sum + fac) % mod;\n  }\n  dp[0] = fac;\n  long long cur = fac;\n  for (int i = 1; i < h; ++i) {\n    dp[i] = sum * cur % mod;\n    cur = (cur + dp[i]) % mod;\n    if (i >= d)\n      cur = (cur + mod - dp[i-d]) % mod;\n  }\n  cur %= mod;\n  if (cur < 0)\n    cur += mod;\n  printf(\"%lld\\n\", cur);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7,N=1e6+5;\nll n,h,d,f[N],dp[N],s;\nint main()\n{\n    scanf(\"%lld%lld%lld\",&n,&h,&d);\n    f[0]=1;\n    for(int i=1;i<=n;i++)\n        f[i]=f[i-1]*i%mod,s=(s+f[i])%mod;\n    dp[1]=1;\n    for(int i=2;i<=h;i++)\n        dp[i]=(dp[i-1]+(dp[i-1]-dp[max(0ll,i-d-1)])*s)%mod;\n    printf(\"%lld\\n\",((dp[h]-dp[h-d])*f[n]%mod+mod)%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(V) V.begin(),V.end()\nusing ll = long long;\nconst ll MOD = 1000000007;\n\nll fact[1000010], seg[2097152];\n\nvoid add(int s, int t, ll v, int k = 1, int l = 0, int r = 1048575) {\n\tif (t < l || r < s)return;\n\tif (s <= l && r <= t) {\n\t\tseg[k] += v;\n\t\tseg[k] %= MOD;\n\t\treturn;\n\t}\n\tadd(s, t, v, k * 2, l, (l + r) / 2);\n\tadd(s, t, v, k * 2 + 1, (l + r) / 2 + 1, r);\n}\n\nll gets(int x) {\n\tll ans = 0;\n\tx += 1048576;\n\twhile (x) {\n\t\tans += seg[x];\n\t\tans %= MOD;\n\t\tx /= 2;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tfact[0] = 1;\n\tll fr = 0, N, H, D, V;\n\tfor (int i = 0;i < 2097152;i++)seg[i] = 0;\n\tcin >> N >> H >> D;\n\tfor (ll i = 1;i <= N;i++) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tfr += fact[i];fr %= MOD;\n\t}\n\tadd(0, 0, fact[N]);\n\tfor (int i = 0;i < H;i++) {\n\t\tV = gets(i) * fr % MOD;\n\t\tadd(i + 1, min(i + D, H), V);\n\t}\n\tV = 0;\n\tfor (int i = H - D;i < H;i++)V += gets(i), V %= MOD;\n\tcout << V << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007; // 998244353\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nvoid solve() {\n    int n, h, d;\n    cin >> n >> h >> d;\n    int _n = n;\n    vector<mint> fac(_n+1);\n    vector<mint> ifac(_n+1);\n    vector<mint> inv(_n+1);\n    auto build = [&](){\n        fac[0] = fac[1] = 1;\n        ifac[1] = 1;\n        inv[1] = 1;\n        for (int i = 2; i <= _n; i++) {\n            fac[i] = fac[i-1] * i;\n            inv[i] = (-MOD/i) * inv[MOD%i];\n            ifac[i] = ifac[i-1] * inv[i];\n        }\n    };\n    build();\n    mint row = 0;\n    for (int i = 1; i <= n; i++) {\n        row += fac[i];\n    }\n    vector<mint> dp(h+1);\n    dp[0] = fac[n];\n    mint pre = dp[0];\n    for (int i = 1; i < h; i++) {\n        dp[i] = pre * row;\n        pre += dp[i];\n        if (i >= d) pre -= dp[i-d];\n    }\n    dp[h] = pre;\n    cout << dp[h];\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\n#include<functional>\ntemplate<typename T>\nstruct lazysegtree{\n\tfunction<T(T,T)>calcfn,lazycalcfn;\n\tfunction<T(T,T,unsigned int)>updatefn;\n\tint n;\n\tT defvalue,lazydefvalue;\n\tvector<T>dat,lazy;\n\tvector<bool>lazyflag;\n\tlazysegtree(int n_=0,T defvalue_=0,\n\t\tfunction<T(T,T)>calcfn_=[](T a,T b){return a+b;},\n\t\tfunction<T(T,T)>lazycalcfn_=[](T a,T b){return a+b;},\n\t\tfunction<T(T,T,unsigned int)>updatefn_=[](T a,T b,unsigned int width){return a+b*width;},\n\t\tT lazydefvalue_=0\n\t):defvalue(defvalue_),lazydefvalue(lazydefvalue_),\n\t\tcalcfn(calcfn_),lazycalcfn(lazycalcfn_),updatefn(updatefn_)\n\t{\n\t\tn=1;\n\t\twhile(n<n_)n<<=1;\n\t\tdat.assign(2*n-1,defvalue);\n\t\tlazy.assign(2*n-1,lazydefvalue);\n\t\tlazyflag.assign(2*n-1,false);\n\t}\n\tvoid copy(const vector<T>&v)\n\t{\n\t\tfor(int i=0;i<v.size();i++)dat[i+n-1]=v[i];\n\t\tfor(int i=n-2;i>=0;i--)dat[i]=calcfn(dat[2*i+1],dat[2*i+2]);\n\t}\n\tvoid eval(int i,int l,int r)\n\t{\n\t\tif(lazyflag[i])\n\t\t{\n\t\t\tdat[i]=updatefn(dat[i],lazy[i],r-l);\n\t\t\tif(r-l>1)\n\t\t\t{\n\t\t\t\tlazy[2*i+1]=lazycalcfn(lazy[2*i+1],lazy[i]);\n\t\t\t\tlazy[2*i+2]=lazycalcfn(lazy[2*i+2],lazy[i]);\n\t\t\t\tlazyflag[2*i+1]=lazyflag[2*i+2]=true;\n\t\t\t}\n\t\t\tlazy[i]=lazydefvalue;\n\t\t\tlazyflag[i]=false;\n\t\t}\n\t}\n\tvoid update(int a,int b,T x,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return;\n\t\telse if(a<=l&&r<=b)\n\t\t{\n\t\t\tlazy[k]=lazycalcfn(lazy[k],x);\n\t\t\tlazyflag[k]=true;\n\t\t\teval(k,l,r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(a,b,x,2*k+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,2*k+2,(l+r)/2,r);\n\t\t\tdat[k]=calcfn(dat[2*k+1],dat[2*k+2]);\n\t\t}\n\t}\n\tT query(int a,int b,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return defvalue;\n\t\telse if(a<=l&&r<=b)return dat[k];\n\t\telse return calcfn(\n\t\t\tquery(a,b,2*k+1,l,(l+r)/2),\n\t\t\tquery(a,b,2*k+2,(l+r)/2,r)\n\t\t);\n\t}\n};\nlong N,H,D,mod=1e9+7;\nmain()\n{\n\tcin>>N>>H>>D;\n\tlazysegtree<long>P(H,0,\n\t[](long a,long b){return (a+b)%mod;},\n\t[](long a,long b){return (a+b)%mod;},\n\t[](long a,long b,unsigned int w){return (a+b*w)%mod;});\n\tlong s=0,p=1;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tp=p*i%mod;\n\t\ts=(s+p)%mod;\n\t}\n\tP.update(0,D,p);\n\tfor(int i=0;i<H;i++)\n\t{\n\t\tP.update(i+1,i+D+1,P.query(i,i+1)*s%mod);\n\t}\n\tcout<<P.query(H-1,H)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\n\ntemplate <typename T>\nstruct BIT\n{\n    int n;\n    vector<T> bit;\n    \n    BIT(){}\n    \n    BIT(int n) : n(n){\n        bit.resize(n + 1);\n    }\n    \n    T sum(int i){\n        i++;\n        T res = 0;\n        while(i){\n            res += bit[i];\n            i -= (i & -i);\n        }\n        return res;\n    }\n    \n    void add(int i, T x){\n        i++;\n        while(i <= n){\n            bit[i] += x;\n            i += (i & -i);\n        }\n    }\n};\n\nll dp[1000005];\n\nint main()\n{\n    ll n, h, d;\n    cin >> n >> h >> d;\n    ll f = 1;\n    ll s = 0;\n    for(ll i = 1; i <= n; i++){\n        f = f * i % MOD;\n        s = (s + f) % MOD;\n    }\n    BIT<ll> bit(h + 2);\n    dp[0] = 1;\n    for(int i = 1; i <= h; i++){\n        dp[i] = (bit.sum(i - 1) - bit.sum(max(0ll, i - d - 1))) % MOD * s % MOD;\n        if(i - d <= 0) dp[i] = (dp[i] + f) % MOD;\n        bit.add(i, dp[i]);\n    }\n    cout << dp[h] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <cstdint>\n#include <iomanip>\n#include <climits>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nconst ll INFL = 1LL << 60;//10^18 = 2^60\nll MOD = 1000000007;\n//ll MOD = 998244353;\n//ll MOD = 924844033;\nstruct mint{\n  ll x;\n  mint(ll x=0):x(x % MOD){}\n  mint& operator+=(const mint a){\n    (x += a.x) %= MOD;\n    return *this;\n  }\n  mint& operator-=(const mint a){\n    (x += MOD-a.x) %= MOD;\n    return *this;\n  }\n  mint& operator*=(const mint a){\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint& operator%=(const mint a){\n    (x %= a.x);\n    return *this;\n  }\n  mint& operator++ (int){\n    (x += 1) %= MOD;\n    return *this;\n  }\n  mint& operator-- (int){\n    (x += MOD-1) %= MOD;\n    return *this;\n  }\n  mint operator+(const mint a) const{\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const{\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const{\n    mint res(*this);\n    return res*=a;\n  }\n  mint operator%(const mint a) const{\n    mint res(*this);\n    return res%=a;\n  }\n  mint po(ll t) const{\n    if(!t) return 1;\n    mint a = po(t>>1);\n    a *= a;\n    if(t&1) a *= *this;\n    return a;\n  }\n  mint inverse() const{\n    return po(MOD-2);\n  }\n  mint& operator/=(const mint a){\n    return (*this) *= a.inverse();\n  }\n  mint operator/(const mint a) const{\n    mint res(*this);\n    return res/=a;\n  }\n  bool operator == (const mint a){\n    return this->x == a.x;\n  }\n  bool operator != (const mint a){\n    return this->x != a.x;\n  }\n  void get(){\n    cout << x << endl;\n  }\n  void ge(){\n    cout << x << \" \";\n  }\n};const mint Mint = 0;\n\n\nmint pow_mod(ll x, ll k){\n  mint res = 1;\n  mint a = x;\n  while(k > 0){\n    if(k % 2){\n      res *= a;\n    }\n    a *= a;\n    k /= 2;\n  }\n  return res;\n}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x;\n    k /= 2;\n  }\n  return res;\n}\n\nmint inverse(ll x){return pow_mod(x, MOD-2);}\n\n//二項演算\nconst int MAXcomb = 200010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nmint comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    mint res = fac[n];\n    res *= finv[k] * finv[n-k];\n    return res;\n}\n\nmint comb_naive(ll N, ll K){//Kが小さい時\n  mint res = 1;\n  rep(i, K) res *= (N-i) % MOD;\n  mint k = 1;\n\n  rep(i, K) k *= (i+1);\n  res /= k;\n  return res;\n}\n\n//約数の列挙O(√n)\nvector<ll> divisor(ll n){\n    vector<ll> res(0);\n    for(ll i = 1; i * i <= n; i++){\n        if(n % i == 0){\n            res.push_back(i);\n            if(i != n/i) res.push_back(n/i);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n\nll disit(ll x, ll d = 10){\n  ll res = 0;\n  while(x){\n    res++;\n    x /= d;\n  }\n  return res;\n}\n\nmint dp[1000010];\nmint sum[1000010];\n\nvoid solve(){\n  ll N, H, D;\n  cin >> N >> H >> D;\n  mint kai = 1, kaiSum = 0;\n  for(ll i = 1; i <= N; i++){\n    kai *= i;\n    kaiSum += kai;\n  }\n  sum[0] = kai;\n  for(ll i = 1; i <= H; i++){\n    mint w = kaiSum;\n    if(i == H) w = 1;\n    mint add;\n    if(i-D-1 >= 0) add = sum[i-1] - sum[i-D-1];\n    else add = sum[i-1];\n    dp[i] = w * add;\n    sum[i] = sum[i-1] + dp[i];\n  }\n  dp[H].get();\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\nusing namespace std;\nusing cd = complex <double>;\n \ntypedef pair <int, int> pii;\n \nconst int Inf = 1000000;\nconst int mod = 1000000007;\nconst double Pi = acos(-1);\n \nvoid Fastio()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n}\n\nint n, h, d;\nlong long r = 0, f = 1;\nlong long dp[1000005], psum[1000005];\n\nsigned main()\n{\n\tFastio();\n\tcin >> n >> h >> d;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tf = f * i % mod;\n\t\tr += f;\n\t\tr %= mod;\n\t}\n\tfor(int i = 1; i <= h; i++)\n\t{\n\t\tint temp;\n\t\tif(0 > i - d - 1)\n\t\t{\n\t\t\ttemp = psum[i - 1];\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttemp = psum[i - 1] - psum[i - d - 1];\n\t\t}\n\t\ttemp = (temp % mod + mod) % mod;\n\t\ttemp = temp * r % mod;\n\t\tif(i <= d)\n\t\t{\n\t\t\ttemp += f;\n\t\t}\n\t\tdp[i] = temp % mod;\n\t\tpsum[i] = (psum[i - 1] + dp[i]) % mod;\n\t}\n\tcout << dp[h] % mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid out(T x) { cout << x << endl; exit(0); }\n#define watch(x) cout << (#x) << \" is \" << (x) << endl\n\n\n\n\n\nusing ll = long long;\n\nconst ll mod = 1e9+7;\nconst int maxn = 1e6 + 5;\n\n\n\nll n, h, d;\nll dp[maxn];\nll acc[maxn];\n\nll fac[maxn];\nll facSum;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);  cout.tie(0);\n    cin>>n>>h>>d;\n    fac[0]=1;\n    for (int i=1; i<=n; i++) {\n\tfac[i]=1ll*i*fac[i-1]%mod;\n\tfacSum += fac[i];\n\tfacSum %= mod;\n    }\n\n\n    dp[0] = fac[n];\n    acc[0] = dp[0];\n    for (ll i=1; i<=h; i++) {\n\tdp[i] += acc[i-1];\n\tif (i-1-d>=0) {\n\t    dp[i] += (mod-acc[i-1-d]);\n\t}\n\tdp[i] %= mod;\n\tif (i<h) {\n\t    dp[i] *= facSum;\n\t    dp[i] %= mod;\n\t}\n\tacc[i]=(acc[i-1]+dp[i])%mod;\n    }\n\n\n    cout<<dp[h]<<endl;    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <queue>\n#include <fstream>\n#include <string>\n#include <math.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<char, ll> P;\n//typedef pair<ll, P> T;\n\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define revrep(i, n) for (ll i = (n) - 1; i >= 0; i--)\n#define f first\n#define s second\n#define pb push_back\n\nconst ll mod = 1000000007;\nconst ll INF = 100000000000010000;\n\nll bit[1000010];\nint kai[1000010];\n\n//void pres(double A, ll x = 20) { printf(\"%.20f\\n\", x); }\n\nll sum(ll i)\n{\n\ti += 1;\n\tll t = 0;\n\twhile (i > 0)\n\t{\n\t\t(t += bit[i]) %= mod;\n\t\ti -= i & -i;\n\t}\n\treturn t;\n}\n\nvoid add(ll i, ll x)\n{\n\ti += 1;\n\twhile (i <= 1000005)\n\t{\n\t\t(bit[i] += x) %= mod;\n\t\ti += i & -i;\n\t}\n}\n\nvoid test() {\n\tcout << \"888888888888888888888888\" << endl;\n}\n\nll gcd(ll x, ll y) {\n\tif (y == 0) return x;\n\treturn gcd(y, x % y);\n}\n\nll pow_mod(ll x, ll y) {\n\tif (y == 0) return 1;\n\tif (y % 2 == 1) {\n\t\treturn x * pow_mod(x, y - 1) % mod;\n\t}\n\telse {\n\t\tll half = pow_mod(x, y / 2);\n\t\treturn half * half % mod;\n\t}\n}\n\nll div_mod(ll x) {\n\treturn pow_mod(x, mod - 2);\n}\n\nll com(ll x, ll y) {\n\treturn kai[x] * div_mod(kai[y] * kai[x - y] % mod) % mod;\n\t//毎回オーダーlog(n)かかる\n}\n\nvoid kaijo() {\n\tkai[0] = 1;\n\tfor (ll i = 1; i <= 1000005; i++) {\n\t\tkai[i] = kai[i - 1] * i % mod;\n\t}\n}\n\nll N, H, D;\nll ans;\n\nvoid solve() {\n\tcin >> N >> H >> D;\n\tkaijo();\n\tll nu = 0;\n\trep(i, N) {\n\t\t(nu += kai[i + 1]) %= mod;\n\t}\n\n\tadd(0, kai[N]);\n\tfor (int i = 1; i <= H; i++) {\n\t\tll num;\n\t\tif (i > D) {\n\t\t\tnum = nu * (mod + sum(i) - sum(i - D - 1)) % mod;\n\t\t}\n\t\telse {\n\t\t\tnum = sum(i) * nu % mod;\n\t\t}\n\n\t\tif (i == H) {\n\t\t\tif (i > D) {\n\t\t\t\tans = (mod + sum(i) - sum(i - D - 1)) % mod;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans = sum(i);\n\t\t\t}\n\t\t}\n\t\tadd(i, num);\n\t}\n\n\tcout << ans << endl;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\tll N;\n\tcin >> N;\n}\n////////////////////////////////////////////////////////////////////////////////////////////jagfhaoi;sd;joi;asdfjzasdi;lfjoi;ernjsdoivcnoizvdfnvdfnon/////////////////////////////////////////////////////////\n////////////////////jgoiadhsjgoi;vsjvgfonhjasoivhoivhno"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\nconstexpr ll MAX=1e6;\nconstexpr ll INF=(1ll<<62);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\nstruct Segment_tree{\n    ll N;\n    vector<pii> node;\n    Segment_tree(ll sz){\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mp(INF,INF));\n        per(i,N-2,0){\n            node[i]=std::min(node[i*2+1],node[i*2+1]);\n        }\n    }\n    void update(ll X,pii val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=std::min(node[X*2+1],node[X*2+2]);\n        }\n    }\n    pii RMQ(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mp(INF,INF);\n        if(a<=l&&r<=b) return node[now];\n        auto vl=RMQ(a,b,now*2+1,l,(l+r)/2),vr=RMQ(a,b,now*2+2,(l+r)/2,r);\n        return std::min(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N,H,D; cin>>N>>H>>D;\n    ll memo=1,sum=0;\n    REP(i,1,N){\n        memo*=i;\n        memo%=MOD;\n        sum+=memo;\n        sum%=MOD;\n    }\n    vi dp(H+1);\n    dp[0]=memo%MOD;\n    ll sum2=dp[0];\n    rep(i,1,H){\n        dp[i]=sum2*sum%MOD;\n        sum2+=dp[i];\n        sum2%=MOD;\n        if(i>=D){\n            sum2-=dp[i-D];\n            sum2%=MOD;\n        }\n    }\n    cout<<sum2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iosfwd>\n#include <iomanip>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <vector>\n#include <bitset>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\n#include <deque>\n#include <string>\n#include <list>\n#include <iterator>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <algorithm>\n#include <assert.h>\n#include <unordered_map>\n\nusing namespace std;\nconst int N = 3e5 + 500;\nconst int LN = 21;\nconst long long mod = 1e9 + 7;\nconst long long INF = 1LL << 57;\n\nlong long n, m, u, v, k, t, q, a, h, x, d;\n\nlong long fact[N];\nlong long dp[N];\n\nint main() {\n   ios::sync_with_stdio(false);cin.tie(0);\n   cin >> n >> h >> d;\n   \n   fact[0] = 1;\n   long long sum = 0;\n   for (int i = 1; i <= n; ++i) {\n      fact[i] = 1LL * i * fact[i - 1];\n      fact[i] %= mod;\n      sum += fact[i];\n      if (sum >= mod) sum -= mod;\n   }\n   \n   dp[0] = fact[n];\n   for (int i = 1; i <= h - 1; ++i) {\n      long long cur = dp[i - 1];\n      if (i - d - 1>= 0) cur -= dp[i - d - 1];\n      if (cur < 0) cur += mod;\n      dp[i] = (sum * cur) % mod;\n      dp[i] += dp[i - 1];\n      if (dp[i] >= mod) dp[i] -= mod;\n   }\n   \n   long long cur = dp[h - 1];\n   if (h - d - 1 >= 0) cur -= dp[h - d - 1];\n   if (cur < 0) cur += mod;\n   cout << cur << endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = (ll)1e9 + 7;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = (int)1e6 + 7;\nll S;\nint n, m, d;\nll dp[N];\nll pref[N];\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d%d\", &m, &n, &d);\n\tll F = 1;\n\tfor (int i = 1; i <= m; i++) {\n\t\tF = mult(F, i);\n\t\tS = add(S, F);\n\t}\n\t//cerr << S << endl;\n\tdp[0] = F;\n\tpref[1] = F;\n\tfor (int i = 1; i <= n; i++) {\n\t\tdp[i] = sub(pref[i], pref[max(0, i - d)]);\n\t\t//cerr << dp[i] << \" \";\n\t\tpref[i + 1] = add(pref[i], mult(S, dp[i]));\n\t}\n\tprintf(\"%lld\\n\", dp[n]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int BASE = 1e9 + 7;\nconst int N = 1e6;\n\nlong long fact[N + 5], invFact[N + 5], f[N + 5];\n\nlong long power(long long x, long long y)\n{\n  if (!y)\n    return 1;\n  long long res = power(x, y >> 1);\n  res = res * res % BASE;\n  if (y & 1)\n    res = res * x % BASE;\n  return res;\n}\n\nint main()\n{\n  int n, h, d;\n  cin >> n >> h >> d;\n\n  fact[0] = 1;\n  for (int i = 1; i <= N; i++)\n    fact[i] = fact[i - 1] * i % BASE;\n  for (int i = 0; i <= N; i++)\n    invFact[i] = power(fact[i], BASE - 2);\n\n  long long sumFact = 0;\n  for (int i = 1; i <= n; i++)\n    sumFact = (sumFact + fact[i]) % BASE;\n\n\n  f[0] = 1;\n  long long curSum = 1;\n  for (int i = 1, j = 0; i <= h; i++)\n  {\n    while (i - j > d)\n      curSum = (curSum - f[j++] + BASE) % BASE;\n    f[i] = curSum * sumFact % BASE;\n    curSum = (curSum + f[i]) % BASE;\n  }\n\n  cout << f[h] * fact[n] % BASE * power(sumFact, BASE - 2) % BASE << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/diverta2019-2/tasks/diverta2019_2_f\n/*<head>*/\n// #include \"Template.hpp\"\n/*</head>*/\n\n/*<body>*/\n/* #region header */\n/* #region 1*/\n/**\n * @file Template.hpp\n * @brief 競技プログラミング用テンプレート\n * @author btk15049\n * @date 2019/05/02\n */\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* #region macro */\n#ifdef BTK\n#    define DEBUG if (1)\n#    define CIN_ONLY if (0)\n#else\n#    define DEBUG if (0)\n#    define CIN_ONLY if (1)\n#endif\n/** @def\n * ALLマクロ\n */\n#define ALL(v) (v).begin(), (v).end()\n\n/** @def\n * 再帰ラムダをするためのマクロ\n */\n#define REC(ret, ...) std::function<ret(__VA_ARGS__)>\n/* #endregion */\n\nnamespace _Template_ {\n    /**\n     * @brief cin高速化処理を行うための構造体\n     * @details CIN_ONLYマクロで動作が変わる\n     */\n    struct cww {\n        cww() {\n            CIN_ONLY {\n                ios::sync_with_stdio(false);\n                cin.tie(0);\n            }\n        }\n    } star;\n    /**\n     * @brief change min\n     * @tparam T 型\n     * @param l 参照\n     * @param r 非参照\n     * @return 更新があればtrue\n     */\n    template <typename T>\n    inline bool chmin(T& l, T r) {\n        bool a = l > r;\n        if (a) l = r;\n        return a;\n    }\n    /**\n     * @brief chminのmax版\n     * @see chmin\n     */\n    template <typename T>\n    inline bool chmax(T& l, T r) {\n        bool a = l < r;\n        if (a) l = r;\n        return a;\n    }\n    /**\n     * @brief\n     * vectorに直接cin流すためのやつ\n     * @tparam T\n     * @param is\n     * @param v\n     * @return istream&\n     */\n    template <typename T>\n    istream& operator>>(istream& is, vector<T>& v) {\n        for (auto& it : v) is >> it;\n        return is;\n    }\n    /**\n     * @brief\n     * rangeを逆向きに操作したいとき用\n     * @details\n     * ループの範囲は[bg,ed)なので注意\n     * @see range\n     */\n    class reverse_range {\n      private:\n        struct I {\n            int x;\n            int operator*() { return x - 1; }\n            bool operator!=(I& lhs) { return x > lhs.x; }\n            void operator++() { --x; }\n        };\n        I i, n;\n\n      public:\n        reverse_range(int n) : i({0}), n({n}) {}\n        reverse_range(int i, int n) : i({i}), n({n}) {}\n        I& begin() { return n; }\n        I& end() { return i; }\n    };\n    /**\n     * @brief\n     * python みたいな range-based for を実現\n     * @details\n     * ループの範囲は[bg,ed)なので注意\n     * !つけると逆向きにループが回る (reverse_range)\n     * 空間計算量はO(1)\n     * 使わない変数ができて警告が出がちなので，unused_varとかを使って警告消しするとよい\n     */\n    class range {\n      private:\n        struct I {\n            int x;\n            int operator*() { return x; }\n            bool operator!=(I& lhs) { return x < lhs.x; }\n            void operator++() { ++x; }\n        };\n        I i, n;\n\n      public:\n        range(int n) : i({0}), n({n}) {}\n        range(int i, int n) : i({i}), n({n}) {}\n        I& begin() { return i; }\n        I& end() { return n; }\n        reverse_range operator!() { return reverse_range(*i, *n); }\n    };\n    /**\n     * @brief\n     * rangeで生まれる使わない変数を消す用（警告消し）\n     */\n    template <typename T>\n    inline T& unused_var(T& v) {\n        return v;\n    }\n    using LL = long long;\n} // namespace _Template_\nusing namespace _Template_;\n/* #endregion */\n/* #endregion */\n/*</body>*/\n\nnamespace xorshift{\n    unsigned yy=114510011;\n    inline unsigned rand(){yy=yy^(yy<<13);yy=yy^(yy>>17);return yy=yy^(yy<<5);}\n    inline unsigned randInt(){return rand();}\n}\n\nLL w[11][11];\nunordered_map<LL,int> cnt;\nconstexpr long long mask = 1e12;\nint main() { \n    int N;\n    cin>>N;\n    for(int i:range(N)){\n        for(int j:range(i)){\n            w[i][j]=w[j][i]=xorshift::randInt()*1ll*xorshift::randInt()%mask;\n        }\n    }\n    vector<int> o(N);\n    iota(ALL(o),0);\n    int ans = 0;\n    int c=0;\n    do{\n        int k=0;\n        for(int i:range(N-1)){\n           k+=w[o[i]][o[i+1]];\n        }\n        cnt[k]++;\n        chmax(ans,cnt[k]);\n        if(cnt[k]>2)c++;\n    }while(next_permutation(ALL(o)));\n    cout<<ans<<endl;\n    cout<<c<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Δ_E\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 1e6+16;\nconst int MO = 1e9+7;\nint mul(int x,int y){\n\treturn (LL)x*y%MO;\n}\nint n,m,d,p,fac[N],f[N];\nint main()\n{\n\tint i,o;\n\tcin>>n>>m>>d;\n\tfac[0]=1;\n\tfor(i=1;i<=n;i=i+1)\n\t\tfac[i]=mul(fac[i-1],i);\n\tfor(i=1;i<=n;i=i+1)\n\t\tp=(p+fac[i])%MO;\n\tf[0]=1;\n\to=1;\n\tfor(i=1;i<m;i=i+1){\n\t\tf[i]=mul(o,p);\n\t\to=(o+f[i])%MO;\n\t\tif(i>=d)\n\t\t\to=(o-f[i-d]+MO)%MO;\n\t}\n\tcout<<mul(o,fac[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#ifdef NON_SUBMIT\n#define TEST(n) (n)\n#define tout cerr\n#else\n#define TEST(n) ((void)0)\n#define tout cin\n#endif\n \nusing namespace std;\n\nconst int MOD=1e9+7;\nint D[1000001];\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL); cout.tie(NULL);\n\tTEST(freopen(\"input.txt\",\"r\",stdin));\n\tTEST(freopen(\"output.txt\",\"w\",stdout));\n\tTEST(freopen(\"debug.txt\",\"w\",stderr));\n\tint N, H, P, t=1, m=1;\n\tcin>>N>>H>>P;\n\tfor(int i=2;i<=N;i++) m=(m+(t=(1LL*t*i)%MOD))%MOD;\n\tD[0]=t;\n\tfor(int i=1;i<=P;i++) D[i]=(1LL*(m+1)*D[i-1])%MOD;\n\tfor(int i=P+1;i<H;i++) D[i]=(1LL*m*(MOD+D[i-1]-D[i-P-1])+D[i-1])%MOD;\n\tcout<<(MOD+D[H-1]-D[H-P-1])%MOD<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\nll dp[2000010],mod = 1000000007;\nint main(){\n    long long i,n,h,d;\n    cin >> n >> h >> d;\n    ll x = 1,y = 0;\n    for(i=1;i<=n;i++){\n        (x *= i) %= mod;\n        (y += x) %= mod;\n    }\n    dp[0] = n;\n    for(i=0;i<=h;i++){\n        if(i==0){\n            (dp[i + 1] += dp[i]) %= mod;\n            (dp[i + d + 1] += mod - dp[i]) %= mod;\n        }else{\n            (dp[i + 1] += dp[i]) %= mod;\n            (dp[i + 1] += y*dp[i]%mod) %= mod;\n            (dp[i + d + 1] += (mod - y*dp[i]%mod)) %= mod;\n        }\n    }\n    cout << dp[h] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define mod 1000000007\n#define Mod1(x) (x>=mod?x-mod:x)\n#define Mod2(x) (x<0?x+mod:x)\n#define maxn 1000010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic char buf[20],len; len=0;\n\tif(x<0)x=-x,putchar('-');\n\tfor(;x;x/=10)buf[len++]=x%10+'0';\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]);\n}\ninline void writesp(ll x){write(x); putchar(' ');}\ninline void writeln(ll x){write(x); putchar('\\n');}\nll f[maxn];\nint n,d,h;\ninline ll power(ll a,ll b)\n{\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ans=ans*a%mod;\n\treturn ans;\n}\nint main()\n{\n\tn=read(); h=read(); d=read();\n\tll val=0,fac=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfac=fac*i%mod;\n\t\tval=Mod1(val+fac);\n\t}\n\tf[0]=1;\n\tll cur=1;\n\tfor(int i=1;i<=h;i++){\n\t\tf[i]=cur*val%mod;\n\t\tcur=Mod1(cur+f[i]);\n\t\tif(i>=d)cur=Mod2(cur-f[i-d]);\n\t}\n\twriteln(f[h]*power(val,mod-2)%mod*fac%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#undef NDEBUG\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(v) (v).begin(), (v).end()\n\nusing li = long long;\nusing ld = long double;\n\nvoid solve(bool);\n\nint main() {\n#ifdef YA\n    auto s = clock();\n    assert(freopen(\"input.txt\", \"r\", stdin));\n    // assert(freopen(\"output.txt\", \"w\", stdout));\n#else\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n#endif\n\n    cout << fixed << setprecision(20);\n\n    solve(true);\n\n#ifdef YA1\n    while (true) solve(false);\n#endif\n\n#ifdef YA\n    cout << endl << endl << \"time = \" << (clock() - s) / (double)CLOCKS_PER_SEC << endl;\n#endif\n\n    return 0;\n}\n\n\nconst int mod = (int)1e9 + 7; \nconst int maxn = 1e6 + 55;\n\nli f[maxn], dp[maxn];\n\nli calc(int n, int h, int d) {\n    f[0] = 1;\n    li mult = 0;\n    for (int i = 1; i <= n; ++i) {\n        f[i] = f[i - 1] * (li)i % mod;\n        mult = (mult + f[i]) % mod;\n    }\n    dp[0] = f[n];\n    li s = dp[0];\n    for (int i = 1; i <= h; ++i) {\n        dp[i] = s * mult % mod;\n        if (i == h)\n            dp[i] = s;\n\n        s = (s + dp[i]) % mod;\n        if (i - d >= 0)\n            s = (s - dp[i - d] + mod) % mod;\n    }\n    return dp[h];\n}\n\nvoid solve(bool __attribute__((unused)) read) {\n    int n, h, d;\n    cin >> n >> h >> d;\n    cout << calc(n, h, d) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 1000005\n#define ll long long\n#define mod 1000000007\nint fac[N],f[N],s[N],n,H,D;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&H,&D);fac[0]=1;\n\tfor(int i=1;i<=n;i++)fac[i]=(ll)fac[i-1]*i%mod;\n\tint sum=0;\n\tfor(int i=1;i<=n;i++)(sum+=fac[i])%=mod;\n\tfor(int i=1;i<=H;i++)\n\t{\n\t\tif(i<=D)f[i]=(fac[n]+(ll)s[i-1]*sum)%mod;\n\t\telse f[i]=(ll)(s[i-1]-s[i-D-1])*sum%mod;\n\t\ts[i]=(s[i-1]+f[i])%mod;\n\t}\n\t// for(int i=1;i<=H;i++)f[i]=(ll)(s[i-1]-(i<=D?0:s[i-D-1]))*fac[n]%mod,s[i]=(s[i-1]+f[i])%mod;\n\tprintf(\"%d\\n\",(f[H]+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n#define fst first\n#define snd second\n\n/* clang-format off */\ntemplate <class T, size_t D> struct _vec { using type = vector<typename _vec<T, D - 1>::type>; };\ntemplate <class T> struct _vec<T, 0> { using type = T; };\ntemplate <class T, size_t D> using vec = typename _vec<T, D>::type;\ntemplate <class T> vector<T> make_v(size_t size, const T& init) { return vector<T>(size, init); }\ntemplate <class... Ts> auto make_v(size_t size, Ts... rest) { return vector<decltype(make_v(rest...))>(size, make_v(rest...)); }\ntemplate <class T> inline void chmin(T &a, const T& b) { if (b < a) a = b; }\ntemplate <class T> inline void chmax(T &a, const T& b) { if (b > a) a = b; }\n/* clang-format on */\n\ntemplate <std::uint_fast64_t Modulus>\nclass modint {\n  using u64 = std::uint_fast64_t;\n\n public:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept\n      : a((x % Modulus + Modulus) % Modulus) {\n  }\n  constexpr u64 &value() noexcept {\n    return a;\n  }\n  constexpr const u64 &value() const noexcept {\n    return a;\n  }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(const modint rhs) noexcept {\n    return *this *= ~rhs;\n  }\n  constexpr modint operator^(u64 exp) const noexcept {\n    modint v = 1, x = *this;\n    while (exp) {\n      if (exp & 1) {\n        v *= x;\n      }\n      x *= x;\n      exp >>= 1;\n    }\n    return v;\n  }\n  constexpr modint operator~() const noexcept {\n    u64 x = a, y = Modulus, u = 1, v = 0;\n    while (y) {\n      u64 t = x / y;\n      swap(x -= t * y, y);\n      swap(u -= t * v, v);\n    }\n    return u;\n  }\n};\n\nusing mint = modint<1000000007>;\n\ntemplate <class T>\nvector<T> sumup(const vector<T>& a) {\n  int N = a.size();\n  vector<T> res(N + 1);\n  for (int i = 0; i < N; i++) res[i + 1] = res[i] + a[i];\n  return res;\n}\n\nll solve(int N, int H, int D) {\n  mint f = 1, fsum = 0;\n  for (int i = 1; i <= N; i++) {\n    f *= i;\n    fsum += f;\n  }\n  vector<mint> dp(H + 1, mint(0)), sum(H + 2, mint(0));\n  for (int h = 1; h <= D; h++) dp[h] = 1;\n  for (int h = 1; h <= H; h++) {\n    dp[h] += fsum * (sum[h] - sum[max(0, h - D)]);\n    sum[h + 1] = sum[h] + dp[h];\n  }\n  mint res = dp[H] * f;\n  return res.value();\n}\n\nint main() {\n#ifdef DEBUG\n  ifstream ifs(\"in.txt\");\n  cin.rdbuf(ifs.rdbuf());\n#endif\n  int N, H, D;\n  while (cin >> N >> H >> D) {\n    cout << solve(N, H, D) << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2\")\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdarg>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define whlie while\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define inf 1001001001\n#define infLL ( (1LL << 61))\n#define MOD 1000000007\n#define FOR(i,a,b) for(int (i)=((int)a); (i)<((int)b); (i)++) // [a,b)\n#define rep(i,N) FOR((i), 0, ((int)N)) // [0,N)\n#define FORR(i,a,b) for(int (i)=((int)b) - 1; (i)>=((int)a); (i)--)\n#define repr(i,N) FORR((i), 0, ((int)N))\n#define all(v) (v).begin(),(v).end()\n#define rall(v) (v).rbegin(),(v).rend()\n#define sz(v) ((int)(v).size())\n#define vrep(v,it) for(auto it=v.begin();it!=v.end();it++)\n#define vrepr(v,it) for(auto it=v.rbegin();it!=v.rend();it++)\n#define inx(t,...) t __VA_ARGS__; in(__VA_ARGS__)\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) ll __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define ind(...) double __VA_ARGS__; in(__VA_ARGS__)\n#define inpii(...) pii __VA_ARGS__; in(__VA_ARGS__)\n#define invi(v,...) vi v; in(v,##__VA_ARGS__)\n#define invl(v,...) vl v; in(v,##__VA_ARGS__)\n#define mem(ar,val) memset((ar), (val), sizeof(ar) )\n#define mem0(ar) memset((ar),  0, sizeof(ar) )\n#define mem1(ar) memset((ar), -1, sizeof(ar) )\n\n#ifdef LOCAL\n    #define dbg(...) fprintf(stderr, __VA_ARGS__)\n    #define trc(...) do { cout << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n    #define stopif(val) assert( !(val) )\n    #define vdbg(v,...) do { cout << #v << \" = \"; vector_debug(v , ##__VA_ARGS__);} while(0)\n#else\n    #define dbg(...) 1\n    #define trc(...) 1\n    #define stopif(...) 1\n    #define vdbg(...) 1\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<string> vs;\ntypedef vector<pii> vpii;\ntypedef vector< vector<int> > vvi;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    cerr << fixed << setprecision(15);\n  }\n} iosetup;\n\nint gcd(int a, int b){if(a>b) swap(a,b); return a==0 ? b : gcd(b%a,a);} ll gcd(ll a, ll b){if(a>b) swap(a,b); return a==0 ? b : gcd(b%a,a);}\nint lcm(int a, int b){return (a / gcd(a,b)) * b;} ll lcm(ll a, ll b){return (a / gcd(a,b)) * b;}\ninline ll pow(int a, int b){ll ans = 1; rep(i,b) ans *= a; return ans;} inline ll pow(ll a, ll b){ll ans = 1; rep(i,b) ans*= a; return ans;}\ninline ll pow(int a, ll b){ll ans = 1; rep(i,b) ans *= a; return ans;} inline ll pow(ll a, int b){ll ans = 1; rep(i,b) ans*= a; return ans;}\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename C> inline void _cin(C &c){cin >> c;}\ntemplate<typename T,typename U> inline void _cin(pair<T,U> &p){cin >> p.fi; cin >> p.se;}\ntemplate<typename C> inline void _cout(const C &c){cout << c;}\ntemplate<typename T,typename U> inline void _cout(const pair<T,U> &p){cout << p.fi << ' ' << p.se;}\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ _cin(t); in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,U ...u){ _cout(t); if(sizeof...(u)) cout << ' '; out(u...);}\ntemplate<typename C> inline void in(vector<C> &v,int N=-1){if(sz(v) != 0){int M=(N == -1) ? sz(v) : N; rep(i,M) _cin(v[i]);}else{C c;rep(i,N) v.pb((_cin(c),c));}}\ntemplate<typename C> inline void in(C v[],int N){rep(i,N) _cin(v[i]);}\ntemplate<typename C> inline void out(const vector<C> &v,int N=-1){int M=(N == -1) ? sz(v) : N; rep(i,M) {cout<<( (i)?\" \":\"\" ); _cout(v[i]);} cout<<\"\\n\";}\ntemplate<typename C> inline void out(C v[],int N){rep(i,N) {cout<<( (i)?\" \":\"\" ); _cout(v[i]);} cout<<\"\\n\";}\ntemplate<typename C> inline void vector_debug(const vector<C> &v,int N=-1){cout << \"{\"; int M=(N == -1) ? sz(v) : N; rep(i,M) {cout<<( (i)?\", \":\"\" ); _cout(v[i]);} cout<<\"}\"<<endl;}\ntemplate<typename C> inline void vector_debug(C v[], int N){cout << \"{\"; rep(i,N) {cout<<((i)?\", \":\"\"); _cout(*(v+i));} cout<<\"}\"<<endl;}\nvoid dbg_out(){cout << endl;} template <typename T,class... U> void dbg_out(const T &t,U ...u){ _cout(t); if(sizeof...(u)) cout << \", \"; dbg_out(u...);}\ntemplate<typename C,class... U> void dbg_out(const vector<C> &v,U ...u){vector_debug(v); if(sizeof...(u)) cout << \", \"; dbg_out(u...);}\ntemplate<typename C,class... U> void dbg_out(const vector<vector<C>> &v,U ...u){cout << \"{ \"; rep(i,sz(v)) {if(i)cout<<\", \"; vector_debug(v[i]);} cout << \" }\"; if(sizeof...(u)) cout << \", \"; dbg_out(u...);}\ntemplate<typename C> inline C vmax(const vector<C> &v){C n=v[0]; rep(i,sz(v)) amax(n,v[i]); return n;} template<typename C> inline C vmax(C v[], int N){C n=v[0]; rep( i , N ) amax(n,v[i]); return n;}\ntemplate<typename C> inline C vmin(const vector<C> &v){C n=v[0]; rep(i,sz(v)) amin(n,v[i]); return n;} template<typename C> inline C vmin(C v[], int N){C n=v[0]; rep( i , N ) amin(n,v[i]); return n;}\ntemplate<typename C> inline C vsum(const vector<C> &v){C n=0; rep(i,sz(v)) n+=v[i]; return n;} template<typename C> inline C vsum(C v[], int N){C n=0; rep( i , N ) n+=v[i]; return n;}\n\n////////////\n/// main ///\n////////////\n\n\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n};\n\nusing modint = ModInt< MOD >;\nll N , H , D;\nmodint f[100100];\n\nint main(){\n  in(N , H , D);\n  modint x( (N * N) % MOD);\n  vector<modint> dp(H + 10);\n  dp[0] = 0; dp[1] = 2;\n  for(int i = 2; i <= H ; i ++){\n    if(i <= D) dp[i] = dp[i-1] * x;\n    else if(i == D + 1) dp[i] = dp[i-1] * x - 2;\n    else {\n      dp[i] = dp[i - 1] * x - dp[i - D] + dp[i - D - 1] ;\n    }\n  }\n  f[0] = 1;\n  rep(i , N + 1){\n    if(i == 0) f[i] = 1;\n    else f[i] = f[i - 1] * i; \n  }\n  out(dp[H] * f[N] / 2);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath> // 変数名にy1が使えなくなるかも…。\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <string>\n\ntypedef __int128_t int128_t;\nstd::istream &operator>>(std::istream& input, int128_t& value) { // int128_tの入力。入力が64bitに収まる前提。\n    long long tmp; input >> tmp; value = tmp;\n    return input;\n}\nstd::ostream &operator<<(std::ostream& output, const int128_t value) { // int128_tの出力。出力が64bitに収まる前提。\n    output << (long long)value;\n    return output;\n}\n\nint128_t cal_mod(const int128_t n, const int128_t mod) {\n    // n % modを計算する。ただしmod <= 0 ならば何もしない。nが負の場合、正にして補正する。\n    if (mod <= 0) {\n        return n;\n    } else if (0 <= n) {\n        return n % mod;\n    } else {\n        int128_t tmp = (-n) / mod + 1;\n        return (n + tmp * mod) % mod;\n    }\n}\n\nint128_t pow_mod(int128_t x, int128_t n, const int128_t mod) {\n    // 累乗の計算。mod <= 0ならば余りの計算は行わない。\n    int128_t ret = 1;\n    while (n > 0) {\n        if (n & 1) { ret = cal_mod(ret * x, mod); }\n        x = cal_mod(x * x, mod);\n        n = (n >> 1);\n    }\n    return ret;\n}\n\nclass Combi_Num {\n    // 「組み合わせ数 % 素数」を、前処理を行ったうえでO(1)で求める。modは32bitに収まることが前提。\n    public:\n    int128_t mod;\n    std::vector<int128_t> factorial, factorial_inv, inv;\n    Combi_Num() {}\n    Combi_Num(const int n, const int128_t mod_in) {\n        mod = mod_in;\n        factorial.resize(n+1, 0);\n        factorial_inv.resize(n+1, 0);\n        inv.resize(n+1, 0);\n        factorial[0] = 1;\n        factorial_inv[0] = 1;\n        inv[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            factorial[i] = (factorial[i-1] * i) % mod;\n            inv[i] = pow_mod(i, mod - 2, mod);\n            factorial_inv[i] = (factorial_inv[i-1] * inv[i]) % mod;\n        }\n    }\n\n    int128_t combi(const int n, const int r) {\n        return (factorial[n] * ((factorial_inv[r] * factorial_inv[n-r]) % mod)) % mod;\n    }\n\n    int128_t perm(const int n, const int r) {\n        return (factorial[n] * factorial_inv[n-r]) % mod;\n    }\n};\n\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 1000010;\nint128_t N, H, D;\n\nCombi_Num cn = Combi_Num(MAX_N, MOD);\n\nint128_t dp[MAX_N], dp_ac[MAX_N];\n\nint main(int argc, char **argv) {\n    std::cin >> N >> H >> D;\n\n    int128_t coeff = 0;\n    for (int i = 1; i <= N; i++) {\n        coeff = (coeff + cn.factorial[i]) % MOD;\n    }\n\n    dp[0] = cn.factorial[N];\n    dp_ac[0] = dp[0];\n\n    //std::cout << dp[0] << \" \" << dp_ac[0] << std::endl;\n\n    for (int i = 1; i <= H; i++) {\n        int128_t tmp = dp_ac[i-1];\n        if (0 < i - D) {\n            tmp = cal_mod(tmp - dp_ac[i - D - 1], MOD);\n        }\n        if (i == H) {\n            dp[i] = tmp;\n        } else {\n            dp[i] = (tmp * coeff) % MOD;\n        }\n        dp_ac[i] = (dp_ac[i-1] + dp[i]) % MOD;\n    }\n\n    std::cout << dp[H] << std::endl;\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int mod = 1000000000 + 7;\nlong long dp[1000010];\n\nint main(int argc, char const *argv[])\n{\n\tint N, H, D;\n\tcin >> N >> H >> D;\n\n\tlong long sum = 0;\n\tlong long fac = 1;\n\tfor(int i = 1; i <= N; i++) {\n\t\tfac = (fac * i) % mod;\n\t\tsum = (sum + fac) % mod;\n\t}\n\tdp[0] = 1;\n\tlong long last = dp[0];\n\t\n\tfor(int i = 1; i <= H; i++) {\n\t\tif(i < H) {\n\t\t\tdp[i] += sum * last;\n\t\t} else {\n\t\t\tdp[i] += fac * last;\n\t\t}\n\t\tdp[i] %= mod;\n\t\tlast += dp[i];\n\t\tif(i - D >= 0) {\n\t\t\tlast -= dp[i - D];\n\t\t}\n\t\tlast %= mod;\n\t}\n\tif(dp[H] < 0) dp[H] += mod;\n\tcout << dp[H] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\n#include<functional>\ntemplate<typename T>\nstruct lazysegtree{\n\tfunction<T(T,T)>calcfn,lazycalcfn;\n\tfunction<T(T,T,unsigned int)>updatefn;\n\tint n;\n\tT defvalue,lazydefvalue;\n\tvector<T>dat,lazy;\n\tvector<bool>lazyflag;\n\tlazysegtree(int n_=0,T defvalue_=0,\n\t\tfunction<T(T,T)>calcfn_=[](T a,T b){return a+b;},\n\t\tfunction<T(T,T)>lazycalcfn_=[](T a,T b){return a+b;},\n\t\tfunction<T(T,T,unsigned int)>updatefn_=[](T a,T b,unsigned int width){return a+b*width;},\n\t\tT lazydefvalue_=0\n\t):defvalue(defvalue_),lazydefvalue(lazydefvalue_),\n\t\tcalcfn(calcfn_),lazycalcfn(lazycalcfn_),updatefn(updatefn_)\n\t{\n\t\tn=1;\n\t\twhile(n<n_)n<<=1;\n\t\tdat.assign(2*n-1,defvalue);\n\t\tlazy.assign(2*n-1,lazydefvalue);\n\t\tlazyflag.assign(2*n-1,false);\n\t}\n\tvoid copy(const vector<T>&v)\n\t{\n\t\tfor(int i=0;i<v.size();i++)dat[i+n-1]=v[i];\n\t\tfor(int i=n-2;i>=0;i--)dat[i]=calcfn(dat[2*i+1],dat[2*i+2]);\n\t}\n\tvoid eval(int i,int l,int r)\n\t{\n\t\tif(lazyflag[i])\n\t\t{\n\t\t\tdat[i]=updatefn(dat[i],lazy[i],r-l);\n\t\t\tif(r-l>1)\n\t\t\t{\n\t\t\t\tlazy[2*i+1]=lazycalcfn(lazy[2*i+1],lazy[i]);\n\t\t\t\tlazy[2*i+2]=lazycalcfn(lazy[2*i+2],lazy[i]);\n\t\t\t\tlazyflag[2*i+1]=lazyflag[2*i+2]=true;\n\t\t\t}\n\t\t\tlazy[i]=lazydefvalue;\n\t\t\tlazyflag[i]=false;\n\t\t}\n\t}\n\tvoid update(int a,int b,T x,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\tif(b<=l||r<=a)return;\n\t\telse if(a<=l&&r<=b)\n\t\t{\n\t\t\tlazy[k]=lazycalcfn(lazy[k],x);\n\t\t\tlazyflag[k]=true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(a,b,x,2*k+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,2*k+2,(l+r)/2,r);\n\t\t\tdat[k]=calcfn(dat[2*k+1],dat[2*k+2]);\n\t\t}\n\t}\n\tT query(int a,int b,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return defvalue;\n\t\telse if(a<=l&&r<=b)return dat[k];\n\t\telse return calcfn(\n\t\t\tquery(a,b,2*k+1,l,(l+r)/2),\n\t\t\tquery(a,b,2*k+2,(l+r)/2,r)\n\t\t);\n\t}\n};\nlong N,H,D,mod=1e9+7;\nmain()\n{\n\tcin>>N>>H>>D;\n\tlazysegtree<long>P(H,0,\n\t[](long a,long b){return (a+b)%mod;},\n\t[](long a,long b){return (a+b)%mod;},\n\t[](long a,long b,unsigned int w){return (a+b*w)%mod;});\n\tlong s=0,p=1;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tp=p*i%mod;\n\t\ts=(s+p)%mod;\n\t}\n\tP.update(0,D,p);\n\tfor(int i=0;i<H;i++)\n\t{\n\t\tP.update(i+1,i+D+1,P.query(i,i+1)*s%mod);\n\t}\n\tcout<<P.query(H-1,H)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n/*\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds; // find_by_order(), order_by_key()\ntemplate<typename TK> using pbds_set = tree<TK, null_type, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename TK, typename TV> using pbds_map = tree<TK, TV, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\n*/\n\nconstexpr lint MOD = 1000000007;\nvector<lint> fac, facInv, inv;\nvoid facInit(int nmax)\n{\n    fac = facInv = inv = vector<lint>(nmax + 1, 1);\n    for (int i = 2; i <= nmax; i++)\n    {\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        facInv[i] = facInv[i-1] * inv[i] % MOD;\n    }\n}\nlint nCr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    if (n >= (int)fac.size()) facInit(n);\n    return (fac[n] * facInv[r] % MOD) * facInv[n-r] % MOD;\n}\nlint nPr(int n, int r)\n{\n    if (n<r || r<0) return 0;\n    if (n >= (int)fac.size()) facInit(n);\n    return fac[n] * facInv[n-r] % MOD;\n}\nlint power(lint x, lint n, lint mod=MOD)\n{\n    lint ans = 1;\n    while (n>0)\n    {\n        if (n & 1) (ans *= x) %= mod;\n        (x *= x) %= mod;\n       n >>= 1;\n    }\n   return ans;\n}\n\n// Solve ax+by=gcd(a, b)\nlint extgcd(lint a, lint b, lint &x, lint &y)\n{\n    lint d = a;\n    if (b != 0) d = extgcd(b, a % b, y, x), y -= (a / b) * x;\n    else x = 1, y = 0;\n    return d;\n}\n// Calc a^(-1) (MOD m)\nlint mod_inverse(lint a, lint m=MOD)\n{\n    lint x, y;\n    extgcd(a, m, x, y);\n    return (m + x % m) % m;\n}\n\nint main()\n{\n    lint N;\n    cin >> N;\n    lint H;\n    cin >> H;\n    lint D;\n    cin >> D;\n    facInit(N);\n    lint fac_sum = 0;\n    FOR(i, 1, N + 1) fac_sum = (fac_sum + fac[i]) % MOD;\n\n    vector<lint> dp(H + 3);\n    dp[0] = fac[N];\n    dp[1] = MOD - fac[N];\n\n    // dbg(fac_sum);\n    // dbg(dp);\n    REP(i, H + 1)\n    {\n        // dbg(dp);\n        if (i > 0) dp[i] = (dp[i - 1] + dp[i]) % MOD;\n        lint fac_sum_ = fac_sum;\n        // if (i == 0) fac_sum_ = 1;\n        (dp[i + 1] += dp[i] * fac_sum_ % MOD) %= MOD;\n        if (i + D + 1 < H + 3) (dp[i + D + 1] += (MOD - dp[i]) * fac_sum_ % MOD) %= MOD;\n    }\n    // dbg(dp);\n    cout << dp[H] * mod_inverse(fac_sum, MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll modminus(ll x, ll y) {\n    return (x - y + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll modpower(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y == 1) {\n        return x % mod;\n    } else if (y % 2 == 0) {\n        ll p = modpower(x, y / 2);\n        return p * p % mod;\n    } else {\n        ll p = modpower (x, y / 2);\n        return (p * p) % mod * (x % mod) % mod;\n    }\n}\n\nll divide(ll x, ll y) {\n    return multiply(x, modpower(y, mod - 2));\n}\n\nll frac[1000000];\nll invfrac[1000000];\n\nvoid fracinvfrac(ll n) {\n    frac[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        frac[i] = multiply(frac[i - 1], i);\n    }\n    invfrac[n] = divide(1, frac[n]);\n    for (int i = n - 1; i >= 0; i--) {\n        invfrac[i] = multiply(invfrac[i + 1], i + 1);\n    }\n}\n\nll modcombi(ll x, ll y) {\n    if (x < y || y < 0) {\n        return 0;\n    } else if (y == 0) {\n        return 1;\n    } else {\n        return multiply(multiply(frac[x], invfrac[x - y]), invfrac[y]);\n    }\n}\n\nll dp[1000010];\nll fracsum[1000010];\nll invfracsum[1000010];\n\nint main() {\n    fracinvfrac(1000010);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N, H, D;\n    cin >> N >> H >> D;\n    fracsum[1] = frac[1];\n    REP(i, 2, 1000010) {\n        fracsum[i] = modadd(fracsum[i - 1], frac[i]);\n    }\n    dp[0] = frac[N];\n    ll sum = dp[0];\n    REP(i, 1, H) {\n        dp[i] = multiply(sum, fracsum[N]);\n        sum = modadd(sum, dp[i]);\n        if (i - D >= 0) {\n            sum = modadd(sum, -dp[i - D]);\n        }\n    }\n    ll ans = 0;\n    PER(i, H - 1, H - D - 1) {\n        ans = modadd(ans, dp[i]);\n    }\n    // invfracsum[1] = invfrac[1];\n    // REP(i, 2, 1000010) {\n    //     invfracsum[i] = invfracsum[i - 1] + invfrac[i];\n    // }\n    // dp[0] = 1;\n    // ll sum = 1;\n    // REP(i, 1, H + 1) {\n    //     ll val = multiply(frac[N], invfracsum[N - 1] + 1);\n    //     dp[i] = multiply(sum, val);\n    //     sum = modadd(sum, dp[i]);\n    //     if (i - D - 1 >= 0) {\n    //         sum = modadd(sum, -dp[i - D - 1]);\n    //     }\n    // }\n    // REP(i, 0, H) {\n    //     cout << dp[i] << \" \";\n    // }\n    // cout << endl;\n    // ll ans = 0;\n    // PER(i, H - 1, H - D - 1) {\n    //     ans = modadd(ans, dp[i]);\n    // }\n    // ans = multiply(ans, frac[N]);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nlong long D[1010000], S[1010000], Mod = 1000000007;\nint n, H, d;\nlong long Sum(int b, int e) {\n\tif (b <= 0)return S[e];\n\treturn (S[e] - S[b - 1] + Mod) % Mod;\n}\nint main() {\n\tscanf(\"%d%d%d\", &n, &H, &d);\n\tD[0] = 1;\n\tint i;\n\tlong long s = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tD[0] = D[0] * i%Mod;\n\t\ts = (s + D[0]) % Mod;\n\t}\n\tS[0] = D[0];\n\tfor (i = 1; i <= H; i++) {\n\t\tD[i] = Sum(i - d, i - 1)*s%Mod;\n\t\tS[i] = (S[i - 1] + D[i]) % Mod;\n\t}\n\tprintf(\"%lld\\n\", Sum(H - d, H - 1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\nll dp[2000010],mod = 1000000007;\nint main(){\n    ll i,n,h,d,x = 1,y = 0;\n    cin >> n >> h >> d;\n    for(i=1;i<=n;i++){\n        (x *= i) %= mod;\n        (y += x) %= mod;\n    }\n    dp[0] = x;\n    for(i=0;i<=h;i++){\n        if(i==0){\n            (dp[i + 1] += dp[i]) %= mod;\n            (dp[i + d + 1] += mod - dp[i]) %= mod;\n        }else{\n            (dp[i + 1] += dp[i]) %= mod;\n            (dp[i + 1] += y*dp[i]%mod) %= mod;\n            (dp[i + d + 1] += (mod - y*dp[i]%mod)) %= mod;\n        }\n    }\n    cout << dp[h] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 1000005;\n\ntemplate <uint mod>\nclass ModInt {\nprivate:\n    uint v;\n    static uint norm(const uint& x){ return x < mod ? x : x - mod; }\n\tstatic ModInt make(const uint& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static uint inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n\texplicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    uint operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        uint v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\nusing mod = ModInt<MOD>;\n\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2;i<MAX_N;i++){\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i);\n\t\tfac[i] = fac[i-1] * i;\n\t\tfinv[i] = finv[i-1] * inv[i];\n\t}\n}\n\nmod comb(int a, int b)\n{\n\tif(a<b) return 0;\n\treturn fac[a] * finv[b] * finv[a-b];\n}\n\nmod dp[MAX_N];\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n,h,d;\n    cin >> n >> h >> d;\n    make();\n    mod res = 0;\n    rep(i,n+1){\n        res += fac[i];\n    }\n    mod ans = 1;\n    dp[0] = 1;\n    srep(i,1,h+1){\n        if(i <= d){\n            dp[i] = (res-1)*(ans-1)+fac[n];\n        }else{\n            dp[i] = (res-1)*ans;\n        }\n        ans += dp[i];\n        if(i >= d){\n            ans -= dp[i-d];\n        }\n    }\n    cout << dp[h] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MOD 1000000007\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n\n#define MOD 1000000007\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\nint n;\nint h;\nint d;\n\n#define MAX 1000002\n\n#define MOD 1000000007\n\nint dp[MAX];\n\n\nint main(){\n\tcin>>n>>h>>d;\n\tC.resize(1000002);\n\tint way1=0;  //all\n\tint k=1;\n\tfor(int j=1;j<=n;j++){\n\t\tmulto(k,j);\n\t\taddto(way1,mul(k,mul(ppow(d+1,n-j),C.C(n,j))));\n\t}\n\tint way2=0;\n\tfor(int j=1;j<=n;j++){\n\t\taddto(way2,mul(ppow(d+1,n-j),C.C(n,j)));\n\t}\n\tdp[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tmulto(dp[0],i);\n\t}\n\tfor(int i=1;i<=h;i++){\n\t\tint lef=max(i-d,0);\n\t\tint rig=i-1;\n\t\tint z=dp[rig];\n\t\tif(lef){\n\t\t\tsubto(z,dp[lef-1]);\n\t\t}\n\t\tif(i!=h){\n\t\t\tmulto(z,way1);\n\t\t}\n\t\telse{\n\t\t\tmulto(z,way2);\n\t\t}\n\t\tdp[i]=z;\n\t\tif(i!=h){\n\t\t\taddto(dp[i],dp[i-1]);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\\n\",dp[h]);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n,h,d;\nvl dp;\n\nint main(){\n\tcin>>n>>h>>d;\n\tll t=0,tmp=1,S;\n\tdp=vl(h+1);\n\tfor(int i=1;i<=n;i++) (tmp*=i)%=mod,(t+=tmp)%=mod;\n\tS=dp[0]=tmp;\n\tfor(int i=1;i<=h;i++){\n\t\tif(i-d>0) S=(S-dp[i-d-1]+mod)%mod;\n\t\tdp[i]=S;\n\t\tif(i<h) (dp[i]*=t)%=mod;\n\t\t(S+=dp[i])%=mod;\n\t}\n\tcout<<dp[h]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n//typedef vector<vector<ll>> Graph;\n\nconst ll mod = 1e9 + 7;\n//const ll mod = 998244353;\n\n#define REP(i,n) for(ll i=0;i<(ll)n;i++)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define spa << \" \" <<\n#define fi first\n#define se second\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\nos << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\nfor(int i = 0; i < (int)v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\nfor(int i = 0; i < (int)v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\ntemplate<typename T> void debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cerr<<v[i][0];for(ll j=1;j<w;j++)cerr spa v[i][j];cerr<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cerr<<v[i][j];cerr<<endl;}};\ntemplate<typename T> void debug(vector<T>&v,ll n){if(n!=0)cerr<<v[0];\nfor(ll i=1;i<n;i++)cerr spa v[i];\ncerr<<endl;};\n\nstring num2bit(ll num, ll len){\n    string bit = \"\";\n    REP(i, len){\n    bit += char('0'+(num>>i & 1));\n    }\n    return bit;\n}\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  // long long から modint を作るときは必ず正の数にしてからコンストラクタに入れること！ \n  // そうしないとバグります\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\nusing mint = modint<mod>;\n\ntemplate <class T, class U> constexpr T power(T x, U exp) {\n  T ret = static_cast<T>(1);\n  while (exp) {\n    if (exp % static_cast<U>(2) == static_cast<U>(1))\n      ret *= x;\n    exp /= static_cast<U>(2);\n    x *= x;\n  }\n  return ::std::move(ret);\n}\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll N, H, D;\n    cin >> N >> H >> D;\n    vector<mint> dp(H+1, 0);\n    vector<mint> S(H+2, 0);\n\n    mint tmp = 1;\n    mint F = 0;\n    for (int i = 1; i <= N; ++i) {\n        tmp *= i;\n        F += tmp;\n    }\n\n    REP(i, D) dp[i+1] = tmp;\n\n    for(int i=1;i<=H;i++){\n        ll mdx = max(i-D, 0ll);\n        dp[i] += (S[i] - S[mdx])*F;\n        S[i+1] = S[i] + dp[i];\n    }\n    \n    cout << dp[H].value() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define maxn 1000005\nconst int mod=1e9+7;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\n#define mp make_pair\n#define ff first\n#define ss second\n \nint n,d,h;\nint f[maxn];\n \ninline int read(){\n    int x=0,f=1; char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n \nint power(int a,int k){\n\tint ret=1;\n\tfor (;k;k>>=1,a=1ll*a*a%mod) if (k&1) ret=1ll*ret*a%mod;\n\treturn ret;\n}\n \nint main(){\n\tn=read(),h=read(),d=read(); int fac=1,val=0;\n\tfor (int i=1;i<=n;i++) fac=1ll*fac*i%mod,val=(val+fac)%mod;\n\tf[0]=1; int sum=f[0];\n\tfor (int i=1,j=0;i<=h;i++){\n\t\tf[i]=1ll*sum*val%mod;\n\t\tsum=(sum+f[i])%mod; if (i-j==d) sum=(sum-f[j])%mod,++j;\n\t}\n\tint ans=1ll*f[h]*fac%mod*power(val,mod-2)%mod;\n\tans=(ans+mod)%mod;\n\tcout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=1e6+10,mod=1e9+7;\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\tx=(ll)x*x%mod;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint dp[maxn],sum;\nint main(){\n\tint n=read(),m=read(),d=read();\n\tint fac=1,coef=0;\n\tREP(i,1,n){\n\t\tfac=(ll)i*fac%mod;\n\t\tcoef=(coef+fac)%mod;\n\t}\n\tsum=dp[0]=fac;\n\tREP(i,1,m){\n\t\tif(i-d>0) sum=(sum+mod-dp[i-d-1])%mod;\n\t\tdp[i]=(ll)sum*coef%mod;\n\t\tif(i==m) break;\n\t\tsum=(sum+dp[i])%mod;\n\t}\n\tprintf(\"%d\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <cstdint>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <cctype>\n#include <functional>\n#include <ctime>\n#include <cmath>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <iomanip>\n#include <float.h>\n#include <math.h>\nusing namespace std;\nusing ll = long long;\n\n\nunsigned euclidean_gcd(unsigned a, unsigned b) {\n    if (a < b) return euclidean_gcd(b, a);\n    unsigned r;\n    while ((r = a % b)) {\n        a = b;\n        b = r;\n    }\n    return b;\n}\n\nclass UnionFind {\npublic:\n    vector <ll> par;\n    vector <ll> siz;\n    UnionFind(ll sz_) : par(sz_), siz(sz_, 1LL) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(ll sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    ll root(ll x) {\n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n    bool merge(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool issame(ll x, ll y) {\n        return root(x) == root(y);\n    }\n\n    ll size(ll x) {\n        return siz[root(x)];\n    }\n};\n\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nlong long modinv(long long a, long long mod) {\n    return modpow(a, mod - 2, mod);\n}\n\n\nint main() {\n    ll n,h,d;\n    cin >> n >> h >> d;\n    ll x = 0;\n    ll zx = 1;\n    for (int i = 1; i < n+1; i++) {\n        zx *= i;\n        zx %= 1000000007;\n        x += zx;\n        x %= 1000000007;\n    }\n    vector<ll> z(h+1);\n    z.at(0) = 1;\n    z.at(1) = x;\n    ll zzx = x;\n    for (int i = 2; i < d + 1; i++) {\n        zzx *= x + 1;\n        zzx %= 1000000007;\n        z.at(i) = zzx;\n    }\n    for (int i = d + 1; i < h+1; i++) {\n        z.at(i) = z.at(i - 1)+z.at(i-1)*modinv(x,1000000007) - z.at(i - 1 - d)+1000000007;\n        z.at(i) %= 1000000007;\n        z.at(i) *= x;\n        z.at(i) %= 1000000007;\n    }\n    cout << z.at(h)*modinv(x,1000000007)%1000000007*zx%1000000007 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntypedef long long ll;\ntypedef long double ld;\nconst int MAXN = 1000005;\nconst ll MOD = 1e9 + 7;\nll fac[MAXN], add[MAXN];\nint main() {\n\tfac[0] = 1;\n\tfor (int i = 1; i < MAXN; ++i)\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\tint n, h, d;\n\tscanf(\"%d%d%d\", &n, &h, &d);\n\tll mult = 0;\n\tfor (int i = 1; i <= n; ++i) mult += fac[i];\n\tmult %= MOD;\n\tfor (int i = 0; i <= h; ++i) {\n\t\tif (i) add[i] += add[i - 1];\n\t\tadd[i] %= MOD;\n\t\tll dp = i == 0 ? fac[n] : add[i] * mult % MOD;\n\t\tif (i + 1 <= h) {\n\t\t\tadd[i + 1] += dp;\n\t\t\tadd[i + 1] %= MOD;\n\t\t}\n\t\tif (i + d + 1 <= h) {\n\t\t\tadd[i + d + 1] -= dp;\n\t\t\tadd[i + d + 1] %= MOD;\n\t\t}\n\t}\n\tif (add[h] < 0) add[h] += MOD;\n\tprintf(\"%lld\\n\", add[h]);\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n\ntemplate <uint32_t Modulus>\nclass modular {\npublic:\n  using value_type = uint32_t;\n  using max_type = uint64_t;\n\n  static constexpr value_type mod = Modulus;\n  static constexpr value_type mod_min = 1;\n  static constexpr value_type mod_max = 2147483647;\n  static_assert(mod >= mod_min, \"invalid mod :: too small\");\n  static_assert(mod <= mod_max, \"invalid mod :: too big\");\n\n  template <class T>\n  static constexpr value_type normalize(T value_) {\n    if (value_ < 0) {\n      value_ = -value_;\n      value_ %= mod;\n      if (value_ == 0) return 0;\n      return mod - value_;\n    }\n    return value_ % mod;\n  }\n\nprivate:\n  value_type value;\n\npublic:\n  constexpr modular(): value(0) { }\n  template <class T>\n  explicit constexpr modular(T value_): value(normalize(value_)) { }\n  template <class T>\n  explicit constexpr operator T() { return static_cast<T>(value); }\n\n  constexpr value_type operator () () const { return value; }\n  constexpr modular operator - () const { return modular(mod - value); }\n  constexpr modular operator ~ () const { return inverse(); }\n\n  constexpr value_type &extract() { return value; }\n  constexpr modular inverse() const { return power(mod - 2); }\n  constexpr modular power(max_type exp) const {\n    modular res(1), mult(*this);\n    while (exp > 0) {\n      if (exp & 1) res *= mult;\n      mult *= mult;\n      exp >>= 1;\n    }\n    return res;\n  }\n\n  constexpr modular operator + (const modular &rhs) const { return modular(*this) += rhs; }\n  constexpr modular& operator += (const modular &rhs) { \n    if ((value += rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator - (const modular &rhs) const { return modular(*this) -= rhs; }\n  constexpr modular& operator -= (const modular &rhs) { \n    if ((value += mod - rhs.value) >= mod) value -= mod; \n    return *this; \n  }\n\n  constexpr modular operator * (const modular &rhs) const { return modular(*this) *= rhs; }\n  constexpr modular& operator *= (const modular &rhs) { \n    value = (max_type) value * rhs.value % mod;\n    return *this;\n  }\n\n  constexpr modular operator / (const modular &rhs) const { return modular(*this) /= rhs; }\n  constexpr modular& operator /= (const modular &rhs) { return (*this) *= rhs.inverse(); }\n\n  constexpr bool zero() const { return value == 0; }\n  constexpr bool operator == (const modular &rhs) const { return value == rhs.value; }\n  constexpr bool operator != (const modular &rhs) const { return value != rhs.value; }\n  friend std::ostream& operator << (std::ostream &stream, const modular &rhs) {\n    return stream << rhs.value;\n  }\n\n};\n\nusing modint = modular<1000000007>;\n\nint main() {\n  int N, H, D;\n  std::cin >> N >> H >> D;\n  std::vector<modint> dp(H);\n  modint coeff, fact(1);\n  for (int i = 1; i <= N; ++i) {\n    fact *= modint(i);\n    coeff += fact;\n  }\n  std::fill(dp.begin(), dp.begin() + D, fact);\n  modint sum;\n  for (int i = 1; i < H; ++i) {\n    sum += dp[i - 1];\n    if (i - D - 1 >= 0) {\n      sum -= dp[i - D - 1];\n    }\n    dp[i] += sum * coeff;\n  }\n  std::cout << dp.back() << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001; //check the limits, dummy\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    \n    int N; cin >> N;\n    int H, D; cin >> H >> D;\n\n    ll fact[N+1];\n    fact[0] = 1;\n    ll factSum = 0;\n    FOR(i, 1, N+1) {\n    \tfact[i] = fact[i-1] * i;\n    \tfact[i] = fact[i] % MOD;\n    \tfactSum += fact[i];\n    \tfactSum = factSum % MOD;\n    }\n\n    ll ans[H+1];\n    ll pref[H+2];\n    pref[0] = 0; pref[1] = fact[N];\n    ans[0] = fact[N];\n    FOR(i, 1, H) {\n    \tans[i] = pref[i] - pref[max(0, i-D)];\n    \tans[i] += MOD; ans[i] = ans[i] % MOD;\n    \tans[i] = ans[i] * factSum; ans[i] = ans[i] % MOD;\n    \tpref[i+1] = pref[i] + ans[i];\n    \tpref[i+1] = pref[i+1] % MOD;\n    \t//cout << ans[i] << \" \" << endl;\n    }\n\n    ans[H] = pref[H] - pref[max(0, H-D)];\n    cout << ans[H] << endl;\n\n\n    \n    return 0;\n}\n\n// read the question correctly (ll vs int)\n// template by bqi343"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int MAXN = 1000005;\n\nint N, H, D;\nlong long dp[MAXN], sum[MAXN];\n\nint main(){\n    scanf(\"%d %d %d\", &N, &H, &D);\n\n    long long t = 0, p = 1;\n    for(int i = 1; i <= N; i++){\n        p = (p * i) % MOD;\n        t = (t + p) % MOD;\n    }\n\n    //cout << t << ' ' << p << endl;\n\n    sum[H + 1] = 0;\n    for(int i = H; i >= 0; i--){\n        if(i == H)dp[i] = 1;\n        else{\n            dp[i] = (sum[i + 1] - sum[min(H + 1, i + D + 1)] + MOD) % MOD;\n        }\n        sum[i] = (sum[i + 1] + t * dp[i]) % MOD;\n    }\n\n    long long r = 0;\n    for(int i = 1; i <= D; i++)\n        r = (r + dp[i]) % MOD;\n    printf(\"%lld\\n\", (r * p) % MOD);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<time.h>\n#include<set>\n#define cl_has_dh(x...) cl_get_th_100(\\\nx,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\\\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\\\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\\\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\\\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\\\n0)\n#define cl_get_th_100(\\\n _0, _1, _2, _3, _4, _5, _6, _7, _8, _9,\\\n_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,\\\n_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,\\\n_30,_31,_32,_33,_34,_35,_36,_37,_38,_39,\\\n_40,_41,_42,_43,_44,_45,_46,_47,_48,_49,\\\n_50,_51,_52,_53,_54,_55,_56,_57,_58,_59,\\\n_60,_61,_62,_63,_64,_65,_66,_67,_68,_69,\\\n_70,_71,_72,_73,_74,_75,_76,_77,_78,_79,\\\n_80,_81,_82,_83,_84,_85,_86,_87,_88,_89,\\\n_90,_91,_92,_93,_94,_95,_96,_97,_98,_99,\\\n_100,x...) _100\n#if 0\n#define cl_blzk cl_blzk0\n#else\n#define cl_blzk cl_blzk3\n#endif\n#define cl_blzk0(x...) cl_blzk1(cl_blzk1(cl_blzk1(x)))\n#define cl_blzk1(x...) cl_blzk2(cl_blzk2(cl_blzk2(x)))\n#define cl_blzk2(x...) cl_blzk3(cl_blzk3(cl_blzk3(x)))\n#define cl_blzk3(x...) cl_blzk4(cl_blzk4(cl_blzk4(x)))\n#define cl_blzk4(x...) cl_blzk5(cl_blzk5(cl_blzk5(x)))\n#define cl_blzk5(x...) cl_blzk6(cl_blzk6(cl_blzk6(x))) \n#define cl_blzk6(x...) cl_blzk7(cl_blzk7(cl_blzk7(x))) \n#define cl_blzk7(x...) x\n#define cl_lj_(a,b) a##b\n#define cl_lj(a,b) cl_lj_(a,b)\n#define cl_not(x) cl_lj(cl_not_,x)\n#define cl_not_0 1\n#define cl_not_1 0\n#define cl_and(x,y) cl_lj(cl_and_,cl_lj(x,y))\n#define cl_and_00 0\n#define cl_and_01 0\n#define cl_and_10 0\n#define cl_and_11 1\n#define cl_bif(x) cl_lj(cl_bif_,x)\n#define cl_bif_0(x...) cl_bif_0_\n#define cl_bif_0_(x...) x\n#define cl_bif_1(x...) x cl_bif_1_\n#define cl_bif_1_(x...)\n#define cl_nn(x...)\n#define cl_zzk(x...) x\n#define cl_zkk(x...) x\n#define cl_after(x...) cl_zzk cl_nn() (x)\n#define cl_txt(x...) #x\n#define cl_show(x...) puts(cl_txt(x))\n#define cl_is_nn(x...) cl_is_nnmm(x)\n#define cl_x_to_dh(x...) ,\n#define cl_is_nnmm(x...) cl_and(cl_and(cl_not(cl_has_dh(cl_x_to_dh x)),cl_has_dh(cl_x_to_dh x ())),cl_not(cl_has_dh(x ())))\ntypedef long long ll;\ntypedef long double ld;\n#define gs1(x,y,z) (quick_IO::very_important_cs_scw=y,quick_IO::very_important_cs_xsd=z,x)\n#define gs0(x,y) (quick_IO::very_important_cs_scw=y,x)\n#define gs(x,y...) cl_lj(gs,cl_has_dh(y))(x,y)\n#define read_cz(cs,_1,_01) cl_bif(_01)((+)quick_IO::whreadm(_1)cl_zkk)(()cl_nn)\n#define write_cz(cs,_1,_01) cl_bif(_01)((,)quick_IO::whwritem(_1)cl_zkk)(()cl_nn)\n#define read(x...) (cl_blzk(cl_nn cl_d(read_cz,,x) ()))\n#define write(x...) cl_blzk(cl_nn cl_d(write_cz,,x) ())\n#define cl_pp(cs,x...) cl_blzk(cl_d(cl_pp_cz,cs,x))\n#define cl_pp_cz(cs,_1,_01) cl_bif(_01)(template<>struct cs<_1>{typedef _1 Type;};)()\n#define cl_d(cz,cs,x...) cl_ds(cz,cs,x)\n#define cl_ds(cz,cs,x...) cl_lj(cl_ds_,cl_is_nn(x))(cz,cs,x)\n#define cl_ds_1(cz,cs,_1,x...) cz(cs,_1,0)\n#define cl_ds_0(cz,cs,_1,x...) cz(cs,_1,1) cl_after(cl_ds_cpy)()(cz,cs,x)\n#define cl_ds_cpy() cl_ds\n#define isdigit(x) (x >= '0' && x <= '9')\n#define pp(a,b) template<>struct a<b>{typedef b Type;};\nnamespace quick_IO {\n\tinline bool blank(char ch) {return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t';}\n  \tll very_important_cs_scw=0,very_important_cs_xsd=6,cs=0;\n  \tinline char gc() {return getchar();}\n  \tinline void pc(char c) {cs?fprintf(stderr,\"%c\",c):putchar(c);}\n\ttemplate <typename T> struct Checker1;\n\tcl_pp(Checker1,bool,int,short,long,long long,unsigned int,unsigned long,unsigned short,unsigned long long,double,long double,float)\n\ttemplate <typename T> struct Checker2;\n\tcl_pp(Checker2,char)\n\tchar lastc=-2;\n\ttemplate <typename T>inline ll readm(typename Checker1<T>::Type&x) {\n\t    register double tmp=1;register bool sign=0; x=0;register char ch=lastc==-2?gc():lastc;\n\t    for (;!isdigit(ch);ch=gc()) if(ch=='-') sign=1;else if(ch==EOF) return 0;for (;isdigit(ch);ch=gc()) x=x*10+(ch-'0');\n\t    if (ch=='.') for (ch=gc();isdigit(ch);ch=gc()) tmp/=10.0,x+=tmp*(ch-'0');if (sign) x=-x;\n\t    lastc=ch;return 1;\n\t}\n\ttemplate <typename T>inline ll readm(typename Checker2<T>::Type&c) {\n\t\tfor(c=lastc==-2?gc():lastc;blank(c);c=gc());if(c==EOF)return 0;\n\t\tlastc=-2;return 1;\n\t}\n  \tinline ll readm(char *s)\n\t{\n    \tregister char ch=lastc==-2?gc():lastc;for (;blank(ch)&&~ch;ch=gc())if(ch==EOF)return 0;\n\t\tfor (;~ch&&!blank(ch);ch=gc()) *s++=ch;*s=0;lastc=-2;return 1;\n  \t}\n\tvoid writellm(ll c,ll x) {\n\t\tif(c<0)pc('-'),c=-c,x--;\n\t\tif(c<10)return ({for(ll i=1;i<=x-1;i++)pc(' ');pc(c^48);void(0);});\n\t\twritellm(c/10,x-1);pc((c%10)^48);\n\t}\n\ttemplate<typename T>ll whreadm(T*x){return readm(x);};\n\ttemplate<typename T>ll whreadm(T&x){return readm<T>(x);};\n\t\t#define x very_important_cs_xsd\n\t\t#define y very_important_cs_scw\n\ttemplate<typename T>void writem(typename Checker2<T>::Type c) {\n\t\tfor(ll i=1;i<=y-1;i++)pc(' ');pc(c);\n\t}\n\ttemplate <typename T> struct Checkers1;\n\tcl_pp(Checkers1,bool,int,short,long,long long,unsigned int,unsigned long,unsigned long long)\n\ttemplate <typename T>inline void ycl(typename Checkers1<T>::Type c){x=0;}\n\ttemplate <typename T>void ycl(T&c){long double ys=0.5;for(ll i=1;i<=x;i++)ys/=10;c+=ys;}\n\ttemplate<typename T>void writem(typename Checker1<T>::Type c) {\n\t\tif(c<0)putchar('-'),c=-c;\n\t\tycl<T>(c);\n\t\twritellm(ll(c),y-(x?x+1:0));c-=ll(c);if(!x)return;\n\t\tpc('.');for(ll i=1;i<=x;i++)c*=10,pc(int(c)^48),c-=char(c);\n\t}\n\tvoid writem(const char* c) {\n\t\tll len=std::strlen(c);for(ll i=1;i<=y-len;i++)pc(' ');\n\t\twhile(*c)pc(*c++); \n\t}\n\t#undef x\n\t#undef y\n\ttemplate<typename T>void whwritem(T*x){writem(x);very_important_cs_scw=0,very_important_cs_xsd=6;};\n\ttemplate<typename T>void whwritem(T x){writem<T>(x);very_important_cs_scw=0,very_important_cs_xsd=6;};\n}\n#define IO_debug 0\n#define IO(x) freopen(#x\".in\",\"r\",stdin)cl_bif(IO_debug)()(;freopen(#x\".out\",\"w\",stdout))\n#define bla ,(((zjhyyds))),\n#define cl_del_3_kh(x...) cl_bif(cl_has_3_kh(x))(cl_del_2_kh x)(x)\n#define cl_del_2_kh(x...) cl_bif(cl_has_2_kh(x))(cl_del_1_kh x)(x)\n#define cl_del_1_kh(x...) cl_bif(cl_has_1_kh(x))(cl_zkk x)(x)\n#define cl_has_3_kh(x...) cl_bif(cl_has_1_kh(x))(cl_has_2_kh x)(0)\n#define cl_has_2_kh(x...) cl_bif(cl_has_1_kh(x))(cl_has_1_kh x)(0)\n#define cl_has_1_kh(x...) cl_is_nn(cl_nn x)\n#define is_zjhyyds(x) cl_bif(cl_has_3_kh(x))(cl_is_nn(is_zjhyyds_(x)))(0)\n#define is_zjhyyds_(x) cl_lj(is_zjhyyds_s,cl_del_3_kh(x))\n#define is_zjhyyds_szjhyyds\n#define cl_rir_dh(cs,x...) cl_zzk(cl_nn cl_rir(cs,(,)x cl_zzk)())\n#define cl_rir(cs,x...) cl_blzk(cl_d(cl_rir_cz,(x),cl_zkk cs))\n#define cl_rir_cz(cs,_1,_01) cl_bif(_01)(cl_after(cl_hg_cpy)()(_1,cl_zkk cs))()\n#define cl_hg_cpy() cl_hg\n#define cl_hg(cs,x...) cl_nn cl_after(cl_ds_cpy)()(cl_hg_cz,cs,x)()\n#define cl_hg_cz(cs,_1,_01) cl_bif(_01)(cl_bif(is_zjhyyds(_1))(()cs cl_nn)((,)_1 cl_zkk))(()cl_nn)\nll readll(void){ll x=0,w=1;char c=getchar();for(;c<'0'||c>'9';(c-'-')||(w=-w),c=getchar());for(;c>='0'&&c<='9';x=(x<<1)+(x<<3)+(c^48),c=getchar());return x*w;}\n#define cl_rill(x...) cl_blzk(cl_nn cl_d(cl_rill_cz,,x)())\n#define rill(x...) cl_rill(x)\n#define cl_rill_cz(cs,_1,_01) cl_bif(_01)((,)_1=readll()cl_zkk)(()cl_nn)\n#define writeln(x...) cl_bif(cl_is_nn(x))(write('\\n'))(write(x,'\\n'))\n#define rep(cs,low,up,x...) rfor(ll cs=low;cs<=up;cl_bif(cl_is_nn(x))(++cs)(x))\n#define frh(cs,cz,low,up,x...) rfor(ll cs,cl_lj(WCR_yyds_,cs)=low;cs=cz[cl_lj(WCR_yyds_,cs)],cl_lj(WCR_yyds_,cs)<=up;cl_lj(WCR_yyds_,cs)++)cl_bif(cl_is_nn(x))()(if(x))\n#define per(cs,low,up,x...) rfor(ll cs=low;cs>=up;cl_bif(cl_is_nn(x))(--cs)(x))\n#define cl_hsdd(hs,x...) cl_blzk(cl_bif(cl_is_nn(x))()(cl_hsdd_(hs,x)))\n#define cl_hsdd_(hs,_1,x...) cl_lj(cl_hsdd_,cl_is_nn(x))(hs,_1,x)\n#define cl_hsdd_1(hs,_1,x...) _1\n#define cl_hsdd_0(hs,_1,x...) hs(_1,cl_after(cl_hsdd_cpy)()(hs,x))\n#define cl_hsdd_cpy() cl_hsdd_\n#define max(x...) cl_hsdd(std::max,x)\n#define min(x...) cl_hsdd(std::min,x)\n#define rfor(x...) for(register x)\n#define ssscc 1\n#if 1\n#define debug(x...) quick_IO::cs=ssscc,write(x),quick_IO::cs=0\n#define debugln(x...) quick_IO::cs=ssscc,writeln(x),quick_IO::cs=0\n#else\n#define debug(x...) quick_IO::cs=0\n#define debugln(x...) quick_IO::cs=0\n#endif\n#define fin(a,b,c) rfor(ll a=cl_bif(cl_is_nn(c))(b)(c);a>=0;a&&(--a&=b)||(a=-1))\nll n,f[1145141];\nconst ll mod=1e9+7;\nll pow(ll x,ll y){ll ans=1;for(;y;(y&1)&&((ans*=x)%=mod),(x*=x)%=mod,y>>=1);return ans;}\nint main(){\n\t//IO(E);\n\tll rill(n,h,d);\n\tll jcn=1,jc1_n=0,s=1;rep(i,1,n)jcn=jcn*i%mod,jc1_n=jc1_n+jcn;jc1_n%=mod;\n\tf[0]=1;rep(i,1,h)(i>d)&&({s-=f[i-d-1];if(s<0)s+=mod;s;}),({s+=f[i]=s*jc1_n%mod;if(s>=mod)s-=mod;s;});\n\twriteln(f[h]*jcn%mod*pow(jc1_n,mod-2)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define int ll\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\ntypedef complex<double> base;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\n\nvoid smain();\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst ll M = 1e9 + 7;\nconst int N = 1e6 + 100;\nll fact[N], rfact[N];\n\nll pw(ll a, ll n = M - 2) {\n    ll ret = 1;\n    while (n) {\n        if (n & 1) ret = ret * a % M;\n        a = a * a % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nvoid init() {\n    fact[0] = 1;\n    for (int i = 1; i < N; ++i) {\n        fact[i] = fact[i - 1] * i % M;\n    }\n    rfact[N - 1] = pw(fact[N - 1]);\n    for (int i = N - 2; i >= 0; --i) {\n        rfact[i] = rfact[i + 1] * (i + 1) % M;\n    }\n}\n\nll solve(int n, int h, int d) {\n    vl dp_sum(h + 1, 0);\n    vl pref_dp(h + 1, 0);\n    pref_dp[0] = dp_sum[0] = fact[n];\n    ll sum_fact = 0;\n    for (int i = 1; i <= n; ++i) {\n        sum_fact = (sum_fact + fact[i]) % M;\n    }\n    for (int i = 1; i < h; ++i) {\n        /* fill dp[i][1] */;\n        int lf = max(0LL, i - d);\n        ll f1;\n        if (lf) f1 = (M + pref_dp[i - 1] - pref_dp[lf - 1]) % M;\n        else f1 = pref_dp[i - 1];\n\n//        for (int j = max(0LL, i - d); j < i; ++j) {\n//            f1 = (f1 + dp_sum[j]) % M;\n//        }\n\n        dp_sum[i] = f1 * sum_fact % M;\n        pref_dp[i] = (pref_dp[i - 1] + dp_sum[i]) % M;\n    }\n\n    ll f1 = 0;\n    for (int j = max(0LL, h - d); j < h; ++j) {\n        f1 = (f1 + dp_sum[j]) % M;\n    }\n    return f1;\n}\n\n\nll solve_old(ll n, ll h, ll d) {\n    vl dp_sum(h + 1, 0);\n    vvl dp(h + 1, vl (n + 1, 0));\n    dp_sum[0] = fact[n];\n    for (int i = 1; i <= h; ++i) {\n        for (int j = max(0LL, i - d); j < i; ++j) {\n            dp[i][1] = (dp[i][1] + dp_sum[j]) % M;\n        }\n        dp_sum[i] = dp[i][1];\n        for (int j = 2; j <= n; ++j) {\n            dp[i][j] = dp[i][j - 1];\n            dp_sum[i] = (dp_sum[i] + dp[i][j] * fact[j]) % M;\n        }\n    }\n    return dp[h][n];\n}\n\nvoid smain() {\n\n    init();\n\n    int n, h, d;\n    cin >> n >> h >> d;\n    cout << solve(n, h, d) << '\\n';\n//    cout << solve_old(n, h, d);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ft first\n#define sd second\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    ll n,g[2],s[2],b[2];\n    cin>>n;\n    ifr(i,2) cin>>g[i]>>s[i]>>b[i];\n    vector<vector<ll>> dp1(5,vector<ll>(n+1));\n    for(ll j=0;j<=n;++j){\n        if(j<g[1]) dp1[1][j]=dp1[0][j];\n        else dp1[1][j]=max(dp1[0][j],dp1[1][j-g[1]]+g[0]);\n    }\n    for(ll j=0;j<=n;++j){\n        if(j<s[1]) dp1[2][j]=dp1[1][j];\n        else dp1[2][j]=max(dp1[1][j],dp1[2][j-s[1]]+s[0]);\n    }\n    for(ll j=0;j<=n;++j){\n        if(j<b[1]) dp1[3][j]=dp1[2][j];\n        else dp1[3][j]=max(dp1[2][j],dp1[3][j-b[1]]+b[0]);\n    }\n    for(ll j=0;j<=n;++j){\n        if(j==0) dp1[4][j]=dp1[3][j];\n        else dp1[4][j]=max(dp1[3][j],dp1[4][j-1]+1);\n    }\n    n=dp1[4][n];\n    swap(g[0],g[1]);\n    swap(s[0],s[1]);\n    swap(b[0],b[1]);\n    vector<ll> dp(n+1),ndp(n+1);\n    if(g[0]<=g[1]);\n    else {\n        for (ll j = 0; j <= n; ++j) {\n            if (j < g[1]) ndp[j] = dp[j];\n            else ndp[j] = max(dp[j], ndp[j - g[1]] + g[0]);\n        }\n        swap(dp,ndp);\n    }\n    if(s[0]<=s[1]);\n    else {\n        for (ll j = 0; j <= n; ++j) {\n            if (j < s[1]) ndp[j] = dp[j];\n            else ndp[j] = max(dp[j], ndp[j - s[1]] + s[0]);\n        }\n        swap(dp,ndp);\n    }\n    if(b[0]<=b[1]);\n    else {\n        for (ll j = 0; j <= n; ++j) {\n            if (j < b[1]) ndp[j] = dp[j];\n            else ndp[j] = max(dp[j], ndp[j - b[1]] + b[0]);\n        }\n        swap(dp,ndp);\n    }\n    for(ll j=0;j<=n;++j){\n        if(j==0) ndp[j]=dp[j];\n        else ndp[j]=max(dp[j],ndp[j-1]+1);\n    }\n    swap(dp,ndp);\n    cout<<max(n,dp[n])<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nID: bqi3431\nPROG: ~\nLANG: C++11 \n*/\n\n#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N,H,D;\n// mi dp[101][101];\nmi cum[1000005];\n\nvoid ad(int l, int r, mi x) {\n    ckmin(r,H);\n    cum[l] += x, cum[r+1] -= x;\n}\n\nint main() {\n\tsetIO(); re(N,H,D);\n\t/*dp[0][N] = 1;\n\tF0R(i,H+1) FOR(j,1,N+1) {\n\t    if (i < H) FOR(k,i+1,min(i+D,H)+1) dp[k][1] += dp[i][j];\n\t    if (j < N) dp[i][j+1] += (j+1)*dp[i][j];\n\t}\n\tps(dp[H][N]);*/\n\tmi sum(0), fac(1);\n\tFOR(i,1,N+1) {\n\t    fac *= i;\n\t    sum += fac;\n\t}\n\tad(1,D,fac);\n\tFOR(i,1,H+1) {\n\t    cum[i] += cum[i-1];\n\t    ad(i+1,i+D,sum*cum[i]);\n\t}\n\tps(cum[H]);\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7,N=1e6+5;\nll n,h,d,f[N],sum[N],s;\nint main()\n{\n    scanf(\"%lld%lld%lld\",&n,&h,&d);\n    f[0]=1;\n    for(int i=1;i<=n;i++)\n        f[i]=f[i-1]*i%mod,s=(s+f[i])%mod;\n    sum[1]=1;\n    for(int i=2;i<=h;i++)\n        sum[i]=(sum[i-1]+(sum[i-1]-sum[max(0ll,i-d-1)])*s)%mod;\n    printf(\"%lld\\n\",((sum[h]-sum[h-d])*f[n]%mod+mod)%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  otera    \n**/\n#include<iostream>\n#include<string> \n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<algorithm> \n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<deque>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\nconst int inf=1e9+7;\nconst ll INF=1LL<<60 ;\nconst ll mod=1e9+7 ;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<int, int> P;\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define debug(x)  cerr << #x << \" = \" << (x) << endl;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n// modint: mod 計算を int を扱うように扱える構造体\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) val += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nconst int MOD = 1000000007;\n//const int MOD = 998244353;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nvoid solve() {\n\tint n, h, d; cin >> n >> h >> d;\n    bc.init(1001000);\n    static mint dp[1001000], sdp[1001000];\n    rep(i, 1001000) {\n        dp[i] = sdp[i] = 0;\n    }\n    dp[0] = bc.fact(n); sdp[1] = bc.fact(n);\n    mint fac = 0;\n    for(int i = 1; i <= n; ++ i) {\n        fac += bc.fact(i);\n    }\n    for(int i = 1; i <= h; ++ i) {\n        int mi = max(0, i - d), ma = i - 1;\n        dp[i] = fac * (sdp[ma + 1] - sdp[mi]);\n        sdp[i + 1] = sdp[i] + dp[i];\n    }\n    mint ans = 0;\n    for(int i = max(0, h - d); i <= h - 1; ++ i) {\n        ans += dp[i];\n    }\n    cout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\n#define N 500000\nll MOD=1e9+7;\n\nll mat[11][11];\n//遅延評価\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree\n{\n  using F = function< Monoid(Monoid, Monoid) >;\n  using G = function< Monoid(Monoid, OperatorMonoid) >;\n  using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n  using P = function< OperatorMonoid(OperatorMonoid, int) >;\n \n  int sz;\n  vector< Monoid > data;\n  vector< OperatorMonoid > lazy;\n  const F f;\n  const G g;\n  const H h;\n  const P p;\n  const Monoid M1;\n  const OperatorMonoid OM0;\n \n \n  LazySegmentTree(int n, const F f, const G g, const H h, const P p,\n                  const Monoid &M1, const OperatorMonoid OM0)\n      : f(f), g(g), h(h), p(p), M1(M1), OM0(OM0)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    data.assign(2 * sz, M1);\n    lazy.assign(2 * sz, OM0);\n  }\n \n  void set(int k, const Monoid &x)\n  {\n    data[k + sz] = x;\n  }\n \n  void build()\n  {\n    for(int k = sz - 1; k > 0; k--) {\n      data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n    }\n  }\n \n  void propagate(int k, int len)\n  {\n    if(lazy[k] != OM0) {\n      if(k < sz) {\n        lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n        lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      }\n      data[k] = g(data[k], p(lazy[k], len));\n      lazy[k] = OM0;\n    }\n  }\n \n  Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r)\n  {\n    propagate(k, r - l);\n    if(r <= a || b <= l) {\n      return data[k];\n    } else if(a <= l && r <= b) {\n      lazy[k] = h(lazy[k], x);\n      propagate(k, r - l);\n      return data[k];\n    } else {\n      return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n                         update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n    }\n  }\n \n  Monoid update(int a, int b, const OperatorMonoid &x)\n  {\n    return update(a, b, x, 1, 0, sz);\n  }\n \n \n  Monoid query(int a, int b, int k, int l, int r)\n  {\n    propagate(k, r - l);\n    if(r <= a || b <= l) {\n      return M1;\n    } else if(a <= l && r <= b) {\n      return data[k];\n    } else {\n      return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n               query(a, b, 2 * k + 1, (l + r) >> 1, r));\n    }\n  }\n \n  Monoid query(int a, int b)\n  {\n    return query(a, b, 1, 0, sz);\n  }\n \n  Monoid operator[](const int &k)\n  {\n    return query(k, k + 1);\n  }\n};\nauto f=[](ll a,ll b){return (a+b)%MOD;};\nauto g=[](ll a,ll b){return (a*b)%MOD;};\nauto ff=[](ll a,ll b){return b;};\nauto h=[](ll a,ll b){return (ll)max(a,b);};\nauto p=[](ll a,ll b){return a;};\n//例\n//区間add　区間min\nLazySegmentTree<ll> dp(1100000,f,f,f,p,INF,0);\n//区間add 区間sum\n//LazySegmentTree<ll> seg(n,f,f,f,g,0,0);\n \n \n//LazySegmentTree(n,f,g,h,p,M1,OM0) \n//サイズnで初期化\n//fは二つの区間の要素をマージする二項演算\n//gは要素と作用素をマージする二項演算(第三因数は区間の長さ)\n//hは作用素同士をマージする二項演算\n//p(value,length)は作用素を下におろした時の演算\n//M1はモノイドの単位元\n//OM0は作用素の単位元\n//update(a,b,x) 区間[a,b)に作用素 x を作用\n//query(a,b) 区間[a,b) の値\nmain(){\n    ll n=in(),h=in(),d=in();\n    //LazySegmentTree<ll> dp(h+d+100,h,f,f,p,LLINF,0ll);\n    dp.update(0,1,n);\n    ll ans=0;\n    rep2(i,0,h-1){\n        if(i+d<h){\n            dp.update(i,i+d+1,dp[i]*((n*(n+1)/2)%MOD)%MOD);\n        }\n        else{\n            ans=(ans+dp[i])%MOD;\n        }\n        /*rep2(j,i+1,i+d){\n            if(j==h)dp[j]=(dp[j]+dp[i])%MOD;\n            else\n            dp[j]=(dp[j]+dp[i]*((n*(n+1)/2)%MOD)%MOD)%MOD;\n        }*/\n    }\n    cout<<ans%MOD;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n \ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nconst ll MOD = TEN(9) + 7;\nconst int maxn = TEN(6) + 10;\n\ninline void add(ll &x, ll y) {\n\tx += y;\n\tif (x >= MOD) x -= MOD;\n}\n\nll dp[maxn];\nll ps[maxn];\n\nint main() {\n\tint N, H, D;\n\tcin >> N >> H >> D;\n\tll k = 1;\n\tll s = 0;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tk = k * i % MOD;\n\t\tadd(s, k);\n\t}\n\n\tfor (int i = 1; i <= H; ++i) {\n\t\tps[i] = ps[i-1];\n\t\tdp[i] = ps[i] - ps[max(0, i-D-1)];\n\t\t\n\t\tif (dp[i] < 0) dp[i] += MOD;\n\t\tdp[i] = dp[i] * s % MOD;\n\t\tif (i <= D) add(dp[i], k);\n\t\tadd(ps[i], dp[i]);\n\t}\n\n\tcout << dp[H] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nint N;\nint D;\nint H;\nLL BIT[1145141];\nLL fact[1145141];\nLL fsum[1145141];\n\nvoid ADD(LL &v, LL t) {\n  v += t;\n  while (v >= MOD) v -= MOD;\n}\n\nvoid Add(int k, LL x) {\n  k++;\n  while (k < 1145141) {\n    ADD(BIT[k], x);\n    k += k&-k;\n  }\n}\n\nLL Get(int k) {\n  k++;\n  LL ret = 0;\n  while (k > 0) {\n    ADD(ret, BIT[k]);\n    k -= k&-k;\n  }\n  return ret;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  cin >> N >> H >> D;\n\n  fact[0] = 1;\n  reps(i, 1, N+2) {\n    fact[i] = fact[i-1]*i% MOD;\n  }\n\n  //fsum[0] = 1;\n  reps(i, 1, N+2) {\n    fsum[i] = (fsum[i-1] + fact[i]) % MOD;\n  }\n\n  Add(0, 1);\n  LL ans = -1;\n  reps(i, 1, H+1) {\n    LL dpi = Get(i-1);\n    if (i >= D+1) ADD(dpi, MOD-Get(i-D-1));\n    if (i <= D) {\n      ADD(dpi, MOD-1);\n      dpi *= fsum[N];\n      dpi %= MOD;\n      ADD(dpi, 1);\n    } else {\n      dpi *= fsum[N];\n      dpi %= MOD;\n    }\n\n    Add(i, dpi);\n    if (i == H) ans = dpi;\n  }\n  assert(ans >= 0);\n\n  //ans *= fsum[N];\n  //ans %= MOD;\n  ans *= fact[N];\n  ans %= MOD;\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace mint {\n  int md = 1e9 + 7;\n  inline void add (int &a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    a += b; if (a >= md) a -= md;\n  }\n  inline void sub (int &a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    a -= b; if (a < 0) a += md;\n  }\n  inline int sum (int a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    add(a, b); return a;\n  }\n  inline int dif (int a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    sub(a, b); return a;\n  }\n  template<class... A>\n  inline int prod (A... args) {\n    long long ret = 1;\n    for (int a :\tinitializer_list<int>{args...}) {\n      assert(0 <= a && a < md);\n      ret *= a;\n      ret %= md;\n    }\n    return (int)(ret % md);\n  }\n  inline void mul (int &a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    a = prod(a, b);\n  }\n  inline int inv (int a) {\n    assert(0 <= a && a < md);\n    a %= md;\n    if(a < 0) a += md;\n    int b = md, u = 0, v = 1;\n    while (a) {\n      int t = b / a;\n      b -= a * t; swap(a, b);\n      u -= v * t; swap(u, v);\n    }\n    assert(b == 1);\n    if(u < 0) u += md;\n    return u;\n  }\n  inline int quot (int a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    return prod(a, inv(b));\n  }\n  inline void div (int& a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    a = quot(a, b);\n  }\n  inline int pow (int a, long long b) {\n    assert(0 <= a && a < md);\n    int res = 1;\n    for (; b; b >>= 1) {\n      if (b & 1) mul(res, a);\n      mul(a, a);\n    }\n    return res;\n  }\n  namespace factorials {\n    int sz;\n    vector<int> fact, finv;\n    void init (int n) {\n      sz = n;\n      fact.resize(n); finv.resize(n);\n      fact[0] = 1;\n      for (int i = 1; i < n; i++) fact[i] = prod(fact[i - 1], i);\n      finv[n - 1] = inv(fact[n - 1]);\n      for (int i = n - 2; i >= 0; i--) finv[i] = prod(finv[i + 1], i + 1);\n    }\n  }\n  inline int fct (int i) {\n    using namespace factorials;\n    assert(0 <= i && i < sz);\n    return fact[i];\n  }\n  inline int fnv (int i) {\n    using namespace factorials;\n    assert(0 <= i && i < sz);\n    return finv[i];\n  }\n  inline int binom (int n, int k) {\n    using namespace factorials;\n    assert(0 <= n && n < sz);\n    if (0 < k || n < k) return 0;\n    return prod(fact[n], finv[k], finv[n - k]);\n  }\n}\nint main() {\n  cin.tie(0); cin.sync_with_stdio(false);\n  int n, h, d;\n  cin >> n >> h >> d;\n  mint::factorials::init(n + 1);\n  int B = 0;\n  for (int i = 1; i <= n; i++) {\n    mint::add(B, mint::fct(i));\n  }\n  vector<int> dp(h, 0);\n  dp[0] = 1;\n  for (int i = 1; i < h; i++) {\n    dp[i] = mint::prod(mint::sum(B, 1), dp[i - 1]);\n    if (i > d) mint::sub(dp[i], mint::prod(B, dp[i - d - 1]));\n  }\n  int ret = mint::prod(\n    mint::dif(dp[h - 1], dp[h - d - 1]),\n    mint::fct(n)\n  );\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 1000111, mod = 1000000007;\n\nint mul(int x, int y) {\n    return (1LL * x * y) % mod;\n}\n\nint power(int a, int b) {\n    if (b == 0) {\n        return 1 % mod;\n    }\n    if (b % 2 == 0) {\n        return power(mul(a, a), b / 2);\n    }\n    return mul(a, power(a, b - 1));\n}\n\nint inv(int x) {\n    return power(x, mod - 2);\n}\n\nconst int max_f = 2 * max_n;\n\nint f[max_f], rf[max_f];\n\nvoid get_all_f() {\n    f[0] = rf[0] = 1;\n    for (int i = 1; i < max_f; ++i) {\n        f[i] = mul(i, f[i - 1]);\n    }\n    rf[max_f - 1] = inv(f[max_f - 1]);\n    for (int i = max_f - 2; i > 0; --i) {\n        rf[i] = mul(i + 1, rf[i + 1]);\n    }\n}\n\nint get_c(int n, int k) {\n    if (n < k) {\n        return 0;\n    }\n    return mul(f[n], mul(rf[k], rf[n - k]));\n}\n\nint n, h, d, dp[max_n], sum[max_n];\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    get_all_f();\n    cin >> n >> h >> d;\n    int k = f[n];\n    int k2 = 0;\n    for (int i = 1; i <= n; ++i) {\n        k2 = (k2 + f[i]) % mod;\n    }\n    sum[0] = dp[0] = power(k2, mod - 2);\n    for (int i = 1; i <= h; ++i) {\n        dp[i] = sum[i - 1] + mod;\n        if (i - d - 1 >= 0) {\n            dp[i] -= sum[i - d - 1];\n        }\n        dp[i] = mul(dp[i], k2);\n        sum[i] = (sum[i - 1] + dp[i]) % mod;\n    }\n    cout << mul(k, dp[h]) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\nusing namespace std;\nlong long n,m,d,i,j,k,dp[1000005][2],g[1000005],fac[1000005],inv[1000005],fi[1000005],mod=1e9+7;\nint main()\n{\n\tfac[1]=fac[0]=inv[1]=fi[0]=fi[1]=1;\n\tfz(i,2,1000003){fac[i]=1ll*fac[i-1]*i%mod;inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;fi[i]=1ll*fi[i-1]*inv[i]%mod;}\n\tscanf(\"%lld%lld%lld\",&n,&m,&d);\n\tlong long syx=1;fz(i,2,n)(syx+=fac[i])%=mod;\n\tfz1(i,min(d,m)) dp[i][1]=fac[n];\n\tfz1(i,m){\n\t\t(g[i]+=g[i-1])%=mod;\n\t\t(dp[i][1]+=g[i])%=mod;\n\t\t(g[i+1]+=dp[i][1]*syx)%=mod;\n\t\t(g[min(i+d,m)+1]+=(mod-dp[i][1])*syx)%=mod;\n\t}\n\tcout<<dp[m][1]*fac[n]%mod*fi[n]%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nLL fac[SIZE],fac_sum[SIZE],dp[SIZE],dp_sum[SIZE];\nint main(){\n    int N,H,D;\n    R(N,H,D);\n    fac[0]=1;\n    FOR(i,1,N){\n        fac[i]=fac[i-1]*i%MOD;\n        fac_sum[i]=(fac_sum[i-1]+fac[i])%MOD;\n    }\n    dp_sum[1]=dp[1]=fac[N];\n    FOR(i,2,H){\n        int low=max(i-D,1);\n        dp[i]=(dp_sum[i-1]-dp_sum[low-1])*fac_sum[N]%MOD;\n        ADD(dp_sum[i],dp[i]+dp_sum[i-1]);\n    }\n    LL an=0;\n    ADD(an,dp_sum[H]-dp_sum[H-D]);\n    W(an);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mxn 1000010\n#define LL long long\nusing namespace std;\nconst int mod=1e9+7;\nLL W,S,dp[mxn],fac[mxn];\nint n,D,H,sl,fh;\nint rd()\n{\n\tsl=0;fh=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch) {if(ch=='-') fh=-1; ch=getchar();}\n\twhile('0'<=ch&&ch<='9') sl=sl*10+ch-'0',ch=getchar();\n\treturn sl*fh;\n}\nvoid upd(LL &x,LL y) {x+=y; if(x>=mod) x-=mod;}\nint main()\n{\n\tn=rd();H=rd();D=rd();fac[0]=1;\n\tfor(int i=1;i<=n;++i) fac[i]=i*fac[i-1]%mod,upd(W,fac[i]);\n\tdp[0]=1;S=1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(i-D-1>=0) upd(S,mod-dp[i-D-1]);\n\t\tif(i<n) dp[i]=S*W%mod; else dp[i]=S;\n\t\tupd(S,dp[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[n]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n#define pb push_back\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nconst int N = 1e6 + 20 , mod = 1e9 + 7 ;\nint n , d , h , dp[N] , m ;\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tcin >> n >> h >> d ;\n\n\tfor (int i = 1 , j = 1 ; i <= n ; i ++) {\n\t\tj = 1ll * j * i % mod ;\n\t\tm = (m + j) % mod ;\n\n\t\tif (i == n) dp[0] = j , dp[1] = -j ;\n\t}\n\n\tfor (int i = 0 ; i <= h ; i ++) {\n\t\tif (!i) {\n\t\t\tint val = dp[i] ;\n\n\t\t\tdp[i + 1] = (dp[i + 1] + val) % mod ;\n\n\t\t\tif (i + d < h) dp[i + d + 1] = (dp[i + d + 1] - mod - val) % mod ;\n\t\t}\n\t\telse {\n\t\t\tdp[i] = (dp[i] + dp[i - 1]) % mod ;\n\n\t\t\tint val = 1ll * dp[i] * m % mod ;\n\n\t\t\tdp[i + 1] = (dp[i + 1] + val) % mod ;\n\t\t\n\t\t\tif (i + d < h) dp[i + d + 1] = (dp[i + d + 1] + mod - val) % mod ;\n\t\t}\n\t}\t\t\n\n\tcout << dp[h] << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* \n\tبسم الله الرحمن الرحیم\n\n\t(; طلا یک جهانی\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 1000 * 1000 + 5, MOD = 1e9 + 7;\nint n, h, d, dp[MAX_N], c, sum;\n\nvoid read_input() {\n\tcin >> n >> h >> d;\n}\n\nvoid prep() {\n\tint fac = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfac = 1LL * i * fac % MOD;\n\t\t(c += fac) %= MOD;\n\t}\n\tsum = dp[0] = fac;\n}\n\nvoid solve() {\n\tprep();\n\tfor (int i = 1; i <= h; i++) {\n\t\tdp[i] = sum;\n\t\tif (i < h)\n\t\t\tdp[i] = 1LL * dp[i] * c % MOD;\n\t\t(sum += dp[i]) %= MOD;\n\t\tif (i >= d)\n\t\t\t(sum -= dp[i - d]) %= MOD;\n\t}\n}\n\nvoid print_output() {\n\tcout << (dp[h] + MOD) % MOD;\n}\n\nint main() {\n\tios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tread_input();\n\tsolve();\n\tprint_output();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LL long long\nusing namespace std;\nconst LL mod=1e9+7;\nLL n,h,d,fac[1000010],f[1000010],s[1000010];\nint main()\n{\n\tscanf(\"%lld %lld %lld\",&n,&h,&d);\n\tfac[0]=fac[1]=1;\n\tfor(LL i=2;i<=n;i++) fac[i]=fac[i-1]*i%mod;\n\tf[1]=s[1]=fac[n];\n\tLL p=0;for(LL i=0;i<=n;i++) (p+=fac[i])%=mod;\n\tfor(LL i=2;i<=d;i++) s[i]=(s[i-1]+(f[i]=f[i-1]*p%mod))%mod;\n\tfor(LL i=d+1;i<=n;i++)\n\t{\n\t\tf[i]=(s[i-1]-s[i-d-1])%mod*(p-1)%mod;\n\t\ts[i]=(s[i-1]+s[i])%mod;\n\t}\n\tprintf(\"%lld\",(f[n]+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// types - only for stuff used a lot \nusing ll = long long;\n#define vv vector\n#define Pp pair\n\n// IO\n#define get(x) scanf(\"%d\",&x)\n#define getl(x) scanf(\"%lld\",&x);\n\n// Operations\n#define pb push_back\n#define pob pop_back\n#define sz(a) int(a.size()) \n#define re(a,b) a=max(a,b) // relax\n#define ri(a,b) a=min(a,b) // relaxi\n\n// Debugging\n\n#ifndef LOCAL\n#define cerr if (0) cerr\n#else\n#define cerr cout\n#endif\n\n#define print(arr,n) {for (int _ = 0; _ < n; _++) cerr<<arr[_]<<\" \"; cerr << endl; }\n#define printv(vec)  {for (int _ : vec) cerr<<_<<\" \"; cerr<<endl;}\n\nconst int mod = 1e9+7, oo = 1e9;\nconst ll loo = 1e18;\n\n// Functions \nll modpow(ll a, ll b) {\n\tll ans = 1; // faster modpow than recursive\n\tfor (; b; b/=2,a=a*a%mod)\n\t\tif (b&1) ans = (ans*a)%mod;\n\treturn ans;\n}\nll gcd(ll a, ll b) {\n\twhile (a) b%=a,swap(a,b);\n\treturn b;\n}\n#define bitcount __builtin_popcountll\n#define f(i,a,b) for (int i = a; i < b; i++)\n#define fr(i,a,b) for (int i = b-1; i >= a; i--)\n\n\n/* \n\n   ALRIGHT HACKERS, THIS IS WHERE THE ACTUAL CODE BEGINS\n\n */\n\nconst bool DEBUG = 1;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n#ifdef LOCAL\n\tif (DEBUG) freopen(\"input.txt\", \"r\", stdin);\n\tif (DEBUG) freopen(\"output.txt\", \"w\", stdout);\n\tclock_t start = clock();\n#endif\n\n\tint n, d, h;\n\tcin>>n>>h>>d;\n\tll c = 0;\n\tll co = 1; \n\tf(i,1,n+1) {\n\t\tco = (co*i)%mod;\n\t\tc = (c+co)%mod;\t\n\t}\n\tll dp[h];\n\tdp[0]=1;\n\tf(i,1,n+1) dp[0]=dp[0]*i%mod;\n\tll partial = dp[0]*c%mod;\n\tf(i,1,h) {\n\t\tdp[i] = partial;\t\n\t\tpartial = (partial+dp[i]*c%mod)%mod;\n\t\tif (i>=d)\n\t\t\tpartial = (partial+mod-dp[i-d]*c%mod)%mod;\n\t}\n\tll ans = 0;\n\tf(i,0,h)\n\t\tif (h-i<=d) ans = (ans+dp[i])%mod;\n\tcout << ans << endl;\n\n#ifdef LOCAL\n\tcout << setprecision(12) << (long double)(clock()-start) / CLOCKS_PER_SEC << endl;\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n\ntemplate<typename M>\nclass Enumeration{\nprivate:\n  static vector<M> fact,finv,invs;\npublic:\n  static void init(Int n){\n    n=min<decltype(M::mod)>(n,M::mod-1);\n\n    Int m=fact.size();\n    if(n<m) return;\n\n    fact.resize(n+1,1);\n    finv.resize(n+1,1);\n    invs.resize(n+1,1);\n\n    if(m==0) m=1;\n    for(Int i=m;i<=n;i++) fact[i]=fact[i-1]*M(i);\n    finv[n]=M(1)/fact[n];\n    for(Int i=n;i>=m;i--) finv[i-1]=finv[i]*M(i);\n    for(Int i=m;i<=n;i++) invs[i]=finv[i]*fact[i-1];\n  }\n\n  static M Fact(Int n){\n    init(n);\n    return fact[n];\n  }\n  static M Finv(Int n){\n    init(n);\n    return finv[n];\n  }\n  static M Invs(Int n){\n    init(n);\n    return invs[n];\n  }\n\n  static M C(Int n,Int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k]*finv[k];\n  }\n\n  static M P(Int n,Int k){\n    if(n<k||k<0) return M(0);\n    init(n);\n    return fact[n]*finv[n-k];\n  }\n\n  static M H(Int n,Int k){\n    if(n<0||k<0) return M(0);\n    if(!n&&!k) return M(1);\n    init(n+k-1);\n    return C(n+k-1,k);\n  }\n\n  static M S(Int n,Int k){\n    M res;\n    init(k);\n    for(Int i=1;i<=k;i++){\n      M tmp=C(k,i)*M(i).pow(n);\n      if((k-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res*=finv[k];\n  }\n\n  static vector<vector<M> > D(Int n,Int m){\n    vector<vector<M> > dp(n+1,vector<M>(m+1,0));\n    dp[0][0]=M(1);\n    for(Int i=0;i<=n;i++){\n      for(Int j=1;j<=m;j++){\n        if(i-j>=0) dp[i][j]=dp[i][j-1]+dp[i-j][j];\n        else dp[i][j]=dp[i][j-1];\n      }\n    }\n    return dp;\n  }\n\n  static M B(Int n,Int k){\n    if(n==0) return M(1);\n    k=min(k,n);\n    init(k);\n    vector<M> dp(k+1);\n    dp[0]=M(1);\n    for(Int i=1;i<=k;i++)\n      dp[i]=dp[i-1]+((i&1)?-finv[i]:finv[i]);\n    M res;\n    for(Int i=1;i<=k;i++)\n      res+=M(i).pow(n)*finv[i]*dp[k-i];\n    return res;\n  }\n\n  static M montmort(Int n){\n    M res;\n    init(n);\n    for(Int k=2;k<=n;k++){\n      if(k&1) res-=finv[k];\n      else res+=finv[k];\n    }\n    return res*=fact[n];\n  }\n\n  static M LagrangePolynomial(vector<M> &y,M t){\n    Int n=y.size()-1;\n    if(t.v<=n) return y[t.v];\n    init(n+1);\n    M num(1);\n    for(Int i=0;i<=n;i++) num*=t-M(i);\n    M res;\n    for(Int i=0;i<=n;i++){\n      M tmp=y[i]*num/(t-M(i))*finv[i]*finv[n-i];\n      if((n-i)&1) res-=tmp;\n      else res+=tmp;\n    }\n    return res;\n  }\n};\ntemplate<typename M>\nvector<M> Enumeration<M>::fact = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::finv = vector<M>();\ntemplate<typename M>\nvector<M> Enumeration<M>::invs = vector<M>();\n\n//INSERT ABOVE HERE\nsigned main(){\n  using M = Mint<Int>;\n  using E = Enumeration<M>;\n  E::init(2e6);\n  Int n,h,d;\n  cin>>n>>h>>d;\n\n  vector<M> as;\n  as.reserve(h+10);\n  as.emplace_back(0);\n  as.emplace_back(E::Fact(n));\n\n  M co{0};\n  for(Int i=0;i<=n;i++) co+=E::Fact(i);\n  for(Int i=2;i<=d;i++){\n    M nxt=as.back()*co;\n    as.emplace_back(nxt);\n  }\n\n  M co2=co-M(1);\n  M sum{0};\n  for(Int i=1;i<=d;i++) sum+=as[i];\n\n  for(Int i=d+1;i<=h;i++){\n    as.emplace_back(sum*co2);\n    sum+=as[i];\n    sum-=as[i-d];\n  }\n\n  //for(Int i=1;i<=h;i++) cout<<i<<\":\"<<as[i]<<endl;\n  cout<<as[h]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x << \" : \" << x << '\\n'\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst ll Mod = 1000000007LL;\nconst int Maxn = 1e6 + 10;\nconst ll Inf = 2242545357980376863LL;\nconst ll Log = 30;\n\nll mul(ll a, ll b){\n\treturn (a * b) % Mod;\n}\n\nll dp[Maxn];\nll f[Maxn];\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\t\n\tll n, h, d;\n\tcin >> n >> h >> d;\n\t\n\t\n\tf[0] = 1;\n\tfor(int i = 1; i <= n; i++) f[i] = mul(f[i - 1], i);\n\tll sm = 0;\n\tfor(int i = 1; i <= n; i++) sm += f[i];\n\tsm %= Mod;\n\t\n\tdp[0] = f[n];\n\tll s = dp[0];\n\tfor(int i = 1; i <= h; i++){\n\t\tdp[i] = mul(s, (i == h ? 1 : sm));\n\t\t//cerr << dp[i] << ' ';\n\t\ts += dp[i];\n\t\tif(i >= d) s -= dp[i - d];\n\t\ts%=Mod;\n\t}\n\tcout << (dp[h] + Mod) % Mod;\n\treturn 0;\n}\n/*\n1\n5 1\n20 21 22 23 24\n\n1\n4 2 \n1 2 3 4\n\n2 4 1 3\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T, class U> using Pa = pair<T, U>;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\nconstexpr ll mod = 1e9+7;\nstruct mint {\n    ll x;\n    mint(ll x=0):x((x%mod+mod)%mod){}\n    \n    friend ostream &operator<<(ostream& os,const mint& a){\n        return os << a.x;\n    }\n\n    friend istream &operator>>(istream& is,mint& a){\n        ll t;\n        is >> t;\n        a = mint(t);\n        return (is);\n    }\n\n    mint& operator+=(const mint a) {\n        if ((x += a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator-=(const mint a) {\n        if ((x += mod-a.x) >= mod) x -= mod;\n        return *this;\n    }\n    mint& operator*=(const mint a) {\n        (x *= a.x) %= mod;\n        return *this;\n    }\n    mint operator+(const mint a) const {\n        mint res(*this);\n        return res+=a;\n    }\n    mint operator-(const mint a) const {\n        mint res(*this);\n        return res-=a;\n    }\n    mint operator*(const mint a) const {\n        mint res(*this);\n        return res*=a;\n    }\n    mint pow(ll t) const {\n        if (!t) return 1;\n        mint a = pow(t>>1);\n        a *= a;\n        if (t&1) a *= *this;\n        return a;\n    }\n    // for prime mod\n    mint inv() const {\n        return pow(mod-2);\n    }\n    mint& operator/=(const mint a) {\n        return (*this) *= a.inv();\n    }\n    mint operator/(const mint a) const {\n        mint res(*this);\n        return res/=a;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,H,D;\n    cin >> N >> H >> D;\n    vec<mint> fact(N+1,1);\n    for(int i=1;i<=N;i++) fact[i] = fact[i-1]*i;\n    mint sum = accumulate(fact.begin()+1,fact.begin()+N,(mint) 0);\n    vvec<mint> dp(H+1,vec<mint>(2,0));\n    dp[0][1] = 1;\n    for(int i=1;i<=H;i++){\n        dp[i][0] = (dp[i-1][0]+dp[i-1][1]*fact[N])*sum;\n        if(i-D-1>=0) dp[i][0] -= (dp[i-D-1][0]+dp[i-D-1][1]*fact[N])*sum;\n        dp[i][1] = dp[i-1][0]+dp[i-1][1]*fact[N];\n        if(i-D-1>=0) dp[i][1] -= dp[i-D-1][0]+dp[i-D-1][1]*fact[N];\n        dp[i][0] += dp[i-1][0];\n        dp[i][1] += dp[i-1][1];\n    }\n//    for(int i=1;i<=H;i++) cerr << i << \" \" << dp[i][0]-dp[i-1][0] << \" \" << dp[i][1]-dp[i-1][1] << \"\\n\";\n    cout << dp[H][1]-dp[H-1][1] << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n#define REP(i, n) for (int i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (int i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n  {1, 0}, {0, 1}, {-1, 0}, {0, -1},  // 4方向\n  {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n  {0, 0},  // 自身\n};\ntemplate <class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T, class S> vector<T> make_vec(size_t n, S x) { return vector<T>(n, x); }\ntemplate <class T, class... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec<T>(ts...))>(n, make_vec<T>(ts...)); }\n\n// debug\ntemplate <class T> ostream& operator<<(ostream& s, vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream& s, vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, unordered_map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n  #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n  #define dump(...)\n  #define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\n\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 1000000007;\n// *************** TEMPLATE END *************** \n\ntemplate <class T>\nT pow(T x, int n, const T UNION = 1) {\n  T ret = UNION;\n  while (n) {\n    if (n & 1) ret *= x;\n    x *= x; n >>= 1;\n  }\n  return ret;\n}\n\ntemplate <int MD>\nstruct ModInt {\n  int x;\n  static unordered_map<int, int> to_inv;\n  ModInt() : x(0) {}\n  ModInt(int x_) { if ((x = x_ % MD + MD) >= MD) x -= MD; }\n\n  ModInt& operator+=(ModInt that) { if ((x += that.x) >= MD) x -= MD; return *this; }\n  ModInt& operator*=(ModInt that) { x = (unsigned long long)x * that.x % MD; return *this; }\n  ModInt& operator-=(ModInt that) { if ((x -= that.x) < 0) x += MD; return *this; }\n  ModInt& operator/=(ModInt that) { x = (unsigned long long)x * that.inv().x % MD; return *this; }\n\n  ModInt operator-() const { return -x < 0 ? MD - x : -x; }\n  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n  bool operator==(ModInt that) const { return x == that.x; }\n  bool operator!=(ModInt that) const { return x != that.x; }\n  ModInt inv() const { return to_inv.count(this->x) ? to_inv[this->x] : (to_inv[this->x] = pow(*this, MD - 2).x); }\n  friend ostream& operator<<(ostream& s, ModInt<MD> a) { s << a.x; return s; }\n  friend istream& operator>>(istream& s, ModInt<MD>& a) { s >> a.x; return s; }\n};\ntemplate <int MD> unordered_map<int, int> ModInt<MD>::to_inv;\nusing mint = ModInt<MOD>;\n\nvector<mint> fact, fact_inv;\nvoid init_factorial(int n) {\n  fact = vector<mint>(n + 1, 1);\n  fact_inv = vector<mint>(n + 1);\n  for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n  fact_inv[n] = mint(1) / fact[n];\n  for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n  // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n}\nmint comb(int n, int r) {\n  return fact[n] * fact_inv[r] * fact_inv[n - r];\n}\n\n// T0: 元の配列のモノイド\n// T1: T0に対する作用素モノイド\ntemplate <class T0, class T1>\nclass SegmentTree {\n  // k番目のノードにのlazyを伝搬\n  void eval(int k, int len) {\n    // u1が正確に単位元ならいらない\n    // if (lazy[k] == u1) return;\n    // len個分のlazy[k]を評価\n    node[k] = g(node[k], p(lazy[k], len));\n    if (k < N - 1) {\n      // 最下段でなければ下のlazyに伝搬\n      lazy[2 * k + 1] = f1(lazy[2 * k + 1], lazy[k]);\n      lazy[2 * k + 2] = f1(lazy[2 * k + 2], lazy[k]);\n    }\n    lazy[k] = u1;\n  }\n  // k番目のノード[l, r)について、[a, b)の範囲内にxを作用\n  void update(int a, int b, T1 x, int k, int l, int r) {\n    eval(k, r - l);\n    if (b <= l || r <= a) return;\n    if (a <= l && r <= b) {\n      lazy[k] = f1(lazy[k], x);\n      eval(k, r - l);\n    } else {\n      update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n      update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n      node[k] = f0(node[2 * k + 1], node[2 * k + 2]);\n    }\n  }\n  // k番目のノード[l, r)について、[a, b)のクエリを求める\n  T0 query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return u0;\n    eval(k, r - l);\n    if (a <= l && r <= b) return node[k];\n    T0 vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n    T0 vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n    return f0(vl, vr);\n  }\npublic:\n  int sz; // 元の配列のサイズ\n  int N;\n  vector<T0> node;\n  vector<T1> lazy;\n  // T0上の演算、単位元\n  using F0 = function<T0(T0, T0)>;\n  F0 f0; T0 u0;\n  // T1上の演算、単位元\n  using F1 = function<T1(T1, T1)>;\n  F1 f1; T1 u1;\n  // 作用\n  using G = function<T0(T0, T1)>;\n  G g;\n  // 多数のt1(T1)に対するf1の合成\n  using P = function<T1(T1, int)>;\n  P p;\n  SegmentTree(const vector<T0>& a, F0 f0, T0 u0, F1 f1, T1 u1, G g, P p)\n  : sz(a.size()), f0(f0), u0(u0), f1(f1), u1(u1), g(g), p(p) {\n    for (N = 1; N < sz; N *= 2);\n    node.resize(2 * N - 1);\n    lazy.resize(2 * N - 1, u1);\n    REP (i, sz) node[N - 1 + i] = a[i];\n    for (int i = N - 2; i >= 0; i--) node[i] = f0(node[2 * i + 1], node[2 * i + 2]);\n  }\n  // [a, b)にxを作用\n  void update(int a, int b, T1 x) {\n    assert(0 <= a && a < b && b <= sz);\n    update(a, b, x, 0, 0, N);\n  }\n  void update(int a, T1 x) {\n    update(a, a + 1, x);\n  }\n  // [a, b)\n  T0 query(int a, int b) {\n    return query(a, b, 0, 0, N);\n  }\n  T0 query(int a) {\n    return query(a, a + 1);\n  }\n};\n\nsigned main() {\n  int n, H, D; cin >> n >> H >> D;\n  init_factorial(n + 10);\n  mint mul = 0;\n  REPI (i, 1, n + 1) {\n    mul += fact[i];\n  }\n\n  // Sum & Add\n  SegmentTree<mint, mint> seg(\n    vector<mint>(H + 1, 0),\n    plus<mint>(), 0,\n    plus<mint>(), 0,\n    plus<mint>(),\n    multiplies<mint>()\n  );\n  seg.update(0, fact[n] / mul);\n  REP (i, H) {\n    mint now = seg.query(i);\n    seg.update(i + 1, min(H + 1, i + D + 1), now * mul);\n  }\n  cout << seg.query(H) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Copyright: lzt\n#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<cmath>\n#include<iostream>\n#include<queue>\n#include<string>\n#include<ctime>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntypedef pair<long long,long long> pll;\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define rep(i,j,k)  for(register int i=(int)(j);i<=(int)(k);i++)\n#define rrep(i,j,k) for(register int i=(int)(j);i>=(int)(k);i--)\n#define Debug(...) fprintf(stderr, __VA_ARGS__)\n\nll read(){\n\tll x=0,f=1;char c=getchar();\n\twhile(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*f;\n}\n\nconst int mod = 1e9 + 7;\nint n, h, d, s, ff;\nint f[1000100];\n\ninline void add(int &x, int y) {\n\tx += y;\n\tif (x >= mod) x -= mod;\n}\ninline void sub(int &x, int y) {\n\tx -= y;\n\tif (x < 0) x += mod;\n}\n\nvoid work() {\n\tn = read(); h = read(); d = read();\n\tff = 1;\n\trep(i, 1, n) {\n\t\tff = ff * 1ll * i % mod;\n\t\tadd(s, ff);\n\t}\n\tf[0] = 1; int tmp = 1;\n\trep(i, 1, h) {\n\t\tf[i] = tmp;\n\t\tadd(tmp, f[i]);\n\t\tif (i >= d) sub(tmp, f[i - d]);\n\t}\n\tcout<<f[h] * 1ll * ff % mod * s % mod << endl;\n}\n\nint main(){\n\t#ifdef LZT\n\t\tfreopen(\"in\",\"r\",stdin);\n\t#endif\n\n\twork();\n\n\t#ifdef LZT\n\t\tDebug(\"My Time: %.3lfms\\n\", (double)clock() / CLOCKS_PER_SEC);\n\t#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n#define FOR(i, l, r) for(int i = (l); i <= (r); ++i)\n#define REP(i, n) FOR(i, 0, (n) - 1)\n#ifdef DEBUG\n  template<class A, class B> ostream& operator<<(ostream &out, const pair<A, B> &p) {\n\t  return out << '(' << p.first << \", \" << p.second << ')';\n  }\n  template<class T> auto operator<<(ostream &out, T &&x) -> decltype(x.begin(), out) {\n\t  out << '{';\n\t  for(auto it = x.begin(); it != x.end(); ++it)\n\t\t  out << *it << (it == --x.end() ? \"\" : \", \");\n\t  return out << '}';\n  }\n  void dump() {}\n  template<class T, class... Args> void dump(T &&x, Args... args) {\n\t  cerr << x << \";  \";\n\t  dump(args...);\n  }\n  const int seed = 1;\n  struct Nl{~Nl(){cerr << '\\n';}};\n# define debug(x...) cerr << (#x != \"\" ? #x \":  \" : \"\"), dump(x), Nl(), cerr\n#else\n  const int seed = chrono::system_clock::now().time_since_epoch().count();\n# define debug(...) 0 && cerr\n#endif\nmt19937_64 rng(seed);\nint rd(int l, int r) {\n\treturn uniform_int_distribution<int>(l, r)(rng);\n}\ntemplate<class T> int size(T a) { return a.size(); }\n\nLL mod = 1e9 + 7;\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tLL n, h, d;\n\tcin >> n >> h >> d;\n\n\tvector<LL> dp(h + 1);\n\n\tLL f = 1;\n\tLL sum = 1;\n\tfor(LL i = 1; i <= n; i++)\n\t{\n\t\tf = (f * i) % mod;\n\t\tsum = (sum + f) % mod;\n\t}\n\n\tdebug(f, sum);\n\n\tdp[0] = 1;\n\tdp[1] = f;\n\tfor(int i = 2; i <= d && i <= h; i++)\n\t{\n\t\tdp[i] = (dp[i - 1] * sum) % mod;\n\t\tdebug(i, dp[i]);\n\t}\n\n\tif(h <= d)\n\t{\n\t\tcout << dp[h] << \"\\n\";\n\t\treturn 0;\n\t}\n\n\tLL last_d = 0;\n\tfor(int i = 1; i <= d; i++)\n\t\tlast_d = (last_d + dp[i]) % mod;\n\n\tsum = (sum - 1 + mod) % mod;\n\tfor(int i = d + 1; i <= h; i++)\n\t{\n\t\tdebug(i, dp[i], last_d);\n\t\tdp[i] = (last_d * sum) % mod;\n\t\tlast_d = (last_d + dp[i] - dp[i - d] + mod) % mod;\n\t}\n\n\tcout << dp[h] << \"\\n\";\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #include <atcoder/all>\nusing namespace std;\n// using namespace atcoder;\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << \"(\" << p.first << \",\" << p.second << \")\";\n  return os;\n}\n#ifdef __LOCAL\n#define debug(x) cerr << __LINE__ << \": \" << #x << \" = \" << (x) << '\\n'\n#define debugArray(x, n)                                      \\\n  cerr << __LINE__ << \": \" << #x << \" = {\";                   \\\n  for (long long hoge = 0; (hoge) < (long long)(n); ++(hoge)) \\\n    cerr << ((hoge) ? \",\" : \"\") << x[hoge];                   \\\n  cerr << \"}\" << '\\n'\n#define debugMatrix(x, h, w)                                         \\\n  cerr << __LINE__ << \": \" << #x << \" =\\n\";                          \\\n  for (long long hoge = 0; (hoge) < (long long)(h); ++(hoge)) {      \\\n    cerr << ((hoge ? \" {\" : \"{{\"));                                  \\\n    for (long long fuga = 0; (fuga) < (long long)(w); ++(fuga))      \\\n      cerr << ((fuga ? \", \" : \"\")) << x[hoge][fuga];                 \\\n    cerr << \"}\" << (hoge + 1 == (long long)(h) ? \"}\" : \",\") << '\\n'; \\\n  }\n#else\n#define debug(x) (void(0))\n#define debugArray(x, n) (void(0))\n#define debugMatrix(x, h, w) (void(0))\n#endif\n\ntemplate <int mod>\nstruct ModInt {\n  int64_t x;\n  ModInt() : x(0) {}\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod)) {}\n  ModInt &operator+=(const ModInt &p) {\n    if ((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator-=(const ModInt &p) {\n    if ((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n  ModInt &operator*=(const ModInt &p) {\n    x = (int)(1LL * x * p.x % mod);\n    return *this;\n  }\n  ModInt &operator/=(const ModInt &p) { return *this *= p.inverse(); }\n  ModInt operator-() const { return ModInt() - *this; }\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n  bool operator==(const ModInt &p) const { return x == p.x; }\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while (b) t = a / b, swap(a -= t * b, b), swap(u -= t * v, v);\n    return ModInt(u);\n  }\n  ModInt pow(int64_t e) const {\n    ModInt ret(1);\n    for (ModInt b = *this; e; e >>= 1, b *= b)\n      if (e & 1) ret *= b;\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x; }\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n  static int modulo() { return mod; }\n  int get() const { return x; }\n};\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  using Mint = ModInt<int(1e9 + 7)>;\n  int N, H, D;\n  cin >> N >> H >> D;\n  Mint fact = 1, sum = 0;\n  for (int i = 1; i <= N; i++) sum += fact *= i;\n  Mint dp[H + 1];\n  dp[1] = 1;\n  if (D + 1 <= H) dp[D + 1] = -1;\n  for (int i = 1; i < H; i++) {\n    dp[i + 1] += dp[i];\n    dp[i + 1] += dp[i] * sum;\n    if (i + D + 1 <= H) dp[i + D + 1] -= dp[i] * sum;\n  }\n  cout << dp[H] * fact << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <limits>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <iterator>\n#include <bitset>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T, class S, class U, class V> void writerLn(T x, S y, U z, V v) { writer(x, ' '); writer(y, ' '); writer(z, ' '); writer(v, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\nll mod_inv(ll a, ll m) { ll x, y; extgcd<ll>(a, m, x, y); return (m + x % m) % m; }\n\n#ifdef _MSC_VER\ntemplate <typename ... Args>\nvoid debugPrintf(const char *format, Args const & ... args) {\n\tfprintf(stderr, format, args ...);\n\tfflush(stderr);\n}\n#else\n#define debugPrintf(...)\n#endif\nconst int MOD = ten(9) + 7;\n\nll fact[ten(6) + 20];\nll fsum[ten(6) + 20];\n\nvoid init() {\n\tfact[0] = 1;\n\tFOR(i, ten(6) + 10) fact[i + 1] = fact[i] * (i + 1) % MOD;\n\tFOR(i, ten(6) + 11) fsum[i + 1] = (fsum[i] + fact[i+1]) % MOD;\n}\n\ntemplate<class T> class BIT {\n\tstatic const int n = ten(6) + 20;\n\tT bit[n + 1];\npublic:\n\tBIT() {}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\twhile (i > 0) { (s += bit[i]) %= MOD; i -= i & -i; }\n\t\treturn s;\n\t}\n\tvoid add(int i, T x) {\n\t\twhile (i <= n) { (bit[i] += x) %= MOD; i += i & -i; }\n\t}\n};\n\nint main() {\n\tinit();\n\t\n\tint n; reader(n);\n\tint h, d; reader(h, d);\n\n\tstatic BIT<ll> bit;\n\tbit.add(1, fact[n]);\n\tbit.add(2, -fact[n]);\n\n\tFOR(i, h) {\n\t\tll ca = bit.sum(i + 1);\n\t\tll nadd = ca * fsum[n] % MOD;\n\t\tint to = min(i + d, h - 1);\n\t\tbit.add(i + 2, nadd);\n\t\tbit.add(to + 2, -nadd);\n\t}\n\tll out2 = 0;\n\tfor (int j = 1; j <= d; j++) {\n\t\tout2 = (out2 + bit.sum(h - j + 1)) % MOD;\n\t}\n\n\twriterLn((out2 + MOD) % MOD);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1e9+7;\nconst int N=1e6+5;\nint n,h,d,sum,jc[N],xu[N],f[N],g[N];\nsigned main()\n{\n\tcin>>n>>h>>d;\n\tint x=0,xjh=n-1;\n\tfor(int i=n-2;i;i--)\n\t{\n\t\txjh=xjh*i%mod;\n\t\tx=(x+xjh)%mod;\n\t}\n\txjh=xjh*n%mod;\n\tx=(x+xjh)%mod;\n\tsum=xu[0]=n;\n\tfor(int i=1;i<h;i++)\n\t{\n\t\tf[i]=sum%mod;\n\t\txu[i]=f[i]*x%mod;\n\t\txu[i]=(xu[i]+f[i]*(n-1)%mod)%mod;\n\t\tif(i>=d)sum=sum-xu[i-d]+xu[i];\n\t\telse sum=sum+xu[i];\n\t\tsum=(sum%mod+mod)%mod;\n\t}\n\tg[1]=sum;\n\tfor(int i=2;i<=n;i++)g[i]=g[i-1]*(n-i+1)%mod;\n\tcout<<(g[n]%mod+mod)%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nsigned main(){\n\tint N, D, H, i;\n\tscanf(\"%lld%lld%lld\", &N, &H, &D);\n\tint fact = 1, fact_sum = 0;\n\tfor(i = 1; i <= N; i++){\n\t\tfact = MOD(fact * i);\n\t\tfact_sum = MOD(fact_sum + fact);\n\t}\n\tvector<int> dp(H + 1, 0), s(H + 1, 0);\n\tdp[1] = 1;\n\ts[1] = 1;\n\tfor(i = 2; i <= H; i++){\n\t\tdp[i] = MOD(fact_sum * (s[i - 1] - s[max(0ll, i - D - 1)]));\n\t\tif(i <= D){\n\t\t\tdp[i] = MOD(dp[i] + 1);\n\t\t}\n\t\ts[i] = MOD(s[i - 1] + dp[i]);\n\t}\n/*\tfor(i = 0; i <= H; i++){\n\t\tprintf(\"dp[%lld] = %lld\\n\", i, dp[i]);\n\t}\n*/\tprintf(\"%lld\\n\", MOD(fact * dp[H]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\ninline ll fastpow(ll bas, ll ex){\n\tregister ll res = 1; bas %= MOD;\n\tfor(; ex; ex >>= 1, bas = bas * bas % MOD) if(ex & 1) res = res * bas % MOD;\n\treturn res;\n}\n\ninline int kazu(int a, const int &b) {return (a += b) >= MOD ? a - MOD : a;}\ninline int hiku(int a, const int &b) {return (a -= b) < 0 ? a + MOD : a;}\n\nint N, H, D, fac[1000005] = {1}, sumfac = 0, isumfac, f[1000005], sumf;\n\nint main(){\n\tgetint(N), getint(H), getint(D);\n\tfor(register int i = 1; i <= N; i++) fac[i] = fac[i - 1] * (ll)i % MOD;\n\tfor(register int i = 1; i <= N; i++) sumfac = kazu(sumfac, fac[i]);\n\tisumfac = fastpow(sumfac, MOD - 2), sumf = f[0] = 1;\n\tfor(register int i = 1; i <= H; i++){\n\t\tif(i > D) sumf = hiku(sumf, f[i - D - 1]);\n\t\tf[i] = sumf * (ll)sumfac % MOD, sumf = kazu(sumf, f[i]);\n\t}\n\treturn printf(\"%d\\n\", f[H-1] * (ll)fac[N] % MOD * isumfac % MOD), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 1000010\n#define mo 1000000007\nusing namespace std;\nll n,h,d,jie[N],su,s1[N];\nint main(){\n\tcin>>n>>h>>d;\n\tjie[0]=1;\n\tfor (int i=1;i<=n;i++)jie[i]=jie[i-1]*i%mo;\n\tfor (int i=1;i<=n;i++)su=(su+jie[i])%mo;\n\ts1[1]=1;\n\tfor (int i=2;i<=h;i++)s1[i]=(s1[i-1]+(s1[i-1]-s1[max(0ll,i-d-1)]+mo)*su)%mo;\n\tcout<<(s1[h]-s1[h-d]+mo)*jie[n]%mo<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define INF  (1<<30)\n#define INFL (1LL<<60)\n#define MOD 1000000007\n#define EPS ((ld)(1e-9))\n\n#define sz(x) ((int)(x).size())\n#define setz(x) memset(x, 0, sizeof(x))\n#define all(x) (x).begin(), (x).end()\n#define rep(i, x)  for (int i = 0, _##i = (x); i < _##i; i++)\n#define repp(i, s, e) for (int i = (s), _##i = (e); i < _##i; i++)\n#define repr(i, s, e) for (int i = (s)-1, _##i = (e); i >= _##i; i--)\n#define repi(i, x) for (auto &i : (x))\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ld, ld> pdd;\ntypedef pair<ll, ll> pll;\n\ntemplate<typename T, typename V>\nostream &operator<<(ostream &os, const pair<T, V> pai) { \n    return os << '(' << pai.first << ' ' << pai.second << ')';\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> v) {\n    cout << \"[\";\n    rep(i, sz(v)) cout << v[i] << \",\";\n    cout << \"]\";\n    return os;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const set<T> v) {\n    cout << \"{\";\n    for (auto p : v) cout << p << \",\";\n    cout << \"}\";\n    return os;\n}\n\ntemplate<typename T, typename V>\nostream &operator<<(ostream &os, const map<T, V> v) {\n    cout << \"{\";\n    for (auto p : v) cout << p << \",\";\n    cout << \"}\";\n    return os;\n}\n\n#ifndef __SOULTCH\n#define debug(...) 0\n#define endl '\\n'\n#else\n#define debug(...) cout << \" [-] \", _dbg(#__VA_ARGS__, __VA_ARGS__)\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cout << sdbg << '=' << h << endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n    while(*sdbg != ',') cout << *sdbg++;\n    cout << '=' << (h) << ','; \n    _dbg(sdbg+1, a...);\n}\n#endif\n\ntemplate<typename T> void get_max(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void get_min(T &a, T b) {a = min(a, b);}\n\nint N, H, D;\nll fsum[1000001] = {1};\nll val[1000000];\n\nint main(void) {\n    iostream::sync_with_stdio(false);\n    cin.tie(nullptr), cout.tie(nullptr);\n\n    cin >> N >> H >> D;\n    repp(i, 1, N+1) fsum[i] = fsum[i-1]*i%MOD;\n    val[0] = fsum[N];\n    repp(i, 2, N+1) fsum[i] = (fsum[i]+fsum[i-1])%MOD;\n\n    ll csum = val[0];\n    repp(i, 1, H) {\n        val[i] = csum*fsum[N]%MOD;\n        csum = (csum+val[i])%MOD;\n        if (i >= D) csum = (csum-val[i-D]+MOD)%MOD;\n    }\n\n    csum = 0;\n    for (int i = max(0, H-D); i < H; i++) csum = (csum+val[i])%MOD;\n\n    cout << csum << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\ntypedef vector<string> svec;\n\nconst string yey = \"Yay!\";\nconst string sad = \":(\";\n\nstruct perm {\nprivate:\n\tint sz;\n\tvector<ll> p, invp;\npublic:\n\tperm(int n) {\n\t\tsz = n + 1;\n\t\tp.resize(sz), invp.resize(sz);\n\t\tp[0] = 1;\n\t\trep1(i, sz - 1) {\n\t\t\tp[i] = p[i - 1] * i%mod;\n\t\t}\n\t\tinvp[sz - 1] = 1;\n\t\tll cop = mod - 2, x = p[sz - 1];\n\t\twhile (cop) {\n\t\t\tif (cop % 2)invp[sz - 1] = invp[sz - 1] * x%mod;\n\t\t\tcop >>= 1; x = x * x % mod;\n\t\t}\n\t\tper(i, sz - 1) {\n\t\t\tinvp[i] = invp[i + 1] * (i + 1) % mod;\n\t\t}\n\t}\n\tll comb(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\tll ret = p[x];\n\t\t(ret *= invp[y]) %= mod;\n\t\t(ret *= invp[x - y]) %= mod;\n\t\treturn ret;\n\t}\n\tll combP(ll x, ll y) {\n\t\tif (x < y || y < 0)return 0;\n\t\treturn p[x] * invp[x - y] % mod;\n\t}\n\tll query(int n) {\n\t\tll ret = 0;\n\t\trep1(i, n) {\n\t\t\tret += p[i];\n\t\t\tif (ret >= mod)ret -= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tll call(int n) {\n\t\treturn p[n];\n\t}\n};\nperm p(1 << 21);\nll mod_pow(ll x, ll n=mod-2) {\n\tll ret = 1;\n\twhile (n) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\n\nstruct BIT {\nprivate:\n\tvector<ll> node; int n;\npublic:\n\tBIT(int n_) {\n\t\tn = n_; node.resize(n, 0);\n\t}\n\t//0-indexed\n\tvoid add(int a, ll w) {\n\t\tfor (int i = a; i < n; i |= i + 1)node[i] += w;\n\t}\n\t//[0,a)\n\tll sum(int a) {\n\t\tll ret = 0;\n\t\tfor (int i = a - 1; i >= 0; i = (i&(i + 1)) - 1)ret += node[i];\n\t\treturn ret%mod;\n\t}\n\t//[a,b)\n\tll sum(int a, int b) {\n\t\treturn sum(b) - sum(a);\n\t}\n};\n\nvoid solve() {\n\tint n, h, d; cin >> n >> h >> d;\n\tll s = p.query(n);\n\tBIT b(h + 1);\n\tll sta = p.call(n) % mod;\n\tb.add(0, sta);\n\tll ans = 0;\n\trep1(i, h) {\n\t\tll z = b.sum(max(i - d,0), i);\n\t\tz = (z%mod + mod) % mod;\n\t\t//cout << i << \" \" << z << endl;\n\t\tb.add(i, z*s%mod);\n\t\tif (i == h)ans = z;\n\t}\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(9);\n\t//init();\n\t//while (cin >> n>>m>>l,n)solve();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod=1e9+7;\nll dp[1000010],sum[1000010],n,h,d,x,s;\n\nll modinv(ll a){\n    ll b=mod,u=1,v=0;\n    while(b){\n        ll t=a/b;\n        a-=t*b; swap(a,b);\n        u-=t*v; swap(u,v);\n        }\n        u%=mod;\n        if(u<0) u+=mod;\n    return u;\n}\n\nint main(){\n  cin >> n >> h >> d; s=1; dp[0]=1; sum[0]=1;\n  for(ll i=1;i<=n;i++){\n    s=s*i%mod; x=(x+s)%mod;\n  }\n  for(ll i=1;i<=h;i++){\n    dp[i]=sum[i-1];\n    if(i-d>0) dp[i]=(dp[i]-sum[i-d-1]+mod)%mod;\n    dp[i]=dp[i]*x%mod;\n    sum[i]=(sum[i-1]+dp[i])%mod;\n  }\n  cout << dp[h]*s%mod*modinv(x)%mod << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nlong long dp[1000005];\n\nconst long long MOD = 1e9+7;\n\nint main(){\n    int N, H, D;\n    scanf(\"%d%d%d\", &N, &H, &D);\n\n    long long retainWays = 0;\n    long long fact = 1;\n    for(int i = 1; i <= N; i ++){\n        fact = fact*i%MOD;\n        retainWays += fact;\n    }\n    retainWays %= MOD;\n\n    //printf(\"retainWays=%lld\\n\", retainWays);\n\n    dp[0] = fact;\n    long long slidingWindowSum = dp[0];\n    for(int i = 1; i <= H; i ++){\n        dp[i] = slidingWindowSum;\n\n        if(i == H){break;}\n\n        dp[i] = dp[i]*retainWays%MOD;\n        slidingWindowSum += dp[i];\n        if(i >= D){slidingWindowSum -= dp[i-D];}\n\n        if(slidingWindowSum >= MOD){slidingWindowSum -= MOD;}\n        else if(slidingWindowSum < 0){slidingWindowSum += MOD;}\n\n        //printf(\"dp[%d]=%lld\\n\", i, dp[i]);\n    }\n\n    printf(\"%lld\", dp[H]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mn=1e6+10;\nconst ll mod=1e9+7;\nll spec=0;\nll dp[mn];\nint main(){\n    ll n,h,d,i;\n    cin>>n>>h>>d;\n    dp[0]=1;\n    ll f=1;\n    for(i=1;i<=n;i++)f=f*i%mod,spec=(spec+f)%mod;\n    ll sum=0;\n    for(i=1;i<=h;i++){\n        sum+=dp[i-1];\n        if(i-d-1>=0)sum-=dp[i-d-1];\n        sum%=mod;\n        if(i!=h)dp[i]=sum*spec%mod;\n        else dp[i]=sum;\n    }\n    for(i=1;i<=n;i++)dp[h]=dp[h]*i%mod;\n    if(dp[h]<0)dp[h]+=mod;\n    printf(\"%lld\",dp[h]);\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\ntemplate <typename T>\nT power(T a, T n, T mod) {\n  T res = 1;\n  T tmp = n;\n  T curr = a;\n  while(tmp){\n    if(tmp % 2 == 1){\n      res = (T)((ll)res * curr % mod);\n    }\n    curr = (T)((ll)curr * curr % mod);\n    tmp >>= 1;\n  }\n\n  return res;\n}\n\nll fac[1000001], fsum[1000001];\nll dp[1000001], dpsum[1000001];\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  LL(n); LL(h); LL(d);\n  fac[0] = 1; FOR(i, 1, 1000001)fac[i] = i * fac[i-1] % mod;\n  FOR(i, 1, 1000001)fsum[i] = (fac[i] + (i > 1 ? fsum[i-1]: 0)) % mod;\n  dp[1] = 1;\n  dpsum[1] = 1;\n  FOR(i, 2, h + 1){\n    dp[i] = dpsum[i-1];\n    if(i-d-1>=0)dp[i] = (dp[i] - dpsum[i-d-1]) % mod;\n    if(dp[i]<0)dp[i] += mod;\n    dp[i] = dp[i] * fsum[n] % mod;\n    if(i <= d)dp[i]++;\n\n    dpsum[i] = (dpsum[i-1] + dp[i]) % mod;\n  }\n\n  cout << dp[h] * fac[n] % mod << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}\nconst int32_t M=1e9+7;\nint32_t rev(int32_t x,int32_t m){\n    if(x==1)return 1;\n    return (1-(ll)rev(m%x,x)*m)/x+m;\n}\nstruct mint{\n    int32_t x;\n    mint():x(0){}\n    mint(int32_t xx):x(xx%M){if(x<0)x+=M;}\n    mint(ll xx):x(xx%M){if(x<0)x+=M;}\n    mint& operator+=(mint b){if((x+=b.x)>=M)x-=M;return *this;}\n    mint operator+(mint b){mint res=*this;res+=b;return res;}\n    mint& operator-=(mint b){if((x-=b.x)<0)x+=M;return *this;}\n    mint operator-(mint b){mint res=*this;res-=b;return res;}\n    mint& operator*=(mint b){x=(ll)x*b.x%M;return *this;}\n    mint operator*(mint b){mint res=*this;res*=b;return res;}\n    mint inverse(){return rev(x,M);}\n    mint& operator/=(mint b){x=(ll)x*rev(b.x,M)%M;return *this;}\n    mint operator/(mint b){mint res=*this;res/=b;return res;}\n    mint operator^(ll w) {mint r=1,a=*this;while(w){if(w&1)r*=a;a*=a;w/=2;}return r;}\n    mint operator^=(ll w){return *this=(*this)^w;}\n    mint operator^(mint w){return *this^w.x;}\n    mint operator^=(mint w){return *this=(*this)^w;}\n    mint operator-()const{return mint()-*this;}\n    explicit operator bool()const{return x;}\n};\nistream&operator>>(istream&is,mint&p){istream&res=is>>p.x;p.x%=M;return res;}\nostream&operator<<(ostream&os,mint p){return os<<p.x;}\ntemplate<typename T>mint operator+(T x,mint y){return mint(x)+y;}\ntemplate<typename T>mint operator-(T x,mint y){return mint(x)-y;}\ntemplate<typename T>mint operator*(T x,mint y){return mint(x)*y;}\ntemplate<typename T>mint operator/(T x,mint y){return mint(x)/y;}\ntemplate<typename T>mint operator^(T x,mint y){return mint(x)^y;}\nmint abs(mint x){return x;}\nconst int N=1e6+6;\nmint dp[N];\nmint s[N];\nmint gs(int i){\n    if(i<0)return 0;\n    return s[i];\n}\nmint g(int l,int r){\n    return gs(r)-gs(l-1);\n}\nint32_t main(){\n    int n,h,d;\n    cin>>n>>h>>d;\n    mint f=1;\n    mint sf=0;\n    for(int i=1;i<=n;++i){\n        f*=i;\n        sf+=f;\n    }\n    dp[0]=s[0]=f;\n    for(int i=1;i<h;++i){\n        dp[i]=sf*g(i-d,i-1);\n        s[i]=s[i-1]+dp[i];\n    }\n    cout<<g(h-d,h-1)<<'\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Set(a,b) memset(a,b,sizeof(a))\nusing namespace std;\nconst int N=1e6+10;\nconst int mod=1e9+7;\ntemplate <typename T> inline void init(T&x){\n\tx=0;char ch=getchar();bool t=0;\n\tfor(;ch>'9'||ch<'0';ch=getchar()) if(ch=='-') t=1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<1)+(x<<3)+(ch-48);\n\tif(t) x=-x;return;\n}\ntypedef long long ll;\ntemplate<typename T>inline void Inc(T&x,int y){x+=y;if(x>=mod) x-=mod;return;}\ntemplate<typename T>inline void Dec(T&x,int y){x-=y;if(x <  0) x+=mod;return;}\ntemplate<typename T>inline int fpow(int x,T k){int ret=1;for(;k;k>>=1,x=(ll)x*x%mod) if(k&1) ret=(ll)ret*x%mod;return ret;}\ninline int Sum(int x,int y){x+=y;if(x>=mod) return x-mod;return x;}\ninline int Dif(int x,int y){x-=y;if(x < 0 ) return x+mod;return x;}\nint n,H,D;\nint fac[N],ifac[N],f[N];\n\nint main()\n{\n\tinit(n),init(H),init(D);fac[0]=ifac[0]=1;\n\tint sum=0;\n\tfor(int i=1;i<=n;++i) fac[i]=(ll)fac[i-1]*i%mod,Inc(sum,fac[i]);\n\tifac[n]=fpow(fac[n],mod-2);\n\tfor(int i=n-1;i;--i) ifac[i]=(ll)ifac[i+1]*(i+1)%mod;\n\tf[0]=fac[n];int S=fac[n];\n\tint L=0;\n\tfor(int i=1;i<=H;++i) {\n\t\tif(i-L>D) Dec(S,f[L++]);\n\t\tif(i==H) cout<<S<<endl;\n\t\tf[i]=(ll)S*sum%mod;\n\t\tInc(S,f[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=1000005;\nconst int mod=1e9+7;\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nvoid dl(int &x,int y){x-=y;if(x<0)x+=mod;}\nint f[MAXN],pre[MAXN],S[MAXN],n,H,D;\nint main()\n{\n\tpre[0]=1;for(int i=1;i<MAXN;i++)pre[i]=1LL*pre[i-1]*i%mod,S[i]=S[i-1],ad(S[i],pre[i]);\n\tn=read();H=read();D=read();\n\tf[0]=pre[n];\n\tfor(int i=1,sum=f[0];i<=H;i++)\n\t{\n\t\tif(i-D-1>=0)dl(sum,f[i-D-1]);\n\t\tif(i!=H)\n\t\t{\n\t\t\tf[i]=1LL*sum*S[n]%mod;\n\t\t\tad(sum,f[i]);\n\t\t}else f[i]=sum;\n\t}pr2(f[H]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <array>\n#include <vector>\n#include <queue>\n#include <set>\n#include <cmath> // 変数名にy1が使えなくなるかも…。\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <string>\n\ntypedef __int128_t int128_t;\nstd::istream &operator>>(std::istream& input, int128_t& value) { // int128_tの入力。入力が64bitに収まる前提。\n    long long tmp; input >> tmp; value = tmp;\n    return input;\n}\nstd::ostream &operator<<(std::ostream& output, const int128_t value) { // int128_tの出力。出力が64bitに収まる前提。\n    output << (long long)value;\n    return output;\n}\n\nint128_t cal_mod(const int128_t n, const int128_t mod) {\n    // n % modを計算する。ただしmod <= 0 ならば何もしない。nが負の場合、正にして補正する。\n    if (mod <= 0) {\n        return n;\n    } else if (0 <= n) {\n        return n % mod;\n    } else {\n        int128_t tmp = (-n) / mod + 1;\n        return (n + tmp * mod) % mod;\n    }\n}\n\nint128_t pow_mod(int128_t x, int128_t n, const int128_t mod) {\n    // 累乗の計算。mod <= 0ならば余りの計算は行わない。\n    int128_t ret = 1;\n    while (n > 0) {\n        if (n & 1) { ret = cal_mod(ret * x, mod); }\n        x = cal_mod(x * x, mod);\n        n = (n >> 1);\n    }\n    return ret;\n}\n\nclass Combi_Num {\n    // 「組み合わせ数 % 素数」を、前処理を行ったうえでO(1)で求める。modは32bitに収まることが前提。\n    public:\n    int128_t mod;\n    std::vector<int128_t> factorial, factorial_inv, inv;\n    Combi_Num() {}\n    Combi_Num(const int n, const int128_t mod_in) {\n        mod = mod_in;\n        factorial.resize(n+1, 0);\n        factorial_inv.resize(n+1, 0);\n        inv.resize(n+1, 0);\n        factorial[0] = 1;\n        factorial_inv[0] = 1;\n        inv[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            factorial[i] = (factorial[i-1] * i) % mod;\n            inv[i] = pow_mod(i, mod - 2, mod);\n            factorial_inv[i] = (factorial_inv[i-1] * inv[i]) % mod;\n        }\n    }\n\n    int128_t combi(const int n, const int r) {\n        return (factorial[n] * ((factorial_inv[r] * factorial_inv[n-r]) % mod)) % mod;\n    }\n\n    int128_t perm(const int n, const int r) {\n        return (factorial[n] * factorial_inv[n-r]) % mod;\n    }\n};\n\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 1000010;\nint128_t N, H, D;\n\nCombi_Num cn = Combi_Num(MAX_N, MOD);\n\nint128_t dp[MAX_N], dp_ac[MAX_N];\n\nint main(int argc, char **argv) {\n    std::cin >> N >> H >> D;\n\n    int128_t coeff = 0;\n    for (int i = 1; i <= N; i++) {\n        coeff = (coeff + cn.factorial[i]) % MOD;\n    }\n\n    dp[0] = cn.factorial[N];\n    dp_ac[0] = dp[0];\n\n    //std::cout << dp[0] << \" \" << dp_ac[0] << std::endl;\n\n    for (int i = 1; i <= H; i++) {\n        int128_t tmp = dp_ac[i-1];\n        if (0 < i - D) {\n            tmp = cal_mod(tmp - dp_ac[i - D - 1], MOD);\n        }\n        if (i == H) {\n            dp[i] = tmp;\n        } else {\n            dp[i] = (tmp * coeff) % MOD;\n        }\n        dp_ac[i] = dp_ac[i-1] + dp[i];\n    }\n\n    std::cout << dp[H] << std::endl;\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define y1 askjdkasldjlkasd\n#include <bits/stdc++.h>\n#undef y1\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi(a, b) for(int i=a; i<=b; i++)\n#define fj(a, b) for(int j=a; j<=b; j++)\n#define fo(a, b) for(int o=a; o<=b; o++)\n#define fdi(a, b) for(int i=a; i>=b; i--)\n#define fdj(a, b) for(int j=a; j>=b; j--)\n#define fdo(a, b) for(int o=a; o>=b; o--)\n#define sz(x) (int)x.size()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<ll> vll;\n\n#ifdef LOCAL\n#define err(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define err(...) while (0)\n#endif\n\ndouble START_TIME;\n\nvoid exit() {\n#ifdef LOCAL\t\n\tcerr << \"TIME: \" << setprecision(5) << fixed << (clock() - START_TIME) / CLOCKS_PER_SEC << endl;\n#endif\t\n\texit(0);\n}\n\ntemplate<typename A, typename B>\nostream& operator<<(ostream& os, pair<A, B> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T> v) {\n\tfi(0, sz(v) - 1) {\n\t\tos << v[i] << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os, set<T> t) {\n\tfor (auto z : t) {\n\t\tos << z << \" \";\n\t}\n\treturn os;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, map<T1, T2> t) {\n\tcerr << endl;\n\tfor (auto z : t) {\n\t\tos << \"\\t\" << z.first << \" -> \" << z.second << endl;\n\t}\n\treturn os;\n}\n\n#ifdef LOCAL\n#define dbg(x) {cerr << __LINE__ << \"\\t\" << #x << \": \" << x << endl;}\n#define dbg0(x, n) {cerr << __LINE__ << \"\\t\" << #x << \": \"; for (int ABC = 0; ABC < n; ABC++) cerr << x[ABC] << ' '; cerr << endl;}\n#else\n#define dbg(x) while(0){}\n#define dbg0(x, n) while(0){}\n#endif\n\n#ifdef LOCAL\n#define ass(x) if (!(x)) { cerr << __LINE__ << \"\\tassertion failed: \" << #x << endl, abort(); }\n#else\n#define ass(x) assert(x)\n#endif\n\n///////////////////////////////////////////////////\n\nconst int MAX = 1e6 + 41;\nconst int MOD = 1e9 + 7;\n\nint n, h, D;\nint d[MAX];\nint u[MAX];\nint f[MAX];\n\nint add(int a, int b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint sub(int a, int b) {\n\ta -= b;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint mul(int a, int b) {\n\treturn (ll) a * b % MOD;\n}\n\nvoid init() {\n\tf[0] = 1;\n\tfi(1, MAX - 1) f[i] = mul(f[i - 1], i);\n}\n\nvoid solve () {\n\tint sum = 0;\n\tfi(1, n) {\n\t\tsum = add(sum, f[i]);\n\t}\n\tu[1] = f[n];\n\tu[D + 1] = sub(0, f[n]);\n\tint cur = 0;\n\t\n\tfi(1, h) {\n\t\tcur = add(cur, u[i]);\n\t\td[i] = cur;\n\t\tint nxt = min(MAX - 1, i + D + 1);\n\t\tint v = mul(cur, sum);\n\t\tu[i + 1] = add(u[i + 1], v);\n\t\tu[nxt] = sub(u[nxt], v);\n\t}\n//\tdbg0(u, h + 1);\n//\tdbg0(d, h + 1);\n\tprintf(\"%d\\n\", d[h]);\n}\n\nint main() {\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n\tSTART_TIME = (double)clock();\n#endif\n\tinit();\n\t\n\tscanf(\"%d %d %d\", &n, &h, &D);\n\tsolve();\n\n\texit();\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long \nll n,h,d;\n#define nn 1000008\nll dp[nn];\nll pre[nn];\n#define mod 1000000007\nll ask(ll l,ll r){\n\tif(l<=0) return pre[r];\n\treturn pre[r]-pre[l-1];\n}\n\tll sf[nn],f[nn];\n\tll qpow(ll x){\n\t\tll y=mod-2;ll res=1;\n\t\twhile(y){\n\t\t\tif(y&1) res=res*x%mod;\n\t\t\tx=x*x%mod;y=y/2;\n\t\t}\n\t\treturn res;\n\t}\nint main(){\n\tcin>>n>>h>>d;\n\tsf[0]=f[0]=1;for(int i=1;i<nn;i++) f[i]=f[i-1]*i%mod;sf[0]=0;\n\tfor(int i=1;i<=n;i++) sf[i]=sf[i-1]+f[i],sf[i]%=mod;\n\tdp[0]=1;pre[0]=f[n];\n\t\n\tfor(int i=1;i<=h;i++){\n\t\tdp[i]+=ask(i-d,i-1);\n\t\tdp[i]%=mod;pre[i]=pre[i-1]+dp[i]*sf[n];pre[i]%=mod;\n\t}\n\t\n\tcout<<(dp[h]%mod+mod)%mod;\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define ll long long\n#define all(aaa) aaa.begin(), aaa.end()\n\nconst int N = 1e6 + 5, MOD = 1e9 + 7;\nll dp[N];\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int n, d, h;\n    cin >> n >> h >> d;\n\n    ll fac_sum = 0, fac = 1;\n\n    for (int i = 1; i <= n; i++) {\n        fac = fac * i % MOD;\n        fac_sum = (fac_sum + fac) % MOD;\n    }\n\n    dp[1] = fac;\n\n    for (int i = 2; i <= h; i++) {\n        dp[i] = (dp[i - 1] - dp[max(0, i - d - 1)] + MOD) * fac_sum % MOD;\n        dp[i] = (dp[i] + dp[i - 1]) % MOD;\n    }\n\n    ll ans = (dp[h] - dp[h - d] + MOD) % MOD;\n\n    cout << ans << \"\\n\";\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll, ll> P;\ntypedef complex<double> com;\nconst int mod = 1e9 + 7;\nconst int MOD = 998244353;\nconst int inf = 2e9;\n\n//template\n\nclass UnionFind {\npublic:\n\tvector<int> par;\n\tUnionFind(int n) {\n\t\tpar = vector<int>(n, -1);\n\t}\n\tint root(int a) {\n\t\tif (par[a] < 0) {\n\t\t\treturn a;\n\t\t}\n\t\telse {\n\t\t\treturn par[a] = root(par[a]);\n\t\t}\n\t}\n\tint size(int a) {\n\t\treturn -par[root(a)];\n\t}\n\tbool connect(int a, int b) {\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif (a == b) {\n\t\t\treturn false;\n\t\t}\n\t\tif (size(a) < size(b)) {\n\t\t\tswap(a, b);\n\t\t}\n\t\tpar[a] += par[b];\n\t\tpar[b] = a;\n\t\treturn true;\n\t}\n};\nstruct edge { int cost, u, v; };\nbool comp(edge& e1,edge& e2){return e1.cost < e2.cost;}\n#define MAX_E 200010\nedge es[MAX_E]; int V,E;\nint kruskal() {\n\tsort(es, es + E, comp);\n\tUnionFind uni(V);\n\tint res = 0;\n\trep(i, 0, E) {\n\t\tedge e = es[i];\n\t\tif (uni.root(e.u) != uni.root(e.v)) {\n\t\t\tuni.connect(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\nll mpow(ll a,ll b) {\n\tll r = 1; a %= mod;\n\twhile (b) {\n\t\tr = r * ((b % 2) ? a : 1) % mod;\n\t\ta = a * a % mod, b >>= 1;\n\t}\n\treturn r;\n}\nvector<ll> fac, finv;\nvoid factor(int N) {\n\tfac.resize(N); finv.resize(N);\n\tfac[0] = finv[0] = 1;\n\trep(i, 1, N)fac[i] = 1LL * fac[i - 1] * i % mod;\n\tfinv[N - 1] = mpow(fac[N - 1], mod - 2);\n\trrep(i,N-2,-1)finv[i] = 1LL * finv[i + 1] * (i + 1) % mod;\n}\nint nCr(int n, int m) {\n\tif (m < 0 || n < m) return 0;\n\treturn 1LL * (1LL * fac[n] * finv[m] % mod) * finv[n - m] % mod;\n}\nll merge_cnt(vector<int>& a) {\n\tint n = a.size();\n\tif (n <= 1) return 0;\n\tll cnt = 0;\n\tvector<int> b(a.begin(), a.begin() + n / 2);\n\tvector<int> c(a.begin() + n / 2, a.end());\n\tcnt += merge_cnt(b);\n\tcnt += merge_cnt(c);\n\tint ai = 0, bi = 0, ci = 0;\n\twhile (ai < n) {\n\t\tif (bi < b.size() && (ci == c.size() || b[bi] <= c[ci])) {\n\t\t\ta[ai++] = b[bi++];\n\t\t}\n\t\telse {\n\t\t\tcnt += n / 2 - bi;\n\t\t\ta[ai++] = c[ci++];\n\t\t}\n\t}\n\treturn cnt;\n}\nvoid fft(vector<com>& x, bool inv) {\n\tint s = x.size();\n\tif (s == 1) return;\n\telse {\n\t\tvector<com> even(s / 2), odd(s / 2);\n\t\trep(i, 0, s / 2) {\n\t\t\teven[i] = x[i * 2];\n\t\t\todd[i] = x[i * 2 + 1];\n\t\t}\n\t\tfft(even, inv);\n\t\tfft(odd, inv);\n\t\tcom w = 1, w_0 = polar(1.0, (inv ? -1 : 1) * 2LL * M_PI / s);\n\t\tint t = s / 2 - 1;\n\t\trep(i, 0, s) {\n\t\t\tx[i] = even[i & t] + w * odd[i & t];\n\t\t\tw *= w_0;\n\t\t}\n\t}\n}\n#define MAX_V 100010\nll d[MAX_V];\nvoid dijkstra(int s,const vector<vector<edge>>& G) {\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tfill(d, d + MAX_V, inf);\n\td[s] = 0;\n\tque.push(P(0, s));\n\twhile (!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) continue;\n\t\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\t\tedge e = G[v][i];\n\t\t\tif (d[e.v] > d[v] + e.cost) {\n\t\t\t\td[e.v] = d[v] + e.cost;\n\t\t\t\tque.push(P(d[e.v], e.v));\n\t\t\t}\n\t\t}\n\t}\n}\nbool cross(ll ax, ll ay, ll bx, ll by, ll cx, ll cy, ll dx, ll dy) {\n\tll ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n\tll tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n\tll tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n\tll td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\treturn tc * td <= 0LL && ta * tb <= 0LL;\n}\nint diameter(const vector<vector<edge>>& g) {\n\tfunction<P(int, int)> dfs = [&](int prev, int v) {\n\t\tP r(0, v);\n\t\trep(i, 0, g[v].size()) {\n\t\t\tedge e = g[v][i];\n\t\t\tif (e.v == prev) continue;\n\t\t\tP tmp = dfs(v, e.v);\n\t\t\ttmp.first += e.cost;\n\t\t\tif (r.first < tmp.first) r = tmp;\n\t\t}\n\t\treturn r;\n\t};\n\tP r = dfs(-1, 0);\n\tP t = dfs(-1, r.second);\n\treturn t.first;\n}\nint bipartite(const vector<vector<int>>& g) {\n\tint n = g.size();\n\tvector<int> color(n, -1);\n\tint white_cnt = 0;\n\tfunction<bool(int, int, int)> dfs = [&](int u, int prev, int c) {\n\t\tcolor[u] = c;\n\t\tif (c == 1) white_cnt++;\n\t\tfor (auto v : g[u]) if (v != prev) {\n\t\t\tif (color[v] == -1) {\n\t\t\t\tif (!dfs(v, u, 1 - c)) return false;\n\t\t\t}\n\t\t\telse if (color[v] != 1 - c) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\tif (!dfs(0, -1, 0)) return -1;\n\treturn white_cnt;\n}\n//template end\n\n\n\nint main() {\n\tint n, h, d; cin >> n >> h >> d;\n\tfactor(1000010);\n\tint mul = 0;\n\trep(i, 1, n + 1) mul = (mul + fac[i]) % mod;\n\tvector<int> dp(h + 10, 0), sdp(h + 10, 0);\n\tdp[0] = sdp[1] = fac[n];\n\trep(i, 1, h + 1) {\n\t\tint l = max(0, i - d),r=i;\n\t\tdp[i] = 1LL*(sdp[r] - sdp[l] + mod) * mul % mod;\n\t\tsdp[i + 1] = (sdp[i] + dp[i]) % mod;\n\t}\n\tint ans = 0;\n\trep(i, max(0, h - d), h) ans = (ans + dp[i]) % mod;\n\tprintf(\"%d\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nint dp[1000005];\n\nconst long long MOD = 1e9+7;\n\nint main(){\n    int N, H, D;\n    scanf(\"%d%d%d\", &N, &H, &D);\n\n    long long retainWays = 0;\n    long long fact = 1;\n  \tif(N == 1000000){\n      \t// hyperoptimisation via precomputation of worst case scenario\n     \tretainWays=370927276;\n      \tfact=641102369;\n    }else{\n        for(int i = 1; i <= N; i ++){\n            fact = fact*i%MOD;\n            retainWays += fact;\n        }\n        retainWays %= MOD;\n    }\n\n    //printf(\"retainWays=%lld fact=%lld\\n\", retainWays, fact);\n\n    dp[0] = fact;\n    int slidingWindowSum = dp[0];\n    for(int i = 1; i < D; i ++){\n        dp[i] = slidingWindowSum*retainWays%MOD;\n\n        slidingWindowSum += dp[i];\n\n        if(slidingWindowSum >= MOD){slidingWindowSum -= MOD;}\n\n        //printf(\"dp[%d]=%lld\\n\", i, dp[i]);\n    }\n  \n  \tfor(int i = D; i < H; i ++){\n        dp[i] = slidingWindowSum*retainWays%MOD;\n\n        slidingWindowSum += dp[i]-dp[i-D];\n\n        if(slidingWindowSum >= MOD){slidingWindowSum -= MOD;}\n        else if(slidingWindowSum < 0){slidingWindowSum += MOD;}\n\n        //printf(\"dp[%d]=%lld\\n\", i, dp[i]);\n    }\n\n    printf(\"%d\", slidingWindowSum);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define ba 47\n#define MAXN 100005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n    if(c == '-') f = -1;\n    c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    res = res * 10 +c - '0';\n    c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint N,H,D;\nint fac[1000005],dp[1000006],sum[1000006];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nint fpow(int x,int c) {\n    int res = 1,t = x;\n    while(c) {\n        if(c & 1) res = mul(res,t);\n        t = mul(t,t);\n        c >>= 1;\n    }\n    return res;\n}\nvoid Solve() {\n    read(N);read(H);read(D);\n    fac[0] = 1;\n    int c = 0;\n    for(int i = 1 ; i <= N ; ++i) {\n        fac[i] = mul(fac[i - 1],i);\n        update(c,fac[i]);\n    }\n    dp[0] = c;sum[0] = 1;\n    for(int i = 1 ; i <= H ; ++i) {\n        int t = sum[i - 1];\n        if(i - D > 0) update(t,MOD - sum[i - D - 1]);\n        dp[i] = mul(t,c);\n        sum[i] = inc(sum[i - 1],dp[i]);\n    }\n    int ans = mul(dp[H],fac[N]);ans = mul(ans,fpow(c,MOD - 2));\n    out(ans);enter;\n}\nint main(){\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MOD=1e9+7;\n\ntemplate<uint_fast64_t Modulus> class modint{\n    using u64=uint_fast64_t;\n    public:\n    u64 a;\n    constexpr modint(const u64 x=0) noexcept:a(((x%Modulus)+Modulus)%Modulus){}\n    constexpr u64 &value() noexcept{return a;}\n    constexpr const u64 &value() const noexcept{return a;}\n    constexpr modint &operator+=(const modint &rhs) noexcept{\n        a+=rhs.a;\n        if (a>=Modulus) a-=Modulus;\n        return *this;\n    }\n    constexpr modint operator+(const modint &rhs) const noexcept{\n        return modint(*this)+=rhs;\n    }\n    constexpr modint &operator++() noexcept{\n        return ++a,*this;\n    }\n    constexpr modint operator++(int) noexcept{\n        modint t=*this; return ++a,t;\n    }\n    constexpr modint &operator-=(const modint &rhs) noexcept{\n        if (a<rhs.a) a+=Modulus;\n        a-=rhs.a;\n        return *this;\n    }\n    constexpr modint operator-(const modint &rhs) const noexcept{\n        return modint(*this)-=rhs;\n    }\n    constexpr modint &operator--() noexcept{\n        return --a,*this;\n    }\n    constexpr modint operator--(int) noexcept{\n        modint t=*this; return --a,t;\n    }\n    constexpr modint &operator*=(const modint &rhs) noexcept{\n        a=a*rhs.a%Modulus;\n        return *this;\n    }\n    constexpr modint operator*(const modint &rhs) const noexcept{\n        return modint(*this)*=rhs;\n    }\n    constexpr modint &operator/=(modint rhs) noexcept{\n        u64 exp=Modulus-2;\n        while(exp){\n            if (exp&1) *this*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return *this;\n    }\n    constexpr modint operator/(const modint &rhs) const noexcept{\n        return modint(*this)/=rhs;\n    }\n    constexpr modint operator-() const noexcept{\n        return modint(Modulus-a);\n    }\n    constexpr bool operator==(const modint &rhs) const noexcept{\n        return a==rhs.a;\n    }\n    constexpr bool operator!=(const modint &rhs) const noexcept{\n        return a!=rhs.a;\n    }\n    constexpr bool operator!() const noexcept{return !a;}\n    friend constexpr modint pow(modint rhs,long long exp) noexcept{\n        modint res{1};\n        while(exp){\n            if (exp&1) res*=rhs;\n            rhs*=rhs; exp>>=1;\n        }\n        return res;\n    }\n    template<class T> friend constexpr modint operator+(T x,modint y) noexcept{\n        return modint(x)+y;\n    }\n    template<class T> friend constexpr modint operator-(T x,modint y) noexcept{\n        return modint(x)-y;\n    }\n    template<class T> friend constexpr modint operator*(T x,modint y) noexcept{\n        return modint(x)*y;\n    }\n    template<class T> friend constexpr modint operator/(T x,modint y) noexcept{\n        return modint(x)/y;\n    }\n    friend ostream &operator<<(ostream &s,const modint &rhs) noexcept{\n        return s << rhs.a;\n    }\n    friend istream &operator>>(istream &s,modint &rhs) noexcept{\n        u64 a; rhs=modint{(s >> a,a)}; return s;\n    }\n};\n\nusing mint=modint<MOD>;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,H,D; cin >> N >> H >> D;\n    vector<mint> dp(H+1,0);\n    dp[0]=1;\n    mint fac_sum=0;\n    for (int i=1;i<=N;++i){\n        dp[0]*=i; fac_sum+=dp[0];\n    }\n    mint sum=dp[0];\n    for (int i=1;i<=H;++i){\n        dp[i]=sum*(i<H?fac_sum:1);\n        sum+=dp[i];\n        if (i-D>=0) sum-=dp[i-D];\n    }\n    cout << dp[H] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define LL long long\n#define PB push_back\n#define MP make_pair\n\n#define MOD 1000000007\n\n//累乗 O(log N)\nlong long power(long long x, long long N){\n\tif(N == 1) return x;\n\tlong long tmp = power(x, N/2);\n\tif(N%2 == 0) return tmp * tmp % MOD;\n\telse return tmp * tmp % MOD * x % MOD;\n}\n\n//逆元 O(log x)\nlong long inverse(long long x){\n\treturn power(x, MOD-2);\n}\n\n//コンビネーション\nstruct Combination{\nprivate:\n\tint N;\n\tvector<long long> fact, inv;\npublic:\n\tvoid init(int n){ //初期化する O(N)\n\t\tN = n;\n\t\tfact.push_back(1);\n\t\tinv.push_back(1);\n\t\tfor(long long i=1; i<=N; i++){\n\t\t\tfact.push_back(fact.back()*i%MOD);\n\t\t\tinv.push_back(inverse(fact.back()));\n\t\t}\n\t}\n\tlong long factorial(int n){\n\t\treturn fact[n];\n\t}\n\tlong long comb(int n, int k){ //nCkを求める O(1)\n\t\treturn fact[n] * inv[k] % MOD * inv[n-k] % MOD;\n\t}\n};\n\nint N, H, D;\nCombination C;\nLL imp = 0;\nLL memo[1000001];\nLL solve(int now){\n\tif(now == H) return C.factorial(N-1);\n\tif(memo[now] != LLONG_MIN) return memo[now];\n\tLL ret = 0;\n\tfor(int j=1; j<=D&&now+j<=H; j++){ //次どこ\n\t\tret += solve(now+j)*imp;\n\t\tret %= MOD;\n\t\tret += solve(now+j)*C.factorial(N-1)*N;\n\t\tret %= MOD;\n\t}\n\treturn memo[now] = ret;\n}\n\nint main(){\n\tcin >> N >> H >> D;\n\tC.init(N);\n\tfor(int i=0; i<=H; i++) memo[i] = LLONG_MIN;\n\tfor(int k=1; k<N; k++){ //何人動かす\n\t\timp += C.factorial(k)*C.comb(N-1-1, k-1);\n\t\timp %= MOD;\n\t}\n\tLL ans = 0;\n\tfor(int i=1; i<=D; i++){\n\t\tans += solve(i)*N;\n\t}\n\tcout << ans%MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(long long i=0;i<(long long)(n);i++)\n#define N 200000\n\nint main() {\n\tlong long x, y, z;\n\tlong long n, m, d, h;\n\tlong long s, ans;\n\tqueue<long long>q;\n\tscanf(\"%lld %lld %lld\", &n, &h, &d);\n\tx = 1;\n\ts = 0;\n\tfor (long long i = 1; i <= n; i++) {\n\t\tx = (x*i) % MOD;\n\t\ts = (s + x) % MOD;\n\t}\n\tm = s;\n\tf(i, d - 1)q.push(0);\n\tq.push(x);\n\ts = x;\n\tfor (long long i = 1; i <= h - 1; i++) {\n\t\tx = (s*m) % MOD;\n\t\tq.push(x);\n\t\ts = (s + x) % MOD;\n\t\tx = q.front();\n\t\tq.pop();\n\t\ts = (s + MOD - x) % MOD;\n\t}\n\tans = 0;\n\twhile (!q.empty()) {\n\t\tx = q.front();\n\t\tq.pop();\n\t\tans = (ans + x) % MOD;\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n#define PI  (3.1415926535)\n\n#define rep(i,n) for(ll i=0LL; i<n; ++i)\n#define srep(i,s,n) for(ll i=s; i<n; ++i)\n#define rrep(i,n) for(ll i=n-1LL; i>=0LL; --i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CIN(x) do { \\\n        assert(!cin.eof()); \\\n        cin >> x; \\\n        assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T> >;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n         << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n\n\n\n#define MOD   (1000000007LL)\n// #define MOD   (998244353LL)\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_perms(ll perms[], ll perm_invs[], ll size, ll mod)\n{\n    perms[0] = 1LL;\n    srep (i, 1, size) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= mod;\n    }\n\n    rep (i, size) {\n        perm_invs[i] = mod_inv(perms[i], mod);\n    }\n}\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n#if !DEBUG\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n    ll h; llin(h);\n    ll d; llin(d);\n\n    S ll perms[1000006];\n    S ll perm_invs[1000006];\n    make_perms(perms, perm_invs, 1000006, MOD);\n\n    ll coef = 0;\n    srep (i, 1, n+1) {\n        coef += perms[i];\n        coef %= MOD;\n    }\n\n    S ll dp[1000006] = {};\n    dp[0] = 1;\n    S V<ll> dpsums;\n    ll dpsum = 1;\n    dpsums.pb(0);\n    dpsums.pb(1);\n\n    srep (i, 1, h) {\n        dp[i] = dpsums[i] - dpsums[max(0LL, i-d)];\n        while (dp[i] < 0) dp[i] += MOD;\n        dp[i] *= coef;\n        dp[i] %= MOD;\n        dpsum += dp[i];\n        dpsum %= MOD;\n        dpsums.pb(dpsum);\n    }\n\n    debug_printf(\"---- dp\\n\");\n    debug_print(dp, 10);\n\n    ll ans = 0;\n    srep (i, h-d, h) {\n        ans += dp[i];\n        ans %= MOD;\n    }\n    ans *= perms[n];\n    ans %= MOD;\n\n    debug_printf(\"---- ans\\n\");\n    cout << ans << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nlong long dp[1000005];\n\nconst long long MOD = 1e9+7;\n\nint main(){\n    int N, H, D;\n    scanf(\"%d%d%d\", &N, &H, &D);\n\n    long long retainWays = 0;\n    long long fact = 1;\n    for(int i = 1; i <= N; i ++){\n        fact = fact*i%MOD;\n        retainWays += fact;\n    }\n    retainWays %= MOD;\n\n    //printf(\"retainWays=%lld\\n\", retainWays);\n\n    dp[0] = fact;\n    long long slidingWindowSum = dp[0];\n    for(int i = 1; i < H; i ++){\n        dp[i] = slidingWindowSum*retainWays%MOD;\n\n        slidingWindowSum += dp[i];\n        if(i >= D){slidingWindowSum -= dp[i-D];}\n\n        if(slidingWindowSum >= MOD){slidingWindowSum -= MOD;}\n        else if(slidingWindowSum < 0){slidingWindowSum += MOD;}\n\n        //printf(\"dp[%d]=%lld\\n\", i, dp[i]);\n    }\n\n    printf(\"%lld\", slidingWindowSum);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define oo 1000000010\n#define mod 1000000007\nconst int N = 1000010;\n\nint n , d , h , dp[N] , sum[N] , fact[N];\n\nint main(){\n\tfact[0] = 1;\n\tscanf(\"%d%d%d\",&n,&h,&d);\n\tint all = 0;\n\tfor(int i = 1;i <= n;i++){\n\t\tfact[i] = (long long)i * fact[i - 1] % mod;\n\t\tall += fact[i];\n\t\tif(all > mod) all -= mod;\n\t}\n\tdp[0] = sum[0] = fact[n];\n\tfor(int i = 1;i < h;i++){\n\t\tif(i <= d)\n\t\t\tdp[i] = (long long)sum[i - 1] * all % mod;\n\t\telse{\n\t\t\tdp[i] = sum[i - 1] - sum[i - d - 1];\n\t\t\tif(dp[i] >= mod) dp[i] -= mod;\n\t\t\tif(dp[i] < 0) dp[i] += mod;\n\t\t\tdp[i] = (long long)dp[i] * all % mod;\n\t\t}\n\t\tsum[i] = sum[i - 1] + dp[i];\n\t\tif(sum[i] >= mod)\n\t\t\tsum[i] -= mod;\n\t}\n\tint ans = 0;\n\tfor(int i = h - 1;i >= h - d;i--){\n\t\tans += dp[i];\n\t\tif(ans >= mod)\n\t\t\tans -= mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int INF=1e9;\nconst int MOD=1e9+7;\n//const int MOD=998244353;\nconst long long LINF=1e18;\nusing namespace std;\n#define int long long\n//template\nint pw(int n,int k){\n  if(k<0)return pw(n,k+MOD-1);\n  int res=1;\n  while(k){\n    if(k&1)res*=n;res%=MOD;\n    n*=n;n%=MOD;\n    k>>=1;\n  }\n  return res;\n}\nstd::vector<int> Factorial(1234567),Finverse(1234567);\nvoid Cinit(){\n  Factorial[0]=1;\n  for(int i=1;i<1234567;i++)Factorial[i]=Factorial[i-1]*i%MOD;\n  for(int i=0;i<1234567;i++)Finverse[i]=pw(Factorial[i],MOD-2);\n}\nint nCk(int n,int k){\n  if(n<k)return 1;if(k<0)return 0;\n  int res=Factorial[n];\n  res*=Finverse[k];res%=MOD;\n  res*=Finverse[n-k];res%=MOD;\n  return res;\n}\n//main\nsigned main(){\n  Cinit();\n  int N,H,D;cin>>N>>H>>D;\n  int sum=0;\n  std::vector<int> wa(1234567);\n  wa[0]=0;for(int i=1;i<1234567;i++)wa[i]=(wa[i-1]+Factorial[i])%MOD;\n  //cout<<wa[5]<<endl;return 0;\n  std::vector<int> dp(3234567,0);\n  queue<int> que;\n  for(int i=0;i<=H;i++){\n    if(i==0){\n      dp[1]+=Factorial[N];\n      sum+=dp[1];\n      que.push(sum);\n      continue;\n    }\n    if(que.size()>D){\n      int p=que.front();que.pop();\n      sum-=p;\n      if(sum<0)sum+=MOD;\n    }\n    dp[i]=sum;\n    que.push(sum*wa[N]%MOD);\n    sum+=sum*wa[N]%MOD;sum%=MOD;\n  }\n  //for(int i=0;i<=10;i++)cout<<dp[i]<<\" \";cout<<endl;\n  cout<<dp[H]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll mod=1e9 +7;\nint n,D,H;\nll doe,sum;\nll f[1010101],s[1010101];\nvoid init()\n{\n\tdoe=1;\n\tfor (int i=1;i<=n;++i)\n\t{\n\t\tdoe=doe*i%mod;\n\t\tsum=(sum+doe)%mod;\n\t}\n}\nll sol(int x,int y)\n{\n\tif (x==0) return s[y];\n\telse return (s[y]-s[x-1]+mod)%mod;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&H,&D);\n\tinit();\n\tf[0]=1; s[0]=1;\n\tfor (int i=1;i<=H;++i)\n\t{\n\t\tint x=max(0,i-D);\n\t\tf[i]=sol(x,i-1)*sum%mod;\n\t\tif (i==H) f[i]=sol(x,i-1)*doe%mod;\n\t\ts[i]=s[i-1]+f[i]; s[i]%=mod;\n\t}\n\tprintf(\"%lld\\n\",f[H]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\nconst int MOD=1e9+7;\nconst int N=1e6+10;\nint add(int a,int b){\n        int ans=(int)(((long long int)a+(long long int)b)%MOD);\n        if(ans<0)ans+=MOD;\n        return ans;\n}\nint mul(int a,int b){return (int)(((long long int)a*(long long int)b)%MOD);}\nint main(){\n        int n,h,d,f[N],ans,s[N],tot=0;\n        scanf(\"%d%d%d\",&n,&h,&d);\n        s[0]=0;\n        f[0]=1;\n        for(int i=1;i<=n;i++){\n                f[i]=mul(f[i-1],i);\n                tot=add(tot,f[i]);\n        }\n        for(int i=1;i<=d;i++)s[i]=add(f[n],mul(s[i-1],tot+1));\n        for(int i=d+1;i<=h;i++)s[i]=add(s[i-1],mul(add(s[i-1],-s[i-d-1]),tot));\n        ans=add(s[h],-s[h-1]);\n        printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nint dp[1000005];\n\nconst long long MOD = 1e9+7;\n\nint main(){\n    int N, H, D;\n    scanf(\"%d%d%d\", &N, &H, &D);\n\n    long long retainWays = 0;\n    long long fact = 1;\n    for(int i = 1; i <= N; i ++){\n        fact = fact*i%MOD;\n        retainWays += fact;\n    }\n    retainWays %= MOD;\n\n    //printf(\"retainWays=%lld\\n\", retainWays);\n\n    dp[0] = fact;\n    int slidingWindowSum = dp[0];\n    for(int i = 1; i < H; i ++){\n        dp[i] = slidingWindowSum*retainWays%MOD;\n\n        slidingWindowSum += dp[i];\n        if(i >= D){slidingWindowSum -= dp[i-D];}\n\n        if(slidingWindowSum >= MOD){slidingWindowSum -= MOD;}\n        else if(slidingWindowSum < 0){slidingWindowSum += MOD;}\n\n        //printf(\"dp[%d]=%lld\\n\", i, dp[i]);\n    }\n\n    printf(\"%d\", slidingWindowSum);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,a) for(int i=start[(a)];i;i=e[i].next)\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ninline int read()\n{\n    int sum=0,p=1;char ch=getchar();\n    while(!(('0'<=ch && ch<='9') || ch=='-'))ch=getchar();\n    if(ch=='-')p=-1,ch=getchar();\n    while('0'<=ch && ch<='9')sum=sum*10+ch-48,ch=getchar();\n    return sum*p;\n}\n\nconst int maxn=1e6+20;\nconst int mod=1e9+7;\n\ninline int power(int a,int b)\n{\n    int ans=1;\n    while(b)\n    {\n\tif(b&1)ans=(ll)ans*a%mod;\n\tb>>=1;\n\ta=(ll)a*a%mod;\n    }\n    return ans;\n}\n\nint n,m,d;\nint N1,N2;\n\ninline void init()\n{\n    n=read();m=read();d=read();\n    int jc=1;\n    REP(i,1,n)jc=(ll)jc*i%mod,N1=(N1+jc)%mod;\n    N2=jc;\n}\n\nint f[maxn];\n\ninline void doing()\n{\n    f[0]=1;\n    int s=1;\n    REP(i,1,m)\n    {\n\tif(i>d)s=(s-f[i-1-d]+mod)%mod;\n\tf[i]=(ll)s*N1%mod;\n\ts=(s+f[i])%mod;\n    }\n    f[m]=(ll)f[m]*power(N1,mod-2)%mod*N2%mod;\n    printf(\"%d\\n\",f[m]);\n}\n\nint main()\n{\n    init();\n    doing();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int INF=1e9;\nconst int MOD=1e9+7;\n//const int MOD=998244353;\nconst long long LINF=1e18;\nusing namespace std;\n#define int long long\n//template\nstd::vector<int> Factorial(1234567);\nvoid Cinit(){\n  Factorial[0]=1;\n  for(int i=1;i<1234567;i++)Factorial[i]=Factorial[i-1]*i%MOD;\n}\n//main\nsigned main(){\n  Cinit();\n  int N,H,D;cin>>N>>H>>D;\n  std::vector<int> wa(1234567);//階乗の累積和\n  wa[0]=0;for(int i=1;i<1234567;i++)wa[i]=(wa[i-1]+Factorial[i])%MOD;\n  int sum=0;\n  queue<int> que;\n  for(int i=0;i<=H;i++){\n    if(i==0){\n      sum+=Factorial[N];\n      que.push(sum);\n      continue;\n    }\n    if(que.size()>D){\n      int p=que.front();que.pop();\n      sum-=p;\n      if(sum<0)sum+=MOD;\n    }\n    if(i==H)cout<<sum<<endl;\n    que.push(sum*wa[N]%MOD);\n    sum+=sum*wa[N]%MOD;sum%=MOD;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n};\n\nusing modint = ModInt< mod >;\n\n\ntemplate< class T >\nstruct BinaryIndexedTree {\n  vector< T > data;\n\n  BinaryIndexedTree(int sz) {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k) {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret += data[k];\n    return (ret);\n  }\n\n  void add(int k, T x) {\n    for(++k; k < data.size(); k += k & -k) data[k] += x;\n  }\n};\n\n\nint main() {\n  int N, H, D;\n\n\n  cin >> N >> H >> D;\n  modint uku = 0, p = 1;\n  for(int i = 1; i <= N; i++) {\n    p *= i;\n    uku += p;\n  }\n\n  BinaryIndexedTree< modint > tap(N + 1);\n\n\n  modint beet = uku + 1;\n  modint mul = p;\n\n  BinaryIndexedTree< modint > bit(H + 1);\n\n  bit.add(1, mul);\n  for(int i = 2; i <= D; i++) { // D のところまでいく\n    mul *= beet;\n    bit.add(i, mul);\n  }\n  modint cur = mul;\n\n  if(H == D) {\n    cout << cur << endl;\n    exit(0);\n  }\n\n\n  for(int i = D + 1; i <= H; i++) {\n    modint sum;\n    sum = bit.sum(i);\n    sum -= bit.sum(i - D - 1);\n\n    sum *= uku;\n    bit.add(i, sum);\n\n    if(i == H) {\n      cout << sum << endl;\n    }\n\n\n  }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}T get(int i){return S[i+B];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpii factor(int N){vpii r;for(int i=2;i*i<=N;++i){if(N%i==0){r<<pii{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pii{N,1};}return r;}\nvl divisors(ll n){vl r;ll m=sqrt(n);foor(i,1,m)if(n%i==0)r<<ll(i);rf(i,r.size()-(m*m==n))r<<n/r[i];return r;}\nvi SuffixArray(str S){int N=S.size();vi rank(N+1),tmp(N+1),sa(N+1);fr(i,N){sa[i]=i;rank[i]=S[i];}sa[N]=N;rank[N]=-1;int k;auto cmp=[&](int&a,int&b)->bool{if(rank[a]!=rank[b])return rank[a]<rank[b];return (a+k<=N?rank[a+k]:-1)<(b+k<=N?rank[b+k]:-1);};for(k=1;k<=N;k*=2){sort(all(sa),cmp);tmp[sa[0]]=0;foor(i,1,N){tmp[sa[i]]=tmp[sa[i-1]]+cmp(sa[i-1],sa[i]);}rank=tmp;}return sa;};\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,H,D;cin>>N>>H>>D;\n\tll d=1,F=0;\n\tfoor(i,1,N){\n\t\t(F+=(d*=i)%=MD)%=MD;\n\t}\n\tvl s(H+2);\n\ts[1]=d;\n\tfoor(i,1,H){\n\t\td=(i==H?:F)*(s[i]-s[max(i-D,0)]+MD)%MD;\n\t\ts[i+1]=(s[i]+d)%MD;\n\t}\n\tprint(d);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//{\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double lf;\ntypedef pair<ll,ll> ii;\n#define REP(i,n) for(ll i=0;i<n;i++)\n#define REP1(i,n) for(ll i=1;i<=n;i++)\n#define FILL(i,n) memset(i,n,sizeof i)\n#define X first\n#define Y second\n#define SZ(_a) (int)_a.size()\n#define ALL(_a) _a.begin(),_a.end()\n#define pb push_back\n#ifdef brian\n#define debug(...) do{\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}while(0)\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\" ,\";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\ntemplate<typename It> ostream& _OUTC(ostream &_s,It _ita,It _itb)\n{\n    _s<<\"{\";\n    for(It _it=_ita;_it!=_itb;_it++)\n    {\n        _s<<(_it==_ita?\"\":\",\")<<*_it;\n    }\n    _s<<\"}\";\n    return _s;\n}\ntemplate<typename _a> ostream &operator << (ostream &_s,vector<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a> ostream &operator << (ostream &_s,set<_a> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _a,typename _b> ostream &operator << (ostream &_s,map<_a,_b> &_c){return _OUTC(_s,ALL(_c));}\ntemplate<typename _t> void pary(_t _a,_t _b){_OUTC(cerr,_a,_b);cerr<<endl;}\n#define IOS()\n#else\n#define debug(...)\n#define pary(...)\n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#endif // brian\n//}\n\n\nconst ll MAXn=1e6+5,MAXlg=__lg(MAXn)+2;\nconst ll MOD=1000000007;\nconst ll INF=ll(1e15);\n\nvoid add(ll &a, ll b)\n{\n    a += b;\n    if(a >= MOD) a -= MOD;\n}\nvoid sub(ll &a, ll b)\n{\n    a -= b;\n    if(a < 0)a += MOD;\n}\n\nll dp[MAXn], fac[MAXn];\n\nint main()\n{\n    IOS();\n    fac[0] = 1;\n    for(ll i = 1;i < MAXn;i ++)fac[i] = fac[i-1] * i % MOD;\n    ll N, H, D;\n    cin>>N>>H>>D;\n    dp[0] = 1;\n\n    ll tt = 1, factt = 0;\n    for(int i = 1;i <= N;i ++)add(factt, fac[i]);\n\n    for(int i = 1;i <= H;i ++)\n    {\n        if(i != H)dp[i] = tt * factt % MOD;\n        else dp[i] = tt * fac[N] % MOD;\n        if(i >= D)sub(tt, dp[i - D]);\n        add(tt, dp[i]);\n    }\n    cout<<dp[H]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a),i##formax=(b);i<i##formax;i++)\n#define FORR(i,a,b) for(int i=(a),i##formax=(b);i>=i##formax;i--)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define pcnt __builtin_popcount\n#define sz(x) (int)(x).size()\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define all(a) (a.begin()),(a.end())\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define perm(c) sort(all(c));for(bool c##p=1;c##p;c##p=next_permutation(all(c)))\n#define bitComb(a,n,k) for(int a##x,a##y,a=(1<<k)-1;a<(1<<n);a##x=a&-a,a##y=a+a##x,a=(((a&~a##y)/a##x)>>1)|a##y)\n#define uniq(v) sort(all(v));v.erase(unique(all(v)), v.end())\n#define bit(n) (1LL<<(n))\n#define randInt(l,r) (uniform_int_distribution<ll>(l,r)(rnd))\n#define randDouble(l,r) (uniform_real_distribution<double>(l,r)(rnd))\n#define dout(d) printf(\"%.12f\\n\",d)\n\ntypedef long long ll;\ntypedef __int128_t lll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T>using V=vector<T>;\ntemplate<class T>using VV=V<V<T>>;\ntemplate<class T,class Y>ostream& operator<<(ostream& o,const pair<T,Y>& p){return o<<\"(\"<<p.fi<<\", \"<<p.se<<\")\";}\ntemplate<typename A,size_t N,typename T>void Fill(A (&array)[N],const T&v){fill((T*)array,(T*)(array+N),v);}\nlll gcd(lll a,lll b,lll &x,lll &y){if(!b){x=1;y=0;return a;}lll d=gcd(b,a%b,y,x);y-=a/b*x;return d;}\nll gcd(ll a,ll b){lll x=0,y=0;return gcd(a,b,x,y);}\nll modInv(ll a,ll m){lll x,y;gcd(a,m,x,y);return (x%m+m)%m;}\nll modPow(lll a,lll n,ll m){if(!a)return a;lll p=1;for(;n>0;n>>=1,a=a*a%m)if(n&1)p=p*a%m;return(ll)p;}\nbool isPrime(ll n){if(n<2||n%2==0)return n==2;lll t=n-1,d=t/(t&-t);for(lll a:{2,325,9375,28178,450775,9780504,1795265022})if(a%n){for(t=d,a=modPow(a,t,n);t!=n-1&&a!=1&&a!=n-1;a=a*a%n,t=t*2%n);if(a!=n-1&&t%2==0)return 0;}return 1;}\nV<ll>fac,rfac;void setFac(int n, int mod){fac=rfac=V<ll>(++n);fac[0]=1;FOR(i,1,n)fac[i]=fac[i-1]*i%mod;rfac[n-1]=modInv(fac[n-1],mod);FORR(i,n-1,1)rfac[i-1]=rfac[i]*i%mod;}\nconst int IINF = 1e9+6;\nconst ll LINF = 1e18;\nconst int MOD = 1e9+7;\nconst double PI = acos(-1);\nconst double EPS = 1e-10;\nstatic random_device rd;\nstatic mt19937 rnd(rd());\n\nconst int N = 1e6;\nint n, h, d;\nll s, t, DP[N+1];\nmain(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  setFac(N, MOD);\n  cin >> n >> h >> d;\n  FOR(i, 1, n+1) s += fac[i];\n  s %= MOD;\n  DP[0] = 1;\n  FOR(i, 1, h+1){\n    t += DP[i-1];\n    if(i>d) t -= DP[i-d-1];\n    t %= MOD;\n    DP[i] = t*s%MOD;\n  }\n  (DP[h]+=MOD)%=MOD;\n  cout << DP[h]*fac[n]%MOD*modInv(s, MOD)%MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(a>b)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<endl;\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\n//ayasii\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\n#define SMOD\n\n#ifdef SMOD\ntemplate<uint mod>\n#else\nuint mod;\n#endif\nstruct ModInt{\n\t#ifdef SMOD\n\tstatic constexpr uint base=mod;\n\t#else\n\tstatic constexpr uint& base=mod;\n\t#endif\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll vv){\n\t\ts(vv%mod+mod);\n\t}\n\tModInt& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n\texplicit operator int()const{\n\t\treturn v;\n\t}\n\tbool operator==(const ModInt&rhs)const{\n\t\treturn v==rhs.v;\n\t}\n\tbool operator!=(const ModInt&rhs)const{\n\t\treturn v!=rhs.v;\n\t}\n\tModInt operator-()const{\n\t\treturn ModInt()-*this;\n\t}\n\tModInt& operator+=(const ModInt&rhs){\n\t\treturn s(v+rhs.v);\n\t}\n\tModInt&operator-=(const ModInt&rhs){\n\t\treturn s(v+mod-rhs.v);\n\t}\n\tModInt&operator*=(const ModInt&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tModInt&operator/=(const ModInt&rhs){\n\t\treturn *this*=rhs.inv();\n\t}\n\tModInt operator+(const ModInt&rhs)const{\n\t\treturn ModInt(*this)+=rhs;\n\t}\n\tModInt operator-(const ModInt&rhs)const{\n\t\treturn ModInt(*this)-=rhs;\n\t}\n\tModInt operator*(const ModInt&rhs)const{\n\t\treturn ModInt(*this)*=rhs;\n\t}\n\tModInt operator/(const ModInt&rhs)const{\n\t\treturn ModInt(*this)/=rhs;\n\t}\n\tfriend ModInt operator+(int x,const ModInt&y){\n\t\treturn ModInt(x)+y;\n\t}\n\tfriend ModInt operator-(int x,const ModInt&y){\n\t\treturn ModInt(x)-y;\n\t}\n\tfriend ModInt operator*(int x,const ModInt&y){\n\t\treturn ModInt(x)*y;\n\t}\n\tfriend ModInt operator/(int x,const ModInt&y){\n\t\treturn ModInt(x)/y;\n\t}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tModInt inv()const{\n\t\treturn pow(mod-2);\n\t}\n};\n\n#ifdef SMOD\ntemplate<uint mod>\nostream& operator<<(ostream&os,const ModInt<mod>&m){\n\treturn os<<m.v;\n}\ntemplate<uint mod>\nvoid print(const ModInt<mod>&m,int suc=1){\n\tprint(m.v,suc);\n}\n#else\nostream& operator<<(ostream&os,const ModInt&m){\n\treturn os<<m.v;\n}\nvoid print(const ModInt&m,int suc=1){\n\tprint(m.v,suc);\n}\n#endif\n\n#ifdef SMOD\nusing mint=ModInt<1000000007>;\n//using mint=ModInt<998244353>;\n#else\nusing mint=ModInt;\n#endif\n\nconst int Vmax=(1<<21)+10;\nmint fact[Vmax],factInv[Vmax],invs[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\trng(i,1,Vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfactInv[Vmax-1]=fact[Vmax-1].inv();\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1]*(i+1);\n\t}\n\tfor(int i=Vmax-1;i>=1;i--){\n\t\tinvs[i]=factInv[i]*fact[i-1];\n\t}\n}\n#ifdef SMOD\nstruct InitFactDummy{\n\tInitFactDummy(){\n\t\tInitFact();\n\t}\n} initFactDummy;\n#endif\nmint Choose(int n,int k){\n\treturn fact[n]*factInv[n-k]*factInv[k];\n}\nmint Binom(int a,int b){\n\treturn fact[a+b]*factInv[a]*factInv[b];\n}\nmint Catalan(int n){\n\treturn Binom(n,n)-(n-1>=0?Binom(n-1,n+1):0);\n}\n\n\nsigned main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,h,d;\n\tcin>>n>>h>>d;\n\tmint w;\n\trng(i,1,n+1)\n\t\tw+=fact[i];\n\tvc<mint> dp(h);\n\tdp[0]=1;\n\tvc<mint> s{0,1};\n\trng(i,1,h){\n\t\tdp[i]=(s[i]-s[max(i-d,int(0))])*w;\n\t\ts.pb(s.back()+dp[i]);\n\t}\n\tmint ans;\n\trng(i,1,d+1)\n\t\tans+=dp[h-i];\n\tcout<<ans*fact[n]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 1000111, mod = 1000000007;\n\nint mul(int x, int y) {\n    return (1LL * x * y) % mod;\n}\n\nint power(int a, int b) {\n    if (b == 0) {\n        return 1 % mod;\n    }\n    if (b % 2 == 0) {\n        return power(mul(a, a), b / 2);\n    }\n    return mul(a, power(a, b - 1));\n}\n\nint inv(int x) {\n    return power(x, mod - 2);\n}\n\nconst int max_f = 2 * max_n;\n\nint f[max_f], rf[max_f];\n\nvoid get_all_f() {\n    f[0] = rf[0] = 1;\n    for (int i = 1; i < max_f; ++i) {\n        f[i] = mul(i, f[i - 1]);\n    }\n    rf[max_f - 1] = inv(f[max_f - 1]);\n    for (int i = max_f - 2; i > 0; --i) {\n        rf[i] = mul(i + 1, rf[i + 1]);\n    }\n}\n\nint get_c(int n, int k) {\n    if (n < k) {\n        return 0;\n    }\n    return mul(f[n], mul(rf[k], rf[n - k]));\n}\n\nint get_x(int h, int cnt, int d) {\n    long long res = 0;\n    for (int i = 0; i * d <= h && i <= cnt; ++i) {\n        int add = mul(get_c(h - i * d + cnt - 1, cnt - 1), get_c(cnt, i));\n        if (i % 2) {\n            add *= -1;\n        }\n        res += add;\n    }\n    res %= mod;\n    res += mod;\n    res %= mod;\n    return res;\n}\n\nint n, h, d;\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    get_all_f();\n    cin >> n >> h >> d;\n    int k = f[n];\n    int k2 = 0;\n    for (int i = 1; i <= n; ++i) {\n        k2 = (k2 + f[i]) % mod;\n    }\n    int ans = 0;\n    for (int cnt = 1; cnt <= h; ++cnt) {\n        int H = h - cnt;\n        int x = get_x(H, cnt, d);\n        ans += mul(k, x);\n        ans %= mod;\n        k = mul(k, k2);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define N 200005\n#define rank Rank\n#define index Index\nLL dp[1000005];\nint mod=1e9+7;\nLL fra[1000005];\nint main(){\n    int n,h,d;\n    scanf(\"%d %d %d\",&n,&h,&d);\n    fra[0]=1;\n    LL ssum=0;\n    for(int i =1;i<=n;i++){\n        fra[i]=fra[i-1]*i%mod;\n        ssum+=fra[i];\n        ssum%=mod;\n    }\n    dp[0]=fra[n];\n    queue<LL> q;\n    LL sum=dp[0];\n    q.push(dp[0]);\n    for(int i=1;i<h;i++){\n        //for(int k = 0;k<n;k++)\n        dp[i]=sum*ssum%mod;\n        q.push(dp[i]);\n        sum+=dp[i];\n        if(q.size()>d){\n            sum-=q.front();\n            q.pop();\n        }\n        sum = (sum%mod+mod)%mod;\n        /*for(int j=1;j<=d;j++){\n            if(i-j>=0){\n                dp[i]+=dp[i-j]*sum;\n                dp[i]%=mod;\n            }\n        }*/\n    }\n    LL ans=0;\n    for(int j=1;j<=d;j++){\n        if(h-j>=0){\n            ans+=dp[h-j];\n            ans%=mod;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MAXN = 1e6+210;\nll M = 1e9+7;\nll powM(ll b, ll p) {\n  if (p==0) return 1;\n  ll ans = powM(b, p/2);\n  ans = ans*ans%M;\n  if (p%2) ans*=b;\n  return ans%M;\n}\nll inv(ll a)  {\n  return powM(a, M-2);\n}\nll fact[MAXN], invf[MAXN];\n\nll dp[MAXN], any[MAXN];\n\nll n, h, d;\n\nint main(){\n  cin.tie(0); ios_base::sync_with_stdio(0);\n  fact[0] = invf[0] = 1;\n  for(ll i = 1;i<MAXN;i++) {\n    fact[i] = fact[i-1]*i%M;\n    invf[i] = inv(fact[i]);\n  }\n  cin >> n >> h >> d;\n  ll magic = 0;\n  for(int j=1;j<=n;j++) {\n    magic = (magic+fact[j])%M;\n  }\n  //cerr << \"MAGIC IS \" << magic <<endl;\n  dp[h] = inv(magic);\n  ll cum = dp[h];\n  for(int i=h-1;i>=0;i--) {\n    dp[i] = magic*cum%M;\n    cum+=dp[i];\n    //cerr << i << \" \" << dp[i] << \" \" << cum <<endl;\n    if (i+d<=h) cum= (cum -dp[i+d]+M)%M;\n    cum = (cum+M)%M;\n  }\n  cout << (dp[0]*fact[n]%M+M)%M <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n#define sqr(a) ((a) * (a))\n#define sz(a) int(a.size())\n#define all(a) a.begin(), a.end()\n#define forn(i, n) for(int i = 0; i < int(n); i++) \n#define fore(i, l, r) for(int i = int(l); i < int(r); i++)\n\ntypedef long long li;\ntypedef long double ld;\ntypedef pair<int, int> pt;\n\ntemplate <class A, class B> ostream& operator << (ostream& out, const pair<A, B> &a) {\n\treturn out << \"(\" << a.x << \", \" << a.y << \")\";\n}\n\ntemplate <class A> ostream& operator << (ostream& out, const vector<A> &v) {\n\tout << \"[\";\n\tforn(i, sz(v)) {\n\t\tif(i) out << \", \";\n\t\tout << v[i];\n\t}\n\treturn out << \"]\";\n}\n\nmt19937 rnd(time(NULL));\n\nconst int INF = int(1e9);\nconst li INF64 = li(1e18);\nconst int MOD = INF + 7;\nconst ld EPS = 1e-9;\nconst ld PI = acos(-1.0);\n\nconst int N = 1000 * 1000 + 13;\n\nint n, h, d;\n\nbool read () {\n\tif (scanf(\"%d%d%d\", &n, &h, &d) != 3)\n\t\treturn false;\n\treturn true;\n}\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n\tif (a < 0)\n\t\ta += MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn (a * li(b)) % MOD;\n}\n\nint dp[N];\nint pr[N];\n\nint get(int l, int r){\n\treturn add(pr[r + 1], -pr[l]);\n}\n\nint fact[N];\nint prfact[N];\n\nvoid solve() {\n\tfact[0] = 1;\n\tprfact[1] = 0;\n\tfore(i, 1, N - 1){\n\t\tfact[i] = mul(fact[i - 1], i);\n\t\tprfact[i + 1] = add(prfact[i], fact[i]);\n\t}\n\tdp[0] = fact[n];\n\tpr[1] = dp[0];\n\tfore(i, 1, h + 1){\n\t\tdp[i] = mul(prfact[n + 1], get(max(0, i - d), i - 1));\n\t\tpr[i + 1] = add(pr[i], dp[i]);\n\t}\n\tprintf(\"%d\\n\", get(h - d, h - 1));\n}\n\nint main() {\n#ifdef _DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\t\n\tint tt = clock();\n\t\n#endif\n\t\n\tcerr.precision(15);\n\tcout.precision(15);\n\tcerr << fixed;\n\tcout << fixed;\n\n#ifdef _DEBUG\n\twhile(read()) {\t\n#else\n\tif (read()){\n#endif\n\t\tsolve();\n\t\t\n#ifdef _DEBUG\n\tcerr << \"TIME = \" << clock() - tt << endl;\n\ttt = clock();\n#endif\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define pb push_back\n#define eb emplace_back\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nstruct handler{\n    typedef ll val_t;\n    typedef ll opr_t;\n    handler(){}\n    val_t def_val(){ return 0ll; }\n    static val_t update(const val_t &l, const opr_t &r){\n        return (l + r) % MOD;\n    }\n    static val_t merge(const val_t &l, const val_t &r){\n        return (l + r) % MOD;\n    }\n};\n\ntemplate<typename Handler>\nstruct SegTree{\n    typedef typename Handler::val_t val_t;\n    typedef typename Handler::opr_t opr_t;\n    vector<val_t> val;\n    Handler hdl;\n    int n;\n\n    SegTree(int size):hdl(){\n        n=1;\n        while(n<size) n<<=1;\n        val=vector<val_t>(2*n, hdl.def_val());\n    }\n    SegTree(const vector<val_t> &in):hdl(){\n        n=1;\n        while(n<in.size()) n<<=1;\n        val=vector<val_t>(2*n, hdl.def_val());\n        for(int i=n-1 + in.size()-1;i>=0;i--){\n            if(n-1 <= i) val[i] = in[i - (n-1)];\n            else val[i] = hdl.merge(val[i*2+1],val[i*2+2]);\n        }\n    }\n    void update(int i, const opr_t& a){\n        i += n-1;\n        val[i] = hdl.update(val[i], a);\n        while(i > 0){\n            i = (i-1)/2;\n            val[i] = hdl.merge(val[i*2+1],val[i*2+2]);\n        }\n    }\n    val_t query(int a,int b,int k,int l,int r){\n        if(r<=a||b<=l) return hdl.def_val();\n        if(a<=l&&r<=b) return val[k];\n        return hdl.merge(query(a, b, k*2+1, l, (l+r)/2),\n                         query(a, b, k*2+2, (l+r)/2, r)\n        );\n    }\n    val_t query(int a, int b){return query(a, b, 0, 0, n);}\n    val_t operator[](size_t i){return query(i, i+1);}\n    friend ostream& operator<<(ostream &os, SegTree<Handler> &t){\n        REP(i, t.n) os << (i ? \", \" : \"[\") << t.query(i, i+1);\n        return os << \"]\";\n    }\n};\n\nint T, N, H, D;\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    while(cin >> N >> H >> D){\n        ll perm = 1, sum = 0;\n        REPS(i, N) {\n            perm = perm * i % MOD;\n            sum += perm;\n        }\n        sum %= MOD;\n        SegTree<handler> seg(H);\n        seg.update(0, perm);\n        REPS(i, H - 1) {\n            seg.update(i, seg.query(max(0, i - D), i) * sum % MOD);\n        }\n        cout << seg.query(max(0, H - D), H) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong N,H,D,mod=1e9+7;\nlong dp[1<<20];\nmain()\n{\n\tcin>>N>>H>>D;\n\tlong s=0,p=1;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tp=p*i%mod;\n\t\ts=(s+p)%mod;\n\t}\n\tlong now=0;\n\tfor(int i=1;i<=H;i++)\n\t{\n\t\tdp[i]=(now*s+p*(i<=D))%mod;\n\t\tnow=(now+dp[i])%mod;\n\t\tif(i>=D)now=(now-dp[i-D]+mod)%mod;\n\t}\n\tcout<<dp[H]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repr(i, n) for (int i = (int)(n) - 1; i >= 0; i--)\n#define range(a) a.begin(), a.end()\nusing namespace std;\nusing ll = long long;\n\nconst int MOD = 1000000007;\n\nstruct mint {\n  int n;\n  mint(int n_ = 0) : n(n_) {}\n};\n\nmint operator-(mint a) {\n  return -a.n + MOD * (a.n != 0);\n}\nmint operator+(mint a, mint b) {\n  int x = a.n + b.n;\n  return x - (x >= MOD) * MOD;\n}\nmint operator-(mint a, mint b) {\n  int x = a.n - b.n;\n  return x + (x < 0) * MOD;\n}\nmint operator*(mint a, mint b) {\n  return (long long)a.n * b.n % MOD;\n}\nmint &operator+=(mint &a, mint b) { return a = a + b; }\nmint &operator-=(mint &a, mint b) { return a = a - b; }\nmint &operator*=(mint &a, mint b) { return a = a * b; }\nistream &operator>>(istream &i, mint &a) { return i >> a.n; }\nostream &operator<<(ostream &o, mint a) { return o << a.n; }\n\nvoid naive() {\n  static mint dp[50][50];\n  int N, H, D;\n  cin >> N >> H >> D;\n  dp[0][N] = 1;\n  for (int i = 0; i <= H; i++) {\n    for (int j = 0; j <= N; j++) {\n      for (int k = i + 1; k <= min(H, i + D); k++) {\n        dp[k][1] += dp[i][j];\n      }\n      if (j < N) {\n        dp[i][j + 1] += dp[i][j] * (j + 1);\n      }\n    }\n  }\n  cout << dp[H][N] << endl;\n}\n\nint main() {\n  int N, H, D;\n  cin >> N >> H >> D;\n  mint f = 1;\n  mint s = 0;\n  for (int i = 1; i <= N; i++) {\n    f *= i;\n    s += f;\n  }\n  vector<mint> dp(H + 2); // dp[i][1]\n  dp[1] += 1;\n  dp[D + 1] -= 1;\n  for (int i = 1; i < H; i++) {\n    dp[i + 1] += dp[i];\n    int l = i + 1;\n    int r = min(H + 1, i + D + 1);\n    dp[l] += dp[i] * s;\n    dp[r] -= dp[i] * s;\n  }\n  mint ans = dp[H] * f;\n  cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define xx first\n#define yy second\n\nusing namespace std;\nconst ll mod = 1e9 + 7, N = 1000000 + 5;\nll dp[N], fac[N];\nll sum, l, n, d, h, now;\n\ninline ll add (ll m, ll n) {\n\tll k = (m + n);\n\treturn k >= mod ? k - mod : k;\n}\n\ninline ll sub(ll m, ll n) {\n\tll k = m - n;\n\treturn k < 0 ? k + mod : k;\n}\n\ninline ll mul (ll m, ll n) {\n\tll k = m * n;\n\tk %= mod;\n\treturn k;\n}\n\ninline ll qpow (ll m, ll n) {\n\tll tot = 1, base = m;\n\twhile (n) {\n\t\tif (n % 2 == 1) {\n\t\t\ttot = mul (tot, base);\n\t\t}\n\t\tbase = mul (base, base);\n\t\tn /= 2;\n\t}\n\treturn tot;\n}\n\nint main () {\n\t#ifdef wll\n\tfreopen (\"testdata.in\", \"r\", stdin);\n\t#endif\n\tcin >> n >> h >> d;\n\tfac[1] = 1;\n\tfor (int i = 2; i <= 1000000; ++i) {\n\t\tfac[i] = mul (fac[i - 1], i);\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tsum = add (sum, fac[i]);\n\t}\n\tdp[0] = 1;\n\tnow = 1;\n\tfor (int i = 1; i <= h; ++i) {\n\t\tif (l < i - d) {\n\t\t\tnow = sub (now, dp[l]);\n\t\t\t++l;\n\t\t}\n\t\tdp[i] = mul (now, sum);\n\t\tnow = add (now, dp[i]);\n\t}\n\tcout << mul (dp[h], mul (fac[n], qpow (sum, mod - 2))) << endl;\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 1e6+10, mod = 1e9+7;\nint n,h,d,sum,fac[N],f[N],pre[N];\n\ninline int Mod(int x){\n\treturn x>=mod?x-mod:x;\n}\ninline int power(int a,int b){\n\tint ret=1;\n\tfor (;b;b>>=1,a=1ll*a*a%mod) if (b&1) ret=1ll*ret*a%mod;\n\treturn ret;\n}\n\ninline int Query(int l,int r){\n\tint ret=pre[r];\n\tif (l>0) ret=Mod(ret+mod-pre[l-1]);\n\treturn ret;\n}\n\nint main(){\n\tn=read(),h=read(),d=read();\n\tfac[0]=1;\n\tFor(i,1,n) fac[i]=1ll*fac[i-1]*i%mod,sum=Mod(sum+fac[i]);\n\tf[0]=fac[n],pre[0]=f[0];\n\tFor(i,1,h){\n\t\tf[i]=1ll*Query(max(0,i-d),i-1)*sum%mod;\n\t\tpre[i]=Mod(pre[i-1]+f[i]);\n\t}\n\tprintf(\"%d\\n\",1ll*f[h]*power(sum,mod-2)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (long long i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (long long i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n  {1, 0}, {0, 1}, {-1, 0}, {0, -1},  // 4方向\n  {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n  {0, 0},  // 自身\n};\ntemplate <class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T, class S> vector<T> make_vec(size_t n, S x) { return vector<T>(n, x); }\ntemplate <class T, class... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec<T>(ts...))>(n, make_vec<T>(ts...)); }\n\n// debug\ntemplate <class T> ostream& operator<<(ostream& s, vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream& s, vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, unordered_map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n  #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n  #define dump(...)\n  #define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\n\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 1000000007;\n// *************** TEMPLATE END *************** \n\ntemplate <class T>\nT pow(T x, int n, const T UNION = 1) {\n  T ret = UNION;\n  while (n) {\n    if (n & 1) ret *= x;\n    x *= x; n >>= 1;\n  }\n  return ret;\n}\n\ntemplate <int MD>\nstruct ModInt {\n  int x;\n  static unordered_map<int, int> to_inv;\n  ModInt() : x(0) {}\n  ModInt(int x_) { if ((x = x_ % MD + MD) >= MD) x -= MD; }\n\n  ModInt& operator+=(ModInt that) { if ((x += that.x) >= MD) x -= MD; return *this; }\n  ModInt& operator*=(ModInt that) { x = (unsigned long long)x * that.x % MD; return *this; }\n  ModInt& operator-=(ModInt that) { if ((x -= that.x) < 0) x += MD; return *this; }\n  ModInt& operator/=(ModInt that) { x = (unsigned long long)x * that.inv().x % MD; return *this; }\n\n  ModInt operator-() const { return -x < 0 ? MD - x : -x; }\n  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n  bool operator==(ModInt that) const { return x == that.x; }\n  bool operator!=(ModInt that) const { return x != that.x; }\n  ModInt inv() const { return to_inv.count(this->x) ? to_inv[this->x] : (to_inv[this->x] = pow(*this, MD - 2).x); }\n  friend ostream& operator<<(ostream& s, ModInt<MD> a) { s << a.x; return s; }\n  friend istream& operator>>(istream& s, ModInt<MD>& a) { s >> a.x; return s; }\n};\ntemplate <int MD> unordered_map<int, int> ModInt<MD>::to_inv;\nusing mint = ModInt<MOD>;\n\nvector<mint> fact, fact_inv;\nvoid init_factorial(int n) {\n  fact = vector<mint>(n + 1, 1);\n  fact_inv = vector<mint>(n + 1);\n  for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n  fact_inv[n] = mint(1) / fact[n];\n  for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n  // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n}\nmint comb(int n, int r) {\n  return fact[n] * fact_inv[r] * fact_inv[n - r];\n}\n\n// T0: 元の配列のモノイド\n// T1: T0に対する作用素モノイド\ntemplate <class T0, class T1>\nclass SegmentTree {\n  // k番目のノードにのlazyを伝搬\n  void eval(int k, int len) {\n    // u1が正確に単位元ならいらない\n    // if (lazy[k] == u1) return;\n    // len個分のlazy[k]を評価\n    node[k] = g(node[k], p(lazy[k], len));\n    if (k < N - 1) {\n      // 最下段でなければ下のlazyに伝搬\n      lazy[2 * k + 1] = f1(lazy[2 * k + 1], lazy[k]);\n      lazy[2 * k + 2] = f1(lazy[2 * k + 2], lazy[k]);\n    }\n    lazy[k] = u1;\n  }\n  // k番目のノード[l, r)について、[a, b)の範囲内にxを作用\n  void update(int a, int b, T1 x, int k, int l, int r) {\n    eval(k, r - l);\n    if (b <= l || r <= a) return;\n    if (a <= l && r <= b) {\n      lazy[k] = f1(lazy[k], x);\n      eval(k, r - l);\n    } else {\n      update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n      update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n      node[k] = f0(node[2 * k + 1], node[2 * k + 2]);\n    }\n  }\n  // k番目のノード[l, r)について、[a, b)のクエリを求める\n  T0 query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return u0;\n    eval(k, r - l);\n    if (a <= l && r <= b) return node[k];\n    T0 vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n    T0 vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n    return f0(vl, vr);\n  }\npublic:\n  int sz; // 元の配列のサイズ\n  int N;\n  vector<T0> node;\n  vector<T1> lazy;\n  // T0上の演算、単位元\n  using F0 = function<T0(T0, T0)>;\n  F0 f0; T0 u0;\n  // T1上の演算、単位元\n  using F1 = function<T1(T1, T1)>;\n  F1 f1; T1 u1;\n  // 作用\n  using G = function<T0(T0, T1)>;\n  G g;\n  // 多数のt1(T1)に対するf1の合成\n  using P = function<T1(T1, int)>;\n  P p;\n  SegmentTree(const vector<T0>& a, F0 f0, T0 u0, F1 f1, T1 u1, G g, P p)\n  : sz(a.size()), f0(f0), u0(u0), f1(f1), u1(u1), g(g), p(p) {\n    for (N = 1; N < sz; N *= 2);\n    node.resize(2 * N - 1);\n    lazy.resize(2 * N - 1, u1);\n    REP (i, sz) node[N - 1 + i] = a[i];\n    for (int i = N - 2; i >= 0; i--) node[i] = f0(node[2 * i + 1], node[2 * i + 2]);\n  }\n  // [a, b)にxを作用\n  void update(int a, int b, T1 x) {\n    assert(0 <= a && a < b && b <= sz);\n    update(a, b, x, 0, 0, N);\n  }\n  void update(int a, T1 x) {\n    update(a, a + 1, x);\n  }\n  // [a, b)\n  T0 query(int a, int b) {\n    return query(a, b, 0, 0, N);\n  }\n  T0 query(int a) {\n    return query(a, a + 1);\n  }\n};\n\nsigned main() {\n  int n, H, D; cin >> n >> H >> D;\n  init_factorial(n + 10);\n  mint mul = 0;\n  REPI (i, 1, n + 1) {\n    mul += fact[i];\n  }\n\n  // Sum & Add\n  SegmentTree<mint, mint> seg(\n    vector<mint>(H + 1, 0),\n    plus<mint>(), 0,\n    plus<mint>(), 0,\n    plus<mint>(),\n    multiplies<mint>()\n  );\n  seg.update(0, fact[n] / mul);\n  REP (i, H) {\n    mint now = seg.query(i);\n    seg.update(i + 1, min(H + 1, i + D + 1), now * mul);\n  }\n  cout << seg.query(H) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long li;\n\n\ntemplate <long long mod>\nstruct modint {\n    long long x;\n\n    modint<mod>(): x(0LL) {}\n    modint<mod>(const long long _data) {\n        if (_data < 0) {\n            x = (_data % mod + mod) % mod;\n        } else if (_data >= mod) {\n            x = _data % mod;\n        } else {\n            x = _data;\n        }\n    }\n\n    bool operator==(const modint<mod>& op) const {\n        return x == op.x;\n    }\n\n    bool operator!=(const modint<mod>& op) const {\n        return !((*this) == op);\n    }\n\n    modint<mod> operator-() const {\n        if (x == 0) {\n            return modint(0);\n        }\n        return modint(mod - x);\n    }\n\n    modint<mod> operator+(const modint<mod>& op) const {\n        const long long newdata = x + op.x;\n        if (newdata >= mod) {\n            return modint<mod>(newdata - mod);\n        } else {\n            return modint<mod>(newdata);\n        }\n    }\n\n    modint<mod> operator-(const modint<mod>& op) const {\n        return *this + (-op);\n    }\n\n    modint<mod> operator*(const modint<mod>& op) const {\n        return modint<mod>(x * op.x % mod);\n    }\n\n    modint<mod> pow(const long long n) const {\n        if (n == 0) {\n            return modint<mod>(1);\n        }\n        modint<mod> sq = pow(n / 2);\n        if (n & 1) {\n            return (*this) * sq * sq;\n        } else {\n            return sq * sq;\n        }\n    }\n\n    modint<mod> inverse() const {\n        return pow(mod - 2);\n    }\n\n    modint<mod> operator/(const modint<mod>& op) const {\n        return (*this) * op.inverse();\n    }\n\n    friend modint<mod> operator/(const long long dividend, const modint<mod>& divisor) {\n        return modint<mod>(dividend) / divisor;\n    }\n\n    static modint<mod> factorial(const long long n) {\n        static std::vector<modint<mod>> cache(1, 1);\n\n        while (cache.size() <= n) {\n            modint<mod> next = cache.back() * cache.size();\n            cache.push_back(next);\n        }\n        return cache[n];\n    }\n\n    static modint<mod> combination(const long long n, const long long k) {\n        if (k < 0 || n < k) {\n            return modint<mod>(0);\n        }\n\n        if (n < 1e6) {\n            return factorial(n) / (factorial(k) * factorial(n - k));\n        }\n\n        modint<mod> ret(1);\n        for (int i = 1; i <= k; ++i) {\n            ret = ret * modint<mod>(n - i + 1) / modint<mod>(i);\n        }\n        return ret;\n    }\n};\n\ntypedef modint<1000000007> mint;\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    li n, h, d;\n    cin >> n >> h >> d;\n\n    mint factsum = 0;\n    for (int i = 0; i < n; ++i) {\n        factsum = factsum + mint::factorial(i + 1);\n    }\n\n    vector<mint> dp(h + 1);\n    dp[0] = mint::factorial(n);\n\n    mint prevsum = dp[0];\n    queue<mint> q;\n    q.push(dp[0]);\n    for (int i = 1; i <= h; ++i) {\n        while (q.size() > d) {\n            prevsum = prevsum - q.front();\n            q.pop();\n        }\n        dp[i] = prevsum * factsum;\n\n        q.push(dp[i]);\n        prevsum = prevsum + dp[i];\n    }\n\n    cout << (dp[h] / factsum).x << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cmath>\n#include <tuple>\n#define rep(i, n) for(i = 0; i < n; i++)\n#define int long long\nusing namespace std;\n\nint mod = 1000000007;\n\nconst int DEPTH = 20;\nstruct SegTree {\n\tint d[1 << (DEPTH + 1)];\n\tSegTree() {\n\t\tint i;\n\t\trep(i, (1 << (DEPTH + 1))) d[i] = 0;\n\t}\n\tvoid add(int l, int r, int x, int a = 0, int b = (1 << DEPTH), int id = 0) {\n\t\tif (a >= r || b <= l) return;\n\t\tif (l <= a && b <= r) { d[id] += x; d[id] %= mod; return; }\n\t\tadd(l, r, a, (a + b) / 2, id * 2 + 1);\n\t\tadd(l, r, (a + b) / 2, b, id * 2 + 2);\n\t}\n\tint getNum(int id) {\n\t\tid += (1 << DEPTH) - 1;\n\t\tint ret = d[id];\n\t\twhile (id > 0) {\n\t\t\tid = (id - 1) / 2;\n\t\t\tret += d[id];\n\t\t\tret %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint n, h, d;\nSegTree seg;\nint fact[1000001];\nint rfact[1000001];\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n >> h >> d;\n\t\n\tfact[0] = 1;\n\trep(i, n) fact[i + 1] = (i + 1) * fact[i] % mod;\n\t\n\trfact[0] = 1;\n\tfor (i = 1; i < n; i++) {\n\t\trfact[i] = rfact[i - 1] + fact[i];\n\t}\n\t\n\tseg.add(1, d + 1, 1);\n\trep(i, h - 1) {\n\t\tif (i == 0) continue;\n\t\tint a = seg.getNum(i);\n\t\tseg.add(i + 1, min(h + 1, i + d + 1), rfact[n] * a % mod);\n\t}\n\tcout << seg.getNum(h) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n    fact.resize(n+1);\n    inv.resize(n+1);\n    invfact.resize(n+1);\n    fact[0]=inv[0]=invfact[0]=1;\n    inv[1]=1;\n    rep(i,n){\n        fact[i+1]=fact[i]*(i+1)%mod;\n        if(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n        invfact[i+1]=invfact[i]*inv[i+1]%mod;\n    }\n}\nll perm(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n    k%=mod-1;\n    if(k<0)k+=mod-1;\n    ll ret=1;\n    while(k){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\n\ntemplate<typename T>\nstruct SegmentTree{\nprivate:\n    int n;\n    T E;\n    vector<T> node;\n    inline void updatef(T& x,T& y){\n        x = y;\n        //x += y;\n        //x = max(x,y);\n        //x = min(x,y);\n    }\n    inline T queryf(T& x,T& y){\n        return (x+y)%mod;\n        //return x+y;\n        //return max(x,y);\n        //return min(x,y);\n    }\n\npublic:\n    SegmentTree(int sz,T E_):E(E_){\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n    }\n\n    SegmentTree(vector<T>& A,T E_):E(E_){\n        int sz=A.size();\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n        rep(i,sz)node[i+n-1]=A[i];\n        for(int i=n-2;i>=0;--i){\n            node[i]=queryf(node[2*i+1], node[2*i+2]);\n        }\n    }\n    void update(int k,T x){\n        k+=n-1;\n        updatef(node[k],x);\n        while(k>0){\n            k=(k-1)/2;\n            node[k]=queryf(node[2*k+1], node[2*k+2]);\n        }\n    }\n       //[a,b)での和を返す\n    T get(int a,int b,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        if(r<=a||b<=l)return E;\n        if(a<=l&&r<=b)return node[k];\n        T xl=get(a,b,2*k+1,l,(l+r)/2);\n        T xr=get(a,b,2*k+2,(l+r)/2,r);\n        return queryf(xl, xr);\n    }\n};\nint main(){\n    int n,h,d;\n    cin>>n>>h>>d;\n    mod_build(1234567);\n    vector<ll> dp(h+1);\n    ll mul = 0;\n    rep(i,n)mul+=fact[i+1];\n    mul%=mod;\n    dp[0]=fact[n]*powmod(mul,mod-2)%mod;\n    rep(i,h){\n        ll ret = dp[i];\n        if(i>=d)ret += mod - dp[i-d];\n        ret = ret*mul%mod;\n        dp[i+1]=(dp[i]+ret)%mod;\n    }\n    cout<<(dp[h]-dp[h-1]+mod)%mod<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define _for(i,j,N) for(int i = (j);i < (N);i++)\n#define _rep(i,j,N) for(int i = (j);i <= (N);i++)\n#define _dec(i,N,j) for(int i = (N-1);i >= (j);i--)\n#define _rec(i,N,j) for(int i = (N);i >=(j);i--)\n#define ALL(x) x.begin(),x.end()\n#define MEM(a,n) memset(a,n,sizeof(a))\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\nint get_int(){int x;scanf(\"%d\",&x);return x;}\nLL get_ll(){LL x;scanf(\"%lld\",&x);return x;}\ndouble get_db(){double x;scanf(\"%lf\",&x);return x;}\n\ntemplate<typename T> int chmin(T &a,T &b){if(a > b){a = b;return 1;}else return 0;}\ntemplate<typename T> int chmax(T &a,T &b){if(a < b){a = b;return 1;}else return 0;}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& v) {_for(i,0,v.size()) os << v[i] << \" \";return os;}\ntemplate<typename T>\nostream& operator<<(ostream& os,const set<T>& v){for(auto a:v) os << a <<\" \";return os;}\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& v){os << v.fst <<\" \"<<v.scd << \" \";return os;}\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const map<T1,T2>& v){for(auto a:v) cout << a << endl;return os;}\n\nstatic const int dx[8] = { 1,  0, -1,  0,  1, -1,  1, -1};\nstatic const int dy[8] = { 0,  1,  0, -1,  1, -1, -1,  1};\nconst double pi  = acos(-1.0);\nconst double eps = 1e-8;\nconst LL  INF  = 0x3f3f3f3f3f3f3f3f;\nconst int inf  = 0x3f3f3f3f;\nconst int mod = 1e9+7;\n\n\nconst int maxn = 1e6+5;\nint N,H,D;\nint facN;\nint mult(LL x,LL y){return x*y%mod;}\nint add(LL x,LL y){return (x+y)%mod;}\nint sub(LL x,LL y){return (x-y+mod)%mod;}\nint dp[maxn];\nint sumN[maxn];\nint sumdp[maxn];\n\nint fpow(int a,int p){\n    if(p == 0) return 1;\n    int ret = fpow(a,p/2);\n    ret = mult(ret,ret);\n    if(p&1) ret = mult(ret,a);\n    return ret;\n}\n\nint searching(int n){\n    dp[0] = 1;\n    sumdp[0] = 0;\n\n    _rep(i,1,n){\n        int k;\n        if(i - D <= 0){\n            k = sumdp[i-1];\n            dp[i] = mult(sumN[N],k);\n            dp[i] = add(dp[i],1);\n        }\n        else{\n            k = sub(sumdp[i-1],sumdp[i - D -1]);\n            dp[i] = mult(k,sumN[N]);\n        }\n        sumdp[i] = add(sumdp[i-1],dp[i]);\n    }\n\n    return mult(dp[n],facN);\n}\n\nint main(){\n    cin >> N >> H >> D;\n    facN = 1;\n    _rep(i,1,N){\n        facN = mult(i,facN);\n        sumN[i] = add(sumN[i-1],facN);\n    }\n    cout << searching(H) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\ntypedef long long LL;\nconst int N=1000005,mod=1000000007;\nint n,h,d;\nLL flv[N],f[N];\n\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&d);\n\tflv[0]=1;\n\trep(i,1,n) flv[i]=flv[i-1]*i%mod;\n\tf[0]=flv[n];\n\tLL sum=flv[n],tot=0;\n\trep(i,1,n) tot=(tot+flv[i])%mod;\n\trep(i,1,h-1)\n\t{\n\t\tf[i]=sum*tot%mod;\n\t\tsum=(sum+f[i])%mod;\n\t\tif(i-d>=0) sum=(sum-f[i-d]+mod)%mod;\n\t}\n\tprintf(\"%lld\\n\",sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=1000005;\nconst int MOD=1000000007;\nint n,h,d;\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nlong long fac,sum;\nlong long s[N],f[N];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&d);\n\tfac=1;\n\tfor(int i=1;i<=n;i++)\n\t\tfac=fac*i%MOD,sum=(sum+fac)%MOD;\n\ts[0]=f[0]=1;\n\tfor(int i=1;i<=h+1;i++)\n\t{\n\t\tlong long p=(s[i-1]-(i-d-1>=0?s[i-d-1]:0)+MOD)%MOD;\n\t\tf[i]=p*sum%MOD;\n\t\ts[i]=(s[i-1]+f[i])%MOD;\n\t}\n\tprintf(\"%lld\",f[h]*fac%MOD*ksm(sum,MOD-2)%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+5,mod=1e9+7;\ntypedef long long ll;\nll f[N],sumf[N],dp[N],sumdp[N];\nll inv(ll x){return x==1?x:(mod-mod/x)*inv(mod%x)%mod;}\nint n,h,d;\nint main()\n{\n    f[0]=1;\n    for(int i=1;i<N;i++) f[i]=f[i-1]*i%mod,sumf[i]=(sumf[i-1]+f[i])%mod;\n    scanf(\"%d%d%d\",&n,&h,&d);\n    dp[0]=1;sumdp[0]=1;\n    for(int i=1;i<=h;i++)\n    {\n        if(i-d-1>=0)\n        dp[i]=(sumdp[i-1]-sumdp[i-d-1])*sumf[n]%mod;\n    else dp[i]=sumdp[i-1]*sumf[n]%mod;\n        sumdp[i]=(sumdp[i-1]+dp[i])%mod;\n    }\n    ll ans=dp[h]*f[n]%mod*inv(sumf[n])%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll modminus(ll x, ll y) {\n    return (x - y + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll modpower(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y == 1) {\n        return x % mod;\n    } else if (y % 2 == 0) {\n        ll p = modpower(x, y / 2);\n        return p * p % mod;\n    } else {\n        ll p = modpower (x, y / 2);\n        return (p * p) % mod * (x % mod) % mod;\n    }\n}\n\nll divide(ll x, ll y) {\n    return multiply(x, modpower(y, mod - 2));\n}\n\nll frac[1000000];\nll invfrac[1000000];\n\nvoid fracinvfrac(ll n) {\n    frac[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        frac[i] = multiply(frac[i - 1], i);\n    }\n    invfrac[n] = divide(1, frac[n]);\n    for (int i = n - 1; i >= 0; i--) {\n        invfrac[i] = multiply(invfrac[i + 1], i + 1);\n    }\n}\n\nll modcombi(ll x, ll y) {\n    if (x < y || y < 0) {\n        return 0;\n    } else if (y == 0) {\n        return 1;\n    } else {\n        return multiply(multiply(frac[x], invfrac[x - y]), invfrac[y]);\n    }\n}\n\nll dp[1000010];\nll fracsum[1000010];\nll invfracsum[1000010];\n\nint main() {\n    fracinvfrac(1000010);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N, H, D;\n    cin >> N >> H >> D;\n    fracsum[1] = frac[1];\n    REP(i, 2, 1000010) {\n        fracsum[i] = modadd(fracsum[i - 1], frac[i]);\n    }\n    dp[0] = frac[N];\n    ll sum = dp[0];\n    REP(i, 1, H) {\n        dp[i] = multiply(sum, fracsum[N]);\n        sum = modadd(sum, dp[i]);\n        if (i - D >= 0) {\n            sum = modadd(sum, -dp[i - D]);\n        }\n    }\n    ll ans = 0;\n    PER(i, H - 1, H - D - 1) {\n        ans = modadd(ans, dp[i]);\n    }\n    // invfracsum[1] = invfrac[1];\n    // REP(i, 2, 1000010) {\n    //     invfracsum[i] = invfracsum[i - 1] + invfrac[i];\n    // }\n    // dp[0] = 1;\n    // ll sum = 1;\n    // REP(i, 1, H + 1) {\n    //     ll val = multiply(frac[N], invfracsum[N - 1] + 1);\n    //     dp[i] = multiply(sum, val);\n    //     sum = modadd(sum, dp[i]);\n    //     if (i - D - 1 >= 0) {\n    //         sum = modadd(sum, -dp[i - D - 1]);\n    //     }\n    // }\n    // REP(i, 0, H) {\n    //     cout << dp[i] << \" \";\n    // }\n    // cout << endl;\n    // ll ans = 0;\n    // PER(i, H - 1, H - D - 1) {\n    //     ans = modadd(ans, dp[i]);\n    // }\n    // ans = multiply(ans, frac[N]);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\nconst int INF = 0x3f3f3f3f;\nconst long long LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007; // 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\n/*-------------------------------------------------*/\nint mod = MOD;\nstruct ModInt {\n  unsigned val;\n  ModInt(): val(0) {}\n  ModInt(long long x) : val(x >= 0 ? x % mod : x % mod + mod) {}\n  ModInt pow(long long exponent) {\n    ModInt tmp = *this, res = 1;\n    while (exponent > 0) {\n      if (exponent & 1) res *= tmp;\n      tmp *= tmp;\n      exponent >>= 1;\n    }\n    return res;\n  }\n  ModInt &operator+=(const ModInt &rhs) { if((val += rhs.val) >= mod) val -= mod; return *this; }\n  ModInt &operator-=(const ModInt &rhs) { if((val += mod - rhs.val) >= mod) val -= mod; return *this; }\n  ModInt &operator*=(const ModInt &rhs) { val = (unsigned long long)val * rhs.val % mod; return *this; }\n  ModInt &operator/=(const ModInt &rhs) { return *this *= rhs.inv(); }\n  bool operator==(const ModInt &rhs) const { return val == rhs.val; }\n  bool operator!=(const ModInt &rhs) const { return val != rhs.val; }\n  bool operator<(const ModInt &rhs) const { return val < rhs.val; }\n  bool operator<=(const ModInt &rhs) const { return val <= rhs.val; }\n  bool operator>(const ModInt &rhs) const { return val > rhs.val; }\n  bool operator>=(const ModInt &rhs) const { return val >= rhs.val; }\n  ModInt operator-() const { return ModInt(-val); }\n  ModInt operator+(const ModInt &rhs) const { return ModInt(*this) += rhs; }\n  ModInt operator-(const ModInt &rhs) const { return ModInt(*this) -= rhs; }\n  ModInt operator*(const ModInt &rhs) const { return ModInt(*this) *= rhs; }\n  ModInt operator/(const ModInt &rhs) const { return ModInt(*this) /= rhs; }\n  friend ostream &operator<<(ostream &os, const ModInt &rhs) { return os << rhs.val; }\n  friend istream &operator>>(istream &is, ModInt &rhs) { long long x; is >> x; rhs = ModInt(x); return is; }\nprivate:\n  ModInt inv() const {\n    // if (__gcd((int)val, mod) != 1) assert(false);\n    unsigned a = val, b = mod; int x = 1, y = 0;\n    while (b) {\n      unsigned tmp = a / b;\n      a -= tmp * b; swap(a, b);\n      x -= tmp * y; swap(x, y);\n    }\n    return ModInt(x);\n  }\n};\nModInt abs(const ModInt &x) { return x.val; }\nstruct Combinatorics {\n  Combinatorics(int MAX = 5000000) {\n    MAX <<= 1;\n    fact.resize(MAX + 1);\n    fact_inv.resize(MAX + 1);\n    fact[0] = 1;\n    FOR(i, 1, MAX + 1) fact[i] = fact[i - 1] * i;\n    fact_inv[MAX] = ModInt(1) / fact[MAX];\n    for (int i = MAX; i > 0; --i) fact_inv[i - 1] = fact_inv[i] * i;\n  }\n  ModInt nCk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    return fact[n] * fact_inv[k] * fact_inv[n - k];\n  }\n  ModInt nPk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    return fact[n] * fact_inv[n - k];\n  }\n  ModInt nHk(int n, int k) {\n    if (n < 0 || k < 0) return ModInt(0);\n    return (k == 0 ? ModInt(1) : nCk(n + k - 1, k));\n  }\nprivate:\n  vector<ModInt> fact, fact_inv;\n};\n\nint main() {\n  cin.tie(0); ios::sync_with_stdio(false);\n  // freopen(\"input.txt\", \"r\", stdin);\n\n  int n, h, d; cin >> n >> h >> d;\n  ModInt seni = 0, tmp = 1;\n  FOR(i, 1, n + 1) {\n    tmp *= i;\n    seni += tmp;\n  }\n  vector<ModInt> dp(h + 1);\n  ModInt ruiseki = 0;\n  dp[0] = 1;\n  FOR(i, 1, h + 1) {\n    dp[i] = ruiseki * seni + (i <= d ? 1 : 0);\n    ruiseki += dp[i];\n    if (i > d) ruiseki -= dp[i - d];\n  }\n  FOR(i, 1, n + 1) dp[h] *= i;\n  cout << dp[h] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,a,b) for(int i=(a);i<(b);i++)\n#define pb push_back\n#define eb emplace_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n\nusing vint=vector<int>;\nusing pint=pair<int,int>;\nusing vpint=vector<pint>;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\ntemplate<class A,class B>\nostream& operator<<(ostream& ost,const pair<A,B>&p){\n    ost<<\"{\"<<p.first<<\",\"<<p.second<<\"}\";\n    return ost;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& ost,const vector<T>&v){\n    ost<<\"{\";\n    for(int i=0;i<v.size();i++){\n        if(i)ost<<\",\";\n        ost<<v[i];\n    }\n    ost<<\"}\";\n    return ost;\n}\n\ntemplate<uint32_t mod>\nstruct ModInt{\n    uint32_t a;\n    ModInt& s(uint32_t vv){\n        a=vv<mod?vv:vv-mod;\n        return *this;\n    }\n\n    ModInt(int64_t x=0){s(x%mod+mod);}\n\n    ModInt& operator+=(const ModInt &x){return s(a+x.a);}\n    ModInt& operator-=(const ModInt &x){return s(a+mod-x.a);}\n    ModInt& operator*=(const ModInt &x){\n        a=uint64_t(a)*x.a%mod;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt &x){\n        *this*=x.inv();\n        return *this;\n    }\n\n    ModInt operator+(const ModInt &x)const{return ModInt(*this)+=x;}\n    ModInt operator-(const ModInt &x)const{return ModInt(*this)-=x;}\n    ModInt operator*(const ModInt &x)const{return ModInt(*this)*=x;}\n    ModInt operator/(const ModInt &x)const{return ModInt(*this)/=x;}\n    bool operator==(const ModInt &x)const{return a==x.a;}\n    bool operator!=(const ModInt &x)const{return a!=x.a;}\n    bool operator<(const ModInt &x)const{return a<x.a;}\n\n    ModInt operator-()const{return ModInt()-*this;}\n    ModInt pow(int64_t n)const{\n        ModInt res(1),x(*this);\n        while(n){\n            if(n&1)res*=x;\n            x*=x;\n            n>>=1;\n        }\n        return res;\n    }\n\n    ModInt inv()const{return pow(mod-2);}\n};\n\ntemplate<uint32_t mod>\nistream& operator>>(istream& in,ModInt<mod>& a){\n    return (in>>a.a);\n}\ntemplate<uint32_t mod>\nostream& operator<<(ostream& out,const ModInt<mod>& a){\n    return (out<<a.a);\n}\nusing mint=ModInt<1000000007>;\n\ntemplate<class Mint,int32_t lg>\nstruct ModIntTable{\n    int N;\n    vector<Mint>facts,finvs,invs;\n    ModIntTable():N(1<<lg),facts(N),finvs(N),invs(N){\n        const uint32_t mod=Mint(-1).a+1;\n        invs[1]=1;\n        for(int i=2;i<N;i++)invs[i]=invs[mod%i]*(mod-mod/i);\n\n        facts[0]=1;\n        finvs[0]=1;\n        for(int i=1;i<N;i++){\n            facts[i]=facts[i-1]*i;\n            finvs[i]=finvs[i-1]*invs[i];\n        }\n    }\n    inline Mint fact(int n)const{return facts[n];}\n    inline Mint finv(int n)const{return finvs[n];}\n    inline Mint inv(int n)const{return invs[n];}\n    inline Mint binom(int n,int k)const{\n        if(n<0||k<0||k>n)return 0;\n        return facts[n]*finvs[k]*finvs[n-k];\n    }\n    inline Mint perm(int n,int k)const{\n        if(n<0||k<0||k>n)return 0;\n        return facts[n]*finvs[n-k];\n    }\n    inline Mint catalan(int n){\n        return facts[2*n]*finvs[n+1]*finvs[n];\n    }\n};\nModIntTable<mint,20>mt;\n\nint N,H,D;\nmint dp[1111111];\nmint acc[1111111];\nsigned main(){\n    cin>>N>>H>>D;\n\n\n    mint coef=0;\n    for(int i=1;i<=N;i++)coef+=mt.fact(i);\n\n    for(int i=1;i<=D;i++)dp[i]+=mt.fact(N);\n    for(int i=1;i<=H;i++){\n        mint tmp=acc[i-1];\n        if(i-D-1>=0)tmp-=acc[i-D-1];\n        dp[i]+=tmp*coef;\n        acc[i]=acc[i-1]+dp[i];\n    }\n    \n    mint ans=dp[H];\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n\tusing value_type = ::std::uint_fast64_t;\n\tvalue_type n;\npublic:\n\tModInt() : n(0) {}\n\tModInt(value_type n_) : n(n_ % mod) {}\n\tModInt(const ModInt& m) : n(m.n) {}\n\n\ttemplate<typename T>\n\texplicit operator T() const { return static_cast<T>(n); }\n\tvalue_type get() const { return n; }\n\n\tfriend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n\t\treturn os << a.n;\n\t}\n\n\tfriend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n\t\tvalue_type x;\n\t\tis >> x;\n\t\ta = ModInt<mod>(x);\n\t\treturn is;\n\t}\n\n\tbool operator==(const ModInt& m) const { return n == m.n; }\n\tbool operator!=(const ModInt& m) const { return n != m.n; }\n\tModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n\tModInt pow(value_type b) const{\n\t\tModInt ans = 1, m = ModInt(*this);\n\t\twhile(b){\n\t\t\tif(b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tModInt inv() const { return (*this).pow(mod-2); }\n\tModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n\tModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n\tModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n\tModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n\tModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n\tModInt& operator++(){ n += 1; return *this; }\n\tModInt& operator--(){ n -= 1; return *this; }\n\tModInt operator++(int){\n\t\tModInt old(n);\n\t\tn += 1;\n\t\treturn old;\n\t}\n\tModInt operator--(int){\n\t\tModInt old(n);\n\t\tn -= 1;\n\t\treturn old;\n\t}\n\tModInt operator-() const { return ModInt(mod-n); }\n};\n\ntemplate<class ValueMonoid, class OperatorMonoid, class Modifier,\n\ttemplate<class...> class Container=::std::vector>\nclass LazySegTree{\npublic:\n\tusing value_structure = ValueMonoid;\n\tusing value_type = typename value_structure::value_type;\n\tusing operator_structure = OperatorMonoid;\n\tusing operator_type = typename operator_structure::value_type;\n\tusing modifier = Modifier;\n\tusing const_reference = const value_type &;\n\tusing container_value_type = Container<value_type>;\n\tusing container_operator_type = Container<operator_type>;\n\tusing size_type = typename container_value_type::size_type;\n\nprivate:\n\tcontainer_value_type tree;\n\tcontainer_operator_type lazy;\n\tsize_type size_, height;\n\n\tstatic size_type getsize(const size_type x){\n\t\tsize_type ret = 1;\n\t\twhile(ret < x)\n\t\t\tret <<= 1;\n\t\treturn ret;\n\t}\n\n\tstatic size_type getheight(const size_type x){\n\t\tsize_type ret = 0;\n\t\twhile((static_cast<size_type>(1) << ret) < x){\n\t\t\tret++;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tinline static value_type calc(const value_type a, const value_type b){\n\t\treturn value_structure::operation(a, b);\n\t}\n\n\tinline static void apply(operator_type &data, const operator_type a){\n\t\tdata = operator_structure::operation(data, a);\n\t}\n\n\tinline static value_type reflect(const value_type v, const operator_type o){\n\t\treturn modifier::operation(v, o);\n\t}\n\n\tvoid push(const size_type index){\n\t\ttree[index] = reflect(tree[index], lazy[index]);\n\t\tapply(lazy[index << 1], lazy[index]);\n\t\tapply(lazy[index << 1 | 1], lazy[index]);\n\t\tlazy[index] = operator_structure::identity();\n\t}\n\n\tvoid calc_node(const size_type index){\n\t\tif(tree.size() <= (index << 1 | 1)) return;\n\t\tassert(0 < index);\n\t\ttree[index] = calc(reflect(tree[index << 1],  lazy[index << 1]),\n\t\t\t\treflect(tree[index << 1 | 1], lazy[index << 1 | 1]));\n\t}\n\n\tvoid build(size_type index){\n\t\twhile(index >>= 1){\n\t\t\tcalc_node(index);\n\t\t}\n\t}\n\n\tvoid propagate(const size_type index){\n\t\tfor(size_type shift = height; shift ; --shift){\n\t\t\tpush(index >> shift);\n\t\t}\n\t}\n\n\tvoid rebuild(){\n\t\tfor(size_type i = size_-1;i > 0;--i){\n\t\t\tcalc_node(i);\n\t\t}\n\t}\npublic:\n\tLazySegTree() : size_(0), height(0), tree(), lazy(){}\n\tLazySegTree(const size_type size)\n\t\t\t: size_(size), height(getheight(size)),\n\t\t\t\ttree(size << 1, value_structure::initializer()),\n\t\t\t\tlazy(size << 1, operator_structure::identity()){\n\t\trebuild();\n\t}\n\ttemplate<class InputIterator>\n\tLazySegTree(InputIterator first, InputIterator last)\n\t\t\t: size_(::std::distance(first, last)){\n\t\theight = getheight(size_);\n\t\ttree = container_value_type(size_, value_structure::identity());\n\t\tlazy = container_operator_type(size_ << 1, operator_structure::identity());\n\t\ttree.insert(tree.end(), first, last);\n\t\trebuild();\n\t}\n\n\tsize_type size() const { return size_; }\n\tconst_reference operator[](const size_type k){\n\t\tassert(k < size_);\n\t\tpropagate(k+size_);\n\t\ttree[k+size_] = reflect(tree[k+size_], lazy[k+size_]);\n\t\tlazy[k+size_] = operator_structure::identity();\n\t\treturn tree[k+size_];\n\t}\n\n\tvalue_type query(size_type l, size_type r){\n\t\tassert(l <= r);\n\t\tassert(0 <= l && l < size_);\n\t\tassert(0 <= r && r <= size_);\n\t\tvalue_type retl = value_structure::identity(),\n\t\t\t\t\t\t\t retr = value_structure::identity();\n\t\tl += size_;\n\t\tr += size_;\n\t\tpropagate(l);\n\t\tpropagate(r-1);\n\t\tfor(; l < r ; l >>= 1, r >>= 1){\n\t\t\tif(l&1){\n\t\t\t\tretl = calc(retl, reflect(tree[l], lazy[l]));\n\t\t\t\tl++;\n\t\t\t}\n\t\t\tif(r&1){\n\t\t\t\tr--;\n\t\t\t\tretr = calc(reflect(tree[r], lazy[r]), retr);\n\t\t\t}\n\t\t}\n\t\treturn calc(retl, retr);\n\t}\n\n\tvoid update(size_type l, size_type r, const operator_type& data){\n\t\tassert(l <= r);\n\t\tassert(0 <= l && l < size_);\n\t\tassert(0 <= r && r <= size_);\n\t\tl += size_;\n\t\tr += size_;\n\t\tpropagate(l);\n\t\tpropagate(r - 1);\n\t\tfor(size_type l_ = l, r_ = r; l_ < r_ ; l_ >>= 1, r_ >>= 1){\n\t\t\tif(l_ & 1) apply(lazy[l_++], data);\n\t\t\tif(r_ & 1) apply(lazy[--r_], data);\n\t\t}\n\t\tbuild(l);\n\t\tbuild(r - 1);\n\t}\n\n\ttemplate<class F>\n\tvoid update(size_type index, const F& f){\n\t\tassert(0 <= index && index < size());\n\t\tindex += size_;\n\t\tpropagate(index);\n\t\ttree[index] = f(::std::move(tree[index]));\n\t\tlazy[index] = operator_structure::identity();\n\t\tbuild(index);\n\t}\n\n\t/*\n\ttemplate<class F>\n\tsize_type search(const F& f) const { // [0, result) is True and [0, result-1) is not.\n\t\tif(f(value_structure::identity()))\n\t\t\treturn 0;\n\t\tif(!f(tree[1]))\n\t\t\treturn size_+1;\n\t\tvalue_type acc = value_structure::identity();\n\t\tsize_type i = 1;\n\t\twhile(i < \n\t}\n\t*/\n};\n\nconst int64 mod = 1e9+7;\nusing Mint = ModInt<mod>;\n\nclass v_monoid {\npublic: \n  using value_type = Mint;\n  static value_type identity() { return 0; }\n  static value_type initializer() { return 0; }\n  static value_type operation(const value_type& a, const value_type& b) {\n    return a + b;\n  }\n};\n\nclass o_monoid {\npublic: \n  using value_type = Mint;\n  static value_type identity() { return 0; }\n  static value_type operation(const value_type &a, const value_type &b) {\n    return a + b;\n  }\n};\n\nclass modifier {\npublic:\n  static Mint operation(const Mint& a, const Mint &b) {\n    return a + b;\n  }\n};\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n  int64 N, H, D;\n  cin >> N >> H >> D;\n  Mint co = 0, a = 1;\n  for (int64 i = N-1; i > 0; i--) {\n    a *= i;\n    co += a;\n  }\n  co += a*N;\n\n  LazySegTree<v_monoid, o_monoid, modifier> dp(H+1);\n  dp.update(1, D+1, N);\n  FOR(i, 1, H) {\n    Mint now = dp.query(i, i+1);\n    dp.update(i+1, min(i+D+1, H+1), now * co);\n  }\n  co = 1;\n  FOR(i, 1, N) co *= i;\n  cout << dp.query(H, H+1)*co << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=1<<20,INF=1<<28;\nll dp[MAX];\n\nll rui(ll a,ll b){\n    ll ans=1;\n    while(b>0){\n        if(b&1) ans=ans*a%mod;\n        a=a*a%mod;\n        b/=2;\n    }\n    return ans;\n}\nll bit[MAX+1],H;\n\n//1-indexed\n\nll sum(int i){\n    ll s=0;\n    while(i>0){\n        s+=bit[i];\n        i-=i&-i;\n        s%=mod;\n    }\n    return s;\n}\n\n//sからtの和=sum(t)-sum(s-1)\n\nvoid add(int i,ll x){\n    while(i<=H){\n        bit[i]+=x;\n        bit[i]%=mod;\n        i+=i&-i;\n    }\n}\n\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    ll N,D;cin>>N>>H>>D;\n    H++;\n    \n    ll bik=1;\n    ll s=0;\n    for(ll i=1;i<=N;i++){\n        bik*=i;\n        bik%=mod;\n        s+=bik;\n        s%=mod;\n    }\n    \n    dp[1]=bik*rui(s,mod-2)%mod;\n    \n    add(1,dp[1]);\n    \n    for(int i=2;i<=H;i++){\n        dp[i]=(sum(i-1)-sum(i-D-1)+mod)%mod*s;\n        dp[i]%=mod;\n        \n        add(i,dp[i]);\n    }\n    \n    cout<<dp[H]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\n#define mod 1000000007\n#define chmin(a,b) a=min(a,b)\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=(a*b)%mod\n#define N 1000010\nll fac[N],inv[N],ivf[N];\nnamespace seg{\n  ll dat[2*N],laz[2*N];\n  void init(){\n    for(int i=0;i<2*N;i++){\n      dat[i]=laz[i]=0;\n    }\n  }\n  ll eval(ll k){\n    if(k<N){\n      mad(laz[k*2],laz[k]);\n      mad(laz[k*2+1],laz[k]);\n    }\n    mad(dat[k],laz[k]); laz[k]=0;\n    return dat[k];\n  }\n  void upd(ll l,ll r,ll x){\n    l+=N,r+=N+1;\n    for(ll a=l,b=r;a<b;a>>=1,b>>=1){\n      if(a&1){mad(laz[a],x); a++;}\n      if(b&1){b--; mad(laz[b],x);}\n    }\n    for(ll a=l,b=r;a+b;a>>=1,b>>=1){\n      dat[a/2]=min(eval(a),eval(a^1));\n      dat[b/2]=min(eval(b),eval(b^1));\n    }\n  }\n  ll qry(ll l,ll r){\n    l+=N,r+=N+1;\n    for(ll d=20;d;d--){\n      eval(l>>d); eval(r>>d);\n    }\n    ll res=1e17;\n    for(ll a=l,b=r;a<b;a>>=1,b>>=1){\n      if(a&1)chmin(res,eval(a++));\n      if(b&1)chmin(res,eval(--b));\n    }\n    return res;\n  };\n};\nint main(){\n    fac[0]=ivf[0]=inv[1]=1;\n    for(int i=1;i<N;i++){\n\tif(i>1)inv[i]=(mod-mod/i*inv[mod%i]%mod)%mod;\n\tfac[i]=fac[i-1]*i%mod;\n\tivf[i]=ivf[i-1]*inv[i]%mod;\n    }\n    \n    ll n,h,d; cin>>n>>h>>d;\n    ll p=0;\n    for(ll i=1;i<=n;i++)mad(p,fac[i]);\n    seg::init();\n    seg::upd(0,0,fac[n]);\n    for(int i=0;i<h;i++){\n\tll x=seg::qry(i,i);\n\tif(i>0)\n\tmul(x,p);\n\tseg::upd(i+1,i+d,x);\n    }\n    cout<<seg::qry(h,h)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\nll nextLong() { ll x; scanf(\"%lld\", &x); return x;}\n\nconst ll MOD = 1e9 + 7;\nstruct mint {\n  ll x;\n  mint(ll x=0):x((x%MOD+MOD)%MOD){}\n  mint& operator+=(const mint a) {if ((x += a.x) >= MOD) x -= MOD;return *this;}\n  mint& operator-=(const mint a) {if ((x += MOD-a.x) >= MOD) x -= MOD;return *this;}\n  mint& operator*=(const mint a) {(x *= a.x) %= MOD;return *this;}\n  mint operator+(const mint a) const {mint res(*this);return res+=a;}\n  mint operator-(const mint a) const {mint res(*this);return res-=a;}\n  mint operator*(const mint a) const {mint res(*this);return res*=a;}\n  mint pow(ll b) const {\n    mint res(1), a(*this);\n    while (b) {\n      if (b & 1) res *= a;\n      a *= a;\n      b >>= 1;\n    }\n    return res;\n  }\n  // for prime MOD\n  mint inv() const {return pow(MOD-2);}\n  mint& operator/=(const mint a) {return (*this) *= a.inv();}\n  mint operator/(const mint a) const {mint res(*this);return res/=a;}\n};\nostream& operator<<(ostream& os, const mint& a) {os << a.x; return os;}\n\nconst int MAX_N = 1123456;\n\nmint fact[MAX_N];\nmint dp[MAX_N];\n\nint main2() {\n  int N = nextLong();\n  int H = nextLong();\n  int D = nextLong();\n\n  mint X = 0;\n  for (int i = 1; i <= N; i++) X += fact[i];\n\n  dp[0] = 1;\n  mint r = dp[0];\n  for (int i = 1; i <= H; i++) {\n    dp[i] = r * X;\n    r += dp[i];\n    if (i - D >= 0) r -= dp[i - D];\n  }\n\n  mint ans = dp[H] / X * fact[N];\n  cout << ans << endl;\n\n  REP(i, N+1) dp[i] = 0;\n\n  return 0;\n}\n\nint main() {\n\n  fact[0] = 1;\n  for (int i = 1; i < MAX_N; i++) fact[i] = mint(i) * fact[i-1];\n\n#ifdef LOCAL\n  for (;!cin.eof();cin>>ws)\n#endif\n    main2();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nint main() {\n    constexpr i64 mod = 1000000007;\n    i64 n, h, d;\n    std::cin >> n >> h >> d;\n    std::vector<i64> a(h + 1);\n    i64 sum = 0;\n    i64 co = 0, f = 1;\n    for (i64 i = 1; i <= n; i++) {\n        f = f * i % mod;\n        co = (co + f) % mod;\n    }\n    for (int i = 1; i <= h; i++) {\n        a[i] = sum * co % mod;\n        if (i <= d) a[i] = (a[i] + f) % mod;\n        else sum = (sum + mod - a[i - d]) % mod;\n        sum = (sum + a[i]) % mod;\n    }\n    std::cout << a[h] << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n};\n\nusing modint = ModInt< mod >;\n\n\ntemplate< class T >\nstruct BinaryIndexedTree {\n  vector< T > data;\n\n  BinaryIndexedTree(int sz) {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k) {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret += data[k];\n    return (ret);\n  }\n\n  void add(int k, T x) {\n    for(++k; k < data.size(); k += k & -k) data[k] += x;\n  }\n};\n\n\nint main() {\n  int N, H, D;\n\n\n  cin >> N >> H >> D;\n  modint uku = 0, p = 1;\n  for(int i = 1; i <= N; i++) {\n    p *= i;\n    uku += p;\n  }\n\n  BinaryIndexedTree< modint > tap(N + 1);\n\n\n  modint beet = uku + 1;\n  modint mul = p;\n\n  BinaryIndexedTree< modint > bit(N + 1);\n\n  bit.add(1, mul);\n  for(int i = 2; i <= D; i++) { // D のところまでいく\n    mul *= beet;\n    bit.add(i, mul);\n  }\n  modint cur = mul;\n\n  if(H == D) {\n    cout << cur << endl;\n    exit(0);\n  }\n\n\n  for(int i = D + 1; i <= H; i++) {\n    modint sum;\n    sum = bit.sum(i);\n    sum -= bit.sum(i - D - 1);\n\n    sum *= uku;\n    bit.add(i, sum);\n\n    if(i == H) {\n      cout << sum << endl;\n    }\n\n\n  }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1e9+7;\nconst int N=1e6+5;\nint n,h,d,sum,jc[N],xu[N],f[N],g[N];\nsigned main()\n{\n\tcin>>n>>h>>d;\n\tint x=0,xjh=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\txjh=xjh*i%mod;\n\t\tx=(x+xjh)%mod;\n\t}\n\tsum=0;f[0]=1;\n\tfor(int i=1;i<=h;i++)\n\t{\n        sum+=f[i-1];\n        if(i>d)sum-=f[i-d-1];\n        sum=(sum%mod+mod)%mod;\n        if(i!=h)f[i]=sum*x%mod;\n        else f[i]=sum;\n\t}\n\tfor(int i=1;i<=n;i++)f[h]=f[h]*i%mod;\n\tcout<<(f[h]%mod+mod)%mod;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint N,H,D;\n\nll fac[1000010];\nll dp[1000010];\n\nint main(){\n  cin>>N>>H>>D;\n\n  fac[0]=1;\n  for(int i=1;i<=N;i++) fac[i]=fac[i-1]*i%MOD;\n\n  ll constant=0;\n  for(int i=1;i<=N;i++) constant=(constant+fac[i])%MOD;\n\n  dp[0]=1;\n  dp[1]=fac[N];\n  ll sum=dp[1];\n\n  for(int i=2;i<=H;i++){\n    dp[i]=sum*constant%MOD;\n    if(i<=D) dp[i]=(dp[i]+dp[0]*fac[N]%MOD)%MOD;\n\n    if(i-D>=1) sum=(sum-dp[i-D]+MOD)%MOD;\n    sum=(sum+dp[i])%MOD;\n  }\n\n  cout<<dp[H]<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD ((ll)1e9+7)\n\nll moddiv(ll a,ll b){\n    a %= MOD;\n    b %= MOD;\n    for(ll m=MOD-2;m>0;m/=2){\n        if(m&1){\n            a=a*b%MOD;\n        }\n        b=b*b%MOD;\n    }\n    return a;\n}\n\nll N, H, D;\n\nll dp[2020202],mk[2020202];\nll i, j, k,ans;\nll fa[1010101];\nint main(){\n    scanf(\"%lld%lld%lld\", &N,&H,&D);\n    fa[0] = 1;\n    fornum(i,0,1010101){\n        fa[i + 1] = fa[i] * (i + 1) % MOD;\n    }\n    ll aDd = 0;\n    fornum(i,0,N){\n        aDd = (aDd + fa[i+1]) % MOD;\n    }\n\n    k = fa[N];\n    mk[D] = k;\n    fornum(i,0,H-1){\n        mk[i + 1 + D] = k * aDd%MOD;\n        k = (k + k * aDd + MOD - mk[i + 1]) % MOD;   \n    }\n    printf(\"%lld\", k);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n\n#define ll long long\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define f first\n#define s second\n#define all(x) x.begin(), x.end()\n#define D(x) cerr << #x << \" is \" << (x) << \"\\n\";\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>; ///find_by_order(),order_of_key()\ntemplate<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) { os << '{' << a.f << \", \" << a.s << '}'; return os; }\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& a){os << '{';for(int i=0;i<sz(a);i++){if(i>0&&i<sz(a))os << \", \";os << a[i];}os<<'}';return os;}\ntemplate<class T> ostream& operator<<(ostream& os, const set<T>& a) {os << '{';int i=0;for(auto p:a){if(i>0&&i<sz(a))os << \", \";os << p;i++;}os << '}';return os;}\ntemplate<class T> ostream& operator<<(ostream& os, const multiset<T>& a) {os << '{';int i=0;for(auto p:a){if(i>0&&i<sz(a))os << \", \";os << p;i++;}os << '}';return os;}\ntemplate<class T1,class T2> ostream& operator<<(ostream& os, const map<T1,T2>& a) {os << '{';int i=0;for(auto p:a){if(i>0&&i<sz(a))os << \", \";os << p;i++;}os << '}';return os;}\n\nconst int N=2e6+5;\nint n,h,d;\nconst int mod=1e9+7;\nint add(int a,int b)\n{\n    a+=b;\n    if(a>=mod)\n        a-=mod;\n    return a;\n}\nint mul(int a,int b)\n{\n    return (ll)a*b%mod;\n}\nint sub(int a,int b)\n{\n    a-=b;\n    if(a<0)\n        a+=mod;\n    return a;\n}\nstruct segTree{\n    vector<int> lazy,sumdp,sumjedan;\n    void init()\n    {\n        lazy.resize(4*N);\n        sumdp.resize(4*N);\n        sumjedan.resize(4*N);\n    }\n    void prop(int i)\n    {\n        sumdp[2*i]=add(sumdp[2*i],mul(lazy[i],sumjedan[2*i]));\n        sumdp[2*i+1]=add(sumdp[2*i+1],mul(lazy[i],sumjedan[2*i+1]));\n        lazy[2*i]+=lazy[i];\n        lazy[2*i+1]+=lazy[i];\n        lazy[i]=0;\n    }\n    void update(int i)\n    {\n        sumdp[i]=add(sumdp[2*i],sumdp[2*i+1]);\n        sumjedan[i]=add(sumjedan[2*i],sumjedan[2*i+1]);\n    }\n    void setdp(int pos,int val,int l=0,int r=N-1,int i=1)\n    {\n        if(r<pos||l>pos)\n            return;\n        if(l==pos&&r==pos)\n        {\n            sumdp[i]=val;\n            sumjedan[i]=val;\n            return;\n        }\n        int m=(l+r)>>1;\n        prop(i);\n        setdp(pos,val,l,m,2*i);\n        setdp(pos,val,m+1,r,2*i+1);\n        update(i);\n    }\n    void inc(int qs,int qe,int l=0,int r=N-1,int i=1)\n    {\n        if(qs>r||qe<l)\n            return;\n        if(qs<=l&&qe>=r)\n        {\n            lazy[i]++;\n            sumdp[i]=add(sumdp[i],sumjedan[i]);\n            return;\n        }\n        int m=(l+r)>>1;\n        prop(i);\n        inc(qs,qe,l,m,2*i);\n        inc(qs,qe,m+1,r,2*i+1);\n        update(i);\n    }\n    int getSum(int qs,int qe,int l=0,int r=N-1,int i=1)\n    {\n        if(qs>r||qe<l)\n            return 0;\n        if(qs<=l&&qe>=r)\n            return sumdp[i];\n        int m=(l+r)>>1;\n        prop(i);\n        return add(getSum(qs,qe,l,m,2*i),getSum(qs,qe,m+1,r,2*i+1));\n    }\n}st;\nint powmod(int x,int k)\n{\n    int ans=1;\n    for(;k;k>>=1,x=mul(x,x))\n        if(k&1)\n            ans=mul(ans,x);\n    return ans;\n}\nvector<int> fact,ifact(N);\nint nCk(int n,int k)\n{\n    return mul(fact[n],mul(ifact[n-k],ifact[k]));\n}\nint main()\n{\n    fact.pb(1);\n    for(int i=1;i<N;i++)\n        fact.pb(mul(fact.back(),i));\n    ifact[N-1]=powmod(fact[N-1],mod-2);\n    for(int i=N-2;i>=0;i--)\n        ifact[i]=mul(ifact[i+1],i+1);\n    st.init();\n    scanf(\"%i %i %i\",&n,&h,&d);\n    int ans=1;\n    for(int i=n-1;i>0;i--)\n        ans=mul(ans,i);\n    st.setdp(h,ans);\n    int magic=1;\n    for(int i=1;i<=n-1;i++)\n        magic=add(magic,mul(nCk(n-1,i),i+1));\n    //printf(\"%i\\n\",magic);\n    for(int i=h-1;i>0;i--)\n    {\n        int sum=st.getSum(i+1,i+d);\n        //printf(\"%i: %i\\n\",i,sum);\n        sum=mul(sum,magic);\n        st.setdp(i,sum);\n        //st.inc(i+1,i+d);\n    }\n    int sum=st.getSum(1,d);\n    sum=mul(sum,n);\n    printf(\"%i\\n\",sum);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstring>\n#include <cstdio>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <stdlib.h>\n#include <queue>\n#include <stack>\n#include <utility>\n#include <fstream>\n#include <random>\n#include <map>\n#include <unordered_map>\n#include <cstdlib>\n#include <functional>\n#include <random>\n#include <time.h>\n#include <chrono>\n#include <sstream>\n#include <iomanip>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define ll long long\n#define INF 1000000001\n#define mod 1000000007\n#define SORT(s) sort(s.begin(), s.end());\n#define reverse(s) reverse(s.begin(), s.end());\n#define P pair<int,int>\n#define mp make_pair\n#define valid(x,y,h,w) (0<=x&&x<h&&0<=y&&y<w)\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\nusing namespace std;\nint POW(int x, int y) { return int(pow(double(x), double(y))); }\ndouble log(double a, double b) { return log(b) / log(a); }\n\nll func2(ll n, ll Ga, ll Sa, ll Ba, ll Gb, ll Sb, ll Bb) {\n\tll ans = 0;\n\t{\n\t\tll G = (n / Ga) * Gb;\n\t\tn = n % Ga;\n\t\tll G2 = (n / Sa) * Sb;\n\t\tn = n % Sa;\n\t\tll G3 = (n / Ba) * Bb;\n\t\tn = n % Ba;\n\t\tans = max(ans, G + G2 + G3 + n);\n\t}\n\t{\n\t\tll G = ((n / Ga)-1) * Gb;\n\t\tn = (n % Ga) + Ga; \n\t\tll G2 = (n / Sa) * Sb;\n\t\tn = n % Sa;\n\t\tll G3 = (n / Ba) * Bb;\n\t\tn = n % Ba;\n\t\tans = max(ans, G + G2 + G3 + n);\n\t}\n\t{\n\t\tll G = ((n / Ga) - 1) * Gb;\n\t\tn = (n % Ga) + Ga;\n\t\tll G2 = ((n / Sa) - 1) * Sb;\n\t\tn = n % Sa + Sa;\n\t\tll G3 = (n / Ba) * Bb;\n\t\tn = n % Ba;\n\t\tans = max(ans, G + G2 + G3 + n);\n\t}\n\t{\n\t\tll G = (n / Ga) * Gb;\n\t\tn = n % Ga;\n\t\tll G2 = ((n / Sa) - 1) * Sb;\n\t\tn = n % Sa + Sa;\n\t\tll G3 = (n / Ba) * Bb;\n\t\tn = n % Ba;\n\t\tans = max(ans, G + G2 + G3 + n);\n\t}\n\treturn ans;\n}\n\n\nll func(ll n, ll Ga, ll Sa, ll Ba, ll Gb, ll Sb, ll Bb) {\n\tGb = max(Gb, Ga);\n\tSb = max(Sb, Sa);\n\tBb = max(Bb, Ba);\n\n\treturn max({\n\t\t\tfunc2(n, Ga, Sa, Ba, Gb, Sb, Bb),\n\t\t\tfunc2(n, Ga, Ba, Sa, Gb, Bb, Sb),\n\t\t\tfunc2(n, Sa, Ga, Ba, Sb, Gb, Bb),\n\t\t\tfunc2(n, Sa, Ba, Ga, Sb, Bb, Gb),\n\t\t\tfunc2(n, Ba, Sa, Ga, Bb, Sb, Gb),\n\t\t\tfunc2(n, Ba, Ga, Sa, Bb, Gb, Sb),\n\t\t\tn\n\n\n\n\t\t});\n}\n\n\n\nint main() {\n\tll n;\n\tll Ga, Sa, Ba;\n\tll Gb, Sb, Bb;\n\tcin >> n >> Ga >> Sa >> Ba >> Gb >> Sb >> Bb;\n\n\tll ans = func(n, Ga, Sa, Ba, Gb, Sb, Bb);\n\tans = func(ans, Gb, Sb, Bb, Ga, Sa, Ba);\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// ModInt begin\n\ntemplate<ll mod>\nstruct ModInt {\n    ll v;\n    ll mod_pow(ll x, ll n) const {\n        return (!n) ? 1 : (mod_pow((x*x)%mod,n/2) * ((n&1)?x:1)) % mod;\n    }\n    ModInt(ll a = 0) : v(a >= mod ? a % mod : a) {}\n    ModInt operator+ ( const ModInt& b ) const {\n        return (v + b.v >= mod ? ModInt(v + b.v - mod) : ModInt(v + b.v));\n    }\n    ModInt operator- () const {\n        return ModInt(-v);\n    }\n    ModInt operator- ( const ModInt& b ) const {\n        return (v - b.v < 0 ? ModInt(v - b.v + mod) : ModInt(v - b.v));\n    }\n    ModInt operator* ( const ModInt& b ) const {return (v * b.v) % mod;}\n    ModInt operator/ ( const ModInt& b ) const {return (v * mod_pow(b.v, mod-2)) % mod;}\n    \n    bool operator== ( const ModInt &b ) const {return v == b.v;}\n    ModInt& operator+= ( const ModInt &b ) {\n        v += b.v;\n        if(v >= mod) v -= mod;\n        return *this;\n    }\n    ModInt& operator-= ( const ModInt &b ) {\n        v -= b.v;\n        if(v < 0) v += mod;\n        return *this;\n    }\n    ModInt& operator*= ( const ModInt &b ) {\n        (v *= b.v) %= mod;\n        return *this;\n    }\n    ModInt& operator/= ( const ModInt &b ) {\n        (v *= mod_pow(b.v, mod-2)) %= mod;\n        return *this;\n    }\n    ModInt pow(ll x) { return ModInt(mod_pow(v, x)); }\n    // operator int() const { return int(v); }\n    // operator long long int() const { return v; }\n};\n\ntemplate<ll mod>\nostream& operator<< (ostream& out, ModInt<mod> a) {return out << a.v;}\ntemplate<ll mod>\nistream& operator>> (istream& in, ModInt<mod>& a) {\n    in >> a.v;\n    return in;\n}\n\n// ModInt end\n\n// 各種組み合わせを求めるライブラリ\ntemplate <typename NumType>\nstruct Combination {\n    int LIMIT;\n    vector<NumType> fact_, finv_;\n\n    Combination() {}\n    Combination(int LIMIT_) : LIMIT(LIMIT_), fact_(LIMIT+1), finv_(LIMIT+1) {\n        fact_[0] = finv_[LIMIT] = NumType(1);\n        for(int i=1; i<=LIMIT; i++) {\n            fact_[i] = fact_[i-1] * NumType(i);\n        }\n        \n        finv_[LIMIT] /= fact_[LIMIT];\n        for(int i=LIMIT-1; i>=0; i--) {\n            finv_[i] = finv_[i+1] * NumType(i+1);\n        }\n    }\n\n    inline NumType fact(int k) const { return fact_[k]; }\n    inline NumType finv(int k) const { return finv_[k]; }\n    NumType P(int n, int r) const {\n        if(r < 0 or n < r) return NumType(0);\n        return fact_[n] * finv_[n-r];\n    }\n    NumType C(int n, int r) const {\n        if(r < 0 or n < r) return NumType(0);\n        return fact_[n] * finv_[n-r] * finv_[r];\n    }\n    // 重複組み合わせ\n    NumType H(int n, int r) const {\n        if(n < 0 or r < 0) return NumType(0);\n        return r == 0 ? NumType(1) : C(n + r - 1, r);\n    }\n    // ベル数 (区別できる n 個のボールを区別できない k 個以下の箱に分割)\n    // B(n, n) := n 個のボールを任意個のグループに分割する場合の数\n    NumType B(int n, int k) const {\n        if(n == 0) return NumType(1);\n        k = min(n, k);\n        NumType ret(0);\n        vector<NumType> pref(k + 1); pref[0] = NumType(1);\n        for(int i=1; i<=k; i++) {\n            if(i & 1) pref[i] = pref[i-1] - finv_[i];\n            else pref[i] = pref[i-1] + finv_[i];\n        }\n        for(int i=1; i<=k; i++) {\n            // 累乗が必要なので適宜書き換える？\n            // ModInt 使うならこれでいい\n            ret += NumType(i).pow(n) * finv_[i] * pref[k-i];\n        }\n        return ret;\n    }\n    // スターリング数 (区別できる n 個のボールを区別できない k 個の箱に分割)\n    NumType S(int n, int k) const {\n        if(n < k) return NumType(0);\n        NumType ans(0);\n        for(int i=0; i<=k; i++) {\n            NumType val = C(k, i) * NumType(i).pow(n);\n            if((k - i) % 2) ans -= val;\n            else ans += val;\n        }\n        return ans * finv_[k];\n    }\n};\n\n// P(n, k) := n の k 分割 (k 個の 0 以上の整数の和)\ntemplate <typename NumType, int LIMIT = 3010>\nstruct Partition {\n    vector< vector<NumType> > dp;\n    Partition() : dp(LIMIT, vector<NumType>(LIMIT)) {\n        for(int k=0; k<LIMIT; k++) dp[0][k] = NumType(1);\n        for(int i=1; i<LIMIT; i++) {\n            for(int j=1; j<LIMIT; j++) {\n                dp[i][j] += dp[i][j-1];\n                if(i-j >= 0) dp[i][j] += dp[i-j][j];\n            }\n        }\n    }\n    inline NumType get(int n, int k) {\n        if(n < 0 or k < 0) return NumType(0);\n        return dp[n][k];\n    }\n};\n\nconst int MAXN = 1000010;\nusing mint = ModInt<MOD>;\nmint dp[MAXN];\nint main() {\n    Combination<mint> comb(MAXN);\n    int N, H, D; cin >> N >> H >> D;\n    mint coeff = 0;\n    for(int i=0; i<N; i++) {\n        coeff += comb.fact(i+1);\n    }\n    // fprintf(stderr, \"coeff = %lld\\n\", coeff.v);\n\n    dp[0] = mint(1);\n    for(int i=1; i<=H; i++) {\n        int r = i - 1;\n        int l = i - D - 1;\n\n        mint vr = dp[r];\n        mint vl = (l < 0 ? mint(0) : dp[l]);\n        dp[i] = dp[i-1] + (vr - vl) * coeff;\n        // fprintf(stderr, \"dp[%d] = %lld\\n\", i, dp[i].v);\n    }\n    mint ans = (dp[H] - dp[H-1]);\n    ans /= coeff;\n    ans *= comb.fact(N);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdint>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <vector>\nusing namespace std;\nusing ll = long long;\n#define fst first\n#define snd second\n\n/* clang-format off */\ntemplate <class T, size_t D> struct _vec { using type = vector<typename _vec<T, D - 1>::type>; };\ntemplate <class T> struct _vec<T, 0> { using type = T; };\ntemplate <class T, size_t D> using vec = typename _vec<T, D>::type;\ntemplate <class T> vector<T> make_v(size_t size, const T& init) { return vector<T>(size, init); }\ntemplate <class... Ts> auto make_v(size_t size, Ts... rest) { return vector<decltype(make_v(rest...))>(size, make_v(rest...)); }\ntemplate <class T> inline void chmin(T &a, const T& b) { if (b < a) a = b; }\ntemplate <class T> inline void chmax(T &a, const T& b) { if (b > a) a = b; }\n/* clang-format on */\n\ntemplate <std::uint_fast64_t Modulus>\nclass modint {\n  using u64 = std::uint_fast64_t;\n\n public:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept\n      : a((x % Modulus + Modulus) % Modulus) {\n  }\n  constexpr u64 &value() noexcept {\n    return a;\n  }\n  constexpr const u64 &value() const noexcept {\n    return a;\n  }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(const modint rhs) noexcept {\n    return *this *= ~rhs;\n  }\n  constexpr modint operator^(u64 exp) const noexcept {\n    modint v = 1, x = *this;\n    while (exp) {\n      if (exp & 1) {\n        v *= x;\n      }\n      x *= x;\n      exp >>= 1;\n    }\n    return v;\n  }\n  constexpr modint operator~() const noexcept {\n    u64 x = a, y = Modulus, u = 1, v = 0;\n    while (y) {\n      u64 t = x / y;\n      swap(x -= t * y, y);\n      swap(u -= t * v, v);\n    }\n    return u;\n  }\n};\n\nusing mint = modint<1000000007>;\n\nll solve(int N, int H, int D) {\n  mint f = 1, fsum = 0;\n  for (int i = 1; i <= N; i++) {\n    f *= i;\n    fsum += f;\n  }\n  vector<mint> dp(H + 1, mint(0)), sum(H + 2, mint(0));\n  for (int h = 1; h <= D; h++) dp[h] = 1;\n  for (int h = 1; h <= H; h++) {\n    dp[h] += fsum * (sum[h] - sum[max(0, h - D)]);\n    sum[h + 1] = sum[h] + dp[h];\n  }\n  mint res = dp[H] * f;\n  return res.value();\n}\n\nint main() {\n#ifdef DEBUG\n  ifstream ifs(\"in.txt\");\n  cin.rdbuf(ifs.rdbuf());\n#endif\n  int N, H, D;\n  while (cin >> N >> H >> D) {\n    cout << solve(N, H, D) << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define drep(i,r,l) for(int i=r;i>=l;--i)\nusing namespace std;\nconst int sz=1e6+7;\nconst int mod=1e9+7;\nint n,h,d;\nint ans;\nint f[sz<<1];\nint fac[sz],sum[sz];\nvoid init(){\n\tfac[1]=sum[1]=1;\n\trep(i,2,sz-1){\n\t\tfac[i]=1ll*i*fac[i-1]%mod;\n\t\tsum[i]=(sum[i-1]+fac[i])%mod;\n\t}\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d%d\",&n,&h,&d);\n\tf[1]=fac[n],f[d+1]=mod-fac[n];\n\trep(i,1,h){\n\t\tans=(ans+f[i])%mod;\n\t\tf[i+1]=(f[i+1]+1ll*ans*sum[n]%mod)%mod;\n\t\tf[i+d+1]=(f[i+d+1]-1ll*ans*sum[n]%mod+mod)%mod; \n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define vd void\n#define mod 1000000007\ntypedef long long ll;\nil ll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nil int pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\nint f[1000010];\nint main(){\n#ifdef XZZSB\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),H=gi(),D=gi(),N=0;\n\tint fact=1;\n\tfor(int i=1;i<=n;++i)fact=1ll*fact*i%mod,N=(N+fact)%mod;\n\tf[0]=1;\n\tfor(int i=1;i<=H;++i)\n\t\tf[i]=(f[i-1]+1ll*N*(f[i-1]-(i-D>0?f[i-D-1]:0)+mod))%mod;\n\tprintf(\"%lld\\n\",1ll*(f[H]-f[H-1]+mod)*fact%mod*pow(N,mod-2)%mod);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll mod_pow(ll a,ll n){\n  ll res=1;\n  while(n>0){\n    if(n&1)res=res*a%mod;\n    a=a*a%mod;\n    n>>=1;\n  }\n  return res;\n}\n\nll fac[1000010],finv[1000010];\n\nll npk(ll n,ll k){\n  return fac[n]*finv[n-k]%mod;\n}\n\nll N,D,H;\nll dp[1000010];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  fac[0]=1;\n  rep(i,1000000)fac[i+1]=fac[i]*(i+1)%mod;\n  rep(i,1000001)finv[i]=mod_pow(fac[i],mod-2);\n\n  cin>>N>>H>>D;\n\n  ll tot=0;\n  repl(i,1,N+1){\n    tot+=fac[i];\n    tot%=mod;\n  }\n\n  dp[0]=1;\n  ll sum=dp[0];\n  repl(i,1,H){\n    if(i-D-1>=0){\n      sum=(sum-dp[i-D-1]+mod)%mod;\n    }\n    dp[i]+=sum*tot%mod;\n    dp[i]%=mod;\n    sum+=dp[i];\n    sum%=mod;\n  }\n  sum=(sum-dp[H-D-1]+mod)%mod;\n  cout<<sum*fac[N]%mod<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;ll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n\treturn powmod(a, MOD-2);\n}\nll f[1000001], invf[1000001];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n    invf[n]=inv(f[n]);\n    for(ll i=n-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n}\nll comb(int x, int y){\n    if(x<y) return 0;\n    return f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nint main()\n{\n\tll n, h, d; cin>>n>>h>>d;\n\tll s[2000020];\n\tfac(n);\n\ts[0]=0;\n\tfor(int i=1; i<=n; i++) s[i]=(s[i-1]+f[i])%MOD;\n\tll dp[2000020];\n\tdp[0]=f[n];\n\tll dps[2000020];\n\tdps[0]=0, dps[1]=dp[0];\n\tfor(int i=1; i<h; i++){\n\t\tdp[i]=(dps[i]-dps[max(0ll, i-d)]+MOD)*s[n]%MOD;\n\t\tdps[i+1]=(dps[i]+dp[i])%MOD;\n\t}\n\tcout<<(dps[h]-dps[h-d]+MOD)%MOD<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MOD 1000000007\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n\n#define MOD 1000000007\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\nint n;\nint h;\nint d;\n\n#define MAX 1000002\n\n#define MOD 1000000007\n\nint dp[MAX];\n\n\nint main(){\n\tcin>>n>>h>>d;\n\tC.resize(1000002);\n\tint way1=0;  //all\n\tint k=1;\n\tfor(int j=1;j<=n;j++){\n\t\tmulto(k,j);\n\t\taddto(way1,k);\n\t}\n\tint way2=1;\n\tdp[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tmulto(dp[0],i);\n\t}\n\tfor(int i=1;i<=h;i++){\n\t\tint lef=max(i-d,0);\n\t\tint rig=i-1;\n\t\tint z=dp[rig];\n\t\tif(lef){\n\t\t\tsubto(z,dp[lef-1]);\n\t\t}\n\t\tif(i!=h){\n\t\t\tmulto(z,way1);\n\t\t}\n\t\telse{\n\t\t\tmulto(z,way2);\n\t\t}\n\t\tdp[i]=z;\n\t\tif(i!=h){\n\t\t\taddto(dp[i],dp[i-1]);\n\t\t}\n\t\telse{\n\t\t\tprintf(\"%d\\n\",dp[h]);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n\nlong long dp[1000005];\n\nconst long long MOD = 1e9+7;\n\nint main(){\n    int N, H, D;\n    scanf(\"%d%d%d\", &N, &H, &D);\n\n    long long retainWays = 0;\n    long long fact = 1;\n    for(int i = 1; i <= N; i ++){\n        fact = fact*i%MOD;\n        retainWays += fact;\n    }\n    retainWays %= MOD;\n\n    //printf(\"retainWays=%lld\\n\", retainWays);\n\n    dp[0] = fact;\n    long long slidingWindowSum = dp[0];\n    for(int i = 1; i <= H; i ++){\n        dp[i] = slidingWindowSum;\n\n        if(i == H){break;}\n\n        dp[i] = dp[i]*retainWays%MOD;\n        slidingWindowSum += dp[i];\n        if(i >= D){slidingWindowSum -= dp[i-D];}\n\n        slidingWindowSum = slidingWindowSum%MOD;\n        if(slidingWindowSum < 0){slidingWindowSum += MOD;}\n\n        //printf(\"dp[%d]=%lld\\n\", i, dp[i]);\n    }\n\n    printf(\"%lld\", dp[H]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // clang-format off\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n\n#ifdef ONLINE_JUDGE\n  #define rep(i,N) for(int i = 0; i < (int)(N); i++)\n  #define repr(i,N) for(int i = (int)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(int i = 1; i <= (int)(N) ; i++)\n  #define repr1(i,N) for(int i = (N) ; (int)(i) > 0 ; i--)\n#else\n  #define rep(i,N) for(long long i = 0; i < (long long)(N); i++)\n  #define repr(i,N) for(long long i = (long long)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(long long i = 1; i <= (long long)(N) ; i++)\n  #define repr1(i,N) for(long long i = (N) ; (long long)(i) > 0 ; i--)\n#endif\n\nusing namespace std; void solve();\nusing ll = long long; template<class T = ll> using V = vector<T>;\nusing vi = V<int>; using vl = V<>; using vvi = V< V<int> >;\nconstexpr int inf = 1001001001; constexpr ll infLL = (1LL << 61) - 1;\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); for(int i=0;i<s;i++) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);} while(0)\n  #define trcc(v) do { cerr << \"name : \" << #v << \"\\n\"; int cnt = 0; each(x , v){cerr << (cnt++) << \" : \"; trc(x); } } while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  #define trcc(...)\n  int main(){solve();}\n#endif\n\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define in2(s,t)     rep(i,sz(s)){in(s[i] , t[i]);}\n#define in3(s,t,u)   rep(i,sz(s)){in(s[i] , t[i] , u[i]);}\n#define in4(s,t,u,v) rep(i,sz(s)){in(s[i] , t[i] , u[i] , v[i]);}\nusing vd = V<double>; using vs = V<string>; using vvl = V< V<> >;\ntemplate<typename T,typename U>ll ceil(T a,U b){return (a + b - 1) / b;}\n\nusing P = pair<ll,ll>; using vp = V<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n// clang-format on\n/////////////////////////\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\nusing vm = vector<modint>;\nusing mint = modint;\n\nvector<ll> fac,finv,inv;\nvoid cominit(int MAX) {\n  MAX++;\n  fac.resize(MAX , 0);\n  finv.resize(MAX , 0);\n  inv.resize(MAX , 0);\n  fac[0] = fac[1] = finv[0] = finv[1] = inv[1] = 1;\n  for (int i = 2; i < MAX; i++){\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\n// nCk combination \ninline long long COM(int n,int k){\n  if(n < k || k < 0 || n < 0) return 0;\n  else return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n// nPk permutation\ninline long long PER(int n,int k){\n  if (n < k || k < 0 || n < 0) return 0;\n  else return (fac[n] * finv[n - k]) % MOD;\n}\n// nHk homogeneous polynomial\ninline long long HGP(int n,int k){\n  if(n == 0 && k == 0) return 1; // depending on problem?\n  else if(n < 1 || k < 0) return 0;\n  else return fac[n + k - 1] * (finv[k] * finv[n - 1] % MOD) % MOD;\n}\n\n// BIT\n\ntemplate< typename T >\nstruct BIT {\n  int N; int max_2beki;\n\n  vector< T > data;\n  // 初期化 1-indexedでデータを管理する 0で初期化\n  BIT(int size){\n      N = ++size;\n      data.assign(N, 0);\n      max_2beki = 1;\n      while(max_2beki * 2 <= N) max_2beki *= 2;\n  }\n\n  // [0,k](閉区間)の総和 閉区間に注意！\n  T sum(int k) {\n    if(k < 0) return 0; // k<0のとき0を返す\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret += data[k];\n    return (ret);\n  }\n\n  // [l,r](閉区間)の総和\n  inline T sum(int l,int r){\n    return sum(r) - sum(l-1);\n  }\n\n  // 一点取得 更新はできないことに注意\n  inline T operator[](int k){\n    return sum(k) - sum(k-1);\n  }\n\n  // data[k] += x;\n  void add(int k, T x) {\n    for(++k; k < N; k += k & -k) data[k] += x;\n  }\n\n  // imos法 [l,r]にxを加算\n  void imos(int l,int r,T x){\n    add(l , x); add(r + 1 , -x);\n  }\n\n  // lower_bound sum(i)がval以上となる最小のi\n  int lower_bound(T w){\n    if(w <= 0) return 0;\n    int x = 0;\n    for(int k = max_2beki; k > 0; k /= 2){\n      if(x+k <= N - 1 && data[x + k] < w){\n        w -= data[x + k];\n        x += k;\n      }\n    }\n    return x;\n  }\n\n  // upper_bound sum(i)がvalより大きくなる最小のi\n  int upper_bound(T w){\n    if(w < 0) return 0;\n    int x = 0;\n    for(int k = max_2beki; k > 0; k /= 2){\n      if(x+k <= N - 1 && data[x + k] <= w){\n        w -= data[x + k];\n        x += k;\n      }\n    }\n    return x;\n  }\n\n};\n\n\n\nvoid solve(){\n  ini(N , H , D);\n  cominit(N + 10);\n  auto mkrui = [](auto v) -> decltype(v){\n    decltype(v) ret(v.size() + 1);\n    for(int i = 0 ; i < int(v.size()) ; i++) \n      ret[i + 1] = ret[i] + v[i];\n    return ret;\n  };\n  auto rui = mkrui(fac);\n\n  mint nya = rui[N + 1] + MOD - 1;\n  BIT<mint> bit(H + 10);\n\n  bit.add(0 , fac[N]);\n  rep1(i , H){\n    mint nxt = nya * bit.sum(max(0ll,i-D) , i - 1);\n    //trc(i , nxt);\n    bit.add(i , nxt);\n  }\n  out(bit[H] / nya);\n\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <fstream>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\ntemplate<typename T>void MACRO_OUT(const T t) { std::cout << t; }\ntemplate<typename First, typename...Rest>void MACRO_OUT(const First first, const Rest...rest) { std::cout << first << \" \"; MACRO_OUT(rest...); }\n#define OUT(...) MACRO_OUT(__VA_ARGS__);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t: \" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t: \";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t: \";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n#define SHOWSTACK(a) {auto tmp(a);std::cerr << #a << \"\\t: \";while(!tmp.empty()){std::cerr << tmp.top() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T & a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T & val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T> & a, const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>> & a, const T & val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nclass ModInt {\n\tfriend std::istream& operator>>(std::istream& is, ModInt& obj);\nprivate:\n\tint M;\n\tbool M_is_prime;\n\tbool isPrime() {\n\t\tfor (int i = 2; i * i <= M; ++i) if (M % i == 0) return false;\n\t\treturn true;\n\t}\npublic:\n\tint val;\n\tModInt() : val(0), M(MOD), M_is_prime(true) {}\n\tModInt(int n) : val(n % MOD), M(MOD), M_is_prime(true) {}\n\tModInt(int n, int m) : val(n % m), M(m), M_is_prime(isPrime()) {}\n\tModInt& operator=(const signed& r) {\n\t\tval = r % M;\n\t\treturn *this;\n\t}\n\tModInt operator+() const { return *this; }\n\tModInt operator-() const { return ModInt(M - val); }\n\tModInt& operator+=(const ModInt & r) {\n\t\tval += r.val;\n\t\tval %= M;\n\t\treturn *this;\n\t}\n\tModInt& operator+=(const int& r) {\n\t\t*this += ModInt(r);\n\t\treturn *this;\n\t}\n\tModInt& operator-=(const ModInt & r) { return *this += -r; }\n\tModInt& operator-=(const int& r) { return *this += -r + M; }\n\tModInt& operator++() { return *this += 1; }\n\tModInt& operator++(signed tmp) { return *this += 1; }\n\tModInt& operator--() { return *this -= 1; }\n\tModInt& operator--(signed tmp) { return *this -= 1; }\n\tModInt& operator*=(const ModInt & r) {\n\t\tval *= r.val;\n\t\tval %= M;\n\t\treturn *this;\n\t}\n\tModInt& operator*=(const int& r) {\n\t\tval *= r % M;\n\t\tval %= M;\n\t\treturn *this;\n\t}\n\tModInt& operator^=(int p) { // O(log(p))\n\t\tModInt res(1);\n\t\twhile (p) {\n\t\t\tif (p & 1) res *= *this;\n\t\t\t*this *= *this;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn *this = res;\n\t}\n\tModInt& operator^=(const ModInt & r) { // O(log(p))\n\t\tint p = r.val;\n\t\treturn *this ^= p;\n\t}\n\tModInt& operator/=(ModInt r) { // M must be a prime.\n\t\tassert(M_is_prime);\n\t\treturn *this *= r ^= (M - 2);\n\t}\n\tModInt & operator/=(int r) { // M must be a prime.\n\t\treturn *this /= ModInt(r);\n\t}\n\tModInt operator+(const ModInt & r) const {\n\t\tauto res(*this);\n\t\treturn res += r;\n\t}\n\tModInt operator-(const ModInt & r) const {\n\t\tauto res(*this);\n\t\treturn res -= r;\n\t}\n\tModInt operator*(const ModInt & r) const {\n\t\tauto res(*this);\n\t\treturn res *= r;\n\t}\n\tModInt operator^(const ModInt & r) const {\n\t\tauto res(*this);\n\t\treturn res ^= r;\n\t}\n\tModInt operator/(const ModInt & r) const { // M must be a prime.\n\t\tauto res(*this);\n\t\treturn res /= r;\n\t}\n\tModInt operator+(const int& r) const {\n\t\tauto res(*this);\n\t\treturn res += r;\n\t}\n\tModInt operator-(const int& r) const {\n\t\tauto res(*this);\n\t\treturn res -= r;\n\t}\n\tModInt operator*(const int& r) const {\n\t\tauto res(*this);\n\t\treturn res *= r;\n\t}\n\tModInt operator^(const int& r) const {\n\t\tauto res(*this);\n\t\treturn res ^= r;\n\t}\n\tModInt operator/(const int& r) const { // M must be a prime.\n\t\tauto res(*this);\n\t\treturn res /= r;\n\t}\n};\nstd::ostream& operator<<(std::ostream & os, const ModInt & obj) {\n\tos << obj.val;\n\treturn os;\n}\n/* friend */ std::istream& operator>>(std::istream & is, ModInt & obj) {\n\tis >> obj.val;\n\tobj.val %= obj.M;\n\treturn is;\n}\n/** ModInt **/\n\nModInt dp[1000006];\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, h, d);\n\n\tModInt A = 0;\n\t{\n\t\tModInt t = 1;\n\t\tFOR(i, 1, n + 1) {\n\t\t\tt *= i;\n\t\t\tA += t;\n\t\t}\n\t}\n\n\tModInt sum = 0;\n\tdp[0] = 1;\n\n\tFOR(i, 1, h) {\n\t\tsum += dp[i - 1];\n\t\tif (i - d - 1 >= 0) sum -= dp[i - d - 1];\n\t\tdp[i] = sum * A;\n\t}\n\n\tModInt ans = 0;\n\tFOR(i, 1, d + 1) if(h - i >= 0) ans += dp[h - i];\n\tFOR(i, 1, n + 1) ans *= i;\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\nusing namespace std;\nconst ll MAX_N=1e6,MOD=1e9+7,MAX_H=1e6;\nll N,H,D,dp[MAX_H+1],fact[MAX_N+1];\nll mpw(ll n,ll m){\n\tll r=1;\n\twhile(m){\n\t\tif(m&1){\n\t\t\tr*=n;\n\t\t\tr%=MOD;\n\t\t}\n\t\tn*=n;\n\t\tn%=MOD;\n\t\tm>>=1;\n\t}\n\treturn r;\n}\nll minv(ll n){\n\treturn mpw(n,MOD-2);\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>N>>H>>D;\n\tfact[0]=1;\n\tREP(i,N){\n\t\tfact[i+1]=(i+1)*fact[i]%MOD;\n\t}\n\tdp[0]=1;\n\tll sm=1,x=0;\n\tREP(i,N){\n\t\tx+=fact[i+1];\n\t\tx%=MOD;\n\t}\n\tREP(i,H){\n\t\tdp[i+1]=sm*x%MOD;\n\t\tsm+=dp[i+1];\n\t\tsm%=MOD;\n\t\tif(i+1-D>=0){\n\t\t\tsm-=dp[i+1-D];\n\t\t\tsm+=MOD;\n\t\t\tsm%=MOD;\n\t\t}\n\t}\n\tll ans=dp[H]*fact[N]%MOD;\n\tans*=minv(x);\n\tans%=MOD;\n\tcout<<ans<<endl;\n\t\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nvoid sol(int i, int st, int dir, vel& cnt, vvel& nex, vvel& use) {\n\tif (use[i].size() == 0 || use[i].back() != st) {\n\t\tuse[i].push_back(st);\n\t\tif (cnt[i] >= 1) {\n\t\t\trep(nd, 2) {\n\t\t\t\tint ne = nex[nd][i];\n\t\t\t\tif (ne != -1) {\n\t\t\t\t\tsol(ne, st, nd, cnt, nex, use);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint ne = nex[dir][i];\n\t\t\tif (ne != -1) {\n\t\t\t\tsol(ne, st, dir, cnt, nex, use);\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main() {\n\tomajinai;\n\tint n, h, d; cin >> n >> h >> d;\n\tint M = 0;\n\tvel dp(h);\n\tdp[0] =1;\n\trep(i, n) {\n\t\tdp[0] *= (i + 1); dp[0] %= p1;\n\t\tM += dp[0];\n\t\tM %= p1;\n\t}\n\tfor (int i = 1; i < h; i++) {\n\t\tdp[i] = (M + 1) * dp[i - 1];\n\t\tif (i >= d + 1) {\n\t\t\tdp[i] -= M * dp[i - d - 1];\n\t\t}\n\t\tdp[i] %= p1; \n\t\tif (dp[i] < 0) { dp[i] += p1; }\n\t}\n\tint ans = dp.back();\n\tif (h >= d + 1) {\n\t\tans -= dp[h - d - 1];\n\t\tif (ans < 0) { ans += p1; }\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nint dp[1000005];\n\nconst long long MOD = 1e9+7;\n\nint main(){\n    int N, H, D;\n    scanf(\"%d%d%d\", &N, &H, &D);\n\n    long long retainWays = 0;\n    long long fact = 1;\n    for(int i = 1; i <= N; i ++){\n        fact = fact*i%MOD;\n        retainWays += fact;\n    }\n    retainWays %= MOD;\n\n    //printf(\"retainWays=%lld\\n\", retainWays);\n\n    dp[0] = fact;\n    int slidingWindowSum = dp[0];\n    for(int i = 1; i < D; i ++){\n        dp[i] = slidingWindowSum*retainWays%MOD;\n\n        slidingWindowSum += dp[i];\n\n        if(slidingWindowSum >= MOD){slidingWindowSum -= MOD;}\n\n        //printf(\"dp[%d]=%lld\\n\", i, dp[i]);\n    }\n  \n  \tfor(int i = D; i < H; i ++){\n        dp[i] = slidingWindowSum*retainWays%MOD;\n\n        slidingWindowSum += dp[i]-dp[i-D];\n\n        if(slidingWindowSum >= MOD){slidingWindowSum -= MOD;}\n        else if(slidingWindowSum < 0){slidingWindowSum += MOD;}\n\n        //printf(\"dp[%d]=%lld\\n\", i, dp[i]);\n    }\n\n    printf(\"%d\", slidingWindowSum);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nvoid sol(int i, int st, int dir, vel& cnt, vvel& nex, vvel& use) {\n\tif (use[i].size() == 0 || use[i].back() != st) {\n\t\tuse[i].push_back(st);\n\t\tif (cnt[i] >= 1) {\n\t\t\trep(nd, 2) {\n\t\t\t\tint ne = nex[nd][i];\n\t\t\t\tif (ne != -1) {\n\t\t\t\t\tsol(ne, st, nd, cnt, nex, use);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint ne = nex[dir][i];\n\t\t\tif (ne != -1) {\n\t\t\t\tsol(ne, st, dir, cnt, nex, use);\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main() {\n\tomajinai;\n\tint n, h, d; cin >> n >> h >> d;\n\tint M = 0;\n\tint ka = 1;\n\trep(i, n) {\n\t\tM += ka;\n\t\tka *= (i + 1);\n\t\tM %= p1;\n\t}\n\tvel dp(h);\n\tdp[0] = 1;\n\tfor (int i = 1; i < h; i++) {\n\t\tdp[i] = (M + 1) * dp[i - 1];\n\t\tif (i >= d + 1) {\n\t\t\tdp[i] -= M * dp[i - d - 1];\n\t\t}\n\t\tdp[i] %= p1; dp[i] += p1; dp[i] %= p1;\n\t}\n\tint ans = dp.back();\n\tif (h >= d + 1) {\n\t\tans += p1 - dp[h - d - 1];\n\t}\n\tans *= ka;\n\tcout << ans % p1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define LL long long\n#define PB push_back\n#define MP make_pair\n\n#define MOD 1000000007\n\n//累乗 O(log N)\nlong long power(long long x, long long N){\n\tif(N == 1) return x;\n\tlong long tmp = power(x, N/2);\n\tif(N%2 == 0) return tmp * tmp % MOD;\n\telse return tmp * tmp % MOD * x % MOD;\n}\n\n//逆元 O(log x)\nlong long inverse(long long x){\n\treturn power(x, MOD-2);\n}\n\n//コンビネーション\nstruct Combination{\nprivate:\n\tint N;\n\tvector<long long> fact, inv;\npublic:\n\tvoid init(int n){ //初期化する O(N)\n\t\tN = n;\n\t\tfact.push_back(1);\n\t\tinv.push_back(1);\n\t\tfor(long long i=1; i<=N; i++){\n\t\t\tfact.push_back(fact.back()*i%MOD);\n\t\t\tinv.push_back(inverse(fact.back()));\n\t\t}\n\t}\n\tlong long factorial(int n){\n\t\treturn fact[n];\n\t}\n\tlong long comb(int n, int k){ //nCkを求める O(1)\n\t\treturn fact[n] * inv[k] % MOD * inv[n-k] % MOD;\n\t}\n};\n\n//RSQ セグメント木\nstruct SegmentTree{\nprivate:\n\tint N;\n\tvector<long long> node;\n\tconst long long DEFAULT = 0LL;\npublic:\n\tvoid init(int n){ //初期化する O(N)\n\t\tnode.clear();\n\t\tN = 1;\n\t\twhile(N < n) N *= 2;\n\t\tfor(int i=0; i<2*N-1; i++) node.push_back(DEFAULT);\n\t}\n\tvoid update(int i, long long x){ //値を変更する O(log N)\n\t\ti += N - 1;\n\t\tnode[i] = x;\n\t\twhile(i > 0){\n\t\t\ti = (i-1)/2; //親の取得は(i-1)/2\n\t\t\tnode[i] = node[i*2+1] + node[i*2+2]; //子の取得はi*2+1,i*2+2\n\t\t}\n\t}\n\tlong long sum(int a, int b, int k=0, int l=0, int r=-1){ //[a,b)の和を求める O(log N)\n\t\tif(r == -1) r = N;\n\t\tif(r <= a || b <= l) return DEFAULT; //交差する場合\n\t\tif(a <= l && r <= b) return node[k]; //完全に含む場合\n\t\treturn sum(a, b, k*2+1, l, (l+r)/2) + sum(a, b, k*2+2, (l+r)/2, r);\n\t}\n};\n\nint N, H, D;\nCombination C;\nLL imp = 0;\nSegmentTree st;\nLL solve(int now){\n\tif(now == H) return C.factorial(N-1);\n\tLL ret = (st.sum(now+1, min(H, now+D)+1) % MOD) * imp;\n\treturn ret % MOD;\n}\n\nint main(){\n\tcin >> N >> H >> D;\n\tC.init(N);\n\tst.init(H+1);\n\timp = C.factorial(N-1) * N % MOD;\n\tfor(int k=1; k<N; k++){\n\t\timp += C.comb(N-1, k)*C.factorial(k-1);\n\t\timp %= MOD;\n\t}\n\tfor(int i=H; i>=0; i--) st.update(i, solve(i));\n\tLL ans = (st.sum(1, D+1) % MOD) * N;\n\tcout << ans%MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1e9+7;\nconst int N=1e6+5;\nint ksm(int b,int n){\n\tint res=1;\n\twhile(n){\n\t\tif(n&1) res=res*b%mod;\n\t\tb=b*b%mod; n>>=1;\n\t}\n\treturn res;\n}\nvoid add(int &x,int y){\n\tx=(x+y)%mod;\n}\nint fac[N],sum,f[N],s[N];\nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t\tfac[i]=fac[i-1]*i%mod,\n\t\tadd(sum,fac[i]);\n}\nsigned main(){\n\tint n,H,D;\n\tcin>>n>>H>>D;\n\tinit(n);f[0]=1;s[0]=1;\n\tfor(int i=1;i<=H;++i){\n\t\tf[i]=(s[i-1]+mod-((i-D>=1)?s[i-D-1]:0))%mod*sum%mod;\n\t\ts[i]=(s[i-1]+f[i])%mod;\n\t//\tcout<<f[i]<<\" \"<<s[i]<<endl;\n\t}\n\tint ans=f[H]*fac[n]%mod*ksm(sum,mod-2)%mod;\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// types - only for stuff used a lot \nusing ll = long long;\n#define vv vector\n#define Pp pair\n\n// IO\n#define get(x) scanf(\"%d\",&x)\n#define getl(x) scanf(\"%lld\",&x);\n\n// Operations\n#define pb push_back\n#define pob pop_back\n#define sz(a) int(a.size()) \n#define re(a,b) a=max(a,b) // relax\n#define ri(a,b) a=min(a,b) // relaxi\n\n// Debugging\n\n#ifndef LOCAL\n#define cerr if (0) cerr\n#else\n#define cerr cout\n#endif\n\n#define print(arr,n) {for (int _ = 0; _ < n; _++) cerr<<arr[_]<<\" \"; cerr << endl; }\n#define printv(vec)  {for (int _ : vec) cerr<<_<<\" \"; cerr<<endl;}\n\nconst int mod = 1e9+7, oo = 1e9;\nconst ll loo = 1e18;\n\n// Functions \nll modpow(ll a, ll b) {\n\tll ans = 1; // faster modpow than recursive\n\tfor (; b; b/=2,a=a*a%mod)\n\t\tif (b&1) ans = (ans*a)%mod;\n\treturn ans;\n}\nll gcd(ll a, ll b) {\n\twhile (a) b%=a,swap(a,b);\n\treturn b;\n}\n#define bitcount __builtin_popcountll\n#define f(i,a,b) for (int i = a; i < b; i++)\n#define fr(i,a,b) for (int i = b-1; i >= a; i--)\n\n\n/* \n\n   ALRIGHT HACKERS, THIS IS WHERE THE ACTUAL CODE BEGINS\n\n */\n\nconst bool DEBUG = 1;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n#ifdef LOCAL\n\tif (DEBUG) freopen(\"input.txt\", \"r\", stdin);\n\tif (DEBUG) freopen(\"output.txt\", \"w\", stdout);\n\tclock_t start = clock();\n#endif\n\n\tint n, d, h;\n\tcin>>n>>h>>d;\n\tll c = 1;\n\tfr(i,2,n+1)\n\t\tc = (c+c*i%mod)%mod;\n\tll dp[h];\n\tdp[0]=1;\n\tf(i,1,n+1) dp[0]=dp[0]*i%mod;\n\tll partial = dp[0]*c;\n\tf(i,1,h) {\n\t\tdp[i] = partial;\t\n\t\tpartial = (partial+dp[i]*c%mod)%mod;\n\t\tif (i>=d)\n\t\t\tpartial = (partial+mod-dp[i-d]*c%mod)%mod;\n\t}\n\tll ans = 0;\n\tf(i,0,h)\n\t\tif (h-i<=d) ans = (ans+dp[i])%mod;\n\tcout << ans << endl;\n\n#ifdef LOCAL\n\tcout << setprecision(12) << (long double)(clock()-start) / CLOCKS_PER_SEC << endl;\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\n#define N 500000\nll MOD=1e9+7;\n\nmain(){\n    ll n=in(),h=in(),d=in();\n    ll ans=0;\n    vector<ll> rui(n+100),dp(h+d+100);\n    rui[1]=1;\n    ll r=1;\n    rep2(i,1,n-1){\n        rui[i+1]=r*(i+1)%MOD+rui[i];\n        r=(r*(i+1))%MOD;\n        rui[i+1]%=MOD;\n    }\n    dp[0]=r;\n    dp[1]=MOD-r;\n    rep2(i,0,h-1){\n        dp[i+1]=(dp[i]+dp[i+1]+dp[i]*rui[n]%MOD)%MOD;\n        dp[i+d+1]=(dp[i+d+1]-dp[i]*rui[n]%MOD+MOD)%MOD;\n        if(i+d>=h)ans=(ans+dp[i])%MOD;\n    }\n    cout<<ans%MOD;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 1200000\n\nconst LL mod=1000000007;\nLL n,m,p,fac[N],sum,f[N],F[N];\n\nvoid upd(LL &x,LL y){x=(x+y+mod)%mod;}\n\nLL inv(LL x){return x==1?1:(mod-mod/x)*inv(mod%x)%mod;}\n\nint main(){\n\tscanf(\"%lld%lld%lld\",&n,&m,&p);\n\tfac[0]=1; for (LL i=1;i<=n;++i){fac[i]=fac[i-1]*i%mod; upd(sum,fac[i]);}\n\tf[0]=fac[n]; F[0]=f[0];\n\tfor (LL i=1;i<=m;++i){\n\t\tf[i]=F[i-1];\n\t\tif (i>p) upd(f[i],-F[i-p-1]);\n\t\tf[i]=f[i]*sum%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n\t}\n\tprintf(\"%lld\\n\",f[m]*inv(sum)%mod);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001; //check the limits, dummy\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    \n    int N; cin >> N;\n    int H, D; cin >> H >> D;\n\n    ll* fact = new ll[N+1];\n    fact[0] = 1;\n    ll factSum = 0;\n    FOR(i, 1, N+1) {\n    \tfact[i] = fact[i-1] * i;\n    \tfact[i] = fact[i] % MOD;\n    \tfactSum += fact[i];\n    \tfactSum = factSum % MOD;\n    }\n\n    ll* ans = new ll[H+1];\n    ll* pref = new ll[H+2];\n    pref[0] = 0; pref[1] = fact[N];\n    ans[0] = fact[N];\n    FOR(i, 1, H) {\n    \tans[i] = pref[i] - pref[max(0, i-D)];\n    \tans[i] += MOD; ans[i] = ans[i] % MOD;\n    \tans[i] = ans[i] * factSum; ans[i] = ans[i] % MOD;\n    \tpref[i+1] = pref[i] + ans[i];\n    \tpref[i+1] = pref[i+1] % MOD;\n    \t//cout << ans[i] << \" \" << endl;\n    }\n\n    ans[H] = pref[H] - pref[max(0, H-D)];\n    ans[H] += MOD; ans[H] = ans[H] % MOD;\n    cout << ans[H] << endl;\n\n\n    \n    return 0;\n}\n\n// read the question correctly (ll vs int)\n// template by bqi343"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nvector<int64_t> fact, seq_inv, fact_inv;\n\nvoid create_fact_mod(int num){\n    fact[0] = 1;\n    fact[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact[i] = fact[i-1] * i % MOD;\n    }\n}\n\nvoid create_seq_inv_mod(int num){\n    seq_inv[0] = 1;\n    seq_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        seq_inv[i] = (MOD - MOD/i) * seq_inv[MOD%i] % MOD;\n    }\n}\n\nvoid create_fact_inv_mod(int num){\n    fact_inv[0] = 1;\n    fact_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact_inv[i] = fact_inv[i-1] * seq_inv[i] % MOD;\n    }\n}\n\nvoid create_mod_tables(int num){\n    fact.resize(num+1);\n    seq_inv.resize(num+1);\n    fact_inv.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y){\n    int64_t d = a;\n    if(b != 0){\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nint64_t inv_mod(int64_t a){\n    int64_t x, y;\n    extgcd(a, MOD, x, y);\n    return (MOD + x%MOD) % MOD;\n}\n\ntemplate<typename T>\nstruct BIT {\n    int n;\n    vector<T> dat;\n\n    BIT(int n=0){\n        initialize(n);\n    }\n\n    void initialize(int nin){\n        n = nin;\n        dat.resize(n, 0);\n    }\n\n    T sum(int i){\n        T s = 0;\n        while(i >= 0){\n            add(s, dat[i]);\n            i = (i & (i+1)) - 1;\n        }\n        return s;\n    }\n\n    T sum_between(int i, int j){\n        return (MOD + sum(j) - sum(i-1)) % MOD;\n    }\n\n    void plus(int i, T x){\n        while(i < n){\n            add(dat[i], x);\n            i |= i+1;\n        }\n    }\n};\n\nint main(){\n    int N, H, D;\n    cin >> N >> H >> D;\n\n    create_mod_tables((int)1e6);\n\n    int64_t C = 0;\n    for(int i=1; i<=N; i++) add(C, fact[i]);\n\n    BIT<int64_t> bit(H+1);\n    bit.plus(0, fact[N]);\n    for(int i=1; i<=H; i++) bit.plus(i, (i==H ? 1 : C) * bit.sum_between(i-D, i-1) % MOD);\n\n    int64_t ans = bit.sum_between(H, H);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst ll mod = 1e9+7;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nconst int MAX_N = 1000010;\nll fact[MAX_N],fact_inv[MAX_N],inv[MAX_N];\n\nll pow_mod(ll a,ll b) {\n    ll ret;\n    if (b < 0) ret = pow_mod(a,mod+b-1);\n    else if (b == 0) ret = 1;\n    else if (b == 1) ret = a;\n    else {\n        ll c = pow_mod(a,b/2);\n        if (b%2) ret = (c*c)%mod*a%mod;\n        else ret = c*c%mod;\n    }\n    return ret;\n}\n\nvoid create_table(int n) {\n    fact[0] = 1;fact[1] = 1;\n    for (int i = 2;i <= n;++i) fact[i] = fact[i-1]*i%mod;\n    fact_inv[n] = pow_mod(fact[n],-1);\n    for (int i = n;i > 0;--i) fact_inv[i-1] = fact_inv[i]*i%mod;\n    for (int i = 1;i <= n;++i) inv[i] = fact_inv[i]*fact[i-1]%mod;\n}\n\nll combi(ll a, ll b) {\n    return fact[a]*fact_inv[b]%mod*fact_inv[a-b]%mod;\n}\n\nint main() {\n    int n,h,d;\n    cin >> n >> h >> d;\n    vector<ll> dp(h+1,0);\n    create_table(n);\n    dp[0] = fact[n];\n    ll sum = 0,a = 0;\n    for (int i = 1;i < n+1;++i) (a += fact[i]) %= mod;\n    for (int i = 0;i < h;++i) {\n        (sum += dp[i]) %= mod;\n        if (i >= d) (sum -= dp[i-d]) %= mod;\n        dp[i+1] = sum*a%mod;\n    }\n    cout << (sum+mod)%mod << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class t> inline t read(t &x){\n\tchar c=getchar();bool f=0;x=0;\n\twhile(!isdigit(c)) f|=c=='-',c=getchar();\n\twhile(isdigit(c)) x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\tif(f) x=-x;return x;\n}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){\n\tread(x);read(a...);\n}\ntemplate<class t> inline void write(t x){\n\tif(x<0) putchar('-'),write(-x);\n\telse{if(x>9) write(x/10);putchar('0'+x%10);}\n}\n\nconst int mod=1e9+7,N=1e6+5;\nint pre[N],f[N],fac[N],sum,n,h,d;\n\nint calc(int l,int r){\n\treturn l>0?(pre[r]-pre[l-1]+mod)%mod:pre[r];\n}\n\nsigned main(){\n\tread(n,h,d);\n\tfac[0]=1;for(int i=1;i<=n;i++) fac[i]=1ll*fac[i-1]*i%mod,sum=(sum+fac[i])%mod;\n\tpre[0]=f[0]=fac[n];\n\tfor(int i=1;i<h;i++){\n\t\tf[i]=1ll*calc(i-d,i-1)*sum%mod;\n\t\tpre[i]=(pre[i-1]+f[i])%mod;\n\t}\n\twrite(calc(h-d,h-1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/timeb.h>\n#include <vector>\n\nusing namespace std;\n\n#define repr(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) repr(i, 0, n)\n#define reprrev(i, a, b) for (int i = (int)(b)-1; i >= (int)(a); i--)\n#define reprev(i, n) reprrev(i, 0, n)\n#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n#define chmin(mi, val) mi = min(mi, val)\n#define chmax(ma, val) ma = max(ma, val)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define mp make_pair\n#define mt make_tuple\n#define INF 1050000000\n#define INFR INT_MAX\n#define INFL (long long)(4e18)\n#define INFLR LLONG_MAX\n#define EPS (1e-10)\n#define MOD 1000000007\n// #define MOD 998244353\n#define PI 3.141592653589793238\n#define RMAX 4294967295\n\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vvvi = vector<vector<vector<int>>>;\nusing vvvvi = vector<vector<vector<vector<int>>>>;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nusing vvvll = vector<vector<vector<ll>>>;\nusing vd = vector<double>;\nusing vvd = vector<vector<double>>;\nusing vb = vector<bool>;\nusing vvb = vector<vector<bool>>;\nusing vc = vector<char>;\nusing vvc = vector<vector<char>>;\nusing vs = vector<string>;\nusing vvs = vector<vector<string>>;\nusing Pi = pair<int, int>;\nusing vPi = vector<Pi>;\nusing vvPi = vector<vector<Pi>>;\nusing vvvPi = vector<vector<vector<Pi>>>;\nusing vvvvPi = vector<vector<vector<vector<Pi>>>>;\nusing Pll = pair<ll, ll>;\nusing vPll = vector<Pll>;\nusing Pd = pair<double, double>;\nusing vPd = vector<Pd>;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate <class T>\nusing pql = priority_queue<T, vector<T>, greater<T>>;\n\n// vvvvvvvvvvvvvvvvvvvvvvv debug output vvvvvvvvvvvvvvvvvvvvvvv\n// vector\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n// pair\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n// vector\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n// map\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> &map_var) {\n    os << \"{\";\n    repi(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n// set\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> &set_var) {\n    os << \"{\";\n    repi(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n#define DUMPOUT cerr\n\nvoid dump_func() {\n    DUMPOUT << endl;\n}\ntemplate <class Head, class... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) {\n        DUMPOUT << \", \";\n    }\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                              \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                            \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\"        \\\n            << endl                                                            \\\n            << \"    \",                                                         \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\n// ^^^^^^^^^^^^^^^^^^^^^^^ debug output ^^^^^^^^^^^^^^^^^^^^^^^\n\nstring YN(bool y, int id = 0) {\n    if (id) cout << id;\n    return (y ? \"YES\" : \"NO\");\n}\nstring yn(bool y, int id = 0) {\n    if (id) cout << id;\n    return (y ? \"Yes\" : \"No\");\n}\nstring ON(bool y, int id = 0) {\n    if (id) cout << id;\n    return (y ? \"OK\" : \"NG\");\n}\n\nint dir4[4][2] = {{0, -1}, {-1, 0}, {1, 0}, {0, 1}};\nint dir8[8][2] = {{-1, -1}, {0, -1}, {1, -1}, {-1, 0},\n                  {1, 0},   {-1, 1}, {0, 1},  {1, 1}};\nchar dirchar[4] = {'<', '^', '>', 'v'};\n\n// [a,b)\nint irand(int a, int b) {\n    static mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n    uniform_int_distribution<int> dist(a, b - 1);\n    return dist(Rand);\n}\n\n// [a,b)\ndouble drand(int a, int b) {\n    static mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n    uniform_real_distribution<double> dist(a, b);\n    return dist(Rand);\n}\n\n// https://qiita.com/IgnorantCoder/items/3101d6276e9bdddf872c\ntemplate <typename A, typename F>\ninline auto transform(const A &v, F &&f) {\n    using result_type =\n        decltype(std::declval<F>()(std::declval<typename A::value_type>()));\n    vector<result_type> y(v.size());\n    std::transform(std::cbegin(v), std::cend(v), std::begin(y), f);\n    return y;\n}\n\n// 多次元vector生成\ntemplate <class T>\nvector<T> make_v(size_t size, const T &init) {\n    return vector<T>(size, init);\n}\ntemplate <class... Ts>\nauto make_v(size_t size, Ts... rest) {\n    return vector<decltype(make_v(rest...))>(size, make_v(rest...));\n}\n\ntemplate <typename T>\nT Max(vector<T> a) {\n    return *max_element(all(a));\n}\ntemplate <typename T>\nT Min(vector<T> a) {\n    return *min_element(all(a));\n}\ntemplate <typename T>\nT Sum(vector<T> a) {\n    return accumulate(all(a), (T)0);\n}\n\n// mapでカウントとかする\ntemplate <typename T>\nvoid Add(map<T, int> &m, T item) {\n    if (m.find(item) == m.end()) {\n        m[item] = 1;\n    } else {\n        m[item]++;\n    }\n}\n\n// デフォルト値つきのmapのget\ntemplate <typename T, typename U>\nU Get(map<T, U> m, T key, U def) {\n    if (m.find(key) == m.end()) {\n        return def;\n    } else {\n        return m[key];\n    }\n}\n\ntemplate <typename T>\nbool Contains(set<T> t, const T &key) {\n    return t.find(key) != t.end();\n}\n\ntemplate <typename T, typename U>\nbool Contains(map<T, U> t, const T &key) {\n    return t.find(key) != t.end();\n}\n\ntemplate <class T>\nstruct Edge {\n    int from, to;\n    T cost;\n    bool operator<(Edge e) {\n        return cost < e.cost;\n    }\n};\n\ntemplate <class T>\nusing Graph = vec<vec<Edge<T>>>;\n\ntemplate <class T>\nostream &operator<<(ostream &os, Edge<T> &edge) {\n    os << \"(\" << edge.from << \"->\" << edge.to << \":\" << edge.cost << \")\";\n    return os;\n}\n\n//======================================================\n\n// 階乗・組み合わせのモジュラ逆数\nclass FactorialMod {\n    // モジュラ逆数を求める(modが素数と仮定)\n    void ModInv() {\n        inv[0] = 0;\n        inv[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            inv[i] = mod - ((mod / i) * inv[mod % i] % mod);\n        }\n    }\n\n    // n!をmodで割った余り\n    void FacInv() {\n        fac[0] = facinv[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            fac[i] = (fac[i - 1] * i) % mod;\n            facinv[i] = (facinv[i - 1] * (int)inv[i]) % mod;\n        }\n    }\n\n  public:\n    int n;\n    int mod;\n    vector<long long> inv;\n    vector<long long> fac;\n    vector<long long> facinv;\n\n    FactorialMod(int _n, int _mod)\n        : n(_n), mod(_mod), inv(vector<long long>(_n + 1)),\n          fac(vector<long long>(_n + 1)), facinv(vector<long long>(_n + 1)) {\n        ModInv();\n        FacInv();\n    }\n\n    ll CombiMod(int r, int k) {\n        if (r == 0 && k == 0) return 1;\n        if (r <= 0 || k < 0 || k > r) return 0;\n        if (k == 0) return 1;\n\n        return (((fac[r] * facinv[k]) % mod) * facinv[r - k]) % mod;\n    }\n};\nlong long powMod(long long x, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * x % mod;\n        x = x * x % mod;\n        n >>= 1;\n    }\n    return res;\n}\nint main(void) {\n    int N, H, D;\n    cin >> N >> H >> D;\n    FactorialMod fm(N, MOD);\n    ll X = 0;\n    repr(i, 1, N + 1) {\n        X += fm.fac[i];\n        X %= MOD;\n    }\n    dump(X);\n\n    deque<ll> slide;\n    slide.push_back(1);\n    ll slide_sum = 1;\n\n    rep(i, H) {\n        slide.push_back(X * slide_sum % MOD);\n        slide_sum = (X + 1) * slide_sum % MOD;\n        if (slide.size() > D) {\n            slide_sum = (slide_sum - slide.front() + MOD) % MOD;\n            slide.pop_front();\n        }\n    }\n    ll ans = (slide.back() * fm.fac[N] % MOD) * powMod(X, MOD - 2, MOD) % MOD;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 1000000007\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 1000000001\n\nint main(){\n\t\n\tint N,H,D;\n\tcin>>N>>H>>D;\n\t\n\tint x = 1;\n\tint t = 1;\n\tfor(int i=2;i<=N;i++){\n\t\tx = mod(x * i);\n\t\tt = mod(t + x);\n\t}\n\t//t=N;\n\tvector<int> dp(H+1,0);\n\t\n\tfor(int i=1;i<=H;i++){\n\t\tdp[i] = mod(mod(dp[i-1]-dp[max(i-D-1,0)]) * t);\n\t\tif(i-D-1<0)dp[i] = mod(dp[i]+1);\n\t\tdp[i] = mod(dp[i] + dp[i-1]);\n\t}\n\t/*\n\tfor(int i=0;i<=H;i++)cout<<dp[i]<<',';\n\tcout<<endl;\n\t*/\n\tint ans = mod(dp.back() - dp[H-1]);\n\tfor(int i=2;i<=N;i++)ans = mod(ans * i);\n\t//ans = mod(ans * t);\n\tcout<<ans<<endl;\n\t\t\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <algorithm>\n\nconstexpr int mod = 1000000007;\nint dp[1000000] = {};\n\nint main() {\n  int N, H, D;\n  scanf(\"%d %d %d\", &N, &H, &D);\n  long long coeff = 0;\n  long long fact = 1;\n  for (int i = 1; i <= N; ++i) {\n    if ((coeff += ((fact *= i) %= mod)) >= mod) coeff -= mod;\n  }\n  std::fill(dp, dp + D, fact);\n  int sum = dp[0];\n  for (int i = 1; i < H; ++i) {\n    if ((dp[i] += (coeff * sum) % mod) >= mod) dp[i] -= mod;\n    if ((sum += dp[i]) >= mod) sum -= mod;\n    if (i >= D) if ((sum -= dp[i - D]) < 0) sum += mod;\n  }\n  printf(\"%d\\n\", dp[H - 1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nconst Int MOD = 1000000007;\nconst int MAX = 1000010;\nInt fac[MAX], sumfac[MAX], dp[MAX];\nint main() {\n    int N, H, D; cin >> N >> H >> D;\n    fac[0] = 1;\n    for (int i = 1; i <= N; i++) {\n        fac[i] = fac[i - 1] * i % MOD;\n        sumfac[i] = (sumfac[i - 1] + fac[i]) % MOD;\n    }\n    dp[0 + 1] = (dp[0 + 1] + fac[N]) % MOD;\n    dp[0 + D + 1] = (dp[0 + D + 1] + MOD - fac[N]) % MOD;\n    for (int i = 1; i < H; i++) {\n        Int t = dp[i] * sumfac[N] % MOD;\n        dp[i + 1] = (dp[i + 1] + t) % MOD;\n        int idx = min(H + 1, i + D + 1);\n        dp[idx] = (dp[idx] + MOD - t) % MOD;\n        dp[i + 1] = (dp[i] + dp[i + 1]) % MOD;\n    }\n    cout << dp[H] << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nvector<int64_t> fact, seq_inv, fact_inv;\n\nvoid create_fact_mod(int num){\n    fact[0] = 1;\n    fact[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact[i] = fact[i-1] * i % MOD;\n    }\n}\n\nvoid create_seq_inv_mod(int num){\n    seq_inv[0] = 1;\n    seq_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        seq_inv[i] = (MOD - MOD/i) * seq_inv[MOD%i] % MOD;\n    }\n}\n\nvoid create_fact_inv_mod(int num){\n    fact_inv[0] = 1;\n    fact_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact_inv[i] = fact_inv[i-1] * seq_inv[i] % MOD;\n    }\n}\n\nvoid create_mod_tables(int num){\n    fact.resize(num+1);\n    seq_inv.resize(num+1);\n    fact_inv.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y){\n    int64_t d = a;\n    if(b != 0){\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nint64_t inv_mod(int64_t a){\n    int64_t x, y;\n    extgcd(a, MOD, x, y);\n    return (MOD + x%MOD) % MOD;\n}\n\ntemplate<typename T>\nstruct BIT {\n    int n;\n    vector<T> dat;\n\n    BIT(int n=0){\n        initialize(n);\n    }\n\n    void initialize(int nin){\n        n = nin;\n        dat.resize(n, 0);\n    }\n\n    T sum(int i){\n        T s = 0;\n        while(i >= 0){\n            add(s, dat[i]);\n            i = (i & (i+1)) - 1;\n        }\n        return s;\n    }\n\n    T sum_between(int i, int j){\n        return (MOD + sum(j) - sum(i-1)) % MOD;\n    }\n\n    void plus(int i, T x){\n        while(i < n){\n            add(dat[i], x);\n            i |= i+1;\n        }\n    }\n};\n\nint main(){\n    int N, H, D;\n    cin >> N >> H >> D;\n\n    create_mod_tables((int)1e6);\n\n    int64_t C = 0;\n    for(int i=1; i<=N; i++) add(C, fact[i]);\n\n    BIT<int64_t> bit(H+1);\n    bit.plus(0, fact[N] * inv_mod(C) % MOD);\n    for(int i=1; i<=H; i++) bit.plus(i, C * bit.sum_between(i-D, i-1) % MOD);\n\n    int64_t ans = bit.sum_between(H, H);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/**\n\n  f(X, D) = (N - D + 1) * f(X, D - 1) -> D >= 2\n  f(X, 1) = (N - 1) * f(X - 1, 1) + (N - 2) * f(X - 1, 2) + ... + 1 * f(X - 1, N - 1) + N * f(X - 1, N)\n  f(X, 2) = (N - 1)\n\n  s0 = // 1/(N - 1)! + 1/(N - 2)! + 1/(N - 3)! + 1/(N - 4)! + ... 1/(N - N)!\n  \n  s1 = // (N - 1)/1 - (N - 1) / (N - 2)\n\n  f(X, \n  f(X, N) = (N - 1)! * (N - 1) * f(X - 1, 1) +\n  \t    (N - 1)! * (N - 2) * f(X - 1, 2) +\n\t    ...\n\t    (N - 1)! * 1 * f(X - 1, N - 1) +\n\t    (N - 1)! * N * f(X - 1, N)\n\n  f(0, 1) - f(0, 2) - ... - f(0, N)\n\n  f(1, 1)\n  **/\t\nnamespace modular_space {\n\tlong long mod;\n\tstruct umod {\n\t\tlong long val;\n\t\tumod(): val(0ll){}\n\t\tumod(long long x){ x %= mod; if(x < 0) x += mod; val = x; }\n\t\tumod& operator += (umod oth){ val += oth.val; if(val >= mod) val -= mod; return *this; }\n\t\tumod& operator -= (umod oth){ val -= oth.val; if(val < 0) val += mod; return *this; }\n\t\tumod& operator *= (umod oth){ val = val * oth.val % mod; return *this; }\n\t\tumod& operator /= (umod oth){ return *this *= oth.inverse(); }\n\t\tumod& operator ^= (long long oth){ return *this = pwr(*this, oth); }\n\t\tumod operator + (umod oth) const { return umod(*this) += oth; }\n\t       \tumod operator - (umod oth) const { return umod(*this) -= oth; }\n\t\tumod operator * (umod oth) const { return umod(*this) *= oth; }\n\t\tumod operator / (umod oth) const { return umod(*this) /= oth; }\n\t\tumod operator ^ (long long oth) const { return umod(*this) ^= oth; }\n\t\tbool operator < (umod oth) const { return val < oth.val; }\n\t\tbool operator > (umod oth) const { return val > oth.val; }\n\t\tbool operator <= (umod oth) const { return val <= oth.val; }\n\t\tbool operator >= (umod oth) const { return val >= oth.val; }\n\t\tbool operator == (umod oth) const { return val == oth.val; }\n\t\tbool operator != (umod oth) const { return val != oth.val; }\n\t\tumod pwr(umod a, long long b) const {\n\t\t\tumod r = 1;\n\t\t\tfor(; b; a *= a, b >>= 1)\n\t\t\t\tif(b&1)\n\t\t\t\t\tr *= a;\n\t\t\treturn r;\n\t\t}\n\t\tumod inverse() const {\n\t\t\tlong long a = val, b = mod, u = 1, v = 0;\n\t\t\twhile(b){\n\t\t\t\tlong long t = a/b;\n\t\t\t\ta -= t * b; swap(a, b);\n\t\t\t\tu -= t * v; swap(u, v);\n\t\t\t}\n\t\t\tif(u < 0)\n\t\t\t\tu += mod;\n\t\t\treturn u;\n\t\t}\n\t\tfriend istream& operator >> (istream &is, umod &oth);\n\t\tfriend ostream& operator << (ostream &os, const umod& oth);\n\t};\n\tostream& operator << (ostream &os, const umod &oth){\n\t\tos << oth.val;\n\t\treturn os;\n\t}\n\tistream& operator >> (istream &is, umod &oth){\n\t\tlong long x; is >> x;\n\t\toth = umod(x);\n\t\treturn is;\n\t}\n\tstruct binprime_kit {\n\t\tint sz;\n\t\tvector<umod> fat, ifat;\n\t\tvoid init(int s){\n\t\t\tsz = s;\n\t\t\tfat.resize(sz + 1);\n\t\t\tifat.resize(sz + 1);\n\t\t\tfat[0] = 1;\n\t\t\tfor(int i = 1; i <= sz; i++) fat[i] = fat[i - 1] * i;\n\t\t\tifat[sz] = fat[sz] ^ (mod - 2);\n\t\t\tfor(int i = sz - 1; i >= 0; i--) ifat[i] = ifat[i + 1] * (i + 1);\n\t\t}\n\t\tumod coef(int n, int r){\n\t\t\tif(n < r) return 0;\n\t\t\treturn fat[n] / (ifat[r] * ifat[n - r]);\n\t\t}\n\t};\n};\nusing umod = modular_space::umod;\nusing binkit = modular_space::binprime_kit;\n/**\nf(0, 1) = 0\nf(0, 2) = 1\n\nf(1, 1) = 2\nf(1, 2) = 2\n\nf(2, 1) = 2 + 4\nf(2, 2) = f(2, 1)\n  **/\nint main(){\n\tmodular_space::mod = 1'000'000'007;\n\tint n, h, d; cin >> n >> h >> d;\n\tvector<umod> f(h + 1), g(h + 1);\n\tbinkit kit; kit.init(h + n + 1);\n\tf[0] = kit.fat[n];\n\tumod fac = 0, sum = f[0];\n\tfor(int i = 1; i <= n; i++) fac += kit.fat[i];\n\tfor(int i = 1; i <= h; i++){\n\t\tif(i - d - 1 >= 0) sum -= f[i - d - 1];\n\t\tumod fact = i == h ? 1 : fac;\n\t\tf[i] = fact * sum;\n\t\tsum += f[i];\n\t}\n\tcout << f[h] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, h, d;\nint fct[2000000];\nint f[2000000];\nconst int mod = 1000000007;\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin >> n >> h >> d;\n  fct[0] = 1;\n  int sum = 0;\n  for (int i = 1; i <= n; i++) {\n    fct[i] = 1ll * fct[i - 1] * i % mod;\n    sum += fct[i];\n    if (sum >= mod) {\n      sum -= mod;\n    }\n  }\n  f[0] = fct[n];\n  int csum = 1ll * fct[n] * sum % mod;\n  for (int i = 1; i <= h; i++) {\n    if (i == h) {\n     for (int j = i - 1; j >= max(0, h - d); j--) {\n       f[i] += f[j];\n       if (f[i] >= mod) {\n         f[i] -= mod;\n       }\n     }\n    } else {\n      f[i] = csum;\n      csum += 1ll * f[i] * sum % mod;\n      if (csum >= mod) {\n        csum -= mod;\n      }\n      if (i >= d) {\n        csum -= 1ll * f[i - d] * sum % mod;\n        if (csum < 0) {\n          csum += mod;\n        }\n      }\n    }\n  }\n  cout << f[h] << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\n\nconst int M = 1000000007;\n\nint main() {\n    int n, h, d; cin >> n >> h >> d;\n    long long coeff = 0;\n    for (int i = n; i >= 1; i--) coeff = i * (1 + coeff) % M;\n    vector<long long> dp(h, 0), acc(h+1, 0);\n    dp[0] = 1;\n    for (int i = 2; i <= n; i++) dp[0] = dp[0] * i % M;\n    acc[1] = dp[0];\n    for (int i = 1; i < h; i++) {\n        dp[i] = (acc[i] - acc[max(0, i-d)]) * coeff % M;\n        acc[i+1] = (acc[i] + dp[i]) % M;\n    }\n    cout << ((acc[h] - acc[h-d]) % M + M) % M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int Maxn = 2000005;\nconst int mod = 1000000007;\n\nint n, h, d;\nint fac, sum;\nint dp[Maxn];\n\nint main()\n{\n    scanf(\"%d %d %d\", &n, &h, &d);\n    fac = sum = 1;\n    for (int i = 2; i <= n; i++) {\n        fac = ll(fac) * i % mod;\n        sum = (sum + fac) % mod;\n    }\n    int cur = 0;\n    dp[1] = fac; dp[d + 1] = (mod - fac) % mod;\n    for (int i = 1; i <= h; i++) {\n        cur = (cur + dp[i]) % mod;\n        if (i == h) { printf(\"%d\\n\", cur); return 0; }\n        int ways = ll(cur) * sum % mod;\n        dp[i + 1] = (dp[i + 1] + ways) % mod;\n        dp[i + d + 1] = (dp[i + d + 1] - ways + mod) % mod;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, H, D;\n\tcin >> N >> H >> D;\n\tvector<int> dp(H + 1, 0);\n\tvector<int> f(N + 1);\n\tf[0] = 1;\n\tint sum = 0;\n\tfor (int i = 1; i <= N; i++) {\n\t\tf[i] = (f[i - 1] * i) % MOD;\n\t\tsum = (sum + f[i]) % MOD;\n\t}\n\n\tdp[1] = f[N];\n\tif (D < H) {\n\t\tdp[D + 1] = -f[N];\n\t}\n\tfor (int i = 1; i <= H; i++) {\n\n\t\tdp[i] = (dp[i - 1] + dp[i]) % MOD;\n\t\tif (dp[i] < 0)dp[i] += MOD;\n\t\tif (i == H)break;\n\n\n\n\t\tint ad = (dp[i] * sum) % MOD;\n\t\tdp[i + 1] += ad;\n\t\tdp[i + 1] %= MOD;\n\t\tint z = i + 1 + D;\n\t\tif (z <= H) {\n\t\t\tdp[z] -= ad;\n\t\t\tdp[z] %= MOD;\n\t\t}\n\t}\n\t//cerr << dp[1] << \" \" << dp[2] << endl;\n\tcout << dp[H] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//This Code was made by Chinese_zjc_.\n#include <iostream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <ctime>\n// #include<windows.h>\n#define int long long\n#define double long double\nusing namespace std;\nconst double PI = acos(-1);\nconst double eps = 0.0000000001;\nconst int INF = 0x3fffffffffffffff;\nconst int MOD = 1000000007;\nconst int MAXN = 1000000;\nint n, d, h, f[1000005], g[1000005], dp[2000005], p, sum[1000005];\nint power(int A, int B)\n{\n    A %= MOD;\n    int res = 1;\n    while (B)\n    {\n        if (B & 1)\n        {\n            res = res * A % MOD;\n        }\n        A = A * A % MOD;\n        B >>= 1;\n    }\n    return res;\n}\nint P(int M, int N)\n{\n    return f[M] * g[M - N] % MOD;\n}\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    f[0] = 1;\n    for (int i = 1; i <= MAXN; ++i)\n    {\n        f[i] = f[i - 1] * i % MOD;\n    }\n    g[MAXN] = power(f[MAXN], MOD - 2);\n    for (int i = MAXN; i; --i)\n    {\n        g[i - 1] = g[i] * i % MOD;\n    }\n    cin >> n >> h >> d;\n    for (int i = 1; i <= n; ++i)\n    {\n        p = (p + f[i]) % MOD;\n    }\n    for (int i = 1; i <= h; ++i)\n    {\n        if (i <= d)\n        {\n            dp[i] = (n + sum[i - 1] * p) % MOD;\n        }\n        else\n        {\n            dp[i] = (sum[i - 1] - sum[i - d - 1] + MOD) * p % MOD;\n        }\n        sum[i] = (sum[i - 1] + dp[i]) % MOD;\n    }\n    cout << dp[h] * P(n - 1, n - 1) % MOD << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T, typename A>\nstd::istream& operator>>(std::istream& is, std::vector<T, A>& v)\n{\n    for (auto& e : v) { is >> e; }\n    return is;\n}\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!===============================================================!//\n//!   88888888b            dP       .88888.   a88888b. 888888ba   !//\n//!   88                   88      d8'   '88 d8'   '88 88    '8b  !//\n//!  a88aaaa    dP.  .dP d8888P    88        88        88     88  !//\n//!   88         '8bd8'    88      88   YP88 88        88     88  !//\n//!   88         .d88b.    88      Y8.   .88 Y8.   .88 88    .8P  !//\n//!   88888888P dP'  'dP   dP       '88888'   Y88888P' 8888888P   !//\n//!===============================================================!//\ntemplate <typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto p = extgcd(b, a % b);\n    return {p.second, p.first - p.second * (a / b)};\n}\ntemplate <typename T>\nconstexpr T inverse(const T a, const T mod) { return (mod + extgcd((mod + a % mod) % mod, mod).first % mod) % mod; }\n//!========================================================!//\n//!  8888ba.88ba                 dP    dP            dP    !//\n//!  88  '8b  '8b                88    88            88    !//\n//!  88   88   88 .d8888b. .d888b88    88 88d888b. d8888P  !//\n//!  88   88   88 88'  '88 88'  '88    88 88'  '88   88    !//\n//!  88   88   88 88.  .88 88.  .88    88 88    88   88    !//\n//!  dP   dP   dP '88888P' '88888P8    dP dP    dP   dP    !//\n//!========================================================!//\ntemplate <uint mod>\nclass ModInt\n{\nprivate:\n    uint v;\n    static uint norm(const uint& x) { return x < mod ? x : x - mod; }\n    static ModInt make(const uint& x)\n    {\n        ModInt m;\n        return m.v = x, m;\n    }\n    static ModInt power(ModInt x, ll n)\n    {\n        ModInt ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static ModInt inv(const ModInt& x) { return ModInt{inverse((ll)x.v, (ll)mod)}; }\n\npublic:\n    ModInt() : v{0} {}\n    ModInt(const ll val) : v{norm(uint(val % (ll)mod + (ll)mod))} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    ModInt<mod>& operator=(const ModInt<mod>& n) { return v = n(), (*this); }\n    ModInt<mod>& operator=(const ll val) { return v = norm(uint(val % (ll)mod + (ll)mod)), (*this); }\n    ModInt<mod> operator+() const { return *this; }\n    ModInt<mod> operator-() const { return make(norm(mod - v)); }\n    ModInt<mod> operator+(const ModInt<mod>& val) const { return make(norm(v + val())); }\n    ModInt<mod> operator-(const ModInt<mod>& val) const { return make(norm(v + mod - val())); }\n    ModInt<mod> operator*(const ModInt<mod>& val) const { return make((uint)((ll)v * val() % (ll)mod)); }\n    ModInt<mod> operator/(const ModInt<mod>& val) const { return *this * inv(val()); }\n    ModInt<mod>& operator+=(const ModInt<mod>& val) { return *this = *this + val; }\n    ModInt<mod>& operator-=(const ModInt<mod>& val) { return *this = *this - val; }\n    ModInt<mod>& operator*=(const ModInt<mod>& val) { return *this = *this * val; }\n    ModInt<mod>& operator/=(const ModInt<mod>& val) { return *this = *this / val; }\n    ModInt<mod> operator+(const ll val) const { return ModInt{v + val}; }\n    ModInt<mod> operator-(const ll val) const { return ModInt{v - val}; }\n    ModInt<mod> operator*(const ll val) const { return ModInt{(ll)v * (val % mod)}; }\n    ModInt<mod> operator/(const ll val) const { return ModInt{(ll)v * inv(val)}; }\n    template <typename I>\n    ModInt<mod> operator^(const I n) const { return power(v, n); }\n    ModInt<mod>& operator+=(const ll val) { return *this = *this + val; }\n    ModInt<mod>& operator-=(const ll val) { return *this = *this - val; }\n    ModInt<mod>& operator*=(const ll val) { return *this = *this * val; }\n    ModInt<mod>& operator/=(const ll val) { return *this = *this / val; }\n    template <typename I>\n    ModInt<mod>& operator^=(const I n) { return (*this) = ((*this) ^ n); }\n    bool operator==(const ModInt<mod>& val) const { return v == val.v; }\n    bool operator!=(const ModInt<mod>& val) const { return not(*this == val); }\n    bool operator==(const ll val) const { return v == norm(uint((ll)mod + val % (ll)mod)); }\n    bool operator!=(const ll val) const { return not(*this == val); }\n    uint operator()() const { return v; }\n};\ntemplate <uint mod>\ninline ModInt<mod> operator+(const ll val, const ModInt<mod>& n) { return n + val; }\ntemplate <uint mod>\ninline ModInt<mod> operator-(const ll val, const ModInt<mod>& n) { return ModInt<mod>{val - (ll)n()}; }\ntemplate <uint mod>\ninline ModInt<mod> operator*(const ll val, const ModInt<mod>& n) { return n * val; }\ntemplate <uint mod>\ninline ModInt<mod> operator/(const ll val, const ModInt<mod>& n) { return ModInt<mod>(val) / n; }\ntemplate <uint mod>\ninline bool operator==(const ll val, const ModInt<mod>& n) { return n == val; }\ntemplate <uint mod>\ninline bool operator!=(const ll val, const ModInt<mod>& n) { return not(val == n); }\ntemplate <uint mod>\ninline std::istream& operator>>(std::istream& is, ModInt<mod>& n)\n{\n    uint v;\n    return is >> v, n = v, is;\n}\ntemplate <uint mod>\nstd::ostream& operator<<(std::ostream& os, const ModInt<mod>& n) { return (os << n()); }\n//!============================================!//\n//!    8888ba.88ba             oo              !//\n//!    88  '8b  '8b                            !//\n//!    88   88   88  .d8888b.  dP  88d888b.    !//\n//!    88   88   88  88'  '88  88  88'  '88    !//\n//!    88   88   88  88.  .88  88  88    88    !//\n//!    dP   dP   dP  '88888P8  dP  dP    dP    !//\n//!============================================!//\nint main()\n{\n    using mint = ModInt<MOD>;\n    const int N = read<int>(), H = read<int>(), D = read<int>();\n    std::vector<mint> f(N + 1, 1);\n    for (int i = 1; i <= N; i++) { f[i] = f[i - 1] * i; }\n    std::vector<mint> dp(H + 1, 0), sum(H + 1, 1);\n    dp[0] = 1;\n    const mint p = std::accumulate(f.begin() + 1, f.end(), mint(0));\n    auto get = [&](const int i, const int j) { return sum[j - 1] - (i == 0 ? mint(0) : sum[i - 1]); };\n    for (int i = 1; i <= H; i++) { dp[i] = get(std::max(0, i - D), i) * p, sum[i] = sum[i - 1] + dp[i]; }\n    std::cout << dp[H] * f[N] / p << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, D, H;\n\tcin >> N >> H >> D;\n\tcat mod = 1000000007, fac = 1, sum_fac = 1;\n\tfor(int i = 2; i <= N; i++) {\n\t\tfac = i * fac % mod;\n\t\tsum_fac = (sum_fac + fac) % mod;\n\t}\n\tvector<cat> dp(H+1, 0), add(H+D+2, 0);\n\tadd[1] = fac;\n\tadd[D+1] = (-fac) % mod;\n\tfor(int i = 1; i <= H; i++) {\n\t\tadd[i] = (add[i] + add[i-1]) % mod;\n\t\tdp[i] = (dp[i] + add[i]) % mod;\n\t\tadd[i+1] = (add[i+1] + dp[i] * sum_fac) % mod;\n\t\tadd[i+D+1] = (add[i+D+1] - dp[i] * sum_fac) % mod;\n\t}\n\tdp[H] %= mod;\n\tif(dp[H] < 0) dp[H] += mod;\n\tcout << dp[H] << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define int long long\n#define inf 1000000007\n#define LINF 100000000000000007LL\n#define ll long long\nusing namespace std;\nint ka[1214514],inv[1214514];\nvoid setkaijo(int n){\n\tka[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tka[i] = ka[i-1] * i;\n\t\tka[i] %= inf;\n\t}\n}\nint modpow(int x,int k){\n\t// x ^ k mod inf\n\tint res = 1;\n\twhile(k>0){\n\t\tif(k%2)res = (res*x)%inf;\n\t\tx = (x*x)%inf;\n\t\tk >>=1;\n\t}\n\treturn res;\n}\nvoid setinv(int n){\n\tfor(int i=0;i<=n;i++){\n\t\tinv[i] = modpow(ka[i],(ll)inf-2);\n\t}\n}\nint comb(int n,int k){\n\tif( k<0 || n<0 || k>n)return 0;\n\tif(k==0 || k==n)return 1;\n\tint res = (ka[n] * inv[k]) % inf;\n\tres = (res*inv[n-k]) % inf;\n\treturn res;\n}\nint dp[1145140],sum[1145140],kais[1145140];\nsigned main(){\n\tint n,h,d;\n\tcin>>n>>h>>d;\n\tsetkaijo(1100000);\n\tdp[0]=1;\n\tsum[0]=1;\n\tkais[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tkais[i] = kais[i-1]+ka[i];\n\t\tkais[i]%=inf;\n\t}\n\tfor(int i=1;i<=h;i++){\n\t\tif( i <= d ){\n\t\t\tdp[i] += ka[n];\n\t\t\tdp[i] += kais[n] * ( sum[i-1] - sum[0] + inf);\n\t\t\tdp[i] %= inf;\n\t\t}\n\t\telse{\n\t\t\tdp[i] = kais[n] * ( sum[i-1] - sum[i-d-1] + inf );\n\t\t\tdp[i] %= inf;\n\t\t}\n\t\tsum[i] = sum[i-1] + dp[i];\n\t\tsum[i] %= inf;\n\t}\n\tcout<<dp[h]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    int N, H, D; cin >> N >> H >> D;\n    Combination C(N);\n\n    mvec dp(H);\n    dp[0] = C.fact[N];\n    mint c0 = 0;\n    FOR(n, 1, N + 1) c0 += C.fact[n];\n    /*\n    REP(i, H){\n        FOR(d, 1, D + 1){\n            if(i + d < H){\n                dp[i + d] += dp[i] * c0;\n            }else if(i + d == H){\n                dp[H] += dp[i];\n            }\n        }\n    }*/\n    mvec dpsum(H + 1, 0);\n    dpsum[1] = dp[0];\n    FOR(i, 1, H){\n        dp[i] = (dpsum[i] - dpsum[max(i - D, 0LL)]) * c0;\n        dpsum[i + 1] = dpsum[i] + dp[i];\n    }\n    mint ans = 0;\n    FOR(i, H - D, H) ans += dp[i];\n    //vdebug(dp);\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for(register int i = x;i <= y; ++ i)\n#define repd(i,x,y) for(register int i = x;i >= y; -- i)\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T>inline void read(T&x)\n{\n\tchar c;int sign = 1;x = 0;\n\tdo { c = getchar(); if(c == '-') sign = -1; }while(!isdigit(c));\n\tdo { x = x * 10 + c - '0'; c = getchar(); }while(isdigit(c));\n\tx *= sign;\n}\n\nconst int mod = 1e9 + 7,N = 1e6 + 50;\nint f[N],fac[N],m,n,h,d;\n\ninline int ksm(int x,int y)\n{\n\tint ans = 1;\n\twhile(y)\n\t{\n\t\tif(y&1) ans = 1ll * ans * x % mod;\n\t\ty >>= 1; x = 1ll * x * x % mod;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tread(n); read(h); read(d);\n\tf[0] = 1; fac[0] = 1;\n\trep(i,1,n) fac[i] = 1ll * fac[i-1] * i % mod;\n\trep(i,1,n) m = (m + fac[i]) % mod;\n\n\trep(i,1,h)\n\t{\n\t\tf[i] = 1ll * (f[i - 1] - (i - d - 1 >= 0 ? f[i - d - 1] : 0)) * m % mod;\n\t\tif(f[i] < 0) f[i] = f[i] + mod;\n\n\t\tf[i] = (f[i-1] + f[i]) % mod;\n\t}\n\t\n\tcout << 1ll * (f[h] - f[h-1] + mod) % mod * fac[n] % mod * ksm(m,mod-2) % mod << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#define ms(s, n) memset(s, n, sizeof(s))\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define FORd(i, a, b) for (int i = (a) - 1; i >= (b); --i)\n#define FORall(it, a) for (__typeof((a).begin()) it = (a).begin(); it != (a).end(); it++)\n#define sz(a) int((a).size())\n#define present(t, x) (t.find(x) != t.end())\n#define all(a) (a).begin(), (a).end()\n#define uni(a) (a).erase(unique(all(a)), (a).end())\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define fi first\n#define se second\n#define prec(n) fixed<<setprecision(n)\n#define bit(n, i) (((n) >> (i)) & 1)\n#define bitcount(n) __builtin_popcountll(n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pi;\ntypedef vector<int> vi;\ntypedef vector<pi> vii;\nconst int MOD = (int) 1e9 + 7;\nconst int FFTMOD = 119 << 23 | 1;\nconst int INF = (int) 1e9 + 23111992;\nconst ll LINF = (ll) 1e18 + 23111992;\nconst ld PI = acos((ld) -1);\nconst ld EPS = 1e-9;\ninline ll gcd(ll a, ll b) {ll r; while (b) {r = a % b; a = b; b = r;} return a;}\ninline ll lcm(ll a, ll b) {return a / gcd(a, b) * b;}\ninline ll fpow(ll n, ll k, int p = MOD) {ll r = 1; for (; k; k >>= 1) {if (k & 1) r = r * n % p; n = n * n % p;} return r;}\ntemplate<class T> inline int chkmin(T& a, const T& val) {return val < a ? a = val, 1 : 0;}\ntemplate<class T> inline int chkmax(T& a, const T& val) {return a < val ? a = val, 1 : 0;}\ninline ull isqrt(ull k) {ull r = sqrt(k) + 1; while (r * r > k) r--; return r;}\ninline ll icbrt(ll k) {ll r = cbrt(k) + 1; while (r * r * r > k) r--; return r;}\ninline void addmod(int& a, int val, int p = MOD) {if ((a = (a + val)) >= p) a -= p;}\ninline void submod(int& a, int val, int p = MOD) {if ((a = (a - val)) < 0) a += p;}\ninline int mult(int a, int b, int p = MOD) {return (ll) a * b % p;}\ninline int inv(int a, int p = MOD) {return fpow(a, p - 2, p);}\ninline int sign(ld x) {return x < -EPS ? -1 : x > +EPS;}\ninline int sign(ld x, ld y) {return sign(x - y);}\nmt19937 mt(chrono::high_resolution_clock::now().time_since_epoch().count());\ninline int mrand() {return abs((int) mt());}\n#define db(x) cerr << \"[\" << #x << \": \" << (x) << \"] \";\n#define endln cerr << \"\\n\";\n\nvoid chemthan() {\n    int n, d, h; cin >> n >> h >> d;\n    vi fac(n + 1);\n    fac[0] = 1; FOR(i, 1, n + 1) fac[i] = mult(fac[i - 1], i);\n    FOR(i, 2, n + 1) addmod(fac[i], fac[i - 1]);\n    vi dp(h + 1);\n    dp[0] = fac[n];\n    submod(dp[0], fac[n - 1]);\n    FOR(i, 1, h + 1) {\n        int lo = i - d;\n        int hi = i - 1;\n        addmod(dp[i], dp[hi]);\n        if (0 < lo) {\n            submod(dp[i], dp[lo - 1]);\n        }\n        if (i < h) {\n            dp[i] = mult(fac[n], dp[i]);\n            addmod(dp[i], dp[i - 1]);\n        }\n    }\n    cout << dp[h] << \"\\n\";\n}\n\nint main(int argc, char* argv[]) {\n    ios_base::sync_with_stdio(0), cin.tie(0);\n    if (argc > 1) {\n        assert(freopen(argv[1], \"r\", stdin));\n    }\n    if (argc > 2) {\n        assert(freopen(argv[2], \"wb\", stdout));\n    }\n    chemthan();\n    cerr << \"\\nTime elapsed: \" << 1000 * clock() / CLOCKS_PER_SEC << \"ms\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<list>\n#include<set>\n#include<string>\nusing namespace std;\nint gcd(int a, int b) {\n\tint c = a % b;\n\twhile (c != 0) {\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\treturn b;\n}\nstruct UnionFind {\n\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n\n\tUnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n\n\tint root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\n\tvoid unite(int x, int y) { // xとyの木を併合\n\t\tint rx = root(x); //xの根をrx\n\t\tint ry = root(y); //yの根をry\n\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t}\n\n\tbool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\treturn rx == ry;\n\t}\n};\ntypedef long long ll;\n\nll M = 1000000007;\n\nvector<ll> fac(300001); //n!(mod M)\nvector<ll> ifac(300001); //k!^{M-2} (mod M)\n\nll mpow(ll x, ll n) {\n\tll ans = 1;\n\twhile (n != 0) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nll comb(ll a, ll b) {\n\tif (a == 0 && b == 0)return 1;\n\tif (a < b || a < 0)return 0;\n\tll tmp = ifac[a - b] * ifac[b] % M;\n\treturn tmp * fac[a] % M;\n}\n// mod. m での a の逆元 a^{-1} を計算する\nlong long modinv(long long a) {\n\tlong long b = M, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= M;\n\tif (u < 0) u += M;\n\treturn u;\n}\nvector<vector<ll>> mul(vector<vector<ll>> a,vector<vector<ll>> b,int n){\n\tint i,j,k,t;\n\tvector<vector<ll>> c(n);\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tt = 0;\n\t\t\tfor (k = 0; k < n; k++)\n\t\t\t\tt = (t + a[i][k]*b[k][j] % M)%M;\n\t\t\tc[i].push_back(t);\n\t\t}\n\t}\n\treturn c;\n}\nint main() {\n\tll n, h, d, dp[1111111], sum[1111111], p = 1,k=0, i,ans=0;\n\tcin >> n >> h >> d;\n\tfor (i = 1; i <= n; i++) {\n\t\tp = p * i%M;\n\t\tk = (k + p) % M;\n\t}\n\tdp[0] = p;\n\tsum[0] = p;\n\tfor (i = 1; i < h; i++) {\n\t\tif (i - d <= 0)\n\t\t\tdp[i] = sum[i - 1] * k%M;\n\t\telse\n\t\t\tdp[i] = (M + sum[i - 1] - sum[i - d - 1])%M*k%M;\n\t\tsum[i] = (sum[i - 1] + dp[i]) % M;\n\t}\n\tans = (M + sum[h - 1] - sum[h - d - 1]) % M;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\ntypedef double DOUBLE;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst ll LL_INF = 1e17 + 10;\nconst int INF = 1e9 + 10;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 1e6 + 5;\n\nll dp[MAXN];\nll f[MAXN], f_sum[MAXN];\n\nvoid solve(){\n\tint n, h, d;\n\tscanf(\"%d%d%d\", &n, &h, &d);\n\tf[0] = 1, f_sum[0] = 0;\n\tREPN(i, 1, n) {\n\t\tf[i] = (f[i - 1] * i) % MOD;\n\t\tf_sum[i] = (f_sum[i - 1] + f[i]) % MOD;\n\t}\n\tdp[0] = f[n];\n\tll dp_sum = f[n];\n\tll ans = 0ll;\n\tREP(i, 1, h) {\n\t\tdp[i] = (dp_sum * f_sum[n]) % MOD;\n\t\tdp_sum = (dp_sum + dp[i]) % MOD;\n\t\tif (i >= d) {\n\t\t\tdp_sum = (dp_sum + MOD - dp[i - d]) % MOD;\n\t\t}\n\t}\n\t/*REP(i, 0, h) {\n\t\tprintf(\"%lld\\n\", dp[i]);\n\t}*/\n\tcout << dp_sum << endl;\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define ll long long\n#define MOD 1000000007\n#define MAX 2000200\nvoid add(int &x,int y){x+=y;if(x>=MOD)x-=MOD;}\ninline int read()\n{\n\tint x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nint n,H,D,jc[MAX],f[MAX],s[MAX];\nint fpow(int a,int b){int s=1;while(b){if(b&1)s=1ll*s*a%MOD;a=1ll*a*a%MOD;b>>=1;}return s;}\nint main()\n{\n\tn=read();H=read();D=read();\n\tjc[0]=1;for(int i=1;i<=n;++i)jc[i]=1ll*jc[i-1]*i%MOD;\n\tint sj=0;for(int i=1;i<=n;++i)sj=(sj+jc[i])%MOD;\n\tf[0]=s[0]=1;\n\tfor(int i=1;i<=H;++i)f[i]=1ll*sj*(s[i-1]+MOD-(i-D<=0?0:s[i-D-1]))%MOD,s[i]=(s[i-1]+f[i])%MOD;\n\tint ans=1ll*f[H]*jc[n]%MOD*fpow(sj,MOD-2)%MOD;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace mint {\n  int md = 1e9 + 7;\n  inline void add (int &a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    a += b; if (a >= md) a -= md;\n  }\n  inline void sub (int &a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    a -= b; if (a < 0) a += md;\n  }\n  inline int sum (int a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    add(a, b); return a;\n  }\n  inline int dif (int a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    sub(a, b); return a;\n  }\n  template<class... A>\n  inline int prod (A... args) {\n    long long ret = 1;\n    for (int a :\tinitializer_list<int>{args...}) {\n      assert(0 <= a && a < md);\n      ret *= a;\n      ret %= md;\n    }\n    return (int)(ret % md);\n  }\n  inline void mul (int &a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    a = prod(a, b);\n  }\n  inline int inv (int a) {\n    assert(0 <= a && a < md);\n    a %= md;\n    if(a < 0) a += md;\n    int b = md, u = 0, v = 1;\n    while (a) {\n      int t = b / a;\n      b -= a * t; swap(a, b);\n      u -= v * t; swap(u, v);\n    }\n    assert(b == 1);\n    if(u < 0) u += md;\n    return u;\n  }\n  inline int quot (int a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    return prod(a, inv(b));\n  }\n  inline void div (int& a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    a = quot(a, b);\n  }\n  inline int pow (int a, long long b) {\n    assert(0 <= a && a < md);\n    int res = 1;\n    for (; b; b >>= 1) {\n      if (b & 1) mul(res, a);\n      mul(a, a);\n    }\n    return res;\n  }\n  namespace factorials {\n    int sz;\n    vector<int> fact, finv;\n    void init (int n) {\n      sz = n;\n      fact.resize(n); finv.resize(n);\n      fact[0] = 1;\n      for (int i = 1; i < n; i++) fact[i] = prod(fact[i - 1], i);\n      finv[n - 1] = inv(fact[n - 1]);\n      for (int i = n - 2; i >= 0; i--) finv[i] = prod(finv[i + 1], i + 1);\n    }\n  }\n  inline int fct (int i) {\n    using namespace factorials;\n    assert(0 <= i && i < sz);\n    return fact[i];\n  }\n  inline int fnv (int i) {\n    using namespace factorials;\n    assert(0 <= i && i < sz);\n    return finv[i];\n  }\n  inline int binom (int n, int k) {\n    using namespace factorials;\n    assert(0 <= n && n < sz);\n    if (0 < k || n < k) return 0;\n    return prod(fact[n], finv[k], finv[n - k]);\n  }\n}\ntemplate <typename T>\nclass binary_indexed_tree {\n  int sz;\n  vector<T> tr;\n  function<T(T, T)> o;\n  function<T(T, T)> dif;\n  T id;\n  public:\n    binary_indexed_tree (\n      int n\n    , function<T(T, T) > o = [](int a, int b) {return a + b;}\n    , function<T(T, T) > dif = [](int a, int b) {return a - b;}\n    , T id = 0\n    )\n    : sz(n)\n    , tr(n, id)\n    , o(o)\n    , dif(dif)\n    , id(id)\n    {\n    }\n    T query (int l, int r) {\n      assert(0 <= l && l <= r && r <= sz);\n      if (l == 0) {\n        r--;\n        T ret = 0;\n        for (; r >= 0; r &= r + 1, r--) ret = o(ret, tr[r]);\n        return ret;\n      }\n      return dif(query(0, r), query(0, l));\n    }\n    void add (int i, T x) {\n      for (; i < sz; i |= i + 1) tr[i] = o(tr[i], x);\n    }\n    void print() {\n      cout << \"bit: \";\n      for (int i = 0; i < sz; i++) {\n        cout << query(i, i + 1);\n        if (i == sz - 1) break;\n        cout << ' ';\n      }\n      cout << endl;\n    }\n};\nint main() {\n  cin.tie(0); cin.sync_with_stdio(false);\n  int n, h, d;\n  cin >> n >> h >> d;\n  mint::factorials::init(n + 1);\n  int B = 0;\n  for (int i = 1; i <= n; i++) {\n    mint::add(B, mint::fct(i));\n  }\n  binary_indexed_tree<int> bit(\n    h,\n    [](int x, int y) {return mint::sum(x, y);},\n    [](int x, int y) {return mint::dif(x, y);}\n  );\n  bit.add(0, 1);\n  for (int i = 1; i < h; i++) {\n    bit.add(i, mint::prod(\n      bit.query(max(0, i - d), i),\n      B\n    ));\n  }\n  int ret = mint::prod(\n    bit.query(h - d, h),\n    mint::fct(n)\n  );\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (long long i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (long long i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n  {1, 0}, {0, 1}, {-1, 0}, {0, -1},  // 4方向\n  {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n  {0, 0},  // 自身\n};\ntemplate <class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T, class S> vector<T> make_vec(size_t n, S x) { return vector<T>(n, x); }\ntemplate <class T, class... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec<T>(ts...))>(n, make_vec<T>(ts...)); }\n\n// debug\ntemplate <class T> ostream& operator<<(ostream& s, vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream& s, vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, unordered_map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n  #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n  #define dump(...)\n  #define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\n\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 1000000007;\n// *************** TEMPLATE END *************** \n\ntemplate <class T>\nT pow(T x, int n, const T UNION = 1) {\n  T ret = UNION;\n  while (n) {\n    if (n & 1) ret *= x;\n    x *= x; n >>= 1;\n  }\n  return ret;\n}\n\ntemplate <int MD>\nstruct ModInt {\n  int x;\n  static unordered_map<int, int> to_inv;\n  ModInt() : x(0) {}\n  ModInt(int x_) { if ((x = x_ % MD + MD) >= MD) x -= MD; }\n\n  ModInt& operator+=(ModInt that) { if ((x += that.x) >= MD) x -= MD; return *this; }\n  ModInt& operator*=(ModInt that) { x = x * that.x % MD; return *this; }\n  ModInt& operator-=(ModInt that) { if ((x -= that.x) < 0) x += MD; return *this; }\n  ModInt& operator/=(ModInt that) { x = x * that.inv().x % MD; return *this; }\n\n  ModInt operator-() const { return -x < 0 ? MD - x : -x; }\n  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n  bool operator==(ModInt that) const { return x == that.x; }\n  bool operator!=(ModInt that) const { return x != that.x; }\n  ModInt inv() const { return to_inv.count(this->x) ? to_inv[this->x] : (to_inv[this->x] = pow(*this, MD - 2).x); }\n  friend ostream& operator<<(ostream& s, ModInt<MD> a) { s << a.x; return s; }\n  friend istream& operator>>(istream& s, ModInt<MD>& a) { s >> a.x; return s; }\n};\ntemplate <int MD> unordered_map<int, int> ModInt<MD>::to_inv;\nusing mint = ModInt<MOD>;\n\nvector<mint> fact, fact_inv;\nvoid init_factorial(int n) {\n  fact = vector<mint>(n + 1, 1);\n  fact_inv = vector<mint>(n + 1);\n  for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n  fact_inv[n] = mint(1) / fact[n];\n  for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n  // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n}\nmint comb(int n, int r) {\n  return fact[n] * fact_inv[r] * fact_inv[n - r];\n}\n\n// T0: 元の配列のモノイド\n// T1: T0に対する作用素モノイド\ntemplate <class T0, class T1>\nclass SegmentTree {\n  // k番目のノードにのlazyを伝搬\n  void eval(int k, int len) {\n    // u1が正確に単位元ならいらない\n    // if (lazy[k] == u1) return;\n    // len個分のlazy[k]を評価\n    node[k] = g(node[k], p(lazy[k], len));\n    if (k < N - 1) {\n      // 最下段でなければ下のlazyに伝搬\n      lazy[2 * k + 1] = f1(lazy[2 * k + 1], lazy[k]);\n      lazy[2 * k + 2] = f1(lazy[2 * k + 2], lazy[k]);\n    }\n    lazy[k] = u1;\n  }\n  // k番目のノード[l, r)について、[a, b)の範囲内にxを作用\n  void update(int a, int b, T1 x, int k, int l, int r) {\n    eval(k, r - l);\n    if (b <= l || r <= a) return;\n    if (a <= l && r <= b) {\n      lazy[k] = f1(lazy[k], x);\n      eval(k, r - l);\n    } else {\n      update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n      update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n      node[k] = f0(node[2 * k + 1], node[2 * k + 2]);\n    }\n  }\n  // k番目のノード[l, r)について、[a, b)のクエリを求める\n  T0 query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return u0;\n    eval(k, r - l);\n    if (a <= l && r <= b) return node[k];\n    T0 vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n    T0 vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n    return f0(vl, vr);\n  }\npublic:\n  int sz; // 元の配列のサイズ\n  int N;\n  vector<T0> node;\n  vector<T1> lazy;\n  // T0上の演算、単位元\n  using F0 = function<T0(T0, T0)>;\n  F0 f0; T0 u0;\n  // T1上の演算、単位元\n  using F1 = function<T1(T1, T1)>;\n  F1 f1; T1 u1;\n  // 作用\n  using G = function<T0(T0, T1)>;\n  G g;\n  // 多数のt1(T1)に対するf1の合成\n  using P = function<T1(T1, int)>;\n  P p;\n  SegmentTree(const vector<T0>& a, F0 f0, T0 u0, F1 f1, T1 u1, G g, P p)\n  : sz(a.size()), f0(f0), u0(u0), f1(f1), u1(u1), g(g), p(p) {\n    for (N = 1; N < sz; N *= 2);\n    node.resize(2 * N - 1);\n    lazy.resize(2 * N - 1, u1);\n    REP (i, sz) node[N - 1 + i] = a[i];\n    for (int i = N - 2; i >= 0; i--) node[i] = f0(node[2 * i + 1], node[2 * i + 2]);\n  }\n  // [a, b)にxを作用\n  void update(int a, int b, T1 x) {\n    assert(0 <= a && a < b && b <= sz);\n    update(a, b, x, 0, 0, N);\n  }\n  void update(int a, T1 x) {\n    update(a, a + 1, x);\n  }\n  // [a, b)\n  T0 query(int a, int b) {\n    return query(a, b, 0, 0, N);\n  }\n  T0 query(int a) {\n    return query(a, a + 1);\n  }\n};\n\nsigned main() {\n  int n, H, D; cin >> n >> H >> D;\n  init_factorial(n + 10);\n  mint mul = 0;\n  REPI (i, 1, n + 1) {\n    mul += fact[i];\n  }\n\n  // Sum & Add\n  SegmentTree<mint, mint> seg(\n    vector<mint>(H + 1, 0),\n    plus<mint>(), 0,\n    plus<mint>(), 0,\n    plus<mint>(),\n    multiplies<mint>()\n  );\n  seg.update(0, fact[n] / mul);\n  REP (i, H) {\n    mint now = seg.query(i);\n    seg.update(i + 1, min(H + 1, i + D + 1), now * mul);\n  }\n  cout << seg.query(H) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class T> vector<T> make_vec(size_t a) { return vector<T>(a); }\ntemplate<class T, class... Ts> auto make_vec(size_t a, Ts... ts) {\n  return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\ntemplate<class T, class V>\ntypename enable_if<is_class<T>::value == 0>::type fill(T &t, const V &v) {\n    t = v;\n}\ntemplate<class T, class V>\ntypename enable_if<is_class<T>::value != 0>::type fill(T &t, const V &v){\n    for (auto &e : t) fill(e, v);\n}\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\n\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef() {}\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        init(n);\n    }\n    constexpr void init(int n) noexcept {\n        fact_.assign(n, 1), inv_.assign(n, 1), finv_.assign(n, 1);\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\nconst int MOD = 1000000007;\nusing mint = Fp<MOD>;\nBiCoef<mint> bc;\n\nconst int MAX = 2100000;\n\nint N, H, D;\nmint dp[MAX], sdp[MAX];\n\nmint solve() {\n    bc.init(MAX);\n    mint fac = 0;\n    for (int i = 1; i <= N; ++i) fac += bc.fact(i);\n\n    //COUT(fac);\n\n    memset(dp, 0, sizeof(dp));\n    memset(sdp, 0, sizeof(sdp));\n    dp[0] = bc.fact(N);\n    sdp[1] = bc.fact(N);\n    for (int v = 1; v <= H; ++v) {\n        int left = max(0, v - D);\n        int right = v;\n        dp[v] = (sdp[right] - sdp[left]) * fac;\n        sdp[v+1] = sdp[v] + dp[v];\n\n        //cout << v << \": \" << dp[v] << endl;\n    }\n\n    mint res = 0;\n    for (int v = max(0, H - D); v <= H-1; ++v) {\n        res += dp[v];\n    }\n    return res;\n}\n\n\nint main() {\n    while (cin >> N >> H >> D) {\n        cout << solve() << endl;\n    }\n}\n\n    \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7,N=1e6+5;\nll n,h,d,f[N],sum[N],s;\nint main()\n{\n    scanf(\"%lld%lld%lld\",&n,&h,&d);\n    f[0]=1;\n    for(int i=1;i<=n;i++)\n        f[i]=f[i-1]*i%mod,s+=f[i];\n    s%=mod;\n    sum[1]=1;\n    for(int i=2;i<=h;i++)\n        sum[i]=(sum[i-1]+(sum[i-1]-sum[max(0ll,i-d-1)])*s)%mod;\n    printf(\"%lld\\n\",(sum[h]-sum[h-d])*f[n]%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 1000010\n#define modn 1000000007\nint f[maxn],fac[maxn],sum[maxn],n,d,h,i,s=0,ans;\nint power(int x,int y)\n{\n\tint s=1,i=x;\n\tfor (;y;y>>=1)\n\t{\n\t\tif (y&1) s=1LL*s*i%modn;\n\t\ti=1LL*i*i%modn;\n\t}\n\treturn s;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&d);\n\tfac[1]=sum[1]=1;\n\tfor (i=2;i<=n;i++)\n\t{\n\t\tfac[i]=1LL*fac[i-1]*i%modn;\n\t\tsum[i]=(sum[i-1]+fac[i])%modn;\n\t}\n\tf[0]=fac[n];\n\ts=f[0];\n\tfor (i=1;i<=h;i++)\n\t{\n\t\tf[i]=1LL*s*sum[n]%modn;\n\t\ts=(s+f[i])%modn;\n\t\tif (i-d>=0) s=(s-f[i-d]+modn)%modn;\n\t}\n\tans=1LL*f[h]*power(sum[n],modn-2)%modn;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <iomanip>\n#include <stdio.h>\n#include <string.h>\n#include <random>\n#include <functional>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::fill;\n\nusing std::setprecision;\nusing std::fixed;\n\nlong long min(long long a, long long b) {return a < b ? a : b;}\nlong long min(int a, long long b) {return a < b ? a : b;}\nlong long min(long long a, int b) {return a < b ? a : b;}\nlong long min(int a, int b) {return a < b ? a : b;}\n\nlong long max(long long a, long long b) {return a > b ? a : b;}\nlong long max(int a, long long b) {return a > b ? a : b;}\nlong long max(long long a, int b) {return a > b ? a : b;}\nlong long max(int a, int b) {return a > b ? a : b;}\n\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n\nconst int N = 1522220;\nconst int MOD = 1e9 + 7;\nconst double eps = 1e-8;\nconst int K = 5;\n\nll inq(ll x, ll y)\n{\n    if (y == 0) return 1;\n    ll l = inq(x, y / 2);\n    if (y % 2) return l * l % MOD * x % MOD;\n    return l * l % MOD;\n}\n\nll n, h, d;\nll kek;\nll fact[N];\nll dp[N], s[N];\n\nll si(int p)\n{\n    if (p < 0) return 0;\n    return s[p];\n}\n\nsigned main()\n{\n    srand(time(NULL));\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> h >> d;\n    fact[0] = 1;\n    for (int i = 1; i < N; i++) fact[i] = fact[i - 1] * i % MOD;\n    for (int i = 1; i <= n; i++) kek = (kek + fact[i]) % MOD;\n    dp[0] = 1;\n    s[0] = 1;\n    for (int i = 1; i <= h; i++)\n    {\n        dp[i] = kek * (si(i - 1) + MOD - si(i - d - 1)) % MOD;\n        s[i] = (s[i - 1] + dp[i]) % MOD;\n    }\n    cout << dp[h] * fact[n] % MOD * inq(kek, MOD - 2) % MOD;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof(x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define y0 _z_y0\n#define y1 _z_y1\n#define x0 _z_x0\n#define x1 _z_x1\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ull;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nvoid enable_comma(){}\nstring tostring(char c);\nstring tostring(LL x);\ntemplate <class A,class B> string tostring(pair <A,B> p);\ntemplate <class A> string tostring(vector <A> v);\nstring tostring(char c){\n\tstring s=\"\";\n\ts+=c;\n\treturn s;\n}\nstring tostring(string s){\n\treturn \"\\\"\"+s+\"\\\"\";\n}\nstring tostring(char *c){\n\treturn tostring((string)c);\n}\nstring tostring(LL x){\n\tif (x<0)\n\t\treturn \"-\"+tostring(-x);\n\tif (x>9)\n\t\treturn tostring(x/10)+tostring(char('0'+x%10));\n\telse\n\t\treturn tostring(char('0'+x));\n}\nstring tostring(int x){\n\treturn tostring((LL)x);\n}\nstring tostring(ull x){\n\tif (x>9)\n\t\treturn tostring((LL)(x/10))+tostring(char('0'+x%10));\n\telse\n\t\treturn tostring(char('0'+x));\n}\nstring tostring(uint x){\n\treturn tostring((LL)x);\n}\nstring tostring(double x){\n\tstatic char res[114];\n\tsprintf(res,\"%lf\\n\",x);\n\treturn tostring(res);\n}\nstring tostring(LD x){\n\treturn tostring((double)x);\n}\ntemplate <class A,class B> string tostring(pair <A,B> p){\n\treturn \"(\"+tostring(p.fi)+\",\"+tostring(p.se)+\")\";\n}\n\ntemplate <class A> string tostring(vector <A> v){\n\tstring res=\"{\";\n\tFor(i,0,(int)v.size()-1){\n\t\tres+=tostring(v[i]);\n\t\tres+=i==(int)v.size()-1?\"}\":\",\";\n\t}\n\tif (res==\"{\")\n\t\tres+=\"}\";\n\treturn res;\n}\ntemplate <class A> string tostring(A a,int L,int R){\n\tstring res=\"{\";\n\tFor(i,L,R){\n\t\tres+=tostring(a[i]);\n\t\tres+=i==R?\"}\":\",\";\n\t}\n\tif (res==\"{\")\n\t\tres+=\"}\";\n\treturn res;\n}\nstring tostrings(){\n\treturn \"\";\n}\ntemplate <typename Head,typename... Tail>\nstring tostrings(Head H,Tail... T){\n\treturn tostring(H)+\" \"+tostrings(T...);\n}\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\n#ifdef zzd\n\t#define outval(x) cerr<<#x\" = \"<<tostring(x)<<endl\n\t#define outvals(...) cerr<<\"[\"<<#__VA_ARGS__<<\"]: \"<<tostrings(__VA_ARGS__)<<endl\n\t#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n\t#define outsign(x) cerr<<\"<\"#x\">\"<<endl\n\t#define outarr(a,L,R) cerr<<#a\"[\"<<(L)<<\"..\"<<(R)<<\"] = \"<<tostring(a,L,R)<<endl\n#else\n\t#define outval(x) enable_comma()\n\t#define outvals(...) enable_comma()\n\t#define outtag(x) enable_comma()\n\t#define outsign(x) enable_comma()\n\t#define outarr(a,L,R) enable_comma()\n#endif\n#ifdef ONLINE_JUDGE\n\t#ifdef assert\n\t\t#undef assert\n\t#endif\n\t#define assert(x) (!(x)?\\\n\t\t\tcout<<\"Assertion failed!\"<<endl<<\\\n\t\t\t\"function: \"<<__FUNCTION__<<endl<<\\\n\t\t\t\"line: \"<<__LINE__<<endl<<\\\n\t\t\t\"expression: \"<<#x<<endl,exit(3),0:1)\n#endif\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\ntemplate <class T> void ckmax(T &x,const T y){\n\tif (x<y)\n\t\tx=y;\n}\ntemplate <class T> void ckmin(T &x,const T y){\n\tif (x>y)\n\t\tx=y;\n}\nconst int mod=1e9+7;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nint md(LL x){\n\treturn (x%mod+mod)%mod;\n}\nconst int N=1000005*2;\nint fac[N],ifac[N],sfac[N];\nvoid prework(){\n\tint n=N-1;\n\tfac[0]=1;\n\tFor(i,1,n)\n\t\tfac[i]=(LL)fac[i-1]*i%mod;\n\tifac[n]=Pow(fac[n],mod-2);\n\tFod(i,n,1)\n\t\tifac[i-1]=(LL)ifac[i]*i%mod;\n\tsfac[0]=1;\n\tFor(i,1,n)\n\t\tsfac[i]=Add(sfac[i-1]+fac[i]);\n}\nint C(int n,int m){\n\tif (m<0||m>n)\n\t\treturn 0;\n\treturn (LL)fac[n]*ifac[m]%mod*ifac[n-m]%mod;\n}\nint n,d,h;\nint main(){\n\tprework();\n\tn=read(),h=read(),d=read();\n\tint ans=0;\n\tFor(i,0,(h-1)/(d+1))\n\t\tans=md(ans+(LL)(i&1?-1:1)*Pow(sfac[n],h-i*d-i-1)%mod*Pow(sfac[n]-1,i)%mod*C(h-i*d-1,i)%mod);\n\tFor(i,1,h/(d+1))\n\t\tans=md(ans+(LL)(i&1?-1:1)*Pow(sfac[n],h-i*d-(i-1)-1)%mod*Pow(sfac[n]-1,i-1)%mod*C(h-i*d-1,i-1)%mod);\n\tans=(LL)ans*fac[n]%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7,N=1e6+5;\nll n,h,d,f[N],sum[N],s;\nint main()\n{\n    scanf(\"%lld%lld%lld\",&n,&h,&d);\n    f[0]=1;\n    for(int i=1;i<=n;i++)\n        f[i]=f[i-1]*i%mod,s=(s+f[i])%mod;\n    sum[1]=1;\n    for(int i=2;i<=h;i++)\n        sum[i]=(sum[i-1]+(sum[i-1]-sum[max(0ll,i-d-1)])*s)%mod;\n    printf(\"%lld\\n\",(sum[h]-sum[h-d])*f[n]%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long dp[1000005];\n\nconst long long MOD = 1e9+7;\n\nint main(){\n    int N, H, D;\n    scanf(\"%d%d%d\", &N, &H, &D);\n\n    long long retainWays = 0;\n    long long fact = 1;\n    for(int i = 1; i <= N; i ++){\n        fact = fact*i%MOD;\n        retainWays += fact;\n    }\n    retainWays %= MOD;\n\n    //printf(\"retainWays=%lld\\n\", retainWays);\n\n    dp[0] = fact;\n    long long slidingWindowSum = dp[0];\n    for(int i = 1; i <= H; i ++){\n        dp[i] = slidingWindowSum;\n\n        dp[i] %= MOD;\n\n        if(i == H){break;}\n\n        dp[i] = dp[i]*retainWays%MOD;\n        slidingWindowSum += dp[i];\n        if(i >= D){slidingWindowSum -= dp[i-D];}\n\n        slidingWindowSum = (slidingWindowSum+MOD);\n        if(slidingWindowSum >= MOD){slidingWindowSum -= MOD;}\n\n        //printf(\"dp[%d]=%lld\\n\", i, dp[i]);\n    }\n\n    printf(\"%lld\", dp[H]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Link : https://codeforces.com/contest/1284/problem/D\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 1000005\n#define mod 1000000007\nint add(int x,int y) {\n  return ((x+y)%mod + mod)%mod;\n}\nint mul(int x,int y) {\n  return (ll)x*y%mod;\n}\nint dp[N];\nvoid solve() {\n  int n,h,d;scanf(\"%d %d %d \", &n,&h,&d);\n  int fac = 1,sum = 0;\n  for(int i=1;i<=n;++i) {\n    fac = mul(fac,i);\n    sum = add(sum,fac);\n  }\n  dp[0] = 1;\n  dp[1] = add(dp[1],-1);\n  for(int p = 0;p<h;++p) {\n    int ed = min(p + d,h);\n    dp[p+1] = add(dp[p+1], mul(sum,dp[p]));\n    dp[ed+1] = add(dp[ed+1],-mul(sum,dp[p]));\n\n    dp[p+1] = add(dp[p+1],dp[p]);\n  }\n  int ret = 0;\n  for(int i=1;i<=d;++i) {\n    ret = add(ret, mul(fac,dp[h-i]));\n  }\n  printf(\"%d\\n\", ret);\n}\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define DBG(v) cerr << #v << \" = \" << (v) << endl;\n\nconst int mod = (int) 1e9 + 7;\nconst int Mx = (int) 1e6 + 9;\n\nll fact[Mx + 9];\nll factInv[Mx + 9];\nll dp[Mx + 9];\n\nll C(const int n, const int k) {\n\treturn fact[n] * factInv[k] % mod * factInv[n - k] % mod;\n}\n\nll modPow(ll n, ll k) {\n\tll res = 1;\n\tfor (n %= mod; k; k >>= 1) {\n\t\tif (k & 1)\n\t\t\tres = res * n % mod;\n\t\tn = n * n % mod;\n\t}\n\treturn res;\n}\n\nll modInv(const ll x) {\n\treturn modPow(x, mod - 2);\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr), cout.tie(nullptr);\n\n\tfact[0] = factInv[0] = 1;\n\tfor (int i = 1; i <= Mx; ++i) {\n\t\tfact[i] = fact[i - 1] * i % mod;\n\t\tfactInv[i] = modInv(fact[i]);\n\t}\n\n\tint N, H, D;\n\tcin >> N >> H >> D;\n\n\tll K = 0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tK += fact[i + 1];\n\t\tK %= mod;\n\t}\n\n\tdp[H] = 1;\n\n\tfor (int h = H - 1; h >= 1; --h) {\n\t\tdp[h] = K * (dp[h + 1] - dp[min(H, h + D) + 1]) % mod;\n\t\tdp[h] += dp[h + 1];\n\t\tdp[h] %= mod;\n\t}\n\n\tconst ll res = fact[N] * (dp[1] - dp[min(H, D) + 1]);\n\tcout << (res % mod + mod) % mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nvector<long long> fact(1000001, 1);\n\nint solve(int N, int H, int D){\n    vector<long long> dp(H, 0);\n    dp[0] = fact[N];\n    long long factSum = 0;\n    for(int i=1;i<=N;i++) factSum = (factSum + fact[i]) % MOD;\n    long long sum = dp[0];\n    for(int i=1;i<H;i++){\n        dp[i] = (sum * factSum) % MOD;\n        sum = (sum + dp[i]) % MOD;\n        if(i - D >= 0) sum = (sum + MOD - dp[i-D]) % MOD;\n    }\n    return sum;\n}\n\nint main(){\n    fact[0] = fact[1] = 1;\n    for(int i=2;i<=1000000;i++) fact[i] = (fact[i-1]*i) % MOD;\n    int N, H, D;\n    while(cin >> N >> H >> D){\n        cout << solve(N, H, D) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=1e6+5,mo=1e9+7;\nint n,h,d,fac[N],i,f[N],s,ss,ans;\nint main(){\n\tscanf(\"%d%d%d\",&n,&h,&d);\n\tfor(i=*fac=1;i<=n;++i)fac[i]=1ll*i*fac[i-1]%mo,ss=(ss+fac[i])%mo;\n\tfor(i=1,*f=s=fac[n];i<=h;++i){\n\t\tif(i>d)s=(s+mo-f[i-d-1])%mo;\n\t\tf[i]=i==h?s:1ll*ss*s%mo,s=(s+f[i])%mo;\n\t}\n\tprintf(\"%d\\n\",f[h]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7,maxn=1000000;\nint n,h,d,ans,jc[2222222],pre[2222222],sum[2222222],dp[2222222];\nvoid Init()\n{\n\tjc[0]=1;\n\tfor (int i=1;i<=maxn;i++) jc[i]=1ll*jc[i-1]*i%mod;\n\tpre[0]=1;\n\tfor (int i=1;i<=maxn;i++) pre[i]=(pre[i-1]+jc[i])%mod;\n}\nint binpow(int a,int t)\n{\n\tint res=1,p=a;\n\tfor (int i=t;i;i>>=1)\n\t{\n\t\tif (i&1) res=1ll*res*p%mod;\n\t\tp=1ll*p*p%mod; \n\t}\n\treturn res;\n}\nint main()\n{\n\tcin>>n>>h>>d;\n\tInit();\n\tdp[0]=1;sum[0]=1;\n\tfor (int i=1;i<h;i++)\n\t{\n\t\tint cur=sum[i-1];\n\t\tif (i-1-d>=0) cur=(cur-sum[i-1-d])%mod;\n\t\tdp[i]=1ll*cur*(pre[n]-1)%mod;\n\t\tsum[i]=(sum[i-1]+dp[i])%mod;\n\t}\n\tfor (int i=0;i<h;i++)\n\t{\n\t\tif (i+d>=h) ans=(ans+dp[i])%mod;\n\t}\n\tans=1ll*ans*jc[n]%mod;\n\tprintf(\"%d\\n\",(ans+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 1000001;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a%b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) *b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\n\n///////////////////////////\n\n\nint main() {\n\t\n\tll N, H, D;\n\tcin >> N >> H >> D;\n\n\tvector<ll> frac(N + 1);\n\n\tfrac[0] = 1;\n\trepn(i, N) frac[i] = frac[i - 1] * i%MOD;\n\n\tll F = 0;\n\trepn(i, N) F = (F + frac[i]) % MOD;\n\n\tvector<ll> dp(H + 1);\n\tdp[0] = frac[N];\n\n\tll X = frac[N];\n\trepn(i, H-1) {\n\t\tdp[i] = X * F%MOD;\n\n\t\tX += dp[i];\n\t\tif (i >= D) { X -= dp[i - D]; }\n\n\t\tX %= MOD;\n\t\tif (X < 0) { X += MOD; }\n\t}\n\n\tcout << X;\n\n\tsystem(\"PAUSE\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n#define REP(i, n) for (int i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (int i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n    {1, 0}, {0, 1},  {-1, 0},  {0, -1},  // 4方向\n    {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n    {0, 0},                              // 自身\n};\ntemplate <class T>\ninline bool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T>\ninline bool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T, class S>\nvector<T> make_vec(size_t n, S x) {\n    return vector<T>(n, x);\n}\ntemplate <class T, class... Ts>\nauto make_vec(size_t n, Ts... ts) {\n    return vector<decltype(make_vec<T>(ts...))>(n, make_vec<T>(ts...));\n}\n\n// debug\ntemplate <class T>\nostream& operator<<(ostream& s, vector<T>& d) {\n    REP(i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \");\n    return s;\n}\ntemplate <class T>\nostream& operator<<(ostream& s, vector<vector<T>>& d) {\n    REP(i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\");\n    return s;\n}\ntemplate <class T, class S>\nostream& operator<<(ostream& s, pair<T, S>& p) {\n    s << \"{\" << p.first << \", \" << p.second << \"}\";\n    return s;\n}\ntemplate <class T, class S>\nostream& operator<<(ostream& s, map<T, S> m) {\n    for (auto it = m.begin(); it != m.end(); it++) {\n        s << *it << (next(it) == m.end() ? \"\" : \"\\n\");\n    }\n    return s;\n}\ntemplate <class T, class S>\nostream& operator<<(ostream& s, unordered_map<T, S> m) {\n    for (auto it = m.begin(); it != m.end(); it++) {\n        s << *it << (next(it) == m.end() ? \"\" : \"\\n\");\n    }\n    return s;\n}\n#ifdef _MY_DEBUG\n#define dump(...)                                                                                                     \\\n    cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), \\\n        cerr << \"*/\\n\\n\";\n#else\n#define dump(...)\n#define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail>\nvoid dump_func(Head&& h, Tail&&... t) {\n    cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...);\n}\n\nstruct Fast {\n    Fast() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n    }\n} fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 1000000007;\n// *************** TEMPLATE END ***************\n\ntemplate <class T>\nT pow(T x, int n, const T UNION = 1) {\n    T ret = UNION;\n    while (n) {\n        if (n & 1) ret *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return ret;\n}\n\ntemplate <int MD>\nstruct ModInt {\n    int x;\n    static unordered_map<int, int> to_inv;\n    ModInt() : x(0) {}\n    ModInt(int x_) {\n        if ((x = x_ % MD + MD) >= MD) x -= MD;\n    }\n\n    ModInt& operator+=(ModInt that) {\n        if ((x += that.x) >= MD) x -= MD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt that) {\n        x = (unsigned long long)x * that.x % MD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt that) {\n        if ((x -= that.x) < 0) x += MD;\n        return *this;\n    }\n    ModInt& operator/=(ModInt that) {\n        x = (unsigned long long)x * that.inv().x % MD;\n        return *this;\n    }\n\n    ModInt operator-() const { return -x < 0 ? MD - x : -x; }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt inv() const { return to_inv.count(this->x) ? to_inv[this->x] : (to_inv[this->x] = pow(*this, MD - 2).x); }\n    friend ostream& operator<<(ostream& s, ModInt<MD> a) {\n        s << a.x;\n        return s;\n    }\n    friend istream& operator>>(istream& s, ModInt<MD>& a) {\n        s >> a.x;\n        return s;\n    }\n};\ntemplate <int MD>\nunordered_map<int, int> ModInt<MD>::to_inv;\nusing mint = ModInt<MOD>;\n\nvector<mint> fact, fact_inv;\nvoid init_factorial(int n) {\n    fact = vector<mint>(n + 1, 1);\n    fact_inv = vector<mint>(n + 1);\n    for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n    fact_inv[n] = mint(1) / fact[n];\n    for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n    // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n}\nmint comb(int n, int r) { return fact[n] * fact_inv[r] * fact_inv[n - r]; }\n\n// T0: 元の配列のモノイド\n// T1: T0に対する作用素モノイド\ntemplate <class T0, class T1>\nclass SegmentTree {\n    // k番目のノードにのlazyを伝搬\n    void eval(int k, int len) {\n        // u1が正確に単位元ならいらない\n        if (lazy[k] == u1) return;\n        // len個分のlazy[k]を評価\n        node[k] = g(node[k], p(lazy[k], len));\n        if (k < N - 1) {\n            // 最下段でなければ下のlazyに伝搬\n            lazy[2 * k + 1] = f1(lazy[2 * k + 1], lazy[k]);\n            lazy[2 * k + 2] = f1(lazy[2 * k + 2], lazy[k]);\n        }\n        lazy[k] = u1;\n    }\n    // k番目のノード[l, r)について、[a, b)の範囲内にxを作用\n    void update(int a, int b, T1 x, int k, int l, int r) {\n        eval(k, r - l);\n        if (b <= l || r <= a) return;\n        if (a <= l && r <= b) {\n            lazy[k] = f1(lazy[k], x);\n            eval(k, r - l);\n        } else {\n            update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n            update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n            node[k] = f0(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n    // k番目のノード[l, r)について、[a, b)のクエリを求める\n    T0 query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return u0;\n        eval(k, r - l);\n        if (a <= l && r <= b) return node[k];\n        T0 vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        T0 vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return f0(vl, vr);\n    }\n\npublic:\n    int sz;  // 元の配列のサイズ\n    int N;\n    vector<T0> node;\n    vector<T1> lazy;\n    // T0上の演算、単位元\n    // using F0 = function<T0(T0, T0)>;\n    // F0 f0;\n    // T0 u0;\n    T0 f0(T0 x, T0 y) { return x + y; };\n    const T0 u0 = 0;\n    // T1上の演算、単位元\n    // using F1 = function<T1(T1, T1)>;\n    // F1 f1;\n    // T1 u1;\n    T1 f1(T0 x, T0 y) { return x + y; };\n    const T1 u1 = 0;\n    // 作用\n    // using G = function<T0(T0, T1)>;\n    // G g;\n    T0 g(T0 x, T1 y) { return x + y; };\n    // 多数のt1(T1)に対するf1の合成\n    // using P = function<T1(T1, int)>;\n    // P p;\n    T1 p(T1 x, int len) { return x * len; };\n    SegmentTree(const vector<T0>& a) : sz(a.size()) {\n        for (N = 1; N < sz; N *= 2)\n            ;\n        node.resize(2 * N - 1);\n        lazy.resize(2 * N - 1, u1);\n        REP(i, sz) node[N - 1 + i] = a[i];\n        for (int i = N - 2; i >= 0; i--) node[i] = f0(node[2 * i + 1], node[2 * i + 2]);\n    }\n    // [a, b)にxを作用\n    void update(int a, int b, T1 x) {\n        assert(0 <= a && a < b && b <= sz);\n        update(a, b, x, 0, 0, N);\n    }\n    void update(int a, T1 x) { update(a, a + 1, x); }\n    // [a, b)\n    T0 query(int a, int b) { return query(a, b, 0, 0, N); }\n    T0 query(int a) { return query(a, a + 1); }\n};\n\nsigned main() {\n    int n, H, D;\n    cin >> n >> H >> D;\n    init_factorial(n + 10);\n    mint mul = 0;\n    REPI(i, 1, n + 1) { mul += fact[i]; }\n\n    // Sum & Add\n    SegmentTree<mint, mint> seg(vector<mint>(H + 1, 0));\n    // SegmentTree<mint, mint> seg(vector<mint>(H + 1, 0), plus<mint>(), 0, plus<mint>(), 0, plus<mint>(),\n    //                             multiplies<mint>());\n    seg.update(0, fact[n] / mul);\n    REP(i, H) {\n        mint now = seg.query(i);\n        seg.update(i + 1, min(H + 1, i + D + 1), now * mul);\n    }\n    cout << seg.query(H) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* Blog: https://misteer.hatenablog.com/entry/diverta2019-2-E */\n\n#include <iostream>\n#include <vector>\n\ntemplate <int MOD>\nclass ModInt {\n    using lint = long long;\n\npublic:\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // assignment\n    ModInt& operator=(const ModInt& x) {\n        if (this != &x) { this->val = x.val; }\n        return *this;\n    }\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator~() const { return *this ^ (MOD - 2); }\n\n    // increment / decrement\n    ModInt& operator++() { return *this += 1; }\n    ModInt& operator--() { return *this -= 1; }\n    ModInt operator++(int) {\n        ModInt before = *this;\n        ++(*this);\n        return before;\n    }\n    ModInt operator--(int) {\n        ModInt before = *this;\n        --(*this);\n        return before;\n    }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator%(const ModInt& x) const { return ModInt(*this) %= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt operator^(const ModInt& x) const { return ModInt(*this) ^= x; }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator%=(const ModInt& x) {\n        val %= x.val;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= ~x; }\n    ModInt& operator^=(const ModInt& x) {\n        int n = x.val;\n        ModInt b = *this;\n        if (n < 0) n = -n, b = ~b;\n\n        *this = 1;\n        while (n > 0) {\n            if (n & 1) *this *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return *this;\n    }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    bool operator<(const ModInt& b) const { return val < b.val; }\n    bool operator<=(const ModInt& b) const { return val <= b.val; }\n    bool operator>(const ModInt& b) const { return val > b.val; }\n    bool operator>=(const ModInt& b) const { return val >= b.val; }\n\n    // I/O\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n};\n\ntemplate <int MOD>\nclass Combination {\n    using mint = ModInt<MOD>;\n\nprivate:\n    int MAX_V;\n    std::vector<mint> f, invf;\n\npublic:\n    explicit Combination(int N)\n        : MAX_V(N), f(MAX_V + 1), invf(MAX_V + 1) {\n        f[0] = 1;\n        for (int i = 1; i <= MAX_V; ++i) {\n            f[i] = f[i - 1] * i;\n        }\n\n        invf[MAX_V] = ~f[MAX_V];\n        for (int i = MAX_V - 1; i >= 0; --i) {\n            invf[i] = invf[i + 1] * (i + 1);\n        }\n    }\n\n    mint fact(int n) const { return f[n]; }\n    mint invfact(int n) const { return invf[n]; }\n    mint perm(int a, int b) const {\n        return a < b ? mint(0) : f[a] * invf[a - b];\n    }\n    mint comb(int a, int b) const {\n        return a < b ? mint(0) : f[a] * invf[a - b] * invf[b];\n    }\n};\n\nusing namespace std;\n\nconstexpr int MOD = 1e9 + 7;\nusing mint = ModInt<MOD>;\nconst Combination<MOD> C(1 << 20);\n\nint main() {\n    /* ----- 入力 ----- */\n    int N, H, D;\n    cin >> N >> H >> D;\n\n    /* ----- 1! + ... + N! ----- */\n    mint fsum = 0;\n    for (int l = 1; l <= N; ++l) {\n        fsum += C.fact(l);\n    }\n\n    /* ----- DP ----- */\n    vector<mint> dp(H + 1, 0), dpsum(H + 1, 0);\n    dp[0] = dpsum[0] = C.fact(N) / fsum;\n    // dp[h] = ブロック数の最大値がhで、そのような山の数が1個となるような操作数\n\n    for (int h = 1; h <= H; ++h) {\n        dp[h] = fsum * (dpsum[h - 1] -\n                        (h - D - 1 >= 0 ? dpsum[h - D - 1] : 0));\n        dpsum[h] = dpsum[h - 1] + dp[h];\n    }\n\n    cout << dp[H] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long fact[1000005];\nlong long dp[1000005];\n\nconst long long MOD = 1e9+7;\n\nint main(){\n    int N, H, D;\n    scanf(\"%d%d%d\", &N, &H, &D);\n\n    long long retainWays = 0;\n    fact[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        fact[i] = fact[i-1]*i%MOD;\n        retainWays += fact[i]%MOD;\n    }\n    retainWays %= MOD;\n\n    //printf(\"retainWays=%lld\\n\", retainWays);\n\n    dp[0] = fact[N];\n    long long slidingWindowSum = dp[0];\n    for(int i = 1; i <= H; i ++){\n        dp[i] = slidingWindowSum;\n\n        /*for(int j = 1; j <= min(i, D); j ++){\n            dp[i] += dp[i-j];\n        }*/\n\n        dp[i] %= MOD;\n\n        if(i == H){break;}\n\n        dp[i] = dp[i]*retainWays%MOD;\n        slidingWindowSum += dp[i];\n        if(slidingWindowSum >= 0){\n            slidingWindowSum -= dp[i-D];\n        }\n        slidingWindowSum = (slidingWindowSum+2*MOD)%MOD;\n\n        //printf(\"dp[%d]=%lld\\n\", i, dp[i]);\n    }\n\n    printf(\"%lld\", dp[H]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\n\nll mod=1e9+7;\nll dp[1000100];\nll pr[1000100];\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tint n,d,h; cin >> n >> h >> d;\n\tll p=1;\n\tll s=0;\n\tfor(ll i=1;i<=n;i++){\n\t\t(p*=i)%=mod;\n\t\t(s+=p)%=mod;\n\t}\n\tfor(int i=1;i<=h;i++){\n\t\tpr[i]=pr[i-1];\n\t\tll sum=(pr[i-1]-pr[max(0,i-d-1)])%mod;\n\t\tif(sum<0)sum+=mod;\n\t\t(dp[i]+=sum*s%mod)%=mod;\n\t\tif(i<=d)(dp[i]+=p)%=mod;\n\t\t(pr[i]+=dp[i])%=mod;\n\t}\n\tcout << dp[h] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n#include <numeric>\n#define M_PI       3.14159265358979323846\n\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define FILL(a, x) memset(a, x, sizeof(a))\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst int N = 1010000;\nconst LL MOD = 1000000007;\nLL fac[N];\nLL sfac[N];\nLL dp[N];\n\nint main() {\n\tLL n, h, d;\n\tcin >> n >> h >> d;\n\tfac[0] = fac[1] = 1;\n\tFOR(i, 1, n + 1) {\n\t\tfac[i] = (fac[i - 1] * i) % MOD;\n\t\tsfac[i] = (sfac[i - 1] + fac[i]) % MOD;\n\t}\n\tdp[0] = fac[n];\n\tLL s = dp[0];\n\tFOR(i, 1, h) {\n\t\tdp[i] = s * sfac[n];\n\t\ts = (s + dp[i])%MOD;\n\t\tif (i >= d)s = (s - dp[i - d] + MOD) % MOD;\n\t}\n\tcout << s << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int MOD = 1e9 + 7;\n\nint add(int a, int b) {\n    return (a + b) % MOD;\n}\n\nint sub(int a, int b) {\n    return (a - b + MOD) % MOD;\n}\n\nint mul(ll a, ll b) {\n    return (a * b) % MOD;\n}\n\nint main() {\n    int n, h, d;\n    cin >> n >> h >> d;\n\n    vector<int> f(n + 1);\n    f[0] = 1;\n    for (int i = 1; i <= n; i++)\n        f[i] = mul(f[i - 1], i);\n\n    int coef = accumulate(f.begin() + 1, f.end(), 0LL) % MOD;\n\n    vector<int> dp(h + 1), pref(h + 2);\n    dp[0] = f[n], pref[1] = f[n];\n    for (int i = 1; i <= h; i++) {\n        dp[i] = sub(pref[i], pref[max(i - d, 0)]);\n        pref[i + 1] = add(pref[i], mul(coef, dp[i]));\n    }\n\n    cout << dp[h] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nlint mo=1000000007;\n#define N 1001001\nlint zyo[N],zs[N],dp[N],ds[N];\nint main()\n{\n\tint n,h,d;\n\tcin>>n>>h>>d;\n\tzyo[0]=1;\n\trep(i,N-10) zyo[i+1]=(zyo[i]*(i+1))%mo;\n\tzs[0]=0;\n\trep(i,N-10) zs[i+1]=(zs[i]+zyo[i+1])%mo;\n\tdp[0]=1;ds[0]=0;ds[1]=1;\n\tREP(i,1,h){\n\t\tdp[i]=ds[i]-ds[max(0,i-d)];\n\t\tdp[i]+=mo;dp[i]%=mo;\n\t\tdp[i]*=zs[n];dp[i]%=mo;\n\t\tds[i+1]=ds[i]+dp[i];ds[i+1]%=mo;\n\t}\n\tlint out=ds[h]-ds[h-d];out+=mo;out%=mo;\n\tcout<<(out*zyo[n])%mo<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mn=1e6+10;\nconst ll mod=1e9+7;\nll spec=0;\nll dp[mn];\nint main(){\n    ll n,h,d,i;\n    cin>>n>>h>>d;\n    dp[0]=1;\n    ll f=1;\n    for(i=1;i<=n;i++)f=f*i%mod,spec=(spec+f)%mod;\n    ll sum=0;\n    for(i=1;i<=h;i++){\n        sum+=dp[i-1];\n        if(i-d-1>=0)sum-=dp[i-d-1];\n        sum%=mod;\n        if(i!=h)dp[i]=sum*spec%mod;\n        else dp[i]=sum;\n    }\n    for(i=1;i<=n;i++)dp[h]=dp[h]*i%mod;\n    printf(\"%lld\",dp[h]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n#define REP(i, n) for (int i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (int i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n  {1, 0}, {0, 1}, {-1, 0}, {0, -1},  // 4方向\n  {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n  {0, 0},  // 自身\n};\ntemplate <class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T, class S> vector<T> make_vec(size_t n, S x) { return vector<T>(n, x); }\ntemplate <class T, class... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec<T>(ts...))>(n, make_vec<T>(ts...)); }\n\n// debug\ntemplate <class T> ostream& operator<<(ostream& s, vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream& s, vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, unordered_map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n  #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n  #define dump(...)\n  #define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\n\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 1000000007;\n// *************** TEMPLATE END *************** \n\ntemplate <class T>\nT pow(T x, int n, const T UNION = 1) {\n  T ret = UNION;\n  while (n) {\n    if (n & 1) ret *= x;\n    x *= x; n >>= 1;\n  }\n  return ret;\n}\n\ntemplate <int MD>\nstruct ModInt {\n  int x;\n  static unordered_map<int, int> to_inv;\n  ModInt() : x(0) {}\n  ModInt(int x_) { if ((x = x_ % MD + MD) >= MD) x -= MD; }\n\n  ModInt& operator+=(ModInt that) { if ((x += that.x) >= MD) x -= MD; return *this; }\n  ModInt& operator*=(ModInt that) { x = (unsigned long long)x * that.x % MD; return *this; }\n  ModInt& operator-=(ModInt that) { if ((x -= that.x) < 0) x += MD; return *this; }\n  ModInt& operator/=(ModInt that) { x = (unsigned long long)x * that.inv().x % MD; return *this; }\n\n  ModInt operator-() const { return -x < 0 ? MD - x : -x; }\n  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n  bool operator==(ModInt that) const { return x == that.x; }\n  bool operator!=(ModInt that) const { return x != that.x; }\n  ModInt inv() const { return to_inv.count(this->x) ? to_inv[this->x] : (to_inv[this->x] = pow(*this, MD - 2).x); }\n  friend ostream& operator<<(ostream& s, ModInt<MD> a) { s << a.x; return s; }\n  friend istream& operator>>(istream& s, ModInt<MD>& a) { s >> a.x; return s; }\n};\ntemplate <int MD> unordered_map<int, int> ModInt<MD>::to_inv;\nusing mint = ModInt<MOD>;\n\nvector<mint> fact, fact_inv;\nvoid init_factorial(int n) {\n  fact = vector<mint>(n + 1, 1);\n  fact_inv = vector<mint>(n + 1);\n  for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n  fact_inv[n] = mint(1) / fact[n];\n  for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n  // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n}\nmint comb(int n, int r) {\n  return fact[n] * fact_inv[r] * fact_inv[n - r];\n}\n\n// T0: 元の配列のモノイド\n// T1: T0に対する作用素モノイド\ntemplate <class T0, class T1>\nclass SegmentTree {\n  // k番目のノードにのlazyを伝搬\n  void eval(int k, int len) {\n    // u1が正確に単位元ならいらない\n    // if (lazy[k] == u1) return;\n    // len個分のlazy[k]を評価\n    node[k] = g(node[k], p(lazy[k], len));\n    if (k < N - 1) {\n      // 最下段でなければ下のlazyに伝搬\n      lazy[2 * k + 1] = f1(lazy[2 * k + 1], lazy[k]);\n      lazy[2 * k + 2] = f1(lazy[2 * k + 2], lazy[k]);\n    }\n    lazy[k] = u1;\n  }\n  // k番目のノード[l, r)について、[a, b)の範囲内にxを作用\n  void update(int a, int b, T1 x, int k, int l, int r) {\n    eval(k, r - l);\n    if (b <= l || r <= a) return;\n    if (a <= l && r <= b) {\n      lazy[k] = f1(lazy[k], x);\n      eval(k, r - l);\n    } else {\n      update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n      update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n      node[k] = f0(node[2 * k + 1], node[2 * k + 2]);\n    }\n  }\n  // k番目のノード[l, r)について、[a, b)のクエリを求める\n  T0 query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return u0;\n    eval(k, r - l);\n    if (a <= l && r <= b) return node[k];\n    T0 vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n    T0 vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n    return f0(vl, vr);\n  }\npublic:\n  int sz; // 元の配列のサイズ\n  int N;\n  vector<T0> node;\n  vector<T1> lazy;\n  // T0上の演算、単位元\n  using F0 = function<T0(T0, T0)>;\n  F0 f0; T0 u0;\n  // T1上の演算、単位元\n  using F1 = function<T1(T1, T1)>;\n  F1 f1; T1 u1;\n  // 作用\n  using G = function<T0(T0, T1)>;\n  G g;\n  // 多数のt1(T1)に対するf1の合成\n  using P = function<T1(T1, int)>;\n  P p;\n  SegmentTree(const vector<T0>& a, F0 f0, T0 u0, F1 f1, T1 u1, G g, P p)\n  : sz(a.size()), f0(f0), u0(u0), f1(f1), u1(u1), g(g), p(p) {\n    for (N = 1; N < sz; N *= 2);\n    node.resize(2 * N - 1);\n    lazy.resize(2 * N - 1, u1);\n    REP (i, sz) node[N - 1 + i] = a[i];\n    for (int i = N - 2; i >= 0; i--) node[i] = f0(node[2 * i + 1], node[2 * i + 2]);\n  }\n  // [a, b)にxを作用\n  void update(int a, int b, T1 x) {\n    assert(0 <= a && a < b && b <= sz);\n    update(a, b, x, 0, 0, N);\n  }\n  void update(int a, T1 x) {\n    update(a, a + 1, x);\n  }\n  // [a, b)\n  T0 query(int a, int b) {\n    return query(a, b, 0, 0, N);\n  }\n  T0 query(int a) {\n    return query(a, a + 1);\n  }\n};\n\nsigned main() {\n  int n, H, D; cin >> n >> H >> D;\n  init_factorial(n + 10);\n  mint mul = 0;\n  REPI (i, 1, n + 1) {\n    mul += fact[i];\n  }\n\n  vector<mint> dp(H + 1);\n  dp[0] = fact[n] / mul;\n  mint acc = dp[0];\n  REPI (i, 1, H + 1) {\n    dp[i] = acc * mul;\n    acc += dp[i];\n    if (i - D >= 0) acc -= dp[i - D];\n  }\n  cout << dp[H] << endl;;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <bitset>\n#include <assert.h>\n#include <unordered_map>\n#include <fstream>\n#include <ctime>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> pii;\ntypedef vector<P> vpl;\ntypedef tuple<ll,ll,ll> tapu;\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define REP(i,a,b) for(int i=(a); i<(b); i++)\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\nconst int inf = 1<<30;\nconst ll linf = 1LL<<62;\nconst int MAX = 1020000;\nll dy[8] = {1,-1,0,0,1,-1,1,-1};\nll dx[8] = {0,0,1,-1,1,-1,-1,1};\nconst double pi = acos(-1);\nconst double eps = 1e-7;\ntemplate<typename T1,typename T2> inline bool chmin(T1 &a,T2 b){\n\tif(a>b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T1,typename T2> inline bool chmax(T1 &a,T2 b){\n\tif(a<b){\n\t\ta = b; return true;\n\t}\n\telse return false;\n}\ntemplate<typename T> inline void print(T &a){\n    rep(i,a.size()) cout << a[i] << \" \";\n    cout << \"\\n\";\n}\ntemplate<typename T1,typename T2> inline void print2(T1 a, T2 b){cout << a << \" \" << b << \"\\n\";}\ntemplate<typename T1,typename T2,typename T3> inline void print3(T1 a, T2 b, T3 c){\n\tcout << a << \" \" << b << \" \" << c << \"\\n\";\n}\nll pcount(ll x) {return __builtin_popcountll(x);}\nconst int mod = 1e9 + 7;\n//const int mod = 998244353;\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 a;\n\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n\treturn modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n\treturn modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n\treturn modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n\treturn modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n\ta += rhs.a;\n\tif (a >= Modulus) {\n\t  a -= Modulus;\n\t}\n\treturn *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n\tif (a < rhs.a) {\n\t  a += Modulus;\n\t}\n\ta -= rhs.a;\n\treturn *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n\ta = a * rhs.a % Modulus;\n\treturn *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n\tu64 exp = Modulus - 2;\n\twhile (exp) {\n\t  if (exp % 2) {\n\t\t*this *= rhs;\n\t  }\n\t  rhs *= rhs;\n\t  exp /= 2;\n\t}\n\treturn *this;\n  }\n};\n\nusing mint = modint<mod>;\n\nvector<ll> fac(MAX), finv(MAX), inv(MAX);\n\nvoid comInit(){\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(ll i=2; i<MAX; i++){\n\t\tfac[i] = fac[i-1]*i % mod;\n\t\tinv[i] = mod - inv[mod%i] * (mod/i) % mod;\n\t\tfinv[i] = finv[i-1] * inv[i] % mod;\n\t}\n}\n\n\nll com(ll n, ll k){\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\nll modpow(ll x, ll n, ll mod){\n\tll res = 1;\n\twhile(n > 0){\n\t\tif(n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nmint dp[1010101];\nmint sum[1010101];\nmint facsum[1010101];\n\nint main(){\n\tll n,h,d; cin >> n >> h >> d;\n\tcomInit();\n\tREP(i,1,n+1) facsum[i] = facsum[i-1] + fac[i];\n\tdp[0] = sum[1] = 1;\n\tREP(i,1,h){\n\t\tmint tmp = sum[i] - sum[max(0LL,i-d)];\n\t\tdp[i] = tmp * facsum[n];\n\t\tsum[i+1] += dp[i] + sum[i];\n\t}\n\tmint ans = (sum[h] - sum[h-d]) * fac[n];\n\tcout << ans.value() << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend istream& operator >> (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(ll e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n\n    static int totient() {\n        int tot = MOD, tmp = MOD;\n        for (int p = 2; p * p <= tmp; p++) if (tmp % p == 0) {\n            tot = tot / p * (p - 1);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot = tot / tmp * (tmp - 1);\n        return tot;\n    }\n\n    static int primitive_root() {\n        if (MOD == 1) return 0;\n        if (MOD == 2) return 1;\n\n        int tot = totient(), tmp = tot;\n        vi tot_pr;\n        for (int p = 2; p * p <= tmp; p++) if (tot % p == 0) {\n            tot_pr.push_back(p);\n            while (tmp % p == 0) tmp /= p;\n        }\n        if (tmp > 1) tot_pr.push_back(tmp);\n\n        for (int r = 2; r < MOD; r++) if (__gcd(r, MOD) == 1) {\n            bool root = true;\n            for (int p : tot_pr) root &= modnum(r).pow(tot / p) != 1;\n            if (root) return r;\n        }\n        assert(false);\n    }\n\n    static modnum generator() { static modnum g = primitive_root(); return g; }\n    static int discrete_log(modnum v) {\n        static const int M = ceil(sqrt(MOD));\n        static unordered_map<int, int> table;\n        if (table.empty()) {\n            modnum e = 1;\n            for (int i = 0; i < M; i++) { table[e.v] = i; e *= generator(); }\n        }\n        static modnum f = generator().pow(totient() - M);\n\n        for (int i = 0; i < M; i++) {\n            if (table.count(v.v)) return table[v.v] + i * M;\n            v *= f;\n        }\n        assert(false);\n    }\n\n    static modnum fact(int n) {\n        static vector<modnum<MOD>> fact = { 1 };\n        while (fact.size() <= n)\n            fact.push_back(fact.back() * fact.size());\n        return fact[n];\n    }\n\n    static modnum ncr(int n, int r) {\n        if (r < 0 || n < r) return 0;\n        return fact(n) / (fact(r) * fact(n - r));\n    }\n};\nusing mn = modnum<int(1e9 + 7)>;\nusing vmn = vector<mn>;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N, H, D;\n    cin >> N >> H >> D;\n\n    vmn reach(H + 1);\n    reach[0] = mn::fact(N);\n\n    mn arrive = 0;\n    for (int tk = 1; tk <= N; tk++)\n        arrive += mn::fact(tk);\n\n    mn lastD = reach[0];\n    for (int um = 1; um <= H; um++) {\n        /*for (int pm = um - 1; pm >= max(0, um - D); pm--) {\n            reach[um] += reach[pm] * (um == H ? 1 : arrive);\n        }*/\n        reach[um] = lastD * (um == H ? 1 : arrive);\n\n        lastD += reach[um];\n        if (um >= D) lastD -= reach[um - D];\n    }\n\n    cout << reach.back() << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int MOD = 1e9 + 7;\n\nint add(int a, int b) {\n    return (a + b) % MOD;\n}\n\nint sub(int a, int b) {\n    return (a - b + MOD) % MOD;\n}\n\nint mul(ll a, ll b) {\n    return (a * b) % MOD;\n}\n\nint main() {\n    int n, h, d;\n    cin >> n >> h >> d;\n\n    vector<int> f(n + 1);\n    f[0] = 1;\n    for (int i = 1; i <= n; i++)\n        f[i] = mul(f[i - 1], i);\n\n    int coef = accumulate(f.begin() + 1, f.end(), 0LL) % MOD;\n\n    vector<int> delta(h + d + 2);\n    delta[1] = add(delta[1], f[n]);\n    delta[d + 1] = sub(delta[d + 1], f[n]);\n\n    int val = 0;\n    for (int i = 1; i <= h; i++) {\n        val = add(val, delta[i]);\n        delta[i + 1] = add(delta[i + 1], mul(coef, val));\n        delta[i + d + 1] = sub(delta[i + d + 1], mul(coef, val));\n    }\n\n    cout << val << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=1000000,mod=1000000007;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\nint Power(int a,int k,int p=mod){int res=1;for (;k;k>>=1,smul(a,a,p)) if (k&1) smul(res,a,p);return res;}\nint Get_inv(int a,int p=mod){return Power(a,p-2,p);}\n\nint n,h,d;\n\nvoid into(){\n  scanf(\"%d%d%d\",&n,&h,&d);\n}\n\nint dp[N+9],sum[N+9];\n\nvoid Get_dp(){\n  int s=0;\n  for (int i=1,fac=1;i<=n;++i) smul(fac,i),sadd(s,fac);\n  sum[0]=dp[0]=Get_inv(s);\n  for (int i=1;i<=h;++i) sum[i]=add(sum[i-1],dp[i]=mul(sub(sum[i-1],i>d?sum[i-d-1]:0),s));\n  for (int i=1;i<=n;++i) smul(dp[h],i);\n}\n\nvoid work(){\n  Get_dp();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",dp[h]);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define X first\n#define Y second\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 5001;\n\nint n;\npair<ll, ll> c[3];\n\nll bruteforce() {\n\tll ans = 0;\n\tfor(int x = 0; c[0].X * x <= n; x++) {\n\t\tint m = n - c[0].X * x;\n\t\tfor(int y = 0; c[1].X * y <= m; y++) {\n\t\t\tint mm = m - c[1].X * y;\n\t\t\tint z = mm / c[2].X;\n\t\t\tans = max(ans, c[0].Y * x + c[1].Y * y + c[2].Y * z);\n\t\t}\n\t}\n\treturn ans;\n}\n\nll solve(vector<int> is) {\n\tauto a = c[is[0]];\n\tauto b = c[is[1]];\n\n\tll ans = 0;\n\n\tfor(int x = 0; a.X * x <= n; x++) {\n\t\tll m = n - a.X * x;\n\t\tll y = m / b.X;\n\t\tans = max(ans, a.Y * x + b.Y * y);\n\t}\n\treturn ans;\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\t\n\tcin >> n;\n\tfor(int j = 0; j < 3; j++) {\n\t\tcin >> c[j].X;\n\t}\n\tfor(int j = 0; j < 3; j++) {\n\t\tcin >> c[j].Y;\n\t}\n\n\tint cnt = 0;\n\tvector<int> fst;\n\tfor(int i = 0; i < 3; i++) {\n\t\tif(c[i].X <= c[i].Y) {\n\t\t\tcnt++;\n\t\t\tfst.push_back(i);\n\t\t} else swap(c[i].X, c[i].Y);\n\t}\n\n\tll ans;\n\tif(cnt == 3 || cnt == 0) {\n\t\tans = bruteforce();\n\t} else if(cnt == 1) {\n\t\tint k = fst[0];\n\t\tint x = n / c[k].X;\n\t\tn = (n % c[k].X) + x * c[k].Y;\n\t\tvector<int> is;\n\t\tfor(int i = 0; i < 3; i++) {\n\t\t\tif(i != k) is.push_back(i);\n\t\t}\n\t\tans = solve(is);\n\t} else {\n\t\tn = solve(fst);\n\t\tint k = 3 - fst[0] - fst[1];\n\t\tll x = n / c[k].X;\n\t\tans = (n % c[k].X) + x * c[k].Y;\n\t}\n\n\tcout << ans << '\\n';\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N=1000010,mod=1e9+7;\n\nint n,h,d,q,p,ans,f[N];\n\nvoid inc(int&x,int y){x+=y;if(x>=mod)x-=mod;}\nvoid dec(int&x,int y){x-=y;if(x<0)x+=mod;}\n\nint pw(int x,int y){\n\tint re=1;\n\twhile(y){\n\t\tif(y&1)re=1ll*re*x%mod;\n\t\ty>>=1;x=1ll*x*x%mod;\n\t}return re;\n}\n\nint main(){\n//\tfreopen(\"e.in\",\"r\",stdin);\n//\tfreopen(\"e.out\",\"w\",stdout);\n\tscanf(\"%d%d%d\",&n,&h,&d);\n\tfor(int i=q=1;i<=n;++i){\n\t\tq=1ll*q*i%mod;\n\t\tinc(p,q);\n\t}\n\tans=1ll*q*pw(p,mod-2)%mod;\n\tfor(int i=f[0]=1,s=1;i<=h;++i){\n\t\tif(i-d-1>=0)dec(s,f[i-d-1]);\n\t\tf[i]=1ll*s*p%mod;\n\t\tinc(s,f[i]);\n\t}\n\tans=1ll*f[h]*ans%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int INF=1e9;\nconst int MOD=1e9+7;\n//const int MOD=998244353;\nconst long long LINF=1e18;\nusing namespace std;\n#define int long long\n//template\nint dp[100][100];\nint pw(int n,int k){\n  if(k<0)return pw(n,k+MOD-1);\n  int res=1;\n  while(k){\n    if(k&1)res*=n;res%=MOD;\n    n*=n;n%=MOD;\n    k>>=1;\n  }\n  return res;\n}\nstd::vector<int> Factorial(1e6),Finverse(1e6);\nvoid Cinit(){\n  Factorial[0]=1;\n  for(int i=1;i<1e6;i++)Factorial[i]=Factorial[i-1]*i%MOD;\n  for(int i=0;i<1e6;i++)Finverse[i]=pw(Factorial[i],MOD-2);\n}\nint nCk(int n,int k){\n  if(n<k)return 1;if(k<0)return 0;\n  int res=Factorial[n];\n  res*=Finverse[k];res%=MOD;\n  res*=Finverse[n-k];res%=MOD;\n  return res;\n}\n//main\nsigned main(){\n  Cinit();\n  int N,H,D;cin>>N>>H>>D;\n  int sum=0;\n  std::vector<int> wa(1e6);\n  wa[0]=0;for(int i=1;i<1e6;i++)wa[i]=(wa[i-1]+Factorial[i])%MOD;\n  //cout<<wa[5]<<endl;return 0;\n  std::vector<int> dp(3234567,0);\n  queue<int> que;\n  for(int i=0;i<=H;i++){\n    if(i==0){\n      dp[1]+=Factorial[N];\n      sum+=dp[1];\n      que.push(sum);\n      continue;\n    }\n    if(que.size()>D){\n      int p=que.front();que.pop();\n      sum-=p;\n      if(sum<0)sum+=MOD;\n    }\n    dp[i]=sum;\n    que.push(sum*wa[N]%MOD);\n    sum+=sum*wa[N]%MOD;sum%=MOD;\n  }\n  //for(int i=0;i<=10;i++)cout<<dp[i]<<\" \";cout<<endl;\n  cout<<dp[H]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=1001000,mod=1000000007;\ninline void Add(int &a,int b){a=a+b>=mod?a+b-mod:a+b;}\ninline int ksm(int a,int b)\n{\n\tint res=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod) if(b&1) res=1ll*res*a%mod;\n\treturn res;\n}\nint fac[maxn],n,D,H,f[maxn],sumfac,sumf;\nint main()\n{\n\tfor(int i=fac[0]=1;i<maxn;i++) fac[i]=1ll*fac[i-1]*i%mod;\n\tcin>>n>>H>>D;\n\tfor(int i=1;i<=n;i++) Add(sumfac,fac[i]);\n\tf[0]=sumf=1;\n\tfor(int i=1;i<=H;i++)\n\t{\n\t\tif(i>=D+1) Add(sumf,mod-f[i-D-1]);\n\t\tf[i]=1ll*sumf*sumfac%mod;Add(sumf,f[i]);\n\t}\n\tprintf(\"%lld\\n\",1ll*fac[n]*f[H]%mod*ksm(sumfac,mod-2)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\n//-------------------------------------------------------------------\n#define P 1000000007\n#define N_MAX 10000000\ntypedef long long int ll;\nll fac[N_MAX+1];\nll inv[N_MAX+1];\nll finv[N_MAX+1];\n\nll comb(ll n, ll k){\n  if(n<0||k<0||n<k) return 0;\n  return (((fac[n]*finv[n-k])%P)*finv[k])%P;\n}\n\n\nvoid init(){\n  fac[0] = finv[0] = fac[1] = finv[1] = inv[1] = 1;\n  for(int i = 2; i <= N_MAX; i++){\n    fac[i] = (fac[i-1]*i)%P;\n    inv[i] = ((-(P/i)*inv[P%i])%P+P)%P;\n    finv[i] = (finv[i-1]*inv[i])%P;\n  }\n}\nll pp(ll a, ll b){\n  return (a * b)%P;\n}\n//-------------------------------------------------------------------\nstruct LazySegmentTree {\nprivate:\n    int n;\n    vector<ll> node, lazy;\npublic:\n    LazySegmentTree(vector<ll> v) {\n        int sz = (int)v.size();\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1);\n        lazy.resize(2*n-1, 0);\n        for(int i=0; i<sz; i++) node[i+n-1] = v[i];\n        for(int i=n-2; i>=0; i--) node[i] = node[i*2+1] + node[i*2+2];\n    }\n\n    void eval(int k, int l, int r) {\n        if(lazy[k] != 0) {\n            node[k] = (node[k] + lazy[k])%P;\n            if(r - l > 1) {\n                lazy[2*k+1] = (lazy[2*k+1] + pp(lazy[k], inv[2]))%P;\n                lazy[2*k+2] = (lazy[2*k+2] + pp(lazy[k], inv[2]))%P;\n            }\n            lazy[k] = 0;\n        }\n    }\n\n    void add(int a, int b, ll x, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] = (lazy[k] + ((r-l)*x)%P)%P;\n            eval(k, l, r);\n        }\n        else {\n            add(a, b, x, 2*k+1, l, (l+r)/2);\n            add(a, b, x, 2*k+2, (l+r)/2, r);\n            node[k] = (node[2*k+1] + node[2*k+2])%P;\n        }\n    }\n\n    ll getsum(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        eval(k, l, r);\n        if(b <= l || r <= a) return 0;\n        if(a <= l && r <= b) return node[k];\n        ll vl = getsum(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getsum(a, b, 2*k+2, (l+r)/2, r);\n        return (vl + vr)%P;\n    }\n};\n//最大値がいくらで、最大値がいくつあるか\n//最大値xの組み合わせは、\n//最大値 y -> x (x>y, y+d<=x, x<=h)となるとき、k個xになる場合\n//nPk\n\n// 2\n// 1 + 2\nint main(int argc, char const *argv[]) {\n  ll n, h, d;std::cin >> n >> h >> d;\n  init();\n  LazySegmentTree seg(vll(h+1, 0));\n  seg.add(0, 1, fac[n]);\n\n  vector<ll> pm(n+1, 0);\n  for(ll i=1;i<=n;i++) pm[i] = (pm[i-1] + fac[i])%P;\n\n  for(ll i=0;i<h;i++){\n    ll now = seg.getsum(i, i+1);\n    ll upd = (now * pm[n])%P;\n    //std::cout << now << '\\n';\n    if(i+d>=h){\n      seg.add(i+1, h, upd);\n      seg.add(h, h+1, now);\n    }else seg.add(i+1, i+d+1, upd);\n  }\n  std::cout << seg.getsum(h, h+1) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,Ofast,inline,unroll-all-loops,-ffast-math\")\n#pragma GCC target(\"popcnt\")\n#include <bits/stdc++.h>\n#define maxn 1000010\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define pii pair<int, int>\n#define pil pair<int, ll>\n#define pll pair<ll, ll>\n#define IL inline\n#define ss system\nusing namespace std;\n\nint n, h, d;\nll f[maxn], s[maxn], fac[maxn], sum = 0;\nconst ll p = 1e9 + 7;\ntemplate <class T> void read(T &x) {\n  char ch = x = 0;\n  bool fl = false;\n  while (!isdigit(ch))\n    fl |= ch == '-', ch = getchar();\n  while (isdigit(ch))\n    x = x * 10 + ch - '0', ch = getchar();\n  x = fl ? -x : x;\n}\nint main() {\n  cin >> n >> h >> d, f[0] = s[0] = fac[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fac[i] = fac[i - 1] * i % p;\n  }\n  for (int i = 1; i <= n; i++) {\n    sum = (sum + fac[i]) % p;\n  }\n  for (int i = 1; i <= h; i++) {\n    f[i] = (s[i - 1] - (i > d ? s[i - d - 1] : 0) + p) % p * (i == h ? fac[n] : sum) % p;\n    s[i] = (s[i - 1] + f[i]) % p;\n  }\n  cout << f[h] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nconst ll MOD = 1000000007;\nstruct Mint {\n\tint val;\n\tMint() { val = 0; }\n\tMint(const ll& x) {\n\t\tval = (-MOD <= x && x <= MOD) ? x : x % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\tfriend bool operator==(const Mint& a, const Mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n\tfriend bool operator<(const Mint& a, const Mint& b) { return a.val < b.val; }\n\tMint& operator+=(const Mint& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tMint& operator-=(const Mint& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tMint& operator*=(const Mint& m) { val = (ll)val * m.val % MOD; return *this; }\n\tfriend Mint pow(Mint a, ll p) {\n\t\tMint ans = 1;\n\t\tfor (; p; p >>= 1, a *= a) if (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tMint& operator/=(const Mint& m) { return *this *= pow(m, MOD - 2); }\n\tMint& operator++() { return *this += 1; }\n\tMint& operator--() { return *this -= 1; }\n\tMint operator++(int) { Mint result(*this); *this += 1; return result; }\n\tMint operator--(int) { Mint result(*this); *this -= 1; return result; }\n\tMint operator-() const { return Mint(-val); }\n\tfriend Mint operator+(Mint a, const Mint& b) { return a += b; }\n\tfriend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n\tfriend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n\tfriend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n\tfriend ostream& operator<<(ostream& os, const Mint& x) { return os << x.val; }\n};\nint main() {\n\tint n, d, h;\n\tscanf(\"%d%d%d\", &n, &h, &d);\n\tvector<Mint> fac(n + 1), dp(h + 1), sumdp(h + 1);\n\tfac[0] = 1;\n\tMint sumfac = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfac[i] = fac[i - 1] * i;\n\t\tsumfac += fac[i];\n\t}\n\tsumdp[0] = dp[0] = fac[n];\n\tfor (int i = 1; i < h; ++i) {\n\t\tdp[i] = (sumdp[i - 1] - (i <= d ? 0 : sumdp[i - d - 1])) * sumfac;\n\t\tsumdp[i] = sumdp[i - 1] + dp[i];\n\t}\n\tMint ans = sumdp[h - 1] - (h <= d ? 0 : sumdp[h - d - 1]);\n\tprintf(\"%d\\n\", ans.val);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define gc getchar()\n#define ll long long\n#define pb push_back\n#define mk make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\n#define pa pair<int,int>\n#define fir first\n#define sec second\nusing namespace std;\nconst int mod = 1e9+7;\ninline int read(){int w=1,s=0;char ch=getchar();while(!isdigit(ch)){if(ch=='-')w=-1;ch=getchar();}while(isdigit(ch)){s=s*10+ch-'0';ch=getchar();}return  w*s;}\nint n,H,D;\nint Sum[1101000],f[1010100];\ninline ll ksm(ll x,ll y){ll res=1;while(y){if(y&1) res=res*x%mod;x=x*x%mod;y>>=1;} return res;}\ninline int pls(int a,int b){a+=b;return a>=mod?a-mod:a;}\ninline int mns(int a,int b){a-=b;return a<0?a+mod:a;}\ninline int get(int x,int y){\n\tif(x==0) return Sum[y];\n\telse return mns(Sum[y],Sum[x-1]);\n}\nint main()\n{\t\n\tn=read(),H=read(),D=read();\n\tint S,cur;\n\tS=cur=1;\n\tfor(rint i=2;i<=n;++i) {\n\t\tcur=1ll*cur*i%mod;\n\t\tS=pls(S,cur);\n\t}\n\tSum[0]=1;\n\tfor(rint i=1;i<=H;++i) {\n\t\tSum[i]=Sum[i-1];\n\t\tf[i]=get(max(i-D,0),i);\n\t\tSum[i]=pls(Sum[i],1ll*f[i]*S%mod);\n\t}\n\tfor(rint i=1;i<=n;++i) f[H]=1ll*f[H]*i%mod;\n\tcout<<f[H]<<\"\\n\";\n\treturn 0;\n}\t"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n    #pragma GCC optimize(\"Ofast\")\n#endif\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing db = double;\nusing ldb = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pll = pair<int_fast64_t, int_fast64_t>;\nusing pdi = pair<double, int>;\nusing pdd = pair<double, double>;\ntemplate <class T> using vct = vector<T>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / (T)16;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double Pi = 3.1415926535897932384626433832795028;\nconstexpr long double Golden = 1.61803398874989484820;\nconstexpr long double eps = 1e-15;\n\n#define iostream_untie true\n#define mod 1000000007LL\n#define stdout_precision 10\n#define stderr_precision 10\n#define itrep(i,v) for(auto i = begin(v); i != end(v); ++i)\n#define ritrep(i,v) for(auto i = rbegin(v); i != rend(v); ++i)\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nnamespace setup {\n    struct setupper {\n        setupper() {\n            if(iostream_untie) {\n                ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n                std::cout.tie(nullptr);\n                std::cerr.tie(nullptr);\n            }\n            std::cout << std::fixed << std::setprecision(stdout_precision);\n            std::cerr << std::fixed << std::setprecision(stderr_precision);\n    #ifdef LOCAL\n            if(!freopen(\"stderr.txt\",\"wt\",stderr)) {\n                std::cerr << \"Failed to open the stderr file\\n\";\n                freopen(\"CON\",\"wt\",stderr);\n            }\n            if(!freopen(\"stdout.txt\",\"wt\",stdout)) {\n                std::cerr << \"Failed to open the stdout file\\n\";\n                freopen(\"CON\",\"wt\",stdout);\n            }\n            if(!freopen(\"stdin.txt\",\"rt\",stdin)) {\n                std::cerr << \"Failed to open the stdin file.\\n\";\n                freopen(\"CON\",\"rt\",stdin);\n            }\n            // auto print_atexit = []() {\n            //     std::cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\";\n            //     std::cerr << \"------------\\n\";\n            // };\n            // atexit((void(*)())print_atexit);\n    #endif\n        }\n    } __setupper;\n}\n\nnamespace std {\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) {\n        sort(__first, __last, greater<>());\n    }\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1>\n    struct hashval_calc {\n        static void apply(size_t& seed, tuple_t const& t) {\n            hashval_calc<tuple_t, index - 1>::apply(seed, t);\n            hash_combine(seed,get<index>(t));\n        }\n    };\n    template <class tuple_t>\n    struct hashval_calc<tuple_t, 0> {\n        static void apply(size_t& seed, tuple_t const& t) {\n            hash_combine(seed,get<0>(t));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& t) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,t);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> istream &operator>> (istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\ntemplate <class T, class U> ostream &operator<< (ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\ntemplate <class T> istream &operator>> (istream &s, vector<T> &v) { for(T &e : v) { s >> e; }   return s; }\ntemplate <class T> ostream &operator<< (ostream &s, const vector<T> &v) {\n    for(size_t i = 0; i < v.size(); ++i) { s << (i ? \" \" : \"\") << v[i]; }   return s;\n}\ntemplate <class tuple_t, size_t index>\nstruct tupleos {\n    static ostream &apply(ostream &s, const tuple_t &t) {\n        tupleos<tuple_t,index - 1>::apply(s,t);\n        return s << \" \" << get<index>(t);\n    }\n}; \ntemplate <class tuple_t>\nstruct tupleos<tuple_t, 0> {\n    static ostream &apply(ostream &s, const tuple_t &t) {\n        return s << get<0>(t);\n    }\n};\ntemplate <class ...T> ostream &operator<< (ostream &s, const tuple<T...> &t) {\n    return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(s,t);\n}\ntemplate <> ostream &operator<< (ostream &s, const tuple<> &t) { return s; }\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T = i64> T read() { T x; return cin >> x, x; }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\n\nnamespace updater {\n    template <class T> static void add(T &x, const T &y) { x += y; }\n    template <class T> static void ext_add(T &x, const T &y, size_t w) { x += y * w; }\n    template <class T> static void mul(T &x, const T &y) { x *= y; }\n    template <class T> static void ext_mul(T &x, const T &y, size_t w) { x *= (T)pow(y,w); }\n    template <class T> static bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n    template <class T> static bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n};\nusing updater::add;\nusing updater::chmax;\nusing updater::chmin;\n\ntemplate <class T> constexpr T minf(const T &x, const T &y) { return min(x,y); }\ntemplate <class T> constexpr T maxf(const T &x, const T &y) { return max(x,y); }\nconstexpr bool bit(i64 n, int e) { return (n >> e) & 1; }\nconstexpr int_fast64_t mask(int_fast64_t n, int e) { return n & ((1 << e) - 1); }\nconstexpr int ilog(int_fast64_t x, int_fast64_t b = 2) { return x ? 1 + ilog(x / b, b) : -1; }\nint_fast64_t binry(int_fast64_t ok, int_fast64_t ng, const function<bool(int_fast64_t)> &fn) {\n    while (abs(ok - ng) > 1) {\n        int_fast64_t mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class T> vector<int> cmprs(const vector<T> &v) {\n    vector<T> tmp = v; vector<int> ret;\n    sort(begin(tmp),end(tmp));\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(T i : v) ret.emplace_back(lower_bound(begin(tmp),end(tmp),i) - begin(tmp));\n    return ret;\n}\ntemplate <class T> vector<int> cmprs(const T *__first, const T *__last) {\n    return cmprs(vector<T>(__first, __last));\n}\nvoid for_subset(int_fast64_t s, const function<void(int_fast64_t)> &fn) {\n    int_fast64_t tmp = s;\n    do { fn(tmp); } while((--tmp &= s) != s);\n}\n\n\n\n/* The main code follows. */\n\n/* The snippet starts here. */\nnamespace Calcfn {\n    #ifndef mod\n        #define mod 1000000007LL\n    #endif\n    struct modint {\n        int x;\n        constexpr modint() : x(0) {}\n        constexpr modint(int_fast64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n        constexpr modint &operator+=(const modint &p) {\n            if((x += p.x) >= mod) x -= mod;\n            return *this;\n        }\n\n        constexpr modint &operator ++() { return ++x,*this; }\n\n        constexpr modint operator ++(int) {\n            modint t = *this; \n            return ++x,t;\n        }\n\n        constexpr modint &operator-=(const modint &p) {\n            if((x += mod - p.x) >= mod) x -= mod;\n            return *this;\n        }\n\n        constexpr modint &operator --() { return --x,*this; }\n\n        constexpr modint operator --(int) {\n            modint t = *this;\n            return --x,t;\n        }\n\n        constexpr modint &operator*=(const modint &p) {\n            x = (int) (1LL * x * p.x % mod);\n            return *this;\n        }\n\n        constexpr modint &operator/=(const modint &p) {\n            *this *= inverse(p);\n            return *this;\n        }\n\n        constexpr modint operator-() { return modint(-x); }\n\n        constexpr modint operator+(const modint &p) { return modint(*this) += p; }\n\n        constexpr modint operator-(const modint &p) { return modint(*this) -= p; }\n\n        constexpr modint operator*(const modint &p) { return modint(*this) *= p; }\n\n        constexpr modint operator/(const modint &p) { return modint(*this) /= p; }\n\n        constexpr bool operator==(const modint &p) { return x == p.x; }\n\n        constexpr bool operator!=(const modint &p) { return x != p.x; }\n\n        constexpr bool operator!() { return !x; }\n\n        constexpr bool operator>(const modint &p) { return x > p.x; }\n\n        constexpr bool operator<(const modint &p) { return x <  p.x; }\n\n        constexpr bool operator>=(const modint &p) { return x >= p.x; }\n\n        constexpr bool operator<=(const modint &p) { return x <= p.x; }\n\n        constexpr static modint inverse(const modint &p) {\n            int a = p.x, b = mod, u = 1, v = 0;\n            while(b > 0) {\n                int t = a / b;\n                a -= t * b;\n                a ^= b ^= a ^= b;\n                u -= t * v;\n                u ^= v ^= u ^= v;\n            }\n            return modint(u);\n        }\n\n        constexpr static modint pow(modint p, uint_fast64_t e) {\n            if(!e) return 1;\n            return pow(p * p, e >> 1) * (e & 1 ? p : 1);\n        }\n\n        friend ostream &operator<<(ostream &s, const modint &p) { return s << p.x; }\n\n        friend istream &operator>>(istream &s, modint &p) {\n            uint_fast64_t x;\n            p = modint((s >> x,x));\n            return s;\n        }\n    };\n\n    constexpr static int N = 2e5 + 2e4, N_max = 2e6 + 2e5;\n\n    struct impl {\n        int_fast64_t fact_[N + 1],invfact_[N + 1],inv_[N + 1];\n\n        constexpr impl() : fact_(),invfact_(),inv_() {\n            fact_[0] = 1;\n            for(int i = 1; i <= N; ++i) fact_[i] = fact_[i - 1] * i % mod;\n            inv_[1] = 1;\n            for(int i = 2; i <= N && i < mod; ++i) inv_[i] = mod - inv_[mod % i] * (mod / i) % mod;\n            invfact_[0] = 1;\n            for(int i = 1; i <= N && i < mod; ++i) invfact_[i] = invfact_[i - 1] * inv_[i] % mod;\n        }\n    };\n    constexpr static impl impl_exe;\n\n    int_fast64_t _dyn_fact[N_max + 1];\n    int_fast64_t _dyn_inv[N_max + 1];\n    int_fast64_t _dyn_invfact[N_max + 1];\n\n    static int_fast64_t dyn_fact(int x) {\n        assert(x <= N_max);\n        if(x < 0) return 0;\n        static size_t _size = 1;\n        for(size_t &i = _size; i <= x; ++i) {\n            if(i <= N) _dyn_fact[i] = impl_exe.fact_[i];\n            else _dyn_fact[i] = _dyn_fact[i - 1] * i % mod;\n        }   \n        return _dyn_fact[x];\n    }\n\n    static int_fast64_t dyn_invfact(int x) {\n        assert(x <= N_max && x < mod);\n        if(x < 0)  return 0;\n        static size_t _size = 1;\n        for(size_t &i = _size; i <= x; ++i) {\n            if(i <= N) {\n                _dyn_inv[i] = impl_exe.inv_[i];\n                _dyn_invfact[i] = impl_exe.invfact_[i];\n            } else {\n                _dyn_inv[i] = mod - _dyn_inv[mod % i] * (mod / i) % mod;\n                _dyn_invfact[i] = _dyn_invfact[i - 1] * _dyn_inv[i] % mod;\n            }\n        }\n        return _dyn_invfact[x];\n    }\n\n    static modint fact(int x) {\n        if(x > N) return dyn_fact(x);\n        return x >= 0 ? impl_exe.fact_[x] : 0;\n    }\n\n    static modint invfact(int x) {\n        assert(x < mod);\n        if(x > N) return dyn_invfact(x);\n        return x >= 0 ? impl_exe.invfact_[x] : 0;\n    }\n\n    static modint comb(int x, int y) {\n        return fact(x) * invfact(y) * invfact(x - y);\n    }\n\n    static modint perm(int x, int y) {\n        return comb(x, y) * fact(y);\n    }\n\n    constexpr static int_fast64_t gcd(int_fast64_t a, int_fast64_t b) {\n        if(!b) return a > 0 ? a : -a; return gcd(b, a % b);\n    }\n\n    constexpr static int_fast64_t lcm(int_fast64_t a, int_fast64_t b) {\n        if(a | b) return a / gcd(a, b) * b; return 0;\n    }\n\n    constexpr static int_fast64_t ext_gcd(int_fast64_t a, int_fast64_t b, int_fast64_t &x, int_fast64_t &y) {\n        int_fast64_t d = a;\n        if (b) d = ext_gcd(b, a % b, y, x), y -= (a / b) * x;\n        else x = 1, y = 0;\n        return d;\n    }\n}\nusing Calcfn::modint;\nusing Calcfn::fact;\nusing Calcfn::perm;\nusing Calcfn::comb;\n/* The snippet ends here. */\n\n\nint n,h,d;\nmodint dp[1<<20];\nmodint acc[1<<20];\n\nsigned main() {\n    cin>>n>>h>>d;\n    modint facs=0;\n    for(int i=1; i<=n; ++i) facs+=fact(i);\n    acc[1]=fact(n);\n    for(int i=1; i<=h; ++i) {\n        dp[i]=acc[i]-acc[max(0,i-d)];\n        acc[i+1]=acc[i]+facs*dp[i];\n    } \n    cout<<dp[h]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <regex>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main()\n{\n    int n, h, d;\n    cin >> n >> h >> d;\n\n    long long tmp = 1;\n    long long sum = 0;\n    for(int i=1; i<=n; ++i){\n        tmp *= i;\n        tmp %= MOD;\n        sum += tmp;\n        sum %= MOD;\n    }\n\n    vector<long long> dp(h+1, 0);\n    for(int i=1; i<=d; ++i)\n        dp[i] = tmp;\n    long long x = 0;\n    for(int i=2; i<=h; ++i){\n        x += dp[i-1];\n        if(i-1-d >= 0)\n            x -= dp[i-1-d] - MOD;\n        x %= MOD;\n        dp[i] += x * sum;\n        dp[i] %= MOD;\n    }\n    cout << dp[h] << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <unordered_map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\nlong long int DP[1100000] = {};\n\nint main(){\n    long long int N, D, H;\n    cin >> N >> H >> D;\n    long long int factN = 1, factS = 0;\n    for(int i = 1; i <= N; i++){\n        factN *= i;\n        factN %= MOD;\n        factS += factN;\n        factS %= MOD;\n    }\n    DP[0] = factN;\n    long long int S = factN;\n    for(int i = 1; i < D; i++){\n        DP[i] = S * factS % MOD;\n        S += DP[i];\n        S %= MOD;\n    }\n    for(int i = D; i < H; i++){\n        DP[i] = S * factS % MOD;\n        S += DP[i];\n        S -= DP[i - D];\n        S += MOD;\n        S %= MOD;\n    }\n    cout << S << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n//#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int N = 3000000;\nint mod = 1e9 + 7;\nint f[N], dp[N], s[N];\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n, d, h;\n    dp[0] = 1;\n    s[0] = 1;\n    cin >> n >> h >> d;\n    f[0] = 1;\n    int q = 0;\n    for (int i = 1; i <= n; i++) f[i] = f[i - 1] * i % mod;\n    for (int i = 1; i <= n; i++){\n        q = (q + f[i]) % mod;\n    }\n    for (int i = 1; i <= h; i++){\n        int z = 0;\n        if (i <= d) z = s[i - 1]; else z = (s[i - 1] - s[i - 1 - d] + mod) % mod;\n        dp[i] = q * z % mod;\n        s[i] = (s[i - 1] + dp[i]) % mod;\n    }\n    int ans = 0;\n    for (int i = 1; i <= d; i++){\n        ans = (ans + dp[h - i]) % mod;\n    }\n    cout <<ans * f[n] % mod;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <chrono>\n#include <random>\n#include <functional>\n\nusing namespace std;\n\nconst int H = 1e6 + 9;\nconst int MOD = 1e9 + 7;\n\nint add(int a, int b) {\n\treturn (a + b) % MOD;\n}\n\nint mul(int a, int b) {\n\treturn 1LL * a * b % MOD;\n}\n\nint dp[H];\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n, h, d;\n\tcin >> n >> h >> d;\n\tdp[0] = 1;\n\tint S = 0;\n\t{\n\t\tint c = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tc = mul(c, i);\n\t\t\tS = add(S, c);\n\t\t}\n\t}\n\tfor (int m = 0; m <= h; m++) {\n\t\tint V = dp[m];\n\t\tif (m > 0) {\n\t\t\tV = mul(V, S);\n\t\t}\n\t\tfor (int to = m + 1; to <= h && to <= m + d; to++) {\n\t\t\tdp[to] = add(dp[to], V);\n\t\t}\n\t}\n\tint ans = dp[h];\n\tfor (int i = 1; i <= n; i++) {\n\t\tans = mul(ans, i);\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <string>\n#define SIZE 1000005\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll dp[SIZE];\nll rdp[SIZE];\n\nint main()\n{\n\tint N,H,D;\n\tscanf(\"%d %d %d\",&N,&H,&D);\n\tll fac=1,coef=0;\n\tfor(ll i=1;i<=N;i++)\n\t{\n\t\tfac=fac*(ll) i%MOD;\n\t\tcoef+=fac;\n\t\tif(coef>=MOD) coef-=MOD;\n\t}\n\tfor(int i=1;i<=H;i++)\n\t{\n\t\tll sum=rdp[i-1]-(i-D-1<0?0:rdp[i-D-1]);\n\t\tif(sum<0) sum+=MOD;\n\t\tsum=sum*coef%MOD;\n\t\tif(i<=D)\n\t\t{\n\t\t\tsum+=fac;\n\t\t\tif(sum>=MOD) sum-=MOD;\n\t\t}\n\t\tdp[i]=sum;\n\t\trdp[i]=rdp[i-1]+sum;\n\t\tif(rdp[i]>=MOD) rdp[i]-=MOD;\n\t}\n\tprintf(\"%lld\\n\",dp[H]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing ull = unsigned long long;\nusing uint = unsigned;\nusing pcc = pair<char, char>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<ld, ld>;\nusing tuplis = array<ll, 3>;\ntemplate<class T> using pq = priority_queue<T, vector<T>, greater<T>>;\nconst ll LINF=0x1fffffffffffffff;\nconst ll MINF=0x7fffffffffff;\nconst int INF=0x3fffffff;\nconst int MOD=1000000007;\nconst int MODD=998244353;\nconst ld DINF=numeric_limits<ld>::infinity();\nconst ld EPS=1e-9;\nconst ld PI=3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n#define overload4(_1,_2,_3,_4,name,...) name\n#define overload3(_1,_2,_3,name,...) name\n#define rep1(n) for(ll i=0;i<n;++i)\n#define rep2(i,n) for(ll i=0;i<n;++i)\n#define rep3(i,a,b) for(ll i=a;i<b;++i)\n#define rep4(i,a,b,c) for(ll i=a;i<b;i+=c)\n#define rep(...) overload4(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n#define rrep1(n) for(ll i=n;i--;)\n#define rrep2(i,n) for(ll i=n;i--;)\n#define rrep3(i,a,b) for(ll i=b;i-->(a);)\n#define rrep4(i,a,b,c) for(ll i=(a)+((b)-(a)-1)/(c)*(c);i>=(a);i-=c)\n#define rrep(...) overload4(__VA_ARGS__,rrep4,rrep3,rrep2,rrep1)(__VA_ARGS__)\n#define each1(i,a) for(auto&&i:a)\n#define each2(x,y,a) for(auto&&[x,y]:a)\n#define each3(x,y,z,a) for(auto&&[x,y,z]:a)\n#define each(...) overload4(__VA_ARGS__,each3,each2,each1)(__VA_ARGS__)\n#define all1(i) begin(i),end(i)\n#define all2(i,a) begin(i),begin(i)+a\n#define all3(i,a,b) begin(i)+a,begin(i)+b\n#define all(...) overload3(__VA_ARGS__,all3,all2,all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(),(i).rend()\n#define rall2(i,k) (i).rbegin(),(i).rbegin()+k\n#define rall3(i,a,b) (i).rbegin()+a,(i).rbegin()+b\n#define rall(...) overload3(__VA_ARGS__,rall3,rall2,rall1)(__VA_ARGS__)\n#define sum(...) accumulate(all(__VA_ARGS__),0LL)\n#define dsum(...) accumulate(all(__VA_ARGS__),0.0L)\n#define Msum(...) accumulate(all(__VA_ARGS__),0_M)\n#define elif else if\n#define unless(a) if(!(a))\n#define INT(...) int __VA_ARGS__;in(__VA_ARGS__)\n#define LL(...) ll __VA_ARGS__;in(__VA_ARGS__)\n#define ULL(...) ull __VA_ARGS__;in(__VA_ARGS__)\n#define STR(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define CHR(...) char __VA_ARGS__;in(__VA_ARGS__)\n#define DBL(...) double __VA_ARGS__;in(__VA_ARGS__)\n#define LD(...) ld __VA_ARGS__;in(__VA_ARGS__)\n#define Sort(a) sort(all(a))\n#define Rev(a) reverse(all(a))\n#define Uniq(a) sort(all(a));a.erase(unique(all(a)),end(a))\n#define vec(type,name,...) vector<type>name(__VA_ARGS__)\n#define VEC(type,name,size) vector<type>name(size);in(name)\n#define vv(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__))\n#define VV(type,name,h,w) vector<vector<type>>name(h,vector<type>(w));in(name)\n#define vvv(type,name,h,w,...) vector<vector<vector<type>>>name(h,vector<vector<type>>(w,vector<type>(__VA_ARGS__)))\ntemplate<class T> auto min(const T& a){ return *min_element(all(a)); }\ntemplate<class T> auto max(const T& a){ return *max_element(all(a)); }\ninline ll popcnt(ull a){ return __builtin_popcountll(a); }\nll gcd(ll a, ll b){ while(b){ ll c = b; b = a % b; a = c; } return a; }\nll lcm(ll a, ll b){ if(!a || !b) return 0; return a * b / gcd(a, b); }\nll intpow(ll a, ll b){ ll ans = 1; while(b){ if(b & 1) ans *= a; a *= a; b /= 2; } return ans; }\nll modpow(ll a, ll b, ll p){ ll ans = 1; while(b){ if(b & 1) (ans *= a) %= p; (a *= a) %= p; b /= 2; } return ans; }\ntemplate<class T> bool chmin(T& a, const T& b){ if(a > b){ a = b; return 1; } return 0; }\ntemplate<class T> bool chmax(T& a, const T& b){ if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmin(T& a, const U& b){ if(a > T(b)){ a = b; return 1; } return 0; }\ntemplate<class T, class U> bool chmax(T& a, const U& b){ if(a < T(b)){ a = b; return 1; } return 0; }\nvector<ll> iota(ll n){ vector<ll> a(n); iota(a.begin(), a.end(), 0); return a; }\nvector<pll> factor(ull x){ vector<pll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans.push_back({i, 1}); while((x /= i) % i == 0) ans.back().second++; } if(x != 1) ans.push_back({x, 1}); return ans; }\nmap<ll,ll> factor_map(ull x){ map<ll,ll> ans; for(ull i = 2; i * i <= x; i++) if(x % i == 0){ ans[i] = 1; while((x /= i) % i == 0) ans[i]++; } if(x != 1) ans[x] = 1; return ans; }\nvector<ll> divisor(ull x){ vector<ll> ans; for(ull i = 1; i * i <= x; i++) if(x % i == 0) ans.push_back(i); rrep(ans.size() - (ans.back() * ans.back() == x)) ans.push_back(x / ans[i]); return ans; }\ntemplate<class T> unordered_map<T, ll> press(vector<T> a){ Uniq(a); unordered_map<T, ll> ans; rep(a.size()) ans[a[i]] = i; return ans; }\ntemplate<class T> map<T, ll> press_map(vector<T> a){ Uniq(a); map<T, ll> ans; rep(a.size()) ans[a[i]] = i; return ans; }\nint scan(){ return getchar(); }\nvoid scan(int& a){ scanf(\"%d\", &a); }\nvoid scan(unsigned& a){ scanf(\"%u\", &a); }\nvoid scan(long& a){ scanf(\"%ld\", &a); }\nvoid scan(long long& a){ scanf(\"%lld\", &a); }\nvoid scan(unsigned long long& a){ scanf(\"%llu\", &a); }\nvoid scan(char& a){ do{ a = getchar(); }while(a == ' ' || a == '\\n'); }\nvoid scan(float& a){ scanf(\"%f\", &a); }\nvoid scan(double& a){ scanf(\"%lf\", &a); }\nvoid scan(long double& a){ scanf(\"%Lf\", &a); }\nvoid scan(vector<bool>& a){ for(unsigned i = 0; i < a.size(); i++){ int b; scan(b); a[i] = b; } }\nvoid scan(char a[]){ scanf(\"%s\", a); }\nvoid scan(string& a){ cin >> a; }\ntemplate<class T> void scan(vector<T>&);\ntemplate<class T, size_t size> void scan(array<T, size>&);\ntemplate<class T, class L> void scan(pair<T, L>&);\ntemplate<class T, size_t size> void scan(T(&)[size]);\ntemplate<class T> void scan(vector<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(deque<T>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, size_t size> void scan(array<T, size>& a){ for(auto&& i : a) scan(i); }\ntemplate<class T, class L> void scan(pair<T, L>& p){ scan(p.first); scan(p.second); }\ntemplate<class T, size_t size> void scan(T (&a)[size]){ for(auto&& i : a) scan(i); }\ntemplate<class T> void scan(T& a){ cin >> a; }\nvoid in(){}\ntemplate <class Head, class... Tail> void in(Head& head, Tail&... tail){ scan(head); in(tail...); }\nvoid print(){ putchar(' '); }\nvoid print(bool a){ printf(\"%d\", a); }\nvoid print(int a){ printf(\"%d\", a); }\nvoid print(unsigned a){ printf(\"%u\", a); }\nvoid print(long a){ printf(\"%ld\", a); }\nvoid print(long long a){ printf(\"%lld\", a); }\nvoid print(unsigned long long a){ printf(\"%llu\", a); }\nvoid print(char a){ printf(\"%c\", a); }\nvoid print(char a[]){ printf(\"%s\", a); }\nvoid print(const char a[]){ printf(\"%s\", a); }\nvoid print(float a){ printf(\"%.15f\", a); }\nvoid print(double a){ printf(\"%.15f\", a); }\nvoid print(long double a){ printf(\"%.15Lf\", a); }\nvoid print(const string& a){ for(auto&& i : a) print(i); }\ntemplate<class T> void print(const complex<T>& a){ if(a.real() >= 0) print('+'); print(a.real()); if(a.imag() >= 0) print('+'); print(a.imag()); print('i'); }\ntemplate<class T> void print(const vector<T>&);\ntemplate<class T, size_t size> void print(const array<T, size>&);\ntemplate<class T, class L> void print(const pair<T, L>& p);\ntemplate<class T, size_t size> void print(const T (&)[size]);\ntemplate<class T> void print(const vector<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const deque<T>& a){ if(a.empty()) return; print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, size_t size> void print(const array<T, size>& a){ print(a[0]); for(auto i = a.begin(); ++i != a.end(); ){ putchar(' '); print(*i); } }\ntemplate<class T, class L> void print(const pair<T, L>& p){ print(p.first); putchar(' '); print(p.second); }\ntemplate<class T, size_t size> void print(const T (&a)[size]){ print(a[0]); for(auto i = a; ++i != end(a); ){ putchar(' '); print(*i); } }\ntemplate<class T> void print(const T& a){ cout << a; }\nint out(){ putchar('\\n'); return 0; }\ntemplate<class T> int out(const T& t){ print(t); putchar('\\n'); return 0; }\ntemplate<class Head, class... Tail> int out(const Head& head, const Tail&... tail){ print(head); putchar(' '); out(tail...); return 0; }\n#ifdef DEBUG\ninline ll __lg(ull __n){ return sizeof(ull) * __CHAR_BIT__  - 1 - __builtin_clzll(__n); }\n#define debug(...) { print(#__VA_ARGS__); print(\":\"); out(__VA_ARGS__); }\n#else\n#define debug(...) void(0)\n#endif\nint first(bool i = true){ return out(i?\"first\":\"second\"); }\nint yes(bool i = true){ return out(i?\"yes\":\"no\"); }\nint Yes(bool i = true){ return out(i?\"Yes\":\"No\"); }\nint No(){ return out(\"No\"); }\nint YES(bool i = true){ return out(i?\"YES\":\"NO\"); }\nint NO(){ return out(\"NO\"); }\nint Yay(bool i = true){ return out(i?\"Yay!\":\":(\"); }\nint possible(bool i = true){ return out(i?\"possible\":\"impossible\"); }\nint Possible(bool i = true){ return out(i?\"Possible\":\"Impossible\"); }\nint POSSIBLE(bool i = true){ return out(i?\"POSSIBLE\":\"IMPOSSIBLE\"); }\nvoid Case(ll i){ printf(\"Case #%lld: \", i); }\n\n\nconstexpr uint mod = MOD;\nstruct Modint{\n    uint num = 0;\n    constexpr Modint() noexcept {}\n    constexpr Modint(const Modint &x) noexcept : num(x.num){}\n    inline constexpr operator ll() const noexcept { return num; }\n    inline constexpr Modint& operator+=(Modint x) noexcept { num += x.num; if(num >= mod) num -= mod; return *this; }\n    inline constexpr Modint& operator++() noexcept { if(num == mod - 1) num = 0; else num++; return *this; }\n    inline constexpr Modint operator++(int) noexcept { Modint ans(*this); operator++(); return ans; }\n    inline constexpr Modint operator-() const noexcept { return Modint(0) -= *this; }\n    inline constexpr Modint operator-(Modint x) const noexcept { return Modint(*this) -= x; }\n    inline constexpr Modint& operator-=(Modint x) noexcept { if(num < x.num) num += mod; num -= x.num; return *this; }\n    inline constexpr Modint& operator--() noexcept { if(num == 0) num = mod - 1; else num--; return *this; }\n    inline constexpr Modint operator--(int) noexcept { Modint ans(*this); operator--(); return ans; }\n    inline constexpr Modint& operator*=(Modint x) noexcept { num = ull(num) * x.num % mod; return *this; }\n    inline constexpr Modint& operator/=(Modint x) noexcept { return operator*=(x.inv()); }\n    template<class T> constexpr Modint(T x) noexcept {\n        using U = typename conditional<sizeof(T) >= 4, T, int>::type;\n        U y = x; y %= U(mod); if(y < 0) y += mod; num = uint(y);\n    }\n    template<class T> inline constexpr Modint operator+(T x) const noexcept { return Modint(*this) += x; }\n    template<class T> inline constexpr Modint& operator+=(T x) noexcept { return operator+=(Modint(x)); }\n    template<class T> inline constexpr Modint operator-(T x) const noexcept { return Modint(*this) -= x; }\n    template<class T> inline constexpr Modint& operator-=(T x) noexcept { return operator-=(Modint(x)); }\n    template<class T> inline constexpr Modint operator*(T x) const noexcept { return Modint(*this) *= x; }\n    template<class T> inline constexpr Modint& operator*=(T x) noexcept { return operator*=(Modint(x)); }\n    template<class T> inline constexpr Modint operator/(T x) const noexcept { return Modint(*this) /= x; }\n    template<class T> inline constexpr Modint& operator/=(T x) noexcept { return operator/=(Modint(x)); }\n    inline constexpr Modint inv() const noexcept { ll x = 0, y = 0; extgcd(num, mod, x, y); return x; }\n    static inline constexpr ll extgcd(ll a, ll b, ll &x, ll &y) noexcept { ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\n    inline constexpr Modint pow(ull x) const noexcept { Modint ans = 1, cnt = *this; while(x){ if(x & 1) ans *= cnt; cnt *= cnt; x /= 2; } return ans; }\n};\nstd::istream& operator>>(std::istream& is, Modint& x){ ll a; in(a); x = a; return is; }\ninline constexpr Modint operator\"\"_M(ull x) noexcept { return Modint(x); }\nstd::vector<Modint> fac(1, 1), inv(1, 1);\ninline void reserve(ll a){\n    if(fac.size() >= a) return;\n    if(a < fac.size() * 2) a = fac.size() * 2;\n    if(a >= mod) a = mod;\n    while(fac.size() < a) fac.push_back(fac.back() * Modint(fac.size()));\n    inv.resize(fac.size());\n    inv.back() = fac.back().inv();\n    for(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint fact(ll n){ if(n < 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint perm(ll n, ll r){\n    if(r < 0 || n < r) return 0;\n    if(n >> 24){ Modint ans = 1; for(ll i = 0; i < r; i++) ans *= n--; return ans; }\n    reserve(n + 1); return fac[n] * inv[n - r];\n}\ninline Modint comb(ll n, ll r){ if(r < 0 || n < r) return 0; reserve(r + 1); return perm(n, r) * inv[r]; }\ninline Modint Mcomb(ll n, ll r){ return comb(n + r - 1, n - 1); } // r balls into n boxes\ninline Modint catalan(ll n){ reserve(n * 2 + 1); return fac[n * 2] * inv[n] * inv[n + 1]; }\nsigned main(){\n    LL(n,h,d);\n    vec(Modint,dp,h+1);\n    vec(Modint,s,h+1);\n    Modint facs=0;\n    rep(i,1,n+1)facs+=fact(i);\n    s[0]=1;\n    rep(h){\n        dp[i+1]=s[i]-(i<d?0_M:s[i-d]);\n        if(i+1==h)out(dp[i+1]*fact(n));\n        dp[i+1]*=facs;\n        s[i+1]=s[i]+dp[i+1];\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n#define unless(p) if(!(p))\n#define until(p) while(!(p))\n\nusing ll = std::int64_t;\nusing P = std::tuple<int,int>;\n\nconstexpr ll MOD = 1'000'000'007;\n\ntemplate <typename M>\nstruct SegmentTree{\n    using T = typename M::type;\n\n    int numLeaves;\n    std::vector<T> data;\n    \n    SegmentTree(int n){\n        numLeaves = 1;\n        while(numLeaves < n){\n            numLeaves *= 2;\n        }\n        \n        data.resize(numLeaves * 2);\n        std::fill(data.begin() + numLeaves, data.end(), M::identity());\n        \n        for(int i=numLeaves-1;i>0;--i){\n            data[i] = M::bop(data[i*2], data[i*2+1]);\n        }\n    }\n\n    template <typename F>\n    SegmentTree(int n, F f){\n        numLeaves = 1;\n        while(numLeaves < n){\n            numLeaves *= 2;\n        }\n\n        data.resize(numLeaves * 2);\n        for(int i=0;i<n;++i){\n            data[i + numLeaves] = std::move(f(i));\n        }\n        std::fill(data.begin() + numLeaves + n, data.end(), M::identity());\n\n        for(int i=numLeaves-1;i>0;--i){\n            data[i] = M::bop(data[i*2], data[i*2+1]);\n        }\n    }\n\n    void set(int k, T v){\n        k += numLeaves;\n        data[k] = v;\n        \n        while(k > 1){\n            k /= 2;\n            data[k] = M::bop(data[k*2], data[k*2+1]);\n        }\n    }\n    \n    T product(int l, int r){\n        l += numLeaves;\n        r += numLeaves;\n        \n        T pl = M::identity(), pr = M::identity();\n        for(;l<r;l/=2,r/=2){\n            if(l & 1){\n                pl = M::bop(pl, data[l]);\n                l += 1;\n            }\n            if(r & 1){\n                r -= 1;\n                pr = M::bop(data[r], pr);\n            }\n        }\n        \n        return M::bop(pl, pr);\n    }\n    \n    T at(int i){\n        return data[i + numLeaves];\n    }\n};\n\nstruct M{\n    using type = ll;\n    static type identity(){\n        return 0;\n    }\n    static type bop(type &m1, type &m2){\n        return (m1 + m2) % MOD;\n    }\n};\n\nSegmentTree<M> seg(1000100);\n\nint N, H, D;\nll fact[1000100], a[1000100];\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    std::cin >> N >> H >> D;\n\n    fact[0] = 1;\n    a[0] = 0;\n\n    for(int i=1;i<=N;++i){\n        fact[i] = fact[i-1] * i % MOD;\n        a[i] = (a[i-1] + 1) * i % MOD;\n    }\n\n    seg.set(H, 1);\n\n    for(int i=H-1;i>0;--i){\n        ll x = seg.product(i + 1, std::min(i + D + 1, H + 1)),\n            y = (fact[N] + a[N-1]) % MOD * x % MOD;\n        seg.set(i, y);\n    }\n\n    ll x = seg.product(1, std::min(0 + D + 1, H + 1)) * N % MOD;\n\n    std::cout << x << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nvoid sol(int i, int st, int dir, vel& cnt, vvel& nex, vvel& use) {\n\tif (use[i].size() == 0 || use[i].back() != st) {\n\t\tuse[i].push_back(st);\n\t\tif (cnt[i] >= 1) {\n\t\t\trep(nd, 2) {\n\t\t\t\tint ne = nex[nd][i];\n\t\t\t\tif (ne != -1) {\n\t\t\t\t\tsol(ne, st, nd, cnt, nex, use);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint ne = nex[dir][i];\n\t\t\tif (ne != -1) {\n\t\t\t\tsol(ne, st, dir, cnt, nex, use);\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main() {\n\tomajinai;\n\tint n, h, d; cin >> n >> h >> d;\n\tint M = 0;\n\tint ka = 1;\n\trep(i, n) {\n\t\tka *= (i + 1); ka %= p1;\n\t\tM += ka;\n\t\tM %= p1;\n\t}\n\tvel dp(h);\n\tdp[0] = 1;\n\tfor (int i = 1; i < h; i++) {\n\t\tdp[i] = (M + 1) * dp[i - 1];\n\t\tif (i >= d + 1) {\n\t\t\tdp[i] -= M * dp[i - d - 1];\n\t\t}\n\t\tdp[i] %= p1; dp[i] += p1; dp[i] %= p1;\n\t}\n\tint ans = dp.back();\n\tif (h >= d + 1) {\n\t\tans += p1 - dp[h - d - 1];\n\t}\n\tans *= ka;\n\tcout << ans % p1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntemplate <int MOD>\nclass ModInt {\n    using lint = long long;\n\npublic:\n    int val;\n\n    // constructor\n    ModInt(lint v = 0) : val(v % MOD) {\n        if (val < 0) val += MOD;\n    };\n\n    // assignment\n    ModInt& operator=(const ModInt& x) {\n        if (this != &x) { this->val = x.val; }\n        return *this;\n    }\n\n    // unary operator\n    ModInt operator+() const { return ModInt(val); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator~() const { return *this ^ (MOD - 2); }\n\n    // increment / decrement\n    ModInt& operator++() { return *this += 1; }\n    ModInt& operator--() { return *this -= 1; }\n    ModInt operator++(int) {\n        ModInt before = *this;\n        ++(*this);\n        return before;\n    }\n    ModInt operator--(int) {\n        ModInt before = *this;\n        --(*this);\n        return before;\n    }\n\n    // arithmetic\n    ModInt operator+(const ModInt& x) const { return ModInt(*this) += x; }\n    ModInt operator-(const ModInt& x) const { return ModInt(*this) -= x; }\n    ModInt operator*(const ModInt& x) const { return ModInt(*this) *= x; }\n    ModInt operator%(const ModInt& x) const { return ModInt(*this) %= x; }\n    ModInt operator/(const ModInt& x) const { return ModInt(*this) /= x; }\n    ModInt operator^(const ModInt& x) const { return ModInt(*this) ^= x; }\n\n    // compound assignment\n    ModInt& operator+=(const ModInt& x) {\n        if ((val += x.val) >= MOD) val -= MOD;\n        return *this;\n    }\n    ModInt& operator-=(const ModInt& x) {\n        if ((val -= x.val) < 0) val += MOD;\n        return *this;\n    }\n    ModInt& operator*=(const ModInt& x) {\n        val = lint(val) * x.val % MOD;\n        return *this;\n    }\n    ModInt& operator%=(const ModInt& x) {\n        val %= x.val;\n        return *this;\n    }\n    ModInt& operator/=(const ModInt& x) { return *this *= ~x; }\n    ModInt& operator^=(const ModInt& x) {\n        int n = x.val;\n        ModInt b = *this;\n        if (n < 0) n = -n, b = ~b;\n\n        *this = 1;\n        while (n > 0) {\n            if (n & 1) *this *= b;\n            n >>= 1;\n            b *= b;\n        }\n        return *this;\n    }\n\n    // compare\n    bool operator==(const ModInt& b) const { return val == b.val; }\n    bool operator!=(const ModInt& b) const { return val != b.val; }\n    bool operator<(const ModInt& b) const { return val < b.val; }\n    bool operator<=(const ModInt& b) const { return val <= b.val; }\n    bool operator>(const ModInt& b) const { return val > b.val; }\n    bool operator>=(const ModInt& b) const { return val >= b.val; }\n\n    // I/O\n    friend std::ostream& operator<<(std::ostream& os, const ModInt& x) noexcept { return os << x.val; }\n    friend std::istream& operator>>(std::istream& is, ModInt& x) noexcept { return is >> x.val; }\n};\n\ntemplate <int MOD>\nclass Combination {\n    using mint = ModInt<MOD>;\n\nprivate:\n    int MAX_V;\n    std::vector<mint> f, invf;\n\npublic:\n    explicit Combination(int N)\n        : MAX_V(N), f(MAX_V + 1), invf(MAX_V + 1) {\n        f[0] = 1;\n        for (int i = 1; i <= MAX_V; ++i) {\n            f[i] = f[i - 1] * i;\n        }\n\n        invf[MAX_V] = ~f[MAX_V];\n        for (int i = MAX_V - 1; i >= 0; --i) {\n            invf[i] = invf[i + 1] * (i + 1);\n        }\n    }\n\n    mint fact(int n) const { return f[n]; }\n    mint invfact(int n) const { return invf[n]; }\n    mint perm(int a, int b) const {\n        return a < b ? mint(0) : f[a] * invf[a - b];\n    }\n    mint comb(int a, int b) const {\n        return a < b ? mint(0) : f[a] * invf[a - b] * invf[b];\n    }\n};\n\nusing namespace std;\n\nconstexpr int MOD = 1e9 + 7;\nusing mint = ModInt<MOD>;\nconst Combination<MOD> C(1 << 20);\n\nint main() {\n    int N, H, D;\n    cin >> N >> H >> D;\n\n    mint fsum = 0;\n    for (int l = 1; l <= N; ++l) {\n        fsum += C.fact(l);\n    }\n\n    vector<mint> dp(H + 1, 0), dpsum(H + 1, 0);\n    dp[0] = dpsum[0] = C.fact(N) / fsum;\n\n    for (int h = 1; h <= H; ++h) {\n        dp[h] = fsum * (dpsum[h - 1] -\n                        (h - D - 1 >= 0 ? dpsum[h - D - 1] : 0));\n        dpsum[h] = dpsum[h - 1] + dp[h];\n    }\n\n    cout << dp[H] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid out(T x) { cout << x << endl; exit(0); }\n#define watch(x) cout << (#x) << \" is \" << (x) << endl\n\n\n\n\n\nusing ll = long long;\n\nconst ll mod = 1e9+7;\nconst int maxn = 1e6 + 5;\n\n\n\nll n, h, d;\nll dp[maxn];\n\nll fac[maxn];\nll facSum;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);  cout.tie(0);\n    cin>>n>>h>>d;\n    fac[0]=1;\n    for (int i=1; i<=n; i++) {\n\tfac[i]=1ll*i*fac[i-1]%mod;\n\tfacSum += fac[i];\n\tfacSum %= mod;\n    }\n\n\n    dp[0] = fac[n];\n    for (ll i=1; i<=h; i++) {\n\tfor (ll j=1; j<=d && i-j>=0; j++) {\n\t    dp[i] += dp[i-j];\n\t    dp[i] %= mod;\n\t}\n\tif (i<h) {\n\t    dp[i] *= facSum;\n\t    dp[i] %= mod;\n\t}\n    }\n\n\n    cout<<dp[h]<<endl;    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e6 + 10;\nconst int mod = (int)1e9 + 7;\ntypedef long long ll;\nint f[maxn], dp[maxn], pre[maxn];\nint pw(int a, int n) {\n\tint res = 1;\n\twhile(n) {\n\t\tif(n & 1) res = 1ll * res * a % mod;\n\t\ta = 1ll * a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint INV(int a) {return pw(a, mod - 2);}\nvoid add(int& a, int b) {\n\ta += b;\n\tif(a >= mod) a -= mod;\n}\nint main() {\n\tint n, h, d;\n\tscanf(\"%d%d%d\", &n ,&h, &d);\n\tf[0] = 1;\n\tint tot = 0;\n\tfor(int i = 1; i <= n; i++) \n\t\tf[i] = 1ll * f[i-1] * i % mod, add(tot, f[i]);\n\tdp[0] = pre[0] = 1;\n\tfor(int i = 1; i <= h; i++) {\n\t\tdp[i] = 1ll * tot * (pre[i - 1] + mod - (i <= d ? 0 : pre[i - d - 1])) % mod;\n\t\tpre[i] = pre[i - 1];\n\t\tadd(pre[i], dp[i]);\n\t}\n\tint ans = 1ll * dp[h] * f[n] % mod * INV(tot) % mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int INF=1e9;\nconst int MOD=1e9+7;\n//const int MOD=998244353;\nconst long long LINF=1e18;\nusing namespace std;\n#define int long long\n//template\nint dp[100][100];\nint pw(int n,int k){\n  if(k<0)return pw(n,k+MOD-1);\n  int res=1;\n  while(k){\n    if(k&1)res*=n;res%=MOD;\n    n*=n;n%=MOD;\n    k>>=1;\n  }\n  return res;\n}\nstd::vector<int> Factorial(1234567),Finverse(1234567);\nvoid Cinit(){\n  Factorial[0]=1;\n  for(int i=1;i<1e6;i++)Factorial[i]=Factorial[i-1]*i%MOD;\n  for(int i=0;i<1e6;i++)Finverse[i]=pw(Factorial[i],MOD-2);\n}\nint nCk(int n,int k){\n  if(n<k)return 1;if(k<0)return 0;\n  int res=Factorial[n];\n  res*=Finverse[k];res%=MOD;\n  res*=Finverse[n-k];res%=MOD;\n  return res;\n}\n//main\nsigned main(){\n  Cinit();\n  int N,H,D;cin>>N>>H>>D;\n  int sum=0;\n  std::vector<int> wa(1234567);\n  wa[0]=0;for(int i=1;i<1234567;i++)wa[i]=(wa[i-1]+Factorial[i])%MOD;\n  //cout<<wa[5]<<endl;return 0;\n  std::vector<int> dp(3234567,0);\n  queue<int> que;\n  for(int i=0;i<=H;i++){\n    if(i==0){\n      dp[1]+=Factorial[N];\n      sum+=dp[1];\n      que.push(sum);\n      continue;\n    }\n    if(que.size()>D){\n      int p=que.front();que.pop();\n      sum-=p;\n      if(sum<0)sum+=MOD;\n    }\n    dp[i]=sum;\n    que.push(sum*wa[N]%MOD);\n    sum+=sum*wa[N]%MOD;sum%=MOD;\n  }\n  //for(int i=0;i<=10;i++)cout<<dp[i]<<\" \";cout<<endl;\n  cout<<dp[H]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll Mod = 1000000007LL;\nconst int Maxn = 1e6 + 10;\n\nll mul(ll a, ll b){\n\treturn (a * b) % Mod;\n}\n\nll dp[Maxn], f[Maxn];\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\t\n\tll n, h, d;\n\tcin >> n >> h >> d;\n\t\n\tll sm = 0;\n\tf[0] = 1;\n\tfor(int i = 1; i <= n; i++) f[i] = mul(f[i - 1], i), sm += f[i];\n\tsm %= Mod;\n\tdp[0] = f[n];\n\tll s = dp[0];\n\tfor(int i = 1; i < h; i++){\n\t\tdp[i] = mul(s, sm);\n\t\ts += dp[i];\n\t\tif(i >= d) s -= dp[i - d];\n\t\ts %= Mod;\n\t}\n\tcout << (s + Mod) % Mod;\n\treturn 0;\n}\n/*\n1\n5 1\n20 21 22 23 24\n\n1\n4 2 \n1 2 3 4\n\n2 4 1 3\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 1e9+7;\n\nlong long int sum[1000001],dp[1000001];\n\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tlong long int N,H,D;\n\tlong long int facsum=0,fac=1;\n\tcin>>N>>H>>D;\n\tfor(int i=1;i<=N;i++){\n\t\tfac=fac*i%mod;\n\t\tfacsum+=fac;\n\t}\n\tfacsum%=mod;\n\tdp[0]=1;\n\tsum[0]=dp[0];\n\tfor(int i=1;i<=H;i++){\n\t\tlong long int here = sum[i-1]-(i-D-1>=0?sum[i-1-D]:0);\n\t\tdp[i]=here%mod*facsum%mod;\n\t\tsum[i]=sum[i-1]+dp[i];\n\t\tif(i==H)\n\t\t\tcout<<here%mod*fac%mod<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <utility>\n#define maxn 1000005\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\ninline int getint(){\n  char c; int res = 0, sig = 1;\n  for(c = getchar();c < '0' || c > '9';c = getchar()) if(c == '-') sig = -1;\n  for(;c >= '0' && c <= '9';c = getchar()) res = res * 10 + (c - '0');\n  return res * sig;\n}\nint n,d,h;\nll fct[maxn],k,g[maxn << 1];\nint main(){\n  n = getint(), h = getint(), d = getint();\n  fct[0] = 1;\n  for(int i = 1;i <= n;i++) fct[i] = (ll)fct[i - 1] * i % mod;\n  for(int i = 1;i <= n;i++) (k += fct[i]) %= mod;\n  g[h] = 1; ll sum = 1;\n  for(int i = h - 1;i >= 1;i--){\n    g[i] = (ll)k * sum % mod;\n    (sum += g[i] - g[i + d] + mod) %= mod;\n  }\n  printf(\"%lld\\n\",(ll)fct[n] * sum % mod);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\nconst int N = 1000000 + 5;\nconst int Mod = 1e9 + 7;\nint n, h, d, S, F, dp[N], fac[N];\nint read() {\n    char c; int x = 0, f = 1;\n    c = getchar();\n    while (c > '9' || c < '0') { if(c == '-') f = -1; c = getchar();}\n    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n    return x * f;\n}\nint Inc(int a, int b) { return (a += b) >= Mod ? a - Mod : a;}\nint Dec(int a, int b) { return (a -= b) < 0 ? a + Mod : a;}\nint Mul(int a, int b) { return 1ll * a * b % Mod;}\nint main() {\n    n = read(), h = read(), d = read();\n    dp[0] = fac[0] = S = 1;\n    rep(i, 1, n) fac[i] = Mul(fac[i - 1], i), F = Inc(F, fac[i]);\n    rep(i, 1, h) {\n        if(i != h) dp[i] = Mul(S, F);\n        else dp[i] = Mul(S, fac[n]);\n        S = Inc(S, dp[i]); if(i >= d) S = Dec(S, dp[i - d]);\n    }\n    printf(\"%d\", dp[h]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\n#define cbr cerr<<\"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ll(x.size())\n#define all(x) (x).begin(), (x).end()\n#define lbd(x,y) (lower_bound(all(x),y)-x.begin())\n#define ubd(x,y) (upper_bound(all(x),y)-x.begin())\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\ninline long long rand(long long x, long long y) { return rng() % (y+1-x) + x; } //inclusivesss\nstring inline to_string(char c) {string s(1,c);return s;} template<typename T> inline T gcd(T a,T b){ return a==0?llabs(b):gcd(b%a,a); }\n\nusing ll=long long; \nusing ld=long double;\n#define FOR(i,s,e) for(ll i=s;i<=ll(e);++i)\n#define DEC(i,s,e) for(ll i=s;i>=ll(e);--i)\nusing pi=pair<ll,ll>; using spi=pair<ll,pi>; using dpi=pair<pi,pi>; \n\n#define LLINF ((long long)1e18)\n#define INF int(1e9+1e6)\n#define MAXN (300006)\nll n,d,h,sum,mod=1e9+7,f=1;\nint main(){\n\tFAST\n\tcin>>n>>h>>d;\n\tFOR(i,1,n)f*=i,f%=mod,sum+=f,sum%=mod;\n\tvector<ll> dp(h+1,0);\n\tdp[0]=f;\n\tll mult=dp[0];\n\tFOR(i,1,h){\n\t\tif(i-d-1 >= 0) mult -= dp[i-d-1], mult += mod, mult %= mod;\n\t\tdp[i]=mult * sum % mod;\n\t\tif(i<h)mult += dp[i], mult %= mod;\n\t}\n\tcout<<mult<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define REP(i, n) for(int i = 0;i < (n);i++)\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst int mod=1000000007 ;\nconst llint inf=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool chmin(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool chmax(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nint main(void){\n\tllint i,n,D,H;cin>>n>>H>>D;\n\tvector<llint>dp(H+D+1);\n\tllint K=0,a=1;\n\tfor(i=1;i<=n;i++){a*=i;a%=mod;K+=a;K%=mod;}\n\tdp[1]=a;dp[1+D]=-a;\n\tfor(i=1;i<H;i++){\n\t\tdp[i+1]+=dp[i]*(K+1);dp[i+1]%=mod;\n\t\tdp[i+1+D]-=dp[i]*K;dp[i+1+D]%=mod;\n\t}\n\t\n\tcout<<(mod+dp[H])%mod<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 1e6 + 10, mod = 1e9 + 7;\n\nll fact[N], dp[N], add[N];\n\nll pwr(ll x, ll e);\n\nint main() {\n\tfast_cin();\n\tll n, h, d;\n\tcin >> n >> h >> d;\n\tfact[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfact[i] = (i * fact[i - 1]) % mod;\n\t}\n\tll fact_sum = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfact_sum += fact[i];\n\t\tfact_sum %= mod;\n\t}\n\tdp[0] = fact[n];\n\tll cur = 0;\n\tfor (int i = 0; i <= h; ++i) {\n\t\tcur += add[i];\n\t\tcur %= mod;\n\t\tdp[i] += cur;\n\t\tdp[i] %= mod;\n\t\tll temp = (fact_sum * dp[i]) % mod;\n\t\tint l = i + 1, r = min(i + d, h);\n\t\tadd[l] += temp;\n\t\tadd[l] %= mod;\n\t\tadd[r + 1] += (mod - temp);\n\t\tadd[r + 1] %= mod;\n\t}\n\tll inverse = pwr(fact_sum, mod - 2);\n\tll ans = (dp[h] * inverse) % mod;\n\tcout << ans << endl;\n}\n\nll pwr(ll x, ll e) {\n\tll res = 1;\n\twhile (e) {\n\t\tif (e & 1) {\n\t\t\tres = (res * x) % mod;\n\t\t}\n\t\tx = (x * x) % mod;\n\t\te /= 2;\n\t}\n\treturn res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1e6+10, MOD = 1e9+7;\nint n, h, d;\nint a[maxn], sum, b[maxn], s[maxn], ans;\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &h, &d);\n\ta[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\ta[i] = (ll)a[i-1]*i%MOD;\n\t\tsum = (ll)(sum+a[i])%MOD;\n\t}\n\tfor (int i = 1; i <= h; ++i) {\n\t\tb[i] = ((s[i-1]-((i-d-1<1)?0:s[i-d-1])+MOD)*(ll)sum+(i<=d))%MOD;\n\t\ts[i] = (s[i-1]+b[i])%MOD;\n\t}\n\tans = (ll)b[h]*a[n]%MOD;\n\tprintf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "// This code wrote by chtholly_micromaker(MicroMaker)\n#pragma GCC optimize(\"Ofast,O3,inline\")\n#pragma GCC target(\"avx,avx2\")\n#include <bits/stdc++.h>\n#define reg register\n#define int long long\n#define ALL(x) (x).begin(),(x).end()\n#define mem(x,y) memset(x,y,sizeof x)\n#define sz(x) (int)(x).size()\n#define ln puts(\"\")\n#define lsp putchar(32)\n#define pb push_back\n#define MP make_pair\n#define dbg(x) cerr<<\">\"<<__func__<<\"\\tLine: \"<<__LINE__<<' '<<#x<<\": \"<<x<<endl\nusing namespace std;\nconst int p=1e9+7;\nconst int MaxN=1000050;\ntemplate <class t> inline void read(t &s){s=0;\nreg int f=1;reg char c=getchar();while(!isdigit(c)){if(c=='-')f=-1;c=getchar();}\nwhile(isdigit(c))s=(s<<3)+(s<<1)+(c^48),c=getchar();s*=f;return;}\ntemplate<class t,class ...A> inline void read(t &x,A &...a){read(x);read(a...);}\ntemplate <class t> inline void write(t x){if(x<0)putchar('-'),x=-x;\nint buf[21],top=0;while(x)buf[++top]=x%10,x/=10;if(!top)buf[++top]=0;\nwhile(top)putchar(buf[top--]^'0');return;}\ninline void setIn(string s){freopen(s.c_str(),\"r\",stdin);return;}\ninline void setOut(string s){freopen(s.c_str(),\"w\",stdout);return;}\ninline void setIO(string s=\"\"){setIn(s+\".in\");setOut(s+\".out\");return;}\ntemplate <class t>inline bool checkmin(t&x,t y){if(x>y){x=y;return 1;}return 0;}\ntemplate <class t>inline bool checkmax(t&x,t y){if(x<y){x=y;return 1;}return 0;}\ninline int lowbit(int x){return x&(-x);}\ninline int fpow(int a,int b)\n{\n\treg int res=1;\n\tfor(;b;b>>=1,a=a*a%p)\n\t\tif(b&1)\n\t\t\tres=res*a%p;\n\treturn res;\n}\nint f[MaxN],g[MaxN];\nsigned main(void)\n{\n\tint n,H,D;read(n,H,D);\n\treg int w=1,t=1;\n\tfor(int i=2;i<=n;++i)\n\t\t(t*=i)%=p,(w+=t)%=p;\n\tf[0]=g[0]=1;\n\tfor(int i=1;i<=H;++i)\n\t\tf[i]=(g[i-1]-(i>D?g[i-D-1]:0)+p)%p*w%p,g[i]=(g[i-1]+f[i])%p;\n\twrite(f[H]*t%p*fpow(w,p-2)%p),ln;\n\treturn 0;\n}\n\n/*\n * Check List:\n * 1. Input / Output File (USACO and OI and UVa)\n * 2. long long \n * 3. Special Test such as n=1\n * 4. Array Size\n * 5. Memory Limit (OI) int is 4 and longlong is 8\n * 6. Mod (a*b%p*c%p not a*b*c%p  ,  (a-b+p)%p not a-b )\n * 7. Name ( int k; for(int k...))\n * 8. more tests , (T=2 .. more)\n * 9. blank \\n after a case\n*/\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<string.h>\n#include<algorithm>\n#include<stdlib.h>\n#include<math.h>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\nconst long long M=1000000007;\nint n,h,d,i,j;\nlong long f[1000005],s[1000005],ans;\nint main()\n{\n\tcin>>n>>h>>d;\n\tf[0]=1;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tf[0]=f[0]*i%M;\n\t\tans=(ans+f[0])%M;\n\t}\n\ts[0]=f[0];\n\tfor(i=1;i<h;i++)\n\t{\n\t\tif(i<=d)\n\t\t\tf[i]=s[i-1]*ans%M;\n\t\telse\n\t\t\tf[i]=(s[i-1]-s[i-d-1])*ans%M;\n\t\ts[i]=(s[i-1]+f[i])%M;\n\t}\n\tcout<<((s[h-1]-s[h-1-d])%M+M)%M<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint     = long long;\nconst lint inf = 1LL << 60;\nconst lint mod = 1000000007;\n\nstruct mint {\n    lint v;\n    lint _mod;\n    mint() : v(0) {}\n    mint(signed v, lint _mod = mod) : v(v), _mod(_mod) {}\n    mint(lint t, lint _mod = mod) : _mod(_mod) {\n        v = t % _mod;\n        if (v < 0)\n            v += _mod;\n    }\n\n    mint pow(lint k) {\n        mint res(1), tmp(v);\n        while (k) {\n            if (k & 1)\n                res *= tmp;\n            tmp *= tmp;\n            k >>= 1;\n        }\n        return res;\n    }\n    static mint add_identity() { return mint(0); }\n    static mint mul_identity() { return mint(1); }\n    mint inv() { return pow(_mod - 2); }\n\n    mint &operator+=(mint a) {\n        v += a.v;\n        if (v >= _mod)\n            v -= _mod;\n        return *this;\n    }\n    mint &operator-=(mint a) {\n        v += _mod - a.v;\n        if (v >= _mod)\n            v -= _mod;\n        return *this;\n    }\n    mint &operator*=(mint a) {\n        v = v * a.v % _mod;\n        return *this;\n    }\n    mint &operator/=(mint a) { return (*this) *= a.inv(); }\n\n    mint operator+(mint a) const { return mint(v) += a; };\n    mint operator-(mint a) const { return mint(v) -= a; };\n    mint operator*(mint a) const { return mint(v) *= a; };\n    mint operator/(mint a) const { return mint(v) /= a; };\n\n    mint operator-() const { return v ? mint(_mod - v) : mint(v); }\n\n    bool operator==(const mint a) const { return v == a.v; }\n    bool operator!=(const mint a) const { return v != a.v; }\n    bool operator<(const mint a) const { return v < a.v; }\n};\nostream &operator<<(ostream &os, mint m) { return os << m.v; }\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    lint n, h, d;\n    cin >> n >> h >> d;\n    vector<mint> dp(h + 1);\n    mint facto = 1;\n    mint f     = 0;\n    for (int i = 1; i <= n; ++i) {\n        facto *= i;\n        f += facto;\n    }\n    dp[0] = facto;\n    for (int i = 1; i <= h; ++i) {\n        dp[i] = dp[i - 1] * f;\n        if (i - d - 1 >= 0)\n            dp[i] -= dp[i - 1 - d] * f;\n        else\n            dp[i] += dp[0] - dp[0] * f;\n        dp[i] += dp[i - 1];\n    }\n    mint ret = dp[h] - dp[h - 1];\n    cout << ret << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i, n, m) for(int i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = std::int_fast64_t;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 1000000007;\nconstexpr long double eps = 1e-15;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n\tos << to_string(p.first) << \" \" << to_string(p.second);\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n\tREP(i, v.size()) {\n\t\tif(i) os << \" \";\n\t\tos << to_string(v[i]);\n\t}\n\treturn os;\n}\n\n\n//number//\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nstruct modint {\n\tll n;\npublic:\n\tmodint(const ll n = 0) : n((n % mod + mod) % mod) {}\n\tstatic modint pow(modint a, ll m) {\n\t\t// static vector<modint> v(1000010, -1);\n\t\t// if(m == mod - 2 && v[a.n] != -1) return v[a.n];\n\t\t// int tmp = a.n;\n\t\tmodint r = 1;\n\t\twhile(m > 0) {\n\t\t\tif(m & 1) { r *= a; }\n\t\t\ta = (a * a); m /= 2;\n\t\t}\n\t\t// if(m == mod - 2) return v[tmp] = r;\n\t\treturn r;\n\t}\n\tmodint &operator++() { *this += 1; return *this; }\n\tmodint &operator--() { *this -= 1; return *this; }\n\tmodint operator++(int) { modint ret = *this; *this += 1; return ret; }\n\tmodint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n\tmodint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n\tfriend bool operator==(const modint& lhs, const modint& rhs) {\n\t\treturn lhs.n == rhs.n;\n\t}\n\tfriend bool operator<(const modint& lhs, const modint& rhs) {\n\t\treturn lhs.n < rhs.n;\n\t}\n\tfriend bool operator>(const modint& lhs, const modint& rhs) {\n\t\treturn lhs.n > rhs.n;\n\t}\n\tfriend modint &operator+=(modint& lhs, const modint& rhs) {\n\t\tlhs.n += rhs.n;\n\t\tif (lhs.n >= mod) lhs.n -= mod;\n\t\treturn lhs;\n\t}\n\tfriend modint &operator-=(modint& lhs, const modint& rhs) {\n\t\tlhs.n -= rhs.n;\n\t\tif (lhs.n < 0) lhs.n += mod;\n\t\treturn lhs;\n\t}\n\tfriend modint &operator*=(modint& lhs, const modint& rhs) {\n\t\tlhs.n = (lhs.n * rhs.n) % mod;\n\t\treturn lhs;\n\t}\n\tfriend modint &operator/=(modint& lhs, const modint& rhs) {\n\t\tlhs.n = (lhs.n * (~rhs).n) % mod;\n\t\treturn lhs;\n\t}\n\tfriend modint operator+(const modint& lhs, const modint& rhs) {\n\t\treturn modint(lhs.n + rhs.n);\n\t}\n\tfriend modint operator-(const modint& lhs, const modint& rhs) {\n\t\treturn modint(lhs.n - rhs.n);\n\t}\n\tfriend modint operator*(const modint& lhs, const modint& rhs) {\n\t\treturn modint(lhs.n * rhs.n);\n\t}\n\tfriend modint operator/(const modint& lhs, const modint& rhs) {\n\t\treturn modint(lhs.n * (~rhs).n);\n\t}\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n\nstruct binomial_coefficient {\nprivate:\n\tint m;\n\tvector<modint> fact;\npublic:\n\tbinomial_coefficient(int m) : m(m) {\n\t\tfact.resize(m);\n\t\tfact[0] = 1;\n\t\tfor(int i = 1; i < m; i++) fact[i] = fact[i - 1] * i;\n\t}\n\tmodint combination(int n, int k) {\n\t\tif(n < 0 || k < 0 || n < k) return 0;\n\t\treturn fact[n] / fact[n - k] / fact[k];\n\t}\n};\n\n\n// graph //\nusing weight = long long;\nstruct edge { int to; weight w; };\ntemplate <typename T> struct vedge : edge { T v; };\nstruct graph {\nprivate:\n\tint n;\n\tbool weighted;\n\tbool tree;\n\tvector<vector<edge>> g;\npublic:\n\tgraph(int n, bool tree = false) : n(n), weighted(false), tree(tree), g(vector<vector<edge>>(n)) { }\n\tvector<edge>& operator[] (int i) { return g[i]; }\n\tint size() { return n; }\n\tbool isweighted() { return weighted; }\n\tbool istree() { return tree; }\n\tvoid add_edge(int s, int t, weight w = 1) {\n\t\tg[s].push_back({t, w});\n\t\tg[t].push_back({s, w});\n\t\tif(w != 1) weighted = true;\n\t}\n\tvoid add_dedge(int s, int t, weight w = 1) {\n\t\tg[s].push_back({t, w});\n\t\tif(w != 1) weighted = true;\n\t}\n};\ntemplate <typename T> struct vgraph {\npublic:\nprivate:\n\tint n;\n\tbool weighted;\n\tbool tree;\n\tvector<vector<vedge<T>>> g;\n\tvgraph(int n, bool tree = false) : n(n), weighted(false), tree(tree), g(vector<vector<vedge<T>>>(n)) { }\n\tvector<edge>& operator[] (int i) { return g[i]; }\n\tint size() { return n; }\n\tbool isweighted() { return weighted; }\n\tbool istree() { return tree; }\n\tvoid add_edge(int s, int t, T v, weight w = 1) {\n\t\tg[s].push_back({t, w, v});\n\t\tg[t].push_back({s, w, v});\n\t\tif(w != 1) weighted = true;\n\t}\n\tvoid add_dedge(int s, int t, T v, weight w = 1) {\n\t\tg[s].push_back({t, w, v});\n\t\tif(w != 1) weighted = true;\n\t}\n\tgraph build_graph() {\n\t\tgraph ret(n);\n\t\tfor(auto v: g) for(auto e: g[v]) {\n\t\t\tret.add_dedge(v, e.to, e.w);\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nvector<weight> shortest_path(graph& g, int s) {\n\tint n = g.size();\n\tvector<weight> path(n, -1);\n\tif(g.isweighted() && !g.istree()) { // dijkstra\n\t\tpriority_queue<pair<weight, int>, vector<pair<weight, int>>, greater<pair<weight, int>>> q;\n\t\tpath[s] = 0;\n\t\tq.push({0, s});\n\t\twhile(!q.empty()) {\n\t\t\tweight cost = q.top().first;\n\t\t\tint p = q.top().second;\n\t\t\tq.pop();\n\t\t\tif(path[p] != cost) continue;\n\t\t\tfor(auto e: g[p]) {\n\t\t\t\tif(path[e.to] == -1 || path[e.to] > cost + e.w) {\n\t\t\t\t\tpath[e.to] = cost + e.w;\n\t\t\t\t\tq.push({path[e.to], e.to});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else { // bfs\n\t\tqueue<int> q;\n\t\tpath[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()) {\n\t\t\tint p = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto e: g[p]) {\n\t\t\t\tif(path[e.to] == -1) {\n\t\t\t\t\tpath[e.to] = path[p] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn path;\n}\n\n\nusing mi = modint;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, h, d;\n\tcin >> n >> h >> d;\n\tvector<mi> fact(1010100, 0);\n\tfact[0] = 1;\n\tFOR(i, 1, 1010100) fact[i] = fact[i - 1] * i;\n\tmi fsum = 0;\n\tFOR(i, 1, n + 1) fsum += fact[i];\n\tmi sum = fact[n];\n\tmi ans = 0;\n\tqueue<mi> q; q.push(fact[n]);\n\tFOR(i, 1, h + 1) {\n\t\twhile((int)q.size() > d) {\n\t\t\tsum -= q.front();\n\t\t\tq.pop();\n\t\t}\n\t\tif(i == h) {\n\t\t\tans = sum;\n\t\t} else {\n\t\t\tq.push(sum * fsum);\n\t\t\tsum += sum * fsum;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n// ---------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\ntemplate<typename T> vector<T> make_vector(size_t sz){\n\treturn vector<T>(sz);\n}\n\ntemplate<typename T,typename... Ts> \nauto make_vector(size_t sz, Ts... ts){\n\treturn vector<decltype(make_vector<T>(ts...))>(sz, make_vector<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V> \ntypename enable_if<is_same<T, U>::value!=0>::type \nfill_value(U &u, const V... v){\n\tu=U(v...);\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_value(U &u, const V... v){\n\tfor(auto &e:u){\n\t\tfill_value<T>(e,v...);\n\t}\n}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n};\n\nunsigned ModInt::MOD = 1000000007;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\n\n\nconst int limit = 1000010;\nmint csum[limit];\n\nint main(void){\n\tint n, h, d;\n\tcin >> n >> h >> d;\n\t\n\tcsum[h] = mint(n);\n\tmint cur = csum[h];\n\t\n\tmint coef = ZERO, tmp = ONE; \n\trep(i, 1, n + 1){\n\t\ttmp *= mint(i);\n\t\tcoef += tmp;\n\t}\n\n\trrep(i, h, 1){\n\t\tcsum[i] = coef * cur;\n\t\tcur += csum[i];\n\t\tif(i + d <= h) cur -= csum[i + d];\n\t}\n\n\trep(i, 1, n) cur *= mint(i);\n\n\tcout << cur << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long fact[1000005];\nlong long dp[1000005];\n\nconst long long MOD = 1e9+7;\n\nint main(){\n    int N, H, D;\n    scanf(\"%d%d%d\", &N, &H, &D);\n\n    long long retainWays = 0;\n    fact[0] = 1;\n    for(int i = 1; i <= N; i ++){\n        fact[i] = fact[i-1]*i%MOD;\n        retainWays += fact[i]%MOD;\n    }\n    retainWays %= MOD;\n\n    //printf(\"retainWays=%lld\\n\", retainWays);\n\n    dp[0] = fact[N];\n    long long slidingWindowSum = dp[0];\n    for(int i = 1; i <= H; i ++){\n        dp[i] = slidingWindowSum;\n\n        /*for(int j = 1; j <= min(i, D); j ++){\n            dp[i] += dp[i-j];\n        }*/\n\n        dp[i] %= MOD;\n\n        if(i == H){break;}\n\n        dp[i] = dp[i]*retainWays%MOD;\n        slidingWindowSum += dp[i];\n        if(i-D >= 0){\n            slidingWindowSum -= dp[i-D];\n        }\n        slidingWindowSum = (slidingWindowSum+2*MOD)%MOD;\n\n        //printf(\"dp[%d]=%lld\\n\", i, dp[i]);\n    }\n\n    printf(\"%lld\", dp[H]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for(register int i = x;i <= y; ++ i)\n#define repd(i,x,y) for(register int i = x;i >= y; -- i)\nusing namespace std;\ntypedef long long ll;\ntemplate<typename T>inline void read(T&x)\n{\n\tchar c;int sign = 1;x = 0;\n\tdo { c = getchar(); if(c == '-') sign = -1; }while(!isdigit(c));\n\tdo { x = x * 10 + c - '0'; c = getchar(); }while(isdigit(c));\n\tx *= sign;\n}\n\nconst int mod = 1e9 + 7,N = 2e5 + 50;\nint f[N],fac[N],m,n,h,d;\n\ninline int ksm(int x,int y)\n{\n\tint ans = 1;\n\twhile(y)\n\t{\n\t\tif(y&1) ans = 1ll * ans * x % mod;\n\t\ty >>= 1; x = 1ll * x * x % mod;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tread(n); read(h); read(d);\n\tf[0] = 1; fac[0] = 1;\n\trep(i,1,n) fac[i] = 1ll * fac[i-1] * i % mod;\n\trep(i,1,n) m = (m + fac[i]) % mod;\n\n\trep(i,1,h)\n\t{\n\t\tf[i] = 1ll * (f[i - 1] - (i - d - 1 >= 0 ? f[i - d - 1] : 0)) * m % mod;\n\t\tif(f[i] < 0) f[i] = f[i] + mod;\n\n\t\tf[i] = (f[i-1] + f[i]) % mod;\n\t}\n\t\n\tcout << 1ll * (f[h] - f[h-1] + mod) % mod * fac[n] % mod * ksm(m,mod-2) % mod << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\n\nll modpow(ll x,ll k){\n\tif(k == 0)return 1;\n\tll ret = modpow(x,k/2);\n\tret *= ret; ret %= MOD;\n\tif(k%2 == 1){\n\t\tret *= x; ret %= MOD;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tll n,h,d;\n\tcin >> n >> h >> d;\n\t\n\tstatic ll dp[1000010];\n\tdp[0] = 1;\n\t\n\tll x = 1;\n\tll y = 0;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tx *= i; x %= MOD;\n\t\ty += x; y %= MOD;\n\t}\n\tll sum = 0;\n\tfor(int i = 0 ; i < h ; i ++){\n\t\tif(i > 0){dp[i] *= y; dp[i] %= MOD;}\n\t\tsum += dp[i];\n\t\tif(i >= d)sum += MOD-dp[i-d];\n\t\tsum %= MOD;\n\t\tdp[i+1] = sum;\n\t}\n\tcout << (dp[h]*x)%MOD << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n#include <numeric>\n#define M_PI       3.14159265358979323846\n\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define FILL(a, x) memset(a, x, sizeof(a))\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n\nconst int N = 1010000;\nconst LL MOD = 1000000007;\nLL fac[N];\nLL sfac[N];\nLL dp[N];\n\nint main() {\n\tLL n, h, d;\n\tcin >> n >> h >> d;\n\tfac[0] = fac[1] = 1;\n\tFOR(i, 1, n + 1) {\n\t\tfac[i] = (fac[i - 1] * i) % MOD;\n\t\tsfac[i] = (sfac[i - 1] + fac[i]) % MOD;\n\t}\n\tdp[0] = fac[n];\n\tLL s = dp[0];\n\tFOR(i, 1, h) {\n\t\tdp[i] = (s * sfac[n])%MOD;\n\t\ts = (s + dp[i])%MOD;\n\t\tif (i >= d)s = (s - dp[i - d] + MOD) % MOD;\n\t}\n\tcout << s << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n\nusing _loop_int = int;\n#define REP(i,n) for(_loop_int i=0; i<(_loop_int)(n); i++)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a); i<(_loop_int)(b); i++)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1; i>=(_loop_int)(a); i--)\n\n#define CHMIN(a,b) (a)=min((a),(b))\n#define CHMAX(a,b) (a)=max((a),(b))\n#define ALL(v) (v).begin(),(v).end()\n\n#define DEBUG(x) cerr<<#x<<\": \"<<(x)<<endl\n#define DEBUG_VEC(v) cerr<<#v<<\": \";REP(__i,(v).size())cerr<<((v)[__i])<<\", \";cerr<<endl\n\nconst ll MOD = 1000000007ll;\n\nll n,h,d;\nll fact[1252525];\nll dp[1252525];\nll sum[1252525];\n\nint main(){\n    cin>>n>>h>>d;\n    fact[0] = 1;\n    FOR(i,1,n+1)fact[i]=i*fact[i-1]%MOD;\n\n    ll a = fact[n];\n    ll m = 0;\n    REP(i,n+1)m = (m+fact[i])%MOD;\n\n    dp[0] = a;\n    sum[1] = (sum[0] + dp[0]) % MOD;\n    FOR(i,1,d){\n        dp[i] = dp[i-1]*m%MOD;\n        sum[i+1] = (sum[i] + dp[i]) % MOD;\n    }\n    FOR(i,d,h){\n        dp[i] = (sum[i]-sum[i-d]+MOD)*(m-1)%MOD;\n        sum[i+1] = (sum[i] + dp[i]) % MOD;\n    }\n    printf(\"%lld\\n\",dp[h-1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n#define REP(i, n) for (int i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (int i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n    {1, 0}, {0, 1},  {-1, 0},  {0, -1},  // 4方向\n    {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n    {0, 0},                              // 自身\n};\ntemplate <class T>\ninline bool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T>\ninline bool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T, class S>\nvector<T> make_vec(size_t n, S x) {\n    return vector<T>(n, x);\n}\ntemplate <class T, class... Ts>\nauto make_vec(size_t n, Ts... ts) {\n    return vector<decltype(make_vec<T>(ts...))>(n, make_vec<T>(ts...));\n}\n\n// debug\ntemplate <class T>\nostream& operator<<(ostream& s, vector<T>& d) {\n    REP(i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \");\n    return s;\n}\ntemplate <class T>\nostream& operator<<(ostream& s, vector<vector<T>>& d) {\n    REP(i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\");\n    return s;\n}\ntemplate <class T, class S>\nostream& operator<<(ostream& s, pair<T, S>& p) {\n    s << \"{\" << p.first << \", \" << p.second << \"}\";\n    return s;\n}\ntemplate <class T, class S>\nostream& operator<<(ostream& s, map<T, S> m) {\n    for (auto it = m.begin(); it != m.end(); it++) {\n        s << *it << (next(it) == m.end() ? \"\" : \"\\n\");\n    }\n    return s;\n}\ntemplate <class T, class S>\nostream& operator<<(ostream& s, unordered_map<T, S> m) {\n    for (auto it = m.begin(); it != m.end(); it++) {\n        s << *it << (next(it) == m.end() ? \"\" : \"\\n\");\n    }\n    return s;\n}\n#ifdef _MY_DEBUG\n#define dump(...)                                                                                                     \\\n    cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), \\\n        cerr << \"*/\\n\\n\";\n#else\n#define dump(...)\n#define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail>\nvoid dump_func(Head&& h, Tail&&... t) {\n    cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...);\n}\n\nstruct Fast {\n    Fast() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n    }\n} fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 1000000007;\n// *************** TEMPLATE END ***************\n\ntemplate <class T>\nT pow(T x, int n, const T UNION = 1) {\n    T ret = UNION;\n    while (n) {\n        if (n & 1) ret *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return ret;\n}\n\ntemplate <int MD>\nstruct ModInt {\n    int x;\n    static unordered_map<int, int> to_inv;\n    ModInt() : x(0) {}\n    ModInt(int x_) {\n        if ((x = x_ % MD + MD) >= MD) x -= MD;\n    }\n\n    ModInt& operator+=(ModInt that) {\n        if ((x += that.x) >= MD) x -= MD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt that) {\n        x = (unsigned long long)x * that.x % MD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt that) {\n        if ((x -= that.x) < 0) x += MD;\n        return *this;\n    }\n    ModInt& operator/=(ModInt that) {\n        x = (unsigned long long)x * that.inv().x % MD;\n        return *this;\n    }\n\n    ModInt operator-() const { return -x < 0 ? MD - x : -x; }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt inv() const { return to_inv.count(this->x) ? to_inv[this->x] : (to_inv[this->x] = pow(*this, MD - 2).x); }\n    friend ostream& operator<<(ostream& s, ModInt<MD> a) {\n        s << a.x;\n        return s;\n    }\n    friend istream& operator>>(istream& s, ModInt<MD>& a) {\n        s >> a.x;\n        return s;\n    }\n};\ntemplate <int MD>\nunordered_map<int, int> ModInt<MD>::to_inv;\nusing mint = ModInt<MOD>;\n\nvector<mint> fact, fact_inv;\nvoid init_factorial(int n) {\n    fact = vector<mint>(n + 1, 1);\n    fact_inv = vector<mint>(n + 1);\n    for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n    fact_inv[n] = mint(1) / fact[n];\n    for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n    // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n}\nmint comb(int n, int r) { return fact[n] * fact_inv[r] * fact_inv[n - r]; }\n\n// T0: 元の配列のモノイド\n// T1: T0に対する作用素モノイド\ntemplate <class T0, class T1>\nclass SegmentTree {\n    // k番目のノードにのlazyを伝搬\n    void eval(int k, int len) {\n        // u1が正確に単位元ならいらない\n        if (lazy[k] == u1) return;\n        // len個分のlazy[k]を評価\n        node[k] = g(node[k], p(lazy[k], len));\n        if (k < N - 1) {\n            // 最下段でなければ下のlazyに伝搬\n            lazy[2 * k + 1] = f1(lazy[2 * k + 1], lazy[k]);\n            lazy[2 * k + 2] = f1(lazy[2 * k + 2], lazy[k]);\n        }\n        lazy[k] = u1;\n    }\n    // k番目のノード[l, r)について、[a, b)の範囲内にxを作用\n    void update(int a, int b, T1 x, int k, int l, int r) {\n        eval(k, r - l);\n        if (b <= l || r <= a) return;\n        if (a <= l && r <= b) {\n            lazy[k] = f1(lazy[k], x);\n            eval(k, r - l);\n        } else {\n            update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n            update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n            node[k] = f0(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n    // k番目のノード[l, r)について、[a, b)のクエリを求める\n    T0 query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return u0;\n        eval(k, r - l);\n        if (a <= l && r <= b) return node[k];\n        T0 vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        T0 vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return f0(vl, vr);\n    }\n\npublic:\n    int sz;  // 元の配列のサイズ\n    int N;\n    vector<T0> node;\n    vector<T1> lazy;\n    // T0上の演算、単位元\n    // using F0 = function<T0(T0, T0)>;\n    // F0 f0;\n    // T0 u0;\n    T0 f0(T0 x, T0 y) { return x + y; };\n    T0 u0 = 0;\n    // T1上の演算、単位元\n    // using F1 = function<T1(T1, T1)>;\n    // F1 f1;\n    // T1 u1;\n    T1 f1(T0 x, T0 y) { return x + y; };\n    T1 u1 = 0;\n    // 作用\n    // using G = function<T0(T0, T1)>;\n    // G g;\n    T0 g(T0 x, T1 y) { return x + y; };\n    // 多数のt1(T1)に対するf1の合成\n    // using P = function<T1(T1, int)>;\n    // P p;\n    T1 p(T1 x, int len) { return x * len; };\n    SegmentTree(const vector<T0>& a) : sz(a.size()) {\n        for (N = 1; N < sz; N *= 2)\n            ;\n        node.resize(2 * N - 1);\n        lazy.resize(2 * N - 1, u1);\n        REP(i, sz) node[N - 1 + i] = a[i];\n        for (int i = N - 2; i >= 0; i--) node[i] = f0(node[2 * i + 1], node[2 * i + 2]);\n    }\n    // [a, b)にxを作用\n    void update(int a, int b, T1 x) {\n        assert(0 <= a && a < b && b <= sz);\n        update(a, b, x, 0, 0, N);\n    }\n    void update(int a, T1 x) { update(a, a + 1, x); }\n    // [a, b)\n    T0 query(int a, int b) { return query(a, b, 0, 0, N); }\n    T0 query(int a) { return query(a, a + 1); }\n};\n\nsigned main() {\n    int n, H, D;\n    cin >> n >> H >> D;\n    init_factorial(n + 10);\n    mint mul = 0;\n    REPI(i, 1, n + 1) { mul += fact[i]; }\n\n    // Sum & Add\n    SegmentTree<mint, mint> seg(vector<mint>(H + 1, 0));\n    // SegmentTree<mint, mint> seg(vector<mint>(H + 1, 0), plus<mint>(), 0, plus<mint>(), 0, plus<mint>(),\n    //                             multiplies<mint>());\n    seg.update(0, fact[n] / mul);\n    REP(i, H) {\n        mint now = seg.query(i);\n        seg.update(i + 1, min(H + 1, i + D + 1), now * mul);\n    }\n    cout << seg.query(H) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\nconst ll MOD = 1000000007;\n\nll A[1000010];\n\nint main() {\n    int n, D, H;\n    cin >> n >> H >> D;\n    ll B = 0;\n    ll meow = 1;\n    for (int i = 1; i <= n; i++) {\n        meow = (meow * i) % MOD;\n        B = (B + meow) % MOD;\n    }\n\n    A[0] = meow;\n    ll sum = A[0];\n    for (int i = 1; i < H; i++) {\n        A[i] = sum * B % MOD;\n        sum = (sum + A[i]) % MOD;\n        if (i - D >= 0)\n            sum = (sum - A[i - D] + MOD) % MOD;\n    }\n    cout << sum << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : E.cpp\n * Author  : Kazune Takahashi\n * Created : 6/16/2019, 12:54:46 AM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define maxs(x, y) (x = max(x, y))\n#define mins(x, y) (x = min(x, y))\ntypedef long long ll;\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\nconst int MAX_SIZE = 1000010;\nclass mint\n{\npublic:\n  static ll MOD;\n  ll x;\n  mint() : x(0) {}\n  mint(ll x) : x(x % MOD) {}\n  mint operator-() const { return x ? MOD - x : 0; }\n  mint &operator+=(const mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  mint &operator-=(const mint &a) { return *this += -a; }\n  mint &operator*=(const mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint &operator/=(const mint &a) { return (*this *= power(MOD - 2)); }\n  mint operator+(const mint &a) const { return mint(*this) += a; }\n  mint operator-(const mint &a) const { return mint(*this) -= a; }\n  mint operator*(const mint &a) const { return mint(*this) *= a; }\n  mint operator/(const mint &a) const { return mint(*this) /= a; }\n  bool operator<(const mint &a) const { return x < a.x; }\n  bool operator==(const mint &a) const { return x == a.x; }\n  const mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\nll mint::MOD = 1e9 + 7;\nistream &operator>>(istream &stream, mint &a) { return stream >> a.x; }\nostream &operator<<(ostream &stream, const mint &a) { return stream << a.x; }\nmint inv[MAX_SIZE];\nmint fact[MAX_SIZE];\nmint factinv[MAX_SIZE];\nvoid init()\n{\n  inv[1] = 1;\n  for (int i = 2; i < MAX_SIZE; i++)\n  {\n    inv[i] = (-inv[mint::MOD % i]) * (mint::MOD / i);\n  }\n  fact[0] = factinv[0] = 1;\n  for (int i = 1; i < MAX_SIZE; i++)\n  {\n    fact[i] = mint(i) * fact[i - 1];\n    factinv[i] = inv[i] * factinv[i - 1];\n  }\n}\nmint choose(int n, int k)\n{\n  if (n >= 0 && k >= 0 && n - k >= 0)\n  {\n    return fact[n] * factinv[k] * factinv[n - k];\n  }\n  return 0;\n}\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// const double epsilon = 1e-10;\n// const ll infty = 1000000000000000LL;\n// const int dx[4] = {1, 0, -1, 0};\n// const int dy[4] = {0, 1, 0, -1};\n\nll N, H, D;\nmint X = 0;\nmint dp[1000010];\nmint sum[1000010];\n\nint main()\n{\n  init();\n  cin >> N >> H >> D;\n  for (auto i = 1; i <= N; i++)\n  {\n    X += fact[i];\n  }\n  for (auto i = 1; i <= D; i++)\n  {\n    dp[i] = 1;\n  }\n  sum[1] = 0;\n  for (auto i = 2; i <= H; i++)\n  {\n    sum[i] = sum[i - 1] + dp[i - 1];\n    dp[i] += sum[i] * X;\n    if (i - D >= 1)\n    {\n      dp[i] -= sum[i - D] * X;\n    }\n#if DEBUG == 1\n    if (H < 100)\n    {\n      cerr << \"sum[\" << i << \"] = \" << sum[i] << endl;\n      cerr << \"dp[\" << i << \"] = \" << dp[i] << endl;\n    }\n#endif\n  }\n  cout << dp[H] * fact[N] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\nusing namespace std;\nusing ll=long long;\n\nconst ll MOD=1e9+7;\nint main(){\n    int n;\n    int h,d;\n    cin>>n>>h>>d;\n    vector<ll> fact(n+1);\n    fact[0]=1;\n    for(int i=1;i<=n;i++) fact[i]=fact[i-1]*i%MOD;\n    vector<ll> dp(h+1);\n    ll v=(accumulate(fact.begin(),fact.end(),0LL)-1)%MOD;\n    dp[0]=fact[n];\n    ll sum=dp[0];    \n    for(int i=1;i<h;i++){\n        if(i-d-1>=0){\n            sum-=dp[i-d-1];\n            sum%=MOD;\n        }\n        dp[i]=sum*v%MOD;\n        sum+=dp[i];\n        sum%=MOD;\n    }\n    ll res=0;\n    for(int i=h-d;i<h;i++){\n        res+=dp[i];\n        res%=MOD;\n    }\n    res=(res+MOD)%MOD;\n    cout<<res<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\n//0-indexed BIT\nclass BIT\n{\n    using T = mint;\nprivate:\n    void _add(int i, T x) {\n        if (i > N) return;\n        data[i] += x;\n        _add(i + (i & -i), x);\n    }\n\npublic:\n    vector<T> data;\n    int N;\n\n    BIT(int N): data(vector<T>(N + 1, 0)), N(N) {}\n\n    //sum of [0,i) (0<=i<=N)\n    T sum(int i) {\n        if (!i) return 0;\n        return data[i] + sum(i - (i & -i));\n    }\n\n    void add(int i, T x) { _add(i + 1, x); };\n\n};\n\nsigned main(){\n\n    int N, H, D; cin >> N >> H >> D;\n    Combination C(N);\n\n    mvec dp(H + 1);\n    BIT b(H + 1);\n    dp[0] = C.fact[N];\n    mint c0 = 0;\n    FOR(n, 1, N + 1) c0 += C.fact[n];\n    FOR(i, 1, H + 1){\n        b.add(i - 1, dp[i - 1]);\n        dp[i] = (b.sum(i) - b.sum(max(i - D, 0LL))) * c0;\n    }\n    mint ans = dp[H] / c0;\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n#define REP(i, n) for (int i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (int i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n  {1, 0}, {0, 1}, {-1, 0}, {0, -1},  // 4方向\n  {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n  {0, 0},  // 自身\n};\ntemplate <class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T, class S> vector<T> make_vec(size_t n, S x) { return vector<T>(n, x); }\ntemplate <class T, class... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec<T>(ts...))>(n, make_vec<T>(ts...)); }\n\n// debug\ntemplate <class T> ostream& operator<<(ostream& s, vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream& s, vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, unordered_map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n  #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n  #define dump(...)\n  #define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\n\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 1000000007;\n// *************** TEMPLATE END *************** \n\ntemplate <class T>\nT pow(T x, int n, const T UNION = 1) {\n  T ret = UNION;\n  while (n) {\n    if (n & 1) ret *= x;\n    x *= x; n >>= 1;\n  }\n  return ret;\n}\n\ntemplate <int MD>\nstruct ModInt {\n  int x;\n  static unordered_map<int, int> to_inv;\n  ModInt() : x(0) {}\n  ModInt(int x_) { if ((x = x_ % MD + MD) >= MD) x -= MD; }\n\n  ModInt& operator+=(ModInt that) { if ((x += that.x) >= MD) x -= MD; return *this; }\n  ModInt& operator*=(ModInt that) { x = (unsigned long long)x * that.x % MD; return *this; }\n  ModInt& operator-=(ModInt that) { if ((x -= that.x) < 0) x += MD; return *this; }\n  ModInt& operator/=(ModInt that) { x = (unsigned long long)x * that.inv().x % MD; return *this; }\n\n  ModInt operator-() const { return -x < 0 ? MD - x : -x; }\n  ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n  ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n  ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n  ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n  bool operator==(ModInt that) const { return x == that.x; }\n  bool operator!=(ModInt that) const { return x != that.x; }\n  ModInt inv() const { return to_inv.count(this->x) ? to_inv[this->x] : (to_inv[this->x] = pow(*this, MD - 2).x); }\n  friend ostream& operator<<(ostream& s, ModInt<MD> a) { s << a.x; return s; }\n  friend istream& operator>>(istream& s, ModInt<MD>& a) { s >> a.x; return s; }\n};\ntemplate <int MD> unordered_map<int, int> ModInt<MD>::to_inv;\nusing mint = ModInt<MOD>;\n\nvector<mint> fact, fact_inv;\nvoid init_factorial(int n) {\n  fact = vector<mint>(n + 1, 1);\n  fact_inv = vector<mint>(n + 1);\n  for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n  fact_inv[n] = mint(1) / fact[n];\n  for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n  // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n}\nmint comb(int n, int r) {\n  return fact[n] * fact_inv[r] * fact_inv[n - r];\n}\n\n// T0: 元の配列のモノイド\n// T1: T0に対する作用素モノイド\ntemplate <class T0, class T1>\nclass SegmentTree {\n  // k番目のノードにのlazyを伝搬\n  void eval(int k, int len) {\n    // u1が正確に単位元ならいらない\n    if (lazy[k] == u1) return;\n    // len個分のlazy[k]を評価\n    node[k] = g(node[k], p(lazy[k], len));\n    if (k < N - 1) {\n      // 最下段でなければ下のlazyに伝搬\n      lazy[2 * k + 1] = f1(lazy[2 * k + 1], lazy[k]);\n      lazy[2 * k + 2] = f1(lazy[2 * k + 2], lazy[k]);\n    }\n    lazy[k] = u1;\n  }\n  // k番目のノード[l, r)について、[a, b)の範囲内にxを作用\n  void update(int a, int b, T1 x, int k, int l, int r) {\n    eval(k, r - l);\n    if (b <= l || r <= a) return;\n    if (a <= l && r <= b) {\n      lazy[k] = f1(lazy[k], x);\n      eval(k, r - l);\n    } else {\n      update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n      update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n      node[k] = f0(node[2 * k + 1], node[2 * k + 2]);\n    }\n  }\n  // k番目のノード[l, r)について、[a, b)のクエリを求める\n  T0 query(int a, int b, int k, int l, int r) {\n    if (r <= a || b <= l) return u0;\n    eval(k, r - l);\n    if (a <= l && r <= b) return node[k];\n    T0 vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n    T0 vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n    return f0(vl, vr);\n  }\npublic:\n  int sz; // 元の配列のサイズ\n  int N;\n  vector<T0> node;\n  vector<T1> lazy;\n  // T0上の演算、単位元\n  using F0 = function<T0(T0, T0)>;\n  F0 f0; T0 u0;\n  // T1上の演算、単位元\n  using F1 = function<T1(T1, T1)>;\n  F1 f1; T1 u1;\n  // 作用\n  using G = function<T0(T0, T1)>;\n  G g;\n  // 多数のt1(T1)に対するf1の合成\n  using P = function<T1(T1, int)>;\n  P p;\n  SegmentTree(const vector<T0>& a, F0 f0, T0 u0, F1 f1, T1 u1, G g, P p)\n  : sz(a.size()), f0(f0), u0(u0), f1(f1), u1(u1), g(g), p(p) {\n    for (N = 1; N < sz; N *= 2);\n    node.resize(2 * N - 1);\n    lazy.resize(2 * N - 1, u1);\n    REP (i, sz) node[N - 1 + i] = a[i];\n    for (int i = N - 2; i >= 0; i--) node[i] = f0(node[2 * i + 1], node[2 * i + 2]);\n  }\n  // [a, b)にxを作用\n  void update(int a, int b, T1 x) {\n    assert(0 <= a && a < b && b <= sz);\n    update(a, b, x, 0, 0, N);\n  }\n  void update(int a, T1 x) {\n    update(a, a + 1, x);\n  }\n  // [a, b)\n  T0 query(int a, int b) {\n    return query(a, b, 0, 0, N);\n  }\n  T0 query(int a) {\n    return query(a, a + 1);\n  }\n};\n\nsigned main() {\n  int n, H, D; cin >> n >> H >> D;\n  init_factorial(n + 10);\n  mint mul = 0;\n  REPI (i, 1, n + 1) {\n    mul += fact[i];\n  }\n\n  // Sum & Add\n  SegmentTree<mint, mint> seg(\n    vector<mint>(H + 1, 0),\n    plus<mint>(), 0,\n    plus<mint>(), 0,\n    plus<mint>(),\n    multiplies<mint>()\n  );\n  seg.update(0, fact[n] / mul);\n  REP (i, H) {\n    mint now = seg.query(i);\n    seg.update(i + 1, min(H + 1, i + D + 1), now * mul);\n  }\n  cout << seg.query(H) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define FOR(i,m,n) for(int i=(m);i<(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n\nconst int INF = 0x3f3f3f3f;\nconst long long LINF = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007; // 998244353;\nconst int dy[] = {1, 0, -1, 0}, dx[] = {0, -1, 0, 1};\n/*-------------------------------------------------*/\nint mod = MOD;\nstruct ModInt {\n  unsigned val;\n  ModInt(): val(0) {}\n  ModInt(long long x) : val(x >= 0 ? x % mod : x % mod + mod) {}\n  ModInt pow(long long exponent) {\n    ModInt tmp = *this, res = 1;\n    while (exponent > 0) {\n      if (exponent & 1) res *= tmp;\n      tmp *= tmp;\n      exponent >>= 1;\n    }\n    return res;\n  }\n  ModInt &operator+=(const ModInt &rhs) { if((val += rhs.val) >= mod) val -= mod; return *this; }\n  ModInt &operator-=(const ModInt &rhs) { if((val += mod - rhs.val) >= mod) val -= mod; return *this; }\n  ModInt &operator*=(const ModInt &rhs) { val = (unsigned long long)val * rhs.val % mod; return *this; }\n  ModInt &operator/=(const ModInt &rhs) { return *this *= rhs.inv(); }\n  bool operator==(const ModInt &rhs) const { return val == rhs.val; }\n  bool operator!=(const ModInt &rhs) const { return val != rhs.val; }\n  bool operator<(const ModInt &rhs) const { return val < rhs.val; }\n  bool operator<=(const ModInt &rhs) const { return val <= rhs.val; }\n  bool operator>(const ModInt &rhs) const { return val > rhs.val; }\n  bool operator>=(const ModInt &rhs) const { return val >= rhs.val; }\n  ModInt operator-() const { return ModInt(-val); }\n  ModInt operator+(const ModInt &rhs) const { return ModInt(*this) += rhs; }\n  ModInt operator-(const ModInt &rhs) const { return ModInt(*this) -= rhs; }\n  ModInt operator*(const ModInt &rhs) const { return ModInt(*this) *= rhs; }\n  ModInt operator/(const ModInt &rhs) const { return ModInt(*this) /= rhs; }\n  friend ostream &operator<<(ostream &os, const ModInt &rhs) { return os << rhs.val; }\n  friend istream &operator>>(istream &is, ModInt &rhs) { long long x; is >> x; rhs = ModInt(x); return is; }\nprivate:\n  ModInt inv() const {\n    // if (__gcd((int)val, mod) != 1) assert(false);\n    unsigned a = val, b = mod; int x = 1, y = 0;\n    while (b) {\n      unsigned tmp = a / b;\n      a -= tmp * b; swap(a, b);\n      x -= tmp * y; swap(x, y);\n    }\n    return ModInt(x);\n  }\n};\nModInt abs(const ModInt &x) { return x.val; }\nstruct Combinatorics {\n  Combinatorics(int MAX = 5000000) {\n    MAX <<= 1;\n    fact.resize(MAX + 1);\n    fact_inv.resize(MAX + 1);\n    fact[0] = 1;\n    FOR(i, 1, MAX + 1) fact[i] = fact[i - 1] * i;\n    fact_inv[MAX] = ModInt(1) / fact[MAX];\n    for (int i = MAX; i > 0; --i) fact_inv[i - 1] = fact_inv[i] * i;\n  }\n  ModInt nCk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    return fact[n] * fact_inv[k] * fact_inv[n - k];\n  }\n  ModInt nPk(int n, int k) {\n    if (n < 0 || n < k || k < 0) return ModInt(0);\n    return fact[n] * fact_inv[n - k];\n  }\n  ModInt nHk(int n, int k) {\n    if (n < 0 || k < 0) return ModInt(0);\n    return (k == 0 ? ModInt(1) : nCk(n + k - 1, k));\n  }\nprivate:\n  vector<ModInt> fact, fact_inv;\n};\n\nint main() {\n  cin.tie(0); ios::sync_with_stdio(false);\n  // freopen(\"input.txt\", \"r\", stdin);\n\n  int n, h, d; cin >> n >> h >> d;\n  ModInt seni = 0, tmp = 1;\n  for (int i = n - 1; i > 0; --i) {\n    tmp *= i;\n    seni += tmp;\n  }\n  tmp *= n;\n  seni += tmp;\n  vector<ModInt> dp(h + 1);\n  ModInt ruiseki = 0;\n  dp[0] = 1;\n  FOR(i, 1, h + 1) {\n    dp[i] = ruiseki * seni + (i <= d ? n : 0);\n    ruiseki += dp[i];\n    if (i > d) ruiseki -= dp[i - d];\n  }\n  FOR(i, 1, n) dp[h] *= i;\n  cout << dp[h] << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int MOD = 1e9 + 7;\n\nint add(int a, int b) {\n    return (a + b) % MOD;\n}\n\nint sub(int a, int b) {\n    return (a - b + MOD) % MOD;\n}\n\nint mul(ll a, ll b) {\n    return (a * b) % MOD;\n}\n\nint main() {\n    int n, h, d;\n    cin >> n >> h >> d;\n\n    vector<int> f(n + 1);\n    f[0] = 1;\n    for (int i = 1; i <= n; i++)\n        f[i] = mul(f[i - 1], i);\n\n    int coef = accumulate(f.begin() + 1, f.end(), 0LL) % MOD;\n\n    vector<int> dp(h + 1), pref(h + 2);\n    dp[0] = 1, pref[1] = f[n];\n    for (int i = 1; i <= h; i++) {\n        dp[i] = sub(pref[i], pref[max(i - d, 0)]);\n        pref[i + 1] = add(pref[i], mul(coef, dp[i]));\n    }\n\n    cout << dp[h] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nlong long mod = 1000000007;\nlong long N, H, D;\nlong long dp[1 << 20], fact[1 << 20];\n\nint main() {\n\tcin >> N >> H >> D;\n\tfact[0] = 1; for (int i = 1; i <= N; i++) fact[i] = (1LL * i*fact[i - 1]) % mod;\n\tlong long s = 0; for (int i = 1; i <= N; i++) { s += fact[i]; s %= mod; }\n\n\tdp[0] = 1; long long ret = dp[0];\n\tfor (int i = 1; i <= H; i++) {\n\t\tif (i == H) dp[i] = (ret*fact[N]) % mod;\n\t\telse dp[i] = (ret * s) % mod;\n\t\tret += dp[i]; ret %= mod;\n\t\tif (i >= D) { ret -= dp[i - D]; ret += mod; ret %= mod; }\n\t}\n\tcout << dp[H] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#define LL long long\nusing namespace std;\nconst LL mod=1e9+7;\nLL n,h,d,fac[1000010],f[1000010],s[1000010];\nint main()\n{\n\tscanf(\"%lld %lld %lld\",&n,&h,&d);\n\tfac[0]=fac[1]=1;\n\tfor(LL i=2;i<=n;i++) fac[i]=fac[i-1]*i%mod;\n\tf[1]=s[1]=fac[n];\n\tLL p=0;for(LL i=0;i<=n;i++) (p+=fac[i])%=mod;\n\tfor(LL i=2;i<=d;i++) s[i]=(s[i-1]+(f[i]=f[i-1]*p%mod))%mod;\n\tfor(LL i=d+1;i<=h;i++)\n\t{\n\t\tf[i]=(s[i-1]-s[i-d-1])%mod*(p-1)%mod;\n\t\ts[i]=(s[i-1]+f[i])%mod;\n\t}\n\tprintf(\"%lld\",(f[h]+mod)%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <random>\n\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nlong DP[1000001];\nlong S[1000001];\nvoid Calc(){\n\tint N = rei();\n\tlong H = rei();\n\tlong D = rei();\n\tS[1] = 1;\n\tfor(int i=2;i<=N;i++){\n\t\tS[i] = S[i-1]*i % mod;\n\t}\n\tlong sumS = 0;\n\tfor(int i=1;i<=N;i++){\n\t\tsumS += S[i];\n\t}\n\tsumS %= mod;\n\tlong sum = 1;\n\tDP[0] = sum;\n\tfor(int i=1;i<H;i++){\n\t\tif(i > D){\n\t\t\tsum += mod - DP[i-D-1];\n\t\t\tsum %= mod;\n\t\t}\n\t\tDP[i] = sum * sumS % mod;\n\t\tsum += DP[i];\n\t\tsum %= mod;\n\t}\n\tif(H > D){\n\t\tsum += mod - DP[H-D-1];\n\t\tsum %= mod;\n\t}\n\tcout << sum * S[N] % mod << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include <iostream>\n    using namespace std;\n     \n    long long mod = 1000000007;\n    long long N, H, D;\n    long long dp[1 << 20], fact[1 << 20];\n     \n    int main() {\n    \tcin >> N >> H >> D;\n    \tfact[0] = 1; for (int i = 1; i <= N; i++) fact[i] = (1LL * i*fact[i - 1]) % mod;\n    \tlong long s = 0; for (int i = 1; i <= N; i++) { s += fact[i]; s %= mod; }\n     \n    \tdp[0] = 1; long long ret = dp[0];\n    \tfor (int i = 1; i <= H; i++) {\n    \t\tif (i == H) dp[i] = (ret*fact[N]) % mod;\n    \t\telse dp[i] = (ret * s) % mod;\n    \t\tret += dp[i]; ret %= mod;\n    \t\tif (i >= D) { ret -= dp[i - D]; ret += mod; ret %= mod; }\n    \t}\n    \tcout << dp[H] << endl;\n    \treturn 0;\n    }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 1000010\n#define ll long long\n#define mod 1000000007\nusing namespace std;\nint f[maxn], suf[maxn], fac[maxn], inv[maxn];\nint calc(int a, int k)\n{\n\tint ans = 1;\n\twhile (k)\n\t{\n\t\tif (k % 2) ans = (ll)ans * a % mod;\n\t\ta = (ll)a *a % mod;\n\t\tk /= 2;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tint n, h, d;\n\tcin >> n >> h >> d;\n\tfac[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfac[i] = (ll)fac[i - 1] * i % mod;\n\tsuf[h] = f[h] = fac[n - 1];\n\tfor (int i = 0; i <= n; i++)\n\t\tinv[i] = calc(fac[i], mod - 2);\n\tint tmp = fac[n];\n\tfor (int i = 1; i <= n - 1; i++)\n\t\ttmp = (tmp + fac[i]) % mod;\n\tfor (int i = h - 1; i >= 1; i--)\n\t{\n\t\tf[i] = ((ll)suf[i + 1] - suf[min(i + d + 1, h)] + mod) % mod * tmp % mod;\n\t\tif (i + d >= h) f[i] = (f[i] + (ll)f[h] * tmp % mod) % mod;\n\t\tsuf[i] = (suf[i + 1] + f[i]) % mod;\n\t}\n\tint res = 0;\n\tfor (int i = 1; i <= d; i++)\n\t\tres = (res + (ll)n * f[i] % mod) % mod;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define REP(i, n) FOR(i, 0, (n))\n#define FOR(i, a, b) for(int i=(a); i<(b); i++)\n#define LAR(a, b) ((a)=max((a),(b)))\n#define SML(a, b) ((a)=min((a),(b)))\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pair<int, int>> vpii;\ntypedef pair<int, int> pii;\n#define PB push_back\n#define EB emplace_back\n#ifdef LOCAL_DEBUG\n#define DEBUG(...) printf(__VA_ARGS__)\n#else\n#define DEBUG(...)\n#endif\n\nll n, g[6];\n\ninline ll op(ll n){\n\tDEBUG(\"%d %d\\n\", g[0]>=g[3], g[1]>=g[4]);\n\tll ret = 0;\n\tfor(ll i=0; i*g[0]<=n; i++){\n\t\tll m = n-i*g[0];\n\t\tfor(ll j=0; j*g[1]<=m; j++){\n\t\t\tll o = m-j*g[1];\n\t\t\tll k = 0, p = o;\n\t\t\tif(g[2] < g[5]){\n\t\t\t\tk = o/g[2];\n\t\t\t\tp = o-k*g[2];\n\t\t\t}\n\t\t\tLAR(ret,\n\t\t\t\t\tp + i*g[3] + j*g[4] + k*g[5]);\n\t\t\tif(g[1]>=g[4]) break;\n\t\t}\n\t\tif(g[0]>=g[3]) break;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%lld\", &n);\n\tREP(i, 6) scanf(\"%lld\", g+i);\n\tn = op(n);\n\tREP(i, 3) swap(g[i], g[i+3]);\n\tif(g[2] >= g[5]){\n\t\tswap(g[0], g[2]);\n\t\tswap(g[3], g[5]);\n\t}\n\tn = op(n);\n\tprintf(\"%lld\\n\", n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong N,H,D,mod=1e9+7;\n#include<vector>\n#include<functional>\ntemplate<typename T>\nstruct lazysegtree{\n\tint n;\n\tT defvalue,lazydefvalue;\n\tvector<T>dat,lazy;\n\tlazysegtree(int n_=0,T defvalue_=0,T lazydefvalue_=0):defvalue(defvalue_),lazydefvalue(lazydefvalue_)\n\t{\n\t\tn=1;\n\t\twhile(n<n_)n<<=1;\n\t\tdat.assign(2*n-1,defvalue);\n\t\tlazy.assign(2*n-1,lazydefvalue);\n\t}\n\tvoid copy(const vector<T>&v)\n\t{\n\t\tfor(int i=0;i<v.size();i++)dat[i+n-1]=v[i];\n\t\tfor(int i=n-2;i>=0;i--)dat[i]=calcfn(dat[2*i+1],dat[2*i+2]);\n\t}\n\tvoid eval(int i,int l,int r)\n\t{\n\t\tif(lazy[i])\n\t\t{\n\t\t\tdat[i]=(dat[i]+lazy[i]*(r-l))%mod;\n\t\t\tif(r-l>1)\n\t\t\t{\n\t\t\t\tlazy[2*i+1]=(lazy[2*i+1]+lazy[i])%mod;\n\t\t\t\tlazy[2*i+2]=(lazy[2*i+2]+lazy[i])%mod;\n\t\t\t}\n\t\t\tlazy[i]=lazydefvalue;\n\t\t}\n\t}\n\tvoid update(int a,int b,T x,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\tif(b<=l||r<=a)return;\n\t\telse if(a<=l&&r<=b)\n\t\t{\n\t\t\tlazy[k]=(lazy[k]+x)%mod;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(a,b,x,2*k+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,2*k+2,(l+r)/2,r);\n\t\t\tdat[k]=(dat[2*k+1]+dat[2*k+2])%mod;\n\t\t}\n\t}\n\tT query(int a,int b,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return defvalue;\n\t\telse if(a<=l&&r<=b)return dat[k];\n\t\telse return (query(a,b,2*k+1,l,(l+r)/2)+query(a,b,2*k+2,(l+r)/2,r))%mod;\n\t}\n};\nmain()\n{\n\tcin>>N>>H>>D;\n\tlazysegtree<long>P(H);\n\tlong s=0,p=1;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tp=p*i%mod;\n\t\ts=(s+p)%mod;\n\t}\n\tP.update(0,D,p);\n\tfor(int i=0;i<H;i++)\n\t{\n\t\tP.update(i+1,i+D+1,P.query(i,i+1)*s%mod);\n\t}\n\tcout<<P.query(H-1,H)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<list>\n#include<set>\n#include<string>\nusing namespace std;\nint gcd(int a, int b) {\n\tint c = a % b;\n\twhile (c != 0) {\n\t\ta = b;\n\t\tb = c;\n\t\tc = a % b;\n\t}\n\treturn b;\n}\nstruct UnionFind {\n\tvector<int> par; // par[i]:iの親の番号　(例) par[3] = 2 : 3の親が2\n\n\tUnionFind(int N) : par(N) { //最初は全てが根であるとして初期化\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n\n\tint root(int x) { // データxが属する木の根を再帰で得る：root(x) = {xの木の根}\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\n\tvoid unite(int x, int y) { // xとyの木を併合\n\t\tint rx = root(x); //xの根をrx\n\t\tint ry = root(y); //yの根をry\n\t\tif (rx == ry) return; //xとyの根が同じ(=同じ木にある)時はそのまま\n\t\tpar[rx] = ry; //xとyの根が同じでない(=同じ木にない)時：xの根rxをyの根ryにつける\n\t}\n\n\tbool same(int x, int y) { // 2つのデータx, yが属する木が同じならtrueを返す\n\t\tint rx = root(x);\n\t\tint ry = root(y);\n\t\treturn rx == ry;\n\t}\n};\ntypedef long long ll;\n\nll M = 1000000007;\n\nvector<ll> fac(300001); //n!(mod M)\nvector<ll> ifac(300001); //k!^{M-2} (mod M)\n\nll mpow(ll x, ll n) {\n\tll ans = 1;\n\twhile (n != 0) {\n\t\tif (n & 1) ans = ans * x % M;\n\t\tx = x * x % M;\n\t\tn = n >> 1;\n\t}\n\treturn ans;\n}\nll comb(ll a, ll b) {\n\tif (a == 0 && b == 0)return 1;\n\tif (a < b || a < 0)return 0;\n\tll tmp = ifac[a - b] * ifac[b] % M;\n\treturn tmp * fac[a] % M;\n}\n// mod. m での a の逆元 a^{-1} を計算する\nlong long modinv(long long a) {\n\tlong long b = M, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= M;\n\tif (u < 0) u += M;\n\treturn u;\n}\nvector<vector<ll>> mul(vector<vector<ll>> a,vector<vector<ll>> b,int n){\n\tint i,j,k,t;\n\tvector<vector<ll>> c(n);\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tt = 0;\n\t\t\tfor (k = 0; k < n; k++)\n\t\t\t\tt = (t + a[i][k]*b[k][j] % M)%M;\n\t\t\tc[i].push_back(t);\n\t\t}\n\t}\n\treturn c;\n}\nint main() {\n\tll n, h, d, dp[1111111], sum[1111111], p = 1,k=0, i,ans=0;\n\tcin >> n >> h >> d;\n\tfor (i = 1; i <= n; i++) {\n\t\tp = p * i%M;\n\t\tk = (k + p) % M;\n\t}\n\tdp[0] = p;\n\tsum[0] = p;\n\tfor (i = 1; i < h; i++) {\n\t\tif (i - d <= 0)\n\t\t\tdp[i] = sum[i - 1] * k%M;\n\t\telse\n\t\t\tdp[i] = (M + sum[i - 1] - sum[i - d - 1])%M*k%M;\n\t\tsum[i] = (sum[i - 1] + dp[i]) % M;\n\t}\n\tif (h == d)\n\t\tans = sum[h - 1];\n\telse\n\t\tans = (M + sum[h - 1] - sum[h - d - 1]) % M;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}T get(int i){return S[i+B];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpii factor(int N){vpii r;for(int i=2;i*i<=N;++i){if(N%i==0){r<<pii{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pii{N,1};}return r;}\nvl divisors(ll n){vl r;ll m=sqrt(n);foor(i,1,m)if(n%i==0)r<<ll(i);rf(i,r.size()-(m*m==n))r<<n/r[i];return r;}\nvi SuffixArray(str S){int N=S.size();vi rank(N+1),tmp(N+1),sa(N+1);fr(i,N){sa[i]=i;rank[i]=S[i];}sa[N]=N;rank[N]=-1;int k;auto cmp=[&](int&a,int&b)->bool{if(rank[a]!=rank[b])return rank[a]<rank[b];return (a+k<=N?rank[a+k]:-1)<(b+k<=N?rank[b+k]:-1);};for(k=1;k<=N;k*=2){sort(all(sa),cmp);tmp[sa[0]]=0;foor(i,1,N){tmp[sa[i]]=tmp[sa[i-1]]+cmp(sa[i-1],sa[i]);}rank=tmp;}return sa;};\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,H,D;cin>>N>>H>>D;\n\tvl d(H+1),s(H+2);\n\tll F=0,f=1;\n\tfoor(i,1,N){\n\t\t(F+=(f*=i)%=MD)%=MD;\n\t}\n\ts[1]=d[0]=f;\n\tfoor(i,1,H){\n\t\td[i]=(i==H?:F)*(s[i]-s[max(i-D,0)]+MD)%MD;\n\t\ts[i+1]=(s[i]+d[i])%MD;\n\t}\n\tprint(d[H]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n \nusing namespace std;\n \n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n \n \ntypedef long long ll;\n#define int ll\n \n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { -1,0, 1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// #define mp make_pair\n//#define endl '\\n'\n\nll mod_pow(ll x, ll p, ll M = MOD) {\n  ll a = 1;\n  while (p) {\n    if (p % 2)\n      a = a*x%M;\n    x = x*x%M;\n    p /= 2;\n  }\n  return a;\n}\n\nll mod_inverse(ll a, ll M = MOD) {\n  return mod_pow(a, M - 2, M);\n}\n\n\nsigned main() {\n  fio();\n  int n, h, d;\n  cin >> n >> h >> d;\n  vl fact(n + 1);\n  fact[0] = 1;\n  rep1 (i, n) {\n    fact[i] = fact[i - 1] * i % MOD;\n  }\n  ll f = 0;\n  rep1 (i, n) f = (f + fact[i]) % MOD;\n\n  vl dp(h + 1);\n  dp[0] = fact[n] * mod_inverse(f) % MOD;\n  queue<ll> qu;\n  qu.push(dp[0]);\n  ll sum = dp[0];\n  for (int i = 1; i <= h; i++) {\n    (dp[i] += sum * f) %= MOD;\n    (sum += dp[i]) %= MOD;\n    qu.push(dp[i]);\n    if (qu.size() > d) {\n      (sum -= qu.front()) %= MOD;\n      qu.pop();\n    }\n  }\n  cout << (dp[h] + MOD) % MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace mint {\n  int md = 1e9 + 7;\n  inline void add (int &a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    a += b; if (a >= md) a -= md;\n  }\n  inline void sub (int &a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    a -= b; if (a < 0) a += md;\n  }\n  inline int sum (int a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    add(a, b); return a;\n  }\n  inline int dif (int a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    sub(a, b); return a;\n  }\n  template<class... A>\n  inline int prod (A... args) {\n    long long ret = 1;\n    for (int a :\tinitializer_list<int>{args...}) {\n      assert(0 <= a && a < md);\n      ret *= a;\n      ret %= md;\n    }\n    return (int)(ret % md);\n  }\n  inline void mul (int &a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    a = prod(a, b);\n  }\n  inline int inv (int a) {\n    assert(0 <= a && a < md);\n    a %= md;\n    if(a < 0) a += md;\n    int b = md, u = 0, v = 1;\n    while (a) {\n      int t = b / a;\n      b -= a * t; swap(a, b);\n      u -= v * t; swap(u, v);\n    }\n    assert(b == 1);\n    if(u < 0) u += md;\n    return u;\n  }\n  inline int quot (int a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    return prod(a, inv(b));\n  }\n  inline void div (int& a, int b) {\n    assert(0 <= a && a < md && 0 <= b && b < md);\n    a = quot(a, b);\n  }\n  inline int pow (int a, long long b) {\n    assert(0 <= a && a < md);\n    int res = 1;\n    for (; b; b >>= 1) {\n      if (b & 1) mul(res, a);\n      mul(a, a);\n    }\n    return res;\n  }\n  namespace factorials {\n    int sz;\n    vector<int> fact, finv;\n    void init (int n) {\n      sz = n;\n      fact.resize(n); finv.resize(n);\n      fact[0] = 1;\n      for (int i = 1; i < n; i++) fact[i] = prod(fact[i - 1], i);\n      finv[n - 1] = inv(fact[n - 1]);\n      for (int i = n - 2; i >= 0; i--) finv[i] = prod(finv[i + 1], i + 1);\n    }\n  }\n  inline int fct (int i) {\n    using namespace factorials;\n    assert(0 <= i && i < sz);\n    return fact[i];\n  }\n  inline int fnv (int i) {\n    using namespace factorials;\n    assert(0 <= i && i < sz);\n    return finv[i];\n  }\n  inline int binom (int n, int k) {\n    using namespace factorials;\n    assert(0 <= n && n < sz);\n    if (0 < k || n < k) return 0;\n    return prod(fact[n], finv[k], finv[n - k]);\n  }\n}\ntemplate <typename T>\nclass binary_indexed_tree {\n    size_t sz;\n    vector<T> tr;\n    function<T(T, T)> sum;\n    function<T(T, T)> dif;\n    T id;\n  public:\n    binary_indexed_tree (\n        size_t n,\n        function<T(T, T) > sum,\n        function<T(T, T) > dif,\n        T id\n      ) :\n      sz(n), tr(n, id),\n      sum(sum), dif(dif), id(id)\n      {}\n    auto query (size_t l, size_t r) const -> T {\n      assert(0 <= l && l <= r && r <= sz);\n      if (l == 0) {\n        int k = (int)r;\n        k--;\n        T ret = 0;\n        for (; k >= 0; k &= k + 1, k--) ret = sum(ret, tr[k]);\n        return ret;\n      }\n      else\n        return dif(query(0, r), query(0, l));\n    }\n    auto operator[] (size_t i) const -> T {\n      assert(0 <= i && i < sz);\n      return query(i, i + 1);\n    }\n    auto at (size_t i) const -> T {\n      return operator[](i);\n    }\n    void add (size_t i, T x) {\n      for (; i < sz; i |= i + 1) tr[i] = sum(tr[i], x);\n    }\n    void print() {\n      cout << \"bit: \";\n      for (int i = 0; i < sz; i++) {\n        if (i) cout << \" \";\n        cout << operator[](i);\n      }\n      cout << endl;\n    }\n};\nint main() {\n  cin.tie(0); cin.sync_with_stdio(false);\n  int n, h, d;\n  cin >> n >> h >> d;\n  mint::factorials::init(n + 1);\n  int B = 0;\n  for (int i = 1; i <= n; i++) {\n    mint::add(B, mint::fct(i));\n  }\n  binary_indexed_tree<int> bit(\n    h,\n    mint::sum,\n    mint::dif,\n    0\n  );\n  bit.add(0, 1);\n  for (int i = 1; i < h; i++) {\n    bit.add(i, mint::prod(\n      bit.query(max(0, i - d), i),\n      B\n    ));\n  }\n  int ret = mint::prod(\n    bit.query(h - d, h),\n    mint::fct(n)\n  );\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n\nlong long dp[1000005];\n\nconst long long MOD = 1e9+7;\n\nint main(){\n    int N, H, D;\n    scanf(\"%d%d%d\", &N, &H, &D);\n\n    long long retainWays = 0;\n    long long fact = 1;\n    for(int i = 1; i <= N; i ++){\n        fact = fact*i%MOD;\n        retainWays += fact;\n    }\n    retainWays %= MOD;\n\n    //printf(\"retainWays=%lld\\n\", retainWays);\n\n    dp[0] = fact;\n    long long slidingWindowSum = dp[0];\n    for(int i = 1; i <= H; i ++){\n        dp[i] = slidingWindowSum;\n\n        if(i == H){break;}\n\n        dp[i] = dp[i]*retainWays%MOD;\n        slidingWindowSum += dp[i];\n        if(i >= D){slidingWindowSum -= dp[i-D];}\n\n        if(slidingWindowSum >= MOD){slidingWindowSum -= MOD;}\n        else if(slidingWindowSum < 0){slidingWindowSum += MOD;}\n\n        //printf(\"dp[%d]=%lld\\n\", i, dp[i]);\n    }\n\n    printf(\"%lld\", dp[H]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <cmath>\n#include <typeinfo>\n#include <numeric>\n#include <cassert>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\ntemplate <typename S, typename T>\nT get_m(M<S, T> &m, S k, S default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename S, typename T>\nvoid _debug_print(const M<S, T> &xlist)\n{\n    for (auto x : xlist) {\n        S k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\nint _main();\nint main()\n{\n    cout << setprecision(12);\n    return _main();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define MOD   (ll)(1e9+7LL)\n\nint _main()\n{\n    ll n; llin(n);\n    ll h; llin(h);\n    ll d; llin(d);\n\n    static ll perms[1000005];\n    static ll acum_perms[1000005];\n    perms[0] = perms[1] = 1LL;\n    acum_perms[0] = acum_perms[1] = 1LL;\n    srep (i, 2, 1000005) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= MOD;\n        acum_perms[i] = acum_perms[i-1] + perms[i];\n        acum_perms[i] %= MOD;\n    }\n    rep (i, 7) debug_printf(\"perms[%lld]=%lld acum_perms[%lld]=%lld\\n\",\n                            i, perms[i], i, acum_perms[i]);\n\n    static ll dp[1000005];\n    dp[0] = perms[n];\n    ll prev_total = dp[0];\n    srep (i, 1, h) {\n        dp[i] = prev_total * acum_perms[n];\n        dp[i] %= MOD;\n        prev_total += dp[i];\n        prev_total %= MOD;\n        if (i >= d) {\n            prev_total -= dp[i-d];\n            while (prev_total < 0LL) prev_total += MOD;\n        }\n    }\n\n    ll ans = 0LL;\n    srep (i, h-d, h) {\n        ans += dp[i];\n        ans %= MOD;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\nusing namespace std;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 30000000000000LL\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define REP(i,n) for(long long i = 0;i < n;++i)    \n#define seg_size 524288\nlong long powering(long long now, long long now_go) {\n\tlong long ans = 1;\n\twhile (now_go != 0) {\n\t\tif (now_go % 2 == 1) {\n\t\t\tans *= now;\n\t\t\tans %= MAX_MOD;\n\t\t}\n\t\tnow *= now;\n\t\tnow %= MAX_MOD;\n\t\tnow_go /= 2;\n\t}\n\treturn ans;\n}\nvector<long long> calc(vector<long long> a, vector<long long> b) {\n\tlong long k = sqrt(a.size());\n\tvector<long long> ans;\n\tfor (int i = 0; i < k; ++i) {\n\t\tfor (int q = 0; q < k; ++q) {\n\t\t\tlong long geko = 0;\n\t\t\tfor (int t = 0; t < k; ++t) {\n\t\t\t\tgeko += a[i * k + t] * b[t * k + q];\n\t\t\t\tgeko %= MAX_MOD;\n\t\t\t}\n\t\t\tans.push_back(geko);\n\t\t}\n\t}\n\treturn ans;\n}\nvector<long long> powered(vector<long long> a, long long n) {\n\tvector<long long> ans = a;\n\tn--;\n\twhile (n != 0) {\n\t\tif (n % 2 == 1) {\n\t\t\tans = calc(ans, a);\n\t\t}\n\t\ta = calc(a, a);\n\t\tn /= 2;\n\t}\n\treturn ans;\n}\nlong long inv(long long now) {\n\treturn powering(now, MAX_MOD - 2LL);\n}\nlong long dp[2000000] = {};\nlong long ans[2000000] = {};\nint main(){\n#define int long long\n\tint n,h,d;\n\tcin >> n >> h >> d;\n\tlong long geko = 1;\n\tfor (long long i = 1; i <= n; ++i) {\n\t\tdp[i] = dp[i - 1];\n\t\tdp[i] += geko;\n\t\tdp[i] %= MAX_MOD;\n\t\tgeko *= (long long)(i + 1LL);\n\t\tgeko %= MAX_MOD;\n\t}\n\tans[0] = geko;\n\tans[0] *= inv(n + 1);\n\tans[0] %= MAX_MOD;\n\tlong long tea = ans[0];\n\tfor (long long i = 1; i < h; ++i) {\n\t\tlong long geko = tea;\n\t\tgeko *= dp[n];\n\t\tgeko %= MAX_MOD;\n\t\tans[i] = geko;\n\t\ttea += ans[i];\n\t\ttea %= MAX_MOD;\n\t\tif (i - d >= 0) {\n\t\t\ttea -= ans[i - d];\n\t\t\ttea += MAX_MOD;\n\t\t\ttea %= MAX_MOD;\n\t\t}\n\t}\n\tlong long final_ans = 0;\n\tfor (int i = max(h - d, 0LL); i < h; ++i) {\n\t\tfinal_ans += ans[i];\n\t\tfinal_ans %= MAX_MOD;\n\t}\n\tcout << final_ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\n\nV<mint> fact,ifact;\nmint Choose(int a,int b){\n\tif(b<0 || a<b) return 0;\n\treturn fact[a] * ifact[b] * ifact[a-b];\n}\nvoid InitFact(int N){\n\tfact.resize(N);\n\tifact.resize(N);\n\tfact[0] = 1;\n\trep1(i,N-1) fact[i] = fact[i-1] * i;\n\tifact[N-1] = fact[N-1].inv();\n\tfor(int i=N-2;i>=0;i--) ifact[i] = ifact[i+1] * (i+1);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\n\tInitFact(2 * TEN(6));\n\n\tint N,H,D;\n\tcin >> N >> H >> D;\n\tV<mint> dp(H+1);\n\tmint F = 0;\n\trep1(i,N) F += fact[i];\n\tdp[0] = fact[N];\n\tmint sum = dp[0];\n\trep1(n,H){\n\t\tdp[n] = sum * F;\n\t\tsum += dp[n];\n\t\tif(n >= D) sum -= dp[n-D];\n\t}\n\tcout << dp[H]/F << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\ntemplate<uint_fast64_t Modulus = MOD>\nstruct Modint {\n  using u64 = uint_fast64_t;\n  u64 a;\n\n  constexpr Modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n\n  constexpr Modint operator+(const Modint rhs) const noexcept {\n    return Modint(*this) += rhs;\n  }\n  constexpr Modint operator-(const Modint rhs) const noexcept {\n    return Modint(*this) -= rhs;\n  }\n  constexpr Modint operator*(const Modint rhs) const noexcept {\n    return Modint(*this) *= rhs;\n  }\n  constexpr Modint operator/(const Modint rhs) const noexcept {\n    return Modint(*this) /= rhs;\n  }\n\n  constexpr Modint &operator+=(const Modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) a -= Modulus;\n    return *this;\n  }\n  constexpr Modint &operator-=(const Modint rhs) noexcept {\n    if (a < rhs.a) a += Modulus;\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr Modint &operator*=(const Modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr Modint &operator/=(Modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp & 1) *this *= rhs;\n      rhs *= rhs;\n      exp >>= 1;\n    }\n    return *this;\n  }\n\n  explicit operator bool() const {\n    return a;\n  }\n\n  friend ostream &operator<<(ostream &os, const Modint &m) {\n    return os << m.a;\n  }\n};\n\nusing mint = Modint<>;\n\nvoid solve() {\n  int n, h, d; cin >> n >> h >> d;\n\n  mint calc = 0;\n  mint fac = 1;\n\n  rep1eq(i,n) calc += fac *= i;\n\n  vector<mint> dp(h+1);\n  dp[0] = 0;\n  dp[1] = fac;\n\n  rep1(i,h) {\n    int j = max(0, i - d);\n    dp[i+1] = dp[i] + (dp[i] - dp[j]) * calc;\n  }\n\n  cout << dp[h] - dp[h - d] << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\ntemplate<typename T>vector<T> & cset(vector<T> &A,T e=T()){for(auto &I:A){I=e;} return A;}\n\n\n//BEGIN CUT HERE\ntemplate <typename T,typename E>\nstruct SegmentTree{\n    using F = function<T(T,T)>;\n    using G = function<T(T,E)>;\n    using H = function<E(E,E)>;\n    int n,height;\n    F f;\n    G g;\n    H h;\n    T ti;\n    E ei;\n    vector<T> dat;\n    vector<E> laz;\n    SegmentTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei){}\n    \n    void init(int n_){\n        n=1;height=0;\n        while(n<n_) n<<=1,height++;\n        dat.assign(2*n,ti);\n        laz.assign(2*n,ei);\n    }\n    void build(const vector<T> &v){\n        int n_=v.size();\n        init(n_);\n        for(int i=0;i<n_;i++) dat[n+i]=v[i];\n        for(int i=n-1;i;i--)\n            dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n    }\n    inline T reflect(int k){\n        return laz[k]==ei?dat[k]:g(dat[k],laz[k]);\n    }\n    inline void eval(int k){\n        if(laz[k]==ei) return;\n        laz[(k<<1)|0]=h(laz[(k<<1)|0],laz[k]);\n        laz[(k<<1)|1]=h(laz[(k<<1)|1],laz[k]);\n        dat[k]=reflect(k);\n        laz[k]=ei;\n    }\n    inline void thrust(int k){\n        for(int i=height;i;i--) eval(k>>i);\n    }\n    inline void recalc(int k){\n        while(k>>=1)\n            dat[k]=f(reflect((k<<1)|0),reflect((k<<1)|1));\n    }\n    void update(int a,int b,E x){\n        thrust(a+=n);\n        thrust(b+=n-1);\n        for(int l=a,r=b+1;l<r;l>>=1,r>>=1){\n            if(l&1) laz[l]=h(laz[l],x),l++;\n            if(r&1) --r,laz[r]=h(laz[r],x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n    void set_val(int a,T x){\n        thrust(a+=n);\n        dat[a]=x;laz[a]=ei;\n        recalc(a);\n    }\n    T query(int a,int b){\n        thrust(a+=n);\n        thrust(b+=n-1);\n        T vl=ti,vr=ti;\n        for(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n            if(l&1) vl=f(vl,reflect(l++));\n            if(r&1) vr=f(reflect(--r),vr);\n        }\n        return f(vl,vr);\n    }\n};\n//END CUT HERE\nusing Int = long long;\n\n\nint main(){\n    using P = pair<Int, Int>;\n    auto F=[](P a,P b){return P((a.first+b.first)%MOD,a.second+b.second);};\n    auto G=[](P a,Int b){return P((a.first+b*a.second%MOD)%MOD,a.second);};\n    auto H=[](Int a,Int b){return (a+b)%MOD;};\n    ll n,h,d;\n    cin>>n>>h>>d;\n    SegmentTree<P,Int> T(F,G,H,P(0,0),0);\n    T.build(vector<P>(h+10,P(0,1)));\n    vector<ll> Fct(n+1,1);\n    for(ll i=1;i<=n;i++){Fct[i]=Fct[i-1]*i%MOD;}\n    ll sum=0;\n    for(ll i=1;i<=n;i++){sum+=Fct[i]; sum%=MOD;}\n    T.update(0,1,Fct[n]);\n    for(ll i=1;i<=h;i++){\n        ll a=T.query(max(0LL,i-d),i).F; a%=MOD;\n        a*=sum; a%=MOD;\n        T.update(i,i+1,a);\n    }\n    ll ans=0;\n    for(ll i=1;i<=d && h-i>=0;i++){\n        ans+=T.query(h-i,h-i+1).F;\n        ans%=MOD;\n    }\n    if(ans<0){ans+=MOD;}\n    cout<<ans<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+5,mod=1e9+7;\ntypedef long long ll;\nll f[N],sumf[N],dp[N],sumdp[N];\nll inv(ll x){return x==1?x:(mod-mod/x)*inv(mod%x)%mod;}\nint n,h,d;\nint main()\n{\n    f[0]=1;\n    for(int i=1;i<N;i++) f[i]=f[i-1]*i%mod,sumf[i]=(sumf[i-1]+f[i])%mod;\n    scanf(\"%d%d%d\",&n,&h,&d);\n    dp[0]=1;sumdp[0]=1;\n    for(int i=1;i<=h;i++)\n    {\n        if(i-d-1>=0)\n        dp[i]=(sumdp[i-1]-sumdp[i-d-1])*sumf[n]%mod;\n    else dp[i]=sumdp[i-1]*sumf[n]%mod;\n        sumdp[i]=(sumdp[i-1]+dp[i])%mod;\n    }\n    ll ans=dp[h]*f[n]%mod*inv(sumf[n])%mod;\n    ans=(ans+mod)%mod;\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=100010;\nconst ll P=1000000007;\nint n,m,D;\nll ans,n1;\nll f[maxn],s[maxn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&D);\n\tint i;\n\tll tmp=1;\n\tf[0]=s[0]=1;\n\tfor(i=1;i<=n;i++) tmp=tmp*i%P,n1=(n1+tmp)%P;\n\tfor(i=1;i<m;i++)\n\t{\n\t\tf[i]=s[i-1]-((i<=D)?0:s[i-D-1])+P;\n\t\tf[i]=f[i]*n1%P;\n\t\ts[i]=(s[i-1]+f[i])%P;\n\t}\n\tprintf(\"%lld\\n\",(s[m-1]-s[m-D-1]+P)*tmp%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pll;\ntypedef vector<bool> vb;\nconst ll oo = 0x3f3f3f3f3f3f3f3f;\nconst double eps = 1e-9;\n#define sz(c) ll((c).size())\n#define all(c) begin(c), end(c)\n#define FOR(i,a,b) for (ll i = (a); i < (b); i++)\n#define FORD(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define xx first\n#define yy second\n#define TR(X) ({ if(1) cerr << \"TR: \" << (#X) << \" = \" << (X) << endl; })\n\nconst ll MOD = 1e9 + 7;\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\tll n, d, h;\n\tcin >> n >> h >> d;\n\t\n\tll sumfac = 0, fac = 1;\n\tFOR(k,1,n+1) {\n\t\tfac = fac*k % MOD;\n\t\tsumfac = (sumfac + fac) % MOD;\n\t}\n\t\n\tvl dp(h+1);\n\tll sum = dp[h] = 1;\n\tFORD(k,0,h) {\n\t\tdp[k] = (k > 0 ? sumfac : fac) * sum % MOD;\n\t\tsum += dp[k];\n\t\tif (k+d <= h) sum -= dp[k+d];\n\t\tsum %= MOD;\n\t\tif (sum < 0) sum += MOD;\n\t}\n\tcout << dp[0] << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nint dp[1000005];\n\nconst long long MOD = 1e9+7;\n\nint main(){\n    int N, H, D;\n    scanf(\"%d%d%d\", &N, &H, &D);\n\n    long long retainWays = 0;\n    long long fact = 1;\n    for(int i = 1; i <= N; i ++){\n        fact = fact*i%MOD;\n        retainWays += fact;\n    }\n    retainWays %= MOD;\n\n    //printf(\"retainWays=%lld\\n\", retainWays);\n\n    dp[0] = fact;\n    long long slidingWindowSum = dp[0];\n    for(int i = 1; i < H; i ++){\n        dp[i] = slidingWindowSum*retainWays%MOD;\n\n        slidingWindowSum += dp[i];\n        if(i >= D){slidingWindowSum -= dp[i-D];}\n\n        if(slidingWindowSum >= MOD){slidingWindowSum -= MOD;}\n        else if(slidingWindowSum < 0){slidingWindowSum += MOD;}\n\n        //printf(\"dp[%d]=%lld\\n\", i, dp[i]);\n    }\n\n    printf(\"%lld\", slidingWindowSum);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e6 + 10,mod = 1e9 + 7;\n\nint dp[N],fac[N],S[N];\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\nint main() {\n\n\tint n = read(),h = read(),d = read(),sum = 0;\n\tfac[0] = 1;\n\tFor(i,1,n) fac[i] = 1ll * fac[i - 1] * i % mod,sum = (sum + fac[i]) % mod;\n\tdp[0] = 1,S[0] = 1;\n\tFor(i,1,h - 1) {\n\t\tdp[i] = 1ll * (S[i - 1] - (i - d - 1 < 0 ? 0 : S[i - d - 1]) + mod) * sum % mod;\n\t\tS[i] = (S[i - 1] + dp[i]) % mod;\n\t}\n\tint ans = 0;\n\tFor(i,h - d,h - 1) ans = (ans + dp[i]) % mod;\n\tprintf(\"%lld\\n\",1ll * ans * fac[n] % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// queue を考えて, 同じ数字は入れるときに順番を決めて, 出てきた順に値を更新する\n#define mod 1000000007\n#define MAX_N 1000001 // = MAX_H\nll fact[MAX_N]; // iの階乗\nll fact_sum[MAX_N]; // i>0での累積和\n\n// 最大値がi個の時の場合の数\nll dp[MAX_N];\n\nint main() {\n    int N, H, D;\n    cin >> N >> H >> D;\n\n    // 階乗計算\n    fact[0]=1;\n    for(int i = 1; i < MAX_N; ++i) {\n        fact[i] = fact[i-1] * i % mod;\n        fact_sum[i] = (fact_sum[i-1] + fact[i]) % mod;\n    }\n\n    dp[0] = fact[N]; // 0をN個queueに入れる\n    ll sum = 0; // Dの幅でしゃくとり\n    for (int i = 1; i <= H; ++i) {\n        sum += dp[i-1]; // dp[i-D] から dp[i-1] まで\n        if(i > D) sum -= dp[i-D-1];\n        sum %= mod;\n        dp[i] = sum * fact_sum[N] % mod; // i個の塔の個数が1からNまで\n    }\n    cout << sum;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\nll ppow(ll a,ll b){\n\ta%=MOD;\n\tll res=1;\n\twhile(b){\n\t\tif(b&1)res=(res*a)%MOD;\n\t\ta=(a*a)%MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nclass Fact{\n\tvector<ll>fact;\n\tvector<ll>inv;\npublic:\n\tFact(){}\n\tFact(int n){\n\t\tn=n*2+10;\n\t\tfact=inv=vector<ll>(n);\n\t\tfact[0]=inv[0]=1;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=(fact[i-1]*i)%MOD;\n\t\t\tinv[i]=ppow(fact[i],MOD-2);\n\t\t}\n\t}\n\tll get(int n){\n\t\treturn fact[n];\n\t}\n\tll nPr(int n,int r){\n\t\treturn fact[n]*inv[n-r]%MOD;\n\t}\n\tll nCr(int n,int r){\n\t\treturn nPr(n,r)*inv[r]%MOD;\n\t}\n\tll nrP(int n,int r){\n\t\treturn nPr(n+r,n);\n\t}\n\tll nrC(int n,int r){\n\t\treturn nCr(n+r,n);\n\t}\n};\nll dp[2000000];\nint main(){\n\tFact fac(1e6);\n\tint n,h,d;cin>>n>>h>>d;\n\tll x=0;\n\tfor(int i=1;i<=n;i++)(x+=fac.get(i))%=MOD;\n\tdp[0]=1;\n\tll sum=1;\n\tfor(int i=1;i<=h;i++){\n\t\tdp[i]=sum*x%MOD;\n\t\t(sum+=dp[i])%=MOD;\n\t\tif(i-d>=0)(sum+=MOD-dp[i-d])%=MOD;\n\t}\n\tcout<<dp[h]*fac.get(n)%MOD*ppow(x,MOD-2)%MOD<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ft first\n#define sd second\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\n\nstruct modint{\n    ll a;\n    const ll MOD=1e9+7;\n    modint(ll a_=0){\n        a=((a_%MOD)+MOD)%MOD;\n    }\n    modint inv()const{\n        ll n=1,m=MOD-2,A=a;\n        while(m){\n            if(m&1)(n*=A)%=MOD;\n            (A*=A)%=MOD;\n            m>>=1;\n        }\n        modint y(n);\n        return y;\n    }\n    bool operator==(const modint& x){\n        return a==x.a;\n    }\n    bool operator!=(const modint& x){\n        return a!=x.a;\n    }\n    modint& operator=(const modint& x){\n        a=x.a;\n        return *this;\n    }\n    modint operator+(const modint& x){\n        modint y(a+x.a);\n        return y;\n    }\n    modint operator-(const modint& x){\n        modint y(a-x.a);\n        return y;\n    }\n    modint operator*(const modint& x){\n        modint y(a*x.a);\n        return y;\n    }\n    modint operator/(const modint& x){\n        return *this * x.inv();\n    }\n    modint& operator+=(const modint& x){\n        *this=*this+x;\n        return *this;\n    }\n    modint& operator-=(const modint& x){\n        *this=*this-x;\n        return *this;\n    }\n    modint& operator*=(const modint& x){\n        *this=*this*x;\n        return *this;\n    }\n    modint& operator/=(const modint& x){\n        *this=*this/x;\n        return *this;\n    }\n};\nistream& operator>>(istream &in,modint& x){\n    ll a_;\n    in>>a_;\n    modint y(a_);\n    x=y;\n    return in;\n}\nostream& operator<<(ostream &out,const modint& x){\n    out<<x.a;\n    return out;\n}\nmodint pwr(ll a,ll b){\n    modint n(1),A(a);\n    while(b){\n        if(b&1) n*=A;\n        A*=A;\n        b>>=1;\n    }\n    return n;\n}\n\nmodint f(vector<modint>& s,int i,int d){\n    if(i<d) return s[i];\n    else return s[i]-s[i-d];\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n,h,d;\n    cin>>n>>h>>d;\n    modint ans,k,c(1);\n    Fr(i,n){\n        c*=i;\n        k+=c;\n    }\n    vector<modint> s(h+1);\n    s[0]=1;\n    fr(i,h-1){\n        ans=k*f(s,i,d);\n        s[i+1]=s[i]+ans;\n    }\n    cout<<c*f(s,h-1,d)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1000010;\nconst ll P=1000000007;\nint n,m,D;\nll ans,n1;\nll f[maxn],s[maxn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&m,&D);\n\tint i;\n\tll tmp=1;\n\tf[0]=s[0]=1;\n\tfor(i=1;i<=n;i++) tmp=tmp*i%P,n1=(n1+tmp)%P;\n\tfor(i=1;i<m;i++)\n\t{\n\t\tf[i]=s[i-1]-((i<=D)?0:s[i-D-1])+P;\n\t\tf[i]=f[i]*n1%P;\n\t\ts[i]=(s[i-1]+f[i])%P;\n\t}\n\tprintf(\"%lld\\n\",(s[m-1]-s[m-D-1]+P)*tmp%P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n#ifdef DEBUG\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n)\\\n\t{cerr << #a << \" = {\";\\\n\tfor(int qwq = (st); qwq <= (n); ++qwq) {\\\n\t\tif(qwq == (st)) cerr << a[qwq];\\\n\t\telse cerr << \", \" << a[qwq];\\\n\t} cerr << \"}\" << endl;}\n#define displayv(v) displaya(v, 0, (int)(v).size() - 1)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define display(x) ;\n#define displaya(a, st, n) ;\n#define displayv(v) ;\n#define eprintf(...) if(0) fprintf(stderr, \"...\")\n#endif\ntemplate<typename T> bool chmin(T &a, const T &b) { return b < a ? a = b, true : false; }\ntemplate<typename T> bool chmax(T &a, const T &b) { return a < b ? a = b, true : false; }\n\nconst LL P = 1000000007;\nLL f[1000000 + 233], g[1000000 + 233];\n\nint main() {\n\tios::sync_with_stdio(false);\n\tint n, d, h;\n\tcin >> n >> h >> d;\n\tLL fac = 1, sum = 0;\n\tfor(int i = 1; i <= n; ++i) fac = fac * i % P, (sum += fac) %= P;\n\tf[0] = fac;\n\tmemset(g, 0, sizeof(g));\n\tg[0] = f[0];\n\tfor(int i = 1; i < h; ++i) {\n//\t\tfor(int j = max(0, i - d); j < i; ++j)\n//\t\t\tf[i] += f[j];\n\t\tif(i - d <= 0) f[i] = g[i - 1];\n\t\telse f[i] = (g[i - 1] - g[i - d - 1]) % P;\n\t\tf[i] = f[i] % P * sum % P;\n\t\tg[i] = (g[i - 1] + f[i]) % P;\n\t}\n\tLL ans = 0;\n\tfor(int j = max(0, h - d); j < h; ++j) ans += f[j];\n\tcout << (ans % P + P) % P << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long dp[1000005];\n\nconst long long MOD = 1e9+7;\n\nint main(){\n    int N, H, D;\n    scanf(\"%d%d%d\", &N, &H, &D);\n\n    long long retainWays = 0;\n    long long fact = 1;\n    for(int i = 1; i <= N; i ++){\n        fact = fact*i%MOD;\n        retainWays += fact;\n    }\n    retainWays %= MOD;\n\n    //printf(\"retainWays=%lld\\n\", retainWays);\n\n    dp[0] = fact;\n    long long slidingWindowSum = dp[0];\n    for(int i = 1; i <= H; i ++){\n        dp[i] = slidingWindowSum;\n\n        if(i == H){break;}\n\n        dp[i] = dp[i]*retainWays%MOD;\n        slidingWindowSum += dp[i];\n        if(i >= D){slidingWindowSum -= dp[i-D];}\n\n        slidingWindowSum = slidingWindowSum%MOD;\n        if(slidingWindowSum < 0){slidingWindowSum += MOD;}\n\n        //printf(\"dp[%d]=%lld\\n\", i, dp[i]);\n    }\n\n    printf(\"%lld\", dp[H]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n#define M 1000000007\n\ntypedef long long ll;\n\nint n, h, d;\n\nll fa[1222333];\nll fs[1222333];\n\n#define N (1<<20)\nll p[2*N];\n\nvoid addVal(int k, ll x) {\n    k += N;\n    p[k] += x;\n    p[k] %= M;\n    if (p[k] < 0) p[k] += M;\n    for (k /= 2; k >= 1; k /= 2) {\n        p[k] = p[2*k]+p[2*k+1];\n        p[k] %= M;\n    }\n}\n\nll getSum(int a, int b) {\n    a += N; b += N;\n    ll s = 0;\n    while (a <= b) {\n        if (a%2 == 1) s = (s+p[a++])%M;\n        if (b%2 == 0) s = (s+p[b--])%M;\n        a /= 2; b /= 2;\n    }\n    return s;\n}\n\nint main() {\n    cin >> n >> h >> d;\n    fa[0] = 1;\n    fs[0] = 0;\n    for (int i = 1; i <= n; i++) {\n        fa[i] = (fa[i-1]*i)%M;\n        fs[i] = (fs[i-1]+fa[i])%M;\n    }\n    addVal(0,fa[n]);\n    addVal(1,-fa[n]);\n    for (int i = 0; i <= h-1; i++) {\n        ll s1 = getSum(0,i)%M;\n        ll s2 = s1*fs[n]%M;\n        addVal(i+1,s2);\n        addVal(min(h,i+d+1),-s2);\n        if (h-i <= d) {\n            addVal(h,s1);\n            addVal(h+1,-s1);\n        }\n    }\n    cout << getSum(0,h) << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mxn 1000010\n#define LL long long\nusing namespace std;\nconst int mod=1e9+7;\nint n,D,H,sl,fh,dp[mxn];\nLL W,S,fac[mxn];\nint rd()\n{\n\tsl=0;fh=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch) {if(ch=='-') fh=-1; ch=getchar();}\n\twhile('0'<=ch&&ch<='9') sl=sl*10+ch-'0',ch=getchar();\n\treturn sl*fh;\n}\nvoid upd(LL &x,LL y) {x+=y; if(x>=mod) x-=mod;}\nint main()\n{\n\tn=rd();H=rd();D=rd();fac[0]=1;\n\tfor(int i=1;i<=n;++i) fac[i]=i*fac[i-1]%mod,upd(W,fac[i]);\n\tdp[0]=1;S=1;\n\tfor(int i=1;i<=H;++i)\n\t{\n\t\tif(i-D-1>=0) upd(S,mod-dp[i-D-1]);\n\t\tif(i<H) dp[i]=S*W%mod; else dp[i]=S;\n\t\tupd(S,dp[i]);\n\t}\n\tprintf(\"%lld\\n\",dp[H]*fac[n]%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,l,r) for (ll i=l;i<=r;i++)\nusing namespace std;\ntypedef long long ll;\nll a,b,c,ans,N,K,M,H,D,tt,t,dp[1000007],ji[1000007];\nll co=1000000007;\nint main(){\n\tscanf(\"%lld%lld%lld\",&N,&H,&D);\n\tji[0]=1;rep(i,1,N) ji[i]=ji[i-1]*i%co; \n\trep(i,1,N) a=(a+ji[i])%co;\n\tdp[0]=ji[N];ll s=ji[N];\n\trep(i,1,H){\n\t\tif (i>b+D) s=(s-dp[b]+co)%co,b++;\n\t\tif (i<H) dp[i]=a*s%co;\n\t\telse dp[i]=s;\n\t\ts=(s+dp[i])%co;\n\t}\n\tprintf(\"%lld\\n\",dp[H]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include<ext/pb_ds/priority_queue.hpp>\n#define MAXN 1000005\n#define INF 1000000000\n#define MOD 1000000007\n#define F first\n#define S second\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef tree<int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\ntypedef __gnu_pbds::priority_queue<int,greater<int>,pairing_heap_tag> pq;\nint n,h,d;\nint fact[MAXN],sfact[MAXN],dp[MAXN],sum[MAXN];\nvoid add(int &a,int b) {a+=b; if(a>=MOD) a-=MOD;}\nvoid dec(int &a,int b) {a-=b; if(a<0) a+=MOD;}\nint get_sum(int x,int y)\n{\n    if(x<=0) return sum[y];\n    int ret=sum[y];\n    dec(ret,sum[x-1]);\n    return ret;\n}\nint main()\n{\n    fact[0]=1;\n    for(int i=1;i<=1000000;i++) fact[i]=1LL*fact[i-1]*i%MOD;\n    for(int i=1;i<=1000000;i++) {sfact[i]=fact[i]; add(sfact[i],sfact[i-1]);}\n    dp[0]=1;\n    sum[0]=1;\n    scanf(\"%d%d%d\",&n,&h,&d);\n    for(int i=1;i<=h-1;i++)\n    {\n        dp[i]=get_sum(i-d,i-1);\n        dp[i]=1LL*dp[i]*sfact[n]%MOD;\n        sum[i]=sum[i-1]; add(sum[i],dp[i]);\n    }\n    dp[h]=get_sum(h-d,h-1);\n    dp[h]=1LL*dp[h]*fact[n]%MOD;\n    printf(\"%d\\n\",dp[h]);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+10;\nconst int mod=1e9+7;\n\nint qpow(int a,int b) {\n\tint ret=1;\n\twhile(b) {\n\t\tif(b&1) ret=1ll*ret*a%mod;\n\t\ta=1ll*a*a%mod,b>>=1;\n\t}\n\treturn ret;\n}\n\nint n,h,d,fac=1,sfac=1,f[N],s[N];\n\nint main() {\n\tcin>>n>>h>>d;\n\tfor(int i=2;i<=n;i++) fac=1ll*fac*i%mod,sfac=(sfac+fac)%mod;\n\tf[0]=s[0]=1;\n\tfor(int i=1;i<=h;i++) f[i]=1ll*(s[i-1]-(i-d<1?0:s[i-d-1])+mod)*sfac%mod,s[i]=(s[i-1]+f[i])%mod;\n\tcout<<1ll*f[h]*fac%mod*qpow(sfac,mod-2)%mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\n\nint main() {\n    int n, h, d; cin >> n >> h >> d;\n    vector<long long> fact(n+1, 1); long long sum = 0;\n    for (long long i = 0; i < n; i++) {\n        fact[i+1] = fact[i] * (i+1) % mod;\n        sum = (sum + fact[i+1]) % mod;\n    }\n    vector<long long> dp(h+1, 0), dp_sum(h+1, 0);\n    dp[0] = fact[n];\n    for (int i = 1; i <= h; i++) {\n        dp_sum[i] = (dp_sum[i-1] + dp[i-1]) % mod;\n        dp[i] = (dp_sum[i] + (mod - dp_sum[max(0, i-d)])) % mod;\n        if (i != h) dp[i] = dp[i] * sum % mod; \n    }\n    cout << dp[h] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\nusing namespace std;\nconst int N=1e6+7,mod=1e9+7;\nint n,d,h,f[N],fac[N],inv[N],sf[N],s[N<<2];\nint qpow(int a,int b)\n{\n\tint ret=1;\n\twhile(b)\n\t{\n\t\tif(b&1)ret=1ll*ret*a%mod;\n\t\ta=1ll*a*a%mod,b>>=1;\n\t}\n\treturn ret;\n}\nvoid update(int k,int v,int l,int r,int rt)\n{\n\tif(l==r){s[rt]=v;return;}\n\tint mid=l+r>>1;\n\tif(k<=mid)update(k,v,lson);\n\telse update(k,v,rson);\n\ts[rt]=(s[rt<<1]+s[rt<<1|1])%mod;\n}\nint query(int L,int R,int l,int r,int rt)\n{\n\tif(L<=l&&r<=R)return s[rt];\n\tint mid=l+r>>1,ret=0;\n\tif(L<=mid)ret+=query(L,R,lson);\n\tif(R>mid)ret+=query(L,R,rson);\n\treturn ret%mod;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&d);\n\tfac[0]=1;for(int i=1;i<=n;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tfor(int i=1;i<=n;i++)sf[i]=(sf[i-1]+fac[i])%mod;\n\tupdate(0,fac[n],0,h,1);\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tf[i]=query(max(0,i-d),i-1,0,h,1);\n\t\tif(i<h)f[i]=1ll*f[i]*sf[n]%mod,update(i,f[i],0,h,1);\n\t}\n\tprintf(\"%d\",f[h]);\n}"
  },
  {
    "language": "C++",
    "code": "// not my code is from Geothermal....\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 1001000;\nconst int MOD = 1e9+7;\n\nll fact[N];\nll ans[N], pref[N];\n\nint main() {\n    ios_base::sync_with_stdio(0); \n    cin.tie(0);\n    \n    int n;\n    cin >> n;\n    int h, d;\n    cin >> h >> d;\n\n    fact[0] = 1;\n    ll factSum = 0;\n   \tfor (int i = 1; i <= n; ++i) {\n    \tfact[i] = fact[i-1] * i;\n    \tfact[i] = fact[i] % MOD;\n    \tfactSum += fact[i];\n    \tfactSum = factSum % MOD;\n    }\n \n    pref[0] = 0; pref[1] = fact[n];\n    // start with n factorial\n    ans[0] = fact[n];\n    for (int i = 1; i < h; ++i) {\n    \tans[i] = pref[i] - pref[max(0, i-d)];\n    \tans[i] += MOD; ans[i] = ans[i] % MOD;\n\n    \t/* for factSum, you can choose the k \"lowest\" buildings from 1 to n and get then to height i, \n    \t and after that assign an order for them for future use*/\n\n    \tans[i] = ans[i] * factSum; ans[i] = ans[i] % MOD;\n    \tpref[i+1] = pref[i] + ans[i];\n    \tpref[i+1] = pref[i+1] % MOD;\n    \t//cout << ans[i] << \" \" << endl;\n    }\n \t/* as here we don't have future use we don't multiply by factSum */\n    ans[h] = pref[h] - pref[max(0, h-d)];\n    ans[h] += MOD; ans[h] = ans[h] % MOD;\n    cout << ans[h] << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// vvvvvvvvvvvv TEMPLATE vvvvvvvvvvvv\n#include <bits/stdc++.h>\nusing namespace std; using ll = long long; using P = pair<ll, ll>;\nconst ll linf = 1e18; const double eps = 1e-12, pi = acos(-1);\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define each(i,a) for (auto&& i : a)\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) begin(a),end(a)\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\ntemplate<typename Head> void out(Head h) { cout << h << endl; } template<typename Head, typename... Tail>void out(Head h, Tail... t) { cout << h << \" \"; out(t...); }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& v) { each(x,v) is >> x; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) { rep(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\nostream& operator<<(ostream& os, const vector<string>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\nstruct yes_no : std::numpunct<char> { string_type do_truename() const { return \"Yes\"; } string_type do_falsename() const { return \"No\"; } };\nvoid solve(); int main() {\n  ios::sync_with_stdio(false); cin.tie(0); locale loc(locale(), new yes_no); cout.imbue(loc); cout << fixed << setprecision(10) << boolalpha;\n  solve();\n}\n// ^^^^^^^^^^^^ TEMPLATE ^^^^^^^^^^^^\n\nconstexpr ll mod = 1e9+7;\nconstexpr ll mul(ll a, ll b) { return a * b % mod; }\nll mul(initializer_list<ll> t) { ll res = 1; each(v, t) res = mul(res, v); return res; }\nll add(ll a, ll b) { return (a + b) % mod; }\nll add(initializer_list<ll> t) { ll res = 0; each(v, t) res = add(res, v); return res; }\nll sub(ll a, ll b) { return (a - b + mod) % mod; }\nll sub(initializer_list<ll> t) { auto it = t.begin(); ll res = *(it++); while (it != t.end()) res = sub(res, *(it++)); return res; }\nll inv(ll n); ll power(ll x, ll n) { if (n < 0) return inv(power(x, -n)); ll res = 1; for (ll i = 1; i <= n; i <<= 1) { if (i & n) res = mul(res, x); x = mul(x, x); } return res; }\nll inv(ll n) { return power(n, mod-2); }\nll divi(ll a, ll b) { return mul(a, inv(b)); }\nll divi(initializer_list<ll> t) { auto it = t.begin(); ll res = *(it++); while (it != t.end()) res = divi(res, *(it++)); return res; }\nvector<ll> fact, rfact;\nvoid init_fact(ll n) { fact.resize(n+1); fact[0] = 1; rep(i, n) fact[i+1] = mul(fact[i], i+1); rfact.resize(n+1); rfact[n] = inv(fact[n]); rrep(i, n) rfact[i] = mul(rfact[i], i+1); }\nll comb(ll n, ll r) { if (r < 0) return 0; if (r > n) return 0; return divi(fact[n], mul(fact[r], fact[n-r])); }\nll perm(ll n, ll r) { if (r < 0) return 0; if (r > n) return 0; return divi(fact[n], fact[n-r]); }\n\nusing Row = vector<ll>;\nusing Matrix = vector<Row>;\nMatrix E(ll n) { Matrix res(n, Row(n, 0)); rep(i, n) res[i][i] = 1; return res; }\nMatrix mul(const Matrix& A, const Matrix& B) { const ll n = A.size(), m = A[0].size(), l = B[0].size(); assert(m == B.size()); Matrix res(n, Row(l, 0)); rep(i, n) rep(j, m) rep(k, l) res[i][k] = add(res[i][k], mul(A[i][j], B[j][k])); return res; }\nRow mul(const Matrix& A, const Row& x) { Matrix tx(x.size()); rep(i, x.size()) tx[i] = Row(1, x[i]); tx = mul(A, tx); Row res(x.size()); rep(i, x.size()) res[i] = tx[i][0]; return res; }\nMatrix power(Matrix A, ll n) { assert(A.size() == A[0].size()); Matrix res = E(A.size()); for (ll i = 1; i <= n; i <<= 1) { if (i & n) res = mul(res, A); A = mul(A, A); } return res; }\n\ntemplate <class Monoid>\nclass SegmentTree {\n  using T = typename Monoid::type;\n  const int size_, n;\n  std::vector<T> data;\n  int expand(int m) const { return m <= 1 ? 1 : expand((m + 1) / 2) * 2; }\npublic:\n  SegmentTree() : SegmentTree(0) {}\n  SegmentTree(const std::vector<T> &vec) :\n    size_(vec.size()), n(expand(size_)), data(n * 2, Monoid::id()) {\n    std::copy(begin(vec), end(vec), begin(data) + n);\n    for (int i = n - 1; i >= 0; --i) {\n      data[i] = Monoid::op(data[i * 2 + 0], data[i * 2 + 1]);\n    }\n  }\n  SegmentTree(const int count, const T &value = Monoid::id()) :\n    SegmentTree(std::vector<T>(count, value)) {}\n  int size() const { return size_; }\n  void update(int pos, const T &value) {\n    assert (0 <= pos && pos < size_); // assertion\n    data[pos += n] = value;\n    while (pos /= 2) {\n      data[pos] = Monoid::op(data[pos * 2], data[pos * 2 + 1]);\n    }\n  }\n  T find(int l, int r) const {\n    assert (0 <= l && l <= r && r <= size_); // assertion\n    l += n; r += n;\n    T res1 = Monoid::id(), res2 = Monoid::id();\n    while (l != r) {\n      if (l % 2) res1 = Monoid::op(res1, data[l++]);\n      if (r % 2) res2 = Monoid::op(data[--r], res2);\n      l /= 2; r /= 2;\n    }\n    return Monoid::op(res1, res2);\n  }\n  using value_type = T;\n  using update_type = T;\n};\n\nstruct Min {\n  using type = ll;\n  static type id() { return linf; }\n  static type op(const type &l, const type &r) { return min(l, r); }\n};\nstruct Max {\n  using type = ll;\n  static type id() { return -linf; }\n  static type op(const type &l, const type &r) { return max(l, r); }\n};\nstruct Sum {\n  using type = ll;\n  static type id() { return 0; }\n  static type op(const type &l, const type &r) { return add(l, r); }\n};\n\nvoid solve() {\n  ll n, h, D; cin >> n >> h >> D;\n  SegmentTree<Sum> seg(h);\n  seg.update(0, 1);\n  init_fact(n+10);\n  ll coe = 0;\n  rep(i, n) {\n    coe = add(coe, fact[i+1]);\n  }\n  rep(y, 1, h) {\n    ll l = max(0LL, y-D);\n    seg.update(y, mul(seg.find(l, y), coe));\n  }\n  ll ans = mul(seg.find(max(0LL, h-D), h), fact[n]);\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong N,H,D,mod=1e9+7;\n//1-indexed\n#include<vector>\ntemplate<typename T>\nstruct BIT{\n\tint n;\n\tvector<T>bit;\n\tBIT(int n_=0,T a=0):n(n_),bit(n_+1,a){}\n\tT sum(int i)\n\t{\n\t\tT ans=0;\n\t\tfor(;i>0;i-=i&-i)(ans+=bit[i])%=mod;\n\t\treturn ans;\n\t}\n\tvoid add(int i,T a)\n\t{\n\t\tif(i==0)return;\n\t\tfor(;i<=n;i+=i&-i)(bit[i]+=a)%=mod;\n\t}\n};\nmain()\n{\n\tcin>>N>>H>>D;\n\tBIT<long>P(H);\n\tlong s=0,p=1;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tp=p*i%mod;\n\t\ts=(s+p)%mod;\n\t}\n\tfor(int i=0;i<D;i++)if(i<H)P.add(i+1,p);\n\tfor(int i=1;i<H;i++)\n\t{\n\t\tP.add(i+1,(P.sum(i)-P.sum(i-D))*s%mod);\n\t}\n\tcout<<((P.sum(H)-P.sum(H-1))%mod+mod)%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 1e9 + 7;\n\nint n, d, h;\nint fac[1000005], pfac[1000005];\nint dp[1000005], pdp[1000005];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &h, &d);\n\t\n\tfac[0] = 1;\n\trep1(i, n) fac[i] = 1LL * fac[i - 1] * i % MOD;\n\trep1(i, n) pfac[i] = (pfac[i - 1] + fac[i]) % MOD;\n\t\n\tpdp[0] = dp[0] = fac[n];\n\trep1(i, h) {\n\t\tdp[i] = pdp[i - 1];\n\t\tif(i > d) dp[i] = (dp[i] - pdp[i - d - 1] + MOD) % MOD;\n\t\tif(i < h) dp[i] = 1LL * dp[i] * pfac[n] % MOD;\n\t\tpdp[i] = (pdp[i - 1] + dp[i]) % MOD;\n\t}\n\t\n\tprintf(\"%d\\n\", dp[h]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nll extgcd(ll a,ll b,ll& x,ll& y){\n\tll d=a;\n\tif(b!=0LL){\n\t\td=extgcd(b,a%b,y,x);\n\t\ty-=(a/b)*x;\n\t}else{\n\t\tx=1;\n\t\ty=0;\n\t}\n\treturn d;\n}\n\nll mod_inverse(ll a,ll m){\n\tll x,y;\n\textgcd(a,m,x,y);\n\treturn (m+x%m)%m;\n}\n\n\nint n,h,d;\nll fact[1000005];\nll factsum[1000005];\nll dp[2000005];\nll sum[2000005];\n\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&h,&d);\n\tfact[0]=0;\n\tfact[1]=1;\n\tfactsum[1]=1;\n\tfor(ll i=2;i<=n;i++){\n\t\tfact[i]=fact[i-1]*i%MOD;\n\t\tfactsum[i]=(fact[i]+factsum[i-1])%MOD;\n\t}\n\tdp[0]=sum[0]=fact[n]*mod_inverse(factsum[n],MOD)%MOD;\n\tfor(int i=1;i<=h;i++){\n\t\tdp[i]=factsum[n]*(sum[i-1]-(i-d-1>=0?sum[i-d-1]:0)+MOD)%MOD;\n\t\tsum[i]=(sum[i-1]+dp[i])%MOD;\n\t}\n\tprintf(\"%lld\\n\",dp[h]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define mod 1000000007LL\n#define eps 1e-13\n// #define PI 3.141592653589793238L\n#define INF 1000000011\n#define INFLL 1000000000000000011LL\n#define vi vector<int>\n#define vll vector<long long>\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define pil pair<int, long long>\n#define pli pair<long long, int>\n#define mp make_pair\n#define F first\n#define S second\n#define pb push_back\n#define fo(i,a,n) for(i = (a); i < (n); i++)\n#define gtl(x) getline(cin, (x))\n#define flsh fflush(stdout)\n#define sws ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0)\n#define gcd __gcd\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)((a).size())\n#define io_file freopen(\"D:/Coding Problems/Contest/input_file.in\", \"r\", stdin); freopen(\"D:/Coding Problems/Contest/output_file.out\", \"w\", stdout)\n\nll modx(ll Base, ll exponent)\n{\n\tll ans = 1;\n\tif(Base == 1)\n\t\treturn Base;\n\twhile(exponent)\n\t{\n\t\tif(exponent & 1)\n\t\t\tans = (ans * Base)%mod;\n\t\tBase = (Base * Base)%mod;\n\t\texponent = exponent >> 1;\n\t}\n\treturn ans;\n}\n\nll inmodx(ll num)\n{\n\treturn (modx(num, mod-2LL));\n}\n\nbool cmp(pair < pll, int > a, pair < pll, int > b)//true for a before b\n{\n\tif(a.F.F*b.F.S <= b.F.F*a.F.S)\n\t\treturn 1;\n\treturn 0;\n}\n\nconst int N = (1e6) + 9;\nconst int M = (N<<2) + 9;\nconst int LOGN = ((int)log2(N)) + 3;\nconst int LOGM = ((int)log2(M)) + 3;\nconst int BUCK = 2*550;\nconst int SQRT = BUCK+9;\n\nll fact[N], dp[N], sum[N];\n\nvoid pre()\n{\n\tint i;\n\tfact[0] = 1;\n\tfo(i,1,N)\n\t\tfact[i] = (fact[i-1] * 1LL * i)%mod;\n\treturn;\n}\n\ninline ll calc_sum(int l, int r)\n{\n\tl = max(l,0);\n\tif(l > r)\n\t\treturn 0;\n\treturn (sum[r]-sum[l]+dp[l]+mod)%mod;\n}\n\nvoid solve()\n{\n\tpre();\n\tint n, h, d, i;\n\tll val = 0, ans;\n\tcin >> n >> h >> d;\n\tfo(i,1,n+1)\n\t\tval += fact[i];\n\tval %= mod;\n\tdp[0] = sum[0] = 1;\n\tfo(i,1,h+1)\n\t{\n\t\tdp[i] = (calc_sum(i-d,i-1)*val)%mod;\n\t\tsum[i] = sum[i-1] + dp[i];\n\t\tif(sum[i] >= mod)\n\t\t\tsum[i] -= mod;\n\t}\n\tans = (dp[h]*inmodx(val))%mod;\n\tans = (ans * fact[n])%mod;\n\tcout << ans << '\\n';\n\treturn;\n}\n\nint main()\n{\n\tsws;\n\tclock_t clk;\n\tclk = clock();\n\t// io_file;\n\t// srand (time(NULL));\n\n\t//Code here\n\tint t = 1, cs;\n\tcout << fixed << setprecision(2);\n\t// cin >> t;\n\tfo(cs,1,t+1)\n\t{\n\t\t// cout << \"Case #\" << cs << \": \";\n\t\tsolve();\n\t}\n\t// Code ends here\n\n\tclk = clock() - clk;\n\tcerr << fixed << setprecision(6) << \"Time: \" << ((double)clk)/CLOCKS_PER_SEC << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//using namespace std;\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#define rep(i,j,n) for(ll i=(ll)(j);i<(ll)(n);i++)\n#define REP(i,j,n) for(ll i=(ll)(j);i<=(ll)(n);i++)\n#define per(i,j,n) for(ll i=(ll)(j);(ll)(n)<=i;i--)\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define disup(A,key) distance(A.begin(),upper_bound(ALL(A),(ll)(key)))\n#define dislow(A,key) distance(A.begin(),lower_bound(ALL(A),(ll)(key)))\n#define pb emplace_back\n#define mp std::make_pair\n#define endl \"\\n\"\n//using std::endl;\nusing std::cin;\nusing std::cout;\nusing std::vector;\nusing std::string;\nusing std::upper_bound;\nusing std::lower_bound;\nusing vi=vector<ll>;\nusing vii=vector<vi>;\nusing pii=std::pair<ll,ll>;\n//\nconstexpr ll MOD=1e9+7;\n//constexpr ll MOD=998244353;\n//constexpr ll MOD=10000000;\nconstexpr ll MAX=1e6;\nconstexpr ll INF=(1ll<<62);\ntemplate<class T>\nclass prique :public std::priority_queue<T, std::vector<T>, std::greater<T>> {};\nstruct Segment_tree{\n    ll N;\n    vector<pii> node;\n    Segment_tree(ll sz){\n        N=1;\n        while(N<sz) N*=2;\n        node.resize(2*N-1,mp(INF,INF));\n        per(i,N-2,0){\n            node[i]=std::min(node[i*2+1],node[i*2+1]);\n        }\n    }\n    void update(ll X,pii val){\n        X+=N-1;\n        node[X]=val;\n        while(X>0){\n            X=(X-1)/2;\n            node[X]=std::min(node[X*2+1],node[X*2+2]);\n        }\n    }\n    pii RMQ(ll a,ll b,ll now,ll l,ll r){ //[a,b),[l,r)\n        if(r<0) r=N;\n        if(r<=a||b<=l) return mp(INF,INF);\n        if(a<=l&&r<=b) return node[now];\n        auto vl=RMQ(a,b,now*2+1,l,(l+r)/2),vr=RMQ(a,b,now*2+2,(l+r)/2,r);\n        return std::min(vl,vr);\n    }\n};\nstruct Binary_indexed_tree{\n    int N;\n    vi bit;\n    Binary_indexed_tree(int n):N(n){\n        bit.resize(N+1,0);\n    }\n    void add(int x,int a){\n        for(x;x<=N;x+=(x&-x)) bit[x]+=a;\n    }\n    ll sum(int x){\n        ll ret=0;\n        for(x;x>0;x-=(x&-x)) ret+=bit[x];\n        return ret;\n    }\n    ll lower_bound(ll X){\n        if(sum(N)<X) return -1;\n        ll ret=0,memo=1,sum=0;\n        while(memo*2<=N) memo*=2;\n        while(memo>0){\n            if(memo+ret<=N&&sum+bit[memo+ret]<X){\n                sum+=bit[memo+ret];\n                ret+=memo;\n            }\n            memo/=2;\n        }\n        return ret+1;\n    }\n};\nstruct Union_Find{\n    ll N;\n    vi par;\n    vi siz;\n    Union_Find(int n):N(n){\n        par.resize(N);\n        siz.resize(N,1);\n        rep(i,0,N) par[i]=i;\n    }\n    ll root(ll X){\n        if(par[X]==X) return X;\n        return par[X]=root(par[X]);\n    }\n    bool same(ll X,ll Y){\n        return root(X)==root(Y);\n    }\n    void unite(ll X,ll Y){\n        X=root(X);\n        Y=root(Y);\n        if(X==Y) return;\n        par[X]=Y;\n        siz[Y]+=siz[X];\n        siz[X]=0;\n    }\n    ll size(ll X){\n        return siz[root(X)];\n    }\n};\nlong long modpow(long long a, long long n, long long mod) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\nvi fac,finv,inv;\nvoid COMinit() {\n    fac.resize(MAX);\n    finv.resize(MAX);\n    inv.resize(MAX);\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\nll COM(ll n,ll r){\n    if(n<r||n<0||r<0) return 0;\n    return fac[n]*finv[r]%MOD*finv[n-r]%MOD;\n}\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    ll N,H,D; cin>>N>>H>>D;\n    ll memo=1,sum=0;\n    REP(i,1,N){\n        memo*=i;\n        memo%=MOD;\n        sum+=memo;\n        sum%=MOD;\n    }\n    vi dp(H+1);\n    dp[0]=memo%MOD;\n    ll sum2=dp[0];\n    rep(i,1,H){\n        dp[i]=sum2*sum%MOD;\n        sum2+=dp[i];\n        sum2%=MOD;\n        if(i>=D){\n            sum2-=dp[i-D];\n            sum2%=MOD;\n            if(sum2<0) sum2+=MOD;\n        }\n    }\n    cout<<sum2<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"../benri.h\"\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7; //998244353\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt(ll v):v(v%MOD){}\n  modInt operator+(const modInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n)const{return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n)const{return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n)const{return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\n#ifdef NUIP\nclass MINT_FRAC____{\npublic:\n\tunordered_map<int,pii> dict;\n\tMINT_FRAC____(int n){\n\t\trep(p,n+1)reps(q,1,n+1)if(__gcd(p,q)==1){\n\t\t\tdict[1ll*p*modpow(q,-1)%MOD]=pii(p,q);\n\t\t\tdict[MOD-1ll*p*modpow(q,-1)%MOD]=pii(-p,q);\n\t\t}\n\t}\n} Il1Il1Il1(1000);\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){if(Il1Il1Il1.dict.count(n.v)) os<<n.v<<\"(\"<<Il1Il1Il1.dict[n.v].X<<\"/\"<<Il1Il1Il1.dict[n.v].Y<<\")\";else os<<n.v;return os;};\n#else\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\n#endif\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return modInt<mod>(n%mod)/m;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(1123456);\n\n\nint main(){\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tint n,d,h;\n\tcin>>n>>h>>d;\n\tmint p=0;\n\trep(i,n) p+=fact[i+1];\n\tvector<mint> dp(h+1);\n\tdp[0]=fact[n]/p;\n\tout(p,1);\n\tmint s=dp[0];\n\treps(i,1,h+1){\n\t\tdp[i]=s*p;\n\t\ts+=dp[i];\n\t\tif(i>=d) s-=dp[i-d];\n\t}\n\t// out(dp,1);\n\tcout<<dp[h]<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// And in the end, the love you take is equal to the love you make.\n//                      Paul McCartney (the Beatles). The End. Abbey Road.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n  if (ib == ie) {\n    ib = ibuf;\n    ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n  }\n  return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n  using namespace _buff;\n  LL ret = 0;\n  bool pos = true;\n  char c = getc();\n  for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n    assert(~c);\n  }\n  if (c == '-') {\n    pos = false;\n    c = getc();\n  }\n  for (; c >= '0' && c <= '9'; c = getc()) {\n    ret = (ret << 3) + (ret << 1) + (c ^ 48);\n  }\n  return pos ? ret : -ret;\n}\n\nconst size_t N = 1e6 + 5;\nconst int MOD = 1e9 + 7;\n\nint qpow(int base, int e) {\n  int ret = 1;\n  for (; e; e >>= 1) {\n    if (e & 1) {\n      ret = (LL) ret * base % MOD;\n    }\n    base = (LL) base * base % MOD;\n  }\n  return ret;\n}\n\nint f[N], pre[N];\n\nint main() {\n  int n = read(), h = read(), d = read();\n\n  int fac = 1, sum = 0;\n  for (int i = 1; i <= n; ++i) {\n    fac = (LL) fac * i % MOD;\n    sum = (sum + fac) % MOD;\n  }\n\n  f[0] = pre[0] = 1;\n  for (int i = 1; i <= h; ++i) {\n    f[i] = (LL) (pre[i - 1] - (i >= d + 1 ? pre[i - d - 1] : 0)) * sum % MOD;\n    pre[i] = (pre[i - 1] + f[i]) % MOD;\n  }\n\n  cout << (LL) f[h] * fac % MOD * qpow(sum, MOD - 2) % MOD << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ninline int read()\n{\n\tint out=0,fh=1;\n\tchar jp=getchar();\n\twhile ((jp>'9'||jp<'0')&&jp!='-')\n\t\tjp=getchar();\n\tif (jp=='-')\n\t\tfh=-1,jp=getchar();\n\twhile (jp>='0'&&jp<='9')\n\t\tout=out*10+jp-'0',jp=getchar();\n\treturn out*fh;\n}\nconst int P=1e9+7;\nconst int MAXN=1e6+10;\nint fac[MAXN];\ninline int add(int a,int b)\n{\n\treturn (a + b) % P;\n}\ninline int mul(int a,int b)\n{\n\treturn 1LL * a * b % P;\n}\nint fpow(int a,int b)\n{\n\tint res=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\tres=mul(res,a);\n\t\ta=mul(a,a);\n\t\tb>>=1;\n\t}\n\treturn res;\n}\nint inv(int x)\n{\n\treturn fpow(x,P-2);\n}\nint n,H,D,sf=0;\nint f[MAXN],sum[MAXN];\nint main()\n{\n\tn=read(),H=read(),D=read();\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tfac[i]=mul(fac[i-1],i);\n\t\tsf=add(sf,fac[i]);\n\t}\n\tf[0]=1,sum[0]=1;\n\tfor(int i=1;i<=H;++i)\n\t{\n\t\tif(i-D-1>=0)\n\t\t\tf[i]=add(sum[i-1],P-sum[i-D-1]);\n\t\telse\n\t\t\tf[i]=sum[i-1];\n\t\tf[i]=mul(f[i],sf);\n\t\tsum[i]=add(sum[i-1],f[i]);\n\t}\n\tcout<<mul(mul(f[H],fac[n]),inv(sf))<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing ll = long long;\n\nusing namespace std;\n\n#include <cassert>\n#define MAX 2000000  // 階乗をいくつまで計算するか\n\nclass modlong {\n    ll val;\n    static ll *invs, *facts, *finvs;\n\n    // 階乗, 逆元, 階乗の逆元をMAXまで求める\n    bool initModlong() {\n        invs[1] = \n        facts[0] = facts[1] =\n        finvs[0] = finvs[1] = 1;\n        for (int i=2; i<=MAX; i++) {\n            invs[i]  = -invs[MOD % i] * (MOD / i) % MOD;\n            facts[i] = facts[i - 1] * i % MOD;\n            finvs[i] = finvs[i - 1] * invs[i] % MOD;\n        }\n        return true;\n    }\n\npublic:\n    static ll MOD; // modの元\n\n    // 初期化 値を引数に与えなかった場合はval=0としておく\n    modlong(ll init = 0) : val(init) {\n        static bool call_once = initModlong(); // static変数の性質により一度だけ呼ばれる\n        assert(call_once); // unusedの回避\n        if (val < 0 || val >= MOD) val %= MOD;\n        if (val < 0) val += MOD;   // 0以上であることを保証\n    }\n\n    // llへのキャスト operator ll()で定義すると modlong +\n    // llとかができなくなる\n    inline ll toll() { return this->val; }\n\n    // 代入\n    void operator=(const modlong &r) { this->val = r.val; }\n    void operator=(const ll &r) { *this = modlong(r); }\n\n    // 足し算; 符号反転; 引き算\n    modlong operator+(const modlong &r) {\n        ll ans = this->val + r.val;\n        if (ans >= MOD) ans -= MOD;\n        return modlong(ans);\n    }\n    modlong operator-() {\n        ll ans = MOD - this->val;\n        return modlong(ans);\n    }\n    modlong operator-(const modlong &r) {\n        modlong rr = r;\n        return *this + (-rr);\n    }\n\n    //かけ算; 逆元; わり算\n    modlong operator*(const modlong &r) {\n        ll ans = this->val * r.val;\n        return modlong(ans);\n    }\n    modlong inv() {\n        assert(*this != 0);\n        if (*this == 1) return modlong(1);\n\n        modlong p, q = *this, m(0), n(1), r, c;\n        p.val = MOD;  // p=modとかくとp.val=mod%mod=0となってしまう\n        while (q > MAX) {\n            r = p.val % q.val;  // r.val=p.val % q.val\n                                // とかくよりもこのほうが代入時に%modされるので安全\n            c = m.val - n.val * (p.val / q.val);\n            p = q, q = r, m = n, n = c;\n        }\n        return n * invs[q.val];\n    }\n    modlong operator/(const modlong &r) { return *this * modlong(r).inv(); }\n    modlong operator%(const modlong &r) { return modlong(this->val % r.val); }\n\n    // ++ -- 前付きと後ろ付き\n    void operator++() { ++this->val; }\n    void operator++(int a) {\n        a = 0;\n        this->val++;\n    }  // a使ってなくねっていうwarningをsilenceするためにaをいじってる\n    void operator--() { --this->val; }\n    void operator--(int a) {\n        a = 0;\n        this->val--;\n    }\n\n    // 四則演算&代入\n    void operator+=(const modlong &r) { *this = *this + r; }\n    void operator-=(const modlong &r) { *this = *this - r; }\n    void operator*=(const modlong &r) { *this = *this * r; }\n    void operator/=(const modlong &r) { *this = *this / r; }\n    void operator%=(const modlong &r) { *this = *this % r; }\n\n    // べき乗\n    modlong pow(long n) {\n        if (n < 0)\n            return inv().pow(-n);  // 逆元の-n乗\n        else if (n == 0)\n            return modlong(1);\n\n        modlong half = pow(n / 2);\n        if (n % 2)\n            return *this * half * half;\n        else\n            return half * half;\n    }\n    modlong pow(modlong n) { return pow(n.val); }\n\n    // コンビネーション\n    modlong comb(modlong _k) {\n        assert(this->val <= MAX);\n        const ll n = this->val, k = _k.val;\n        if (k < 0 || k > n) return 0;\n        if (k == 0 || k == n) return 1;\n        return modlong(facts[n]) * finvs[k] * finvs[n - k];\n    }\n\n    // 階乗\n    modlong fact() { \n        assert(this->val <= MAX);\n        return modlong(facts[this->val]);\n    }\n\n    friend bool operator<(const modlong &l, const modlong &r) { return l.val < r.val; }\n    friend bool operator>(const modlong &l, const modlong &r) { return l.val > r.val; }\n    friend bool operator==(const modlong &l, const modlong &r) { return l.val == r.val; }\n    friend bool operator!=(const modlong &l, const modlong &r) { return !(l == r); }\n    friend bool operator<=(const modlong &l, const modlong &r) { return !(l > r); }\n    friend bool operator>=(const modlong &l, const modlong &r) { return !(l < r); }\n\n    friend ostream &operator<<(ostream &os, const modlong &out) {\n        os << out.val;\n        return os;\n    }\n    friend istream &operator>>(istream &is, modlong &in) {\n        ll inl;\n        is >> inl;\n        in.val = inl % modlong::MOD;\n        return is;\n    }\n};\n\n// コンビネーション\ninline modlong modComb(ll n, ll k) { return modlong(n).comb(k); }\n// 階乗\ninline modlong modFact(ll n) { return modlong(n).fact(); }\n\n// static変数たち c++17ならinlineでかけるのでclassの中に入れられる(https://ja.cppreference.com/w/cpp/language/static)\nll *modlong::invs  = new ll[MAX+1];\nll *modlong::facts = new ll[MAX+1];\nll *modlong::finvs = new ll[MAX+1];\n\nll modlong::MOD = (ll)1e9 + 7;\n\n\nint main() {\n    int n, h, d;\n    cin >> n >> h >> d;\n    modlong vari = 0;\n    for (int i=1; i<=n; i++) {\n        vari += modFact(i);\n    }\n    queue<modlong> q;\n    q.push(modFact(n));\n    modlong ans, sum = modFact(n);\n    for (int i=1; i<=h; i++) {\n        ans = sum * vari;\n        q.push(ans);\n        sum += ans;\n        if (q.size() > d) {\n            sum -= q.front();\n            q.pop();\n        }\n    }\n    cout << ans / vari << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#define fastio ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0)\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define pii pair <int, int>\n#define pll pair <ll, ll>\n#define pci pair <char, int>\n#define pld pair <ld, ld>\n#define ppll pair <pll, pll>\n#define vll vector <ll>\n#define vvll vector <vll>\n#define vpll vector <pll>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define mll map <ll, ll>\n#define fastmap gp_hash_table\n#define cd complex <double>\n#define vcd vector <cd>\n#define PI 3.14159265358979\n#pragma 03\nusing namespace std;\nusing namespace __gnu_pbds;\nll dp[2000005];\nll mod = 1e9 + 7;\nint main(){\n\tll n, h, d; cin >> n >> h >> d;\n\tll x = 1, y = 0;\n\tfor (ll i = 1; i<=n; i++){\n\t\t(x *= i) %= mod; (y += x) %= mod;\n\t}\n\tdp[0] = x;\n\tfor (ll i = 0; i<=h; i++){\n\t\tif (!i){\n\t\t\t(dp[i+1] += dp[i]) %= mod;\n\t\t\t(dp[i+d+1] += mod - dp[i]) %= mod;\n\t\t}\n\t\tif (i){\n\t\t\t(dp[i+1] += dp[i]) %= mod;\n\t\t\t(dp[i+1] += y * dp[i] % mod) %= mod;\n\t\t\t(dp[i+d+1] += (mod - y * dp[i] % mod)) %= mod;\n\t\t}\n\t}\n\tcout << dp[h] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#define ll long long\n#define mod 1000000007\n#define Mod1(x) (x>=mod?x-mod:x)\n#define Mod2(x) (x<0?x+mod:x)\n#define maxn 200010\ninline ll read()\n{\n\tll x=0; char c=getchar(),f=1;\n\tfor(;c<'0'||'9'<c;c=getchar())if(c=='-')f=-1;\n\tfor(;'0'<=c&&c<='9';c=getchar())x=x*10+c-'0';\n\treturn x*f;\n}\ninline void write(ll x)\n{\n\tstatic char buf[20],len; len=0;\n\tif(x<0)x=-x,putchar('-');\n\tfor(;x;x/=10)buf[len++]=x%10+'0';\n\tif(!len)putchar('0');\n\telse while(len)putchar(buf[--len]);\n}\ninline void writesp(ll x){write(x); putchar(' ');}\ninline void writeln(ll x){write(x); putchar('\\n');}\nll f[maxn];\nint n,d,h;\ninline ll power(ll a,ll b)\n{\n\tll ans=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ans=ans*a%mod;\n\treturn ans;\n}\nint main()\n{\n\tn=read(); h=read(); d=read();\n\tll val=0,fac=1;\n\tfor(int i=1;i<=n;i++){\n\t\tfac=fac*i%mod;\n\t\tval=Mod1(val+fac);\n\t}\n\tf[0]=1;\n\tll cur=1;\n\tfor(int i=1;i<=h;i++){\n\t\tf[i]=cur*val%mod;\n\t\tcur=Mod1(cur+f[i]);\n\t\tif(i>=d)cur=Mod2(cur-f[i-d]);\n\t}\n\twriteln(f[h]*power(val,mod-2)%mod*fac%mod);\n\t// printf(\"%lld %lld\\n\",val,fac);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nvoid sol(int i, int st, int dir, vel& cnt, vvel& nex, vvel& use) {\n\tif (use[i].size() == 0 || use[i].back() != st) {\n\t\tuse[i].push_back(st);\n\t\tif (cnt[i] >= 1) {\n\t\t\trep(nd, 2) {\n\t\t\t\tint ne = nex[nd][i];\n\t\t\t\tif (ne != -1) {\n\t\t\t\t\tsol(ne, st, nd, cnt, nex, use);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint ne = nex[dir][i];\n\t\t\tif (ne != -1) {\n\t\t\t\tsol(ne, st, dir, cnt, nex, use);\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main() {\n\tomajinai;\n\tint n, h, d; cin >> n >> h >> d;\n\tint M = 0;\n\tint ka = 1;\n\trep(i, n) {\n\t\tka *= (i + 1);\n\t\tM += ka;\n\t\tM %= p1;\n\t}\n\tvel dp(h);\n\tdp[0] = 1;\n\tfor (int i = 1; i < h; i++) {\n\t\tdp[i] = (M + 1) * dp[i - 1];\n\t\tif (i >= d + 1) {\n\t\t\tdp[i] -= M * dp[i - d - 1];\n\t\t}\n\t\tdp[i] %= p1; dp[i] += p1; dp[i] %= p1;\n\t}\n\tint ans = dp.back();\n\tif (h >= d + 1) {\n\t\tans += p1 - dp[h - d - 1];\n\t}\n\tans *= ka;\n\tcout << ans % p1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid out(T x) { cout << x << endl; exit(0); }\n#define watch(x) cout << (#x) << \" is \" << (x) << endl\n\n\n\n\n\nusing ll = long long;\n\nconst ll mod = 1e9+7;\nconst int maxn = 1e6 + 5;\n\n\n\nll n, h, d;\nll dp[maxn];\nll acc[maxn];\n\nll fac[maxn];\nll facSum;\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);  cout.tie(0);\n    cin>>n>>h>>d;\n    fac[0]=1;\n    for (int i=1; i<=n; i++) {\n\tfac[i]=1ll*i*fac[i-1]%mod;\n\tfacSum += fac[i];\n\tfacSum %= mod;\n    }\n\n\n\n    // facSum = 1! + 2! ... N!\n\n\n    // dp[i]: (# of ways to have at least 1 square reach height i) x (all orders of blocks that get stacked to this height)\n\n\n    dp[0] = fac[n];\n    acc[0] = dp[0];\n    for (ll i=1; i<=h; i++) {\n\tdp[i] += acc[i-1];\n\tif (i-1-d>=0) {\n\t    dp[i] += (mod-acc[i-1-d]);\n\t}\n\tdp[i] %= mod;\n\n\t// at height H, we don't care about order of arrival\n\tif (i<h) {\n\t    dp[i] *= facSum;\n\t    dp[i] %= mod;\n\t}\n\tacc[i]=(acc[i-1]+dp[i])%mod;\n    }\n\n\n    cout<<dp[h]<<endl;    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/rope>\n\n#define ll long long\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define f first\n#define s second\n#define all(x) x.begin(), x.end()\n#define D(x) cerr << #x << \" is \" << (x) << \"\\n\";\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\ntemplate<class T> using ordered_set = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>; ///find_by_order(),order_of_key()\ntemplate<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) { os << '{' << a.f << \", \" << a.s << '}'; return os; }\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& a){os << '{';for(int i=0;i<sz(a);i++){if(i>0&&i<sz(a))os << \", \";os << a[i];}os<<'}';return os;}\ntemplate<class T> ostream& operator<<(ostream& os, const set<T>& a) {os << '{';int i=0;for(auto p:a){if(i>0&&i<sz(a))os << \", \";os << p;i++;}os << '}';return os;}\ntemplate<class T> ostream& operator<<(ostream& os, const multiset<T>& a) {os << '{';int i=0;for(auto p:a){if(i>0&&i<sz(a))os << \", \";os << p;i++;}os << '}';return os;}\ntemplate<class T1,class T2> ostream& operator<<(ostream& os, const map<T1,T2>& a) {os << '{';int i=0;for(auto p:a){if(i>0&&i<sz(a))os << \", \";os << p;i++;}os << '}';return os;}\n\nconst int N=2e6+5;\nvector<int> dp(N);\nint n,h,d;\nconst int mod=1e9+7;\nint add(int a,int b)\n{\n    a+=b;\n    if(a>=mod)\n        a-=mod;\n    return a;\n}\nint mul(int a,int b)\n{\n    return (ll)a*b%mod;\n}\nint sub(int a,int b)\n{\n    a-=b;\n    if(a<0)\n        a+=mod;\n    return a;\n}\nint powmod(int x,int k)\n{\n    int ans=1;\n    for(;k;k>>=1,x=mul(x,x))\n        if(k&1)\n            ans=mul(ans,x);\n    return ans;\n}\nint get(int l,int r)\n{\n    return sub(dp[l],dp[r+1]);\n}\nvector<int> fact,ifact(N);\nint nCk(int n,int k)\n{\n    return mul(fact[n],mul(ifact[n-k],ifact[k]));\n}\nint main()\n{\n    fact.pb(1);\n    for(int i=1;i<N;i++)\n        fact.pb(mul(fact.back(),i));\n    ifact[N-1]=powmod(fact[N-1],mod-2);\n    for(int i=N-2;i>=0;i--)\n        ifact[i]=mul(ifact[i+1],i+1);\n    scanf(\"%i %i %i\",&n,&h,&d);\n    dp[h]=fact[n-1];\n    int magic=0;\n    for(int i=1;i<=n;i++){\n        magic=add(magic,fact[i]);\n    }\n    for(int i=h-1;i>0;i--)\n    {\n        dp[i]=mul(get(i+1,i+d),magic);\n        dp[i]=add(dp[i],dp[i+1]);\n    }\n    int sum=get(1,d);\n    sum=mul(sum,n);\n    printf(\"%i\\n\",sum);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nsigned main(){\n\n    int N, H, D; cin >> N >> H >> D;\n    Combination C(N);\n\n    mvec dp(H + 1);\n    dp[0] = C.fact[N];\n    mint c0 = 0;\n    FOR(n, 1, N + 1) c0 += C.fact[n];\n    mvec dpsum(H + 2, 0);\n    dpsum[1] = dp[0];\n    FOR(i, 1, H + 1){\n        dp[i] = (dpsum[i] - dpsum[max(i - D, 0LL)]) * c0;\n        dpsum[i + 1] = dpsum[i] + dp[i];\n    }\n    mint ans = dp[H] / c0;\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n31415 9265 3589\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define pb emplace_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n    out<<'('<<P.F<<','<<P.S<<')';\n    return out;\n}\n\n//}}}\nconst ll maxn=1000005;\nconst ll maxlg=__lg(maxn)+2;\nconst ll INF64=8000000000000000000LL;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst ld PI=acos(-1);\nconst ld eps=1e-9;\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n    ll res=1LL;\n    while(b){\n        if(b&1) res=res*a%MOD;\n        a=a*a%MOD;\n        \n        b>>=1;\n    }\n    return res;\n}\n\nll inv(ll n){\n    return mypow(n,MOD-2);\n}\n\nll dp[maxn];\nll pre[maxn];\nll fac[maxn];\nint main(){\n    IOS;\n    fac[0]=1;\n    for(int i=1;i<maxn;i++)fac[i]=fac[i-1]*i%MOD;\n    int n,h,d;\n    cin>>n>>h>>d;\n    dp[1]=1;\n    for(int i=1;i<=n;i++) dp[1]=dp[1]*i%MOD;\n    pre[0]=0;\n    pre[1]=dp[1];\n\n    ll x=0;\n    for(int i=1;i<=n;i++){\n        x+=fac[i];\n        if(x>=MOD) x-=MOD;\n    }\n    for(int i=1;i<=h;i++){\n        dp[i]=pre[i];\n        if(i>=d){\n            dp[i]-=pre[i-d];\n            if(dp[i]<0) dp[i]+=MOD;\n        }\n        pre[i+1]=(pre[i]+dp[i]*x)%MOD;\n        // cout<<dp[i]<<'\\n';\n    }\n    ll ans=dp[h]%MOD;\n    cout<<ans<<'\\n';\n    return 0;\n}\n    "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD_> struct ModInt {\n    static const unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    ModInt extgcd() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\n//const LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\nint N, H, D;\nMint dp[1000011];\n\nvoid MAIN() {\n    scanf(\"%d%d%d\", &N, &H, &D);\n\n    Mint P = 0;\n    {\n\tMint f = 1;\n\tfor (int i=1; i<=N; i++) {\n\t    f *= i;\n\t    P += f;\n\t}\n\tdp[0] = f;\n    }\n\n    Mint sum = 0;\n    for (int i=1; i<=H; i++) {\n\tsum += dp[i-1];\n\tif (i > D) sum -= dp[i-D-1];\n\tdp[i] = sum * P;\n    }\n\n    printf(\"%d\\n\", sum.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2,Ofast,inline,unroll-all-loops,-ffast-math\")\n#pragma GCC target(\"popcnt\")\n#include <bits/stdc++.h>\n#define maxn 1000010\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\n#define pob pop_back\n#define pf push_front\n#define pof pop_front\n#define pii pair<int, int>\n#define pil pair<int, ll>\n#define pll pair<ll, ll>\n#define IL inline\n#define ss system\nusing namespace std;\n\nint n, h, d;\nll f[maxn], s[maxn], fac[maxn], sum = 0;\nconst ll p = 1e9 + 7;\ntemplate <class T> void read(T &x) {\n  char ch = x = 0;\n  bool fl = false;\n  while (!isdigit(ch))\n    fl |= ch == '-', ch = getchar();\n  while (isdigit(ch))\n    x = x * 10 + ch - '0', ch = getchar();\n  x = fl ? -x : x;\n}\nint main() {\n  cin >> n >> h >> d, fac[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    fac[i] = fac[i - 1] * i % p;\n  }\n  f[0] = s[0] = fac[n];\n  for (int i = 1; i <= n; i++) {\n    sum = (sum + fac[i]) % p;\n  }\n  for (int i = 1; i <= h; i++) {\n    f[i] = (s[i - 1] - (i > d ? s[i - d - 1] : 0) + p) % p * (i == h ? 1 : sum) % p;\n    s[i] = (s[i - 1] + f[i]) % p;\n  }\n  cout << f[h] << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i=(a); i<(b); i++)\n#define PPC(x) __builtin_popcount((x))\n#define ALL(x) (x).begin(), (x).end()\n#define pb push_back\nusing namespace std;\n\nconst int maxN = 1 << 20, mod = 1000000007;\n\nlong long dp[maxN], pref[maxN];\n\ninline void add_mod(long long& a, long long b)\t{   a = (a + b) % mod;  }\ninline void mult_mod(long long& a, long long b)\t{   a = a * b % mod;    }\n\nlong long qpow(long long a, long long b)\n{\n    long long res0 = 1;\n    for (; b!=0; b>>=1)\n    {\n        if (b & 1)  mult_mod(res0, a);\n        mult_mod(a, a);\n    }\n    return res0;\n}\n\nlong long sumOnInt(int a, int b)\n{\n\tlong long res = pref[b];\n\tif (a > 0)\n\t\tres = (res - pref[a-1] + mod) % mod;\n\treturn res;\n}\n\nint main()\n{\n\tint n, h, d;\n\tscanf (\"%d%d%d\", &n, &h, &d);\n\tlong long fact = 1, w = 0;\n\tFOR(i, 1, n+1)\n\t\tmult_mod(fact, i), add_mod(w, fact);\n\t\t\n\tdp[0] = pref[0] = 1;\n\tFOR(i, 1, h+1)\n\t{\n\t\tdp[i] = sumOnInt(i-d, i-1) * w % mod;\n\t\tpref[i] = (pref[i-1] + dp[i]) % mod;\n\t}\n\t\n\tlong long res = dp[h] * qpow(w, mod-2) % mod;\n\tmult_mod(res, fact);\n\t\n\tprintf(\"%lld\\n\", res);\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MOD 1000000007\n\nint n, h, d;\nlong long fac = 1, sum, dp[1000005], ad[1000005], cur;\n\nvoid add(long long& a, long long b) {\n\ta += b;\n\tif (a >= MOD)\n\t\ta -= MOD;\n}\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &h, &d);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfac = fac * i % MOD;\n\t\tadd(sum, fac);\n\t}\n\tdp[0] = fac;\n\tfor (int i = 0; i < h; i++) {\n\t\tadd(cur, ad[i]);\n\t\tadd(dp[i], cur);\n\t\tif (i + d >= h)\n\t\t\tadd(dp[h], dp[i]);\n\t\tad[i + 1] = (ad[i + 1] + dp[i] * sum) % MOD;\n\t\tadd(ad[min(i + d + 1, h)], MOD - dp[i] * sum % MOD);\n\t}\n\tprintf(\"%lld\\n\", dp[h]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nvoid sol(int i,int st,int dir,vel&cnt, vvel& nex,vvel& use) {\n\tif (use[i].size() == 0 || use[i].back() != st) {\n\t\tuse[i].push_back(st);\n\t\tif (cnt[i] >= 1) {\n\t\t\trep(nd, 2) {\n\t\t\t\tint ne = nex[nd][i];\n\t\t\t\tif(ne!=-1){\n\t\t\t\t\tsol(ne, st, nd, cnt, nex, use);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint ne = nex[dir][i];\n\t\t\tif (ne != -1) {\n\t\t\t\tsol(ne, st, dir, cnt, nex, use);\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main() {\n\tomajinai;\n\tint n, h, d; cin >> n >> h >> d;\n\tmake_kai(n + 1, p1);\n\tint M = 0;\n\trep(i, n) {\n\t\tM += kai[i + 1];\n\t\tM %= p1;\n\t}\n\tvel dp(h);\n\tdp[0] = 1;\n\tfor (int i = 1; i < h; i++) {\n\t\tdp[i] = (M+1) * dp[i - 1];\n\t\tif (i >= d + 1) {\n\t\t\tdp[i] -= M * dp[i - d - 1];\n\t\t}\n\t\tdp[i] %= p1; dp[i] += p1; dp[i] %= p1;\n\t}\n\tint ans = dp.back();\n\tif (h >= d + 1) {\n\t\tans += p1 - dp[h - d - 1];\n\t}\n\tans *= kai[n];\n\tcout << ans % p1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <cstdio>\n#include <iomanip>\n#include <fstream>\n#include <cassert>\n#include <cstring>\n#include <unordered_set>\n#include <unordered_map>\n#include <numeric>\n#include <ctime>\n#include <bitset>\n#include <complex>\n#include <chrono>\n#include <random>\n#include <functional>\n\nusing namespace std;\n\nconst int H = 1e6 + 9;\nconst int MOD = 1e9 + 7;\n\nint add(int a, int b) {\n\treturn (a + b) % MOD;\n}\n\nint sub(int a, int b) {\n\treturn (a - b + MOD) % MOD;\n}\n\nint mul(int a, int b) {\n\treturn 1LL * a * b % MOD;\n}\n\nint dp[H];\nint sb[H];\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n, h, d;\n\tcin >> n >> h >> d;\n\tdp[0] = 1;\n\tint S = 0;\n\t{\n\t\tint c = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tc = mul(c, i);\n\t\t\tS = add(S, c);\n\t\t}\n\t}\n\tint C = 0;\n\tfor (int m = 0; m <= h; m++) {\n\t\tC = sub(C, sb[m]);\n\t\tif (m > 0) {\n\t\t\tdp[m] = C;\n\t\t}\n\t\tint V = dp[m];\n\t\tif (m > 0) {\n\t\t\tV = mul(V, S);\n\t\t}\n\t\tC = add(C, V);\n\t\tif (m + d + 1 <= h) {\n\t\t\tsb[m + d + 1] = add(sb[m + d + 1], V);\n\t\t}\n\t}\n\tint ans = dp[h];\n\tfor (int i = 1; i <= n; i++) {\n\t\tans = mul(ans, i);\n\t}\n\tcout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define IL inline\n#define _ 1524288\n#define ll long long\nusing namespace std;\n\nIL ll gi(){\n\tll data=0,fu=1; char ch=0; while(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')fu=-1,ch=getchar();\n\twhile('0'<=ch&&ch<='9')data=(data<<1)+(data<<3)+(ch^48),ch=getchar(); return data*fu;\n}\n\nint n,H,D,f[_],pre[_],g[_],Ans;\n#define mod 1000000007\nIL int Pow(int ts,int js){\n\tint al=1;\n\twhile(js){\n\t\tif(js&1)al=1ll*al*ts%mod;\n\t\tts=1ll*ts*ts%mod;\n\t\tjs>>=1;\n\t}return al;\n}\n\nint main(){\n\tn=gi(); H=gi(); D=gi();\n\tint ret=0,fc=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfc=1ll*i*fc%mod;\n\t\tret=(ret+fc)%mod; \n\t}\n\tf[0]=fc; pre[0]=f[0];\n\tfor(int i=1;i<=H;++i){\n\t\tf[i]=(pre[i-1]-((i-D-1>=0)?pre[i-D-1]:0)+mod)%mod;\n\t\tf[i]=1ll*ret*f[i]%mod;\n\t\tpre[i]=(pre[i-1]+f[i])%mod;\n\t}\n\tcout<<1ll*f[H]*Pow(ret,mod-2)%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nll N,D,H;\nll mo=1000000007;\n\ntemplate<class V, int ME> class BIT_mod {\npublic:\n\tV bit[1<<ME];\n\tBIT_mod(){ZERO(bit);};\n\tV operator()(int e) {ll s=0;e++;while(e) s+=bit[e-1],e-=e&-e; return s%mo;}\n\tV add(int e,V v) { e++; while(e<=1<<ME) { bit[e-1]+=v; bit[e-1] -= (bit[e-1]>=mo)?mo:0; e+=e&-e;}}\n};\nBIT_mod<ll,20> bt;\nll fact[1010101];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\t\n\tcin>>N>>H>>D;\n\n\tfact[0]=1;\n\tfor(i=0;i<=1010000;i++) fact[i+1]=fact[i]*(i+1)%mo;\n\t\n\tll sum=0;\n\tfor(i=1;i<=N;i++) sum+=fact[i];\n\tsum%=mo;\n\t\n\t\n\tbt.add(1,fact[N]);\n\tbt.add(D+1,mo-fact[N]);\n\tfor(i=1;i<=H-1;i++) {\n\t\tll cur=bt(i)%mo;\n\t\tbt.add(i+1,cur*sum%mo);\n\t\tbt.add(i+D+1,mo-cur*sum%mo);\n\t}\n\t\n\tcout<<bt(H)%mo<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 1000111, mod = 1000000007;\n\nint mul(int x, int y) {\n    return (1LL * x * y) % mod;\n}\n\nint power(int a, int b) {\n    if (b == 0) {\n        return 1 % mod;\n    }\n    if (b % 2 == 0) {\n        return power(mul(a, a), b / 2);\n    }\n    return mul(a, power(a, b - 1));\n}\n\nint inv(int x) {\n    return power(x, mod - 2);\n}\n\nconst int max_f = 2 * max_n;\n\nint f[max_f], rf[max_f];\n\nvoid get_all_f() {\n    f[0] = rf[0] = 1;\n    for (int i = 1; i < max_f; ++i) {\n        f[i] = mul(i, f[i - 1]);\n    }\n    rf[max_f - 1] = inv(f[max_f - 1]);\n    for (int i = max_f - 2; i > 0; --i) {\n        rf[i] = mul(i + 1, rf[i + 1]);\n    }\n}\n\nint get_c(int n, int k) {\n    if (n < k) {\n        return 0;\n    }\n    return mul(f[n], mul(rf[k], rf[n - k]));\n}\n\nint n, h, d, dp[max_n], sum[max_n];\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    get_all_f();\n    cin >> n >> h >> d;\n    int k = f[n];\n    int k2 = 0;\n    for (int i = 1; i <= n; ++i) {\n        k2 = (k2 + f[i]) % mod;\n    }\n    sum[0] = dp[0] = power(k2, mod - 2);\n    for (int i = 1; i <= h; ++i) {\n        dp[i] = sum[i - 1] + mod;\n        if (i - d - 1 >= 0) {\n            dp[i] -= sum[i - d - 1];\n        }\n        dp[i] = mul(dp[i], k2);\n        sum[i] = (sum[i - 1] + dp[i]) % mod;\n    }\n    cout << mul(k, dp[h]) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define LL long long\n#define PB push_back\n#define MP make_pair\n\n#define MOD 1000000007\n\n//累乗 O(log N)\nlong long power(long long x, long long N){\n\tif(N == 1) return x;\n\tlong long tmp = power(x, N/2);\n\tif(N%2 == 0) return tmp * tmp % MOD;\n\telse return tmp * tmp % MOD * x % MOD;\n}\n\n//逆元 O(log x)\nlong long inverse(long long x){\n\treturn power(x, MOD-2);\n}\n\n//コンビネーション\nstruct Combination{\nprivate:\n\tint N;\n\tvector<long long> fact, inv;\npublic:\n\tvoid init(int n){ //初期化する O(N)\n\t\tN = n;\n\t\tfact.push_back(1);\n\t\tinv.push_back(1);\n\t\tfor(long long i=1; i<=N; i++){\n\t\t\tfact.push_back(fact.back()*i%MOD);\n\t\t\tinv.push_back(inverse(fact.back()));\n\t\t}\n\t}\n\tlong long factorial(int n){\n\t\treturn fact[n];\n\t}\n\tlong long comb(int n, int k){ //nCkを求める O(1)\n\t\treturn fact[n] * inv[k] % MOD * inv[n-k] % MOD;\n\t}\n};\n\n//RSQ セグメント木\nstruct SegmentTree{\nprivate:\n\tint N;\n\tvector<long long> node;\n\tconst long long DEFAULT = 0LL;\npublic:\n\tvoid init(int n){ //初期化する O(N)\n\t\tnode.clear();\n\t\tN = 1;\n\t\twhile(N < n) N *= 2;\n\t\tfor(int i=0; i<2*N-1; i++) node.push_back(DEFAULT);\n\t}\n\tvoid update(int i, long long x){ //値を変更する O(log N)\n\t\ti += N - 1;\n\t\tnode[i] = x;\n\t\twhile(i > 0){\n\t\t\ti = (i-1)/2; //親の取得は(i-1)/2\n\t\t\tnode[i] = node[i*2+1] + node[i*2+2]; //子の取得はi*2+1,i*2+2\n\t\t}\n\t}\n\tlong long sum(int a, int b, int k=0, int l=0, int r=-1){ //[a,b)の和を求める O(log N)\n\t\tif(r == -1) r = N;\n\t\tif(r <= a || b <= l) return DEFAULT; //交差する場合\n\t\tif(a <= l && r <= b) return node[k]; //完全に含む場合\n\t\treturn sum(a, b, k*2+1, l, (l+r)/2) + sum(a, b, k*2+2, (l+r)/2, r);\n\t}\n};\n\nint N, H, D;\nCombination C;\nLL imp = 0;\nLL memo[1000001];\nSegmentTree st;\nLL solve(int now){\n\tif(now == H) return C.factorial(N-1);\n\tif(memo[now] != LLONG_MIN) return memo[now];\n\tLL ret = 0;\n\t/*for(int j=1; j<=D&&now+j<=H; j++){ //次どこ\n\t\tret += solve(now+j);\n\t\tret %= MOD;\n\t}*/\n\tret = st.sum(now+1, min(H, now+D)+1) % MOD;\n\tret *= imp;\n\tret %= MOD;\n\treturn memo[now] = ret;\n}\n\nint main(){\n\tcin >> N >> H >> D;\n\tC.init(N);\n\tst.init(H+1);\n\tfor(int i=0; i<=H; i++) memo[i] = LLONG_MIN;\n\timp = C.factorial(N-1)*N%MOD;\n\tfor(int k=1; k<N; k++){\n\t\timp += C.factorial(k)*C.comb(N-1-1, k-1);\n\t\timp %= MOD;\n\t}\n\tfor(int i=H; i>=0; i--) st.update(i, solve(i));\n\tLL ans = 0;\n\tfor(int i=1; i<=D; i++){\n\t\tans += solve(i)*N;\n\t}\n\tcout << ans%MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n#define MOD 1000000007\n#define MAX 2000200\nvoid add(int &x,int y){x+=y;if(x>=MOD)x-=MOD;}\nint n,H,D,jc[MAX],f[MAX],s[MAX];\nint fpow(int a,int b){int s=1;while(b){if(b&1)s=1ll*s*a%MOD;a=1ll*a*a%MOD;b>>=1;}return s;}\nint main()\n{\n    cin>>n>>H>>D;\n    jc[0]=1;for(int i=1;i<=n;++i)jc[i]=1ll*jc[i-1]*i%MOD;\n    int sj=0;for(int i=1;i<=n;++i)sj=(sj+jc[i])%MOD;\n    f[0]=s[0]=1;\n    for(int i=1;i<=H;++i)f[i]=1ll*sj*(s[i-1]+MOD-(i-D<=0?0:s[i-D-1]))%MOD,s[i]=(s[i-1]+f[i])%MOD;\n    int ans=1ll*f[H]*jc[n]%MOD*fpow(sj,MOD-2)%MOD;\n    printf(\"%d\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll maxn=1e6+10;\nconst ll mod=1e9+7;\nll n,h,d;\nll fac[maxn],sum[maxn];\nll fpow(ll a,ll k){\n    ll res=1;\n    while(k){\n        if(k&1)\n            res=res*a%mod;\n        a=a*a%mod;\n        k/=2;\n    }\n    return res;\n}\nll inv(ll a){\n    return fpow(a,mod-2);\n}\nint main(){\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    cin>>n>>h>>d;\n    ll t=1;//n的阶乘\n    ll s=1;//n的阶乘前缀和\n    for(ll i=2;i<=n;++i){\n        t=t*i%mod;\n        s=(s+t)%mod;\n    }\n    fac[0]=inv(s);//(1/(1+2!+...+n!))\n    sum[0]=fac[0];\n    for(ll i=1;i<=h;++i){\n        ll u=(sum[i-1]-(i>d?sum[i-d-1]:0)+mod)%mod;\n        fac[i]=u*s%mod;//fac[1]=sum[0]*s=1\n        sum[i]=(sum[i-1]+fac[i])%mod;//sum[1]=sum[0]+fac[1]\n    }\n    for(ll i=n;i>=1;--i)fac[h]=fac[h]*i%mod;\n    cout<<fac[h];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define LL long long\n#define PB push_back\n#define MP make_pair\n\n#define MOD 1000000007\n\n//累乗 O(log N)\nlong long power(long long x, long long N){\n\tif(N == 1) return x;\n\tlong long tmp = power(x, N/2);\n\tif(N%2 == 0) return tmp * tmp % MOD;\n\telse return tmp * tmp % MOD * x % MOD;\n}\n\n//逆元 O(log x)\nlong long inverse(long long x){\n\treturn power(x, MOD-2);\n}\n\n//コンビネーション\nstruct Combination{\nprivate:\n\tint N;\n\tvector<long long> fact, inv;\npublic:\n\tvoid init(int n){ //初期化する O(N)\n\t\tN = n;\n\t\tfact.push_back(1);\n\t\tinv.push_back(1);\n\t\tfor(long long i=1; i<=N; i++){\n\t\t\tfact.push_back(fact.back()*i%MOD);\n\t\t\tinv.push_back(inverse(fact.back()));\n\t\t}\n\t}\n\tlong long factorial(int n){\n\t\treturn fact[n];\n\t}\n\tlong long comb(int n, int k){ //nCkを求める O(1)\n\t\treturn fact[n] * inv[k] % MOD * inv[n-k] % MOD;\n\t}\n};\n\n//RSQ セグメント木\nstruct SegmentTree{\nprivate:\n\tint N;\n\tvector<long long> node;\n\tconst long long DEFAULT = 0LL;\npublic:\n\tvoid init(int n){ //初期化する O(N)\n\t\tnode.clear();\n\t\tN = 1;\n\t\twhile(N < n) N *= 2;\n\t\tfor(int i=0; i<2*N-1; i++) node.push_back(DEFAULT);\n\t}\n\tvoid update(int i, long long x){ //値を変更する O(log N)\n\t\ti += N - 1;\n\t\tnode[i] = x;\n\t\twhile(i > 0){\n\t\t\ti = (i-1)/2; //親の取得は(i-1)/2\n\t\t\tnode[i] = node[i*2+1] + node[i*2+2]; //子の取得はi*2+1,i*2+2\n\t\t}\n\t}\n\tlong long sum(int a, int b, int k=0, int l=0, int r=-1){ //[a,b)の和を求める O(log N)\n\t\tif(r == -1) r = N;\n\t\tif(r <= a || b <= l) return DEFAULT; //交差する場合\n\t\tif(a <= l && r <= b) return node[k]; //完全に含む場合\n\t\treturn sum(a, b, k*2+1, l, (l+r)/2) + sum(a, b, k*2+2, (l+r)/2, r);\n\t}\n};\n\nint N, H, D;\nCombination C;\nLL imp = 0;\nSegmentTree st;\nLL solve(int now){\n\tif(now == H) return C.factorial(N-1);\n\tLL ret = (st.sum(now+1, min(H, now+D)+1) % MOD) * imp;\n\treturn ret % MOD;\n}\n\nint main(){\n\tcin >> N >> H >> D;\n\tC.init(N);\n\tst.init(H+1);\n\timp = C.factorial(N-1) * N % MOD;\n\tfor(int k=1; k<N; k++){\n\t\timp += C.comb(N-1-1, k-1)*C.factorial(k-1);\n\t\timp %= MOD;\n\t}\n\tfor(int i=H; i>=0; i--) st.update(i, solve(i));\n\tLL ans = (st.sum(1, D+1) % MOD) * N;\n\tcout << ans%MOD << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nstatic const ll mod=1000000007;\nll N,H,D;\nll dp[2][1000005];\nll fac[1000005];\nint main(){\n  cin>>N>>H>>D;\n  fac[0]=1;ll sum=0;\n  for(ll i=1;i<=N;i++){\n    fac[i]=(fac[i-1]*i)%mod;\n    sum=(sum+fac[i])%mod;\n  }dp[1][0]=fac[N];\n  for(ll i=1;i<H;i++){\n  dp[1][i]=(sum*(dp[0][i-1]+dp[1][i-1]))%mod;\n    dp[0][i]=(dp[0][i-1]+dp[1][i-1])%mod;\n    if(0<=i-D)\n      dp[0][i]=(dp[0][i]-dp[1][i-D]+mod)%mod;\n  }ll ans=(dp[0][H-1]+dp[1][H-1])%mod;\n  cout<<ans<<endl;\n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n#define REP(i, n) for (int i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (int i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n    {1, 0}, {0, 1},  {-1, 0},  {0, -1},  // 4方向\n    {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n    {0, 0},                              // 自身\n};\ntemplate <class T>\ninline bool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T>\ninline bool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T, class S>\nvector<T> make_vec(size_t n, S x) {\n    return vector<T>(n, x);\n}\ntemplate <class T, class... Ts>\nauto make_vec(size_t n, Ts... ts) {\n    return vector<decltype(make_vec<T>(ts...))>(n, make_vec<T>(ts...));\n}\n\n// debug\ntemplate <class T>\nostream& operator<<(ostream& s, vector<T>& d) {\n    REP(i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \");\n    return s;\n}\ntemplate <class T>\nostream& operator<<(ostream& s, vector<vector<T>>& d) {\n    REP(i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\");\n    return s;\n}\ntemplate <class T, class S>\nostream& operator<<(ostream& s, pair<T, S>& p) {\n    s << \"{\" << p.first << \", \" << p.second << \"}\";\n    return s;\n}\ntemplate <class T, class S>\nostream& operator<<(ostream& s, map<T, S> m) {\n    for (auto it = m.begin(); it != m.end(); it++) {\n        s << *it << (next(it) == m.end() ? \"\" : \"\\n\");\n    }\n    return s;\n}\ntemplate <class T, class S>\nostream& operator<<(ostream& s, unordered_map<T, S> m) {\n    for (auto it = m.begin(); it != m.end(); it++) {\n        s << *it << (next(it) == m.end() ? \"\" : \"\\n\");\n    }\n    return s;\n}\n#ifdef _MY_DEBUG\n#define dump(...)                                                                                                     \\\n    cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), \\\n        cerr << \"*/\\n\\n\";\n#else\n#define dump(...)\n#define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail>\nvoid dump_func(Head&& h, Tail&&... t) {\n    cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...);\n}\n\nstruct Fast {\n    Fast() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n    }\n} fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 1000000007;\n// *************** TEMPLATE END ***************\n\ntemplate <class T>\nT pow(T x, int n, const T UNION = 1) {\n    T ret = UNION;\n    while (n) {\n        if (n & 1) ret *= x;\n        x *= x;\n        n >>= 1;\n    }\n    return ret;\n}\n\ntemplate <int MD>\nstruct ModInt {\n    int x;\n    static unordered_map<int, int> to_inv;\n    ModInt() : x(0) {}\n    ModInt(int x_) {\n        if ((x = x_ % MD + MD) >= MD) x -= MD;\n    }\n\n    ModInt& operator+=(ModInt that) {\n        if ((x += that.x) >= MD) x -= MD;\n        return *this;\n    }\n    ModInt& operator*=(ModInt that) {\n        x = (unsigned long long)x * that.x % MD;\n        return *this;\n    }\n    ModInt& operator-=(ModInt that) {\n        if ((x -= that.x) < 0) x += MD;\n        return *this;\n    }\n    ModInt& operator/=(ModInt that) {\n        x = (unsigned long long)x * that.inv().x % MD;\n        return *this;\n    }\n\n    ModInt operator-() const { return -x < 0 ? MD - x : -x; }\n    ModInt operator+(ModInt that) const { return ModInt(*this) += that; }\n    ModInt operator*(ModInt that) const { return ModInt(*this) *= that; }\n    ModInt operator-(ModInt that) const { return ModInt(*this) -= that; }\n    ModInt operator/(ModInt that) const { return ModInt(*this) /= that; }\n    bool operator==(ModInt that) const { return x == that.x; }\n    bool operator!=(ModInt that) const { return x != that.x; }\n    ModInt inv() const { return to_inv.count(this->x) ? to_inv[this->x] : (to_inv[this->x] = pow(*this, MD - 2).x); }\n    friend ostream& operator<<(ostream& s, ModInt<MD> a) {\n        s << a.x;\n        return s;\n    }\n    friend istream& operator>>(istream& s, ModInt<MD>& a) {\n        s >> a.x;\n        return s;\n    }\n};\ntemplate <int MD>\nunordered_map<int, int> ModInt<MD>::to_inv;\nusing mint = ModInt<MOD>;\n\nvector<mint> fact, fact_inv;\nvoid init_factorial(int n) {\n    fact = vector<mint>(n + 1, 1);\n    fact_inv = vector<mint>(n + 1);\n    for (int i = 0; i < n; i++) fact[i + 1] = fact[i] * (i + 1);\n    fact_inv[n] = mint(1) / fact[n];\n    for (int i = n - 1; i >= 0; i--) fact_inv[i] = fact_inv[i + 1] * (i + 1);\n    // for (int i = 0; i < n + 1; i++) assert(fact[i] * fact_inv[i] == 1);\n}\nmint comb(int n, int r) { return fact[n] * fact_inv[r] * fact_inv[n - r]; }\n\n// T0: 元の配列のモノイド\n// T1: T0に対する作用素モノイド\ntemplate <class T0, class T1>\nclass BaseSegmentTree {\n    // k番目のノードにのlazyを伝搬\n    void eval(int k, int len) {\n        // 定数倍高速化\n        if (lazy[k] == u1) return;\n        // len個分のlazy[k]を評価\n        node[k] = g(node[k], p(lazy[k], len));\n        if (k < N - 1) {\n            // 最下段でなければ下のlazyに伝搬\n            lazy[2 * k + 1] = f1(lazy[2 * k + 1], lazy[k]);\n            lazy[2 * k + 2] = f1(lazy[2 * k + 2], lazy[k]);\n        }\n        lazy[k] = u1;\n    }\n    // k番目のノード[l, r)について、[a, b)の範囲内にxを作用\n    void update(int a, int b, T1 x, int k, int l, int r) {\n        eval(k, r - l);\n        if (b <= l || r <= a) return;\n        if (a <= l && r <= b) {\n            lazy[k] = f1(lazy[k], x);\n            eval(k, r - l);\n        } else {\n            update(a, b, x, 2 * k + 1, l, (l + r) / 2);\n            update(a, b, x, 2 * k + 2, (l + r) / 2, r);\n            node[k] = f0(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n    // k番目のノード[l, r)について、[a, b)のクエリを求める\n    T0 query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return u0;\n        eval(k, r - l);\n        if (a <= l && r <= b) return node[k];\n        T0 vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        T0 vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return f0(vl, vr);\n    }\n\npublic:\n    int sz;  // 元の配列のサイズ\n    int N;\n    vector<T0> node;\n    vector<T1> lazy;\n    // T0上の演算、単位元\n    virtual T0 f0(T0, T0) = 0;\n    const T0 u0;\n    // T1上の演算、単位元\n    virtual T1 f1(T1, T1) = 0;\n    const T1 u1;\n    // 作用\n    virtual T0 g(T0, T1) = 0;\n    // 多数のt1(T1)に対するf1の合成\n    virtual T1 p(T1, int) = 0;\n\n    BaseSegmentTree(T0 u0, T1 u1) : u0(u0), u1(u1) {}\n    void set_by_vector(const vector<T0>& a) {\n        sz = a.size();\n        for (N = 1; N < sz; N *= 2)\n            ;\n        node.resize(2 * N - 1, u0);\n        lazy.resize(2 * N - 1, u1);\n        for (int i = 0; i < sz; i++) node[N - 1 + i] = a[i];\n        for (int i = N - 2; i >= 0; i--) node[i] = f0(node[2 * i + 1], node[2 * i + 2]);\n    }\n    void set_by_unit(int n) {\n        sz = n;\n        for (N = 1; N < sz; N *= 2)\n            ;\n        node.resize(2 * N - 1, u0);\n        lazy.resize(2 * N - 1, u1);\n    }\n    // [a, b)にxを作用\n    void update(int a, int b, T1 x) {\n        assert(0 <= a && a < b && b <= sz);\n        update(a, b, x, 0, 0, N);\n    }\n    void update(int a, T1 x) { update(a, a + 1, x); }\n    // [a, b)\n    T0 query(int a, int b) { return query(a, b, 0, 0, N); }\n    T0 query(int a) { return query(a, a + 1); }\n};\n\ntemplate <class T0, class T1>\nstruct SumAddQuery : public BaseSegmentTree<T0, T1> {\n    SumAddQuery() : BaseSegmentTree<T0, T1>(0, 0) {}\n    using BaseSegmentTree<T0, T1>::BaseSegmentTree;\n    T0 f0(T0 x, T0 y) override { return x + y; }\n    T1 f1(T1 x, T1 y) override { return x + y; }\n    T0 g(T0 x, T1 y) override { return x + y; }\n    T1 p(T1 x, int len) override { return x * len; }\n};\n\nsigned main() {\n    int n, H, D;\n    cin >> n >> H >> D;\n    init_factorial(n + 10);\n    mint mul = 0;\n    REPI(i, 1, n + 1) { mul += fact[i]; }\n\n    SumAddQuery<mint, mint> seg;\n    seg.set_by_unit(H + 1);\n    seg.update(0, fact[n] / mul);\n    REP (i, H) {\n        mint now = seg.query(i);\n        seg.update(i + 1, min(H + 1, i + D + 1), now * mul);\n    }\n    cout << seg.query(H) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████\n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬████╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);i--)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<vector<P> > Graph;\n\n#include <cstdint>\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n  using u64 = std::uint_fast64_t;\n\n  u64 a;\n\npublic:\n  constexpr modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n  constexpr u64 val() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr bool operator==(const modint rhs) const noexcept {\n    return modint(*this).value() == rhs.value();\n  }\n  modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\nusing mint = modint<MOD>;\n\ntypedef vector<mint> vec;\ntypedef vector<vector<mint>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,d,h;\n  cin >> n >> h >> d;\n\n  vec fact(n+10,1);\n  REP(i,n) fact[i+1] = fact[i]*(i+1);\n\n  mint mul = 0;\n  FOR(i,1,n+1) mul += fact[i];\n\n  vec dp(h+10,0), sum(h+10,0);\n  dp[1] = 1;\n  sum[1] = 1; sum[2] = mul+1;\n\n  FOR(i,2,h+1){\n    int u = max(0LL,i-d);\n    dp[i] = sum[i]-sum[u];\n    sum[i+1] = sum[i] + dp[i]*mul;\n  }\n\n  //REP(i,h+1) cout << dp[i].val() << endl;\n\n  cout << (dp[h]*fact[n]).val() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<math.h>\n#include<iomanip>\n#include<set>\n#include<numeric>\n#include<cstring>\n#include<cstdio>\n#include<functional>\n#include<bitset>\n#include<limits.h>\n#include<cassert>\n#include<iterator>\n#include<complex>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<time.h>\n#include<random>\n#include<array>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n#define rep(i, a, b) for(int i = a; i < b; i++)\n#define rrep(i, a, b) for(int i = b - 1; i >= a; i--)\n#define ALL(a) a.begin(), a.end()\nusing pii = pair<int,int>;\nusing piii = pair<pii,int>;\nusing pll = pair<long long, long long>;\nusing plll = pair<pll, long long>;\n// #pragma GCC optimize(\"Ofast\")\n// #define _GLIBCXX_DEBUG\n#define pcnt __builtin_popcount\n#define buli(x) __builtin_popcountll(x)\n#define pb push_back\n#define mp make_pair\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define isSquare(x) (sqrt(x)*sqrt(x) == x)\ntemplate<class T>inline bool chmax(T &a, const T &b) {if(a<b){a = b; return 1;} return 0; };\ntemplate<class T>inline bool chmin(T &a, const T &b) {if(a>b){a = b; return 1;} return 0; };\ninline void in(void){return;}\ntemplate <typename First, typename... Rest> void in(First& first, Rest&... rest){cin >> first;in(rest...);return;}\ninline void out(void){cout << \"\\n\";return;}\ntemplate <typename First, typename... Rest> void out(First first, Rest... rest){cout << first << \" \";out(rest...);return;}\nconst double EPS = 1e-9;\nconst int mod = 1e9 + 7;\n// const int mod = 998244353;\nconst int INF = 1e9;\nconst long long INFLL = 1e18;\nvoid iosetup() {\n    cin.tie(nullptr);ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n}\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 >& p) {\n    os << p.first << \" \" << p.second;\n    return os;\n}\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n    is >> p.first >> p.second;\n    return is;\n}\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n    for(int i = 0; i < (int) v.size(); i++) {\n        os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n    }\n    return os;\n}\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n    for(T &in : v) is >> in;\n    return is;\n}\ntemplate<class T> vector<T> make_vec(size_t a) {return vector<T>(a); }\ntemplate<class T, class... Ts> auto make_vec(size_t a, Ts... ts){\n    return vector<decltype(make_vec<T>(ts...))>(a, make_vec<T>(ts...));\n}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S, T>& t){return pair<S,T>(s.first-t.first, s.second-t.second);}\ntemplate<class S, class T> pair<S,T> operator*(const pair<S,T> &s, const S& t){return pair<S,T>(s.first*t, s.second*t);}\ntemplate <typename T> void Exit(T first){cout << first << endl;exit(0); };\ntemplate< int mod > struct ModInt {\n    unsigned x; ModInt() : x(0) {}\n    ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n    ModInt &operator+=(const ModInt &p) {if((x += p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator-=(const ModInt &p) {if((x += mod - p.x) >= mod) x -= mod;return *this;}\n    ModInt &operator*=(const ModInt &p) {x = (int) (1LL * x * p.x % mod);return *this;}\n    ModInt &operator/=(const ModInt &p) {*this *= p.inverse();return *this;}\n    ModInt operator-() const { return ModInt(-x); }\n    ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n    ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n    ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n    ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n    bool operator==(const ModInt &p) const { return x == p.x; }\n    bool operator!=(const ModInt &p) const { return x != p.x; }\n    ModInt inverse() const {int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) { t = a / b; swap(a -= t * b, b); swap(u -= t * v, v); }return ModInt(u);}\n    ModInt pow(int64_t n) const {ModInt ret(1), mul(x); while(n > 0) {if(n & 1) ret *= mul;mul *= mul;n >>= 1;}return ret;}\n    friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x;}\n    friend istream &operator>>(istream &is, ModInt &a) { int64_t t; is >> t; a = ModInt< mod >(t); return (is); }\n    static int get_mod() { return mod; }\n}; using modint = ModInt< mod >;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nconst pii dxy[4] = {pii(1,0), pii(0, 1), pii(-1, 0), pii(0, -1)};\n\n//----------------------- edit from here ---------------------------------\ntemplate< typename T >\nstruct Combination {\n    vector< T > _fact, _rfact, _inv;\n\n    Combination(int sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n        _fact[0] = _rfact[sz] = _inv[0] = 1;\n        for(int i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n        _rfact[sz] /= _fact[sz];\n        for(int i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n        for(int i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n    }\n\n    inline T fact(int k) const { return _fact[k]; }\n\n    inline T rfact(int k) const { return _rfact[k]; }\n\n    inline T inv(int k) const { return _inv[k]; }\n\n    T P(int n, int r) const {\n        if(r < 0 || n < r) return 0;\n        return fact(n) * rfact(n - r);\n    }\n\n    T C(int p, int q) const {\n        if(q < 0 || p < q) return 0;\n        return fact(p) * rfact(q) * rfact(p - q);\n    }\n\n    T H(int n, int r) const {\n        if(n < 0 || r < 0) return (0);\n        return r == 0 ? 1 : C(n + r - 1, r);\n    }\n};\n\nint main(){\n    iosetup();\n    int N, H, D; cin >> N >> H >> D;\n    auto dp = make_vec<modint>(H + 1);\n    Combination<modint> comb(N + 1);\n    modint tmp = 0;\n    rep(i, 1, N + 1) tmp += comb.P(i, i);\n    // tmp += comb.P(N, N);\n    // cerr << tmp << endl;\n\n    rep(i, 1, D + 1) dp[i] = N;\n\n    rep(i, 1, H){\n        dp[i] += dp[i-1];\n        dp[i+1] += dp[i] * tmp;\n        if(i+D+1<=H) dp[i+D+1] -= dp[i] * tmp;\n    }\n    modint ans = dp[H] * comb.fact(N-1);\n    cout << ans << endl;\n    // cout << dp[H] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MOD 1000000007\n\nlong long totient(long long a) {\n\tll ret = a;\n\tfor(int i = 2;i * i <= a;i++){\n\t\tif(a % i == 0){\n\t\t\tret = ret * (i - 1) / i;\n\t\t\twhile(a % i == 0)a /= i;\n\t\t}\n\t}\n\tif(a > 1)ret = ret * (a - 1) / a;\n\treturn ret;\n}\n\n// a / b (mod p) b と p は互いに素\n// O(sqrt(p))かかるので注意\nlong long totient_div(long long a, long long b, long long p) {\n\tlong long ret = a;\n\tlong long tp = totient(p) - 1;\n\tlong long c = b;\n\tfor(int i = 0;i <= 60;i++){\n\t\tif(tp & (1LL << i))ret = (ret * c) % p;\n\t\tc = (c * c) % p;\n\t}\n\treturn ret;\n}\n\n//a^b % MOD\nlong long mod_pow(ll a,ll b){\n\tlong long ret = 1;\n\tlong long c = a;\n\tfor(int i = 0;i <= 60;i++){\n\t\tif(b & (1LL << i))ret = (ret * c) % MOD;\n\t\tc = (c * c) % MOD;\n\t}\n\treturn ret;\n}\n\n//ａをbで割る\nlong long mod_div(long long a,long long b){\n\tlong long tmp = MOD - 2,c = b,ret = 1;\n\twhile(tmp > 0){\n\t\tif(tmp & 1){\n\t\t\tret *= c;ret %= MOD;\n\t\t}\n\t\tc *= c;c %= MOD;tmp >>= 1;\n\t}\n\treturn a*ret%MOD;\n}\n\n#define MAX_K 333333\nvector<long long> kaijo(MAX_K);\nlong long combination(long long n, long long r){\n    if(n < r || n < 0 || r < 0)\n        return 0;\n\tif(kaijo[0] != 1){\n\t\tkaijo[0] = 1;\n\t\tfor(long long i = 1;i < MAX_K;i++)kaijo[i] = (kaijo[i-1] * i) % MOD;\n\t}\n    long long ret = kaijo[n];\n\tlong long tmp = (kaijo[r] * kaijo[n-r]) % MOD;\n    return mod_div(ret,tmp);\n}\n\n\nll dp[1111111];\nll fact[1111111];\nll factAcc[1111111];\n\nvoid calFact(){\n\tfact[0] = 1;\n\tREP(i, 1111110) {\n\t\tfact[i+1] = fact[i] * (i+1) % MOD;\n\t\tfactAcc[i+1] = (factAcc[i] + fact[i+1]) % MOD;\n\t}\n}\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\tcalFact();\n\tll n, d, h;cin >> n >> h >> d;\n\tdp[0] = mod_div(1, factAcc[n]);\n\tll sum = 0;\n\tll l = 0;\n\n\tREP(i, h){\n\t\tsum = (sum + dp[i] * factAcc[n] % MOD) % MOD;\n\t\twhile(l < i && i - l >= d){\n\t\t\tsum = (sum + MOD - dp[l] * factAcc[n] % MOD) % MOD;\n\t\t\tl++;\n\t\t}\n\t\tdp[i+1] = sum;\n\t}\n\n\tcout << dp[h] * fact[n] % MOD << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\nconstexpr dd PI  = 3.1415926535897932;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E)  for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S)  for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define each(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll sz(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll Upper2N(ll s) { return 1LL<<MSB(s)<<1; }//s<2^nなる最小の2^n\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\n[[nodiscard]] inline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\n[[nodiscard]] inline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\n[[nodiscard]] inline ll BitCut(ll s, ll i){ return s & (1LL<<++i)-1; }//sの第0～第ibitを抽出\ninline vll str2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'0'); return move(v);}\ninline vll ALP2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'A'); return move(v);}\ninline vll alp2num(string &s, ll N) {vll v(N); REP(i, N) v[i]=(ll)(s[i]-'a'); return move(v);}\ntemplate<class T> inline ll FloorIdx(vector<T> &v, T x){ return upper_bound(ALL(v), x)-v.begin()-1; }\ntemplate<class T> inline ll CeilIdx(vector<T> &v, T x){ return lower_bound(ALL(v), x)-v.begin(); }\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T, class S> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T> inline vector<T> cinv2(ll N){\n\tvector<T> v(N); REP(i, N){ll a, b; cin>>a>>b; v[i]={a,b};} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> inline void coutv(deque<T> &v, string d=\" \"){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?\"\":d);} cout<<'\\n';}\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T, class S> void Dump(map<T, S> &m){\n\tfor(auto e: m) cout << e.first << \" : \" << e.second << '\\n';\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\nstruct Combination{\n\tvmll f, g; // factorial, factorial^-1\n\tCombination(){}\n\tCombination(ll maxN): f(maxN+1, 1), g(maxN+1){ InitSub(maxN); }\n\tvoid init(ll maxN){ f.resize(maxN+1, 1); g.resize(maxN+1); InitSub(maxN); }\n\tmll operator () (ll n, ll r){ return (n<0||r<0||n<r) ? mll(0) : f[n]*g[n-r]*g[r]; }//nCr\n\tmll P(ll n, ll r){ return (n<0 || r<0 || n<r) ? mll(0) : f[n]*g[n-r]; } //nPr\n\tmll inv(ll n) { return f[n-1] * g[n]; } //1/n\n\tmll fact(ll n) { return f[n]; } //n!\n\tmll finv(ll n) { return g[n]; } //1/n!\n\tvoid InitSub(ll maxN){\n\t\tREPS(i, 1, maxN){ f[i] = f[i-1] * i; }\n\t\tg[maxN] = 1 / f[maxN];\n\t\tDEPS(i, 1, maxN){ g[i-1] = g[i] * i; }\n\t}\n};\n\ntemplate <class T> struct CumulativeSumG{\n\tll s=0, e=-1;  vector<T> cum;\n\tCumulativeSumG(){};\n\tCumulativeSumG(vector<T> &v): e(v.size()-1), cum(e+2) { ini(v); }\n\tCumulativeSumG(vector<T> &v, ll S, ll E): s(S), e(E), cum(e-s+2){ ini(v); }\n\tvoid Init(vector<T> &v){ e=v.size()-1; cum.resize(e+2); ini(v); }\n\tvoid Init(vector<T> &v, ll S, ll E){ s=S; e=E; cum.resize(e-s+2); ini(v); }\n\tvoid Add(T x) { e++; cum.push_back(cum.back() + x); }\n\tT operator () (ll begin, ll end){ return cum[end+1-s] - cum[begin-s]; }\n\tvoid ini(vector<T> &v) { REPS(i, s, e) cum[i+1-s] = cum[i-s] + v[i]; }\n};\nusing CumulativeSum = CumulativeSumG<mll>;\n\n\nvoid solve()\n{\n\tll n, h, D;  cin >> n >> h >> D;\n\tCombination cmb(n+10);\n\tmll nn=cmb.fact(n);//n!\n\tmll sn=0;//Σi!\n\trep(i, 1, n) sn+=cmb.fact(i);\n\n\tvmll dp(h+1);\n\tauto Dp = [&](ll i)->mll&{\n\t\treturn dp[i];\n\t};\n\tDp(0)=1;\n\n\tCumulativeSum cm(dp, 0, 0);\n\n\trep(i, 1, h){\n\t\tif (i<=D){\n\t\t\tDp(i)=nn+sn*cm(1, i-1);\n\t\t}\n\t\telse{\n\t\t\tDp(i)=sn*cm(i-D, i-1);\n\t\t}\n\t\tcm.Add(Dp(i));\n\t}\n\n\tcout << Dp(h) << '\\n';\n}\n\nint main(){\n#if 1\n\tsolve();\n#else\n\tll t;  cin >> t;\n\trep(i, 0, t-1){\n\t\tsolve();\n\t}\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int mod = 1000000007;\n\nint N, H, D;\nll DP[1000000], S[1000000], t;\n\nll s(int x) {\n\tif (x - D - 1 >= 0)\n\t\treturn (S[x - 1] + mod - S[x - D - 1]) % mod;\n\telse\n\t\treturn S[x - 1];\n}\n\nint main() {\n\tcin >> N >> H >> D;\n\tll tmp = 1;\n\tfor (ll i = 1; i <= N; i++) {\n\t\ttmp *= i;\n\t\ttmp %= mod;\n\t\tt += tmp;\n\t\tt %= mod;\n\t}\n\tDP[0] = S[0] = tmp;\n\tfor (int i = 1; i < H; i++) {\n\t\tDP[i] = s(i)*t%mod;\n\t\tS[i] = (S[i - 1] + DP[i]) % mod;\n\t}\n\tcout << s(H) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> p_ll;\n\ntemplate<class T>\nvoid debug(T itr1, T itr2) { auto now = itr1; while(now<itr2) { cout << *now << \" \"; now++; } cout << endl; }\n#define repr(i,from,to) for (int i=(int)from; i<(int)to; i++)\n#define all(vec) vec.begin(), vec.end()\n#define rep(i,N) repr(i,0,N)\n#define per(i,N) for (int i=(int)N-1; i>=0; i--)\n\nconst ll MOD = pow(10,9)+7;\nconst ll LLINF = pow(2,61)-1;\nconst int INF = pow(2,30)-1;\n\nvector<ll> fac;\nvoid c_fac(int x=pow(10,6)+10) { fac.resize(x,true); rep(i,x) fac[i] = i ? (fac[i-1]*i)%MOD : 1; }\nll inv(ll a, ll m=MOD) { ll b = m, x = 1, y = 0; while (b!=0) { int d = a/b; a -= b*d; swap(a,b); x -= y*d; swap(x,y); } return (x+m)%m; }\nll nck(ll n, ll k) { return fac[n]*inv(fac[k]*fac[n-k]%MOD)%MOD; }\nll gcd(ll a, ll b) { if (a<b) swap(a,b); return b==0 ? a : gcd(b, a%b); }\nll lcm(ll a, ll b) { return a/gcd(a,b)*b; }\n\n\nint main() {\n  ll N, H, D; cin >> N >> H >> D;\n  c_fac();\n  ll facsum = 0; repr(i,1,N+1) facsum = (facsum+fac[i]) % MOD;\n\n  ll dp[H+1] = {}; dp[0] = 1;\n  rep(i,H) {\n    if (i<D) dp[i+1] = ((dp[i]-dp[0])*facsum+fac[N]) % MOD;\n    else dp[i+1] = (dp[i]-dp[i-D]+MOD) * facsum % MOD;\n    dp[i+1] = (dp[i] + dp[i+1]) % MOD;\n  }\n  // debug(dp,dp+(H+1));\n\n  ll result = (dp[H] - dp[H-1] + MOD) % MOD;\n  cout << result << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#include <cmath>\n#include <cassert>\n#include <string>\n#define SIZE 1000005\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll dp[SIZE];\nll rdp[SIZE];\n\nint main()\n{\n\tint N,H,D;\n\tscanf(\"%d %d %d\",&N,&H,&D);\n\tll fac=1,coef=0;\n\tfor(ll i=1;i<=N;i++)\n\t{\n\t\tfac=fac*(ll) i%MOD;\n\t\tcoef+=fac;\n\t\tif(coef>=MOD) coef-=MOD;\n\t}\n\tfor(int i=1;i<=H;i++)\n\t{\n\t\tll sum=rdp[i-1]-(i-D-1<0?0:rdp[i-D-1]);\n\t\tif(sum<0) sum+=MOD;\n\t\tsum=sum*coef%MOD;\n\t\tif(i<=D)\n\t\t{\n\t\t\tsum+=fac;\n\t\t\tif(sum>=MOD) sum-=MOD;\n\t\t}\n\t\tdp[i]=sum;\n\t\trdp[i]=rdp[i-1]+sum;\n\t\tif(rdp[i]>=MOD) rdp[i]-=MOD;\n\t}\n\tprintf(\"%lld\\n\",dp[H]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// https://atcoder.jp/contests/diverta2019-2/tasks/diverta2019_2_e\n/*<head>*/\n// #include \"ModInt.hpp\"\n/*</head>*/\n\n/*<body>*/\n/* #region header */\n/* #region 1*/\n/**\n * @file Template.hpp\n * @brief 競技プログラミング用テンプレート\n * @author btk15049\n * @date 2019/05/02\n */\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* #region macro */\n#ifdef BTK\n#    define DEBUG if (1)\n#    define CIN_ONLY if (0)\n#else\n#    define DEBUG if (0)\n#    define CIN_ONLY if (1)\n#endif\n/** @def\n * ALLマクロ\n */\n#define ALL(v) (v).begin(), (v).end()\n\n/** @def\n * 再帰ラムダをするためのマクロ\n */\n#define REC(ret, ...) std::function<ret(__VA_ARGS__)>\n/* #endregion */\n\nnamespace _Template_ {\n    /**\n     * @brief cin高速化処理を行うための構造体\n     * @details CIN_ONLYマクロで動作が変わる\n     */\n    struct cww {\n        cww() {\n            CIN_ONLY {\n                ios::sync_with_stdio(false);\n                cin.tie(0);\n            }\n        }\n    } star;\n    /**\n     * @brief change min\n     * @tparam T 型\n     * @param l 参照\n     * @param r 非参照\n     * @return 更新があればtrue\n     */\n    template <typename T>\n    inline bool chmin(T& l, T r) {\n        bool a = l > r;\n        if (a) l = r;\n        return a;\n    }\n    /**\n     * @brief chminのmax版\n     * @see chmin\n     */\n    template <typename T>\n    inline bool chmax(T& l, T r) {\n        bool a = l < r;\n        if (a) l = r;\n        return a;\n    }\n    /**\n     * @brief\n     * vectorに直接cin流すためのやつ\n     * @tparam T\n     * @param is\n     * @param v\n     * @return istream&\n     */\n    template <typename T>\n    istream& operator>>(istream& is, vector<T>& v) {\n        for (auto& it : v) is >> it;\n        return is;\n    }\n    /**\n     * @brief\n     * rangeを逆向きに操作したいとき用\n     * @details\n     * ループの範囲は[bg,ed)なので注意\n     * @see range\n     */\n    class reverse_range {\n      private:\n        struct I {\n            int x;\n            int operator*() { return x - 1; }\n            bool operator!=(I& lhs) { return x > lhs.x; }\n            void operator++() { --x; }\n        };\n        I i, n;\n\n      public:\n        reverse_range(int n) : i({0}), n({n}) {}\n        reverse_range(int i, int n) : i({i}), n({n}) {}\n        I& begin() { return n; }\n        I& end() { return i; }\n    };\n    /**\n     * @brief\n     * python みたいな range-based for を実現\n     * @details\n     * ループの範囲は[bg,ed)なので注意\n     * !つけると逆向きにループが回る (reverse_range)\n     * 空間計算量はO(1)\n     * 使わない変数ができて警告が出がちなので，unused_varとかを使って警告消しするとよい\n     */\n    class range {\n      private:\n        struct I {\n            int x;\n            int operator*() { return x; }\n            bool operator!=(I& lhs) { return x < lhs.x; }\n            void operator++() { ++x; }\n        };\n        I i, n;\n\n      public:\n        range(int n) : i({0}), n({n}) {}\n        range(int i, int n) : i({i}), n({n}) {}\n        I& begin() { return i; }\n        I& end() { return n; }\n        reverse_range operator!() { return reverse_range(*i, *n); }\n    };\n    /**\n     * @brief\n     * rangeで生まれる使わない変数を消す用（警告消し）\n     */\n    template <typename T>\n    inline T& unused_var(T& v) {\n        return v;\n    }\n    using LL = long long;\n} // namespace _Template_\nusing namespace _Template_;\n/* #endregion */\n/* #region 2*/\n\n/**\n * @file ModInt.hpp\n * @brief mod構造体\n * @author btk15049\n * @date 2019/03/08\n * @datails\n *  \\todo verifyが足りない\n *  verify: CSA12E，RUPC day3 F\n */\n\n//! [WARNING!] mod が入力で与えられる場合はconstexprを外す\nconstexpr int mod = 1e9 + 7;\n\nnamespace _ModInt_ {\n    /**\n     * @brief mod構造体\n     * @details\n     * 整数をラップして，常に保持されているデータがmodされた状態になるよう管理．\n     */\n    class ModInt {\n      private:\n        //! 中身\n        int x;\n\n      public:\n        /**\n         * @brief ゲッター\n         * @details 出力時などは \"cout << *ret << endl;\"のようにやるとよい．\n         */\n        long long operator*() const { return x; }\n        /**\n         * @brief デフォルトコンストラクタ．0で初期化される．\n         */\n        ModInt() { x = 0; }\n\n        /**\n         * @brief intからのコンストラクタ\n         * @param[in] y 設定したい値\n         * @details\n         * modをとらないので高速．ただしmodより大きい値や負の数を入れると事故るので注意．\n         */\n        ModInt(const int y) { x = y; }\n\n        /**\n         * @brief long longからのコンストラクタ\n         * @param[in] y 設定したい値\n         * @details 毎回modを取るので低速．\n         */\n        ModInt(const long long y) { x = (int)((mod + y % mod) % mod); }\n\n        /**\n         * @brief ModIntからの代入演算子\n         * @param[in] o 設定したい値\n         * @details 高速\n         */\n        ModInt(const ModInt& o) { this->x = *o; }\n        /**\n         * @brief 整数から高速にModIntを作りたいときに使う\n         * @param[in] x 設定したい値\n         * @details xが[0,mod)であることが保証されてないと正しく動かない．\n         */\n        static inline ModInt raw(const long long x) {\n            // assert(x<mod);\n            return ModInt((int)x);\n        }\n\n        /**\n         * @brief 整数から安全にModIntを作りたいときに使う\n         * @param[in] x 設定したい値\n         * @details mod2回取るから遅い．負数でもOK．\n         */\n        static inline ModInt get(const long long x) { return ModInt(x); }\n\n        /**\n         * @brief intからの代入演算子\n         * @param[in] o 設定したい値\n         * @details\n         * modをとらないので高速．ただしmodより大きい値や負の数を入れると事故るので注意．\n         */\n        ModInt& operator=(const int o) {\n            this->x = o >= mod ? o - mod : o;\n            return *this;\n        }\n\n        /**\n         * @brief long longからの代入演算子\n         * @param[in] o 設定したい値\n         * @details mod2回取るから遅い．負数でもOK．\n         */\n        ModInt& operator=(const long long o) {\n            this->x = (int)((mod + o % mod) % mod);\n            return *this;\n        }\n\n        /**\n         * @brief ModIntからの代入演算子\n         * @param[in] o 設定したい値\n         * @details 高速\n         */\n        ModInt& operator=(const ModInt o) {\n            this->x = *o;\n            return *this;\n        }\n    };\n\n    /**\n     * @param[in] l ModInt\n     * @param[in] r ModInt\n     * @details if文使って少し高速化．\n     */\n    inline ModInt add(const ModInt l, const ModInt r) {\n        const long long x = *l + *r;\n        return ModInt::raw(x >= mod ? x - mod : x);\n    }\n\n    /**\n     * @param[in] l ModInt\n     * @param[in] r ModInt．\n     */\n    inline ModInt mul(const ModInt l, const ModInt r) {\n        return ModInt::raw(*l * *r % mod);\n    }\n\n    /**\n     * @brief a^x %modを求める\n     * @param[in] a ModInt\n     * @param[in] x long long．\n     */\n    inline ModInt pow(ModInt a, long long x) {\n        ModInt ret = ModInt::raw(1);\n        while (x) {\n            if (x & 1) {\n                ret = mul(ret, a);\n            }\n            a = mul(a, a);\n            x >>= 1;\n        }\n        return ret;\n    }\n\n    /**\n     * @brief x^-1 %modを求める\n     * @param[in] x ModInt．\n     * @details\n     *   内部ではユークリッドの拡張互助法を使っている．\n     *   O(log(mod))\n     */\n    inline ModInt inv(const ModInt x) {\n        long long a = *x, b = mod, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            swap(a -= t * b, b);\n            swap(u -= t * v, v);\n        }\n        return ModInt::get(u);\n    }\n\n    /**\n     * @brief 負数を求める単項演算子\n     * @param[in] x ModInt\n     */\n    inline ModInt operator-(const ModInt x) { return add(mod, -*x); }\n\n    /**\n     * @param[in] l ModInt\n     * @param[in] r ModInt\n     */\n    inline ModInt operator+(const ModInt l, const ModInt r) {\n        return add(l, r);\n    }\n\n    /**\n     * @param[in] l ModInt\n     * @param[in] r ModInt\n     */\n    inline ModInt operator*(const ModInt l, const ModInt r) {\n        return mul(l, r);\n    }\n\n    /**\n     * @param[in] l ModInt\n     * @param[in] r ModInt\n     */\n    inline ModInt operator-(const ModInt l, const ModInt r) {\n        return add(l, -r);\n    }\n\n    /**\n     * @param[in] l ModInt\n     * @param[in] r int\n     * @details\n     * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n     */\n    inline ModInt operator+(const ModInt l, const int r) {\n        return add(l, ModInt::raw(r));\n    }\n\n    /**\n     * @param[in] l ModInt\n     * @param[in] r int\n     */\n    inline ModInt operator+(const ModInt l, const long long r) {\n        return add(l, ModInt::get(r));\n    }\n\n    /**\n     * @param[in] l ModInt\n     * @param[in] r int\n     * @details\n     * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n     */\n    inline ModInt operator*(const ModInt l, const int r) {\n        return mul(l, ModInt::raw(r));\n    }\n\n    /**\n     * @param[in] l ModInt\n     * @param[in] r int\n     */\n    inline ModInt operator*(const ModInt l, const long long r) {\n        return mul(l, ModInt::get(r));\n    }\n\n    /**\n     * @param[in] l ModInt\n     * @param[in] r int\n     * @details\n     * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n     */\n    inline ModInt operator-(const ModInt l, const int r) {\n        return add(l, ModInt::raw(mod - r));\n    }\n\n    /**\n     * @param[in] l ModInt\n     * @param[in] r int\n     */\n    inline ModInt operator-(const ModInt l, const long long r) {\n        return add(l, -ModInt::get(r));\n    }\n\n    /**\n     * @param[in] l ModInt\n     * @param[in] r int\n     * @details\n     * 右辺は定数を想定しているのでmodをとらないrawを使ってModIntに変換している．ただしmodより大きい値や負の数を入れると事故るので注意．\n     */\n    inline ModInt operator/(const ModInt l, const int r) {\n        return mul(l, inv(ModInt::raw(r)));\n    }\n\n    /**\n     * @param[in] l ModInt\n     * @param[in] r int\n     */\n    inline ModInt operator/(const ModInt l, const long long r) {\n        return mul(l, inv(ModInt::get(r)));\n    }\n\n    /**\n    * @param[in] l ModInt\n    * @param[in] r long long\n    * @details\n    *   pow(l,r)を呼び出すだけなのでpowを参照のこと．\n    計算量はO(log mod)\n    */\n    inline ModInt operator^(const ModInt l, const long long r) {\n        return pow(l, r);\n    }\n\n    /**\n     * @brief\n     * +=の実装、各operator+を呼ぶだけ\n     * @tparam T\n     * @param l ModInt\n     * @param r 足すやつ\n     * @return ModInt&\n     */\n    template <typename T>\n    ModInt& operator+=(ModInt& l, T r) {\n        l = l + r;\n        return l;\n    }\n\n    /**\n     * @brief\n     * -=の実装、各operator-を呼ぶだけ\n     * @tparam T\n     * @param l ModInt\n     * @param r 引くやつ\n     * @return ModInt&\n     */\n    template <typename T>\n    ModInt& operator-=(ModInt& l, T r) {\n        l = l - r;\n        return l;\n    }\n\n    /**\n     * @brief\n     * *=の実装、各operator*を呼ぶだけ\n     * @tparam T\n     * @param l ModInt\n     * @param r かけるやつ\n     * @return ModInt&\n     */\n    template <typename T>\n    ModInt& operator*=(ModInt& l, T r) {\n        l = l * r;\n        return l;\n    }\n\n    /**\n     * @namespace factorial\n     * @brief 順列数関連の関数のまとめ\n     * @details\n     *   - combination\n     *   - permutation\n     */\n    namespace factorial {\n        //! 順列数を格納する配列のサイズ\n        constexpr int size = 1123456;\n\n        //! 前計算ができているかどうかのフラグ\n        bool is_build = false;\n\n        //! 順列数を格納する配列\n        ModInt factorial[size];\n        //! (順列数)^-1を格納する配列\n        ModInt inverse_factorial[size];\n\n        /**\n         * @brief 順列数の前計算\n         * @details\n         *   順列数と，その逆元を[0,size)まで求める.\n         *   計算量は，O(size + log(mod))\n         */\n        void build() {\n            is_build     = true;\n            factorial[0] = 1;\n            for (int i = 1; i < size; i++) {\n                factorial[i] = factorial[i - 1] * i;\n            }\n            inverse_factorial[size - 1] = inv(factorial[size - 1]);\n            for (int i = size - 1; i >= 1; i--) {\n                inverse_factorial[i - 1] = inverse_factorial[i] * i;\n            }\n        }\n\n        /**\n         * @brief nPkを求める\n         * @details\n         *   前計算がしてあれば O(1)．前計算してない場合は is_build\n         * を読み取って前計算をする．\n         */\n        inline ModInt permutation(int n, int k) {\n            if (k < 0 || k > n) return ModInt::raw(0);\n            if (!is_build) build();\n            return factorial[n] * inverse_factorial[n - k];\n        }\n\n        /**\n         * @brief nCkを求める\n         * @details\n         *   前計算がしてあれば O(1)．前計算してない場合は is_build\n         * を読み取って前計算をする．\n         */\n        inline ModInt combination(int n, int k) {\n            if (k < 0 || k > n) return ModInt::raw(0);\n            if (!is_build) build();\n            return factorial[n] * inverse_factorial[k]\n                   * inverse_factorial[n - k];\n        }\n    } // namespace factorial\n} // namespace _ModInt_\nusing namespace _ModInt_;\n/* #endregion */\n/* #endregion */\n/*</body>*/\nint N, D, H;\nModInt dp[2123456];\nint main() {\n    cin >> N >> H >> D;\n    ModInt K = 0;\n    for (int i : range(1, N + 1)) {\n        K += factorial::permutation(i, i);\n    }\n    dp[1]     = factorial::permutation(N, N);\n    dp[D + 1] = -factorial::permutation(N, N);\n    ModInt c  = 0;\n    for (int i : range(1, H + 1)) {\n        c += dp[i];\n        dp[i + 1] += c * K;\n        dp[i + D + 1] -= c * K;\n    }\n    cout << (*c) << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\n#define N 500000\nll MOD=1e9+7;\n\nll mat[11][11];\n//遅延評価\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree\n{\n  using F = function< Monoid(Monoid, Monoid) >;\n  using G = function< Monoid(Monoid, OperatorMonoid) >;\n  using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n  using P = function< OperatorMonoid(OperatorMonoid, int) >;\n \n  int sz;\n  vector< Monoid > data;\n  vector< OperatorMonoid > lazy;\n  const F f;\n  const G g;\n  const H h;\n  const P p;\n  const Monoid M1;\n  const OperatorMonoid OM0;\n \n \n  LazySegmentTree(int n, const F f, const G g, const H h, const P p,\n                  const Monoid &M1, const OperatorMonoid OM0)\n      : f(f), g(g), h(h), p(p), M1(M1), OM0(OM0)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    data.assign(2 * sz, M1);\n    lazy.assign(2 * sz, OM0);\n  }\n \n  void set(int k, const Monoid &x)\n  {\n    data[k + sz] = x;\n  }\n \n  void build()\n  {\n    for(int k = sz - 1; k > 0; k--) {\n      data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n    }\n  }\n \n  void propagate(int k, int len)\n  {\n    if(lazy[k] != OM0) {\n      if(k < sz) {\n        lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n        lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      }\n      data[k] = g(data[k], p(lazy[k], len));\n      lazy[k] = OM0;\n    }\n  }\n \n  Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r)\n  {\n    propagate(k, r - l);\n    if(r <= a || b <= l) {\n      return data[k];\n    } else if(a <= l && r <= b) {\n      lazy[k] = h(lazy[k], x);\n      propagate(k, r - l);\n      return data[k];\n    } else {\n      return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n                         update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n    }\n  }\n \n  Monoid update(int a, int b, const OperatorMonoid &x)\n  {\n    return update(a, b, x, 1, 0, sz);\n  }\n \n \n  Monoid query(int a, int b, int k, int l, int r)\n  {\n    propagate(k, r - l);\n    if(r <= a || b <= l) {\n      return M1;\n    } else if(a <= l && r <= b) {\n      return data[k];\n    } else {\n      return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n               query(a, b, 2 * k + 1, (l + r) >> 1, r));\n    }\n  }\n \n  Monoid query(int a, int b)\n  {\n    return query(a, b, 1, 0, sz);\n  }\n \n  Monoid operator[](const int &k)\n  {\n    return query(k, k + 1);\n  }\n};\nauto f=[](ll a,ll b){return (a+b)%MOD;};\nauto g=[](ll a,ll b){return (a*b)%MOD;};\nauto ff=[](ll a,ll b){return b;};\nauto h=[](ll a,ll b){return (ll)max(a,b);};\nauto p=[](ll a,ll b){return a;};\n//例\n//区間add　区間min\nLazySegmentTree<ll> dp(1100000,h,f,f,p,INF,0);\n//区間add 区間sum\n//LazySegmentTree<ll> seg(n,f,f,f,g,0,0);\n \n \n//LazySegmentTree(n,f,g,h,p,M1,OM0) \n//サイズnで初期化\n//fは二つの区間の要素をマージする二項演算\n//gは要素と作用素をマージする二項演算(第三因数は区間の長さ)\n//hは作用素同士をマージする二項演算\n//p(value,length)は作用素を下におろした時の演算\n//M1はモノイドの単位元\n//OM0は作用素の単位元\n//update(a,b,x) 区間[a,b)に作用素 x を作用\n//query(a,b) 区間[a,b) の値\nmain(){\n    ll n=in(),h=in(),d=in();\n    //LazySegmentTree<ll> dp(h+d+100,h,f,f,p,LLINF,0ll);\n    dp.update(0,1,n);\n    ll ans=0;\n    rep2(i,0,h-1){\n        if(i+d<h){\n            dp.update(i,i+d+1,dp[i]*((n*(n+1)/2)%MOD)%MOD);\n        }\n        else{\n            ans=(ans+dp[i])%MOD;\n        }\n        /*rep2(j,i+1,i+d){\n            if(j==h)dp[j]=(dp[j]+dp[i])%MOD;\n            else\n            dp[j]=(dp[j]+dp[i]*((n*(n+1)/2)%MOD)%MOD)%MOD;\n        }*/\n    }\n    cout<<ans%MOD;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  long long N,H,D;\n  cin >> N >> H >> D;\n  vector<long long> dp[H+1,0];\n  long long ii = 1;\n  long long ic;\n  long long iii = 0;\n  for (int i=1; i<N+1; i++) {\n    ic = i;\n    ii *= ic;\n    ii %= 1000000007;\n    iii += ii * ic;\n    iii %= 1000000007;\n  }\n  dp[0] += ii;\n  for (int i=1; i<H+1) {\n    if (i == H) {\n      dp[H] = dp[H-1] * 2;\n      dp[H] %= 1000000007;\n      dp[H] += 1000000007;\n      dp[H] -= dp[H-D-1];\n      dp[H] %= 1000000007;\n    }\n      \n    dp[i] = dp[i-1] * 2;\n    if (i > D) {\n      dp[i] += 1000000007;\n      dp[i] -= dp[i-D-1];\n    }\n    dp[i] %= 1000000007;\n    dp[i] *= iii;\n    dp[i] %= 1000000007;\n  }\n  \n  cout << dp[H] << endl;\n    \n    \n    \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 1000100\nconst int mod=1e9+7;\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,D,H,s[N],dp[N],sum,fac[N];\nint qpow(int a,int b){\n\tint ans=1;\n\twhile(b){\n\t\tif(b&1)ans=1LL*ans*a%mod;\n\t\ta=1LL*a*a%mod;\n\t\tb>>=1;\n\t}\n\treturn ans;\n}\nvoid init(int n){\n\tfac[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfac[i]=1LL*fac[i-1]*i%mod;\n\t\tsum=(sum+fac[i])%mod;\n\t}\n}\nint main(){\n\tn=read(),H=read(),D=read();\n\tinit(n);\n\tdp[0]=s[0]=fac[n];\n\tfor(int i=1;i<=H;++i){\n\t\tdp[i]=1LL*(s[i-1]-(i<D?0:s[i-D-1])+mod)*sum%mod;\n\t\ts[i]=(s[i-1]+dp[i])%mod;\n\t}\n\tprintf(\"%lld\\n\",1LL*dp[H]*qpow(sum,mod-2)%mod);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pow fuck\n#define int long long\nusing namespace std;\nconst int mod=1e9+7;\nint sqr(int x){return x*x%mod;}\nint pow(int a,int n){return !n?1:sqr(pow(a,n/2))*(n&1?a:1)%mod;}\nint f[1000011],dp[1000011],n,h,d,s[1000011];\nmain()\n{\n\tcin>>n>>h>>d;\n\tf[1]=s[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tf[i]=f[i-1]*i%mod;\n\t\ts[i]=(s[i-1]+f[i])%mod;\n\t}\n\tint sum=dp[0]=1;\n\tfor(int i=1;i<=h;i++)\n\t{\n\t\tdp[i]=sum*s[n]%mod;\n\t\tsum=(sum+dp[i])%mod;\n\t\tif(i>=d)sum=(sum-dp[i-d]+mod)%mod;\n\t}\n\tcout<<dp[h]*f[n]%mod*pow(s[n],mod-2)%mod<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\n#define N 500000\nll MOD=1e9+7;\n\nll mat[11][11];\n//遅延評価\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree\n{\n  using F = function< Monoid(Monoid, Monoid) >;\n  using G = function< Monoid(Monoid, OperatorMonoid) >;\n  using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n  using P = function< OperatorMonoid(OperatorMonoid, int) >;\n \n  int sz;\n  vector< Monoid > data;\n  vector< OperatorMonoid > lazy;\n  const F f;\n  const G g;\n  const H h;\n  const P p;\n  const Monoid M1;\n  const OperatorMonoid OM0;\n \n \n  LazySegmentTree(int n, const F f, const G g, const H h, const P p,\n                  const Monoid &M1, const OperatorMonoid OM0)\n      : f(f), g(g), h(h), p(p), M1(M1), OM0(OM0)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    data.assign(2 * sz, M1);\n    lazy.assign(2 * sz, OM0);\n  }\n \n  void set(int k, const Monoid &x)\n  {\n    data[k + sz] = x;\n  }\n \n  void build()\n  {\n    for(int k = sz - 1; k > 0; k--) {\n      data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n    }\n  }\n \n  void propagate(int k, int len)\n  {\n    if(lazy[k] != OM0) {\n      if(k < sz) {\n        lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n        lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      }\n      data[k] = g(data[k], p(lazy[k], len));\n      lazy[k] = OM0;\n    }\n  }\n \n  Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r)\n  {\n    propagate(k, r - l);\n    if(r <= a || b <= l) {\n      return data[k];\n    } else if(a <= l && r <= b) {\n      lazy[k] = h(lazy[k], x);\n      propagate(k, r - l);\n      return data[k];\n    } else {\n      return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n                         update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n    }\n  }\n \n  Monoid update(int a, int b, const OperatorMonoid &x)\n  {\n    return update(a, b, x, 1, 0, sz);\n  }\n \n \n  Monoid query(int a, int b, int k, int l, int r)\n  {\n    propagate(k, r - l);\n    if(r <= a || b <= l) {\n      return M1;\n    } else if(a <= l && r <= b) {\n      return data[k];\n    } else {\n      return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n               query(a, b, 2 * k + 1, (l + r) >> 1, r));\n    }\n  }\n \n  Monoid query(int a, int b)\n  {\n    return query(a, b, 1, 0, sz);\n  }\n \n  Monoid operator[](const int &k)\n  {\n    return query(k, k + 1);\n  }\n};\nauto f=[](ll a,ll b){return (a+b)%MOD;};\nauto g=[](ll a,ll b){return (a*b)%MOD;};\nauto ff=[](ll a,ll b){return b;};\nauto h=[](ll a,ll b){return (ll)max(a,b);};\nauto p=[](ll a,ll b){return a;};\n//例\n//区間add　区間min\nLazySegmentTree<ll> dp(1100000,f,f,f,p,INF,0);\n//区間add 区間sum\n//LazySegmentTree<ll> seg(n,f,f,f,g,0,0);\n \n \n//LazySegmentTree(n,f,g,h,p,M1,OM0) \n//サイズnで初期化\n//fは二つの区間の要素をマージする二項演算\n//gは要素と作用素をマージする二項演算(第三因数は区間の長さ)\n//hは作用素同士をマージする二項演算\n//p(value,length)は作用素を下におろした時の演算\n//M1はモノイドの単位元\n//OM0は作用素の単位元\n//update(a,b,x) 区間[a,b)に作用素 x を作用\n//query(a,b) 区間[a,b) の値\nmain(){\n    ll n=in(),h=in(),d=in();\n    //LazySegmentTree<ll> dp(h+d+100,h,f,f,p,LLINF,0ll);\n    dp.update(0,1,n);\n    ll ans=0;\n    rep2(i,0,h-1){\n        if(i+d<h){\n            dp.update(i,i+d+1,dp[i]*((n*(n+1)/2)%MOD)%MOD);\n        }\n        else{\n            dp.update(i,i+d+1,dp[i]*((n*(n+1)/2)%MOD)%MOD);\n            ans=(ans+dp[i])%MOD;\n        }\n        /*rep2(j,i+1,i+d){\n            if(j==h)dp[j]=(dp[j]+dp[i])%MOD;\n            else\n            dp[j]=(dp[j]+dp[i]*((n*(n+1)/2)%MOD)%MOD)%MOD;\n        }*/\n    }\n    cout<<ans%MOD;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n\n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1200010];\n                int inv[1200010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n//    mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\n\nint dp[1000020];\n\nint rui[1000020]={};\n\nint rp[1000200];\n\n signed main(){\n \t\n \n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\n\n \tdp[0]=1;\n \trui[0]=1;\n \tint n,d,h;\n \tcin>>n>>h>>d;\n \tmod=inf;\n \tgya(1000200);\n \tpr[0]=rp[0];\n \tfor(int i=1;i<=1000005;i++){\n \t\trp[i]=rp[i-1]+pr[i];\n \t\trp[i]%=inf;\n \t}\n \t\n \tfor(int i=1;i<=h;i++){\n \t\tint l=i-d;\n \t\tint r=i-1;\n \t\tl=max(0ll,l);\n \t\t\n \t\tif(l){\n \t\t\tdp[i]=(rui[r]-rui[l-1]+inf)%inf;\n \t\t\t\n \t\t}\n \t\telse{\n \t\t\tdp[i]=rui[r]%inf;\n \t\t}\n \t\t\n \t\tif(i<h)dp[i]*=rp[n];\n \t\t\n \t\trui[i]=(dp[i]+rui[i-1])%inf;\n \t\t\n \t\t//cout<<i<<\" \"<<dp[i]<<endl;\n \t}\n \t\n \tcout<<dp[h]*pr[n]%inf<<endl;\n \t\n \t\n \treturn 0;\n \n  }\n "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define P 1000000007\n#define M 2000010\nusing namespace std;\n\ntypedef long long ll;\n\nint n, d, h;\n\nll tmp = 0;\n\nll F[M], S[M];\n\nint main() {\n\tscanf(\"%d%d%d\", &n, &h, &d), h--;\n\tll s = 1;\n\tfor(int i = 1; i <= n; i++) s = s * i % P, tmp = (tmp + s) % P;\n\tF[0] = 1, F[1] = tmp, S[0] = 1, S[1] = tmp + 1;\n\tfor(int i = 2; i <= d; i++) F[i] = F[i - 1] * (tmp + 1) % P, S[i] = (S[i - 1] + F[i]) % P;\n\tfor(int i = d + 1; i <= h; i++) F[i] = tmp * (S[i - 1] - S[i - d - 1]) % P, S[i] = (S[i - 1] + F[i]) % P;\n\tll ans = 0;\n\tfor(int i = h + 1 - d; i <= h; i++) ans = (ans + F[i]) % P;\n\tprintf(\"%lld\\n\", ((ans * s) % P + P) % P) % P;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\n#include <cstdint>\nusing namespace std;\nusing LL = long long;\n\nLL N, D, H;\n\n\ntemplate <std::uint_fast64_t Modulus> class modint {\n\tusing u64 = std::uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr modint(const u64 x = static_cast<u64>(0)) noexcept\n\t\t: a(x% Modulus) {}\n\tconstexpr u64& value() noexcept { return a; }\n\tconstexpr const u64& value() const noexcept { return a; }\n\tconstexpr modint operator+(const modint rhs) const noexcept {\n\t\treturn modint(*this) += rhs;\n\t}\n\tconstexpr modint operator-(const modint rhs) const noexcept {\n\t\treturn modint(*this) -= rhs;\n\t}\n\tconstexpr modint operator*(const modint rhs) const noexcept {\n\t\treturn modint(*this) *= rhs;\n\t}\n\tconstexpr modint operator/(const modint rhs) const noexcept {\n\t\treturn modint(*this) /= rhs;\n\t}\n\tconstexpr modint& operator+=(const modint rhs) noexcept {\n\t\ta += rhs.a;\n\t\tif (a >= Modulus) {\n\t\t\ta -= Modulus;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator-=(const modint rhs) noexcept {\n\t\tif (a < rhs.a) {\n\t\t\ta += Modulus;\n\t\t}\n\t\ta -= rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator*=(const modint rhs) noexcept {\n\t\ta = a * rhs.a % Modulus;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator/=(modint rhs) noexcept {\n\t\tu64 exp = Modulus - static_cast<u64>(2);\n\t\twhile (exp) {\n\t\t\tif (exp % static_cast<u64>(2) != static_cast<u64>(0)) {\n\t\t\t\t*this *= rhs;\n\t\t\t}\n\t\t\trhs *= rhs;\n\t\t\texp /= static_cast<u64>(2);\n\t\t}\n\t\treturn *this;\n\t}\n};\n\nusing mint = modint<1000000007>;\n\nmint dp[1234567], im[1234567];\nmint fact[1234567];\n\nint main() {\n\tLL N, D, H;\n\tcin >> N >> H >> D;\n\tmint fimos = 0;\n\tfact[0] = 1;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfact[i] = fact[i - 1] * i;\n\t\tfimos += fact[i];\n\t}\n\tdp[0] = fact[N];\n\tim[1] = fact[N];\n\tfor (int i = 1; i <= H; ++i) {\n\t\tmint tmp = (im[i] - ((i - D < 0) ? 0 : im[i - D]));\n\t\ttmp *= fimos;\n\t\tdp[i] = tmp;\n\t\tim[i + 1] = tmp + im[i];\n\t}\n\tmint ans = dp[H] / fimos;\n\tcout << ans.a << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(ll i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define hash dhsjakhd\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef long double ld;\n\n\nunsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\nstd::mt19937 eng(seed);\n\nuniform_int_distribution<> DD(0, (1ll << 31));\n\nll random2(){\n    return (ll(DD(eng))*(1ll << 31) + ll(DD(eng))) & ((1ll << 62ll)-1);\n}\n\nll n,m,T,k,q;\n\nconst ll big = 1000000007;\nconst ll big2 = 1000000009;\nconst ll mod =  998244353;\n\nconst ll MAXN = 1000001;\n\nll FS[MAXN] = {0};\nll DP[MAXN] = {0};\nll FAC[MAXN] = {0};\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    //freopen(\"input.txt\",\"r\",stdin);\n   // freopen(\"autput.txt\",\"w\",stdout);\n\n    ll a,b,c,d;\n    ll h;\n    ll t = 1;\n    ll prev = -1;\n    rep(c1,0,MAXN){\n        FS[c1] = (prev+t)%big;\n        FAC[c1] = t%big;\n        prev = FS[c1];\n        t *= (ll(c1+1));\n        t %= big;\n    }\n\n\n    cin >> n >> h >> d;\n    DP[h] = 1;\n    ll sum = DP[h];\n    ll r = h;\n    for(int c1 = h-1; c1 >= 0; c1--){\n        DP[c1] = (sum)%big;\n       /* if(c1 == 0){\n            DP[c1] = (FAC[n] * sum)%big;\n        }*/\n        //if(c1 < h-1)DP[c1] *= FS[n];\n        DP[c1] %= big;\n        sum += (DP[c1]*FS[n])%big;\n        if(r-c1+1 > d){\n            a = (DP[r]*FS[n])%big;\n            if(r == h)a = DP[r];\n            sum += big*2-a;\n            sum %= big;\n            r--;\n        }\n    }\n\n    cout << (FAC[n]*DP[0])%big << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\ntemplate<int mod, bool isPrime = false >\nclass  Mint {\n\tusing ll = long long;\n\tll value;\npublic:\n\tconstexpr Mint() : value(0) {};\n\tconstexpr Mint(ll x) : value(x) {\n\t\tvalue %= mod;\n\t\tif (value < 0)value += mod;\n\t}\n\tconstexpr Mint(const Mint& other) : value(other.value) {}\n\n\tll& get() { return value; }\n\tll get() const { return value; }\n\n\tconstexpr Mint pow(ll n) {\n\t\tMint ret(1), tmp(value);\n\t\twhile (n) {\n\t\t\tif (n & 1)ret *= tmp;\n\t\t\tn >>= 1;\n\t\t\ttmp *= tmp;\n\t\t}\n\t\treturn ret;\n\t}\n\tconstexpr bool operator == (const Mint& a) const {\n\t\treturn value == a.value;\n\t}\n\tconstexpr bool operator != (const Mint& a) const {\n\t\treturn value != a.value;\n\t}\n\tconstexpr Mint& operator =(const Mint& a) {\n\t\tvalue = a.value;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator +=(const Mint& a) {\n\t\tif ((value += a.value) >= mod)value -= mod;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator -=(const Mint& a) {\n\t\tif ((value += mod - a.value) >= mod)value -= mod;\n\t\treturn *this;\n\t}\n\tconstexpr Mint& operator *=(const Mint& a) {\n\t\tvalue = value * a.value % mod;\n\t\treturn *this;\n\t}\n\n\tconstexpr Mint& operator /=(const Mint& a) {\n\t\treturn *this *= inv(a);\n\t}\n\tconstexpr Mint operator +(const Mint& a) const {\n\t\treturn Mint(*this) += a;\n\t}\n\tconstexpr Mint operator -(const Mint& a) const {\n\t\treturn Mint(*this) -= a;\n\t}\n\tconstexpr Mint operator *(const Mint& a) const {\n\t\treturn Mint(*this) *= a;\n\t}\n\tconstexpr Mint operator /(const Mint& a) const {\n\t\treturn Mint(*this) /= a;\n\t}\n};\ntemplate<int mod, bool isPrime> std::ostream& operator << (std::ostream& os, const Mint<mod, isPrime>& m) { os << m.get(); return os; }\ntemplate<int mod, bool isPrime> std::istream& operator >> (std::istream& is, Mint<mod, isPrime>& m) { is >> m.get();  return is; }\n\ntemplate<int mod>\nconstexpr Mint<mod, true> inv(const Mint<mod, true>& m) {\n\tlong long a = m.get(), b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; std::swap(a, b);\n\t\tu -= t * v; std::swap(u, v);\n\t}\n\treturn Mint<mod, true>(u);\n}\n\ntemplate<int mod, bool isPrime>\nconstexpr Mint<mod, isPrime> operator +(long long lhs, const Mint<mod, isPrime>& a) {\n\treturn Mint<mod, isPrime>(lhs + a.get());\n}\n\ntemplate<int mod, bool isPrime>\nconstexpr Mint<mod, isPrime> operator -(long long lhs, const Mint<mod, isPrime>& a) {\n\treturn Mint<mod, isPrime>(lhs - a.get());\n}\n\ntemplate<int mod, bool isPrime>\nconstexpr Mint<mod, isPrime> operator *(long long lhs, const Mint<mod, isPrime>& a) {\n\treturn Mint<mod, isPrime>(lhs % mod * a.get());\n}\n\n\ntemplate<int mod>\nconstexpr Mint<mod, true> operator /(long long lhs, const Mint<mod, true>& a) {\n\treturn Mint<mod, true>(lhs % mod * inv(a));\n}\n\nconstexpr int default_mod = 1000000007;\nusing mint = Mint<default_mod, true>;\n\nstruct RARS {\n\tstruct t1 {\n\t\tmint val;\n\t\tint size;\n\t\tconstexpr t1(long long v, long long s) :val(v), size(s) {}\n\t\tconstexpr t1() : val(0), size(0) {}\n\t};\n\tusing t2 = mint;\n\tstatic constexpr t1 id1() {\n\t\treturn t1(0, 0);\n\t}\n\tstatic constexpr t2 id2() {\n\t\treturn 0ll;\n\t}\n\tstatic t1 op1(const t1& a, const t1& b) {\n\t\treturn t1((a.val + b.val).get(), a.size + b.size);\n\t}\n\tstatic t1 op2(const t1& a, const t2& b) {\n\t\treturn t1((a.val + b * a.size).get(), a.size);\n\t}\n\tstatic t2 op3(const t2& a, const t2& b) {\n\t\treturn a + b;\n\t}\n};\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n, h, d;\n\tcin >> n >> h >> d;\n\tvector<mint> dp(h + 1);\n\tdp[0] = 1;\n\tFOR(i, 1, d + 1)dp[i] = n;\n\tmint col = 0;\n\tmint t = 1;\n\tfor (int i = 0; i <= n - 1; ++i) {\n\t\tif (i != n - 1) {\n\t\t\tcol += t * (n - 1 - i);\n\t\t\tt *= (n - 1 - i);\n\t\t}\n\t\telse {\n\t\t\tcol += t * n;\n\t\t}\n\t}\n\tmint sum = 0;\n\n\tFOR(i, 1, h + 1) {\n\t\tdp[i] += sum * col;\n\t\tsum += dp[i];\n\t\tif (i > d)sum -= dp[i - d];\n\t}\n\tmint res = dp[h];\n\tREP(i, n - 1)res *= i + 1;\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD ((ll)1e9+7)\n\nll moddiv(ll a,ll b){\n    a %= MOD;\n    b %= MOD;\n    for(ll m=MOD-2;m>0;m/=2){\n        if(m&1){\n            a=a*b%MOD;\n        }\n        b=b*b%MOD;\n    }\n    return a;\n}\n\nll N, H, D;\n\nll dp[2020202],mk[2020202];\nll i, j, k,ans;\nll fa[1010101];\nint main(){\n    scanf(\"%lld%lld%lld\", &N,&H,&D);\n    fa[0] = 1;\n    fornum(i,0,1010101){\n        fa[i + 1] = fa[i] * (i + 1) % MOD;\n    }\n    ll aDd = 0;\n    fornum(i,0,N){\n        aDd = (aDd + fa[i+1]) % MOD;\n    }\n    \n    k = fa[N];\n    mk[D] = k;\n    fornum(i,0,H-1){\n        mk[i + 1 + D] = k * aDd;\n        k = (k + k * aDd + MOD - mk[i + 1]) % MOD;   \n    }\n    printf(\"%lld\", k);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\n//0-indexed BIT\nclass BIT\n{\n    using T = mint;\nprivate:\n    T _sum(int i) {\n        if (!i) return 0;\n        return data[i] + _sum(i - (i & -i));\n    }\n\n    void _add(int i, T x) {\n        if (i > N) return;\n        data[i] += x;\n        _add(i + (i & -i), x);\n    }\n\npublic:\n    vector<T> data;\n    int N;\n\n    BIT(int N): data(vector<T>(N + 1, 0)), N(N) {}\n\n    //sum of [0,i]\n    //sum(-1)=0\n    T sum(int i) { return _sum(i + 1); };\n\n    void add(int i, T x) { _add(i + 1, x); };\n\n};\n\nsigned main(){\n\n    int N, H, D; cin >> N >> H >> D;\n    Combination C(N);\n\n    mvec dp(H + 1);\n    BIT b(H + 1);\n    dp[0] = C.fact[N];\n    mint c0 = 0;\n    FOR(n, 1, N + 1) c0 += C.fact[n];\n    FOR(i, 1, H + 1){\n        b.add(i - 1, dp[i - 1]);\n        dp[i] = (b.sum(i - 1) - b.sum(max(i - D, 0LL) - 1)) * c0;\n    }\n    mint ans = dp[H] / c0;\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\n#include<functional>\ntemplate<typename T>\nstruct lazysegtree{\n\tfunction<T(T,T)>calcfn,lazycalcfn;\n\tfunction<T(T,T,unsigned int)>updatefn;\n\tint n;\n\tT defvalue,lazydefvalue;\n\tvector<T>dat,lazy;\n\tvector<bool>lazyflag;\n\tlazysegtree(int n_=0,T defvalue_=0,\n\t\tfunction<T(T,T)>calcfn_=[](T a,T b){return a+b;},\n\t\tfunction<T(T,T)>lazycalcfn_=[](T a,T b){return a+b;},\n\t\tfunction<T(T,T,unsigned int)>updatefn_=[](T a,T b,unsigned int width){return a+b*width;},\n\t\tT lazydefvalue_=0\n\t):defvalue(defvalue_),lazydefvalue(lazydefvalue_),\n\t\tcalcfn(calcfn_),lazycalcfn(lazycalcfn_),updatefn(updatefn_)\n\t{\n\t\tn=1;\n\t\twhile(n<n_)n<<=1;\n\t\tdat.assign(2*n-1,defvalue);\n\t\tlazy.assign(2*n-1,lazydefvalue);\n\t\tlazyflag.assign(2*n-1,false);\n\t}\n\tvoid copy(const vector<T>&v)\n\t{\n\t\tfor(int i=0;i<v.size();i++)dat[i+n-1]=v[i];\n\t\tfor(int i=n-2;i>=0;i--)dat[i]=calcfn(dat[2*i+1],dat[2*i+2]);\n\t}\n\tvoid eval(int i,int l,int r)\n\t{\n\t\tif(lazyflag[i])\n\t\t{\n\t\t\tdat[i]=updatefn(dat[i],lazy[i],r-l);\n\t\t\tif(r-l>1)\n\t\t\t{\n\t\t\t\tlazy[2*i+1]=lazycalcfn(lazy[2*i+1],lazy[i]);\n\t\t\t\tlazy[2*i+2]=lazycalcfn(lazy[2*i+2],lazy[i]);\n\t\t\t\tlazyflag[2*i+1]=lazyflag[2*i+2]=true;\n\t\t\t}\n\t\t\tlazy[i]=lazydefvalue;\n\t\t\tlazyflag[i]=false;\n\t\t}\n\t}\n\tvoid update(int a,int b,T x,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\t//eval(k,l,r);\n\t\tif(b<=l||r<=a)return;\n\t\telse if(a<=l&&r<=b)\n\t\t{\n\t\t\tlazy[k]=lazycalcfn(lazy[k],x);\n\t\t\tlazyflag[k]=true;\n\t\t\teval(k,l,r);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdate(a,b,x,2*k+1,l,(l+r)/2);\n\t\t\tupdate(a,b,x,2*k+2,(l+r)/2,r);\n\t\t\tdat[k]=calcfn(dat[2*k+1],dat[2*k+2]);\n\t\t}\n\t}\n\tT query(int a,int b,int k=0,int l=0,int r=-1)//[a,b)\n\t{\n\t\tif(r<0)r=n;\n\t\teval(k,l,r);\n\t\tif(b<=l||r<=a)return defvalue;\n\t\telse if(a<=l&&r<=b)return dat[k];\n\t\telse return calcfn(\n\t\t\tquery(a,b,2*k+1,l,(l+r)/2),\n\t\t\tquery(a,b,2*k+2,(l+r)/2,r)\n\t\t);\n\t}\n};\nlong N,H,D,mod=1e9+7;\nmain()\n{\n\tcin>>N>>H>>D;\n\tlazysegtree<long>P(H,0,\n\t[](long a,long b){return (a+b)%mod;},\n\t[](long a,long b){return (a+b)%mod;},\n\t[](long a,long b,unsigned int w){return (a+b*w)%mod;});\n\tlong s=0,p=1;\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tp=p*i%mod;\n\t\ts=(s+p)%mod;\n\t}\n\tP.update(0,D,p);\n\tfor(int i=0;i<H;i++)\n\t{\n\t\tP.update(i+1,i+D+1,P.query(i,i+1)*s%mod);\n\t}\n\tcout<<P.query(H-1,H)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long ll;\nconst int mod=1000000007;\nint f[1000050],g[1000050],s[1000050];\nint main(){\n\tint n,h,d,p,i;\n\tscanf(\"%d%d%d\",&n,&h,&d);\n\tf[0]=f[1]=1;\n\tfor(i=2;i<=n;++i)f[i]=(ll)f[i-1]*i%mod;\n\tp=2;\n\tfor(i=2;i<=n;++i)p=(p+f[i])%mod;\n\ts[1]=g[1]=f[n];\n\tfor(i=2;i<=d;++i)s[i]=(s[i-1]+(g[i]=(ll)g[i-1]*p%mod))%mod;\n\tfor(i=d+1;i<=h;++i){\n\t\tg[i]=(ll)(s[i-1]-s[i-d-1])*(p-1)%mod;\n\t\ts[i]=(s[i-1]+g[i])%mod;\n\t}\n\tprintf(\"%d\\n\",g[h]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <tuple>\n#include <cstdint>\n#include <iomanip>\n#include <climits>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n)-1; i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n#define chmin(x, y) x = min(x, y);\n#define chmax(x, y) x = max(x, y);\nvoid BinarySay(ll x, ll y = 60){rep(i, y) cout << (x>>(y-1-i) & 1); cout << endl;}\nconst ll INFL = 1LL << 60;//10^18 = 2^60\n//ll MOD = 1000000007;\nll MOD = 998244353;\nstruct mint{\n  ll x;\n  mint(ll x=0):x(x % MOD){}\n  mint& operator+=(const mint a){\n    (x += a.x) %= MOD;\n    return *this;\n  }\n  mint& operator-=(const mint a){\n    (x += MOD-a.x) %= MOD;\n    return *this;\n  }\n  mint& operator*=(const mint a){\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint& operator%=(const mint a){\n    (x %= a.x);\n    return *this;\n  }\n  mint& operator++ (int){\n    (x += 1) %= MOD;\n    return *this;\n  }\n  mint& operator-- (int){\n    (x += MOD-1) %= MOD;\n    return *this;\n  }\n  mint operator+(const mint a) const{\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const{\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const{\n    mint res(*this);\n    return res*=a;\n  }\n  mint operator%(const mint a) const{\n    mint res(*this);\n    return res%=a;\n  }\n  mint po(ll t) const{\n    if(!t) return 1;\n    mint a = po(t>>1);\n    a *= a;\n    if(t&1) a *= *this;\n    return a;\n  }\n  mint inverse() const{\n    return po(MOD-2);\n  }\n  mint& operator/=(const mint a){\n    return (*this) *= a.inverse();\n  }\n  mint operator/(const mint a) const{\n    mint res(*this);\n    return res/=a;\n  }\n  bool operator == (const mint a){\n    return this->x == a.x;\n  }\n  bool operator != (const mint a){\n    return this->x != a.x;\n  }\n  void get(){\n    cout << x << endl;\n  }\n  void ge(){\n    cout << x << \" \";\n  }\n};const mint Mint = 0;\n\n\nmint pow_mod(ll x, ll k){\n  mint res = 1;\n  mint a = x;\n  while(k > 0){\n    if(k % 2){\n      res *= a;\n    }\n    a *= a;\n    k /= 2;\n  }\n  return res;\n}\n\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x;\n    k /= 2;\n  }\n  return res;\n}\n\nmint inverse(ll x){return pow_mod(x, MOD-2);}\n\n//二項演算\nconst int MAXcomb = 200010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nmint comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    mint res = fac[n];\n    res *= finv[k] * finv[n-k];\n    return res;\n}\n\nmint comb_naive(ll N, ll K){//Kが小さい時\n  mint res = 1;\n  rep(i, K) res *= (N-i) % MOD;\n  mint k = 1;\n\n  rep(i, K) k *= (i+1);\n  res /= k;\n  return res;\n}\n\n//約数の列挙O(√n)\nvector<ll> divisor(ll n){\n    vector<ll> res(0);\n    for(ll i = 1; i * i <= n; i++){\n        if(n % i == 0){\n            res.push_back(i);\n            if(i != n/i) res.push_back(n/i);\n        }\n    }\n    sort(res.begin(), res.end());\n    return res;\n}\n\nll disit(ll x, ll d = 10){\n  ll res = 0;\n  while(x){\n    res++;\n    x /= d;\n  }\n  return res;\n}\n\n\nvoid solve(){\n\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\nconstexpr int inf = 1000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\nconstexpr ll mod = 1000000007;\nconstexpr ll modsize = 5000010;\nvector<ll> fac(modsize);\nvector<ll> inv(modsize);\nvector<ll> facinv(modsize);\n\nvoid modcalc() {\n\tif (modsize == 0) abort();\n\tfac[0] = 1; fac[1] = 1; inv[1] = 1;\n\tfacinv[0] = 1; facinv[1] = 1;\n\tfor (ll i = 2; i < modsize; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfacinv[i] = facinv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll modinv(ll a) {\n\tif (a == 0) abort();\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a % mod;\n\t\ta = a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nll modcomb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[k] % mod * facinv[n - k] % mod;\n}\n\nll modperm(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[n - k] % mod;\n}\n\nll modhom(ll n, ll k) {\n\tif (n < 0 || k < 0 || n == 0 && k > 0) return 0;\n\tif (n == 0 && k == 0) return 1;\n\treturn fac[n + k - 1] * facinv[k] % mod * facinv[n - 1] % mod;\n}\n\nll dp[1000010], sum[1000010];\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\tmodcalc();\n\n\tll n, h, d;\n\tcin >> n >> h >> d;\n\tll coeff = 0;\n\tfor (int i = 1; i <= n; i++) coeff += fac[i];\n\tcoeff %= mod;\n\tdp[0] = sum[0] = 1;\n\tfor (int i = 1; i <= h; i++) {\n\t\tint idx = i - d - 1;\n\t\tif (idx < 0) dp[i] = coeff * sum[i - 1] % mod;\n\t\telse dp[i] = coeff * (sum[i - 1] - sum[idx] + mod) % mod;\n\t\tsum[i] = sum[i - 1] + dp[i];\n\t\tif (sum[i] >= mod) sum[i] -= mod;\n\t}\n\tcout << dp[h] * fac[n] % mod * modinv(coeff) % mod << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 1000000007;\nll N, H, D;\nll dp[2005000];\nll imos[2000500];\nll inv[2000000];\nll FactorialInv[2000000];\nll Factorial[2000000];\nll FactorialSum[2000000];\nll beki(ll a, ll b){\n    if(b == 0){\n        return 1;\n    }\n    ll ans = beki(a, b / 2);\n    ans = ans * ans % mod;\n    if(b % 2 == 1){\n        ans = ans * a % mod;\n    }\n    return ans;\n}\nvoid init_combination(){\n    inv[1] = 1;\n    FactorialInv[1] = 1;\n    Factorial[1] = 1;\n    Factorial[0] = 1;\n    FactorialInv[0] = 1;\n    inv[0] = 1;\n    FactorialSum[1] = 1;\n    for(int i = 2; i < 2000000; i++){\n        inv[i] = beki(i, mod - 2);\n        Factorial[i] = Factorial[i - 1] * i % mod;\n        FactorialInv[i] = FactorialInv[i - 1] * inv[i] % mod;\n        FactorialSum[i] = (FactorialSum[i-1] + Factorial[i]) % mod;\n    }\n}\nll combination(ll a, ll b){\n    if((a == b) || (b == 0)){\n        return 1;\n    }\n    ll ans = Factorial[a] * FactorialInv[b] % mod;\n    ans = ans * FactorialInv[a - b] % mod;\n    return ans;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    init_combination();\n    cin >> N >> H >> D;\n    for(int i = 1; i <= D; i++) dp[i] = Factorial[N];\n    for(int before = 1; before <= H; before++) {\n        imos[before] += imos[before-1];\n        imos[before] %= mod;\n        dp[before] += imos[before];\n        dp[before] %= mod;\n        imos[before+1] += dp[before] * FactorialSum[N-1];\n        imos[before+D+1] -= dp[before] * FactorialSum[N-1];\n        /*\n        if(before + D >= H) {\n            dp[H] += dp[before] * (N - 1);\n            dp[H] %= mod;\n        }\n        */\n        imos[before+1] += dp[before] * Factorial[N];\n        imos[before+D+1] -= dp[before] * Factorial[N];\n        /*\n        if(before + D + 1 >= H) {\n            dp[H] += dp[before] * Factorial[N];\n            dp[H] %= mod;\n        }\n        */\n        imos[before+1] = (imos[before+1]) % mod;\n        imos[before+D+1] %= mod;\n        imos[before+D+1] += mod;\n        imos[before+D+1] %= mod;\n        imos[before+D+2] %= mod;\n        imos[before+D+2] += mod;\n        imos[before+D+2] %= mod;\n        //cerr << before << \" \" << imos[before] << \" \" << dp[before] << endl;\n    }\n    cout << dp[H] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\n\nclass Solver2 {\n public:\n  LL n, h, d;\n  vector<Modint<>> dp, sum;\n  Solver2(LL n, LL h, LL d) : n(n), h(h), d(d), dp(h * 2 + 1), sum(h * 2 + 1){};\n\n  void solve() {\n    Modint<> coeff(0);\n    Modint<> perm(1);\n    //vector<Modint<>> fac(3000000);\n\n    for (LL i = n; i >= 1; --i) {\n      coeff += 1;\n      coeff *= i;\n      perm *= i;\n    }\n    /*fac[0] = Modint<>(1);\n    for (LL i = 1; i < fac.size(); ++i) {\n      fac[i] = fac[i - 1] * i;\n    }*/\n    dp[h] = Modint<>(1);\n    sum[h] = Modint<>(1);\n    for (int i = h - 1; i >= 0; --i) {\n      if (i > 0)\n        dp[i] = (sum[i + 1] - sum[i + d + 1]) * coeff;\n      else\n        dp[i] = (sum[i + 1] - sum[i + d + 1]) * perm;\n      sum[i] = sum[i + 1] + dp[i];\n      if (i < 100) DBG(i, dp[i])\n    }\n\n    cout << dp[0] << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, h, d;\n  std::cin >> n >> h >> d;\n\n  Problem::Solver2 sol(n, h, d);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <set>\n#include <algorithm>\n#include <vector>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint n, d, h;\nllint fsum;\n\nconst int FACT_MAX = 1000005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint dp[1000005];\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n >> h >> d;\n\tmake_fact();\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tfsum += fact[i], fsum %= mod;\n\t}\n\t\n\tllint sum = 0;\n\tdp[0] = fact[n], sum += dp[0];\n\tfor(int i = 1; i <= h; i++){\n\t\tdp[i] = sum;\n\t\tdp[i] *= fsum, dp[i] %= mod;\n\t\tsum += dp[i], sum %= mod;\n\t\tif(i-d >= 0) sum += mod - dp[i-d], sum %= mod;\n\t}\n\tcout << dp[h] * modpow(fsum, mod-2) % mod << endl;\n\t\n\t//for(int i = 0; i <= h; i++) cout << dp[i] << \" \"; cout << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int N; cin >> N;\n    int ga, sa, ba, gb, sb, bb;\n    cin >> ga >> sa >> ba >> gb >> sb >> bb;\n\n    //\n    int ans =N;\n    int num=0;\n    if(ga < gb) num++;\n    if(sa < sb) num++;\n    if(ba < bb) num++;\n    //\n    if(num==3){\n    for(int x=0; x*ga<=N; x++){\n        for(int y=0; x*ga+y*sa <=N; y++){\n            int left=N-x*ga-y*sa;\n            if(bb <= ba){ ans = max(ans, N-x*ga-y*sa+x*gb+y*sb);}\n            else{\n                int z = left/ba;\n                ans =max(ans,N-x*ga-y*sa+x*gb+y*sb+z*(bb-ba));\n            }\n        }\n    }\n    cout << ans << endl;\n    }\n\n    //\n    if(num==2){\n        if(ga >= gb) {swap(ga,ba); swap(gb,bb);}\n        if(sa >= sb) {swap(sa,ba); swap(sb,bb);}\n        for(int x=0; x*ga<=N; x++){\n            for(int y=0; x*ga+y*sa <=N; y++){\n                int M=N+x*(gb-ga)+y*(sb-sa);\n                ans = max(ans, M%bb+M/bb*ba);\n            }\n        }\n        cout << ans << endl;\n    }\n\n    if(num==1){\n        if( sa < sb ){swap(ga,sa); swap(gb,sb);}\n        if( ba < bb) {swap(ga,ba); swap(gb,bb);}\n        int M=N%ga+N/ga*gb;\n        for(int y=0; sb*y<=M; y++){\n            int left=M-sb*y;\n            ans = max(ans, left%bb+left/bb*ba+y*(sa-sb));\n        }\n        cout << ans << endl;\n    }\n\n    if(num==0){\n        swap(ga,gb); swap(sa,sb); swap(ba,bb);\n    for(int x=0; x*ga<=N; x++){\n        for(int y=0; x*ga+y*sa <=N; y++){\n            int left=N-x*ga-y*sa;\n            if(bb <= ba){ ans = max(ans, N-x*ga-y*sa+x*gb+y*sb);}\n            else{\n                int z = left/ba;\n                ans =max(ans,N-x*ga-y*sa+x*gb+y*sb+z*(bb-ba));\n            }\n        }\n    }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\nint mod(int n) {\n    n %= MOD;\n    if (n < 0) return n + MOD;\n    else return n;\n}   \nint fp(int a, int p) {\n    int ans = 1, c = a;\n    for (int i = 0; (1ll << i) <= p; ++i) {\n        if ((p >> i) & 1) ans = mod(ans * c);\n        c = mod(c * c);\n    }   \n    return ans;\n}   \nint dv(int a, int b) { return mod(a * fp(b, MOD - 2)); }\n\nconst int N = 1e6 + 7;\nint f[N], inv[N];\nvoid prec() {\n    f[0] = 1;\n    for (int i = 1; i < N; ++i)\n        f[i] = mod(f[i - 1] * i);\n    inv[N - 1] = fp(f[N - 1], MOD - 2);\n    for (int i = N - 2; i >= 0; --i)\n        inv[i] = mod(inv[i + 1] * (i + 1));\n}\nint C(int n, int k) {\n    return mod(f[n] * mod(inv[k] * inv[n - k]));\n}   \n\nvoid add(int &a, int b) { a = mod(a + b); }\n\nint dp[N];\nint t[N];\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n    prec();\n    int n, h, d;\n    cin >> n >> h >> d;\n    for (int mx = 1; mx <= d; ++mx)\n        dp[mx] = f[n];\n\n    int fc = 0;\n    for (int cnt = 1; cnt <= n; ++cnt)\n        add(fc, f[cnt]);\n\n    int cur = 0;\n    for (int mx = 1; mx <= h; ++mx) {\n        add(cur, t[mx]);\n        add(dp[mx], cur);\n        int de = mod(dp[mx] * fc);\n        add(t[mx + 1], de);\n        int r = min(mx + d, h);\n        add(t[r + 1], -de);\n    }                       \n    cout << dp[h] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// And in the end, the love you take is equal to the love you make.\n//                      Paul McCartney (the Beatles). The End. Abbey Road.\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing LL = long long;\n\nnamespace _buff {\n\nconst size_t BUFF = 1 << 19;\nchar ibuf[BUFF], *ib = ibuf, *ie = ibuf;\nchar getc() {\n  if (ib == ie) {\n    ib = ibuf;\n    ie = ibuf + fread(ibuf, 1, BUFF, stdin);\n  }\n  return ib == ie ? -1 : *ib++;\n}\n\n}\n\nLL read() {\n  using namespace _buff;\n  LL ret = 0;\n  bool pos = true;\n  char c = getc();\n  for (; (c < '0' || c > '9') && c != '-'; c = getc()) {\n    assert(~c);\n  }\n  if (c == '-') {\n    pos = false;\n    c = getc();\n  }\n  for (; c >= '0' && c <= '9'; c = getc()) {\n    ret = (ret << 3) + (ret << 1) + (c ^ 48);\n  }\n  return pos ? ret : -ret;\n}\n\nconst size_t N = 1e6 + 5;\nconst int MOD = 1e9 + 7;\n\nint qpow(int base, int e) {\n  int ret = 1;\n  for (; e; e >>= 1) {\n    if (e & 1) {\n      ret = (LL) ret * base % MOD;\n    }\n    base = (LL) base * base % MOD;\n  }\n  return ret;\n}\n\nint f[N], pre[N];\n\nint main() {\n  int n = read(), h = read(), d = read();\n\n  int fac = 1, sum = 0;\n  for (int i = 1; i <= n; ++i) {\n    fac = (LL) fac * i % MOD;\n    sum = (sum + fac) % MOD;\n  }\n\n  f[0] = pre[0] = 1;\n  for (int i = 1; i <= h; ++i) {\n    f[i] = (LL) (pre[i - 1] - (i >= d + 1 ? pre[i - d - 1] : 0)) * sum % MOD;\n    pre[i] = (pre[i - 1] + f[i]) % MOD;\n  }\n\n  if (f[h] < 0) f[h] += MOD;\n  cout << (LL) f[h] * fac % MOD * qpow(sum, MOD - 2) % MOD << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//clock_t start=clock();clock_t end=clock();cout<<(double)(end-start)/CLOCKS_PER_SEC<<endl;\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned int ui;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppii;\ntypedef pair<int,pii> pipi;\ntypedef pair<ll,ll> pll;\ntypedef pair<pll,ll> ppll;\ntypedef pair<ll,pll> plpl;\ntypedef pair<pii,pii> P;\ntypedef tuple<ll,ll,ll> tl;\ntypedef pair<double,double> pdd;\ntypedef vector<vector<ll>> mat;\nll mod=1000000007;\nll mod2=998244353;\nll mod3=1000003;\nll mod4=998244853;\nll mod5=1000000009;\nll inf=1LL<<62;\ndouble pi=3.141592653589793238462643383279L;\ndouble eps=1e-14;\n#define rep(i,m,n) for(ll i=m;i<n;i++)\n#define rrep(i,n,m) for(ll i=n;i>=m;i--)\n#define srep(itr,st) for(auto itr=st.begin();itr!=st.end();itr++)\n#define mrep(itr,mp) for(auto itr=mp.begin();itr!=mp.end();itr++)\n#define Max(a,b) a=max(a,b)\n#define Min(a,b) a=min(a,b)\nint dh[4]={1,-1,0,0};\nint dw[4]={0,0,1,-1};\nint ddh[8]={-1,-1,-1,0,0,1,1,1};\nint ddw[8]={-1,0,1,-1,1,-1,0,1};\nstruct custom_hash {\n    static uint64_t splitmix64(uint64_t x) {\n        // http://xorshift.di.unimi.it/splitmix64.c\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31);\n    }\n\n    size_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM);\n    }\n};\n#define umh unordered_map<ll,ll,custom_hash>\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    if(a%b==0)return b;\n    return gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n    ll c=gcd(a,b);\n    return a*b/c;\n}\nll Pow(ll n,ll k){\n    ll ret=1;\n    ll now=n;\n    while(k>0){\n        if(k&1)ret*=now;\n        now*=now;\n        k/=2;\n    }\n    return ret;\n}\nll beki(ll n,ll k,ll md){\n  ll ret=1;\n  ll now=n;\n    now%=md;\n  while(k>0){\n    if(k%2==1){\n      ret*=now;\n      ret%=md;\n    }\n    now*=now;\n    now%=md;\n    k/=2;\n  }\n  return ret;\n}\nll gyaku(ll n,ll md){\n  return beki(n,md-2,md);\n}\nll popcount(ll n){\n    ll ret=0;\n    ll u=n;\n    while(u>0){\n        ret+=u%2;\n        u/=2;\n        \n    }\n    return ret;\n}\nstruct BIT{\nprivate:\n    ll u;\n    vector<ll> bit;\npublic:\n    BIT(ll n){\n        u=1;while(u<n)u*=2;\n        bit.resize(u+10,0);\n        \n    }\n    void add(ll n,ll x){\n        ll i=n;\n        bit[i]+=x;\n        bit[i]%=mod;\n        while(i<u){\n            i+=i&(-i);\n            bit[i]+=x;\n            bit[i]%=mod;\n        }\n\n    }\n    ll sum(ll n){\n        ll i=n;\n        ll ret=0;\n        while(i>0){\n            ret+=bit[i];\n            i-=i&(-i);\n            ret%=mod;\n        }\n        return ret;\n    }\n    ll lb(ll w){\n        if(w<=0)return 0;\n        ll x=0;\n        for(ll k=u;k>0;k/=2){\n            if(x+k<=u&&bit[x+k]<w){\n                w-=bit[x+k];\n                x+=k;\n            }\n        }\n        return x+1;\n    }\n};\n//vector<BIT> b(26,n+1);\nint main(){\n    ios::sync_with_stdio(false);cin.tie(0);\n    ll n,h,d;cin>>n>>h>>d;\n    ll dp[h+1];\n    BIT bi(h+1);\n    dp[0]=1;\n    ll kai[1000001];\n    kai[0]=1;\n    rep(i,1,1000001)(kai[i]=kai[i-1]*i)%=mod;\n    ll sum=0;\n    rep(i,1,n+1)(sum+=kai[i])%=mod;\n    rep(i,1,h+1){\n        ll l=i-d;\n        if(l<=0){\n            ll su=bi.sum(i-1);\n            (su*=sum)%=mod;\n            dp[i]=su+kai[n];\n            dp[i]%=mod;\n        }\n        else{\n            ll su=bi.sum(i-1)-bi.sum(l-1)+mod;\n            su%=mod;\n            (su*=sum)%=mod;\n            dp[i]=su;\n        }\n        bi.add(i,dp[i]);\n    }\n    cout<<dp[h]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\nusing namespace std;\n#define MOD 1000000007\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\n\n//priority_queue<ll> max;//大きい順\n//priority_queue<ll, Array, greater<ll>> min;//小さい順\n\n/*firstについては昇順 secondについては降順\nsort(all(wh), [&](P x, P y) {\n\tif (x.first == y.first)return x.second > y.second;\n\treturn x.first < y.first;\n});\n*/\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n//substr　文字列取り出し\n//upper_bound ある値より大きい一番左のイテレータを返す、lowerは以上(setに対して使うとO(N)なので、setのメンバ関数を使う\n//stoi\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap,bool revFlag,ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif(revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph & G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d,Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size()-1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif(negative[i]==true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unionSet(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\t\n\tll _sum(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1,0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tll sum(ll a, ll b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1,INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\nbool z_algorithm(string &str,vector<int> &z,ll s) {//s&tを渡してtにsが含まれるかを返す\n\tconst int L = str.size();\n\tz.resize(str.size());\n\tfor (int i = 1, left = 0, right = 0; i < L; i++) {\n\t\tif (i > right) {\n\t\t\tleft = right = i;\n\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\tz[i] = right - left;\n\t\t\tright--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - left;\n\t\t\tif (z[k] < right - i + 1) {\n\t\t\t\tz[i] = z[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft = i;\n\t\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\t\tz[i] = right - left;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t\tif (z[i] == s)return true;\n\t}\n\treturn false;\n}\nbool z_algorithm(string& str, vector<int>& z) {//z[i]==|s|のときstr[i]からsが含まれる\n\tconst int L = str.size();\n\tz.resize(str.size());\n\tfor (int i = 1, left = 0, right = 0; i < L; i++) {\n\t\tif (i > right) {\n\t\t\tleft = right = i;\n\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\tz[i] = right - left;\n\t\t\tright--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - left;\n\t\t\tif (z[k] < right - i + 1) {\n\t\t\t\tz[i] = z[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft = i;\n\t\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\t\tz[i] = right - left;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nll ModPow(ll x, ll n) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\nArray inv;\nll mod;\nll mod_inv(ll x) {\n\tll n = mod - 2LL;\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nll nCr(ll n, ll r) {\n\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n}\nll nPr(ll n, ll r) {\n\treturn (fact[n] * inv[n - r]) % mod;\n}\nll nHr(ll n, ll r) {\n\treturn nCr(r + n - 1, r);\n}\nCombination(ll n, ll _mod) {\n\tmod = _mod;\n\tfact.resize(n + 1);\n\tfact[0] = 1;\n\tREP(i, n) {\n\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t}\n\tinv.resize(n + 1);\n\tREP(i, n + 1) {\n\t\tinv[i] = mod_inv(fact[i]);\n\t}\n}\n};\n\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nMatrix mIdentity(ll n) {\n\tMatrix A(n, Array(n));\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\nMatrix mMul(const Matrix & A, const Matrix & B) {\n\tMatrix C(A.size(), Array(B[0].size()));\n\tfor (int i = 0; i < C.size(); ++i)\n\t\tfor (int j = 0; j < C[i].size(); ++j)\n\t\t\tfor (int k = 0; k < A[i].size(); ++k)\n\t\t\t\t(C[i][j] += (A[i][k] % MOD) * (B[k][j] % MOD)) %= MOD;\n\treturn C;\n}\n// O( n^3 log e )\nMatrix mPow(const Matrix & A, ll e) {\n\treturn e == 0 ? mIdentity(A.size()) :\n\t\te % 2 == 0 ? mPow(mMul(A, A), e / 2) : mMul(A, mPow(A, e - 1));\n}\n\ntemplate <class T>class RectangleSum {\npublic:\n\tvector<vector<T>> sum;\n\tT GetSum(int left, int right, int top, int bottom) { //[left, right], [top, bottom]\n\t\tT res = sum[bottom][right];\n\t\tif (left > 0) res -= sum[bottom][left - 1];\n\t\tif (top > 0) res -= sum[top - 1][right];\n\t\tif (left > 0 && top > 0) res += sum[top - 1][left - 1];\n\t\treturn res;\n\t}\n\tRectangleSum(const vector<vector<T>>& s, int h, int w) {\n\t\tsum.resize(h);\n\t\tfor (int i = 0; i < h; i++) sum[i].resize(w, 0);\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tsum[y][x] = s[y][x];\n\t\t\t\tif (y > 0) sum[y][x] += sum[y - 1][x];\n\t\t\t\tif (x > 0) sum[y][x] += sum[y][x - 1];\n\t\t\t\tif (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tll n, h, d;\n\tcin >> n >> h >> d;\n\tSumSegTree sum(2000010);\n\tsum.add(1, 1); sum.add(d+1, -1);\n\tll trans = 0;\n\tll now = 1;\n\tREP(i, n) {\n\t\t(now *= (i + 1)) %= MOD;\n\t\t(trans += now) %= MOD;\n\t}\n\trep(i,1,h){\n\t\tll dp = sum.sum(0, i + 1);\n\t\tdp %= MOD;\n\t\tll next = dp * trans % MOD;\n\t\tsum.add(i + 1, next);\n\t\tsum.add(min(i + 1 + d,h+1), -next);\n\t}\n\tll ans = sum.sum(0, h+1);\n\tans %= MOD;\n\t(ans *= now) %= MOD;\n\tcout << ans << endl;\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<cmath>\n#include<time.h>\n#include<set>\n#define cl_has_dh(x...) cl_get_th_100(\\\nx,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\\\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\\\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\\\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\\\n1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\\\n0)\n#define cl_get_th_100(\\\n _0, _1, _2, _3, _4, _5, _6, _7, _8, _9,\\\n_10,_11,_12,_13,_14,_15,_16,_17,_18,_19,\\\n_20,_21,_22,_23,_24,_25,_26,_27,_28,_29,\\\n_30,_31,_32,_33,_34,_35,_36,_37,_38,_39,\\\n_40,_41,_42,_43,_44,_45,_46,_47,_48,_49,\\\n_50,_51,_52,_53,_54,_55,_56,_57,_58,_59,\\\n_60,_61,_62,_63,_64,_65,_66,_67,_68,_69,\\\n_70,_71,_72,_73,_74,_75,_76,_77,_78,_79,\\\n_80,_81,_82,_83,_84,_85,_86,_87,_88,_89,\\\n_90,_91,_92,_93,_94,_95,_96,_97,_98,_99,\\\n_100,x...) _100\n#if 0\n#define cl_blzk cl_blzk0\n#else\n#define cl_blzk cl_blzk3\n#endif\n#define cl_blzk0(x...) cl_blzk1(cl_blzk1(cl_blzk1(x)))\n#define cl_blzk1(x...) cl_blzk2(cl_blzk2(cl_blzk2(x)))\n#define cl_blzk2(x...) cl_blzk3(cl_blzk3(cl_blzk3(x)))\n#define cl_blzk3(x...) cl_blzk4(cl_blzk4(cl_blzk4(x)))\n#define cl_blzk4(x...) cl_blzk5(cl_blzk5(cl_blzk5(x)))\n#define cl_blzk5(x...) cl_blzk6(cl_blzk6(cl_blzk6(x))) \n#define cl_blzk6(x...) cl_blzk7(cl_blzk7(cl_blzk7(x))) \n#define cl_blzk7(x...) x\n#define cl_lj_(a,b) a##b\n#define cl_lj(a,b) cl_lj_(a,b)\n#define cl_not(x) cl_lj(cl_not_,x)\n#define cl_not_0 1\n#define cl_not_1 0\n#define cl_and(x,y) cl_lj(cl_and_,cl_lj(x,y))\n#define cl_and_00 0\n#define cl_and_01 0\n#define cl_and_10 0\n#define cl_and_11 1\n#define cl_bif(x) cl_lj(cl_bif_,x)\n#define cl_bif_0(x...) cl_bif_0_\n#define cl_bif_0_(x...) x\n#define cl_bif_1(x...) x cl_bif_1_\n#define cl_bif_1_(x...)\n#define cl_nn(x...)\n#define cl_zzk(x...) x\n#define cl_zkk(x...) x\n#define cl_after(x...) cl_zzk cl_nn() (x)\n#define cl_txt(x...) #x\n#define cl_show(x...) puts(cl_txt(x))\n#define cl_is_nn(x...) cl_is_nnmm(x)\n#define cl_x_to_dh(x...) ,\n#define cl_is_nnmm(x...) cl_and(cl_and(cl_not(cl_has_dh(cl_x_to_dh x)),cl_has_dh(cl_x_to_dh x ())),cl_not(cl_has_dh(x ())))\ntypedef long long ll;\ntypedef long double ld;\n#define gs1(x,y,z) (quick_IO::very_important_cs_scw=y,quick_IO::very_important_cs_xsd=z,x)\n#define gs0(x,y) (quick_IO::very_important_cs_scw=y,x)\n#define gs(x,y...) cl_lj(gs,cl_has_dh(y))(x,y)\n#define read_cz(cs,_1,_01) cl_bif(_01)((+)quick_IO::whreadm(_1)cl_zkk)(()cl_nn)\n#define write_cz(cs,_1,_01) cl_bif(_01)((,)quick_IO::whwritem(_1)cl_zkk)(()cl_nn)\n#define read(x...) (cl_blzk(cl_nn cl_d(read_cz,,x) ()))\n#define write(x...) cl_blzk(cl_nn cl_d(write_cz,,x) ())\n#define cl_pp(cs,x...) cl_blzk(cl_d(cl_pp_cz,cs,x))\n#define cl_pp_cz(cs,_1,_01) cl_bif(_01)(template<>struct cs<_1>{typedef _1 Type;};)()\n#define cl_d(cz,cs,x...) cl_ds(cz,cs,x)\n#define cl_ds(cz,cs,x...) cl_lj(cl_ds_,cl_is_nn(x))(cz,cs,x)\n#define cl_ds_1(cz,cs,_1,x...) cz(cs,_1,0)\n#define cl_ds_0(cz,cs,_1,x...) cz(cs,_1,1) cl_after(cl_ds_cpy)()(cz,cs,x)\n#define cl_ds_cpy() cl_ds\n#define isdigit(x) (x >= '0' && x <= '9')\n#define pp(a,b) template<>struct a<b>{typedef b Type;};\nnamespace quick_IO {\n\tinline bool blank(char ch) {return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t';}\n  \tll very_important_cs_scw=0,very_important_cs_xsd=6,cs=0;\n  \tinline char gc() {return getchar();}\n  \tinline void pc(char c) {cs?fprintf(stderr,\"%c\",c):putchar(c);}\n\ttemplate <typename T> struct Checker1;\n\tcl_pp(Checker1,bool,int,short,long,long long,unsigned int,unsigned long,unsigned short,unsigned long long,double,long double,float)\n\ttemplate <typename T> struct Checker2;\n\tcl_pp(Checker2,char)\n\tchar lastc=-2;\n\ttemplate <typename T>inline ll readm(typename Checker1<T>::Type&x) {\n\t    register double tmp=1;register bool sign=0; x=0;register char ch=lastc==-2?gc():lastc;\n\t    for (;!isdigit(ch);ch=gc()) if(ch=='-') sign=1;else if(ch==EOF) return 0;for (;isdigit(ch);ch=gc()) x=x*10+(ch-'0');\n\t    if (ch=='.') for (ch=gc();isdigit(ch);ch=gc()) tmp/=10.0,x+=tmp*(ch-'0');if (sign) x=-x;\n\t    lastc=ch;return 1;\n\t}\n\ttemplate <typename T>inline ll readm(typename Checker2<T>::Type&c) {\n\t\tfor(c=lastc==-2?gc():lastc;blank(c);c=gc());if(c==EOF)return 0;\n\t\tlastc=-2;return 1;\n\t}\n  \tinline ll readm(char *s)\n\t{\n    \tregister char ch=lastc==-2?gc():lastc;for (;blank(ch)&&~ch;ch=gc())if(ch==EOF)return 0;\n\t\tfor (;~ch&&!blank(ch);ch=gc()) *s++=ch;*s=0;lastc=-2;return 1;\n  \t}\n\tvoid writellm(ll c,ll x) {\n\t\tif(c<0)pc('-'),c=-c,x--;\n\t\tif(c<10)return ({for(ll i=1;i<=x-1;i++)pc(' ');pc(c^48);void(0);});\n\t\twritellm(c/10,x-1);pc((c%10)^48);\n\t}\n\ttemplate<typename T>ll whreadm(T*x){return readm(x);};\n\ttemplate<typename T>ll whreadm(T&x){return readm<T>(x);};\n\t\t#define x very_important_cs_xsd\n\t\t#define y very_important_cs_scw\n\ttemplate<typename T>void writem(typename Checker2<T>::Type c) {\n\t\tfor(ll i=1;i<=y-1;i++)pc(' ');pc(c);\n\t}\n\ttemplate <typename T> struct Checkers1;\n\tcl_pp(Checkers1,bool,int,short,long,long long,unsigned int,unsigned long,unsigned long long)\n\ttemplate <typename T>inline void ycl(typename Checkers1<T>::Type c){x=0;}\n\ttemplate <typename T>void ycl(T&c){long double ys=0.5;for(ll i=1;i<=x;i++)ys/=10;c+=ys;}\n\ttemplate<typename T>void writem(typename Checker1<T>::Type c) {\n\t\tif(c<0)putchar('-'),c=-c;\n\t\tycl<T>(c);\n\t\twritellm(ll(c),y-(x?x+1:0));c-=ll(c);if(!x)return;\n\t\tpc('.');for(ll i=1;i<=x;i++)c*=10,pc(int(c)^48),c-=char(c);\n\t}\n\tvoid writem(const char* c) {\n\t\tll len=std::strlen(c);for(ll i=1;i<=y-len;i++)pc(' ');\n\t\twhile(*c)pc(*c++); \n\t}\n\t#undef x\n\t#undef y\n\ttemplate<typename T>void whwritem(T*x){writem(x);very_important_cs_scw=0,very_important_cs_xsd=6;};\n\ttemplate<typename T>void whwritem(T x){writem<T>(x);very_important_cs_scw=0,very_important_cs_xsd=6;};\n}\n#define IO_debug 0\n#define IO(x) freopen(#x\".in\",\"r\",stdin)cl_bif(IO_debug)()(;freopen(#x\".out\",\"w\",stdout))\n#define bla ,(((zjhyyds))),\n#define cl_del_3_kh(x...) cl_bif(cl_has_3_kh(x))(cl_del_2_kh x)(x)\n#define cl_del_2_kh(x...) cl_bif(cl_has_2_kh(x))(cl_del_1_kh x)(x)\n#define cl_del_1_kh(x...) cl_bif(cl_has_1_kh(x))(cl_zkk x)(x)\n#define cl_has_3_kh(x...) cl_bif(cl_has_1_kh(x))(cl_has_2_kh x)(0)\n#define cl_has_2_kh(x...) cl_bif(cl_has_1_kh(x))(cl_has_1_kh x)(0)\n#define cl_has_1_kh(x...) cl_is_nn(cl_nn x)\n#define is_zjhyyds(x) cl_bif(cl_has_3_kh(x))(cl_is_nn(is_zjhyyds_(x)))(0)\n#define is_zjhyyds_(x) cl_lj(is_zjhyyds_s,cl_del_3_kh(x))\n#define is_zjhyyds_szjhyyds\n#define cl_rir_dh(cs,x...) cl_zzk(cl_nn cl_rir(cs,(,)x cl_zzk)())\n#define cl_rir(cs,x...) cl_blzk(cl_d(cl_rir_cz,(x),cl_zkk cs))\n#define cl_rir_cz(cs,_1,_01) cl_bif(_01)(cl_after(cl_hg_cpy)()(_1,cl_zkk cs))()\n#define cl_hg_cpy() cl_hg\n#define cl_hg(cs,x...) cl_nn cl_after(cl_ds_cpy)()(cl_hg_cz,cs,x)()\n#define cl_hg_cz(cs,_1,_01) cl_bif(_01)(cl_bif(is_zjhyyds(_1))(()cs cl_nn)((,)_1 cl_zkk))(()cl_nn)\nll readll(void){ll x=0,w=1;char c=getchar();for(;c<'0'||c>'9';(c-'-')||(w=-w),c=getchar());for(;c>='0'&&c<='9';x=(x<<1)+(x<<3)+(c^48),c=getchar());return x*w;}\n#define cl_rill(x...) cl_blzk(cl_nn cl_d(cl_rill_cz,,x)())\n#define rill(x...) cl_rill(x)\n#define cl_rill_cz(cs,_1,_01) cl_bif(_01)((,)_1=readll()cl_zkk)(()cl_nn)\n#define writeln(x...) cl_bif(cl_is_nn(x))(write('\\n'))(write(x,'\\n'))\n#define rep(cs,low,up,x...) rfor(ll cs=low;cs<=up;cl_bif(cl_is_nn(x))(++cs)(x))\n#define frh(cs,cz,low,up,x...) rfor(ll cs,cl_lj(WCR_yyds_,cs)=low;cs=cz[cl_lj(WCR_yyds_,cs)],cl_lj(WCR_yyds_,cs)<=up;cl_lj(WCR_yyds_,cs)++)cl_bif(cl_is_nn(x))()(if(x))\n#define per(cs,low,up,x...) rfor(ll cs=low;cs>=up;cl_bif(cl_is_nn(x))(--cs)(x))\n#define cl_hsdd(hs,x...) cl_blzk(cl_bif(cl_is_nn(x))()(cl_hsdd_(hs,x)))\n#define cl_hsdd_(hs,_1,x...) cl_lj(cl_hsdd_,cl_is_nn(x))(hs,_1,x)\n#define cl_hsdd_1(hs,_1,x...) _1\n#define cl_hsdd_0(hs,_1,x...) hs(_1,cl_after(cl_hsdd_cpy)()(hs,x))\n#define cl_hsdd_cpy() cl_hsdd_\n#define max(x...) cl_hsdd(std::max,x)\n#define min(x...) cl_hsdd(std::min,x)\n#define rfor(x...) for(register x)\n#define ssscc 1\n#if 1\n#define debug(x...) quick_IO::cs=ssscc,write(x),quick_IO::cs=0\n#define debugln(x...) quick_IO::cs=ssscc,writeln(x),quick_IO::cs=0\n#else\n#define debug(x...) quick_IO::cs=0\n#define debugln(x...) quick_IO::cs=0\n#endif\n#define fin(a,b,c) rfor(ll a=cl_bif(cl_is_nn(c))(b)(c);a>=0;a&&(--a&=b)||(a=-1))\nll n,f[1145141];\nconst ll mod=1e9+7;\nll pow(ll x,ll y){ll ans=1;for(;y;(y&1)&&((ans*=x)%=mod),(x*=x)%=mod,y>>=1);return ans;}\nint main(){\n\t//IO(E);\n\tll rill(n,h,d);\n\tll jcn=1,jc1_n=0,s=1;rep(i,1,n)jcn=jcn*i%mod,jc1_n=jc1_n+jcn;jc1_n%=mod;\n\tf[0]=1;rep(i,1,h)(i>d)&&({s-=f[i-d-1];if(s<0)s+=mod;s;}),s+=f[i]=s*jc1_n%mod;\n\twriteln(f[h]*jcn%mod*pow(jc1_n,mod-2)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nint D, H;\nll mod = 1000000007;\nll dp[1000010], cmp[1000010] = {0};\nll F[1000010] = {1};\nll FF;\n\nint main()\n{\n    cin >> N >> H >> D;\n\n    for(int i = 1; i < 1000010; i++)\n    {\n        F[i] = (F[i - 1] * i) % mod;\n        if(i <= N)FF = (FF + F[i]) % mod;\n    }\n    dp[0] = cmp[0] = F[N];\n\n    for(int i = 1; i < H; i++)\n    {\n        dp[i] = (mod + cmp[i - 1] - ((i - D - 1 >= 0) ? cmp[i - D - 1] : 0)) % mod;\n        dp[i] = dp[i] * FF % mod;\n        cmp[i] = (cmp[i - 1] + dp[i]) % mod;\n    }\n    cout << (mod + cmp[H - 1] - ((H - D - 1 >= 0) ? cmp[H - D - 1] : 0)) % mod << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <cmath>\n# include <algorithm>\n# include <stdio.h>\n# include <cstdint>\n# include <cstring>\n# include <string>\n# include <cstdlib>\n# include <vector>\n# include <bitset>\n# include <map>\n# include <queue>\n# include <ctime>\n# include <stack>\n# include <set>\n# include <list>\n# include <random>\n# include <deque>\n# include <functional>\n# include <iomanip>\n# include <sstream>\n# include <fstream>\n# include <complex>\n# include <numeric>\n# include <immintrin.h>\n# include <cassert>\n# include <array>\n# include <tuple>\n# include <unordered_set>\n# include <unordered_map>\nusing namespace std;\nconst long long md = 1e9 + 7;\n\nint n, h, d;\nlong long dp[1000005], dp2[1000005];\n\nint main(int argc, const char * argv[]) {\n#ifdef __APPLE__\n    freopen(\"/Users/danya.smelskiy/Documents/Danya/Resources/input.txt\",\"r\",stdin);\n    //freopen(\"/Users/danya.smelskiy/Documents/Danya/Danya/output.out\", \"w\", stdout);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> h >> d;\n    long long f = 1, ff = 0;\n    for (int i = 1; i <= n; ++i) {\n        f = (f * 1ll * i) % md;\n        ff += f;\n        if (ff >= md) ff -= md;\n    }\n    dp[0] = 1;\n    dp2[0] = 1;\n    int l, r;\n    long long cur;\n    for (int i = 1; i <= h; ++i) {\n        l = i - d - 1;\n        r = i - 1;\n        cur = dp2[r];\n        if (l >= 0) {\n            cur -= dp2[l];\n            if (cur < 0) cur += md;\n        }\n        if (i < h) {\n            cur *= ff;\n            cur %= md;\n        } else {\n            cur *= f;\n            cur %= md;\n        }\n        dp[i] = cur;\n        dp2[i] = dp2[i - 1] + cur;\n        if (dp2[i] >= md) dp2[i] -= md;\n    }\n    cout << dp[h] << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\ntypedef long long ll;\nusing namespace std;\n\nll dp[1000010], mod=1000000007;\n\nint main(void){\n    int N, H, D;\n    cin >> N >> H >> D;\n    ll mult=0;\n    dp[0]=1;\n    for(int i=1; i<=N; ++i){\n        (dp[0] *= i) %= mod;\n        (mult += dp[0]) %= mod;\n    }\n    ll sum=dp[0];\n    for(int i=1; i<H; ++i){\n        dp[i]=(sum*mult)%mod;\n        if(i>=D) (sum += mod-dp[i-D]) %= mod;\n        (sum += dp[i]) %= mod;\n    }\n    cout << sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  long long N,H,D;\n  cin >> N >> H >> D;\n  vector<long long> dp(H,0);\n  vector<long long> totdp(H,0);\n  long long ii = 1;\n  long long ic;\n  long long iii = 0;\n  for (int i=1; i<N+1; i++) {\n    ic = i;\n    ii *= ic;\n    ii %= 1000000007;\n    iii += ii;\n    iii %= 1000000007;\n  }\n  dp[0] = ii;\n  totdp[0] = ii;\n  \n  cerr << ii << endl;\n  for (int i=1; i<H; i++) {\n      \n    dp[i] = totdp[i-1];\n    if (i > D) {\n      dp[i] += 1000000007;\n      dp[i] -= totdp[i-D-1];\n    }\n    dp[i] %= 1000000007;\n    dp[i] *= iii;\n    dp[i] %= 1000000007;\n    totdp[i] = totdp[i-1] + dp[i];\n    totdp[i] %= 1000000007;\n    cerr << dp[i] << endl;\n  }\n  \n  long long ans = totdp[H-1];\n  ans += 1000000007;\n  if (H > D) {\n    ans -= totdp[H-D-1];\n  }\n  ans %= 1000000007;\n  cout << ans << endl;\n    \n  cerr << iii;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long ll;\nconst int mod=1000000007;\nint f[1000050],g[1000050],s[1000050];\nint main(){\n\tint n,h,d,p,i;\n\tscanf(\"%d%d%d\",&n,&h,&d);\n\tf[0]=f[1]=1;\n\tfor(i=2;i<=n;++i)f[i]=(ll)f[i-1]*i%mod;\n\tp=2;\n\tfor(i=2;i<=n;++i)p=(p+f[i])%mod;\n\ts[1]=g[1]=f[n];\n\tfor(i=2;i<=d;++i)s[i]=(s[i-1]+(g[i]=(ll)g[i-1]*p%mod))%mod;\n\tfor(i=d+1;i<=h;++i){\n\t\tg[i]=(ll)(s[i-1]-s[i-d-1]+mod)*(p-1+mod)%mod;\n\t\ts[i]=(s[i-1]+g[i])%mod;\n\t}\n\tprintf(\"%d\\n\",g[h]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\ntemplate<ll mod> struct Mod_Int{\n    ll x;\n    Mod_Int() {}\n    Mod_Int(ll y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod){}\n\n    Mod_Int &operator += (const Mod_Int &p) {\n        x = (x + p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator -= (const Mod_Int &p) {\n        x = (x + mod - p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator *= (const Mod_Int &p) {\n        x = (x * p.x) % mod;\n        return *this;\n    }\n\n    Mod_Int &operator /= (const Mod_Int &p) {\n        *this *= p.inverse();\n        return *this;\n    }\n\n    Mod_Int operator -() const {return Mod_Int(-x);}\n\n    Mod_Int operator + (const Mod_Int &p) const {return Mod_Int(*this) += p;}\n\n    Mod_Int operator - (const Mod_Int &p) const {return Mod_Int(*this) -= p;}\n\n    Mod_Int operator * (const Mod_Int &p) const {return Mod_Int(*this) *= p;}\n\n    Mod_Int operator / (const Mod_Int &p) const {return Mod_Int(*this) /= p;}\n\n    bool operator == (const Mod_Int &p) const {return x == p.x;}\n\n    bool operator != (const Mod_Int &p) const {return x != p.x;}\n\n    Mod_Int pow(ll n) const{\n        Mod_Int now = *this, ret = 1;\n        while(n > 0){\n            if(n & 1) ret *= now;\n            now *= now, n >>= 1;\n        }\n        return ret;\n    }\n\n    Mod_Int inverse() const{\n        return pow(mod-2);\n    }\n};\n\nusing mint = Mod_Int<MOD>;\nconst int MAX_N = 1e6;\nmint fac[MAX_N+1];\n\nvoid init(){\n    fac[0] = 1;\n    rep2(i, 1, MAX_N){\n        fac[i] = fac[i-1]*mint(i);\n    }\n}\n\nmint comb(mint n, mint k){\n    return fac[n.x]/(fac[n.x-k.x]*fac[k.x]);\n}\n\nmint perm(mint n, mint k){\n    return fac[n.x]/fac[n.x-k.x];\n}\n\nint main(){\n    init();\n    int N, H, D;\n    cin >> N >> H >> D;\n    mint S = 0;\n    rep2(i, 1, N) S += fac[i];\n    mint dp[H+1], sum[H+2];\n    fill(dp, dp+H+1, 0);\n    sum[0] = 0;\n    dp[0] = sum[1] = 1;\n    rep2(i, 1, D) dp[i] = fac[N];\n    rep2(i, 1, H){\n        dp[i] += (sum[i]-sum[max(1, i-D)])*S;\n        sum[i+1] = sum[i]+dp[i];\n    }\n    mint ans = 0;\n    cout << dp[H].x << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define inf 1000000010\n#define N 1000010\n#define P 1000000007\nchar getc(){char c=getchar();while ((c<'A'||c>'Z')&&(c<'a'||c>'z')&&(c<'0'||c>'9')) c=getchar();return c;}\nint gcd(int n,int m){return m==0?n:gcd(m,n%m);}\nint read()\n{\n\tint x=0,f=1;char c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\treturn x*f;\n}\nint n,h,d,f[N],sum[N],s,t;\nint ksm(int a,int k)\n{\n\tint s=1;\n\tfor (;k;k>>=1,a=1ll*a*a%P) if (k&1) s=1ll*s*a%P;\n\treturn s;\n}\nint inv(int a){return ksm(a,P-2);}\nsigned main()\n{\n\tn=read(),h=read(),d=read();\n\ts=t=1;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tt=1ll*t*i%P;\n\t\ts=(s+t)%P;\n\t}\n\tf[0]=inv(s);sum[0]=f[0];\n\tfor (int i=1;i<=h;i++)\n\t{\n\t\tint u=(sum[i-1]-(i>d?sum[i-d-1]:0)+P)%P;\n\t\tf[i]=1ll*u*s%P;\n\t\tsum[i]=(sum[i-1]+f[i])%P;\n\t}\n\tfor (int i=n-1;i>=1;i--) f[h]=1ll*f[h]*i%P;\n\tcout<<1ll*f[h]*n%P;\n\treturn 0;\n\t//NOTICE LONG LONG!!!!!\n}\n//一个序列，每次将某个最小值改成最大值~最大值+d之间的数，求令序列所有数均为h的方案数\n//只与最大值是啥以及有几个最大值有几个最小值有关 \n//最小值移动时的选择方案数 可以直接在移动最大值时乘上移动后的最大值数量 \n//f[i][j]最大值为i且有j个时的方案数\n//f[i][j]=f[i][j-1]*j (j>1)\n//f[i][1]=Σf[i-x][y] (x=1~D,y=1~n) \n//Σf[i][x]=f[i][1]*(1+(n-1)+(n-1)*(n-2)+……) "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconst int N=1e6+5;\nconst int p=1e9+7;\n\nint read()\n{\n\tint s=0;\n\tchar c=getchar(),lc='+';\n\twhile (c<'0'||'9'<c) lc=c,c=getchar();\n\twhile ('0'<=c&&c<='9') s=s*10+c-'0',c=getchar();\n\treturn lc=='-'?-s:s;\n}\nvoid write(int x)\n{\n\tif (x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tif (x<10) putchar(x+'0');\n\telse\n\t{\n\t\twrite(x/10);\n\t\tputchar(x%10+'0');\n\t}\n}\nvoid print(int x,char c='\\n')\n{\n\twrite(x);\n\tputchar(c);\n}\nint power(int a,int b)\n{\n\ta%=p;\n\tint ret=1;\n\twhile (b)\n\t{\n\t\tif (b&1) ret=ret*a%p;\n\t\ta=a*a%p;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint fact[N],SUM=0,dp[N],sum[N];\n\nsigned main()\n{\n\tint n=read(),h=read(),d=read();\n\tfact[0]=1;\n\tsum[0]=dp[0]=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfact[i]=fact[i-1]*i%p;\n\t\tSUM=(SUM+fact[i])%p;\n\t}\n\tfor (int i=1;i<=h;i++)\n\t{\n\t\tdp[i]=(sum[i-1]-(i-d-1>=0?sum[i-d-1]:0)+p)%p*SUM%p;\n\t\tsum[i]=(sum[i-1]+dp[i])%p;\n\t}\n\tprint(dp[h]*fact[n]%p*power(SUM,p-2)%p);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\n#define REP(NAME, NUM) for (int NAME = 0; NAME < (NUM); ++NAME)\n#define BREP(NAME, NUM) for (int NAME = (NUM)-1; NAME >= 0; --NAME)\n#define ALL(NAME) (NAME).begin(), (NAME).end()\n\n#define cMOD 1000000007ULL\n#define cINF ((1ll<<62)-1)\n#define cINFINT ((1<<30)-1)\n\n\ntemplate <typename T>\nvoid calcFactional_mod( size_t size, \n\tvector<T>& fac, vector<T>& inv, vector<T>& facInv, T mod )\n{\n\tfor( T i = 2; i < size; ++i )\n\t{\n\t\tfac[i] = fac[i - 1] * i % mod; // n! % mod\n\t\tinv[i] = mod - inv[mod % i] * ( mod / i ) % mod; // 逆元計算 (n)^-1 % mod\n\t\tfacInv[i] = facInv[i - 1] * inv[i] % mod; // (n!)^-1 % mod\n\t}\n}\ntemplate <typename T>\nT pow_mod(T x, T n, T mod)\n{\n\tT res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)\n\t\t\tres = (res * x) % mod;\n\t\tx = (x * x) % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tconst ll maxN = 1000010;\n\tvector<ll> fac( maxN, 1 ), inv( maxN, 1 ), facInv( maxN, 1 );\n\tcalcFactional_mod<ll>( maxN, fac, inv, facInv, cMOD);\n\tauto mod = cMOD;\n\tauto add = [mod]      ( ll a, ll b ) { return ( a + b ) % mod; };\n\tauto sub = [mod]      ( ll a, ll b ) { return ( a + mod -b ) % mod; };\n\tauto mul = [mod]      ( ll a, ll b ) { return a * b % mod; };\n\tauto div = [&inv, mod]( ll a, ll b ) { return a * inv[b] % mod; };\n\tauto pow = [mod]      ( ll a, ll b ) { return pow_mod<ll>( a, b, mod ); };\n\t\n\tll n,h,d; cin >> n>>h>>d;\n\tll nsum = 0;\n\tREP(i,n) nsum = add( nsum, fac[i+1] ); \n\n\tvector<ll> dp( h, 0 );\n\tdp[0]=1;\n\tREP(i,h) if(i!=0)\n\t{\n\t\tll t = sub( dp[i-1], (i-1-d>=0 ? dp[i-1-d] : 0) );\n\t\tdp[i] = add( mul( t, nsum ), dp[i-1] );\n\t}\n\n\tll ans = sub( dp[h-1], (h-1-d>=0 ? dp[h-1-d] : 0) );\n\tans = mul( ans, fac[n] );\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\n#define N 500000\nll MOD=1e9+7;\n\nll mat[11][11];\n//遅延評価\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree\n{\n  using F = function< Monoid(Monoid, Monoid) >;\n  using G = function< Monoid(Monoid, OperatorMonoid) >;\n  using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n  using P = function< OperatorMonoid(OperatorMonoid, int) >;\n \n  int sz;\n  vector< Monoid > data;\n  vector< OperatorMonoid > lazy;\n  const F f;\n  const G g;\n  const H h;\n  const P p;\n  const Monoid M1;\n  const OperatorMonoid OM0;\n \n \n  LazySegmentTree(int n, const F f, const G g, const H h, const P p,\n                  const Monoid &M1, const OperatorMonoid OM0)\n      : f(f), g(g), h(h), p(p), M1(M1), OM0(OM0)\n  {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    data.assign(2 * sz, M1);\n    lazy.assign(2 * sz, OM0);\n  }\n \n  void set(int k, const Monoid &x)\n  {\n    data[k + sz] = x;\n  }\n \n  void build()\n  {\n    for(int k = sz - 1; k > 0; k--) {\n      data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n    }\n  }\n \n  void propagate(int k, int len)\n  {\n    if(lazy[k] != OM0) {\n      if(k < sz) {\n        lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n        lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n      }\n      data[k] = g(data[k], p(lazy[k], len));\n      lazy[k] = OM0;\n    }\n  }\n \n  Monoid update(int a, int b, const OperatorMonoid &x, int k, int l, int r)\n  {\n    propagate(k, r - l);\n    if(r <= a || b <= l) {\n      return data[k];\n    } else if(a <= l && r <= b) {\n      lazy[k] = h(lazy[k], x);\n      propagate(k, r - l);\n      return data[k];\n    } else {\n      return data[k] = f(update(a, b, x, 2 * k + 0, l, (l + r) >> 1),\n                         update(a, b, x, 2 * k + 1, (l + r) >> 1, r));\n    }\n  }\n \n  Monoid update(int a, int b, const OperatorMonoid &x)\n  {\n    return update(a, b, x, 1, 0, sz);\n  }\n \n \n  Monoid query(int a, int b, int k, int l, int r)\n  {\n    propagate(k, r - l);\n    if(r <= a || b <= l) {\n      return M1;\n    } else if(a <= l && r <= b) {\n      return data[k];\n    } else {\n      return f(query(a, b, 2 * k + 0, l, (l + r) >> 1),\n               query(a, b, 2 * k + 1, (l + r) >> 1, r));\n    }\n  }\n \n  Monoid query(int a, int b)\n  {\n    return query(a, b, 1, 0, sz);\n  }\n \n  Monoid operator[](const int &k)\n  {\n    return query(k, k + 1);\n  }\n};\nauto f=[](ll a,ll b){return (a+b)%MOD;};\nauto g=[](ll a,ll b){return (a*b)%MOD;};\nauto ff=[](ll a,ll b){return b;};\nauto h=[](ll a,ll b){return (ll)max(a,b);};\nauto p=[](ll a,ll b){return a;};\n//例\n//区間add　区間min\nLazySegmentTree<ll> dp(2100000,f,f,f,g,INF,0);\n//区間add 区間sum\n//LazySegmentTree<ll> seg(n,f,f,f,g,0,0);\n \n \n//LazySegmentTree(n,f,g,h,p,M1,OM0) \n//サイズnで初期化\n//fは二つの区間の要素をマージする二項演算\n//gは要素と作用素をマージする二項演算(第三因数は区間の長さ)\n//hは作用素同士をマージする二項演算\n//p(value,length)は作用素を下におろした時の演算\n//M1はモノイドの単位元\n//OM0は作用素の単位元\n//update(a,b,x) 区間[a,b)に作用素 x を作用\n//query(a,b) 区間[a,b) の値\nmain(){\n    ll n=in(),h=in(),d=in();\n    //LazySegmentTree<ll> dp(h+d+100,h,f,f,p,LLINF,0ll);\n    dp.update(0,1,n);\n    ll ans=0;\n    rep2(i,0,h-1){\n        if(i+d<h){\n            dp.update(i+1,i+d+1,dp[i]*((n*(n+1)/2)%MOD)%MOD);\n        }\n        else{\n            dp.update(i+1,i+d+1,dp[i]*((n*(n+1)/2)%MOD)%MOD);\n            ans=(ans+dp[i])%MOD;\n        }\n        /*rep2(j,i+1,i+d){\n            if(j==h)dp[j]=(dp[j]+dp[i])%MOD;\n            else\n            dp[j]=(dp[j]+dp[i]*((n*(n+1)/2)%MOD)%MOD)%MOD;\n        }*/\n    }\n    cout<<ans%MOD;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nlong long fact[1100000];\nlong long sum[1100000];\nlong long dp[1100000];\nlong long bit[1100000];\nlong long calc(int a,int b){\n\tif(a>b)return 0;\n\tif(a)return (mod+calc(0,b)-calc(0,a-1))%mod;\n\tlong long ret=0;\n\tfor(;b>=0;b=(b&(b+1))-1)ret=(ret+bit[b])%mod;\n\treturn ret;\n}\nvoid add(int a,long long b){\n\tfor(;a<1100000;a|=a+1)bit[a]=(bit[a]+b)%mod;\n}\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tfact[0]=1;\n\tfor(int i=1;i<1100000;i++)fact[i]=fact[i-1]*i%mod;\n\tlong long cur=0;\n\tfor(int i=1;i<=a;i++)cur=(cur+fact[i])%mod;\n\tdp[0]=1;\n\tadd(0,1);\n\tfor(int i=1;i<=b;i++){\n\t\tlong long tmp=calc(max(1,i-c),i-1)*cur%mod;\n\t\tif(i-c<=0)tmp=(tmp+fact[a])%mod;\n\t\tdp[i]=tmp;\n\t//\tprintf(\"%d: %lld\\n\",i,dp[i]);\n\t\tadd(i,tmp);\n\t}\n\tprintf(\"%lld\\n\",dp[b]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define mod 1000000007LL\n#define maxn 100005\n#define IN freopen(\"C.in\",\"r\",stdin)\n#define OUT freopen(\"output.txt\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG pf(\"Hi\\n\")\n#define INF 1000000000\n#define i64 long long int\n#define eps (1e-8)\n#define xx first\n#define yy second\n#define ln 17\n#define off 2\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<i64, i64> pii;\n\n\nclass numberTheory{\n\npublic:\n    numberTheory(){}\n\n    pii extendedEuclid(i64 a, i64 b) { // returns x, y | ax + by = gcd(a,b)\n\n        if(b == 0) return pii( a >= 0 ? 1 : -1 , 0LL);\n        else {\n            pii d = extendedEuclid(b, a % b);\n            return pii(d.yy, d.xx - d.yy * (a / b));\n        }\n\n    }\n\n    i64 modularInverse(i64 a, i64 n) {\n        pair<i64,i64> ret = extendedEuclid(a, n);\n        return ((ret.xx % n) + n) % n;\n    }\n\n\n    i64 bigMod(i64 a, i64 n , i64 m)\n    {\n        if(n==0) return 1 ;\n        i64 ret = bigMod(a,n/2,m) ;\n        ret = (ret*ret)%m ;\n        if(n%2) ret = (ret*a)%m ;\n        return ret ;\n    }\n};\n\nconst i64 N = 2000000 ;\n\ni64 fact[N+5] , invFact[N+5] ;\n\ni64 C(i64 n, i64 r)\n{\n    if( n<0 || r<0 || r>n ) return 0 ;\n    i64 ret = (fact[n]*invFact[r])%mod ;\n    return (ret*invFact[n-r])%mod ;\n}\n\nvoid preprocess()\n{\n    numberTheory nt ;\n\n    fact[0] = 1 ;\n    for(i64 x=1 ; x<=N ; x++) fact[x] = (fact[x-1]*x)%mod ;\n\n    invFact[N] = nt.modularInverse(fact[N],mod) ;\n\n    for(i64 x=N-1 ; x>=0 ; x--) invFact[x] = (invFact[x+1]*(x+1) )%mod ;\n}\n\ni64 ans[N+5] , dp[N+5] ;\n\nint main()\n{\n    preprocess() ;\n\n    numberTheory nt ;\n\n    i64 n , h , d ;\n\n    scanf(\"%lld %lld %lld\",&n,&h,&d) ;\n\n    ans[0] = 1 ;\n    dp[0] = ( 1LL*ans[0]* fact[n] )%mod ;\n\n    i64 m = 0 ;\n\n    for(i64 i=1 ; i<=n ; i++) m = (m+fact[i] )%mod ;\n\n //   printf(\"%lld %lld\\n\",ans[0],dp[0]) ;\n\n    for(i64 i=1 ; i<=h ; i++)\n    {\n        ans[i] = dp[i-1] ;\n\n        if( i>d  ) ans[i] = (ans[i]- dp[i-d-1])%mod ;\n\n        dp[i] = (ans[i]*m)%mod ;\n        dp[i] = (dp[i-1] +dp[i])%mod ;\n\n   //     printf(\"%lld %lld\\n\",ans[i],dp[i]) ;\n    }\n    ans[h] = (ans[h]%mod + mod)%mod ;\n\n    printf(\"%lld\\n\",ans[h]) ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll modminus(ll x, ll y) {\n    return (x - y + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll modpower(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y == 1) {\n        return x % mod;\n    } else if (y % 2 == 0) {\n        ll p = modpower(x, y / 2);\n        return p * p % mod;\n    } else {\n        ll p = modpower (x, y / 2);\n        return (p * p) % mod * (x % mod) % mod;\n    }\n}\n\nll divide(ll x, ll y) {\n    return multiply(x, modpower(y, mod - 2));\n}\n\nll frac[1000020];\nll invfrac[1000020];\n\nvoid fracinvfrac(ll n) {\n    frac[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        frac[i] = multiply(frac[i - 1], i);\n    }\n    invfrac[n] = divide(1, frac[n]);\n    for (int i = n - 1; i >= 0; i--) {\n        invfrac[i] = multiply(invfrac[i + 1], i + 1);\n    }\n}\n\nll modcombi(ll x, ll y) {\n    if (x < y || y < 0) {\n        return 0;\n    } else if (y == 0) {\n        return 1;\n    } else {\n        return multiply(multiply(frac[x], invfrac[x - y]), invfrac[y]);\n    }\n}\n\nll dp[1000010];\nll fracsum[1000010];\n// ll invfracsum[1000010];\n\nint main() {\n    fracinvfrac(1000010);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N, H, D;\n    cin >> N >> H >> D;\n    fracsum[1] = frac[1];\n    REP(i, 2, 1000010) {\n        fracsum[i] = modadd(fracsum[i - 1], frac[i]);\n    }\n    dp[0] = frac[N];\n    ll sum = dp[0];\n    REP(i, 1, H) {\n        dp[i] = multiply(sum, fracsum[N]);\n        sum = modadd(sum, dp[i]);\n        if (i - D >= 0) {\n            sum = modadd(sum, -dp[i - D]);\n        }\n    }\n    ll ans = 0;\n    PER(i, H - 1, H - D - 1) {\n        ans = modadd(ans, dp[i]);\n    }\n    // invfracsum[1] = invfrac[1];\n    // REP(i, 2, 1000010) {\n    //     invfracsum[i] = invfracsum[i - 1] + invfrac[i];\n    // }\n    // dp[0] = 1;\n    // ll sum = 1;\n    // REP(i, 1, H + 1) {\n    //     ll val = multiply(frac[N], invfracsum[N - 1] + 1);\n    //     dp[i] = multiply(sum, val);\n    //     sum = modadd(sum, dp[i]);\n    //     if (i - D - 1 >= 0) {\n    //         sum = modadd(sum, -dp[i - D - 1]);\n    //     }\n    // }\n    // REP(i, 0, H) {\n    //     cout << dp[i] << \" \";\n    // }\n    // cout << endl;\n    // ll ans = 0;\n    // PER(i, H - 1, H - D - 1) {\n    //     ans = modadd(ans, dp[i]);\n    // }\n    // ans = multiply(ans, frac[N]);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC optimize (\"unroll-loops\")\n// #pragma GCC target (\"avx2\")\n\n\n#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 20000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX * 2 + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\null gin[N_MAX];\n// here we go\n\nsll xa, ya, za;\nsll xb, yb, zb;\n\nvoid sw (sll *l, sll *r) {\n\tsll t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\null frac[N_MAX];\null dp[N_MAX];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tull sf = 0;\n\n\tfrac[0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tfrac[i] = (frac[i - 1] * i) % MOD;\n\t\tsf += frac[i];\n\t}\n\tsf %= MOD;\n\n\tsum = dp[0] = 0;\n\tfor (i = 1; i <= h; i++) {\n\t\tdp[i] = sum * (sf % MOD) % MOD;\n\t\t// if (i <= k) dp[i] = (MOD + dp[i] - 1) % MOD;\n\t\tif (i <= k) dp[i] = (dp[i] + frac[n]) % MOD;\n\t\tsum += dp[i];\n\n\t\tif (i >= k) sum += MOD - dp[i - k];\n\t\tsum %= MOD;\n\n\t\t// printf(\"%llu %llu..\\n\", dp[i], sum);\n\t}\n\n\tresult = dp[h];\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15f\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 5;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\tscanf(\"%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\tscanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < 0; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m);\n\t// for (i = 0; i < m; i++) {\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// scanf(\"%lld\", &e[i]);\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n\ntypedef int32_t i32;\ntypedef int64_t i64;\n\nconst i32 mod = 1000000007;\n\ni32 mod_pow (i32 r, i32 n) {\n  i32 t = 1;\n  i32 s = r;\n  while (n > 0) {\n    if (n & 1) t = (i64) t * s % mod;\n    s = (i64) s * s % mod;\n    n >>= 1;\n  }\n  return t;\n}\n\ni32 inv (i32 a) {\n  return mod_pow (a, mod - 2);\n}\n\ni32 *fact = NULL;\ni32 *iFact = NULL;\nvoid init_fact (const i32 n) {\n  fact = (i32 *) calloc (n + 1, sizeof (i32));\n  fact[0] = 1;\n  for (i32 i = 1; i <= n; ++i) {\n    fact[i] = (i64) i * fact[i - 1] % mod;\n  }\n  iFact = (i32 *) calloc (n + 1, sizeof (i32));\n  iFact[n] = inv (fact[n]);\n  for (i32 i = n - 1; i >= 0; --i) {\n    iFact[i] = (i64) (i + 1) * iFact[i + 1] % mod;\n  }\n}\n\n#define ALLOC(size,type) ((type*)calloc((size),sizeof(type)))\n\nvoid run (void) {\n  i32 n, h, d;\n  scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, &n, &h, &d);\n  init_fact (n);\n  i64 p = 0;\n  for (i32 i = 1; i <= n; ++i) {\n    p += fact[i];\n  }\n  p %= mod;\n  i32 *dp = ALLOC (h + d, i32) + d;\n  dp[0] = fact[n];\n  i64 sum = dp[0];\n  for (i32 i = 1; i < h; ++i) {\n    dp[i] = sum * p % mod;\n    sum = (sum + dp[i] + mod - dp[i - d]) % mod;\n  }\n  printf (\"%\" PRIi64 \"\\n\", sum);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    srand(time(0));\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nlong long factorial[1048576];\n\nvoid cfact(){\n    long long i;\n    factorial[0]=1;\n    factorial[1]=1;\n    for(i=2;i<1048576;i++){\n        factorial[i]=factorial[i-1]*i;\n        factorial[i]%=mod;\n    }\n}\n\nlong long power(long long a, long long b){\n\tlong long x = 1, y = a;\n\twhile (b > 0){\n\t\tif(b%2){\n\t\t\tx = (x*y)%mod;\n\t\t}\n\t\ty = (y*y)%mod;\n\t\tb /= 2;\n\t}\n\treturn x%mod;\n}\n\nlong long modular_inverse(long long n){\n\treturn power(n, mod-2);\n}\n\nlong long calcnCr(long long n,long long k){\n\treturn (factorial[n]*(modular_inverse(factorial[k])*modular_inverse(factorial[n-k])%mod))%mod;\n}\n\nint main(void){\n  cfact();\n  long long i,j,n,h,d,sig=0,t;\n  long long dp[1048576]={0};\n  long long rw[1048576]={0};\n  scanf(\"%lld%lld%lld\",&n,&h,&d);\n  for(i=1;i<=n;i++){\n    sig+=factorial[i];\n    sig%=mod;\n  }\n  dp[0]=factorial[n];\n  rw[0]=factorial[n];\n  for(i=1;i<=h;i++){\n    t=llmax(-1,i-d-1);\n    if(t==-1){\n      dp[i]=rw[i-1];\n    }\n    else{\n      dp[i]=(mod+rw[i-1]-rw[t])%mod;\n    }\n    if(i==h){break;}\n    dp[i]*=sig;\n    dp[i]%=mod;\n    rw[i]=rw[i-1]+dp[i];\n    rw[i]%=mod;\n  }\n  printf(\"%lld\\n\",dp[h]);\n  return 0;\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "const val P = 1000000007L\n\nfun modPlus(x1: Long, x2: Long) = (x1 + x2) % P\nfun modMinus(x1: Long, x2: Long) = (x1 + P - x2) % P\nfun modTimes(x1: Long, x2: Long) = x1 * x2 % P\n\nfun main(args: Array<String>) {\n    val (n, h, d) = readLine()!!.split(\" \").map { it.toInt() }\n    val factorials = LongArray(n + 1)\n    factorials[0] = 1L\n    for (i in 1..n) {\n        factorials[i] = modTimes(i.toLong(), factorials[i - 1])\n    }\n    var x = 0L\n    for (i in 1..n) {\n        x = modPlus(x, factorials[i])\n    }\n\n    val dp = LongArray(h + 1)\n    val dpSum = LongArray(h + 1)\n    dp[1] = factorials[n]\n    dpSum[1] = dp[1]\n    for (i in 2..h) {\n        val factor = modMinus(dpSum[i - 1], dpSum[Math.max(i - d - 1, 0)])\n        dp[i] = modPlus(modTimes(factor, x), if (i <= d) factorials[n] else 0L)\n        dpSum[i] = modPlus(dpSum[i - 1], dp[i])\n    }\n    println(dp[h])\n}"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n\n  private static void solve() {\n    int n = ni();\n    int h = ni();\n    int d = ni();\n    int mod = (int) 1e9 + 7;\n\n    long[] dp = new long[h + 1];\n    dp[0] = 1;\n\n    long fs = 0;\n    long f = 1;\n    for (int i = 1; i <= n; i++) {\n      f = f * i % mod;\n      fs = (fs + f) % mod;\n    }\n\n    long sum = 0;\n    for (int i = 1; i <= h; i++) {\n      sum += dp[i - 1];\n      sum %= mod;\n      dp[i] = sum;\n\n      if (i >= d) {\n        sum += mod - dp[i - d];\n        sum %= mod;\n      }\n\n      // min -> m\n      dp[i] *= fs;\n      dp[i] %= mod;\n    }\n\n    long ret = 0;\n    for (int i = 1; i <= d; i++) {\n      ret += dp[h - i];\n      ret %= mod;\n    }\n    System.out.println(ret * f % mod);\n\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.function.LongBinaryOperator;\nimport java.nio.charset.Charset;\nimport java.util.StringTokenizer;\nimport java.io.OutputStreamWriter;\nimport java.io.OutputStream;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.Objects;\nimport java.io.Writer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author mikit\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        EBalancedPiles solver = new EBalancedPiles();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EBalancedPiles {\n        private static final int MOD = (int) 1e9 + 7;\n\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            // out.setBoolLabel(LightWriter.BoolLabel.YES_NO_FIRST_UP);\n            int n = in.ints(), h = in.ints(), d = in.ints();\n            ModMath mod = new ModMath();\n            Factorial fact = mod.getFactorial(1_000_001);\n\n            IntLazySegmentTree st0 = new IntLazySegmentTree(new long[h + 1], (x, y) -> (x + y) % MOD, 0L,\n                    (x, u) -> (x + u) % MOD, (u1, u2) -> (u1 + u2) % MOD, 0, (u, t) -> u * t % MOD);\n            IntLazySegmentTree st1 = new IntLazySegmentTree(new long[h + 1], (x, y) -> (x + y) % MOD, 0L,\n                    (x, u) -> (x + u) % MOD, (u1, u2) -> (u1 + u2) % MOD, 0, (u, t) -> u * t % MOD);\n\n            st1.update(0, 1);\n            for (int i = 0; i <= h; i++) {\n                long v0 = st0.query(i, i + 1);\n                st1.update(i, v0 % MOD);\n                long v1 = st1.query(i, i + 1);\n                //System.out.println(i + \":\" + v0 + \" - \" + v1);\n                st0.update(i + 1, Math.min(i + d + 1, h + 1), (v0 + n * v1 % MOD) % MOD);\n            }\n            //st0.print();\n            //st1.print();\n            out.ans(st1.query(h, h + 1)).ln();\n        }\n\n    }\n\n    static interface LongIntToLongFunction<T, R> {\n        long applyAsLong(long x, int y);\n\n    }\n\n    static final class BitMath {\n        private BitMath() {\n        }\n\n        public static int count(int v) {\n            v = (v & 0x55555555) + ((v >> 1) & 0x55555555);\n            v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n            v = (v & 0x0f0f0f0f) + ((v >> 4) & 0x0f0f0f0f);\n            v = (v & 0x00ff00ff) + ((v >> 8) & 0x00ff00ff);\n            v = (v & 0x0000ffff) + ((v >> 16) & 0x0000ffff);\n            return v;\n        }\n\n        public static int count(long v) {\n            v = (v & 0x5555555555555555L) + ((v >> 1) & 0x5555555555555555L);\n            v = (v & 0x3333333333333333L) + ((v >> 2) & 0x3333333333333333L);\n            v = (v & 0x0f0f0f0f0f0f0f0fL) + ((v >> 4) & 0x0f0f0f0f0f0f0f0fL);\n            v = (v & 0x00ff00ff00ff00ffL) + ((v >> 8) & 0x00ff00ff00ff00ffL);\n            v = (v & 0x0000ffff0000ffffL) + ((v >> 16) & 0x0000ffff0000ffffL);\n            v = (v & 0x00000000ffffffffL) + ((v >> 32) & 0x00000000ffffffffL);\n            return (int) v;\n        }\n\n        public static int lsb(int v) {\n            if (v == 0) {\n                throw new IllegalArgumentException(\"Bit not found\");\n            }\n            v |= (v << 1);\n            v |= (v << 2);\n            v |= (v << 4);\n            v |= (v << 8);\n            v |= (v << 16);\n            return 32 - count(v);\n        }\n\n        public static int lsb(long v) {\n            if (v == 0) {\n                throw new IllegalArgumentException(\"Bit not found\");\n            }\n            v |= (v << 1);\n            v |= (v << 2);\n            v |= (v << 4);\n            v |= (v << 8);\n            v |= (v << 16);\n            v |= (v << 32);\n            return 64 - count(v);\n        }\n\n        public static int extractMsb(int v) {\n            v = (v & 0xFFFF0000) > 0 ? v & 0xFFFF0000 : v;\n            v = (v & 0xFF00FF00) > 0 ? v & 0xFF00FF00 : v;\n            v = (v & 0xF0F0F0F0) > 0 ? v & 0xF0F0F0F0 : v;\n            v = (v & 0xCCCCCCCC) > 0 ? v & 0xCCCCCCCC : v;\n            v = (v & 0xAAAAAAAA) > 0 ? v & 0xAAAAAAAA : v;\n            return v;\n        }\n\n    }\n\n    static final class IntMath {\n        private IntMath() {\n        }\n\n        public static boolean isPrime(int n) {\n            if (n == 2) {\n                return true;\n            } else if (n <= 1 || (n & 1) == 0) {\n                return false;\n            }\n            int r = BitMath.lsb(n - 1);\n            int d = (n - 1) >> r;\n            ModMath m = new ModMath(n, true);\n            outer:\n            for (int a : new int[]{2, 7, 61}) {\n                int x = (int) m.pow(a, d);\n                if (x == 1 || x == n - 1 || n - 2 < a) {\n                    continue;\n                }\n                for (int j = 1; j < r; j++) {\n                    x = (int) m.pow(x, 2);\n                    if (x == n - 1) {\n                        continue outer;\n                    }\n                }\n                return false;\n            }\n            return true;\n        }\n\n        public static boolean isPrime(long n) {\n            if (n < Integer.MAX_VALUE) {\n                return isPrime((int) n);\n            }\n            int s = BitMath.lsb(n - 1);\n            long d = (n - 1) >> s;\n            ModMath m = new ModMath(n);\n            outer:\n            for (int a : new int[]{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {\n                long r = m.pow(a, d);\n                if (r == 1 || r == n - 1 || n - 2 < a) {\n                    continue;\n                }\n                for (int j = 0; j < s; j++) {\n                    r = m.pow(r, 2);\n                    if (r == n - 1) {\n                        continue outer;\n                    }\n                }\n                return false;\n            }\n            return true;\n        }\n\n    }\n\n    static class Vec3i implements Comparable<Vec3i> {\n        public int x;\n        public int y;\n        public int z;\n\n        public Vec3i(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Vec3i vec3i = (Vec3i) o;\n            return x == vec3i.x &&\n                    y == vec3i.y &&\n                    z == vec3i.z;\n        }\n\n        public int hashCode() {\n            return Objects.hash(x, y, z);\n        }\n\n        public String toString() {\n            return \"(\" + x + \", \" + y + \", \" + z + \")\";\n        }\n\n        public int compareTo(Vec3i o) {\n            if (x == o.x) {\n                if (y == o.y) {\n                    return Integer.compare(z, o.z);\n                }\n                return Integer.compare(y, o.z);\n            }\n            return Integer.compare(x, o.x);\n        }\n\n    }\n\n    static interface Verified {\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(long l) {\n            return ans(Long.toString(l));\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n\n    }\n\n    static class ModMath {\n        private static final int DEFAULT_MOD = 1_000_000_007;\n        private final long mod;\n\n        public ModMath(long mod, boolean unsafe) {\n            if (!unsafe && !IntMath.isPrime(mod)) {\n                throw new RuntimeException(\"This class is designed for primes!\");\n            }\n            this.mod = mod;\n        }\n\n        public ModMath(long mod) {\n            this(mod, false);\n        }\n\n        public ModMath() {\n            this(DEFAULT_MOD, true);\n        }\n\n        public long mod(long x) {\n            x %= mod;\n            return x < 0 ? x + mod : x;\n        }\n\n        public long inv(long x) {\n            //return pow(x, mod - 2);\n            return mod(LongEuclidSolver.solve(x, mod).x);\n        }\n\n        public long pow(long x, long y) {\n            y %= (mod - 1);\n            if (y < 0) {\n                return pow(inv(x), -y);\n            } else if (y == 0) {\n                return 1;\n            } else if (y % 2 == 0) {\n                long z = pow(x, y / 2);\n                return (z * z) % mod;\n            } else {\n                return (x % mod) * pow(x, y - 1) % mod;\n            }\n        }\n\n        public Factorial getFactorial(int n) {\n            return new Factorial(this, n);\n        }\n\n    }\n\n    static class Vec3l implements Comparable<Vec3l> {\n        public long x;\n        public long y;\n        public long z;\n\n        public Vec3l(long x, long y, long z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Vec3i vec3i = (Vec3i) o;\n            return x == vec3i.x &&\n                    y == vec3i.y &&\n                    z == vec3i.z;\n        }\n\n        public int hashCode() {\n            return Objects.hash(x, y, z);\n        }\n\n        public String toString() {\n            return \"(\" + x + \", \" + y + \", \" + z + \")\";\n        }\n\n        public int compareTo(Vec3l o) {\n            if (x == o.x) {\n                if (y == o.y) {\n                    return Long.compare(z, o.z);\n                }\n                return Long.compare(y, o.z);\n            }\n            return Long.compare(x, o.x);\n        }\n\n    }\n\n    static class IntLazySegmentTree {\n        private final int n;\n        private final int m;\n        private final long[] tree;\n        private final long[] lazy;\n        private final LongBinaryOperator op;\n        private final long zero;\n        private final LongBinaryOperator up;\n        private final LongBinaryOperator merge;\n        private final long nop;\n        private final LongIntToLongFunction mul;\n\n        public IntLazySegmentTree(long[] array, LongBinaryOperator op, long zero, LongBinaryOperator up,\n                                  LongBinaryOperator merge, long nop,\n                                  LongIntToLongFunction mul) {\n            this.n = array.length;\n            int msb = BitMath.extractMsb(n);\n            this.m = n == msb ? msb : (msb << 1);\n            this.op = op;\n            this.zero = zero;\n            this.up = up;\n            this.merge = merge;\n            this.nop = nop;\n            this.mul = mul;\n            this.tree = new long[m * 2 - 1];\n            Arrays.fill(tree, zero);\n            System.arraycopy(array, 0, this.tree, m - 1, array.length);\n            this.lazy = new long[m * 2 - 1];\n            Arrays.fill(lazy, nop);\n            for (int i = m - 2; i >= 0; i--) {\n                tree[i] = op.applyAsLong(tree[2 * i + 1], tree[2 * i + 2]);\n            }\n        }\n\n        public IntLazySegmentTree(long[] array, LongBinaryOperator op, long zero, LongBinaryOperator up,\n                                  LongBinaryOperator merge, long nop) {\n            this(array, op, zero, up, merge, nop, (q, n) -> q);\n        }\n\n        private void eval(int len, int k) {\n            if (lazy[k] == nop) {\n                return;\n            } else if (k * 2 + 1 < m * 2 - 1) {\n                lazy[k * 2 + 1] = merge.applyAsLong(lazy[k * 2 + 1], lazy[k]);\n                lazy[k * 2 + 2] = merge.applyAsLong(lazy[k * 2 + 2], lazy[k]);\n            }\n            tree[k] = up.applyAsLong(tree[k], mul.applyAsLong(lazy[k], len));\n            lazy[k] = nop;\n        }\n\n        public void update(int i, long v) {\n            i += m - 1;\n            eval(1, i);\n            tree[i] = up.applyAsLong(tree[i], v);\n            while (i > 0) {\n                i = (i - 1) / 2;\n                tree[i] = op.applyAsLong(tree[2 * i + 1], tree[2 * i + 2]);\n            }\n        }\n\n        private long update(int l, int r, long q, int k, int sl, int sr) {\n            if (r <= sl || sr <= l) {\n                eval(sr - sl, k);\n                return tree[k];\n            }\n            if (l <= sl && sr <= r) {\n                lazy[k] = merge.applyAsLong(lazy[k], q);\n                eval(sr - sl, k);\n                return tree[k];\n            } else {\n                eval(sr - sl, k);\n                return tree[k] = op.applyAsLong(\n                        update(l, r, q, k * 2 + 1, sl, (sl + sr) / 2),\n                        update(l, r, q, k * 2 + 2, (sl + sr) / 2, sr)\n                );\n            }\n        }\n\n        public void update(int l, int r, long q) {\n            update(l, r, q, 0, 0, m);\n        }\n\n        private long query(int l, int r, int k, int sl, int sr) {\n            if (r <= sl || sr <= l) {\n                return zero;\n            }\n            eval(sr - sl, k);\n            if (l <= sl && sr <= r) {\n                return tree[k];\n            } else {\n                long left = query(l, r, 2 * k + 1, sl, (sl + sr) / 2);\n                long right = query(l, r, 2 * k + 2, (sl + sr) / 2, sr);\n                return op.applyAsLong(left, right);\n            }\n        }\n\n        public long query(int l, int r) {\n            return query(l, r, 0, 0, m);\n        }\n\n    }\n\n    static class Factorial {\n        private final ModMath mod;\n        private final long[] natural;\n        private final long[] reverse;\n\n        public Factorial(ModMath mod, int max) {\n            this.mod = mod;\n            this.natural = new long[max];\n            this.reverse = new long[max];\n            natural[0] = 1;\n            for (int i = 1; i < max; i++) {\n                natural[i] = mod.mod(natural[i - 1] * i);\n            }\n            reverse[max - 1] = mod.inv(natural[max - 1]);\n            for (int i = max - 1; i > 0; i--) {\n                reverse[i - 1] = mod.mod(reverse[i] * i);\n            }\n        }\n\n        public String toString() {\n            return \"Factorial{\" +\n                    \"natural=\" + Arrays.toString(natural) +\n                    \", reverse=\" + Arrays.toString(reverse) +\n                    '}';\n        }\n\n    }\n\n    static class LongEuclidSolver {\n        private LongEuclidSolver() {\n        }\n\n        public static Vec3l solve(long a, long b) {\n            LongEuclidSolver.ReferenceLong p = new LongEuclidSolver.ReferenceLong(), q = new LongEuclidSolver.ReferenceLong();\n            long d = solve(a, b, p, q);\n            return new Vec3l(p.val, q.val, d);\n        }\n\n        private static long solve(long a, long b, LongEuclidSolver.ReferenceLong p, LongEuclidSolver.ReferenceLong q) {\n            if (b == 0) {\n                p.val = 1;\n                q.val = 0;\n                return a;\n            } else {\n                long d = solve(b, a % b, q, p);\n                q.val -= (a / b) * p.val;\n                return d;\n            }\n        }\n\n        private static class ReferenceLong {\n            private long val;\n\n        }\n\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ints() {\n            return Integer.parseInt(string());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\n// 合計がh、トビ幅が最大d, 最後にn-1個の0\n// 1 0 1 0 *4\n// 1 1 0 *2\n// 最初は1, 0は連続でn-1個まで\n// (0が登場した回数+1)!の積っぽい\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), h = ni(), D = ni();\n\t\tlong f = 1;\n\t\tlong fs = 1;\n\t\tint mod = 1000000007;\n\t\tfor(int i = 1;i <= n-1;i++){\n\t\t\tf = f * (i+1) % mod;\n\t\t\tfs += f;\n\t\t}\n\t\tfs %= mod;\n\t\t\n\t\tlong[] ft = new long[h+5];\n\t\taddFenwick(ft, 0, f);\n\t\taddFenwick(ft, 1, mod-f);\n\t\tlong ans = 0;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tlong cur = sumFenwick(ft, i);\n\t\t\tif(i+D >= h){\n\t\t\t\tans += cur;\n\t\t\t}\n\t\t\tcur = cur * fs % mod;\n\t\t\taddFenwick(ft, i+1, cur);\n\t\t\tif(i+D+1 <= h){\n\t\t\t\taddFenwick(ft, i+D+1, mod-cur);\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(ans%mod);\n\t}\n\t\n\tpublic static final int mod = 1000000007;\n\t\n\tpublic static long sumFenwick(long[] ft, int i)\n\t{\n\t\tlong sum = 0;\n\t\tfor(i++;i > 0;i -= i&-i){\n\t\t\tsum += ft[i];\n\t\t\tif(sum >= mod)sum -= mod;\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tpublic static void addFenwick(long[] ft, int i, long v)\n\t{\n\t\tv %= mod;\n\t\tif(v < 0)v += mod;\n\t\tif(v == 0)return;\n\t\tint n = ft.length;\n\t\tfor(i++;i < n;i += i&-i){\n\t\t\tft[i] += v;\n\t\t\tif(ft[i] >= mod)ft[i] -= mod;\n\t\t}\n\t}\n\t\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 27);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            TaskE solver = new TaskE();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n    static class TaskE {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int h = in.readInt();\n            int d = in.readInt();\n            NumberTheory.Modular mod = new NumberTheory.Modular(1e9 + 7);\n            NumberTheory.Factorial fact = new NumberTheory.Factorial(n, mod);\n            int[] dp = new int[h + 1];\n            dp[0] = fact.fact(n);\n            int factSum = 0;\n            for (int i = 1; i <= n; i++) {\n                factSum = mod.plus(factSum, fact.fact(i));\n            }\n            int[] preDpSum = new int[h + 1];\n            preDpSum[0] = dp[0];\n            for (int i = 1; i <= h; i++) {\n                dp[i] = preDpSum[i - 1];\n                if (i - d - 1 >= 0) {\n                    dp[i] = mod.subtract(dp[i], preDpSum[i - d - 1]);\n                }\n                if (i < h) {\n                    dp[i] = mod.mul(dp[i], factSum);\n                }\n                preDpSum[i] = mod.plus(preDpSum[i - 1], dp[i]);\n            }\n\n            out.println(dp[h]);\n        }\n\n    }\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n    static class NumberTheory {\n        public static class Modular {\n            int m;\n\n            public Modular(int m) {\n                this.m = m;\n            }\n\n            public Modular(long m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public Modular(double m) {\n                this.m = (int) m;\n                if (this.m != m) {\n                    throw new IllegalArgumentException();\n                }\n            }\n\n            public int valueOf(int x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return x;\n            }\n\n            public int valueOf(long x) {\n                x %= m;\n                if (x < 0) {\n                    x += m;\n                }\n                return (int) x;\n            }\n\n            public int mul(int x, int y) {\n                return valueOf((long) x * y);\n            }\n\n            public int plus(int x, int y) {\n                return valueOf(x + y);\n            }\n\n            public int subtract(int x, int y) {\n                return valueOf(x - y);\n            }\n\n            public String toString() {\n                return \"mod \" + m;\n            }\n\n        }\n\n        public static class InverseNumber {\n            int[] inv;\n\n            public InverseNumber(int[] inv, int limit, NumberTheory.Modular modular) {\n                this.inv = inv;\n                inv[1] = 1;\n                int p = modular.m;\n                for (int i = 2; i <= limit; i++) {\n                    int k = p / i;\n                    int r = p % i;\n                    inv[i] = modular.mul(-k, inv[r]);\n                }\n            }\n\n            public InverseNumber(int limit, NumberTheory.Modular modular) {\n                this(new int[limit + 1], limit, modular);\n            }\n\n        }\n\n        public static class Factorial {\n            int[] fact;\n            int[] inv;\n            NumberTheory.Modular modular;\n\n            public Factorial(int[] fact, int[] inv, NumberTheory.InverseNumber in, int limit,\n                            NumberTheory.Modular modular) {\n                this.modular = modular;\n                this.fact = fact;\n                this.inv = inv;\n                fact[0] = inv[0] = 1;\n                for (int i = 1; i <= limit; i++) {\n                    fact[i] = modular.mul(fact[i - 1], i);\n                    inv[i] = modular.mul(inv[i - 1], in.inv[i]);\n                }\n            }\n\n            public Factorial(int limit, NumberTheory.Modular modular) {\n                this(new int[limit + 1], new int[limit + 1], new NumberTheory.InverseNumber(limit, modular), limit,\n                                modular);\n            }\n\n            public int fact(int n) {\n                return fact[n];\n            }\n\n        }\n\n    }\n    static class FastOutput implements AutoCloseable, Closeable {\n        private StringBuilder cache = new StringBuilder(10 << 20);\n        private final Writer os;\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput println(int c) {\n            cache.append(c).append('\\n');\n            return this;\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author anand.oza\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EBalancedPiles solver = new EBalancedPiles();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EBalancedPiles {\n        private NumberTheory.Mod107 m = new NumberTheory.Mod107();\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt(), h = in.nextInt(), d = in.nextInt();\n\n//        out.println(solveSlow(n, h, d));\n            out.println(solveFast(n, h, d));\n        }\n\n        public long solveFast(int n, int h, int d) {\n\n            NumberTheory.ModularNumber[] mult1 = new NumberTheory.ModularNumber[n + 1];\n            mult1[0] = m.create(1);\n            mult1[1] = m.create(1);\n            for (int i = 2; i <= n; i++) {\n                mult1[i] = mult1[i - 1].mult(n + 1 - i);\n            }\n\n            NumberTheory.ModularNumber[] mult2 = new NumberTheory.ModularNumber[n + 1];\n            mult2[0] = m.create(0);\n            for (int i = 1; i < n; i++) {\n                mult2[i] = mult2[i - 1].add(mult1[i].mult(n - i));\n            }\n            mult2[n] = mult2[n - 1].add(mult1[n].mult(n));\n\n            NumberTheory.ModularNumber[] ans = new NumberTheory.ModularNumber[h + 1];\n            NumberTheory.ModularNumber[] sum = new NumberTheory.ModularNumber[h + 1];\n            NumberTheory.ModularNumber sumLastD = m.create(0);\n\n            sum[0] = m.create(n);\n            sumLastD = sumLastD.add(sum[0]);\n            for (int i = 1; i <= h; i++) {\n                ans[i] = sumLastD;\n                sum[i] = ans[i].mult(mult2[n]);\n                sumLastD = sumLastD.add(sum[i]);\n                if (i - d >= 0)\n                    sumLastD = sumLastD.subtract(sum[i - d]);\n            }\n\n//        System.out.println(Arrays.toString(mult1));\n//        System.out.println(Arrays.toString(mult2));\n//        System.out.println(Arrays.toString(ans));\n\n            NumberTheory.ModularNumber answer = m.create(0);\n            answer = ans[h].mult(mult1[n]);\n            return answer.value;\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n\n    static class NumberTheory {\n        private static void ASSERT(boolean assertion) {\n            if (!assertion)\n                throw new AssertionError();\n        }\n\n        public abstract static class Modulus<M extends NumberTheory.Modulus<M>> {\n            ArrayList<NumberTheory.ModularNumber<M>> factorial = new ArrayList<>();\n\n            public abstract long modulus();\n\n            public Modulus() {\n                super();\n                factorial.add(create(1));\n            }\n\n            public NumberTheory.ModularNumber<M> create(long value) {\n                return new NumberTheory.ModularNumber(value, this);\n            }\n\n        }\n\n        public static class Mod107 extends NumberTheory.Modulus<NumberTheory.Mod107> {\n            public long modulus() {\n                return 1_000_000_007L;\n            }\n\n        }\n\n        public static class ModularNumber<M extends NumberTheory.Modulus<M>> {\n            public final long value;\n            public final M m;\n            public final long MOD;\n\n            public ModularNumber(long value, M m) {\n                this.m = m;\n                this.MOD = m.modulus();\n                this.value = (value % MOD + MOD) % MOD;\n            }\n\n            public NumberTheory.ModularNumber<M> add(NumberTheory.ModularNumber<M> other) {\n                ASSERT(m.modulus() == other.m.modulus());\n                return this.add(other.value);\n            }\n\n            public NumberTheory.ModularNumber<M> add(long other) {\n                return m.create(value + other);\n            }\n\n            public NumberTheory.ModularNumber<M> subtract(NumberTheory.ModularNumber<M> other) {\n                ASSERT(m.modulus() == other.m.modulus());\n                return this.subtract(other.value);\n            }\n\n            public NumberTheory.ModularNumber<M> subtract(long other) {\n                return m.create(value - other);\n            }\n\n            public NumberTheory.ModularNumber<M> mult(NumberTheory.ModularNumber<M> other) {\n                ASSERT(m.modulus() == other.m.modulus());\n                return this.mult(other.value);\n            }\n\n            public NumberTheory.ModularNumber<M> mult(long other) {\n                return m.create(value * other);\n            }\n\n            public String toString() {\n                return String.valueOf(value);\n            }\n\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing static System.Math;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\n\npublic static class P\n{\n    public static void Main()\n    {\n        var nhd = Console.ReadLine().Split().Select(int.Parse).ToArray();\n        var n = nhd[0];\n        var h = nhd[1];\n        var d = nhd[2];\n        //最大値の遷移を考える。\n        //最大値の遷移を考えた時に、それぞれのノードについて1個-n個の可能性がある。\n        //最大値がn回現れる場合、次にそれが取られるときの通り数はn!\n        //なので、sum_1^n i! が掛けられる\n        //経路長がlの場合、accumFactorial^(l-1)*n! 通り余計な分がある(最初のn個0のぶん)\n        //あとは多分経路長がl個のものが何個、みたいなのが求められれば嬉しい\n        //l回DP回した時のaの数、がそれに該当しそう 絶対ヤバい\n        //(1+x^2+x^3...x^d)^nのx^nの項が該当する\n        //l個に分割する(要素d個まで) とも言いかえられる これを高速に求めたい\n        //要素D個より多くある要素が一つある→-dしてあげればいい\n        //((n-1)!/((n-l)!*(l-1)!) - n*((n-1-d)!/((n-l-d)!*(l-1)!) + (n-1)*((n-1-2d)!/((n-l-2d)!*(l-1)!) -\n        //ってなる l+1した時は、((n-d-l-1)!/(n-d-l)! == n-d-l) * ((l-1)!/(l-1-1)! == l-1) == (n-d-l)*(l-1)で割る\n        //変化する量dが入ってるからいける\n\n        //掛ける数は経路長に依存しない形で分解できるので、実際は通過する場合に掛ける、で良いのでは?\n        ModInt factorialAccum = 0;\n        ModInt factorial = 1;\n        for (int i = 1; i <= n; i++)\n            factorialAccum += factorial *= i;\n        SegmentTree<ModInt1e9p6> segTree = new SegmentTree<ModInt1e9p6>(h + 1, 0, (x, y) => x + y);\n        segTree.Operate(0, 1);\n        for (int i = 0; i <= h; i++)\n        {\n            segTree.Operate(i + 1, Min(i + d, segTree.Size - 1), segTree[i]);\n        }\n        ModInt res = 1;\n        for (int i = 0; i < h - 1; i++)\n        {\n            res *= Power(factorialAccum, segTree[i] * segTree[n - i]);\n        }\n        Console.WriteLine(res * factorial);\n    }\n\n    static ModInt Power(ModInt n, long m)\n    {\n        ModInt pow = n;\n        ModInt res = 1;\n        while (m > 0)\n        {\n            if ((m & 1) == 1) res *= pow;\n            pow *= pow;\n            m >>= 1;\n        }\n        return res;\n    }\n}\n\n\nclass SegmentTree<T>\n{\n    public readonly int Size;\n    T[] Operators;\n    Func<T, T, T> Merge;\n    int LeafCount;\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public SegmentTree(int size, T identity, Func<T, T, T> merge)\n    {\n        Size = size;\n        Merge = merge;\n        LeafCount = 1;\n        while (LeafCount < size) LeafCount <<= 1;\n        Operators = new T[LeafCount << 1];\n        for (int i = 0; i < Operators.Length; i++)\n            Operators[i] = identity;\n    }\n    public T this[int index]\n    {\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        get { return Query(index); }\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public void Operate(int i, T x) { i += LeafCount; Operators[i] = Merge(Operators[i], x); }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public void Operate(int l, int r, T x)\n    {\n        for (l += LeafCount, r += LeafCount; l <= r; l = (l + 1) >> 1, r = (r - 1) >> 1)\n        {\n            if ((l & 1) == 1) Operators[l] = Merge(Operators[l], x);\n            if ((r & 1) == 0) Operators[r] = Merge(Operators[r], x);\n        }\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public T Query(int i)\n    {\n        i += LeafCount;\n        T res = Operators[i];\n        while (0 < (i >>= 1)) res = Merge(res, Operators[i]);\n        return res;\n    }\n}\n\n\nstruct ModInt\n{\n    public const int Mod = 1000000007;\n    const long POSITIVIZER = ((long)Mod) << 31;\n    long Data;\n    public ModInt(long data) { if ((Data = data % Mod) < 0) Data += Mod; }\n    public static implicit operator long(ModInt modInt) => modInt.Data;\n    public static implicit operator ModInt(long val) => new ModInt(val);\n    public static ModInt operator +(ModInt a, int b) => new ModInt() { Data = (a.Data + b + POSITIVIZER) % Mod };\n    public static ModInt operator +(ModInt a, long b) => new ModInt(a.Data + b);\n    public static ModInt operator +(ModInt a, ModInt b) { long res = a.Data + b.Data; return new ModInt() { Data = res >= Mod ? res - Mod : res }; }\n    public static ModInt operator -(ModInt a, int b) => new ModInt() { Data = (a.Data - b + POSITIVIZER) % Mod };\n    public static ModInt operator -(ModInt a, long b) => new ModInt(a.Data - b);\n    public static ModInt operator -(ModInt a, ModInt b) { long res = a.Data - b.Data; return new ModInt() { Data = res < 0 ? res + Mod : res }; }\n    public static ModInt operator *(ModInt a, int b) => new ModInt(a.Data * b);\n    public static ModInt operator *(ModInt a, long b) => a * new ModInt(b);\n    public static ModInt operator *(ModInt a, ModInt b) => new ModInt() { Data = a.Data * b.Data % Mod };\n    public static ModInt operator /(ModInt a, ModInt b) => new ModInt() { Data = a.Data * GetInverse(b) % Mod };\n    public static bool operator ==(ModInt a, ModInt b) => a.Data == b.Data;\n    public static bool operator !=(ModInt a, ModInt b) => a.Data != b.Data;\n    public override string ToString() => Data.ToString();\n    public override bool Equals(object obj) => (ModInt)obj == this;\n    public override int GetHashCode() => (int)Data;\n    static long GetInverse(long a)\n    {\n        long div, p = Mod, x1 = 1, y1 = 0, x2 = 0, y2 = 1;\n        while (true)\n        {\n            if (p == 1) return x2 + Mod; div = a / p; x1 -= x2 * div; y1 -= y2 * div; a %= p;\n            if (a == 1) return x1 + Mod; div = p / a; x2 -= x1 * div; y2 -= y1 * div; p %= a;\n        }\n    }\n}\n\n\nstruct ModInt1e9p6\n{\n    public const int Mod = 1000000007;\n    const long POSITIVIZER = ((long)Mod) << 31;\n    long Data;\n    public ModInt1e9p6(long data) { if ((Data = data % Mod) < 0) Data += Mod; }\n    public static implicit operator long(ModInt1e9p6 modInt) => modInt.Data;\n    public static implicit operator ModInt1e9p6(long val) => new ModInt1e9p6(val);\n    public static ModInt1e9p6 operator +(ModInt1e9p6 a, int b) => new ModInt1e9p6() { Data = (a.Data + b + POSITIVIZER) % Mod };\n    public static ModInt1e9p6 operator +(ModInt1e9p6 a, long b) => new ModInt1e9p6(a.Data + b);\n    public static ModInt1e9p6 operator +(ModInt1e9p6 a, ModInt1e9p6 b) { long res = a.Data + b.Data; return new ModInt1e9p6() { Data = res >= Mod ? res - Mod : res }; }\n    public static ModInt1e9p6 operator -(ModInt1e9p6 a, int b) => new ModInt1e9p6() { Data = (a.Data - b + POSITIVIZER) % Mod };\n    public static ModInt1e9p6 operator -(ModInt1e9p6 a, long b) => new ModInt1e9p6(a.Data - b);\n    public static ModInt1e9p6 operator -(ModInt1e9p6 a, ModInt1e9p6 b) { long res = a.Data - b.Data; return new ModInt1e9p6() { Data = res < 0 ? res + Mod : res }; }\n    public static ModInt1e9p6 operator *(ModInt1e9p6 a, int b) => new ModInt1e9p6(a.Data * b);\n    public static ModInt1e9p6 operator *(ModInt1e9p6 a, long b) => a * new ModInt1e9p6(b);\n    public static ModInt1e9p6 operator *(ModInt1e9p6 a, ModInt1e9p6 b) => new ModInt1e9p6() { Data = a.Data * b.Data % Mod };\n    public static bool operator ==(ModInt1e9p6 a, ModInt1e9p6 b) => a.Data == b.Data;\n    public static bool operator !=(ModInt1e9p6 a, ModInt1e9p6 b) => a.Data != b.Data;\n    public override string ToString() => Data.ToString();\n    public override bool Equals(object obj) => (ModInt1e9p6)obj == this;\n    public override int GetHashCode() => (int)Data;\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\n\nnamespace ReadWriteTemplate\n{\n    public static class Solver\n    {\n        private static void SolveCase()\n        {\n            const long MOD = 1000000000 + 7;\n            long n = ReadLong();\n            long h = ReadLong();\n            long d = ReadLong();\n\n            long[] f = new long[n + 1];\n            f[0] = 1;\n            for (int i = 0; i < n; i++)\n            {\n                f[i + 1] = f[i] * (i + 1) % MOD;\n            }\n\n            long A = 0;\n            for (int i = 0; i < n; i++)\n            {\n                A = (A + f[i + 1]) % MOD;\n            }\n\n            long[] a = new long[h + 1];\n            a[0] = 1;\n            for (int i = 0; i < d; i++)\n            {\n                a[i + 1] = f[n];\n            }\n\n            long sum = a[1];\n            for (int i = 2; i <= h; i++)\n            {\n                if (i - d - 1 > 0)\n                {\n                    sum = (sum + MOD - a[i - d - 1]) % MOD;\n                }\n                a[i] = (a[i] + sum * A) % MOD;\n                sum = (sum + a[i]) % MOD;\n            }\n\n            Writer.WriteLine(a[h]);\n        }\n\n        public static void Solve()\n        {\n#if DEBUG\n            var sw = Stopwatch.StartNew();\n#endif\n\n            SolveCase();\n\n#if DEBUG\n            sw.Stop();\n            Console.WriteLine($\"{sw.ElapsedMilliseconds} ms\");\n#endif\n        }\n\n        public static void Main()\n        {\n            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n\n#if DEBUG\n            // Reader = Console.In; Writer = Console.Out;\n            Reader = File.OpenText(\"input.txt\"); Writer = File.CreateText(\"output.txt\");\n#else\n            Reader = Console.In; Writer = Console.Out;\n#endif\n\n            // Solve();\n            Thread thread = new Thread(Solve, 64 * 1024 * 1024);\n            thread.CurrentCulture = CultureInfo.InvariantCulture;\n            thread.Start();\n            thread.Join();\n\n            Reader.Close();\n            Writer.Close();\n        }\n\n        public static IOrderedEnumerable<TSource> OrderByWithShuffle<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)\n        {\n            return source.Shuffle().OrderBy(keySelector);\n        }\n\n        public static T[] Shuffle<T>(this IEnumerable<T> source)\n        {\n            T[] result = source.ToArray();\n            Shuffle(result);\n            return result;\n        }\n\n        private static void Shuffle<T>(IList<T> array)\n        {\n            Random rnd = new Random();\n            for (int i = array.Count - 1; i >= 1; i--)\n            {\n                int k = rnd.Next(i + 1);\n                T tmp = array[k];\n                array[k] = array[i];\n                array[i] = tmp;\n            }\n        }\n\n        #region Read/Write\n\n        private static TextReader Reader;\n\n        private static TextWriter Writer;\n\n        private static Queue<string> CurrentLineTokens = new Queue<string>();\n\n        private static string[] ReadAndSplitLine()\n        {\n            return Reader.ReadLine().Split(new[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n        }\n\n        public static string ReadToken()\n        {\n            while (CurrentLineTokens.Count == 0)\n                CurrentLineTokens = new Queue<string>(ReadAndSplitLine());\n            return CurrentLineTokens.Dequeue();\n        }\n\n        public static string ReadLine()\n        {\n            return Reader.ReadLine();\n        }\n\n        public static int ReadInt()\n        {\n            return int.Parse(ReadToken());\n        }\n\n        public static long ReadLong()\n        {\n            return long.Parse(ReadToken());\n        }\n\n        public static double ReadDouble()\n        {\n            return double.Parse(ReadToken(), CultureInfo.InvariantCulture);\n        }\n\n        public static int[] ReadIntArray()\n        {\n            return ReadAndSplitLine().Select(int.Parse).ToArray();\n        }\n\n        public static long[] ReadLongArray()\n        {\n            return ReadAndSplitLine().Select(long.Parse).ToArray();\n        }\n\n        public static double[] ReadDoubleArray()\n        {\n            return ReadAndSplitLine().Select(s => double.Parse(s, CultureInfo.InvariantCulture)).ToArray();\n        }\n\n        public static int[][] ReadIntMatrix(int numberOfRows)\n        {\n            int[][] matrix = new int[numberOfRows][];\n            for (int i = 0; i < numberOfRows; i++)\n                matrix[i] = ReadIntArray();\n            return matrix;\n        }\n\n        public static string[] ReadLines(int quantity)\n        {\n            string[] lines = new string[quantity];\n            for (int i = 0; i < quantity; i++)\n                lines[i] = Reader.ReadLine().Trim();\n            return lines;\n        }\n\n        public static void WriteArray<T>(IEnumerable<T> array)\n        {\n            Writer.WriteLine(string.Join(\" \", array));\n        }\n\n        #endregion\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Number = System.Int32;\n\nnamespace Program {\n\tpublic class Solver {\n\t\tRandom rnd = new Random();\n\t\tpublic void Solve() {\n\t\t\tvar n = ri;\n\t\t\tvar m = ri;\n\t\t\tvar d = ri;\n\t\t\tconst long M = (long)1e9 + 7;\n\t\t\tvar fact = new long[n + 1];\n\t\t\tfact[0] = 1;\n\t\t\tvar coef = 0L;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfact[i] = fact[i - 1] * i % M;\n\t\t\t\tcoef = (coef + fact[i]) % M;\n\t\t\t}\n\t\t\tvar dp = new long[m + 1];\n\t\t\tvar cum = new long[m + 1];\n\t\t\tdp[0] = cum[0] = 1;\n\t\t\tfor (int i = 1; i <= m; i++) {\n\t\t\t\tvar add = cum[i - 1];\n\t\t\t\tif (i - d - 1 >= 0) add += M - cum[i - d - 1];\n\t\t\t\tif (i != m)\n\t\t\t\t\tadd *= coef;\n\t\t\t\tdp[i] = add % M;\n\t\t\t\tcum[i] = (cum[i - 1] + dp[i]) % M;\n\t\t\t}\n\t\t\tDebug.WriteLine(coef);\n\t\t\t//Debug.WriteLine(dp.AsJoinedString());\n\t\t\tvar ans = dp[m] * fact[n] % M;\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\t\tconst long INF = 1L << 60;\n\t\tstatic int[] dx = { -1, 0, 1, 0 };\n\t\tstatic int[] dy = { 0, 1, 0, -1 };\n\t\tint ri { get { return sc.Integer(); } }\n\t\tlong rl { get { return sc.Long(); } }\n\t\tdouble rd { get { return sc.Double(); } }\n\t\tstring rs { get { return sc.Scan(); } }\n\t\tpublic IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n\t\tstatic T[] Enumerate<T>(int n, Func<int, T> f) {\n\t\t\tvar a = new T[n];\n\t\t\tfor (int i = 0; i < a.Length; ++i) a[i] = f(i);\n\t\t\treturn a;\n\t\t}\n\t\tstatic public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\t}\n}\n\n#region main\nstatic class Ex {\n\tstatic public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\tstatic public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n\t\treturn string.Join(st, ie);\n\t}\n\tstatic public void Main() {\n\t\tConsole.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = true });\n\t\tvar solver = new Program.Solver();\n\t\t/* \n\t\tvar t = new System.Threading.Thread(solver.Solve, 50000000);\n\t\tt.Start();\n\t\tt.Join();\n\t\t*/\n\t\tsolver.Solve();\n\t\tConsole.Out.Flush();\n\t}\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n\tusing System.IO;\n\tusing System.Text;\n\tusing System.Globalization;\n\n\tpublic class Printer : StreamWriter {\n\t\tpublic override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n\t\tpublic Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n\t}\n\n\tpublic class StreamScanner {\n\t\tpublic StreamScanner(Stream stream) { str = stream; }\n\n\t\tpublic readonly Stream str;\n\t\tprivate readonly byte[] buf = new byte[1024];\n\t\tprivate int len, ptr;\n\t\tpublic bool isEof = false;\n\t\tpublic bool IsEndOfStream { get { return isEof; } }\n\n\t\tprivate byte read() {\n\t\t\tif (isEof) return 0;\n\t\t\tif (ptr >= len) {\n\t\t\t\tptr = 0;\n\t\t\t\tif ((len = str.Read(buf, 0, 1024)) <= 0) {\n\t\t\t\t\tisEof = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[ptr++];\n\t\t}\n\n\t\tpublic char Char() {\n\t\t\tbyte b = 0;\n\t\t\tdo b = read(); while ((b < 33 || 126 < b) && !isEof);\n\t\t\treturn (char)b;\n\t\t}\n\t\tpublic string Scan() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic string ScanLine() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n\t\tpublic int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n\t\tpublic double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n\t}\n}\n\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Text;\nusing E = System.Linq.Enumerable;\n\npartial class Solver\n{\n    public void Run()\n    {\n        var N = ni();\n        var H = ni();\n        var D = ni();\n\n        long C = 0, F = 1;\n        int mod = 1000000007;\n\n        for (int i = 1; i <= N; i++)\n        {\n            F = (F * i) % mod;\n            C += F;\n            C %= mod;\n        }\n\n        var dp = new long[H + 1];\n        var diff = new long[H + 1];\n        for (int i = 1; i <= D && i <= H; i++)\n        {\n            dp[i] += 1;\n            dp[i] %= mod;\n        }\n\n        for (int i = 1; i <= H; i++)\n        {\n            diff[i] += diff[i - 1];\n            diff[i] %= mod;\n            dp[i] += diff[i];\n            var next = (dp[i] + mod) % mod * C % mod;\n            if (i + 1 <= H)\n            {\n                diff[i + 1] += next;\n                diff[i + 1] %= mod;\n            }\n            if (i + D + 1 <= H)\n            {\n                diff[i + D + 1] += mod - next;\n                diff[i + D + 1] %= mod;\n            }\n        }\n\n        long ans = dp[H] * F % mod;\n\n        cout.WriteLine(ans);\n    }\n}\n\n// PREWRITEN CODE BEGINS FROM HERE\npartial class Solver : Scanner\n{\n    public static void Main(string[] args)\n    {\n#if LOCAL\n        new Solver(Console.In, Console.Out).Run();\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver(Console.In, Console.Out).Run();\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader)\n    {\n        this.cin = reader;\n        this.cout = writer;\n    }\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer)\n    {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\npublic static class LinqPadExtension\n{\n    static public T Dump<T>(this T obj)\n    {\n#if LOCAL\n        return LINQPad.Extensions.Dump(obj);\n#else\n        return obj;\n#endif\n    }\n}\npublic class Scanner\n{\n    private readonly TextReader Reader;\n    private readonly Queue<string> TokenQueue = new Queue<string>();\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    public Scanner()\n        : this(Console.In)\n    {\n    }\n\n    public Scanner(TextReader reader)\n    {\n        this.Reader = reader;\n    }\n\n    public int NextInt() { return int.Parse(Next(), ci); }\n    public long NextLong() { return long.Parse(Next(), ci); }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size)\n    {\n        var array = new string[size];\n        for (int i = 0; i < size; i++) array[i] = Next();\n        return array;\n    }\n    public int[] NextIntArray(int size)\n    {\n        var array = new int[size];\n        for (int i = 0; i < size; i++) array[i] = NextInt();\n        return array;\n    }\n\n    public long[] NextLongArray(int size)\n    {\n        var array = new long[size];\n        for (int i = 0; i < size; i++) array[i] = NextLong();\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size)\n    {\n        var array = new double[size];\n        for (int i = 0; i < size; i++) array[i] = NextDouble();\n        return array;\n    }\n\n    public string Next()\n    {\n        if (TokenQueue.Count == 0)\n        {\n            if (!StockTokens()) throw new InvalidOperationException();\n        }\n        return TokenQueue.Dequeue();\n    }\n\n    public bool HasNext()\n    {\n        if (TokenQueue.Count > 0)\n            return true;\n        return StockTokens();\n    }\n    static readonly char[] _separator = new[] { ' ' };\n    private bool StockTokens()\n    {\n        while (true)\n        {\n            var line = Reader.ReadLine();\n            if (line == null) return false;\n            var tokens = line.Split(_separator, StringSplitOptions.RemoveEmptyEntries);\n            if (tokens.Length == 0) continue;\n            foreach (var token in tokens)\n                TokenQueue.Enqueue(token);\n            return true;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\n\nnamespace ReadWriteTemplate\n{\n    public static class Solver\n    {\n        private static void SolveCase()\n        {\n            const long MOD = 1000000000 + 7;\n            long n = ReadLong();\n            long h = ReadLong();\n            long d = ReadLong();\n\n            long[] f = new long[n + 1];\n            f[0] = 1;\n            for (int i = 0; i < n; i++)\n            {\n                f[i + 1] = f[i] * (i + 1) % MOD;\n            }\n\n            long A = 0;\n            for (int i = 0; i < n; i++)\n            {\n                A = (A + f[i + 1]) % MOD;\n            }\n\n            long[] a = new long[h + 1];\n            a[0] = 1;\n            for (int i = 0; i < d; i++)\n            {\n                a[i + 1] = f[n];\n            }\n\n            long sum = a[0] + a[1];\n            for (int i = 2; i <= h; i++)\n            {\n                if (i - d - 1 >= 0)\n                {\n                    sum = (sum + MOD - a[i - d - 1]) % MOD;\n                }\n                a[i] = (a[i] + sum * A) % MOD;\n                sum = (sum + a[i]) % MOD;\n            }\n\n            // WriteArray(a);\n            Writer.WriteLine(a[h]);\n        }\n\n        public static void Solve()\n        {\n#if DEBUG\n            var sw = Stopwatch.StartNew();\n#endif\n\n            SolveCase();\n\n#if DEBUG\n            sw.Stop();\n            Console.WriteLine($\"{sw.ElapsedMilliseconds} ms\");\n#endif\n        }\n\n        public static void Main()\n        {\n            Thread.CurrentThread.CurrentCulture = CultureInfo.InvariantCulture;\n\n#if DEBUG\n            // Reader = Console.In; Writer = Console.Out;\n            Reader = File.OpenText(\"input.txt\"); Writer = File.CreateText(\"output.txt\");\n#else\n            Reader = Console.In; Writer = Console.Out;\n#endif\n\n            // Solve();\n            Thread thread = new Thread(Solve, 64 * 1024 * 1024);\n            thread.CurrentCulture = CultureInfo.InvariantCulture;\n            thread.Start();\n            thread.Join();\n\n            Reader.Close();\n            Writer.Close();\n        }\n\n        public static IOrderedEnumerable<TSource> OrderByWithShuffle<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector)\n        {\n            return source.Shuffle().OrderBy(keySelector);\n        }\n\n        public static T[] Shuffle<T>(this IEnumerable<T> source)\n        {\n            T[] result = source.ToArray();\n            Shuffle(result);\n            return result;\n        }\n\n        private static void Shuffle<T>(IList<T> array)\n        {\n            Random rnd = new Random();\n            for (int i = array.Count - 1; i >= 1; i--)\n            {\n                int k = rnd.Next(i + 1);\n                T tmp = array[k];\n                array[k] = array[i];\n                array[i] = tmp;\n            }\n        }\n\n        #region Read/Write\n\n        private static TextReader Reader;\n\n        private static TextWriter Writer;\n\n        private static Queue<string> CurrentLineTokens = new Queue<string>();\n\n        private static string[] ReadAndSplitLine()\n        {\n            return Reader.ReadLine().Split(new[] { ' ', '\\t' }, StringSplitOptions.RemoveEmptyEntries);\n        }\n\n        public static string ReadToken()\n        {\n            while (CurrentLineTokens.Count == 0)\n                CurrentLineTokens = new Queue<string>(ReadAndSplitLine());\n            return CurrentLineTokens.Dequeue();\n        }\n\n        public static string ReadLine()\n        {\n            return Reader.ReadLine();\n        }\n\n        public static int ReadInt()\n        {\n            return int.Parse(ReadToken());\n        }\n\n        public static long ReadLong()\n        {\n            return long.Parse(ReadToken());\n        }\n\n        public static double ReadDouble()\n        {\n            return double.Parse(ReadToken(), CultureInfo.InvariantCulture);\n        }\n\n        public static int[] ReadIntArray()\n        {\n            return ReadAndSplitLine().Select(int.Parse).ToArray();\n        }\n\n        public static long[] ReadLongArray()\n        {\n            return ReadAndSplitLine().Select(long.Parse).ToArray();\n        }\n\n        public static double[] ReadDoubleArray()\n        {\n            return ReadAndSplitLine().Select(s => double.Parse(s, CultureInfo.InvariantCulture)).ToArray();\n        }\n\n        public static int[][] ReadIntMatrix(int numberOfRows)\n        {\n            int[][] matrix = new int[numberOfRows][];\n            for (int i = 0; i < numberOfRows; i++)\n                matrix[i] = ReadIntArray();\n            return matrix;\n        }\n\n        public static string[] ReadLines(int quantity)\n        {\n            string[] lines = new string[quantity];\n            for (int i = 0; i < quantity; i++)\n                lines[i] = Reader.ReadLine().Trim();\n            return lines;\n        }\n\n        public static void WriteArray<T>(IEnumerable<T> array)\n        {\n            Writer.WriteLine(string.Join(\" \", array));\n        }\n\n        #endregion\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression,\n                          System.Linq.Expressions.UnaryExpression>;\n\nclass Program {\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = 1L << 60;\n    const double eps = 1e-11;\n    static void Main(string[] args)\n    {\n        long n, h, d;\n        sc.Multi(out n, out h, out d);\n        var fact = new long[n + 1];\n        fact[0] = 1;\n        long fsum = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            fact[i] = fact[i - 1] * i % M;\n            fsum = (fsum + fact[i]) % M;\n        }\n        var dp = new long[h + 1];\n        dp[0] = 1;\n        var ims = new long[h + 2];\n        for (int i = 0; i <= h; i++)\n        {\n            dp[i] = (dp[i] + ims[i] - ims[Math.Max(0, i - d)] + M) % M;\n            ims[i + 1] = (ims[i] + dp[i] * (i == 0 ? 1 : fsum)) % M;\n        }\n        Prt(dp[h] * fact[n] % M);\n        sw.Flush();\n    }\n\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n}\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util {\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static pair<P, char>[] adjacents_with_str(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new pair<P, char>(new P(i + dd[k], j + dd[k ^ 1]), dstring[k])).ToArray();\n    public static pair<P, char>[] adjacents_with_str(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new pair<P, char>(new P(i + dd[k], j + dd[k ^ 1]), dstring[k])).Where(p => inside(p.v1.v1, p.v1.v2, h, w)).ToArray();\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static void Assert(bool cond) { if (!cond) throw new Exception(); }\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T> {\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nusing System.Text;//テキストの高速出力に必要\nclass Program\n{\n\tstatic void Main()\n\t{\n\t\tlong n = long.Parse(Console.ReadLine());\n\t\tlong[,] changes = new long[2,3];\n    for(int i = 0; i < 2; i++)\n    {\n      string[] inputa = Console.ReadLine().Split(' ');\n\t    changes[i,0] = long.Parse(inputa[0]);\n      changes[i,1] = long.Parse(inputa[1]);\n      changes[i,2] = long.Parse(inputa[2]);\n    }\n\n    long memo = 0;\n    long m = n;\n    for(int i = 0; i <= n; i++)\n    {\n      for(int j = 0; j <= n-i; j++)\n      {\n        if(changes[0,0] < changes[1,0]) memo += changes[1,0]*(i/changes[0,0])\n          +(i-i/changes[0,0]*changes[0,0]);\n        if(changes[0,1] < changes[1,1]) memo += changes[1,1]*(j/changes[0,1])\n          +(j-j/changes[0,1]*changes[0,1]);\n        if(changes[0,2] < changes[1,2]) memo += changes[1,2]*((n-i-j)/changes[0,2])\n          +((n-i-j)-(n-i-j)/changes[0,2]*changes[0,2]);\n        m = Math.Max(m,memo);\n      }\n    }\n    n = m;\n    m = n;\n\n    if(changes[0,0] < changes[1,0])\n    {\n      for(int i = 0; i <= n; i++)\n      { \n        memo = 0;\n        if(changes[1,1] < changes[0,1]) memo += changes[0,1]*(i/changes[1,1]);\n        if(changes[1,2] < changes[0,2]) memo += changes[0,2]*((n-i)/changes[1,2]);\n        m = Math.Max(m,memo);\n      }\n    }else if(changes[0,1] < changes[1,1])\n    {\n      for(int i = 0; i <= n; i++)\n      { \n        memo = 0;\n        if(changes[1,0] < changes[0,0]) memo += changes[0,0]*(i/changes[1,0]);\n        if(changes[1,2] < changes[0,2]) memo += changes[0,2]*((n-i)/changes[1,2]);\n        m = Math.Max(m,memo);\n      }\n    }else if(changes[0,2] < changes[1,2])\n    {\n      for(int i = 0; i <= n; i++)\n      { \n        memo = 0;\n        if(changes[1,1] < changes[0,1]) memo += changes[0,1]*(i/changes[1,1]);\n        if(changes[1,0] < changes[0,0]) memo += changes[0,0]*((n-i)/changes[1,0]);\n        m = Math.Max(m,memo);\n      }\n    }else\n    {\n      for(int i = 0; i <= n; i++)\n      {\n        for(int j = 0; j <= n-i; j++)\n        {\n          memo = 0;\n          if(changes[1,0] < changes[0,0]) memo += changes[0,0]*(i/changes[1,0]);\n          if(changes[1,1] < changes[0,1]) memo += changes[0,1]*(j/changes[1,1]);\n          if(changes[1,2] < changes[0,2]) memo += changes[0,2]*((n-i-j)/changes[1,2]);\n          m = Math.Max(m,memo);\n        }\n      }\n    }\n    Console.WriteLine(m);\n\t}\n}"
  },
  {
    "language": "Lisp",
    "code": "(eval-when (:compile-toplevel :load-toplevel :execute)\n  (sb-int:defconstant-eqx opt\n    #+swank '(optimize (speed 3) (safety 2))\n    #-swank '(optimize (speed 3) (safety 0) (debug 0))\n    #'equal)\n  #+swank (ql:quickload '(:cl-debug-print :fiveam) :silent t)\n  #-swank (set-dispatch-macro-character\n           #\\# #\\> (lambda (s c p) (declare (ignore c p)) `(values ,(read s nil nil t)))))\n#+swank (cl-syntax:use-syntax cl-debug-print:debug-print-syntax)\n#-swank (disable-debugger) ; for CS Academy\n\n;; BEGIN_INSERTED_CONTENTS\n;;;\n;;; Arithmetic operations with static modulus\n;;;\n\n;; FIXME: Currently MOD* and MOD+ doesn't apply MOD when the number of\n;; parameters is one.\n(defmacro define-mod-operations (divisor)\n  `(progn\n     (defun mod* (&rest args)\n       (reduce (lambda (x y) (mod (* x y) ,divisor)) args))\n\n     (defun mod+ (&rest args)\n       (reduce (lambda (x y) (mod (+ x y) ,divisor)) args))\n\n     #+sbcl\n     (eval-when (:compile-toplevel :load-toplevel :execute)\n       (locally (declare (muffle-conditions warning))\n         (sb-c:define-source-transform mod* (&rest args)\n           (if (null args)\n               1\n               (reduce (lambda (x y) `(mod (* ,x ,y) ,',divisor)) args)))\n         (sb-c:define-source-transform mod+ (&rest args)\n           (if (null args)\n               0\n               (reduce (lambda (x y) `(mod (+ ,x ,y) ,',divisor)) args)))))\n\n     (define-modify-macro incfmod (delta)\n       (lambda (x y) (mod (+ x y) ,divisor)))\n\n     (define-modify-macro decfmod (delta)\n       (lambda (x y) (mod (- x y) ,divisor)))\n\n     (define-modify-macro mulfmod (multiplier)\n       (lambda (x y) (mod (* x y) ,divisor)))))\n\n\n(in-package :cl-user)\n\n(defmacro dbg (&rest forms)\n  #+swank\n  (if (= (length forms) 1)\n      `(format *error-output* \"~A => ~A~%\" ',(car forms) ,(car forms))\n      `(format *error-output* \"~A => ~A~%\" ',forms `(,,@forms)))\n  #-swank (declare (ignore forms)))\n\n(defmacro define-int-types (&rest bits)\n  `(progn\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"UINT~A\" b)) () '(unsigned-byte ,b))) bits)\n     ,@(mapcar (lambda (b) `(deftype ,(intern (format nil \"INT~A\" b)) () '(signed-byte ,b))) bits)))\n(define-int-types 2 4 7 8 15 16 31 32 62 63 64)\n\n(declaim (inline println))\n(defun println (obj &optional (stream *standard-output*))\n  (let ((*read-default-float-format* 'double-float))\n    (prog1 (princ obj stream) (terpri stream))))\n\n(defconstant +mod+ 1000000007)\n\n;;;\n;;; Body\n;;;\n\n(define-mod-operations +mod+)\n(defun main ()\n  (declare #.OPT)\n  (let* ((n (read))\n         (h (read))\n         (d (read))\n         (dp (make-array (+ h 1) :element-type 'uint31 :initial-element 0))\n         (cumuls (make-array (+ h 1) :element-type 'uint31 :initial-element 0))\n         (factor 0))\n    (declare (uint31 n h d factor))\n    (let ((base 1))\n      (declare (uint31 base))\n      (loop for x from 1 to n\n            do (mulfmod base x)\n               (incfmod factor base))\n      (setf (aref dp 0) base))\n    (dotimes (x (+ h 1))\n      (when (< 0 x)\n        (incfmod (aref cumuls x) (aref cumuls (- x 1)))\n        (incfmod (aref dp x) (aref cumuls x)))\n      (when (< 0 x h)\n        (mulfmod (aref dp x) factor))\n      (when (<= (+ x 1) h)\n        (incfmod (aref cumuls (+ x 1)) (aref dp x)))\n      (when (<= (+ x d 1) h)\n        (decfmod (aref cumuls (+ x d 1)) (aref dp x))))\n    (println (aref dp h))))\n\n#-swank (main)\n\n;;;\n;;; Test and benchmark\n;;;\n\n#+swank\n(defun io-equal (in-string out-string &key (function #'main) (test #'equal))\n  \"Passes IN-STRING to *STANDARD-INPUT*, executes FUNCTION, and returns true if\nthe string output to *STANDARD-OUTPUT* is equal to OUT-STRING.\"\n  (labels ((ensure-last-lf (s)\n             (if (eql (uiop:last-char s) #\\Linefeed)\n                 s\n                 (uiop:strcat s uiop:+lf+))))\n    (funcall test\n             (ensure-last-lf out-string)\n             (with-output-to-string (out)\n               (let ((*standard-output* out))\n                 (with-input-from-string (*standard-input* (ensure-last-lf in-string))\n                   (funcall function)))))))\n\n#+swank\n(defun get-clipbrd ()\n  (with-output-to-string (out)\n    (run-program \"powershell.exe\" '(\"-Command\" \"Get-Clipboard\") :output out :search t)))\n\n#+swank (defparameter *this-pathname* (uiop:current-lisp-file-pathname))\n#+swank (defparameter *dat-pathname* (uiop:merge-pathnames* \"test.dat\" *this-pathname*))\n\n#+swank\n(defun run (&optional thing (out *standard-output*))\n  \"THING := null | string | symbol | pathname\n\nnull: run #'MAIN using the text on clipboard as input.\nstring: run #'MAIN using the string as input.\nsymbol: alias of FIVEAM:RUN!.\npathname: run #'MAIN using the text file as input.\"\n  (let ((*standard-output* out))\n    (etypecase thing\n      (null\n       (with-input-from-string (*standard-input* (delete #\\Return (get-clipbrd)))\n         (main)))\n      (string\n       (with-input-from-string (*standard-input* (delete #\\Return thing))\n         (main)))\n      (symbol (5am:run! thing))\n      (pathname\n       (with-open-file (*standard-input* thing)\n         (main))))))\n\n#+swank\n(defun gen-dat ()\n  (uiop:with-output-file (out *dat-pathname* :if-exists :supersede)\n    (format out \"\")))\n\n#+swank\n(defun bench (&optional (out (make-broadcast-stream)))\n  (time (run *dat-pathname* out)))\n\n;; To run: (5am:run! :sample)\n#+swank\n(it.bese.fiveam:test :sample\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"2 2 1\n\"\n    \"6\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"2 30 15\n\"\n    \"94182806\n\"))\n  (it.bese.fiveam:is\n   (common-lisp-user::io-equal \"31415 9265 3589\n\"\n    \"312069529\n\")))\n"
  },
  {
    "language": "Ruby",
    "code": "eval\"N,H,D=\"+`tr \\\\  ,`\ns=n=0\nt=1\n1.upto(N){|i|s+=t=t*i%M=10**9+7}\nH.times{|i|x=n*s\ni<D&&x+=t\n$*<<x%=M\nn+=x-($*[~D]||0)}\np$*[-1]"
  },
  {
    "language": "Ruby",
    "code": "eval\"N,H,D=\"+`tr \\\\  ,`\nM=10**9+7\ns=n=0\nt=1\n1.upto(N){|i|s+=t=t*i%M}\nH.times{|i|x=n*s\ni<D&&x+=t\n$*<<x%=M\nn+=x-($*[~D]||0)}\np$*[-1]"
  },
  {
    "language": "Ruby",
    "code": "p \"idk\""
  },
  {
    "language": "OCaml",
    "code": "let n, h, d = Scanf.scanf \"%d %d %d\" (fun x y z -> x, y, z);;\n\nlet md = 1000000007L;;\nlet ( +: ) x y = Int64.add x y;;\nlet ( -: ) x y = Int64.sub x y;;\nlet ( *: ) x y = Int64.mul x y;;\nlet ( +++ ) (x : int) (y : int) : int = Int64.to_int @@ let z = Int64.of_int x +: Int64.of_int y in\n                                  if z < md then z else z -: md;;\nlet ( --- ) (x : int) (y : int) : int = Int64.to_int @@ let z = Int64.of_int x -: Int64.of_int y in\n                                  if z >= 0L then z else z +: md;;\nlet ( *** ) (x : int) (y : int) : int = Int64.to_int @@ Int64.rem (Int64.of_int x *: Int64.of_int y) md;;\n      \nlet f = ref 1 and s = ref 0;;\nfor i = 1 to n do\n  f := !f *** i;\n  s := !s +++ !f;\ndone;;\nlet f = !f and s = !s;;\n\nlet dp = Array.make (h+2) 0;;\ndp.(1) <- dp.(1) +++ 1;;\ndp.(d+1) <- dp.(d+1) --- 1;;\nfor i = 1 to h-1 do\n  dp.(i+1) <- dp.(i+1) +++ dp.(i);\n  let l = i + 1 in\n  let r = min (h+1) (i+d+1) in\n  dp.(l) <- dp.(l) +++ dp.(i) *** s;\n  dp.(r) <- dp.(r) --- dp.(i) *** s;\ndone;;\nlet ans = dp.(h) *** f;;\nPrintf.printf \"%d\\n\" ans;;\n\n\n\n"
  },
  {
    "language": "Perl",
    "code": "$s+=($.*=$_)%=$==1e9+7for<>=~/ .* /..$`;($n-=$_[-$']-($\\=$_[@_]=($s%$=*$n+$.*($_<=$'))%$=))%=$=for 1..$&;print"
  },
  {
    "language": "Perl",
    "code": "($s+=($.*=$_)%=$==1e9+7)%=$=for<>=~/ .* /..$`;($n-=$_[-$']-($\\=$_[@_]=($n*$s+$.*($_<=$'))%$=))%=$=for 1..$&;print"
  },
  {
    "language": "Perl",
    "code": "($s+=($.*=$_)%=$==1e9+7)%=$=for<>=~/ .* /..$`;($n-=$_[-$']-($\\=$_[@_]=$n*$s%$=+$.*($_<=$')))%=$=for 1..$&;print"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\nimmutable long MOD = 10^^9 + 7;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0];\n    auto H = s[1];\n    auto D = s[2];\n\n    auto F = new long[](N+1);\n    F[0] = F[1] = 1;\n    foreach (i; 2..N+1) F[i] = F[i-1] * i % MOD;\n    long co = 0;\n    foreach (i; 1..N+1) co = (co + F[i]) % MOD;\n\n    auto dp = new long[](H+1);\n    dp[0] = F[N];\n\n    auto st = new LazySegmentTree!(long, long, (a,b)=>(a+b)%MOD, (a,b)=>(a+b)%MOD, (a,b)=>(a+b)%MOD, (a,b)=>a*b%MOD, 0L, 0L)(H+1);\n    st.update(0, 0, 1);\n\n    foreach (i; 0..H) {\n        if (i == 0) {\n            st.update(i+1, min(i+D, H), F[N]);\n        } else {\n            long tmp = st.query(i, i);\n            st.update(i+1, min(i+D, H), tmp*co%MOD);\n        }\n    }\n\n    st.query(H, H).writeln;\n}\n\nclass LazySegmentTree(T, L, alias opTT, alias opTL, alias opLL, alias opPrd, T eT, L eL) {\n    T[] table;\n    L[] lazy_;\n    int n;\n    int size;\n\n    this(int n) {\n        this.n = n;\n        size = 1;\n        while (size <= n) size <<= 1;\n        size <<= 1;\n        table = new T[](size);\n        lazy_ = new L[](size);\n        table[] = eT;\n        lazy_[] = eL;\n    }\n\n    void push(int i, int a, int b) {\n        if (lazy_[i] == eL) return;\n        table[i] = opTL(table[i], opPrd(lazy_[i], b - a + 1));\n        if (i * 2 + 1 < size) {\n            lazy_[i*2] = opLL(lazy_[i*2], lazy_[i]);\n            lazy_[i*2+1] = opLL(lazy_[i*2+1], lazy_[i]);\n        }\n        lazy_[i] = eL;\n    }\n\n    T query(int l, int r) {\n        if (l > r) return eT;\n        return query(l, r, 1, 0, n-1);\n    }\n\n    T query(int l, int r, int i, int a, int b) {\n        if (b < l || r < a) return eT;\n        push(i, a, b);\n        if (l <= a && b <= r) {\n            return table[i];\n        } else {\n            return opTT(query(l, r, i*2, a, (a+b)/2), query(l, r, i*2+1, (a+b)/2+1, b));\n        }\n    }\n\n    void update(int l, int r, L val) {\n        if (l > r) return;\n        update(l, r, 1, 0, n-1, val);\n    }\n\n    void update(int l, int r, int i, int a, int b, L val) {\n        if (b < l || r < a) {\n            push(i, a, b);\n        } else if (l <= a && b <= r) {\n            lazy_[i] = opLL(lazy_[i], val);\n            push(i, a, b);\n        } else {\n            push(i, a, b);\n            update(l, r, i*2, a, (a+b)/2, val);\n            update(l, r, i*2+1, (a+b)/2+1, b, val);\n            table[i] = opTT(table[i*2], table[i*2+1]);\n        }\n    }\n}"
  },
  {
    "language": "Nim",
    "code": "import algorithm, future, hashes, macros, math, sequtils, sets, strutils, tables, times, unicode, queues\n \nmacro unpack(rhs: seq, cnt: static[int]): auto =\n  let t = genSym(); result = quote do:(let `t` = `rhs`;())\n  if NimMinor <= 17:\n    for i in 0..<cnt: result[0][1].add(quote do:`t`[`i`])\n  else:\n    for i in 0..<cnt: result[1].add(quote do:`t`[`i`])\n \ntemplate input(T: typedesc, cnt: Natural = 1): untyped =\n  let line = stdin.readLine.split(\" \")\n  when T is int:         line.map(parseInt).unpack(cnt)\n  elif T is float:       line.map(parseFloat).unpack(cnt)\n  elif T is string:      line.unpack(cnt)\n  elif T is char:        line.mapIt(it[0]).unpack(cnt)\n  elif T is seq[int]:    line.map(parseInt)\n  elif T is seq[float]:  line.map(parseFloat)\n  elif T is seq[string]: line\n  elif T is seq[char]:   line.mapIt(it[0])\n \n# proc `%=`(n: var int, m: int)  = n = n mod m\n# proc `//=`(n: var int, m: int) = n = n div m\n# proc `<<=`(n: var int, m: int) = n = n shl m\n# proc `>>=`(n: var int, m: int) = n = n shr m\n# proc `<?=`(n: var int, m: int) = n = min(n, m)\n# proc `>?=`(n: var int, m: int) = n = max(n, m)\n# proc newSeq2[T](n1, n2: Natural): seq[seq[T]] = newSeqWith(n1, newSeq[T](n2))\n# proc newSeq3[T](n1, n2, n3: Natural): seq[seq[seq[T]]] = newSeqWith(n1, newSeqWith(n2, newSeq[T](n3)))\n \n# -------------------------------------------------- #\n\n\n\n# ModInt : Z/1000000007Z\n# Remember as an int in 0..<1000000007\n# However $ModInt(-3)==\"-3\". So if arg may be negative, use $newModInt(-3)==1000000004\n# tested in ARC 190330\n\nproc floorMod*[T: SomeNumber](x, y: T): T =\n  result = x mod y\n  if (result > 0 and y < 0) or (result < 0 and y > 0): result += y\n\nconst MOD = int(1000000007)\ntype ModInt* = distinct int\n\nproc newModInt(x:int): ModInt = ModInt(floorMod(x, MOD))\nproc `-`(x: ModInt): ModInt = ModInt(floorMod(-int(x), MOD))\n\nproc `+`(x:ModInt, y:ModInt): ModInt = ModInt(floorMod(int(x)+int(y), MOD))\nproc `+`(x:ModInt, y:int): ModInt = ModInt(floorMod(int(x)+y, MOD))\nproc `+`(x:int, y:ModInt): ModInt = ModInt(floorMod(x+int(y), MOD))\nproc `+=`(x: var ModInt, y: ModInt or int)  = x = x + y\nproc `-`(x:ModInt, y:ModInt): ModInt = ModInt(floorMod(int(x)-int(y), MOD))\nproc `-`(x:ModInt, y:int): ModInt = ModInt(floorMod(int(x)-y, MOD))\nproc `-`(x:int, y:ModInt): ModInt = ModInt(floorMod(x-int(y), MOD))\nproc `-=`(x: var ModInt, y: ModInt or int)  = x = x - y\n\nproc `==`(x:ModInt, y:ModInt): bool = ((int(x)-int(y)) mod MOD == 0)\nproc `==`(x:ModInt, y:int): bool = ((int(x)-y) mod MOD == 0)\nproc `==`(x:int, y:ModInt): bool = ((x-int(y)) mod MOD == 0)\nproc `!=`(x:ModInt, y:ModInt): bool = not(x==y)\nproc `!=`(x:ModInt, y:int): bool = not(x==y)\nproc `!=`(x:int, y:ModInt): bool = not(x==y)\n\nproc `*`(x:ModInt, y:ModInt): ModInt = ModInt(floorMod(int(x)*int(y), MOD))\nproc `*`(x:ModInt, y:int): ModInt = ModInt(floorMod(int(x)*y, MOD))\nproc `*`(x:int, y:ModInt): ModInt = ModInt(floorMod(x*int(y), MOD))\nproc `*=`(x: var ModInt, y: ModInt or int)  = x = x * y\n\nproc `^`(x:ModInt, y:int): ModInt =\n  var x = x\n  var y = floorMod(y, MOD-1) #x^(MOD-1)==1\n  result = ModInt(1)\n  while true:\n    if (y and 1) != 0:\n      result *= x\n    y = y shr 1\n    if y == 0:\n      break\n    x *= x\nproc inv(x:ModInt): ModInt = x^(-1)\nproc inv(x:int): ModInt = ModInt(x)^(-1)\n\nproc `/`(x:ModInt, y:ModInt):ModInt = x * inv(y)\nproc `/`(x:ModInt, y:int):ModInt = x * inv(ModInt(y))\nproc `/`(x:int, y:ModInt):ModInt = ModInt(x) * inv(y)\nproc `/=`(x: var ModInt, y: ModInt or int)  = x = x / y\nproc `$`(x:ModInt):string = $int(x)\n\n\n\n\nvar (N,H,D) = input(int,3)\nvar factorial : array[1000010, ModInt]\nfactorial[0]=ModInt(1)\nfor i in 1..N:\n  factorial[i]=i*factorial[i-1]\n\nvar G = ModInt(0)\nfor i in 1..N:\n  G += factorial[i]\n\n\n\nvar dp :array[1000010, ModInt]\nvar sdp :array[1000010, ModInt]\nsdp[0] = ModInt(0)\ndp[0] = factorial[N]\nsdp[1] = sdp[0]+dp[0]\n\nfor h in 1..<H:\n  dp[h] = G * ( sdp[h] - sdp[max(0,h-D)] )\n  sdp[h+1] = sdp[h] + dp[h]\n\necho sdp[H] - sdp[max(0,H-D)]\n"
  },
  {
    "language": "Nim",
    "code": "#{{{ header\nimport algorithm, sequtils, tables, future, macros, math, sets, strutils\n \nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\nproc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString(): string =\n  var get = false\n  result = \"\"\n  while true:\n    var c = getchar()\n    if int(c) == 255:\n      break\n    elif int(c) > int(' '):\n      get = true\n      result.add(c)\n    else:\n      if get: break\n      get = false\nproc infinity[T]():T =\n  return (T(1) shl T(sizeof(T)*8-2))-1\n#}}}\n\n#{{{ gcd and inverse\n#define __GCD_H\nproc gcd(a,b:int):int=\n  if b == 0: return a\n  else: return gcd(b,a mod b)\nproc lcm(a,b:int):int=\n  return a div gcd(a, b) * b\n# a x + b y = gcd(a, b)\nproc extgcd(a,b:int, x,y:var int):int =\n  var\n    g = a\n  x = 1\n  y = 0\n  if b != 0:\n    g = extgcd(b, a mod b, y, x)\n    y -= (a div b) * x\n  return g;\n\nproc invMod(a,m:int):int =\n  var\n    x,y:int\n  if extgcd(a, m, x, y) == 1: return (x + m) mod m\n  else: return 0 # unsolvable\n#}}}\n\nconst MOD = 1_000_000_007\n#{{{ Mint\ntype Mint = object\n  v:int\n\nproc newMint[T](a:T):Mint =\n  return Mint(v:a mod MOD)\nproc newMint(a:Mint):Mint =\n  return a\n\nproc `+=`[T](a:var Mint,b:T):void =\n  a.v += newMint(b).v\n  if a.v >= MOD:\n    a.v -= MOD\nproc `+`[T](a:Mint,b:T):Mint =\n  var c = a\n  c += b\n  return c\nproc `*=`[T](a:var Mint,b:T):void =\n  a.v *= newMint(b).v\n  a.v = a.v mod MOD\nproc `*`[T](a:Mint,b:T):Mint =\n  var c = a\n  c *= b\n  return c\nproc `-`(a:Mint):Mint =\n  if a.v == 0: return a\n  else: return Mint(v:MOD - a.v)\nproc `-=`[T](a:var Mint,b:T):void =\n  a.v -= newMint(b).v\n  if a.v < 0:\n    a.v += MOD\nproc `-`[T](a:Mint,b:T):Mint =\n  var c = a\n  c -= b\n  return c\nproc `/=`[T](a:var Mint,b:T):void =\n  a.v *= invMod(newMint(b).v,MOD)\n  a.v = a.v mod MOD\nproc `/`[T](a:Mint,b:T):Mint =\n  var c = a\n  c /= b\n  return c\n#}}}\n\n#{{{ fact, comb, perm\nvar\n  factorial_val = @[newMint(1)]\n\nproc fact(n:int):Mint =\n  for i in len(factorial_val)..n:\n    factorial_val.add(factorial_val[i-1] * i)\n  return factorial_val[n]\n\nproc comb(n,r:int):Mint =\n  if n<0 or r<0 or n<r:\n    return newMint(0)\n  else:\n    return fact(n)/(fact(r)*fact(n-r))\n\nproc perm(n,r:int):Mint =\n  if n<0 or n<r:\n    return newMint(0)\n  else:\n    return fact(n)/fact(n-r)\n#}}}\n\n\nproc main():void =\n  var\n    N = nextInt()\n    H = nextInt()\n    D = nextInt()\n    dp = newSeqWith(H+1,newMint(0))\n    fact_sum = newMint(0)\n    dp_sum = newMint(0)\n  for i in 1..N:\n    fact_sum += fact(i)\n  dp[0] = fact(N)\n  dp_sum += dp[0]\n  for i in 1..H:\n    dp[i] = dp_sum\n    if i < H:\n      dp[i] *= fact_sum\n    dp_sum += dp[i]\n    if i >= D:\n      dp_sum -= dp[i-D]\n  echo dp[H].v\n  discard\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nrange = xrange\ninput = raw_input\n\nmod = 10**9 + 7\n\nn,h,d = [int(x) for x in input().split()]\n\nbig = 10**6+10\nfac = [1]\nwhile len(fac)<big:\n    fac.append(fac[-1] * len(fac) % mod)\n\ncumfac = [0]\nfor f in fac:\n    cumfac.append((cumfac[-1] + f)%mod)\n\nDP = [0]*(h+1)\nDP[0] = fac[n]\n\nmulti = cumfac[n+1] - cumfac[1]\ns = 0\nfor i in range(1,h):\n    s += DP[i-1]\n    if i-d-1>=0:\n        s -= DP[i-d-1]\n    s %= mod\n    DP[i] = s*multi % mod\n\n# special\nDP[h] = sum(DP[max(0,h-d):h]) % mod\n\nprint DP[-1]\n"
  },
  {
    "language": "Python",
    "code": "N, H, D = map(int, input().split())\nP, a, s = 10**9+7, 1, 0\nfor i in range(1, N+1):\n    a = a*i%P\n    s = (s+a)%P\n\nX = [a]\nfor i in range(1, H):\n    X.append(a*s%P)\n    a += X[-1]\n    if i >= D: a -= X[-D-1]\n    a %= P\n\nprint(a)"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nfib = 1\nif n < 10:\n    fib = [1, 2, 4, 7, 12, 20, 33, 54, 88]\nelse:\n    fib = [1, 2, 4, 7, 12, 20, 33, 54, 55]\n    \nprod = [1] * 10\nfor i in range(1,9):\n    prod[i] = prod[i-1] * fib[i]\n    \n\nans = [[0] * n for i in range(n)]\nfor i in range(n):\n    for j in range(i+1, n):\n        ans[i][j] = ans[j][i] = fib[j-i-1] * prod[n-2-i]\n\nfor i in range(n):\n    print(\" \".join(list(map(str, ans[i]))))\n    "
  },
  {
    "language": "Python",
    "code": "n, h, d = map(int, input().split())\nMOD = 10 ** 9 + 7\n\n\nif n * h * d >= 10 ** 7:\n    print(re)\n\n# dp[i][j] := 高さiのブロックが最大高さでj個ある時の通り数\ndp = [[0] * (n + 1) for i in range(h + 1)]\ndp[0][n] = 1\n\n# O(HDN)\nfor i in range(h):\n    # j = 0 -> j = 1 にする\n    for diff in range(1, d + 1):\n        if i + 1 - diff < 0:\n            continue\n        for cnt in range(1, n + 1):\n            dp[i + 1][1] += dp[i + 1 - diff][cnt] * cnt\n            dp[i + 1][1] %= MOD\n\n    # j -> j + 1 にする\n    for j in range(2, n + 1):\n        dp[i + 1][j] += dp[i + 1][j - 1] * (n - (j - 1))\n        dp[i + 1][j] %= MOD\n\nprint(dp[-1][-1] % MOD)"
  },
  {
    "language": "Python",
    "code": "n, h, d = map(int, input().split())\nMOD = 10 ** 9 + 7\n\n\nif d != 1:\n    print(re)\n\nfact = [1] * (n + 1)\nfor i in range(n):\n    fact[i + 1] = fact[i] * (i + 1)\n    fact[i + 1] %= MOD\n\n# fact_sum = fact[1] + fact[2] + ... + fact[n]\nfact_sum = 0\nfor i in range(1, n + 1):\n    fact_sum += fact[i]\n    fact_sum %= MOD\n\ndp = [0] * (h + 1)\ndp[0] = 1\nfor i in range(h):\n    dp[i + 1] = dp[i] * fact_sum\n    dp[i + 1] %= MOD\n\nprint((dp[-1] - dp[-2] * (fact_sum - fact[-1])) % MOD)"
  },
  {
    "language": "Python",
    "code": "N, H, D = map(int, input().split())\nP, a, s = 10**9+7, 1, 0\nfor i in range(1, N+1):\n    a = a*i%P\n    s = (s+a)%P\n\nX = [a]\nfor i in range(1, H):\n    X.append(a*s%P)\n    a += X[-1]\n    if i >= D: a -= X[-D-1]\n    a %= P\n\nprint(a)"
  },
  {
    "language": "Python",
    "code": "N, H, D = map(int,input().split())\nMOD = 10**9 + 7\n\nfact = [1]\nfact_cum = [0] # 1! to N!\nfor i in range(1,N+1):\n  fact.append((fact[-1]*i)%MOD)\n  fact_cum.append((fact_cum[-1] + fact[-1])%MOD)\n\ndp = [0] * (H+1)\ndp_cum = [0] * (H+1)\ndp[0] = 1\ndp_cum[0] = 1\n\nfor n in range(1,H+1):\n  x = dp_cum[n-1]\n  if n > D:\n    x -= dp_cum[n-D-1]\n  x *= fact_cum[N]\n  x %= MOD\n  dp[n] = x\n  dp_cum[n] = (dp_cum[n-1] + x)%MOD\n\n\nanswer = dp[H]\nanswer *= fact[N]\nanswer %= MOD\nanswer *= pow(fact_cum[N],MOD-2,MOD)\nanswer %= MOD\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "n, h, d = map(int, input().split())\nMOD = 10 ** 9 + 7\n\n\nif n * h >= 10 ** 7:\n    print(re)\n\n# dp[i][j] := 高さiのブロックが最大高さでj個ある時の通り数\ndp = [[0] * (n + 1) for i in range(h + 1)]\ndp[0][n] = 1\n\n# O(HN)\nru = [[0] * (n + 2) for i in range(h + 1)]\nru[0][n + 1] = 1\nfor i in range(h):\n    # j = 0 -> j = 1 にする\n    for diff in range(1, d + 1):\n        if i + 1 - diff < 0:\n            continue\n        dp[i + 1][1] += ru[i + 1 - diff][n + 1]\n\n    # j - 1 -> j にする\n    for j in range(2, n + 1):\n        dp[i + 1][j] += dp[i + 1][j - 1] * j\n        dp[i + 1][j] %= MOD\n\n    for j in range(n + 1):\n        ru[i + 1][j + 1] = ru[i + 1][j] + dp[i + 1][j]\n        ru[i + 1][j + 1] %= MOD\n\nprint(dp[-1][-1] % MOD)"
  },
  {
    "language": "Python",
    "code": "N,H,D=map(int,input().split())\nmod=10**9+7\n\nconst=0\nfrac=[1]\nfor i in range(1,N+1):\n    frac.append((frac[-1]*i)%mod)\n    const=(const+frac[-1])%mod\n\ndp=[0]*(H+1)\ndp[0]=1\ndp[1]=frac[-1]\n\nS=dp[1]\nfor i in range(2,D+1):\n    dp[i]=const*S+frac[-1]\n    dp[i]%=mod\n    S=(S+dp[i])%mod\n\nS=sum(dp[i] for i in range(1,D+1))\nS%=mod\n\nfor i in range(D+1,H+1):\n    dp[i]=const*S\n    dp[i]%=mod\n    S=(S+dp[i]-dp[i-D])%mod\n\nprint(dp[H])\n"
  },
  {
    "language": "Python",
    "code": "N,H,D=map(int,input().split())\nmod=10**9+7\ntable=[1]\nnum=0\nfor i in range(1,N+1):\n    table.append(table[-1]*i%mod)\n    num=(num+table[-1])%mod\ndp=[0]*(H+1)\nd_sum=[0]*(H+1)\nfor i in range(1,D+1):\n    dp[i]=table[N]\nfor i in range(1,H+1):\n    dp[i]=(dp[i]+(d_sum[i-1]-d_sum[max(0,i-D-1)])*num)%mod\n    d_sum[i]=(dp[i]+d_sum[i-1])%mod\nprint(dp[H])"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/diverta2019-2/tasks/diverta2019_2_e\nMの時、 a1<=a2<=a3…aN\nを満たす通り数 X[M] が分かれば解ける(全ての順N!は等しいため)\n\n当然、次のMにはa1から順に更新していくことになる(M+?にね)\nDの時\nX[M] = (X[M-1] + X[M-2] +　… + X[M-D]) * N\nが成立かな\nX[0] = 1\n\nN=2\nX[0]=1\nX[1]=2\nX[2]=6\n\nN=3\nX[0]=1\nX[1]=9\n\nX[M]の更新式\n→これが間違ってそう\nX[M] = (X[M-1] + X[M-2] +　… + X[M-D]) * (1!+2!+3!+…N!)\n→エスパーだけどなんか正しそう\n\nX[H-1]を求めてN!を掛ければそれが答え\n→サンプル合った！！\n\"\"\"\nimport math\nN,H,D = map(int,input().split())\nmod = 10**9+7\n\nmul = 0\nfac = 1\nfor i in range(1,N+1):\n    fac *= i\n    fac %= mod\n    mul += fac\n    mul %= mod\n\nX = [1]\nnsum = 1\nfor i in range(H-1):\n\n    #print (i,nsum,mul)\n    X.append(nsum*mul%mod)\n\n    nsum += X[-1]\n    if i >= D-1:\n        nsum -= X[i-D+1]\n        \n\n#print (X)\nprint (nsum * math.factorial(N) % mod)\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\nhttps://atcoder.jp/contests/diverta2019-2/tasks/diverta2019_2_e\nMの時、 a1<=a2<=a3…aN\nを満たす通り数 X[M] が分かれば解ける(全ての順N!は等しいため)\n\n当然、次のMにはa1から順に更新していくことになる(M+?にね)\nDの時\nX[M] = (X[M-1] + X[M-2] +　… + X[M-D]) * N\nが成立かな\nX[0] = 1\n\nN=2\nX[0]=1\nX[1]=2\nX[2]=6\n\nN=3\nX[0]=1\nX[1]=9\n\nX[M]の更新式\n→これが間違ってそう\nX[M] = (X[M-1] + X[M-2] +　… + X[M-D]) * (1!+2!+3!+…N!)\n→エスパーだけどなんか正しそう\n\nX[H-1]を求めてN!を掛ければそれが答え\n→サンプル合った！！\n\"\"\"\nimport math\nN,H,D = map(int,input().split())\nmod = 10**9+7\n\nmul = 0\nfac = 1\nfor i in range(1,N+1):\n    fac *= i\n    fac %= mod\n    mul += fac\n    mul %= mod\n\nX = [1]\nnsum = 1\nfor i in range(H-1):\n\n    #print (i,nsum,mul)\n    X.append(nsum*mul%mod)\n\n    nsum += X[-1]\n    nsum %= mod\n    if i >= D-1:\n        nsum -= X[i-D+1]\n        \n\n#print (X)\nprint (nsum * fac % mod)\n"
  },
  {
    "language": "Python",
    "code": "n, h, d = map(int, input().split())\nMOD = 10 ** 9 + 7\n\n\nif n * h * d >= 10 ** 7:\n    print(re)\n\n# dp[i][j] := 高さiのブロックが最大高さでj個ある時の通り数\ndp = [[0] * (n + 1) for i in range(h + 1)]\ndp[0][n] = 1\n\n# O(HDN)\nfor i in range(h):\n    # j = 0 -> j = 1 にする\n    for diff in range(1, d + 1):\n        if i + 1 - diff < 0:\n            continue\n        for cnt in range(1, n + 1):\n            dp[i + 1][1] += dp[i + 1 - diff][cnt] * cnt\n            dp[i + 1][1] %= MOD\n\n    # j -> j + 1 にする\n    for j in range(2, n + 1):\n        dp[i + 1][j] += dp[i + 1][j - 1] * (n - (j - 1))\n        dp[i + 1][j] %= MOD\n\nprint(dp[-1][-1])"
  },
  {
    "language": "Python",
    "code": "n = int(input())\nga, sa, ba = list(map(int, input().split()))\ngb, sb, bb = list(map(int, input().split()))\n\nw_ab = []\nv_ab = []\n\nif ga < gb:\n    w_ab.append(ga)\n    v_ab.append(gb)\nif sa < sb:\n    w_ab.append(sa)\n    v_ab.append(sb)\nif ba < bb:\n    w_ab.append(ba)\n    v_ab.append(bb)\n\nnum = (n+1)*(len(w_ab)+1)\ndp = [0]*num\nfor i in range(len(w_ab)):\n    for j in range(n+1):\n        if j < w_ab[i]:\n            dp[(i+1)*(n+1) + j] = dp[i*(n+1) + j]\n        else:\n            dp[(i+1)*(n+1) + j] = max(dp[i*(n+1) + j], dp[(i+1)*(n+1) + j - w_ab[i]] + v_ab[i])\nans = 0\nlength = len(w_ab)\nfor j in range(n+1):\n    ans = max(ans, dp[length*(n+1) + j] + n-j)\nn = ans\n\nw_ab = []\nv_ab = []\n\nif ga > gb:\n    w_ab.append(gb)\n    v_ab.append(ga)\nif sa > sb:\n    w_ab.append(sb)\n    v_ab.append(sa)\nif ba > bb:\n    w_ab.append(bb)\n    v_ab.append(ba)\n\nnum = (n+1)*(len(w_ab)+1)\ndp = [0]*num\nfor i in range(len(w_ab)):\n    for j in range(n+1):\n        if j < w_ab[i]:\n            dp[(i+1)*(n+1) + j] = dp[i*(n+1) + j]\n        else:\n            dp[(i+1)*(n+1) + j] = max(dp[i*(n+1) + j], dp[(i+1)*(n+1) + j - w_ab[i]] + v_ab[i])\n\nlength = len(w_ab)\nans = 0\nfor j in range(n+1):\n    ans = max(ans, dp[length*(n+1) + j] + n-j)\nprint(ans)\n  "
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef main():\n    md = 10 ** 9 + 7\n    n, h, d = MI()\n    sum_fact = 0\n    n_fact = 1\n    for x in range(1, n + 1):\n        n_fact *= x\n        sum_fact += n_fact\n        n_fact %= md\n        sum_fact %= md\n    if h==1:\n        print(n_fact)\n        exit()\n    dp = [0] * (h + 1)\n    dp[0] = dp[1] = n_fact\n    s = 0\n    for i in range(2, h + 1):\n        if i <= d:\n            s += dp[i - 1]\n            dp[i] = s * sum_fact + dp[0]\n        elif i == d + 1:\n            s += dp[i - 1]\n            dp[i] = s * sum_fact\n        else:\n            s += dp[i - 1] - dp[i - 1 - d]\n            dp[i] = s * sum_fact\n        s %= md\n        dp[i] %= md\n    print(dp[-1])\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "a = \"2 2 1\"\nprint \"6\"\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nMOD = 10**9+7\ndef frac(limit):\n    frac = [1]*limit\n    for i in range(2,limit):\n        frac[i] = i * frac[i-1]%MOD\n    fraci = [None]*limit\n    fraci[-1] = pow(frac[-1], MOD -2, MOD)\n    for i in range(-2, -limit-1, -1):\n        fraci[i] = fraci[i+1] * (limit + i + 1) % MOD\n    return frac, fraci\nfrac, fraci = frac(1341398)\ndef comb(a, b):\n    if not a >= b >= 0:\n        return 0\n    return frac[a]*fraci[b]*fraci[a-b]%MOD\n\nN, H, D = map(int, readline().split())\n\nM = 0\nfor i in range(1, N+1):\n    M = (M+frac[i]) % MOD\n\ndp = [0]*(H+2)\ndp[1] = frac[N]\nDp = dp[:]\n\nfor i in range(2, H+1):\n    dp[i] = M*(Dp[i-1] - Dp[max(0, i-D-1)]) % MOD\n    Dp[i] = (Dp[i-1] + dp[i]) % MOD\ndp[H+1] = (Dp[H] - Dp[max(0, H-D)]) % MOD\nprint(dp[H+1])\n"
  },
  {
    "language": "Python",
    "code": "n, h, d = map(int, input().split())\nMOD = 10 ** 9 + 7\n\n\nif n * h + h * d >= 10 ** 7:\n    print(re)\n\n# dp[i][j] := 高さiのブロックが最大高さでj個ある時の通り数\ndp = [[0] * (n + 1) for i in range(h + 1)]\ndp[0][n] = 1\n\n# O(HN)\nru = [[0] * (n + 2) for i in range(h + 1)]\nru[0][n + 1] = 1\nfor i in range(h):\n    # j = 0 -> j = 1 にする\n    for diff in range(1, d + 1):\n        if i + 1 - diff < 0:\n            continue\n        dp[i + 1][1] += ru[i + 1 - diff][n + 1]\n        dp[i + 1][1] %= MOD\n\n    # j - 1 -> j にする\n    for j in range(2, n + 1):\n        dp[i + 1][j] += dp[i + 1][j - 1] * j\n        dp[i + 1][j] %= MOD\n\n    for j in range(n + 1):\n        ru[i + 1][j + 1] = ru[i + 1][j] + dp[i + 1][j]\n        ru[i + 1][j + 1] %= MOD\n\nprint(dp[-1][-1] % MOD)"
  },
  {
    "language": "Python",
    "code": "N, H, D = map(int,input().split())\nMOD = 10**9 + 7\n\nfact = [1]\nfact_cum = [0] # 1! to N!\nfor i in range(1,N+1):\n  fact.append((fact[-1]*i)%MOD)\n  fact_cum.append((fact_cum[-1] + fact[-1])%MOD)\n\ndp = [0] * (H+1)\ndp_cum = [0] * (H+1)\ndp[0] = 1\ndp_cum[0] = 1\n\nfor n in range(1,H+1):\n  x = dp_cum[n-1]\n  if n > D:\n    x -= dp_cum[n-D-1]\n  x *= fact_cum[N]\n  x %= MOD\n  dp[n] = x\n  dp_cum[n] = (dp_cum[n-1] + x)%MOD\n\n\nanswer = dp[H]\nanswer *= fact[N]\nanswer %= MOD\nanswer *= pow(fact_cum[N],MOD-2,MOD)\nanswer %= MOD\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "mod = 1000000007\neps = 10**-9\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    N, H, D = map(int, input().split())\n    imos = [0] * (H+2)\n    ans = [0] * (H+1)\n    M = 0\n    f = 1\n    for i in range(1, N+1):\n        f = (f * i)%mod\n        M = (M + f)%mod\n    imos[1] += f\n    imos[D+1] -= f\n    for i in range(1, H):\n        ans[i] = (ans[i-1] + imos[i])%mod\n        imos[i+1] = (imos[i+1] + (ans[i] * M)%mod)%mod\n        if i+D+1 <= H:\n            imos[i+D+1] = (imos[i+D+1] - (ans[i] * M)%mod)%mod\n    print((ans[H-1] + imos[H])%mod)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\ntemplate <typename T>\nT power(T a, T n, T mod) {\n  T res = 1;\n  T tmp = n;\n  T curr = a;\n  while(tmp){\n    if(tmp % 2 == 1){\n      res = (T)((ll)res * curr % mod);\n    }\n    curr = (T)((ll)curr * curr % mod);\n    tmp >>= 1;\n  }\n\n  return res;\n}\n\nll fac[1000001], fsum[1000001];\nll dp[1000001], dpsum[1000001];\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  LL(n); LL(h); LL(d);\n  fac[0] = 1; FOR(i, 1, 1000001)fac[i] = i * fac[i-1] % mod;\n  FOR(i, 1, 1000001)fsum[i] = (fac[i] + (i > 1 ? fsum[i-1]: 0)) % mod;\n  dp[1] = 1;\n  dpsum[1] = 1;\n  FOR(i, 2, h + 1){\n    dp[i] = dpsum[i-1];\n    if(i-d-1>=0)dp[i] = (dp[i] - dpsum[i-d-1]) % mod;\n    if(dp[i]<0)dp[i] += mod;\n    dp[i] = dp[i] * fsum[n] % mod;\n    if(i <= d)dp[i]++;\n\n    dpsum[i] = (dpsum[i-1] + dp[i]) % mod;\n  }\n\n  cout << dp[h] * fac[n] % mod << endl;\n  return 0;\n}"
  },
  {
    "language": "Python",
    "code": "N, H, D = map(int, input().split())\n\nMOD = 10**9 + 7\n\nv = 1\nw = 0\nfor i in range(1, N+1):\n    v = v * i % MOD\n    w += v\nv %= MOD\nw %= MOD\n\ndp = [0]*(H+1)\ndp[0] = v\ns = 0\nfor i in range(H):\n    s += dp[i] % MOD\n    if i+1 < H:\n        dp[i+1] = s * w % MOD\n    else:\n        dp[i+1] = s % MOD\n    if i-D+1 >= 0:\n        s -= dp[i-D+1] % MOD\nprint(dp[H])"
  },
  {
    "language": "Python",
    "code": "n, h, d = map(int, input().split())\nMOD = 10 ** 9 + 7\n\nfact, fact_acc = 1, 1\nfor i in range(2, n + 1):\n    fact = fact * i % MOD\n    fact_acc = (fact_acc + fact) % MOD\n\ndp = [0] * (h + 1)\ndp[0] = base = fact\nfor i in range(1, h):\n    dp[i] = base * fact_acc % MOD\n    base = (base + dp[i]) % MOD\n    if i >= d:\n        base = (base - dp[i - d]) % MOD\nprint(base)\n"
  },
  {
    "language": "Python",
    "code": "n, h, d = map(int, input().split())\nMOD = 10 ** 9 + 7\n\n# dp[i][j] := 高さiのブロックが最大高さでj個ある時の通り数\ndp = [[0] * (n + 1) for i in range(h + 1)]\ndp[0][n] = 1\n\n# O(HDN)\nfor i in range(h):\n    # j = 0 -> j = 1 にする\n    for diff in range(1, d + 1):\n        if i + 1 - diff < 0:\n            continue\n        for cnt in range(1, n + 1):\n            dp[i + 1][1] += dp[i + 1 - diff][cnt] * cnt\n            dp[i + 1][1] %= MOD\n\n    # j -> j + 1 にする\n    for j in range(2, n + 1):\n        dp[i + 1][j] += dp[i + 1][j - 1] * (n - (j - 1))\n        dp[i + 1][j] %= MOD\n\nprint(dp[-1][-1])"
  },
  {
    "language": "Python",
    "code": "N, H, D = map(int,input().split())\nMOD = 10**9 + 7\n \nfact = [1]\nfact_cum = [0]\nfor i in range(1,N+1):\n  fact.append((fact[-1]*i)%MOD)\n  fact_cum.append((fact_cum[-1] + fact[-1])%MOD)\n \nap = [0] * (H+1)\nap_cum = [0] * (H+1)\nap[0] = 1\nap_cum[0] = 1\n \nfor n in range(1,H+1):\n  x = ap_cum[n-1]\n  if n > D:\n    x -=ap_cum[n-D-1]\n  x *= fact_cum[N]\n  x %= MOD\n  ap[n] = x\n  ap_cum[n] = (ap_cum[n-1] + x)%MOD\n \n \nans = ap[H]\nans *= fact[N]\nans %= MOD\nans *= pow(fact_cum[N],MOD-2,MOD)\nans %= MOD\n \nprint(ans)"
  },
  {
    "language": "Python",
    "code": "n, h, d = map(int, input().split())\nMOD = 10 ** 9 + 7\n\n\nfact = [1] * (n + 1)\nfor i in range(n):\n    fact[i + 1] = fact[i] * (i + 1)\n    fact[i + 1] %= MOD\n\n# fact_sum = fact[1] + fact[2] + ... + fact[n]\nfact_sum = 0\nfor i in range(1, n + 1):\n    fact_sum += fact[i]\n    fact_sum %= MOD\n\ndp = [0] * (h + 1)\nru = [0] * (h + 2)\ndp[0] = 1\nru[1] = 1\nfor i in range(h):\n    l = max(i + 1 - d, 0)\n    dp[i + 1] += (ru[i + 1] - ru[l]) * fact_sum\n    dp[i + 1] %= MOD\n    ru[i + 2] = ru[i + 1] + dp[i + 1]\n    ru[i + 2] %= MOD\n\nprint((dp[-1] * fact[n] * pow(fact_sum, MOD - 2, MOD)) % MOD)"
  },
  {
    "language": "Python",
    "code": "N, H, D = map(int, input().split())\nMOD = 10 ** 9 + 7\n\nfact = 1\ns = 0\nfor i in range(1, N+1) :\n    fact = fact * i % MOD\n    s = (s + fact) % MOD\n\ndp = [0] * H\ndp[0] = 1\nret = 1\n\nfor i in range(1, H) :\n    dp[i] = ret * s % MOD\n    ret = (ret + ret * s) % MOD\n    if i >= D : \n        ret = (ret - dp[i - D]) % MOD\n        \nprint(ret * fact % MOD)"
  },
  {
    "language": "Python",
    "code": "n, h, d = map(int, input().split())\nMOD = 10 ** 9 + 7\n\n\nif n * h * d >= 10 ** 7:\n    print(re)\n\n# dp[i][j] := 高さiのブロックが最大高さでj個ある時の通り数\ndp = [[0] * (n + 1) for i in range(h + 1)]\ndp[0][n] = 1\n\n# O(HDN)\nfor i in range(h):\n    # j = 0 -> j = 1 にする\n    for diff in range(1, d + 1):\n        if i + 1 - diff < 0:\n            continue\n        for cnt in range(1, n + 1):\n            dp[i + 1][1] += dp[i + 1 - diff][cnt]\n            dp[i + 1][1] %= MOD\n\n    # j - 1 -> j にする\n    for j in range(2, n + 1):\n        dp[i + 1][j] += dp[i + 1][j - 1] * j\n        dp[i + 1][j] %= MOD\n\nprint(dp[-1][-1] % MOD)"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n/// Verified by https://atcoder.jp/contests/arc093/submissions/3968098\nmod mod_int {\n    use std::ops::*;\n    pub trait Mod: Copy { fn m() -> i64; }\n    #[derive(Copy, Clone, Hash, PartialEq, Eq, PartialOrd, Ord)]\n    pub struct ModInt<M> { pub x: i64, phantom: ::std::marker::PhantomData<M> }\n    impl<M: Mod> ModInt<M> {\n        // x >= 0\n        pub fn new(x: i64) -> Self { ModInt::new_internal(x % M::m()) }\n        fn new_internal(x: i64) -> Self {\n            ModInt { x: x, phantom: ::std::marker::PhantomData }\n        }\n        pub fn pow(self, mut e: i64) -> Self {\n            debug_assert!(e >= 0);\n            let mut sum = ModInt::new_internal(1);\n            let mut cur = self;\n            while e > 0 {\n                if e % 2 != 0 { sum *= cur; }\n                cur *= cur;\n                e /= 2;\n            }\n            sum\n        }\n        #[allow(dead_code)]\n        pub fn inv(self) -> Self { self.pow(M::m() - 2) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Add<T> for ModInt<M> {\n        type Output = Self;\n        fn add(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x + other.x;\n            if sum >= M::m() { sum -= M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Sub<T> for ModInt<M> {\n        type Output = Self;\n        fn sub(self, other: T) -> Self {\n            let other = other.into();\n            let mut sum = self.x - other.x;\n            if sum < 0 { sum += M::m(); }\n            ModInt::new_internal(sum)\n        }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> Mul<T> for ModInt<M> {\n        type Output = Self;\n        fn mul(self, other: T) -> Self { ModInt::new(self.x * other.into().x % M::m()) }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> AddAssign<T> for ModInt<M> {\n        fn add_assign(&mut self, other: T) { *self = *self + other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> SubAssign<T> for ModInt<M> {\n        fn sub_assign(&mut self, other: T) { *self = *self - other; }\n    }\n    impl<M: Mod, T: Into<ModInt<M>>> MulAssign<T> for ModInt<M> {\n        fn mul_assign(&mut self, other: T) { *self = *self * other; }\n    }\n    impl<M: Mod> Neg for ModInt<M> {\n        type Output = Self;\n        fn neg(self) -> Self { ModInt::new(0) - self }\n    }\n    impl<M> ::std::fmt::Display for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            self.x.fmt(f)\n        }\n    }\n    impl<M: Mod> ::std::fmt::Debug for ModInt<M> {\n        fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n            let (mut a, mut b, _) = red(self.x, M::m());\n            if b < 0 {\n                a = -a;\n                b = -b;\n            }\n            write!(f, \"{}/{}\", a, b)\n        }\n    }\n    impl<M: Mod> From<i64> for ModInt<M> {\n        fn from(x: i64) -> Self { Self::new(x) }\n    }\n    // Finds the simplest fraction x/y congruent to r mod p.\n    // The return value (x, y, z) satisfies x = y * r + z * p.\n    fn red(r: i64, p: i64) -> (i64, i64, i64) {\n        if r.abs() <= 10000 {\n            return (r, 1, 0);\n        }\n        let mut nxt_r = p % r;\n        let mut q = p / r;\n        if 2 * nxt_r >= r {\n            nxt_r -= r;\n            q += 1;\n        }\n        if 2 * nxt_r <= -r {\n            nxt_r += r;\n            q -= 1;\n        }\n        let (x, z, y) = red(nxt_r, r);\n        (x, y - q * z, z)\n    }\n} // mod mod_int\n\nmacro_rules! define_mod {\n    ($struct_name: ident, $modulo: expr) => {\n        #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n        struct $struct_name {}\n        impl mod_int::Mod for $struct_name { fn m() -> i64 { $modulo } }\n    }\n}\nconst MOD: i64 = 1_000_000_007;\ndefine_mod!(P, MOD);\ntype ModInt = mod_int::ModInt<P>;\n\n// Depends on ModInt.rs\nfn fact_init(w: usize) -> (Vec<ModInt>, Vec<ModInt>) {\n    let mut fac = vec![ModInt::new(1); w];\n    let mut invfac = vec![0.into(); w];\n    for i in 1 .. w {\n        fac[i] = fac[i - 1] * i as i64;\n    }\n    invfac[w - 1] = fac[w - 1].inv();\n    for i in (0 .. w - 1).rev() {\n        invfac[i] = invfac[i + 1] * (i as i64 + 1);\n    }\n    (fac, invfac)\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input!(n: usize, h: usize, d: usize);\n    const W: usize = 3_000_000;\n    let (fac, invfac) = fact_init(W);\n    let mut dp = vec![ModInt::new(0); h + 1];\n    dp[0] += fac[n];\n    let mut acc = vec![ModInt::new(0); h + 2];\n    acc[0] += fac[n];\n    let mut facsum = ModInt::new(0);\n    for i in 1..n + 1 {\n        facsum += fac[i];\n    }\n    for i in 1..h + 1 {\n        if i <= d {\n            dp[i] += fac[n];\n        }\n        let lo = max(d + 1, i) - d;\n        let hi = i;\n        dp[i] += (acc[hi] - acc[lo]) * facsum;\n        acc[i + 1] = acc[i] + dp[i];\n    }\n    \n    puts!(\"{}\\n\", dp[h]);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "pub trait IterScan: Sized {\n    type Output;\n    fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output>;\n}\npub trait MarkedIterScan: Sized {\n    type Output;\n    fn mscan<'a, I: Iterator<Item = &'a str>>(self, iter: &mut I) -> Option<Self::Output>;\n}\n#[derive(Debug)]\npub struct Scanner<'a> {\n    iter: std::str::SplitAsciiWhitespace<'a>,\n}\nimpl<'a> Scanner<'a> {\n    #[inline]\n    pub fn new(s: &'a str) -> Self {\n        let iter = s.split_ascii_whitespace();\n        Self { iter }\n    }\n    #[inline]\n    pub fn scan<T: IterScan>(&mut self) -> <T as IterScan>::Output {\n        T::scan(&mut self.iter).unwrap()\n    }\n    #[inline]\n    pub fn mscan<T: MarkedIterScan>(&mut self, marker: T) -> <T as MarkedIterScan>::Output {\n        marker.mscan(&mut self.iter).unwrap()\n    }\n    #[inline]\n    pub fn scan_vec<T: IterScan>(&mut self, size: usize) -> Vec<<T as IterScan>::Output> {\n        (0..size)\n            .map(|_| T::scan(&mut self.iter).unwrap())\n            .collect()\n    }\n    #[inline]\n    pub fn scan_chars(&mut self) -> Vec<char> {\n        self.iter.next().unwrap().chars().collect::<Vec<char>>()\n    }\n}\nmod scanner_impls {\n    use super::*;\n    macro_rules !iter_scan_impls {($($t :ty ) *) =>{$(impl IterScan for $t {type Output =Self ;#[inline ] fn scan <'a ,I :Iterator <Item =&'a str >>(iter :&mut I ) ->Option <Self >{iter .next () ?.parse ::<$t >() .ok () } } ) *} ;}\n    iter_scan_impls !(char u8 u16 u32 u64 usize i8 i16 i32 i64 isize f32 f64 u128 i128 String ) ;\n    macro_rules !iter_scan_tuple_impl {($($T :ident ) *) =>{impl <$($T :IterScan ) ,*>IterScan for ($($T ,) *) {type Output =($(<$T as IterScan >::Output ,) *) ;#[inline ] fn scan <'a ,It :Iterator <Item =&'a str >>(_iter :&mut It ) ->Option <Self ::Output >{Some (($($T ::scan (_iter ) ?,) *) ) } } } ;}\n    iter_scan_tuple_impl!();\n    iter_scan_tuple_impl!(A);\n    iter_scan_tuple_impl !(A B ) ;\n    iter_scan_tuple_impl !(A B C ) ;\n    iter_scan_tuple_impl !(A B C D ) ;\n    iter_scan_tuple_impl !(A B C D E ) ;\n    iter_scan_tuple_impl !(A B C D E F ) ;\n    iter_scan_tuple_impl !(A B C D E F G ) ;\n    iter_scan_tuple_impl !(A B C D E F G H ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I J ) ;\n    iter_scan_tuple_impl !(A B C D E F G H I J K ) ;\n    pub struct ScannerIter<'a, 'b, T> {\n        inner: &'b mut Scanner<'a>,\n        _marker: std::marker::PhantomData<fn() -> T>,\n    }\n    impl<'a, 'b, T: IterScan> Iterator for ScannerIter<'a, 'b, T> {\n        type Item = <T as IterScan>::Output;\n        fn next(&mut self) -> Option<Self::Item> {\n            T::scan(&mut self.inner.iter)\n        }\n    }\n    impl<'a> Scanner<'a> {\n        #[inline]\n        pub fn iter<'b, T: IterScan>(&'b mut self) -> ScannerIter<'a, 'b, T> {\n            ScannerIter {\n                inner: self,\n                _marker: std::marker::PhantomData,\n            }\n        }\n    }\n}\nmod marker {\n    use super::*;\n    pub struct Usize1;\n    impl IterScan for Usize1 {\n        type Output = usize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            usize::scan(iter).map(|x| x.wrapping_sub(1))\n        }\n    }\n    pub struct Isize1;\n    impl IterScan for Isize1 {\n        type Output = isize;\n        #[inline]\n        fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n            isize::scan(iter).map(|x| x.wrapping_sub(1))\n        }\n    }\n}\n#[macro_export]\nmacro_rules !min {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::min ($e ,min !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmin {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::min ($dst ,min !($($src ) ,+) ) ;$dst =x ;} } ;}\n#[macro_export]\nmacro_rules !max {($e :expr ) =>{$e } ;($e :expr ,$($es :expr ) ,+) =>{std ::cmp ::max ($e ,max !($($es ) ,+) ) } ;}\n#[macro_export]\nmacro_rules !chmax {($dst :expr ,$($src :expr ) ,+) =>{{let x =std ::cmp ::max ($dst ,max !($($src ) ,+) ) ;$dst =x ;} } ;}\npub trait Modulus {\n    fn get_modulus() -> u32;\n    #[inline]\n    fn modulo(x: u32) -> u32 {\n        x % Self::get_modulus()\n    }\n}\n#[allow(unused_macros)]\nmacro_rules! make_modulus {\n    ($t :ident ,$e :expr ) => {\n        pub struct $t {}\n        impl Modulus for $t {\n            #[inline]\n            fn get_modulus() -> u32 {\n                const MODULUS: u32 = $e;\n                MODULUS\n            }\n        }\n    };\n}\n#[allow(unused_macros)]\nmacro_rules! make_dynamic_modulus {\n    ($t :ident ,$m :ident ,$e :expr ) => {\n        pub struct $t {}\n        static mut $m: u32 = $e;\n        impl Modulus for $t {\n            #[inline]\n            fn get_modulus() -> u32 {\n                unsafe { $m }\n            }\n        }\n    };\n}\npub mod modulus {\n    use super::*;\n    pub struct Modulo1000000007 {}\n    impl Modulus for Modulo1000000007 {\n        #[inline]\n        fn get_modulus() -> u32 {\n            const MODULUS: u32 = 1_000_000_007;\n            MODULUS\n        }\n    }\n    pub struct Modulo1000000009 {}\n    impl Modulus for Modulo1000000009 {\n        #[inline]\n        fn get_modulus() -> u32 {\n            const MODULUS: u32 = 1_000_000_009;\n            MODULUS\n        }\n    }\n    pub struct Modulo998244353 {}\n    impl Modulus for Modulo998244353 {\n        #[inline]\n        fn get_modulus() -> u32 {\n            const MODULUS: u32 = 998_244_353;\n            MODULUS\n        }\n    }\n    pub struct DynModulo {}\n    static mut DYN_MODULUS: u32 = 1_000_000_007;\n    impl Modulus for DynModulo {\n        #[inline]\n        fn get_modulus() -> u32 {\n            unsafe { DYN_MODULUS }\n        }\n    }\n    pub fn set_dyn_modulus(m: u32) {\n        unsafe {\n            DYN_MODULUS = m;\n        }\n    }\n}\npub struct MInt<M>\nwhere\n    M: Modulus,\n{\n    x: u32,\n    _marker: std::marker::PhantomData<fn() -> M>,\n}\nimpl<M: Modulus> MInt<M> {\n    #[inline]\n    pub fn new(x: u32) -> Self {\n        Self {\n            x: M::modulo(x),\n            _marker: std::marker::PhantomData,\n        }\n    }\n    #[inline]\n    pub fn new_unchecked(x: u32) -> Self {\n        Self {\n            x,\n            _marker: std::marker::PhantomData,\n        }\n    }\n    #[inline]\n    pub fn inner(self) -> u32 {\n        self.x\n    }\n    #[inline]\n    pub fn one() -> Self {\n        Self::new_unchecked(1)\n    }\n    #[inline]\n    pub fn zero() -> Self {\n        Self::new_unchecked(0)\n    }\n    #[inline]\n    pub fn get_mod() -> u32 {\n        M::get_modulus()\n    }\n    #[inline]\n    pub fn pow(mut self, mut y: usize) -> Self {\n        let mut x = Self::one();\n        while y > 0 {\n            if y & 1 == 1 {\n                x *= self;\n            }\n            self *= self;\n            y >>= 1;\n        }\n        x\n    }\n    #[inline]\n    /// only prime modulus\n    pub fn inv(self) -> Self {\n        let mut a = self.x;\n        let (mut b, mut u, mut s) = (M::get_modulus(), 1, 0);\n        let k = a.trailing_zeros();\n        a >>= k;\n        for _ in 0..k {\n            if u & 1 == 1 {\n                u += M::get_modulus();\n            }\n            u /= 2;\n        }\n        while a != b {\n            if b < a {\n                std::mem::swap(&mut a, &mut b);\n                std::mem::swap(&mut u, &mut s);\n            }\n            b -= a;\n            if s < u {\n                s += M::get_modulus();\n            }\n            s -= u;\n            let k = b.trailing_zeros();\n            b >>= k;\n            for _ in 0..k {\n                if s & 1 == 1 {\n                    s += M::get_modulus();\n                }\n                s /= 2;\n            }\n        }\n        Self::new_unchecked(s)\n    }\n}\nmod mint_impls {\n    use super::*;\n    use std::{\n        cmp::Ordering,\n        fmt::{self, Debug},\n        hash::{Hash, Hasher},\n        iter::{Product, Sum},\n        marker::PhantomData,\n        num::ParseIntError,\n        ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Neg, Sub, SubAssign},\n        str::FromStr,\n    };\n    impl<M: Modulus> Clone for MInt<M> {\n        #[inline]\n        fn clone(&self) -> Self {\n            Self {\n                x: Clone::clone(&self.x),\n                _marker: PhantomData,\n            }\n        }\n    }\n    impl<M: Modulus> Copy for MInt<M> {}\n    impl<M: Modulus> Debug for MInt<M> {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            Debug::fmt(&self.x, f)\n        }\n    }\n    impl<M: Modulus> Default for MInt<M> {\n        #[inline]\n        fn default() -> Self {\n            Self::zero()\n        }\n    }\n    impl<M: Modulus> PartialEq for MInt<M> {\n        #[inline]\n        fn eq(&self, other: &Self) -> bool {\n            PartialEq::eq(&self.x, &other.x)\n        }\n    }\n    impl<M: Modulus> PartialOrd for MInt<M> {\n        #[inline]\n        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n            PartialOrd::partial_cmp(&self.x, &other.x)\n        }\n    }\n    impl<M: Modulus> Eq for MInt<M> {}\n    impl<M: Modulus> Ord for MInt<M> {\n        #[inline]\n        fn cmp(&self, other: &Self) -> Ordering {\n            Ord::cmp(&self.x, &other.x)\n        }\n    }\n    impl<M: Modulus> Hash for MInt<M> {\n        #[inline]\n        fn hash<H: Hasher>(&self, state: &mut H) {\n            Hash::hash(&self.x, state)\n        }\n    }\n    impl<M: Modulus> From<u32> for MInt<M> {\n        #[inline]\n        fn from(x: u32) -> Self {\n            Self::new(x)\n        }\n    }\n    impl<M: Modulus> From<u64> for MInt<M> {\n        #[inline]\n        fn from(x: u64) -> Self {\n            Self::new_unchecked((x % M::get_modulus() as u64) as u32)\n        }\n    }\n    impl<M: Modulus> From<i32> for MInt<M> {\n        #[inline]\n        fn from(x: i32) -> Self {\n            let x = x % M::get_modulus() as i32;\n            if x < 0 {\n                Self::new_unchecked((x + M::get_modulus() as i32) as u32)\n            } else {\n                Self::new_unchecked(x as u32)\n            }\n        }\n    }\n    impl<M: Modulus> From<i64> for MInt<M> {\n        #[inline]\n        fn from(x: i64) -> Self {\n            let x = x % M::get_modulus() as i64;\n            if x < 0 {\n                Self::new_unchecked((x + M::get_modulus() as i64) as u32)\n            } else {\n                Self::new_unchecked(x as u32)\n            }\n        }\n    }\n    impl<M: Modulus> Add for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn add(self, rhs: Self) -> Self::Output {\n            let mut x = self.x + rhs.x;\n            if x >= M::get_modulus() {\n                x -= M::get_modulus();\n            }\n            Self::new_unchecked(x)\n        }\n    }\n    impl<M: Modulus> Sub for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn sub(self, rhs: Self) -> Self::Output {\n            if self.x < rhs.x {\n                Self::new_unchecked(self.x + M::get_modulus() - rhs.x)\n            } else {\n                Self::new_unchecked(self.x - rhs.x)\n            }\n        }\n    }\n    impl<M: Modulus> Mul for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn mul(self, rhs: Self) -> Self::Output {\n            Self::new_unchecked((self.x as u64 * rhs.x as u64 % M::get_modulus() as u64) as u32)\n        }\n    }\n    impl<M: Modulus> Div for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn div(self, rhs: Self) -> Self::Output {\n            self * rhs.inv()\n        }\n    }\n    impl<M: Modulus> Neg for MInt<M> {\n        type Output = Self;\n        #[inline]\n        fn neg(self) -> Self::Output {\n            if self.x == 0 {\n                Self::zero()\n            } else {\n                Self::new_unchecked(M::get_modulus() - self.x)\n            }\n        }\n    }\n    impl<M: Modulus> Sum for MInt<M> {\n        #[inline]\n        fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Self::zero(), Add::add)\n        }\n    }\n    impl<M: Modulus> Product for MInt<M> {\n        #[inline]\n        fn product<I: Iterator<Item = Self>>(iter: I) -> Self {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n    impl<'a, M: Modulus + 'a> Sum<&'a MInt<M>> for MInt<M> {\n        #[inline]\n        fn sum<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n            iter.fold(Self::zero(), Add::add)\n        }\n    }\n    impl<'a, M: Modulus + 'a> Product<&'a MInt<M>> for MInt<M> {\n        #[inline]\n        fn product<I: Iterator<Item = &'a Self>>(iter: I) -> Self {\n            iter.fold(Self::one(), Mul::mul)\n        }\n    }\n    impl<M: Modulus> fmt::Display for MInt<M> {\n        fn fmt<'a>(&self, f: &mut fmt::Formatter<'a>) -> Result<(), fmt::Error> {\n            write!(f, \"{}\", self.x)\n        }\n    }\n    impl<M: Modulus> FromStr for MInt<M> {\n        type Err = ParseIntError;\n        #[inline]\n        fn from_str(s: &str) -> Result<Self, Self::Err> {\n            s.parse::<u32>().map(Self::new)\n        }\n    }\n    macro_rules! mint_ref_binop {\n        ($imp :ident ,$method :ident ,$t :ty ) => {\n            impl<M: Modulus> $imp<$t> for &$t {\n                type Output = <$t as $imp<$t>>::Output;\n                #[inline]\n                fn $method(self, other: $t) -> <$t as $imp<$t>>::Output {\n                    $imp::$method(*self, other)\n                }\n            }\n            impl<M: Modulus> $imp<&$t> for $t {\n                type Output = <$t as $imp<$t>>::Output;\n                #[inline]\n                fn $method(self, other: &$t) -> <$t as $imp<$t>>::Output {\n                    $imp::$method(self, *other)\n                }\n            }\n            impl<M: Modulus> $imp<&$t> for &$t {\n                type Output = <$t as $imp<$t>>::Output;\n                #[inline]\n                fn $method(self, other: &$t) -> <$t as $imp<$t>>::Output {\n                    $imp::$method(*self, *other)\n                }\n            }\n        };\n    }\n    mint_ref_binop!(Add, add, MInt<M>);\n    mint_ref_binop!(Sub, sub, MInt<M>);\n    mint_ref_binop!(Mul, mul, MInt<M>);\n    mint_ref_binop!(Div, div, MInt<M>);\n    macro_rules! mint_ref_unop {\n        ($imp :ident ,$method :ident ,$t :ty ) => {\n            impl<M: Modulus> $imp for &$t {\n                type Output = <$t as $imp>::Output;\n                #[inline]\n                fn $method(self) -> <$t as $imp>::Output {\n                    $imp::$method(*self)\n                }\n            }\n        };\n    }\n    mint_ref_unop!(Neg, neg, MInt<M>);\n    macro_rules! mint_ref_op_assign {\n        ($imp :ident ,$method :ident ,$t :ty ,$fromimp :ident ,$frommethod :ident ) => {\n            impl<M: Modulus> $imp<$t> for $t {\n                #[inline]\n                fn $method(&mut self, rhs: $t) {\n                    *self = $fromimp::$frommethod(*self, rhs);\n                }\n            }\n            impl<M: Modulus> $imp<&$t> for $t {\n                #[inline]\n                fn $method(&mut self, other: &$t) {\n                    $imp::$method(self, *other);\n                }\n            }\n        };\n    }\n    mint_ref_op_assign!(AddAssign, add_assign, MInt<M>, Add, add);\n    mint_ref_op_assign!(SubAssign, sub_assign, MInt<M>, Sub, sub);\n    mint_ref_op_assign!(MulAssign, mul_assign, MInt<M>, Mul, mul);\n    mint_ref_op_assign!(DivAssign, div_assign, MInt<M>, Div, div);\n}\nimpl<M: Modulus> IterScan for MInt<M> {\n    type Output = Self;\n    #[inline]\n    fn scan<'a, I: Iterator<Item = &'a str>>(iter: &mut I) -> Option<Self::Output> {\n        iter.next()?.parse::<MInt<M>>().ok()\n    }\n}\ntype M = MInt<modulus::Modulo1000000007>;\n#[derive(Clone, Debug)]\npub struct MemorizedFactorial<M: Modulus> {\n    pub fact: Vec<MInt<M>>,\n    pub inv_fact: Vec<MInt<M>>,\n}\nimpl<M: Modulus> MemorizedFactorial<M> {\n    pub fn new(max_n: usize) -> Self {\n        let mut fact = vec![MInt::one(); max_n + 1];\n        let mut inv_fact = vec![MInt::one(); max_n + 1];\n        for i in 2..=max_n {\n            fact[i] = fact[i - 1] * MInt::new(i as u32);\n        }\n        inv_fact[max_n] = fact[max_n].inv();\n        for i in (3..=max_n).rev() {\n            inv_fact[i - 1] = inv_fact[i] * MInt::new(i as u32);\n        }\n        Self { fact, inv_fact }\n    }\n    #[inline]\n    pub fn combination(&self, n: usize, r: usize) -> MInt<M> {\n        debug_assert!(n < self.fact.len());\n        if r <= n {\n            self.fact[n] * self.inv_fact[r] * self.inv_fact[n - r]\n        } else {\n            MInt::zero()\n        }\n    }\n    #[inline]\n    pub fn permutation(&self, n: usize, r: usize) -> MInt<M> {\n        debug_assert!(n < self.fact.len());\n        if r <= n {\n            self.fact[n] * self.inv_fact[n - r]\n        } else {\n            MInt::zero()\n        }\n    }\n    #[inline]\n    pub fn homogeneous_product(&self, n: usize, r: usize) -> MInt<M> {\n        debug_assert!(n + r < self.fact.len() + 1);\n        if n != 0 && r != 0 {\n            self.combination(n + r - 1, r)\n        } else {\n            MInt::one()\n        }\n    }\n    #[inline]\n    pub fn inv(&self, n: usize) -> MInt<M> {\n        debug_assert!(n < self.fact.len());\n        debug_assert!(n > 0);\n        self.inv_fact[n] * self.fact[n - 1]\n    }\n}\nfn main() {\n    #[allow(unused_imports)]\n    use std::io::{Read as _, Write as _};\n    let __out = std::io::stdout();\n    let mut __in_buf = String::new();\n    std::io::stdin().read_to_string(&mut __in_buf).unwrap();\n    let mut __scanner = Scanner::new(&__in_buf);\n    #[allow(unused_macros)]\n    macro_rules !scan {() =>{scan !(usize ) } ;(($($t :tt ) ,*) ) =>{($(scan !($t ) ) ,*) } ;([$t :tt ;$len :expr ] ) =>{(0 ..$len ) .map (|_ |scan !($t ) ) .collect ::<Vec <_ >>() } ;({$t :tt =>$f :expr } ) =>{$f (scan !($t ) ) } ;(chars ) =>{__scanner .scan_chars () } ;($t :ty ) =>{__scanner .scan ::<$t >() } ;}\n    let mut __out = std::io::BufWriter::new(__out.lock());\n    #[allow(unused_macros)]\n    macro_rules !print {($($arg :tt ) *) =>(::std ::write !(__out ,$($arg ) *) .unwrap () ) }\n    #[allow(unused_macros)]\n    macro_rules !println {($($arg :tt ) *) =>(::std ::writeln !(__out ,$($arg ) *) .unwrap () ) }\n    #[allow(unused_macros)]\n    macro_rules! echo {\n        ($iter :expr ) => {\n            echo!($iter, \"\\n\")\n        };\n        ($iter :expr ,$sep :expr ) => {\n            let mut iter = $iter;\n            if let Some(item) = iter.next() {\n                print!(\"{}\", item);\n            }\n            for item in iter {\n                print!(\"{}{}\", $sep, item);\n            }\n            println!();\n        };\n    }\n    let n = scan!();\n    let h = scan!();\n    let d = scan!();\n    let f = MemorizedFactorial::new(n);\n    let mut dp = vec![M::zero(); h];\n    dp[0] = f.fact[n];\n    let c = f.fact[1..=n].iter().sum::<M>();\n    let mut sum = vec![M::zero(); h + 1];\n    sum[1] = dp[0];\n    for i in 1..h {\n        dp[i] = (sum[i] - sum[i.saturating_sub(d)]) * c;\n        sum[i + 1] = sum[i] + dp[i];\n    }\n    println!(\"{}\", sum[h] - sum[h - d]);\n}"
  },
  {
    "language": "Rust",
    "code": "// input\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, bytes) => {\n        read_value!($next, String).into_bytes()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nmod mint {\n    use std::fmt;\n    use std::ops::{\n        Add, AddAssign, BitXor, BitXorAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign,\n    };\n\n    pub const MOD: i32 = 1_000_000_007;\n    pub const ZERO: Mint = Mint { val: 0 };\n    pub const ONE: Mint = Mint { val: 1 };\n    pub const TWO: Mint = Mint { val: 2 };\n\n    #[derive(Clone, Copy, Debug)]\n    pub struct Mint {\n        val: i32,\n    }\n\n    impl Add for Mint {\n        type Output = Self;\n        fn add(self, other: Self) -> Self {\n            let mut v = self;\n            v += other;\n            v\n        }\n    }\n\n    impl AddAssign for Mint {\n        fn add_assign(&mut self, other: Self) {\n            self.val += other.val;\n            if self.val >= MOD {\n                self.val -= MOD;\n            }\n        }\n    }\n\n    impl Sub for Mint {\n        type Output = Self;\n        fn sub(self, other: Self) -> Self {\n            let mut v = self;\n            v -= other;\n            v\n        }\n    }\n\n    impl SubAssign for Mint {\n        fn sub_assign(&mut self, other: Self) {\n            self.val -= other.val;\n            if self.val < 0 {\n                self.val += MOD;\n            }\n        }\n    }\n\n    impl Mul for Mint {\n        type Output = Self;\n        fn mul(self, other: Self) -> Self {\n            let mut v = self;\n            v *= other;\n            v\n        }\n    }\n\n    impl MulAssign for Mint {\n        fn mul_assign(&mut self, other: Self) {\n            self.val = ((self.val as i64) * (other.val as i64) % (MOD as i64)) as i32;\n        }\n    }\n\n    impl Div for Mint {\n        type Output = Self;\n        fn div(self, other: Self) -> Self {\n            let mut v = self;\n            v /= other;\n            v\n        }\n    }\n\n    impl DivAssign for Mint {\n        fn div_assign(&mut self, other: Self) {\n            *self *= other ^ Mint::from(MOD - 2);\n        }\n    }\n\n    impl BitXor for Mint {\n        type Output = Self;\n        fn bitxor(mut self, other: Self) -> Self {\n            self ^= other;\n            self\n        }\n    }\n\n    impl BitXorAssign for Mint {\n        fn bitxor_assign(&mut self, mut other: Self) {\n            let mut x = *self;\n            *self = 1.into();\n            while other.val != 0 {\n                if (other.val & 1) == 1 {\n                    *self *= x;\n                }\n                x *= x;\n                other.val >>= 1;\n            }\n        }\n    }\n\n    // i32\n    impl Add<i32> for Mint {\n        type Output = Self;\n        fn add(self, other: i32) -> Self {\n            self + Mint::from(other)\n        }\n    }\n\n    impl AddAssign<i32> for Mint {\n        fn add_assign(&mut self, other: i32) {\n            *self += Mint::from(other);\n        }\n    }\n\n    impl Sub<i32> for Mint {\n        type Output = Self;\n        fn sub(self, other: i32) -> Self {\n            self - Mint::from(other)\n        }\n    }\n\n    impl SubAssign<i32> for Mint {\n        fn sub_assign(&mut self, other: i32) {\n            *self -= Mint::from(other);\n        }\n    }\n\n    impl Mul<i32> for Mint {\n        type Output = Self;\n        fn mul(self, other: i32) -> Self {\n            self * Mint::from(other)\n        }\n    }\n\n    impl MulAssign<i32> for Mint {\n        fn mul_assign(&mut self, other: i32) {\n            *self *= Mint::from(other);\n        }\n    }\n\n    impl Div<i32> for Mint {\n        type Output = Self;\n        fn div(self, other: i32) -> Self {\n            self / Mint::from(other)\n        }\n    }\n\n    impl DivAssign<i32> for Mint {\n        fn div_assign(&mut self, other: i32) {\n            *self /= Mint::from(other);\n        }\n    }\n\n    impl BitXor<i32> for Mint {\n        type Output = Self;\n        fn bitxor(self, other: i32) -> Self {\n            self ^ Mint::from(other)\n        }\n    }\n\n    impl BitXorAssign<i32> for Mint {\n        fn bitxor_assign(&mut self, other: i32) {\n            *self ^= Mint::from(other);\n        }\n    }\n\n    impl From<i32> for Mint {\n        fn from(mut item: i32) -> Self {\n            while item >= MOD {\n                item -= MOD\n            }\n            while item < 0 {\n                item += MOD\n            }\n            Mint { val: item }\n        }\n    }\n\n    // usize\n    impl Add<usize> for Mint {\n        type Output = Self;\n        fn add(self, other: usize) -> Self {\n            self + Mint::from(other)\n        }\n    }\n\n    impl AddAssign<usize> for Mint {\n        fn add_assign(&mut self, other: usize) {\n            *self += Mint::from(other);\n        }\n    }\n\n    impl Sub<usize> for Mint {\n        type Output = Self;\n        fn sub(self, other: usize) -> Self {\n            self - Mint::from(other)\n        }\n    }\n\n    impl SubAssign<usize> for Mint {\n        fn sub_assign(&mut self, other: usize) {\n            *self -= Mint::from(other);\n        }\n    }\n\n    impl Mul<usize> for Mint {\n        type Output = Self;\n        fn mul(self, other: usize) -> Self {\n            self * Mint::from(other)\n        }\n    }\n\n    impl MulAssign<usize> for Mint {\n        fn mul_assign(&mut self, other: usize) {\n            *self *= Mint::from(other);\n        }\n    }\n\n    impl Div<usize> for Mint {\n        type Output = Self;\n        fn div(self, other: usize) -> Self {\n            self / Mint::from(other)\n        }\n    }\n\n    impl DivAssign<usize> for Mint {\n        fn div_assign(&mut self, other: usize) {\n            *self /= Mint::from(other);\n        }\n    }\n\n    impl BitXor<usize> for Mint {\n        type Output = Self;\n        fn bitxor(self, other: usize) -> Self {\n            self ^ Mint::from(other)\n        }\n    }\n\n    impl BitXorAssign<usize> for Mint {\n        fn bitxor_assign(&mut self, other: usize) {\n            *self ^= Mint::from(other);\n        }\n    }\n\n    impl From<usize> for Mint {\n        fn from(item: usize) -> Self {\n            Mint::from((item % (MOD as usize)) as i32)\n        }\n    }\n\n    impl fmt::Display for Mint {\n        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n            write!(f, \"{}\", self.val)\n        }\n    }\n}\n\nfn main() {\n    input! {\n        n: usize,\n        h: usize,\n        d: usize,\n    }\n\n    let mut f = vec![mint::ONE; n + 1];\n    let mut sumf = vec![mint::ZERO; n + 1];\n    for i in 0..n {\n        f[i + 1] = f[i] * mint::Mint::from(i + 1);\n    }\n    for i in 0..n {\n        sumf[i + 1] = sumf[i] + f[i + 1];\n    }\n\n    let mut dp = vec![mint::ZERO; h + 2];\n    dp[1] += mint::ONE;\n    dp[d + 1] -= mint::ONE;\n    for i in 1..h {\n        let l = i + 1;\n        let u = std::cmp::min(h, i + d) + 1;\n\n        let v = dp[i];\n        dp[l] += v * sumf[n] + v;\n        dp[u] -= v * sumf[n];\n    }\n    // eprintln!(\"{:?}\", f);\n    // eprintln!(\"{:?}\", sumf);\n    // eprintln!(\"{:?}\", dp);\n    println!(\"{}\", dp[h] * f[n]);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// See run() at line 135 for solution.\n#![allow(unused_imports, unused_macros, non_snake_case)]\nuse std::cmp::{max, min, Ordering};\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n\n//{{{ ---- macros ----\n#[macro_use]\nmod macros {\n    // {{{ input!\n    // https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\n    macro_rules! input {\n        (source = $s:expr, $($r:tt)*) => {\n            let mut iter = $s.split_whitespace();\n            let mut next = || { iter.next().unwrap() };\n            input_inner!{next, $($r)*}\n        };\n        ($($r:tt)*) => {\n            let stdin = std::io::stdin();\n            let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n            let mut next = move || -> String{\n                bytes\n                    .by_ref()\n                    .map(|r|r.unwrap() as char)\n                    .skip_while(|c|c.is_whitespace())\n                    .take_while(|c|!c.is_whitespace())\n                    .collect()\n            };\n            input_inner!{next, $($r)*}\n        };\n    }\n    macro_rules! input_inner {\n        ($next:expr) => {};\n        ($next:expr, ) => {};\n\n        ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n            let $var = read_value!($next, $t);\n            input_inner!{$next $($r)*}\n        };\n    }\n    macro_rules! read_value {\n        ($next:expr, ( $($t:tt),* )) => {\n            ( $(read_value!($next, $t)),* )\n        };\n\n        ($next:expr, [ $t:tt ; $len:expr ]) => {\n            (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        };\n\n        ($next:expr, chars) => {\n            read_value!($next, String).chars().collect::<Vec<char>>()\n        };\n\n        ($next:expr, usize1) => {\n            read_value!($next, usize) - 1\n        };\n\n        ($next:expr, $t:ty) => {\n            $next().parse::<$t>().expect(\"Parse error\")\n        };\n    }\n    //}}}\n\n    //{{{ read!\n    macro_rules! read {\n        ($($t:tt),*; $n:expr) => {{\n            let stdin = ::std::io::stdin();\n            let ret = ::std::io::BufRead::lines(stdin.lock()).take($n).map(|line| {\n                let line = line.unwrap();\n                let mut it = line.split_whitespace();\n                _read!(it; $($t),*)\n            }).collect::<Vec<_>>();\n            ret\n        }};\n        ($($t:tt),*) => {{\n            let line = readln();\n            let mut it = line.split_whitespace();\n            _read!(it; $($t),*)\n        }};\n    }\n\n    macro_rules! _read {\n        ($it:ident; [char]) => {\n            _read!($it; String).chars().collect::<Vec<_>>()\n        };\n        ($it:ident; [u8]) => {\n            Vec::from(_read!($it; String).into_bytes())\n        };\n        ($it:ident; [$t:ty]) => {\n            $it.map(|s| s.parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))).collect::<Vec<_>>()\n        };\n        ($it:ident; $t:ty) => {\n            $it.next().unwrap_or_else(|| panic!(\"input mismatch\")).parse::<$t>().unwrap_or_else(|e| panic!(\"{}\", e))\n        };\n        ($it:ident; $($t:ty),+) => {\n            ($(_read!($it; $t)),*)\n        };\n    }\n    //}}}\n\n    //{{{ utility macros missing in 1.15.1\n    // https://atcoder.jp/contests/nikkei2019-qual/submissions/4098548\n    macro_rules! eprint {\n        ($($t:tt)*) => {{\n            use ::std::io::Write;\n            let _ = write!(::std::io::stderr(), $($t)*);\n        }};\n    }\n    macro_rules! eprintln {\n        () => { eprintln!(\"\"); };\n        ($($t:tt)*) => {{\n            use ::std::io::Write;\n            let _ = writeln!(::std::io::stderr(), $($t)*);\n        }};\n    }\n    macro_rules! dbg {\n        ($val:expr) => {\n            match $val {\n                tmp => {\n                    eprintln!(\n                        \"[{}:{}] {} = {:#?}\",\n                        file!(),\n                        line!(),\n                        stringify!($val),\n                        &tmp\n                    );\n                    tmp\n                }\n            }\n        };\n    }\n    //}}}\n}\n//}}}\n\nuse algonium::math::Comb;\n\nuse algonium::math::Mint107;\nuse algonium::math::Mod107;\nfn run() {\n    input! {\n        n: usize,\n        h: usize,\n        d: usize,\n    }\n    let mut dp = vec![Mint107::from(0); h + 1];\n    let mut sum = vec![Mint107::from(0); h + 2];\n\n    let mut ways = Mint107::from(0);\n    let mut fact = Mint107::from(1);\n    for i in 1..n + 1 {\n        fact *= i;\n        ways += fact;\n    }\n\n    dp[0] = fact;\n    sum[1] = sum[0] + dp[0];\n\n    for i in 1..h + 1 {\n        let lower = if i >= d { i - d } else { 0 };\n        let base = sum[i] - sum[lower];\n        let ways = if i != h { ways } else { 1.into() };\n        dp[i] = base * ways;\n        sum[i + 1] = sum[i] + dp[i];\n    }\n\n    println!(\"{}\", dp[h]);\n}\n\n//{{{ ---- template ----\nfn main() {\n    let _ = ::std::thread::Builder::new()\n        .name(\"run\".to_string())\n        .stack_size(256 * 1024 * 1024)\n        .spawn(run)\n        .unwrap()\n        .join()\n        .unwrap();\n}\n\npub trait SetMinMax {\n    fn set_min(&mut self, v: Self) -> bool;\n    fn set_max(&mut self, v: Self) -> bool;\n}\n\nimpl<T> SetMinMax for T\nwhere\n    T: PartialOrd,\n{\n    fn set_min(&mut self, v: T) -> bool {\n        *self > v && {\n            *self = v;\n            true\n        }\n    }\n    fn set_max(&mut self, v: T) -> bool {\n        *self < v && {\n            *self = v;\n            true\n        }\n    }\n}\n\n#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, Hash)]\npub struct Reverse<T>(pub T);\n\nimpl<T: PartialOrd> PartialOrd for Reverse<T> {\n    #[inline]\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n\n    #[inline]\n    fn lt(&self, other: &Self) -> bool {\n        other.0 < self.0\n    }\n    #[inline]\n    fn le(&self, other: &Self) -> bool {\n        other.0 <= self.0\n    }\n    #[inline]\n    fn ge(&self, other: &Self) -> bool {\n        other.0 >= self.0\n    }\n    #[inline]\n    fn gt(&self, other: &Self) -> bool {\n        other.0 > self.0\n    }\n}\n\nimpl<T: Ord> Ord for Reverse<T> {\n    #[inline]\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\n\n#[allow(unused)] // This is defined for read! macro\nfn readln() -> String {\n    let mut line = String::new();\n    ::std::io::stdin()\n        .read_line(&mut line)\n        .unwrap_or_else(|e| panic!(\"{}\", e));\n    line\n}\n//}}}\n\n//{{{ https://github.com/ichyo/rust-algorithms.git\npub mod algonium {\n    #![doc = \" This library provides a collection of classic algorithms,\"]\n    #![doc = \" focusing on programming contests such as codeforces and atcoder.\"]\n    pub mod data_structure {\n        mod bit {\n            #[doc = \" Binary Indexed Tree (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure supports these two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[at]\"]\n            #[doc = \" 2. the sum of v[begin], v[begin+1], .., v[end-1]\"]\n            pub struct BIT {\n                tree: Vec<i64>,\n            }\n            #[doc = \" Binary Indexed Tree (range-version) (0-indexed)\"]\n            #[doc = \"\"]\n            #[doc = \" This data structure two queries in O(log n)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. add w to v[begin], v[begin+1], ..., v[end-1]\"]\n            #[doc = \" 2. get the sum of v[begin], v[begin+1], ..., v[end-1]\"]\n            pub struct BITRange {\n                bit0: BIT,\n                bit1: BIT,\n            }\n            impl BIT {\n                #[doc = \" Constructs a new BIT of length `len`.\"]\n                #[doc = \" All values are initialized zero.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" # #[warn(unused_mut)]\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" ```\"]\n                pub fn new(len: usize) -> BIT {\n                    BIT { tree: vec![0; len] }\n                }\n                #[doc = \" Returns the number of elements in the BIT.\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(100);\"]\n                #[doc = \" assert_eq!(bit.len(), 100);\"]\n                #[doc = \" ```\"]\n                pub fn len(&self) -> usize {\n                    self.tree.len()\n                }\n                #[doc = \" Add a value `value` to a element of index `index`.\"]\n                #[doc = \" v[index] += value\"]\n                #[doc = \"\"]\n                #[doc = \" # Panics\"]\n                #[doc = \"\"]\n                #[doc = \" Panics if `index > len`\"]\n                #[doc = \"\"]\n                #[doc = \" # Examples\"]\n                #[doc = \"\"]\n                #[doc = \" ```\"]\n                #[doc = \" use algonium::data_structure::BIT;\"]\n                #[doc = \" let mut bit = BIT::new(10);\"]\n                #[doc = \" bit.add(5, 100);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 100);\"]\n                #[doc = \" bit.add(5, 10);\"]\n                #[doc = \" assert_eq!(bit.get(3, 6), 110);\"]\n                #[doc = \" ```\"]\n                pub fn add(&mut self, index: usize, value: i64) {\n                    assert!(index < self.tree.len());\n                    let mut idx = index;\n                    while idx < self.tree.len() {\n                        self.tree[idx] += value;\n                        idx |= idx + 1;\n                    }\n                }\n                #[doc = \" sum of v[idx] such that begin <= idx < end\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    let a = if end > 0 { self.cum(end - 1) } else { 0 };\n                    let b = if begin > 0 { self.cum(begin - 1) } else { 0 };\n                    a - b\n                }\n                #[doc = \" v[0] + ... + v[last]\"]\n                fn cum(&self, last: usize) -> i64 {\n                    assert!(last < self.tree.len());\n                    let mut res = 0;\n                    let mut idx = last as i64;\n                    while idx >= 0 {\n                        res += self.tree[idx as usize];\n                        idx = (idx & (idx + 1)) - 1;\n                    }\n                    res\n                }\n            }\n            impl BITRange {\n                pub fn new(n: usize) -> BITRange {\n                    BITRange {\n                        bit0: BIT::new(n + 1),\n                        bit1: BIT::new(n + 1),\n                    }\n                }\n                #[doc = \" v[begin], v[begin+1], ..., v[end-1] += by\"]\n                pub fn add(&mut self, begin: usize, end: usize, by: i64) {\n                    if begin >= end {\n                        return;\n                    }\n                    let a = begin as i64;\n                    let b = end as i64;\n                    self.bit0.add(begin, -by * a);\n                    self.bit0.add(end, by * b);\n                    self.bit1.add(begin, by);\n                    self.bit1.add(end, -by);\n                }\n                #[doc = \" v[begin] + ... + v[end-1]\"]\n                pub fn get(&self, begin: usize, end: usize) -> i64 {\n                    if begin >= end {\n                        return 0;\n                    }\n                    self.cum(end) - self.cum(begin)\n                }\n                #[doc = \" v[0] + ... + v[end-1]\"]\n                fn cum(&self, end: usize) -> i64 {\n                    let a = self.bit0.get(0, end);\n                    let b = self.bit1.get(0, end);\n                    a + b * end as i64\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_add() {\n                    let mut bit = BIT::new(10);\n                    bit.add(100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_range_add() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(5, 100, 1);\n                }\n                #[test]\n                #[should_panic]\n                fn test_out_of_bound_get() {\n                    let bit = BIT::new(10);\n                    bit.get(0, 1000);\n                }\n                #[test]\n                fn test_empty_range() {\n                    let mut bit = BITRange::new(10);\n                    bit.add(9, 0, 100);\n                    bit.add(7, 3, 100);\n                    assert_eq!(0, bit.get(0, 9));\n                    assert_eq!(0, bit.get(0, 5));\n                    assert_eq!(0, bit.get(2, 5));\n                }\n                #[test]\n                fn test_simple() {\n                    let mut bit = BIT::new(10);\n                    bit.add(2, 1);\n                    bit.add(3, 3);\n                    bit.add(5, 10);\n                    bit.add(0, -4);\n                    bit.add(9, -5);\n                    assert_eq!(5, bit.get(0, 10));\n                    assert_eq!(4, bit.get(2, 4));\n                    assert_eq!(1, bit.get(2, 3));\n                    assert_eq!(0, bit.get(2, 2));\n                    assert_eq!(0, bit.get(2, 0));\n                    assert_eq!(-4, bit.get(0, 1));\n                    assert_eq!(5, bit.get(5, 10));\n                    let mut bit = BITRange::new(10);\n                    bit.add(1, 3, 1);\n                    bit.add(2, 5, 2);\n                    assert_eq!(1, bit.get(1, 2));\n                    assert_eq!(4, bit.get(1, 3));\n                    assert_eq!(6, bit.get(1, 4));\n                    assert_eq!(6, bit.get(0, 4));\n                }\n            }\n        }\n        mod segment_tree {\n            use std::cmp;\n            use std::marker::PhantomData;\n            pub trait Monoid<T> {\n                fn id() -> Option<T> {\n                    None\n                }\n                fn op(l: &Option<T>, r: &Option<T>) -> Option<T>;\n            }\n            pub struct MinOp<T: Ord> {\n                phantom: PhantomData<T>,\n            }\n            impl<T: Ord + Clone> Monoid<T> for MinOp<T> {\n                #[inline]\n                fn op(l: &Option<T>, r: &Option<T>) -> Option<T> {\n                    match (l.clone(), r.clone()) {\n                        (Some(l), Some(r)) => Some(cmp::min(l, r)),\n                        (Some(l), None) => Some(l),\n                        (None, Some(r)) => Some(r),\n                        (None, None) => None,\n                    }\n                }\n            }\n            pub struct SegmentTree<M: Monoid<T>, T: Clone> {\n                phantom: PhantomData<M>,\n                data: Vec<Option<T>>,\n                size: usize,\n                size_p2: usize,\n            }\n            impl<M: Monoid<T>, T: Clone> SegmentTree<M, T> {\n                pub fn from_vec(v: Vec<T>) -> SegmentTree<M, T> {\n                    let size = v.len();\n                    let mut size_p2 = 1;\n                    while size_p2 < v.len() {\n                        size_p2 *= 2;\n                    }\n                    let mut data = vec![None; size_p2 * 2];\n                    for (i, x) in v.into_iter().enumerate() {\n                        data[size_p2 + i] = Some(x);\n                    }\n                    for i in (0..size_p2).rev() {\n                        data[i] = M::op(&data[i * 2 + 0], &data[i * 2 + 1]);\n                    }\n                    SegmentTree {\n                        phantom: PhantomData,\n                        data: data,\n                        size: size,\n                        size_p2: size_p2,\n                    }\n                }\n                pub fn size(&self) -> usize {\n                    self.size\n                }\n                pub fn update(&mut self, mut pos: usize, value: T) {\n                    assert!(pos < self.size);\n                    pos += self.size_p2;\n                    self.data[pos] = Some(value);\n                    loop {\n                        pos /= 2;\n                        if pos == 0 {\n                            break;\n                        }\n                        self.data[pos] = M::op(&self.data[pos * 2], &self.data[pos * 2 + 1]);\n                    }\n                }\n                pub fn query(&self, mut l: usize, mut r: usize) -> Option<T> {\n                    assert!(l <= r && r <= self.size);\n                    l += self.size_p2;\n                    r += self.size_p2;\n                    let mut res1 = M::id();\n                    let mut res2 = M::id();\n                    while l < r {\n                        if (l & 1) != 0 {\n                            res1 = M::op(&res1, &self.data[l]);\n                            l += 1;\n                        }\n                        if (r & 1) != 0 {\n                            r -= 1;\n                            res2 = M::op(&self.data[r], &res2);\n                        }\n                        l >>= 1;\n                        r >>= 1;\n                    }\n                    M::op(&res1, &res2)\n                }\n            }\n            #[doc = \" segment tree to get minimum value in a range\"]\n            pub type RMQ<T> = SegmentTree<MinOp<T>, T>;\n            #[cfg(test)]\n            mod tests {\n                use super::RMQ;\n                #[test]\n                fn test_rms() {\n                    let mut test = vec![1, 5, 4, 8, 6, 9, 2, 0, 8, 1];\n                    let mut rms = RMQ::from_vec(test.clone());\n                    for i in 0..test.len() {\n                        for j in i..test.len() + 1 {\n                            assert_eq!(test[i..j].iter().cloned().min(), rms.query(i, j));\n                        }\n                    }\n                    rms.update(7, 5);\n                    test[7] = 5;\n                    for i in 0..test.len() {\n                        for j in i..test.len() + 1 {\n                            assert_eq!(test[i..j].iter().cloned().min(), rms.query(i, j));\n                        }\n                    }\n                }\n            }\n        }\n        mod union_find {\n            #[doc = \" Disjoint-set data structure\"]\n            #[doc = \"\"]\n            #[doc = \" This provides operations for disjoint sets.\"]\n            #[doc = \" They runs in nearly constatant time.\"]\n            #[doc = \" (the actual time is `O(A(n))` where `A(n)` is the inverse of ackermann function.)\"]\n            #[doc = \"\"]\n            #[doc = \" 1. unite(x, y) - unite a set including x and another set including y into one.\"]\n            #[doc = \" 2. same(x, y) - determine if x and y are in the same set.\"]\n            #[doc = \" 3. size(x) - calculate the number of elements of the set including x.\"]\n            #[doc = \"\"]\n            #[doc = \" [`UnionFind::new(n)`](#method.new) creates n disjoint sets. `i`-th set contains single element `i` (0-indexed).\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::data_structure::UnionFind;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut uf = UnionFind::new(4);\"]\n            #[doc = \" assert!(!uf.same(0, 1));\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(0, 1);\"]\n            #[doc = \" assert!(uf.same(0, 1));\"]\n            #[doc = \" assert_eq!(uf.size(0), 2);\"]\n            #[doc = \"\"]\n            #[doc = \" uf.unite(1, 2);\"]\n            #[doc = \" assert!(uf.same(0, 2));\"]\n            #[doc = \" assert_eq!(uf.size(0), 3);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            #[doc = \" # Panics\"]\n            #[doc = \" panics if `x` or `y` is not less than number of elements given in the initialization method.\"]\n            #[doc = \"\"]\n            pub struct UnionFind {\n                data: Vec<i32>,\n            }\n            impl UnionFind {\n                #[doc = \" Creates a object with n disjoint sets. `i`-th set is `{ i }`.\"]\n                pub fn new(n: usize) -> UnionFind {\n                    UnionFind { data: vec![-1; n] }\n                }\n                #[doc = \" Unite a set including `x` and another set including y into one.\"]\n                #[doc = \" Returns `true` only if they were in different set.\"]\n                pub fn unite(&mut self, x: usize, y: usize) -> bool {\n                    let x = self.root(x);\n                    let y = self.root(y);\n                    if x != y {\n                        let (x, y) = if self.data[x] <= self.data[y] {\n                            (x, y)\n                        } else {\n                            (y, x)\n                        };\n                        self.data[x] += self.data[y];\n                        self.data[y] = x as i32;\n                    }\n                    x != y\n                }\n                #[doc = \" Returns `true` only if `x` and `y` are in a same set.\"]\n                pub fn same(&mut self, x: usize, y: usize) -> bool {\n                    self.root(x) == self.root(y)\n                }\n                #[doc = \" Returns the number of elements of a set including `x`.\"]\n                pub fn size(&mut self, x: usize) -> u32 {\n                    let r = self.root(x);\n                    (-self.data[r]) as u32\n                }\n                #[doc = \" internal method to return representative element of a set including `x`.\"]\n                pub fn root(&mut self, x: usize) -> usize {\n                    if self.data[x] < 0 {\n                        x\n                    } else {\n                        let nx = self.data[x] as usize;\n                        let r = self.root(nx);\n                        self.data[x] = r as i32;\n                        r\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut uf = UnionFind::new(3);\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(1, uf.size(1));\n                    assert_eq!(1, uf.size(2));\n                    assert_eq!(0, uf.root(0));\n                    assert_eq!(1, uf.root(1));\n                    assert_eq!(2, uf.root(2));\n                    assert!(!uf.same(1, 2));\n                    uf.unite(1, 2);\n                    assert_ne!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(1, uf.size(0));\n                    assert_eq!(2, uf.size(1));\n                    assert_eq!(2, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    uf.unite(0, 1);\n                    assert_eq!(uf.root(0), uf.root(2));\n                    assert_eq!(uf.root(1), uf.root(2));\n                    assert_eq!(3, uf.size(0));\n                    assert_eq!(3, uf.size(1));\n                    assert_eq!(3, uf.size(2));\n                    assert!(uf.same(1, 2));\n                    assert!(uf.same(0, 2));\n                }\n            }\n        }\n        pub use self::bit::{BITRange, BIT};\n        pub use self::segment_tree::{MinOp, Monoid, SegmentTree, RMQ};\n        pub use self::union_find::UnionFind;\n    }\n    pub mod math {\n        mod comb {\n            use super::mint::{Mint, Module};\n            #[doc = \" Useful struct to compute combinations\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Comb, Mod107, Mint107};\"]\n            #[doc = \" let comb: Comb<Mod107> = Comb::new(100);\"]\n            #[doc = \" assert_eq!(Mint107::from(24), comb.fact(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(1), comb.fact(4) * comb.factinv(4));\"]\n            #[doc = \" assert_eq!(Mint107::from(12), comb.perm(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(6), comb.comb(4, 2));\"]\n            #[doc = \" assert_eq!(Mint107::from(10), comb.multi_comb(4, 2));\"]\n            #[doc = \" ```\"]\n            pub struct Comb<M: Module> {\n                fact: Vec<Mint<M>>,\n                factinv: Vec<Mint<M>>,\n            }\n            impl<M: Module> Comb<M> {\n                #[doc = \" Create a object that provides effiecint computation of combinations\"]\n                #[doc = \" for input smaller than `n`.\"]\n                #[doc = \"\"]\n                #[doc = \" This requires `O(n)` time.\"]\n                pub fn new(n: usize) -> Comb<M> {\n                    let mut fact: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    let mut factinv: Vec<Mint<M>> = vec![0.into(); n + 1];\n                    fact[0] = 1.into();\n                    for i in 0..n {\n                        fact[i + 1] = fact[i] * (i + 1);\n                    }\n                    factinv[n] = fact[n].inv();\n                    for i in (0..n).rev() {\n                        factinv[i] = factinv[i + 1] * (i + 1);\n                    }\n                    Comb {\n                        fact: fact,\n                        factinv: factinv,\n                    }\n                }\n                #[doc = \" `n! = 1 * 2 * ... * n`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn fact(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.fact.get(n as usize) {\n                        *x\n                    } else if n >= M::module() as u64 {\n                        Mint::from(0)\n                    } else {\n                        let mut res = 1.into();\n                        for a in 1..(n + 1) {\n                            res *= a;\n                        }\n                        res\n                    }\n                }\n                #[doc = \" returns `y` such that `n! * y == 1`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n is smaller than input in `new` method.\"]\n                pub fn factinv(&self, n: u64) -> Mint<M> {\n                    if let Some(x) = self.factinv.get(n as usize) {\n                        *x\n                    } else {\n                        self.fact(n).inv()\n                    }\n                }\n                #[doc = \" `nPr = n! / (n - r)!`\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn perm(&self, n: u64, r: u64) -> Mint<M> {\n                    if n >= r {\n                        self.fact(n) * self.factinv((n - r) as u64)\n                    } else {\n                        0.into()\n                    }\n                }\n                #[doc = \" `nCr = n! / (n - r)! / r!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn comb(&self, n: u64, r: u64) -> Mint<M> {\n                    let m = M::module() as u64;\n                    if n >= m {\n                        self.comb(n % m, r % m) * self.comb(n / m, r / m)\n                    } else if n >= r {\n                        self.fact(n) * self.factinv(n - r) * self.factinv(r)\n                    } else {\n                        Mint::from(0)\n                    }\n                }\n                #[doc = \" `(n + k - 1)! / k!`.\"]\n                #[doc = \"\"]\n                #[doc = \" `O(1)` if n and r are smaller than input in `new` method.\"]\n                pub fn multi_comb(&self, n: u64, r: u64) -> Mint<M> {\n                    if r == 0 {\n                        Mint::from(1)\n                    } else {\n                        self.comb(n + r - 1, r)\n                    }\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    assert_eq!(Mint::from(336), c.perm(8, 3));\n                    assert_eq!(Mint::from(56), c.comb(8, 3));\n                    assert_eq!(Mint::from(10), c.multi_comb(3, 3));\n                }\n                #[test]\n                fn test_fact() {\n                    #[derive(Clone, Copy, Debug)]\n                    struct Mod;\n                    impl Module for Mod {\n                        fn module() -> u32 {\n                            1000000007\n                        }\n                    }\n                    let c = Comb::<Mod>::new(100);\n                    let p = 8721234;\n                    let mut f = Mint::from(1);\n                    for i in 1..(p + 1) {\n                        f *= i;\n                    }\n                    assert_eq!(f, c.fact(p));\n                }\n            }\n        }\n        mod mint {\n            use std::fmt;\n            use std::marker::PhantomData;\n            use std::mem;\n            use std::ops;\n            #[doc = \" Trait for `Mint`. `module()` should return prime number.\"]\n            pub trait Module: Copy + Clone {\n                fn module() -> u32;\n            }\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 7`\"]\n            pub const MOD_107: u32 = 1_000_000_007;\n            #[doc = \" One of famous numbers in programming contest. `10^9 + 9`\"]\n            pub const MOD_109: u32 = 1_000_000_009;\n            #[doc = \" One of famous numbers in programming contest. `998_244_353`\"]\n            pub const MOD_998: u32 = 998_244_353;\n            #[doc = \" struct to implement Module trait. it returns `MOD_107`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod107;\n            impl Module for Mod107 {\n                fn module() -> u32 {\n                    MOD_107\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_109`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod109;\n            impl Module for Mod109 {\n                fn module() -> u32 {\n                    MOD_109\n                }\n            }\n            #[doc = \" struct to implement Module trait. it returns `MOD_998`.\"]\n            #[derive(Debug, Copy, Clone)]\n            pub struct Mod998;\n            impl Module for Mod998 {\n                fn module() -> u32 {\n                    MOD_998\n                }\n            }\n            #[doc = \" Wrapper class to compute mod `1_000_000_007` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" # // TODO: implement convert to u64\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint107 = Mint<Mod107>;\n            #[doc = \" Wrapper class to compute mod `1_000_000_009` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint109, MOD_109};\"]\n            #[doc = \" let x: Mint109 = 1234567.into();\"]\n            #[doc = \" let y: Mint109 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_109 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint109 = Mint<Mod109>;\n            #[doc = \" Wrapper class to compute mod `998_244_353` automatically.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint998, MOD_998};\"]\n            #[doc = \" let x: Mint998 = 1234567.into();\"]\n            #[doc = \" let y: Mint998 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_998 as u64);\"]\n            #[doc = \" ```\"]\n            #[doc = \"\"]\n            pub type Mint998 = Mint<Mod998>;\n            #[doc = \" Wrapper class to compute modulo operation.\"]\n            #[doc = \" See examples\"]\n            #[doc = \" [`Mint107`](type.Mint107.html),\"]\n            #[doc = \" [`Mint109`](type.Mint109.html),\"]\n            #[doc = \" [`Mint998`](type.Mint998.html)\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::math::{Mint107, MOD_107};\"]\n            #[doc = \" let x: Mint107 = 1234567.into();\"]\n            #[doc = \" let y: Mint107 = 2345678.into();\"]\n            #[doc = \" let z = x * y;\"]\n            #[doc = \" assert_eq!(z.val as u64, 1234567u64 * 2345678u64 % MOD_107 as u64);\"]\n            #[doc = \" ```\"]\n            #[derive(Debug, Copy, Clone, Eq)]\n            pub struct Mint<M: Module> {\n                #[doc = \" internal value. this is always less than `self.module()`.\"]\n                pub val: u32,\n                m: PhantomData<M>,\n            }\n            impl<M: Module> Mint<M> {\n                fn module(self) -> u32 {\n                    M::module()\n                }\n                fn new(val: u32) -> Mint<M> {\n                    assert!(val < M::module());\n                    Mint {\n                        val: val,\n                        m: PhantomData,\n                    }\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Add<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn add(self, other: T) -> Mint<M> {\n                    let nval = self.val + other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Sub<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn sub(self, other: T) -> Mint<M> {\n                    let nval = self.val + self.module() - other.into().val;\n                    Mint::new(if nval >= self.module() {\n                        nval - self.module()\n                    } else {\n                        nval\n                    })\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Mul<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn mul(self, other: T) -> Mint<M> {\n                    let nval = self.val as u64 * other.into().val as u64;\n                    Mint::new((nval % (self.module() as u64)) as u32)\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::Div<T> for Mint<M> {\n                type Output = Mint<M>;\n                fn div(self, other: T) -> Mint<M> {\n                    self * other.into().inv()\n                }\n            }\n            impl<M: Module> Mint<M> {\n                #[doc = \" Returns number `y` that satisfies `x * y == 1` where `x` is the original value.\"]\n                #[doc = \"\"]\n                #[doc = \" This assumes `module()` returns prime number.\"]\n                pub fn inv(self) -> Mint<M> {\n                    let mut a = self.val as i32;\n                    let mut b = self.module() as i32;\n                    let mut u = 1 as i32;\n                    let mut v = 0 as i32;\n                    while b != 0 {\n                        let t = a / b;\n                        a -= t * b;\n                        mem::swap(&mut a, &mut b);\n                        u -= t * v;\n                        mem::swap(&mut u, &mut v);\n                    }\n                    Mint::new(if u < 0 { u + self.module() as i32 } else { u } as u32)\n                }\n            }\n            impl<M: Module> PartialEq for Mint<M> {\n                fn eq(&self, other: &Mint<M>) -> bool {\n                    self.val == other.val\n                }\n            }\n            impl<M: Module> fmt::Display for Mint<M> {\n                fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                    self.val.fmt(f)\n                }\n            }\n            macro_rules ! impl_signed_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = ( x as i64 ) % ( M :: module ( ) as i64 ) ; if x >= 0 { Mint { val : t as u32 , m : PhantomData } } else { Mint { val : ( M :: module ( ) as i64 + t ) as u32 , m : PhantomData } } } } ) * ) }\n            macro_rules ! impl_unsigned_mint { ( $ ( $ t : ty ) * ) => ( $ ( impl < M : Module > From <$ t > for Mint < M > { # [ inline ] fn from ( x : $ t ) -> Mint < M > { let t = x as u64 % M :: module ( ) as u64 ; Mint :: new ( t as u32 ) } } ) * ) }\n            impl_signed_mint! { i8 i16 i32 i64 isize }\n            impl_unsigned_mint! { u8 u16 u32 u64 usize }\n            impl<T: Into<Mint<M>>, M: Module> ops::AddAssign<T> for Mint<M> {\n                fn add_assign(&mut self, other: T) {\n                    *self = *self + other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::SubAssign<T> for Mint<M> {\n                fn sub_assign(&mut self, other: T) {\n                    *self = *self - other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::MulAssign<T> for Mint<M> {\n                fn mul_assign(&mut self, other: T) {\n                    *self = *self * other.into();\n                }\n            }\n            impl<T: Into<Mint<M>>, M: Module> ops::DivAssign<T> for Mint<M> {\n                fn div_assign(&mut self, other: T) {\n                    *self = *self / other.into();\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let a: Mint<Mod107> = Mint::from(3);\n                    let b: Mint<Mod107> = Mint::from(1000000000);\n                    assert_eq!(Mint::from(3000000000u64 % Mod107::module() as u64), a * b);\n                }\n            }\n        }\n        pub use self::comb::Comb;\n        pub use self::mint::{Mint, Module};\n        pub use self::mint::{Mint107, Mint109, Mint998};\n        pub use self::mint::{Mod107, Mod109, Mod998};\n        pub use self::mint::{MOD_107, MOD_109, MOD_998};\n    }\n    pub mod util {\n        mod permutation {\n            #[doc = \" It contains same methods as `std::next_permutaion` in C++.\"]\n            #[doc = \" these methods should rearrange the elements into the next/prev lexicographically greater permutation.\"]\n            #[doc = \"\"]\n            #[doc = \" This is implemented in [T] where T is Ord.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::Permutation;\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [5, 0, 9, 2];\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \" assert!(perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 9, 0]);\"]\n            #[doc = \" assert!(perm.prev_permutation());\"]\n            #[doc = \" assert_eq!(perm, [5, 2, 0, 9]);\"]\n            #[doc = \"\"]\n            #[doc = \" let mut perm = [4, 3, 2, 1, 0];\"]\n            #[doc = \" assert!(!perm.next_permutation());\"]\n            #[doc = \" assert_eq!(perm, [4, 3, 2, 1, 0]);\"]\n            #[doc = \" ```\"]\n            pub trait Permutation {\n                #[doc = \" It rearranges the elements into the next lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the last permutation.\"]\n                fn next_permutation(&mut self) -> bool;\n                #[doc = \" It rearranges the elements into the previous lexicographically greater permutation.\"]\n                #[doc = \"\"]\n                #[doc = \" Returns `false` without modifying any state only if current is the first permutation.\"]\n                fn prev_permutation(&mut self) -> bool;\n            }\n            impl<T> Permutation for [T]\n            where\n                T: Ord,\n            {\n                fn next_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] >= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    let mut j = self.len() - 1;\n                    while self[j] <= self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(j, i - 1);\n                    self[i..].reverse();\n                    true\n                }\n                fn prev_permutation(&mut self) -> bool {\n                    if self.len() <= 1 {\n                        return false;\n                    }\n                    let mut i = self.len() - 1;\n                    while i > 0 && self[i - 1] <= self[i] {\n                        i -= 1;\n                    }\n                    if i == 0 {\n                        return false;\n                    }\n                    self[i..].reverse();\n                    let mut j = self.len() - 1;\n                    while self[j - 1] < self[i - 1] {\n                        j -= 1;\n                    }\n                    self.swap(i - 1, j);\n                    true\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::*;\n                #[test]\n                fn test_simple() {\n                    let mut data = [0, 0, 1, 1, 2];\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.next_permutation();\n                    assert_eq!(&data, &[0, 1, 1, 0, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 1, 0, 1, 2]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 2, 1, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 2, 1]);\n                    data.prev_permutation();\n                    assert_eq!(&data, &[0, 0, 1, 1, 2]);\n                    assert!(!data.prev_permutation());\n                }\n            }\n        }\n        mod random {\n            use std::num::Wrapping;\n            #[doc = \" Not secure but fast random generator.\"]\n            #[doc = \"\"]\n            #[doc = \" # Examples\"]\n            #[doc = \" ```\"]\n            #[doc = \" use algonium::util::XorShift;\"]\n            #[doc = \" let mut xorshift = XorShift::new();\"]\n            #[doc = \" assert_eq!(3701687786, xorshift.next_u32());\"]\n            #[doc = \" assert_eq!(458299110, xorshift.next_u32());\"]\n            #[doc = \" ```\"]\n            #[derive(Clone, Debug, Default)]\n            pub struct XorShift {\n                x: Wrapping<u32>,\n                y: Wrapping<u32>,\n                z: Wrapping<u32>,\n                w: Wrapping<u32>,\n            }\n            impl XorShift {\n                #[doc = \" Create object with default seed.\"]\n                pub fn new() -> XorShift {\n                    XorShift {\n                        x: Wrapping(123_456_789),\n                        y: Wrapping(362_436_069),\n                        z: Wrapping(521_288_629),\n                        w: Wrapping(88_675_123),\n                    }\n                }\n                #[doc = \" Get next random u32 number.\"]\n                pub fn next_u32(&mut self) -> u32 {\n                    let x = self.x;\n                    let t = x ^ (x << 11);\n                    self.x = self.y;\n                    self.y = self.z;\n                    self.z = self.w;\n                    let v = self.w;\n                    self.w = v ^ (v >> 19) ^ (t ^ (t >> 8));\n                    self.w.0\n                }\n            }\n            #[cfg(test)]\n            mod tests {\n                use super::XorShift;\n                #[test]\n                fn test_basic() {\n                    let mut xorshift = XorShift::new();\n                    assert_eq!(3701687786, xorshift.next_u32());\n                    assert_eq!(458299110, xorshift.next_u32());\n                }\n            }\n        }\n        pub use self::permutation::Permutation;\n        pub use self::random::XorShift;\n    }\n}\n\n//}}}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/diverta2019-2/tasks/diverta2019_2_e\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nconst MOD: u64 = 1e9 as u64 + 7;\n\nstruct Combination {\n    fact: Vec<u64>,\n    invfact: Vec<u64>,\n}\n\nimpl Combination {\n    fn inv(a: u64) -> u64 {\n        Combination::pow(a, MOD - 2)\n    }\n\n    fn pow(a: u64, p: u64) -> u64 {\n        let mut p = p;\n        let mut aa = a;\n        let mut ret = 1;\n        while p >= 1 {\n            if p & 1 == 1 {\n                ret *= aa;\n                ret %= MOD;\n            }\n            p >>= 1;\n            aa = aa * aa % MOD;\n        }\n        ret\n    }\n\n    fn new(upto: usize) -> Self {\n        let mut fact = vec![0; upto];\n        let mut invfact = vec![0; upto];\n\n        fact[0] = 1;\n        for i in 1..upto {\n            fact[i] = fact[i - 1] * (i as u64) % MOD;\n        }\n\n        invfact[upto - 1] = Combination::inv(fact[upto - 1]);\n        invfact[0] = 1;\n        for i in (1..upto - 1).rev() {\n            invfact[i] = invfact[i + 1] * ((i + 1) as u64) % MOD;\n        }\n\n        Combination {\n            fact: fact,\n            invfact: invfact,\n        }\n    }\n\n    fn comb(&self, n: u64, r: u64) -> u64 {\n        if n < 0 || r < 0 || r > n {\n            return 0;\n        }\n        self.fact[n as usize] * self.invfact[r as usize] % MOD * self.invfact[(n - r) as usize] % MOD\n    }\n\n    fn perm(&self, n: usize, r: usize) -> u64 {\n        if r < 0 || r > n {\n            return 0;\n        }\n        self.fact[n] * self.invfact[n-r] % MOD\n    }\n}\n\nfn main() {\n    input! {\n        n: usize, h: usize, d: usize\n    };\n\n    let comb = Combination::new(1000000+10);\n\n\n    let mut prod = 0;\n    for i in 1..n+1 {\n        let add = comb.fact[i];\n        prod += add;\n        prod %= MOD;\n    }\n\n    let mut dp = vec![0; h+1];\n    let mut esum = comb.fact[n];\n    dp[0] = comb.fact[n];\n    for i in 1..h+1 {\n        dp[i] = esum % MOD;\n        if i == h {\n            break;\n        }\n\n        dp[i] *= prod;\n        dp[i] %= MOD;\n\n        esum += dp[i];\n        if i >= d {\n            esum += MOD - dp[i-d];\n        }\n        esum %= MOD;\n    }\n    println!(\"{}\", dp[h]);\n}\n"
  }
]