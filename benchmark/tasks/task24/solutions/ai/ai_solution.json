[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Python",
    "code": "from typing import List, Tuple\nimport heapq\n\ndef knight_moves(N: int, x: int, y: int) -> List[Tuple[int, int]]:\n    moves = [\n        (x+2, y+1), (x+2, y-1), (x-2, y+1), (x-2, y-1),\n        (x+1, y+2), (x+1, y-2), (x-1, y+2), (x-1, y-2)\n    ]\n    return [(nx, ny) for nx, ny in moves if 0 <= nx < N and 0 <= ny < N]\n\ndef bishop_moves(N: int, x: int, y: int) -> List[Tuple[int, int]]:\n    moves = []\n    for dx, dy in [(1,1), (1,-1), (-1,1), (-1,-1)]:\n        nx, ny = x+dx, y+dy\n        while 0 <= nx < N and 0 <= ny < N:\n            moves.append((nx, ny))\n            nx += dx\n            ny += dy\n    return moves\n\ndef rook_moves(N: int, x: int, y: int) -> List[Tuple[int, int]]:\n    moves = []\n    for dx, dy in [(1,0), (-1,0), (0,1), (0,-1)]:\n        nx, ny = x+dx, y+dy\n        while 0 <= nx < N and 0 <= ny < N:\n            moves.append((nx, ny))\n            nx += dx\n            ny += dy\n    return moves\n\ndef solve(N: int, board: List[List[int]]) -> Tuple[int, int]:\n    nums = {board[x][y]: (x, y) for x in range(N) for y in range(N)}\n    \n    start_pos = nums[1]\n    \n    pieces = {\n        'knight': knight_moves,\n        'bishop': bishop_moves,\n        'rook': rook_moves\n    }\n    \n    best_total_steps = float('inf')\n    best_replacements = float('inf')\n    \n    for start_piece in pieces:\n        queue = [(0, 0, start_pos, start_piece, 1)]\n        visited = set()\n        \n        while queue:\n            steps, replacements, (x, y), current_piece, current_num = heapq.heappop(queue)\n            \n            if current_num > N*N:\n                if steps < best_total_steps or (steps == best_total_steps and replacements < best_replacements):\n                    best_total_steps = steps\n                    best_replacements = replacements\n                break\n            \n            state = (x, y, current_piece, current_num)\n            if state in visited:\n                continue\n            visited.add(state)\n            \n            target = nums[current_num + 1]\n            \n            for piece_name, move_func in pieces.items():\n                for nx, ny in move_func(N, x, y):\n                    if (nx, ny) == target:\n                        new_steps = steps + 1\n                        new_replacements = replacements\n                        if piece_name != current_piece:\n                            new_replacements += 1\n                        \n                        heapq.heappush(queue, (new_steps, new_replacements, (nx, ny), \n                                               piece_name, current_num + 1))\n    \n    return best_total_steps, best_replacements\n\ndef main():\n    N = int(input())\n    board = [list(map(int, input().split())) for _ in range(N)]\n    \n    steps, replacements = solve(N, board)\n    print(f\"{steps} {replacements}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-05 17:32:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Python",
    "code": "import sys\nfrom collections import deque\n\ndef main():\n    N = int(sys.stdin.readline())\n    board = []\n    pos = {}\n    for i in range(N):\n        row = list(map(int, sys.stdin.readline().split()))\n        board.append(row)\n        for j in range(N):\n            pos[row[j]] = (i, j)\n    \n    # Directions for each piece: knight, bishop, rook\n    knight_moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2),\n                    (1, -2), (1, 2), (2, -1), (2, 1)]\n    bishop_moves = []\n    for d in [(-1, -1), (-1, 1), (1, -1), (1, 1)]:\n        for k in range(1, N):\n            bishop_moves.append((d[0]*k, d[1]*k))\n    rook_moves = []\n    for d in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n        for k in range(1, N):\n            rook_moves.append((d[0]*k, d[1]*k))\n    \n    # Initialize DP: (current number, piece type: 0=knight,1=bishop,2=rook) -> (steps, replacements)\n    INF = float('inf')\n    dp = [[ [INF, INF] for _ in range(3) ] for __ in range(N*N + 2)]\n    # Start at number 1, any piece\n    for p in range(3):\n        dp[1][p] = [0, 0]\n    \n    for num in range(1, N*N):\n        for p in range(3):\n            steps, replacements = dp[num][p]\n            if steps == INF:\n                continue\n            current_i, current_j = pos[num]\n            next_i, next_j = pos[num+1]\n            \n            # Check if we can move to next_i, next_j with current piece\n            reachable = False\n            if p == 0:  # knight\n                for di, dj in knight_moves:\n                    ni = current_i + di\n                    nj = current_j + dj\n                    if 0 <= ni < N and 0 <= nj < N and (ni, nj) == (next_i, next_j):\n                        reachable = True\n                        break\n            elif p == 1:  # bishop\n                if (current_i + current_j) == (next_i + next_j) or (current_i - current_j) == (next_i - next_j):\n                    reachable = True\n            elif p == 2:  # rook\n                if current_i == next_i or current_j == next_j:\n                    reachable = True\n            \n            if reachable:\n                if steps + 1 < dp[num+1][p][0] or (steps + 1 == dp[num+1][p][0] and replacements < dp[num+1][p][1]):\n                    dp[num+1][p] = [steps + 1, replacements]\n            \n            # Try switching pieces\n            for new_p in range(3):\n                if new_p == p:\n                    continue\n                if steps + 1 < dp[num][new_p][0] or (steps + 1 == dp[num][new_p][0] and replacements + 1 < dp[num][new_p][1]):\n                    dp[num][new_p] = [steps + 1, replacements + 1]\n    \n    # After processing all numbers, find the minimal steps and replacements\n    min_steps = INF\n    min_replacements = INF\n    for p in range(3):\n        steps, replacements = dp[N*N][p]\n        if steps < min_steps or (steps == min_steps and replacements < min_replacements):\n            min_steps = steps\n            min_replacements = replacements\n    print(min_steps, min_replacements)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-05 17:32:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef bfs(board, start, pieces):\n    N = len(board)\n    queue = deque([(start, 0, 0, -1)])  # position, steps, replacements, current_piece\n    visited = set([start + (-1,)])\n    directions = {\n        'knight': [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)],\n        'bishop': [(i, i) for i in range(1, N)]\n                + [(-i, -i) for i in range(1, N)]\n                + [(i, -i) for i in range(1, N)]\n                + [(-i, i) for i in range(1, N)],\n        'rook': [(0, i) for i in range(1, N)]\n               + [(i, 0) for i in range(1, N)]\n               + [(0, -i) for i in range(1, N)]\n               + [(-i, 0) for i in range(1, N)]\n    }\n\n    while queue:\n        (x, y), steps, replacements, current_piece = queue.popleft()\n        current_number = board[x][y]\n\n        if current_number == N**2:\n            return steps, replacements\n\n        for p, dirs in directions.items():\n            if p != current_piece:\n                new_replacements = replacements + 1\n            else:\n                new_replacements = replacements\n\n            for dx, dy in dirs:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < N and 0 <= ny < N:\n                    new_number = board[nx][ny]\n                    if new_number == current_number + 1 and (nx, ny, p) not in visited:\n                        visited.add((nx, ny, p))\n                        queue.append(((nx, ny), steps + 1, new_replacements, p))\n\nN = int(input().strip())\nboard = [list(map(int, input().strip().split())) for _ in range(N)]\n\nstart_pos = None\nfor i in range(N):\n    for j in range(N):\n        if board[i][j] == 1:\n            start_pos = (i, j)\n            break\n    if start_pos is not None:\n        break\n\npieces = ['knight', 'bishop', 'rook']\nresults = [bfs(board, start_pos, pieces)]\n\nprint(*min(results, key=lambda x: (x[0], x[1])))",
    "timestamp": "2025-08-12 21:43:09"
  }
]