[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\nimport scala.collection.mutable.ArrayBuffer\nimport scala.reflect.ClassTag\n\nobject Main extends App {\n\n  import scala.io.StdIn._\n\n  implicit object G extends Group[Int] {\n    override def plus(a: Int, b: Int): Int = a + b\n\n    override def minus(a: Int, b: Int): Int = a - b\n\n    override def times(a: Int, b: Int): Int = a * b\n\n    override def maxSentinel: Int = Int.MaxValue\n\n    override def zero: Int = 0\n  }\n  solve\n  def solve: Unit = {\n    val n = readLine.trim.toInt\n    if (n == 0) return\n    val dolls = Array.tabulate(n){_ ⇒\n      val Array(x, y, z) = readLine.trim.split(' ').map(_.toInt)\n      Doll(x, y, z)\n    }\n    val buffer = ArrayBuffer[(Int, Int, Int)]()\n    for {i ← 0 until n;j ← 0 until n if dolls(i).canInclude(dolls(j))} {\n      buffer.append((j, i, -dolls(j).weight))\n    }\n    if (buffer.nonEmpty) {\n      val maxReduce = minCostMatching2(n, n, buffer.toArray, n)\n      println(dolls.map {\n        _.weight\n      }.sum + maxReduce)\n    }else {\n      println(dolls.map{_.weight}.sum)\n    }\n    solve\n  }\n  case class Doll(x: Int, y: Int, z: Int){\n    private val sorted = Array(x, y, z).sorted\n    def weight: Int = x * y * z\n    def canInclude(that: Doll): Boolean = (0 until 3).forall(i ⇒ sorted(i) > that.sorted(i))\n  }\n  implicit class Extend[T](value: T){\n    def let[R](func: T ⇒ R): R = func(value)\n    def also(func: T ⇒ Unit): T = {func(value); value}\n  }\n  trait Group[T]{\n    def plus(a: T, b: T): T\n    def minus(a: T, b: T): T\n    def times(a: T, b: Int): T\n    def maxSentinel: T\n    def zero: T\n  }\n\n  private case class Edge[N](to: Int, pair: Int, capacity: Int, cost: N)\n  def minCostMatching2[N: ClassTag](s: Int, t: Int, edges: Array[(Int, Int, N)], matchingLimit: Int)(implicit m: Group[N], o: Ordering[N]): N = {\n    val nodes = makeGraph(s, t, edges)\n    val source = 0\n    val drain = s + t + 1\n    val potential = Array.tabulate(s + t + 2){_ ⇒ m.maxSentinel}\n    for ((_, to, cost) ← edges if o.compare(potential(to + s + 1), cost) > 0) potential(to + s + 1) = cost\n    potential.indices.withFilter(i ⇒ o.compare(potential(i), m.maxSentinel) == 0).foreach(i ⇒ potential(i) = m.zero)\n    val minCost = Array.tabulate(s + t + 2){_ ⇒ m.maxSentinel}\n    val queue = mutable.PriorityQueue()(Ordering.by[(Int, N), N](_._2).reverse)\n    val prevEdge = Array.tabulate(s + t + 2){_ ⇒ Edge(0, 0, 0, m.zero)}\n    var canMatch = true\n    var result = m.zero\n    for (_ ← 1 to matchingLimit if canMatch){\n      minCost.indices.foreach(i ⇒ minCost(i) = m.maxSentinel)\n      minCost(source) = m.zero\n      queue.clear()\n      queue.enqueue((source, m.zero))\n      while(queue.nonEmpty){\n        val (prev, cost) = queue.dequeue()\n        if (minCost(prev) == cost && prev != s + t + 1){\n          for (Edge(to, pair, capacity, c) ← nodes(prev) if capacity == 1){\n            //minCost(to) > cost + potential(prev) + c - potential(to)\n            if (o.compare(minCost(to), m.plus(m.plus(cost, potential(prev)), m.minus(c, potential(to)))) > 0) {\n              minCost(to) = m.plus(m.plus(cost, potential(prev)), m.minus(c, potential(to)))\n              prevEdge(to) = nodes(to)(pair)\n              queue.enqueue((to, minCost(to)))\n            }\n          }\n        }\n      }\n      if (minCost(drain) == m.maxSentinel){\n        canMatch = false\n      }else {\n        result = m.plus(result, minCost(drain))\n        var last = drain\n        while(last != source){\n          val rev = prevEdge(last)\n          val edge = nodes(rev.to)(rev.pair)\n          nodes(last)(edge.pair) = rev.copy(capacity = 1)\n          nodes(rev.to)(rev.pair) = edge.copy(capacity = 0)\n          last = rev.to\n        }\n        for (x ← 1 until drain){\n          potential(x) = m.plus(potential(x), minCost(x))\n        }\n      }\n    }\n    result\n  }\n  private def makeGraph[N](s: Int, t: Int, edges: Array[(Int, Int, N)])(implicit m: Group[N]): Array[Array[Edge[N]]]= {\n    val e = Array.tabulate(s + t + 2){_ ⇒ ArrayBuffer[Edge[N]]()}\n    for (x ← 1 to s){\n      e(x).append(Edge(0, e(0).length, 0, m.zero))\n      e(0).append(Edge(x, 0, 1, m.zero))\n    }\n    for (y ← s + 1 to s + t){\n      e(y).append(Edge(s + t + 1, e(s + t + 1).length, 1, m.zero))\n      e(s + t + 1).append(Edge(y, 0, 0, m.zero))\n    }\n    for ((from, to, cost) ← edges){\n      e(from + 1).append(Edge(to + s + 1, e(to + s + 1).length, 1, cost))\n      e(to + s + 1).append(Edge(from + 1, e(from + 1).length - 1, 0, m.minus(m.zero, cost)))\n    }\n    e.map(_.toArray)\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.mutable\nimport scala.collection.mutable.ArrayBuffer\nimport scala.util.control.Breaks._\n\nobject Main extends App {\n  val in = new Scanner(System.in)\n  while (true) {\n    val n = in.nextInt()\n    if (n == 0) {\n      break\n    }\n    val xyz = (for (_ <- 0 until n) yield {\n      Array(in.nextInt(), in.nextInt(), in.nextInt()).sorted\n    }).toArray\n\n\n    val source = n * 2\n    val sink = source + 1\n    val minimumCostFlow = new MinimumCostFlow(sink + 1)\n    for {\n      i <- 0 until n\n      j <- 0 until n\n      if i != j\n      if xyz(i)(0) < xyz(j)(0)\n      if xyz(i)(1) < xyz(j)(1)\n      if xyz(i)(2) < xyz(j)(2)\n    } {\n      minimumCostFlow.addEdge(i, n + j, 1, 0)\n    }\n    for (i <- 0 until n) {\n      minimumCostFlow.addEdge(source, i, 1, 0)\n      minimumCostFlow.addEdge(i, sink, 1, xyz(i)(0) * xyz(i)(1) * xyz(i)(2))\n      minimumCostFlow.addEdge(i + n, sink, 1, 0)\n    }\n\n    val cost = minimumCostFlow.calculateCost(source, sink, n)\n    println(cost)\n  }\n}\n\nclass Edge(val to: Int, var cap: Long, val cost: Long, val rev: Int)\n\nclass MinimumCostFlow(V: Int) {\n  val graph: Array[ArrayBuffer[Edge]] = (for (_ <- 0 until V) yield new ArrayBuffer[Edge]()).toArray\n  val prevV = new Array[Int](V)\n  val prevE = new Array[Int](V)\n\n  def addEdge(from: Int, to: Int, cap: Long, cost: Long): Unit = {\n    graph(from).append(new Edge(to, cap, cost, graph(to).size))\n    graph(to).append(new Edge(from, 0, -cost, graph(from).size - 1))\n  }\n\n  def calculateCost(source: Int, sink: Int, flow: Long): Long = {\n    val INF = Long.MaxValue / 2\n    var cost = 0L\n    var residue = flow\n    val potential = new Array[Long](V)\n    while (residue > 0) {\n      val dist = Array.fill[Long](V)(INF)\n      dist(source) = 0\n      val queue = mutable.PriorityQueue.empty[(Long, Int)](implicitly[Ordering[(Long, Int)]].reverse)\n      queue.enqueue((0, source))\n      while (queue.nonEmpty) {\n        val p = queue.dequeue()\n        val v = p._2\n        if (dist(v) >= p._1) {\n          for (i <- graph(v).indices) {\n            val e = graph(v)(i)\n            val u = e.to\n            if (e.cap > 0 && dist(u) > dist(v) + e.cost + potential(v) - potential(u)) {\n              dist(u) = dist(v) + e.cost + potential(v) - potential(u)\n              prevV(u) = v\n              prevE(u) = i\n              queue.enqueue((dist(u), u))\n            }\n          }\n        }\n      }\n      if (dist(sink) == INF) {\n        return -1\n      }\n\n      for (v <- 0 until V) {\n        potential(v) += dist(v)\n      }\n      var d = residue\n      var v = sink\n      while (v != source) {\n        d = math.min(d, graph(prevV(v))(prevE(v)).cap)\n        v = prevV(v)\n      }\n      residue -= d\n      cost += d * potential(sink)\n\n      v = sink\n      while (v != source) {\n        val e = graph(prevV(v))(prevE(v))\n        e.cap -= d\n        graph(v)(e.rev).cap += d\n        v = prevV(v)\n      }\n    }\n    return cost\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\n\nimport scala.collection.mutable\nimport scala.collection.mutable.ArrayBuffer\n\nobject Main extends App {\n  val in = new Scanner(System.in)\n\n  def solve(n: Int): Long = {\n    val xyz = (for (_ <- 0 until n) yield {\n      Array(in.nextInt(), in.nextInt(), in.nextInt()).sorted\n    }).toArray\n\n\n    val source = n * 2\n    val sink = source + 1\n    val minimumCostFlow = new MinimumCostFlow(sink + 1)\n    for {\n      i <- 0 until n\n      j <- 0 until n\n      if i != j\n      if xyz(i)(0) < xyz(j)(0)\n      if xyz(i)(1) < xyz(j)(1)\n      if xyz(i)(2) < xyz(j)(2)\n    } {\n      minimumCostFlow.addEdge(i, n + j, 1, 0)\n    }\n    for (i <- 0 until n) {\n      minimumCostFlow.addEdge(source, i, 1, 0)\n      minimumCostFlow.addEdge(i, sink, 1, xyz(i)(0) * xyz(i)(1) * xyz(i)(2))\n      minimumCostFlow.addEdge(i + n, sink, 1, 0)\n    }\n    minimumCostFlow.calculateCost(source, sink, n)\n  }\n\n  def loop(): Unit = {\n    while (true) {\n      val n = in.nextInt()\n      if (n == 0) {\n        return\n      }\n      val ans = solve(n)\n      println(ans)\n    }\n  }\n\n  loop()\n\n}\n\nclass Edge(val to: Int, var cap: Long, val cost: Long, val rev: Int)\n\nclass MinimumCostFlow(V: Int) {\n  val graph: Array[ArrayBuffer[Edge]] = (for (_ <- 0 until V) yield new ArrayBuffer[Edge]()).toArray\n  val prevV = new Array[Int](V)\n  val prevE = new Array[Int](V)\n\n  def addEdge(from: Int, to: Int, cap: Long, cost: Long): Unit = {\n    graph(from).append(new Edge(to, cap, cost, graph(to).size))\n    graph(to).append(new Edge(from, 0, -cost, graph(from).size - 1))\n  }\n\n  def calculateCost(source: Int, sink: Int, flow: Long): Long = {\n    val INF = Long.MaxValue / 2\n    var cost = 0L\n    var residue = flow\n    val potential = new Array[Long](V)\n    while (residue > 0) {\n      val dist = Array.fill[Long](V)(INF)\n      dist(source) = 0\n      val queue = mutable.PriorityQueue.empty[(Long, Int)](implicitly[Ordering[(Long, Int)]].reverse)\n      queue.enqueue((0, source))\n      while (queue.nonEmpty) {\n        val p = queue.dequeue()\n        val v = p._2\n        if (dist(v) >= p._1) {\n          for (i <- graph(v).indices) {\n            val e = graph(v)(i)\n            val u = e.to\n            if (e.cap > 0 && dist(u) > dist(v) + e.cost + potential(v) - potential(u)) {\n              dist(u) = dist(v) + e.cost + potential(v) - potential(u)\n              prevV(u) = v\n              prevE(u) = i\n              queue.enqueue((dist(u), u))\n            }\n          }\n        }\n      }\n      if (dist(sink) == INF) {\n        return -1\n      }\n\n      for (v <- 0 until V) {\n        potential(v) += dist(v)\n      }\n      var d = residue\n      var v = sink\n      while (v != source) {\n        d = math.min(d, graph(prevV(v))(prevE(v)).cap)\n        v = prevV(v)\n      }\n      residue -= d\n      cost += d * potential(sink)\n\n      v = sink\n      while (v != source) {\n        val e = graph(prevV(v))(prevE(v))\n        e.cap -= d\n        graph(v)(e.rev).cap += d\n        v = prevV(v)\n      }\n    }\n    return cost\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(a) (a).begin(), (a).end()\n#define endl \"\\n\"\n#define rep(i, a, b) for (auto i = (a); i < (b); ++i)\n#define rrep(i, a, b) for (auto i = (a); i > (b); --i)\n#define UNIQUE(v) (v).erase(unique((v).begin(), (v).end()), (v).end())\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#ifdef LOCAL_DEFINE\nstruct InitInput\n{\n  InitInput()\n  {\n    FILE *stream1;\n    stream1 = freopen(\"in.txt\", \"r\", stdin);\n    assert(stream1 != nullptr);\n    cerr << \"This problem is not interactive\" << endl;\n  }\n} LOCAL_INPUT;\nstruct LOCAL_OUTPUT\n{\n  LOCAL_OUTPUT()\n  {\n    FILE *stream2;\n    const char *outputfile = \"out.txt\";\n    stream2 = freopen(outputfile, \"w\", stdout);\n    assert(stream2 != nullptr);\n    cerr << \"output [ \" << outputfile << \" ]\" << endl;\n  }\n} /*LOCAL_OUTPUT*/;\n#define show(x) cerr << #x << \" = \" << (x) << \" (line \" << __LINE__ << \")\" << endl\n#define showA(a, n) \\\n  do{for(int i=0;i<(n);i++)cerr<<\"(\"<<i<<\" = \"<<(a)[i]<<\") \";cerr<<endl;}while(0)\n#define showA2(a, n, m) \\\n  do {for(int i=0;i<(n);i++){for(int j=0;j<(m);j++){cerr<<\"(\"<<i<<\", \"<<j<<\" = \"<<(a)[i][j]<<\") \";}cerr<<endl;}cerr<<endl;}while(0)\n#else\n#define show(x)\n#define showA(a, n)\n#define showA2(a, n, m)\n#endif\n\nstruct InitAim\n{\n  InitAim()\n  {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(12);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    cerr << \"This problem is not interactive\" << endl;\n#endif\n  }\n} aim_cpo;\n\n///////////////////////////////////////////////////////////////////////////////////\n// TEMPLATE(data structure)\n///////////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename T>\nbool chmin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate <typename T>\nbool chmax(T &a, T b) { return a < b ? (a = b, true) : false; }\ntemplate <typename T>\nvoid ln(T i, T n) { cout << (i == n - 1 ? \"\\n\" : \" \"); }\ntemplate <typename T, typename S>\nostream &operator<<(ostream &out, const pair<T, S> &pair1)\n{\n  out << '(' << pair1.fi << \", \" << pair1.se << ')';\n  return out;\n}\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &vector1)\n{\n  out << '[';\n  for (unsigned int i = 0; i < vector1.size(); i++)\n  {\n    out << vector1[i];\n    if (i == vector1.size() - 1)\n      out << \"]\";\n    else\n      out << \", \";\n  }\n  return out;\n}\n\n#define GCD(a, b) __gcd(a, b)\ntemplate <typename T>\nT LCM(T a, T b)\n{\n  return a / GCD(a, b) * b;\n}\ntemplate <typename T>\nT EXTGCD(T a, T b, T &x, T &y)\n{\n  T d = a;\n  if (b != 0)\n  {\n    d = EXTGCD(b, a % b, y, x);\n    y -= (a / b) * x;\n  }\n  else\n    x = 1, y = 0;\n  return d;\n}\ntemplate <typename T>\nbool is_prime(T a)\n{\n  for (int i = 2; i * i <= a; i++)\n    if (a % i == 0)\n      return true;\n  return false;\n}\ntemplate <typename T, typename S>\nT Pow(T a, S b)\n{\n  T res = 1, now = a;\n  while (b)\n  {\n    if (b & 1)\n      res *= now;\n    b >>= 1;\n    now *= now;\n  }\n  return res;\n}\n\n/* MOD */\nll MOD = 1000000000L + 7L;\n#define Madd(a, b) (((a) % MOD) + ((b) % MOD)) % MOD\n#define Mmul(a, b) (((a) % MOD) * ((b) % MOD)) % MOD\n#define Msub(a, b) (((a) % MOD) + MOD - ((b) % MOD)) % MOD\ntemplate <typename T, typename S>\nT ModPow(T a, S b)\n{\n  assert(b >= 0);\n  T res = 1, now = Msub(a, 0);\n  while (b)\n  {\n    if (b & 1)\n      res = Mmul(res, now);\n    b >>= 1;\n    now = Mmul(now, now);\n  }\n  return res;\n}\ntemplate <typename T>\nT ModInverse(T a, T mod, bool prime)\n{ // if mod is prime, \"prime\" is true.\n  if (prime)\n    return ModPow(a, mod - 2);\n  else\n  {\n    T x, y;\n    EXTGCD(a, mod, x, y);\n    return (mod + x % mod) % mod;\n  }\n}\ntemplate <typename T>\nT EulerTotient(T a)\n{\n  vector<pair<int, int>> v;\n  for (T i = 2; i * i <= a; i++)\n  {\n    int cnt = 0;\n    while (a % i == 0)\n    {\n      cnt++;\n      a /= i;\n    }\n    if (cnt != 0)\n      v.emplace_back(i, cnt);\n  }\n  if (a != 1)\n    v.emplace_back(a, 1);\n  //showV(v, (int) v.size());\n  T res = 1;\n  for (int i = 0; i < (int)v.size(); i++)\n  {\n    if (v[i].se == 1)\n    {\n      //res *= v[i].fi - 1;\n      res = Mmul(res, v[i].fi - 1);\n    }\n    else\n    {\n      //res *= Pow(v[i].fi, v[i].se) - Pow(v[i].fi, v[i].se - 1);\n      res = Mmul(res, Msub(ModPow(v[i].fi, v[i].se), ModPow(v[i].fi, v[i].se - 1)));\n    }\n  }\n  return res;\n}\n#define Mdivide(a, b) Mmul(((a) % MOD), (ModInverse((b), MOD, true))) % MOD\nll comb(ll a, ll b)\n{\n  chmin(b, a - b);\n  ll res = 1LL, now = a;\n  for (ll i = 1; i <= b; i++)\n  {\n    res = Mmul(res, now);  //res *= now;\n    res = Mdivide(res, i); // res /= i;\n    now--;\n  }\n  return res;\n}\n\ntemplate <typename T>\nclass BIT\n{\npublic:\n  BIT(int size)\n  {\n    BITTable.assign(++size, 0);\n  }\n  T sum(int k)\n  {\n    T res = 0;\n    for (++k; k > 0; k -= k & -k)\n    {\n      res += BITTable[k];\n    }\n    return res;\n  }\n  T sum(int l, int r)\n  {\n    if (l == 0)\n      return sum(r);\n    return sum(r) - sum(l - 1);\n  }\n  void update(int k, T x)\n  { // b[k] += x;\n    for (++k; k < (int)BITTable.size(); k += k & -k)\n      BITTable[k] += x;\n  }\n\nprivate:\n  vector<T> BITTable;\n};\n\ntemplate <typename T>\nclass IntervalTree\n{\n  using F = function<T(T, T)>;\n\npublic:\n  IntervalTree(int n, const F func, const T init) : func(func), init(init)\n  {\n    size = 1;\n    while ((int)size < n)\n      size <<= 1;\n    table.assign(2 * size, init);\n  }\n  void set(int k, T &x)\n  {\n    table[size + k] = x;\n  }\n  void build()\n  {\n    for (int i = size - 1; i >= 0; --i)\n    {\n      table[i] = func(table[i * 2], table[i * 2 + 1]);\n    }\n  }\n  void update(int k, const T &x)\n  {\n    k += size;\n    table[k] = x;\n    while (k >>= 1)\n    {\n      table[k] = func(table[k * 2], table[k * 2 + 1]);\n    }\n  }\n  T query(int a, int b)\n  {\n    T L = init, R = init;\n    for (a += size, b += size; a < b; a >>= 1, b >>= 1)\n    {\n      if (a & 1)\n        L = func(L, table[a++]);\n      if (b & 1)\n        R = func(table[--b], R);\n    }\n    return func(L, R);\n  }\n  T operator[](const int k) const\n  {\n    return table[k + size];\n  }\n\nprivate:\n  unsigned int size;\n  vector<T> table;\n  const F func;\n  const T init;\n};\n\nclass UnionFind\n{\npublic:\n  explicit UnionFind(int _n) : n(_n)\n  {\n    par.resize(static_cast<unsigned long>(_n));\n    rank.resize(static_cast<unsigned long>(_n));\n    sizes.resize(static_cast<unsigned long>(_n));\n    for (int i = 0; i < _n; i++)\n    {\n      par[i] = i;\n      rank[i] = 0;\n      sizes[i] = 1;\n    }\n  }\n  int find(int a)\n  {\n    if (par[a] == a)\n      return a;\n    return par[a] = find(par[a]);\n  }\n  bool same(int a, int b)\n  {\n    return find(a) == find(b);\n  }\n  void unite(int a, int b)\n  {\n    link(find(a), find(b));\n  }\n  int size(int a)\n  {\n    return sizes[find(a)];\n  }\n  void view()\n  {\n    for (int i = 0; i < n; i++)\n    {\n      cout << \" par\"\n           << \"[\" << i << \"]=\" << par[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    for (int i = 0; i < n; i++)\n    {\n      cout << \"size\"\n           << \"[\" << i << \"]=\" << sizes[i] << ((i == n - 1) ? \"\\n\" : \",\");\n    }\n    cout << endl;\n  }\n\nprivate:\n  void link(int a, int b)\n  {\n    if (same(a, b))\n      return;\n    if (rank[a] > rank[b])\n    {\n      par[b] = a;\n      sizes[a] += sizes[b];\n      sizes[b] = 0;\n    }\n    else\n    {\n      par[a] = b;\n      if (rank[a] == rank[b])\n        rank[b]++;\n      sizes[b] += sizes[a];\n      sizes[a] = 0;\n    }\n  }\n  int n;\n  vector<int> par;\n  vector<int> rank;\n  vector<int> sizes;\n};\n\ntemplate<typename T>\nclass Dinic{\npublic:\n  Dinic(int SIZE) :SIZE(SIZE) {\n    v = vector<vector<tuple<int, T, int>>>(SIZE + 10);\n  }\n\n  void AddEdge(int from, int to, T cap) {\n    v[from].push_back(make_tuple(to, cap, v[to].size()));\n    v[to].push_back(make_tuple(from, 0, v[from].size() - 1));\n  }\n\n  void bfs(int s) {\n    level = vector<int>(SIZE + 10, -1);\n    queue<int> q;\n    level[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int now = q.front(); q.pop();\n      for (int i = 0; i < (int)v[now].size(); i++) {\n        int next, nextrv; T nextc; tie(next, nextc, nextrv) = v[now][i];\n        if (nextc > 0 && level[next] < 0) {\n          level[next] = level[now] + 1;\n          q.push(next);\n        }\n      }\n    }\n  }\n\n  T dfs(int now, int t, T f) {\n    if (now == t) return f;\n    for (int &i = iter[now]; i < (int)v[now].size(); i++) {\n      int next, nextrv; T nextc; tie(next, nextc, nextrv) = v[now][i];\n      if (nextc > 0 && level[now] < level[next]) {\n        T d = dfs(next, t, min(f, nextc));\n        if (d > 0) {\n          get<1>(v[now][i]) -= d;\n          get<1>(v[next][nextrv]) += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  T max_flow(int s, int t) {\n    T flow = 0;\n    for (;;) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      iter = vector<int>(SIZE + 10, 0);\n      int f;\n      while ((f = dfs(s, t, INT_MAX)) > 0) {\n        flow += f;\n      }\n    }\n  }\nprivate:\n  int SIZE;\n  vector<vector<tuple<int, T, int>>> v;\n  vector<int> level, iter;\n};\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< int > prevv, preve;\n\n  PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n};\n\n\n///////////////////////////////////////////////////////////////////////////////////\n// MAIN\n///////////////////////////////////////////////////////////////////////////////////\n// 735134400 約数が1344個ある高度合成数(<= 1e9)\n// 897612484786617600 約数が103680個ある高度合成数(<= 1e18)\n// 苦手分野 重複順列\n// LLの数値をつかう時は最後にLLをつける癖をつけよう\n\nvoid solve(int &n) {\n  int x[101], y[101], z[101];\n  int sum = 0;\n  rep(i, 0, n) {\n    cin >> x[i] >> y[i] >> z[i];\n    sum += x[i] * y[i] * z[i];\n  }\n  int s = 2 * n;\n  int t = s + 1;\n  PrimalDual<int, int> F(2 * n + 2);\n  rep(i, 0, n) {\n    rep(j, 0, n) {\n      if (i == j) continue;\n      auto check = [&](){\n        if (x[i] > x[j] && y[i] > y[j] && z[i] > z[j]) return true;\n        if (x[i] > x[j] && z[i] > y[j] && y[i] > z[j]) return true;\n        if (y[i] > x[j] && x[i] > y[j] && z[i] > z[j]) return true;\n        if (y[i] > x[j] && z[i] > y[j] && x[i] > z[j]) return true;\n        if (z[i] > x[j] && x[i] > y[j] && y[i] > z[j]) return true;\n        if (z[i] > x[j] && y[i] > y[j] && x[i] > z[j]) return true;\n        return false;\n      };\n      if (check()) {\n        F.add_edge(i, n + j, 1, -x[j] * y[j] * z[j]);\n      }\n    }\n  }\n  rep(i, 0, n) {\n    F.add_edge(s, i, 1, 0);\n    F.add_edge(n + i, t, 1, 0);\n    F.add_edge(i, t, 1, 0);\n  }\n  cout << sum + F.min_cost_flow(s, t, n) << endl;\n}\n\nint main()\n{\n  int n;\n  while (cin >> n, n) solve(n);\n#ifdef LOCAL_DEFINE\n  cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \"s.\" << endl;\n  show(MOD);\n#endif\n  return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// NOTE\n///////////////////////////////////////////////////////////////////////////////////\n/*\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i, n) for(int i = 0; i < n; ++i)\n#define vi vector<int>\n#define all(c) (c).begin(), (c).end()\n\ntemplate <typename T> T hungarian(vector<vector<T>> &A) {\n    const T infty = numeric_limits<T>::max();\n    const int N = (int)A.size();\n    const int M = (int)A[0].size();\n    vector<int> P(M), way(M);\n    vector<T> U(N, 0), V(M, 0), minV;\n    vector<bool> used;\n\n    for(int i = 1; i < N; i++) {\n        P[0] = i;\n        minV.assign(M, infty);\n        used.assign(M, false);\n        int j0 = 0;\n        while(P[j0] != 0) {\n            int i0 = P[j0], j1 = 0;\n            used[j0] = true;\n            T delta = infty;\n            for(int j = 1; j < M; j++) {\n                if(used[j]) continue;\n                T curr = A[i0][j] - U[i0] - V[j];\n                if(curr < minV[j]) minV[j] = curr, way[j] = j0;\n                if(minV[j] < delta) delta = minV[j], j1 = j;\n            }\n            for(int j = 0; j < M; j++) {\n                if(used[j])\n                    U[P[j]] += delta, V[j] -= delta;\n                else\n                    minV[j] -= delta;\n            }\n            j0 = j1;\n        }\n        do {\n            P[j0] = P[way[j0]];\n            j0 = way[j0];\n        } while(j0 != 0);\n    }\n    return -V[0];\n}\n\nmain() {\n    while(1) {\n        int n;\n        cin >> n;\n        if(!n) return 0;\n        vi x(n), y(n), z(n);\n        rep(i, n) cin >> x[i] >> y[i] >> z[i];\n        vi id(n);\n        rep(i, n) {\n            vi v{x[i], y[i], z[i]};\n            sort(all(v));\n            x[i] = v[0], y[i] = v[1], z[i] = v[2];\n        }\n        vector<vi> a(n + 1, vi(n + 1));\n        int ans = 0;\n        rep(i, n) rep(j, n) {\n            if(x[i] < x[j] and y[i] < y[j] and z[i] < z[j]) { a[i + 1][j + 1] = -x[i] * y[i] * z[i]; }\n        }\n        rep(i, n) ans += x[i] * y[i] * z[i];\n        cout << ans + hungarian(a) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct MinimumCostFlow {\n\tusing Flow = int;\n\tusing Cost = int;\n\tstruct Edge {\n\t\tint to, rev;\n\t\tFlow cap;\n\t\tCost cost;\n\t\tEdge() {}\n\t\tEdge(int to, int rev, Flow cap, Cost cost) :to(to), rev(rev), cap(cap), cost(cost) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\tvector<int> dist;\n\tvector<int> prevv, preve;\n\tMinimumCostFlow(int n) :n(n), g(n), dist(n), prevv(n), preve(n) {}\n\tvoid addArc(int from, int to, Flow cap, Cost cost) {\n\t\tg[from].emplace_back(to, (int)g[to].size(), cap, cost);\n\t\tg[to].emplace_back(from, (int)g[from].size() - 1, 0, -cost);\n\t}\n\t// s??????t????????????f???????°??????¨???\n\t// ??????????????´?????? -1\n\tCost minimumCostFlow(int s, int t, Flow f) {\n\t\tCost total = 0;\n\t\twhile (f > 0) {\n\t\t\t// Bellman-Ford\n\t\t\tfill(dist.begin(), dist.end(), INF);\n\t\t\tdist[s] = 0;\n\t\t\tbool update = true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tfor (int v = 0; v < n; v++) {\n\t\t\t\t\tif (dist[v] == INF)continue;\n\t\t\t\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n\t\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ????????\\???????????????\n\t\t\tif (dist[t] == INF)\n\t\t\t\treturn -1;\n\t\t\t// ?????????????????£??????????????????\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v])\n\t\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t\tf -= d;\n\t\t\ttotal += d*dist[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn total;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tfor (int N; cin >> N&&N;) {\n\t\t;\n\t\tvector<int> x(N), y(N), z(N); rep(i, 0, N) {\n\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t}\n\t\tMinimumCostFlow mcf(N + N + 2);\n\t\tint s = N + N, t = s + 1;\n\t\trep(i, 0, N) {\n\t\t\tmcf.addArc(s, i, 1, 0);\n\t\t\tmcf.addArc(i + N, t, 1, 0);\n\t\t}\n\t\trep(i, 0, N)rep(j, 0, N) {\n\t\t\tif (i == j) {\n\t\t\t\tmcf.addArc(i, t, 1, x[i] * y[i] * z[i]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvector<int> I{ x[i],y[i],z[i] }, J{ x[j],y[j],z[j] };\n\t\t\t\tsort(all(I)); sort(all(J));\n\t\t\t\tif (I[0] < J[0] && I[1] < J[1] && I[2] < J[2]) {\n\t\t\t\t\tmcf.addArc(i, N + j, 1, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << mcf.minimumCostFlow(s, t, N) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nstatic const ll INF = 1e18;\n\nstruct edge {\n  int to;\n  ll cap, cost;\n  int rev;\n};\n\nvector<ll> h, d; // ポテンシャル, 最短距離\nvector<int> prevv, preve; // 直前の頂点と辺\n\nvoid add_edge(vector<vector<edge>> &G, int from, int to, ll cap, ll cost) {\n  G[from].emplace_back((edge) {to, cap, cost, (int) G[to].size()});\n  G[to].emplace_back((edge) {from, 0, -cost, (int) G[from].size() - 1});\n}\n\n// sからtへの流量fの最小費用流(流せない場合は-1)\nll min_cost_flow(vector<vector<edge>> &G, int s, int t, ll f) {\n  ll res = 0;\n  h.assign(G.size(), 0);\n  prevv.assign(G.size(), 0);\n  preve.assign(G.size(), 0);\n  while (f > 0) {\n    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;\n    d.assign(G.size(), INF);\n    d[s] = 0;\n    pq.push(make_pair(0, s));\n    while (!pq.empty()) {\n      pair<ll, int> p = pq.top();\n      pq.pop();\n      int v = p.second;\n      if (d[v] < p.first) continue;\n      for (int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && d[e.to] > d[v] + e.cost + h[v] - h[e.to]) {\n          d[e.to] = d[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          pq.push(make_pair(d[e.to], e.to));\n        }\n      }\n    }\n    if (d[t] == INF) return -1;\n    for (int i = 0; i < G.size(); i++) h[i] += d[i];\n    \n    // s-t間最短路に流す\n    int nowf = f;\n    for (int i = t; i != s; i = prevv[i]) {\n      nowf = min<ll>(nowf, G[prevv[i]][preve[i]].cap);\n    }\n    f -= nowf;\n    res += nowf * h[t];\n    for (int i = t; i != s; i = prevv[i]) {\n      edge &e = G[prevv[i]][preve[i]];\n      e.cap -= nowf;\n      G[i][e.rev].cap += nowf;\n    }\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  \n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) return 0;\n    \n    ll sum = 0;\n    vector<vector<ll>> v(n, vector<ll>(3));\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 3; j++) {\n        cin >> v[i][j];\n      }\n      sort(v[i].begin(), v[i].end());\n      sum += v[i][0] * v[i][1] * v[i][2];\n    }\n    \n    int vs = 2 * n, vt = 2 * n + 1; // フローの始点と終点\n    vector<vector<edge>> G(2 * n + 2);\n    for (int i = 0; i < n; i++) {\n      add_edge(G, vs, i, 1, 0);\n      add_edge(G, i + n, vt, 1, 0);\n      for (int j = 0; j < n; j++) {\n        if (v[i][0] > v[j][0] && v[i][1] > v[j][1] && v[i][2] > v[j][2]) {\n          add_edge(G, i, j + n, 1, -v[j][0] * v[j][1] * v[j][2]);\n        }\n      }\n    }\n    add_edge(G, vs, vt, n, 0);\n    ll fl = min_cost_flow(G, vs, vt, n);\n    cout << sum + fl << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <string.h>\n#include <queue>\nusing namespace std;\nconst int INF = 1e9;\n\nstruct edge {int to, cap, cost, rev;};\n \nint V;\nconst int MAX_V = 202;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f){\n  int res = 0;\n  fill(h, h+V, 0);\n  while(f > 0){\n    priority_queue< pair<int,int>, vector< pair<int,int> >, greater< pair<int,int> > > que;\n    fill(dist, dist+V, INF);\n    dist[s] = 0;\n    que.emplace(0, s);\n    while(!que.empty()){\n      pair<int,int> p = que.top();\n      que.pop();\n      int v = p.second;\n      if(dist[v] < p.first) continue;\n      for(int i = 0; i < G[v].size(); ++i){\n        edge &e = G[v][i];\n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.emplace(dist[e.to], e.to);\n        }\n      }\n    }\n    if(dist[t] == INF) return -1;\n    for(int v = 0; v < V; ++v) h[v] += dist[v];\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d*h[t];\n    for(int v = t; v != s; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int N, M, L;\n  while(cin >> N, N){\n    V = 2*N + 2;\n    vector< vector<int> > M;\n    long long int ans = 0;\n    for(int i = 0; i < N; ++i){\n      int x, y, z;\n      cin >> x >> y >> z;\n      int s = min({x, y, z}), l = max({x, y, z}), m = x + y + z - s - l;\n      M.push_back({s, m, l});\n      //ans += s*m*l;\n    }\n    sort(M.begin(), M.end());\n\n    for(int i = 0; i < N; ++i){\n      add_edge(i, 2*N+1, 1, M[i][0]*M[i][1]*M[i][2]);\n      for(int j = 0; j < i; ++j){\n        if(M[j][0] < M[i][0] && M[j][1] < M[i][1] && M[j][2] < M[i][2])\n          add_edge(j, i+N, 1, 0);\n      }\n    }\n    \n    for(int i = 0; i < N; ++i){\n      add_edge(2*N, i, 1, 0);\n      add_edge(N+i, 2*N+1, 1, 0);\n    }\n\n    ans += min_cost_flow(2*N, 2*N+1, N);\n    /*\n    for(int i = 0; i < N; ++i){\n      if(G[2*N][i].cap) ans += M[i][0]*M[i][1]*M[i][2];\n    }\n    */\n    cout << ans << endl;\n    for(int i = 0; i < V; ++i) G[i].clear();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define mod 1000000007\nusing ll=long long;\nconst int INF=1000000000;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n \nstruct IOSetup{\n    IOSetup(){\n        cin.tie(0);\n        ios::sync_with_stdio(0);\n        cout<<fixed<<setprecision(12);\n    }\n} iosetup;\n \ntemplate<typename T1,typename T2>\nostream &operator<<(ostream &os,const pair<T1,T2>&p){\n    os<<p.first<<\" \"<<p.second;\n    return os;\n}\n \ntemplate<typename T>\nostream &operator<<(ostream &os,const vector<T>&v){\n    for(int i=0;i<(int)v.size();i++) os<<v[i]<<(i+1==(int)v.size()?\"\":\" \");\n    return os;\n}\n\ntemplate<typename T1,typename T2>\nistream &operator>>(istream &is,pair<T1,T2>&p){\n    is>>p.first>>p.second;\n    return is;\n}\n\ntemplate<typename T>\nistream &operator>>(istream &is,vector<T>&v){\n    for(T &x:v)is>>x;\n    return is;\n}\n\ntemplate<typename flow_t, typename cost_t>\nstruct PrimalDual{\n    const cost_t TINF;\n \n    struct edge{\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;//この辺の逆辺がg[from]の何番目にあるか\n        bool isrev;\n    };\n \n    vector<vector<edge>> graph;\n    vector<cost_t> potential,min_cost;\n    vector<int> prevv,preve;//点，辺\n \n    PrimalDual(int V):graph(V),TINF(numeric_limits<cost_t>::max()){}\n \n    void add_edge(int from,int to,flow_t cap,cost_t cost){\n        graph[from].push_back((edge){to,cap,cost,(int)graph[to].size(),false});\n        graph[to].push_back((edge){from,0,-cost,(int)graph[from].size()-1,true});\n    }\n \n    cost_t min_cost_flow(int s,int t,flow_t f){\n        int V=(int)graph.size();\n        cost_t ret=0;\n        using Pi=pair<cost_t,int>;\n        priority_queue<Pi,vector<Pi>,greater<Pi>> que;\n        potential.assign(V,0);\n        preve.assign(V,-1);\n        prevv.assign(V,-1);\n \n        while(f>0){\n            min_cost.assign(V,TINF);\n            que.emplace(0,s);\n            min_cost[s]=0;\n            //dijkstraパート\n            while(!que.empty()){\n                Pi p=que.top();que.pop();\n                if(min_cost[p.second]<p.first) continue;\n                for(int i=0;i<graph[p.second].size();i++){\n                    edge &e=graph[p.second][i];\n                    cost_t nextCost=min_cost[p.second]+e.cost+potential[p.second]-potential[e.to];\n                    if(e.cap>0 and min_cost[e.to]>nextCost){\n                        min_cost[e.to]=nextCost;\n                        prevv[e.to]=p.second,preve[e.to]=i;\n                        que.emplace(min_cost[e.to],e.to);\n                    }\n                }\n            }\n            if(min_cost[t]==TINF) return -1;\n            //dijkstraの結果に応じてpotentialを上げ下げ\n            for(int v=0;v<V;v++)potential[v]+=min_cost[v];\n            flow_t addflow=f;\n            for(int v=t;v!=s;v=prevv[v]){\n                addflow=min(addflow,graph[prevv[v]][preve[v]].cap);\n            }\n            f-=addflow;\n            ret+=addflow*potential[t];//天才じゃん\n            for(int v=t;v!=s;v=prevv[v]){\n                edge &e=graph[prevv[v]][preve[v]];\n                e.cap-=addflow;\n                graph[v][e.rev].cap+=addflow;\n            }\n        }\n        return ret;\n    }\n \n    void output(){\n        for(int i=0;i<graph.size();i++){\n            for(auto &e:graph[i]){\n                if(e.isrev)continue;\n                auto &rev_e=graph[e.to][e.rev];\n                cout<<i<<\"->\"<<e.to<<\" (flow: \"<<rev_e.cap<<\" / \"<<rev_e.cap+e.cap<<\")\"<<endl;\n            }\n        }\n    }\n};\n \n\n\n\nint n;\n\nstruct Box{\n    vector<int> p;\n    int v;\n    Box(int x,int y,int z){\n        p.resize(3);\n        p[0]=x,p[1]=y,p[2]=z;\n        sort(ALL(p));\n        v=x*y*z;\n    }\n    Box(){}\n};\n\n// can a cover b?\nbool cover(Box a,Box b){\n    rep(i,3){\n        if(not(a.p[i]>b.p[i])) return false;\n    }\n    return true;\n}\n\nvoid solve(){\n    vector<Box> v(n);\n    ll res=0;\n    rep(i,n){\n        int x,y,z;cin>>x>>y>>z;\n        v[i]=Box(x,y,z);\n        res+=v[i].v;\n    }\n\n    PrimalDual<int,int> flow(2*n+2);\n    int src=2*n,sink=2*n+1;\n    flow.add_edge(src,sink,n,0);\n    rep(i,n){\n        flow.add_edge(src,i,1,0);\n        flow.add_edge(n+i,sink,1,0);\n    }\n\n    rep(i,n){\n        rep(j,n){\n            if(cover(v[i],v[j])){\n                flow.add_edge(i,n+j,1,-v[j].v);\n            }\n        }\n    }\n    cout<<res+flow.min_cost_flow(src,sink,n)<<endl;\n}\n\nsigned main(){\n    while(cin>>n,n) solve();\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\nconstexpr int INF = numeric_limits<int>::max()/2;\nconstexpr long long LINF = numeric_limits<long long>::max()/3;\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os, const map<T,U>& mp){ os << \"{\"; for(auto& p : mp){ os << p << \",\"; } os << \"}\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const set<T>& st){ os<<\"{\"; for(T v:st) os<<v<<\",\"; os <<\"}\"; return os; }\ntemplate<typename T,typename U> inline void chmax(T &x,U y){ if(y>x) x = y; }\ntemplate<typename T,typename U> inline void chmin(T &x,U y){ if(y<x) x = y; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\n//constexpr double eps = 1e-14; \nconstexpr double eps = 1e-10; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nstruct MinCostFlow{/*{{{*/\n    const int inf = std::numeric_limits<int>::max()/2;\n    struct edge{\n        int to,cap,cost,rev;\n        edge(){}\n        edge(int t,int ca,int co,int r) : to(t),cap(ca),cost(co),rev(r){}\n    };\n\n    int V;  // # of node \n    vector<vector<edge>> G;\n    MinCostFlow(){}\n    MinCostFlow(int V_){ init(V_); }\n\n    void init(int V_){\n        V = V_;\n        G.resize(V);\n    }\n\n    void add_edge(int from,int to,int cap,int cost){\n        G[from].emplace_back(to,cap,cost,G[to].size());\n        G[to].emplace_back(from,0,-cost,G[from].size()-1);\n    }\n\n    // s->tに向かって流量f流すときの最小費用\n    // もしs->tに向かってf流せない場合は-1\n    int min_cost_flow(int s,int t,int f){\n        int res=0;\n        vector<int> dist(V,inf);\n        vector<int> prevv(V),preve(V);\n        while(f>0){\n            dist.assign(V,inf);\n            dist[s] = 0;\n            bool update=true;\n            while(update){\n                update=false;\n                for(int v=0;v<V;v++){\n                    if(dist[v]==inf) continue;\n                    for(int i=0;i<(int)G[v].size();i++){\n                        edge &e = G[v][i];\n                        if(e.cap>0 and dist[e.to] > dist[v]+e.cost){\n                            dist[e.to] = dist[v] + e.cost;\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }\n\n            if(dist[t] == inf) return inf;   // 流量fを流すことは不可能\n\n            int d = f;\n            for(int v=t;v!=s;v=prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n            f -= d;\n            res += d * dist[t];\n            for(int v=t;v!=s;v=prevv[v]){\n                edge &e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};/*}}}*/\n\nbool ok(vector<int>& a,vector<int>& b){\n    for(int i=0;i<(int)a.size();i++){\n        if(a[i] <= b[i]) return false;\n    }\n    return true;\n}\n\n\nvoid solve(int N){\n    vector<vector<int>> box(N,vector<int>(3,0));\n    rep(i,N){\n        rep(j,3) cin >> box[i][j];\n        sort(all(box[i]));\n    }\n\n    MinCostFlow graph(2*N+2);\n    int SOURCE = 2*N;\n    int SINK = 2*N+1;\n\n    rep(i,N) rep(j,N) {\n        if(ok(box[i],box[j])){\n            int t = -1;\n            rep(k,3) t *= box[j][k];\n            graph.add_edge(i,j+N,1,t);\n        }\n    }\n    rep(i,N){\n        graph.add_edge(i,SINK,1,0);\n        graph.add_edge(SOURCE,i,1,0);\n        graph.add_edge(i+N,SINK,1,0);\n    }\n\n\n    int t = graph.min_cost_flow(SOURCE,SINK,N);\n    int sum = 0;\n    for(int i=0;i<N;i++) sum += box[i][0] * box[i][1] * box[i][2];\n    cout << sum + t << endl;\n}\n\nint main(){\n    while(1){\n        int N; cin >> N;\n        if(N == 0)break;\n        solve(N);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_B&lang=jp\n\n#include <iostream>\n#include <map>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, int>P;\n\nclass MCF{\npublic:\n\tclass edge{\n\tpublic:\n\t\tint to, cap, cost, rev;\n\t\tedge(){};\n\t\tedge(int _to, int _cap, int _cost, int _rev){\n\t\t\tto = _to;\n\t\t\tcap = _cap;\n\t\t\tcost = _cost;\n\t\t\trev = _rev;\n\t\t}\n\t};\n\n\tvector<vector<edge> >G;\n\tvector<int>h;\n\tvector<int>dist;\n\tvector<int>prevv;\n\tvector<int>preve;\n\tMCF(int n){\n\t\tG.resize(n);\n\t\tpreve.resize(n, 0);\n\t\tprevv.resize(n, 0);\n\t}\n\tvoid addEdge(int from, int to, int cap, int cost){\n\t\tG[from].push_back(edge(to, cap, cost, G[to].size()));\n\t\tG[to].push_back(edge(from, 0, -cost, G[from].size() - 1));\n\t}\n\tint flow(int s, int t, int f){\n\t\tint res = 0;\n\t\th.clear();\n\t\th.resize(G.size(), 0);\n\t\twhile (f > 0){\n\t\t\tpriority_queue<P, vector<P>, greater<P> >que;\n\t\t\tdist.clear();\n\t\t\tdist.resize(G.size(), 1145141919);\n\t\t\tdist[s] = 0;\n\t\t\tque.push(P(0, s));\n\t\t\twhile (!que.empty()){\n\t\t\t\tP p = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++){\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push(P(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == 1145141919){\n\t\t\t\treturn res;\n                return -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < G.size(); v++)h[v] += dist[v];\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]){\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]){\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main(){\n\n    for(int n;cin>>n,n;){\n        MCF mcf(202);\n        vector<vector<int> >mt(n);\n        vector<int>vol(n, 1);\n        int sum = 0;\n        for(int i=0;i<n;i++){\n            for(int j = 0; j< 3;j++){\n                int tmp;\n                cin>>tmp;\n                mt[i].push_back(tmp);\n                vol[i]*=tmp;\n            }\n            sort(mt[i].begin(), mt[i].end());\n            sum += vol[i];\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                int f = 0;\n                for(int k = 0; k < 3; k++){\n                    if(mt[i][k] >= mt[j][k])f=1;\n                }\n                if(f)continue;\n                mcf.addEdge(i, 100+j, 1, -vol[i]);\n            }\n            mcf.addEdge(200, i, 1, 0);\n            mcf.addEdge(100+i, 201, 1, 0);\n        }\n        cout<<sum + mcf.flow(200, 201, 100)<<endl;\n    }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\n\nstruct Edge{\n\tllint to, cost;\n\tEdge(){}\n\tEdge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint N;\nllint L[105][3];\nvector<Edge> g[105];\n\nllint volume(llint x)\n{\n\tllint ret = 1;\n\tfor(llint i = 0; i < 3; i++) ret *= L[x][i];\n\treturn ret;\n}\n\nbool compare(llint x, llint y)\n{\n\tfor(llint i = 0; i < 3; i++){\n\t\tif(L[x][i] <= L[y][i]) return false;\n\t}\n\treturn true;\n}\n\n\nstruct edge{\n\tllint to, cap, cost, rev;\n\tedge(){}\n\tedge(llint a, llint b, llint c, llint d){\n\t\tto = a, cap = b, cost = c, rev = d;\n\t}\n};\n\n\nllint S, T;\nvector<edge> G[205];\nllint dist[205];\nllint prevv[205], preve[205];\n\nvoid BellmanFord()\n{\n\tfor(llint i = 0; i <= T; i++) dist[i] = inf;\n\tdist[S] = 0, prevv[S] = -1;\n\t\n\tbool update = true;\n\twhile(update){\n\t\tupdate = false;\n\t\tfor(llint i = 0; i <= T; i++){\n\t\t\tfor(llint j = 0; j < G[i].size(); j++){\n\t\t\t\tif(G[i][j].cap == 0) continue;\n\t\t\t\tif(dist[G[i][j].to] > dist[i] + G[i][j].cost){\n\t\t\t\t\tdist[G[i][j].to] = dist[i] + G[i][j].cost;\n\t\t\t\t\tprevv[G[i][j].to] = i;\n\t\t\t\t\tpreve[G[i][j].to] = j;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid add_edge(llint from, llint to, llint cap, llint cost)\n{\n\tG[from].push_back( edge(to, cap, cost, G[to].size()) );\n\tG[to].push_back( edge(from, 0, -cost, G[from].size()-1) );\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tfor(llint i = 0; i < N; i++){\n\t\t\tfor(llint j = 0; j < 3; j++){\n\t\t\t\tcin >> L[i][j];\n\t\t\t}\n\t\t\tsort(L[i], L[i]+3);\n\t\t}\n\t\t\n\t\tfor(llint i = 0; i < N; i++) g[i].clear();\n\t\tfor(llint i = 0; i < N; i++){\n\t\t\tfor(llint j = 0; j < N; j++){\n\t\t\t\tif(compare(i, j)){\n\t\t\t\t\tg[i].push_back(Edge(j, volume(j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tS = 2*N+1, T = 2*N+2;\n\t\tfor(llint i = 0; i <= T; i++) G[i].clear();\n\t\tfor(llint i = 0; i < N; i++){\n\t\t\tfor(llint j = 0; j < g[i].size(); j++){\n\t\t\t\tadd_edge(i, N+g[i][j].to, inf, -g[i][j].cost);\n\t\t\t}\n\t\t}\n\t\tfor(llint i = 0; i < N; i++){\n\t\t\tadd_edge(S, i, 1, 0);\n\t\t\tadd_edge(i+N, T, 1, 0);\n\t\t}\n\t\t\n\t\tllint ans = 0;\n\t\twhile(1){\n\t\t\tBellmanFord();\n\t\t\tif(dist[T] >= inf / 2) break;\n\t\t\t\n\t\t\tllint p = T, flow = N;\n\t\t\twhile(prevv[p] != -1){\n\t\t\t\tflow = min(flow, G[prevv[p]][preve[p]].cap);\n\t\t\t\tp = prevv[p];\n\t\t\t}\n\t\t\t\n\t\t\tp = T;\n\t\t\twhile(prevv[p] != -1){\n\t\t\t\tG[prevv[p]][preve[p]].cap -= flow;\n\t\t\t\tG[p][G[prevv[p]][preve[p]].rev].cap += flow;\n\t\t\t\tp = prevv[p];\n\t\t\t}\n\t\t\tans += dist[T] * flow;\n\t\t}\n\t\t\n\t\tllint sum = 0;\n\t\tfor(llint i = 0; i < N; i++) sum += volume(i);\n\t\tans = sum + ans;\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing W = ll;\nusing edge = struct {int to, rev; W cap, flow, cost;};\nusing G = vector<vector<edge>>;\n\nvoid add_edge(G &graph, int from, int to, W cap, W cost) {\n    graph[from].push_back({to, int(graph[to].size()) , cap , 0 , cost});\n    graph[to].push_back({from, int(graph[from].size()) - 1, 0 , 0, -cost});\n}\n\nW primal_dual(G &graph, int s, int t, int f) {\n    const W inf = 1LL << 50;\n    W res = 0;\n    while (f) {\n        int n = graph.size(), update;\n        vector<W> dist(n, inf);\n        vector<int> pv(n, 0), pe(n, 0);\n        dist[s] = 0;\n\n        rep(loop, n) {\n            update = false;\n            rep(v, n)rep(i, graph[v].size()) {\n                edge &e = graph[v][i];\n                if (e.cap > e.flow and chmin(dist[e.to], dist[v] + e.cost)) {\n                    pv[e.to] = v, pe[e.to] = i;\n                    update = true;\n\n                }\n            }\n            if (!update) break;\n        }\n\n        if (dist[t] == inf) return -1;\n\n        W d = f;\n\n        for (int v = t; v != s; v = pv[v]){\n            chmin(d, graph[pv[v]][pe[v]].cap - graph[pv[v]][pe[v]].flow);\n        }\n\n        f -= d, res += d * dist[t];\n\n        for (int v = t; v != s; v = pv[v]) {\n            edge &e = graph[pv[v]][pe[v]];\n            e.flow += d;\n            graph[v][e.rev].flow -= d;\n        }\n    }\n    return res;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vector<vi> dolls(n, vi(3));\n        vi V(n);\n        rep(i, n){\n            auto& e = dolls[i];\n            cin >> e[0] >> e[1] >> e[2];\n            sort(_all(e));\n            V[i] = e[0] * e[1] * e[2];\n        }\n        G g(2 * n + 2);\n\n        rep(i, n){\n            rep(j, n){\n                bool ok = true;\n                rep(k, 3){\n                    if(dolls[i][k] >= dolls[j][k]) ok = false;\n                }\n                if(ok){\n                    add_edge(g, 2 * i + 1, 2 * j, n, -V[i]);\n                }\n            }\n        }\n        int s = 2 * n, t = s + 1;\n        rep(i, n){\n            add_edge(g, s, 2 * i + 1, 1, V[i]);\n            add_edge(g, 2 * i + 1, t, n, 0);\n            add_edge(g, 2 * i, 2 * i + 1, 1, 0);\n        }\n\n        cout << primal_dual(g, s, t, n) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define inf 1e9\n\nusing namespace std;\n\nstruct Edge{\n\tint to, cost;\n\tEdge(){}\n\tEdge(int a, int b){\n\t\tto = a, cost = b;\n\t}\n};\n\nint N;\nint L[105][3];\nvector<Edge> g[105];\n\nint volume(int x)\n{\n\tint ret = 1;\n\tfor(int i = 0; i < 3; i++) ret *= L[x][i];\n\treturn ret;\n}\n\nbool compare(int x, int y)\n{\n\tfor(int i = 0; i < 3; i++){\n\t\tif(L[x][i] <= L[y][i]) return false;\n\t}\n\treturn true;\n}\n\n\nstruct edge{\n\tint to, cap, cost, rev;\n\tedge(){}\n\tedge(int a, int b, int c, int d){\n\t\tto = a, cap = b, cost = c, rev = d;\n\t}\n};\n\n\nint S, T;\nvector<edge> G[205];\nint dist[205];\nint prevv[205], preve[205];\n\nvoid BellmanFord()\n{\n\tfor(int i = 0; i <= T; i++) dist[i] = inf;\n\tdist[S] = 0, prevv[S] = -1;\n\t\n\tbool update = true;\n\twhile(update){\n\t\tupdate = false;\n\t\tfor(int i = 0; i <= T; i++){\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\tif(G[i][j].cap == 0) continue;\n\t\t\t\tif(dist[G[i][j].to] > dist[i] + G[i][j].cost){\n\t\t\t\t\tdist[G[i][j].to] = dist[i] + G[i][j].cost;\n\t\t\t\t\tprevv[G[i][j].to] = i;\n\t\t\t\t\tpreve[G[i][j].to] = j;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n\tG[from].push_back( edge(to, cap, cost, G[to].size()) );\n\tG[to].push_back( edge(from, 0, -cost, G[from].size()-1) );\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\tcin >> L[i][j];\n\t\t\t}\n\t\t\tsort(L[i], L[i]+3);\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++) g[i].clear();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(compare(i, j)){\n\t\t\t\t\tg[i].push_back(Edge(j, volume(j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*for(int i = 0; i < N; i++){\n\t\t\tcout << \"* \";\n\t\t\tfor(int j = 0; j < g[i].size(); j++){\n\t\t\t\tcout << g[i][j].to << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\t\n\t\tS = 2*N+1, T = 2*N+2;\n\t\tfor(int i = 0; i <= T; i++) G[i].clear();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < g[i].size(); j++){\n\t\t\t\tadd_edge(i, N+j, inf, -g[i][j].cost);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tadd_edge(S, i, 1, 0);\n\t\t\tadd_edge(i+N, T, 1, 0);\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\twhile(1){\n\t\t\tBellmanFord();\n\t\t\tif(dist[T] >= inf / 2) break;\n\t\t\t\n\t\t\tint p = T, flow = N;\n\t\t\twhile(prevv[p] != -1){\n\t\t\t\tflow = min(flow, G[prevv[p]][preve[p]].cap);\n\t\t\t\tp = prevv[p];\n\t\t\t}\n\t\t\t\n\t\t\tp = T;\n\t\t\twhile(prevv[p] != -1){\n\t\t\t\tG[prevv[p]][preve[p]].cap -= flow;\n\t\t\t\tG[p][G[prevv[p]][preve[p]].rev].cap += flow;\n\t\t\t\tp = prevv[p];\n\t\t\t}\n\t\t\tans += dist[T] * flow;\n\t\t}\n\t\t\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < N; i++) sum += volume(i);\n\t\tans = sum + ans;\n\t\tcout << ans << endl;;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstruct Edge {\n\tint to;\n\n\tint64_t cost;\n\tint64_t capacity;\n\tint rev_i;\n};\n\nusing EdgeVec = std::vector<Edge>;\nusing EdgeLists = std::vector<EdgeVec>;\n\n///////////////\n// 最小費用流 //\n///////////////\n\nclass MinCostFlow {\nprivate:\n\tconst int64_t inf_{LLONG_MAX};\n\n\tEdgeLists edges;\n\tconst int source_, sink_;\n\tstd::vector<int64_t> distance_;\n\tstd::vector<bool> visited_;\n\n\tvoid calcDistance()\n\t{\n\t\tstd::fill(distance_.begin(), distance_.end(), inf_);\n\t\tdistance_[source_] = 0;\n\t\tstd::queue<std::pair<int, int64_t>> que;\n\t\tque.push({source_, 0});\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tauto now{que.front()};\n\t\t\tque.pop();\n\t\t\tif (now.second > distance_[now.first]) continue;\n\t\t\tfor (Edge& edge: edges[now.first])\n\t\t\t\tif (edge.capacity > 0 && distance_[now.first] + edge.cost < distance_[edge.to])\n\t\t\t\t{\n\t\t\t\t\tdistance_[edge.to] = distance_[now.first] + edge.cost;\n\t\t\t\t\tque.push({edge.to, distance_[edge.to]});\n\t\t\t\t}\n\t\t}\n\t}\n\n\tint64_t calcCapacity(const int index, const int64_t flow)\n\t{\n\t\tif (index == source_) return flow;\n\t\tvisited_[index] = true;\n\t\tfor (Edge& prev_node: edges[index])\n\t\t{\n\t\t\tEdge& rev_edge{edges[prev_node.to][prev_node.rev_i]};\n\t\t\tif (visited_[prev_node.to] || rev_edge.capacity == 0 || distance_[prev_node.to] + rev_edge.cost != distance_[index]) continue;\n\t\t\tconst int64_t additional_flow{calcCapacity(prev_node.to, std::min(flow, rev_edge.capacity))};\n\t\t\tif (additional_flow == 0) continue;\n\t\t\tprev_node.capacity += additional_flow;\n\t\t\trev_edge.capacity -= additional_flow;\n\t\t\treturn additional_flow;\n\t\t}\n\t\treturn 0;\n\t}\n\npublic:\n\tMinCostFlow(const int node_num, const int source, const int sink)\n\t\t: edges(node_num), distance_(node_num), visited_(node_num), source_(source), sink_(sink) {}\n\t\n\tvoid addEdge(const int from, const int to, const int64_t cost, const int capacity)\n\t{\n\t\tedges[from].push_back({to, cost, capacity, (int)edges[to].size()});\n\t\tedges[to].push_back({from, -cost, 0, (int)edges[from].size() - 1});\n\t}\n\n\tint64_t operator()(const int64_t flow)\n\t{\n\t\tint64_t min_cost{};\n\t\tfor (int64_t flow_rest{flow}; flow_rest > 0;)\n\t\t{\n\t\t\tcalcDistance();\n\t\t\tif (distance_[sink_] == inf_) return inf_;\n\t\t\tstd::fill(visited_.begin(), visited_.end(), false);\n\t\t\tint64_t additional_flow{calcCapacity(sink_, flow_rest)};\n\t\t\tflow_rest -= additional_flow;\n\t\t\tmin_cost += additional_flow * distance_[sink_];\n\t\t}\n\t\treturn min_cost;\n\t}\n};\n\n\nclass Solve {\nprivate:\n\tusing i3 = std::array<int64_t, 3>;\n\tstd::vector<i3> xyz;\n\n\tbool canContain(int in, int out)\n\t{\n\t\tfor (int i{}; i < 3; i++)\n\t\t\tif (xyz[in][i] >= xyz[out][i])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tint64_t calcVolume(int index)\n\t{\n\t\tint64_t ret{1};\n\t\tfor (int i{}; i < 3; i++)\n\t\t\tret *= xyz[index][i];\n\t\treturn ret;\n\t}\n\npublic:\n\tbool is_last_query_{};\n\tSolve()\n\t{\n\t\tint N;\n\t\tscanf(\"%d\", &N);\n\t\tif (N == 0)\n\t\t{\n\t\t\tis_last_query_ = true;\n\t\t\treturn;\n\t\t}\n\t\txyz.resize(N);\n\t\tfor (auto& e: xyz)\n\t\t{\n\t\t\tfor (auto& f: e) scanf(\"%lld\", &f);\n\t\t\tstd::sort(e.begin(), e.end());\n\t\t}\n\t\tMinCostFlow minCostFlow(2 * N + 2, 0, 2 * N + 1);\n\t\tfor (int i{}; i < N; i++)\n\t\t{\n\t\t\tminCostFlow.addEdge(0, 1 + i, -calcVolume(i), 1);\n\t\t\tminCostFlow.addEdge(N + 1 + i, 2 * N + 1, 0, 1);\n\t\t}\n\t\tminCostFlow.addEdge(0, 2 * N + 1, 0, N);\n\t\tfor (int i{}; i < N; i++)\n\t\t\tfor (int j{}; j < N; j++)\n\t\t\t\tif (canContain(i, j))\n\t\t\t\t\tminCostFlow.addEdge(1 + i, N + 1 + j, 0, 1);\n\n\t\tint64_t ans{};\n\t\tfor (int i{}; i < N; i++) ans += calcVolume(i);\n\t\tans += minCostFlow(N);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n};\n\n\nint main()\n{\n\twhile (!Solve().is_last_query_);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nstruct Primal_Dual\n{\n  const int INF = 1 << 30;\n  typedef pair< int, int > Pi;\n \n  struct edge\n  {\n    int to, cap, cost, rev;\n  };\n  vector< vector< edge > > graph;\n  vector< int > potential, min_cost, prevv, preve;\n \n  Primal_Dual(int V) : graph(V) {}\n \n  void add_edge(int from, int to, int cap, int cost)\n  {\n    graph[from].push_back((edge) {to, cap, cost, (int) graph[to].size()});\n    graph[to].push_back((edge) {from, 0, -cost, (int) graph[from].size() - 1});\n  }\n \n  int min_cost_flow(int s, int t, int f)\n  {\n    int V = graph.size(), ret = 0;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n \n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.push(Pi(0, s));\n      min_cost[s] = 0;\n \n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          int nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.push(Pi(min_cost[e.to], e.to));\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      int addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};\n \nvoid solve()\n{\n  int N;\n  cin >> N;\n  if(N == 0) return;\n  int X[100][3];\n  int sub = 0;\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < 3; j++) cin >> X[i][j];\n    sub += X[i][0] * X[i][1] * X[i][2];\n    sort(X[i], X[i] + 3);\n  }\n  Primal_Dual flow(N + N + 2);\n  for(int i = 0; i < N; i++) {\n    for(int j = 0; j < N; j++) {\n      bool check = true;\n      for(int k = 0; k < 3; k++) if(X[i][k] >= X[j][k]) check = false;\n      if(check) {\n        flow.add_edge(i, N + j, 1, X[i][0] * X[i][1] * X[i][2] * -1);\n      }\n    }\n  }\n  int S = N + N, T = N + N + 1;\n  for(int i = 0; i < N; i++) flow.add_edge(S, i, 1, 0);\n  for(int i = 0; i < N; i++) flow.add_edge(i + N, T, 1, 0);\n  for(int i = 0; i < N; i++) flow.add_edge(i, T, 1, 0);\n  cout << sub + flow.min_cost_flow(S, T, N) << endl;\n  solve();\n}\n \nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i = (a);i < (b);i++)\n#define RFOR(i,a,b) for(int i = (b)-1;i >= (a);i--)\n#define REP(i,n) FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define pb push_back\n#define mp make_pair\n#define ft first\n#define sd second\n\n#define MAX_N 100\n#define INF (1<<20)\n\nint N;\nint x[MAX_N], y[MAX_N], z[MAX_N], m[MAX_N];\n\nbool input(){\n  cin>>N;\n  int a[3];\n  REP(i, N) {\n    cin>>a[0]>>a[1]>>a[2];\n    sort(a, a+3);\n    x[i] = a[0];\n    y[i] = a[1];\n    z[i] = a[2];\n    m[i] = x[i]*y[i]*z[i];\n  }\n  return N!=0;\n}\n\n#define MAX_V 204\nstruct edge { int to, cap, cost, rev; };\nint V; // ????????°\nvector<edge> G[MAX_V]; // ??°???????????£??\\???????????¨???\nint h[MAX_V]; // ??????????????£???\nint dist[MAX_V]; // ???????????¢\nint prevv[MAX_V], preve[MAX_V]; // ??´??????????????¨???\n// from??????to??????????????????cap????????????cost???????????°?????????????????????\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n// s??????t????????????f???????°??????¨???????±???????\n// ??????????????´??????-1?????????\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    fill(h, h + V, 0); // h????????????\n    while (f > 0) {\n        // ??????????????????????????¨??????h?????´??°??????\n        priority_queue<P, vector<P>, greater<P> > que;\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        que.push(P(0, s));\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (int i = 0; i < G[v].size(); i++) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == INF) {\n            // ????????\\???????????????\n            return -1;\n        }\n        for (int v = 0; v < V; v++) h[v] += dist[v];\n        // s-t????????????????????£??????????????????\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nvoid resetG(int ver){\n  V = ver;\n  REP(i,V)G[i].clear();//while(!G[i].empty()) G[i].pop_back();\n}\n\nvoid solve(){\n resetG(N * 2 + 2);\n REP(i,N){\n   REP(j,N){\n     if(i == j)\n       continue;\n     if(x[i] > x[j] && y[i] > y[j] && z[i] > z[j])\n       add_edge(j,i + N, 1, 0);\n   }\n   add_edge(V-2, i, 1, 0);\n   add_edge(i+N, V-1, 1, 0);\n   add_edge(i, V-1, 1, m[i]);\n }\n cout<<min_cost_flow(V-2, V-1,N)<<endl;\n}\n\nint main(){\n  cin.tie(0);\n\n  while (input()){\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\n\nstruct Edge{\n\tllint to, cost;\n\tEdge(){}\n\tEdge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint N;\nllint L[105][3];\nvector<Edge> g[105];\n\nllint volume(llint x)\n{\n\tllint ret = 1;\n\tfor(llint i = 0; i < 3; i++) ret *= L[x][i];\n\treturn ret;\n}\n\nbool compare(llint x, llint y)\n{\n\tfor(llint i = 0; i < 3; i++){\n\t\tif(L[x][i] <= L[y][i]) return false;\n\t}\n\treturn true;\n}\n\n\nstruct edge{\n\tllint to, cap, cost, rev;\n\tedge(){}\n\tedge(llint a, llint b, llint c, llint d){\n\t\tto = a, cap = b, cost = c, rev = d;\n\t}\n};\n\n\nllint S, T;\nvector<edge> G[205];\nllint dist[205];\nllint prevv[205], preve[205];\n\nvoid BellmanFord()\n{\n\tfor(llint i = 0; i <= T; i++) dist[i] = inf;\n\tdist[S] = 0, prevv[S] = -1;\n\t\n\tbool update = true;\n\twhile(update){\n\t\tupdate = false;\n\t\tfor(llint i = 0; i <= T; i++){\n\t\t\tfor(llint j = 0; j < G[i].size(); j++){\n\t\t\t\tif(G[i][j].cap == 0) continue;\n\t\t\t\tif(dist[G[i][j].to] > dist[i] + G[i][j].cost){\n\t\t\t\t\tdist[G[i][j].to] = dist[i] + G[i][j].cost;\n\t\t\t\t\tprevv[G[i][j].to] = i;\n\t\t\t\t\tpreve[G[i][j].to] = j;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid add_edge(llint from, llint to, llint cap, llint cost)\n{\n\tG[from].push_back( edge(to, cap, cost, G[to].size()) );\n\tG[to].push_back( edge(from, 0, -cost, G[from].size()-1) );\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tfor(llint i = 0; i < N; i++){\n\t\t\tfor(llint j = 0; j < 3; j++){\n\t\t\t\tcin >> L[i][j];\n\t\t\t}\n\t\t\tsort(L[i], L[i]+3);\n\t\t}\n\t\t\n\t\tfor(llint i = 0; i < N; i++) g[i].clear();\n\t\tfor(llint i = 0; i < N; i++){\n\t\t\tfor(llint j = 0; j < N; j++){\n\t\t\t\tif(compare(i, j)){\n\t\t\t\t\tg[i].push_back(Edge(j, volume(j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*for(llint i = 0; i < N; i++){\n\t\t\tcout << \"* \";\n\t\t\tfor(llint j = 0; j < g[i].size(); j++){\n\t\t\t\tcout << g[i][j].to << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\t\n\t\tS = 2*N+1, T = 2*N+2;\n\t\tfor(llint i = 0; i <= T; i++) G[i].clear();\n\t\tfor(llint i = 0; i < N; i++){\n\t\t\tfor(llint j = 0; j < g[i].size(); j++){\n\t\t\t\tadd_edge(i, N+j, inf, -g[i][j].cost);\n\t\t\t}\n\t\t}\n\t\tfor(llint i = 0; i < N; i++){\n\t\t\tadd_edge(S, i, 1, 0);\n\t\t\tadd_edge(i+N, T, 1, 0);\n\t\t}\n\t\t\n\t\tllint ans = 0;\n\t\twhile(1){\n\t\t\tBellmanFord();\n\t\t\tif(dist[T] >= 1e9) break;\n\t\t\t\n\t\t\tllint p = T, flow = N;\n\t\t\twhile(prevv[p] != -1){\n\t\t\t\tflow = min(flow, G[prevv[p]][preve[p]].cap);\n\t\t\t\tp = prevv[p];\n\t\t\t}\n\t\t\t\n\t\t\tp = T;\n\t\t\twhile(prevv[p] != -1){\n\t\t\t\tG[prevv[p]][preve[p]].cap -= flow;\n\t\t\t\tG[p][G[prevv[p]][preve[p]].rev].cap += flow;\n\t\t\t\tp = prevv[p];\n\t\t\t}\n\t\t\tans += dist[T] * flow;\n\t\t}\n\t\t\n\t\tllint sum = 0;\n\t\tfor(llint i = 0; i < N; i++) sum += volume(i);\n\t\tans = sum + ans;\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\n// (行き先, 容量, コスト, 逆辺)\nstruct edge{ int to,cap,cost,rev; };\n\nint V; // TODO:initialize\nconst int MAX_V = 222; // TODO:initialize\nconst int INF = 12345678; // TODO:initialize\nvector<edge> G[MAX_V];\nint h[MAX_V]; // ポテンシャル\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V]; // 直前の頂点と辺\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].pb({to,cap,cost,(int)G[to].size()});\n    G[to].pb({from,0,-cost,(int)G[from].size()-1});\n}\n\n// sからtへの流量fの最小費用流(不可能なら-1)\nint min_cost_flow(int s, int t, int f, bool neg = false){\n    int res = 0;\n    fill(h,h+V,0);\n    while(f>0){\n        priority_queue<pi,vector<pi>,greater<pi>> pq;\n        fill(dist,dist+V,INF);\n        dist[s]=0;\n        if(neg)\n        {\n            // bellman-fordでhを更新\n            neg = false;\n            bool update;\n            do{\n                update = false;\n                rep(v,V){\n                    if(dist[v] == INF) continue;\n                    rep(i,G[v].size()){\n                        edge &e = G[v][i];\n                        if(e.cap>0 && dist[e.to]>dist[v]+e.cost){\n                            dist[e.to]=dist[v]+e.cost;\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }while(update);\n        }\n        else\n        {\n            // dijkstraでhを更新\n            pq.push(pi(0,s));\n            while(!pq.empty()){\n                pi p = pq.top();\n                pq.pop();\n                int v = p.se;\n                if(p.fi>dist[v]) continue;\n                rep(i,G[v].size()){\n                    edge &e = G[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        pq.push(pi(dist[e.to],e.to));\n                    }\n                }\n            }\n        }\n\n        // これ以上流せない\n        if(dist[t]==INF) return -1;\n\n        rep(v,V) h[v] += dist[v];\n\n        // s-t間の最短路に沿って目一杯流す\n        int d=f;\n        for(int v=t; v!=s; v=prevv[v]) d = min(d,G[prevv[v]][preve[v]].cap);\n        f -= d;\n        res += d*h[t];\n\n        for(int v=t; v!=s; v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        vector<vector<int>> a(n);\n        rep(i,n){\n            vector<int> v(3);\n            rep(j,3) cin >>v[j];\n            sort(all(v));\n            a[i] = v;\n        }\n\n        rep(i,MAX_V) G[i].clear();\n        V = 2*n+2;\n        int S = 2*n, T = S+1;\n\n        int ans = 0;\n        rep(i,n){\n            int vol = 1;\n            rep(j,3) vol *= a[i][j];\n\n            ans += vol;\n\n            rep(j,n){\n                bool ok = true;\n                rep(k,3) ok &= (a[i][k] < a[j][k]);\n                if(ok) add_edge(2*i+1,2*j,1,-vol);\n            }\n\n            add_edge(S,2*i,1,0);\n            add_edge(2*i,2*i+1,1,0);\n            add_edge(2*i+1,T,1,0);\n        }\n        add_edge(S,T,n,0);\n\n        cout << ans + min_cost_flow(S,T,n) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n#include<climits>\n#include<cstring>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\ntypedef long long ll;\n\nstruct Edge{\n  int to,cap,cost,rev;\n  Edge(int to=0,int cap=0,int cost=0,int rev=0):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\nconst int MAX_V = 300, IINF = INT_MAX;\nint V;\nvector<Edge> G[MAX_V];\nint h[MAX_V],dist[MAX_V],prevv[MAX_V],preve[MAX_V];\n\ninline void add_edge(int from,int to,int cap,int cost){\n  G[from].push_back(Edge(to,cap,cost,G[to].size()));\n  G[to].push_back(Edge(from,0,-cost,G[from].size()-1));\n}\n\nll min_cost_flow(int s,int t){\n  ll res = 0;\n  fill(h,h+V,0);\n  while(1){\n    priority_queue<ii,vector<ii>,greater<ii> > Q;\n    fill(dist,dist+V,IINF);\n    dist[s] = 0;\n    Q.push(ii(0,s));\n    while(!Q.empty()){\n      ii p = Q.top(); Q.pop();\n      int v = p.second;\n      if( dist[v] < p.first ) continue;\n      for(int i=0;i<G[v].size();i++){\n        Edge &e = G[v][i];\n        if( e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to] ) { \n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          Q.push(ii(dist[e.to],e.to));\n        }\n      }\n    }\n    //if( dist[t] == IINF ) break;\n    rep(v,V) h[v] += dist[v];\n    if( h[t] >= 0LL ) break;\n    ll d = IINF;\n    for(int v=t;v!=s;v=prevv[v]) d = min(d,(ll)G[prevv[v]][preve[v]].cap);\n    res += d * h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      Edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main() {\n  int n;\n  while( cin >> n, n ) {\n    vector<int> x(n),y(n),z(n);\n    int sum = 0;\n    rep(i,n) {\n      cin >> x[i] >> y[i] >> z[i];\n      sum += x[i] * y[i] * z[i];\n    }\n    int source = 2 * n, sink = 2 * n + 1;\n    V = sink + 1;\n    rep(i,V) G[i].clear();\n\n    rep(i,n) {\n      add_edge(source,i,1,0);\n      add_edge(n+i,sink,1,0);\n    }\n\n    auto check = [&](int s,int t) -> bool {\n      vector<int> v1(3),v2(3);\n      v1[0] = x[s], v1[1] = y[s], v1[2] = z[s];\n      v2[0] = x[t], v2[1] = y[t], v2[2] = z[t];\n      sort(v1.begin(),v1.end());\n      sort(v2.begin(),v2.end());\n      rep(i,3) if( v1[i] <= v2[i] ) return false;\n      return true;\n    };\n    \n    rep(i,n) {\n      rep(j,n) if( i != j ) {\n\tif( check(i,j) ) {\n\t  add_edge(i,n+j,1,-1*x[j]*y[j]*z[j]);\n\t}\n      }\n    }\n    cout << sum + min_cost_flow(source,sink) << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing W = ll;\nusing edge = struct {int to, rev; W cap, flow, cost;};\nusing G = vector<vector<edge>>;\n\nvoid add_edge(G &graph, int from, int to, W cap, W cost) {\n    graph[from].push_back({to, int(graph[to].size()) , cap , 0 , cost});\n    graph[to].push_back({from, int(graph[from].size()) - 1, 0 , 0, -cost});\n}\n\nW primal_dual(G &graph, int s, int t, int f) {\n    const W inf = 1LL << 50;\n    W res = 0;\n    while (f) {\n        int n = graph.size(), update;\n        vector<W> dist(n, inf);\n        vector<int> pv(n, 0), pe(n, 0);\n        dist[s] = 0;\n\n        rep(loop, n) {\n            update = false;\n            rep(v, n)rep(i, graph[v].size()) {\n                edge &e = graph[v][i];\n                if (e.cap > e.flow and chmin(dist[e.to], dist[v] + e.cost)) {\n                    pv[e.to] = v, pe[e.to] = i;\n                    update = true;\n\n                }\n            }\n            if (!update) break;\n        }\n\n        if (dist[t] == inf) return -1;\n\n        W d = f;\n\n        for (int v = t; v != s; v = pv[v]){\n            chmin(d, graph[pv[v]][pe[v]].cap - graph[pv[v]][pe[v]].flow);\n        }\n\n        f -= d, res += d * dist[t];\n\n        for (int v = t; v != s; v = pv[v]) {\n            edge &e = graph[pv[v]][pe[v]];\n            e.flow += d;\n            graph[v][e.rev].flow -= d;\n        }\n    }\n    return res;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    for(int n; cin >> n, n;){\n        vector<vi> dolls(n, vi(3));\n        vi V(n);\n        rep(i, n){\n            auto& e = dolls[i];\n            cin >> e[0] >> e[1] >> e[2];\n            sort(_all(e));\n            V[i] = e[0] * e[1] * e[2];\n        }\n        G g(2 * n + 2);\n\n        rep(i, n){\n            rep(j, n){\n                bool ok = true;\n                rep(k, 3){\n                    if(dolls[i][k] >= dolls[j][k]) ok = false;\n                }\n                if(ok){\n                    add_edge(g, 2 * i, 2 * j + 1, n, 0);\n                }\n            }\n        }\n        int s = 2 * n, t = s + 1;\n        rep(i, n){\n            add_edge(g, s, 2 * i, 1, 0);\n            add_edge(g, 2 * i + 1, t, 1, 0);\n            add_edge(g, 2 * i, t, n, V[i]);\n        }\n\n        cout << primal_dual(g, s, t, n) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// MOVED\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\n// 二部グラフの最大重みマッチング\nclass Hungarian {\n    int n, p, q;\n    vvi mat;\n    vi fx, fy, x, y;\n    const i64 INF = 1e9;\n\npublic:\n    Hungarian(const vvi& mat) : mat(mat) {\n        n = mat.size();\n        fx.assign(n, INF);\n        fy.assign(n, 0);\n        x.assign(n, -1);\n        y.assign(n, -1);\n    }\n\n    i64 run() {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                fx[i] = max(fx[i], mat[i][j]);\n            }\n        }\n\n        for (int i = 0; i < n;) {\n            vi t(n, -1), s(n + 1, i);\n            for (p = q = 0; p <= q && x[i] < 0; p++) {\n                for (int k = s[p], j = 0; j < n && x[i] < 0; j++) {\n                    if (fx[k] + fy[j] == mat[k][j] && t[j] < 0) {\n                        s[++q] = y[j];\n                        t[j] = k;\n                        if (s[q] < 0) {\n                            for (p = j; p >= 0; j = p) {\n                                y[j] = k = t[j];\n                                p = x[k];\n                                x[k] = j;\n                            }\n                        }\n                    }\n                }\n            }\n            if (x[i] < 0) {\n                i64 d = INF;\n                for (int k = 0; k <= q; k++) {\n                    for (int j = 0; j < n; j++) {\n                        if (t[j] < 0) {\n                            d = min(d, fx[s[k]] + fy[j] - mat[s[k]][j]);\n                        }\n                    }\n                }\n                for (int j = 0; j < n; j++) {\n                    fy[j] += (t[j] < 0 ? 0 : d);\n                }\n                for (int k = 0; k <= q; k++) {\n                    fx[s[k]] -= d;\n                }\n            } else {\n                i++;\n            }\n        }\n        i64 ret = 0;\n        for (int i = 0; i < n; i++) {\n            ret += mat[i][x[i]];\n        }\n        return ret;\n    }\n\n    int match_y(int k) {\n        return x[k];\n    }\n\n    int match_x(int k) {\n        return y[k];\n    }\n};\n\nint main() {\n    int n;\n    while (cin >> n) {\n        long long sum = 0;\n        vector<vector<int>> as(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 3; j++) {\n                int a;\n                cin >> a;\n                as[i].push_back(a);\n            }\n            sum += as[i][0] * as[i][1] * as[i][2];\n            sort(as[i].begin(), as[i].end());\n        }\n        vvi mat(n, vi(n));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                bool ok = true;\n                for (int k = 0; k < 3; k++) {\n                    if (as[i][k] >= as[j][k]) ok = false;\n                }\n                if (ok) {\n                    mat[i][j] = as[i][0] * as[i][1] * as[i][2];\n                }\n            }\n        }\n        Hungarian h(mat);\n        cout << sum - h.run() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\n// 二部グラフの最大重みマッチング\nclass Hungarian {\n    int n, p, q;\n    vvi mat;\n    vi fx, fy, x, y;\n    const i64 INF = 1e9;\n\npublic:\n    Hungarian(const vvi& mat) : mat(mat) {\n        n = mat.size();\n        fx.assign(n, INF);\n        fy.assign(n, 0);\n        x.assign(n, -1);\n        y.assign(n, -1);\n    }\n\n    i64 run() {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                fx[i] = max(fx[i], mat[i][j]);\n            }\n        }\n\n        for (int i = 0; i < n;) {\n            vi t(n, -1), s(n + 1, i);\n            for (p = q = 0; p <= q && x[i] < 0; p++) {\n                for (int k = s[p], j = 0; j < n && x[i] < 0; j++) {\n                    if (fx[k] + fy[j] == mat[k][j] && t[j] < 0) {\n                        s[++q] = y[j];\n                        t[j] = k;\n                        if (s[q] < 0) {\n                            for (p = j; p >= 0; j = p) {\n                                y[j] = k = t[j];\n                                p = x[k];\n                                x[k] = j;\n                            }\n                        }\n                    }\n                }\n            }\n            if (x[i] < 0) {\n                i64 d = INF;\n                for (int k = 0; k <= q; k++) {\n                    for (int j = 0; j < n; j++) {\n                        if (t[j] < 0) {\n                            d = min(d, fx[s[k]] + fy[j] - mat[s[k]][j]);\n                        }\n                    }\n                }\n                for (int j = 0; j < n; j++) {\n                    fy[j] += (t[j] < 0 ? 0 : d);\n                }\n                for (int k = 0; k <= q; k++) {\n                    fx[s[k]] -= d;\n                }\n            } else {\n                i++;\n            }\n        }\n        i64 ret = 0;\n        for (int i = 0; i < n; i++) {\n            ret += mat[i][x[i]];\n        }\n        return ret;\n    }\n\n    int match_y(int k) {\n        return x[k];\n    }\n\n    int match_x(int k) {\n        return y[k];\n    }\n};\n\nint main() {\n    int n;\n    while (cin >> n) {\n        if (n == 0) break;\n        long long sum = 0;\n        vector<vector<int>> as(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 3; j++) {\n                int a;\n                cin >> a;\n                as[i].push_back(a);\n            }\n            sum += as[i][0] * as[i][1] * as[i][2];\n            sort(as[i].begin(), as[i].end());\n        }\n        vvi mat(n, vi(n));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                bool ok = true;\n                for (int k = 0; k < 3; k++) {\n                    if (as[i][k] >= as[j][k]) ok = false;\n                }\n                if (ok) {\n                    mat[i][j] = as[i][0] * as[i][1] * as[i][2];\n                }\n            }\n        }\n        Hungarian h(mat);\n        cout << sum - h.run() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i = (a);i < (b);i++)\n#define RFOR(i,a,b) for(int i = (b)-1;i >= (a);i--)\n#define REP(i,n) FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define pb push_back\n#define mp make_pair\n#define ft first\n#define sd second\n\n#define MAX_N 100\n#define INF (1<<20)\n\nint N;\nint x[MAX_N], y[MAX_N], z[MAX_N], m[MAX_N];\n\nbool input(){\n  cin>>N;\n  int a[3];\n  REP(i, N) {\n    cin>>a[0]>>a[1]>>a[2];\n    sort(a, a+3);\n    x[i] = a[0];\n    y[i] = a[1];\n    z[i] = a[2];\n    m[i] = x[i]*y[i]*z[i];\n  }\n  return N!=0;\n}\n\n#define MAX_V 204\nstruct edge { int to, cap, cost, rev; };\nint V; // ????????°\nvector<edge> G[MAX_V]; // ??°???????????£??\\???????????¨???\nint dist[MAX_V]; // ???????????¢\nint prevv[MAX_V], preve[MAX_V]; // ??´??????????????¨???\n// from??????to??????????????????cap????????????cost???????????°?????????????????????\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n// s??????t????????????f???????°??????¨???????±???????\n// ??????????????´??????-1?????????\nint min_cost_flow(int s, int t, int f) {\n\n    int res = 0;\n    while (f > 0) {\n        // ???????????????????????????????????????s-t????????????????±???????\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        bool update = true;\n        while (update) {\n            update = false;\n            for (int v = 0; v < V; v++) {\n                if (dist[v] == INF) continue;\n                for (int i = 0; i < G[v].size(); i++) {\n                    edge &e = G[v][i];\n                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n        if (dist[t] == INF) {\n            // ????????\\???????????????\n            return -1;\n        }\n        // s-t????????????????????£??????????????????\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * dist[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nvoid resetG(int ver){\n  V = ver;\n  REP(i,V)G[i].clear();//while(!G[i].empty()) G[i].pop_back();\n//  REP(i,V){preve[i] = 0;prevv[i] = 0;}\n}\n\nvoid solve(){\n resetG(N * 2 + 2);\n REP(i,N){\n   REP(j,N){\n     if(i == j)\n       continue;\n     if(x[i] > x[j] && y[i] > y[j] && z[i] > z[j])\n       add_edge(j,i + N, 1, 0);\n   }\n   add_edge(V-2, i, 1, 0);\n   add_edge(i+N, V-1, 1, 0);\n   add_edge(i, V-1, 1, m[i]);\n }\n cout<<min_cost_flow(V-2, V-1,N)<<endl;\n}\n\nint main(){\n  cin.tie(0);\n\n  while (input()){\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define reps(i, n, m) for (int i = (int) (n); i < (int) (m); i++)\n#define rep(i, n) reps(i, 0, n)\n\nstruct edge {\n\tint to;\n\tint flow;\n\tint cost;\n\tint rev;\n\tedge(int a, int b, int c, int d) : to(a), flow(b), cost(c), rev(d) {}\n};\n\nint N;\nvector<vector<edge>> e;\nconst int INF = 1e9;\n\nvoid add_edge(int from, int to, int flow, int cost)\n{\n\te[from].emplace_back(to, flow, cost, e[to].size());\n\te[to].emplace_back(from, 0,  -cost, e[from].size()-1);\n}\n\nbool init()\n{\n\tcin >> N;\n\tif (N == 0) return false;\t\n\te.clear();\n\te.resize(N * 2 + 2);\n\tconst int S = N * 2;\n\tconst int G = N * 2 + 1;\n\tvector<tuple<int, int,int>> s;\n\trep(i, N) {\n\t\tadd_edge(S, i, 1, 0);\n\t\tint t = i + N;\n\t\tadd_edge(t, G, 1, 0);\n\t}\n\trep(i, N) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tvector<int> t{a, b, c};\n\t\tsort(t.begin(), t.end());\n\t\ts.emplace_back(t[0], t[1], t[2]);\n\t}\n\tsort(s.begin(), s.end());\n\trep(i, N) {\n\t\tint cost = get<0>(s[i]) * get<1>(s[i]) * get<2>(s[i]);\n\t\tadd_edge(i, G, 1, cost);\n\t\treps(j, i+1, N) {\n\t\t\tif (get<0>(s[i]) < get<0>(s[j]) &&\n\t\t\t\tget<1>(s[i]) < get<1>(s[j]) &&\n\t\t\t\tget<2>(s[i]) < get<2>(s[j])) {\n\t\t\t\tadd_edge(i, j + N, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n\nint min_cost_flow(int s, int t, int f, int V)\n{\n\tint res = 0;\n\tvector<int> dist(V, INF);\n\tvector<int> prevv(V);\n\tvector<int> preve(V);\n\twhile (f > 0) {\n\t\tfill(dist.begin(), dist.end(), INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile (update) {\n\t\t\tupdate = false;\n\t\t\trep(v, V) {\n\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\trep(i, e[v].size()) {\n\t\t\t\t\tedge& E = e[v][i];\n\t\t\t\t\tif (E.flow > 0 && dist[v] + E.cost < dist[E.to]) {\n\t\t\t\t\t\tdist[E.to] = dist[v] + E.cost;\n\t\t\t\t\t\tprevv[E.to] = v;\n\t\t\t\t\t\tpreve[E.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, e[prevv[v]][preve[v]].flow);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge& E = e[prevv[v]][preve[v]];\n\t\t\tE.flow -= d;\n\t\t\te[v][E.rev].flow += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint solve()\n{\n\treturn min_cost_flow(N * 2, N * 2 + 1, N, N * 2 + 2);\n}\n\nint main()\n{\n\twhile (init()) {\n\t\tcout << solve() << endl;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// Ford-Fulkerson 法による 最大流 O( F |E| )\n// Bellman-Ford 法による 最小費用流 O( F |V| |E| )\n// [条件に注意] Dijkstra 法による 最小費用流 O( F |E| log |V| )\n// Verified: AOJ GRL_6_A (Maximum Flow)\n// Verified: AOJ GRL_6_B (Minimum Cost Flow)\n\n// 行き先と容量と逆辺のインデックスを記録する構造体\n// 通常のグラフの辺の構造体と異なるため注意\n\ntemplate <typename Type>\nstruct Edge {\n    int to; Type cap, cost; int rev;\n    Edge(int t, Type c, int r) : to(t), cap(c), rev(r) {}\n    Edge(int t, Type ca, Type co, int r) : to(t), cap(ca), cost(co), rev(r) {}\n};\n\ntemplate <typename Type>\nusing Graph = vector< vector< Edge<Type> > >;\n\ntemplate <typename Type>\nstruct Flow {\n    vector< vector< Edge<Type> > > G;\n    const Type MAXC = 1 << 30;\n    int n;\n    vector<bool> used;\n    vector<int> prevv, preve, dist;\n    Flow(int _n) : G(_n), n(_n), used(_n, false), \n        prevv(_n), preve(_n), dist(_n, MAXC) {}\n\n    // G[e.to][e.rev] で逆辺を操作できる\n    void add_edge(int from, int to, Type cap) {\n        G[from].push_back(Edge<Type>(to, cap, G[to].size()));\n        G[to].push_back(Edge<Type>(from, 0, G[from].size() - 1));\n    }\n    void add_edge(int from, int to, Type cap, Type cost) {\n        G[from].push_back(Edge<Type>(to, cap, cost, G[to].size()));\n        G[to].push_back(Edge<Type>(from, 0, -cost, G[from].size() - 1));\n    }\n\n    Type dfs(int v, int t, Type f) {\n        if(v == t) return f;\n        used[v] = true;\n        for(int i=0; i < G[v].size(); i++) {\n            Edge<Type> &e = G[v][i];\n            if(!used[e.to] && e.cap > 0) {\n                Type d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    Type max_flow(int s, int t) {\n        Type flow = 0;\n        while(1) {\n            fill(used.begin(), used.end(), false);\n            Type f = dfs(s, t, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    // ベルマンフォード法で最小費用流を解く\n    // 負辺や負閉路があるときは基本的にこちらのほうが確実\n    Type mincost_flow(int s, int t, Type f) {\n        Type res = 0;\n        Type ma = MAXC;\n        while(f > 0) {\n            fill(dist.begin(), dist.end(), ma);\n            dist[s] = 0;\n            bool update = true;\n            while(update) {\n                update = false;\n                for(int v = 0; v < n; v++) {\n                    if(dist[v] == ma) continue;\n                    for(int i=0; i<G[v].size(); i++) {\n                        Edge<Type> &e = G[v][i];\n                        if(e.cap>0 && dist[e.to] > dist[v] + e.cost) {\n                            dist[e.to] = dist[v] + e.cost;\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }\n\n            if(dist[t] == ma) return -1;\n            Type d = f;\n            for(int v = t; v != s; v = prevv[v]) {\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * dist[t];\n            for(int v = t; v != s; v = prevv[v]) {\n                Edge<Type> &e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n\n    // ポテンシャルの導入により、ダイクストラ法で最小費用流を解く\n    // [仮定している条件]\n    //     1. グラフに負の閉路が存在しない (流量の 0 初期化のため)\n    //        もし存在するならベルマンフォードで負の閉路を見つけ\n    //        そこに流せるだけ流してスタート\n    //     2. グラフに負の辺が存在しない (pot_0 の計算可能性)\n    //        もし存在する場合は最初のみベルマンフォードを使う必要あり\n    Type fast_mincost_flow(int s, int t, Type f) {\n        Type res = 0, ma = MAXC;\n        vector<Type> pot(n);\n        while(f > 0) {\n            using PT = pair<Type, int>;\n            priority_queue< PT, vector<PT>, greater<PT> > que;\n            fill(dist.begin(), dist.end(), ma);\n\n            dist[s] = 0;\n            que.push(make_pair(0, s));\n            while(!que.empty()) {\n                PT cur = que.top(); que.pop();\n                int v = cur.second;\n                if(dist[v] < cur.first) continue;\n                for(size_t i=0; i<G[v].size(); i++) {\n                    Edge<Type>& e = G[v][i];\n                    if(e.cap > 0 and dist[e.to] > dist[v] + e.cost + pot[v] - pot[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + pot[v] - pot[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        que.push(make_pair(dist[e.to], e.to));\n                    }\n                }\n            }\n            if(dist[t] == ma) {\n                return -1;\n            }\n            for(int v=0; v<n; v++) pot[v] += dist[v];\n\n            Type d = f;\n            for(int v=t; v!=s; v=prevv[v]) {\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * pot[t];\n            for(int v=t; v!=s; v=prevv[v]) {\n                Edge<Type>& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\n\nsigned main() {\n    int N;\n    while(cin >> N, N) {\n        vector< vector<int> > mats(N);\n\n        int sum = 0;\n        for(int i=0; i<N; i++) {\n            vector<int> v(3);\n            for(int k=0; k<3; k++) cin >> v[k];\n            sort(v.begin(), v.end());\n            mats[i] = v;\n            sum += v[0] * v[1] * v[2];\n        }\n\n        int source = 2*N, sink = source + 1;\n        auto construct = [&]() {\n            Flow<int> fl(2*N + 2);\n            fl.add_edge(source, sink, N, 0);\n            for(int i=0; i<N; i++) {\n                fl.add_edge(source, i, 1, 0);\n                fl.add_edge(N+i, sink, 1, 0);\n            }\n\n            for(int i=0; i<N; i++) {\n                for(int j=0; j<N; j++) {\n                    if(i == j) continue;\n                    bool ok = true;\n                    for(int k=0; k<3; k++) {\n                        ok &= (mats[i][k] > mats[j][k]);\n                    }\n                    if(ok) {\n                        int V = mats[j][0] * mats[j][1] * mats[j][2];\n                        fl.add_edge(i, N+j, 1, -V);\n                    }\n                }\n            }\n            return fl;\n        };\n\n        int mincost;\n        {\n            Flow<int> fl = construct();\n            mincost = fl.mincost_flow(source, sink, N);\n        }\n        cout << sum + mincost << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <tuple>\n#include <limits>\n#include <queue>\n\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate <class Cap, class Cost>\nstruct MinCostFlow {\n    struct Edge {\n        int src, dst;\n        Cap cap;\n        Cost cost;\n        Edge(int src, int dst, Cap cap, Cost cost)\n            : src(src), dst(dst), cap(cap), cost(cost){};\n    };\n\n    using Edges = std::vector<Edge>;\n    using Graph = std::vector<std::vector<int>>;\n\n    Edges edges;\n    Graph graph;\n    std::vector<Cost> dist, pot;\n    std::vector<int> rev;\n\n    const Cost INF = std::numeric_limits<Cost>::max() / 2;\n\n    explicit MinCostFlow(int n) : graph(n), dist(n), pot(n), rev(n) {}\n\n    void span(int u, int v, Cap cap, Cost cost) {\n        graph[u].push_back(edges.size());\n        edges.emplace_back(u, v, cap, cost);\n\n        graph[v].push_back(edges.size());\n        edges.emplace_back(v, u, 0, -cost);\n    }\n\n    void dijkstra(int s) {\n        std::fill(dist.begin(), dist.end(), INF);\n        dist[s] = 0;\n        MinHeap<std::pair<Cost, int>> heap;\n        heap.emplace(0, s);\n\n        while (!heap.empty()) {\n            int u;\n            Cost d;\n            std::tie(d, u) = heap.top();\n            heap.pop();\n            if (d > dist[u]) continue;\n\n            for (auto eidx : graph[u]) {\n                const auto& edge = edges[eidx];\n                int v = edge.dst;\n\n                if (edge.cap > 0 &&\n                    dist[u] < INF &&\n                    dist[v] > dist[u] + edge.cost + pot[u] - pot[v]) {\n                    dist[v] = dist[u] + edge.cost + pot[u] - pot[v];\n                    rev[v] = eidx;\n                    heap.emplace(dist[v], v);\n                }\n            }\n        }\n    }\n\n    Cost exec(int s, int g, Cap flow) {\n        Cost ret = 0;\n        std::fill(pot.begin(), pot.end(), 0);\n\n        while (flow > 0) {\n            dijkstra(s);\n            if (dist[g] == INF) break;\n\n            for (int v = 0; v < (int)graph.size(); ++v) {\n                pot[v] = std::min(pot[v] + dist[v], INF);\n            }\n\n            Cap f = flow;\n            int v = g;\n            while (v != s) {\n                const auto& edge = edges[rev[v]];\n                f = std::min(f, edge.cap);\n                v = edge.src;\n            }\n\n            flow -= f;\n            ret += f * pot[g];\n\n            v = g;\n            while (v != s) {\n                auto& edge = edges[rev[v]];\n                auto& redge = edges[rev[v] ^ 1];\n                edge.cap -= f;\n                redge.cap += f;\n                v = edge.src;\n            }\n        }\n        return (flow > 0 ? -1 : ret);\n    }\n};\n\nusing Box = std::array<int, 3>;\n\nbool contain(Box a, Box b) {\n    for (int q = 0; q < 6; ++q) {\n        bool judge = true;\n        for (int i = 0; i < 3; ++i) {\n            if (a[i] <= b[i]) judge = false;\n        }\n        if (judge) return true;\n\n        std::next_permutation(a.begin(), a.end());\n    }\n    return false;\n}\n\nbool solve() {\n    int n;\n    std::cin >> n;\n    if (n == 0) return false;\n\n    std::vector<Box> bs(n);\n    for (auto& b : bs) {\n        for (auto& x : b) std::cin >> x;\n    }\n\n    const int S = n * 2 + 0, G = n * 2 + 1;\n    MinCostFlow<int, int> mcf(n * 2 + 2);\n\n    for (int v = 0; v < n; ++v) {\n        const auto& b = bs[v];\n        mcf.span(S, v, 1, 0);\n        mcf.span(S, v + n, 1, b[0] * b[1] * b[2]);\n        mcf.span(v + n, G, 1, 0);\n    }\n\n    for (int u = 0; u < n; ++u) {\n        for (int v = 0; v < n; ++v) {\n            if (contain(bs[u], bs[v])) {\n                mcf.span(u, v + n, 1, 0);\n            }\n        }\n    }\n\n    std::cout << mcf.exec(S, G, n) << std::endl;\n    return true;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while (solve()) {}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nusing i64=int64_t;\n\ntemplate<class flow_type,class cost_type> struct min_cost_flow{\n    struct edge{\n        int to,from,rev;\n        flow_type cap;\n        cost_type cost;\n        edge(int to,int from,int rev,flow_type cap,cost_type cost):\n            to(to),from(from),rev(rev),cap(cap),cost(cost){}\n    };\n    const int size=0;\n    vector<vector<edge>> graph;\n    min_cost_flow(int size_):size(size_),graph(size_){}\n    void add_edge(int from,int to,flow_type cap,cost_type cost){\n        graph[from].push_back(edge(to,from,int(graph[to].size()),cap,cost));\n        graph[to].push_back(edge(from,to,int(graph[from].size()-1),0,-cost));\n    }\n    cost_type min_path(int s,int t){\n        const cost_type inf=numeric_limits<cost_type>::max();\n        vector<cost_type> dist(size,inf);\n        vector<edge*> route(size);\n        queue<int> que;\n        vector<bool> inq(size);\n        dist[s]=0;\n        que.push(s);\n        inq[s]=true;\n        while(!que.empty()){\n            int u=que.front();\n            que.pop();\n            inq[u]=false;\n            for(edge &e:graph[u]){\n                if(e.cap==0) continue;\n                int v=e.to;\n                if(dist[v]>dist[u]+e.cost){\n                    dist[v]=dist[u]+e.cost;\n                    route[v]=&e;\n                    if(!inq[v]){\n                        que.push(v);\n                        inq[v]=true;\n                    }\n                }\n            }\n        }\n\n        if(dist[t]==inf) return inf;\n        flow_type flow=numeric_limits<flow_type>::max();\n        {\n            int v=t;\n            while(v!=s){\n                edge &e=*route[v];\n                //e.cap-=1;\n                //graph[e.to][e.rev].cap+=1;\n                //c+=e.cost;\n                flow=min(flow,e.cap);\n                v=e.from;\n            }\n        }\n        cost_type c=0;\n        {\n            int v=t;\n            while(v!=s){\n                edge &e=*route[v];\n                e.cap-=flow;\n                graph[e.to][e.rev].cap+=flow;\n                c+=e.cost*flow;\n                v=e.from;\n            }\n        }\n        return dist[t];\n    }\n    //??????????????´??????numeric_limits<cost_type>::max()??????????????¨?????¨???\n    cost_type calc_min_cost_flow(int s,int t,flow_type flow){\n        cost_type total_cost=0;\n        for(flow_type i=0; i<flow; ++i){\n            cost_type c=min_path(s,t);\n            if(c==numeric_limits<cost_type>::max()) return c;\n            total_cost+=c;\n        }\n        return total_cost;\n    }\n};\n\nvoid solve(int N){\n    vector<vector<i64>> xyz(N,vector<i64>(3));\n    rep(i,0,N) rep(j,0,3) cin >> xyz[i][j];\n\n    auto ok=[&](int i,int j){\n        bool res=false;\n        vector<int> v={0,1,2};\n        do{\n            bool f=true;\n            rep(k,0,3) if(xyz[i][v[k]]<=xyz[j][k]){\n                f=false;\n                break;\n            }\n            res|=f;\n        }while(next_permutation(v.begin(),v.end()));\n        return res;\n    };\n\n    min_cost_flow<i64,i64> mcf(2*N+2);\n    const int s=2*N,t=2*N+1;\n    rep(i,0,N){\n        mcf.add_edge(s,i,1,0);\n        mcf.add_edge(i+N,t,1,0);\n        mcf.add_edge(i,t,1,0);\n    }\n\n    rep(i,0,N){\n        rep(j,0,N){\n            if(ok(i,j)) mcf.add_edge(i,j+N,1,-xyz[j][0]*xyz[j][1]*xyz[j][2]);\n        }\n    }\n\n    i64 ans=0;\n    rep(i,0,N) ans+=xyz[i][0]*xyz[i][1]*xyz[i][2];\n    ans+=mcf.calc_min_cost_flow(s,t,N);\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    for(;;){\n        int N;\n        cin >> N;\n        if(!N) break;\n        solve(N);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nstatic const ll INF = 1e18;\n\nstruct edge {\n  int to;\n  ll cap, cost;\n  int rev;\n};\n\nvector<ll> h, d; // ポテンシャル, 最短距離\nvector<int> prevv, preve; // 直前の頂点と辺\n\nvoid add_edge(vector<vector<edge>> &G, int from, int to, ll cap, ll cost) {\n  G[from].emplace_back((edge) {to, cap, cost, (int) G[to].size()});\n  G[to].emplace_back((edge) {from, 0, -cost, (int) G[from].size() - 1});\n}\n\n// sからtへの流量fの最小費用流(流せない場合は-1)\nll min_cost_flow(vector<vector<edge>> &G, int s, int t, ll f) {\n  ll res = 0;\n  h.assign(G.size(), 0);\n  prevv.assign(G.size(), 0);\n  preve.assign(G.size(), 0);\n  while (f > 0) {\n    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;\n    d.assign(G.size(), INF);\n    d[s] = 0;\n    pq.push(make_pair(0, s));\n    while (!pq.empty()) {\n      pair<ll, int> p = pq.top();\n      pq.pop();\n      int v = p.second;\n      if (d[v] < p.first) continue;\n      for (int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && d[e.to] > d[v] + e.cost + h[v] - h[e.to]) {\n          d[e.to] = d[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          pq.push(make_pair(d[e.to], e.to));\n        }\n      }\n    }\n    if (d[t] == INF) return -1;\n    for (int i = 0; i < G.size(); i++) h[i] += d[i];\n    \n    // s-t間最短路に流す\n    int nowf = f;\n    for (int i = t; i != s; i = prevv[i]) {\n      nowf = min<ll>(nowf, G[prevv[i]][preve[i]].cap);\n    }\n    f -= nowf;\n    res += nowf * h[t];\n    for (int i = t; i != s; i = prevv[i]) {\n      edge &e = G[prevv[i]][preve[i]];\n      e.cap -= nowf;\n      G[i][e.rev].cap += nowf;\n    }\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  \n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0) return 0;\n    \n    ll sum = 0;\n    vector<vector<ll>> v(n, vector<ll>(3));\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < 3; j++) {\n        cin >> v[i][j];\n      }\n      sort(v[i].begin(), v[i].end());\n      sum += v[i][0] * v[i][1] * v[i][2];\n    }\n    \n    int vs = 2 * n, vt = 2 * n + 1; // フローの始点と終点\n    vector<vector<edge>> G(2 * n + 2);\n    for (int i = 0; i < n; i++) {\n      add_edge(G, vs, i, 1, 0);\n      add_edge(G, i + n, vt, 1, 0);\n      for (int j = 0; j < n; j++) {\n        if (v[i][0] > v[j][0] && v[i][1] > v[j][1] && v[i][2] > v[j][2]) {\n          add_edge(G, i, j + n, 1, -v[j][0] * v[j][1] * v[j][2]);\n        }\n      }\n    }\n    add_edge(G, vs, vt, n, 0);\n    ll fl = min_cost_flow(G, vs, vt, n);\n    cout << sum + fl << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <string.h>\n#include <queue>\nusing namespace std;\nconst int INF = 1e9;\n\nstruct edge {int to, cap, cost, rev;};\n \nint V;\nconst int MAX_V = 202;\nvector<edge> G[MAX_V];\nint h[MAX_V];\nint dist[MAX_V];\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int from, int to, int cap, int cost){\n  G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n  G[to].push_back((edge){from, 0, -cost, (int)G[from].size()-1});\n}\n\nint min_cost_flow(int s, int t, int f){\n  int res = 0;\n  fill(h, h+V, 0);\n  while(f > 0){\n    priority_queue< pair<int,int>, vector< pair<int,int> >, greater< pair<int,int> > > que;\n    fill(dist, dist+V, INF);\n    dist[s] = 0;\n    que.emplace(0, s);\n    while(!que.empty()){\n      pair<int,int> p = que.top();\n      que.pop();\n      int v = p.second;\n      if(dist[v] < p.first) continue;\n      for(int i = 0; i < G[v].size(); ++i){\n        edge &e = G[v][i];\n        if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n          dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n          prevv[e.to] = v;\n          preve[e.to] = i;\n          que.emplace(dist[e.to], e.to);\n        }\n      }\n    }\n    if(dist[t] == INF) return -1;\n    for(int v = 0; v < V; ++v) h[v] += dist[v];\n    int d = f;\n    for(int v = t; v != s; v = prevv[v]){\n      d = min(d, G[prevv[v]][preve[v]].cap);\n    }\n    f -= d;\n    res += d*h[t];\n    for(int v = t; v != s; v = prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int N, M, L;\n  while(cin >> N, N){\n    V = 2*N + 2;\n    vector< vector<int> > M;\n    long long int ans = 0;\n    for(int i = 0; i < N; ++i){\n      int x, y, z;\n      cin >> x >> y >> z;\n      int s = min({x, y, z}), l = max({x, y, z}), m = x + y + z - s - l;\n      M.push_back({s, m, l});\n      //ans += s*m*l;\n    }\n    sort(M.begin(), M.end());\n\n    for(int i = 0; i < N; ++i){\n      add_edge(i, 2*N+1, 1, M[i][0]*M[i][1]*M[i][2]);\n      for(int j = 0; j < i; ++j){\n        if(M[j][0] < M[i][0] && M[j][1] < M[i][1] && M[j][2] < M[i][2])\n          add_edge(j, i+N, 1, 0);\n      }\n    }\n    \n    for(int i = 0; i < N; ++i){\n      add_edge(2*N, i, 1, 0);\n      add_edge(N+i, 2*N+1, 1, 0);\n    }\n\n    ans += min_cost_flow(2*N, 2*N+1, N);\n    /*\n    for(int i = 0; i < N; ++i){\n      if(G[2*N][i].cap) ans += M[i][0]*M[i][1]*M[i][2];\n    }\n    */\n    cout << ans << endl;\n    for(int i = 0; i < V; ++i) G[i].clear();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod*mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nint max_n;\nconst int mn = 100000;\nstruct edge {\n\tint to, cap, cost, rev;\n};\nvector<edge> G[mn];\nint par[mn];\nint dist[mn];\nvoid add_edge(int from, int to, int cap, int cost) {\n\tG[from].push_back({ to,cap,cost,(int)G[to].size() });\n\tG[to].push_back({ from,0,-cost,(int)G[from].size() - 1 });\n\tmax_n = max({ max_n, from + 1, to + 1 });\n}\nint minimum_road(int s, int t) {\n\tfill(par, par + max_n, -1);\n\tfill(dist, dist + max_n, mod);\n\tdist[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q; q.push({ 0,s });\n\twhile (!q.empty()) {\n\t\tP p = q.top(); q.pop();\n\t\tint id = p.second;\n\t\tif (id == t)continue;\n\t\trep(j, G[id].size()) {\n\t\t\tif (G[id][j].cap > 0) {\n\t\t\t\tint to = G[id][j].to;\n\t\t\t\tint nd = p.first + G[id][j].cost;\n\t\t\t\tif (nd < dist[to]) {\n\t\t\t\t\tdist[to] = nd;\n\t\t\t\t\tpar[to] = id;\n\t\t\t\t\tq.push({ dist[to],to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint cur = t;\n\twhile (cur != s) {\n\t\tint p = par[cur];\n\t\tif (p < 0)return -1;\n\t\trep(j, G[p].size()) {\n\t\t\tif (G[p][j].cap > 0 && G[p][j].to == cur && dist[p] + G[p][j].cost == dist[cur]) {\n\t\t\t\tG[p][j].cap--;\n\t\t\t\tG[cur][G[p][j].rev].cap++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcur = p;\n\t}\n\treturn dist[t];\n}\nint u;\nint minimum_cost_flow(int s, int t) {\n\tint ret = 0;\n\twhile(true) {\n\t\tint z = minimum_road(s, t);\n\t\tif (z < 0)return ret;\n\t\tret += z; u++;\n\t}\n\treturn ret;\n}\nconst int m_n = 1000001;\nvoid solve() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tu = 0;\n\t\trep(i, 2*n + 2)G[i].clear();\n\t\tvector<vector<int>> v(n);\n\t\tint sum = 0;\n\t\trep(i, n) {\n\t\t\tv[i].resize(3);\n\t\t\trep(j, 3)cin >> v[i][j];\n\t\t\tsum += v[i][0] * v[i][1] * v[i][2];\n\t\t\tsort(v[i].begin(), v[i].end());\n\t\t}\n\t\tint s = 2*n, t = 2*n + 1;\n\t\trep(i, n) {\n\t\t\tadd_edge(s, i, 1,0);\n\t\t\tadd_edge(n+i, t, 1,0);\n\t\t}\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tbool f = true;\n\t\t\t\trep(k, 3) {\n\t\t\t\t\tif (v[i][k] >= v[j][k])f = false;\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tadd_edge(i, n+j, 1,m_n-v[i][0]*v[i][1]*v[i][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint z = minimum_cost_flow(s, t);\n\t\tz = u * m_n - z;\n\t\tcout << sum-z << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DUMP(x) cerr << #x << \"=\" << x << endl\n#define DUMP2(x, y) cerr<<\"(\"<<#x<<\", \"<<#y<<\") = (\"<<x<<\", \"<<y<<\")\"<< endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\n#define in_range(x, y, w, h) (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n#define ALL(a) (a).begin(),(a).end()\n\ntypedef long long ll;\nconst int INF   = 1e9;\nconst ll  INFLL = 1e18;\ntypedef pair<int, int> PII;\nint dx[4]={0, -1, 1, 0}, dy[4]={-1, 0, 0, 1};\n\nstruct Edge { \n    int to, cap, rev, cost; \n    // Edge (int _to, int _cap, int _rev, int _cost) : to(_to), cap(_cap), rev(_rev), cost(_cost) {}\n};\n\nclass MinCostFlow {\npublic:\n    int N;\n    vector<vector<Edge>> G;\n    vector<int> dist, prevv, preve;\n\n    MinCostFlow(int _n) : N(_n), G(_n, vector<Edge>()), dist(vector<int>(_n)),\n        prevv(vector<int>(_n)), preve(vector<int>(_n)) {}\n\n    void add_edge(int from, int to, int cap, int cost)\n    {\n        G[from].push_back({to, cap, (int)G[to].size(), cost});\n        G[to].push_back({from, 0, (int)G[from].size()-1, -cost});\n    }\n\n    int min_cost_flow(int s, int t, int f)\n    {\n        int res = 0;\n        while (f > 0) {\n            fill(dist.begin(), dist.end(), INF);\n            dist[s] = 0;\n            bool update = true;\n            while (update) {\n                update = false;\n                for (int v=0; v<N; v++) {\n                    if (dist[v] == INF) continue;\n                    for (int i=0; i<(int)G[v].size(); i++) {\n                        Edge &e = G[v][i];\n                        if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                            dist[e.to] = dist[v] + e.cost;\n                            prevv[e.to] = v;\n                            preve[e.to] = i;\n                            update = true;\n                        }\n                    }\n                }\n            }\n            if (dist[t] == INF) return -1;\n\n            int d = f;\n            for (int v=t; v!=s; v=prevv[v]) {\n                d = min(d, G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d * dist[t];\n            for (int v=t; v!=s; v=prevv[v]) {\n                Edge &e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nstruct Block {\n    int x[3];\n    void sort() { std::sort(x, x+3); }\n    bool can_contain(Block &rhs)\n    {\n        sort();\n        rhs.sort();\n        return (x[0] > rhs.x[0] && x[1] > rhs.x[1] && x[2] > rhs.x[2]);\n    }\n};\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int N;\n    while (cin >> N, N) {\n        vector<Block> B(N);\n        rep(i, N) {\n            int X, Y, Z;\n            cin >> X >> Y >> Z;\n            B[i] = {X, Y, Z};\n        }\n\n        const int SOURCE = 2*N;\n        const int SINK   = 2*N+1;\n        MinCostFlow flow(2*N+2);\n\n        rep(i, N) {\n            int cost = B[i].x[0] * B[i].x[1] * B[i].x[2];\n            flow.add_edge(SOURCE, i, 1, 0);\n            flow.add_edge(i, SINK, 1, cost);\n            flow.add_edge(N + i, SINK, 1, 0);\n        }\n\n        rep(i, N) {\n            rep(j, N) {\n                if (i == j) continue;\n                if (B[j].can_contain(B[i])) {\n                    flow.add_edge(i, N+j, 1, 0);\n                }\n            }\n        }\n\n        /*\n        int ans = INF;\n        rep(i, N) {\n            int c = flow.min_cost_flow(SOURCE, SINK, i+1);\n            if (c >= 0) ans = min(ans, c);\n        }\n        cout << ans << endl;\n        */\n\n        cout << flow.min_cost_flow(SOURCE, SINK, N) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 301\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nstruct edge{ int to,cap,cost,rev; };\n\nint v;\nvector<edge> e[MAX];\nint h[MAX];\nint dist[MAX];\nint prevv[MAX],preve[MAX];\n\nvoid add_edge(int from,int to,int cap,int cost){\n  e[from].push_back((edge){to,cap,cost,(int)e[to].size()});\n  e[to].push_back((edge){from,0,-cost,(int)e[from].size()-1});\n}\n \nint min_cost_flow(int s,int t,int f){\n  int res=0;\n  fill(h,h+v,0);\n  fill(prevv,prevv+MAX,0);\n  fill(preve,preve+MAX,0);\n  while(f>0){\n    priority_queue<pii,vector<pii>,greater<pii> > pq;\n    fill(dist,dist+v,inf);\n    dist[s]=0;\n    pq.push(pii(0,s));\n    while(pq.size()){\n      pii p=pq.top();\n      pq.pop();\n      int u=p.second;\n      if(dist[u]<p.first)continue;\n      for(int i=0;i<e[u].size();i++){\n        edge &E=e[u][i];\n        if(E.cap>0 && dist[E.to]>dist[u]+E.cost+h[u]-h[E.to]){\n          dist[E.to]=dist[u]+E.cost+h[u]-h[E.to];\n          prevv[E.to]=u;\n          preve[E.to]=i;\n          pq.push(pii(dist[E.to],E.to));\n        }\n      }\n    }\n    if(dist[t]==inf)return -1;\n    for(int i=0;i<v;i++)h[i]+=dist[i];\n \n    int d=f;\n    for(int u=t;u!=s;u=prevv[u]){\n      d=min(d,e[prevv[u]][preve[u]].cap);\n    }\n    f-=d;\n    res+=d*h[t];\n    for(int u=t;u!=s;u=prevv[u]){\n      edge &E=e[prevv[u]][preve[u]];\n      E.cap-=d;\n      e[u][E.rev].cap+=d;\n    }\n  }\n  return res;\n}\n\nint n;\nvector<vector<int> > dolls;\nint vol[MAX];\n\nvoid init(){\n  dolls.clear();\n  FOR(i,0,MAX)e[i].clear();\n}\n\nbool containable(vector<int> a,vector<int> b){\n  FOR(i,0,3)if(b[i]<=a[i])return false;\n  return true;\n}\n\nint solve(){\n  int sum = 0;\n  FOR(i,0,n){\n    vol[i] = dolls[i][0]*dolls[i][1]*dolls[i][2];\n    sum += vol[i];\n  }\n  FOR(i,0,n){\n    FOR(j,0,n){\n      if(i==j)continue;\n      if(containable(dolls[i],dolls[j]))add_edge(i,j+n,1,-vol[i]);\n    }\n  }\n  int s=n+n,t=s+1,u=t+1;;\n  v = t+2;\n  FOR(i,0,n)add_edge(s,i,1,0);\n  FOR(i,0,n)add_edge(i+n,t,1,0);\n  add_edge(s,u,inf,0);\n  add_edge(u,t,inf,0);\n  int res = min_cost_flow(s,t,inf);\n  return sum+res;\n}\n\nint main()\n{\n  while(cin>>n && n){\n    init();\n    FOR(i,0,n){\n      vector<int> v;\n      v.resize(3);\n      cin>>v[0]>>v[1]>>v[2];\n      sort(all(v));\n      dolls.pb(v);\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\nstruct MincostFlow{\n    struct edge{\n        int to, rev;\n        int cap, cost;\n        edge(int to, int rev, int cap, int cost)\n            :to(to),rev(rev),cap(cap),cost(cost){}\n        edge(){}\n    };\n    \n    int n;\n    vector<vector<edge>> graph;\n\n    MincostFlow(int n):n(n){\n        graph.resize(n);\n    }\n    void add_edge(int from, int to, int cap, int cost){\n        graph[from].emplace_back(to, graph[to].size(), cap, cost);\n        graph[to].emplace_back(from, (int)graph[from].size()-1, 0, -cost);\n    }\n    int exec(int s, int g, int f){\n        int res = 0;\n        while(f > 0){\n            vector<int> prevv(n), preve(n);\n            vector<int> mincost(n, inf);\n            mincost[s] = 0;\n            while(1){\n                bool update = false;\n                for(int i=0; i<n; i++){\n                    if(mincost[i] == inf) continue;\n                    for(int j=0; j<(int)graph[i].size(); j++){\n                        edge &e = graph[i][j];\n                        if(e.cap>0 && mincost[i] +e.cost < mincost[e.to]){\n                            mincost[e.to] = mincost[i] +e.cost;\n                            prevv[e.to] = i;\n                            preve[e.to] = j;\n                            update = true;\n                        }\n                    }\n                }\n                if(!update) break;\n            }\n            if(mincost[g] == inf){\n                return -1;\n            }\n         \n            int d = f;\n            for(int v=g; v!=s; v=prevv[v]){\n                d = min(d, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d*mincost[g];\n            for(int v=g; v!=s; v=prevv[v]){\n                edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= d;\n                graph[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n\n        vector<vector<int>> len(n, vector<int>(3));\n        for(int i=0; i<n; i++){\n            for(int j=0; j<3; j++){\n                cin >> len[i][j];\n            }\n            sort(len[i].begin(), len[i].end());\n        }\n        MincostFlow mcf(2*n +2);\n        for(int i=0; i<n; i++){\n            for(int j=0; j<n; j++){\n                bool ok = true;\n                for(int k=0; k<3; k++){\n                    if(len[i][k] >= len[j][k]) ok = false;\n                }\n                if(ok){\n                    mcf.add_edge(i, n+j, 1, 0);\n                }\n            }\n        }\n        for(int i=0; i<n; i++){\n            mcf.add_edge(2*n, i, 1, 0);\n            mcf.add_edge(n+i, 2*n+1, 1, 0);\n            mcf.add_edge(i, 2*n+1, 1, len[i][0]*len[i][1]*len[i][2]);\n        }\n        cout << mcf.exec(2*n, 2*n+1, n) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct PrimalDual{\n  const int INF = 1<<28;\n  typedef pair<int,int> P;\n  struct edge{\n    int to,cap,cost,rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n\n  int n;\n  vector<vector<edge> > G;\n  vector<int> h,dist,prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(int sz):n(sz),G(sz),h(sz),dist(sz),prevv(sz),preve(sz){}\n  \n  void add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n  }\n\n  int flow(int s,int t,int f){\n    int res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      priority_queue<P,vector<P>,greater<P> > que;\n      fill(dist.begin(),dist.end(),INF);\n      dist[s]=0;\n      que.push(P(0,s));\n      while(!que.empty()){\n        P p=que.top();que.pop();\n        int v=p.second;\n        if(dist[v]<p.first) continue;\n        for(int i=0;i<(int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n            dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            que.push(P(dist[e.to],e.to));\n          }\n        }\n      }\n      if(dist[t]==INF) return -1;\n      for(int v=0;v<n;v++) h[v]+=dist[v];\n      int d=f;\n      for(int v=t;v!=s;v=prevv[v]){\n        d=min(d,G[prevv[v]][preve[v]].cap);\n      }\n      f-=d;\n      res+=d*h[t];\n      for(int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    PrimalDual p(n*2+2);\n    int sum=0,cube[n],a[3];\n    vector<vector<int> >v(n);\n    r(i,n){\n      r(j,3)cin>>a[j];\n      sort(a,a+3);\n      sum+=a[0]*a[1]*a[2];\n      cube[i]=a[0]*a[1]*a[2];\n      r(j,3)v[i].push_back(a[j]);\n    }\n    r(i,n){\n      r(j,n){\n        int c=0;\n        r(k,3)if(v[i][k]<v[j][k])c++;\n        if(c==3){\n          p.add_edge(i,n+j,1,0);\n        }\n      }\n    }\n    r(i,n)p.add_edge(n*2,i,1,0);\n    r(i,n)p.add_edge(i+n,n*2+1,1,0);\n    r(i,n)p.add_edge(i,n*2+1,1,cube[i]);\n    cout<<p.flow(n*2,n*2+1,n)<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_V 4005\ntypedef pair<ll,ll> P;\nll INF=(1LL<<40);\n\nstruct edge { ll to,cap,cost,rev; };\n\nint V;\nvector<edge> G[MAX_V];\nll h[MAX_V];\nll dist[MAX_V];\nint prevv[MAX_V],preve[MAX_V];\n\nvoid init_edge(){\n  for(int i=0;i<V;i++)G[i].clear();\n}\n\nvoid add_edge(int from,int to,int cap,ll cost){\n  G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n  G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n}\n\nll min_cost_flow(int s,int t,int f){\n  ll res = 0;\n  fill(h,h+V,0);\n  while(f>0){\n    \n    priority_queue< P, vector<P>, greater<P> >  que;\n    fill( dist, dist+V , INF );\n    dist[s]=0;\n    que.push(P(0,s));\n    while(!que.empty()){\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if(dist[v]<p.first)continue;\n      for(int i=0;i<(int)G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap>0&&dist[e.to] > dist[v]+e.cost+h[v]-h[e.to]){\n          dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n          prevv[e.to]=v;\n          preve[e.to]=i;\n          que.push(P(dist[e.to],e.to));\n        }\n      }\n    }\n\n    if(dist[t]==INF){\n      return -1;\n    }\n\n    for(int v=0;v<V;v++)h[v]+=dist[v];\n    ll d=f;\n    for(int v=t;v!=s;v=prevv[v]){\n      d=min(d,G[prevv[v]][preve[v]].cap);\n    }\n    f-=d;\n    res+=(ll)d*h[t];\n    for(int v=t;v!=s;v=prevv[v]){\n      edge &e = G[prevv[v]][preve[v]];\n      e.cap -= d;\n      G[v][e.rev].cap += d;\n    }\n\n\n  }\n  return res;\n}\n\n\nvoid init(){\n  for(int i=0;i<MAX_V;i++)\n    G[i].clear();\n}\n\n\ntypedef pair< P , ll > PP;\n\nint main(){\n  int N;\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    init();\n    vector<PP> t(N);\n    for(int i=0;i<N;i++){\n      int a,b,c;\n      cin>>a>>b>>c;\n      if(a<b)swap(a,b);\n      if(b<c)swap(b,c);\n      if(a<b)swap(a,b);\n      t[i]=PP( P(a,b) , c);\n    }\n    sort(t.begin(),t.end());\n    reverse(t.begin(),t.end());\n    ll MAX=1e7;\n    \n    for(int i=0;i<N;i++){\n      for(int j=i+1;j<N;j++){\n        if(t[i].first.first>t[j].first.first)\n          if(t[i].first.second>t[j].first.second)\n            if(t[i].second>t[j].second){\n              ll value=t[j].first.first*t[j].first.second*t[j].second;\n              //              cout<<MAX-value<<endl;\n              add_edge(i,N+j,1,MAX-value);\n            }\n      }\n    }\n\n    V=N+N+2;\n    int si=V-2;\n    int ti=V-1;\n\n    ll sum=0;\n    for(int i=0;i<N;i++){\n      sum+= t[i].first.first*t[i].first.second*t[i].second;\n      add_edge(si,i,1,0);\n      add_edge(N+i,ti,1,0);\n    }\n    \n    add_edge(si,ti,N,MAX);\n    \n    ll ans=min_cost_flow(si,ti,N);\n    ans-=MAX*N;\n    ans=-ans;\n    cout<<sum-ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\n// 二部グラフの最大重みマッチング\nclass Hungarian {\n    int n, p, q;\n    vvi mat;\n    vi fx, fy, x, y;\n    const i64 INF = 1e9;\n\npublic:\n    Hungarian(const vvi& mat) : mat(mat) {\n        n = mat.size();\n        fx.assign(n, INF);\n        fy.assign(n, 0);\n        x.assign(n, -1);\n        y.assign(n, -1);\n    }\n\n    i64 run() {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                fx[i] = max(fx[i], mat[i][j]);\n            }\n        }\n\n        for (int i = 0; i < n;) {\n            vi t(n, -1), s(n + 1, i);\n            for (p = q = 0; p <= q && x[i] < 0; p++) {\n                for (int k = s[p], j = 0; j < n && x[i] < 0; j++) {\n                    if (fx[k] + fy[j] == mat[k][j] && t[j] < 0) {\n                        s[++q] = y[j];\n                        t[j] = k;\n                        if (s[q] < 0) {\n                            for (p = j; p >= 0; j = p) {\n                                y[j] = k = t[j];\n                                p = x[k];\n                                x[k] = j;\n                            }\n                        }\n                    }\n                }\n            }\n            if (x[i] < 0) {\n                i64 d = INF;\n                for (int k = 0; k <= q; k++) {\n                    for (int j = 0; j < n; j++) {\n                        if (t[j] < 0) {\n                            d = min(d, fx[s[k]] + fy[j] - mat[s[k]][j]);\n                        }\n                    }\n                }\n                for (int j = 0; j < n; j++) {\n                    fy[j] += (t[j] < 0 ? 0 : d);\n                }\n                for (int k = 0; k <= q; k++) {\n                    fx[s[k]] -= d;\n                }\n            } else {\n                i++;\n            }\n        }\n        i64 ret = 0;\n        for (int i = 0; i < n; i++) {\n            ret += mat[i][x[i]];\n        }\n        return ret;\n    }\n\n    int match_y(int k) {\n        return x[k];\n    }\n\n    int match_x(int k) {\n        return y[k];\n    }\n};\n\nint main() {\n    int n;\n    while (cin >> n) {\n        if (n == 0) break;\n        long long sum = 0;\n        vector<vector<int>> as(n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 3; j++) {\n                int a;\n                cin >> a;\n                as[i].push_back(a);\n            }\n            sum += as[i][0] * as[i][1] * as[i][2];\n            sort(as[i].begin(), as[i].end());\n        }\n        vvi mat(n, vi(n));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                bool ok = true;\n                for (int k = 0; k < 3; k++) {\n                    if (as[i][k] >= as[j][k]) ok = false;\n                }\n                if (ok) {\n                    mat[i][j] = as[i][0] * as[i][1] * as[i][2];\n                }\n            }\n        }\n        Hungarian h(mat);\n        cout << sum - h.run() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i = (a);i < (b);i++)\n#define RFOR(i,a,b) for(int i = (b)-1;i >= (a);i--)\n#define REP(i,n) FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define pb push_back\n#define mp make_pair\n#define ft first\n#define sd second\n\n#define MAX_N 100\n#define INF (1<<20)\n\nint N;\nint x[MAX_N], y[MAX_N], z[MAX_N], m[MAX_N];\n\nbool input(){\n  cin>>N;\n  int a[3];\n  REP(i, N) {\n    cin>>a[0]>>a[1]>>a[2];\n    sort(a, a+3);\n    x[i] = a[0];\n    y[i] = a[1];\n    z[i] = a[2];\n    m[i] = x[i]*y[i]*z[i];\n  }\n  return N!=0;\n}\n\n#define MAX_V 204\nstruct edge { int to, cap, cost, rev; };\nint V; // ????????°\nvector<edge> G[MAX_V]; // ??°???????????£??\\???????????¨???\nint dist[MAX_V]; // ???????????¢\nint prevv[MAX_V], preve[MAX_V]; // ??´??????????????¨???\n// from??????to??????????????????cap????????????cost???????????°?????????????????????\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, -cost, (int)G[from].size() - 1});\n}\n// s??????t????????????f???????°??????¨???????±???????\n// ??????????????´??????-1?????????\nint min_cost_flow(int s, int t, int f) {\n\n    int res = 0;\n    while (f > 0) {\n        // ???????????????????????????????????????s-t????????????????±???????\n        fill(dist, dist + V, INF);\n        dist[s] = 0;\n        bool update = true;\n        while (update) {\n            update = false;\n            for (int v = 0; v < V; v++) {\n                if (dist[v] == INF) continue;\n                for (int i = 0; i < G[v].size(); i++) {\n                    edge &e = G[v][i];\n                    if (e.cap > 0 && dist[e.to] > dist[v] + e.cost) {\n                        dist[e.to] = dist[v] + e.cost;\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        update = true;\n                    }\n                }\n            }\n        }\n        if (dist[t] == INF) {\n            // ????????\\???????????????\n            return -1;\n        }\n        // s-t????????????????????£??????????????????\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * dist[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nvoid resetG(int ver){\n  V = ver;\n  REP(i,V)G[i].clear();//while(!G[i].empty()) G[i].pop_back();\n//  REP(i,V){preve[i] = 0;prevv[i] = 0;}\n}\n\nvoid solve(){\n resetG(N * 2 + 2);\n REP(i,N){\n   REP(j,N){\n     if(i == j)\n       continue;\n     if(x[i] > x[j] && y[i] > y[j] && z[i] > z[j])\n       add_edge(j,i + N, 1, 0);\n   }\n   add_edge(V-2, i, 1, 0);\n   add_edge(i+N, V-1, 1, 0);\n   add_edge(i, V-1, 1, m[i]);\n }\n cout<<min_cost_flow(V-2, V-1,N)<<endl;\n}\n\nint main(){\n  cin.tie(0);\n\n  while (input()){\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for (ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass MinCostFlow {\npublic:\n  struct edge { int to, cap, cost, rev; };\n\nprivate:\n  const int INF = 1 << 28;\n  int N;\n  vector<vector<edge>> E;\n  vector<int> h, dist, prevv, preve;\n\npublic:\n  MinCostFlow(int N): N(N), E(N), h(N, 0), dist(N), prevv(N), preve(N) {}\n\n  void add_directed_edge(int from, int to, int cap, int cost) {\n    E[from].push_back((edge) { to, cap, cost, (int) E[to].size() });\n    E[to].push_back((edge) { from, 0, -cost, (int) E[from].size() - 1 });\n  }\n\n  int min_cost_flow(int s, int t, int f) {\n    int ret = 0;\n    while (f > 0) {\n      priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n      for (int i = 0; i < N; i++) dist[i] = INF;\n      dist[s] = 0;\n      q.push(make_pair(0, s));\n      while (!q.empty()) {\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if (dist[v] < p.first) continue;\n        for (int i = 0; i < E[v].size(); i++) {\n          edge &e = E[v][i];\n          if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n            prevv[e.to] = v;\n            preve[e.to] = i;\n            q.push(make_pair(dist[e.to], e.to));\n          }\n        }\n      }\n      if (dist[t] == INF) return -1;\n      for (int v = 0; v < N; v++) h[v] += dist[v];\n      int d = f;\n      for (int v = t; v != s; v = prevv[v]) d = min(d, E[prevv[v]][preve[v]].cap);\n      f -= d;\n      ret += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        edge &e = E[prevv[v]][preve[v]];\n        e.cap -= d;\n        E[v][e.rev].cap += d;\n      }\n    }\n    return ret;\n  }\n};\n\nll volume(vector<ll> &b) {\n  return b[0] * b[1] * b[2];\n}\n\nbool contain(vector<ll> &b1, vector<ll> &b2) {\n  bool ret = false;\n  do {\n    bool ok = true;\n    REP(i, 0, 3) ok = ok && b1[i] < b2[i];\n    ret = ret || ok;\n  } while (next_permutation(b1.begin(), b1.end()));\n  sort(b1.begin(), b1.end());\n  return ret;\n}\n\nint main(void) {\n  for (ll N; cin >> N, N;) {\n    vector<vector<ll>> B(N, vector<ll>(3));\n    REP(i, 0, N) cin >> B[i][0] >> B[i][1] >> B[i][2];\n\n    REP(i, 0, N) sort(B[i].begin(), B[i].end());\n\n    MinCostFlow mcf(N * 2 + 2);\n    ll s = N * 2, t = N * 2 + 1;\n    vector<ll> p(N), q(N);\n    REP(i, 0, N) p[i] = i;\n    REP(i, 0, N) q[i] = N + i;\n\n    REP(i, 0, N) mcf.add_directed_edge(s, p[i], 1, 0);\n    REP(i, 0, N) mcf.add_directed_edge(p[i], t, 1, volume(B[i]));\n    REP(i, 0, N) mcf.add_directed_edge(q[i], t, 1, 0);\n\n    REP(i, 0, N) {\n      REP(j, 0, N) if (j != i) {\n        if (contain(B[i], B[j])) {\n          mcf.add_directed_edge(p[i], q[j], 1, 0);\n        }\n      }\n    }\n\n    cout << mcf.min_cost_flow(s, t, N) << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nconst Int inf = 1LL<<55;\n\nstruct edge {\n  Int to, cap, cost, rev;\n  edge(){}\n  edge(Int to, Int cap, Int cost, Int rev)\n    :to(to), cap(cap), cost(cost), rev(rev){}\n};\n\ntypedef pair<Int, Int> Pi;\n\nstruct PrimalDual {\n  vector< vector<edge> > graph;\n  vector<Int> mincost, h, prevv, preve;\n  PrimalDual(Int V):graph(V), mincost(V), h(V), prevv(V), preve(V){}\n  void add_edge(Int from, Int to, Int cap, Int cost) {\n    //cout<<from<<\" \"<<to<<\" \"<<cap<<\" \"<<cost<<endl;\n    graph[from].emplace_back(to, cap, cost, (Int)graph[to].size());\n    graph[to].emplace_back(from, 0, -cost, (Int)graph[from].size()-1);\n  }\n  Int min_cost_flow(Int s, Int t, Int f) {\n    Int res = 0;\n    fill(h.begin(), h.end(), 0);\n    fill(prevv.begin(), prevv.end(), -1);\n    fill(preve.begin(), preve.end(), -1);\n\n    while(f > 0) {\n      priority_queue<Pi, vector<Pi>, greater<Pi> > que;\n      fill(mincost.begin(), mincost.end(), inf);\n      mincost[s] = 0;\n      que.emplace(0, s);\n      while(!que.empty()) {\n        Pi p = que.top(); que.pop();\n        Int v = p.second;\n        if(mincost[v] < p.first) continue;\n        for(Int i = 0; i < (Int)graph[v].size(); i++) {\n          edge& e = graph[v][i];          \n          Int dual_cost = mincost[v] + e.cost + h[v] - h[e.to];\n          //cout<<dual_cost<<endl;\n          if(e.cap > 0 && dual_cost < mincost[e.to]) {\n            mincost[e.to] = dual_cost;\n            prevv[e.to] = v; preve[e.to] = i;\n            que.emplace(dual_cost, e.to);\n          }\n        }\n      }\n\n      if(mincost[t] == inf) return inf;\n      for(Int v = 0; v < (Int)graph.size(); v++) h[v] += mincost[v];\n      Int d = f;\n      for(Int v = t; v != s; v = prevv[v]) {\n        d = min(d, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= d;\n      res += d*h[t];\n      //cout<<res<<\" \"<<d<<\" \"<<h[t]<<endl;\n      for(Int v = t; v != s; v = prevv[v]) {\n        edge& e = graph[prevv[v]][preve[v]];\n        e.cap -= d;\n        graph[v][e.rev].cap += d;\n      }\n    }\n    return res;\n  }\n};\n\nstruct doll{\n  Int x,y,z;\n  doll(){}\n  doll(Int x,Int y,Int z):x(x),y(y),z(z){}\n  Int getVol() {\n    return x*y*z;\n  }\n};\n\nInt in(doll a,doll b){\n  for(Int k=0;k<6;k++){\n    if(k==1||k==3||k==5) swap(a.x,a.y);\n    if(k==2||k==4) swap(a.x,a.z);\n    if(b.x<a.x&&b.y<a.y&&b.z<a.z) return true;\n  }\n  return false;\n}\n\nsigned main(){\n  Int n;\n  while(cin >> n, n) {\n    vector<doll> D(n);\n    Int ans = 0;\n    for(Int i = 0; i < n; i++) {\n      cin >> D[i].x >> D[i].y >> D[i].z;\n      ans += D[i].getVol();\n    }\n    Int s = n*2, t = s+1, V = t+1;\n    PrimalDual graph(V);\n    for(Int i = 0; i < n; i++) {\n      graph.add_edge(s, i, 1, 0);\n    }\n    for(Int i = 0; i < n; i++) {\n      graph.add_edge(i, t, 1, 0); \n    }\n    for(Int i = 0; i < n; i++) {\n      for(Int j = 0; j < n; j++) {\n        if(i == j) continue;\n        if(in(D[i], D[j])) {\n          //cout<<\"in \"<<i<<\" \"<<j<<endl;\n          graph.add_edge(i, n+j, 1, -D[j].getVol());\n        }\n      }\n    }\n    //cout << ans << endl;\n    for(Int i = 0; i < n; i++) {\n      graph.add_edge(n+i, t, 1, 0);\n    }\n    //cout<<n<<endl;\n    Int tmp = graph.min_cost_flow(s, t, n);\n    assert(tmp != inf);\n    cout << ans + tmp << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T>\nstruct Primal_Dual {\n  using Pa = pair<T, int>;\n  T infinity = (long long)(1e10);\n  struct edge {\n    int to;\n    T cap, cost;\n    int rev;\n  };\n  int v;\n  vector<vector<edge>> edges;\n  vector<T> h;\n  vector<T> dist;\n  vector<int> prevv, preve;\n  Primal_Dual(int vsize = 1) {\n    v = vsize;\n    edges.resize(v);\n    h.resize(v);\n    dist.resize(v);\n    prevv.resize(v);\n    preve.resize(v);\n  }\n  bool add(int from, int to, T cap, T cost) {\n    edges[from].push_back((edge){to, cap, cost, (int)edges[to].size()});\n    edges[to].push_back((edge){from, 0, -cost, (int)edges[from].size() - 1});\n    return 1;\n  }\n  T solve(int s, int t, T f) {\n    T ans = 0;\n    h.assign(v, 0);\n    while (f > 0) {\n      priority_queue<Pa, vector<Pa>, greater<Pa>> qu;\n      dist.assign(v, infinity);\n      dist[s] = 0;\n      qu.push({0, s});\n      while (!qu.empty()) {\n        Pa now = qu.top();\n        qu.pop();\n        int nowv = now.second;\n        if (dist[nowv] < now.first) continue;\n        for (int i = 0; i < (int)edges[nowv].size(); ++i) {\n          edge &e = edges[nowv][i];\n          if (e.cap > 0 &&\n              dist[e.to] > dist[nowv] + e.cost + h[nowv] - h[e.to]) {\n            dist[e.to] = dist[nowv] + e.cost + h[nowv] - h[e.to];\n            prevv[e.to] = nowv;\n            preve[e.to] = i;\n            qu.push({dist[e.to], e.to});\n          }\n        }\n      }\n      if (dist[t] == infinity) return -1;\n      for (int i = 0; i < v; ++i) h[i] += dist[i];\n      T d = f;\n      for (int i = t; i != s; i = prevv[i])\n        d = min(d, edges[prevv[i]][preve[i]].cap);\n      f -= d;\n      ans += d * h[t];\n      for (int i = t; i != s; i = prevv[i]) {\n        edge &e = edges[prevv[i]][preve[i]];\n        e.cap -= d;\n        edges[i][e.rev].cap += d;\n      }\n    }\n    return ans;\n  }\n};\n\nstruct mat {\n  vector<long long> v;\n};\n\nint n;\nvector<mat> v;\nPrimal_Dual<long long> pd;\n\nint main() {\n  while (1) {\n    cin >> n;\n    if (n == 0) break;\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n      v[i].v.resize(3);\n      for (int j = 0; j < 3; ++j) cin >> v[i].v[j];\n      sort(v[i].v.begin(), v[i].v.end(), greater<long long>());\n    }\n    pd = Primal_Dual<long long>((n + 1) * 2);\n    long long sum = 0;\n    for (int i = 0; i < n; ++i) {\n      sum += v[i].v[0] * v[i].v[1] * v[i].v[2];\n      pd.add(2 * n, i, 1, 0);\n      pd.add(i, 2 * n + 1, 1, 1e8);\n      pd.add(i + n, 2 * n + 1, 1, 0);\n      for (int j = 0; j < n; ++j) {\n        bool ch = 1;\n        for (int k = 0; k < 3; ++k)\n          if (v[i].v[k] >= v[j].v[k]) ch = 0;\n        if (ch)\n          pd.add(i, j + n, 1,\n                 (long long)1e8 - v[i].v[0] * v[i].v[1] * v[i].v[2]);\n      }\n    }\n    cout << sum - (n * (long long)(1e8)) + pd.solve(2 * n, 2 * n + 1, n)\n         << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\n\nstruct Edge{\n\tllint to, cost;\n\tEdge(){}\n\tEdge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint N;\nllint L[105][3];\nvector<Edge> g[105];\n\nllint volume(llint x)\n{\n\tllint ret = 1;\n\tfor(llint i = 0; i < 3; i++) ret *= L[x][i];\n\treturn ret;\n}\n\nbool compare(llint x, llint y)\n{\n\tfor(llint i = 0; i < 3; i++){\n\t\tif(L[x][i] <= L[y][i]) return false;\n\t}\n\treturn true;\n}\n\n\nstruct edge{\n\tllint to, cap, cost, rev;\n\tedge(){}\n\tedge(llint a, llint b, llint c, llint d){\n\t\tto = a, cap = b, cost = c, rev = d;\n\t}\n};\n\n\nllint S, T;\nvector<edge> G[205];\nllint dist[205];\nllint prevv[205], preve[205];\n\nvoid BellmanFord()\n{\n\tfor(llint i = 0; i <= T; i++) dist[i] = inf;\n\tdist[S] = 0, prevv[S] = -1;\n\t\n\tbool update = true;\n\twhile(update){\n\t\tupdate = false;\n\t\tfor(llint i = 0; i <= T; i++){\n\t\t\tfor(llint j = 0; j < G[i].size(); j++){\n\t\t\t\tif(G[i][j].cap == 0) continue;\n\t\t\t\tif(dist[G[i][j].to] > dist[i] + G[i][j].cost){\n\t\t\t\t\tdist[G[i][j].to] = dist[i] + G[i][j].cost;\n\t\t\t\t\tprevv[G[i][j].to] = i;\n\t\t\t\t\tpreve[G[i][j].to] = j;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid add_edge(llint from, llint to, llint cap, llint cost)\n{\n\tG[from].push_back( edge(to, cap, cost, G[to].size()) );\n\tG[to].push_back( edge(from, 0, -cost, G[from].size()-1) );\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tfor(llint i = 0; i < N; i++){\n\t\t\tfor(llint j = 0; j < 3; j++){\n\t\t\t\tcin >> L[i][j];\n\t\t\t}\n\t\t\tsort(L[i], L[i]+3);\n\t\t}\n\t\t\n\t\tfor(llint i = 0; i < N; i++) g[i].clear();\n\t\tfor(llint i = 0; i < N; i++){\n\t\t\tfor(llint j = 0; j < N; j++){\n\t\t\t\tif(compare(i, j)){\n\t\t\t\t\tg[i].push_back(Edge(j, volume(j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tS = 2*N+1, T = 2*N+2;\n\t\tfor(llint i = 0; i <= T; i++) G[i].clear();\n\t\tfor(llint i = 0; i < N; i++){\n\t\t\tfor(llint j = 0; j < g[i].size(); j++){\n\t\t\t\tadd_edge(i, N+g[j][j].to, inf, -g[i][j].cost);\n\t\t\t}\n\t\t}\n\t\tfor(llint i = 0; i < N; i++){\n\t\t\tadd_edge(S, i, 1, 0);\n\t\t\tadd_edge(i+N, T, 1, 0);\n\t\t}\n\t\t\n\t\tllint ans = 0;\n\t\twhile(1){\n\t\t\tBellmanFord();\n\t\t\tif(dist[T] >= inf / 2) break;\n\t\t\t\n\t\t\tllint p = T, flow = N;\n\t\t\twhile(prevv[p] != -1){\n\t\t\t\tflow = min(flow, G[prevv[p]][preve[p]].cap);\n\t\t\t\tp = prevv[p];\n\t\t\t}\n\t\t\t\n\t\t\tp = T;\n\t\t\twhile(prevv[p] != -1){\n\t\t\t\tG[prevv[p]][preve[p]].cap -= flow;\n\t\t\t\tG[p][G[prevv[p]][preve[p]].rev].cap += flow;\n\t\t\t\tp = prevv[p];\n\t\t\t}\n\t\t\tans += dist[T] * flow;\n\t\t}\n\t\t\n\t\tllint sum = 0;\n\t\tfor(llint i = 0; i < N; i++) sum += volume(i);\n\t\tans = sum + ans;\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\n\nstruct Edge{\n\tllint to, cost;\n\tEdge(){}\n\tEdge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint N;\nllint L[105][3];\nvector<Edge> g[105];\n\nllint volume(llint x)\n{\n\tllint ret = 1;\n\tfor(llint i = 0; i < 3; i++) ret *= L[x][i];\n\treturn ret;\n}\n\nbool compare(llint x, llint y)\n{\n\tfor(llint i = 0; i < 3; i++){\n\t\tif(L[x][i] <= L[y][i]) return false;\n\t}\n\treturn true;\n}\n\n\nstruct edge{\n\tllint to, cap, cost, rev;\n\tedge(){}\n\tedge(llint a, llint b, llint c, llint d){\n\t\tto = a, cap = b, cost = c, rev = d;\n\t}\n};\n\n\nllint S, T;\nvector<edge> G[205];\nllint dist[205];\nllint prevv[205], preve[205];\n\nvoid BellmanFord()\n{\n\tfor(llint i = 0; i <= T; i++) dist[i] = inf;\n\tdist[S] = 0, prevv[S] = -1;\n\t\n\tbool update = true;\n\twhile(update){\n\t\tupdate = false;\n\t\tfor(llint i = 0; i <= T; i++){\n\t\t\tfor(llint j = 0; j < G[i].size(); j++){\n\t\t\t\tif(G[i][j].cap == 0) continue;\n\t\t\t\tif(dist[G[i][j].to] > dist[i] + G[i][j].cost){\n\t\t\t\t\tdist[G[i][j].to] = dist[i] + G[i][j].cost;\n\t\t\t\t\tprevv[G[i][j].to] = i;\n\t\t\t\t\tpreve[G[i][j].to] = j;\n\t\t\t\t\tupdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid add_edge(llint from, llint to, llint cap, llint cost)\n{\n\tG[from].push_back( edge(to, cap, cost, G[to].size()) );\n\tG[to].push_back( edge(from, 0, -cost, G[from].size()-1) );\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N;\n\t\tif(N == 0) break;\n\t\tfor(llint i = 0; i < N; i++){\n\t\t\tfor(llint j = 0; j < 3; j++){\n\t\t\t\tcin >> L[i][j];\n\t\t\t}\n\t\t\tsort(L[i], L[i]+3);\n\t\t}\n\t\t\n\t\tfor(llint i = 0; i < N; i++) g[i].clear();\n\t\tfor(llint i = 0; i < N; i++){\n\t\t\tfor(llint j = 0; j < N; j++){\n\t\t\t\tif(compare(i, j)){\n\t\t\t\t\tg[i].push_back(Edge(j, volume(j)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*for(llint i = 0; i < N; i++){\n\t\t\tcout << \"* \";\n\t\t\tfor(llint j = 0; j < g[i].size(); j++){\n\t\t\t\tcout << g[i][j].to << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\t\n\t\tS = 2*N+1, T = 2*N+2;\n\t\tfor(llint i = 0; i <= T; i++) G[i].clear();\n\t\tfor(llint i = 0; i < N; i++){\n\t\t\tfor(llint j = 0; j < g[i].size(); j++){\n\t\t\t\tadd_edge(i, N+j, inf, -g[i][j].cost);\n\t\t\t}\n\t\t}\n\t\tfor(llint i = 0; i < N; i++){\n\t\t\tadd_edge(S, i, 1, 0);\n\t\t\tadd_edge(i+N, T, 1, 0);\n\t\t}\n\t\t\n\t\tllint ans = 0;\n\t\twhile(1){\n\t\t\tBellmanFord();\n\t\t\tif(dist[T] >= inf / 2) break;\n\t\t\t\n\t\t\tllint p = T, flow = N;\n\t\t\twhile(prevv[p] != -1){\n\t\t\t\tflow = min(flow, G[prevv[p]][preve[p]].cap);\n\t\t\t\tp = prevv[p];\n\t\t\t}\n\t\t\t\n\t\t\tp = T;\n\t\t\twhile(prevv[p] != -1){\n\t\t\t\tG[prevv[p]][preve[p]].cap -= flow;\n\t\t\t\tG[p][G[prevv[p]][preve[p]].rev].cap += flow;\n\t\t\t\tp = prevv[p];\n\t\t\t}\n\t\t\tans += dist[T] * flow;\n\t\t}\n\t\t\n\t\tllint sum = 0;\n\t\tfor(llint i = 0; i < N; i++) sum += volume(i);\n\t\tans = sum + ans;\n\t\tcout << ans << endl;;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n\nclass MinCostFlow{\npublic:\n    struct edge{\n        int to;\n        int cap;\n        int cost;\n        int rev;\n    };\n    int V;\n    int inf;\n    vector<vector<edge> > G;\n    vector<int> h,dist;\n    vector<int> prevv,preve;\n    MinCostFlow(int node_size): V(node_size),inf(numeric_limits<int>::max()/4),G(V),h(V,0),dist(V),prevv(V),preve(V){}\n    void add_edge(int from, int to,int cap,int cost){\n        G[from].push_back((edge){to,cap,cost,(int)G[to].size()});\n        G[to].push_back((edge){from,0,-cost,(int)G[from].size()-1});\n    }\n    int solve(int s,int t){\n        int res = 0;\n        int f = inf;\n        while(1){\n            priority_queue<pair<int,int>,vector<pair<int,int> > ,greater<pair<int,int>> > que;\n            fill(dist.begin(),dist.end(),inf);\n            dist[s] = 0;\n            que.push(pair<int,int>(0,s));\n            while(!que.empty()){\n                pair<int,int> p = que.top();\n                que.pop();\n                int v = p.second;\n                if(dist[v] < p.first) continue;\n                for(int i=0;i<(int)G[v].size();i++){\n                    edge& e = G[v][i];\n                    if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        prevv[e.to] = v,preve[e.to] = i;\n                        que.push(pair<int,int>(dist[e.to],e.to)); \n                    }\n                }\n            }\n            if(dist[t]==inf)break;\n            for(int i=0;i<V;i++){\n                h[i] += dist[i];\n            }\n            int d = f;\n            for(int v = t;v !=s;v = prevv[v]){\n                d = min(d,G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += h[t]*d;\n            for(int v = t;v != s;v = prevv[v]){\n                edge& e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint a[3][101];\n\nbool contain(int i,int j){ // i -> j\n    vector<int> p(3);\n    p[0] = 0;\n    p[1] = 1;\n    p[2] = 2;\n    bool flag = 0;\n    do{\n        bool fff = 1;\n        rep(k,3){\n            if(a[k][i] <= a[p[k]][j])fff = 0;\n        }\n        if(fff)flag = 1;\n    }while(next_permutation(p.begin(),p.end()));\n    return flag;\n}\nint main(){\n    int n;\n    while(cin >> n && n!=0){\n        int sm = 0;\n        rep(i,n){\n            cin >> a[0][i] >> a[1][i] >> a[2][i];\n            sm += a[0][i]*a[1][i]*a[2][i];\n        }\n        MinCostFlow mf(2*n+2);\n        int s = 0;\n        int t = 2*n+1;\n        \n        rep(i,n){\n            mf.add_edge(s,i+1,1,0);\n            mf.add_edge(i+n+1,t,1,0);\n        }\n        rep(i,n){\n            rep(j,n){\n                if(i==j)continue;\n                if(contain(i,j)){\n                    mf.add_edge(i+1,j+n+1,1,-a[0][j]*a[1][j]*a[2][j]);\n                    // cerr << i << \" \" << j  << \" \" << a[0][j]*a[1][j]*a[2][j] << endl;\n                }\n            }\n        }\n        cout << sm + mf.solve(s,t) << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e9;\n\nclass min_cost_flow {\n\tusing pii = pair<int, int>;\n\tstruct edge {\n\t\tint to, cap, cost, rev;\n\t\tedge(int to_, int cap_, int cost_, int rev_)\n\t\t\t: to(to_), cap(cap_), cost(cost_), rev(rev_) {}\n\t};\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> h, dist, prevv, preve;\npublic:\n\tmin_cost_flow(int _V) : V(_V), G(_V), h(_V), dist(_V), prevv(_V), preve(_V) {}\n\tvoid add(int from, int to, int cap, int cost) {\n\t\tG[from].push_back(edge(to, cap, cost, G[to].size()));\n\t\tG[to].push_back(edge(from, 0, -cost, G[from].size() - 1));\n\t}\n\tint calc(int s, int t, int f) {\n\t\tint res = 0;\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<pii, vector<pii>, greater<pii>> que;\n\t\t\tfill(dist.begin(), dist.end(), INF);\n\t\t\tdist[s] = 0;\n\t\t\tque.push(pii(0, s));\n\t\t\twhile (!que.empty()) {\n\t\t\t\tpii p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first) continue;\n\t\t\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push(pii(dist[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == INF) return -1;\n\t\t\tfor (int v = 0; v < V; v++)\n\t\t\t\th[v] += dist[v];\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint N;\n\twhile (cin >> N, N) {\n\t\tvector<int> x(N), y(N), z(N);\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tcin >> x[i] >> y[i] >> z[i];\n\t\t\tvector<int> tp = { x[i], y[i], z[i] };\n\t\t\tsort(tp.begin(), tp.end());\n\t\t\tx[i] = tp[0];\n\t\t\ty[i] = tp[1];\n\t\t\tz[i] = tp[2];\n\t\t\tsum += x[i] * y[i] * z[i];\n\t\t}\n\t\tmin_cost_flow mcf(N * 2 + 2);\n\t\tint s = N * 2, t = N * 2 + 1;\n\t\tmcf.add(s, t, INF, 0);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tmcf.add(s, i, 1, 0);\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (x[i] < x[j] && y[i] < y[j] && z[i] < z[j]) {\n\t\t\t\t\tmcf.add(i, N + j, 1, -x[i] * y[i] * z[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tmcf.add(N + i, t, 1, 0);\n\t\t}\n\t\tcout << sum + mcf.calc(s, t, INF) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct PrimalDual{\n  const int INF = 1<<28;\n  typedef pair<int,int> P;\n  struct edge{\n    int to,cap,cost,rev;\n    edge(){}\n    edge(int to,int cap,int cost,int rev):to(to),cap(cap),cost(cost),rev(rev){}\n  };\n\n  int n;\n  vector<vector<edge> > G;\n  vector<int> h,dist,prevv,preve;\n\n  PrimalDual(){}\n  PrimalDual(int sz):n(sz),G(sz),h(sz),dist(sz),prevv(sz),preve(sz){}\n  \n  void add_edge(int from,int to,int cap,int cost){\n    G[from].push_back(edge(to,cap,cost,G[to].size()));\n    G[to].push_back(edge(from,0,-cost,G[from].size()-1));\n  }\n\n  int flow(int s,int t,int f){\n    int res=0;\n    fill(h.begin(),h.end(),0);\n    while(f>0){\n      priority_queue<P,vector<P>,greater<P> > que;\n      fill(dist.begin(),dist.end(),INF);\n      dist[s]=0;\n      que.push(P(0,s));\n      while(!que.empty()){\n        P p=que.top();que.pop();\n        int v=p.second;\n        if(dist[v]<p.first) continue;\n        for(int i=0;i<(int)G[v].size();i++){\n          edge &e=G[v][i];\n          if(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n            dist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n            prevv[e.to]=v;\n            preve[e.to]=i;\n            que.push(P(dist[e.to],e.to));\n          }\n        }\n      }\n      if(dist[t]==INF) return -1;\n      for(int v=0;v<n;v++) h[v]+=dist[v];\n      int d=f;\n      for(int v=t;v!=s;v=prevv[v]){\n        d=min(d,G[prevv[v]][preve[v]].cap);\n      }\n      f-=d;\n      res+=d*h[t];\n      for(int v=t;v!=s;v=prevv[v]){\n        edge &e=G[prevv[v]][preve[v]];\n        e.cap-=d;\n        G[v][e.rev].cap+=d;\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    PrimalDual p(n*2+2);\n    int sum=0,cube[n],a[3];\n    vector<vector<int> >v(n);\n    r(i,n){\n      r(j,3)cin>>a[j];\n      sort(a,a+3);\n      sum+=a[0]*a[1]*a[2];\n      cube[i]=a[0]*a[1]*a[2];\n      r(j,3)v[i].push_back(a[j]);\n    }\n    r(i,n){\n      r(j,n){\n        int c=0;\n        r(k,3)if(v[i][k]>v[j][k])c++;\n        if(c==3){\n          p.add_edge(i,n+j,1,-cube[j]);\n        }\n      }\n    }\n    r(i,n)p.add_edge(n*2,i,1,0);\n    r(i,n)p.add_edge(i+n,n*2+1,1,0);\n    r(i,n)p.add_edge(i,n*2+1,1,0);\n    cout<<sum+p.flow(n*2,n*2+1,n)<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing weight = int;\nusing P = std::pair<int, int>;\n\nconstexpr int INF = 1e9;\n\nstruct edge {\n    int to, cap;\n    weight cost;\n    int rev;\n};\n\nusing edges = std::vector<edge>;\nusing graph = std::vector<edges>;\n\nvoid add_edge(graph& g, int from, int to, int cap, weight cost) {\n    g[from].push_back(edge{to, cap, cost, (int)g[to].size()});\n    g[to].push_back(edge{from, 0, -cost, (int)g[from].size()-1});\n}\n\n// verified\nweight min_cost_flow(graph& g, int s, int t, weight f) {\n    weight res = 0;\n    std::vector<weight> h(g.size(), 0);\n    std::vector<weight> dist(g.size());\n    std::vector<int> prevv(g.size()), preve(g.size());\n    std::fill(h.begin(), h.end(), 0);\n    while(f > 0) {\n        std::priority_queue<P, std::vector<P>, std::greater<P>> que;\n        std::fill(dist.begin(), dist.end(), INF);\n        dist[s] = 0;\n        que.push(P{0, s});\n        while(!que.empty()) {\n            P p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v] < p.first) {\n                continue;\n            }\n            for(int i=0; i<g[v].size(); ++i) {\n                edge& e = g[v][i];\n                if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(P{dist[e.to], e.to});\n                }\n            }\n        }\n        if(dist[t] == INF) {\n            return -1;\n        }\n        for(int v=0; v<g.size(); ++v) {\n            h[v] += dist[v];\n        }\n\n        weight d = f;\n        for(int v=t; v!=s; v=prevv[v]) {\n            d = min(d, g[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for(int v=t; v!=s; v=prevv[v]) {\n            edge& e = g[prevv[v]][preve[v]];\n            e.cap -= d;\n            g[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main() {\n    int N;\n    while(cin >> N, N) {\n        int sum = 0;\n        vector<vector<int>> v(N, vector<int>(3));\n        for(int i = 0; i < N; ++i) {\n            cin >> v[i][0] >> v[i][1] >> v[i][2];\n            sort(begin(v[i]), end(v[i]));\n            sum += v[i][0] * v[i][1] * v[i][2];\n        }\n        graph g(2 * N + 3);\n        const int source = 2 * N;\n        const int dummy = source + 1;\n        const int dest = dummy + 1;\n        for(int i = 0; i < N; ++i) {\n            for(int j = 0; j < N; ++j) {\n                if(i == j) {\n                    continue;\n                }\n                if(v[i][0] < v[j][0] && v[i][1] < v[j][1] && v[i][2] < v[j][2]) {\n                    add_edge(g, j, i + N, 1, -v[i][0] * v[i][1] * v[i][2]);\n                }\n            }\n            add_edge(g, source, i, 1, 0);\n            add_edge(g, i + N, dest, 1, 0);\n        }\n        add_edge(g, source, dummy, INF, 0);\n        add_edge(g, dummy, dest, INF, 0);\n\n        cout << sum + min_cost_flow(g, source, dest, N) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define reps(i, n, m) for (int i = (int) (n); i < (int) (m); i++)\n#define rep(i, n) reps(i, 0, n)\n\nstruct edge {\n\tint to;\n\tint flow;\n\tint cost;\n\tint rev;\n\tedge(int a, int b, int c, int d) : to(a), flow(b), cost(c), rev(d) {}\n};\n\nint N;\nvector<vector<edge>> e;\nconst int INF = 1e9;\n\nvoid add_edge(int from, int to, int flow, int cost)\n{\n\te[from].emplace_back(to, flow, cost, e[to].size());\n\te[to].emplace_back(from, 0,  -cost, e[from].size()-1);\n}\n\nbool init()\n{\n\tcin >> N;\n\tif (N == 0) return false;\t\n\te.clear();\n\te.resize(N * 2 + 2);\n\tconst int S = N * 2;\n\tconst int G = N * 2 + 1;\n\tvector<tuple<int, int,int>> s;\n\trep(i, N) {\n//\t\te[S].emplace_back(i, 1, 0, e[i].size());\n//\t\te[i].emplace_back(S, 0, 0, e[S].size()-1);\n\t\tadd_edge(S, i, 1, 0);\n\t\tint t = i + N;\n//\t\te[t].emplace_back(G, 1, 0, e[G].size());\n//\t\te[G].emplace_back(t, 0, 0, e[t].size()-1);\n\t\tadd_edge(t, G, 1, 0);\n\t}\n\trep(i, N) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tvector<int> t{a, b, c};\n\t\tsort(t.begin(), t.end());\n\t\ts.emplace_back(t[0], t[1], t[2]);\n\t}\n\tsort(s.begin(), s.end());\n\trep(i, N) {\n\t\tint cost = get<0>(s[i]) * get<1>(s[i]) * get<2>(s[i]);\n//\t\te[i].emplace_back(G, 1, cost, e[G].size());\n//\t\te[G].emplace_back(i, 1, -cost, e[i].size()-1);\n\t\tadd_edge(i, G, 1, cost);\n\t\treps(j, i+1, N) {\n\t\t\tif (get<0>(s[i]) < get<0>(s[j]) &&\n\t\t\t\tget<1>(s[i]) < get<1>(s[j]) &&\n\t\t\t\tget<2>(s[i]) < get<2>(s[j])) {\n//\t\t\t\te[i].emplace_back(j, 1, 0, e[i].size());\n//\t\t\t\te[j].emplace_back(i, 0, 0, e[i].size()-1);\n\t\t\t\tadd_edge(i, j + N, 1, 0);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\n\nint min_cost_flow(int s, int t, int f, int V)\n{\n\tint res = 0;\n\tvector<int> dist(V, INF);\n\tvector<int> prevv(V);\n\tvector<int> preve(V);\n\twhile (f > 0) {\n\t\tfill(dist.begin(), dist.end(), INF);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile (update) {\n\t\t\tupdate = false;\n\t\t\trep(v, V) {\n\t\t\t\tif (dist[v] == INF) continue;\n\t\t\t\trep(i, e[v].size()) {\n\t\t\t\t\tedge& E = e[v][i];\n\t\t\t\t\tif (E.flow > 0 && dist[v] + E.cost < dist[E.to]) {\n\t\t\t\t\t\tdist[E.to] = dist[v] + E.cost;\n\t\t\t\t\t\tprevv[E.to] = v;\n\t\t\t\t\t\tpreve[E.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, e[prevv[v]][preve[v]].flow);\n\t\t}\n\t\tf -= d;\n\t\tres += d * dist[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge& E = e[prevv[v]][preve[v]];\n\t\t\tE.flow -= d;\n\t\t\te[v][E.rev].flow += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint solve()\n{\n\treturn min_cost_flow(N * 2, N * 2 + 1, N, N * 2 + 2);\n}\n\nint main()\n{\n\twhile (init()) {\n\t\tcout << solve() << endl;\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1LL<<59)\n\n#define MAX_V (100*2+2)\nstruct edge { int to, cap, cost, rev;};\n\nvector<edge> G[MAX_V];\nvector<int> h(MAX_V);\nvector<int> dist(MAX_V);\nint prevv[MAX_V], preve[MAX_V];\n\nvoid add_edge(int form, int to, int cap, int cost){\n    G[form].push_back((edge){to, cap, cost, (int)G[to].size()});\n    G[to].push_back((edge){form, 0, -cost, (int)G[form].size() - 1});\n}\n\nvoid shortest_path(int s, vector<int> &d){\n    int v = d.size();\n    rep(i,d.size())d[i]=INF;\n    d[s]=0;\n    rep(loop,v){\n        rep(i,v){\n            for(auto e:G[i]){\n                if(e.cap && d[i]!=INF && d[e.to]>d[i]+e.cost)\n                    d[e.to]=d[i]+e.cost;\n            }\n        }\n    }\n}\n\nint min_cost_flow(int s, int t, int f){\n    int res = 0;\n    shortest_path(s,h);\n\n    while(f>0){\n        priority_queue<pii,vector<pii>, greater<pii> >que;\n        rep(i,dist.size())dist[i]=INF;\n        dist[s] = 0;\n        que.push(pii(0,s));\n        while(!que.empty()){\n            pii p = que.top();\n            que.pop();\n            int v = p.second;\n            if(dist[v]<p.first)continue;\n            for(int i=0;i<G[v].size();i++){\n                edge &e = G[v][i];\n                if(e.cap>0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.push(pii(dist[e.to], e.to));\n                }\n            }\n        }\n        if(dist[t]==INF)return -INF;\n\n        for(int v=0;v<h.size();v++)h[v]+=dist[v];\n\n        int d=f;\n        for(int v=t;v!=s;v=prevv[v]){\n            d=min(d,G[prevv[v]][preve[v]].cap);\n        }\n        f-=d;\n        res+=d*h[t];\n        for(int v=t;v!=s;v=prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap-=d;\n            G[v][e.rev].cap+=d;\n        }\n    }\n    return res;\n}\n\nstruct data{\n    int x,y,z;\n\n    bool operator < (data obj) const{\n        if(x<obj.x && y<obj.y && z<obj.z)return true;\n        else return false;\n    }\n};\n\nint taiseki(int a, int b, int c){\n    return a*b*c;\n}\n\n\n/*\n vector<edge> G[MAX_V];\n vector<int> h(MAX_V);\n vector<int> dist(MAX_V);\n int prevv[MAX_V], preve[MAX_V];\n */\n\nsigned main(){\n    int n;\n    while(cin>>n&&n){\n        rep(i,MAX_V)G[i].clear();\n        rep(i,h.size())h[i] = 0;\n        rep(i,dist.size())dist[i] = 0;\n        rep(i,MAX_V)prevv[i] = preve[i] = 0;\n\n        vector<data> v(n);\n        rep(i,n){\n            vector<int> tt(3);\n            rep(j,3)cin>>tt[j];\n            sort(all(tt));\n            v[i] = data{tt[0],tt[1],tt[2]};\n        }\n\n        int S = 2*n;\n        int T = S+1;\n\n        rep(i,n) add_edge(S  , i  , 1, 0);\n        rep(i,n) add_edge(i  , n+i, 1, 0);\n        rep(i,n) add_edge(n+i, T  , 1, 0);\n\n        add_edge(S,T,INF,0);\n\n        rep(i,n){\n            rep(j,n){\n                if(i==j)continue;\n                if(v[i]<v[j]){\n                    add_edge(j+n, i, 1, -taiseki(v[i].x, v[i].y, v[i].z));\n                }\n            }\n        }\n\n        int sum = 0;\n        rep(i,v.size()){\n            sum+=taiseki(v[i].x, v[i].y, v[i].z);\n        }\n        int res = min_cost_flow(S,T,n);\n        cout<<sum + res<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i, n) for(int i = 0; i < n; ++i)\n#define vi vector<int>\n#define all(c) (c).begin(), (c).end()\n\ntemplate <typename T> T hungarian(vector<vector<T>> &A) {\n    const T infty = numeric_limits<T>::max();\n    const int N = (int)A.size();\n    const int M = (int)A[0].size();\n    vector<int> P(M), way(M);\n    vector<T> U(N, 0), V(M, 0), minV;\n    vector<bool> used;\n\n    for(int i = 1; i < N; i++) {\n        P[0] = i;\n        minV.assign(M, infty);\n        used.assign(M, false);\n        int j0 = 0;\n        while(P[j0] != 0) {\n            int i0 = P[j0], j1 = 0;\n            used[j0] = true;\n            T delta = infty;\n            for(int j = 1; j < M; j++) {\n                if(used[j]) continue;\n                T curr = A[i0][j] - U[i0] - V[j];\n                if(curr < minV[j]) minV[j] = curr, way[j] = j0;\n                if(minV[j] < delta) delta = minV[j], j1 = j;\n            }\n            for(int j = 0; j < M; j++) {\n                if(used[j])\n                    U[P[j]] += delta, V[j] -= delta;\n                else\n                    minV[j] -= delta;\n            }\n            j0 = j1;\n        }\n        do {\n            P[j0] = P[way[j0]];\n            j0 = way[j0];\n        } while(j0 != 0);\n    }\n    return -V[0];\n}\n\nmain() {\n    while(1) {\n        int n;\n        cin >> n;\n        if(!n) return 0;\n        vi x(n), y(n), z(n);\n        rep(i, n) cin >> x[i] >> y[i] >> z[i];\n        vi id(n);\n        rep(i, n) {\n            vi v{x[i], y[i], z[i]};\n            sort(all(v));\n            x[i] = v[0], y[i] = v[1], z[i] = v[2];\n        }\n        vector<vi> a(n + 1, vi(n + 1));\n        int ans = 0;\n        rep(i, n) rep(j, n) {\n            if(x[i] < x[j] and y[i] < y[j] and z[i] < z[j]) { a[i + 1][j + 1] = -x[i] * y[i] * z[i]; }\n        }\n        rep(i, n) ans += x[i] * y[i] * z[i];\n        cout << ans + hungarian(a) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\ntypedef long long  Weight;\nstruct Edge {\n\tint src, dest;\n\tint cap, rev;\n\tWeight weight;\n\tbool operator < (const Edge &rhs) const { return weight > rhs.weight; }\n};\n\nconst int V = 4000;\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nWeight h[V];                //ポテンシャル\nWeight dist[V];             //最短距離\nint prevv[V], preve[V];  //直前の辺と頂点\n\nvoid add_edge(Graph &g, int src, int dest, int cap, Weight weight) {\n\tg[src].push_back(Edge{ src, dest, cap, (int)g[dest].size(), weight });\n\tg[dest].push_back(Edge{ dest, src, 0, (int)g[src].size() - 1, -weight });\n}\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst Weight INF = 2147483647;\nconst Weight ZERO=0;\n//コストがdoubleの時はeps使おう\nWeight min_cost_flow(Graph &g, int s, int t, int f) {\n\tWeight res = ZERO;\n\tmemset(h, ZERO, sizeof(h));\n\ttypedef pair<Weight, int> P;\n//ポテンシャルを先に計算して速度向上\n//REP(i, g.size() / 2 - 1) {\n//\tint v = i + 2;\n//\tREP(j, g[v].size()) {\n//\t\tEdge &e = g[v][j];\n//\t\tif (e.cap == 0) continue;\n//\t\tint u = e.dest;\n//\t\th[u] = min(h[u], h[v] + e.weight);\n//\t}\n//\tv = i + g.size() / 2 + 1;\n//\tREP(j, g[v].size()) {\n//\t\tEdge &e = g[v][j];\n//\t\tif (e.cap == 0) continue;\n//\t\tint u = e.dest;\n//\t\th[u] = min(h[u], h[v] + e.weight);\n//\t}\n//}\n\twhile (f > 0) {\n\t\tpriority_queue<P, vector<P>, greater<P> > que;\n\t\tfill(dist, dist + V, INF);\n\t\tdist[s] = 0;\n\t\tque.push(P(ZERO, s));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tconst int v = p.second;\n\t\t\tif (dist[v] < p.first) continue;\n\t\t\tREP(i, g[v].size()) {\n\t\t\t\tEdge &e = g[v][i];\n\t\t\t\tif (e.cap > 0 && dist[e.dest] > dist[v] + e.weight + h[v] - h[e.dest]) {\n\t\t\t\t\tdist[e.dest] = dist[v] + e.weight + h[v] - h[e.dest];\n\t\t\t\t\tprevv[e.dest] = v;\n\t\t\t\t\tpreve[e.dest] = i;\n\t\t\t\t\tque.push(P(dist[e.dest], e.dest));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == INF) return -1;\n\t\tfor(int v=0;v<V;++v) h[v] = h[v] + dist[v];\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) d = min(d, g[prevv[v]][preve[v]].cap);\n\t\tf -= d;\n\t\tres = res + d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tg[v][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint ar(vector<int>&s) {\n\treturn s[0]*s[1]*s[2];\n}\n\nint main()\n{\n\twhile (true) {\n\t\tint N;cin>>N;\n\t\tif(!N)break;\n\t\tvector<vector<int>>matos;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint a,b,c;cin>>a>>b>>c;\n\t\t\tmatos.emplace_back(vector<int>{ a,b,c });\n\t\t}\n\n\t\tconst int start=0;\n\t\tconst int ma_in=start+1;\n\t\tconst int ma_out=ma_in+N;\n\t\tconst int goal=ma_out+N;\n\t\tGraph g(goal+1);\n\t\tfor (int i = 0; i < N; ++i) {\n\n\t\t\tadd_edge(g,start,ma_in+i,1,0);\n\t\t\t\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tauto mato_i(matos[i]);\n\t\t\t\tauto mato_j(matos[j]);\n\n\t\t\t\tvector<int>perms(3);\n\t\t\t\tiota(perms.begin(),perms.end(),0);\n\n\t\t\t\tbool ok=false;\n\t\t\t\tdo {\n\t\t\t\t\tbool nok=true;\n\t\t\t\t\tfor (int d = 0; d < 3; ++d) {\n\t\t\t\t\t\tif (mato_i[d] >= mato_j[perms[d]]) {\n\t\t\t\t\t\t\tnok=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(nok)ok=true;\n\t\t\t\t}while(next_permutation(perms.begin(),perms.end()));\n\n\t\t\t\tif (ok) {\n\t\t\t\t\tadd_edge(g,ma_in+i,ma_out+j,1,0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tadd_edge(g,ma_in+i,goal,1,ar(matos[i]));\n\t\t\tadd_edge(g,ma_out+i,goal,1,0);\n\t\t}\n\n\t\tint ans=min_cost_flow(g,start,goal,N);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxi 1000000 \n#define INF 1000000007\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to,cap,cost,rev;\n\tedge(){}\n\tedge(int tt,int cc,int co,int rr){\n\t\tto=tt;\n\t\tcap=cc;\n\t\tcost=co;\n\t\trev=rr;\n\t}\n};\n\nvector<edge> G[1000];\nint V;\nint h[1001];\nint dist[1001];\nint prevv[1001],preve[1001];\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tG[from].push_back(edge(to,cap,cost,G[to].size()));\n\tG[to].push_back(edge(from,0,-cost,G[from].size()-1));\n}\n\nint min_cost_flow(int s,int t,int f){\n\tint res=0;\n\tfill(h,h+V,0);\n\twhile(f>0){\n\t\tpriority_queue<P,vector<P>,greater<P> > que;\n\t\tfill(dist,dist+V,INF);\n\t\tdist[s]=0;\n\t\tque.push(P(0,s));\n\t\twhile(que.size()){\n\t\t\tP p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(dist[v]<p.first)continue;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\tprevv[e.to]=v;\n\t\t\t\t\tpreve[e.to]=i;\n\t\t\t\t\tque.push(P(dist[e.to],e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t]==INF)return -1;\n\t\tfor(int v=0;v<V;v++){\n\t\t\th[v]+=dist[v];\n\t\t}\n\t\tint d=f;\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\td=min(d,G[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf-=d;\n\t\tres+=d*h[t];\n\t\tfor(int v=t;v!=s;v=prevv[v]){\n\t\t\tedge &e=G[prevv[v]][preve[v]];\n\t\t\te.cap-=d;\n\t\t\tG[v][e.rev].cap+=d;\n\t\t}\n\t}\n\treturn res;\n}\n\nint n;\nint d[101][3];\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tint all=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%d%d%d\",&d[i][0],&d[i][1],&d[i][2]);\n\t\t\tsort(d[i],d[i]+3);\n\t\t\tall+=d[i][0]*d[i][1]*d[i][2];\n\t\t}\n\t\tint s=n*2,t=s+1;\n\t\tV=t+1;\n\t\tfor(int i=0;i<=t;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tadd_edge(s,i,1,0);\n\t\t\tadd_edge(i+n,t,1,0);\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tbool flag=true;\n\t\t\t\tfor(int k=0;k<3;k++){\n\t\t\t\t\tif(d[i][k]<=d[j][k])flag=false;\n\t\t\t\t}\n\t\t\t\tif(flag){\n\t\t\t\t\tadd_edge(i,n+j,1,maxi-d[j][0]*d[j][1]*d[j][2]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint v=min_cost_flow(s,t,1);\n\t\t\tif(v>=0){\n\t\t\t\tres+=maxi-v;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",all-res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 305\n\n\n//辺を表す構造体{行先、容量、コスト、逆辺のインデックス}\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_cost,int arg_rev_index){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\tcost = arg_cost;\n\t\trev_index = arg_rev_index;\n\t}\n\n\tint to,capacity,cost,rev_index;\n};\n\nstruct Info{\n\tint x,y,z;\n};\n\nint N;\nint V; //頂点数\nint in_index[105],out_index[105];\nint dist[NUM]; //最短距離\nint pre_node[NUM],pre_edge[NUM]; //直前の頂点と辺\nvector<Edge> G[NUM]; //グラフの隣接リスト表現\nInfo info[105];\n\n\n//fromからtoへ向かう容量capacity,コストcostの辺をグラフに追加する\nvoid add_edge(int from,int to,int capacity,int cost){\n\tG[from].push_back(Edge(to,capacity,cost,G[to].size()));\n\tG[to].push_back(Edge(from,0,-cost,G[from].size()-1));\n}\n\n//sourceからsinkへの、流量flowの最小費用流を求める\n//流せない場合は-1を返す\nint min_cost_flow(int source,int sink,int flow){\n\tint ret = 0;\n\twhile(flow > 0){\n\t\t//ベルマンフォード方により、source-sink間最短経路を求める\n\t\tfor(int i = 0; i < V; i++)dist[i] = BIG_NUM;\n\t\tdist[source] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t\tupdate = false;\n\t\t\tfor(int node_id = 0; node_id < V; node_id++){\n\t\t\t\tif(dist[node_id] == BIG_NUM)continue;\n\t\t\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\t\t\tEdge &e = G[node_id][i];\n\t\t\t\t\tif(e.capacity > 0 && dist[e.to] > dist[node_id]+e.cost){\n\t\t\t\t\t\tdist[e.to] = dist[node_id]+e.cost; //node_idを経由した方が早い場合\n\t\t\t\t\t\tpre_node[e.to] = node_id;\n\t\t\t\t\t\tpre_edge[e.to] = i;\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(dist[sink] == BIG_NUM){\n\t\t\t//これ以上流せない\n\t\t\treturn -1;\n\t\t}\n\n\t\t//source-sink間最短路に沿って目いっぱい流す\n\t\tint tmp_flow = flow;\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\ttmp_flow = min(tmp_flow,G[pre_node[node_id]][pre_edge[node_id]].capacity);\n\t\t}\n\t\tflow -= tmp_flow;\n\t\tret += tmp_flow*dist[sink];\n\t\tfor(int node_id = sink; node_id != source; node_id = pre_node[node_id]){\n\t\t\tEdge &e = G[pre_node[node_id]][pre_edge[node_id]];\n\t\t\te.capacity -= tmp_flow;\n\t\t\tG[node_id][e.rev_index].capacity += tmp_flow;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < NUM; i++)G[i].clear();\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%d %d %d\",&info[i].x,&info[i].y,&info[i].z);\n\t}\n\n\tint source = 0,sink = 1,index = 2;\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tin_index[i] = index++;\n\t\tadd_edge(source,in_index[i],1,0);\n\t\tadd_edge(in_index[i],sink,1,info[i].x*info[i].y*info[i].z);\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tout_index[i] = index++;\n\t\tadd_edge(out_index[i],sink,1,0); //★★コスト0用ノード★★\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\t//自分を仕舞える人形に辺を張る\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif((info[i].x < info[k].x && info[i].y < info[k].y && info[i].z < info[k].z) ||\n\t\t\t\t(info[i].x < info[k].x && info[i].y < info[k].z && info[i].z < info[k].y) ||\n\t\t\t\t(info[i].x < info[k].y && info[i].y < info[k].x && info[i].z < info[k].z) ||\n\t\t\t\t(info[i].x < info[k].y && info[i].y < info[k].z && info[i].z < info[k].x) ||\n\t\t\t\t(info[i].x < info[k].z && info[i].y < info[k].x && info[i].z < info[k].y) ||\n\t\t\t\t(info[i].x < info[k].z && info[i].y < info[k].y && info[i].z < info[k].x)\n\t\t\t){\n\t\t\t\tadd_edge(in_index[i],out_index[k],1,0); //仕舞われることを、コスト0の辺で表す\n\t\t\t}\n\t\t}\n\t}\n\n\tV = index;\n\n\tprintf(\"%d\\n\",min_cost_flow(source,sink,N));\n}\n\nint main(){\n\n\twhile(true){\n\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n    const cost_t INF;\n\n    struct edge {\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;\n        bool isrev;\n    };\n    vector< vector< edge > > graph;\n    vector< cost_t > potential, min_cost;\n    vector< int > prevv, preve;\n\n    PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n    void add_edge(int from, int to, flow_t cap, cost_t cost) {\n        graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n        graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n    }\n\n    cost_t min_cost_flow(int s, int t, flow_t f) {\n        int V = (int) graph.size();\n        cost_t ret = 0;\n        using Pi = pair< cost_t, int >;\n        priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n\n        while(f > 0) {\n            min_cost.assign(V, INF);\n            que.emplace(0, s);\n            min_cost[s] = 0;\n            while(!que.empty()) {\n                Pi p = que.top();\n                que.pop();\n                if(min_cost[p.second] < p.first) continue;\n                for(int i = 0; i < graph[p.second].size(); i++) {\n                    edge &e = graph[p.second][i];\n                    cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if(e.cap > 0 && min_cost[e.to] > nextCost) {\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second, preve[e.to] = i;\n                        que.emplace(min_cost[e.to], e.to);\n                    }\n                }\n            }\n            if(min_cost[t] == INF) return -1;\n            for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n            flow_t addflow = f;\n            for(int v = t; v != s; v = prevv[v]) {\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for(int v = t; v != s; v = prevv[v]) {\n                edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n       }\n       return ret;\n    }\n\n    void output() {\n        for(int i = 0; i < graph.size(); i++) {\n            for(auto &e : graph[i]) {\n                if(e.isrev) continue;\n                auto &rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\n//const ll mod = 1000000007;\nll N;\nvector<ll> x, y, z;\n\nbool Contain(int i, int j) {\n    vector<ll> v = {x[i], y[i], z[i]};\n    vector<ll> w = {x[j], y[j], z[j]};\n    sort(v.begin(), v.end());\n    sort(w.begin(), w.end());\n    for(int k = 0; k < 3; k++) {\n        if(v[k] <= w[k]) return false;\n    }\n    return true;\n}\n\nvoid solve() {\n    x.resize(N);\n    y.resize(N);\n    z.resize(N);\n    for(int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i] >> z[i];\n    }\n    PrimalDual<ll, ll> graph(2 * N + 2);\n    int s = 2 * N;\n    int t = 2 * N + 1;\n    for(int i = 0; i < N; i++) {\n        graph.add_edge(s, i, 1, 0);\n        graph.add_edge(i + N, t, 1, 0);\n        for(int j = 0; j < N; j++) {\n            if(Contain(i, j)) {\n                //cerr << i << \" \" << j << endl;\n                graph.add_edge(i, j + N, 1, 0);\n            } else {\n                graph.add_edge(i, j + N, 1, x[j]*y[j]*z[j]);\n            }\n        }\n    }\n    cout << graph.min_cost_flow(s, t, N) << endl;\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N) {\n        if(N == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define M 1000000007\n\ntypedef pair<int, int> P;\nstruct edge { int to, cap, cost, rev; };\n\nint V;\nvector<edge> G[400];\nint h[400];\nint dist[400];\nint prevv[400], preve[400];\nvoid add_edge(int from, int to, int cap, int cost) {\n    G[from].push_back((edge){ to, cap, cost, (int)G[to].size() });\n    G[to].push_back((edge){ from, 0, -cost, (int)G[from].size() - 1 });\n}\n\n// ??????????????´??????M\nint min_cost_flow(int s, int t, int f) {\n    int res = 0;\n    fill(h, h + V, 0);\n    while (f > 0) {\n        priority_queue<P, vector<P>, greater<P> > q;\n        fill(dist, dist + V, M);\n        dist[s] = 0;\n        q.push(P(0, s));\n        while (!q.empty()) {\n            P p = q.top();\n            q.pop();\n            int v = p.second;\n            if (dist[v] < p.first) continue;\n            for (int i = 0; i < (int)G[v].size(); ++i) {\n                edge &e = G[v][i];\n                if (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    q.push(P(dist[e.to], e.to));\n                }\n            }\n        }\n        if (dist[t] == M) {\n            return M;\n        }\n        for (int v = 0; v < V; ++v) {\n            h[v] += dist[v];\n        }\n        int d = f;\n        for (int v = t; v != s; v = prevv[v]) {\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for (int v = t; v != s; v = prevv[v]) {\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) return 0;\n        V = 3 * n + 2;\n        for (int i = 0; i < 400; ++i) {\n            G[i].clear();\n            h[i] = 0;\n            dist[i] = 0;\n            prevv[i] = 0;\n            preve[i] = 0;\n        }\n        int S = 3 * n, T = 3 * n + 1;\n        for (int i = 0; i < n; ++i) {\n            add_edge(S, i * 3 + 1, 1, 0);\n            add_edge(i * 3 + 2, T, 1, 0);\n        }\n        int ans = 0;\n        vector<vector<int> > a(n);\n        for (int i = 0; i < n; ++i) {\n            a[i].resize(3);\n            cin >> a[i][0] >> a[i][1] >> a[i][2];\n            sort(a[i].begin(), a[i].end());\n            int cub = a[i][0] * a[i][1] * a[i][2];\n            add_edge(i * 3, i * 3 + 1, 1, -cub);\n            add_edge(i * 3 + 1, i * 3 + 2, 1, 0);\n            ans += cub;\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i == j) continue;\n                if (a[i][0] > a[j][0] && a[i][1] > a[j][1] && a[i][2] > a[j][2]) {\n                    add_edge(i * 3 + 2, j * 3, 1, 0);\n                }\n            }\n        }\n        while (true) {\n            int cost = min_cost_flow(S, T, 1);\n            if (cost >= 0) break;\n            ans += cost;\n        }\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\ntemplate <typename T> T hungarian(vector<vector<T>>& A) {\n    const T inf = numeric_limits<T>::max();\n    const int N = (int)A.size();\n    const int M = (int)A[0].size();\n    vector<int> P(M), way(M);\n    vector<T> U(N, 0), V(M, 0), minV;\n    vector<bool> used;\n\n    for (int i = 0; i < N; ++i) {\n        P[0] = i;\n        minV.assign(M, inf);\n        used.assign(M, false);\n        int j0 = 0;\n        while (P[j0]) {\n            int i0 = P[j0], j1 = 0;\n            used[j0] = true;\n            T delta = inf;\n            for (int j = 1; j < M; ++j) {\n                if (used[j]) continue;\n                T curr = A[i0][j] - U[i0] - V[j];\n                if (curr < minV[j]) minV[j] = curr, way[j] = j0;\n                if (minV[j] < delta) delta = minV[j], j1 = j;\n            }\n            for (int j = 0; j < M; ++j) {\n                if (used[j]) U[P[j]] += delta, V[j] -= delta;\n                else minV[j] -= delta;\n            }\n            j0 = j1;\n        }\n        do {\n            P[j0] = P[way[j0]];\n            j0 = way[j0];\n        } while (j0);\n    }\n    return -V[0];\n}\n\nint N;\nvector<int> v[100];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (cin >> N, N) {\n        int sum = 0;\n        REP (i, N) {\n            int mul = 1;\n            v[i].resize(3);\n            REP (j, 3) cin >> v[i][j], mul *= v[i][j];\n            sort(v[i].begin(), v[i].end());\n            sum += mul;\n        }\n        vector<vector<int>> A(N + 1, vector<int>(N + 1));\n        REP (i, N) REP (j, N) if (i != j) {\n            int yes = 1;\n            REP (k, 3) yes &= (v[i][k] < v[j][k]);\n            if (yes) A[i + 1][j + 1] = -(v[i][0] * v[i][1] * v[i][2]);\n        }\n        cout << sum + hungarian<int>(A) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For(i, 0, n)\n#define rrep(i, n) rFor(i, n, 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nstruct edge{\n    int to, cap, cost, rev;\n    edge(int to, int cap, int cost, int rev): to(to), cap(cap), cost(cost), rev(rev){}\n};\n\nint n, V;\nvector<edge> G[210];\nint h[210], dist[210], prevv[210], preve[210];\n\nvoid add_edge(int from, int to, int cap, int cost){\n    G[from].emplace_back(to, cap, cost, G[to].size());\n    G[to].emplace_back(from, 0, -cost, G[from].size() - 1);\n}\n\nint min_cost_flow(int s, int t, int f){\n    int res = 0;\n    fill(h, h + V, 0);\n    while(f > 0){\n        priority_queue<pii, vector<pii>, greater<>> que;\n        fill(dist, dist + V, mod);\n        dist[s] = 0;\n        que.emplace(0, s);\n        while(!que.empty()){\n            auto p = que.top();\n            que.pop();\n            int v = p.se;\n            if(dist[v] < p.fi) continue;\n            for(int i = 0; i < G[v].size(); ++i){\n                edge &e = G[v][i];\n                if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.emplace(dist[e.to], e.to);\n                }\n            }\n        }\n        if(dist[t] == mod) return -1;\n        for(int v = 0 ; v < V; ++v) h[v] += dist[v];\n\n        int d = f;\n        for(int v = t; v != s; v = prevv[v]){\n            d = min(d, G[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for(int v = t; v != s; v = prevv[v]){\n            edge &e = G[prevv[v]][preve[v]];\n            e.cap -= d;\n            G[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nvoid solve(){\n    V = 2 * n + 2;\n    array<int, 3> cube[n];\n    rep(i, n)rep(j, 3) scanf(\"%d\", &cube[i][j]);\n    rep(i, 2 * n + 2) G[i].clear();\n    rep(i, n){\n        rep(j, n)if(i != j){\n            sort(cube[i].begin(), cube[i].end());\n            do{\n                if(cube[i][0] < cube[j][0] && cube[i][1] < cube[j][1] && cube[i][2] < cube[j][2]){\n                    add_edge(i, j + n, 1, 0);\n                    break;\n                }\n            }while(next_permutation(cube[i].begin(), cube[i].end()));\n        }\n    }\n    rep(i, n){\n        add_edge(i, 2 * n + 1, 1, cube[i][0] * cube[i][1] * cube[i][2]);\n        add_edge(2 * n, i, 1, 0);\n        add_edge(i + n, 2 * n + 1, 1, 0);\n    }\n    printf(\"%d\\n\", min_cost_flow(2 * n, 2 * n + 1, n));\n}\n\nint main(){\n    while(scanf(\"%d\", &n) && n){\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing T = long long;\nconstexpr T inf = 1e9;\n\n// 二部グラフ最大重みマッチング\nT hungarian(const std::vector<std::vector<T>> &a) {\n  int n = a.size(), p, q;\n  assert((int)a[0].size() == n);\n  std::vector<T> fx(n, inf), fy(n, 0);\n  std::vector<int> x(n, -1), y(n, -1);\n  for (int i = 0; i < n; ++i)\n    for (int j = 0; j < n; ++j) fx[i] = std::max(fx[i], a[i][j]);\n  for (int i = 0; i < n;) {\n    std::vector<int> t(n, -1), s(n + 1, i);\n    for (p = q = 0; p <= q && x[i] < 0; ++p)\n      for (int k = s[p], j = 0; j < n && x[i] < 0; ++j)\n        if (fx[k] + fy[j] == a[k][j] && t[j] < 0) {\n          s[++q] = y[j], t[j] = k;\n          if (s[q] < 0)\n            for (p = j; p >= 0; j = p) y[j] = k = t[j], p = x[k], x[k] = j;\n        }\n    if (x[i] < 0) {\n      T d = inf;\n      for (int k = 0; k <= q; ++k)\n        for (int j = 0; j < n; ++j)\n          if (t[j] < 0) d = std::min(d, fx[s[k]] + fy[j] - a[s[k]][j]);\n      for (int j = 0; j < n; ++j) fy[j] += (t[j] < 0 ? 0 : d);\n      for (int k = 0; k <= q; ++k) fx[s[k]] -= d;\n    } else\n      ++i;\n  }\n  T ret = 0;\n  for (int i = 0; i < n; ++i) ret += a[i][x[i]];\n  return ret;\n}\n\nusing namespace std;\n\nusing ll = long long;\nint main() {\n  int n;\n  while (cin >> n, n) {\n    vector<vector<ll>> v;\n    ll sum = 0;\n    for (int i = 0; i < n; i++) {\n      ll x, y, z;\n      cin >> x >> y >> z;\n      vector<ll> tmp = {x, y, z};\n      sort(tmp.begin(), tmp.end());\n      v.push_back(tmp);\n      sum += x * y * z;\n    }\n    vector<vector<ll>> a(n, vector<ll>(n, 0));\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) {\n        if (v[i][0] < v[j][0] && v[i][1] < v[j][1] && v[i][2] < v[j][2]) {\n          a[i][j] = v[i][0] * v[i][1] * v[i][2];\n        }\n      }\n    }\n    cout << sum - hungarian(a) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\nusing P = pair<ll,ll>;\nconst ll inf = 1e14;\n\nclass min_cost_flow{\nprivate:\n    int N;\n    struct edge{int to; ll cap,cost; int rev; bool is_rev;};\n    vector<vector<edge>> G;\n    vector<ll> h,dist,prevv,preve;\npublic:\n    min_cost_flow(int n){\n        N = n;\n        G = vector<vector<edge>>(N);\n        h = dist = prevv = preve = vector<ll>(N,0);\n    }\n    void add_edge(int from,int to,ll cap,ll cost){\n        G[from].push_back((edge){to,cap,cost,(int) G[to].size(),false});\n        G[to].push_back((edge){from,0,-cost,(int) G[from].size()-1,true});\n    }\n    ll answer(int s,int t,ll f){\n        ll res = 0;\n        fill(h.begin(),h.end(),0);\n        while(f>0){\n            priority_queue<P,vector<P>,greater<P>> Q;\n            fill(dist.begin(),dist.end(),inf);\n            dist[s] = 0;\n            Q.push(P(0,s));\n            while(!Q.empty()){\n                P p = Q.top(); Q.pop();\n                int v = p.second;\n                if(dist[v]<p.first) continue;\n                for(int i=0;i<G[v].size();i++){\n                    edge &e = G[v][i];\n                    if(e.cap>0 && dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n                        dist[e.to] = dist[v]+e.cost+h[v]-h[e.to];\n                        prevv[e.to] = v;\n                        preve[e.to] = i;\n                        Q.push(P(dist[e.to],e.to));\n                    }\n                }\n            }\n            if(dist[t]==inf) return -1;\n            for(int v=0;v<N;v++) h[v] += dist[v];\n            ll d = f;\n            for(int v=t;v!=s; v=prevv[v]){\n                d = min(d,G[prevv[v]][preve[v]].cap);\n            }\n            f -= d;\n            res += d*h[t];\n            for(int v=t;v!=s;v=prevv[v]){\n                edge &e = G[prevv[v]][preve[v]];\n                e.cap -= d;\n                G[v][e.rev].cap += d;\n            }\n        }\n        return res;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N;\n    while(cin >> N && N){\n        vec<int> X(N),Y(N),Z(N);\n        int ans = 0;\n        for(int i=0;i<N;i++){\n            cin >> X[i] >> Y[i] >> Z[i];\n            ans += X[i]*Y[i]*Z[i];\n        }\n        //i->j?\n        auto in = [&](int i,int j){\n            vvec<int> v(2);\n            v[0].push_back(X[i]);\n            v[0].push_back(Y[i]);\n            v[0].push_back(Z[i]);\n            v[1].push_back(X[j]);\n            v[1].push_back(Y[j]);\n            v[1].push_back(Z[j]);\n            sort(v[0].begin(),v[0].end());\n            sort(v[1].begin(),v[1].end());\n            bool ok = true;\n            for(int i=0;i<3;i++) ok &= v[0][i]>v[1][i];\n            return ok;\n        };\n        int s = 2*N,t = 2*N+1;\n        min_cost_flow flow(2*N+2);\n\n        auto id = [&](int i,int f){\n            return i+f*N;\n        };\n\n        for(int i=0;i<N;i++){\n            flow.add_edge(s,id(i,0),1,0);\n            flow.add_edge(id(i,1),t,1,0);\n            flow.add_edge(id(i,0),id(i,1),1,0);\n            for(int j=0;j<N;j++) if(in(i,j)){\n                flow.add_edge(id(i,1),id(j,0),1,-X[j]*Y[j]*Z[j]);\n            }\n        }\n        flow.add_edge(s,t,N,0);\n        int a = flow.answer(s,t,N);\n//        cerr << a << \"\\n\";\n        cout << ans+a << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2828 Matryoshka Doll\n// 2018.3.9 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 500\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 205\ntypedef struct { int to, rev; int cap, cost; } EDGE;\nEDGE edge[MAX][MAX]; int hi[MAX];\nint V;\t\t\t\t// 頂点数\nint potential[MAX], dist[MAX], prevv[MAX], preve[MAX];\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n\tint f, t;\n\tEDGE *ep;\n\n\tf = hi[from]++, t = hi[to]++;\n\tep = &edge[from][f], ep->to = to, ep->cap = cap, ep->cost = cost, ep->rev = t; \n\tep = &edge[to][t], ep->to = from, ep->cap = 0, ep->cost = -cost, ep->rev = f;\n}\n\nint minCostFlow(int S, int T, int F)\n{\n\tint i, v, nv, t, nt, ret;\n\tEDGE *ep;\n\n\tret = 0;\n\tmemset(potential, 0, V << 2);\n  \n\twhile (F > 0) {\n\t\tmemset(dist, INF, V << 2);\n\t\tqsize = 0;\n\t\tdist[S] = 0;\n\t\tenq(S, 0);\n\t\twhile (qsize) {\n\t\t\tv = que[0].s, t = que[0].t, deq();\n\t\t\tif (dist[v] < t) continue;\n\t\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\t\tep = &edge[v][i];\n\t\t\t\tif (ep->cap <= 0) continue;\n\t\t\t\tnv = ep->to;\n\t\t\t\tnt = t + ep->cost - potential[nv] + potential[v];\n\t\t\t\tif(dist[nv] > nt) {\n\t\t\t\t\tdist[nv] = nt;\n\t\t\t\t\tprevv[nv] = v, preve[nv] = i;\n\t\t\t\t\tenq(nv, nt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[T] == INF) return -1;\n\t\tfor (v = 0; v < V; v++) potential[v] += dist[v];\n\n\t\tt = F;\n\t\tfor (v = T; v != S; v = prevv[v]) {\n\t\t\tep = &edge[prevv[v]][preve[v]];\n\t\t\tif (t > ep->cap) t = ep->cap;\n\t\t}\n\t\tF -= t;\n\n\t\tret += t * potential[T];\n\t\tfor (v = T; v != S; v = prevv[v]) {\n\t\t\tep = &edge[prevv[v]][preve[v]];\n\t\t\tep->cap -= t;\n\t\t\tedge[v][ep->rev].cap += t;\n\t\t}\n\t}\n\treturn ret;\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\ntypedef struct { int x, y, z; } T;\nT tbl[102];\n\nint main()\n{\n\tint N, i, j;\n\tint source, sink;\n\n\twhile (N = in()) {\n\t\tsource = N << 1, sink = source+1, V = sink+1;\n\t\tmemset(hi, 0, V << 2);\n\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tint x = in(), y = in(), z = in(), t;\n\t\t\tif (y > z) t = y, y = z, z = t;\n\t\t\tif (x > y) t = x, x = y, y = t;\n\t\t\tif (y > z) t = y, y = z, z = t;\n\t\t\ttbl[i].x = x, tbl[i].y = y, tbl[i].z = z;\n\t\t}\n\n\t\tfor (i = 0; i < N; i++) for (j = 0; j < N; j++) if (i != j) {\n\t\t\tif (tbl[i].x < tbl[j].x && tbl[i].y < tbl[j].y && tbl[i].z < tbl[j].z)\n\t\t\t\tadd_edge(i, N+j, 1, 0);\n\t\t}\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tadd_edge(source, i, 1, 0);\n\t\t\tadd_edge(i, sink, 1, tbl[i].x*tbl[i].y*tbl[i].z);\n\t\t\tadd_edge(i+N, sink, 1, 0);\n\t\t}\n\t\tprintf(\"%d\\n\", minCostFlow(source, sink, N));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2828 Matryoshka Doll\n// 2018.3.9 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 10000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\n#define MAX 205\ntypedef struct { int to, rev; int cap, cost; } EDGE;\nEDGE edge[MAX][MAX]; int hi[MAX], lim[MAX];\nint V;\t\t\t\t// 頂点数\nint potential[MAX], dist[MAX], prevv[MAX], preve[MAX];\n\nvoid add_edge(int from, int to, int cap, int cost)\n{\n\tint f, t;\n\tEDGE *ep;\n\n\tf = hi[from]++, t = hi[to]++;\n\tep = &edge[from][f], ep->to = to, ep->cap = cap, ep->cost = cost, ep->rev = t; \n\tep = &edge[to][t], ep->to = from, ep->cap = 0, ep->cost = -cost, ep->rev = f;\n}\n\nint minCostFlow(int S, int T, int F)\n{\n\tint i, v, nv, t, nt, ret;\n\tEDGE *ep;\n\n\tret = 0;\n\tmemset(potential, 0, V << 2);\n  \n\twhile (F > 0) {\n\t\tmemset(dist, INF, V << 2);\n\t\tqsize = 0;\n\t\tdist[S] = 0;\n\t\tenq(S, 0);\n\t\twhile (qsize) {\n\t\t\tv = que[0].s, t = que[0].t, deq();\n\t\t\tif (dist[v] < t) continue;\n\t\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\t\tep = &edge[v][i];\n\t\t\t\tif (ep->cap <= 0) continue;\n\t\t\t\tnv = ep->to;\n\t\t\t\tnt = t + ep->cost - potential[nv] + potential[v];\n\t\t\t\tif(dist[nv] > nt) {\n\t\t\t\t\tdist[nv] = nt;\n\t\t\t\t\tprevv[nv] = v, preve[nv] = i;\n\t\t\t\t\tenq(nv, nt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[T] == INF) return -1;\n\t\tfor (v = 0; v < V; v++) potential[v] += dist[v];\n\n\t\tt = F;\n\t\tfor (v = T; v != S; v = prevv[v]) {\n\t\t\tep = &edge[prevv[v]][preve[v]];\n\t\t\tif (t > ep->cap) t = ep->cap;\n\t\t}\n\t\tF -= t;\n\n\t\tret += t * potential[T];\n\t\tfor (v = T; v != S; v = prevv[v]) {\n\t\t\tep = &edge[prevv[v]][preve[v]];\n\t\t\tep->cap -= t;\n\t\t\tedge[v][ep->rev].cap += t;\n\t\t}\n\t}\n\treturn ret;\n}\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\ntypedef struct { int x, y, z; } T;\nT tbl[102];\n\nint cmp(int *a, int *b) { return *a - *b; }\n\nint main()\n{\n\tint N, i, j;\n\tint source, sink;\n\n\twhile (N = in()) {\n\t\tmemset(hi, 0, sizeof(hi)), memset(lim, 0, sizeof(lim));\n\t\tsource = N << 1, sink = source+1, V = sink+1;\n\n\t\tfor (i = 0; i < N; i++) {\n\t\t\ttbl[i].x = in(), tbl[i].y = in(), tbl[i].z = in();\n\t\t\tqsort(tbl+i, 3, sizeof(int), cmp);\n\t\t}\n\n\t\tfor (i = 0; i < N; i++) for (j = 0; j < N; j++) if (i != j) {\n\t\t\tif (tbl[i].x < tbl[j].x && tbl[i].y < tbl[j].y && tbl[i].z < tbl[j].z)\n\t\t\t\tadd_edge(i, N+j, 1, 0);\n\t\t}\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tadd_edge(source, i, 1, 0);\n\t\t\tadd_edge(i, sink, 1, tbl[i].x*tbl[i].y*tbl[i].z);\n\t\t\tadd_edge(i+N, sink, 1, 0);\n\t\t}\n\t\tprintf(\"%d\\n\", minCostFlow(source, sink, N));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nfrom heapq import heappush, heappop\nclass MinCostFlow:\n    INF = 10**18\n\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap, cost):\n        G = self.G\n        G[fr].append([to, cap, cost, len(G[to])])\n        G[to].append([fr, 0, -cost, len(G[fr])-1])\n\n    def flow(self, s, t, f):\n        N = self.N; G = self.G\n        INF = MinCostFlow.INF\n\n        res = 0\n        H = [0]*N\n        prv_v = [0]*N\n        prv_e = [0]*N\n\n        while f:\n            dist = [INF]*N\n            dist[s] = 0\n            que = [(0, s)]\n\n            while que:\n                c, v = heappop(que)\n                if dist[v] < c:\n                    continue\n                for i, (w, cap, cost, _) in enumerate(G[v]):\n                    if cap > 0 and dist[w] > dist[v] + cost + H[v] - H[w]:\n                        dist[w] = r = dist[v] + cost + H[v] - H[w]\n                        prv_v[w] = v; prv_e[w] = i\n                        heappush(que, (r, w))\n            if dist[t] == INF:\n                return -1\n\n            for i in range(N):\n                H[i] += dist[i]\n\n            d = f; v = t\n            while v != s:\n                d = min(d, G[prv_v[v]][prv_e[v]][1])\n                v = prv_v[v]\n            f -= d\n            res += d * H[t]\n            v = t\n            while v != s:\n                e = G[prv_v[v]][prv_e[v]]\n                e[1] -= d\n                G[v][e[3]][1] += d\n                v = prv_v[v]\n        return res\n\ndef solve():\n    N = int(readline())\n    if N == 0:\n        return False\n    P = []\n    for i in range(N):\n        *p, = map(int, readline().split())\n        p.sort()\n        P.append(p)\n    mcf = MinCostFlow(2*N+2)\n    P.sort()\n    su = 0\n    for i in range(N):\n        xi, yi, zi = P[i]\n        for j in range(i):\n            xj, yj, zj = P[j]\n            if xi > xj and yi > yj and zi > zj:\n                mcf.add_edge(2*j+1, 2*i, 1, -xj*yj*zj)\n        su += xi*yi*zi\n        mcf.add_edge(2*i, 2*i+1, 1, 0)\n        mcf.add_edge(2*N, 2*i, 1, 0)\n        mcf.add_edge(2*i+1, 2*N+1, 1, 0)\n    ans = su\n    for i in range(N):\n        f = mcf.flow(2*N, 2*N+1, 1)\n        su += f\n        ans = min(ans, su)\n    write(\"%d\\n\" % ans)\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Python",
    "code": "import heapq\n\nclass MinCostFlow:\n    class Edge:\n        def __init__(self,to,cap,rev,cost):\n            self.to = to\n            self.cap = cap\n            self.rev = rev\n            self.cost = cost\n\n    def __init__(self,n,inf=1000000007):\n        self.n = n\n        self.inf = inf\n        self.e = [[] for _ in range(n)]\n\n    def add_edge(self, fr, to, cap, cost):\n        self.e[fr].append(self.Edge(to,cap,len(self.e[to]),cost))\n        self.e[to].append(self.Edge(fr,0,len(self.e[fr])-1,-cost))\n\n    def compute(self,source,sink,f):\n        res = 0\n        h = [0]*self.n\n        prevv = [0]*self.n\n        preve = [0]*self.n\n        while (f > 0):\n            pq = []\n            dist = [self.inf]*self.n\n            dist[source] = 0\n            heapq.heappush(pq,(0,source))\n            while pq:\n                cost, v = heapq.heappop(pq)\n                cost = -cost\n                if dist[v] < cost:continue\n                for i, edge in enumerate(self.e[v]):\n                    if edge.cap > 0 and dist[v] - h[edge.to] < dist[edge.to] - edge.cost - h[v]:\n                        dist[edge.to] = dist[v] + edge.cost + h[v] - h[edge.to]\n                        prevv[edge.to] = v\n                        preve[edge.to] = i\n                        heapq.heappush(pq,(-dist[edge.to],edge.to))\n            if dist[sink] == self.inf:return -1\n            for v in range(self.n):\n                h[v] += dist[v]\n\n            d, v = f, sink\n            while v != source:\n                d = min(d,self.e[prevv[v]][preve[v]].cap)\n                v = prevv[v]\n            f -= d\n            res += d*h[sink]\n            v = sink\n            while v != source:\n                self.e[prevv[v]][preve[v]].cap -= d\n                self.e[v][self.e[prevv[v]][preve[v]].rev].cap += d\n                v = prevv[v]\n        return res\n\ndef less(a,b):\n    for i in range(3):\n        if b[i]<=a[i]:return False\n    return True\n\ndef main():\n    while True:\n        n = int(input())\n        if n==0:break\n        a = []\n        MCF = MinCostFlow(n+n+2)\n        s = n+n\n        t = s+1\n        summ = 0\n        for i in range(n):\n            x = list(map(int,input().split()))\n            x.sort()\n            a.append(x)\n            summ+=(x[0]*x[1]*x[2])\n        for i in range(n):\n            for j in range(n):\n                if i == j:continue\n                if less(a[i],a[j]):\n                    MCF.add_edge(i,j+n,1,-(a[i][0]*a[i][1]*a[i][2]))\n        for i in range(n):\n            MCF.add_edge(s,i,1,0)\n            MCF.add_edge(i+n,t,1,0)\n        MCF.add_edge(s,t,MCF.inf,0)\n        print (summ+MCF.compute(s,t,MCF.inf))\n\nif __name__ == '__main__':\n    main()\n\n\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n\n    loop {\n        let n: usize = sc.read();\n        if n == 0 {\n            return;\n        }\n        let mut xyz = vec![];\n        for _ in 0..n {\n            let x: i64 = sc.read();\n            let y: i64 = sc.read();\n            let z: i64 = sc.read();\n            let mut v = vec![x, y, z];\n            v.sort();\n            xyz.push(v);\n        }\n\n        let v = n * 2 + 2;\n        let mut graph = primal_dual::MinimumCostFlowSolver::new(v);\n        let source = v - 2;\n        let sink = v - 1;\n        for i in 0..n {\n            graph.add_edge(source, i, 1, 0);\n            graph.add_edge(i, sink, 1, xyz[i][0] * xyz[i][1] * xyz[i][2]);\n            graph.add_edge(i + n, sink, 1, 0);\n            for j in 0..n {\n                if (0..3).all(|p| xyz[i][p] < xyz[j][p]) {\n                    graph.add_edge(i, j + n, 1, 0);\n                }\n            }\n        }\n        let f = graph.solve(source, sink, n as i64).unwrap();\n        println!(\"{}\", f);\n    }\n}\npub mod primal_dual {\n    use std::cmp;\n    use std::collections::BinaryHeap;\n    use std::i64;\n    type Flow = i64;\n    type Cost = i64;\n    const INF: Cost = 1 << 50;\n    struct Edge {\n        to: usize,\n        capacity: Flow,\n        flow: Flow,\n        cost: Cost,\n        reverse_to: usize,\n        is_reversed: bool,\n    }\n    impl Edge {\n        fn residue(&self) -> Flow {\n            self.capacity - self.flow\n        }\n    }\n\n    pub struct MinimumCostFlowSolver {\n        graph: Vec<Vec<Edge>>,\n        previous_edge: Vec<(usize, usize)>,\n    }\n\n    impl MinimumCostFlowSolver {\n        pub fn new(n: usize) -> Self {\n            MinimumCostFlowSolver {\n                graph: (0..n).map(|_| Vec::new()).collect(),\n                previous_edge: vec![(0, 0); n],\n            }\n        }\n\n        pub fn add_edge(&mut self, from: usize, to: usize, capacity: Flow, cost: Cost) {\n            let reverse_from = self.graph[to].len();\n            let reverse_to = self.graph[from].len();\n            self.graph[from].push(Edge {\n                to,\n                capacity,\n                flow: 0,\n                cost,\n                reverse_to: reverse_from,\n                is_reversed: false,\n            });\n            self.graph[to].push(Edge {\n                to: from,\n                capacity,\n                flow: capacity,\n                cost: -cost,\n                reverse_to,\n                is_reversed: true,\n            });\n        }\n\n        pub fn solve(&mut self, source: usize, sink: usize, mut flow: Flow) -> Option<Flow> {\n            let n = self.graph.len();\n            let mut result = 0;\n            let mut h = vec![0; n];\n            let mut q: BinaryHeap<(Cost, usize)> = BinaryHeap::new();\n            while flow > 0 {\n                let mut dist = vec![INF; n];\n                dist[source] = 0;\n                q.push((0, source));\n                while let Some((current_dist, v)) = q.pop() {\n                    if dist[v] < current_dist {\n                        continue;\n                    }\n                    for (i, e) in self.graph[v].iter().enumerate() {\n                        if e.residue() == 0 {\n                            continue;\n                        }\n                        if dist[e.to] + h[e.to] > current_dist + h[v] + e.cost {\n                            dist[e.to] = current_dist + h[v] + e.cost - h[e.to];\n                            self.previous_edge[e.to] = (v, i);\n                            q.push((dist[e.to], e.to));\n                        }\n                    }\n                }\n\n                if dist[sink] == INF {\n                    return None;\n                }\n\n                for i in 0..n {\n                    h[i] += dist[i];\n                }\n                let mut df = flow;\n                let mut v = sink;\n                while v != source {\n                    let (prev_v, prev_e) = self.previous_edge[v];\n                    df = cmp::min(df, self.graph[prev_v][prev_e].residue());\n                    v = prev_v;\n                }\n                flow -= df;\n                result += df * h[sink];\n                let mut v = sink;\n                while v != source {\n                    let (prev_v, prev_e) = self.previous_edge[v];\n                    self.graph[prev_v][prev_e].flow += df;\n                    let reversed_edge_id = self.graph[prev_v][prev_e].reverse_to;\n                    self.graph[v][reversed_edge_id].flow -= df;\n                    v = prev_v;\n                }\n            }\n            Some(result)\n        }\n\n        pub fn neg_solve(&mut self, source: usize, sink: usize, mut flow: Flow) -> Option<Flow> {\n            let n = self.graph.len();\n            let mut result = 0;\n            while flow > 0 {\n                let mut dist = vec![INF; n];\n                dist[source] = 0;\n                loop {\n                    let mut updated = false;\n                    for v in 0..n {\n                        if dist[v] == INF {\n                            continue;\n                        }\n\n                        for (i, e) in self.graph[v].iter().enumerate() {\n                            if e.residue() == 0 {\n                                continue;\n                            }\n                            if dist[e.to] > dist[v] + e.cost {\n                                dist[e.to] = dist[v] + e.cost;\n                                self.previous_edge[e.to] = (v, i);\n                                updated = true;\n                            }\n                        }\n                    }\n                    if !updated {\n                        break;\n                    }\n                }\n\n                if dist[sink] == INF {\n                    return None;\n                }\n\n                let mut df = flow;\n                let mut v = sink;\n                while v != source {\n                    let (prev_v, prev_e) = self.previous_edge[v];\n                    df = cmp::min(df, self.graph[prev_v][prev_e].residue());\n                    v = prev_v;\n                }\n                flow -= df;\n                result += df * dist[sink];\n                let mut v = sink;\n                while v != source {\n                    let (prev_v, prev_e) = self.previous_edge[v];\n                    self.graph[prev_v][prev_e].flow += df;\n                    let reversed_edge_id = self.graph[prev_v][prev_e].reverse_to;\n                    self.graph[v][reversed_edge_id].flow -= df;\n                    v = prev_v;\n                }\n            }\n            Some(result)\n        }\n    }\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> Self {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: ToString>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write_all(s.to_string().as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n\n"
  }
]