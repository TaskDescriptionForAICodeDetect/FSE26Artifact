[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint main() {\n    int N, M;\n    while (scanf(\"%d %d\", &N, &M) == 2) {\n        if (N == 0 && M == 0) break;\n        \n        int codebook[16];\n        for (int i = 0; i < M; i++) {\n            scanf(\"%d\", &codebook[i]);\n        }\n        \n        int samples[20000];\n        for (int i = 0; i < N; i++) {\n            scanf(\"%d\", &samples[i]);\n        }\n        \n        int dp[20001][256];\n        for (int i = 0; i <= N; i++) {\n            for (int j = 0; j < 256; j++) {\n                dp[i][j] = INT_MAX;\n            }\n        }\n        dp[0][128] = 0;\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < 256; j++) {\n                if (dp[i][j] == INT_MAX) continue;\n                for (int k = 0; k < M; k++) {\n                    int next = j + codebook[k];\n                    if (next < 0) next = 0;\n                    if (next > 255) next = 255;\n                    int diff = samples[i] - next;\n                    int new_val = dp[i][j] + diff * diff;\n                    if (new_val < dp[i+1][next]) {\n                        dp[i+1][next] = new_val;\n                    }\n                }\n            }\n        }\n        \n        int min = INT_MAX;\n        for (int j = 0; j < 256; j++) {\n            if (dp[N][j] < min) {\n                min = dp[N][j];\n            }\n        }\n        printf(\"%d\\n\", min);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:13:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, M;\n    while (cin >> N >> M) {\n        if (N == 0 && M == 0) break;\n        \n        vector<int> codebook(M);\n        for (int i = 0; i < M; ++i) {\n            cin >> codebook[i];\n        }\n        \n        vector<int> input(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> input[i];\n        }\n        \n        vector<vector<int>> dp(N, vector<int>(256, INT_MAX));\n        \n        // Initialize the first step\n        for (int c : codebook) {\n            int next = 128 + c;\n            next = max(0, min(255, next));\n            int diff = input[0] - next;\n            dp[0][next] = diff * diff;\n        }\n        \n        for (int i = 1; i < N; ++i) {\n            for (int prev_val = 0; prev_val <= 255; ++prev_val) {\n                if (dp[i-1][prev_val] == INT_MAX) continue;\n                for (int c : codebook) {\n                    int next_val = prev_val + c;\n                    next_val = max(0, min(255, next_val));\n                    int diff = input[i] - next_val;\n                    int new_cost = dp[i-1][prev_val] + diff * diff;\n                    if (new_cost < dp[i][next_val]) {\n                        dp[i][next_val] = new_cost;\n                    }\n                }\n            }\n        }\n        \n        int min_cost = *min_element(dp[N-1].begin(), dp[N-1].end());\n        cout << min_cost << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:13:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class DPCM {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            int n = scanner.nextInt();\n            int m = scanner.nextInt();\n            if (n == 0 && m == 0) break;\n            \n            int[] codebook = new int[m];\n            for (int i = 0; i < m; i++) {\n                codebook[i] = scanner.nextInt();\n            }\n            \n            int[] signal = new int[n];\n            for (int i = 0; i < n; i++) {\n                signal[i] = scanner.nextInt();\n            }\n            \n            int[][] dp = new int[n][256];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < 256; j++) {\n                    dp[i][j] = Integer.MAX_VALUE;\n                }\n            }\n            \n            dp[0][128] = (signal[0] - 128) * (signal[0] - 128);\n            \n            for (int i = 1; i < n; i++) {\n                for (int prev = 0; prev < 256; prev++) {\n                    if (dp[i-1][prev] == Integer.MAX_VALUE) continue;\n                    for (int k = 0; k < m; k++) {\n                        int current = prev + codebook[k];\n                        current = Math.max(0, Math.min(255, current));\n                        int diff = signal[i] - current;\n                        int newCost = dp[i-1][prev] + diff * diff;\n                        if (newCost < dp[i][current]) {\n                            dp[i][current] = newCost;\n                        }\n                    }\n                }\n            }\n            \n            int minSum = Integer.MAX_VALUE;\n            for (int j = 0; j < 256; j++) {\n                if (dp[n-1][j] < minSum) {\n                    minSum = dp[n-1][j];\n                }\n            }\n            System.out.println(minSum);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:14:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DPCM {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int T = scanner.nextInt();\n\n        for (int t = 0; t < T; t++) {\n            int N = scanner.nextInt();\n            int[] input = new int[N];\n            for (int i = 0; i < N; i++) {\n                input[i] = scanner.nextInt();\n            }\n\n            int K = scanner.nextInt();\n            int[] codebook = new int[K];\n            for (int i = 0; i < K; i++) {\n                codebook[i] = scanner.nextInt();\n            }\n\n            long minSquaredDiff = solve(input, codebook);\n            System.out.println(minSquaredDiff);\n        }\n    }\n\n    static long solve(int[] input, int[] codebook) {\n        int N = input.length;\n        int K = codebook.length;\n        int[][] dp = new int[N][256];\n        \n        for (int j = 0; j < 256; j++) {\n            int diff = Math.abs(j - 128);\n            dp[0][j] = diff * diff;\n        }\n\n        for (int i = 1; i < N; i++) {\n            for (int j = 0; j < 256; j++) {\n                dp[i][j] = Integer.MAX_VALUE;\n                for (int k = 0; k < K; k++) {\n                    int prevValue = j;\n                    int currValue = Math.min(255, Math.max(0, prevValue + codebook[k]));\n                    int diff = input[i] - currValue;\n                    int cost = dp[i-1][prevValue] + diff * diff;\n                    dp[i][j] = Math.min(dp[i][j], cost);\n                }\n            }\n        }\n\n        long minSquaredDiff = Long.MAX_VALUE;\n        for (int j = 0; j < 256; j++) {\n            minSquaredDiff = Math.min(minSquaredDiff, dp[N-1][j]);\n        }\n\n        return minSquaredDiff;\n    }\n}",
    "timestamp": "2025-08-05 21:14:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n\n#define MAX_N 1000\n#define MAX_K 256\n\nint main() {\n    int T, N, K;\n    int input[MAX_N];\n    int codebook[MAX_K];\n    long long dp[MAX_N + 1][MAX_K];\n\n    scanf(\"%d\", &T);\n    \n    while (T--) {\n        scanf(\"%d %d\", &N, &K);\n        \n        for (int i = 0; i < N; i++) {\n            scanf(\"%d\", &input[i]);\n        }\n        \n        for (int j = 0; j < K; j++) {\n            scanf(\"%d\", &codebook[j]);\n        }\n        \n        for (int j = 0; j < K; j++) {\n            dp[0][j] = 0;\n        }\n        \n        for (int i = 1; i <= N; i++) {\n            for (int j = 0; j < K; j++) {\n                dp[i][j] = LLONG_MAX;\n                for (int prev = 0; prev < K; prev++) {\n                    int decoded = (i == 1) ? 128 : codebook[prev];\n                    int diff = input[i-1] - (decoded + codebook[j]);\n                    long long curr_error = (long long)diff * diff;\n                    \n                    if (dp[i-1][prev] != LLONG_MAX) {\n                        dp[i][j] = (dp[i-1][prev] + curr_error < dp[i][j]) ? \n                                    dp[i-1][prev] + curr_error : dp[i][j];\n                    }\n                }\n            }\n        }\n        \n        long long min_error = LLONG_MAX;\n        for (int j = 0; j < K; j++) {\n            min_error = (dp[N][j] < min_error) ? dp[N][j] : min_error;\n        }\n        \n        printf(\"%lld\\n\", min_error);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:14:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n    int T, N, K;\n    cin >> T;\n\n    while (T--) {\n        cin >> N >> K;\n        vector<int> input(N);\n        vector<int> codebook(K);\n\n        for (int i = 0; i < N; i++) {\n            cin >> input[i];\n        }\n\n        for (int i = 0; i < K; i++) {\n            cin >> codebook[i];\n        }\n\n        vector<vector<long long>> dp(N, vector<long long>(K, LLONG_MAX));\n\n        for (int j = 0; j < K; j++) {\n            int diff = abs(input[0] - (codebook[j] + 128));\n            dp[0][j] = diff * diff;\n        }\n\n        for (int i = 1; i < N; i++) {\n            for (int j = 0; j < K; j++) {\n                for (int prev = 0; prev < K; prev++) {\n                    int decoded = min(max(codebook[prev] + codebook[j] + 128, 0), 255);\n                    int diff = abs(input[i] - decoded);\n                    long long candidate = dp[i-1][prev] + diff * diff;\n                    dp[i][j] = min(dp[i][j], candidate);\n                }\n            }\n        }\n\n        long long minSum = LLONG_MAX;\n        for (int j = 0; j < K; j++) {\n            minSum = min(minSum, dp[N-1][j]);\n        }\n\n        cout << minSum << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:14:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def differential_pulse_code_modulation(input_signals, codebook):\n    n = len(input_signals)\n    m = len(codebook)\n    \n    # Initialize DP table\n    dp = [[float('inf')] * m for _ in range(n + 1)]\n    dp[0] = [0] * m\n    \n    # Initialize starting value\n    start_value = 128\n    \n    for i in range(1, n + 1):\n        for j in range(m):\n            current_value = input_signals[i - 1]\n            for k in range(m):\n                # Calculate the previous decoded value\n                prev_value = max(0, min(255, start_value + codebook[k]))\n                \n                # Decode using the current codebook[j]\n                decoded_value = max(0, min(255, prev_value + codebook[j]))\n                \n                # Calculate the squared difference\n                squared_difference = (current_value - decoded_value) ** 2\n                \n                # Update dp\n                dp[i][j] = min(dp[i][j], dp[i - 1][k] + squared_difference)\n    \n    # Find the minimum squared difference sum from the last row of dp table\n    min_sqd_sum = min(dp[n])\n    \n    return min_sqd_sum\n\n# Example test\n# Can replace with input sequences and appropriate codebook\ninput_signals = [100, 105, 110]  # example sequence\ncodebook = [-3, 0, 3]  # example codebook\nresult = differential_pulse_code_modulation(input_signals, codebook)\nprint(result)",
    "timestamp": "2025-08-13 05:35:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class DPCM {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (scanner.hasNext()) {\n            int n = scanner.nextInt();\n            int[] inputSignal = new int[n];\n            for (int i = 0; i < n; i++) {\n                inputSignal[i] = scanner.nextInt();\n            }\n\n            int m = scanner.nextInt();\n            int[] codebook = new int[m];\n            for (int i = 0; i < m; i++) {\n                codebook[i] = scanner.nextInt();\n            }\n\n            System.out.println(minimizeSquaredDifference(inputSignal, codebook));\n        }\n    }\n\n    private static int minimizeSquaredDifference(int[] inputSignal, int[] codebook) {\n        int n = inputSignal.length;\n        int[][] dp = new int[n][256];\n        int[][] path = new int[n][256];\n        \n        for (int v = 0; v < 256; v++) {\n            dp[0][v] = (v - inputSignal[0]) * (v - inputSignal[0]);\n        }\n        \n        for (int i = 1; i < n; i++) {\n            for (int v = 0; v < 256; v++) {\n                dp[i][v] = Integer.MAX_VALUE;\n                for (int j = 0; j < codebook.length; j++) {\n                    int prevV = v - codebook[j];\n                    if (prevV >= 0 && prevV < 256) {\n                        int curCost = dp[i - 1][prevV] + (v - inputSignal[i]) * (v - inputSignal[i]);\n                        if (curCost < dp[i][v]) {\n                            dp[i][v] = curCost;\n                            path[i][v] = prevV;\n                        }\n                    }\n                }\n            }\n        }\n        \n        int result = Integer.MAX_VALUE;\n        for (int v = 0; v < 256; v++) {\n            if (dp[n - 1][v] < result) {\n                result = dp[n - 1][v];\n            }\n        }\n        \n        return result;\n    }\n}",
    "timestamp": "2025-08-13 05:35:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_N 1000\n#define CODEBOOK_SIZE 8\n\nint abs(int x) {\n    return x < 0 ? -x : x;\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int n, codebook[CODEBOOK_SIZE], input[MAX_N];\n    \n    // Read the size of the impulse sequence\n    while (scanf(\"%d\", &n) != EOF) {\n        // Read the codebook\n        for (int i = 0; i < CODEBOOK_SIZE; i++) {\n            scanf(\"%d\", &codebook[i]);\n        }\n        \n        // Read the input sequence\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &input[i]);\n        }\n        \n        // DP array to store the minimal sum of squared differences ending at each input\n        int dp[MAX_N][256];\n        \n        // Initialize dp array with a large number\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 256; j++) {\n                dp[i][j] = INT_MAX;\n            }\n        }\n        \n        // Base case: starting value is 128\n        dp[0][128] = 0;\n        \n        // Iterate over each sample\n        for (int i = 1; i < n; i++) {\n            // Iterate over all possible current output values\n            for (int j = 0; j < 256; j++) {\n                if (dp[i-1][j] == INT_MAX) continue;\n                \n                // Try each codebook value\n                for (int k = 0; k < CODEBOOK_SIZE; k++) {\n                    // Calculate current value with clipping\n                    int currentValue = j + codebook[k];\n                    if (currentValue < 0) currentValue = 0;\n                    if (currentValue > 255) currentValue = 255;\n                    \n                    // Update dp for current condition\n                    int diff = input[i] - currentValue;\n                    int squareDiff = diff * diff;\n                    dp[i][currentValue] = min(dp[i][currentValue], dp[i-1][j] + squareDiff);\n                }\n            }\n        }\n        \n        // Find the minimum squared difference for the last input\n        int result = INT_MAX;\n        for (int j = 0; j < 256; j++) {\n            if (dp[n-1][j] < result) {\n                result = dp[n-1][j];\n            }\n        }\n        \n        // Output the result for this dataset\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 05:35:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_dpcm(input_signal):\n    codebook = [0, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240]\n    n = len(input_signal)\n    \n    # Initialize dp array to store minimum squared difference\n    dp = [[float('inf')] * len(codebook) for _ in range(n)]\n    \n    # Initialize first row with initial differences from 128\n    for j in range(len(codebook)):\n        dp[0][j] = (input_signal[0] - codebook[j]) ** 2\n    \n    # Dynamic programming to find minimum squared difference\n    for i in range(1, n):\n        for j in range(len(codebook)):\n            min_diff = float('inf')\n            for k in range(len(codebook)):\n                # Clip previous value between 0 and 255\n                prev_val = max(0, min(255, codebook[k] + codebook[j]))\n                curr_diff = dp[i-1][k] + (input_signal[i] - prev_val) ** 2\n                min_diff = min(min_diff, curr_diff)\n            dp[i][j] = min_diff\n    \n    # Return minimum squared difference from last row\n    return min(dp[-1])\n\n# Read input and solve\nt = int(input())\nfor _ in range(t):\n    n = int(input())\n    input_signal = list(map(int, input().split()))\n    print(solve_dpcm(input_signal))",
    "timestamp": "2025-08-13 05:35:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    while True:\n        N, M = map(int, input[ptr:ptr+2])\n        ptr +=2\n        if N ==0 and M ==0:\n            break\n        codebook = list(map(int, input[ptr:ptr+M]))\n        ptr +=M\n        samples = list(map(int, input[ptr:ptr+N]))\n        ptr +=N\n        \n        # DP table: dp[i][v] = min squared sum up to i-th sample with output v\n        INF = float('inf')\n        dp_prev = [INF] * 256\n        dp_prev[128] = 0  # initial state\n        \n        for i in range(N):\n            dp_curr = [INF] * 256\n            for prev_v in range(256):\n                if dp_prev[prev_v] == INF:\n                    continue\n                for code in codebook:\n                    next_v = prev_v + code\n                    next_v = max(0, min(255, next_v))\n                    diff = samples[i] - next_v\n                    new_cost = dp_prev[prev_v] + diff * diff\n                    if new_cost < dp_curr[next_v]:\n                        dp_curr[next_v] = new_cost\n            dp_prev = dp_curr\n        \n        min_sum = min(dp_prev)\n        print(min_sum)\n\nsolve()",
    "timestamp": "2025-08-13 05:35:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\n\nint clip(int value) {\n    return max(0, min(255, value));\n}\n\nint main() {\n    int N, M;\n\n    // Read the number of samples and the codebook size\n    while (cin >> N >> M) {\n        vector<int> inputSignal(N);\n        vector<int> codebook(M);\n\n        // Read input signal\n        for (int i = 0; i < N; ++i) {\n            cin >> inputSignal[i];\n        }\n\n        // Read codebook values\n        for (int i = 0; i < M; ++i) {\n            cin >> codebook[i];\n        }\n\n        vector<vector<int>> dp(N, vector<int>(M, INT_MAX));\n        vector<vector<int>> previous(N, vector<int>(M, -1));\n\n        int initialValue = 128;\n\n        // Initialize the first step\n        for (int j = 0; j < M; ++j) {\n            int decodedValue = clip(initialValue + codebook[j]);\n            dp[0][j] = (inputSignal[0] - decodedValue) * (inputSignal[0] - decodedValue);\n        }\n\n        // Dynamic programming to compute the minimum sum\n        for (int i = 1; i < N; ++i) {\n            for (int j = 0; j < M; ++j) {\n                int decodedValue = clip(previous[i - 1][0] + codebook[j]);\n                for (int k = 0; k < M; ++k) {\n                    decodedValue = clip(decodedValue + codebook[k]);\n                    int diff = (inputSignal[i] - decodedValue) * (inputSignal[i] - decodedValue);\n\n                    int totalCost = dp[i - 1][j] + diff;\n                    if (totalCost < dp[i][j]) {\n                        dp[i][j] = totalCost;\n                        previous[i][j] = j;\n                    }\n                }\n            }\n        }\n\n        // Find the minimum sum in the last row\n        int minSum = INT_MAX;\n        for (int j = 0; j < M; ++j) {\n            minSum = min(minSum, dp[N - 1][j]);\n        }\n\n        // Output the minimum sum\n        cout << minSum << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:26:05"
  }
]