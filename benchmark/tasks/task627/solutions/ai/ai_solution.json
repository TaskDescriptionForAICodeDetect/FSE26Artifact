[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_VERTICES 1000\n\nbool graph[MAX_VERTICES][MAX_VERTICES];\nbool visited[MAX_VERTICES];\nint match[MAX_VERTICES];\n\nbool dfs(int u, int n, int m) {\n    for (int v = 0; v < m; v++) {\n        if (graph[u][v] && !visited[v]) {\n            visited[v] = true;\n            \n            if (match[v] == -1 || dfs(match[v], n, m)) {\n                match[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint maximum_matching(int n, int m) {\n    memset(match, -1, sizeof(match));\n    \n    int max_match = 0;\n    for (int u = 0; u < n; u++) {\n        memset(visited, 0, sizeof(visited));\n        \n        if (dfs(u, n, m))\n            max_match++;\n    }\n    \n    return max_match;\n}\n\nint main() {\n    int n, m, edges;\n    scanf(\"%d %d %d\", &n, &m, &edges);\n    \n    memset(graph, 0, sizeof(graph));\n    \n    for (int i = 0; i < edges; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u][v] = true;\n    }\n    \n    printf(\"%d\\n\", maximum_matching(n, m));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:21:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX 100\n\nint X, Y;\nbool graph[MAX][MAX];\nbool visited[MAX];\nint match[MAX];\n\nbool bpm(int u) {\n    for (int v = 0; v < Y; v++) {\n        if (graph[u][v] && !visited[v]) {\n            visited[v] = true;\n            if (match[v] == -1 || bpm(match[v])) {\n                match[v] = u;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nint maxBPM() {\n    memset(match, -1, sizeof(match));\n    int result = 0;\n    for (int u = 0; u < X; u++) {\n        memset(visited, 0, sizeof(visited));\n        if (bpm(u)) {\n            result++;\n        }\n    }\n    return result;\n}\n\nint main() {\n    int edges;\n    scanf(\"%d %d %d\", &X, &Y, &edges);\n    memset(graph, 0, sizeof(graph));\n    for (int i = 0; i < edges; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u][v] = true;\n    }\n    printf(\"%d\\n\", maxBPM());\n    return 0;\n}",
    "timestamp": "2025-08-05 22:22:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nbool bfs(vector<vector<int>>& residualGraph, vector<int>& level, int source, int sink) {\n    fill(level.begin(), level.end(), -1);\n    level[source] = 0;\n    queue<int> q;\n    q.push(source);\n    \n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        \n        for (int v = 0; v < residualGraph.size(); ++v) {\n            if (residualGraph[u][v] > 0 && level[v] == -1) {\n                level[v] = level[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    return level[sink] != -1;\n}\n\nint dfs(vector<vector<int>>& residualGraph, vector<int>& level, vector<int>& ptr, int u, int sink, int flow) {\n    if (u == sink) return flow;\n    \n    for (int& v = ptr[u]; v < residualGraph.size(); ++v) {\n        if (residualGraph[u][v] > 0 && level[v] == level[u] + 1) {\n            int min_flow = min(flow, residualGraph[u][v]);\n            int path_flow = dfs(residualGraph, level, ptr, v, sink, min_flow);\n            \n            if (path_flow > 0) {\n                residualGraph[u][v] -= path_flow;\n                residualGraph[v][u] += path_flow;\n                return path_flow;\n            }\n        }\n    }\n    return 0;\n}\n\nint dinic(vector<vector<int>>& graph, int source, int sink) {\n    int max_flow = 0;\n    vector<int> level(graph.size());\n    vector<int> ptr(graph.size());\n    \n    while (bfs(graph, level, source, sink)) {\n        fill(ptr.begin(), ptr.end(), 0);\n        while (int flow = dfs(graph, level, ptr, source, sink, INT_MAX)) {\n            max_flow += flow;\n        }\n    }\n    return max_flow;\n}\n\nint maxBipartiteMatching(vector<vector<int>>& graph, int x, int y) {\n    int total = x + y + 2;\n    vector<vector<int>> residualGraph(total, vector<int>(total, 0));\n    int source = 0, sink = total - 1;\n    \n    for (int i = 1; i <= x; ++i) {\n        residualGraph[source][i] = 1;\n    }\n    \n    for (int i = x + 1; i <= x + y; ++i) {\n        residualGraph[i][sink] = 1;\n    }\n    \n    for (int u = 0; u < x; ++u) {\n        for (int v = 0; v < y; ++v) {\n            if (graph[u][v]) {\n                residualGraph[u + 1][x + v + 1] = 1;\n            }\n        }\n    }\n    \n    return dinic(residualGraph, source, sink);\n}\n\nint main() {\n    int x, y, e;\n    cin >> x >> y >> e;\n    vector<vector<int>> graph(x, vector<int>(y, 0));\n    \n    for (int i = 0; i < e; ++i) {\n        int u, v;\n        cin >> u >> v;\n        graph[u][v] = 1;\n    }\n    \n    cout << maxBipartiteMatching(graph, x, y) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:22:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BipartiteMatching {\n    private int X, Y;\n    private List<Integer>[] adj;\n    private int[] pairX, pairY;\n    private int[] dist;\n\n    public BipartiteMatching(int X, int Y) {\n        this.X = X;\n        this.Y = Y;\n        adj = new ArrayList[X + 1];\n        for (int i = 0; i <= X; i++) {\n            adj[i] = new ArrayList<>();\n        }\n    }\n\n    public void addEdge(int u, int v) {\n        adj[u].add(v);\n    }\n\n    private boolean bfs() {\n        Queue<Integer> queue = new LinkedList<>();\n        for (int u = 1; u <= X; u++) {\n            if (pairX[u] == 0) {\n                dist[u] = 0;\n                queue.add(u);\n            } else {\n                dist[u] = Integer.MAX_VALUE;\n            }\n        }\n        dist[0] = Integer.MAX_VALUE;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            if (dist[u] < dist[0]) {\n                for (int v : adj[u]) {\n                    if (dist[pairY[v]] == Integer.MAX_VALUE) {\n                        dist[pairY[v]] = dist[u] + 1;\n                        queue.add(pairY[v]);\n                    }\n                }\n            }\n        }\n        return dist[0] != Integer.MAX_VALUE;\n    }\n\n    private boolean dfs(int u) {\n        if (u != 0) {\n            for (int v : adj[u]) {\n                if (dist[pairY[v]] == dist[u] + 1 && dfs(pairY[v])) {\n                    pairX[u] = v;\n                    pairY[v] = u;\n                    return true;\n                }\n            }\n            dist[u] = Integer.MAX_VALUE;\n            return false;\n        }\n        return true;\n    }\n\n    public int maxMatching() {\n        pairX = new int[X + 1];\n        pairY = new int[Y + 1];\n        dist = new int[X + 1];\n        int result = 0;\n\n        while (bfs()) {\n            for (int u = 1; u <= X; u++) {\n                if (pairX[u] == 0 && dfs(u)) {\n                    result++;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int X = scanner.nextInt();\n        int Y = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        BipartiteMatching bm = new BipartiteMatching(X, Y);\n        for (int i = 0; i < E; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            bm.addEdge(u, v);\n        }\n\n        System.out.println(bm.maxMatching());\n    }\n}",
    "timestamp": "2025-08-05 22:23:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass BipartiteMatching {\n    private int[] match;\n    private int[] dist;\n    private List<Integer>[] graph;\n    private int n, m;\n\n    public int maxMatching(List<Integer>[] bipartiteGraph, int leftSize, int rightSize) {\n        n = leftSize;\n        m = rightSize;\n        graph = bipartiteGraph;\n        match = new int[m];\n        dist = new int[n];\n        Arrays.fill(match, -1);\n\n        int maxMatch = 0;\n        while (bfs()) {\n            for (int i = 0; i < n; i++) {\n                if (dfs(i)) {\n                    maxMatch++;\n                }\n            }\n        }\n        return maxMatch;\n    }\n\n    private boolean bfs() {\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            dist[i] = Integer.MAX_VALUE;\n            if (match(i) == -1) {\n                dist[i] = 0;\n                queue.offer(i);\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (int v : graph[u]) {\n                int matchedVertex = match(v);\n                if (matchedVertex == -1) {\n                    return true;\n                }\n                if (dist[matchedVertex] == Integer.MAX_VALUE) {\n                    dist[matchedVertex] = dist[u] + 1;\n                    queue.offer(matchedVertex);\n                }\n            }\n        }\n        return false;\n    }\n\n    private boolean dfs(int u) {\n        if (u != -1) {\n            for (int v : graph[u]) {\n                int matchedVertex = match(v);\n                if (matchedVertex == -1 || \n                    (dist[matchedVertex] == dist[u] + 1 && dfs(matchedVertex))) {\n                    match[v] = u;\n                    return true;\n                }\n            }\n            dist[u] = Integer.MAX_VALUE;\n            return false;\n        }\n        return true;\n    }\n\n    private int match(int v) {\n        for (int i = 0; i < m; i++) {\n            if (match[i] == v) return i;\n        }\n        return -1;\n    }\n}",
    "timestamp": "2025-08-05 22:23:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass BipartiteMatching {\nprivate:\n    int n, m;\n    vector<vector<int>> graph;\n    vector<int> matchX, matchY;\n    vector<bool> visited;\n\n    bool bfs() {\n        queue<int> q;\n        for (int x = 0; x < n; x++) {\n            if (matchX[x] == -1) {\n                q.push(x);\n                visited[x] = true;\n            }\n        }\n\n        while (!q.empty()) {\n            int x = q.front();\n            q.pop();\n\n            for (int y : graph[x]) {\n                if (matchY[y] == -1 || (!visited[matchY[y]] && bfs(matchY[y]))) {\n                    if (matchY[y] == -1) {\n                        int curX = x, curY = y, nextX;\n                        while (curX != -1) {\n                            nextX = matchX[curX];\n                            matchX[curX] = curY;\n                            matchY[curY] = curX;\n                            curY = nextX;\n                            curX = curY != -1 ? matchY[curY] : -1;\n                        }\n                        return true;\n                    }\n                    q.push(matchY[y]);\n                    visited[matchY[y]] = true;\n                }\n            }\n        }\n        return false;\n    }\n\n    bool bfs(int x) {\n        queue<int> q;\n        q.push(x);\n        visited[x] = true;\n\n        while (!q.empty()) {\n            x = q.front();\n            q.pop();\n\n            for (int y : graph[x]) {\n                if (matchY[y] == -1 || (!visited[matchY[y]] && bfs(matchY[y]))) {\n                    if (matchY[y] == -1) {\n                        int curX = x, curY = y, nextX;\n                        while (curX != -1) {\n                            nextX = matchX[curX];\n                            matchX[curX] = curY;\n                            matchY[curY] = curX;\n                            curY = nextX;\n                            curX = curY != -1 ? matchY[curY] : -1;\n                        }\n                        return true;\n                    }\n                    q.push(matchY[y]);\n                    visited[matchY[y]] = true;\n                }\n            }\n        }\n        return false;\n    }\n\npublic:\n    BipartiteMatching(int n, int m) : n(n), m(m), graph(n), matchX(n, -1), matchY(m, -1), visited(n) {}\n\n    void addEdge(int x, int y) {\n        graph[x].push_back(y);\n    }\n\n    int maximumMatching() {\n        int matching = 0;\n        while (bfs()) {\n            fill(visited.begin(), visited.end(), false);\n            matching++;\n        }\n        return matching;\n    }\n};\n\nint main() {\n    int n, m, e;\n    cin >> n >> m >> e;\n\n    BipartiteMatching bm(n, m);\n\n    for (int i = 0; i < e; i++) {\n        int x, y;\n        cin >> x >> y;\n        bm.addEdge(x, y);\n    }\n\n    cout << bm.maximumMatching() << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:23:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef bfs(level, pair_x, pair_y, adj_list, m, n):\n    queue = deque()\n    for u in range(m):\n        if pair_x[u] == -1:\n            level[u] = 0\n            queue.append(u)\n        else:\n            level[u] = -1\n    \n    found_augmenting_path = False\n    while queue:\n        u = queue.popleft()\n        for v in adj_list[u]:\n            if pair_y[v] == -1:\n                found_augmenting_path = True\n            elif level[pair_y[v]] == -1:\n                level[pair_y[v]] = level[u] + 1\n                queue.append(pair_y[v])\n    \n    return found_augmenting_path\n\ndef dfs(u, level, pair_x, pair_y, adj_list):\n    for v in adj_list[u]:\n        if pair_y[v] == -1 or (level[pair_y[v]] == level[u] + 1 and dfs(pair_y[v], level, pair_x, pair_y, adj_list)):\n            pair_x[u] = v\n            pair_y[v] = u\n            return True\n    return False\n\ndef hopcroft_karp(X, Y, edges):\n    m = len(X)\n    n = len(Y)\n    adj_list = [[] for _ in range(m)]\n    for u, v in edges:\n        adj_list[u].append(v)\n    \n    pair_x = [-1] * m\n    pair_y = [-1] * n\n    \n    matching_size = 0\n    while True:\n        level = [-1] * m\n        if not bfs(level, pair_x, pair_y, adj_list, m, n):\n            break\n        for u in range(m):\n            if pair_x[u] == -1 and dfs(u, level, pair_x, pair_y, adj_list):\n                matching_size += 1\n    \n    return matching_size\n\n# Example usage:\nX = [0, 1, 2]  # Vertex set X\nY = [0, 1, 2]  # Vertex set Y\nedges = [(0, 0), (0, 1), (1, 1), (2, 2)]  # Edges between X and Y\nprint(hopcroft_karp(X, Y, edges))  # Output: 3",
    "timestamp": "2025-08-13 10:17:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class BipartiteMatching {\n    public static void main(String[] args) {\n        // Example usage\n        int[][] graph = {\n            {1, 0, 1, 0},\n            {0, 1, 1, 0},\n            {0, 0, 0, 1},\n            {1, 1, 0, 0}\n        };\n        \n        BipartiteMatching bm = new BipartiteMatching();\n        System.out.println(\"Maximum matching size: \" + bm.maxBipartiteMatching(graph)); // Output should be the size of the maximum matching\n    }\n\n    public int maxBipartiteMatching(int[][] graph) {\n        int n = graph.length; // Number of vertices in set X\n        int m = graph[0].length; // Number of vertices in set Y\n\n        // Array to keep track of which vertex in Y is matched with which in X\n        int[] matchR = new int[m];\n        Arrays.fill(matchR, -1); // Initially, all vertices in Y are unmatched\n\n        int result = 0; // Store the number of matchings\n        for (int u = 0; u < n; u++) {\n            boolean[] visited = new boolean[m];\n            if (bfs(u, visited, matchR, graph)) {\n                result++;\n            }\n        }\n        return result;\n    }\n\n    private boolean bfs(int u, boolean[] visited, int[] matchR, int[][] graph) {\n        for (int v = 0; v < graph[0].length; v++) {\n            // If there's an edge from u in X to v in Y and v is not visited\n            if (graph[u][v] == 1 && !visited[v]) {\n                visited[v] = true; // Mark v as visited\n\n                // v is not matched or previously matched vertex in X can find alternative\n                if (matchR[v] < 0 || bfs(matchR[v], visited, matchR, graph)) {\n                    matchR[v] = u;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}",
    "timestamp": "2025-08-13 10:17:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX 100\n\nint adj[MAX][MAX], visited[MAX], pairU[MAX], pairV[MAX];\nint m, n;\n\nint bpm(int u) {\n    for (int v = 0; v < n; v++) {\n        if (adj[u][v] && !visited[v]) {\n            visited[v] = 1;\n            if (pairV[v] == -1 || bpm(pairV[v])) {\n                pairV[v] = u;\n                pairU[u] = v;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxBipartiteMatching() {\n    memset(pairU, -1, sizeof(pairU));\n    memset(pairV, -1, sizeof(pairV));\n    \n    int result = 0;\n    for (int u = 0; u < m; u++) {\n        memset(visited, 0, sizeof(visited));\n        if (bpm(u))\n            result++;\n    }\n    return result;\n}\n\nint main() {\n    // Read matrix dimensions\n    scanf(\"%d %d\", &m, &n);\n    \n    // Read adjacency matrix\n    for (int u = 0; u < m; u++) {\n        for (int v = 0; v < n; v++) {\n            scanf(\"%d\", &adj[u][v]);\n        }\n    }\n    \n    printf(\"%d\\n\", maxBipartiteMatching());\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:17:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_bipartite_matching(graph):\n    def dfs(node):\n        if visited[node]:\n            return False\n        visited[node] = True\n        \n        for neighbor in graph[node]:\n            if match[neighbor] == -1 or dfs(match[neighbor]):\n                match[neighbor] = node\n                return True\n        \n        return False\n\n    n = len(graph)\n    match = [-1] * n\n    max_match = 0\n\n    for node in range(n):\n        visited = [False] * n\n        if dfs(node):\n            max_match += 1\n\n    return max_match",
    "timestamp": "2025-08-13 10:17:54"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\nclass BipartiteGraph:\n    def __init__(self, X, Y, edges):\n        self.X = X\n        self.Y = Y\n        self.graph = {x: [] for x in X}\n        for x, y in edges:\n            self.graph[x].append(y)\n        self.pair_X = {x: None for x in X}\n        self.pair_Y = {y: None for y in Y}\n    \n    def bfs(self):\n        queue = deque()\n        self.dist = {}\n        for x in self.X:\n            if self.pair_X[x] is None:\n                self.dist[x] = 0\n                queue.append(x)\n            else:\n                self.dist[x] = float('inf')\n        dist_null = float('inf')\n        while queue:\n            x = queue.popleft()\n            if self.dist[x] < dist_null:\n                for y in self.graph[x]:\n                    if self.pair_Y[y] is None:\n                        dist_null = self.dist[x] + 1\n                    elif self.dist[self.pair_Y[y]] == float('inf'):\n                        self.dist[self.pair_Y[y]] = self.dist[x] + 1\n                        queue.append(self.pair_Y[y])\n        return dist_null != float('inf')\n    \n    def dfs(self, x):\n        for y in self.graph[x]:\n            if self.pair_Y[y] is None or (self.dist[self.pair_Y[y]] == self.dist[x] + 1 and self.dfs(self.pair_Y[y])):\n                self.pair_X[x] = y\n                self.pair_Y[y] = x\n                return True\n        self.dist[x] = float('inf')\n        return False\n    \n    def hopcroft_karp(self):\n        result = 0\n        while self.bfs():\n            for x in self.X:\n                if self.pair_X[x] is None:\n                    if self.dfs(x):\n                        result += 1\n        return result\n\ndef max_bipartite_matching(X, Y, edges):\n    graph = BipartiteGraph(X, Y, edges)\n    return graph.hopcroft_karp()",
    "timestamp": "2025-08-13 10:18:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX = 500;\n\nvector<int> adj[MAX];\nint pairU[MAX], pairV[MAX], dist[MAX];\nint n, m; // n = size of U, m = size of V\n\nbool bfs() {\n    queue<int> Q;\n    for (int u = 1; u <= n; ++u) {\n        if (pairU[u] == 0) {\n            dist[u] = 0;\n            Q.push(u);\n        } else {\n            dist[u] = -1;\n        }\n    }\n    bool reachable = false;\n    while (!Q.empty()) {\n        int u = Q.front();\n        Q.pop();\n        for (auto &v : adj[u]) {\n            if (pairV[v] == 0) {\n                reachable = true;\n            } else if (dist[pairV[v]] == -1) {\n                dist[pairV[v]] = dist[u] + 1;\n                Q.push(pairV[v]);\n            }\n        }\n    }\n    return reachable;\n}\n\nbool dfs(int u) {\n    for (auto &v : adj[u]) {\n        if (pairV[v] == 0 || (dist[pairV[v]] == dist[u] + 1 && dfs(pairV[v]))) {\n            pairU[u] = v;\n            pairV[v] = u;\n            return true;\n        }\n    }\n    dist[u] = -1;\n    return false;\n}\n\nint hopcroftKarp() {\n    memset(pairU, 0, sizeof(pairU));\n    memset(pairV, 0, sizeof(pairV));\n    int matching = 0;\n    while (bfs()) {\n        for (int u = 1; u <= n; ++u) {\n            if (pairU[u] == 0 && dfs(u)) {\n                ++matching;\n            }\n        }\n    }\n    return matching;\n}\n\nint main() {\n    int edges;\n    cin >> n >> m >> edges;\n    for (int i = 0; i < edges; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n    }\n    cout << \"Largest Matching Size: \" << hopcroftKarp() << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:58:09"
  }
]