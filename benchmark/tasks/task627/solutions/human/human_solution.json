[
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAX 256\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\nint X, Y, E;\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[to].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (1) {\n        for (int i = 0; i < MAX; i++) used[i] = false;\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(void) {\n    cin >> X >> Y >> E;\n    while (E--) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, X+y, 1);\n    }\n    int s = X+Y, t = s+1;\n    for (int i = 0; i < X; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        add_edge(X+i, t, 1);\n    }\n    cout << max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nusing Num=double;\nusing Vec=vector<Num>;\nusing Mat=vector<Vec>;\nconst Num Inf=numeric_limits<Num>::infinity();\nconst Num NoSolution=numeric_limits<Num>::quiet_NaN();\nNum EPS=1e-10;\n/*\nmin c*x\ns.t. A*x<=b\n     x>=0\n*/\n\nNum simplex(const Mat &A,const Vec &b,const Vec &c){\n    const int m=A.size(),n=A[0].size();\n\n    Mat D(m+1,Vec(n+m+1));\n    Vec id(m+n);\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++)D[i][j]=A[i][j];\n        D[i][n+i]=1;\n        D[i][n+m]=-b[i];\n    }\n    for(int i=0;i<n;i++)D[m][i]=c[i];\n\n    for(int i=0;i<m;i++)id[i]=n+i;\n    for(int i=0;i<n;i++)id[m+i]=i;\n\n    while(true){\n        int r=n;\n        for(int i=n-1;i>=0;i--)if(D[m][id[m+i]]<-EPS)r=i;\n        if(r==n)return D[m][n+m];\n        int s=m;\n        for(int i=0;i<m;i++)if(D[i][id[m+r]]>EPS){\n            if(s==m||-D[s][n+m]/D[s][id[m+r]]>-D[i][n+m]/D[i][id[m+r]])s=i;\n        }\n        if(s==m)return Inf;//NoBound\n        Num k=D[s][id[m+r]];\n        for(int i=0;i<=n+m;i++)D[s][i]/=k;\n        for(int i=0;i<=m;i++){\n            if(i==s)continue;\n            k=D[i][id[m+r]];\n            for(int j=0;j<=n+m;j++)D[i][j]-=k*D[s][j];\n        }\n        swap(id[s],id[m+r]);\n    }\n}\n\nint X,Y,E;\n\nint x[111][11111],y[111][111111];\n\nsigned main(){\n    cin>>X>>Y>>E;\n    rep(i,E){\n        int a,b;cin>>a>>b;\n        x[a][i]=1;y[b][i]=1;\n    }\n\n    Mat A;Vec b,c(E);\n    rep(i,E)c[i]=-1;\n    for(int i=0;i<X;i++){\n        Vec v(E);rep(j,E)v[j]=x[i][j];\n        A.pb(v);b.pb(1);\n    }\n    for(int i=0;i<Y;i++){\n        Vec v(E);rep(j,E)v[j]=y[i][j];\n        A.pb(v);b.pb(1);\n    }\n    rep(i,E){\n        Vec v(E);v[i]=1;\n        A.pb(v);b.pb(1);\n    }\n\n    cout<<round(-simplex(A,b,c))<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAX 1024\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\nint X, Y, E;\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, cap, (int)G[to].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge& e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (1) {\n        for (int i = 0; i < MAX; i++) used[i] = false;\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(void) {\n    cin >> X >> Y >> E;\n    while (E--) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, X+y, 1);\n    }\n    int s = X+Y, t = s+1;\n    for (int i = 0; i < X; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        add_edge(X+i, t, 1);\n    }\n    cout << max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <iostream>\n#include <random>\n#include <map>\n#include <iomanip>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include <fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\n\nusing ll = long long;\nusing vll = vector<ll>;\nusing pll = pair<ll, ll>;\nusing qll = queue<ll>;\nusing vb = vector<bool>;\nusing mll = map<ll, ll>;\nusing sll = stack<ll>;\n#define REP(i,n) for(ll i(0);(i)<(n);(i)++)\n#define rep(i,n) for(ll i(0);(i)<(n);(i)++)\n#define ALL(a) a.begin(), a.end()\n#define elnd endl //* missspell check\nconst ll INF = 1LL << 60;\n\nvoid add_edge(vector<vll> &G, ll u, ll v){\n    G[u].push_back(v); G[v].push_back(u);\n}\n\nbool dfs(vector<vll> &G, vb &checked, vll &match, ll v){\n    //* match is initialized -1 outside\n    checked[v] = true;\n    REP(i, G[v].size()){\n        ll u = G[v][i], w = match[u];\n        if(w < 0 || !checked[w] && dfs(G, checked, match, w)){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nll BipartiteMatching(vector<vll> &G){\n    ll N = G.size();\n    vb checked(N, false);\n    vll match(N, -1);\n    ll res = 0;\n    REP(v, N){\n        if(match[v] < 0){\n            fill(ALL(checked), false);\n            if(dfs(G, checked, match, v)){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\n//! submitted to: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_7_A&lang=jp\nint main(){\n    ll X, Y, E; cin >> X >> Y >> E;\n    ll N = X+Y;\n    vector<vll> G(N);\n    REP(i, E){\n        ll x, y;\n        cin >> x >> y;\n        y += X;\n        add_edge(G, x, y);\n    }\n    ll m = 0;\n    m = BipartiteMatching(G);\n    cout<<m<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\n#define VMAX 100\n\nvector<int> G[VMAX + VMAX];\nbool checked[VMAX + VMAX];\nint mate[VMAX + VMAX];\n\nbool augment(int x)\n{\n\tif (checked[x])\n\t{\n\t\treturn false;\n\t}\n\tchecked[x] = true;\n\tfor (auto y : G[x])\n\t{\n\t\tif (mate[y] == -1 || augment(y))\n\t\t{\n\t\t\tmate[x] = y;\n\t\t\tmate[y] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint max_matching(int X)\n{\n\tint match = 0;\n\tfill(mate, mate + VMAX + VMAX, -1);\n\tfor (int i = 0; i < X; i++)\n\t{\n\t\tfill(checked, checked + VMAX + VMAX, false);\n\t\tif (augment(i))\n\t\t{\n\t\t\tmatch++;\n\t\t}\n\t}\n\treturn match;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint X,Y,E;\n\tcin >> X >> Y >> E;\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\n\t\tG[x].push_back(X + y);\n\t\tG[X + y].push_back(x);\n\t}\n\n\tcout << max_matching(X) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n参考\n・蟻本p197\n・https://ei1333.github.io/luzhiled/snippets/graph/bipartite-matching.html\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nusing Graph=vector<vector<int>>;\n\n\nstruct BipartiteMatching{\n    Graph graph;\n    vector<int> match,used;\n    int now,sz;\n\n    BipartiteMatching(int n):sz(n),graph(n),used(n,-1),match(n,-1),now(0){}\n\n    void add_edge(int u,int v){\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    bool dfs(int idx){\n        used[idx]=now;\n        for(int to:graph[idx]){\n            int to_match=match[to];\n            if(to_match==-1 || (used[to_match]!=now && dfs(to_match) )  ){\n                match[idx]=to;\n                match[to]=idx;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int bipartite_matching(){\n        int ret=0;\n        for(int i=0;i<sz;i++){\n            if(match[i]==-1){\n                ret+=dfs(i);\n                now++;\n            }\n        }\n        return ret;\n    }\n};\n\nsigned main(){\n    int x,y,e;\n    cin>>x>>y>>e;\n    BipartiteMatching b(x+y);\n\n    while(e--){\n        int s,t;\n        cin>>s>>t;\n        b.add_edge(s,t+x);\n    }\n    cout<<b.bipartite_matching()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing Flow = int;\nstruct FlowEdge {\n  int src, dst;\n  Flow cap;\n  int rev;\n  FlowEdge(const int s = 0, const int d = 0, const Flow c = 0, const int r = 0) : src(s), dst(d), cap(c), rev(r) {}\n};\n\nusing FlowEdges = std::vector<FlowEdge>;\n\nclass FlowGraph {\n  std::vector<FlowEdges> g;\n\npublic:\n  FlowGraph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  FlowEdges &operator[](const int i) & { return g[i]; }\n\n  void addEdge(const int src, const int dst, const Flow c = 1) {\n    g[src].emplace_back(src, dst, c, g[dst].size());\n    g[dst].emplace_back(dst, src, 0, g[src].size() - 1);\n  }\n};\n\n// Change it to 'FlowGraph &g' when you need a residual network\ntemplate<Flow inf = std::numeric_limits<Flow>::max() / 8> Flow fordFulkerson(FlowGraph g, const int source, const int sink) {\n  std::vector<int> used(g.size());\n  std::function<Flow(int, Flow)> dfs = [&](int v, Flow f) -> Flow {\n    if (v == sink) return f;\n    used[v] = true;\n    for (auto &e : g[v]) {\n      if (used[e.dst] || e.cap <= 0) continue;\n      Flow d = dfs(e.dst, min(f, e.cap));\n      if (d <= 0) continue;\n      e.cap -= d;\n      g[e.dst][e.rev].cap += d;\n      return d;\n    }\n    return 0;\n  };\n  Flow s = 0;\n  for (;;) {\n    std::fill(used.begin(), used.end(), false);\n    Flow f = dfs(source, inf);\n    if (f == 0) return s;\n    s += f;\n  }\n}\n\nmain {\n  int X, Y, E;\n  cin >> X >> Y >> E;\n  FlowGraph g(X + Y + 2);\n  rep(i, X) g.addEdge(X + Y, i, 1);\n  rep(i, Y) g.addEdge(X + i, X + Y + 1, 1);\n  while (E--) {\n    int x, y;\n    cin >> x >> y;\n    g.addEdge(x, X + y);\n  }\n  cout << fordFulkerson(g, X + Y, X + Y + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct HopcroftKarp {\n    int sizeL, sizeR;\n    vector<vector<int>> candy;      // candy[l] = R\n    vector<bool> matched, seen;\n    vector<int> matching, dist;\n    HopcroftKarp(int l, int r) : sizeL(l), sizeR(r), candy(l) { }\n    void add_edge(int u, int v) { candy[u].emplace_back(v); }\n    void bfs() {\n        dist.assign(sizeL, -1);\n        queue<int> que;\n        for (int left = 0; left < sizeL; left++) if (!matched[left]) {\n            dist[left] = 0; que.emplace(left);\n        }\n        while (!que.empty()) {\n            int left = que.front(); que.pop();\n            for (auto right: candy[left]) {\n                int nxt = matching[right];\n                if (nxt >= 0 && dist[nxt] == -1) {\n                    dist[nxt] = dist[left] + 1;\n                    que.emplace(nxt);\n                }\n            }\n        }\n    }\n    bool dfs(int left) {\n        seen[left] = true;\n        for (auto &right: candy[left]) {\n            int nxt = matching[right];\n            if (nxt < 0 || (!seen[nxt] && dist[nxt] == dist[left] + 1 && dfs(nxt))) {\n                matching[right] = left;\n                return matched[left] = true;\n            }\n        }\n        return false;\n    }\n    int solve() {\n        matched.assign(sizeL, false);\n        matching.assign(sizeR, -1), dist.assign(sizeL, -1);\n        int res = 0;\n        while (true) {\n            bfs();\n            seen.assign(sizeL, false);\n            int flow = 0;\n            for (int i = 0; i < sizeL; i++) {\n                if (!matched[i] && dfs(i)) flow++;\n            }\n            if (flow == 0) return res;\n            res += flow;\n        }\n    }\n    friend ostream& operator<<(ostream& os, HopcroftKarp& bm) {\n        for (int i = 0; i < bm.matching.size(); i++) if (~bm.matching[i]) {\n            os << bm.matching[i] << \" - \" << i << endl;\n        }\n        return os;\n    }\n};\n\nint main() {\n    int X, Y, E; cin >> X >> Y >> E;\n    HopcroftKarp bm(X, Y);\n    while (E--) {\n        int a, b; cin >> a >> b;\n        bm.add_edge(a, b);\n    }\n    cout << bm.solve() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "# include \"bits/stdc++.h\"\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntypedef pair<LL, LL> pii;\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\n# pragma warning(disable:4996)\n\nconst int MAX_V = 101010;\n\nstruct edge { int to; LL cap; int rev; };\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, LL cap) {\n\tG[from].emplace_back(edge{ to,cap,(int)G[to].size() });\n\tG[to].emplace_back(edge{ from,0,(int)G[from].size() - 1 });\n}\n\nvoid bfs(int s) {\n\tfor (int i = 0; i < MAX_V; i++)level[i] = -1;\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nLL dfs(int v, int t, LL f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0LL;\n}\n\nLL max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tfor (int i = 0; i < MAX_V; i++)iter[i] = 0;\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF<LL>())) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\n\nint x, y, e;\nint s = 99999, t = 100000;\nint main() {\n\tcin >> x >> y >> e;\n\tREP(i, x)add_edge(s, i, 1);\n\tREP(j, y)add_edge(200 + j, t, 1);\n\tREP(i, e) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tadd_edge(a, 200 + b, 1);\n\t}\n\tcout << max_flow(s,t) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAX 1024\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\nint X, Y, E;\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, cap, (int)G[to].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge& e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (1) {\n        for (int i = 0; i < MAX; i++) used[i] = false;\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(void) {\n    cin >> X >> Y >> E;\n    while (E--) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, X+y, 1);\n    }\n    int s = X+Y, t = s+1;\n    for (int i = 0; i < X; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        add_edge(t, X+i, 1);\n    }\n    cout << max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\nclass BipartiteMatching {\n    int n, n0;\n    int mode;\n    vvi adj;\n    vi mc;\n    vi used;\n\n    bool dfs(int v) {\n        used[v] = true;\n        for (int i = 0; i < adj[v].size(); i++) {\n            int u = adj[v][i];\n            int w = mc[u];\n            if (w < 0 || (!used[w] && dfs(w))) {\n                mc[v] = u;\n                mc[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\npublic:\n    BipartiteMatching(int n) : n(n), adj(n), mc(n, -1) {\n        mode = 0;\n    }\n    BipartiteMatching(int n, int m) : n(n + m), n0(n), adj(n + m), mc(n + m, -1) {\n        mode = 1;\n    }\n\n    void addEdge(int u, int v) {\n        if (mode == 0) {\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        } else {\n            adj[u].push_back(n0 + v);\n            adj[n0 + v].push_back(u);\n        }\n    }\n\n    int match() {\n        int ret = 0;\n        for (int v = 0; v < n; v++) {\n            if (mc[v] < 0) {\n                used = vi(n);\n                if (dfs(v)) {\n                    ret++;\n                }\n            }\n        }\n        return ret;\n    }\n\n    int operator[](int k) {\n        return mc[k];\n    }\n};\n\nint main() {\n    int x, y, e;\n    cin >> x >> y >> e;\n    BipartiteMatching match(x, y);\n    for (int i = 0; i < e; i++) {\n        int a, b;\n        cin >> a >> b;\n        match.addEdge(a, b);\n    }\n\n    cout << match.match() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n\n#define INF 99999999\n\nusing namespace std;\n\nstruct edge{\n\tint to,cap,rev; \n};\n\nconst int MAX_V = 205;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\t\t//??°???????????\\???\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n\tif(v == t)\treturn f;\n\tused[v] = true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e = G[v][i];\t//?????§?????°??¨????????????(?????????????????£??\\???????????????????????????)\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\t//e???G[v][i]?????¨????????¢?????§???????????????????????????G[v][i]??????????????????????????¨??????\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f = dfs(s,t,INF);\n\t\tif(f == 0)\treturn flow;\n\t\tflow += f;\n\t}\n}\n\nint main(){\n\tint n,m,s,t,result,x,y;\n\tcin >> x >> y >> m;\n\tfor(int i=0;i<m;i++){\n\t\tint from,to,cap;\n\t\tcin >> from;\n\t\tcin >> to;\n\t\tadd_edge(x+y,from,INF);\n\t\tadd_edge(from,x+to,1);\n\t\tadd_edge(x+to,x+y+1,INF);\n\t}\n\tresult = max_flow(x+y,x+y+1);\n\tcout << result/2 << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <tuple>\n#include <cassert>\n#include <exception>\n#include <iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\n#define rep(i,a,n) for(ll i = (a);i < (n);i++)\n#define per(i,a,n) for(ll i = (a);i > (n);i--)\n#define lep(i,a,n) for(ll i = (a);i <= (n);i++)\n#define pel(i,a,n) for(ll i = (a);i >= (n);i--)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define sz size()\n#define print(X) cout << (X) << endl\n#define fprint(NUM,X) cout << fixed << setprecision(NUM) << (X) << endl\n#define fprints(NUM,X,Y) cout << fixed << setprecision(NUM) << (X) << \" \" << (Y) << endl\nstatic const int INF = 1e+9+7;\nll n,m,l;\nstring s,t;\nll d[200010],dp[1010][1010];\ndouble w[1000],v[1000];\ndouble box[200010];\n\nstatic const int MAX = 10000;\nint V;\nvector<int> graph[MAX];\nint match[MAX];\nbool used[MAX];\n\nvoid add_edge(int u,int v){\n  graph[u].push_back(v);\n  graph[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i = 0;i < graph[v].size();i++){\n    int u = graph[v][i] , w = match[u];\n    if(w < 0 || (!used[w] && dfs(w))){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset(match,-1,sizeof(match));\n  for(int v = 0;v < V;v++){\n    if(match[v] < 0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)){\n        res++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> V >> n >> l;\n  rep(i,0,l){\n    int x,y;\n    cin >> x >> y;\n    add_edge(x,y);\n  }\n  print(bipartite_matching());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\n\n//BEGIN CUT HERE\n//Dinic\n//最大流を高速に求めることが出来ます\n//二部マッチングにも使ってください\nclass Dinic{\npublic:\n\n    //引数はありうる頂点の最大の数を入れてください\n    explicit Dinic(int v):vertex(static_cast<unsigned int>(v)){\n        G.resize(vertex+10);\n    }\n\n    //頂点fromからtoへの流せる量の最大がcapのとき、add_edge(int from,int to,ll cap)\n    //\n    //二部マッチングのときは、capは1にしてください\n    //二部マッチングのとき、意図的に、与えられる頂点以外に２つ頂点を作ってください\n    //それをs,tとしてsからtへの最大流を求めてください\n    void add_edge(int from,int to,ll cap){\n        G[from].push_back((edge){to, cap, static_cast<int>(G[to].size())});\n        G[to].push_back((edge){from, 0, static_cast<int>(G[from].size() - 1)});\n    }\n\n    ll max_flow(int s,int t){//s->start , t->end\n        ll flow=0;\n        for(;;){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter.clear();\n            iter.resize(vertex+10,0);\n            ll f;\n            while((f=dfs(s,t,INF))>0)flow+=f;\n        }\n    }\nprivate:\n    unsigned int vertex;\n    struct edge{\n        int to;\n        ll cap;\n        int rev;\n    };\n    vector<vector<edge> > G;\n    vector<int> level;\n    vector<int> iter;\n    ll INF=(ll)1e16;\n    void bfs(int start){\n        level.clear();\n        level.resize(vertex+10,-1);\n        queue<int> q;\n        q.push(start);\n        level[start]=0;\n        while(!q.empty()){\n            int now=q.front();\n            q.pop();\n            for(int i=0;i<(int)G[now].size();i++) {\n                if(G[now][i].cap>0 && level[G[now][i].to]<0){\n                    level[G[now][i].to]=level[now]+1;\n                    q.push(G[now][i].to);\n                }\n            }\n        }\n    }\n    ll dfs(int now,int t,ll f){\n        if(now==t)return f;\n        for(int &i=iter[now];i<(int)G[now].size();i++){\n            edge &e=G[now][i];\n            if(e.cap>0 && level[now]<level[e.to]){\n                ll d=dfs(e.to,t,min(f,e.cap));\n                if(d>0){\n                    e.cap-=d;\n                    G[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n};\n//END CUT HERE\n\n//検証しました!!!!\n//ARC092-B 2D Plane 2N Points\n/*int main(){\n    int n;cin>>n;\n    Dinic f(2*n);\n    int s=2*n;\n    int t=s+1;\n    vector<pair<int,int> > aka,ao;\n    for(int i=0;i<n;i++){\n        int a,b;cin>>a>>b;\n        aka.push_back({a,b});\n        f.add_edge(s,i,1);\n    }\n    for(int i=0;i<n;i++){\n        int a,b;cin>>a>>b;\n        ao.push_back({a,b});\n        f.add_edge(n+i,t,1);\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(aka[j].first<ao[i].first && aka[j].second<ao[i].second){\n                f.add_edge(j,n+i,1);\n            }\n        }\n    }\n    cout<<f.max_flow(s,t)<<endl;\n}*/\n/*\nint main(){\n    int v,e;cin>>v>>e;\n    Dinic f(v);\n    for(int i=0;i<e;i++){\n        int from,to,cap;cin>>from>>to>>cap;\n        f.add_edge(from,to,cap);\n    }\n    cout<<f.max_flow(0,v-1)<<endl;\n}*/\n\nint main(){\n    int x,y,e;cin>>x>>y>>e;\n    Dinic d(x+y+2);\n    int s=x+y+1;\n    int t=s+1;\n    for(int i=0;i<x;i++){\n        d.add_edge(s,i,1);\n    }\n    for(int j=0;j<y;j++){\n        d.add_edge(x+j,t,1);\n    }\n    for(int i=0;i<e;i++){\n        int a,b;cin>>a>>b;\n        d.add_edge(a,x+b,1);\n    }\n    cout<<d.max_flow(s,t)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n//by NeighThorn\nusing namespace std;\nconst int maxn=100+5,maxm=10000+5;\nint n,m,e,hd[maxn],to[maxm*2],nxt[maxm*2],cnt,pre[maxn],vis[maxn],ans;\ninline void add(int x,int y){\n\tto[cnt]=y;nxt[cnt]=hd[x];hd[x]=cnt++;\n}\ninline bool dfs(int root){\n\tfor(int i=hd[root];i!=-1;i=nxt[i])\n\t\tif(!vis[to[i]]){\n\t\t\tvis[to[i]]=1;\n\t\t\tif(pre[to[i]]==-1||dfs(pre[to[i]])){\n\t\t\t\tpre[to[i]]=root;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\nsigned main(void){\n\tcnt=0;ans=0;\n\tmemset(hd,-1,sizeof(hd));\n\tmemset(pre,-1,sizeof(pre));\n\tscanf(\"%d%d%d\",&n,&m,&e);\n\tfor(int i=1,x,y;i<=e;i++)\n\t\tscanf(\"%d%d\",&x,&y),add(x,y+n);\n\tfor(int i=0;i<n;i++)\n\t\tmemset(vis,0,sizeof(vis)),ans+=dfs(i);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\nconst int MAX_V = 250;\n\nint V, match[MAX_V], used[MAX_V];\nvector<int> G[MAX_V];\n\nbool dfs(int v){\n  used[v] = true;\n  REP(i, G[v].size()){\n    int u = G[v][i], w = match[u];\n    if(w < 0 || (!used[w] && dfs(w))){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  REP(v, V)\n    if(match[v] < 0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)) ++res;\n    }\n  return res;\n}\n\nint main() {\n  int X, Y, E; cin >>X >>Y >>E;\n  V = X + Y;\n  REP(i, E){\n    int u, v; cin >>u >>v;\n    v += X;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  cout <<bipartite_matching() <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <bitset>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int> >vpi;\ntypedef pair<int,int> pi;\n#define R return\n#define W while\n#define FOR(i,a) for(int i=0;i<a;i++)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\nvi v[510];\nbitset<510>b,x;\nint m[510];\nbool dfs(int now){\n    FOR(i,v[now].size())if(!b[v[now][i]]){\n        b[v[now][i]]=true;\n        if(m[v[now][i]]==-1||dfs(m[v[now][i]])){\n            m[v[now][i]]=now;\n            R x[now]=true;\n        }\n    }\n    R false;\n}\nint main(){\n    int n,y,k,l,r,ans=0;\n    x.reset();\n    scanf(\"%d%d\",&n,&y,&k);\nn=max(n,y);\n    n++;\n    FOR(i,n)m[i]=-1;\n    W(k--){\n        scanf(\"%d%d\",&l,&r);\n        v[l].PB(r);\n    }\n    FOR(i,n)if(!x[i]){\n        b.reset();\n        if(dfs(i))ans++;\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int vmax=210;\n\nint X,Y,M;\nvector<int> graph[vmax];\nint match[vmax];\nbool used[vmax];\n\nbool dfs(int v){\n\tused[v]=true;\n\tfor(auto &u:graph[v]){\n\t\tint w=match[u];\n\t\tif(w < 0 || (!used[w] && dfs(w)) ){\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(){\n\tint res=0;\n\trep(i,vmax) match[i]=-1;\n\trep(v,X+Y){\n\t\tif(match[v]<0){\n\t\t\trep(i,vmax) used[i]=0;\n\t\t\tif(dfs(v)) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tcin >> X >> Y >> M;\n\trep(i,M){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tb+=X;\n\t\tgraph[a].push_back(b);\n\t\tgraph[b].push_back(a);\n\t}\n\tcout << bipartite_matching() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstdint>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint main() {\n\tint X, Y, E;\n\tcin >> X >> Y >> E;\n\tint c[202][202] = { {0} };\n\tfor (int i = 0; i < E; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tc[x + 1][y + 101] = 1;\n\t}\n\tfor (int i = 0; i < X; i++) c[0][i + 1] = 1;\n\tfor (int i = 0; i < Y; i++) c[i + 101][201] = 1;\n\tint frm[202];\n\tqueue<int> q;\n\tint r = 0;\n\twhile (true) {\n\t\tfor (auto& e : frm)e = -1;\n\t\tfrm[0] = 0;\n\t\tq.push(0);\n\t\twhile (!q.empty()) {\n\t\t\tint f = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = 0; i < 202; i++) {\n\t\t\t\tif (c[f][i] > 0 && frm[i] == -1){\n\t\t\t\t\tfrm[i] = f;\n\t\t\t\t\tq.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (frm[201] == -1)break;\n\t\tint z = INT32_MAX / 2,s = 201,t;\n\t\twhile (s != 0) {\n\t\t\tt = frm[s];\n\t\t\tz = min(z, c[t][s]);\n\t\t\ts = t;\n\t\t}\n\t\tr += z;\n\t\ts = 201;\n\t\twhile (s != 0) {\n\t\t\tt = frm[s];\n\t\t\tc[t][s] -= z;\n\t\t\tc[s][t] += z;\n\t\t\ts = t;\n\t\t}\n\t}\n\tcout << r << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#include<vector>\n#include<utility>\n#include<vector>\n#include<queue>\n\nnamespace ProconLib{\n    \n    template<typename cap_t,cap_t INF,typename edge_t>\n    class FlowImpl{\n        protected:\n        using Edges=std::vector<edge_t>;\n        using Graph=std::vector<Edges>;\n        int N;\n        Graph g;\n        std::vector<int> level;\n        std::vector<int> iter;\n        void bfs(int s);\n        cap_t dfs(int v,int t,cap_t f);\n        FlowImpl(int N):N(N),g(N){};\n    };\n\n    template<typename cap_t,cap_t INF,typename edge_t>\n    void FlowImpl<cap_t,INF,edge_t>::bfs(int s){\n        level.assign(N,-1);\n        std::queue<int> que;\n        level[s]=0;\n        que.push(s);\n        while(!que.empty()){\n            int v=que.front(); que.pop();\n            for(int i=0;i<g[v].size();i++){\n                edge_t &e=g[v][i];\n                if(e.cap>0 && level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    template<typename cap_t,cap_t INF,typename edge_t>\n    cap_t FlowImpl<cap_t,INF,edge_t>::dfs(int v,int t,cap_t f){\n        if(v==t) return f;\n        for(int& i=iter[v];i<g[v].size();i++){\n            edge_t& e=g[v][i];\n            if(e.cap>0 && level[v]<level[e.to]){\n                cap_t d=dfs(e.to,t,std::min(f,e.cap));\n                if(d>0){\n                    e.cap-=d;\n                    g[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n}\nnamespace ProconLib{\n    template<typename T>\n    struct EdgeForMaximumFlow{\n        int to;\n        T cap;\n        int rev;\n        EdgeForMaximumFlow(int to,T cap,int rev):to(to),cap(cap),rev(rev){}\n    };\n\n    template<typename cap_t=long long,cap_t INF=cap_t(1e9+9)>\n    class MaximumFlow:protected FlowImpl<cap_t,INF,EdgeForMaximumFlow<cap_t>>{\n        protected:\n        using Edge=EdgeForMaximumFlow<cap_t>;\n        using Super=FlowImpl<cap_t,INF,Edge>;\n        using Super::N;\n        using Super::g;\n        using Super::level;\n        using Super::iter;\n        using Super::bfs;\n        using Super::dfs;\n        public:\n        MaximumFlow(int N):Super(N){}\n        void addEdge(int from,int to,cap_t cap);\n        cap_t maximumFlow(int s,int t);\n    };\n\n    template<typename cap_t,cap_t INF>\n    cap_t MaximumFlow<cap_t,INF>::maximumFlow(int s,int t){\n        cap_t flow=0;\n        while(true){\n            bfs(s);\n            if(level[t]<0) return flow;\n            iter.assign(N,0);\n            cap_t f;\n            while((f=dfs(s,t,INF))>0){\n                flow+=f;\n            }\n        }\n    }\n    template<typename cap_t,cap_t INF>\n    void MaximumFlow<cap_t,INF>::addEdge(int from,int to,cap_t cap){\n        g[from].push_back(Edge(to,cap,int(g[to].size())));\n        g[to].push_back(Edge(from,cap_t(0),int(g[from].size())));\n    }\n}\nnamespace ProconLib{\n\n    class BipartiteMatching:private MaximumFlow<int>{\n        using Super=MaximumFlow<int>;\n        using Super::g;\n        int N,M;\n        int S,T;\n        int matchNum=0;\n        int X(int id){return id;}\n        int Y(int id){return N+id;}\n        int inverseY(int id){return id-N;}\n        public:\n        BipartiteMatching(int N,int M);\n        void addEdge(int x,int y){Super::addEdge(X(x),Y(y),1);}\n        int match(){return matchNum+=maximumFlow(S,T);}\n        std::vector<std::pair<int,int>> getMatches();\n    };\n\n    BipartiteMatching::BipartiteMatching(int N,int M):N(N),M(M),S(N+M),T(N+M+1),Super(N+M+2){\n        for(int i=0;i<N;i++) Super::addEdge(S,X(i),1);\n        for(int i=0;i<M;i++) Super::addEdge(Y(i),T,1);\n    }\n    std::vector<std::pair<int,int>> BipartiteMatching::getMatches(){\n        std::vector<std::pair<int,int>> res;\n        for(int i=0;i<N;i++){\n            for(auto& e:g[X(i)]){\n                if(e.to!=S && e.cap==0){\n                    res.push_back(std::pair<int,int>{i,inverseY(e.to)});\n                }\n            }\n        }\n        return res;\n    }\n}using namespace ProconLib;\nint main(){\n    int X,Y,E;\n    cin>>X>>Y>>E;\n    BipartiteMatching bm(X,Y);\n    for(int i=0;i<E;i++){\n        int x,y;\n        cin>>x>>y;\n        bm.addEdge(x,y);\n    }\n\n    cout<<bm.match()<<endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl;\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define repi(start,end) for(int i=start; i<end; i++)\n#define repj(start,end) for(int j=start; j<end; j++)\n#define repk(start,end) for(int k=start; k<end; k++)\n#define repl(start,end) for(int l=start; l<end; l++)\n#define RE return 0;\n\nstruct edge{int to,cap,rev;};\n\nint n,k;\nbool can[201][201];\nint used[100];\n\nvector<edge> G[201];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  used[v]=true;\n  repi(0, G[v].size()){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    int f=dfs(s, t, INF);\n    if(f==0) return flow;\n    flow+=f;\n  }\n}\n\nvoid solve(){\n  int s=n+k,t=s+1;\n  \n  repi(0, n){\n    add_edge(s,i,1);\n  }\n  repi(0, k){\n    add_edge(n+i, t, 1);\n  }\n  \n  repi(0, n){\n    repj(0, k){\n      if(can[i][j]){\n        add_edge(i, n+j, 1);\n      }\n    }\n  }\n  \n  cout<<max_flow(s, t)<<en\n}\n\n\n\n\nint main(){\n  /*\n  cin>>n>>k;\n  repi(0, n){\n    int num;\n    cout<<\"        \"<<i<<\":\"<<en\n    cout<<\"how many?     \";\n    cin>>num;\n    cout<<\"encode ->   \";\n    int a;\n    repj(0, num) {cin>>a; can[i][a]=true;}\n  }\n  cout<<en*/\n  \n  int e,a,b;\n  cin>>n>>k>>e;\n  repi(0, e){\n    cin>>a>>b;\n    can[a][b]=true;\n  }\n  \n  solve();\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nconst int MAX=200;\nconst int MAX_cap=10000;\n\nclass edge\n{\npublic:\n\tint to,cap,rev;\n\tedge(){}\n\tedge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back(edge(to,cap,G[to].size()));\n\tG[to].push_back(edge(from,0,G[from].size()-1));\n\treturn;\n}\n\nint dfs(int v,int t,int f)\n{\n\tif(v==t)return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to]&&e.cap>0)\n\t\t{\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0)\n\t\t\t{\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxflow(int s,int t)\n{\n\tint flow=0;\n\twhile(1)\n\t{\n\t\tfor(int i=0;i<MAX;i++)used[i]=false;\n\t\tint f=dfs(s,t,MAX_cap);\n\t\tif(f==0)return flow;\n\t\tflow+=f;\n\t}\n}\n\nint main()\n{\n\tint X,Y,E;cin>>X>>Y>>E;\n\tint u,v;\n\tint s=X+Y,t=s+1;\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tcin>>u>>v;\n\t\tadd_edge(u,X+v,1);\n\t}\n\tfor(int i=0;i<X;i++)add_edge(s,i,1);\n\tfor(int i=0;i<Y;i++)add_edge(X+i,t,1);\n\t\n\tcout<<maxflow(s,t)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\ntypedef pair<LL, LL> P;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQ(c)     (c).erase(unique(ALL((c))),(c).end())\n# define mp          make_pair\n# define eb          emplace_back\n# define FOR(i,a,b)  for(int i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(int i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nconstexpr int MAX_V = 100000;\n\nint n;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\n//uとvを結ぶ辺をグラフに追加する\nvoid add_edge(int u, int v) {\n\tG[u].emplace_back(v);\n\tG[v].emplace_back(u);\n}\n\n//増加パスをDFSで探す\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || (!used[w] && dfs(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//二部グラフの最大マッチングを求める\nint bipartite_matching() {\n\tint res = 0;\n\tfor (int i = 0; i < MAX_V; i++)match[i] = -1;\n\tfor (int v = 0; v < n; v++) {\n\t\tif (match[v] < 0) {\n\t\t\tfor (int i = 0; i < MAX_V; i++)used[i] = false;\n\t\t\tif (dfs(v)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint x, y, e;\n\nint main() {\n\tcin >> x >> y >> e;\n\tn = max(x, y);\n\tREP(i, e) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tadd_edge(a, b);\n\t}\n\tcout << bipartite_matching() << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nstruct bipartite_matching{\n    int n, x, y;\n    VVI e;\n    VI match;\n    vector<bool> used;\n\n    void init(int a, int b){\n        x = a;\n        y = b;\n        n = x + y;\n        e.resize(n);\n        match.resize(n);\n        used.resize(n);\n    }\n\n    void add_edge(int u, int v){\n        e[u].push_back(v + x);\n        e[v + x].push_back(u);\n    }\n\n    bool dfs(int v){\n        used[v] = true;\n        for (int u : e[v]){\n            int w = match[u];\n            if (w < 0 || (!used[w] && dfs(w))){\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int calc_matching(){\n        int res = 0;\n        fill(ALL(match), -1);\n        REP(v,n){\n            if (match[v] < 0){\n                used.assign(n, 0);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    int n, m, e;\n    cin >> n >> m >> e;\n\n    bipartite_matching bm;\n    bm.init(n, m);\n\n    while (e--){\n        int u, v;\n        cin >> u >> v;\n        bm.add_edge(u, v);\n    }\n\n    cout << bm.calc_matching() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n// 最大二部マッチング\n// O(V(V+E))\nclass BipartiteMatching\n{\n    int size;\n    vector<vector<int>> g;\n    vector<int> match;\n    vector<bool> used;\n    bool dfs(int v)\n    {\n        used[v] = true;\n        for (const auto &u : g[v])\n        {\n            int w = match[u];\n            if (w < 0 || (!used[w] && dfs(w)))\n            {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n  public:\n    BipartiteMatching(int v) : size(v), g(v), match(v), used(v) {}\n    void add_edge(int u, int v)\n    {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    int maximum_matching(void)\n    {\n        int res = 0;\n        fill(begin(match), end(match), -1);\n        for (int v = 0; v < size; ++v)\n        {\n            if (match[v] >= 0)\n                continue;\n            fill(begin(used), end(used), 0);\n            if (dfs(v))\n                ++res;\n        }\n        return res;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int x, y, e;\n    cin >> x >> y >> e;\n    BipartiteMatching bm(x + y);\n    while (e--)\n    {\n        int a, b;\n        cin >> a >> b;\n        bm.add_edge(a, x + b);\n    }\n    cout << bm.maximum_matching() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string.h>\n#include <queue>\nusing namespace std;\n\nstruct edge{int to, cap, rev;};\nint level[300];\nint iter[300];\nint INF = 100000000;\n\nvoid bfs(vector< vector<edge> > &G, int s){\n  memset(level, -1, sizeof(level));\n  queue<int> que;\n  level[s] = 0;\n  que.push(s);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    for(int i = 0; i < G[v].size(); ++i){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\n\nint dfs(vector< vector<edge> > &G, int v, int t, int f){\n  if(v == t) return f;\n  for(int &i = iter[v]; i < G[v].size(); ++i){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(G,e.to,t,min(f,e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\n\nint max_flow(vector< vector<edge> > G, int s, int t){\n  int flow = 0;\n  for(;;){\n    bfs(G,s);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(G,s,t,INF)) > 0){\n      flow += f;\n    }\n  }\n}\n\nint main(){\n  int X, Y, E;\n  cin >> X >> Y >> E;\n  int x, y, V = X + Y + 2;\n  vector< vector<edge> > G(V);\n  for(int i = 0; i < E; ++i){\n    cin >> x >> y;\n    y += X;\n    G[x].push_back((edge){y,1,G[y].size()});\n    G[y].push_back((edge){x,0,G[x].size()-1});\n  }\n  int s = X + Y, t = X + Y + 1;\n  for(int i = 0; i < X; ++i){\n    G[s].push_back((edge){i,1,G[i].size()});\n    G[i].push_back((edge){s,0,G[s].size()-1});\n  }\n  for(int i = 0; i < Y; ++i){\n    G[X+i].push_back((edge){t,1,G[t].size()});\n    G[t].push_back((edge){X+i,0,G[X+i].size()-1});\n  }\n  cout << max_flow(G,s,t) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <set>\n#include <bitset>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int>>vpi;\ntypedef pair<int,int> pi;\n#define R return\n#define W while\n#define FOR(i,a) for(int i=0;i<a;i++)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define I insert\n#define P push\nint main(){\n    int x,y,k,l,r,ans=0,temp,n;\n    pair<priority_queue<pi,vpi,greater<pi>>,priority_queue<pi,vpi,greater<pi>>>pq;\n    pair<vi,vi>v[510];\n    pi d[510];\n    set<pi>s;\n    pair<bitset<510>,bitset<510>>b;\n    b.F.reset();\n    b.S.reset();\n    scanf(\"%d%d%d\",&x,&y,&k);\n    n=max(x,y)+1;\n    W(k--){\n        scanf(\"%d%d\",&l,&r);\n        if(s.count(MP(l,r)))continue;\n        s.I(MP(l,r));\n        v[l].F.PB(r);\n        v[r].S.PB(l);\n    }\n    FOR(i,n){\n        d[i].F=(int)v[i].F.size();\n        d[i].S=(int)v[i].S.size();\n        pq.F.P(MP(d[i].F,i));\n        pq.S.P(MP(d[i].S,i));\n    }\n    W(!(pq.F.empty()||pq.S.empty())){\n        if(pq.F.top().F<=pq.S.top().F){\n            temp=pq.F.top().S;\n            pq.F.pop();\n            if(b.F[temp])continue;\n            b.F[temp]=true;\n            FOR(i,v[temp].F.size())if(!b.S[v[temp].F[i]]){\n                b.S[v[temp].F[i]]=true;\n                ans++;\n                FOR(j,v[v[temp].F[i]].S.size())if(!b.F[v[v[temp].F[i]].S[j]]){\n                    d[v[v[temp].F[i]].S[j]].F--;\n                    pq.F.P(MP(d[v[v[temp].F[i]].S[j]].F,v[v[temp].F[i]].S[j]));\n                }\n            }\n        }\n        else{\n            temp=pq.S.top().S;\n            pq.S.pop();\n            if(b.S[temp])continue;\n            b.S[temp]=true;\n            FOR(i,v[temp].S.size())if(!b.F[v[temp].S[i]]){\n                b.F[v[temp].S[i]]=true;\n                ans++;\n                FOR(j,v[v[temp].S[i]].F.size())if(!b.S[v[v[temp].S[i]].F[j]]){\n                    d[v[v[temp].S[i]].F[j]].S--;\n                    pq.S.P(MP(d[v[v[temp].S[i]].F[j]].S,v[v[temp].S[i]].F[j]));\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mx = 305;\nconst int inf = 0x3f3f3f3f;\nconst int S = mx - 2, T = mx - 1;\n\nstruct edge {\n  int from, to, cap;\n  edge *rev;\n  edge(int from, int to, int cap) : from(from), to(to), cap(cap) {}\n  void flow(int f) { cap -= f, rev->cap += f; }\n};\n\nvector<edge *> adj[mx];\n\nvoid addEdge(int u, int v, int c) {\n  edge *e = new edge(u, v, c);\n  e->rev = new edge(v, u, 0);\n  e->rev->rev = e;\n  adj[u].push_back(e);\n  adj[v].push_back(e->rev);\n}\n\nbool vis[mx], inq[mx];\nint bt[mx], mf[mx];\nedge *bte[mx];\nbool augment(int &flow) {\n  fill(vis, vis + mx, false);\n  fill(inq, inq + mx, false);\n  fill(mf, mf + mx, 0);\n  queue<int> q;\n  q.push(S);\n  mf[S] = inf;  \n  while (!q.empty()) {\n    int p = q.front();\n    q.pop();\n    inq[p] = false;\n    if (vis[p])\n      continue;\n    // printf(\"Visit: %d\\n\", p);\n    vis[p] = true;\n    if (p == T)\n      break;\n    for (edge *e : adj[p]) {\n      // printf(\"Edge: %d -> %d, cap %d\\n\", e->from, e->to, e->cap);\n      if (!vis[e->to] && min(e->cap, mf[p]) > mf[e->to]) {\n        bt[e->to] = p;\n        bte[e->to] = e;\n        mf[e->to] = min(e->cap, mf[p]);\n        if (!inq[e->to])\n          q.push(e->to), inq[e->to] = true;\n      }\n    }\n  }\n  // printf(\"Done, vis: %d\\n\", vis[T]);\n  if (!vis[T])\n    return false;\n  int p = T, f = mf[T];\n  while (p != S) {\n    bte[p]->flow(f);\n    p = bt[p];\n  }\n  flow = f;\n  return true;\n}\n\nint maxflow() {\n  int flow, mflow = 0;\n  while (augment(flow))\n    mflow += flow;\n  return mflow;\n}\n\nint main() {\n  int x, y, e;\n  cin >> x >> y >> e;\n\n  for (int i = 0; i < x; i++)\n    addEdge(S, i, 1);\n  for (int i = 100; i < 100 + y; i++)\n    addEdge(i, T, 1);\n\n  for (int i = 0; i < e; i++) {\n    int a, b;\n    cin >> a >> b;\n    addEdge(a, 100 + b, inf);\n  }\n\n  cout << maxflow() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,s,n) for (int i = (int)s; i < (int)n; i++)\n#define ll long long\n#define ld long double\n#define pb push_back\n#define eb emplace_back\n#define All(x) x.begin(), x.end()\n#define Range(x, i, j) x.begin() + i, x.begin() + j\n#define lbidx(x, y) lower_bound(x.begin(), x.end(), y) - x.begin()\n#define ubidx(x, y) upper_bound(x.begin(), x.end(), y) - x.begin()\n#define llbidx(x, y, z) lower_bound(x.begin(), x.end(), z) - lower_bound(x.begin(), x.end(), y) // 二要素間の距離\n#define deg2rad(deg) ((((double)deg)/((double)360)*2*M_PI))\n#define rad2deg(rad) ((((double)rad)/(double)2/M_PI)*(double)360)\n#define Find(set, element) set.find(element) != set.end()\n#define Decimal(x) printf(\"%.10f\\n\", x) // 小数点を10桁まで表示\n// debug用\n#define PrintVec(x) for (auto elementPrintVec: x) { cout << elementPrintVec << \" \"; } cout << \"\\n\";\n#define debug(x) cerr << #x << \": \" << (x) << \"\\n\";\n#define endl \"\\n\"\n// gcj print用\n#define Case(x) printf(\"Case #%d: \", x);\n\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<vector<vector<int>>> vvvi;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> vvl;\ntypedef vector<vector<vector<int>>> vvvl;\ntypedef vector<PI> vpi;\ntypedef vector<vector<PI>> vvpi;\ntypedef vector<vector<vector<PI>>> vvvpi;\ntypedef vector<PLL> vpl;\ntypedef vector<vector<PLL>> vvpl;\ntypedef vector<vector<vector<PLL>>> vvvpl;\n\nint POWINT(int x, int n) {\n  int ret = 1;\n  while (n > 0) {\n    if (n & 1) ret *= x;\n    x *= x;\n    n >>= 1;\n  }\n  return ret;\n};\n\nll POWLL(ll x, int n) {\n  ll ret = 1;\n  while (n > 0) {\n    if (n & 1) ret *= x;\n    x *= x;\n    n >>= 1;\n  }\n  return ret;\n};\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n  if(a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n  if(a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\nconst int INF = 1e9+7;\n\nclass Dinic {\n  struct Edge {\n    int to, cap, rev;\n  };\n\n  public:\n    int V;\n    vector<vector<Edge>> G;\n    vector<int> level; // sからの距離\n    vector<bool> used;\n  Dinic(int V): V(V), G(V), used(V) {}\n\n  void addEdge(int from, int to, int cap) {\n    G[from].pb((Edge){ to, cap, (int) G[to].size() });\n    G[to].pb((Edge) { from, 0, (int) G[from].size()-1 });\n  }\n  // sからの到達するのにかかる最短のステップ数をbfsで調べる\n  void bfs(int s) {\n    level.assign(V, -1); // level 初期化\n    queue<int> q;\n    level[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int v = q.front();\n      q.pop();\n      for (auto &e: G[v]) {\n        // level[e.to] == -1つまり未\"発見\"\n        // 距離が増加する向きの辺のみからなるグラフを作成\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v] + 1;\n          q.push(e.to);\n        }\n      }\n    }\n  }\n\n  int dfs(int v, int t, int f) {\n    if (v == t) return f;\n\n    used[v] = true;\n    rep (i, 0, G[v].size()) {\n      Edge &e = G[v][i];\n      // 容量ありでかつ辺の先はより遠い\n      if (e.cap > 0 && level[v] < level[e.to] && !used[e.to]) {\n        int d = dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n\n    return 0;\n  }\n\n  int max_flow(int s, int t) {\n    int ret = 0, f;\n    while (bfs(s), level[t] >= 0)  {\n      used.assign(V, false);\n      while ((f = dfs(s, t, INF)) > 0) {\n        ret += f;\n      }\n    }\n    return ret;\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int X, Y, E; cin >> X >> Y >> E;\n\n  Dinic dinic(X+Y+2);\n  int x, y;\n  int s = X+Y, t = X+Y+1;\n  rep(i, 0, E) {\n    cin >> x >> y;\n    dinic.addEdge(x, y+X, 1);\n  }\n\n  rep(x, 0, X) {\n    dinic.addEdge(s, x, 1);\n  }\n\n  rep(y, 0, Y) {\n    dinic.addEdge(y+X, t, 1);\n  }\n\n  cout << dinic.max_flow(s, t) << endl;\n\n  return 0;\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, N) for (int i = 0; i < (int)N; i++)\n\nconst int INF = 1e9;\nconst int MAX_V = 200;\n\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid addEdge(int from, int to, int cap){\n  G[from].push_back((edge) {to, cap, static_cast<int>(G[to].size())});\n  G[to].push_back((edge) {from, 0, static_cast<int>(G[from].size()) - 1});\n}\n\nint dfs(int v, int t, int f) {\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0) {\n      int d = dfs(e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint maxFlow(int s, int t) {\n  int flow = 0;\n  while(true) {\n    memset(used, 0, sizeof(used));\n    int f = dfs(s, t, INF);\n    if( f == 0 ) return flow;\n    flow += f;\n  }\n}\n\nint main () {\n  int X, Y, E;\n  cin >> X >> Y >> E;\n\n  // s, X, Y, t\n  int s = 0;\n  int t = 1 + X + Y;\n\n  rep(i,X) addEdge(s, i + 1, 1);\n  rep(i,Y) addEdge(1 + X + i, t, 1);\n  rep(i,E) {\n    int x, y;\n    cin >> x >> y;\n    addEdge(x + 1, 1 + X + y, INF);\n  }\n\n  cout << maxFlow(s, t)  << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint exist(int y,const vector<int> &p) //y?????????????????¨??????????????§???????????? ????????°????????????x????????????????????????\n{\n    for(int i = 0; i < p.size(); i++)\n    {\n        if(p[i] == y)\n            return i;\n    }\n    return -1;\n}\n\nbool match(int x, int start, const vector<vector<bool> > &v,vector<int> &p) //??????????????°\n{\n    for(int i = start; i < v[0].size(); i++) //start??????y?????????????????§??°?????????\n    {\n        if(v[x][i]) //??????x,i?????¨?????????????????°\n        {\n            int rem = exist(i, p); //i????????§?????¨??????????????????\n            p[x] = i; //x,i?????¨????????§?????????\n            if(rem < 0) //i????????¨????????¨????????????????????°??¢??°?????????\n            {\n                return true;\n                \n            }\n            else //i????????¨????????¨?????????????????°\n            {\n                p[rem] = -1; //????????¨??????????¶????\n                bool ok = match(rem,i+1,v,p); //??£????????¨??????????????????????????????\n                if(!ok) //???????????????????????£??????????????????\n                {\n                    p[x] = -1;\n                    p[rem]= i;\n                }\n                else //???????????£????????¢??°????????????\n                    return true;\n            }\n        }\n    }\n    for(int i = 0; i < start; i++)\n    {\n        if(v[x][i]) //??????x,i?????¨?????????????????°\n        {\n            int rem = exist(i, p); //i????????§?????¨??????????????????\n            p[x] = i; //x,i?????¨????????§?????????\n            if(rem < 0) //i????????¨????????¨????????????????????°??¢??°?????????\n            {\n                return true;\n                \n            }\n            else //i????????¨????????¨?????????????????°\n            {\n                p[rem] = -1; //????????¨??????????¶????\n                bool ok = match(rem,i+1,v,p); //??£????????¨??????????????????????????????\n                if(!ok) //???????????????????????£??????????????????\n                {\n                    p[x] = -1;\n                    p[rem]= i;\n                }\n                else //???????????£????????¢??°????????????\n                    return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int xn,yn,e,x,y;\n    cin >> xn >> yn >> e;\n    vector< vector<bool> > v(xn, vector<bool>(yn,false));\n    vector<int> p(xn,-1);\n    for(int i = 0; i < e; i++)\n    {\n        cin >> x >> y;\n        v[x][y] = true;\n    }//???????????§?????????\n    \n    for(int i = 0; i<xn;i++)\n    {\n        match(i,0,v,p);\n    }\n    //???????????§?¨?????????????????????¨???\n    int c = 0;\n    for(int i = 0; i<p.size();i++)\n    {\n        if(p[i]>=0)\n            c++;\n    }\n    cout << c << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\ntemplate <typename T>\nstruct Edge {\n    int to; T cap, cost; int rev;\n    Edge(int t, T c, int r) : to(t), cap(c), rev(r) {}\n    Edge(int t, T ca, T co, int r) : to(t), cap(ca), cost(co), rev(r) {}\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\nstruct BipartiteMatching {\n    int S, T, E, a, b;\n    Graph<int> G;\n    vector<int> used;\n    BipartiteMatching(int x, int y, int z) : S(x), T(y), E(z) {\n        G.resize(S+T+2);\n        used.resize(S+T+2);\n        a = S + T, b = a + 1;\n    }\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back(Edge<int>(to, cap, G[to].size()));\n        G[to].push_back(Edge<int>(from, 0, G[from].size() - 1));\n    }\n    void readGraph() {\n        for(int i=0; i<E; i++) {\n            int x, y; cin >> x >> y;\n            // x--; y--;\n            add_edge(x, y+S, 1);\n        }\n        for(int i=0; i<S; i++) add_edge(a  , i, 1);\n        for(int i=0; i<T; i++) add_edge(i+S, b, 1);\n    }\n    int dfs(int v, int t, int f) {\n        if(v == t) return f;\n        used[v] = true;\n        for(size_t i=0; i<G[v].size(); i++) {\n            Edge<int> &e = G[v][i];\n            if(!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int solve() {\n        int flow = 0;\n        while(1) {\n            fill(used.begin(), used.end(), 0);\n            int f = dfs(a, b, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nsigned main() {\n    int x, y, e; cin >> x >> y >> e;\n    BipartiteMatching B(x, y, e);\n    B.readGraph();\n    cout << B.solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) for(auto&& x : v){cout << x << \" \";} cout << endl\n#define printVV(vv) for(auto&& v : vv){for(auto&& x : v){cout << x << \" \";}cout << endl;}\n#define printP(p) cout << p.first << \" \" << p.second << endl\n#define printVP(vp) for(auto&& p : vp) printP(p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<Pii> vp;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\ntemplate<typename T> using Graph = vector<vector<T>>;\n\nstruct edge { int to, cap, rev; };\n\nconst int MAX_V = 210;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].emplace_back((edge){to, cap, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nvoid bfs(int s) {\n    memset(level, -1, sizeof(level));\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n        int v = que.front(); que.pop();\n        for (int i = 0; i < G[v].size(); i++) {\n            edge &e = G[v][i];\n            if (e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    for (int &i = iter[v]; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[v] < level[e.to]) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        memset(iter, 0, sizeof(iter));\n        int f;\n        while ((f = dfs(s, t, inf)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n\n    rep(i, E) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, X + y, 1);\n    }\n\n    const int s = X + Y, t = s + 1;\n    rep(x, X) {\n        add_edge(s, x, 1);\n    }\n    rep(y, Y) {\n        add_edge(X + y, t, 1);\n    }\n\n    cout << max_flow(s, t) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//  Created by Vignesh Manoharan\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<vi> vvi;\n\nconst int INF = 1000000000;\nconst ll LINF = 1e17;\nconst double PI =3.141592653589793238;\n#pragma unused(INF,PI,LINF)\n#define F(i,a,n) for(int i=(a);i<(n);i++)\n\ntemplate<typename T,typename TT> ostream& operator<<(ostream &s,pair<T,TT> t) {return s<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<typename T> ostream& operator<<(ostream &s,vector<T> t){\n    for(int i=0;i<(t).size();i++)s<<t[i]<<((i<(t).size()-1)?\" \":\"\");return s; }\ntemplate<typename T> ostream& operator<<(ostream &s,set<T> t){for(T x:t) s<<x<<\" \";return s; }\ntemplate<typename T> istream& operator>>(istream &s,vector<T> &t){\n    for(int _i=0;_i<t.size();_i++) s>>t[_i];return s; }\n\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n\nstruct flow_graph{\n    int MAX_V,E,s,t,head,tail;\n    int *cap,*to,*next,*last,*dist,*q,*now;\n    flow_graph(){}\n    flow_graph(int V, int MAX_E){\n        MAX_V = V; E = 0;\n        cap = new int[2*MAX_E], to = new int[2*MAX_E], next = new int[2*MAX_E];\n        last = new int[MAX_V], q = new int[MAX_V], dist = new int[MAX_V], now = new int[MAX_V];\n        fill(last,last+MAX_V,-1);\n    }\n    void clear(){\n        fill(last,last+MAX_V,-1);\n        E = 0;\n    }\n    void add_edge(int u, int v, int uv, int vu = 0){\n        to[E] = v, cap[E] = uv, next[E] = last[u]; last[u] = E++;\n        to[E] = u, cap[E] = vu, next[E] = last[v]; last[v] = E++;\n    }\n    bool bfs(){\n        fill(dist,dist+MAX_V,-1);\n        head = tail = 0;\n        \n        q[tail] = t; ++tail;\n        dist[t] = 0;\n        \n        while(head<tail){\n            int v = q[head]; ++head;\n            \n            for(int e = last[v];e!=-1;e = next[e]){\n                if(cap[e^1]>0 && dist[to[e]]==-1){\n                    q[tail] = to[e]; ++tail;\n                    dist[to[e]] = dist[v]+1;\n                }\n            }\n        }\n        \n        return dist[s]!=-1;\n    }\n    \n    int dfs(int v, int f){\n        if(v==t) return f;\n        \n        for(int &e = now[v];e!=-1;e = next[e]){\n            if(cap[e]>0 && dist[to[e]]==dist[v]-1){\n                int ret = dfs(to[e],min(f,cap[e]));\n                \n                if(ret>0){\n                    cap[e] -= ret;\n                    cap[e^1] += ret;\n                    return ret;\n                }\n            }\n        }\n        \n        return 0;\n    }\n    \n    long long max_flow(int source, int sink){\n        s = source; t = sink;\n        long long f = 0;\n        int x;\n        \n        while(bfs()){\n            for(int i = 0;i<MAX_V;++i) now[i] = last[i];\n            \n            while(true){\n                x = dfs(s,INF);\n                if(x==0) break;\n                f += x;\n            }\n        }\n        \n        return f;\n    }\n} G;\n\nint main(int argc, const char * argv[]) {\n#ifdef local_test\n    //    input\n    //    freopen(\"input\",\"w\",stdout);\n    //    cout<<\"1 \\n 100 10 \\n\";\n     freopen(\"input\",\"r\",stdin);\n     freopen(\"output\",\"w\",stdout);\n#endif\n    int x,y,e,u,v;\n    scanf(\"%d %d %d\",&x,&y,&e);\n    G=flow_graph(x+y+2,e+x+y);\n    for(int i = 0;i<e;i++){\n        scanf(\"%d %d\",&u,&v);\n        G.add_edge(u,x+v,1);\n    }\n    for(int i=0;i<x;i++){\n        G.add_edge(x+y,i,1);\n    }\n    for(int i=0;i<y;i++){\n        G.add_edge(x+i,x+y+1,1);\n    }\n    printf(\"%lld\\n\",G.max_flow(x+y,x+y+1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<ll, ll> pll;\n\n#define FOR(i, n, m) for(ll (i)=(m);(i)<(n);++(i))\n#define REP(i, n) FOR(i,n,0)\n#define OF64 std::setprecision(10)\n\nconst ll MOD = 1000000007;\nconst ll INF = (ll) 1e15;\n\nstruct Flow {\n    explicit Flow(int n) {\n        mVertices.resize(n);\n        mDir.assign(n, 0);\n        mIter.assign(n, 0);\n    }\n\n    void addEdge(int from, int to, long long int cap) {\n        mVertices[from].edge.emplace_back(Edge{to, cap, static_cast<int>(mVertices[to].edge.size())});\n        mVertices[to].edge.emplace_back(Edge{from, 0, static_cast<int>(mVertices[from].edge.size())});\n    }\n\n    long long int maxFlow(int s, int t) {\n        long long int retValue = 0;\n        while (true) {\n            bfs(s);\n            if (mDir[t] == MAX_VALUE)\n                break;\n            fill(mIter.begin(), mIter.end(), 0);\n            long long int flow = 0;\n            while ((flow = dfs(s, t, INF_VALUE)) > 0)\n                retValue += flow;\n        }\n        return retValue;\n    }\n\n    void bfs(int s) {\n        fill(mDir.begin(), mDir.end(), MAX_VALUE);\n        queue<int> q;\n        q.push(s);\n        mDir[s] = 0;\n        while (!q.empty()) {\n            int t = q.front();\n            q.pop();\n            int cost = mDir[t] + 1;\n            for (const auto &e:mVertices[t].edge) {\n                if (mDir[e.to] <= cost || e.capacity <= 0)\n                    continue;\n                mDir[e.to] = cost;\n                q.push(e.to);\n            }\n        }\n    }\n\n    long long int dfs(int s, int t, long long int f) {\n        if (s == t)\n            return f;\n        for (int &i = mIter[s]; i < mVertices[s].edge.size(); ++i) {\n            Edge &e = mVertices[s].edge[i];\n            if (e.capacity <= 0 || mDir[s] >= mDir[e.to])\n                continue;\n            long long int d = dfs(e.to, t, std::min(f, e.capacity));\n            if (d > 0) {\n                e.capacity -= d;\n                mVertices[e.to].edge[e.rev].capacity += d;\n                return d;\n            }\n        }\n        return 0;\n    }\n\n    struct Edge {\n        int to;\n        long long int capacity;\n        int rev;\n    };\n    struct Vertex {\n        vector<Edge> edge;\n    };\n    vector<Vertex> mVertices;\n    vector<int> mDir;\n    vector<int> mIter;\n\n    const int MAX_VALUE = 1e9;\n    long long int INF_VALUE = (long long int) 1e15;\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll X, Y, E;\n    cin >> X >> Y >> E;\n    Flow flow(X + Y + 2);\n    REP(i, E) {\n        ll a, b;\n        cin >> a >> b;\n        flow.addEdge(a + 1, b + X + 1, 1);\n    }\n    REP(i, X) {\n        flow.addEdge(0, i + 1, 1);\n    }\n    REP(i, Y) {\n        flow.addEdge(i + X + 1, X + Y + 1, 1);\n    }\n\n    cout << flow.maxFlow(0, X + Y + 1) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <string>\n#include <queue>\n#include <tuple>\n#include <cmath>\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define all(x) (x).begin(),(x).end()\n#define PRINT(V) cout << V << \"\\n\"\n#define SORT(V) sort((V).begin(),(V).end())\n#define RSORT(V) sort((V).rbegin(), (V).rend())\nusing namespace std;\nusing ll = long long;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nclass bipertite_matching{\n    private:\n        int siz;\n        vector<vector<int>> g;\n        vector<bool> done;\n        vector<int> match;\n    public:\n        bipertite_matching(int n){\n            siz = n;\n            g.resize(n);\n            done.resize(n);\n            match.resize(n,-1);\n        }\n        void add_edge(int u,int v){\n            g[u].push_back(v);\n            g[v].push_back(u);\n        }\n        bool dfs(int v){\n            done[v] = true;\n            for(int u:g[v]){\n                int w = match[u];\n                if (w < 0 || (!done[w] && dfs(w))){\n                    match[v] = u;\n                    match[u] = v;\n                    return true;\n                }\n            }\n            return false;\n        }\n        int bipartiteMatching(){\n            int res = 0;\n            rep(i,siz){\n                if (match[i] < 0){\n                    done.assign(siz,false);\n                    if (dfs(i)) res++;\n                }\n            }\n            return res;\n        }\n};\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int X,Y,E,x,y;\n    cin >> X >> Y >> E;\n    bipertite_matching g(X+Y);\n    rep(i,E){\n        cin >> x >> y;\n        g.add_edge(x,X+y);\n    }\n    PRINT(g.bipartiteMatching());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nconstexpr int inf = 0x3f3f3f3f;\nconstexpr ll linf = 0x3f3f3f3f3f3f3f3fLL;\n\nclass FordFulkerson\n{\npublic:\n    FordFulkerson(int n) : _n(n), _graph(n), _used(n, false) {}\n\n    void add_edge(int from, int to, ll cap)\n    {\n        _graph[from].emplace_back(to, cap, (int)_graph[to].size());\n        _graph[to].emplace_back(from, 0, (int)_graph[from].size() - 1);\n    }\n\n    ll operator()(int s, int t)\n    {\n        ll flow = 0;\n        while (true) {\n            fill(_used.begin(), _used.end(), false);\n            ll f = dfs(s, t, linf);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\nprivate:\n    struct edge\n    {\n        int to; ll cap; int rev;\n        edge(int to, ll cap, int rev) : to(to), cap(cap), rev(rev) {}\n    };\n\n    int _n;\n    vector<vector<edge>> _graph;\n    vector<bool> _used;\n\n    ll dfs(int v, int t, ll f)\n    {\n        if (v == t) return f;\n        _used[v] = true;\n        for (auto &e: _graph[v]) {\n            if (!_used[e.to] && e.cap > 0) {\n                ll d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    _graph[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n};\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int X, Y, E; cin >> X >> Y >> E;\n\n    FordFulkerson flow(X + Y + 2);\n    int s = X + Y, t = X + Y + 1;\n    \n    for (int i = 0; i < X; i++) flow.add_edge(s, i, 1);\n    for (int i = 0; i < Y; i++) flow.add_edge(X + i, t, 1);\n\n    for (int i = 0; i < E; i++) {\n        int x, y; cin >> x >> y;\n        flow.add_edge(x, X + y, 1);\n    }\n\n    cout << flow(s, t) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n//typedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\ntypedef vector<vector<int>> mat;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nvector<vector<int>> G;\nint match[210];\nbool used[210];\n\nbool dfs(int v)\n{\n\tused[v] = true;\n\trep(i, 0, SZ(G[v]))\n\t{\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(int X)\n{\n\tint res = 0;\n\trep(i, 0, 210)match[i] = -1;\n\trep(v, 0, X)\n\t{\n\t\tif (match[v] < 0)\n\t\t{\n\t\t\trep(i, 0, 210)used[i] = false;\n\t\t\tif (dfs(v))\n\t\t\t{\n\t\t\t//\tcout << v << endl;\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint X, Y, E, x, y;\n\tcin >> X >> Y >> E;\n\tG.resize(X + Y);\n\twhile (E--)\n\t{\n\t\tcin >> x >> y;\n\t\tG[x].push_back(X + y);\n\t\tG[X + y].push_back(x);\n\t}\n\n\tcout << bipartite_matching(X) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_7_A&lang=jp\n\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass BM{\npublic:\n\tvector<vector<int> >G;\n\tvector<int>match;\n\tvector<int>used;\n\tBM(int n){\n\t\tG.resize(n);\n\t}\n\tvoid addEdge(int from, int to){\n\t\tG[from].push_back(to);\n\t\tG[to].push_back(from);\n\t}\n\tbool dfs(int v){\n\t\tused[v] = 1;\n\t\tfor (int i = 0; i < G[v].size(); i++){\n\t\t\tint u = G[v][i];\n\t\t\tint w = match[u];\n\t\t\tif (w < 0 || !used[w] && dfs(w)){\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint flow(){\n\t\tint res = 0;\n\t\tmatch.clear();\n\t\tmatch.resize(G.size(), -1);\n\t\tfor (int v = 0; v < G.size(); v++){\n\t\t\tif (match[v] < 0){\n\t\t\t\tused.clear();\n\t\t\t\tused.resize(G.size(), 0);\n\t\t\t\tif (dfs(v)){\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main(){\n\n\tint X, Y, E;\n\tcin >> X >> Y >> E;\n\tBM bm(X + Y);\n\tfor (int i = 0; i < E; i++){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tbm.addEdge(x, y + X);\n\t}\n\tcout << bm.flow() << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nstruct bipartite_matching{\n    int n, x, y;\n    VVI e;\n    VI match;\n    vector<bool> used;\n\n    void init(int a, int b){\n        x = a;\n        y = b;\n        n = x + y;\n        e.resize(n);\n        match.resize(n);\n        used.resize(n);\n    }\n\n    void add_edge(int u, int v){\n        e[u].push_back(v + x);\n        e[v + x].push_back(u);\n    }\n\n    bool dfs(int v){\n        used[v] = true;\n        for (int u : e[v]){\n            int w = match[u];\n            if (w < 0 || (!used[w] && dfs(w))){\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int calc_matching(){\n        int res = 0;\n        fill(ALL(match), -1);\n        REP(v,n){\n            if (match[v] < 0){\n                used.assign(n, 0);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    int n, m, e;\n    cin >> n >> m >> e;\n\n    cout << 3 << endl;\n\n    bipartite_matching bm;\n    bm.init(n, m);\n\n    REP(_,e){\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        bm.add_edge(u, v);\n    }\n\n    cout << bm.calc_matching() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nconst int INF = 1e9;\nconst int MAX_V = 1000;\n\nstruct Flow{\n    struct edge{\n        int to, cap, rev;\n    };\n    vector<edge> G[MAX_V];//隣接リスト\n    bool used[MAX_V];\n\n    void add_edge(int from, int to, int cap){\n        G[from].push_back((edge){to, cap, (int)G[to].size()});//from -> to\n        G[to].push_back((edge){from, 0, (int)G[from].size() - 1});//to -> from\n    }\n\n    //増加パスを探す\n    int dfs(int v, int t, int f){\n        if(v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); ++i){\n            edge &e = G[v][i];\n            if(!used[e.to] && e.cap > 0){\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    //sからtへの最大流\n    int max_flow(int s, int t){\n        int flow = 0;\n        while(1){\n            memset(used, 0, sizeof(used));\n            int f = dfs(s, t, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nint main(){\nint X,Y,E; cin >> X >> Y >> E;\n  Flow mf;\n  for(int i = 0; i < E; i++){ int x,y;  cin >> x >> y; y += X;\n    mf.add_edge(x,y,1);// directed expression\n                            }\n  \n  for(int i = 0; i < X; i++){\n    mf.add_edge( X + Y, i, 1); }\n  \n  for(int j = 0; j < Y; j++){\n    mf.add_edge(X + j, X + Y + 1, 1);}\n  \n  cout << mf.max_flow( X + Y,  X  +  Y  + 1 ) <<  endl;\n  return 0;}\n  \n    \n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//?????????\n#pragma region MACRO \n#define putans(x)  std::cerr << \"[ answer ]: \" ; cout << (x) << endl\n#define dputans(x) std::cerr << \"[ answer ]: \"; cout << setprecision(27) << (double)(x) << endl\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define RREP(i,a,n) for(int i=(int)(n-1); i>= a; i--)\n#define rep(i,n) REP(i,0,n)\n#define rrep(i,n) RREP(i,0,n)\n#define all(a) begin((a)),end((a))\n#define mp make_pair\n#define exist(container, n) ((container).find((n)) != (container).end())\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#ifdef _DEBUG //???????????????????????????????????????????????????\nstd::ifstream ifs(\"data.txt\");\n#define put ifs >>\n#else //?????£????????????????????§?????????????????????\n#define put cin >>\n#endif\n#pragma endregion\n//???????????°??????????????´\n#pragma region CODING_SUPPORT\n#ifdef _DEBUG\n#define dbg(var0) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << endl; }\n#define dbg2(var0, var1) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg(var1); }\n#define dbg3(var0, var1, var2) { std::cerr << ( #var0 ) << \"=\" << ( var0 ) << \", \"; dbg2(var1, var2); }\n#define dbgArray(a,n) {std::cerr << (#a) << \"=\";  rep(i,n){std::cerr <<(a[i])<<\",\";} cerr<<endl;} \n#else\n#define dbg(var0) {}\n#define dbg2(var0, var1) {}\n#define dbg3(var0, var1, var2) {}\n#define dbgArray(a,n) {}\n#endif \n#pragma endregion \n//typedef????????????????????????????¶????????????§?????????\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii; typedef pair<string, string> pss; typedef pair<int, string>pis;\ntypedef vector<string> vs; typedef vector<int> vi;\n#pragma endregion\n//??????????????°(???????????????????????§??????)\n#pragma region CONST_VAL\n#define PI (2*acos(0.0))\n#define EPS (1e-10)\n#define MOD (ll)(1e9 + 7)\n#define INF (ll)(2*1e9)\n#pragma endregion\n\nstruct edge { int to, cap, rev; };\n\nstatic const int MAX_V = 1000;\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid addEdge(int from, int to, int cap) {\n\tG[from].push_back({ to,cap,(int)G[to].size() });\n\tG[to].push_back({ from,0,(int)G[from].size() - 1 });\n}\n\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxFlow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tfill(used, used + MAX_V, 0);\n\t\tint f = dfs(s, t, INF);\n\t\tif (f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\n\nint main() {\n\tint x, y, e; put x >> y >> e;\n\tint s = x+y;\n\tint t = s+1;\n\trep(i, x) {\n\t\taddEdge(s, i, 1);\n\t}\n\trep(i, y) {\n\t\taddEdge(x + i, t, 1);\n\t}\n\trep(i, e) {\n\t\tint xi, yi;\n\t\tput xi >> yi;\n\t\taddEdge(xi, x + yi, 1);\n\t}\n\tcout << maxFlow(s, t) << endl;\nEND:\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<int> list[100000];\nint N, M, E;\nint match[100000];\nbool used[100000];\nint x, y;\n\nbool DFS(int V) {\n\tused[V] = true;\n\tfor (int i = 0; i < list[V].size(); i++) {\n\t\tint u = list[V][i]; int w = match[u];\n\t\tif (w < 0 || !used[u] && DFS(w)) {\n\t\t\tmatch[V] = u;\n\t\t\tmatch[u] = V;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint supermatching() {\n\tint r = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int j = 0; j < N + M; j++) {\n\t\tif (match[j] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (DFS(j)) { r++; }\n\t\t}\n\t}\n\treturn r;\n}\n\nint main() {\n\tcin >> N >> M >> E;\n\tfor (int i = 0; i < E; i++) {\n\t\tcin >> x >> y;\n\t\ty += N;\n\t\tlist[y].push_back(x);\n\t\tlist[x].push_back(y);\n\t}\n\tcout << supermatching() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\n//?????§2??¨??????????????° verified AOJ GRL_7_A\n#define MAX_V 100000\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u,int v){\n    G[u].pb(v);\n    G[v].pb(u);\n}\n\n// ?¢???§??????DFS??§??¢???\nbool dfs(int v){\n    used[v]=true;\n    rep(i,G[v].size()){\n        int u=G[v][i],w=match[u];           //u:v??????????§???????????????? , w:u??¨??????????????°??????????????????\n        if(w<0 || (!used[w] && dfs(w))){    //u????????????????????????dfs??§???w????????£???????????? ??????w?????\\????????¢??????????????£???(=?¢???§?????????) ??´???\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(int V){\n    int res=0;\n    rep(i,MAX_V)match[i]=-1;\n    rep(v,V){\n        if(match[v]<0){\n            rep(i,MAX_V)used[i]=0;\n            if( dfs(v) ) res++;       //?¢???§????????????????????°res+=1\n        }\n    }\n    return res;\n}\n\nint main(){\n    int x,y,e;\n    cin>>x>>y>>e;\n    rep(i,e){\n        int a,b;\n        cin>>a>>b;\n        add_edge(a,b);\n    }\n    \n    cout<<bipartite_matching(e)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i,n) for (int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int MAX_V = 210;\nstruct edge{\n\tint to, cap, rev;\n\tedge(int to,int cap, int rev):to(to),cap(cap),rev(rev){}\n};\nvector<vector<edge> > G(MAX_V); //??°???????????£??\\???????????¨???\nbool used[MAX_V]; //DFS??§??¢???????????????????????????????????°\n\nvoid add_edge(int from, int to, int cap){\n\t\tG[from].push_back(edge(to,cap,G[to].size()));\n\t\tG[to].push_back(edge(from,0,G[from].size() - 1));\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif( !used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -=d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxflow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tfill(used,used + MAX_V,false);\n\t\tint f = dfs(s,t,INF);\n\t\tif(f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\nint x,y,e;\n\tcin >> x >> y >> e;\n\tint s = x+y, t = s+1;\n\tREP(i,e){\n\t\tint from,to;\n\t\tcin >> from >> to;\n\t\tadd_edge(from,to + x,1);\n\t}\n\tREP(i,x){\n\t\tadd_edge(s,i,1);//?§?????????????????????????\n\t}\n\tREP(i,y){\n\t\tadd_edge(x + i,t,1);//????????????????????????\n\t}\n\tcout << maxflow(s,t) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nconst int MAX=100;\nconst int MAX_cap=10000;\n\nclass edge\n{\npublic:\n\tint to,cap,rev;\n\tedge(){}\n\tedge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from,int to,int cap)\n{\n\tG[from].push_back(edge(to,cap,G[to].size()));\n\tG[to].push_back(edge(from,0,G[from].size()-1));\n\treturn;\n}\n\nint dfs(int v,int t,int f)\n{\n\tif(v==t)return f;\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tedge &e=G[v][i];\n\t\tif(!used[e.to]&&e.cap>0)\n\t\t{\n\t\t\tint d=dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0)\n\t\t\t{\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxflow(int s,int t)\n{\n\tint flow=0;\n\twhile(1)\n\t{\n\t\tfor(int i=0;i<MAX;i++)used[i]=false;\n\t\tint f=dfs(s,t,MAX_cap);\n\t\tif(f==0)return flow;\n\t\tflow+=f;\n\t}\n}\n\nint main()\n{\n\tint X,Y,E;cin>>X>>Y>>E;\n\tint u,v;\n\tint s=X+Y,t=s+1;\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tcin>>u>>v;\n\t\tadd_edge(u,X+v,1);\n\t}\n\tfor(int i=0;i<X;i++)add_edge(s,i,1);\n\tfor(int i=0;i<Y;i++)add_edge(X+i,t,1);\n\t\n\tcout<<maxflow(s,t)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9;\n\nstruct edge{int to, cap, rev;};\nvector<edge> G[206];\nbool used[206];\nint dfs(int v, int t, int f){\n\tif(v == t)return f;\n\tused[v] = true;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid add(int v, int u){\n\tG[v].push_back((edge){u, 1, (int)G[u].size()});\n\tG[u].push_back((edge){v, 0, (int)G[v].size()-1});\n}\n\nint main(){\n\tint n1, n2, m, v, u, c;\n\tscanf(\"%d%d%d\", &n1, &n2, &m);\n\tfor(int i = 0;i < m;i++){\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tadd(v, n1+u);\n\t}\n\tfor(int i = 0;i < n1;i++)add(n1+n2, i);\n\tfor(int i = 0;i < n2;i++)add(n1+i, n1+n2+1);\n\t\n\tint flow = 0;\n\twhile(1){\n\t\tfill(used, used+206, 0);\n\t\tint f = dfs(n1+n2, n1+n2+1, inf);\n\t\tif(f == 0)break;\n\t\tflow += f;\n\t}\n\t\n\tprintf(\"%d\\n\", flow);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAX 256\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\nint X, Y, E;\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[to].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge& e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (1) {\n        for (int i = 0; i < MAX; i++) used[i] = false;\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(void) {\n    cin >> X >> Y >> E;\n    while (E--) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, X+y, 1);\n    }\n    int s = X+Y, t = s+1;\n    for (int i = 0; i < X; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        add_edge(X+i, t, 1);\n    }\n    cout << max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint INF = 10000000;\nint bipartite_matching(vector<pair<int, int>> &E, int X, int Y){\n\tint V = X + Y + 2;\n\tvector<set<int>> E2(V);\n\tfor (int i = 0; i < X; i++){\n\t\tE2[0].insert(i + 1);\n\t}\n\tfor (int i = 0; i < E.size(); i++){\n\t\tint v = E[i].first;\n\t\tint w = E[i].second;\n\t\tE2[v + 1].insert(X + 1 + w);\n\t}\n\tfor (int i = X + 1; i < V - 1; i++){\n\t\tE2[i].insert(V - 1);\n\t}\n\tint F = 0;\n\twhile (1){\n\t\tvector<bool> used(V, false);\n\t\tvector<int> prev(V, -1);\n\t\tused[0] = true;\n\t\tqueue<int> Q;\n\t\tQ.push(0);\n\t\twhile (!Q.empty()){\n\t\t\tint v = Q.front();\n\t\t\tQ.pop();\n\t\t\tfor (int w : E2[v]){\n\t\t\t\tif (!used[w]){\n\t\t\t\t\tused[w] = true;\n\t\t\t\t\tprev[w] = v;\n\t\t\t\t\tQ.push(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!used[V - 1]){\n\t\t\tbreak;\n\t\t}\n\t\tint c = V - 1;\n\t\twhile (c != 0){\n\t\t\tE2[prev[c]].erase(c);\n\t\t\tE2[c].insert(prev[c]);\n\t\t\tc = prev[c];\n\t\t}\n\t\tF++;\n\t}\n\treturn F;\n}\nint main(){\n  int X, Y, e;\n  cin >> X >> Y >> e;\n  vector<pair<int, int>> E(e);\n  for (int i = 0; i < e; i++){\n    int x, y;\n    cin >> x >> y;\n    E[i] = make_pair(x, y);\n  }\n  cout << bipartite_matching(E, X, Y) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <complex>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <regex>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\nusing namespace std;\n\n#define chmax(x, y) x = max(x, y)\n#define chmin(x, y) x = min(x, y)\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n#define repLRE(i, l, r) for (ll i = (l); i <= (r); ++i)\n#define rrepLRE(i, l, r) for (ll i = (l); i >= (r); --i)\n#define Sort(v) sort(v.begin(), v.end())\n#define rSort(v) sort(v.rbegin(), v.rend())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define Lower_bound(v, x) \\\n  distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) \\\n  distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\nusing T = tuple<ll, ll, ll>;\nusing vll = vector<ll>;\nusing vP = vector<P>;\nusing vT = vector<T>;\nusing vvll = vector<vector<ll>>;\nusing vvP = vector<vector<P>>;\nusing dqll = deque<ll>;\n\nll dx[9] = {-1, 1, 0, 0, -1, -1, 1, 1, 0};\nll dy[9] = {0, 0, -1, 1, -1, 1, -1, 1, 0};\n\n/* Macros reg. ends here */\n\nconst ll INF = 1LL << 50;\n\nstatic const long long mod = 1000000007;\n\nstruct edge {\n  ll to, cap, rev;\n};\n\nvector<vector<edge>> to;\nvector<bool> used;\nvoid addE(ll u, ll v, ll w) {\n  to[u].push_back({v, w, (ll)to[v].size()});\n  to[v].push_back({u, 0, (ll)to[u].size() - 1});\n}\n\nll dfs(ll u, ll t, ll f) {\n  assert(f > 0);\n  if (u == t) return f;\n  used[u] = true;\n  for (edge& e : to[u]) {\n    if (used[e.to] || e.cap <= 0) continue;\n    ll d = dfs(e.to, t, min(f, e.cap));\n    if (d == 0) continue;\n    e.cap -= d;\n    to[e.to][e.rev].cap += d;\n    return d;\n  }\n  return 0;\n}\n\nint main() {\n  // ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  cout << fixed << setprecision(15);\n\n  ll nx, ny, ne;\n  cin >> nx >> ny >> ne;\n\n  to.resize(nx + ny + 2);\n  rep(i, nx) { addE(nx + ny, i, 1); }\n  rep(i, ny) { addE(nx + i, nx + ny + 1, 1); }\n\n  rep(i, ne) {\n    ll x, y;\n    cin >> x >> y;\n    addE(x, nx + y, 1);\n  }\n\n  ll ans = 0;\n  while (true) {\n    used.assign(nx + ny + 2, false);\n    ll add = dfs(nx + ny, nx + ny + 1, INF);\n    if (add == 0) {\n      cout << ans << endl;\n      return 0;\n    } else\n      ans += add;\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define _GLIBCXX_DEBUG\nusing namespace std;\nusing ll = long long;\nusing vec = vector<ll>;\nusing vect = vector<double>;\nusing Graph = vector<vector<ll>>;\n#define loop(i, n) for (ll i = 0; i < n; i++)\n#define Loop(i, m, n) for (ll i = m; i < n; i++)\n#define pool(i, n) for (ll i = n; i >= 0; i--)\n#define Pool(i, m, n) for (ll i = n; i >= m; i--)\n#define mod 1000000007ll\n#define setbit bitset<8>\n#define flagcount __builtin_popcount\n#define flag(x) (1 << x)\n#define flagadd(bit, x) bit |= flag(x)\n#define flagpop(bit, x) bit &= ~flag(x)\n#define flagon(bit, i) bit &flag(i)\n#define flagoff(bit, i) !(bit & (1 << i))\n#define all(v) v.begin(), v.end()\n#define low2way(v, x) lower_bound(all(v), x)\n#define high2way(v, x) upper_bound(all(v), x)\n#define count2way(v, x) high2way(v, x) - low2way(v, x)\n#define lower(v, x) low2way(v, x) - v.begin()       //1番左が0、もし見つから無いならｎを出力\n#define higher(v, x) high2way(v, x) - v.begin() - 1 //1番左が0、もし見つからないならn-1を出力（注意）\n#define putout(a) cout << a << endl\n#define putout2(a, b) \\\n    putout(a);        \\\n    putout(b)\n#define putout3(a, b, c) \\\n    putout(a);           \\\n    putout(b);           \\\n    putout(c)\n#define putout4(a, b, c, d) \\\n    putout(a);              \\\n    putout(b);              \\\n    putout(c);              \\\n    putout(d)\n#define putout5(a, b, c, d, e) \\\n    putout(a);                 \\\n    putout(b);                 \\\n    putout(c);                 \\\n    putout(d);                 \\\n    putout(e)\n#define Gput(a, b) G[a].push_back(b)\n#define cin1(a) cin >> a\n#define cin2(a, b) cin >> a >> b\n#define cin3(a, b, c) cin >> a >> b >> c\n#define cin4(a, b, c, d) cin >> a >> b >> c >> d\n#define cin5(a, b, c, d, e) cin >> a >> b >> c >> d >> e\n#define Sum(v) accumulate(all(v), 0ll)\n#define gcd(x, y) __gcd(x, y)\nll ctoi(char c)\n{\n    if (c >= '0' && c <= '9')\n    {\n        return c - '0';\n    }\n    return 0;\n}\ntemplate <typename T>\nT lcm(T x, T y)\n{\n    T z = gcd(x, y);\n    return x * y / z;\n}\ntemplate <typename T>\nbool primejudge(T n)\n{\n    if (n < 2)\n        return false;\n    else if (n == 2)\n        return true;\n    else if (n % 2 == 0)\n        return false;\n    double sqrtn = sqrt(n);\n    for (T i = 3; i < sqrtn + 1; i++)\n    {\n        if (n % i == 0)\n        {\n            return false;\n        }\n        i++;\n    }\n    return true;\n}\ntemplate <typename T>\nT modinv(T a, T m)\n{\n    T b = m, u = 1, v = 0;\n    while (b)\n    {\n        T t = a / b;\n        a -= t * b;\n        swap(a, b);\n        u -= t * v;\n        swap(u, v);\n    }\n    u %= m;\n    if (u < 0)\n        u += m;\n    return u;\n}\n//場合によって使い分ける\n//const ll dx[4]={1,0,-1,0};\n//const ll dy[4]={0,1,0,-1};\nconst ll dx[8] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dy[8] = {0, 1, 1, 1, 0, -1, -1, -1};\n//多次元配列の宣言法\n//vector<vector<ll>> field(h, vector<ll>(w));\ntemplate <class T>\ninline void chmax(T &a, T b)\n{\n    if (a < b)\n        a = b;\n}\ntemplate <class T>\ninline void chmin(T &a, T b)\n{\n    if (a > b)\n        a = b;\n}\n/*\nライブラリをここに置いてコメントを削除\n*/\n#define fst first\n#define snd second\nconst long long INF = (1ll << 50);\nstruct graph\n{\n    typedef long long flow_type;\n    struct edge\n    {\n        int src, dst;\n        flow_type capacity, flow;\n        size_t rev;\n    };\n    int n;\n    vector<vector<edge>> adj;\n    graph(int n) : n(n), adj(n) {}\n    void add_edge(int src, int dst, flow_type capacity)\n    {\n        adj[src].push_back({src, dst, capacity, 0, adj[dst].size()});\n        adj[dst].push_back({dst, src, 0, 0, adj[src].size() - 1});\n    }\n    flow_type max_flow(int s, int t)\n    {\n        vector<int> level(n), iter(n);\n        function<int(void)> levelize = [&]() { // foward levelize\n            level.assign(n, -1);\n            level[s] = 0;\n            queue<int> Q;\n            Q.push(s);\n            while (!Q.empty())\n            {\n                int u = Q.front();\n                Q.pop();\n                if (u == t)\n                    break;\n                for (auto &e : adj[u])\n                {\n                    if (e.capacity > e.flow && level[e.dst] < 0)\n                    {\n                        Q.push(e.dst);\n                        level[e.dst] = level[u] + 1;\n                    }\n                }\n            }\n            return level[t];\n        };\n        function<flow_type(int, flow_type)> augment = [&](int u, flow_type cur) {\n            if (u == t)\n                return cur;\n            for (int &i = iter[u]; i < adj[u].size(); ++i)\n            {\n                edge &e = adj[u][i], &r = adj[e.dst][e.rev];\n                if (e.capacity > e.flow && level[u] < level[e.dst])\n                {\n                    flow_type f = augment(e.dst, min(cur, e.capacity - e.flow));\n                    if (f > 0)\n                    {\n                        e.flow += f;\n                        r.flow -= f;\n                        return f;\n                    }\n                }\n            }\n            return flow_type(0);\n        };\n        for (int u = 0; u < n; ++u) // initialize\n            for (auto &e : adj[u])\n                e.flow = 0;\n\n        flow_type flow = 0;\n        while (levelize() >= 0)\n        {\n            fill(all(iter), 0);\n            for (flow_type f; (f = augment(s, INF)) > 0;)\n                flow += f;\n        }\n        return flow;\n    }\n};\n/*\n    graph g(n);\n    //g.add_edge(u, v, w);\n    g.add_edge(u-1, v-1, w);\n    g.max_flow(0, n-1)\n*/\nint main()\n{\n    cout << fixed << setprecision(30);\n    ll X, Y, E;\n    cin >> X >> Y >> E;\n    graph g(X + Y + 2);\n    loop(i, X) g.add_edge(0, i + 1, 1);\n    loop(i, Y) g.add_edge(X + 1 + i, X + Y + 1, 1);\n    loop(i, E)\n    {\n        ll u, v;\n        cin >> u >> v;\n        u++;\n        v += (X + 1);\n        g.add_edge(u, v, 1);\n    }\n    putout(g.max_flow(0, X + Y + 1));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = a; i < n; ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nclass HopcroftKarp {\n\n    void bfs() {\n        const int n = g.size();\n        dist.assign(n, -1);\n        queue<int> que;\n        for (int i = 0; i < n; ++i) {\n            if (used[i]) continue;\n            que.emplace(i);\n            dist[i] = 0;\n        }\n        \n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int& u : g[v]) {\n                int w = match[u];\n                if (w >= 0 && dist[w] == -1) {\n                    dist[w] = dist[v] + 1;\n                    que.emplace(w);\n                }\n            }\n        }\n    }\n\n    bool dfs(int v) {\n        vv[v] = true;\n        for (auto& u : g[v]) {\n            int w = match[u];\n            if (w < 0 || (!vv[w] && dist[w] == dist[v] + 1 && dfs(w))) {\n                match[u] = v;\n                used[v] = true;\n                return true;\n            }\n        }\n        return false;\n    }\n    \npublic:\n    vector<vector<int>> g;\n    vector<int> dist, match;\n    vector<bool> used, vv;\n\n    HopcroftKarp(int n, int m) : g(n), match(m, -1), used(n) {}\n\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n    }\n\n    int bipartite_matching() {\n        const int n = g.size();\n        int res = 0;\n        while (true) {\n            bfs();\n            vv.assign(n, false);\n            int flow = 0;\n            for (int i = 0; i < n; ++i) {\n                if (!used[i] && dfs(i)) ++flow;\n            }\n            if (!flow) break;\n            res += flow;\n        }\n        return res;\n    }\n};\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    HopcroftKarp hk(X, Y);\n    REP(i, E) {\n        int x, y;\n        cin >> x >> y;\n        hk.add_edge(x, y);\n    }\n    cout << hk.bipartite_matching() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = int(A); I < int(B); ++I)\n#define FORR(I,A,B) for(ll I = int((B)-1); I >= int(A); --I)\n#define TO(x,t,f) ((x)?(t):(f))\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //xi>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //xi>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a<b)swap(a,b);if(a%b==0)return b;return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}//saisyo kobaisu\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=1e18+7;\nconst ll MOD=1e9+7;\n\nstruct edge{int to,cap,rev;};\nstruct Maxflow{//ant book p.194\n\tvector<vector<edge> > G;\n\tvector<int> level,iter;\n\tvoid initsize(int nv){\n\t\tG.resize(nv);\n\t\tlevel.resize(nv);\n\t\titer.resize(nv);\n\t}\n\tvoid add_edge(int from,int to,int cap){\n\t\tG[from].push_back((edge){to,cap,G[to].size()});\n\t\tG[to].push_back((edge){from,0,G[from].size()-1});\n\t}\n\tvoid bfs(int s){\n\t\tfill(level.begin(),level.end(),-1);\n\t\t//memset(level,-1,sizeof(level));\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile( !que.empty() ){\n\t\t\tint v = que.front();que.pop();\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[e.to]<0){\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v,int t,int f){\n\t\tif(v==t)return f;\n\t\tfor(int &i = iter[v];i<G[v].size();i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s,int t){\n\t\tint flow=0;\n\t\tfor(;;){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0)return flow;\n\t\t\tfill(iter.begin(),iter.end(),0);\n\t\t\t//memset(iter,0,sizeof(iter));\n\t\t\tint f;\n\t\t\twhile((f=dfs(s,t,INT_MAX))>0){\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n \nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tMaxflow mf;\n\tint X,Y,E;\n\tcin>>X>>Y>>E;\n\tmf.initsize(X+Y+2);\n\tFOR(i,0,E){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tmf.add_edge(x+1,y+X+1,1);\n\t}\n\tFOR(i,1,X+1){\n\t  mf.add_edge(0,i,1);\n\t}\n\tFOR(i,1,Y+1){\n\t  mf.add_edge(i+X,X+Y+1,1);\n\t}\n\tcout<<mf.max_flow(0,X+Y+1)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nstruct edge {\n\tint to; // ?????????\n\tint cap; // ??????\n\tint rev; // ??????\n\tedge() {}\n\tedge(int to, int cap, int rev) :to(to), cap(cap), rev(rev) {}\n};\n\nvector<vector<edge>> G; // ??°???????????£??\\???????????¨???\nvector<int> used; // DFS??§?????§???????????????????????°\n\n\t\t\t\t  // from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge(to, cap, G[to].size()));\n\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\n// ?¢?????????????DFS??§??¢???\nint dfs(int v, int t, int f) {\n\tif (v == t) return f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n// s??????t???????????§???????±???????\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tfill(used.begin(), used.end(), 0);\n\t\tint f = dfs(s, t, INF);\n\t\tif (f == 0) return flow;\n\t\tflow += f;\n\t}\n}\n\n\n/* use example */\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll X, Y, E; cin >> X >> Y >> E;\n\tG.resize(X + Y + 2); used.resize(X + Y + 2);\n\tfor (int i = 0; i < E;i++) {\n\t\tll x, y; cin >> x >> y;\n\t\tx++; y++;\n\t\tadd_edge(x, X + y, 1); // ?????¨??´???????????¨??´???????????????\n\t}\n\tfor (int i = 1; i <= X;i++) add_edge(0, i, 1);\n\tfor (int j = X + 1;j <= X + Y;j++) add_edge(j, X + Y + 1, 1);\n\tcout << max_flow(0, X+Y+1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fio() ios::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pi;\ntypedef pair<pi, ll> pii;\n\nconst ll mod = 1e9 + 7;\nconst ll maxn = 1e2 + 2;\nconst ll N = 1e2 + 2;\nconst ll inf = 1e12;\nconst ld eps = 1e-6;\n\nll g[maxn][maxn], matchU[maxn], ans;\nbool vis[maxn];\nll n, m, e;\nbool isDone;\n\nbool dfs(ll v) {\n\tfor (int i = 0; i < m; i++) {\n\t\tif (g[v][i] && !vis[i]) {\n\t\t\tvis[i] = true;\n\t\t\tif (matchU[i] < 0 || dfs(matchU[i])) {\n\t\t\t\tmatchU[i] = v;\n\t\t\t\treturn true;\t\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tfio();\n\tcin >> n >> m >> e;\n\tfor (int i = 0; i < e; i++) {\n\t\tll fr, to;\n\t\tcin >> fr >> to;\n\t\tg[fr][to] = 1;\t\n\t}\n\tfor (int i = 0; i < maxn; i++)\n\t\tmatchU[i] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < maxn; j++)\n\t\t\tvis[j] = 0;\n\t\tif (dfs(i))\n\t\t\tans++;\t\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) (int)(x).size()\nusing namespace std;\nusing ll = long long;\nconstexpr ll INF = 3000000000000000000;\n\nstruct Dinic {\n    struct Edge {int to, rev, cap;};\n    vector<vector<Edge>> Graph;\n    vector<int> dist, iter;\n    Dinic(int v) : Graph(v) {}\n    void AddEdge(int from, int to, int cap) {\n        Graph[from].push_back({to, SZ(Graph[to]), cap});\n        Graph[to].push_back({from, SZ(Graph[from]) - 1, 0});\n    }\n    bool bfs(int s, int t) {\n        dist.assign(SZ(Graph), -1);\n        queue<int> q;\n        dist[s] = 0;\n        q.push(s);\n        while (!q.empty() && dist[t] == -1) {\n            int v = q.front();\n            q.pop();\n            for (const auto &e: Graph[v]) {\n                if (e.cap > 0 && dist[e.to] == -1) {\n                    dist[e.to] = dist[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n        return dist[t] != -1;\n    }\n    int dfs(int now, int t, int mn) {\n        if (now == t) return mn;\n        for (int &i = iter[now]; i < SZ(Graph[now]); ++i) {\n            Edge &e = Graph[now][i];\n            if (e.cap > 0 && dist[now] + 1 == dist[e.to]) {\n                int d = dfs(e.to, t, min(mn, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    Graph[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int MaxFlow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            iter.assign(SZ(Graph), 0);\n            int f = 0;\n            while ((f = dfs(s, t, 1001001001)) > 0) ans += f;\n        }\n        return ans;\n    }\n};\n\nint main() {\n    int x, y, e;\n    cin >> x >> y >> e;\n    Dinic D(x + y + 2);\n    REP(i, x) D.AddEdge(0, i + 1, 1);\n    REP(i, y) D.AddEdge(i + x + 1, x + y + 1, 1);\n    REP(i, e) {\n        int a, b;\n        cin >> a >> b;\n        D.AddEdge(a + 1, b + x + 1, 1);\n    }\n    cout << D.MaxFlow(0, x + y + 1) << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\n\nconst int INF = 1 << 19;\n\n\nstruct FlowEdge {\n  FlowEdge(int f, int t, int c, int _flow) : from(f), to(t), cap(c), flow(_flow) {}\n  int from, to, cap, flow;\n};\n\n\nclass Dinic {\npublic:\n  Dinic(int n) : n(n), m(0) {\n    adj.resize(n+2);\n  }\n\n  void add_edge(int u, int v, int cap) {\n    edges.push_back(FlowEdge(u, v, cap, 0));\n    edges.push_back(FlowEdge(v, u, 0, 0));\n    adj[u].push_back(m);\n    adj[v].push_back(m+1);\n    m += 2;\n  }\n\n  int max_flow() {\n    int flow = 0;\n    int s = 0, t = n+1;\n    for (;;) {\n      if (!bfs(s, t)) break;\n      ptr.assign(n+2, 0);\n      while (int f = dfs(s, t, INF)) {\n        flow += f;\n      }\n    }\n\n    return flow;\n  }\n\nprivate:\n  bool bfs(int s, int t) {\n    level.assign(n+2, -1);\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n      int v = que.front(); que.pop();\n      for (size_t i = 0; i < adj[v].size(); ++i) {\n        int pos = adj[v][i];\n        FlowEdge &e = edges[pos];\n        if (e.cap > e.flow && level[e.to] < 0) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n    return level[t] > 0;\n  }\n\n  int dfs(int s, int t, int f) {\n    if (f == 0) return 0;\n    if (s == t) return f;\n    for (int &iter=ptr[s]; iter < (int)adj[s].size(); ++iter) {\n      int pos = adj[s][iter];\n      FlowEdge &e = edges[pos];\n      if (level[e.to] != level[e.from]+1 || e.cap - e.flow < 1)\n        continue;\n      int d = dfs(e.to, t, min(f, e.cap-e.flow));\n      if (d > 0) {\n        edges[pos].flow += d;\n        edges[pos^1].flow -= d;\n        return d;\n      }\n    }\n    return 0;\n  }\n\nprivate:\n  int n, m;\n  vector<FlowEdge> edges;\n  vector<vector<int> > adj;\n  vector<int> level, ptr;\n  queue<int> que;\n};\n\n\nvoid solve(int x, int y, int e) {\n  Dinic dinic(x+y);\n\n  for (int i = 0; i < e; ++i) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    int u = a+1, v = b+x+1;\n    dinic.add_edge(u, v, 1);\n  }\n\n  // source edge\n  int s = 0;\n  for (int i = 1; i <= x; ++i) {\n    dinic.add_edge(s, i, 1);\n  }\n  // sink edge;\n  int t = x+y+1;\n  for (int i = x+1; i <= x+y; ++i) {\n    dinic.add_edge(i, t, 1);\n  }\n\n  printf(\"%d\\n\", dinic.max_flow());\n}\n\nint main() {\n\n  int x, y, e;\n  scanf(\"%d %d %d\", &x, &y, &e); \n\n  solve(x, y, e);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mx = 305;\nconst int inf = 0x3f3f3f3f;\nconst int S = mx - 2, T = mx - 1;\n\nstruct edge {\n  int from, to, cap;\n  edge *rev;\n  edge(int from, int to, int cap) : from(from), to(to), cap(cap) {}\n  void flow(int f) { cap -= f, rev->cap += f; }\n};\n\nvector<edge *> adj[mx];\n\nvoid addEdge(int u, int v, int c) {\n  edge *e = new edge(u, v, c);\n  edge *rev = new edge(v, u, 0);\n  e->rev = rev, rev->rev = e;\n  adj[u].push_back(e);\n  adj[v].push_back(rev);\n}\n\nbool vis[mx], inq[mx];\nint bt[mx], mf[mx];\nedge *bte[mx];\nbool augment(int &flow) {\n  fill(vis, vis + mx, false);\n  fill(inq, inq + mx, false);\n  fill(mf, mf + mx, 0);\n  queue<int> q;\n  q.push(S);\n  mf[S] = inf;\n  while (!q.empty()) {\n    int p = q.front();\n    q.pop();\n    inq[p] = false;\n    if (vis[p])\n      continue;\n    vis[p] = true;\n    if (p == T)\n      break;\n    for (edge *e : adj[p]) {\n      if (!vis[e->to] && min(e->cap, mf[p]) > mf[e->to]) {\n        bt[e->to] = p;\n        bte[e->to] = e;\n        mf[e->to] = min(e->cap, mf[p]);\n        if (!inq[e->to])\n          q.push(e->to), inq[e->to] = true;\n      }\n    }\n  }\n  if (!vis[T])\n    return false;\n  int p = T, f = mf[T];\n  while (p != S) {\n    bte[p]->flow(f);\n    p = bt[p];\n  }\n  flow = f;\n  return true;\n}\n\nint maxflow() {\n  int flow, mflow = 0;\n  while (augment(flow))\n    mflow += flow;\n  return mflow;\n}\n\nint main() {\n  int x, y, e;\n  cin >> x >> y >> e;\n\n  for (int i = 0; i < x; i++)\n    addEdge(S, i, 1);\n  for (int i = 100; i < 100 + y; i++)\n    addEdge(i, T, 1);\n\n  for (int i = 0; i < e; i++) {\n    int a, b;\n    cin >> a >> b;\n    addEdge(a, 100 + b, inf);\n  }\n\n  cout << maxflow() << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <random>\nusing namespace std;\nusing ll    =long long;    using dd   =double;        using pll    =pair<ll, ll>;  using tll    =tuple<ll,ll,ll>;\nusing vll   =vector<ll>;   using vdd  =vector<dd>;    using vpll   =vector<pll>;   using vtll   =vector<tll>;\nusing vvll  =vector<vll>;  using vvdd =vector<vdd>;   using vvpll  =vector<vpll>;  using vvtll  =vector<vtll>;\nusing vvvll =vector<vvll>; using vvvdd=vector<vvdd>;  using vvvpll =vector<vvpll>; using vvvtll =vector<vvtll>;\nusing vvvvll=vector<vvvll>;using vvvvdd=vector<vvvdd>;using vvvvpll=vector<vvvpll>;using vvvvtll=vector<vvvtll>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define rep(i, S, E) REPS(i, S, E)\n#define REP(i, N) REPS(i, 0, (N)-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define dep(i, E, S) DEPS(i, S, E)\n#define DEP(i, N) DEPS(i, 0, (N)-1)\n#define EACH(e, v) for (auto&& e : v)\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S,ll E){ T s=v[S]; REPS(i,S+1,E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline ll Size(T &v){ return (ll)v.size(); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\nll Gcd(ll a, ll b){ return (b==0) ? a : Gcd(b, a%b); }\nll Lcm(ll a, ll b){ return a * b / Gcd(a, b); }\ninline vll Bit2Idx(ll m){vll v; for(ll i=0;m;m>>=1,i++) if(m&1)v.push_back(i); return move(v);}\ninline ll BitNum(ll m){ for (ll c=0;; m>>=1){ c+=m&1; if (!m)return c; } }\ninline ll Bit(ll s, ll i){ return (s>>i)&1; } //sの第ibit i=0-63\ninline ll BitOn(ll s, ll i){ return s|(1LL<<i); } //sの第ibitON i=0-63\ninline ll BitOff(ll s, ll i){ return s&~(1LL<<i); } //sの第ibitOFF i=0-63\ntemplate<class T> inline ll UnderNumOf(vector<T> &v, T x){ //sort済vのx以下の個数を得る\n\treturn upper_bound(v.begin(), v.end(), x) - v.begin(); }\ntemplate<class T, class Pr> inline ll UnderNumOf(vector<T> &v, T x, Pr pred){ //x以下個数\n\treturn upper_bound(v.begin(), v.end(), x, pred) - v.begin(); }\ntemplate<class T> inline ll OverNumOf(vector<T> &v, T x){ //sort済vのx以上の個数を得る\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x) - v.begin()); }\ntemplate<class T, class Pr> inline ll OverNumOf(vector<T> &v, T x, Pr pred){ //x以上の個数\n\treturn (ll)v.size() - (lower_bound(v.begin(), v.end(), x, pred) - v.begin()); }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T=ll> inline vector<vector<T>> cinvv(ll N, ll M){\n\tvector<vector<T>> vv(N); REP(i, N) vv[i] = cinv(M); return move(vv);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n#if defined(_DEBUG)\nll dumpW = 5;\ntemplate<class T> void Dump(vector<T> &v){\n\tREP(i, (ll)v.size()) { cerr << ((i==0)?\"[\":\" \") << setw(dumpW) << v[i]; }  cerr << \"]\";\n}\nvoid Dump(vll &v){\n\tREP(i, (ll)v.size()) {\n\t\tcerr << ((i==0)?\"[\":\" \") << setw(dumpW);\n\t\tif       (v[i] == INF) cerr << \"INF\";\n\t\telse if (v[i] == -INF) cerr << \"-INF\";\n\t\telse                   cerr << v[i];\n\t}  cerr << \"]\";\n}\ntemplate<class T> void Dump(vector<vector<T>> &v){\n\tll N=(ll)v.size();  string d[2][2]={{\" \", \"[\"},  {\"\\n\", \"]\\n\"}};\n\tREP(i, N) { cerr << d[0][i==0];  Dump(v[i]);  cerr << d[1][i==N-1]; }\n}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  <\", \"[ <\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ---<\", \"[ ---<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">---\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){\n\tll N=(ll)v.size();  string d[2]={\"  ======<\", \"[ ======<\"};\n\tREP(i, N) { cerr << d[i==0] << i << \">======\\n\"; Dump(v[i]); }  cerr << \"]\\n\";\n}\n#else\ntemplate<class T> void Dump(vector<T> &v){}\ntemplate<class T> void Dump(vector<vector<T>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<T>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<T>>>> &v){}\ntemplate<class T> void Dump(vector<vector<vector<vector<vector<T>>>>> &v){}\n#endif\n\ntemplate<ll MOD> struct mll_{\n\tll val;\n\tmll_(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll_ operator - () const { return -val; }\n\tmll_ operator + (const mll_ &b) const { return val + b.val; }\n\tmll_ operator - (const mll_ &b) const { return val - b.val; }\n\tmll_ operator * (const mll_ &b) const { return val * b.val; }\n\tmll_ operator / (const mll_ &b) const { return mll_(*this) /= b; }\n\tmll_ operator + (ll b) const { return *this + mll_(b); }\n\tmll_ operator - (ll b) const { return *this - mll_(b); }\n\tmll_ operator * (ll b) const { return *this * mll_(b); }\n\tfriend mll_ operator + (ll a, const mll_ &b) { return b + a; }\n\tfriend mll_ operator - (ll a, const mll_ &b) { return -b + a; }\n\tfriend mll_ operator * (ll a, const mll_ &b) { return b * a; }\n\tfriend mll_ operator / (ll a, const mll_ &b) { return mll_(a)/b; }\n\tmll_ &operator += (const mll_ &b) { val=(val+b.val)%MOD; return *this; }\n\tmll_ &operator -= (const mll_ &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll_ &operator *= (const mll_ &b) { val=(val*b.val)%MOD; return *this; }\n\tmll_ &operator /= (const mll_ &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll_ &operator += (ll b) { return *this += mll_(b); }\n\tmll_ &operator -= (ll b) { return *this -= mll_(b); }\n\tmll_ &operator *= (ll b) { return *this *= mll_(b); }\n\tmll_ &operator /= (ll b) { return *this /= mll_(b); }\n\tbool operator == (const mll_ &b) { return val == b.val; }\n\tbool operator != (const mll_ &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll_(b); }\n\tbool operator != (ll b) { return *this != mll_(b); }\n\tfriend bool operator == (ll a, const mll_ &b) { return mll_(a) == b.val; }\n\tfriend bool operator != (ll a, const mll_ &b) { return mll_(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll_ &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll_ &a) { return is >> a.val; }\n\tstatic mll_ Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll_(0);\n\t\tmll_ c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nusing mll = mll_<1000000007LL>; //1000000007LL;// 998244353LL;\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\nusing vvvvvmll = std::vector<vvvvmll>;\n\n\nclass DinicMethod{\npublic:\n\tstruct Edge{ ll to, cap, rev; };\n\tvector<vector<Edge>> G;\nprivate:\n\tvll level;\n\tvll iter;\npublic:\n\tDinicMethod(ll nodeNum): G(nodeNum){}\n\n\tvoid Link(ll v, ll u, ll cap, ll rcap = 0){//v→uに重みcapで張る、逆辺も張る\n\t\tthis->G[v].push_back({u,  cap, (ll)this->G[u].size()});\n\t\tthis->G[u].push_back({v, rcap, (ll)this->G[v].size()-1});\n\t}\n\n\tll MaxFlow(ll s, ll t){//s→tの最大流を求める\n\t\tll f, flow = 0;\n\t\twhile (true){\n\t\t\tthis->BfsLevelRenew(s);\n\t\t\tif (this->level[t] < 0) return flow;\n\t\t\titer.assign(this->G.size(), 0);\n\t\t\twhile ((f = this->DfsFindPath(s, t, INF)) > 0) { flow += f; }\n\t\t}\n\t}\n\nprivate:\n\tvoid BfsLevelRenew(ll s) {\n\t\tthis->level.assign(this->G.size(), -1);\n\t\tthis->level[s] = 0;\n\t\tqueue<ll> que;\n\t\tque.push(s);\n\t\twhile (!que.empty()){\n\t\t\tll from = que.front(); que.pop();\n\t\t\tEACH(e, this->G[from]){\n\t\t\t\tif (e.cap > 0 && this->level[e.to] < 0){\n\t\t\t\t\tthis->level[e.to] = this->level[from] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll DfsFindPath(ll v, ll t, ll f){\n\t\tif (v == t) return f;\n\n\t\tfor (ll &i = iter[v]; i < (ll)this->G[v].size(); i++){\n\t\t\tEdge &e = this->G[v][i];\n\t\t\tif (e.cap > 0  &&  this->level[v] < this->level[e.to]){\n\t\t\t\tll d = this->DfsFindPath(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tthis->G[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n};\n\n\nclass DinicMatching{\nprivate:\n\tDinicMethod dm;\n\tll sNum, tNum, s, t;\npublic:\n\tDinicMatching(ll sNum, ll tNum): dm(sNum+tNum+2), sNum(sNum), tNum(tNum),\n\t\ts(sNum+tNum), t(sNum+tNum+1)\n\t{\n\t\tREP(i, sNum){ dm.Link(this->s, i, 1); }\n\t\tREP(i, tNum){ dm.Link(i+sNum, this->t, 1); }\n\t}\n\n\tvoid Link(ll sIdx, ll tIdx){ dm.Link(sIdx, tIdx + this->sNum, 1); }\n\n\tvector<pair<ll, ll>> GetMatch(){ //最大マッチングを得る\n\t\tll matchNum = dm.MaxFlow(this->s, this->t);\n\t\tvector<pair<ll, ll>> matches;\n\t\tREP(v, this->sNum){//ソース側ノードをなめる\n\t\t\tEACH(e, dm.G[v]){\n\t\t\t\tif (e.cap == 0 && e.to != this->s){\n\t\t\t\t\tmatches.emplace_back(v, e.to - sNum);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn move(matches);\n\t}\n};\n\n\nvoid solve()\n{\n\tll X, Y, E;  cin >> X >> Y >> E;\n\tDinicMatching dm(X, Y);\n\trep(i, 0, E-1){\n\t\tll x, y;  cin >> x >> y;\n\t\tdm.Link(x, y);\n\t}\n\n\tvpll matches = dm.GetMatch();\n\tll ans = Size(matches);\n\tcout << ans << '\\n';\n}\n\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>  //{{{\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define ALL(c) (c).begin(), (c).end()\n#define DUMP(x) std::cerr << #x << ':' << x << '\\n';\n\ntypedef long long ll;\n// clang-format off\ntemplate<typename T,typename U>inline bool chmax(T&x,U a){if(x>=a)return 0;x=a;return 1;}\ntemplate<typename T,typename U>inline bool chmin(T&x,U a){if(x<=a)return 0;x=a;return 1;}\ninline int in(){int x;scanf(\"%d\", &x);return x;}\n// clang-format on\n// }}}\n//{{{ graph.hpp\n#ifndef INCLUDE_GRAPH_HPP\n#define INCLUDE_GRAPH_HPP\n#include <vector>\n#include <climits>\nnamespace orliv {\nnamespace graph {\nstruct Edge {\n  typedef int weight_type;\n  static constexpr weight_type INF =\n      std::numeric_limits<weight_type>::max() - 100;\n\n  int from, to;\n  weight_type w;\n  Edge(int from, int to, weight_type w = 1) : from(from), to(to), w(w) {}\n  bool operator<(const Edge& rhs) const {\n    if (w != rhs.w) return w > rhs.w;\n    if (from != rhs.from) return from < rhs.from;\n    return to < rhs.to;\n  }\n};\n\ntypedef Edge::weight_type Weight;\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Weight> Weights;\ntypedef std::vector<int> Path;\ntypedef std::vector<int> Nodes;\n}\ntypedef std::vector<graph::Edges> Graph;\n}\n#endif\n//}}}\n// {{{ dinic.cc\n// verify AOJ GRL_6_A\n#ifndef INCLUDE_GRAPH_HPP\n#include \"graph.hpp\"\n#endif\n#include <queue>\n\nnamespace orliv {\nnamespace graph {\nstruct Dinic {\n  struct REdge {\n    int rev;\n    int to;\n    int from;\n    Edge::weight_type cap;\n    REdge(const Edge& edge, int rev)\n        : rev(rev), to(edge.to), from(edge.from), cap(edge.w) {}\n  };\n  typedef std::vector<REdge> REdges;\n  typedef std::vector<REdges> RGraph;\n  RGraph G;\n  std::vector<int> level, iter;\n\n  Dinic(int V) : G(V), level(V), iter(V) {}\n\n  template <typename... Types>\n  void add(Types... args) {\n    Edge e(std::forward<Types>(args)...);\n    G[e.from].emplace_back(e, G[e.to].size());\n    Edge r(e.to, e.from, 0);\n    G[r.from].emplace_back(r, G[r.to].size() - 1);\n  }\n  int getFlow(int s, int t) {\n    int flow = 0;\n    while (1) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      std::fill(iter.begin(), iter.end(), 0);\n      for (int f; f = dfs(s, t, Edge::INF), f > 0; flow += f)\n        ;\n    }\n  }\n\n private:\n  void bfs(int s) {\n    std::fill(level.begin(), level.end(), -1);\n    std::queue<int> Q;\n    level[s] = 0;\n    for (Q.push(s); !Q.empty(); Q.pop()) {\n      auto v = Q.front();\n      for (const auto& e : G[v]) {\n        if (e.cap <= 0) continue;\n        if (level[e.to] >= 0) continue;\n        level[e.to] = level[v] + 1;\n        Q.push(e.to);\n      }\n    }\n  }\n  int dfs(int v, int t, int f) {\n    if (v == t) return f;\n    for (int& i = iter[v]; i < G[v].size(); i++) {\n      auto& e = G[v][i];\n      if (e.cap <= 0) continue;\n      if (level[v] >= level[e.to]) continue;\n      int d = dfs(e.to, t, std::min(f, e.cap));\n      if (d <= 0) continue;\n      e.cap -= d;\n      G[e.to][e.rev].cap += d;\n      return d;\n    }\n    return 0;\n  }\n};\n}\n}\n//}}}\n\nusing namespace std;\n\nint main() {\n  int X = in(), Y = in(), E = in();\n  orliv::graph::Dinic dinic(X + Y + 2);\n  for (int i = 0; i < E; i++) {\n    int x = in(), y = in();\n    dinic.add(x, X + y);\n  }\n  for (int x = 0; x < X; x++) dinic.add(X + Y, x);\n  for (int y = 0; y < Y; y++) dinic.add(X + y, X + Y + 1);\n  cout << dinic.getFlow(X + Y, X + Y + 1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n//O(VE)\n\nclass BipartiteMatching {\nprivate:\n  int V;\n  vector<int> match;\n  vector<vector<int>> G;\n  vector<bool> used;\n\n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  bool dfs(int v) {\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n      int u = G[v][i], w = match[u];\n      if (w < 0 || ((!used[w]) && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int res = 0;\n    fill(match.begin(), match.end(), -1);\n    for (int v = 0; v < V; v++) {\n      if (match[v] < 0) {\n        fill(used.begin(), used.end(), 0);\n        if (dfs(v)) res++;\n      }\n    }\n    return res;\n  }\n\npublic:\n  BipartiteMatching(int N) : V(N), G(N, vector<int>()) {\n    match.resize(V);\n    used.resize(V);\n  }\n\n  void addEdge(int u, int v) { return add_edge(u, v); }\n  int getNum() { return bipartite_matching(); }\n};\n\nsigned main() {\n  int X, Y, E;\n  cin >> X >> Y >> E;\n\n  BipartiteMatching bm(X + Y);\n\n  while (E--) {\n    int x, y;\n    cin >> x >> y;\n    bm.addEdge(x, X + y);\n  }\n\n  cout << bm.getNum() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define N 205\n\nint n, m, e;\n\nbitset<N> vis;\nvector<int> to[N];\narray<int, N> match;\n\nbool hungary(int u)\n{\n\tif (u == -1)\n\t\treturn true;\n\t\n\tfor (auto v : to[u])if (!vis[v])\n\t{\n\t\tvis.set(v);\n\t\tif (hungary(match[v]))\n\t\t\treturn match[v] = u, true;\n\t}\n\t\t\t\n\treturn false;\n}\n\nsigned main(void)\n{\n\tcin >> n >> m >> e;\n\t\n\tfor (int i = 1, x, y; i <= e; ++i)\n\t{\n\t\tcin >> x >> y; y += n;\n\t\tto[x].push_back(y);\n\t\tto[y].push_back(x);\n\t}\n\t\n\tfor (auto &i : match)\n\t\ti = -1;\n\t\n\tint answer = 0;\n\t\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tvis.reset();\n\t\tif (hungary(i))\n\t\t\t++answer;\n\t}\n\t\n\tcout << answer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdlib>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <stdio.h>\n#include <ctype.h>\n#include <string.h>\nusing namespace std;\n#define pie 3.141592653589793238462643383279\n#define mod 1000000007\n#define INF 10000000000000000\n#define int long long\n#define all(vec) vec.begin(),vec.end()\n#define P pair<int,int>\n#define S second\n#define F first\n\nint gcd(int x, int y) {\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\nint lcm(int x, int y) {\n\treturn x / gcd(x, y)*y;\n}\nbool prime(int x) {\n\tfor (int i = 2; i <= sqrt(x); i++) {\n\t\tif (x%i == 0)return false;\n\t}\n\treturn true;\n}\nint kai(int x, int y) {\n\tint res = 1;\n\tfor (int i = x - y + 1; i <= x; i++) {\n\t\tres *= i; res %= mod;\n\t}\n\treturn res;\n}\nint mod_pow(int x, int y, int m) {\n\tint res = 1;\n\twhile (y > 0) {\n\t\tif (y & 1) {\n\t\t\tres = res * x % m;\n\t\t}\n\t\tx = x * x % m;\n\t\ty >>= 1;\n\t}\n\treturn res;\n}\n\nint comb(int x, int y) {\n\tif (y > x)return 0;\n\treturn kai(x, y) * mod_pow(kai(y, y), mod - 2, mod) % mod;\n}\n\nstruct edge { int to, cap, rev; };\n\nvector<edge> g[210];\nbool used[210];\n\nvoid add_edge(int from, int to, int cap) {\n\tg[from].push_back(edge{ to,cap,(int)g[to].size() });\n\tg[to].push_back(edge{ from,0,(int)g[from].size() - 1 });\n}\n\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0; i < (int)g[v].size(); i++) {\n\t\tedge &e = g[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s, int t) {\n\tint flow = 0;\n\twhile (1) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, INF);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n\nint x, y, m;\n\nsigned main() {\n\tcin >> x >> y >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tint a, b; cin >> a >> b;\n\t\tadd_edge(a, x + b, 1);\n\t}\n\tfor (int i = 0; i < x; i++)add_edge(x + y, i, 1);\n\tfor (int i = 0; i < y; i++)add_edge(x + i, x + y + 1, 1);\n\tcout << max_flow(x + y, x + y + 1) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, start, end) for (long long i = start; i < end; ++i)\n#define repreverse(i, start, end) for (long long i = start; i >= end; --i)\n#define all(x) (x).begin(), (x).end()\n#define len(x) ((long long)(x).size())\n#define lcm(a, b) ((a) / __gcd((a), (b)) * (b))\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vll = vector<ll>;\nusing vllvll = vector<vll>;\nusing pll = pair<ll, ll>;\ntemplate<class T>void print1d(T x,ll n=-1){if(n==-1)n=x.size();rep(i,0,n){cout<<x[i]<<' ';}cout<<'\\n';}\ntemplate<class T>void print2d(T x,ll r=-1,ll c=-1){if(r==-1)r=x.size();if(c==-1)c=x[0].size();rep(i,0,r)print1d(x[i],c);}\ntemplate<class T, class U>bool haskey(T mp, U key) { return mp.find(key) != mp.end(); }\ntemplate<class T, class U>bool isin(T el, U container) { return find(all(container), el) != container.end(); }\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<class T>bool even(T n) { return ! (n & 1); }\ntemplate<class T>bool odd(T n) { return n & 1; }\ntemplate<class T>ld deg2rad(T deg) { return M_PI * deg / 180.0; }\ntemplate<class T>ld rad2deg(T rad) { return 180.0 * rad / M_PI; }\nll intpow(ll a,ll n){ll p=1;while(n){if(n&1)p*=a;a*=a;n>>=1;}return p;}\nconst long double pi = M_PI;\nconst long long big = 1LL << 50;\nconst long long inf = 1LL << 60;\nconst long long mod = 1e9 + 7;\n\nconst int MAX = 100010;\n\nstruct Edge\n{\n        long long to, cap, rev;\n};\n\nstd::vector<std::vector<Edge> > flowGraph(MAX);\nstd::vector<bool> used(MAX);\n\nvoid add_edge(long long from, long long to, long long cap)\n{\n        flowGraph[from].push_back((Edge){to, cap, (long long)flowGraph[to].size()});\n        flowGraph[to].push_back((Edge){from, 0, (long long)flowGraph[from].size()-1});\n}\n\nint _dfs(long long v, long long t, long long f)\n{\n        if (v == t) return f;\n        used[v] = true;\n        for (long long i = 0; i < (long long)flowGraph[v].size(); ++i) {\n                Edge &e = flowGraph[v][i];\n                if (! used[e.to] and e.cap > 0) {\n                        long long d = _dfs(e.to, t, min(f, e.cap));\n                        if (d > 0) {\n                                e.cap -= d;\n                                flowGraph[e.to][e.rev].cap += d;\n                                return d;\n                        }\n                }\n        }\n        return 0;\n}\n\nint max_flow(long long s, long long t)\n{\n        long long flow = 0;\n        while (true) {\n                std::fill(used.begin(), used.end(), false);\n                long long f = _dfs(s, t, 1LL<<60);\n                if (f == 0) return flow;\n                flow += f;\n        }\n}\n\n\n\nint main()\n{\n        ll X, Y, E;\n        cin >> X >> Y >> E;\n\n\n        vllvll connected(X, vll(Y));\n\n        rep(i, 0, E) {\n                ll xx, yy;\n                cin >> xx >> yy;\n                connected[xx][yy] = 1;\n        }\n\n        ll left = MAX-2;\n        ll right = MAX-1;\n\n        rep(i, 0, X) {\n                add_edge(left, i, 1);\n        }\n\n        rep(i, 0, X) {\n                rep(j, 0, Y) {\n                        if (connected[i][j]) {\n                                add_edge(i, X+j, 1);\n                        }\n                }\n        }\n\n        rep(i, 0, Y) {\n                add_edge(X+i, right, 1);\n        }\n\n        cout << max_flow(left, right) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \nconstexpr int N = 1e4 + 10, INF = INT_MAX / 4;\n \nclass BipartiteMatching { // O( ( V + E ) * sqrt( V ) )\n public: \n  vector< int > G[ N ]; // N = total number of nodes = n + m\n  int n, m, match[ N ], dist[ N ];\n  // n: number of nodes on left side, nodes are numbered 1 to n\n  // m: number of nodes on right side, nodes are numbered n+1 to n+m\n  // G = NIL[0] ??? G1[G[1---n]] ??? G2[G[n+1---n+m]]\n  bool BFS() {\n    queue< int > Q;\n    for (int i = 1; i <= n; i++ ) {\n      if ( match[ i ] == 0 ) {\n        dist[ i ] = 0;\n        Q.push( i );\n      }\n      else dist[ i ] = INF;\n    }\n    dist[ 0 ] = INF;\n    while ( !Q.empty() ) {\n      int u = Q.front(); Q.pop();\n      if ( dist[ u ] < dist[ 0 ] )\n        for(int v : G[u])\n          if ( dist[ match[ v ] ] == INF ) {\n            dist[ match[ v ] ] = dist[ u ] + 1;\n            Q.push( match[ v ] );\n          }\n    }\n    return ( dist[ 0 ] != INF );\n  }\n  bool DFS( int u ) {\n    if ( u != 0 ) {\n      for(int v : G[u])\n        if ( dist[ match[ v ] ] == dist[ u ] + 1 and DFS( match[ v ] ) ) {\n          match[ v ] = u;\n          match[ u ] = v;\n          return true;\n        }\n      dist[ u ] = INF;\n      return false;\n    }\n    return true;\n  }\n  int Solve() {\n    int matching = 0;\n    fill_n(match, n+m+1, 0);\n    while ( BFS() )\n      for (int i = 1; i <= n; i++ )\n        if ( match[ i ] == 0 and DFS( i ) ) matching++;\n    return matching;\n  }\n  void AddEdge( int u, int v ) { G[ u ].push_back( n + v ); }\n} ob;\n \nint main() {\n  int E; scanf(\"%d %d %d\", &ob.n, &ob.m, &E);\n  for(int i = 0; i < E; ++i) {\n    int x, y; scanf(\"%d %d\", &x, &y);\n    ob.AddEdge(x+1, y+1);\n  }\n  printf(\"%d\\n\", ob.Solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// statics\nusing namespace std;\nusing int64 = long long;\nusing PAIR = pair<int, int>;\nconstexpr int INF = 1 << 30;\nconstexpr int64 LINF = 1LL << 60;\nconstexpr int MOD = 1e9 + 7;\nconstexpr int MAX_N = 1e5 + 1;\nconstexpr int MAX_V = 575;\n\n// init/input\n#define int int64\n#define INIT ios::sync_with_stdio(false);cin.tie(0);\n#define VAR(type, ...) type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T &t) {cin>>t;}\ntemplate<typename First, typename...Rest> void MACRO_VAR_Scan(First &first, Rest&...rest) {cin>>first;MACRO_VAR_Scan(rest...);}\n#define VEC(type, c, n) vector<type> c(n);for(auto &&i:c)cin>>i;\n\n// out\n#define OUT(dist) cout<<(dist);\n#define FOUT(n, dist) cout <<fixed<<setprecision(n)<<(dist);\n#define SP cout<<\" \";\n#define BR cout<<\"\\n\";\n#define debug(x) cerr << #x << \":\" << (x);BR;\n\n// utility\n#define ALL(a) (a).begin(), (a).end()\n#define EACH(i, a) for(auto &&i:(a))\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=0;--i)\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n\nint V;\nvector< int > G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to) {\n  G[from].push_back(to);\n  G[to].push_back(from);\n}\n\nint dfs(int v) {\n  used[v] = true;\n\n  for (int i = 0; i < (int)G[v].size(); ++i) {\n    int to = G[v][i], w = match[to];\n    if (w < 0 || !used[w] && dfs(w)) {\n      match[v] = to;\n      match[to] = v;\n      return true;\n    }\n  }\n}\n\n// 二部グラフの最大マッチング\nint bipartie_matching() {\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  for (int v = 0; v < V; ++v) {\n    if (match[v] < 0) {\n      memset(used, 0, sizeof(used));\n      if (dfs(v) > 0) {\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nsigned main() {\n  INIT;\n\n  VAR(int, X, Y, E);\n  REP(ei, E) {\n    VAR(int, from, to);\n    add_edge(from, X + to);\n  }\n  V = X + Y;\n  \n  OUT(bipartie_matching())BR;\n\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define REP(i, n) for (ll i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (ll i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define fi first\n#define se second\n#define pb push_back\n#define debug(x) cerr << #x << \": \" << (x) << endl\n#define debug2(x, y) cerr << #x << \": \" << (x) << \" \" << #y << \": \" << y << endl;\n#define int long long\nusing namespace std;\nusing II = pair<int, int>;\nusing VII = vector<II>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VVVI = vector<VVI>;\ntemplate <class T = int> inline T in() { T x; cin >> x; return x; }\ntemplate <class T = int> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T = int> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<T>& d) { int n = d.size(); REP (i, n) s << d[i] << \" \"; return s; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<vector<T>>& dd) { for (vector<T> d: dd) s << d << endl; return s; }\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nconst int MOD = 1e9 + 7;\n\n// Dinic法 O(E * V^2)\nclass Graph {\n  int t; // ゴール\n  VI level, iter;\n  void bfs(int s) {\n    for (int i = 0; i < level.size(); i++) level[i] = -1;\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()) {\n      int v = que.front(); que.pop();\n      for (int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  int dfs(int v, int f) {\n    if (v == t) return f;\n    for (int &i = iter[v]; i < G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n        int d = dfs(e.to, min(f, e.cap));\n        if (d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\npublic:\n  int V;\n  struct edge {int to, cap, rev; };\n  vector<vector<edge>> G;\n  Graph(int V) : V(V), G(V), level(V), iter(V) {}\n\n  void add_edge(int from, int to, int cap) {\n    G[from].push_back(edge{ to, cap, (int)G[to].size() });\n    G[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n  }\n\n  int max_flow(int s, int t) {\n    int flow = 0;\n    this->t = t;\n    while (1) {\n      bfs(s);\n      if (level[t] < 0) return flow;\n      for (int i = 0; i < iter.size(); i++) iter[i] = 0;\n      int f;\n      while ((f = dfs(s, (1LL << 60))) > 0) {\n        flow += f;\n      }\n    }\n  }\n};\n\nsigned main() {\n  int X, Y, E; cin >> X >> Y >> E;\n  Graph g(X + Y + 2);\n  while (E--) {\n    int x, y; cin >> x >> y;\n    g.add_edge(x, X + y, 1);\n  }\n  int s = X + Y;\n  int t = X + Y + 1;\n  REP (i, X) {\n    g.add_edge(s, i, 1);\n  }\n  REP (i, Y) {\n    g.add_edge(X + i, t, 1);\n  }\n  cout << g.max_flow(s, t) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <list>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int maxv=2*(100+10);\nint N,M,E;\nvector<int> g[maxv];\nint vis[maxv];\nint match[maxv];\nvoid add_edge(int from,int to)\n{\n    g[from].push_back(to);\n    g[to].push_back(from);\n}\nbool dfs(int t)\n{\n    vis[t]=1;\n    for(int i=0;i<g[t].size();i++)\n    {\n        int v=g[t][i],w=match[v];\n        if(w<0||(!vis[w]&&dfs(w)))\n        {\n            match[t]=v;\n            match[v]=t;\n            return true;\n        }\n    }\n    return false;\n}\nvoid binrary_match()\n{\n    memset(match,-1,sizeof(match));\n    int res=0;\n    for(int i=0;i<N+M;i++)\n    {\n        if(match[i]<0)\n        {\n            memset(vis,0,sizeof(vis));\n            if(dfs(i)) res++;\n        }\n    }\n    printf(\"%d\\n\",res);\n}\nint main()\n{\n//    freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d%d%d\",&N,&M,&E);\n    int u,v;\n    for(int i=0;i<E;i++)\n    {\n        scanf(\"%d%d\",&u,&v);\n        add_edge(u,N+v);\n    }\n    binrary_match();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int MAX_N=500;\n\nstruct edge{\n\tint to,cap,rev;\n};\n\nvector<edge> G[MAX_N];\nvector<int> check(MAX_N,0);\n\nint dfs(int v,int t, int f ){\n\tif(v==t){return f;}\n\tcheck[v]=1;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(check[e.to]==0 && e.cap > 0){\n\t\t\tint ff =dfs(e.to,t,min(f,e.cap));\n\t\t\tif(ff>0){\n\t\t\t\te.cap -= ff;\n\t\t\t\tG[e.to][e.rev].cap += ff;\n\t\t\t\treturn ff;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxflow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tfill(check.begin(),check.end(),0);\n\t\tint f = dfs(s,t,INT_MAX);\n\t\tif(f==0){return flow;}\n\t\tflow += f;\n\t}\n}\n\nint main(){\n\tint X,Y,E,s,t;\n\tcin >> X >> Y >> E ;\n\t\n\tfor(int i=0;i<E;i++){\n\t\tcin >> s >> t ;\n\t\tG[s].push_back((edge){X+t,1,G[t].size()});\n\t\tG[X+t].push_back((edge){s,0,G[s].size()-1});\n\t}\n\t\n\tfor(int i=0;i<X;i++){\n\t\tG[X+Y].push_back((edge){i,1,G[i].size()});\n\t\tG[i].push_back((edge){X+Y,0,G[X+Y].size()-1});\n\t}\n\t\n\tfor(int i=X;i<X+Y;i++){\n\t\tG[i].push_back((edge){X+Y+1,1,G[X+Y+1].size()});\n\t\tG[X+Y+1].push_back((edge){i,0,G[i].size()-1});\n\t}\n\t\n\tfor(int k=0;k<X+Y+2;k++){\n\t\tfor(int i=0;i<G[k].size();i++){\n\t\t\tcout << G[k][i].to << \" \" <<G[k][i].cap << endl;\n\t\t}\n\t\tcout <<endl;\n\t}\n\t\n\tcout << maxflow(X+Y,X+Y+1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int MAX_N=202;\n\nstruct edge{\n\tint to,cap,rev;\n};\n\nvector<edge> G[MAX_N];\nvector<int> check(MAX_N,0);\n\nint dfs(int v,int t, int f ){\n\tif(v==t){return f;}\n\tcheck[v]=1;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(check[e.to]==0 && e.cap > 0){\n\t\t\tint ff =dfs(e.to,t,min(f,e.cap));\n\t\t\tif(ff>0){\n\t\t\t\te.cap -= ff;\n\t\t\t\tG[e.to][e.rev].cap += ff;\n\t\t\t\treturn ff;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxflow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tfill(check.begin(),check.end(),0);\n\t\tint f = dfs(s,t,INT_MAX);\n\t\tif(f==0){return flow;}\n\t\tflow += f;\n\t}\n}\n\nint main(){\n\tint X,Y,E,s,t;\n\tcin >> X >> Y >> E ;\n\t\n\tfor(int i=0;i<E;i++){\n\t\tcin >> s >> t ;\n\t\tG[s].push_back((edge){X+t,1,G[t].size()});\n\t\tG[X+t].push_back((edge){s,0,G[s].size()-1});\n\t}\n\t\n\tfor(int i=0;i<X;i++){\n\t\tG[X+Y].push_back((edge){i,1,G[i].size()});\n\t\tG[i].push_back((edge){X+Y,0,G[X+Y].size()-1});\n\t}\n\t\n\tfor(int i=X;i<X+Y;i++){\n\t\tG[i].push_back((edge){X+Y+1,1,G[X+Y+1].size()});\n\t\tG[X+Y+1].push_back((edge){i,0,G[i].size()-1});\n\t}\n\t/*\n\tint k=7;\n\tfor(int i=0;i<G[k].size();i++){\n\t\tcout << G[k][i].to << endl;\n\t}\n\t*/\n\t\n\tcout << maxflow(X+Y,X+Y+1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\nconst int MAX_V = 210; //MAX_X + MAX_Y\nconst int MAX_X = 105;\nconst int MAX_Y = 105;\n\nclass Edge{\n    public:\n        int to, cap, rev;\n};\n\ntypedef vector<vector<Edge>> AdjList;\nAdjList G(MAX_V);\nbool used[MAX_V];\n\nvoid addEdge(int from, int to, int cap){\n    G[from].emplace_back(Edge{to, cap, static_cast<int>(G[to].size())});\n    G[to].emplace_back(Edge{from, 0, static_cast<int>(G[from].size() - 1)});\n}\n\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    rep(i,G[v].size()){\n        Edge &e = G[v][i];\n        if(not used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxFlow(int s, int t){\n    int flow = 0;\n    while(true){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\nint bipartiteMatching(int x, int y, bool edge[MAX_X][MAX_Y]){\n    int s = x + y, t = s + 1; //set x : 0 ~ x-1, set y : x ~ x+y-1\n\n    rep(i,x) addEdge(s, i, 1); //s??¨??????x????????¶\n    rep(i,y) addEdge(x + i, t, 1); //??????y??¨t????????¶\n\n    rep(i,x) rep(j,y) if(edge[i][j]) addEdge(i, x + j, 1); //??????x??¨??????y????????¶\n\n    return maxFlow(s, t);\n}\n\nint main(){\n    int x, y, e;\n    cin >> x >> y >> e;\n\n    bool edge[MAX_X][MAX_Y] = {0};\n    rep(i,e){\n        int a, b;\n        cin >> a >> b;\n        edge[a][b] = 1;\n    }\n    cout << bipartiteMatching(x, y, edge) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\nusing namespace std;\n\nstruct edge{ int to,cap,rev; };\n\nint V,E;\nint X,Y;\nvector<edge> G[202];\nbool used[202];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to] && e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(used,used+(X+Y+2),0);\n    int f=dfs(s,t,inf);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nint main()\n{\n  int x,y;\n  cin>>X>>Y>>E;\n  int s=X+Y;\n  int t=s+1;\n  for(int i=0;i<X;i++){\n    add_edge(s,i,1);\n  }\n  for(int i=0;i<Y;i++){\n    add_edge(X+i,t,1);\n  }\n  for(int i=0;i<E;i++){\n    cin>>x>>y;\n    add_edge(x,X+y,1);\n  }\n  cout<<max_flow(s,t)<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"MyDisjointset.h\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\nusing namespace std;\ntypedef pair<int, int> P; typedef long long int ll; typedef vector <int> vecint; typedef vector <vecint> dvecint; typedef vector <dvecint> vecdvecint; typedef vector <vector <dvecint> > dvecdvecint;\nconst int INF = 100000000;\nstruct edge {\n\tint to, cap, rev;\n};\nint level[202]; vector <edge> G[202];\nvecint to[102];\nvoid addedge(int from, int to, int cap) {\n\tedge e1 = { to, cap, G[to].size() };\n\tedge e2 = { from, 0, G[from].size()};\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nvoid bfs(int s) {\n\tfill(level, level + 202, -1);\n\tqueue<int> q;\n\tq.push(s);\n\tlevel[s] = 0;\n\twhile (!q.empty()) {\n\t\tint f = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[f].size(); i++) {\n\t\t\tedge e = G[f][i];\n\t\t\tif (level[e.to] < 0 && e.cap > 0) {\n\t\t\t\tlevel[e.to] = level[f] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int s, int t, int f) {\n\tif (s == t) return f;\n\tfor (int i = 0; i < G[s].size(); i++) {\n\t\tedge &e = G[s][i];\n\t\tif (level[e.to] > level[s] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main() {\n\tint nx, ny, ne;\n\tcin >> nx >> ny >> ne;\n\tfor (int i = 0; i < ne; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tto[x + 1].push_back(y + nx + 1);\n\t}\n\tfor (int i = 1; i <= nx; i++)\n\t\tfor (int j = 0; j < to[i].size(); j++)\n\t\t\taddedge(i, to[i][j], 1);\n\tint t = 1 + nx + ny;\n\tfor (int i = 1; i <= nx; i++)\n\t\taddedge(0, i, 1);\n\tfor (int i = nx + 1; i <= nx + ny; i++)\n\t\taddedge(i, t, 1);\n\tint flow = 0;\n\twhile (true) {\n\t\tbfs(0);\n\t\tif (level[t] < 0) break;\n\t\tint f;\n\t\twhile ((f = dfs(0, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n\tcout << flow << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n//typedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\ntypedef vector<vector<int>> mat;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nvector<vector<int>> G;\nint match[210];\nbool used[210];\n\nbool dfs(int v)\n{\n\tused[v] = true;\n\trep(i, 0, SZ(G[v]))\n\t{\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(int X)\n{\n\tint res = 0;\n\trep(i, 0, 210)match[i] = -1;\n\trep(v, 0, X)\n\t{\n\t\tif (match[v] < 0)\n\t\t{\n\t\t\trep(i, 0, 210)used[i] = false;\n\t\t\tif (dfs(v))\n\t\t\t{\n\t\t\t\tcout << v << endl;\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint X, Y, E, x, y;\n\tcin >> X >> Y >> E;\n\tG.resize(X + Y);\n\twhile (E--)\n\t{\n\t\tcin >> x >> y;\n\t\tG[x].push_back(X + y);\n\t\tG[X + y].push_back(x);\n\t}\n\n\tcout << bipartite_matching(X) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n#include <cstring>          // memset()\n#include <vector>\n#include <algorithm>        // min()\n\nusing namespace std;\nstatic const int MAX_X = 100;\nstatic const int MAX_Y = 100;\nstatic const int MAX_V = MAX_X + MAX_Y + 2;\nstatic const int INF = 100000000;\n\ntypedef struct edge_tbl\n{\n\tint to, cap;\n\tunsigned long rev;\n} edge;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nint\ndfs(int v, int t, int f)\n{\n\tif (v == t)\n\t\treturn f;\n\n\tused[v] = true;\n\tfor (unsigned int i = 0; i < G[v].size(); ++i)\n\t{\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0)\n\t\t{\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0)\n\t\t\t{\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint\nmax_flow(int s, int t)\n{\n\tint flow = 0;\n\twhile (true)\n\t{\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, INF);\n\t\tif (f == 0)\n\t\t\treturn flow;\n\n\t\tflow += f;\n\t}\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint X, Y, E;\n\tint x, y;\n\n\tscanf(\"%d %d %d\", &X, &Y, &E);\n\tint s = X + Y, t = s + 1;\n\tfor (int i = 0; i < X; ++i)\n\t{\n\t\tG[s].push_back((edge){i, 1, G[i].size()});\n\t\tG[i].push_back((edge){s, 0, G[s].size() - 1});\n\t}\n\n\tfor (int i = 0; i < Y; ++i)\n\t{\n\t\tG[X + i].push_back((edge){t, 1, G[t].size()});\n\t\tG[t].push_back((edge){X + i, 0, G[X + i].size() - 1});\n\t}\n\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tG[x].push_back((edge){X + y, 1, G[X + y].size()});\n\t\tG[X + y].push_back((edge){x, 0, G[x].size() - 1});\n\t}\n\n\tprintf(\"%d\\n\", max_flow(s, t));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\n#define MAX_V 202\n#define MAX_E 1000\nusing namespace std;\nstruct edge {\n\tint to, cap, rev;\n\tedge(int to_, int cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {};\n};\n\nint V, E;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid AddEdge(int from, int to, int cap) {\n\tG[from].push_back(edge(to, cap, G[to].size()));\n\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid BFS(int s) {\n\tfill(level, level + V, -1);\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint DFS(int v, int t, int f) {\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = DFS(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint Dinic(int s, int t) {\n\tint flow = 0;\n\twhile (true) {\n\t\tBFS(s);\n\t\tif (level[t] < 0) return flow;\n\t\tfill(iter, iter + V, 0);\n\t\tint f;\n\t\twhile ((f = DFS(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint X, Y;\n\tcin >> X >> Y >> E;\n\tV = X + Y + 2;\n\tfor (int i = 0; i < X; i++) {\n\t\tAddEdge(X + Y, i, 1);\n\t}\n\tfor (int i = 0; i < Y; i++) {\n\t\tAddEdge(X + i, X + Y + 1, 1);\n\t}\n\tfor (int i = 0, x, y; i < E; i++) {\n\t\tcin >> x >> y;\n\t\tAddEdge(x, X + y, 1);\n\t}\n\tcout << Dinic(X + Y, X + Y + 1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* ---------- STL Libraries ---------- */\n// IO library\n#include <cstdio>\n#include <fstream>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n#include <random>\n#include <cstring>\n\n// container library\n#include <array>\n#include <bitset>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <stack>\n\n/* ---------- Namespace ---------- */\nusing namespace std;\n\n/* ---------- Type ---------- */\nusing ll = long long;\n#define int ll\n#define P pair<ll, ll>\n\n/* ---------- Constants  */\nconst double PI = 3.141592653589793238462643383279;\nconst ll MOD = 1e9 + 7;\nconst int INF = 1LL << 55;\n\nstruct FordFulkerson {\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n\n    int dfs(int s, int t, int mn) {\n        if (s == t) return mn;\n        visited[s] = true;\n        for (int i = 0; i < table[s].size(); i++) {\n            edge &e = table[s][i];\n            if (visited[e.to] || e.cap <= 0) continue;\n            int diff = dfs(e.to, t, min(mn, e.cap));\n            if (diff > 0) {\n                e.cap -= diff;\n                table[e.to][e.rev].cap += diff;\n                return diff;\n            }\n        }\n        return 0;\n    }\n\n    int V;\n    vector<vector<edge> > table;\n    vector<bool> visited;\npublic:\n    FordFulkerson(int v) {\n        V = v;\n        table.resize(V);\n        visited.resize(V);\n    }\n\n    void add_edge(int from , int to, int cap) {\n        table[from].push_back((edge){to, cap, (int) table[to].size()});\n        table[to].push_back((edge){from, 0, (int) table[from].size() - 1});\n    }\n\n    int calc(int s, int t) {\n        int flow = 0;\n        while (true) {\n            fill(visited.begin(), visited.end(), false);\n            int f = dfs(s, t, INF);\n            if (f == 0) break;\n            flow += f;\n        }\n        return flow;\n    }\n};\n\n\nsigned main() {\n    int X, Y, E;\n    cin >> X >> Y >> E;\n\n    FordFulkerson ff = FordFulkerson(X + Y + 2);\n    for (int i = 0; i < E; i++) {\n        int x, y;\n        cin >> x >> y;\n        ff.add_edge(x, X + y, 1);\n    }\n    for (int i = 0; i < X; i++) {\n        ff.add_edge(X + Y, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        ff.add_edge(X + i, X + Y + 1, 1);\n    }\n\n    cout << ff.calc(X + Y, X + Y + 1) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL=unsigned int;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define rep(i,n) for(UL i=0; i<(n); i++)\n\nstruct Edge{ UL u,v; UL c; UL r; };\n\nUL X,Y,M;\nUL S,T;\nUL N;\nvector<UL> E[202];\nvector<Edge> J;\n\nUL fD[202];\nUL fF[202];\nUL fAns;\n\nUL fDFS(UL p,UL c=10000000){\n if(p==T) return c;\n UL f=0;\n for(UL& i=fF[p]; i<E[p].size(); i++){\n  Edge& e = J[E[p][i]];\n  if(c-f==0) return f;\n  if(fF[e.v]) continue;\n  if(e.c==0) continue;\n  if(fD[e.v]!=fD[p]+1) continue;\n  UL tmp = fDFS(e.v,min(c-f,e.c));\n  e.c -= tmp; J[e.r].c += tmp;\n  f += tmp;\n }\n return f;\n}\n\nUL flow(){\n rep(i,N) fD[i]=~0u;\n fD[S]=0;\n queue<UL> Q; Q.push(S);\n while(Q.size()){\n  UL p=Q.front(); Q.pop();\n  for(UL j:E[p]){\n   if(fD[J[j].v]!=~0u) continue;\n   if(J[j].c==0) continue;\n   fD[J[j].v]=fD[p]+1;\n   Q.push(J[j].v);\n  }\n }\n rep(i,N) fF[i]=0;\n UL res=fDFS(S);\n fAns += res;\n return res;\n}\n\nvoid add_edge(UL u,UL v){\n  E[u].push_back(J.size());\n  J.push_back(Edge{u,v,1,(UL)J.size()+1});\n  E[v].push_back(J.size());\n  J.push_back(Edge{v,u,0,(UL)J.size()-1});\n}\n\nint main(){\n scanf(\"%u%u%u\",&X,&Y,&M);\n rep(i,M){\n  UL u,v; scanf(\"%u%u\",&u,&v); v+=X;\n  add_edge(u,v);\n }\n S=X+Y; T=S+1;\n N=T+1;\n rep(x,X) add_edge(S,x);\n rep(y,Y) add_edge(X+y,T);\n while(flow());\n printf(\"%u\\n\",fAns);\n return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define MP make_pair\n#define PB push_back\n#define ALL(x) (x).begin(),(x).end()\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define REP1(i,n) for(int i=1;i<(n);i++)\n#define REP2(i,d,n) for(int i=(d);i<(n);i++)\n#define RREP(i,n) for(int i=(n);i>=0;i--)\n#define CLR(a) memset((a),0,sizeof(a))\n#define MCLR(a) memset((a),-1,sizeof(a))\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI > VVI;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef pair<int,int> PII;\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double EPS = 1e-9;\n\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\nconst int MAX_V = 1000;\n\nclass BipartiteMatching {\npublic:\n    int V;\n    VI G[MAX_V];\n    int match[MAX_V];\n    bool used[MAX_V];\n\n    BipartiteMatching(int n){\n        V = n;\n    }\n\n    void add_edge(int u, int v){\n        G[u].PB(v);\n        G[v].PB(u);\n    }\n\n    bool dfs(int v){\n        used[v] = true;\n        REP(i, G[v].size()){\n            int u = G[v][i], w = match[u];\n            if(w < 0 || !used[w] && dfs(w)){\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    int solve(){\n        int res = 0;\n        memset(match, -1, sizeof(match));\n        REP(v, V){\n            if(match[v] < 0){\n                memset(used, 0, sizeof(used));\n                if(dfs(v)){\n                    res++;\n                }\n            }\n        }\n\n        return res;\n    }\n};\n\nint main(){\n    int x, y, e;\n    cin >> x >> y >> e;\n    BipartiteMatching bm(x+y);\n    REP(i, e){\n        int a,b;\n        cin >> a >> b;\n        b+=x;\n        bm.add_edge(a,b);\n    }\n\n    cout << bm.solve() << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n\tint to, flow, rev;\n\tEdge(int to, int flow, int rev) {\n\t\tthis->to = to;\n\t\tthis->flow = flow;\n\t\tthis->rev = rev;\n\t}\n};\n\ntypedef vector<int> Array;\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, int flow) {\n\tg[from].push_back(Edge(to, flow, g[to].size()));\n\tg[to].push_back(Edge(from, 0, g[from].size() - 1));\n}\n\nint dfs(Graph &g, int s, int t, int f, Array &dist, Array &iter) {\n\tif (s == t) return f;\n\t\n\tfor (int &i = iter[s]; i < g[s].size(); i++) {\n\t\tint ns = g[s][i].to;\n\t\tif (g[s][i].flow == 0 || dist[ns] != dist[s] + 1) continue;\n\t\t\n\t\tint res = dfs(g, ns, t, min(f, g[s][i].flow), dist, iter);\n\t\tif (res > 0) {\n\t\t\tg[s][i].flow -= res;\n\t\t\tg[ns][g[s][i].rev].flow += res;\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxflow(Graph g, int s, int t) {\n\tint n = g.size();\n\tint i, sumFlow = 0;\n\t\n\twhile (true) {\n\t\tArray dist(n, -1);\n\t\tqueue<int> que;\n\t\tque.push(s); dist[s] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tint pos = que.front(); que.pop();\n\t\t\tfor (i = 0; i < g[pos].size(); i++) {\n\t\t\t\tint npos = g[pos][i].to;\n\t\t\t\tif (dist[npos] == -1 && g[pos][i].flow > 0) {\n\t\t\t\t\tdist[npos] = dist[pos] + 1;\n\t\t\t\t\tque.push(npos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[t] == -1) break;\n\n\t\tArray iter(n, 0);\n\t\twhile (true) {\n\t\t\tint f = dfs(g, s, t, 1e+9, dist, iter);\n\t\t\tif (f == 0) break;\n\t\t\tsumFlow += f;\n\t\t}\n\t}\n\treturn sumFlow;\n}\n\nint x, y, m;\nint u, v;\nGraph g;\n\nint main() {\n\tint i;\n\t\n\tcin >> x >> y >> m;\n\tint n = x + y + 2;\n\tg.resize(n);\n\t\n\tfor (i = 0; i < m; i++) {\n\t\tcin >> u >> v;\n\t\tadd_edge(g, 1 + u, 1 + x + v, 1);\n\t}\n\t\n\tfor (i = 0; i < x; i++) add_edge(g, 0, 1 + i, 1);\n\tfor (i = 0; i < y; i++) add_edge(g, 1 + x + i, n - 1, 1);\n\tcout << maxflow(g, 0, n - 1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"MyDisjointset.h\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\nusing namespace std;\ntypedef pair<int, int> P; typedef long long int ll; typedef vector <int> vecint; typedef vector <vecint> dvecint; typedef vector <dvecint> vecdvecint; typedef vector <vector <dvecint> > dvecdvecint;\nconst int INF = 100000000;\nint match[200], used[200];\nvector <int> G[200];\nbool dfs(int v) {\n\tused[v] = 1;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tint u = G[v][i]; int w = match[u];\n\t\tif (w < 0 ||!used[w] && dfs(w) ){\n\t\t\tmatch[u] = v;\n\t\t\tmatch[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tint nx, ny, ne; cin >> nx >> ny >> ne;\n\tfor (int i = 0; i < ne; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tG[x].push_back(y + nx);\n\t\tG[y + nx].push_back(x);\n\t}\n\tint v = nx + ny;\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int i = 0; i < v; i++) {\n\t\tif (match[i] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(i))\n\t\t\t\tres++;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst D EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> PII;\n\nstruct  P {\n\tint x, y;\n\tP() {}\n\tP(int x_, int y_) : x(x_), y(y_) {}\n};\n\n/** GRL_7 : Matcing - Bipartite Matching **/\nconst int MAX_V = 1000;\n\nclass Flow {\npublic:\n\tstruct edge { int to, cap, rev; };\n\tvector<edge> G[MAX_V];\n\tbool used[MAX_V];\n\t\n\tvoid add_edge(int from, int to, int cap) {\n\t\tG[from].push_back((edge){to, cap, (int)G[to].size()});\n\t\tG[to].push_back((edge){from, 0, (int)G[from].size()-1});\n\t}\n\t\n\tint dfs(int v, int t, int f) {\n\t\tif (v==t) return f;\n\t\tused[v] = true;\n\t\tfor (int i=0; i<G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (!used[e.to] && e.cap>0) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d>0) {\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint max_flow(int s, int t) {\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tint f = dfs(s, t, INF);\n\t\t\tif (f==0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n};\n\nint main()\n{\n\tFlow F;\n\tint X, Y, E;\n\t// 0 ~ X-1 : X\n\t// X ~ X+Y-1 : Y\n\t// X+Y : s\n\t// X+Y+1 : t\n\tcin>>X>>Y>>E;\n\tint s=X+Y, t=s+1;\n\trep(i, E) {\n\t\tint x, y;\n\t\tcin>>x>>y;\n\t\tF.add_edge(x, X+y, 1);\n\t}\n\trep(i, X) {\n\t\tF.add_edge(s, i, 1);\n\t}\n\trep(i, Y) {\n\t\tF.add_edge(X+i, t, 1);\n\t}\n\t\n\tcout << F.max_flow(s, t) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // {{{\n// clang-format off\n#pragma GCC optimize \"O3,omit-frame-pointer,inline\"\n#pragma GCC target \"tune=native\"\n#define ARG4(_1, _2, _3, _4, ...) _4\n#define rep(...) ARG4(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define REP(i, a) FOR(i, 0, a)\n#define FOR(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(...) ARG4(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define RREP(i, a) RFOR(i, 0, a)\n#define RFOR(i, a, b) for (int i = (b)-1; i >= (int)(a); --i)\n#define ALL(c) (c).begin(), (c).end()\n#define TEN(n) ((ll)(1e##n))\n#define pb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define USE1(T) template<typename T>inline\n#define USE2(T, U) template<typename T,typename U>inline\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\n\ntemplate<typename T>using duo=std::pair<T,T>;\ntemplate<typename T>using vec=std::vector<T>;\nusing ll=long long;\nusing pii=duo<int>;\nUSE2(T,U)bool chmax(T&x,U a){return x<a&&(x=a,1);}\nUSE2(T,U)bool chmin(T&x,U a){return a<x&&(x=a,1);}\nUSE1(T=int)T in(){T x;std::cin>>x;return x;}\nUSE1(T=int)vec<T>in(int n){vec<T>v;v.reserve(n);rep(i,n)v.pb(in<T>());return v;}\nUSE1(T=int)vec<T>in(int n,T a){vec<T>v;v.reserve(n);rep(i,n)v.pb(in<T>()+a);return v;}\nUSE1(T)vec<std::pair<T,int>>enume(const vec<T>&x,int s=0){int N=x.size();vec<std::pair<T,int>>v;v.reserve(N);rep(i,N)v.pb(x[i],s+i);return v;}\nUSE1(T)vec<T>ndvec(T v,int n){return vec<T>(n,v);}\nUSE2(T,...Ts)auto ndvec(T v,int n,Ts...ns)->vec<decltype(ndvec(v,ns...))>{return ndvec(ndvec(v,ns...),n);}\nUSE1(T)void pr(T x){std::cout<<x<<'\\n';}\nUSE2(T,...Ts)void pr(T x,Ts...xs){std::cout<<x<<' ';pr(xs...);}\nUSE1(T=int)T rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}return x;}\nUSE1(T=int)void wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n// clang-format on\n// }}}\nstruct IoSetup { // {{{\n  IoSetup() {\n    std::ios::sync_with_stdio(0);\n    std::cin.tie(0);\n    std::cout.precision(10);\n    std::cerr.precision(10);\n  }\n} iosetup; //}}}\n#include <vector>\nnamespace copr {\ntemplate <typename CapacityType>\nstruct ResidualGraph {\n  struct REdge;\n  using REdges = std::vector<REdge>;\n  using RGraph = std::vector<REdges>;\n  using value_type = RGraph;\n  struct REdge {\n    using value_type = CapacityType;\n    value_type cap;\n    int to, rev;\n    const bool is_rev;\n    REdge(int to, value_type cap, int rev, bool is_rev)\n        : to(to), cap(cap), rev(rev), is_rev(is_rev) {}\n  };\n  const int V;\n  RGraph G;\n\n  ResidualGraph(int V) : V(V), G(V) {}\n  inline REdge& rev(const REdge& e) { return G[e.to][e.rev]; }\n  void add_edge(int from, int to, CapacityType cap) {\n    G[from].emplace_back(to, cap, G[to].size(), false);\n    G[to].emplace_back(from, 0, G[from].size() - 1, true);\n  }\n};\n} // namespace copr\nnamespace copr {\nResidualGraph<int> build_bipartite_graph(int X, int Y,\n                                         const std::vector<std::pair<int, int>>& edge) {\n  ResidualGraph<int> G(X + Y + 2);\n  for (int i = 0; i < X; i++) {\n    G.add_edge(0, 1 + i, 1);\n  }\n  for (int i = 0; i < Y; i++) {\n    G.add_edge(1 + X + i, 1 + X + Y, 1);\n  }\n  for (auto&& e : edge) {\n    G.add_edge(1 + e.first, 1 + X + e.second, 1);\n  }\n  return G;\n}\n} // namespace copr\nnamespace copr {\ntemplate <typename GraphType>\nstruct graph_traits {\n  using value_type = typename GraphType::value_type;\n  using vertex_type = typename value_type::value_type;\n  using edge_type = typename vertex_type::value_type;\n  using path_type = vertex_type;\n};\n} // namespace copr\n\n#include <algorithm>\n#include <limits>\n#include <queue>\n\nnamespace copr {\ntemplate <typename T>\nstruct Dinic {\n  using graph_type = ResidualGraph<T>;\n  using edge_type = typename graph_traits<graph_type>::edge_type;\n  using capacity_type = typename edge_type::value_type;\n\n  static constexpr auto inf = std::numeric_limits<capacity_type>::max();\n  const int UNREACHABLE = -1;\n\n  graph_type& Gf;\n  std::vector<int> level, iter;\n  Dinic(graph_type& Gf) : Gf(Gf), level(Gf.V), iter(Gf.V) {}\n\n  capacity_type max_flow_value(int s, int t) {\n    capacity_type value = 0;\n    while (labeling(s), level[t] != UNREACHABLE) {\n      std::fill(iter.begin(), iter.end(), 0);\n      capacity_type bf;\n      while (bf = blocking_flow(s, t, inf), bf > 0) {\n        value += bf;\n      }\n    }\n    return value;\n  }\n  bool labeling(int s) {\n    std::fill(level.begin(), level.end(), UNREACHABLE);\n    level[s] = 0;\n    static std::queue<int> Q;\n    Q.push(s);\n    for (; not Q.empty(); Q.pop()) {\n      auto v = Q.front();\n      for (auto& e : Gf.G[v]) {\n        if (level[e.to] != UNREACHABLE) continue;\n        if (e.cap == 0) continue;\n        level[e.to] = level[v] + 1;\n        Q.push(e.to);\n      }\n    }\n    return true;\n  }\n  capacity_type blocking_flow(int v, int t, capacity_type f) {\n    if (v == t) return f;\n    auto& V = Gf.G[v];\n    for (int& i = iter[v]; i < V.size(); ++i) {\n      auto& e = V[i];\n      if (e.cap == 0) continue;\n      if (level[v] >= level[e.to]) continue;\n      auto bf = blocking_flow(e.to, t, std::min(f, e.cap));\n      if (bf > 0) {\n        e.cap -= bf;\n        Gf.rev(e).cap += bf;\n        return bf;\n      }\n    }\n    return 0;\n  }\n};\ntemplate <typename T>\nDinic<T> dinic(ResidualGraph<T>& Gf) {\n  return Dinic<T>(Gf);\n}\n} // namespace copr\nnamespace copr {\nint bipartite_matching(int X, int Y, const std::vector<std::pair<int, int>>& edge) {\n  auto G = copr::build_bipartite_graph(X, Y, edge);\n  return copr::dinic(G).max_flow_value(0, 1 + X + Y);\n}\n} // namespace copr\nusing namespace std;\nconst int inf = 1001001001;\nconst ll infl = 1001001001001001001ll;\nconst int dd[] = {0, 1, 0, -1, 0};\n\nsigned main() { //\n  int X = in(), Y = in(), E = in();\n  vec<duo<int>> edges;\n  rep(i, E) {\n    int x = in(), y = in();\n    edges.emplace_back(x, y);\n  }\n  pr(copr::bipartite_matching(X, Y, edges));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int mx = 305;\nconst int inf = 0x3f3f3f3f;\nconst int S = mx - 2, T = mx - 1;\n\nstruct edge {\n  int from, to, cap;\n  edge *rev;\n  edge(int from, int to, int cap) : from(from), to(to), cap(cap) {}\n  void flow(int f) { cap -= f, rev->cap += f; }\n};\n\nvector<edge *> adj[mx];\n\nvoid addEdge(int u, int v, int c) {\n  edge *e = new edge(u, v, c);\n  edge *rev = new edge(v, u, 0);\n  e->rev = rev, rev->rev = e;\n  adj[u].push_back(e);\n  adj[v].push_back(rev);\n}\n\nbool vis[mx], inq[mx];\nint bt[mx], mf[mx];\nedge *bte[mx];\nbool augment(int &flow) {\n  fill(vis, vis + mx, false);\n  fill(inq, inq + mx, false);\n  fill(mf, mf + mx, 0);\n  queue<int> q;\n  q.push(S);\n  mf[S] = inf;\n  while (!q.empty()) {\n    int p = q.front();\n    q.pop();\n    inq[p] = false;\n    if (vis[p])\n      continue;\n    // printf(\"Visit: %d\\n\", p);\n    vis[p] = true;\n    if (p == T)\n      break;\n    for (edge *e : adj[p]) {\n      // printf(\"Edge: %d -> %d, cap %d\\n\", e->from, e->to, e->cap);\n      if (!vis[e->to] && min(e->cap, mf[p]) > mf[e->to]) {\n        bt[e->to] = p;\n        bte[e->to] = e;\n        mf[e->to] = min(e->cap, mf[p]);\n        if (!inq[e->to])\n          q.push(e->to), inq[e->to] = true;\n      }\n    }\n  }\n  // printf(\"Done, vis: %d\\n\", vis[T]);\n  if (!vis[T])\n    return false;\n  int p = T, f = mf[T];\n  while (p != S) {\n    bte[p]->flow(f);\n    p = bt[p];\n  }\n  flow = f;\n  return true;\n}\n\nint maxflow() {\n  int flow, mflow = 0;\n  while (augment(flow))\n    mflow += flow;\n  return mflow;\n}\n\nint main() {\n  int x, y, e;\n  cin >> x >> y >> e;\n\n  for (int i = 0; i < x; i++)\n    addEdge(S, i, 1);\n  for (int i = 100; i < 100 + y; i++)\n    addEdge(i, T, 1);\n\n  for (int i = 0; i < e; i++) {\n    int a, b;\n    cin >> a >> b;\n    addEdge(a, 100 + b, inf);\n  }\n\n  cout << maxflow() << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define repr(i, n) REPR(i, n, 0)\n#define REPR(i, s, e) for(int i=(int)(s-1); i>=(int)(e); i--)\n#define pb push_back\n#define all(r) r.begin(),r.end()\n#define rall(r) r.rbegin(),r.rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n//?????§???\nstruct MaxFlow {\n    struct Edge {\n        int to, cap, rev;\n        Edge() {};\n        Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {};\n    };\n    int V;\n    vector<vector<Edge>> G;\n    vector<int> used;\n\n    MaxFlow(int V) : V(V), G(V, vector<Edge>()), used(V){}\n\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back({to, cap, (int)G[to].size()});\n        G[to].push_back({from, 0, (int)G[from].size() - 1});\n    }\n\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            Edge& e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (1) {\n            // memset(used, 0, sizeof(used));\n            used = vector<int>(V, 0);\n            int f = dfs(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\n\nint main(){\n    int x, y, e;\n    cin >> x >> y >> e;\n    MaxFlow flow(x + y + 2);\n    int source = x + y, sink = x + y + 1;\n    rep(i, e) {\n        int a, b;\n        cin >> a >> b;\n        b += x;\n        flow.add_edge(a, b, 1);\n    }\n    rep(i, x) flow.add_edge(source, i, 1);\n    rep(i, y) flow.add_edge(x+i, sink, 1);\n    cout << flow.max_flow(source, sink) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int n) { return n & 1; }\nconstexpr bool even(const int n) { return ~n & 1; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing Flow = int;\nstruct FlowEdge {\n  int src, dst;\n  Flow cap;\n  int rev;\n  FlowEdge(const int s = 0, const int d = 0, const Flow c = 0, const int r = 0) : src(s), dst(d), cap(c), rev(r) {}\n};\n\nusing FlowEdges = std::vector<FlowEdge>;\n\nclass FlowGraph {\n  std::vector<FlowEdges> g;\n\npublic:\n  FlowGraph(const int size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  FlowEdges &operator[](const int i) & { return g[i]; }\n\n  void addEdge(const int src, const int dst, const Flow c = 1) {\n    g[src].emplace_back(src, dst, c, g[dst].size());\n    g[dst].emplace_back(dst, src, 0, g[src].size() - 1);\n  }\n};\n\ntemplate<Flow inf = std::numeric_limits<Flow>::max()> Flow dinic(FlowGraph g, const int source, const int sink) {\n  std::vector<int> level(g.size()), iter(g.size());\n  auto bfs = [&] {\n    std::fill(level.begin(), level.end(), -1);\n    std::queue<int> q;\n    level[source] = 0;\n    q.push(source);\n    while (q.size()) {\n      int v = q.front();\n      q.pop();\n      for (auto &e : g[v]) {\n        if (level[e.dst] >= 0 || e.cap <= 0) continue;\n        level[e.dst] = level[v] + 1;\n        q.push(e.dst);\n      }\n    }\n    return level[sink] >= 0;\n  };\n  std::function<Flow(int, Flow)> dfs = [&](int v, Flow f) -> Flow {\n    if (v == sink) return f;\n    Flow s = 0;\n    for (; iter[v] < g[v].size(); iter[v]++) {\n      auto &e = g[v][iter[v]];\n      if (level[v] >= level[e.dst] || e.cap <= 0) continue;\n      Flow d = dfs(e.dst, min(f, e.cap));\n      e.cap -= d;\n      g[e.dst][e.rev].cap += d;\n      s += d;\n      f -= d;\n      if (f == 0) break;\n    }\n    return s;\n  };\n  Flow s = 0;\n  while (bfs()) {\n    std::fill(iter.begin(), iter.end(), 0);\n    s += dfs(source, inf);\n  }\n  return s;\n}\n\nmain {\n  int X, Y, E;\n  cin >> X >> Y >> E;\n  FlowGraph g(X + Y + 2);\n  rep(i, X) g.addEdge(X + Y, i, 1);\n  rep(i, Y) g.addEdge(X + i, X + Y + 1, 1);\n  while (E--) {\n    int x, y;\n    cin >> x >> y;\n    g.addEdge(x, X + y);\n  }\n  cout << dinic(g, X + Y, X + Y + 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl;\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define repi(start,end) for(int i=start; i<end; i++)\n#define repj(start,end) for(int j=start; j<end; j++)\n#define repk(start,end) for(int k=start; k<end; k++)\n#define repl(start,end) for(int l=start; l<end; l++)\n#define RE return 0;\n\nstruct edge{int to,cap,rev;};\n\nint n,k;\nbool can[1000][1000];\nint used[100];\n\nvector<edge> G[2000000];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  used[v]=true;\n  repi(0, G[v].size()){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    int f=dfs(s, t, INF);\n    if(f==0) return flow;\n    flow+=f;\n  }\n}\n\nvoid solve(){\n  int s=n+k,t=s+1;\n  \n  repi(0, n){\n    add_edge(s,i,1);\n  }\n  repi(0, k){\n    add_edge(n+i, t, 1);\n  }\n  \n  repi(0, n){\n    repj(0, k){\n      if(can[i][j]){\n        add_edge(i, n+j, 1);\n      }\n    }\n  }\n  \n  cout<<max_flow(s, t)<<en\n}\n\n\n\n\nint main(){\n  /*\n  cin>>n>>k;\n  repi(0, n){\n    int num;\n    cout<<\"        \"<<i<<\":\"<<en\n    cout<<\"how many?     \";\n    cin>>num;\n    cout<<\"encode ->   \";\n    int a;\n    repj(0, num) {cin>>a; can[i][a]=true;}\n  }\n  cout<<en*/\n  \n  int e,a,b;\n  cin>>n>>k>>e;\n  repi(0, e){\n    cin>>a>>b;\n    can[a][b]=true;\n  }\n  \n  solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing graph = vector<vector<int>>;\n\n// require: input graph is bipartite\nclass bipartite_matching {\npublic:\n    bipartite_matching(graph const& g)\n        : g_(g), match_(g.size(), -1), used_(g.size(), false)\n    {}\n\n    int solve() {\n        const int n = g_.size();\n        int res = 0;\n        bool update = true;\n        while(update) {\n            update = false;\n            for(int v = 0; v < n; ++v) {\n                if(match_[v] == -1 && dfs(v)) {\n                    update = true;\n                    ++res;\n                }\n            }\n            if(update) fill(used_.begin(), used_.end(), false);\n        }\n        return res;\n    }\n\n    int match(int v) const { return match_[v]; }\n\nprivate:\n    bool dfs(int v) {\n        if(used_[v]) return false;\n        used_[v] = true;\n        for(auto u : g_[v]) {\n            if(match_[u] < 0 || dfs(match_[u])) {\n                match_[u] = v;\n                match_[v] = u;\n                return true;\n            }\n        }\n        return false;\n    }\n\nprivate:\n    graph g_;\n    vector<int> match_;\n    vector<bool> used_;\n};\n\nint main() {\n    int X, Y, E; cin >> X >> Y >> E;\n    graph g(X + Y);\n    for(int i = 0; i < E; ++i) {\n        int x, y; cin >> x >> y;\n        g[x].push_back(y + X);\n        g[y + X].push_back(x);\n    }\n    bipartite_matching bm(g);\n    cout << bm.solve() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Long = long long;\n\ntemplate<typename W>\nstruct Edge { \n    int to,rev;\n    W cap;\n    Edge(int to, int rev, W cap) : to(to), rev(rev), cap(cap) {}\n};\n\ntemplate<typename W>\nusing Graph = vector<vector<Edge<W>>>;\n\ntemplate<typename W>\nstruct NetWork {\n    Graph<W> G;\n    NetWork(int V) : G(V) { }\n    void add_edge(int from, int to, W cap) {\n        G[from].emplace_back(to, (int)G[to].size(), cap);\n        G[to].emplace_back(from, (int)G[from].size()-1, 0);\n    }\n};\n\n// private\ntemplate<typename W>\nvoid bfs(int s, Graph<W> &g, vector<int> &level) {\n    fill(level.begin(),level.end(), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while(!que.empty()) {\n        int v=que.front();que.pop();\n        for(auto &e : g[v]) {\n            if( e.cap > 0 && level[e.to] < 0) {\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\n// private\ntemplate<typename W>\nW dfs(int v,int t,W f, Graph<W> &g, vector<int> &iter, vector<int> &level) {\n    if(v==t) return f;\n    for(int &i = iter[v] ; i < g[v].size();i++ ) {\n        Edge<W> &e = g[v][i];\n        if( e.cap > 0 && level[v]<level[e.to] ) {\n            int d = dfs(e.to, t , min(f , e.cap), g, iter, level);\n            if( d > 0 ) {\n                e.cap-=d;\n                g[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// Dinic法\ntemplate<typename W>\nW max_flow(NetWork<W> &network, int s, int t) {\n    W flow = 0;\n    // networkのグラフ\n    Graph<W> &g = network.G;\n    // level[i] : 頂点sから頂点iまでの最短距離\n    vector<int> level(g.size(), -1);\n    vector<int> iter(g.size(), 0);\n    for( ; ; ) {\n        bfs(s, g, level);\n        // フローを流せるエッジが存在しない.\n        if( level[t] < 0 ) return flow;\n        fill(iter.begin(),iter.end(),0);\n        int f;\n        while( (f=dfs(s , t, numeric_limits<W>::max(), g, iter, level)) > 0){\n            flow += f;\n        }\n    }\n    return flow;\n}\n\nstruct BipartiteGraph : NetWork<int> {\n    vector<int> used;\n    BipartiteGraph(int V) : NetWork<int>::NetWork(V+2) , used(V, false) { }\n    void add_edge(int x, int y) {\n        NetWork<int>::add_edge(x, y, 1);\n        if (!used[x]) {\n            NetWork<int>::add_edge(NetWork<int>::G.size()-2, x, 1);\n            used[x] = true;\n        }\n        if (!used[y]) {\n            NetWork<int>::add_edge(y, NetWork<int>::G.size()-1, 1);\n            used[y] = true;\n        }\n    }\n};\n\nint max_matching(BipartiteGraph &g) {\n    return max_flow(g, g.G.size()-2, g.G.size()-1);\n}\n\n\nint main(void) {\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    BipartiteGraph g(X+Y);\n    for(int i = 0;i < E;i++) {\n        int x,y;\n        cin >> x >> y;\n        g.add_edge(x,X+y);\n    }\n    cout << max_matching(g) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nconst int max_v=202;\nstruct edge{int to,cap,rev;};\nvector<edge> graph[max_v];\nbool used[max_v];\n\nvoid add_edge(int from,int to,int cap){\n    graph[from].push_back(edge{to,cap,int(graph[to].size())});\n    graph[to].push_back(edge{from,0,int(graph[from].size()-1)});\n}\n\nint ford_fulkerson_dfs(int v,int t,int f){\n    if(v==t) return f;\n    used[v]=true;\n    for(auto &e:graph[v]){\n        if(used[e.to] or e.cap<=0) continue;\n        int d=ford_fulkerson_dfs(e.to,t,min(f,e.cap));\n        if(d>0){\n            e.cap-=d;\n            graph[e.to][e.rev].cap+=d;\n            return d;\n        }\n    }\n    return 0;\n}\n\nint ford_fulkerson(int s,int t){\n    int flow=0,f;\n    while(true){\n        fill_n((bool*)used,max_v,false);\n        f=ford_fulkerson_dfs(s,t,inf);\n        if(f==0) return flow;\n        flow+=f;\n    }\n}\n\nvoid solve(){\n    int x_size,y_size,e_size;\n    cin >> x_size >> y_size >> e_size;\n    rep(i,0,e_size){\n        int x,y;\n        cin >> x >> y;\n        add_edge(x,x_size+y,1);\n    }\n    \n    rep(i,0,x_size) add_edge(x_size+y_size,i,1);\n    rep(i,0,y_size) add_edge(x_size+i,x_size+y_size+1,1);\n    \n    cout << ford_fulkerson(x_size+y_size,x_size+y_size+1) << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\nvector<int> list[100000];\nint N, M, E;\nint match[100000];\nbool used[100000];\nint x, y;\n\nbool DFS(int V) {\n\tused[V] = true;\n\tfor (int i = 0; i < list[V].size(); i++) {\n\t\tint u = list[V][i]; int w = match[u];\n\t\tif (w < 0 || !used[u] && DFS(w)) {\n\t\t\tmatch[V] = u;\n\t\t\tmatch[u] = V;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint supermatching() {\n\tint r = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int j = 0; j < N + M; j++) {\n\t\tif (match[j] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (DFS(j)) { r++; }\n\t\t}\n\t}\n\treturn r;\n}\n\nint main() {\n\tcin >> N >> M >> E;\n\tfor (int i = 0; i < E; i++) {\n\t\tcin >> x >> y;\n\t\ty += N;\n\t\tlist[y].push_back(x);\n\t\tlist[x].push_back(y);\n\t}\n\tcout << supermatching() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define int long long\n\nconstexpr long long INF = (long long)1e18;\n\nclass ford_fulkerson{\n\tint maxv;\n\tstruct edge{ int to, cap, rev; };\npublic:\n\tvector<vector<edge>> G;\n\tvector<bool> used;\n\n\t\n\tford_fulkerson(int maxv = 0) : maxv(maxv){\n\t\tresize(maxv);\n\t}\n\t\n\tvoid init(){\n\t\tG.clear();\n\t\tused.clear();\n\t}\n\t\n\tvoid resize(int v){\n\t\tG.resize(v);\n\t\tused.resize(v);\n\t}\n\t\n\tvoid add_edge(int from, int to, int cap){\n\t\tG[from].push_back((edge){to,cap,(int)G[to].size()});\n\t\tG[to].push_back((edge){from, 0, (int)G[from].size()-1});\n\t}\n\n\tint dfs(int v, int t, int f){\n\t\tif(v == t) return f;\n\t\tused[v] = true;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(!used[e.to] && e.cap > 0){\n\t\t\t\tint d = dfs(e.to, t, min(f,e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint max_flow(int s, int t){\n\t\tint flow = 0;\n\t\tfor(;;){\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tint f = dfs(s,t,INF);\n\t\t\tif(f == 0) return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n};\n\nsigned main(){\n\tint X, Y, E; \n\tford_fulkerson ff;\n\t\n\tcin>>X>>Y>>E;\n\t\n\tff.resize(X+Y+2);\n\t\n\tfor(int i = 0; i < E; i++){\n\t\tint x, y;\n\t\t\n\t\tcin>>x>>y;\n\t\t\n\t\tff.add_edge(x, y + X, 1);\n\t}\n\t\n\tfor(int i = 0; i < X; i++){\n\t\tff.add_edge(X+Y, i, 1);\n\t}\n\t\n\tfor(int i = 0; i < Y; i++){\n\t\tff.add_edge(i + X, X+Y+1, 1);\n\t}\n\t\n\tcout<<ff.max_flow(X+Y, X+Y+1)<<endl;\n\t\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing ll = long long;\nusing namespace std;\nconstexpr ll inf = 1e9;\nconstexpr ll mod = 1e9+7;\n\nstruct Edge {\n    int to;\n    int cap;\n    int rev;\n};\nvector<Edge> edges[11001];\nbool used[11001] = {false};\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (auto&& edge : edges[v]) {\n        if (used[edge.to] || edge.cap <= 0) continue;\n        int d = dfs(edge.to, t, min(f, edge.cap));\n        if (d > 0) {\n            edge.cap -= d;\n            edges[edge.to][edge.rev].cap += d;\n            return d;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int X, Y, E;\n    cin>>X>>Y>>E;\n    for (int e = 0; e < E; e++) {\n        int x, y;\n        cin>>x>>y;\n        x++; y += X+1;\n        edges[x].push_back(Edge{y, 1, (int)edges[y].size()});\n        edges[y].push_back(Edge{x, 0, (int)edges[x].size()-1});\n    }\n\n    for (int x = 1; x <= X; x++) {\n        edges[0].push_back(Edge{x, 1, (int)edges[x].size()});\n        edges[x].push_back(Edge{0, 0, (int)edges[0].size()-1});\n    }\n    for (int y = X+1; y < X+Y+1; y++) {\n        edges[y].push_back(Edge{X+Y+1, 1, (int)edges[X+Y+1].size()});\n        edges[X+Y+1].push_back(Edge{y, 0, (int)edges[y].size()-1});\n    }\n\n    int flow = 0;\n    while (1) {\n        fill(begin(used), end(used), false);\n        int f = dfs(0, X+Y+1, inf);\n        if (f == 0) break;\n        flow += f;\n    }\n    cout<<flow<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define uint unsigned int\n#define dotimes(i, n) for (int i = 0, i##max__ = (n); i < i##max__; i++)\n#define whole(x, f, ...) ([&](decltype((x)) c__) { return (f)(begin(c__), end(c__), ## __VA_ARGS__); })(x)\n\nint rint() { int x; scanf(\"%lld\", &x); return x; }\nvoid wint(int x) { printf(\"%lld\\n\", x); }\n\ntemplate<typename T> int size(T const& c) { return static_cast<int>(c.size()); }\ntemplate<typename T> bool maxs(T& a, T const& b) { return a < b ? a = b, true : false; }\ntemplate<typename T> bool mins(T& a, T const& b) { return a > b ? a = b, true : false; }\ninline int lg(int x) { return 63 - __builtin_clzll(static_cast<unsigned int>(x)); }\n\n#ifdef EBUG\n#define INT_WIDTH \"\"\n#include \"debug.h\"\n#else\n#define inspect(...) do {} while (0)\n#define debugf(...) do {} while (0)\n#define debugv(...) do {} while (0)\n#endif\n\nint dinic(const int s, const int t, vector<vector<tuple<int, int&, int&>>>& capacities) {\n  const int n = ::size(capacities);\n  int r = 0;\n  queue<int> q;\n  vector<int> levels, progresses;\n  for (;;) {\n    // BFS\n    levels.assign(n, -1);\n    q.emplace(s);\n    levels[s] = 0;\n    while (!q.empty()) {\n      const int u = q.front(), l = levels[u] + 1;\n      q.pop();\n      for (auto&& p : capacities[u]) {\n        int v = get<0>(p);\n        if (levels[v] < 0 && get<1>(p) > 0) {\n          levels[v] = l;\n          q.emplace(v);\n        }\n      }\n    }\n    if (levels[t] < 0)\n      break;\n    // DFS\n    progresses.assign(n, 0);\n    function<int(int, int)> rec;\n    rec = [&](int u, int f) {\n      if (u == s)\n        return f;\n      const int l = ::size(capacities[u]);\n      int r = 0;\n      for (int& progress = progresses[u]; progress < l; progress++) {\n        auto&& p = capacities[u][progress];\n        int v = get<0>(p);\n        if (get<2>(p) > 0 && levels[v] < levels[u]) {\n          int x = rec(v, min(get<2>(p), f));\n          if (x > 0) {\n            get<1>(p) += x;\n            get<2>(p) -= x;\n            f -= x;\n            r += x;\n            if (f == 0)\n              break;\n          }\n        }\n      }\n      return r;\n    };\n    r += rec(t, 1LL << 61);\n  }\n  return r;\n}\n\ntemplate<typename T>\nint dinic(const int n, const int s, const int t, T const& edges) {\n  vector<vector<tuple<int, int&, int&>>> capacities(n);\n  vector<pair<int, int>> underlying_capacities;\n  underlying_capacities.reserve(edges.size());\n  // p = ((u, v), (capacity of u -> v, capacity of v -> u))\n  for (pair<pair<int, int>, pair<int, int>> const& p : edges) {\n    underlying_capacities.push_back(p.second);\n    auto& uc = underlying_capacities.back();\n    capacities[p.first.first].emplace_back(p.first.second, uc.first, uc.second);\n    capacities[p.first.second].emplace_back(p.first.first, uc.second, uc.first);\n  }\n  return dinic(s, t, capacities);\n}\n\nsigned main() {\n  const int X = rint();\n  const int Y = rint();\n  const int E = rint();\n  vector<pair<pair<int, int>, pair<int, int>>> edges;\n  edges.reserve(X + Y + E);\n  dotimes(i, E) {\n    int x = rint();\n    int y = rint();\n    edges.emplace_back(make_pair(x+2, y+X+2), make_pair(1, 0));\n  }\n  dotimes(x, X)\n    edges.emplace_back(make_pair(0, x+2), make_pair(1, 0));\n  dotimes(y, Y)\n    edges.emplace_back(make_pair(y+X+2, 1), make_pair(1, 0));\n  wint(dinic(X+Y+2, 0, 1, edges));\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nconst int MAX = 512;\n\nint X, Y, E;\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, cap, G[to].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge& e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (1) {\n        for (int i = 0; i < MAX; i++) used[i] = false;\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(void) {\n    cin >> X >> Y >> E;\n    while (E--) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, X+y, 1);\n    }\n    int s = X+Y, t = s+1;\n    for (int i = 0; i < X; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        add_edge(t, X+i, 1);\n    }\n    cout << max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n// verified: http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3998051\nstruct BipartiteMatching {\n    int V;\n    vector<vector<int>> graph;\n    vector<int> match;\n    vector<int> used;\n    int updateIndex;\n\n    void add_edge(int u, int v) {\n        graph[u].push_back(v);\n    }\n\n    bool dfs(int v) {\n        if (used[v] == updateIndex) return false;\n        used[v] = updateIndex;\n        for (int u : graph[v]) {\n            int w = match[u];\n            if (w == -1 || dfs(w)) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int bipartiteMatching() {\n        match.assign(V, -1);\n        used.assign(V, false);\n        int res = 0;\n        bool update = true;\n        while (update) {\n            update = false;\n            for (int v = 0; v < V; ++v) {\n                if (match[v] == -1 && dfs(v)) {\n                    update = true;\n                    res++;\n                }\n            }\n            if (update) updateIndex++;\n        }\n        return res;\n    }\n};\n\nint main() {\n    int X, Y, E;\n    cin >> X >> Y >> E;\n\n    BipartiteMatching bm;\n    bm.V = X + Y;\n    bm.graph.resize(bm.V);\n    for (int i = 0; i < E; ++i) {\n        int x, y;\n        cin >> x >> y;\n        bm.add_edge(x, X + y);\n    }\n\n    cout << bm.bipartiteMatching() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// statics\nusing namespace std;\nusing int64 = long long;\nusing PAIR = pair<int, int>;\nconstexpr int INF = 1 << 30;\nconstexpr int64 LINF = 1LL << 60;\nconstexpr int MOD = 1e9 + 7;\nconstexpr int MAX_N = 1e5 + 1;\nconstexpr int MAX_V = 575;\n\n// init/input\n#define int int64\n#define INIT ios::sync_with_stdio(false);cin.tie(0);\n#define VAR(type, ...) type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T &t) {cin>>t;}\ntemplate<typename First, typename...Rest> void MACRO_VAR_Scan(First &first, Rest&...rest) {cin>>first;MACRO_VAR_Scan(rest...);}\n#define VEC(type, c, n) vector<type> c(n);for(auto &&i:c)cin>>i;\n\n// out\n#define OUT(dist) cout<<(dist);\n#define FOUT(n, dist) cout <<fixed<<setprecision(n)<<(dist);\n#define SP cout<<\" \";\n#define BR cout<<\"\\n\";\n#define debug(x) cerr << #x << \":\" << (x);BR;\n\n// utility\n#define ALL(a) (a).begin(), (a).end()\n#define EACH(i, a) for(auto &&i:(a))\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=0;--i)\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n\nint V;\nvector< int > G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to) {\n  G[from].push_back(to);\n  G[to].push_back(from);\n}\n\nint dfs(int v) {\n  used[v] = true;\n\n  for (int i = 0; i < (int)G[v].size(); ++i) {\n    int to = G[v][i], w = match[to];\n    if (w < 0 || (!used[w] && dfs(w))) {\n      match[v] = to;\n      match[to] = v;\n      return true;\n    }\n  }\n}\n\nsigned main() {\n  INIT;\n\n  VAR(int, X, Y, E);\n  REP(ei, E) {\n    VAR(int, from, to);\n    add_edge(from, X + to);\n  }\n  V = X + Y;\n\n  // 二部グラフの最大マッチング\n  auto bipartie_matching = []() {\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for (int v = 0; v < V; ++v) {\n      if (match[v] < 0) {\n\tmemset(used, 0, sizeof(used));\n\tif (dfs(v) > 0) {\n\t  res++;\n\t}\n      }\n    }\n    return res;\n  };\n  \n  OUT(bipartie_matching())BR;\n\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <list>\n#include <stack>\n#include <string>\n#include <functional>\n#include <numeric>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\nusing namespace std;\n#define INT_MAX 2147483647\n#define INT_MIN (-2147483647 - 1)\n#define INF (int)1e8\n#define _INF (int)-1e8\n#define INFLL (long long)1e14\n#define _INFLL (long long)-1e14\n#define Loop(i, n) for(int i = 0; i < (int)n; i++)\n#define Loop1(i, n) for(int i = 1; i <= (int)n; i++)\n#define Loopr(i, n) for(int i = (int)n - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = (int)n; i >= 1; i--)\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef pair<int, int> P;\n\n\n\nclass Networkflow {\nprivate:\n\tstruct edgedata {\n\t\tint from, to, capacity, weight;\n\t\tedgedata* dual_p;\n\t\tbool operator<(const edgedata & another) const {\n\t\t\treturn (weight != another.weight ? weight < another.weight : capacity > another.capacity);\n\t\t}\n\t};\n\tstruct node {\n\t\tint id, d;\n\t\tbool done;\n\t\tedgedata* fromedge_p;\n\t\tlist<edgedata> edges;\n\t\tbool operator<(const node & another) const {\n\t\t\treturn !(d != another.d ? d < another.d : id < another.id);\n\t\t}\n\t};\n\tvector<node> nodes;\n\tint n;\n\tint source, sink;\n\tedgedata* dummy;\npublic:\n\tint result;\n\tNetworkflow(int size, int s, int t) {\n\t\tn = size;\n\t\tsource = s;\n\t\tsink = t;\n\t\tnodes.resize(n);\n\t\tdummy = new edgedata;\n\t\tinit();\n\t}\n\tvoid init() {\n\t\tLoop(i, n) {\n\t\t\tnodes[i] = { i, INT_MAX, false, dummy, {} };\n\t\t}\n\t}\n\tvoid addedge(int s, int t, int c, int w) {\n\t\tnodes[s].edges.push_back({ s, t, c, w, dummy });\n\t\tnodes[t].edges.push_back({ t, s, 0, w * (-1) , &(nodes[s].edges.back()) });\n\t\tnodes[s].edges.back().dual_p = &(nodes[t].edges.back());\n\t}\n\tvoid maxflow() {\n\t\tLoop(i, n) nodes[i].edges.sort();\n\t\tresult = 0;\n\t\tvector<pair<int, edgedata*>> stk;\n\t\tint a; // the node which is focused on\n\t\tint df; // how much flow in one operation\n\t\twhile (1) {\n\t\t\ta = source;\n\t\t\tLoop(i, n) nodes[i].done = false;\n\t\t\tnodes[source].done = true;\n\t\t\twhile (a != sink) {\n\t\t\t\tint b = -1;\n\t\t\t\tedgedata* p;\n\t\t\t\tfor (auto itr = nodes[a].edges.begin(); itr != nodes[a].edges.end(); ++itr) {\n\t\t\t\t\tif ((*itr).capacity > 0) {\n\t\t\t\t\t\tb = (*itr).to;\n\t\t\t\t\t\tif (nodes[b].done) b = -1;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tp = &(*itr);\n\t\t\t\t\t\t\tstk.push_back(make_pair(a, p));\n\t\t\t\t\t\t\tnodes[b].done = true;\n\t\t\t\t\t\t\ta = b;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (b == -1) {\n\t\t\t\t\tif (stk.empty()) break;\n\t\t\t\t\ta = stk.back().first;\n\t\t\t\t\tstk.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (stk.empty()) break;\n\t\t\tdf = INT_MAX;\n\t\t\tLoop(i, stk.size()) {\n\t\t\t\tdf = min(df, (*(stk[i].second)).capacity);\n\t\t\t}\n\t\t\twhile (stk.size()) {\n\t\t\t\t(*(stk.back().second)).capacity -= df;\n\t\t\t\t(*((*(stk.back().second)).dual_p)).capacity += df;\n\t\t\t\tstk.pop_back();\n\t\t\t}\n\t\t\tresult += df;\n\t\t}\n\t\treturn;\n\t}\n\t// if succeeding to satisfy flow then return true\n\t// thus if you want to gain mincostmaxflow then flow = INT_MAX and return false\n\tbool mincostflow(int flow) {\n\t\tvector<node> nodesbuf = nodes;\n\t\tLoop(i, n) nodesbuf[i].edges.sort();\n\t\tint potential = 0;\n\t\tLoop(i, n) {\n\t\t\tpotential = min(potential, nodesbuf[i].edges.front().weight);\n\t\t}\n\t\tLoop(i, n) {\n\t\t\tfor (auto itr = nodesbuf[i].edges.begin(); itr != nodesbuf[i].edges.end(); ++itr) {\n\t\t\t\t(*itr).weight -= potential;\n\t\t\t}\n\t\t}\n\t\tresult = 0;\n\t\tnode a;\n\t\tint df; // how much flow in one operation\n\t\tint sumf = 0;\n\t\twhile (1) {\n\t\t\tLoop(i, n) {\n\t\t\t\tnodesbuf[i].d = INT_MAX;\n\t\t\t\tnodesbuf[i].done = false;\n\t\t\t\tnodesbuf[i].fromedge_p = dummy;\n\t\t\t}\n\t\t\tpriority_queue<node> pq;\n\t\t\tnodesbuf[source].d = 0;\n\t\t\tpq.push(nodesbuf[source]);\n\t\t\twhile (pq.size()) {\n\t\t\t\ta = pq.top(); pq.pop();\n\t\t\t\tif (nodesbuf[a.id].done) continue;\n\t\t\t\tnodesbuf[a.id].done = true;\n\t\t\t\tfor (auto itr = nodesbuf[a.id].edges.begin(); itr != nodesbuf[a.id].edges.end(); ++itr) {\n\t\t\t\t\tif ((*itr).capacity == 0) continue;\n\t\t\t\t\tnode *b = &nodesbuf[(*itr).to];\n\t\t\t\t\tif ((*b).done) continue;\n\t\t\t\t\tint cand = nodesbuf[a.id].d + ((*itr).weight);\n\t\t\t\t\tif (cand < (*b).d) {\n\t\t\t\t\t\t(*b).d = cand;\n\t\t\t\t\t\t(*b).fromedge_p = &(*itr);\n\t\t\t\t\t\tpq.push(*b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!nodesbuf[sink].done) break;\n\t\t\tdf = INT_MAX;\n\t\t\tint focus = sink;\n\t\t\twhile (focus != source) {\n\t\t\t\tdf = min(df, (*(nodesbuf[focus].fromedge_p)).capacity);\n\t\t\t\tresult += potential;\n\t\t\t\tfocus = (*(nodesbuf[focus].fromedge_p)).from;\n\t\t\t}\n\t\t\tdf = min(df, flow - sumf);\n\t\t\tfocus = sink;\n\t\t\twhile (focus != source) {\n\t\t\t\t(*(nodesbuf[focus].fromedge_p)).capacity -= df;\n\t\t\t\t(*((*(nodesbuf[focus].fromedge_p)).dual_p)).capacity += df;\n\t\t\t\tfocus = (*(nodesbuf[focus].fromedge_p)).from;\n\t\t\t}\n\t\t\tsumf += df;\n\t\t\tresult += nodesbuf[sink].d * df;\n\t\t\tif (sumf == flow) return true;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nint main() {\n\tint v, w, e;\n\tcin >> v >> w >> e;\n\tint a = v + w;\n\tint b = v + w + 1;\n\tNetworkflow networkflow(v + w + 2, a, b);\n\tLoop(i, e) {\n\t\tint s, t; cin >> s >> t;\n\t\tnetworkflow.addedge(s, v + t, 1, 1);\n\t}\n\tLoop(i, v) {\n\t\tnetworkflow.addedge(a, i, 1, 1);\n\t}\n\tLoop(i, w) {\n\t\tnetworkflow.addedge(v + i, b, 1, 1);\n\t}\n\tnetworkflow.maxflow();\n\tcout << networkflow.result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nnamespace Flow {\n    struct Edge {\n        int to, capacity, cost, reverse;\n        Edge(int to, int capacity, int cost, int reverse) :\n            to(to), capacity(capacity), cost(cost), reverse(reverse) {}\n    };\n    template <int MaxN> class PrimalDual {\n        int n = MaxN;\n        vector<Edge> g[MaxN];\n    public:\n        void clear(int n) {\n            this->n = n;\n            for (int i = 0; i < n; ++i)\n                g[i].clear();\n        }\n        void push(int from, int to, int capacity = 1, int cost = 0) {\n            g[from].emplace_back(to, capacity, cost, g[to].size());\n            g[to].emplace_back(from, 0, -cost, g[from].size() - 1);\n        }\n        pair<int, int> flow(int s, int t, int f = 1 << 30) {\n            int flow = f, cost = 0;\n            static int prevv[MaxN], preve[MaxN], dist[MaxN], h[MaxN];\n            fill(h, h + n, 0);\n            while (flow > 0) {\n                fill(dist, dist + n, 1 << 30);\n                dist[s] = 0;\n                using P = pair<int, int>;\n                priority_queue<P, vector<P>, greater<P>> q;\n                for (q.emplace(0, s); q.size(); ) {\n                    auto p = q.top();\n                    q.pop();\n                    int v = p.second;\n                    if (dist[v] < p.first) continue;\n                    for (auto& e : g[v]) {\n                        int d = dist[v] + e.cost + h[v] - h[e.to];\n                        if (e.capacity > 0 && dist[e.to] > d) {\n                            dist[e.to] = d;\n                            prevv[e.to] = v;\n                            preve[e.to] = &e - &g[v][0];\n                            q.emplace(d, e.to);\n                        }\n                    }\n                }\n                if (dist[t] == 1 << 30) break;\n                for (int v = 0; v < n; ++v)\n                    h[v] += dist[v];\n                int d = flow;\n                for (int v = t; v != s; v = prevv[v])\n                    d = min(d, g[prevv[v]][preve[v]].capacity);\n                flow -= d;\n                cost += d * h[t];\n                for (int v = t; v != s; v = prevv[v]) {\n                    auto& e = g[prevv[v]][preve[v]];\n                    e.capacity -= d;\n                    g[v][e.reverse].capacity += d;\n                }\n            }\n            return { f - flow, cost };\n        }\n    };\n}\n\nint main() {\n    int n, m, l;\n    cin >> n >> m >> l;\n    Flow::PrimalDual<202> pd;\n    pd.clear(n + m + 2);\n    for (int i = 0; i < n; ++i)\n        pd.push(n + m, i);\n    for (int i = 0; i < m; ++i)\n        pd.push(i + n, n + m + 1);\n    for (int i = 0; i < l; ++i) {\n        int a, b;\n        cin >> a >> b;\n        pd.push(a, b + n);\n    }\n    cout << pd.flow(n + m, n + m + 1).first << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <set>\n#include <bitset>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int> >vpi;\ntypedef pair<int,int> pi;\n#define R return\n#define W while\n#define FOR(i,a) for(int i=0;i<a;i++)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define I insert\n#define P push\nint main(){\n    int x,y,k,l,r,ans=0,temp,n;\n    pair<priority_queue<pi,vpi,greater<pi> >,priority_queue<pi,vpi,greater<pi> > >pq;\n    pair<vi,vi>v[510];\n    pi d[510];\n    set<pi>s;\n    pair<bitset<510>,bitset<510> >b;\n    b.F.reset();\n    b.S.reset();\n    scanf(\"%d%d%d\",&x,&y,&k);\n    n=max(x,y)+1;\n    W(k--){\n        scanf(\"%d%d\",&l,&r);\n        if(s.count(MP(l,r)))continue;\n        s.I(MP(l,r));\n        v[l].F.PB(r);\n        v[r].S.PB(l);\n    }\n    FOR(i,n){\n        d[i].F=(int)v[i].F.size();\n        d[i].S=(int)v[i].S.size();\n        pq.F.P(MP(d[i].F,i));\n        pq.S.P(MP(d[i].S,i));\n    }\n    W(!(pq.F.empty()||pq.S.empty())){\n        if(pq.F.top().F<=pq.S.top().F){\n            temp=pq.F.top().S;\n            pq.F.pop();\n            if(b.F[temp])continue;\n            b.F[temp]=true;\n            FOR(i,v[temp].F.size())if(!b.S[v[temp].F[i]]){\n                b.S[v[temp].F[i]]=true;\n                ans++;\n                FOR(j,v[v[temp].F[i]].S.size())if(!b.F[v[v[temp].F[i]].S[j]]){\n                    d[v[v[temp].F[i]].S[j]].F--;\n                    pq.F.P(MP(d[v[v[temp].F[i]].S[j]].F,v[v[temp].F[i]].S[j]));\n                }\n            }\n        }\n        else{\n            temp=pq.S.top().S;\n            pq.S.pop();\n            if(b.S[temp])continue;\n            b.S[temp]=true;\n            FOR(i,v[temp].S.size())if(!b.F[v[temp].S[i]]){\n                b.F[v[temp].S[i]]=true;\n                ans++;\n                FOR(j,v[v[temp].S[i]].F.size())if(!b.S[v[v[temp].S[i]].F[j]]){\n                    d[v[v[temp].S[i]].F[j]].S--;\n                    pq.S.P(MP(d[v[v[temp].S[i]].F[j]].S,v[v[temp].S[i]].F[j]));\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include \"../max_flow.cpp\"\n#define MAX_N 1000\nusing namespace std;\n\nint N,K;\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\n\nint solve(){\n  //0??????N-1: ???????????\\???????????????????????????\n  //N??????N+K-1: ???????????????????????????\n  int s = N+K, t = s+1;\n  \n  //s??¨???????????\\??????????????¶\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  \n  //????????¨t?????????\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  //???????????\\????????¨??????????????¶\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n\n  return max_flow(s,t);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include <cstring>\n\nusing namespace std;\ntypedef long long ll;\n#define int long long\ntypedef vector<int> VI;\ntypedef pair<int, int> pii;\ntypedef vector<pii> VP;\ntypedef vector<string> VS;\ntypedef priority_queue<int> PQ;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n#define fore(i,a) for(auto &i:a)\n#define REP(i,n) for(int i=0;i<n;i++)\n#define eREP(i,n) for(int i=0;i<=n;i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define eFOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define SORT(c) sort((c).begin(),(c).end())\n#define rSORT(c) sort((c).rbegin(),(c).rend())\n#define LB(x,a) lower_bound((x).begin(),(x).end(),(a))\n#define UB(x,a) upper_bound((x).begin(),(x).end(),(a))\n#define INF 1000000000\n#define LLINF 9223372036854775807\n#define mod 1000000007\n//priority_queue<int,vector<int>, greater<int> > q2;\nVI G[2000];\n\nint match[2010];\nbool used[2010];\nint N;\n\nbool dfs(int v) {\n\tused[v] = true;\n\tREP(i, G[v].size()) {\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || (!used[w] && dfs(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint solve() {\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tREP(v, N) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v))res++;\n\t\t}\n\t}\n\n\treturn res;\n}\n\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint X, Y, M; cin >> X >> Y >> M;\n\tREP(i, M) {\n\t\tint a, b; cin >> a >> b;\n\t\tb += X;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tN = X + Y;\n\n\tcout << solve() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct Edge {\n  int to, cap, rev;\n  Edge(int to_, int cap_, int rev_) : to(to_), cap(cap_) , rev(rev_) { }\n};\n\nint INF = (int)1e9;\nconst int MAX_V = 400;\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n  G[from].emplace_back(to, cap, G[to].size());\n  G[to].emplace_back(from, 0, G[from].size() - 1);\n}\n\nint find_flow(int v, int t, int f) {\n  if(v == t) return f;\n  used[v] = true;\n  for(Edge &e : G[v]) {\n    if(used[e.to] == false && e.cap > 0) {\n      int d = find_flow(e.to, t, min(f, e.cap));\n      if(d > 0) {\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s, int t) {\n  int flow = 0;\n  while(true) {\n    fill(used, used + MAX_V, false);\n    int f = find_flow(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main() {\n  int X, Y, E; cin >> X >> Y >> E;\n  int src = X + Y;\n  int dst = X + Y + 1;\n  for(int i = 0; i < X; i++) {\n    add_edge(src, i, 1);\n  }\n  for(int i = 0; i < Y; i++) {\n    add_edge(X + i, dst, 1);\n  }\n  while(E--) {\n    int x, y; cin >> x >> y;\n    add_edge(x, X + y, 1);\n  }\n  cout << max_flow(src, dst) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\nusing namespace std;\n\nstruct edge{ int to,cap,rev; };\n\nint V,E;\nint X,Y;\nvector<edge> G[102];\nbool used[102],can[102][102]={};\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to] && e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(used,used+100,0);\n    int f=dfs(s,t,inf);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nvoid solve(){\n  int s=X+Y,t=s+1;\n\n  for(int i=0;i<X;i++){\n    add_edge(s,i,1);\n  }\n  for(int i=0;i<Y;i++){\n    add_edge(X+i,t,1);\n  }\n  for(int i=0;i<X;i++){\n    for(int j=0;j<Y;j++){\n      if(can[i][j]){\n\tadd_edge(i,X+j,1);\n      }\n    }\n  }\n  cout<<max_flow(s,t)<<endl;\n}\n\nint main()\n{\n  int x,y;\n  cin>>X>>Y>>E;\n  for(int i=0;i<E;i++){\n    cin>>x>>y;\n    can[x][y]=true;\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\ntemplate <typename T>\nstruct Edge {\n    int to; T cap, cost; int rev;\n    Edge(int t, T c, int r) : to(t), cap(c), rev(r) {}\n    Edge(int t, T ca, T co, int r) : to(t), cap(ca), cost(co), rev(r) {}\n};\n\ntemplate <typename T>\nstruct Flow {\n    vector< vector< Edge<T> > > G;\n    int n;\n    vector<bool> used;\n    Flow(int _n) : G(_n), n(_n), used(_n, false) {}\n\n    // G[e.to][e.rev] ??§?????????????????§??????\n    void add_edge(int from, int to, T cap) {\n        G[from].push_back(Edge<T>(to, cap, G[to].size()));\n        G[to].push_back(Edge<T>(from, 0, G[from].size() - 1));\n    }\n\n    T dfs(int v, int t, T f) {\n        if(v == t) return f;\n        used[v] = true;\n        for(int i=0; i < G[v].size(); i++) {\n            Edge<T> &e = G[v][i];\n            if(!used[e.to] && e.cap > 0) {\n                T d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T max_flow(int s, int t) {\n        T flow = 0;\n        while(1) {\n            fill(used.begin(), used.end(), false);\n            T f = dfs(s, t, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nsigned main() {\n    int X, Y, E; cin >> X >> Y >> E;\n    int x, y;\n    int s = X+Y, t = s+1;\n\n    Flow<int> fl(X + Y + 2);\n    rep(i,0,X) fl.add_edge(s, i, 1);\n    rep(i,0,Y) fl.add_edge(X+i, t, 1);\n    rep(i,0,E) {\n        cin >> x >> y;\n        fl.add_edge(x, X+y, 1);\n    }\n    cout << fl.max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAX 1024\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\nint X, Y, E;\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, cap, (int)G[to].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge& e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (1) {\n        for (int i = 0; i < MAX; i++) used[i] = false;\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(void) {\n    cin >> X >> Y >> E;\n    while (E--) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, X+y, 1);\n    }\n    int s = X+Y, t = s+1;\n    for (int i = 0; i < X; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        add_edge(t, X+i, 1);\n    }\n    cout << max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\n\n/**\n * 与えられるグラフを下の形式で2部グラフに分ける\n */\nbool mkbigraph(VVI& G, VVI& biG, int& M1, int& M2){\n  int N = SZ(G), sz = 0;\n  VI col(N, -1);\n  REP(i,N){\n\tif(col[i] != -1) continue;\n\tqueue<int> q;\n\tq.push(i);\n\tcol[i] = 0;\n\t++sz;\n\twhile(!q.empty()){\n\t  int u = q.front();\n\t  q.pop();\n\t  for(int to: G[u]){\n\t\tif(col[to] == -1){\n\t\t  col[to] = col[u] ^ 1;\n\t\t  q.push(to);\n\t\t  if(col[to] == 0) ++sz;\n\t\t}\n\t\telse if(col[to] == col[u]){\n\t\t  return false;\n\t\t}\n\t  }\n\t}\n  }\n\n  VI id(N, -1);\n  biG.resize(sz);\n  M1 = M2 = 0;\n  REP(i,N){\n\tif(id[i] == -1) id[i] = M1++;\n\tif(col[i] != 0) continue;\n\t\n\tfor(int to: G[i]){\n\t  if(col[to] == 0) continue;\n\t  if(id[to] == -1) id[to] = M2++;\n\t  biG[i].PB(id[to]);\n\t}\n  }\n\n  return true;\n}\n\n/* Hopcroft–Karp Algorithm\n * O(V E^0.5)\n *\n * 二部グラフ G = U \\cup V とすると\n * N == SZ(G) == SZ(U) == SZ(matchU)\n * M == SZ(matchV) == SZ(V)\n * かつ V={0,1,...,N-1}, U={0,1,...,M-1}となっていて\n * Gには U -> V の辺のみ含むこと\n * ref https://brilliant.org/wiki/hopcroft-karp/\n */\nint bipartite_matching(VVI& G, VI& matchU, VI& matchV){\n  int N = G.size();\n  fill(ALL(matchU), -1);\n  fill(ALL(matchV), -1);\n  vector<int> level(N);\n  vector<bool> finished(N);\n\n  int total = 0;\n  for(bool up=true;up;){\n\tup = false;\n\n\t// bfs\n\tfill(ALL(level), -1);\n    queue<int> Q;\n\tREP(i,N){\n\t  if(matchU[i] == -1){\n\t\tlevel[i] = 0;\n\t\tQ.push(i);\n\t  }\n\t}\n\twhile(!Q.empty()){\n      int u = Q.front();\n\t  Q.pop();\n      for(auto to: G[u]){\n\t\tif(matchV[to] != -1 && level[matchV[to]] == -1){\n\t\t  level[matchV[to]] = level[u] + 1;\n\t\t  Q.push(matchV[to]);\n\t\t}\n\t  }\n    }\n\n\t// dfs\n\tfill(ALL(finished), false);\n\tfunction<bool(int)> dfs = [&](int u){\n\t  finished[u] = true;\n\t  for(auto to: G[u]){\n\t\tint bk = matchV[to];\n\t\tif(bk == -1 || (!finished[bk] && level[bk] == level[u]+1 && dfs(bk))){\n\t\t  matchU[u] = to;\n\t\t  matchV[to] = u;\n\t\t  return true;\n\t\t}\n\t  }\n\t  return false;\n\t};\n\n\n\tREP(i,N){\n\t  if(matchU[i] == -1 && dfs(i)){\n\t\tup = true;\n\t\t++total;\n\t  }\n    }\n  }\n  return total;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int X, Y, E;\n  cin >> X >> Y >> E;\n  VVI G(X+Y);\n  REP(i,E){\n\tint x, y;\n\tcin >> x >> y;\n\tG[x].PB(X+y);\n\tG[X+y].PB(x);\n  }\n  int M1, M2;\n  VVI biG;\n  mkbigraph(G, biG, M1, M2);\n  VI mu(M1), mv(M2);\n  cout << bipartite_matching(biG, mu, mv) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\nconst int MAX_V = 101;\nconst int MAX_X = 101;\nconst int MAX_Y = 101;\n\nclass Edge{\n    public:\n        int to, cap, rev;\n};\n\ntypedef vector<vector<Edge>> AdjList;\nAdjList G(MAX_V);\nbool used[MAX_V];\n\nvoid addEdge(int from, int to, int cap){\n    G[from].emplace_back(Edge{to, cap, static_cast<int>(G[to].size())});\n    G[to].emplace_back(Edge{from, 0, static_cast<int>(G[from].size() - 1)});\n}\n\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    rep(i,G[v].size()){\n        Edge &e = G[v][i];\n        if(not used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxFlow(int s, int t){\n    int flow = 0;\n    while(true){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\nint bipartiteMatching(int x, int y, bool edge[MAX_X][MAX_Y]){\n    int s = x + y, t = s + 1; //set x : 0 ~ x-1, set y : x ~ x+y-1\n\n    rep(i,x) addEdge(s, i, 1); //s??¨??????x????????¶\n    rep(i,y) addEdge(x + i, t, 1); //??????y??¨t????????¶\n\n    rep(i,x) rep(j,y) if(edge[i][j]) addEdge(i, x + j, 1); //??????x??¨??????y????????¶\n\n    return maxFlow(s, t);\n}\n\nint main(){\n    int x, y, e;\n    cin >> x >> y >> e;\n\n    bool edge[MAX_X][MAX_Y] = {0};\n    rep(i,e){\n        int a, b;\n        cin >> a >> b;\n        edge[a][b] = 1;\n    }\n    cout << bipartiteMatching(x, y, edge) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//二部マッチング\n//辺の構造体を持つ隣接リストで表現\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 1000000\n#define INF 1e9\n\n//辺を表す構造体　(行先、容量、逆辺の場所)\nstruct edge{\n    int to, cap, rev;\n};\n\nvector<vector<edge> > G(MAX_V);       //グラフの隣接リスト表現\nbool used[MAX_V];                    //DFSですでに調べたかのグラフ\n\n\n// from から to へ向かう容量 cap の辺をグラフに張る\nvoid add_edge(int from, int to, int cap){\n\n    edge F;\n    edge T;\n    F.to = to;\n    F.cap = cap;\n    F.rev = G[to].size();\n    G[from].push_back(F);\n\n    T.to = from;\n    T.cap = 0;\n    T.rev = G[from].size() - 1;\n    G[to].push_back(T);    \n}\n\n//増加パスをDFSで探す\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];                          //すごい\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;            //もっとすごい\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n//s から t への最大流を求める\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(){\n\n    //入力\n    //xはuに属する\n    //yはvに属する\n    int u, v, e; cin >> u >> v >> e;               //uの頂点数　v超点数　辺数\n    \n    for(int i = 0; i < e; i++){\n        int x, y; cin >> x >> y;\n        y += u;\n        add_edge(x, y, 1);\n    }\n\n    for(int i = 1; i <= u; i++) add_edge(0, i, 1);\n    for(int i = u + 1; i <= u + v; i++) add_edge(i, u + v + 1, 1);\n    \n    cout << max_flow(0, u + v + 1) << endl;\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// this program solves bipartite matching using \n// maximum flow algorithm\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nconst int N = 220;\nconst int M = 22000;\n\nstruct Edge {\n\tint to, cap, next;\n} es[M];\n\nint S, T;  // source, sink\nint SIZE = 0; // number of edges\nint h[N]; // pointer to edge list\nint dist[N], queue[N]; // for calculating shortest path\n\n// add forward and backtracked edge\nvoid add(int u, int v, int cap) {\n\tint i = SIZE++;\n\tes[i].to = v;\n\tes[i].cap = cap;\n\tes[i].next = h[u];\n\th[u] = i; \n\tint j = SIZE++;\n\tes[j].to = u;\n\tes[j].cap = 0;\n\tes[j].next = h[v];\n\th[v] = j; \n}\n\n// returns whether find a path from S to T\nbool bfs() {\n\tint front = 0, back = 0;\n\tmemset(dist, -1, sizeof(dist));\n\tqueue[back++] = S;\n\tdist[S] = 0;\n\twhile (front < back) {\n\t\tint x = queue[front++];\n\t\tfor (int i = h[x]; i != -1; i = es[i].next)\n\t\t\tif (es[i].cap > 0) {\n\t\t\t\tint y = es[i].to;\n\t\t\t\tif (dist[y] == -1) {\n\t\t\t\t\tdist[y] = dist[x] + 1;\n\t\t\t\t\tqueue[back++] = y;\n\t\t\t\t}\n\t\t\t}\n\t\tif (dist[T] != -1)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n// returns the flow pushed from x to T\nint dfs(int x, int flow) {\n\tif (x == T) return flow;\n\tint dy = dist[x] + 1, ret = 0;\n\tfor (int i = h[x]; i != -1 && flow > 0; i = es[i].next) {\n\t\tint y = es[i].to;\n\t\tif (dist[y] != dy) continue;\n\t\tint f = dfs(y, std::min(flow, es[i].cap));\n\t\tif (f != 0) {\n\t\t\tes[i].cap -= f;\n\t\t\tes[i^1].cap += f;\n\t\t\tret += f;\n\t\t\tflow -= f;\n\t\t}\n\t}\n\tif (flow > 0)\n\t\tdist[x] = -1;\n\treturn ret;\n}\n\nvoid run() {\n\tint n1, n2, m, u, v;\n\tscanf(\"%d%d%d\", &n1, &n2, &m);\n\tmemset(h, -1, sizeof(h));\n\tS = 0, T = n1 + n2 + 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tu++, v++;\n\t\tadd(u, n1 + v, 1);\n\t}\n\tfor (int i = 1; i <= n1; i++)\n\t\tadd(S, i, 1);\n\tfor (int i = 1; i <= n2; i++)\n\t\tadd(n1 + i, T, 1);\n\tint flow = 0;\n\twhile (bfs())\n\t\tflow += dfs(S, 0x3fffffff);\n\tprintf(\"%d\\n\", flow);\n}\n\nint main() {\n\trun();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<algorithm>\n#include<vector>\nstruct bimatch{\n\tint n;\n\tvector<vector<int> >G;\n\tvector<int>match;\n\tvector<bool>used;\n\tbimatch(int _n=0):n(_n),G(n),match(n),used(n){}\n\tvoid add_edge(int u,int v)\n\t{\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tbool dfs(int v)\n\t{\n\t\tused[v]=true;\n\t\tfor(int u:G[v])\n\t\t\n\t\t{\n\t\t\tint w=match[u];\n\t\t\tif(w<0||!used[w]&&dfs(w))\n\t\t\t{\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint count()\n\t{\n\t\tint ans=0;\n\t\tfill(match.begin(),match.end(),-1);\n\t\tfor(int v=0;v<n;v++)\n\t\t{\n\t\t\tif(match[v]<0)\n\t\t\t{\n\t\t\t\tfill(used.begin(),used.end(),false);\n\t\t\t\tif(dfs(v))ans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\nint X,Y,E;\nmain()\n{\n\tcin>>X>>Y>>E;\n\tbimatch P(X+Y);\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tint x,y;cin>>x>>y;\n\t\tP.add_edge(x,X+y);\n\t}\n\tcout<<P.count()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 1e9 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\nconst int MAX_N=500;\n\nstruct edge{\n    int to,cap,rev;\n};\n\nvector<edge> G[MAX_N];\nvector<int> check(MAX_N,0);\n\nint dfs(int v,int t, int f ){\n    if(v==t){return f;}\n    check[v]=1;\n    for(int i=0;i<G[v].size();i++){\n        if(check[G[v][i].to]==0 && G[v][i].cap > 0){\n            int ff =dfs(G[v][i].to,t,min(f,G[v][i].cap));\n            if(ff>0){\n                G[v][i].cap -= ff;\n                G[G[v][i].to][G[v][i].rev].cap += ff;\n                return ff;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxflow(int s,int t){\n    int flow = 0;\n    while(1){\n        fill(check.begin(),check.end(),0);\n        int f = dfs(s,t,INT_MAX);\n        if(f==0){return flow;}\n        flow += f;\n    }\n}\n\nint bipartite_matching_flow(int X, int Y, vector<pii> &edge_list){\n    //X: ?????¨??°??????????????????????????°???Y: ???????????????????????°???edge_list: ??¨????????????????????§??¨???????????????\n    for(int i=0;i<edge_list.size();i++){\n        int s = edge_list[i].first;\n        int t = edge_list[i].second;\n        G[s].push_back((edge){X+t,1,G[X+t].size()});\n        G[X+t].push_back((edge){s,0,G[s].size()-1});\n    }\n\n    for(int i=0;i<X;i++){\n        G[X+Y].push_back((edge){i,1,G[i].size()});\n        G[i].push_back((edge){X+Y,0,G[X+Y].size()-1});\n    }\n\n    for(int i=X;i<X+Y;i++){\n        G[i].push_back((edge){X+Y+1,1,G[X+Y+1].size()});\n        G[X+Y+1].push_back((edge){i,0,G[i].size()-1});\n    }\n    return maxflow(X+Y,X+Y+1);\n}\n\nint main(){\n    int X,Y,E,s,t;\n    cin >> X >> Y >> E;\n    vector<pii> edge_list(E);\n    REP(i, E){\n        cin >> edge_list[i].first >> edge_list[i].second;\n    }\n    cout << bipartite_matching_flow(X, Y, edge_list) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  Created by Vignesh Manoharan\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<vi> vvi;\n\nconst int INF = 1000000000;\nconst ll LINF = 1e17;\nconst double PI =3.141592653589793238;\n#pragma unused(INF,PI,LINF)\n#define F(i,a,n) for(int i=(a);i<(n);i++)\n\ntemplate<typename T,typename TT> ostream& operator<<(ostream &s,pair<T,TT> t) {return s<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<typename T> ostream& operator<<(ostream &s,vector<T> t){\n    for(int i=0;i<(t).size();i++)s<<t[i]<<((i<(t).size()-1)?\" \":\"\");return s; }\ntemplate<typename T> ostream& operator<<(ostream &s,set<T> t){for(T x:t) s<<x<<\" \";return s; }\ntemplate<typename T> istream& operator>>(istream &s,vector<T> &t){\n    for(int _i=0;_i<t.size();_i++) s>>t[_i];return s; }\n\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n\nstruct flow_graph{\n    int MAX_V,E,s,t,head,tail;\n    int *cap,*to,*next,*last,*dist,*q,*now;\n    flow_graph(){}\n    flow_graph(int V, int MAX_E){\n        MAX_V = V; E = 0;\n        cap = new int[2*MAX_E], to = new int[2*MAX_E], next = new int[2*MAX_E];\n        last = new int[MAX_V], q = new int[MAX_V], dist = new int[MAX_V], now = new int[MAX_V];\n        fill(last,last+MAX_V,-1);\n    }\n    void clear(){\n        fill(last,last+MAX_V,-1);\n        E = 0;\n    }\n    void add_edge(int u, int v, int uv, int vu = 0){\n        to[E] = v, cap[E] = uv, next[E] = last[u]; last[u] = E++;\n        to[E] = u, cap[E] = vu, next[E] = last[v]; last[v] = E++;\n    }\n    bool bfs(){\n        fill(dist,dist+MAX_V,-1);\n        head = tail = 0;\n        \n        q[tail] = t; ++tail;\n        dist[t] = 0;\n        \n        while(head<tail){\n            int v = q[head]; ++head;\n            \n            for(int e = last[v];e!=-1;e = next[e]){\n                if(cap[e^1]>0 && dist[to[e]]==-1){\n                    q[tail] = to[e]; ++tail;\n                    dist[to[e]] = dist[v]+1;\n                }\n            }\n        }\n        \n        return dist[s]!=-1;\n    }\n    \n    int dfs(int v, int f){\n        if(v==t) return f;\n        \n        for(int &e = now[v];e!=-1;e = next[e]){\n            if(cap[e]>0 && dist[to[e]]==dist[v]-1){\n                int ret = dfs(to[e],min(f,cap[e]));\n                \n                if(ret>0){\n                    cap[e] -= ret;\n                    cap[e^1] += ret;\n                    return ret;\n                }\n            }\n        }\n        \n        return 0;\n    }\n    \n    long long max_flow(int source, int sink){\n        s = source; t = sink;\n        long long f = 0;\n        int x;\n        \n        while(bfs()){\n            for(int i = 0;i<MAX_V;++i) now[i] = last[i];\n            \n            while(true){\n                x = dfs(s,INF);\n                if(x==0) break;\n                f += x;\n            }\n        }\n        \n        return f;\n    }\n} G;\n\nint main(int argc, const char * argv[]) {\n#ifdef local_test\n    //    input\n    //    freopen(\"input\",\"w\",stdout);\n    //    cout<<\"1 \\n 100 10 \\n\";\n     freopen(\"input\",\"r\",stdin);\n     freopen(\"output\",\"w\",stdout);\n#endif\n    int x,y,e,u,v;\n    scanf(\"%d %d %d\",&x,&y,&e);\n    G=flow_graph(x+y+2,e+x+y);\n    for(int i = 0;i<e;i++){\n        scanf(\"%d %d\",&u,&v);\n        G.add_edge(u,x+v,1,1);\n    }\n    for(int i=0;i<x;i++){\n        G.add_edge(x+y,i,1,1);\n    }\n    for(int i=0;i<y;i++){\n        G.add_edge(x+i,x+y+1,1,1);\n    }\n    printf(\"%lld\\n\",G.max_flow(x+y,x+y+1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <valarray>\nusing namespace std;\n\nbool match(int cur,bool arr[],bool V[],int npair[], int column){\n    if(cur < 0){\n        return true;\n    }\n    if(V[cur]){\n        return false;\n    }\n    V[cur] = true;\n    for(int i = 0; i < column; i++){\n        if(!arr[cur*column + i]){\n            continue;\n        }\n        if(match(npair[i],arr,V,npair,column)){\n            npair[i] = cur;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n    int row,column,E;\n    scanf(\"%d %d %d\",&row,&column,&E);\n    bool arr[row*column],V[row];\n    for(int ei = 0; ei < E; ei++){\n        int from,to;\n        scanf(\"%d %d\",&from,&to);\n        arr[from*column + to] = true;\n    }\n    int npair[column],count = 0;\n    for(int i = 0; i < column; i++){\n        npair[i] = -1;\n    }\n    for(int cur = 0; cur < row; cur++){\n        for(int i = 0; i < row; i++){\n            V[i] = false;\n        }\n        if(match(cur,arr,V,npair,column)){\n            count++;\n        }\n    }\n    printf(\"%d\\n\",count);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\nusing namespace std;\n\n#define MAX_V 1000\n\nstruct edge{\n\tlong long int to, cap, rev; // 行き先、容量、逆辺\n};\n\nvector<edge> G[MAX_V] = {};\nbool used[MAX_V];\n\n// from から to へ向かう容量 cap の辺を張る\nvoid add_edge(long long int from, long long int to, long long int cap){\n\tG[from].push_back((edge){to, cap, G[to].size()});\n\tG[to].push_back((edge){from, 0, G[from].size() - 1}); // 有向辺\n\t// G[to].push_back((edge){from, cap, G[from].size() - 1}); // 無向辺\n}\n\n// 増加パスを dfs で探す\nlong long int dfs(int v, int t, long long int f){\n\tif(v == t){\n\t\treturn f;\n\t}\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tlong long int d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n// s から t への最大流を求める\nlong long int max_flow(int s, int t){\n\tlong long int flow = 0;\n\twhile(true){\n\t\tfill(used, used + MAX_V, 0);\n\t\tlong long int f = dfs(s, t, INF);\n\t\tif(f == 0){\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\n\nint main(){\n\t\n\tint X, Y, E;\n\tcin >> X >> Y >> E;\n\t\n\tfor(int i = 0; i < X; i++){\n\t\tadd_edge(0, i + 1, 1);\n\t}\n\t\n\tfor(int i = 0; i < Y; i++){\n\t\tadd_edge(X + i + 1, X + Y + 1, 1);\n\t}\n\t\n\tfor(int i = 0; i < E; i++){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tadd_edge(u + 1, X + v + 1, 1);\n\t}\n\t\n\tcout << max_flow(0, X + Y + 1) << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int,int>;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define repeat(i, j, k) for(int i = (j); i < (int)(k); i++)\n#define all(v) v.begin(),v.end()\n#define debug(x) cerr << #x << \" : \" << x << endl\n\ntemplate<class T> bool set_min(T &a, const T &b) { return a > b  ? a = b, true : false; }\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n// vector\ntemplate<class T> istream& operator >> (istream &is , vector<T> &v) { for(T &a : v) is >> a; return is; }\ntemplate<class T> ostream& operator << (ostream &os , const vector<T> &v) { for(const T &t : v) os << \"\\t\" << t; return os << endl; }\n// pair\ntemplate<class T, class U> ostream& operator << (ostream &os , const pair<T, U> &v) { return os << \"<\" << v.first << \", \" << v.second << \">\"; }\n\nconst int INF = 1 << 30;\nconst ll INFL = 1LL << 60;\n\ntemplate<class T>\nstruct Edge {\n    int to;\n    T capacity, cost, rev;\n};\n\ntemplate<class T=ll, T T_INF=INFL>\nstruct Flow {\n    int N;\n    vector<vector<Edge<T>>> E;\n\n    Flow(int n) : N(n) {\n        E.resize(N);\n    }\n    void add_arc(int from, int to, T cap, T cost = 0) {\n        E[from].push_back(Edge<T>{to, cap, cost, (ll)E[to].size()}); // E[to].size() ????????§??????????????????\n        E[to].push_back(Edge<T>{from, 0, -cost, (ll)E[from].size() - 1}); // ??????\n    }\n    // s -> t ??? f ??????????????????????°??????¨????¨?????????????????????? - 1\n    // ????????¨??°??????????£???????\n    T min_cost_flow(int s, int t, T f) {\n        auto bellmanford = [&] (int s, vector<int> &prev_v, vector<int> &prev_e) {\n            vector<T> dist(N, T_INF);\n            dist[s] = 0;\n            bool updated = true;\n            while(updated) {\n                updated = false;\n                rep(v, N) {\n                    if(dist[v] >= T_INF) continue;\n                    rep(i, E[v].size()) {\n                        auto &e = E[v][i];\n                        if(e.capacity > 0 and set_min(dist[e.to], dist[v] + e.cost)) {\n                            prev_v[e.to] = v;\n                            prev_e[e.to] = i;\n                            updated = true;\n                        }\n                    }\n                }\n            }            \n            return dist;\n        };\n        \n        T res = 0;\n        vector<int> prev_v(N), prev_e(N);\n        while(f > 0) {\n            auto dist = bellmanford(s, prev_v, prev_e);\n            if(dist[t] == T_INF) return -1;\n            T d = f;\n            // s -> t ???????°?????????????????????????????°??????? d ????±???????\n            for(int v = t; v != s; v = prev_v[v]) {\n                d = min(d, E[prev_v[v]][prev_e[v]].capacity);\n            }\n            // d ????????????            \n            for(int v = t; v != s; v = prev_v[v]) {\n                auto &e = E[prev_v[v]][prev_e[v]];\n                e.capacity -= d;\n                E[v][e.rev].capacity += d;\n            }\n            f -= d;\n            res += d * dist[t]; // ??????????????¨\n        }\n        return res;\n    }\n\n    // s -> t ??? ?????§???\n    // bad O(F|E|)\n    // Edge.cost ???????????¨???????????¨??°??????????£???????\n    T max_flow(int s, int t) {\n        function<T(int ,int ,T, vector<char>&)> dfs = [&] (int v, int t, T f, vector<char> &used) {\n            if(v == t) return f;\n            used[v] = true;\n            for(auto &e : E[v]) {\n                if(not used[e.to] and e.capacity > 0) {\n                    T d = dfs(e.to, t, min(f, e.capacity), used);\n                    if(d > 0) {\n                        e.capacity -= d;\n                        E[e.to][e.rev].capacity += d;\n                        return d;\n                    }\n                }\n            }\n            return (T)0;\n        };\n        T flow = 0;\n        for(;;) {\n            vector<char> used(N);\n            T f = dfs(s, t, T_INF, used);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n    \nclass Solver {\n  public:\n    bool solve() {\n        int X, Y, E; cin >> X >> Y >> E;\n        int N = X + Y;\n        Flow<> graph(N + 2);\n        rep(i, E) {\n            int x, y; cin >> x >> y;            \n            graph.add_arc(x, y + X, 1);\n        }\n        rep(i, X) graph.add_arc(N, i, 1);\n        rep(i, Y) graph.add_arc(X + i, N + 1, 1);\n        cout << graph.max_flow(N, N + 1) << endl; \n        return 0;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    Solver s;\n    s.solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n//#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n//#include <array>\n//#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n//#include <deque>\n#include<valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n\n// etc\n#include <cassert>\n#include <functional>\n#include <iomanip>\n//#include <typeinfo>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define OUT(d) std::cout<<d;\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<d;\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<d;\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define PAIR std::pair<int, int>\n#define PAIRLL std::pair<ll, ll>\n#define IN(a, x, b) (a<=x && x<b)\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << d << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWPAIR(p) {std::cerr << #p << \"\\t:(\" << p.first << \",\\t\" << p.second << \")\\n\";}\n#define SHOWPAIRVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr<<'('<<yyy.first<<\", \"<<yyy.second<<\") \";}std::cerr << \"\\n\";}}\n#define SHOWPAIRVECTOR(v) {for(const auto& xxx:v){std::cerr<<'('<<xxx.first<<\", \"<<xxx.second<<\") \";}std::cerr<<\"\\n\";}\n#define SHOWQUEUE(a) {std::queue<decltype(a.front())> tmp(a);std::cerr << #a << \"\\t:\";for(int i=0; i<static_cast<int>(a.size()); ++i){std::cerr << tmp.front() << \"\\n\";tmp.pop();}std::cerr << \"\\n\";}\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-7;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\n// Dinic???\nclass Dinic {\nprivate:\n\tstruct Edge {\n\t\tint to, cap, rev;\n\t\tEdge(int t, int c, int r) :to(t), cap(c), rev(r) {}\n\t};\n\tint V;\n\tstd::vector<std::vector<Edge>> graph;\n\tstd::vector<int> level, iter;\n\npublic:\n\tDinic(int v) : V(v) {\n\t\tgraph.resize(v);\n\t\tlevel.resize(v, -1);\n\t\titer.resize(v, 0);\n\t}\n\t// from??????to??????????????????cap???????????°?????????????????????\n\tvoid addEdge(int from, int to, int cap) {\n\t\tgraph[from].emplace_back(to, cap, graph[to].size());\n\t\tgraph[to].emplace_back(from, 0, graph[from].size() - 1);\n\t}\n\n\t// s????????????????????¢???BFS??§?¨??????????\n\tvoid bfs(int s) {\n\t\tstd::fill(level.begin(), level.end(), -1);\n\t\tstd::queue<int> queue;\n\t\tlevel[s] = 0;\n\t\tqueue.push(s);\n\t\twhile (!queue.empty()) {\n\t\t\tint v = queue.front(); queue.pop();\n\t\t\tfor (int i = 0; i < graph[v].size(); ++i) {\n\t\t\t\tEdge& e = graph[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tqueue.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// ?¢?????????????DFS??§??¢???\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t) return f;\n\t\tfor (int& i = iter[v]; i < graph[v].size(); ++i) {\n\t\t\tEdge& e = graph[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, std::min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tgraph[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\t// s??????t???????????§???????±???????\n\tint maxFlow(int s, int t) {\n\t\tint res = 0;\n\t\twhile (true) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0) return res;\n\t\t\tstd::fill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, (1LL << 31) - 1)) > 0) {\n\t\t\t\tres += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nsigned main() {\n\tINIT;\n\tVAR(int, n, m, e);\n\tVEC_ROW(int, e, x, y);\n\tDinic dinic(2 + n + m);\n\tREP(i, n) dinic.addEdge(0, i + 1, 1);\n\tREP(i, m) dinic.addEdge(i + n + 1, n+m+1, 1);\n\tREP(i, e) dinic.addEdge(x[i] + 1, y[i] + n + 1, 1);\n\tOUT(dinic.maxFlow(0, m + n + 1))BR;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ########################################################\n// ################ MaxBipartiteMatching ##################\n// Hopcroft ( E * sqrt(V) )\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=50005,MAXM=150000;\nint x,y,e,last[MAXN],prev[MAXM],head[MAXM];\nint matching[MAXN],dist[MAXN],Q[MAXN];\nbool used[MAXN],vis[MAXN];\nvoid bfs()\n{\n  fill(dist,dist+x,-1);\n  int Qs=0;\n  for (int u=0;u<x;++u)\n    if (!used[u])\n      Q[Qs++] = u,dist[u]=0;\n  for (int i=0;i<Qs;i++)\n    {\n      int u1=Q[i];\n      for (int j=last[u1];j>=0;j=prev[j])\n\t{\n\t  int u2=matching[head[j]];\n\t  if (u2>=0 && dist[u2]<0)\n\t      dist[u2]=dist[u1]+1,Q[Qs++]=u2;\n\t}\n    }\n}\nbool dfs(int u1)\n{\n  vis[u1]=true;\n  for (int i=last[u1];i>=0;i=prev[i])\n    {\n      int v=head[i];\n      int u2=matching[v];\n      if (u2<0 || !vis[u2] && dist[u2]==dist[u1]+1 && dfs(u2))\n\t{\n\t  matching[v]=u1;\n\t  return used[u1]=true;\n\t}\n    }\n  return false;\n}\nint maxMatching()\n{\n  fill(matching,matching+y,-1);\n  for (int res=0;;)\n    {\n      bfs();\n      fill(vis,vis+x,false);\n      int f=0;\n      for (int u=0;u<x;++u)\n\tif (!used[u] && dfs(u))\n\t  ++f;\n      if (!f)\n\treturn res;\n      res+=f;\n    }\n}\nint main()\n{\n  cin>>x>>y>>e;\n  fill(last,last+x,-1);\n  for(int i=0;i<e;i++)\n    {\n      int u,v;\n      cin>>u>>v;//0-based\n      head[i]=v;\n      prev[i]=last[u];\n      last[u]=i;\n    }\n  cout<<maxMatching()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n#define MAX_V 1000\nint V;\nVI G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v) {\n  G[u].PB(v);\n  G[v].PB(u);\n}\n\nbool dfs(int v) {\n  used[v] = true;\n  REP(i, G[v].size()) {\n    int u = G[v][i], w = match[u];\n    if(w < 0 || !used[w] && dfs(w)) {\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching() {\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  REP(v, V) {\n    if(match[v] < 0) {\n      memset(used, 0, sizeof(used));\n      if(dfs(v)) res++;\n    }\n  }\n  return res;\n}\n\nsigned main(void)\n{\n  int x, y, e;\n  cin >> x >> y >> e;\n  REP(i, e) {\n    int a, b;\n    cin >> a >> b;\n    add_edge(a, x+b);\n  }\n  V = x + y;\n\n  cout << bipartite_matching() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int MAX_N=500;\n\nstruct edge{\n\tint to,cap,rev;\n};\n\nvector<edge> G[MAX_N];\nvector<int> check(MAX_N,0);\n\nint dfs(int v,int t, int f ){\n\tif(v==t){return f;}\n\tcheck[v]=1;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(check[e.to]==0 && e.cap > 0){\n\t\t\tint ff =dfs(e.to,t,min(f,e.cap));\n\t\t\tif(ff>0){\n\t\t\t\te.cap -= ff;\n\t\t\t\tG[e.to][e.rev].cap += ff;\n\t\t\t\treturn ff;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxflow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tfill(check.begin(),check.end(),0);\n\t\tint f = dfs(s,t,INT_MAX);\n\t\tif(f==0){return flow;}\n\t\tflow += f;\n\t}\n}\n\nint main(){\n\tint X,Y,E,s,t;\n\tcin >> X >> Y >> E ;\n\t\n\tfor(int i=0;i<E;i++){\n\t\tcin >> s >> t ;\n\t\tG[s].push_back((edge){X+t,1,G[t].size()});\n\t\tG[X+t].push_back((edge){s,0,G[s].size()-1});\n\t}\n\t\n\tfor(int i=0;i<X;i++){\n\t\tG[X+Y].push_back((edge){i,1,G[i].size()});\n\t\tG[i].push_back((edge){X+Y,0,G[X+Y].size()-1});\n\t}\n\t\n\tfor(int i=X;i<X+Y;i++){\n\t\tG[i].push_back((edge){X+Y+1,1,G[X+Y+1].size()});\n\t\tG[X+Y+1].push_back((edge){i,0,G[i].size()-1});\n\t}\n\t/*\n\tint k=7;\n\tfor(int i=0;i<G[k].size();i++){\n\t\tcout << G[k][i].to << endl;\n\t}\n\t*/\n\t\n\tcout << maxflow(X+Y,X+Y+1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"MyDisjointset.h\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\nusing namespace std;\ntypedef pair<int, int> P; typedef long long int ll; typedef vector <int> vecint; typedef vector <vecint> dvecint; typedef vector <dvecint> vecdvecint; typedef vector <vector <dvecint> > dvecdvecint;\nconst int INF = 100000000;\nstruct edge {\n\tint to, cap, rev;\n};\nint level[102]; vector <edge> G[102];\nvecint to[102];\nvoid addedge(int from, int to, int cap) {\n\tedge e1 = { to, cap, G[to].size() };\n\tedge e2 = { from, 0, G[from].size()};\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nvoid bfs(int s) {\n\tfill(level, level + 102, -1);\n\tqueue<int> q;\n\tq.push(s);\n\tlevel[s] = 0;\n\twhile (!q.empty()) {\n\t\tint f = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[f].size(); i++) {\n\t\t\tedge e = G[f][i];\n\t\t\tif (level[e.to] < 0 && e.cap > 0) {\n\t\t\t\tlevel[e.to] = level[f] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int s, int t, int f) {\n\tif (s == t) return f;\n\tfor (int i = 0; i < G[s].size(); i++) {\n\t\tedge &e = G[s][i];\n\t\tif (level[e.to] > level[s] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main() {\n\tint nx, ny, ne;\n\tcin >> nx >> ny >> ne;\n\tfor (int i = 0; i < ne; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tto[x + 1].push_back(y + nx + 1);\n\t}\n\tfor (int i = 1; i <= nx; i++)\n\t\tfor (int j = 0; j < to[i].size(); j++)\n\t\t\taddedge(i, to[i][j], 1);\n\tint t = 1 + nx + ny;\n\tfor (int i = 1; i <= nx; i++)\n\t\taddedge(0, i, 1);\n\tfor (int i = nx + 1; i <= nx + ny; i++)\n\t\taddedge(i, t, 1);\n\tint flow = 0;\n\twhile (true) {\n\t\tbfs(0);\n\t\tif (level[t] < 0) break;\n\t\tint f;\n\t\twhile ((f = dfs(0, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n\tcout << flow << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define rep2(i, l, r) for(Int i = (Int)(l); i < (Int)(r); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\nint main() {\n   Int n, m, e;\n   std::cin >> n >> m >> e;\n   std::vector<Int> ss(1), ts(1), fs(1), bs(1);\n   auto addEdge = [&](Int s, Int t, Int f, Int b) {\n      ss.emplace_back(s);\n      ts.emplace_back(t);\n      fs.emplace_back(f);\n      bs.emplace_back(b);\n   };\n   rep(i, e) {\n      Int x, y;\n      std::cin >> x >> y;\n      addEdge(x, n+y, 0, 1);\n   }\n   Int source = n+m, sink = n+m+1;\n   Int v = n + m + 2;\n   rep2(i,0,n)   addEdge(source, i, 0, 1);\n   rep2(i,n,n+m) addEdge(i, sink, 0, 1);\n   std::vector<std::vector<Int>> es(v);\n   rep(i, fs.size()) {\n      Int s = ss[i], t = ts[i];\n      es[s].emplace_back(i);\n      es[t].emplace_back(-i);\n   }\n   Int res = 0;\n   for(;;) {\n      std::queue<Int> q;\n      std::vector<Int> xs(v, -1), ps(v, -1);\n      xs[source] = (Int)1<<53;\n      q.emplace(source);\n      while( not q.empty() ) {\n         Int s = q.front(); q.pop();\n         for(Int i : es[s]) {\n            Int t = i > 0 ? ts[i] : ss[-i];\n            Int w = i > 0 ? bs[i] : fs[-i];\n            guard( w > 0 and xs[t] == -1 );\n            xs[t] = std::min(xs[s], w);\n            ps[t] = i;\n            q.emplace(t);\n         }\n      }\n      Int tf = xs[sink];\n      if( xs[sink] <= 0 ) break;\n      for(Int i=sink, k=ps[i]; i!=source; i=k>0?ss[k]:ts[-k], k=ps[i]) {\n         if( k > 0 ) {\n            fs[k] += tf;\n            bs[k] -= tf;\n         }\n         else {\n            fs[-k] -= tf;\n            bs[-k] += tf;\n         }\n      }\n      res += tf;\n   }\n   printf(\"%ld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\ntemplate <typename T>\nstruct Edge {\n    int to; T cap, cost; int rev;\n    Edge(int t, T c, int r) : to(t), cap(c), rev(r) {}\n    Edge(int t, T ca, T co, int r) : to(t), cap(ca), cost(co), rev(r) {}\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\nstruct BipartiteMatching {\n    int S, T, E, a, b;\n    Graph<int> G;\n    vector<int> used;\n    BipartiteMatching(int x, int y, int z) : S(x), T(y), E(z) {\n        G.resize(S+T+2);\n        used.resize(S+T+2);\n        a = S + T, b = a + 1;\n    }\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back(Edge<int>(to, cap, G[to].size()));\n        G[to].push_back(Edge<int>(from, 0, G[from].size() - 1));\n    }\n    void readGraph() {\n        for(int i=0; i<E; i++) {\n            int x, y; cin >> x >> y;\n            // x--; y--;\n            add_edge(x, y+S, 1);\n        }\n        for(int i=0; i<S; i++) add_edge(a  , i, 1);\n        for(int i=0; i<T; i++) add_edge(i+S, b, 1);\n    }\n    int dfs(int v, int t, int f) {\n        if(v == t) return f;\n        used[v] = true;\n        for(size_t i=0; i<G[v].size(); i++) {\n            Edge<int> &e = G[v][i];\n            if(!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int solve() {\n        int flow = 0;\n        while(1) {\n            fill(used.begin(), used.end(), 0);\n            int f = dfs(a, b, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nsigned main() {\n    int x, y, e; cin >> x >> y >> e;\n    BipartiteMatching B(x, y, e);\n    B.readGraph();\n    cout << B.solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"MyDisjointset.h\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\nusing namespace std;\ntypedef pair<int, int> P; typedef long long int ll; typedef vector <int> vecint; typedef vector <vecint> dvecint; typedef vector <dvecint> vecdvecint; typedef vector <vector <dvecint> > dvecdvecint;\nconst int INF = 100000000;\nstruct edge {\n\tint to, cap, rev;\n};\nint level[102]; vector <edge> G[102];\nvecint to[102];\nvoid addedge(int from, int to, int cap) {\n\tedge e1 = { to, cap, G[to].size() };\n\tedge e2 = { from, 0, G[from].size() - 1 };\n\tG[from].push_back(e1);\n\tG[to].push_back(e2);\n}\nvoid bfs(int s) {\n\tfill(level, level + 102, -1);\n\tqueue<int> q;\n\tq.push(s);\n\tlevel[s] = 0;\n\twhile (!q.empty()) {\n\t\tint f = q.front(); q.pop();\n\t\tfor (int i = 0; i < G[f].size(); i++) {\n\t\t\tedge e = G[f][i];\n\t\t\tif (level[e.to] < 0 && e.cap > 0) {\n\t\t\t\tlevel[e.to] = level[f] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int s, int t, int f) {\n\tif (s == t) return f;\n\tfor (int i = 0; i < G[s].size(); i++) {\n\t\tedge &e = G[s][i];\n\t\tif (level[e.to] > level[s] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint main() {\n\tint nx, ny, ne;\n\tcin >> nx >> ny >> ne;\n\tfor (int i = 0; i < ne; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tto[x + 1].push_back(y + nx + 1);\n\t}\n\tfor (int i = 1; i <= nx; i++)\n\t\tfor (int j = 0; j < to[i].size(); j++)\n\t\t\taddedge(i, to[i][j], 1);\n\tint t = 1 + nx + ny;\n\tfor (int i = 1; i <= nx; i++)\n\t\taddedge(0, i, 1);\n\tfor (int i = nx + 1; i <= nx + ny; i++)\n\t\taddedge(i, t, 1);\n\tint flow = 0;\n\twhile (true) {\n\t\tbfs(0);\n\t\tif (level[t] < 0) break;\n\t\tint f;\n\t\twhile ((f = dfs(0, t, INF)) > 0) \n\t\t\tflow += f;\n\t}\n\tcout << flow << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#define _SILENCE_CXX17_RESULT_OF_DEPRECATION_WARNING\n#include \"bits/stdc++.h\"\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define rrep(i, n) for(int i=(n)-1; i>=0; --i)\n#define rfor(i, m, n) for(int i=(m); i>=(n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing LL = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<LL>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<double>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<LL, LL>;\tusing VPL = vector<PLL>;\ntemplate<class T>using Grid = vector<vector<T>>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr LL inf_ll = (LL)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\ntemplate<class T>inline void Sort(T& a)noexcept { sort(all(a)); }\ntemplate<class T>inline void RSort(T& a)noexcept { sort(rall(a)); }\ntemplate<class T>inline void Reverse(T& a)noexcept { reverse(all(a)); }\ntemplate<class T>inline void Unique(T& a)noexcept { a.erase(unique(all(a)), a.end()); }\ntemplate<class T>inline T Sorted(T a)noexcept { Sort(a); return a; }\ntemplate<class T>inline T RSorted(T a)noexcept { RSort(a); return a; }\ntemplate<class T>inline T Reversed(T a)noexcept { Reverse(a); return a; }\ntemplate<class T>inline T Uniqued(T a)noexcept { Unique(a); return a; }\ntemplate<class T>inline auto Max(const T& a)noexcept { return *max_element(all(a)); }\ntemplate<class T>inline auto Min(const T& a)noexcept { return *min_element(all(a)); }\ntemplate<class T>inline int MaxPos(const T& a)noexcept { return max_element(all(a)) - a.begin(); }\ntemplate<class T>inline int MinPos(const T& a)noexcept { return min_element(all(a)) - a.begin(); }\ntemplate<class T, class U>inline int Count(const T& a, const  U& v)noexcept { return count(all(a), v); }\ntemplate<class T, class U>inline int Find(const T& a, const U& v)noexcept { auto pos = find(all(a), v); return pos == a.end() ? -1 : pos - a.begin(); }\ntemplate<class T, class U>inline U Sum(const T& a, const U& v)noexcept { return accumulate(all(a), v); }\ntemplate<class T, class U>inline int Lower(const T& a, const U& v)noexcept { return lower_bound(all(a), v) - a.begin(); }\ntemplate<class T, class U>inline int Upper(const T& a, const U& v)noexcept { return upper_bound(all(a), v) - a.begin(); }\ntemplate<class T, class P>inline void RemoveIf(T& a, P f)noexcept { a.erase(remove_if(all(a), f), a.end()); }\ntemplate<class T>inline T Age(T n, T m)noexcept { return (n + m - 1) / m; }\ntemplate<class T>inline T Age2(T n, T m)noexcept { return Age(n, m) * m; }\ntemplate<class T>inline T Tri(T n)noexcept { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\ntemplate<class T = long long>inline T BIT(int b)noexcept { return T{ 1 } << b; }\ntemplate<class T>inline T Gcd(T n, T m)noexcept { return m ? Gcd(m, n % m) : n; }\ntemplate<class T>inline T Lcm(T n, T m)noexcept { return n / Gcd(n, m) * m; }\ntemplate<class T>inline T Pow(T a, T n)noexcept { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; }return r; }\ntemplate<class T>inline T Powmod(T a, T n, T m = MOD)noexcept { T r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r; }\ntemplate<class T>inline bool chmax(T& a, const T& b)noexcept { if (a < b) { a = b; return true; } return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b)noexcept { if (a > b) { a = b; return true; } return false; }\ntemplate<class T>inline bool inRange(const T& v, const T& min, const T& max)noexcept { return min <= v && v <= max; }\ninline string operator*(string s, int n)noexcept { string ret; rep(i, n)ret += s; return ret; }\n\n// --- input --- //\n#if defined(_WIN32) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\ninline int gc()noexcept { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v)noexcept { cin >> v; }\ninline void InputF(char& v)noexcept { while (isspace(v = gc())); }\ninline void InputF(string& v)noexcept {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (LL)(c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v)noexcept {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v)noexcept {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v)noexcept {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T InputF() { T v; InputF(v); return v; }\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>()noexcept {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>()noexcept {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T()noexcept { return InputF<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n)noexcept { return InputV(n); }\n\tInputV operator[](pair<int, int> n)noexcept { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T, size_t W>array<vector<T>, W> get(int H) {\n\t\tarray<vector<T>, W> ret;\n\t\trep(i, H)rep(j, W) { T x = *this; ret[j].push_back(x); }\n\t\treturn ret;\n\t}\n}in;\n#define input(type) InputF<type>()\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc }; bool isPrint = true;\n\tvoid p(double v) { printf(\"%.20f\", v); } void p(long double v) { printf(\"%.20Lf\", v); }\n\tvoid p(int v) { printf(\"%d\", v); }\tvoid p(LL v) { printf(\"%lld\", v); }\n\tvoid p(char v) { putchar(v); }\t\tvoid p(bool v) { printf(\"%s\", v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); printf(\"%s\", D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.l); p(v[i]); } }\n\tvoid p(const BoolStr& v) { B = v; isPrint = false; } void p(const DivStr& v) { D = v; isPrint = false; }\npublic:\n\tvoid operator()() { printf(\"%s\", D.l); }\n\ttemplate<class H>void operator()(H&& h) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.l); isPrint = true;\n\t}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.d); isPrint = true; operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n}out;\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) (void(0))\n#endif\n\ntemplate<class F>auto MakeVector(size_t size, F f) {\n\tvector<decay_t<result_of_t<F(size_t)>>> res(size);\n\tfor (size_t i = 0; i < size; ++i)res[i] = f(i);\n\treturn res;\n}\ntemplate<class T>vector<T> Slice(const vector<T>& v, size_t i, size_t len) {\n\treturn i < v.size() ? vector<T>(v.begin() + i, v.begin() + min(i + len, v.size())) : vector<T>();\n}\ntemplate<class T, class F>void Each(T& v, F f) {\n\tfor (auto& e : v)f(e);\n}\ntemplate<class T, class F>auto Map(const vector<T>& v, F f) {\n\tvector<decay_t<result_of_t<F(T)>>> res(v.size());\n\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e);\n\treturn res;\n}\ntemplate<class T, class F>auto MapIndex(const vector<T>& v, F f) {\n\tvector<decay_t<result_of_t<F(size_t, T)>>> res(v.size());\n\tfor (size_t i = 0; i < v.size(); ++i)res[i] = f(i, v[i]);\n\treturn res;\n}\ntemplate<class T, class F>vector<T> Select(const vector<T>& v, F f) {\n\tvector<T> res;\n\tfor (const auto& e : v)if (f(e))res.push_back(e);\n\treturn res;\n}\n\n// ---------------------------------------------------------------- //\n\nusing Weight = long long;\nconstexpr Weight INF = numeric_limits<Weight>::max();\nstruct Edge {\n\tint to; Weight cost;\n\tEdge() :to(-1), cost(-1) {}\n\tEdge(int _to, Weight _cost = 1) :to(_to), cost(_cost) {}\n};\nbool operator>(const Edge& e1, const Edge& e2) { return e1.cost > e2.cost; }\nstruct Edge2 {\n\tint u, v; Weight cost;\n\tEdge2() :u(-1), v(-1), cost(0) {}\n\tEdge2(int _u, int _v, Weight _cost) :u(_u), v(_v), cost(_cost) {}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\nusing UnWeightedGraph = vector<vector<int>>;\n\nstruct BipartiteMatching {\n\tint n, m;\n\tUnWeightedGraph g;\n\tvector<bool> used;\n\tvector<int> p, q;\n\tBipartiteMatching(int _n, int _m, const UnWeightedGraph& _g)\n\t\t: n(_n), m(_m), used(n), g(_g), p(n, -1), q(m, -1) {}\n\tbool dfs(int v) {\n\t\tif (used[v])return false;\n\t\tused[v] = true;\n\t\tfor (auto u : g[v]) {\n\t\t\tif (q[u] == -1 || dfs(q[u])) {\n\t\t\t\tq[u] = v; p[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint operator()() {\n\t\tint res = 0; bool flag = true;\n\t\twhile (flag) {\n\t\t\tflag = false;\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif (p[i] == -1 && dfs(i)) {\n\t\t\t\t\tflag = true; ++res;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main() {\n\tint X = in, Y = in, E = in;\n\tUnWeightedGraph g(X + Y);\n\trep(i, E) {\n\t\tint x = in, y = in;\n\t\tg[x].push_back(y);\n\t}\n\tBipartiteMatching solve(X, Y, g);\n\tout(solve());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct BiMatch{\n  int L,R;\n  vector<vector<int> > G;\n  vector<int> match,level;\n  \n  BiMatch(){}\n  BiMatch(int L,int R):L(L),R(R),G(L+R),match(L+R,-1),level(L){}\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v+L);\n    G[v+L].push_back(u);\n  }\n  \n  bool bfs(){\n    queue<int> q;\n    for(int i=0;i<L;i++){\n      level[i]=-1;\n      if(match[i]<0){\n\tlevel[i]=0;\n\tq.emplace(i);\n      }\n    }\n    while(!q.empty()){\n      int v=q.front();q.pop();\n      for(int u:G[v]){\n\tint w=match[u];\n\tif(w<0) return true;\n\tif(level[w]<0){\n\t  level[w]=level[v]+1;\n\t  q.emplace(w);\n\t}\n      }\n    }\n    return false;\n  }\n\n  bool dfs(int v){\n    for(int u:G[v]){\n      int w=match[u];\n      if(w<0||(level[w]>level[v]&&dfs(w))){\n\tmatch[v]=u;\n\tmatch[u]=v;\n\treturn true;\n      }\n    }\n    return false;\n  }\n  \n  int build(){\n    int res=0;\n    while(bfs())\n      for(int i=0;i<L;i++)\n\tif(match[i]<0&&dfs(i))\n\t  res++;\n    return res;\n  }\n  \n};\n//END CUT HERE\n\nsigned main(){\n  int X,Y,E;\n  cin>>X>>Y>>E;\n  BiMatch bm(X,Y);\n  for(int i=0;i<E;i++){\n    int x,y;\n    cin>>x>>y;\n    bm.add_edge(x,y);\n  }\n  cout<<bm.build()<<endl;\n  return 0;\n}\n/*\n  verified on 2017/10/29\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_7_A&lang=jp\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\nvector<int> list[100000];\nint N, M, E;\nint match[100000];\nbool used[100000];\nint x, y;\n \n//?????°???????¢??????????\nbool DFS(int V) {\n    used[V] = true;\n    for (int i = 0; i < list[V].size(); i++) {\n        int u = list[V][i]; int w = match[u];\n        if (w < 0 || !used[w] && DFS(w)) {\n            match[V] = u;\n            match[u] = V;\n            return true;\n        }\n    }\n    return false;\n}\n \nint supermatching() {\n    int r = 0;\n    memset(match, -1, sizeof(match));\n    for (int j = 0; j < N + M; j++) {\n        if (match[j] < 0) {\n            memset(used, 0, sizeof(used));\n            if (DFS(j)) { r++; }\n        }\n    }\n    return r;\n}\n \nint main() {\n    cin >> N >> M >> E;\n    for (int i = 0; i < E; i++) {\n        cin >> x >> y;\n        y += N;\n        list[y].push_back(x);\n        list[x].push_back(y);\n    }\n    cout << supermatching() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nstruct Edge {\n    int from, to, cap, flow;\n    Edge(int from, int to, int cap, int flow):from(from), to(to), cap(cap), flow(flow){}   \n};\n\nstruct Maxflow {\n    int n;\n    vector<Edge> edges;\n    vector<vector<int>> g;\n    \n    vector<int> p; //The id of the edge that connects to a vertex on the shortest path\n    vector<int> a; //The possible flow change from the start to a vertex\n    int flow = 0;\n    \n    Maxflow(int n) : n(n) {\n        g.assign(n + 1, vector<int>());\n    }\n    \n    void addEdge(int from, int to, int cap) {\n        edges.push_back(Edge(from , to, cap, 0));\n        edges.push_back(Edge(to, from, 0, 0));\n        g[from].push_back(edges.size() - 2);\n        g[to].push_back(edges.size() - 1);   \n    }\n    \n    int solve(int s, int t) {\n       while (findAugumentedPath(s, t)) {\n       }\n       return flow;\n    }\n    \n    bool findAugumentedPath(int s, int t) {  \n        p.assign(n + 1, -1);\n        a.assign(n + 1, 0);\n        \n        queue<int> q;\n\n        p[s] = -2;\n        a[s] = INF;\n        q.push(s);\n        \n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            for (int eid: g[u]) {\n                Edge e = edges[eid];\n                if (a[e.to] == 0 && e.cap > e.flow) {\n                    p[e.to] = eid;\n                    a[e.to] = min(a[u], e.cap - e.flow);\n                    q.push(e.to);\n                }\n            }\n            if (a[t] != 0) {\n                break;\n            }\n        }\n        if (a[t] == 0) {\n            return false;\n        }\n        flow += a[t];\n        for (int u = t; u != s; u = edges[p[u]].from) {\n            edges[p[u]].flow += a[t];\n            edges[p[u] ^ 1].flow -= a[t];\n        }\n        return true;\n    }   \n};\n\n\nint main() {\n    int m, n, e;\n    //cin >> v >> e >> s >> t;\n    cin >> m >> n >> e;\n    int s = 0;\n    int t = m + n + 1;\n    Maxflow maxflow(m + n + 2);\n    \n    for (int i = 1; i < m + 1; i++) {\n        maxflow.addEdge(0, i, 1);\n    }\n    for (int i = m + 1; i < m + n + 1; i++) {\n        maxflow.addEdge(i, m + n + 1, 1);\n    }\n    for (int i = 0; i < e; i++) {\n        int from, to;\n        cin >> from >> to;\n        maxflow.addEdge(from + 1, m + 1 + to, 1);\n    }\n    int ans = maxflow.solve(s, t);\n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nstruct Dinic {\n\tusing value_type = T;\nprivate :\n\tconst value_type INF = numeric_limits<value_type>::max();\n\tstruct Edge {\n\tpublic : \n\t\tint to, rev; value_type cap;\n\t\tEdge (int to, value_type cap, int rev) :\n\t\t\tto(to), cap(cap), rev(rev) { }\n    };\n    vector<int> level, idx;\n    vector<vector<Edge>> g;\npublic : \n\tDinic (int n) : g(n), level(n), idx(n) { }\n\n\tDinic (int l, int r, vector<pair<int, int>> &edges) : g(l + r + 2), level(l + r + 2), idx(l + r + 2) {\n\t\tfor (int i = 1; i <= l; i++) add_edge(0, i, 1);\n\t\tfor (int i = 1; i <= r; i++) add_edge(l + i, l + r + 1, 1);\n\t\tfor (const auto &p : edges) add_edge(p.first + 1, p.second + l + 1, 1);\n\t}\n\n\tvoid add_edge (int from, int to, value_type cost) {\n\t\tg[from].emplace_back(to, cost, g[to].size());\n\t\tg[to].emplace_back(from, 0, g[from].size() - 1);\n\t}\n\n\tvoid init (int s) {\n\t\tfill(level.begin(), level.end(), -1); level[s] = 0;\n\t\tqueue<int> que; que.emplace(s);\n\t\twhile (not que.empty()) {\n\t\t\tconst int v = que.front(); que.pop();\n\t\t\tfor (const Edge &e : g[v]) {\n\t\t\t\tif (e.cap > 0 and level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.emplace(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvalue_type find_flow (int v, int t, value_type f) {\n\t\tif (v == t) return f;\n\t\tfor (int &i = idx[v]; i < g[v].size(); i++) {\n\t\t\tEdge &e = g[v][i];\n\t\t\tif (e.cap > 0 and level[v] < level[e.to]) {\n\t\t\t\tvalue_type flow = find_flow(e.to, t, min(f, e.cap));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te.cap -= flow;\n\t\t\t\t\tg[e.to][e.rev].cap += flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tvalue_type max_flow (int s, int t) {\n\t\tvalue_type ret = 0;\n\t\twhile (true) {\n\t\t\tinit(s);\n\t\t\tif (level[t] < 0) break;\n\t\t\tfill(idx.begin(), idx.end(), 0);\n\t\t\twhile (true) {\n\t\t\t\tvalue_type flow = find_flow(s, t, INF);\n\t\t\t\tif (flow <= 0) break;\n\t\t\t\tret += flow;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\tvector<pair<int, int>> bipartite_matching (int l, int r) {\n\t\tmax_flow(0, l + r + 1);\n\t\tvector<pair<int, int>> ret;\n\t\tfor (int v = 1; v <= l; v++) {\n\t\t\tfor (const auto &e : g[v]) {\n\t\t\t\tif (e.to == 0 or e.cap > 0) continue;\n\t\t\t\tret.emplace_back(v - 1, e.to - l - 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\tint l, r, m;\n\tcin >> l >> r >> m;\n\tvector<pair<int, int>> e(m);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> e[i].first >> e[i].second;\n\t}\n\t\n\tDinic<int> g(l, r, e);\n\t\n\tcout << g.max_flow(0, l + r + 1) << '\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nbool match(int cur,bool arr[],bool V[],int npair[], int column){\n    if(cur < 0){\n        return true;\n    }\n    if(V[cur]){\n        return false;\n    }\n    V[cur] = true;\n    for(int i = 0; i < column; i++){\n        if(!arr[cur*column + i]){\n            continue;\n        }\n        if(match(npair[i],arr,V,npair,column)){\n            npair[i] = cur;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n    int row,column,E;\n    scanf(\"%d %d %d\",&row,&column,&E);\n    bool arr[row*column],V[row];\n    for(int i = 0; i < row*column; i++){\n        arr[i] = false;\n    }\n    for(int ei = 0; ei < E; ei++){\n        int from,to;\n        scanf(\"%d %d\",&from,&to);\n        arr[from*column + to] = true;\n    }\n    int npair[column],count = 0;\n    for(int i = 0; i < column; i++){\n        npair[i] = -1;\n    }\n    for(int cur = 0; cur < row; cur++){\n        for(int i = 0; i < row; i++){\n            V[i] = false;\n        }\n        if(match(cur,arr,V,npair,column)){\n            count++;\n        }\n    }\n    printf(\"%d\\n\",count);\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Ford-Fulkerson's maximum cardinality bipartite matching\n//\n// Description:\n//   Compute the maximum cardinality matching for bipartite graph.\n//\n// Algorithm:\n//   Standard augmentaing path.\n//\n//\n// Complexity:\n//   O(m n) time\n//\n//\n// Verified:\n//   AOJ Matching\n//\n\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n#define all(c) (c).begin(), (c).end()\n\nstruct graph {\n  int L, R;\n  vector<vector<int>> adj;\n  graph(int L, int R) : L(L), R(R), adj(L+R) { }\n  void add_edge(int u, int v) {\n    adj[u].push_back(v+L);\n    adj[v+L].push_back(u);\n  }\n  int maximum_matching() {\n    vector<int> visited(L), mate(L+R, -1);\n    function<bool(int)> augment = [&](int u) { // DFS\n      if (visited[u]) return false;\n      visited[u] = true;\n      for (int w: adj[u]) {\n        int v = mate[w];\n        if (v < 0 || augment(v)) {\n          mate[u] = w;\n          mate[w] = u;\n          return true;\n        }\n      }\n      return false;\n    };\n    int match = 0;\n    for (int u = 0; u < L; ++u) {\n      fill(all(visited), 0);\n      if (augment(u)) ++match;\n    }\n    return match;\n  }\n};\n\nint main() {\n  int L, R, m; \n  scanf(\"%d %d %d\", &L, &R, &m);\n  graph g(L, R);\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    g.add_edge(u, v);\n  }\n  printf(\"%d\\n\", g.maximum_matching());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define mod 1000000007 //1e9+7\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1001\n\nstruct BipartiteMatching{\n  \n  int V;\n  vector<vector<int> > G;\n  vector<int> match;\n  vector<bool> used;\n  \n  BipartiteMatching(int n):\n    V(n),G(n,vector<int>()),used(n,false){}\n  \n  void add_edge(int u, int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  \n  bool dfs(int v){\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++){\n      int u = G[v][i], w = match[u];\n      if(w < 0 || (!used[w] && dfs(w))){\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n  \n  int solve(){\n    int res = 0;\n    match.assign(V,-1);\n    for(int i=0;i<V;i++){\n      if(match[i] < 0){\n        used.assign(V,false);\n        if(dfs(i)) res++;\n      }\n    }\n    \n    return res;\n  }\n  \n};\n\n\n\nint main(){\n  int x,y,e;\n\n  scanf(\"%d%d%d\",&x,&y,&e);\n\n  BipartiteMatching bip(x+y);\n\n  for(int i=0;i<e;i++){\n    int a,b;\n\n    scanf(\"%d%d\",&a,&b);\n\n    bip.add_edge(a,b+x);\n  }\n\n  printf(\"%d\\n\",bip.solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for (ll i=0;i<(n);++i)\nconst ll MOD=1e9+7;\n\nstruct BipartiteMatching{\n    int n,time;\n    vector<vector<int>> G;\n    vector<int> match,used,dead;\n    BipartiteMatching(int n):n(n),time(0),G(n),\n        match(n,-1),used(n,-1),dead(n,0){}\n    void add_edge(int u,int v){\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    int dfs(int v){\n        used[v]=time;\n        for (int u:G[v]){\n            if (dead[u]) continue;\n            int w=match[u];\n            if (w<0||(used[w]<time&&dfs(w))){\n                match[v]=u;\n                match[u]=v;\n                return 1;\n            }\n        }\n        return 0;\n    }\n    int build(){\n        int res=0;\n        for (int v=0;v<n;++v){\n            if (dead[v]) continue;\n            if (match[v]<0){\n                ++time;\n                res+=dfs(v);\n            }\n        }\n        return res;\n    }\n    int disable(int v){\n        int u=match[v];\n        if (u>=0) match[u]=-1;\n        match[v]=-1; dead[v]=1;\n        ++time;\n        return u>=0?dfs(u)-1:0;\n    }\n    int enable(int v){\n        dead[v]=0;\n        ++time;\n        return dfs(v);\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int X,Y,E; cin >> X >> Y >> E;\n    BipartiteMatching BM(X+Y);\n    rep(i,E){\n        int x,y; cin >> x >> y;\n        BM.add_edge(x,X+y);\n    }\n    cout << BM.build() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <valarray>\nusing namespace std;\n\nbool match(int cur,bool arr[],bool V[],int npair[], int column){\n    if(cur < 0){\n        return true;\n    }\n    if(V[cur]){\n        return false;\n    }\n    V[cur] = true;\n    for(int i = 0; i < column; i++){\n        if(!arr[cur*column + i]){\n            continue;\n        }\n        if(match(npair[i],arr,V,npair,column)){\n            npair[i] = cur;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n    int row,column,E;\n    scanf(\"%d %d %d\",&row,&column,&E);\n    bool arr[row*column],V[row];\n    for(int ei = 0; ei < E; ei++){\n        int from,to;\n        scanf(\"%d %d\",&from,&to);\n        arr[from*column + to] = true;\n    }\n    int npair[column],count = 0;\n    for(int i = 0; i < column; i++){\n        npair[i] = -1;\n    }\n    for(int cur = 0; cur < row; cur++){\n        for(int i = 0; i < row; i++){\n            V[i] = false;\n        }\n        if(match(cur,arr,V,npair,column)){\n            count++;\n        }\n    }\n    printf(\"%d\\n\",count);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma warning(disable:4996)\n#ifdef _MSC_VER\n#  define __builtin_popcount __popcnt\n#endif\n#define int long long\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\ninline void my_io() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tcout << fixed << setprecision(10);\n}\nint x, y, e;\nvector<vector<int>>G;//グラフの隣接リスト表現\nvector<int>match;//マッチングのペア\nvector<bool>used;//ループチェック用\n//uとvを結ぶ辺をグラフに追加する\nvoid add_edge(int u, int v) {\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n//増加パスをDFSで探す\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i<G[v].size(); i++) {\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w<0 || !used[w] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n//二部グラフの最大マッチングを求める\nint bipartitea_matching() {\n\tint res = 0;\n\tfill(match.begin(), match.end(), -1);\n\tfor (int v = 0; v<x+y; v++) {\n\t\tif (match[v]<0) {//頂点vのマッチングのペアがない場合\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tif (dfs(v)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tcin >> x >> y >> e;\n\tG.resize(x + y);\n\tmatch.resize(x + y);\n\tused.resize(x + y);\n\tfor (int i = 0; i < e; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tv += x;\n\t\tadd_edge(u, v);\n\t}\n\tcout << bipartitea_matching() << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(a)  (a).begin(),(a).end()\n#define sz(x) int(x.size())\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<long long, long long> Pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long>> vvll;\ntemplate <typename T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate <typename T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst long long INF = 1LL << 60;\nconst int INT_INF = 1 << 30;\nconst double PI = acos(-1.0);\n#define MOD 1000000007LL\n#define endl \"\\n\"\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  ll N, M, K;\n  cin >> N >> M >> K;\n  if(K == 0){\n    cout << 0 << endl;\n    return 0;\n  }\n  vvll G(N+M, vll(0));\n  while(K--){\n    ll x, y;\n    cin >> x >> y;\n    y += N;\n    G.at(x).push_back(y);\n    G.at(y).push_back(x);\n  }\n  vll match(N+M, -1);\n  vll flag(N+M, 0);\n  function<bool(ll)> dfs = [&](ll v){\n    flag[v] = 1;\n    for(int i = 0; i < sz(G.at(v)); i++){\n      ll next = G.at(v).at(i);\n      ll u = match.at(next);\n      if(u == -1 || (!flag[u] && dfs(u))){\n        match.at(v) = next;\n        match.at(next) = v;\n        return true;\n      }\n    }\n    return false;\n  };\n  ll ans = 0;\n  for(int i = 0; i < N; i++){\n    if(match.at(i) == -1){\n      fill(ALL(flag), 0);\n      if(dfs(i)) ans++;\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\n    sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate <class T> bool chmax(T &a, const T &b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\nstruct Edge {\n  int from, to, cost, rev;\n  Edge(int from, int to, int cost, int rev)\n      : from(from), to(to), cost(cost), rev(rev) {}\n};\nstruct Graph {\n  int V;\n  vector<vector<Edge>> G;\n  vector<int> used;\n  Graph(int V) : V(V) {\n    used = vector<int>(V, 0);\n    G = vector<vector<Edge>>(V);\n  }\n  void add_edge(int from, int to, int cost = 1) {\n    G[from].push_back(Edge(from, to, cost, G[to].size()));\n    G[to].push_back(Edge(to, from, 0, G[from].size() - 1));\n  }\n  int augment_path(int s, int t, int f) {\n    if (s == t)\n      return f;\n    used[s] = true;\n    rep(i, 0, G[s].size()) {\n      Edge &e = G[s][i];\n      if (!used[e.to] && e.cost > 0) {\n        int d = augment_path(e.to, t, min(f, e.cost));\n        if (d > 0) {\n          e.cost -= d;\n          G[e.to][e.rev].cost += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t) {\n    int flow = 0;\n    while (1) {\n      used = vector<int>(V, 0);\n      int f = augment_path(s, t, INF);\n      if (f == 0)\n        break;\n      flow += f;\n    }\n    return flow;\n  }\n};\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int X, Y, E;\n  cin >> X >> Y >> E;\n  Graph g(X + Y + 2);\n  int s = X + Y, t = s + 1;\n  rep(i, 0, E) {\n    int x, y;\n    cin >> x >> y;\n    g.add_edge(x, X + y);\n  }\n  // take care of the direction of edges\n  rep(i, 0, X) g.add_edge(s, i);\n  rep(i, 0, Y) g.add_edge(i + X,t);\n\n  cout << g.max_flow(s, t) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define i_7 (ll)(1E9+7)\n#define i_5 (ll)(1E9+5)\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    else return c+i_7;\n}\ntypedef pair<int,int> i_i;\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E12;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll * pos,ll val){*pos=max(*pos,val);}//Max(&dp[i][j],dp[i-1][j]);\nvoid Min(ll * pos,ll val){*pos=min(*pos,val);}\nvoid Add(ll * pos,ll val){*pos=mod(*pos+val);}\nconst long double EPS=1E-8;\n////////////////////////////////////////\n#define MAX_V 30000//調節！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！\n//辺を表す構造体{行き先、容量、逆辺}\nstruct edge{ll to,cap,rev;};\nvector<edge> G[MAX_V];\nbool used[MAX_V];//dfsですでに調べたかのフラグ\n//fromからtoへの流量capの辺をグラフに追加\nvoid add_edge(ll from,ll to,ll cap){\n    //cout<<from<<\" \"<<to<<\" \"<<cap<<endl;\n    G[from].push_back((edge){to,cap,static_cast<ll>(G[to].size())});\n    G[to].push_back((edge){from,0,static_cast<ll>(G[from].size()-1)});\n}\n//増加パスをdfsで探す\nll dfs(ll v,ll t,ll f){\n    if(v==t)return f;\n    used[v]=true;\n    for(ll i=0;i<G[v].size();i++){\n        edge &e=G[v][i];\n        if(!used[e.to]&&e.cap>0){\n            ll d=dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nll max_flow(ll s,ll t){\n    ll flow=0;\n    while(1){\n        memset(used,0,sizeof(used));\n        ll f=dfs(s,t,inf);\n        if(f==0)return flow;\n        flow+=f;\n    }\n}\n///////////////////////////////////////\n\n\n\nint main(){\n    int x,y,e;cin>>x>>y>>e;\n    set<i_i>s;\n    while(e--){\n        i_i z;cin>>z.first>>z.second;\n        s.insert(z);\n    }\n    int N=105;\n    int flag=0;\n    for(auto z:s){\n        add_edge(z.first,N+z.second,1);\n        \n    }\n    int sta=2*N,end=2*N+1;\n    rep(i,0,N-1){\n        add_edge(sta,i,1);\n        add_edge(i+N,end,1);\n    }\n    cout<<max_flow(sta,end)<<endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint X,Y,E,x,y;\nbool D[110][110] = {};\n\nint PY[110];\nbool V[110];\nbool match(int x) {\n  if(x < 0) return true;\n  if(V[x]) return false;\n  V[x] = true;\n  for(int y = 0; y < Y; ++y) {\n    if(!D[x][y]) continue;\n    if(match(PY[y])) {\n      PY[y] = x;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  cin >> X >> Y  >> E;\n  for(int i = 0; i < E; ++i) {\n    cin >> x >> y;\n    D[x][y] = true;\n  }\n  fill(PY,PY+Y,-1);\n  int count = 0;\n  for(int x = 0; x < X; ++x) {\n    fill(V,V+X,false);\n    if(match(x)) ++count;\n  }\n  cout << count;\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\nusing namespace std;\n\nstruct BipartiteMatching {\n    int n;\n    vector<vector<int>> g;\n    vector<int> match;\n    vector<bool> used;\n    BipartiteMatching(int n) : n(n), g(n), match(n), used(n) {}\n    void addEdge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    int maxmimumMatching(void) {\n        int res = 0;\n        match.assign(n, -1);\n        fill(match.begin(), match.end(), -1);\n        for(int v = 0; v < n; ++v){\n            if (match[v] < 0) {\n                used.assign(n, false);\n                if (augument(v)) res++;\n            }\n        }\n        return res;\n    }\n    bool augument(int v) {\n        used[v] = true;\n        for (int u : g[v]) {\n            int w = match[u];\n            if (w < 0 || (!used[w] && augument(w))) {\n                match[v] = u; \n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\n#include <iostream>\nint main() {\n    int X, Y, E;\n    while (cin >> X >> Y >> E) {\n        BipartiteMatching bm(X + Y);\n        for (int i = 0; i < E; ++i) {\n            int x, y;\n            cin >> x >> y;\n            bm.addEdge(x , y + X);\n        }\n        cout << bm.maxmimumMatching() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\n// ------ Variable ------ //\n\n#define MAX_V 100\n\nint V; vector<int> G[MAX_V];\n\nint match[MAX_V];\n\nbool used[MAX_V];\n\n\n// ------ Bipartite_Matching ------ //\n\nbool search(int v)\n{\n\tused[v] = true;\n\n\tfor (int i = 0; i < G[v].size(); i++)\n\t{\n\t\tint u = G[v][i], w = match[u];\n\n\t\tif (w < 0 || !used[w] && search(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint bipartite_matching()\n{\n\tint res = 0;\n\n\tfill(match, match + V, -1);\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (match[i] < 0)\n\t\t{\n\t\t\tfill(used, used + V, 0);\n\n\t\t\tif (search(i))\n\t\t\t{\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint X, Y, E, A, B;\n\n\tcin >> X >> Y >> E; V = X + Y;\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tG[A].push_back(X + B);\n\t\tG[X + B].push_back(A);\n\t}\n\n\tif (E == 0)\n\t{\n\t\tcout << bipartite_matching() << endl;\n\t}\n\telse\n\t{\n\t\tcout << 0 << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n//by NeighThorn\nusing namespace std;\nconst int maxn=200+5,maxm=10000+5;\nint n,m,e,hd[maxn],to[maxm*2],nxt[maxm*2],cnt,pre[maxn],vis[maxn],ans;\ninline void add(int x,int y){\n\tto[cnt]=y;nxt[cnt]=hd[x];hd[x]=cnt++;\n}\ninline bool dfs(int root){\n\tfor(int i=hd[root];i!=-1;i=nxt[i])\n\t\tif(!vis[to[i]]){\n\t\t\tvis[to[i]]=1;\n\t\t\tif(pre[to[i]]==-1||dfs(pre[to[i]])){\n\t\t\t\tpre[to[i]]=root;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\nsigned main(void){\n\tcnt=0;ans=0;\n\tmemset(hd,-1,sizeof(hd));\n\tmemset(pre,-1,sizeof(pre));\n\tscanf(\"%d%d%d\",&n,&m,&e);\n\tfor(int i=1,x,y;i<=e;i++)\n\t\tscanf(\"%d%d\",&x,&y),add(x,y+n);\n\tfor(int i=0;i<n;i++)\n\t\tmemset(vis,0,sizeof(vis)),ans+=dfs(i);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\nconst int INF = (1 << 30) - 1;\nconst ll INF64 = ((ll)1 << 62) - 1;\nconst double PI = 3.1415926535897932384626433832795;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { -1, 0, 1, 0 };\n\n// ei1333さんからパクった\nstruct Bipartite_Matching\n{\n\tvector< vector< int > > graph;\n\tvector< int > match, alive, used;\n\tint timestamp;\n\n\tBipartite_Matching(int n)\n\t{\n\t\ttimestamp = 0;\n\t\tgraph.resize(n);\n\t\talive.assign(n, 1);\n\t\tused.assign(n, 0);\n\t\tmatch.assign(n, -1);\n\t}\n\n\tvoid add_edge(int u, int v)\n\t{\n\t\tgraph[u].push_back(v);\n\t\tgraph[v].push_back(u);\n\t}\n\n\tbool dfs(int v)\n\t{\n\t\tused[v] = timestamp;\n\t\tfor (int i = 0; i < graph[v].size(); i++) {\n\t\t\tint u = graph[v][i], w = match[u];\n\t\t\tif (alive[u] == 0) continue;\n\t\t\tif (w == -1 || (used[w] != timestamp && dfs(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn (true);\n\t\t\t}\n\t\t}\n\t\treturn (false);\n\t}\n\n\tint bipartite_matching()\n\t{\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < graph.size(); i++) {\n\t\t\tif (alive[i] == 0) continue;\n\t\t\tif (match[i] == -1) {\n\t\t\t\t++timestamp;\n\t\t\t\tret += dfs(i);\n\t\t\t}\n\t\t}\n\t\treturn (ret);\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint x, y, e;\n\tcin >> x >> y >> e;\n\n\tBipartite_Matching graph(x + y);\n\tfor (int i = 0; i < e; i++) {\n\t\tint xx, yy;\n\t\tcin >> xx >> yy;\n\t\tgraph.add_edge(xx, x + yy);\n\t}\n\n\tcout << graph.bipartite_matching() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_7_A&lang=jp\n\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\nusing namespace std;\n\n#define MAX_V 1000\nconst int INF = 1 << 30;\n\n//辺を表す構造体(行先，容量，逆辺)\nstruct edge{\n  int to, cap, rev;\n};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\n//辺の追加\nvoid add_edge(int from, int to, int cap){\n  G[from].push_back(edge{to, cap, (int)G[to].size()});\n  G[to].push_back(edge{from, 0, (int)G[from].size() - 1});\n}\n\n//増加パスをDFSで探す\nint dfs(int v, int t, int f){\n  if(v == t) return f;\n  used[v] = true;\n  for(int i = 0; i < (int)G[v].size(); i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to, t, min(f, e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\n//sからtへの最大流を求める\nint max_flow(int s, int t){\n  int flow = 0;\n  for(;;){\n    fill(used, used + MAX_V, false);\n    int f = dfs(s, t, INF);\n    if(f == 0) return flow;\n    flow += f;\n  }\n}\n\nint main(){\n  int X, Y, M;\n  cin >> X >> Y >> M;\n\n  int s = X + Y + 1;\n  int t = X + Y + 2;\n\n  for(int i = 0; i < X; i++){\n    add_edge(s, i, 1);\n  }\n  for(int i = 0; i < Y; i++){\n    add_edge(i + X, t, 1);\n  }\n\n  for(int i = 0; i < M; i++){\n    int x, y;\n    cin >> x >> y;\n    y += X;\n\n    add_edge(x, y, 1);\n  }\n\n  cout << max_flow(s, t) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int MAX_N=500;\n\nstruct edge{\n\tint to,cap,rev;\n};\n\nvector<edge> G[MAX_N];\nvector<int> check(MAX_N,0);\n\nint dfs(int v,int t, int f ){\n\tif(v==t){return f;}\n\tcheck[v]=1;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(check[e.to]==0 && e.cap > 0){\n\t\t\tint ff =dfs(e.to,t,min(f,e.cap));\n\t\t\tif(ff>0){\n\t\t\t\te.cap -= ff;\n\t\t\t\tG[e.to][e.rev].cap += ff;\n\t\t\t\treturn ff;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxflow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tfill(check.begin(),check.end(),0);\n\t\tint f = dfs(s,t,INT_MAX);\n\t\tif(f==0){return flow;}\n\t\tflow += f;\n\t}\n}\n\nint main(){\n\tint X,Y,E,s,t;\n\tcin >> X >> Y >> E ;\n\t\n\tfor(int i=0;i<E;i++){\n\t\tcin >> s >> t ;\n\t\tG[s].push_back((edge){X+t,1,G[t].size()});\n\t\tG[X+t].push_back((edge){s,0,G[s].size()-1});\n\t}\n\t\n\tfor(int i=0;i<X;i++){\n\t\tG[X+Y].push_back((edge){i,1,G[i].size()});\n\t\tG[i].push_back((edge){X+Y,0,G[X+Y].size()-1});\n\t}\n\t\n\tfor(int i=X;i<X+Y;i++){\n\t\tG[i].push_back((edge){X+Y+1,1,G[X+Y+1].size()});\n\t\tG[X+Y+1].push_back((edge){i,0,G[i].size()-1});\n\t}\n\t/*\n\tint k=11;\n\tfor(int i=0;i<G[k].size();i++){\n\t\tcout << G[k][i].to << endl;\n\t}\n\t*/\n\t\n\tcout << maxflow(X+Y,X+Y+1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << '\\n'; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) do { std::cerr << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); } while (false)\n#else\n\t#define debug(...) do {} while (false)\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\tnamespace std {\n\t\ttemplate<typename T> class dvector : public std::vector<T> {\n\t\tpublic:\n\t\t\tdvector() : std::vector<T>() {}\n\t\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\t\tT& operator[](size_t n) {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst T& operator[](size_t n) const {\n\t\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << '\\n'; return this->at(n);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\tdbool(const dbool& b) : boolvalue(b.boolvalue) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<T>& v) {\n\t\tfor (size_t i = 0; i < v.size(); ++i){ s << v[i]; if (i < v.size() - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::dvector<std::dvector<T>>& vv) {\n\t\ts << \"\\n\"; for (size_t i = 0; i < vv.size(); ++i){ s << vv[i] << \"\\n\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate <typename T, size_t N> std::ostream& operator<<(std::ostream& s, const std::array<T, N>& a) {\n\t\ts << \"{ \"; for (size_t i = 0; i < N; ++i){ s << a[i] << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\\n\"; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << \"\\n\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) {\n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGFPE_exception();\t}\n\tvoid catch_SIGSEGV(int e) { std::cerr << boost::stacktrace::stacktrace() << '\\n'; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = (ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr ll dx[4] = {1LL, 0LL, -1LL, 0LL};\nconstexpr ll dy[4] = {0LL, 1LL, 0LL, -1LL};\nconstexpr ll dx8[8] = {1LL, 0LL, -1LL, 0LL, 1LL, 1LL, -1LL, -1LL};\nconstexpr ll dy8[8] = {0LL, 1LL, 0LL, -1LL, 1LL, -1LL, 1LL, -1LL};\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\nvoid p() { std::cout << '\\n'; }\ntemplate<typename Head, typename... Tail> void p(Head head, Tail... tail) { std::cout << head << (sizeof...(tail) ? \" \" : \"\"); p(tail...); }\ntemplate<typename T> inline void pv(std::vector<T>& v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline T gcd(T a, T b) { return b ? gcd(b,a%b) : a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a,  b) * b; }\ntemplate<typename T> inline bool chmax(T& a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T& a, T b) { return a > b && (a = b, true); }\ntemplate<typename T> inline void uniq(std::vector<T>& v) { v.erase(std::unique(v.begin(), v.end()), v.end()); }\n\n/*-----8<-----template-----8<-----*/\n\n/*\n一般マッチング問題を解く\n(頂点が複数のペアに属さないようなペア決めを考えたとき、ペア数が最大になるような決め方)\n頂点のペアを格納したvectorを返す\n計算量：O(VElogV)\n*/\n::std::vector<::std::pair<ll, ll>> gabow_edmonds(const ::std::vector<::std::vector<ll>>& gra){\n\tstruct edge {\n\t\tll to;\n\t\tll label;\n\t\tedge(ll to, ll label) : to(to), label(label) {}\n\t};\n\t// E0 - 初期化\n\tll N = gra.size();\n\t::std::vector<::std::vector<edge>> g(N + 1);\n\t::std::vector<::std::pair<ll, ll>> edges;\n\t{\n\t\tll cnt = N + 1;\n\t\tfor(ll i = 0;i < N;i++){\n\t\t\tfor(auto to : gra[i]){\n\t\t\t\tif(i < to){\n\t\t\t\t\tg[to + 1].emplace_back(i + 1, cnt);\n\t\t\t\t\tg[i + 1].emplace_back(to + 1, cnt++);\n\t\t\t\t\tedges.emplace_back(i + 1, to + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t::std::vector<ll> mate(N + 1 , 0);\n\t::std::vector<ll> label(N + 1 , -1);\n\t::std::vector<ll> first(N + 1 , 0);\n\t::std::queue<ll> que;\n\n\t// firstの遅延評価\n\t::std::function<ll(ll)> eval_first = [&](ll x){\n\t\tif(label[first[x]] < 0) return first[x];\n\t\tfirst[x] = eval_first(first[x]);\n\t\treturn first[x];\n\t};\n\n\t// サブルーチンR\n\t::std::function<void(ll, ll)> rematch = [&](ll v, ll w){\n\t\t// R1\n\t\tll t = mate[v];\n\t\tmate[v] = w;\n\t\tif(mate[t] != v) return;\n\t\t// R2\n\t\tif(label[v] <= N){\n\t\t\tmate[t] = label[v];\n\t\t\trematch(label[v] , t);\n\t\t}\n\t\t// R3\n\t\telse{\n\t\t\tll x = edges[label[v] - N - 1].first;\n\t\t\tll y = edges[label[v] - N - 1].second;\n\t\t\trematch(x , y);\n\t\t\trematch(y , x);\n\t\t}\n\t};\n\n\t::std::function<void(ll, ll, ll)> assignLabel = [&](ll x, ll y, ll num){\n\t\t// L0\n\t\tll r = eval_first(x);\n\t\tll s = eval_first(y);\n\t\tll join = 0;\n\t\tif(r == s) return;\n\t\t// -numがフラグ\n\t\tlabel[r] = -num;\n\t\tlabel[s] = -num;\n\t\twhile(true){\n\t\t\t// L1\n\t\t\tif(s != 0) ::std::swap(r , s);\n\t\t\t// L2\n\t\t\tr = eval_first(label[mate[r]]);\n\t\t\tif(label[r] == -num){\n\t\t\t\tjoin = r;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlabel[r] = -num;\n\t\t}\n\t\t// L3\n\t\tll v = first[x];\n\t\t// L4\n\t\twhile(v != join){\n\t\t\tque.push(v);\n\t\t\tlabel[v] = num;\n\t\t\tfirst[v] = join;\n\t\t\tv = first[label[mate[v]]];\n\t\t}\n\t\t// L3\n\t\tv = first[y];\n\t\t// L4\n\t\twhile(v != join){\n\t\t\tque.push(v);\n\t\t\tlabel[v] = num;\n\t\t\tfirst[v] = join;\n\t\t\tv = first[label[mate[v]]];\n\t\t}\n\t\t// L5は遅延評価しているため不要\n\t\t// L6\n\t\treturn;\n\t};\n\n\t::std::function<bool(ll)> augment_check = [&](ll u){\n\t\t// E1 後半\n\t\tfirst[u] = 0;\n\t\tlabel[u] = 0;\n\t\tque.push(u);\n\t\twhile(!que.empty()){\n\t\t\t// E2 \n\t\t\tll x = que.front();\n\t\t\tque.pop();\n\t\t\tfor(auto e : g[x]){\n\t\t\t\tll y = e.to;\n\t\t\t\t// E3\n\t\t\t\tif(mate[y] == 0 && y != u){\n\t\t\t\t\tmate[y] = x;\n\t\t\t\t\trematch(x , y);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// E4\n\t\t\t\telse if(label[y] >= 0){\n\t\t\t\t\tassignLabel(x , y , e.label);\n\t\t\t\t}\n\t\t\t\t// E5\n\t\t\t\telse if(label[mate[y]] < 0){\n\t\t\t\t\tlabel[mate[y]] = x;\n\t\t\t\t\tfirst[mate[y]] = y;\n\t\t\t\t\tque.push(mate[y]);\n\t\t\t\t}\n\t\t\t\t// E6\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\tfor(ll i = 1;i <= N;i++){\n\t\t// E1\n\t\tque = ::std::queue<ll>();\n\t\tif(mate[i] != 0) continue;\n\t\tif(augment_check(i)){\n\t\t\t// E7\n\t\t\t::std::fill(label.begin(), label.end(), -1);\n\t\t}\n\t}\n\n\t::std::vector<::std::pair<ll, ll>> ans;\n\tfor(ll i = 1;i <= N;i++){\n\t\tif(i < mate[i]){\n\t\t\tans.emplace_back(i-1 , mate[i]-1);\n\t\t}\n\t}\n\treturn ans;\n}\n\n/*-----8<-----library-----8<-----*/\n\nvoid solve() {\n\tll X,Y,E;\n\tcin>>X>>Y>>E;\n\tll N=X+Y;\n\tvector<vector<ll>> g(N);\n\trep(i,E){\n\t\tll a,b;\n\t\tcin>>a>>b;\n\t\tg[a].push_back(b+X);\n\t\tg[b+X].push_back(a);\n\t}\n\n\tvector<pair<ll,ll>> pairv = gabow_edmonds(g);\n\tdebug(pairv);\n\tp(pairv.size());\n}\n\nsigned main() {\n\tsolve();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <list>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int maxv=100;\nint N,M,E;\nvector<int> g[maxv];\nint vis[maxv];\nint match[maxv];\nvoid add_edge(int from,int to)\n{\n    g[from].push_back(to);\n    g[to].push_back(from);\n}\nbool dfs(int t)\n{\n    vis[t]=1;\n    for(int i=0;i<g[t].size();i++)\n    {\n        int v=g[t][i],w=match[v];\n        if(w<0||(!vis[w]&&dfs(w)))\n        {\n            match[t]=v;\n            match[v]=t;\n            return true;\n        }\n    }\n    return false;\n}\nvoid binrary_match()\n{\n    memset(match,-1,sizeof(match));\n    int res=0;\n    for(int i=0;i<N+M;i++)\n    {\n        if(match[i]<0)\n        {\n            memset(vis,0,sizeof(vis));\n            if(dfs(i)) res++;\n        }\n    }\n    printf(\"%d\\n\",res);\n}\nint main()\n{\n//    freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d%d%d\",&N,&M,&E);\n    int u,v;\n    for(int i=0;i<E;i++)\n    {\n        scanf(\"%d%d\",&u,&v);\n        add_edge(u,N+v);\n    }\n    binrary_match();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n\nusing namespace std;\n\nconst int MAX_V = 205;\nvector<int> G[MAX_V];\nvector<int> match(MAX_V);\nvector<bool> used(MAX_V);\n\nvoid add_edge(const int &u, const int &v) {\n\tG[u].emplace_back(v);\n\tG[v].emplace_back(u);\n}\n\nbool dfs(const int &v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//?????¨??????????????°????????§???????±?????????????\nint bipartite_matching(const int &V) {\n\tint res = 0;\n\tfill(match.begin(), match.end(), -1);\n\tfor (int v = 0; v < V; ++v) {\n\t\tif (match[v] < 0) {\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tif (dfs(v))++res;\n\t\t}\n\t}\n\treturn res - 1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::ios_base::sync_with_stdio(false);\n\tint X, Y, E, s, t; cin >> X >> Y >> E;\n\tfor (int i = 0; i < E; ++i) {\n\t\tcin >> s >> t;\n\t\tadd_edge(s, t);\n\t}\n\tint ans = bipartite_matching(X + Y);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\nstruct Maxflow {\n\tstruct edge { int to, cap, rev; edge(int t, int c, int r) { to = t; cap = c; rev = r; } };\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> itr, level;\n\n\tMaxflow(int V) : V(V) { G.assign(V, vector<edge>()); }\n\n\tvoid add_edge(int from, int to, int cap) {\n\t\tG[from].push_back(edge( to, cap, (int)G[to].size() ));\n\t\tG[to].push_back(edge( from, 0, (int)G[from].size() - 1 ));\n\t}\n\n\tvoid bfs(int s) {\n\t\tlevel.assign(V, -1);\n\t\tqueue<int> q;\n\t\tlevel[s] = 0; q.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (auto &e : G[v]) {\n\t\t\t\tif (e.cap > 0 and level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t) return f;\n\t\tfor (int& i = itr[v]; i < (int)G[v].size(); ++i) {\n\t\t\tedge& e = G[v][i];\n\t\t\tif (e.cap > 0 and level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint run(int s, int t) {\n\t\tint ret = 0, f;\n\t\twhile (bfs(s), level[t] >= 0) {\n\t\t\titr.assign(V, 0);\n\t\t\twhile ((f = dfs(s, t, INF)) > 0) ret += f;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main()\n{\n\tint X, Y, E;\n\tcin >> X >> Y >> E;\n\n\tMaxflow mf(1+X+Y+1);\n\trep(i, 0, X) mf.add_edge(0, i+1, 1);\n\trep(i, 0, E)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tmf.add_edge(1 + x, 1 + X + y, 1);\n\t}\n\trep(i, 0, Y) mf.add_edge(1 + X + i, 1 + X + Y, 1);\n\n\tcout << mf.run(0, 1 + X + Y) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4996)\n#define EVEN(x) (mu[x] == x || (mu[x] != x && phi[mu[x]] != mu[x]))\n#define ODD(x)  (mu[x] != x && phi[mu[x]] == mu[x] && phi[x] != x)\n#define OUTER(x) (mu[x] != x && phi[mu[x]] == mu[x] && phi[x] == x)\nusing namespace std;\ntypedef int Weight;\nstruct Edge {\n\tint src, dst; Weight weight;\n\tEdge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) { }\n};\nbool operator<(const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nint maximumMatching(const Graph &g) {\n\tint n = g.size();\n\tvector<int> mu(n), phi(n), rho(n), scanned(n);\n\tfor (int v = 0; v < n; v++) mu[v] = phi[v] = rho[v] = v;\n\tfor (int x = -1; ; ) {\n\t\tif (x < 0) {\n\t\t\tfor (x = 0; x < n && (scanned[x] || !EVEN(x)); ++x);\n\t\t\tif (x == n) break;\n\t\t}\n\t\tint y = -1;\n\t\tfor (int e = 0; e < (int)g[x].size(); e++) if (OUTER(g[x][e].dst) || (EVEN(g[x][e].dst) && rho[g[x][e].dst] != rho[x])) y = g[x][e].dst;\n\t\tif (y == -1) scanned[x] = true, x = -1;\n\t\telse if (OUTER(y)) phi[y] = x;\n\t\telse {\n\t\t\tvector<int> dx(n, -2), dy(n, -2);\n\t\t\tfor (int k = 0, w = x; dx[w] < 0; w = k % 2 ? mu[w] : phi[w]) dx[w] = k++;\n\t\t\tfor (int k = 0, w = y; dy[w] < 0; w = k % 2 ? mu[w] : phi[w]) dy[w] = k++;\n\t\t\tbool vertex_disjoint = true;\n\t\t\tfor (int v = 0; v < n; v++) if (dx[v] >= 0 && dy[v] > 0) vertex_disjoint = false;\n\t\t\tif (vertex_disjoint) {\n\t\t\t\tfor (int v = 0; v < n; v++) if (dx[v] % 2) mu[phi[v]] = v, mu[v] = phi[v];\n\t\t\t\tfor (int v = 0; v < n; v++) if (dy[v] % 2) mu[phi[v]] = v, mu[v] = phi[v];\n\t\t\t\tmu[x] = y; mu[y] = x; x = -1;\n\t\t\t\tfor (int v = 0; v < n; v++) phi[v] = rho[v] = v, scanned[v] = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint r = x, d = n;\n\t\t\t\tfor (int v = 0; v < n; v++) if (dx[v] >= 0 && dy[v] >= 0 && rho[v] == v && d > dx[v]) d = dx[v], r = v;\n\t\t\t\tfor (int v = 0; v < n; v++) if (dx[v] <= d && dx[v] % 2 && rho[phi[v]] != r) phi[phi[v]] = v;\n\t\t\t\tfor (int v = 0; v < n; v++) if (dy[v] <= d && dy[v] % 2 && rho[phi[v]] != r) phi[phi[v]] = v;\n\t\t\t\tif (rho[x] != r) phi[x] = y;\n\t\t\t\tif (rho[y] != r) phi[y] = x;\n\t\t\t\tfor (int v = 0; v < n; v++) if (dx[rho[v]] >= 0 || dy[rho[v]] >= 0) rho[v] = r;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0; for (int u = 0; u < n; u++) if (u < mu[u]) ret++;\n\treturn ret;\n}\nint X, Y, E, x, y; Graph G;\nint main() {\n\tscanf(\"%d%d%d\", &X, &Y, &E); G.resize(X + Y);\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tG[x].push_back(Edge(x, X + y, 1));\n\t\tG[X + y].push_back(Edge(X + y, x, 1));\n\t}\n\tprintf(\"%d\\n\", maximumMatching(G));\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint exist(int y,const vector<int> &p) //y?????????????????¨??????????????§???????????? ????????°????????????x????????????????????????\n{\n    for(int i = 0; i < p.size(); i++)\n    {\n        if(p[i] == y)\n            return i;\n    }\n    return -1;\n}\n\nbool match(int x, int start, const vector<vector<bool> > &v,vector<int> &p) //??????????????°\n{\n    for(int i = start; i < v[0].size(); i++) //start??????y?????????????????§??°?????????\n    {\n        if(v[x][i]) //??????x,i?????¨?????????????????°\n        {\n            int rem = exist(i, p); //i????????§?????¨??????????????????\n            p[x] = i; //x,u?????¨????????§?????????\n            if(rem < 0) //i????????¨????????¨????????????????????°??¢??°?????????\n            {\n                return true;\n                \n            }\n            else //i????????¨????????¨?????????????????°\n            {\n                p[rem] = -1; //????????¨??????????¶????\n                bool ok = match(rem,i+1,v,p); //??£????????¨??????????????????????????????\n                if(!ok) //???????????????????????£??????????????????\n                {\n                    p[x] = -1;\n                    p[rem]= i;\n                }\n                else //???????????£????????¢??°????????????\n                    return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int xn,yn,e,x,y;\n    cin >> xn >> yn >> e;\n    vector< vector<bool> > v(xn, vector<bool>(yn,false));\n    vector<int> p(xn,-1);\n    for(int i = 0; i < e; i++)\n    {\n        cin >> x >> y;\n        v[x][y] = true;\n    }//???????????§?????????\n    \n    for(int i = 0; i<xn;i++)\n    {\n        match(i,0,v,p);\n    }\n    //???????????§?¨?????????????????????¨???\n    int c = 0;\n    for(int i = 0; i<p.size();i++)\n    {\n        if(p[i]>=0)\n            c++;\n    }\n    cout << c << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<P> vp;\ntypedef vector<bool> vb;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst vi emp;\n\nclass Graph{\n\tprivate:\n\tint V;\n\tvvi List;\n\tbool Bipartite_Matching_dfs(int v,vi& match,vb& used){\n\t\tused[v]=1;\n\t\tfor(auto i=List[v].begin();i!=List[v].end();i++){\n\t\t\tint w=match[*i];\n\t\t\tif(w<0||!used[w]&&Bipartite_Matching_dfs(w,match,used)){\n\t\t\t\tmatch[v]=*i;\n\t\t\t\tmatch[*i]=v;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic:\n\tGraph(int v){\n\t\tV=v;\n\t\tList=vvi(v);\n\t}\n\tint Bipartite_Matching(){\n\t\tint ans=0;\n\t\tvi match(V,-1);\n\t\tfor(auto i=0;i<V;i++){\n\t\t\tif(match[i]<0){\n\t\t\t\tvb used(V);\n\t\t\t\tif(Bipartite_Matching_dfs(i,match,used)) ans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid add_edge(int x,int y){\n\t\tList[x].push_back(y);\n\t\tList[y].push_back(x);\n\t}\n};\n\nint X,Y,E;\n\nint main(){\n\tcin>>X>>Y>>E;\n\tGraph gra(X+Y);\n\tint s,t;\n\tfor(int i=0;i<E;i++){\n\t\tcin>>s>>t;\n\t\tgra.add_edge(s,t+X);\n\t}\n\tcout<<gra.Bipartite_Matching()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\n#include <cstring>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for(int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define Cout(obj) cout << obj << endl\n#define Size(obj) (int)(obj).size()\n#define fcout cout << fixed << setprecision(10)\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nconst int MaxV = 10000;\nint V;\nvector<int> graph[MaxV];\nint match[MaxV];\nbool used[MaxV];\n\nvoid addEdge(int u, int v)\n{\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n}\n\nbool dfs(int v)\n{\n    used[v] = true;\n    \n    for(auto e : graph[v])\n    {\n        int u = e, w = match[u];\n\n        if(w < 0 || !used[w] && dfs(w))\n        {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint bipartiteMatcing()\n{\n    int res = 0;\n\n    memset(match, -1, sizeof(match));\n\n    REP(v, V)\n    {\n        if(match[v] < 0)\n        {\n            memset(used, 0, sizeof(used));\n\n            if(dfs(v))\n            {\n                res++;\n            }\n        }\n    }\n\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    \n    V = X + Y;\n    int S = X + Y, T = S + 1;\n\n    REP(i, X)\n    {\n        addEdge(S, i);\n    }\n\n    REP(i, Y)\n    {\n        addEdge(T, i + X);\n    }\n\n    REP(i, E)\n    {\n        int x, y;\n        cin >> x >> y;\n\n        addEdge(x, y + X);\n    }\n\n    Cout(V - bipartiteMatcing());\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n \nint X,Y,E,x,y;\nbool D[110][110]={};\nint PY[100];\nbool V[110];\n \nbool match(int x)\n{\n    if(x<0) return true;\n    if(V[x]) return false;\n    V[x]=true;\n    for(int y=0;y<Y;++y){\n        if(!D[x][y]) continue;\n        if(match(PY[y])){\n            PY[y]=x;\n            return true;\n        }\n    }\n    return false;\n}\n \nint main()\n{\n    cin>>X>>Y>>E;\n    for(int i=0;i<E;++i){\n        cin>>x>>y;\n        D[x][y]=true;\n    }\n \n    fill(PY, PY+Y, -1);\n    int count=0;\n    for(int x=0;x<X;++x){\n        fill(V, V+X, false);\n        if(match(x)) ++count;\n    }\n \n    cout<<count<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint X,Y,E,x,y;\nbool D[110][110] = {};\n\nint PY[110];\nbool V[110];\nbool match(int x) {\n  if(x < 0) return true;\n  if(V[x]) return false;\n  V[x] = true;\n  for(int y = 0; y < Y; ++y) {\n    if(!D[x][y]) continue;\n    if(match(PY[y])) {\n      PY[y] = x;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  cin >> X >> Y  >> E;\n  for(int i = 0; i < E; ++i) {\n    cin >> x >> y;\n    D[x][y] = true;\n  }\n  fill(PY,PY+Y,-1);\n  int count = 0;\n  for(int x = 0; x < X; ++x) {\n    fill(V,V+X,false);\n    if(match(x)) ++count;\n  }\n  cout << count << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <sstream>\n\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <list>\n#include <deque>\n#include <queue>\n#include <stack>\n\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <functional>\n\n#include <chrono>\n#include <random>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing ui64 = uint_fast64_t;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vl = vector<i64>;\nusing vvl = vector<vl>;\nusing vd = vector<double>;\nusing vvd = vector<vd>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing pii = pair<int, int>;\nusing pll = pair<i64, i64>;\n\ntemplate<class T>\nistream& operator >> (istream& is, T& vec){\n    for(auto&& x:vec) is >> x;\n    return is;\n}\n\ntemplate<class T>\nauto operator<<(std::ostream& os, const T& vec)\n    -> typename std::conditional<true, std::ostream&, decltype(*vec.begin())>::type{\n    os << \"[ \";\n    for(auto it = vec.begin(); it != vec.end(); ++it){\n        os << *it << (it+1 == vec.end() ? \" \" : \", \");\n    }\n    os << \"]\";\n    return os;\n}\n\n//////////////////////////////////////////////////\n\ntemplate<typename T>\nstruct edge{\n    int f, t;\n    T data;\n    edge(int f_, int t_, T data_):f(f_), t(t_), data(data_){};\n    edge(){};\n    bool operator<(const edge& r){\n        return this->data < r.data;\n    }\n};\n\ntemplate<typename T>\nstruct graph{\n    vector< vector<edge<T> > > data;\n    graph(int n):data(n){};\n    graph(){};\n    int size(){\n        return (int)data.size();\n    }\n    void add_edge(int f, int t, T c){\n        data[f].emplace_back(f, t, c);\n    }\n};\n\n//////////////////////////////////////////////////\n\ntemplate<typename T>\npair<int, vi> bipartite_matching(graph<T> &G, vector<int> U){\n    const int INF = numeric_limits<int> :: max() - 5;\n    graph<T> H = G;\n    H.data.resize(H.size() + 1);\n    int NIL = (int)G.size();\n    vi ret(H.size(), NIL);\n    vi dist(H.size(), -10);\n\n    function<bool(void)> BFS = [&](){\n        queue<int> q;\n        for(auto&& u:U){\n            if(ret[u] == NIL){\n                dist[u] = 0;\n                q.push(u);\n            }else\n                dist[u] = INF;\n        }\n        dist[NIL] = INF;\n        while(!q.empty()){\n            int u = q.front();q.pop();\n            if(dist[u] < dist[NIL])\n                for(auto&& e:H.data[u]){\n                    if(dist[ret[e.t]] == INF){\n                        dist[ret[e.t]] = dist[u] + 1;\n                        q.push(ret[e.t]);\n                    }\n                }\n        }\n        return dist[NIL] != INF;\n    };\n\n    function<bool(int)> DFS = [&](int u){\n        if(u != NIL){\n            for(auto&& e:H.data[u])\n                if(dist[ret[e.t]] == dist[u] + 1)\n                    if(DFS(ret[e.t])){\n                        ret[e.t] = u;\n                        ret[u] = e.t;\n                        return true;\n                    }\n            dist[u] = INF;\n            return false;\n        } \n        return true;\n    };\n\n    int m = 0;\n    int c = 0;\n    while(BFS()){\n        for(auto&& u:U)\n            if(ret[u] == NIL)\n                if(DFS(u))m++;\n    }\n\n    return make_pair(m, ret);\n}\n\n//////////////////////////////////////////////////\n\nint main(){\n    int x, y, e;\n    cin >> x >> y >> e;\n    graph<int> g(x+y);\n    vi U(x);\n    for(int i=0;i<e;i++){\n        int f, t;\n        cin >> f >> t;\n        t += x;\n        g.add_edge(f, t, 0);\n        g.add_edge(t, f, 0);\n    }\n    for(int i=0;i<x;i++)U[i] = i;\n    pair<int, vi> r = bipartite_matching(g, U);\n    cout << r.first << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 正答者の解答より(※一部改変, %d を 使用, %llu だと WA に なってしまう).\n// iman12氏.\n// http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3416985#1\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n  \nLL g[102][102], matchU[102], ans;\nbool vis[102];\nLL X, Y, E;\n  \nbool dfs(LL v){\n    for (int i = 0; i < Y; i++){\n        if (g[v][i] && !vis[i]){\n            vis[i] = true;\n            if(matchU[i] < 0 || dfs(matchU[i])){\n                matchU[i] = v;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n  \nint main() {\n \n    // 1. 入力.\n    scanf(\"%d %d %d\", &X, &Y, &E);\n     \n    // 2. 始点, 終点.\n    for(int i = 0; i < E; i++) {\n        int fr, to;\n        scanf(\"%d %d\", &fr, &to);\n        g[fr][to] = 1;  \n    }\n     \n    // 3. マッチング.\n    for(int i = 0; i < 102; i++) matchU[i] = -1;\n    for(int i = 0; i < X; i++){\n        for (int j = 0; j < 102; j++) vis[j] = 0;\n        if(dfs(i)) ans++; \n    }\n     \n    // 4. 出力.\n    printf(\"%d\\n\", ans);\n \n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\n//const int dx[] = {-1, 0, 1, 0};\n//const int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n#define MAX_V 150\n#define INF (1<<20)\n\nstruct Edge {\n    int to;\n    int cap;\n    int rev;\n};\n\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((Edge) {to, cap, (int) G[to].size()});\n    G[to].push_back((Edge) {from, 0, (int) G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n\n    used[v] = true;\n\n    for (int i = 0; i < G[v].size(); i++) {\n        Edge &e = G[v][i];\n\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap -= d;\n                return d;\n            }\n        }\n\n    }\n\n    return 0;\n\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (true) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) {\n            return flow;\n        }\n        flow += f;\n    }\n}\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n\nint main() {\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n\n    int s = 0;\n    int t = X + Y + 1;\n\n    //sからXに辺を貼る\n    //Yからtに辺を貼る\n    for (int i = 1; i <= X; i++) add_edge(s, i, 1);\n    for (int i = X + 1; i <= (X + Y); i++) add_edge(i, t, 1);\n\n    //XとYに辺を貼る\n    for (int i = 0; i < E; i++) {\n        int x, y;\n        cin >> x >> y;\n        x++;\n        y += (X + 1);\n        add_edge(x, y, 1);\n    }\n\n    cout << max_flow(s, t) <<endl;\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <complex>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nconst int INF = 1 << 27;\nconst int MAX_V = 101;\n//////////////////////////////\n// 2??¨??????????????°(???????????¨???1)\nint V, match[MAX_V], used[MAX_V];\nvector<int> G[MAX_V];\n\nbool dfs(int v){\n  used[v] = true;\n  REP(i, G[v].size()){\n    int u = G[v][i], w = match[u];\n    if(w < 0 || (!used[w] && dfs(w))){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartite_matching(){\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  REP(v, V)\n    if(match[v] < 0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)) ++res;\n    }\n  return res;\n}\nint main() {\n  int X, Y, E; cin >>X >>Y >>E;\n  V = X + Y;\n  REP(i, E){\n    int u, v; cin >>u >>v;\n    v += X;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  cout << bipartite_matching()/2 <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=155;\nconst int INF=2e9;\nint n,cost[M][M],from[M],lx[M],ly[M],slack[M],vx[M],vy[M];\nint path(int v){\n  int t;\n  vx[v]=1;\n  for(int i=1;i<=n;i++)\n    {\n      if(vy[i])continue;\n      t=lx[v]+ly[i]-cost[v][i];\n      if(t==0)\n\t{\n\t  vy[i]=1;\n\t  if(from[i]==0||path(from[i]))\n\t    {\n\t      from[i]=v;\n\t      return 1;\n            }\n        }\n      else if(t<slack[i])\n\tslack[i]=t;\n    }\n  return 0;\n}\nint hung()\n{\n  int d,ans=0;\n  for(int i=1;i<=n;i++)\n    while(true)\n      {\n\tmemset(vx,0,sizeof(vx));\n\tmemset(vy,0,sizeof(vy));\n\tfor(int j=1;j<=n;j++)\n\t  slack[j]=INF;\n\tif(path(i)) break;\n\td=INF;\n\tfor(int j=1;j<=n;j++)\n\t  if(!vy[j] && slack[j]<d)\n\t    d=slack[j];\n\tfor(int j=1;j<=n;j++)\n\t  {\n\t    if(vx[j])lx[j]-=d;\n\t    if(vy[j])ly[j]+=d;\n\t  }\n      }\n  for(int i=1;i<=n;i++)\n    ans+=cost[from[i]][i];//the from meaning...\n  return ans;\n}\nint main()\n{\n  int y,e;\n  cin>>n>>y>>e;\n  while(e--)\n    {\n      int u,v;cin>>u>>v;u++;v++;\n      cost[u][v]=1;\n      if(cost[u][v]>lx[u])\n\tlx[u]=cost[u][v];\n    }\n  n=max(n,y);\n  cout<<hung();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass dinic{\nprivate:\n\tunordered_map<int,unordered_map<int,T>> mp;\n\tunordered_map<int,int> level;\n\tunordered_set<string> visited;\npublic:\n\tvoid add_edge(int from, int to, T cap){\n\t\tmp[from][to] = cap;\n\t\tmp[to][from] = 0;\n\t}\n\n\tvoid bfs(int s){\n\t\tlevel.clear();\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\n\t\t\tint v = q.front();q.pop();\n\t\t\tfor(auto x:mp[v]){\n\t\t\t\tif(x.second > 0 && !level.count(x.first)){\n\t\t\t\t\tlevel[x.first] = level[v] + 1;\n\t\t\t\t\tq.push(x.first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tT dfs(int v, int t, T f){\n\t\tif(v == t){\n\t\t\treturn f;\n\t\t}\n\t\tfor(auto x:mp[v]){\n\t\t\tif(visited.count(to_string(v) + \":\" + to_string(x.first))) continue;\n\t\t\tvisited.insert(to_string(v) + \":\" + to_string(x.first));\n\t\t\tif(x.second > 0 && level.count(x.first) && level[v] < level[x.first]){\n\t\t\t\tT d = dfs(x.first, t, min(f, x.second));\n\t\t\t\tif(d > 0){\n\t\t\t\t\tmp[v][x.first] -= d;\n\t\t\t\t\tmp[x.first][v] += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tT max_flow(int s, int t){\n\t\tT flow = 0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(!level.count(t)) return flow;\n\t\t\tvisited.clear();\n\t\t\tT f;\n\t\t\twhile((f = dfs(s, t, 10000000)) > 0){\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main(){\n\tdinic<int> g;\n\tint x,y,e;\n\tcin >> x >> y >> e;\n\tfor(int i=0;i<e;i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tg.add_edge(-1,x,1);\n\t\tg.add_edge(x,y+100,1);\n\t\tg.add_edge(y+100,-2,1);\n\t}\n\tcout << g.max_flow(-1,-2) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n \n \nstruct edge {\n  int from;\n  int to;\n  i64 cost;\n  int num;\n};\n \ni64 gabow_scaling_wbm(const vector<vector<edge>>& g, int V0) {\n  int n = g.size();\n  int m = 0;\n  auto MF = [&]() {\n    i64 MAX = 1;\n    for(int i = 0;i < n;i++) {\n      for(auto e : g[i]) {\n        m++;\n        MAX = max(MAX , abs(e.cost));\n      }\n    }\n    return MAX;\n  };\n  int k = (int)log2(MF()) + 1;\n  vector<edge> es(m);\n \n  for(int i = 0;i < n;i++) {\n    for(auto e : g[i]) {\n      es[e.num] = e;\n    }\n  }\n \n \n  vector<i64> c(m,0);\n  vector<i64> yd(n, 0);\n  vector<i64> y(n,0);\n  vector<int> mate(n , -1);\n  vector<int> used(n, false);\n \n  auto cl = [&c, &y, &mate](const edge& e) {\n    return c[e.num] - y[e.from] - y[e.to] + (mate[e.to] == e.from ? 0 : 1);\n  };\n \n  auto eligible = [&cl, &yd](const edge& e) {\n    return yd[e.from] + yd[e.to] == cl(e);\n  };\n \n  auto hk = [n,m, &es,V0, &cl , &eligible, &yd, &used, &mate, &g]() {\n    bool loop = false;\n    bool res = true;\n    vector<bool> vv(n, false);\n\n    do{\n      loop = false;\n      vector<bool> vis(n, false);\n\n      function<bool(int)> hk_dfs = [&](int v) {\n        vis[v] = true;\n        for(auto e : g[v]) {\n          if(!eligible(e)) continue;\n          if(mate[e.to] == -1 || (!vis[mate[e.to]] && hk_dfs(mate[e.to]))) {\n            mate[e.to] = v;\n            used[v] = true;\n            vv[e.to] = true;\n            return true;\n          }\n        }\n        return false;\n      };\n\n\n      for(int i = 0;i < V0;i++) {\n        if(!used[i]) {\n          if(hk_dfs(i)) {\n            loop = true;\n          }\n        }\n      }\n      res = true;\n      for(int i = V0;i < n;i++) {\n        if(mate[i] == -1) res = false;\n      }\n    } while(loop);\n    /*\n    cout << \"===\" << endl;\n    for(int i = V0;i < n;i++) {\n      if(mate[i] != -1) {\n        cout << mate[i] << \"-\" << i << endl;\n      }\n    }\n    */\n\n    for(int i = V0;i < n;i++) {\n      if(vv[i]) yd[i]--;\n    }\n    return res;\n  };\n \n  for(int s = k - 1;s >= 0;s--) {\n    //cout << \"scaling\" << \" \" << s << endl;\n    for(int i = 0;i < m;i++) {\n      c[i] = c[i] * 2 + (es[i].cost >= 0 ? 1 : -1) * ((abs(es[i].cost) >> s) & 1);\n    }\n    for(int i = 0;i < n;i++) {\n      y[i] = y[i] * 2 - 1;\n    }\n\n    yd.assign(n, 0);\n    mate.assign(n, -1);\n    used.assign(n, false);\n \n    while(!hk()) {\n      vector<bool> vis(n, false);\n \n      using P = pair<i64,i64>;\n\n      vector<queue<int>> Q(5 * n + 1);\n      int idx = 0;\n\n      vector<i64> dd(n, 0);\n      i64 DELTA = 0;\n \n      for(int i = 0;i < V0;i++) {\n        if(!used[i]) {\n          for(auto e: g[i]) {\n            Q[cl(e) - yd[i] - yd[e.to] + dd[i]].push(e.to);\n          }\n          vis[i] = true;\n        }\n      }\n\n      bool freed = false;\n      \n      while(true) {\n        while(idx < Q.size() && Q[idx].empty()) idx++;\n        if(idx >= Q.size()) break;\n        i64 D = idx;\n        int w = Q[idx].front();\n        Q[idx].pop();\n        if(vis[w]) continue;\n        //if(freed && DELTA != D) break;\n        vis[w] = true;\n        DELTA = D;\n        dd[w] = DELTA;\n        if(mate[w] != -1 && !vis[mate[w]]) {\n          int mm = mate[w];\n          dd[mm] = DELTA;\n          for(auto e : g[mm]) {\n            if(vis[e.to]) continue;\n            if(mate[e.to] == mm) continue;\n            Q[cl(e) - yd[mm] - yd[e.to] + dd[mm]].push(e.to);\n          }\n          vis[mm] = true;\n        }\n        else if(mate[w] == -1) {\n          freed = true;\n        }\n      }\n \n      for(int i = 0;i < n;i++) {\n        if(!vis[i]) continue;\n        yd[i] = yd[i] + (DELTA - dd[i]) * (i < V0 ? 1 : -1);\n      }\n    }\n    for(int i = 0;i < n;i++) {\n      y[i] = y[i] + yd[i];\n    }\n  }\n \n  i64 ans = 0;\n  for(int i = 0;i < V0;i++) {\n    for(auto e: g[i]) {\n      if(mate[e.to] == i) {\n        ans += e.cost;\n      }\n    }\n  }\n  return ans;\n}\n\nint main() {\n  int x,y,m;\n  cin >> x >> y >> m;\n  vector<vector<edge>> g(x + y + x + y);\n  int idx = 0;\n  for(int i = 0;i < m;i++) {\n    int v,w;\n    cin >> v >> w;\n    g[v].push_back({v, w + x + y, -1  , idx++});\n    g[w + x].push_back({w + x, v + x + y + y, -1, idx++});\n  }\n  for(int i = 0;i < x; i++) {\n    g[i].push_back({i, i + x + y + y, 0, idx++});\n  }\n  for(int i = x;i < x + y;i++) {\n    g[i].push_back({i, i + y, 0, idx++});\n  }\n  cout << -gabow_scaling_wbm(g,x + y) / 2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma region macros_and_aliases\n\n#define rep(i, n) for(long long i = 0; i < (n); i++)\n#define rrep(i, n) for(long long i = (n)-1; i > -1; i--)\n#define Rep(i, m, n) for(long long i = (m); i < (n); i++)\n#define rRep(i, m, n) for(long long i = (n)-1; i >= (m); i--)\n#define REP(i, m, n, p) for(long long i = m; i < n; i += p)\n#define foa(s, v) for(auto &s : v)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define pq priority_queue\n#define bcnt(n) __builtin_popcountll(n)\n#define endk endl\n#define ednl endl\n#define enld endl\n\nusing ll = long long;\nusing ld = long double;\nusing vb = vector<bool>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vvvll = vector<vvll>;\nusing mll = map<long long, long long>;\nusing pll = pair<long long, long long>;\nusing qll = queue<long long>;\nusing sll = set<long long>;\nusing vpll = vector<pair<long long, long long>>;\ntemplate <class T = ll>\nusing V = vector<T>;\ntemplate <class T = ll>\nusing VV = V<V<T>>;\ntemplate <class T = ll>\nusing VVV = V<V<V<T>>>;\n//昇順pq(小さい方から取り出す)\ntemplate <class T = ll>\nusing pqup = priority_queue<T, vector<T>, greater<T>>;\n//降順pq(大きい方から取り出す)\ntemplate <class T = ll>\nusing pqdn = priority_queue<T>;\n\n#define debug(var)              \\\n\tstd::cout << #var << \" : \"; \\\n\tview(var)\ntemplate <typename T>\nvoid view(T e) {\n\tstd::cout << e << std::endl;\n}\ntemplate <typename T>\nvoid view(const std::vector<T> &v) {\n\tfor(const auto &e : v) {\n\t\tstd::cout << e << \" \";\n\t}\n\tstd::cout << std::endl;\n}\ntemplate <typename T>\nvoid view(const std::vector<std::vector<T>> &vv) {\n\tcout << \"\\n\";\n\tfor(const auto &v : vv) {\n\t\tview(v);\n\t}\n}\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\ntemplate <typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\n#pragma endregion\n\n#pragma region constants\n\nlong long const limLL = 9223372036854775807;  // POW(2,63)-1 ~ 9.22e18\nlong long const dekai = 3e16;\nconst long double pi = acos(-1);\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint ddx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint ddy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nconst int mod = 1000000007;\n// const int mod = 998244353;\n#pragma endregion\n\n#pragma region basic_procedure\n\ntemplate <class T>\ninline bool isin(T x, T lef, T rig) {\n\treturn ((lef <= x) && (x < rig));\n}\ntemplate <class T>\ninline bool isin(T x, T y, T lef, T rig) {\n\treturn isin(x, lef, rig) && isin(y, lef, rig);\n}\ntemplate <class T>\ninline bool isin(T X, T lefX, T rigX, T Y, T lefY, T rigY) {\n\treturn isin(X, lefX, rigX) && isin(Y, lefY, rigY);\n}\n\ntemplate <class T>\ninline bool chmin(T &a, T b) {\n\tif(a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T>\ninline bool chmax(T &a, T b) {\n\tif(a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nvoid Yes(bool f = 1) { cout << (f ? \"Yes\" : \"No\") << \"\\n\"; }\nvoid No() { cout << \"No\\n\"; }\nvoid YES(bool f = 1) { cout << (f ? \"YES\" : \"NO\") << \"\\n\"; }\nvoid NO() { cout << \"NO\\n\"; }\nvoid err() { cout << -1 << \"\\n\"; }\n\nvector<long long> vin(long long n) {  //整数n個の入力を受け取ってベクトルに突っ込んで返す\n\tvector<long long> v(n);\n\tfor(long long i = 0; i < n; i++) {\n\t\tcin >> v[i];\n\t}\n\treturn v;\n}\n\n//ベクトルの出力(検証済)\n// vectorの中身を出力する 答えの出力に利用可能\ntemplate <class T>\nvoid vout(vector<T> &v, bool tate = 0) {\n\tif(v.size() > 0) {\n\t\tfor(auto it = v.begin(); it < v.end(); it++) {\n\t\t\tcout << *it;\n\t\t\tif(it != v.end() - 1) {\n\t\t\t\tif(tate)\n\t\t\t\t\tcout << endl;\n\t\t\t\telse\n\t\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\tcout << endl;\n}\n\ntemplate <class T>\nvoid add(vector<T> &v, T val) {\t //ベクトルの各要素に加算\n\tfor(auto &a : v) a += val;\n\treturn;\n}\n\n// vectorの中身を数える map<要素,個数>を返す\ntemplate <class T>\nmap<T, long long> cntv(vector<T> v) {\n\tmap<T, long long> m;\n\tfor(auto &g : v) {\n\t\tif(m.count(g))\n\t\t\tm[g]++;\n\t\telse\n\t\t\tm[g] = 1;\n\t}\n\treturn m;\n}\n\n//配列圧縮(検証済)\n//{1,36,1,3,8,-2,-92}を\n//{2, 5,2,3,4, 1,  0}にする\ntemplate <class T>\nvector<long long> press(vector<T> &v) {\n\tlong long n = v.size();\n\tvector<long long> w(n);\n\tmap<T, long long> m;\n\tfor(T &p : v) m[p] = 0;\n\tlong long i = 0;\n\tfor(auto &p : m) {\n\t\tp.second = i;\n\t\ti++;\n\t}\n\tfor(long long i = 0; i < n; i++) w.at(i) = m[v.at(i)];\n\treturn w;\n}\n\ntemplate <class T>\nT divup(T a, T b) {\n\t//端数繰りあがり割り算\n\tassert(b != 0);\n\tT x = abs(a);\n\tT y = abs(b);\n\tT z = (x + y - 1) / y;\n\tif((a < 0 && b > 0) || (a > 0 && b < 0))\n\t\treturn -z;\n\telse if(a == 0)\n\t\treturn 0;\n\telse\n\t\treturn z;\n}\n\nlong long POW(long long a, long long n) {\n\t// 整数のとき限定の普通のPOW関数\n\t//標準機能のpow(a,n)は整数だとバグるのでこちらを使う\n\tlong long res = 1;\n\twhile(n > 0) {\n\t\tif(n & 1) res = res * a;\n\t\ta = a * a;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\ntemplate <class T>\nint sgn(T x) {\t//符号関数\n\tif(x < 0) return -1;\n\tif(x == 0) return x;\n\treturn 1;\n}\n\nlong long modpow(long long a, long long n, long long mod) {\t // a^n mod\n\tlong long res = 1;\n\twhile(n > 0) {\n\t\tif(n & 1) res = res * a % mod;\n\t\ta = a * a % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nlong long modinv(long long a, long long mod) {\t// a^{-1} mod\n\t// modとaが互いに素のときのみ有効(数学的に逆元が一意に定まるのがそのときのみ)\n\treturn modpow(a, mod - 2, mod);\n}\n\nvvll comb(100, vll(100, -1));\nlong long com(long long n, long long k) {  //普通の二項計数(overflowに注意)\n\tassert(n < 100 && k < 100);\n\tif(n < k || k < 0 || n < 0) return 0;\n\tif(comb[n][k] != -1) return comb[n][k];\n\tll res;\n\tif(n - k < k)\n\t\tres = com(n, n - k);\n\telse if(k == 0)\n\t\tres = 1;\n\telse\n\t\tres = com(n - 1, k - 1) + com(n - 1, k);\n\tcomb[n][k] = res;\n\treturn res;\n}\n\n// nCk modを求める\nconst ll MAX = 5100000;\n// この値は求める二項計数の値に応じて変える\n// MAX=3*10^7のとき1900msほど、ほぼ比例\n// MAX=5*10^6程度ならそれほど気にしなくてよい(300ms程)\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid cominit() {\n\t// テーブルを作る前処理\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(ll i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfinv[i] = finv[i - 1] * inv[i] % mod;\n\t}\n}\nlong long commod(ll n, ll k) {\t// 二項係数計算\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % mod) % mod;\n}\nlong long pmod(ll n, ll k) {  //順列計算\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * finv[n - k] % mod;\n}\nlong long hmod(ll n, ll k) {  // nHk計算\n\t// n個の区別しないoを区別するk個の箱に入れる方法の総数\n\t//(n+k-1)C(k-1)と等しい\n\treturn commod(n + k - 1, n);\n}\n#pragma endregion\n\ntemplate <class T = long long>\nstruct edge {\n\tT cap;\n\tint from;\n\tint to;\n\tint rev;  // fromの方の配列で逆辺が何番目に存在するか\n\tbool operator<(const edge a) const {\n\t\tif(cap != a.cap) return cap < a.cap;\n\t\tif(from != a.from) return from < a.from;\n\t\treturn to < a.to;\n\t}\n\tbool operator>(const edge a) const {\n\t\tif(cap != a.cap) return cap > a.cap;\n\t\tif(from != a.from) return from > a.from;\n\t\treturn to > a.to;\n\t}\n};\n\ntemplate <class T = long long>\nclass Dinic {\n   private:\n\tint ver;  //頂点数\n\tvector<vector<edge<T>>> edges;\n\tvector<int> level;\n\tvector<int> chk;\n\n   public:\n\tDinic(int vertex) : ver(vertex), edges(vertex), level(vertex, -1), chk(vertex, 0) {}\n\n\t//辺と逆辺の追加 (0-indexed)\n\tvoid update(int from, int to, T cap = 1) {\n\t\tedge<T> e;\n\t\te.cap = cap;\n\t\te.from = from;\n\t\te.to = to;\n\t\te.rev = (int)edges[to].size();\n\t\tedges[from].push_back(e);\n\n\t\te.cap = (T)0;\n\t\tswap(e.to, e.from);\n\t\te.rev = (int)edges[from].size() - 1;\n\t\tedges[to].push_back(e);\n\t}\n\n\t//入力受取 (1-indexed)\n\tvoid input(int edge_num, int index = 1) {\n\t\tfor(int i = 0; i < edge_num; i++) {\n\t\t\tint a;\n\t\t\tint b;\n\t\t\tT cap;\n\t\t\tcin >> a >> b >> cap;\n\t\t\ta -= index;\n\t\t\tb -= index;\n\t\t\tupdate(a, b, cap);\n\t\t}\n\t}\n\n   private:\n\t//有効な辺のみを用いた幅優先探索で距離を求める\n\tvoid bfs(int s) {\n\t\tlevel.assign(ver, -1);\n\t\tlevel[s] = 0;\n\t\tqueue<int> q;\n\t\tq.push(s);\n\t\twhile(!q.empty()) {\n\t\t\tint now = q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto &e : edges[now]) {\n\t\t\t\tif(level[e.to] >= 0) continue;\n\t\t\t\tif(e.cap <= 0) continue;\n\t\t\t\tlevel[e.to] = level[now] + 1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t//流せる辺を探す\n\tT dfs(int now, int t, T f) {\n\t\tif(now == t) return f;\n\t\tfor(int i = chk[now]; i < (int)edges[now].size(); i++) {\n\t\t\tauto &e = edges[now][i];\n\t\t\tif(level[now] + 1 != level[e.to] || e.cap <= 0) {\n\t\t\t\tchk[now]++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tT k = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(k > 0) {\n\t\t\t\te.cap -= k;\n\t\t\t\tedges[e.to][e.rev].cap += k;\n\t\t\t\treturn k;\n\t\t\t}\n\t\t\tchk[now]++;\n\t\t}\n\t\treturn (T)0;\n\t}\n\n   public:\n\tT maxflow(int s, int t) {\n\t\tT flow = 0;\n\t\tconst T INF = 3e16;\t // T == int だとバグる\n\t\twhile(1) {\n\t\t\tbfs(s);\n\t\t\tif(level[t] < 0) return flow;\n\t\t\tfor(int i = 0; i < ver; i++) chk[i] = 0;\n\t\t\tT fl = 1;\n\t\t\twhile(fl > 0) {\n\t\t\t\tfl = dfs(s, t, INF);\n\t\t\t\tflow += fl;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\t// cout << fixed << setprecision(15);\n\tint x, y, e;\n\tcin >> x >> y >> e;\n\tint s = x + y;\n\tint t = s + 1;\n\tDinic<> d(x + y + 2);\n\trep(i, e) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tb += x;\n\t\td.update(a, b);\n\t}\n\trep(i, x) { d.update(s, i); }\n\trep(i, y) d.update(i + x, t);\n\tcout << d.maxflow(s, t) << enld;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int64_t i = 0; i < (n); i++)\n#define irep(i, n) for (int64_t i = 0; i <= (n); i++)\n#define rrep(i, n) for (int64_t i = (n)-1; i >= 0; i--)\n#define rirep(i, n) for (int64_t i = n; i >= 0; i--)\n\nclass FlowNetwork {\n  struct Edge {\n    int from;\n    int to;\n    int64_t capacity;\n    int64_t flow;\n  };\n\n  vector<vector<int>> outEdge, inEdge;\n  vector<Edge> edgeData;\n\n public:\n  FlowNetwork(int size) : outEdge(size), inEdge(size) {}\n\n  void addEdge(const int from, const int to, const int64_t capacity) {\n    const int eId = edgeData.size();\n    Edge eData;\n    eData.from = from;\n    eData.to = to;\n    eData.flow = 0;\n    eData.capacity = capacity;\n    edgeData.push_back(eData);\n    outEdge[from].push_back(eId);\n    inEdge[to].push_back(eId);\n  }\n\n  int64_t maxflow(const int source, const int sink) {\n    const int n = outEdge.size();\n\n    while (true) {\n      // check if reachable to sink\n      vector<int> parent(n, -1);\n      queue<int> q;\n      q.push(source);\n\n      while (!q.empty()) {\n        const int v = q.front();\n        q.pop();\n\n        for (const int e : outEdge[v]) {\n          const Edge &data = edgeData[e];\n          const int nv = data.to;\n          if (parent[nv] < 0 && data.capacity - data.flow > 0) {\n            q.push(nv);\n            parent[nv] = e;\n          }\n        }\n\n        for (const int e : inEdge[v]) {\n          const Edge &data = edgeData[e];\n          const int nv = data.from;\n          if (parent[nv] < 0 && data.flow > 0) {\n            q.push(nv);\n            parent[nv] = e;\n          }\n        }\n      }\n\n      if (parent[sink] < 0) {\n        break;\n      }\n\n      // select path from source to sink\n      int64_t d = numeric_limits<int64_t>::max();\n      int v = sink;\n      while (v != source) {\n        const int e = parent[v];\n        const Edge &data = edgeData[e];\n        if (data.to == v) {\n          d = min(d, data.capacity - data.flow);\n          v = data.from;\n        } else {\n          d = min(d, data.flow);\n          v = data.to;\n        }\n      }\n\n      // update flow on the path\n      v = sink;\n      while (v != source) {\n        const int e = parent[v];\n        Edge &data = edgeData[e];\n        if (data.to == v) {\n          data.flow += d;\n          v = data.from;\n        } else {\n          data.flow -= d;\n          v = data.to;\n        }\n      }\n    }\n\n    int64_t result = 0;\n    for (const int e : inEdge[sink]) {\n      result += edgeData[e].flow;\n    }\n    return result;\n  }\n};\n\nint main() {\n  int X, Y, E;\n  cin >> X >> Y >> E;\n\n  const int nodeNum = X + Y + 2;\n  FlowNetwork net(nodeNum);\n  const int source = nodeNum - 2;\n  const int sink = nodeNum - 1;\n\n  rep(i, X) { net.addEdge(source, i, 1); }\n  rep(i, Y) { net.addEdge(X + i, sink, 1); }\n\n  rep(i, E) {\n    int x, y;\n    cin >> x >> y;\n\n    net.addEdge(x, X + y, 1);\n  }\n\n  cout << net.maxflow(source, sink) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n\nstruct BipartiteMatching {\n    int n;\n    std::vector<std::vector<int>> G;\n    std::vector<int> match;\n    std::vector<bool> used;\n    BipartiteMatching(int n) : n(n), G(n), match(n), used(n) {}\n    void addEdge(int u, int v) {\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    bool dfs(int v) {\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            int u = G[v][i], w = match[u];\n            if (w < 0 || !used[w] && dfs(w)) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n    std::vector<std::pair<int, int>> getMaxMatching() {\n        std::vector<std::pair<int, int>> ret;\n        fill(match.begin(), match.end(), -1);\n        for (int i = 0; i < n; i++) {\n            if (match[i] < 0) {\n                fill(used.begin(), used.end(), false);\n                dfs(i);\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (i < match[i]) { ret.push_back({i, match[i]}); }\n        }\n        return ret;\n    }\n};\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    BipartiteMatching bm(X + Y);\n    for (int i = 0; i < E; i++) {\n        int x, y;\n        cin >> x >> y;\n        bm.addEdge(x, X + y);\n    }\n    cout << bm.getMaxMatching().size() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pii> vii;\ntypedef vector<pll> vll;\n#define fi first\n#define se second\nconst ll INFLL=LLONG_MAX;\nconst int INF=INT_MAX;\nconst ll MAXLL=0x3f3f3f3f3f3f3f3f;\nconst int MAX=0x3f3f3f3f;\n#define eb emplace_back\n#define emp emplace\n#define mp(a,b) make_pair(a,b)\ntemplate<class T> using min_heap=priority_queue<T,vector<T>,greater<T> >;\ntemplate<class T>\nvoid sort(vector<T>& v){\n\tsort(v.begin(),v.end());\n}\ntemplate <class T, class U>\nvoid sort(vector<T>& v,U func){\n\tsort(v.begin(),v.end(),func);\n}\ntemplate <class T>\nint lb_index(vector<T>& v,T k){\n\treturn lower_bound(v.begin(),v.end(),k)-v.begin();\n}\ntemplate <class T>\nint ub_index(vector<T>& v,T k){\n\treturn upper_bound(v.begin(),v.end(),k)-v.begin();\n}\nstruct flow{\n\tint n,s,t;\n\tconst long long MAXVAL=0x3f3f3f3f3f3f3f3f;\n\tstruct edge{\n\t\tint from,to;\n\t\tlong long cap,cost;\n\t\tedge(int u,int v,long long c,long long w):from(u),to(v),cap(c),cost(w){}\n\t\tedge(int u,int v,long long c):from(u),to(v),cap(c){\n\t\t\tcost=0;\n\t\t}\n\t};\n\tvector<edge>e;\n\tvector<vector<int> >adj;\n\tvector<long long>dist;\n\tvector<int>par;\n\tvector<bool>inq;\n\tvoid spfa(){\n\t\tfill(dist.begin(),dist.end(),MAXVAL);\n\t\tfill(inq.begin(),inq.end(),0);\n\t\tfill(par.begin(),par.end(),0);\n\t\tqueue<int>q;\n\t\tdist[s]=0;\n\t\tq.emplace(s);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();\n\t\t\tq.pop();\n\t\t\tinq[u]=0;\n\t\t\tfor(auto i:adj[u]){\n\t\t\t\tif(e[i].cap<=0)continue;\n\t\t\t\tint v=e[i].to;\n\t\t\t\tlong long l=e[i].cost;\n\t\t\t\tif(dist[u]+l<dist[v]){\n\t\t\t\t\tdist[v]=dist[u]+l;\n\t\t\t\t\tpar[v]=i;\n\t\t\t\t\tif(!inq[v])q.emplace(v),inq[v]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long augcost(){\n\t\tlong long curflow=MAXVAL;\n\t\tfor(int u=t;u!=s;u=e[par[u]].from){\n\t\t\tcurflow=min(curflow,e[par[u]].cap);\n\t\t}\n\t\tfor(int u=t;u!=s;u=e[par[u]].from){\n\t\t\te[par[u]].cap-=curflow;\n\t\t\te[par[u]^1].cap+=curflow;\n\t\t}\n\t\treturn curflow;\n\t}\n\tflow(int n,int s,int t):n(n),s(s),t(t),dist(n),inq(n),par(n),adj(n){}\n\tvoid addedge(int u,int v,long long c,long long w){\n\t\tadj[u].emplace_back(e.size());\n\t\te.emplace_back(u,v,c,w);\n\t\tadj[v].emplace_back(e.size());\n\t\te.emplace_back(v,u,0,-w);\n\t}\n\tvoid addedge(int u,int v,long long c){\n\t\tadj[u].emplace_back(e.size());\n\t\te.emplace_back(u,v,c);\n\t\tadj[v].emplace_back(e.size());\n\t\te.emplace_back(v,u,0);\n\t}\n\tvoid setflow(long long k){\n\t\tint ns=n++;\n\t\tadj.resize(n);\n\t\tdist.resize(n);\n\t\tinq.resize(n);\n\t\tpar.resize(n);\n\t\taddedge(ns,s,k,0);\n\t\ts=ns;\n\t}\n\tpair<long long,long long> getflow(){\n\t\tlong long maxflow=0,cost=0;\n\t\tfor(;;){\n\t\t\tspfa();\n\t\t\tif(dist[t]==MAXVAL)break;\n\t\t\tlong long f=augcost();\n\t\t\tmaxflow+=f;\n\t\t\tcost+=dist[t]*f;\n\t\t}\n\t\treturn {maxflow,cost};\n\t}\n};\nint main(){\n\tint x,y,e;\n\tcin>>x>>y>>e;\n\tflow f(x+y+2,x+y,x+y+1);\n\tfor(int i=0;i<x;i++){\n\t\tf.addedge(x+y,i,1);\n\t}\n\tfor(int i=0;i<y;i++){\n\t\tf.addedge(x+i,x+y+1,1);\n\t}\n\twhile(e--){\n\t\tint l,r;\n\t\tcin>>l>>r;\n\t\tf.addedge(l,x+r,1);\n\t}\n\tcout<<f.getflow().fi<<\"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\n///------------------- O(|E|*sqrt(|V|)) -------------------///\nstruct hopcroft_karp {\n    int l, r;\n    vector<int> last, prev, head, matching, d;\n    vector<bool> used, vis;\n    hopcroft_karp(int l, int r) : l(l), r(r), last(l, -1), matching (r, -1), d(l), used(l), vis(l) {}\n    /// u -> 0 to l, v -> 0 to r\n    void add_edge(int u, int v) {\n        head.push_back(v);\n        prev.push_back(last[u]);\n        last[u] = prev.size()-1;\n    }\n    void bfs() {\n        fill(d.begin(), d.end(), -1);\n        queue<int> q;\n        for(int u = 0; u < l; u++) {\n            if(!used[u]) {\n                q.push(u);\n                d[u] = 0;\n            }\n        }\n        while(q.size()) {\n            int u = q.front(); q.pop();\n            for(int e = last[u]; e >= 0; e = prev[e]) {\n                int v = matching[ head[e] ];\n                if(v >= 0 && d[v] < 0) {\n                    d[v] = d[u]+1;\n                    q.push(v);\n                }\n            }\n        }\n    }\n    bool dfs(int u) {\n        vis[u] = true;\n        for(int e = last[u]; e >= 0; e = prev[e]) {\n            int v = head[e];\n            int k = matching[v];\n            if(k < 0 || ( !vis[k] && d[k] == d[u]+1 && dfs(k) )) {\n                matching[v] = u;\n                used[u] = true;\n                return true;\n            }\n        }\n        return false;\n    }\n    int max_matching() {\n        int ans = 0;\n        while(true) {\n            bfs();\n            fill(vis.begin(), vis.end(), false);\n            int f = 0;\n            for(int u = 0; u < l; u++)\n                if(!used[u] && dfs(u)) f++;\n            if(f == 0) return ans;\n            ans += f;\n        }\n        return 0;\n    }\n};\n\n\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  #ifdef Larra\n  freopen(\"in\",\"r\",stdin);\n  freopen(\"out\",\"w\",stdout);\n  #endif\n  int n1, n2, m;\n  cin>>n1>>n2>>m;\n  hopcroft_karp hp(n1, n2);\n  for(int i = 0; i < m; i++){\n      int u,v;\n      cin>>u>>v;\n      hp.add_edge(u, v);\n  }\n  cout<<hp.max_matching()<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nstruct bipartite_matching{\n    int n, x, y;\n    VVI e;\n    VI match;\n    vector<bool> used;\n\n    void init(int a, int b){\n        x = a;\n        y = b;\n        n = x + y;\n        e.resize(n);\n        match.resize(n);\n        used.resize(n);\n    }\n\n    void add_edge(int u, int v){\n        e[u].push_back(v + x);\n        e[v + x].push_back(u);\n    }\n\n    bool dfs(int v){\n        used[v] = true;\n        for (int u : e[v]){\n            int w = match[u];\n            if (w < 0 || (!used[w] && dfs(w))){\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int calc_matching(){\n        int res = 0;\n        fill(ALL(match), -1);\n        REP(v,n){\n            if (match[v] < 0){\n                used.assign(n, 0);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    int n, m, e;\n    cin >> n >> m >> e;\n\n    bipartite_matching bm;\n    bm.init(n, m);\n\n    while (e--){\n        int u, v;\n        cin >> u >> v;\n        bm.add_edge(u, v);\n    }\n\n    cout << bm.calc_matching() << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nconst int MAX_V = 210;\n\nint V;\nint match[MAX_V];\nbool used[MAX_V];\nvector<vector<int>> g(MAX_V);\nbool dfs(int v){\n    used[v] = true;\n    for(int i=0; i<g[v].size(); i++){\n        int u = g[v][i], w = match[u];\n\n        if(w < 0 || (!used[w] && dfs(w))){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nint bipartite_matching(){\n    int res = 0;\n    memset(match, -1, sizeof(match));\n\n    for(int v=0; v<V; v++){\n        if(match[v] < 0){\n            memset(used, false, sizeof(used));\n            if(dfs(v)){\n                res++;\n            }\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    int x, y, e; cin>>x>>y>>e;\n    V = x + y;\n    for(int i=0; i<e; i++){\n        int s, t; cin>>s>>t;\n        g[s].eb(t+100);\n        g[t+100].eb(s);\n    }\n\n    cout << bipartite_matching() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\nconstexpr double eps = 1e-14; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nclass MaxFlow{\n    public:\n        struct edge{\n            int to,cap,rev;\n            edge(int t,int c,int r){to=t,cap=c,rev=r;}\n        };\n\n        int N;\n        vector<vector<edge>> G;\n        vector<bool> used;\n\n        // n : ???????????°\n        MaxFlow(int n){\n            N = n;\n            G.resize(n);\n            used.resize(n);\n        }\n\n        // ???????????????????????¨????????????????????????\n        void add_edge(int from,int to,int cap=1){\n            G[from].push_back(edge(to,cap,G[to].size()));\n            G[to].push_back(edge(from,0,G[from].size()-1));\n        }\n\n        // v??????t?????????f??\\?????§??????????????§??????\n        int dfs(int v, int t, int f){\n            if (v == t) return f;\n            used[v] = true;\n\n            for (size_t i = 0; i < G[v].size(); i++){\n                edge &e = G[v][i];\n                if (!used[e.to] && e.cap>0){\n                    int d = dfs(e.to, t, min(f, e.cap));\n                    if (d > 0){\n                        e.cap -= d;\n                        G[e.to][e.rev].cap += d;        //???????????????\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        // s??????t???????????§???????±???????\n        int max_flow(int s,int t){\n            int flow = 0;\n            while(true){\n                used.assign(N,false);\n                int f=dfs(s,t,INF);\n                if(f==0) return flow;\n                flow += f;\n            }\n        }\n};\n\nint VX,VY,E;\n\nint main(){\n    cin >> VX >> VY >> E;\n    MaxFlow flow(VX+VY+2);\n    rep(i,E){\n        int x,y;\n        cin >> x >> y;\n        y += VX;\n        flow.add_edge(x,y);\n    }\n\n    rep(i,VX){\n        flow.add_edge(VX+VY,i);\n    }\n    rep(i,VY){\n        flow.add_edge(i+VX,VX+VY+1);\n    }\n\n    int ans = flow.max_flow(VX+VY,VX+VY+1);\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nconst double eps = 1e-8;\nconst int MOD = 1000000007;\n//int main() {\n//    cin.tie(0);\n//    ios::sync_with_stdio(false);\n//    cout << fixed << setprecision(10);\n//\n//}\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n    // edge(int src, int to, T cost): src(src), to(to), cost(cost) {}\n    // // G[i].push_back({src, to, cost}) requires no constructor\n};\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\nstruct HopcroftKarp {\n    vector<vector<int>> g;\n    vector<int> d, mch;\n    vector<bool> used, vv;\n    HopcroftKarp(int n, int m) : g(n), mch(m, -1), used(n) {}\n    void add_edge(int u, int v) {\n        g[u].push_back(v);\n    }\n    void bfs() {\n        d.assign(g.size(), -1);\n        queue<int> que;\n        for (int i = 0; i < g.size(); i++) {\n            if (!used[i]) {\n                que.emplace(i);\n                d[i] = 0;\n            }\n        }\n        while (!que.empty()) {\n            int a = que.front();\n            que.pop();\n            for (auto &b : g[a]) {\n                int c = mch[b];\n                if (c >= 0 && d[c] == -1) {\n                    d[c] = d[a] + 1;\n                    que.emplace(c);\n                }\n            }\n        }\n    }\n    bool dfs(int a) {\n        vv[a] = true;\n        for (auto &b : g[a]) {\n            int c = mch[b];\n            if (c < 0 || (!vv[c] && d[c] == d[a] + 1 && dfs(c))) {\n                mch[b] = a;\n                used[a] = true;\n                return (true);\n            }\n        }\n        return (false);\n    }\n    int bipartite_matching() {\n        int ret = 0;\n        while (true) {\n            bfs();\n            vv.assign(g.size(), false);\n            int flow = 0;\n            for (int i = 0; i < g.size(); i++) {\n                if (!used[i] && dfs(i)) ++flow;\n            }\n            if (flow == 0) return ret;\n            ret += flow;\n        }\n    }\n};\nint main() {\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    HopcroftKarp bm(X, Y);\n    for(int i = 0; i < E; i++) {\n        int a, b;\n        cin >> a >> b;\n        bm.add_edge(a, b);\n    }\n    cout << bm.bipartite_matching() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_N 1000\n#define MAX_V 1000\n#define INF 1e9\nusing namespace std;\nint N,K;\nbool can[MAX_N][MAX_N]; //can[i][j]:=???????????\\??????i?????????j??????????????????\nstruct edge{int to, cap, rev;};\nvector<edge> G[MAX_V]; //??°???????????£??\\?????????\nbool used[MAX_V];      //DFS??§?????§??????????????????????????°\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});  \n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v,int t,int f){\n  if(v == t)return f;\n  used[v]=true;\n  for(int i=0; i<G[v].size() ;i++){\n    edge &e = G[v][i];\n    if(!used[e.to] && e.cap > 0){\n      int d = dfs(e.to ,t , min(f,e.cap));\n      if(d > 0){\n\te.cap -= d;\n\tG[e.to][e.rev].cap += d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    memset(used,0,sizeof(used));\n    int f = dfs(s, t, INF);\n    if(f == 0)return flow;\n    flow += f;\n  }\n}\n\n\nint Biparite_Matching(){\n  //0??????N-1: ???????????\\???????????????????????????\n  //N??????N+K-1: ???????????????????????????\n  int s = N+K, t = s+1;\n  \n  //s??¨???????????\\??????????????¶\n  for(int i=0; i<N; i++) add_edge(s,i,1);\n  \n  //????????¨t?????????\n  for(int i=0; i<K; i++) add_edge(N+i,t,1);\n  \n  //???????????\\????????¨??????????????¶\n  for(int i=0;i<N;i++)\n    for(int j=0;j<K;j++)\n      if(can[i][j]) add_edge(i, N+j , 1);\n\n  return max_flow(s,t);\n}\n\nint main(){\n  int E;\n  cin>>N>>K>>E;\n  for(int i=0; i<E ;i++){\n    int x,y;\n    cin>>x>>y;\n    can[x][y]=1;\n  }\n  cout<<Biparite_Matching()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define vmaxsize         1000\n#define emaxsize         10010\n#define unvisited          -1\n#define undefined          -1\n#define noparent            0\n#define free                0\n#define false               0\n#define true                1\nint tail[emaxsize+1], head[emaxsize+1];\nint edgefirst[vmaxsize+1], edgenext[emaxsize+1];\nint match[vmaxsize+1];  // ???v?????\\?¶?????????????????????°??????match[v]\nint m, n, n1, n2;       // ?????´????????°n1????????´????????°n2???n=n1+n2\nint level[vmaxsize+1];  // ??¬????????°?????????????????????v?????¬??????level[v]\nint queue[vmaxsize+1];  // ???????????¢?´¢?????????????????\\???\nint max_level;          // ????????????????????????????????´?????????????°???¬??????\nint t_found;            // ????????????????????????????????´???????????°???????????¨???t_found=true\nint front, rear;        // ?????\\????????????front??¨????°?rear\nint parent[vmaxsize + 1]; // ??±???????????¢?´¢??¨???????????????v??????parent[v]\nint pathfound, pathend;   // ?¢??????????????????¨ (pathfound=true)???pathend????????´?????????\nvoid bipartite_graph_input(void){\n    int a;\n    scanf(\"%d %d %d\", &n1, &n2, &m);\n    n=n1+n2; // n?????°??????????????°\n    for (a = 1; a <= m; a++) {\n        scanf(\"%d %d\", &tail[a], &head[a]);\n        tail[a]++;\n        head[a]++;\n        head[a] += n1;\n    }\n}\nvoid bipartite_incidence_list_construct(void){\n    int a, v1;\n    for (v1 = 1; v1 <= n1; v1++) edgefirst[v1] = 0;\n    for (a = m; a >= 1; a--) {\n        v1 = tail[a];\n        edgenext[a] = edgefirst[v1];\n        edgefirst[v1] = a;\n    }\n}\nvoid matching_output(void){\n    int a, v1, k;\n    k=0; \n    for (v1 = 1; v1 <= n1; v1++) {\n        if (match[v1] != free) {\n            k++;\n        }\n    }\n    printf(\"%d\\n\", k);\n}\nvoid bipartite_bfs(int v1){// ?????´??????v1??????????????¨??°????????§??????????????¢?´¢\n    int v2, w1;\n    int a,b;\n    for(a = edgefirst[v1]; a != 0; a = edgenext[a]) {// v1?????\\?¶???????????????????????????????????????????????????§??\\????????°?????????\n        v2 = head[a]; // a????????´??????v1???????????´??????v2???????????????????????¨?????????\n        if(level[v2] != unvisited){ // ?????´??????v2????¨???????????????¨???????????????????????????\n            ;\n        }else{// v2????????´????????§??????????¨????\n            level[v2] = level[v1] + 1;\n            if (t_found == n + 2){// ?¢??????????????????????????????£????????????\n                if (match[v2] != free) {// v2???????????????????????????\n                    b = match[v2]; // ??????????????°??????b\n                    w1 = tail[b]; // b????????????v2???????????????w1???????????????????????????\n                    level[w1] = level[v2] + 1; \n                    queue[++rear] = w1;\n                }\n                else {// v2???????????????????????????????????§v1??????v2????????????????¢??????????\n                    t_found = rear + 1; // t_found<n+2 ????¢??????????????????¨?????????\n                    max_level = level[v2];\n                }\n            }\n        }\n    }\n}\nvoid levelgraph(void){// ??¬????????°??????????§????\n    int v,v1;\n    rear = 0;    // ?????\\???????????????\n    front = 1;\n    t_found=n+2; // ?¢?????????????????????????????????????????????¨???????¨????\n    for (v = 1; v <= n; v++) level[v] = unvisited; // ????????????????¨??????¨???????¨????\n    for (v1 = 1; v1 <= n1; v1++) {\n        if (match[v1] == free) {// v1???????????????????????????????????´??????\n            level[v1] = 0; // v1??????????????¨??°????????????????????¢?´¢????????§????????????\n            queue[++rear] = v1; //?????\\???queue???????°????v1????????\\\n        }\n    }\n\n\n\n    while (front < t_found) {// ?¢???????????????????????????????????????????\n        if (front != rear + 1) {// ?????\\???queue????????§??????????????°?????????\n            v1 = queue[front++]; // ?????\\?????????????????????v1?????????\n            bipartite_bfs(v1); //v1??????????????¨??°????????????????????¢?´¢????§?\n        }\n        else {// ?????\\???queue????????§???????????§???while?????????????????¶????????????\n            break;\n        }\n    }\n\n\n    \n}\nvoid bipartite_dfs(int v1)\n{ // ?????´??????v1??????????????¨??°????????§?????±???????????¢?´¢\n    int v2, w1;\n    int a, b;\n    for (a = edgefirst[v1]; a != 0; a = edgenext[a])\n    {                 // v1?????\\?¶???????????????????????????????????????????????????§??\\????????°?????????\n        v2 = head[a]; // a????????´??????v1???????????´??????v2???????????????????????¨?????????\n        if (parent[v2] == undefined && level[v2] == level[v1] + 1)\n        {\n            parent[v2] = a; // a????????´??????v2?????????????????´??????v1???????????¨?????????\n            if (level[v2] != max_level)\n            {                   // v2????????´????????§????????????????????????\n                b = match[v2];  // ??????????????°??????b\n                w1 = tail[b];   // b????????????v2???????????????w1?????????????????????????????¨?????????\n                parent[w1] = b; // b????????´??????w1????????????v2?????????\n                bipartite_dfs(w1);\n\n                if (pathfound)\n                    return; //Added by Goro Satake\n\n            }\n            else\n            { // level[v2] == max_level\n                if (match[v2] == free)\n                {                     // v2????????´????????§???????????????????????????\n                    pathend = v2;     // ?¢??????????????????????v2\n                    pathfound = true; // ?¢????????????????\n                    return;           // ?¢????????????????????????°?????¶????????????????????±??????????????????????±????????????????\n                }\n            }\n        }\n    }\n}\nvoid augmentation(void)\n{\n    int v, v1, v2, w1;\n    int a, b;\n    for (v = 1; v <= n; v++)\n        parent[v] = undefined;\n    for (v1 = 1; v1 <= n1; v1++)\n    {\n        if (match[v1] != free)\n        {\n            continue;\n        }\n        else\n        {                          // v1???????????????????????????????????´??????\n            pathfound = false;     // v1??????????¢???????????????¢?´¢\n            parent[v1] = noparent; // v1???????????±???????????¢?´¢??¨?????????v1\n            bipartite_dfs(v1);     // v1???????????±?????????\n            if (!pathfound)\n            {\n                continue;\n            }\n            else\n            {                   // v1???????????±???????????§pathend???????¢????????????????\n                v2 = pathend;   // ??±???????????¢?´¢??¨??§pathend???????????????v1?????§?????????\n                a = parent[v2]; // ????????????????????????????????°?????¨?????????????????°????????????\n                match[v2] = a;\n                w1 = tail[a];\n                match[w1] = a;\n                while (w1 != v1)\n                {\n                    b = parent[w1];\n                    v2 = head[b];\n                    a = parent[v2];\n                    match[v2] = a;\n                    w1 = tail[a];\n                    match[w1] = a;\n                }\n            }\n        }\n    }\n}\nint main(void){\n    int v;\n    bipartite_graph_input(); \n    // ?????¨??°??????????????°m????????´?????°n1????????´?????°n2?????????????§?????????????????±?????????????\n    bipartite_incidence_list_construct(); // ??\\?¶?????????????????§?????????????\n    for (v = 1; v <= n; v++) match[v] = free; // ?????´??????????????????????????????????????????\n    levelgraph();\n    while(t_found != n + 2){\n        augmentation();\n        levelgraph();\n    }\n    matching_output(); // ??????????????????????????°?????????\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl;\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define repi(start,end) for(int i=start; i<end; i++)\n#define repj(start,end) for(int j=start; j<end; j++)\n#define repk(start,end) for(int k=start; k<end; k++)\n#define repl(start,end) for(int l=start; l<end; l++)\n#define RE return 0;\n\nstruct edge{int to,cap,rev;};\n\nint n,k;\nbool can[201][201];\nint used[100];\n\nvector<edge> G[100];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  used[v]=true;\n  repi(0, G[v].size()){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    int f=dfs(s, t, INF);\n    if(f==0) return flow;\n    flow+=f;\n  }\n}\n\nvoid solve(){\n  int s=n+k,t=s+1;\n  \n  repi(0, n){\n    add_edge(s,i,1);\n  }\n  repi(0, k){\n    add_edge(n+i, t, 1);\n  }\n  \n  repi(0, n){\n    repj(0, k){\n      if(can[i][j]){\n        add_edge(i, n+j, 1);\n      }\n    }\n  }\n  \n  cout<<max_flow(s, t)<<en\n}\n\n\n\n\nint main(){\n  /*\n  cin>>n>>k;\n  repi(0, n){\n    int num;\n    cout<<\"        \"<<i<<\":\"<<en\n    cout<<\"how many?     \";\n    cin>>num;\n    cout<<\"encode ->   \";\n    int a;\n    repj(0, num) {cin>>a; can[i][a]=true;}\n  }\n  cout<<en*/\n  \n  int e,a,b;\n  cin>>n>>k>>e;\n  repi(0, e){\n    cin>>a>>b;\n    can[a][b]=true;\n  }\n  \n  solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n#include <bits/stdc++.h>\n#define loop(n) for (lint ngtkana_is_a_genius = 0; ngtkana_is_a_genius < lint(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (lint i = lint(begin); (i) < lint(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto&& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto&& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#if DEBUG\n#define debug(...)\\\n  do {\\\n    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_impl(__VA_ARGS__);\\\n    std::cerr << std::noboolalpha;\\\n  } while (false)\n#else\n#define debug(...) {}\n#endif\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n  { for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& tuple_input_impl(std::istream& os, Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { (void)std::initializer_list<int>{((void)(os >> std::get< Inds >(tuple)), 0)...}; return os; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::istream& operator>> (std::istream& os, Tuple<Args...>& tuple)\n  { return tuple_input_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t ... Inds, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& tuple_output_impl(std::ostream& os, const Tuple<Args...>& tuple, std::integer_sequence<std::size_t, Inds...>)\n  { os << \"(\"; (void)std::initializer_list<int>{((void)(os << (Inds > 0 ? \",\" : \"\") << std::get< Inds >(tuple)), 0)...}; return os << \")\"; }\ntemplate < template < typename ... > class Tuple,  typename... Args, std::size_t = std::tuple_size< Tuple < Args ... > >::value >\nstd::ostream& operator<< (std::ostream& os, const Tuple<Args...>& tuple)\n { return tuple_output_impl(os, tuple, std::index_sequence_for<Args...>()); }\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int L, R, m;\n  std::cin >> L >> R >> m;\n  int n = L + R;\n  int s = n, t = n + 1;\n  int N = n + 2;\n  std::vector<std::vector<std::pair<int,int>>> graph(N);\n  auto insert = [&] (int i, int j) {\n    graph.at(i).emplace_back(j, false);\n  };\n  loop(m) {\n    int i, j; std::cin >> i >> j;\n    j += L;\n    insert(i,j);\n  }\n  rep(i,0,L) insert(s, i);\n  rep(i,0,R) insert(L + i, t);\n  #if DEBUG\n    rep(i,0,N) {\n      auto v = graph.at(i);\n      debug(i,v);\n    }\n  #endif\n  debug(graph);\n\n  int ans = 0;\n  while (true) {\n    std::vector<int> aug;\n    std::vector<int> ckd(N, false);\n    auto dfs = [&] (auto&&dfs, int x, int p) -> bool {\n      bool found = x == t;\n      ckd.at(x) = true;\n      for (auto&& e : graph.at(x)) {\n        int y, flag; std::tie(y, flag) = e;\n        if (flag || y == p || ckd.at(y)) continue;\n        if (dfs(dfs, y, x)) {\n          found = true;\n          e.second = true;\n          graph.at(y).emplace_back(x, false);\n        }\n      }\n      if (found) {\n        aug.emplace_back(x);\n      }\n      return found;\n    };\n    bool found = dfs(dfs, s, s);\n    if (!found) break;\n    ans++;\n    debug(ans, graph, aug);\n  }\n  std::cout << ans << std::endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nusing Num=double;\nusing Vec=vector<Num>;\nusing Mat=vector<Vec>;\nconst Num Inf=numeric_limits<Num>::infinity();\nconst Num NoSolution=numeric_limits<Num>::quiet_NaN();\nNum EPS=1e-10;\n/*\nmin c*x\ns.t. A*x<=b\n     x>=0\n*/\n\nNum simplex(const Mat &A,const Vec &b,const Vec &c){\n    const int m=A.size(),n=A[0].size();\n\n    Mat D(m+1,Vec(n+m+1));\n    Vec id(m+n);\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++)D[i][j]=A[i][j];\n        D[i][n+i]=1;\n        D[i][n+m]=-b[i];\n    }\n    for(int i=0;i<n;i++)D[m][i]=c[i];\n\n    for(int i=0;i<m;i++)id[i]=n+i;\n    for(int i=0;i<n;i++)id[m+i]=i;\n\n    while(true){\n        int r=n;\n        for(int i=n-1;i>=0;i--)if(D[m][id[m+i]]<-EPS)r=i;\n        if(r==n)return D[m][n+m];\n        int s=m;\n        for(int i=0;i<m;i++)if(D[i][id[m+r]]>EPS){\n            if(s==m||-D[s][n+m]/D[s][id[m+r]]>-D[i][n+m]/D[i][id[m+r]])s=i;\n        }\n        if(s==m)return Inf;//NoBound\n        Num k=D[s][id[m+r]];\n        for(int i=0;i<=n+m;i++)D[s][i]/=k;\n        for(int i=0;i<=m;i++){\n            if(i==s)continue;\n            k=D[i][id[m+r]];\n            for(int j=0;j<=n+m;j++)D[i][j]-=k*D[s][j];\n        }\n        swap(id[s],id[m+r]);\n    }\n}\n\nint X,Y,E;\n\nint x[111][11111],y[111][11111];\n\nsigned main(){\n    cin>>X>>Y>>E;\n    rep(i,E){\n        int a,b;cin>>a>>b;\n        x[a][i]=1;y[b][i]=1;\n    }\n\n    Mat A;Vec b,c(E);\n    rep(i,E)c[i]=-1;\n    for(int i=0;i<X;i++){\n        Vec v(E);rep(j,E)v[j]=x[i][j];\n        A.pb(v);b.pb(1);\n    }\n    for(int i=0;i<Y;i++){\n        Vec v(E);rep(j,E)v[j]=y[i][j];\n        A.pb(v);b.pb(1);\n    }\n    /*\n    rep(i,E){\n        Vec v(E);v[i]=1;\n        A.pb(v);b.pb(1);\n    }*/\n\n    Num t=-simplex(A,b,c);\n    int s=round(t);\n    if(abs(t-s)>0.01)assert(0);\n    cout<<s<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\nusing namespace std;\n\nstruct edge{ int to,cap,rev; };\n\nint V,E;\nint X,Y;\nvector<edge> G[102];\nbool used[102],can[102][102]={};\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to] && e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(used,used+100,0);\n    int f=dfs(s,t,inf);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nvoid solve(){\n  int s=X+Y,t=s+1;\n\n  for(int i=0;i<X;i++){\n    add_edge(s,i,1);\n  }\n  for(int i=0;i<Y;i++){\n    add_edge(X+i,t,1);\n  }\n  for(int i=0;i<X;i++){\n    for(int j=0;j<Y;j++){\n      if(can[i][j]){\n\tadd_edge(i,X+i,1);\n      }\n    }\n  }\n  cout<<max_flow(s,t)<<endl;\n}\n\nint main()\n{\n  int x,y;\n  cin>>X>>Y>>E;\n  for(int i=0;i<E;i++){\n    cin>>x>>y;\n    can[x][y]=true;\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define be(v) (v).begin(),(v).end()\n#define pb(q) push_back(q)\ntypedef long long ll;\nusing namespace std;\nconst ll mod=1000000007, INF=mod*mod*3LL;\n#define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl;\n\ntemplate<class FLOWTYPE> struct Edge {\n    int rev, from, to;\n    FLOWTYPE cap, icap;\n    Edge(int r, int f, int t, FLOWTYPE c) : rev(r), from(f), to(t), cap(c), icap(c) {}\n    friend ostream& operator << (ostream& s, const Edge& E) {\n        if (E.cap > 0) return s << E.from << \"->\" << E.to << '(' << E.cap << ')';\n        else return s;\n    }\n};\n\n// graph class (for network-flow)\ntemplate<class FLOWTYPE> struct Graph {\n    vector<vector<Edge<FLOWTYPE> > > list;\n    \n    Graph(int n = 0) : list(n) { }\n    void init(int n = 0) { list.clear(); list.resize(n); }\n    void reset() { for (int i = 0; i < (int)list.size(); ++i) for (int j = 0; j < list[i].size(); ++j) list[i][j].cap = list[i][j].icap; }\n    inline vector<Edge<FLOWTYPE> >& operator [] (int i) { return list[i]; }\n    inline const size_t size() const { return list.size(); }\n    \n    inline Edge<FLOWTYPE> &redge(Edge<FLOWTYPE> e) {\n        if (e.from != e.to) return list[e.to][e.rev];\n        else return list[e.to][e.rev + 1];\n    }\n    \n    void addedge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, 0));\n    }\n    \n    void add_undirected_edge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, cap));\n    }\n};\n\ntemplate<class FLOWTYPE> struct Dinic {\n    const FLOWTYPE INF = 1<<30; // to be set\n    vector<int> level, iter;\n\n    Dinic() { }\n    void dibfs(Graph<FLOWTYPE> &G, int s) {\n        level.assign((int)G.size(), -1);\n        level[s] = 0;\n        queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int i = 0; i < G[v].size(); ++i) {\n                Edge<FLOWTYPE> &e = G[v][i];\n                if (level[e.to] < 0 && e.cap > 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    \n    FLOWTYPE didfs(Graph<FLOWTYPE> &G, int v, int t, FLOWTYPE f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < G[v].size(); ++i) {\n            Edge<FLOWTYPE> &e = G[v][i], &re = G.redge(e);\n            if (level[v] < level[e.to] && e.cap > 0) {\n                FLOWTYPE d = didfs(G, e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    re.cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    FLOWTYPE solve(Graph<FLOWTYPE> &G, int s, int t) {\n        level.assign((int)G.size(), -1); iter.assign((int)G.size(), 0);\n        FLOWTYPE res = 0;\n        while (true) {\n            dibfs(G, s);\n            if (level[t] < 0) return res;\n            for (int i = 0; i < (int)iter.size(); ++i) iter[i] = 0;\n            FLOWTYPE flow = 0;\n            while ((flow = didfs(G, s, t, INF)) > 0) {\n                res += flow;\n            }\n        }\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    cout.tie(0);\n    ios::sync_with_stdio(false);\n    int x,y,m,a,b;\n    cin >> x >> y >> m;\n    Graph<int> G(300);\n    for(int i=0;i<x;i++){\n    \tG.addedge(298,i,1);\n    }\n    for(int i=0;i<y;i++){\n    \tG.addedge(i+x,299,1);\n    }\n    for(int i=0;i<m;i++){\n    \tcin >> a >> b;\n    \tG.addedge(a,b+x,1);\n    }\n    Dinic<int> di;\n    cout << di.solve(G,298,299) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#define MAX_V 100\n#define INF 1000\nusing namespace std;\n\nint V, M;               //頂点，辺の数\nvector<int> G[MAX_V];   //グラフの隣接リスト表現\nint match[MAX_V];       //マッチングのペア\nbool used[MAX_V];       //DFSですでに調べたかのフラグ\n\n//uとvを結ぶ辺をグラフに追加する\nvoid add_edge(int u, int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\n//増加パスをDFSで探す\nbool dfs(int v){\n    for (int i=0; i<G[v].size(); i++){\n        if (used[G[v][i]] == false){\n            used[G[v][i]] = true;\n            if (match[G[v][i]] < 0){\n                match[G[v][i]] = v;\n                match[v] = G[v][i];\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n//二部グラフの最大マッチングを求める\nint bipartite_matching(){\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for(int v=0;v<V;v++){\n        if(match[v] < 0){\n            memset(used, 0, sizeof(used));\n            if(dfs(v)){\n                   res++;\n            }\n        }\n    }\n    return res;\n}\n\nint main(void){\n\tcin >> V >> M;\n\tint a,b;\n\tfor(int i=0;i<M;i++){\n\t\tcin >> a >> b;\n\t\tadd_edge(a,b);\n\t}\n\tstd::cout << bipartite_matching() << std::endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\nstruct edge { int to, rev; int cap; };\nvoid add_edge(vector<vector<edge>>& G, int u, int v, int c) {\n   G[u].push_back((edge){ v, SZ(G[v])  , c });\n   G[v].push_back((edge){ u, SZ(G[u])-1, 0 });\n}\nint dfs(vector< vector<edge> >& G, vector<bool>& used, int v, int t, int flow)\n{\n   if (v == t) return flow;\n   used[v] = true;\n   for(int i = 0; i < G[v].size(); ++i) {\n      edge& e = G[v][i];\n      if (used[e.to] || e.cap == 0) continue;\n      int d = dfs(G, used, e.to, t, min(e.cap, flow));\n      if (d > 0) {\n         e.cap -= d;\n         G[e.to][e.rev].cap += d;\n         return d;\n      }\n   }\n   return 0;\n}\nint max_flow(vector< vector<edge> >& G, int s, int t)\n{\n   int flow = 0;\n   vector<bool> used(G.size());\n   for (;;) {\n      fill(used.begin(), used.end(), false);\n      int f = dfs(G, used, s, t, INF);\n      if (f == 0) return flow;\n      flow += f;\n   }\n}\n\nsigned main()\n{\n   int a, b, m; cin >> a >> b >> m;\n   V<V<edge>> G(a+b+2);\n   REP(i, m) {\n      int x, y; cin >> x >> y;\n      add_edge(G, x, y+a, 1);\n   }\n   REP(x, a) {\n      add_edge(G, a+b, x, 1);\n   }\n   REP(y, b) {\n      add_edge(G, y+a, a+b+1, 1);\n   }\n   int ans = max_flow(G, a+b, a+b+1);\n   cout << ans << endl;\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define pp pair<pair<ll, ll>,pair<ll, ll>>\n#define pll pair<ll,ll>\n#define ppll pair<ll,pll>\n#define pdd pair<double,double>\n#define vii vector<int>\n#define vll vector<ll>\n#define mat vector<vector<ll>>\n#define lb lower_bound\n#define ub upper_bound\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define sc second\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep2(i,a,b) for(ll i=a;i<b;i++)\n#define repr(i,n) for(ll i=n-1;i>=0;i--)\n#define all(x) x.begin(),x.end()\n#define sz(x) (ll) (x).size()\n#define pq priority_queue<ll>\n#define pqg priority_queue<ll,vector<ll>,greater<ll>>\n#define LB(v,x) (lower_bound(v.begin(),v.end(),x)-v.begin())\n#define UB(v,x) (upper_bound(v.begin(),v.end(),x)-v.begin())\n#define ERASE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end())\n#define int ll\n// #define ll int\nusing namespace std;\nconst ll INF = 1 << 29;\nconst ll LLINF = (1LL << 60LL);\nconst ll MOD = 1000000007;\nconst int MAX_V = 500;\n// const ll mod = 998244353;\nconst ll MAX = 2100000;\nconst double pi = acos(-1);\nconst double eps = 1e-10;\nll dx[8] ={1,0,-1,0,1,-1,1,-1};\nll dy[8] ={0,1,0,-1,1,-1,-1,1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\n\n\ntemplate< class flow_type >\nstruct Dinic {\n    const flow_type inf;\n    struct edge {\n        int to;\n        flow_type cap;\n        int rev;\n        edge(int to, flow_type cap, int rev) : to(to), cap(cap), rev(rev) {}\n    };\n\n    vector < vector < edge > > graph;\n    vector < int > level, iter;\n\n    Dinic(int V) : inf(numeric_limits< flow_type >::max()/2), graph(V) {}\n\n    void add_edge(int from, int to, flow_type cap) {\n\n        graph[from].emplace_back(to, cap, (int)graph[to].size());\n        graph[to].emplace_back(from, 0, (int)graph[from].size() - 1);\n    }\n\n    void bfs(int source) {\n        level.assign(graph.size(), -1);\n        queue<int> que;\n        que.push(source);\n        level[source] = 0;\n        while(!que.empty()) {\n            int v = que.front(); que.pop();\n            for(int i = 0; i < (int)graph[v].size(); i++) {\n                edge &e = graph[v][i];\n                if(e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    flow_type dfs(int v, int  sink, flow_type f) {\n        if(v == sink) return f;\n        for(int &i = iter[v]; i < (int)graph[v].size(); i++){\n            edge &e = graph[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]) {\n                flow_type d = dfs(e.to, sink, min(e.cap, f));\n                if (d > 0) {\n                    e.cap -= d;\n                    graph[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    flow_type max_flow(int source, int sink) {\n        flow_type flow = 0;\n        while(true) {\n            bfs(source);\n            if(level[sink] < 0) return flow;\n            iter.assign(graph.size(), 0);\n            flow_type f;\n            while((f = dfs(source, sink, inf)) > 0) flow += f;\n        }\n    }\n\n    \n};\n\n\nvoid solve() {\n    int x,y,E;\n    cin>>x>>y>>E;\n    Dinic<int> din(x+y+2);\n    rep(i,x) din.add_edge(0,i+1,1);\n    rep(j,y) din.add_edge(j+x+1,x+y+1,1);\n    rep(i,E){\n        ll a,b;\n        cin>>a>>b;\n        din.add_edge(a+1, b+x+1,1);\n    }\n    cout<<din.max_flow(0,x+y+1)<<endl;\n}\n\n\n\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n\n\n    solve(); \n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\ntypedef vector<int> Vint;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct edge{\n  int to, cap, inv;\n};\n\nvector<edge> G[202];\nbool vsted[202];\nint inf = 123456789; //???????°´??????\n\nint dfs(int v, int e, int now, int t, int w){\n  if(now == t)return w;\n  vsted[now] = true;\n  for(int i = 0;i < G[now].size();++i){\n    edge tmp = G[now][i];\n    if(!vsted[tmp.to] && tmp.cap > 0){\n      int d = dfs(v, e, tmp.to, t, min(w, tmp.cap));\n      if(d > 0){\n        G[now][i].cap -= d;\n        G[tmp.to][tmp.inv].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nll edmondskarp(int v, int e, int s, int t){\n  ll res = 0;\n  for(;;){\n    for(int i = 0;i < v;++i)vsted[i] = false;\n    int x = dfs(v, e, s, t, inf);\n    if(x == 0)return res;\n    res += x;\n  }\n  return res;\n}\n\nsigned main(void){\n  int i, j, k;\n\n  int3(x, y, e);\n  int v = x + y + 2;\n  rep(i, e){\n    int2(l, r); /*--l; --r;*/ r += x;\n    G[l].pb((edge){r, 1, G[r].size()});\n    G[r].pb((edge){l, 0, G[l].size() - 1});\n  }\n\n  rep(i, x){\n    int r = i, l = x + y;\n    G[l].pb((edge){r, 1, G[r].size()});\n    G[r].pb((edge){l, 0, G[l].size() - 1});\n  }\n  rep(i, y){\n    int l = i + x, r = x + y + 1;\n    G[l].pb((edge){r, 1, G[r].size()});\n    G[r].pb((edge){l, 0, G[l].size() - 1});\n  }\n\n  cout << edmondskarp(v, e, x + y, v - 1) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include <cstdlib>  \n#include <math.h>\n#include <cmath>\n#include<complex>\n#include<cctype>\n#include<string>\n#include<set>\n#include<iomanip>\n#include <map>\n#include<algorithm>\n#include <functional>\n#include<vector>\n#include<climits>\n#include<stack>\n#include<queue>\n#include<bitset>\n#include <deque>\n#include <climits>\n#include <typeinfo>\n#include <utility> \n#include <numeric>\nusing namespace std;\nusing Complex = complex<double>;\nusing ll = long long;\ntemplate<typename T>using min_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst ll inf = 1145141919810364364LL;\ndouble PI = acos(-1.0);\n#define all(x) (x).begin(),(x).end()\n#define puts(x) cout << x << endl\n#define rep(i,m,n) for(ll i = m;i < n;++i)\n#define pb push_back\n#define fore(i,a) for(auto &i:a)\n#define rrep(i,m,n) for(ll i = m;i >= n;--i)\n\n\n//ford-fulkerson\nstruct edge { ll to, cap, rev; };\n\nconst int MAX_V = 400;\nint used[MAX_V + 3];\nvector<edge>G[MAX_V + 3];\nint fl = 0;\n\nll dfs(ll v, ll t, ll f) {\n\tif (v == t)return f;\n\tused[v] = 1;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tedge e = G[v][i];\n\t\tif (used[e.to] == 0 && e.cap > 0) {\n\t\t\tll d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\tG[v][i].cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid add_edge(ll from, ll to, ll cap) {\n\tedge fe = { to,cap,(int)G[to].size() };\n\tedge toe = { from,0,(int)G[from].size() };\n\tG[from].pb(fe);\n\tG[to].pb(toe);\n}\n\nll max_flow(int s, int t) {\n\tll flow = 0;\n\twhile (1) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tll f = dfs(s, t, inf);\n\t\tif (f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n// end of ford-fulkerson\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\n\tint X,Y,E;\n\tcin >> X >> Y >> E;\n\n\tfor (int i = 0; i < X; i++)add_edge(300,i,1);\n\tfor (int i = 0; i < Y; i++)add_edge(i+100,301,1);\n\tfor (int i = 0; i < E; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tadd_edge(x,y+100,1);\n\t}\n\t\n\tputs(max_flow(300,301));\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\nstatic const int MAX_V = 100;\nstatic const int MAX_K = 1000;\n \nint V;\nvector<int> G[MAX_V * 2];\nint match[MAX_V * 2];\nbool used[MAX_V * 2];\n \nvoid add_edge(int u, int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n \nbool dfs(int v){\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    int u = G[v][i], w = match[u];\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n \nint bipartite_matching(){\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  for(int v = 0; v < V; v++){\n    if(match[v] < 0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)){\n    res++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int X, Y, E;\n  scanf(\"%d %d %d\", &X, &Y, &E);\n  V = X + Y;\n  int u, v;\n  for(int i = 0; i < E; i++){\n    scanf(\"%d %d\", &u, &v);\n    add_edge(u, v + X);\n  }\n  printf(\"%d\\n\", bipartite_matching());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nconst int INF = 1e9;\nconst int MAX_V = 300;\n\nint X, Y;\nstruct Flow{\n    struct edge{\n        int to, cap, rev;\n    };\n    vector<edge> G[MAX_V];//??£??\\?????????\n    bool used[MAX_V];\n\n    void add_edge(int from, int to, int cap){\n        G[from].push_back((edge){to, cap, G[to].size()});//from -> to\n        G[to].push_back((edge){from, 0, G[from].size() - 1});//to -> from\n    }\n\n    //?¢???????????????¢???\n    int dfs(int v, int t, int f){\n        if(v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); ++i){\n            edge &e = G[v][i];\n            if(!used[e.to] && e.cap > 0){\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    //s??????t???????????§???\n    int max_flow(int s, int t){\n        int flow = 0;\n        while(1){\n            memset(used, 0, sizeof(used));\n            int f = dfs(s, t, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nint main(void){\n\tint e; cin >> X >> Y >> e;\n\tint s = X + Y;\n\tint t = X + Y + 1;\n\tFlow mf;\n\t//s -> x\n\trep(i, X){\n\t\tmf.add_edge(s, i, 1);\n\t}\n\t// y -> t\n\trep(i, Y){\n\t\tmf.add_edge(X + i, t, 1);\n\t}\n\t// x -> y\n\trep(i, e){\n\t\tint tx, ty; cin >> tx >> ty;\n\t\tmf.add_edge(tx, X + ty, 1);\n\t}\n\n\tprintf(\"%d\\n\", mf.max_flow(s, t));\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 200\n\nint V;\nvector<int> G[NUM];\nint match[NUM];\nbool used[NUM];\n\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\tG[to].push_back(from);\n}\n\nint dfs(int node_id){\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tint adj_node_id = G[node_id][i],pair_id = match[adj_node_id];\n\t\tif((pair_id < 0)||(used[pair_id] == false && dfs(pair_id) == true)){\n\t\t\tmatch[node_id] = adj_node_id;\n\t\t\tmatch[adj_node_id] = node_id;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint bipartie_matching(){\n\tint ret = 0;\n\tfor(int i = 0; i < V; i++)match[i] = -1;\n\tfor(int node_id = 0; node_id < V; node_id++){\n\t\tif(match[node_id] < 0){\n\t\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\t\tif(dfs(node_id)){\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\n\tint X,Y,E;\n\n\tscanf(\"%d %d %d\",&X,&Y,&E);\n\n\tint from,to;\n\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tadd_edge(from,X+to);\n\t}\n\n\tV = X+Y;\n\n\tprintf(\"%d\\n\",bipartie_matching());\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 10000\nusing namespace std;\nint V;                //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\???????????¨???\nint match[MAX_V];     //??????????????°????????¢\nbool used[MAX_V];     //DFS??§?????§??????????????????????????°\n\n//u??¨v????????¶????????°?????????????????????\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\n//?¢?????????????DFS??§??¢???\nbool dfs(int v){\n  used[v] = true;\n  for(int i=0; i<G[v].size(); i++){\n    int u = G[v][i], w = match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\n//?????¨??°??????????????§??????????????°????±???????\nint Bipartite_Matching(){\n  int res=0;\n  memset(match, -1, sizeof(match));\n  for(int v=0; v<V; v++){\n    if(match[v] < 0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)) res++;\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  int n,m,l;\n  cin>>n>>m>>l;\n  for(int i=0,a,b;i<l;i++)cin>>a>>b,add_edge(a,n+b);\n  V=n+m;\n  cout <<Bipartite_Matching()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl;\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define repi(start,end) for(int i=start; i<end; i++)\n#define repj(start,end) for(int j=start; j<end; j++)\n#define repk(start,end) for(int k=start; k<end; k++)\n#define repl(start,end) for(int l=start; l<end; l++)\n#define RE return 0;\n\nstruct edge{int to,cap,rev;};\n\nint n,k;\nbool can[1000][1000];\nint used[100];\n\nvector<edge> G[2000000];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  //cout<<\"  v = \"<<v<<en\n  if(v==t) return f;\n  used[v]=true;\n  repi(0, G[v].size()){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int i=0;\n  int flow=0;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    //cout<<\"         \"<<i++<<en\n    int f=dfs(s, t, INF);\n    if(f==0) return flow;\n    flow+=f;\n  }\n}\n\nvoid solve(){\n  int s=n+k,t=s+1;\n  \n  repi(0, n){\n    add_edge(s,i,1);\n  }\n  repi(0, k){\n    add_edge(n+i, t, 1);\n  }\n  \n  repi(0, n){\n    repj(0, k){\n      if(can[i][j]){\n        add_edge(i, n+j, 1);\n      }\n    }\n  }\n  \n  cout<<max_flow(s, t)<<en\n}\n\n\n\n\n\n\nint main(){\n  /*\n  cin>>n>>k;\n  repi(0, n){\n    int num;\n    cout<<\"        \"<<i<<\":\"<<en\n    cout<<\"how many?     \";\n    cin>>num;\n    cout<<\"encode ->   \";\n    int a;\n    repj(0, num) {cin>>a; can[i][a]=true;}\n  }\n  cout<<en*/\n  \n  repi(0, 1000){\n    repj(0, 1000){\n      can[i][j]=false;\n    }\n  }\n  \n  int e,a,b;\n  cin>>n>>k>>e;\n  repi(0, e){\n    cin>>a>>b;\n    can[a][b]=true;\n  }\n  \n  solve();\n  RE\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define N 205\n#define M 20005\n\nint n, m, e;\n\nint ans = 0;\n\nbitset<N> vis;\n\narray<int, N> mac;\n\narray<vector<int>, N> to;\n\nbool dfs(int u)\n{\n\tif (u == -1)\n\t\treturn true;\n\t\t\n\tfor (auto v : to[u])\n\t\tif (!vis[v])\n\t\t{\n\t\t\tvis.set(v);\n\t\t\tif (dfs(mac[v]))\n\t\t\t{\n\t\t\t\tmac[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\treturn false;\n}\n\nsigned main(void)\n{\n\tcin >> n >> m >> e;\n\t\n\tfor (int x, y; e--; )\n\t{\n\t\tcin >> x >> y;\n\t\tto[x].push_back(y + n);\n\t\tto[y + n].push_back(x);\n\t}\n\t\n\tmemset(begin(mac), -1, sizeof(mac));\n\t\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tvis.reset();\n\t\tans += dfs(i);\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint V;  //  頂点数\nconst int MAX_V = 10001;\nvector<int> G[MAX_V];  // グラフの隣接リスト表現\nint match[MAX_V];      // マッチングのペア\nbool used[MAX_V];      // DFS で既に調べたかのフラグ\n\n// u と v を結ぶ辺をグラフに追加する\nvoid add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\n// 増加パスを DFSで探す\nbool dfs(int v) {\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        int u = G[v][i], w = match[u];\n        if (w < 0 || !used[w] && dfs(w)) {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\n// 二部グラフの最大マッチングを求める\nint bipartite_matching() {\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    //cout << \"V:\" << V << endl;\n    for (int v = 0; v < V; v++) {\n        //cout << \"v:\" << v << \" match[v]:\" << match[v] << endl;\n        if (match[v] < 0) {\n            memset(used, 0, sizeof(used));\n            if (dfs(v)) {\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nint main(int argc, char *argv[]) {\n\tint x, y, e;\n\tcin >> x >> y >> e;\n    V = x + y;\n\tfor (int i = 0; i < e; i++) {\n\t    int from, to;\n\t    cin >> from >> to;\n\t    add_edge(from, to + 1000);\n\t}\n    cout << bipartite_matching() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> lpair;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e18;\n#define rep(i,m,n) for(ll i = (m); i < (n); i++)\n#define rrep(i,m,n) for(ll i = (m); i >= (n); i--)\n#define print(x) cout << (x) << endl;\n#define print2(x,y) cout << (x) << \" \" << (y) << endl;\n#define printa(x,n) for(ll i = 0; i < n; i++){ cout << (x[i]) << \" \";} cout<<endl;\ntypedef struct {\n    ll to;\n    ll cap;\n    ll rev;\n} edge;\nvector<edge> G[210];\nbool used[210];\n\nll dfs(ll v, ll t, ll f){\n    if(v == t) return f;\n    used[v] = true;\n    rep(i,0,G[v].size()){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            ll d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll X,Y,E;\n    cin >> X >> Y >> E;\n    ll x[10010], y[10010];\n    rep(i,0,E){\n        cin >> x[i] >> y[i];\n        x[i]++; y[i] += X+1;\n        G[x[i]].push_back((edge){y[i], 1, G[y[i]].size()});\n        G[y[i]].push_back((edge){x[i], 0, G[x[i]].size()-1});\n    }\n    rep(i,1,X+1){\n        G[0].push_back((edge){i, 1, G[i].size()});\n        G[i].push_back((edge){0, 0, G[0].size()-1});        \n    }\n    rep(i,X+1,X+Y+1){\n        G[i].push_back((edge){X+Y+1, 1, G[X+Y+1].size()});\n        G[X+Y+1].push_back((edge){i, 0, G[i].size()-1});\n    }\n\n    ll ans = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        ll f = dfs(0, X+Y+1, INF);\n        if(f == 0) break;\n        ans += f;\n    }\n    print(ans);\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<math.h>\n\nusing namespace std;\n\n#define INF 1e9+7\n\nstruct edge{\n  int t,c, rev;\n};\n\nstruct Graph{\n  vector<vector<edge>> edges;\n  vector<int> used;\n  Graph(int n): edges(n){};\n};\n\nint dfs(int v, int t, int f, Graph& G){\n  if(v == t) return f;\n  G.used[v] = 1;\n  for(edge& e:G.edges[v]){\n    if(!G.used[e.t] && e.c > 0){\n      int d = dfs(e.t, t, min(f, e.c), G);\n      if(d > 0){\n        e.c -= d;\n        G.edges[e.t][e.rev].c += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  int x,y,e;\n  int ans = 0;\n  cin >> x >> y >> e;\n  Graph G = Graph(x+y+2);\n  for(int i = 0; i < e; i++){\n    int f,t;\n    cin >> f >> t;\n    G.edges[f].push_back((edge){x+t, 1, (int)G.edges[x+t].size()});\n    G.edges[x+t].push_back((edge){f, 0, (int)G.edges[f].size() - 1});\n  }\n  int s = x+y;\n  int t = x+y+1;\n\n  for(int i = 0; i < x; i++){\n    G.edges[s].push_back({i, 1, (int)G.edges[i].size()});\n    G.edges[i].push_back({s, 0, (int)G.edges[s].size() - 1});\n  }\n  for(int i = 0; i < y; i++){\n    G.edges[x+i].push_back({t, 1, (int)G.edges[t].size()});\n    G.edges[t].push_back({x+i, 0, (int)G.edges[x+i].size() - 1});\n  }\n  for(;;){\n    G.used = vector<int>(x+y+2, 0);\n    int f = dfs(s, t, INF, G);\n    if(f == 0) break;\n    ans += f;\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nbool can[105][105];\nstruct edge{\n  int to,cap,rev;\n};\nvector<edge> G[1005];\nbool used[1005];\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    for(int i=0;i<1005;i++) used[i]=false;\n    int f=dfs(s,t,12345678);\n    if(f==0) return flow;\n    flow+=f;\n  }\n}\nint main(){\n  int x,y,k;\n  cin>>x>>y>>k;\n  for(int i=0;i<105;i++){\n    for(int j=0;j<105;j++) can[i][j]=false;\n  }\n  for(int i=0;i<k;i++){\n    int a,b;\n    cin>>a>>b;\n    can[a][b]=true;\n  }\n  int s=x+y,t=s+1;\n  for(int i=0;i<x;i++) add_edge(s,i,1);\n  for(int i=0;i<y;i++) add_edge(x+i,t,1);\n  for(int i=0;i<x;i++){\n    for(int j=0;j<y;j++){\n      if(can[i][j]){\n        add_edge(i,x+j,1);\n      }\n    }\n  }\n  cout<<max_flow(s,t)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define EVEN(x) (mu[x] == x || (mu[x] != x && phi[mu[x]] != mu[x]))\n#define ODD(x)  (mu[x] != x && phi[mu[x]] == mu[x] && phi[x] != x)\n#define OUTER(x) (mu[x] != x && phi[mu[x]] == mu[x] && phi[x] == x)\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nint maximumMatching(const Graph &g) {\n  int n = g.size();\n  vector<int> mu(n), phi(n), rho(n), scanned(n);\n  REP(v,n) mu[v] = phi[v] = rho[v] = v; // (1) initialize\n  for (int x = -1; ; ) {\n    if (x < 0) {                        // (2) select even\n      for (x = 0; x < n && (scanned[x] || !EVEN(x)); ++x);\n      if (x == n) break;\n    }\n    int y = -1;                         // (3) select incident\n    FOR(e, g[x]) if (OUTER(e->dst) || (EVEN(e->dst) && rho[e->dst] != rho[x])) y = e->dst;\n    if (y == -1) scanned[x] = true, x = -1;\n    else if (OUTER(y)) phi[y] = x;      // (4) growth\n    else {\n      vector<int> dx(n, -2), dy(n, -2); // (5,6), !TRICK! x % 2 --> x >= 0\n      for (int k = 0, w = x; dx[w] < 0; w = k % 2 ? mu[w] : phi[w]) dx[w] = k++;\n      for (int k = 0, w = y; dy[w] < 0; w = k % 2 ? mu[w] : phi[w]) dy[w] = k++;\n      bool vertex_disjoint = true;\n      REP(v,n) if (dx[v] >= 0 && dy[v] > 0) vertex_disjoint = false;\n      if (vertex_disjoint) {            // (5) augment\n        REP(v,n) if (dx[v] % 2) mu[phi[v]] = v, mu[v] = phi[v];\n        REP(v,n) if (dy[v] % 2) mu[phi[v]] = v, mu[v] = phi[v];\n        mu[x] = y; mu[y] = x; x = -1;\n        REP(v,n) phi[v] = rho[v] = v, scanned[v] = false;\n      } else {                          // (6) shrink\n        int r = x, d = n;\n        REP(v,n) if (dx[v] >= 0 && dy[v] >= 0 && rho[v] == v && d > dx[v]) d = dx[v], r = v;\n        REP(v,n) if (dx[v] <= d && dx[v] % 2 && rho[phi[v]] != r) phi[phi[v]] = v;\n        REP(v,n) if (dy[v] <= d && dy[v] % 2 && rho[phi[v]] != r) phi[phi[v]] = v;\n        if (rho[x] != r) phi[x] = y;\n        if (rho[y] != r) phi[y] = x;\n        REP(v,n) if (dx[rho[v]] >= 0 || dy[rho[v]] >= 0) rho[v] = r;\n      }\n    }\n  }\n  int ret = 0;\n  REP(u,n) if (u < mu[u]) ret++;\n  return ret;\n}\nint X, Y, E, x, y; Graph G;\nint main() {\n\tscanf(\"%d%d%d\", &X, &Y, &E); G.resize(X + Y);\n\tfor(int i = 0; i < E; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tG[x].push_back(Edge(x, X + y, 1));\n\t\tG[X + y].push_back(Edge(X + y, x, 1));\n\t}\n\tprintf(\"%d\\n\", maximumMatching(G));\n}"
  },
  {
    "language": "C++",
    "code": "//  Created by Vignesh Manoharan\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <stack>\n#include <set>\n#include <cstring>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<vi> vvi;\n\nconst int INF = 1000000000;\nconst ll LINF = 1e17;\nconst double PI =3.141592653589793238;\n#pragma unused(INF,PI,LINF)\n#define F(i,a,n) for(int i=(a);i<(n);i++)\n\ntemplate<typename T,typename TT> ostream& operator<<(ostream &s,pair<T,TT> t) {return s<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<typename T> ostream& operator<<(ostream &s,vector<T> t){\n    for(int i=0;i<(t).size();i++)s<<t[i]<<((i<(t).size()-1)?\" \":\"\");return s; }\ntemplate<typename T> ostream& operator<<(ostream &s,set<T> t){for(T x:t) s<<x<<\" \";return s; }\ntemplate<typename T> istream& operator>>(istream &s,vector<T> &t){\n    for(int _i=0;_i<t.size();_i++) s>>t[_i];return s; }\n\n#define pb push_back\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n\nstruct flow_graph{\n    int MAX_V,E,s,t,head,tail;\n    int *cap,*to,*next,*last,*dist,*q,*now;\n    flow_graph(){}\n    flow_graph(int V, int MAX_E){\n        MAX_V = V; E = 0;\n        cap = new int[2*MAX_E], to = new int[2*MAX_E], next = new int[2*MAX_E];\n        last = new int[MAX_V], q = new int[MAX_V], dist = new int[MAX_V], now = new int[MAX_V];\n        fill(last,last+MAX_V,-1);\n    }\n    void clear(){\n        fill(last,last+MAX_V,-1);\n        E = 0;\n    }\n    void add_edge(int u, int v, int uv, int vu = 0){\n        to[E] = v, cap[E] = uv, next[E] = last[u]; last[u] = E++;\n        to[E] = u, cap[E] = vu, next[E] = last[v]; last[v] = E++;\n    }\n    bool bfs(){\n        fill(dist,dist+MAX_V,-1);\n        head = tail = 0;\n        \n        q[tail] = t; ++tail;\n        dist[t] = 0;\n        \n        while(head<tail){\n            int v = q[head]; ++head;\n            \n            for(int e = last[v];e!=-1;e = next[e]){\n                if(cap[e^1]>0 && dist[to[e]]==-1){\n                    q[tail] = to[e]; ++tail;\n                    dist[to[e]] = dist[v]+1;\n                }\n            }\n        }\n        \n        return dist[s]!=-1;\n    }\n    \n    int dfs(int v, int f){\n        if(v==t) return f;\n        \n        for(int &e = now[v];e!=-1;e = next[e]){\n            if(cap[e]>0 && dist[to[e]]==dist[v]-1){\n                int ret = dfs(to[e],min(f,cap[e]));\n                \n                if(ret>0){\n                    cap[e] -= ret;\n                    cap[e^1] += ret;\n                    return ret;\n                }\n            }\n        }\n        \n        return 0;\n    }\n    \n    long long max_flow(int source, int sink){\n        s = source; t = sink;\n        long long f = 0;\n        int x;\n        \n        while(bfs()){\n            for(int i = 0;i<MAX_V;++i) now[i] = last[i];\n            \n            while(true){\n                x = dfs(s,INT_MAX);\n                if(x==0) break;\n                f += x;\n            }\n        }\n        \n        return f;\n    }\n} G;\n\nint main(int argc, const char * argv[]) {\n#ifdef local_test\n    //    input\n    //    freopen(\"input\",\"w\",stdout);\n    //    cout<<\"1 \\n 100 10 \\n\";\n     freopen(\"input\",\"r\",stdin);\n     freopen(\"output\",\"w\",stdout);\n#endif\n    int x,y,e,u,v;\n    scanf(\"%d %d %d\",&x,&y,&e);\n    G=flow_graph(x+y+2,e+x+y);\n    for(int i = 0;i<e;i++){\n        scanf(\"%d %d\",&u,&v);\n        G.add_edge(u,x+v,1,1);\n    }\n    for(int i=0;i<x;i++){\n        G.add_edge(x+y,i,1,1);\n    }\n    for(int i=0;i<y;i++){\n        G.add_edge(x+i,x+y+1,1,1);\n    }\n    printf(\"%lld\\n\",G.max_flow(x+y,x+y+1));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// statics\nusing namespace std;\nusing int64 = long long;\nusing PAIR = pair<int, int>;\nconstexpr int INF = 1 << 30;\nconstexpr int64 LINF = 1LL << 60;\nconstexpr int MOD = 1e9 + 7;\nconstexpr int MAX_N = 1e5 + 1;\nconstexpr int MAX_V = 575;\n\n// init/input\n#define int int64\n#define INIT ios::sync_with_stdio(false);cin.tie(0);\n#define VAR(type, ...) type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T &t) {cin>>t;}\ntemplate<typename First, typename...Rest> void MACRO_VAR_Scan(First &first, Rest&...rest) {cin>>first;MACRO_VAR_Scan(rest...);}\n#define VEC(type, c, n) vector<type> c(n);for(auto &&i:c)cin>>i;\n\n// out\n#define OUT(dist) cout<<(dist);\n#define FOUT(n, dist) cout <<fixed<<setprecision(n)<<(dist);\n#define SP cout<<\" \";\n#define BR cout<<\"\\n\";\n#define debug(x) cerr << #x << \":\" << (x);BR;\n\n// utility\n#define ALL(a) (a).begin(), (a).end()\n#define EACH(i, a) for(auto &&i:(a))\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=0;--i)\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n\nint V;\nvector< int > G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to) {\n  G[from].push_back(to);\n  G[to].push_back(from);\n}\n\nint dfs(int v) {\n  used[v] = true;\n\n  for (int i = 0; i < (int)G[v].size(); ++i) {\n    int to = G[v][i], w = match[to];\n    if (w < 0 || !used[w] && dfs(w)) {\n      match[v] = to;\n      match[to] = v;\n      return true;\n    }\n  }\n}\n\nsigned main() {\n  INIT;\n\n  VAR(int, X, Y, E);\n  REP(ei, E) {\n    VAR(int, from, to);\n    add_edge(from, X + to);\n  }\n  V = X + Y;\n\n  // 二部グラフの最大マッチング\n  auto bipartie_matching = []() {\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for (int v = 0; v < V; ++v) {\n      if (match[v] < 0) {\n\tmemset(used, 0, sizeof(used));\n\tif (dfs(v) > 0) {\n\t  res++;\n\t}\n      }\n    }\n    return res;\n  };\n  \n  OUT(bipartie_matching())BR;\n\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string.h>\nusing namespace std;\ntypedef long long ll;\nll inf = 1e18;\n\nclass network_flow{\nprivate:\n\tint N;\n\tstruct edge{int to; ll cap; int rev;};\n\tvector<vector<edge>> G;\n\tvector<int> level,iter;\n\tvoid bfs(int s){\n\t\tfor(int i=0;i<=N;i++) level[i] = -1;\n\t\tqueue<int> Q;\n\t\tlevel[s] = 0;\n\t\tQ.push(s);\n\t\twhile(!Q.empty()){\n\t\t\tint v = Q.front(); Q.pop();\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[e.to]<0){\n\t\t\t\t\tlevel[e.to] = level[v]+1;\n\t\t\t\t\tQ.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll dfs(int v,int t,ll f){\n\t\tif(v==t) return f;\n\t\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(level[v]<level[e.to] && e.cap>0){\n\t\t\t\tll d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\tnetwork_flow(int n){\n\t\tN = n;\n\t\tG = vector<vector<edge>>(N+1);\n\t\tlevel = iter = vector<int>(N+1);\n\t}\n\tvoid add_edge(int from, int to,ll cap){\n\t\tG[from].push_back((edge){to,cap,(int) G[to].size()});\n\t\tG[to].push_back((edge){from,0,(int) G[from].size()-1});\n\t}\n\tll max_flow(int s,int t){\n\t\tll flow = 0;\n\t\tfor(;;){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0) return flow;\n\t\t\tfor(int i=0;i<=N;i++) iter[i] = 0;\n\t\t\tll f;\n\t\t\twhile((f=dfs(s,t,inf))>0) flow += f;\n\t\t}\n\t}\n};\n\nint X,Y,E;\n\nint main(){\n\tcin >> X >> Y >> E;\n\tnetwork_flow flow(X+Y+2);\n    int x,y;\n    for(int i=1;i<=X;i++) flow.add_edge(0,i,1);\n    for(int i=1;i<=Y;i++) flow.add_edge(X+i,X+Y+1,1);\n    for(int i=0;i<E;i++){\n\t\tcin >> x >> y;\n        x++; y++;\n\t\tflow.add_edge(x,X+y,1);\n\t}\n\tcout << flow.max_flow(0,X+Y+1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint X,Y,E,x,y;\nbool D[110][110]={};\nint PY[100];\nbool V[110];\n\nbool match(int x)\n{\n\tif(x<0) return true;\n\tif(V[x]) return false;\n\tV[x]=true;\n\tfor(int y=0;y<Y;++y){\n\t\tif(!D[x][y]) continue;\n\t\tif(match(PY[y])){\n\t\t\tPY[y]=x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main()\n{\n\tcin>>X>>Y>>E;\n\tfor(int i=0;i<E;++i){\n\t\tcin>>x>>y;\n\t\tD[x][y]=true;\n\t}\n\n\tfill(PY, PY+Y, -1);\n\tint count=0;\n\tfor(int x=0;x<X;++x){\n\t\tfill(V, V+X, false);\n\t\tif(match(x)) ++count;\n\t}\n\n\tcout<<count<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAX 1024\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\nint X, Y, E;\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, cap, G[to].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge& e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (1) {\n        for (int i = 0; i < MAX; i++) used[i] = false;\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(void) {\n    cin >> X >> Y >> E;\n    while (E--) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, X+y, 1);\n    }\n    int s = X+Y, t = s+1;\n    for (int i = 0; i < X; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        add_edge(t, X+i, 1);\n    }\n    cout << max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <valarray>\nusing namespace std;\n\nbool match(int cur,bool arr[],bool V[],int npair[], int column){\n    if(cur < 0){\n        return true;\n    }\n    if(V[cur]){\n        return false;\n    }\n    V[cur] = true;\n    for(int i = 0; i < column; i++){\n        if(!arr[cur*column + i]){\n            continue;\n        }\n        if(match(npair[i],arr,V,npair,column)){\n            npair[i] = cur;\n            return true;\n        }\n    }\n    return true;\n}\n\nint main(){\n    int row,column,E;\n    scanf(\"%d %d %d\",&row,&column,&E);\n    bool arr[row*column],V[row];\n    for(int ei = 0; ei < E; ei++){\n        int from,to;\n        scanf(\"%d %d\",&from,&to);\n        arr[from*column + to] = true;\n    }\n    int npair[column],count = 0;\n    for(int i = 0; i < column; i++){\n        npair[i] = -1;\n    }\n    for(int cur = 0; cur < row; cur++){\n        for(int i = 0; i < row; i++){\n            V[i] = false;\n        }\n        if(match(cur,arr,V,npair,column)){\n            count++;\n        }\n    }\n    printf(\"%d\",count);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\n#define INF 1<<29\nusing namespace std;\nstruct edge{int to,cap,rev;};\nvector<edge>G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int>q;\n  level[s]=0;\n  q.push(s);\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(int i=0;i<(int)(G[v].size());i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n        level[e.to]=level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<(int)(G[v].size());i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\nint main(){\n  int x,y,m;\n  cin>>x>>y>>m;\n  while(m--){\n    int a,b;\n    cin>>a>>b;\n    add_edge(a+1,b+x+1,1);\n  }\n  for(int i=0;i<x;i++){\n  \tadd_edge(0,i+1,1);\n  }\n  for(int i=0;i<y;i++){\n  \tadd_edge(x+i+1,x+y+1,1);\n  }\n  cout<<max_flow(0,x+y+1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<P> vp;\ntypedef vector<ll> vll;\n\nconst int INF = 99999999;\nconst int MAX_V = 1000;\n\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];       // for DFS\n\n// add graph the edge\nvoid add_edge(int from, int to, int cap) {\n    G[from].emplace_back((edge){to, cap, (int)G[to].size()});\n    G[to].emplace_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n\tfor (auto& e : G[v]) {\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    for(;;) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nsigned main() {\n\tint X, Y, E;\n\tcin >> X >> Y >> E;\n\tint N = X + Y;\n\tint s = N;\n\tint t = s + 1;\n\trep(i, X) {\n\t\tadd_edge(s, i, 1);\n\t}\n\trep(i, Y) {\n\t\tadd_edge(i + X, t, 1);\n\t}\n\trep(i, E) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tadd_edge(a, b + X, 1);\n\t}\n\tcout << max_flow(s, t) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define mod 1000000007 //1e9+7\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1001\n\nstruct BipartiteMatching{\n  \n  int V;\n  vector<vector<int> > G;\n  vector<int> match;\n  vector<bool> used;\n  \n  BipartiteMatching(int n):\n    V(n),G(n,vector<int>()){}\n  \n  void add_edge(int u, int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  \n  bool dfs(int v){\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++){\n      int u = G[v][i], w = match[u];\n      if(w < 0 || (!used[w] && dfs(w))){\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n  \n  int solve(){\n    int res = 0;\n    match.assign(V,-1);\n    for(int i=0;i<V;i++){\n      if(match[i] < 0){\n        used.assign(V,false);\n        if(dfs(i)) res++;\n      }\n    }\n    \n    return res;\n  }\n  \n};\n\n\n\nint main(){\n  int x,y,e;\n\n  scanf(\"%d%d%d\",&x,&y,&e);\n\n  BipartiteMatching bip(x+y);\n\n  for(int i=0;i<e;i++){\n    int a,b;\n\n    scanf(\"%d%d\",&a,&b);\n\n    bip.add_edge(a,b+x);\n  }\n\n  printf(\"%d\\n\",bip.solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<unordered_set>\nlong long const infty = 0x3fffffffffffff;\nstruct edge{\n    int from,to;\n    long long weight;\n};\nclass Graph{\nprotected:\n    //隣接リスト\n    std::vector<edge> *adj;\npublic:\n    //頂点の数\n    int numVertex;\n    //辺の数\n    int numEdge;\n\n    //---基本---\n\n    //v頂点のグラフを作成する（頂点の番号は0-indexed）\n    Graph(int v){\n        numVertex=v;\n        numEdge=0;\n        adj=new std::vector<edge>[v];\n    }\n    ~Graph(){ delete[] adj; }\n    void addEdge(int u,int v,long long w=1LL){\n        adj[u].push_back({u,v,w});\n        numEdge++;\n    }\n    //フロー計算用の有向辺+逆辺の追加\n    //weightは容量、fromは逆辺への参照\n    void addNetwork(int u,int v,long long w=1LL){\n        adj[u].push_back({(int)adj[v].size(),v,w});\n        adj[v].push_back({(int)adj[u].size()-1,u,0});\n        numEdge++;\n    }\n\n    //辺の重みの和\n    long long sum_weight(bool isDirected=true){\n        long long sum=0;\n        for(int i=0;i<numVertex;i++){\n            for(int j=0;j<(int)adj[i].size();j++){\n                sum+=adj[i][j].weight;\n            }\n        }\n        if(isDirected)return sum;\n        else return sum/2; //無向グラフなら両方の向きの辺が隣接リストに入っている\n    }\n\n    //---一般のグラフに使えるアルゴリズム---\n    \n    //単一頂点を始点とする最短経路 O(V+E)\n    //制約 : weightをすべて1とみなす（つまり最短パス長）\n    void shortestPath_bfs(int *l,int s){\n        for(int i=0;i<numVertex;i++)l[i]=-1;\n        std::queue<int> q;\n        l[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();\n            q.pop();\n            for(int i=0;i<(int)adj[v].size();i++){\n                edge &e = adj[v][i];\n                if(e.weight>0 && l[e.to]<0){\n                    l[e.to]=l[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    //単一頂点を始点とする最短経路 O(E+VlogV)\n    //制約 : weight>=0, weightがすべて等しいときはO(V^2)\n    void shortestPath_Dijkstra(long long l[],int s,int prev[]=NULL){\n        for(int i=0;i<numVertex;i++)l[i]=infty;\n        if(prev!=NULL)for(int i=0;i<numVertex;i++)prev[i]=-1;\n        l[s]=0;\n        auto cmp=[](const edge &a,const edge &b)->bool { return a.weight>b.weight; };\n        std::priority_queue<edge,std::vector<edge>,decltype(cmp)> pq(cmp);\n        pq.push({0,s,-1});\n        while(!pq.empty()){\n            int u=pq.top().to;\n            pq.pop();\n            for(auto i=adj[u].begin();i!=adj[u].end();i++){\n                int v=(*i).to;\n                long long w=(*i).weight;\n                if(l[v]>l[u]+w){\n                    l[v]=l[u]+w;\n                    if(prev!=NULL)prev[v]=u;\n                    pq.push({u,v,l[v]});\n                }\n            }\n        }\n    }\n\nprivate:\n    //最短距離の更新\n    bool relaxing_Bellman_Ford(long long l[]){\n        bool relaxed=false;\n        for(int u=0;u<numVertex;u++){\n            if(l[u]==infty)continue;\n            for(int i=0;i<(int)adj[u].size();i++){\n                edge &e=adj[u][i];\n                if(l[e.to]>l[u]+e.weight){\n                    l[e.to]=l[u]+e.weight;\n                    relaxed=true;\n                }\n            }\n        }\n        return relaxed;\n    }\npublic:\n    //単一頂点を始点とする最短経路 O(VE)\n    //返り値はsを始点とする閉路の存在\n    bool shortestPath_Bellman_Ford(long long l[],int s){\n        for(int i=0;i<numVertex;i++)l[i]=infty;\n        l[s]=0;\n        for(int rep=0;rep<numVertex;rep++){\n            if(!relaxing_Bellman_Ford(l))return false;\n        }\n        return true;\n    }\n    //各頂点を通る閉路の存在 O(VE)\n    bool find_negative_loop(bool b[]){\n        long long *l=new long long[numVertex];\n        for(int i=0;i<numVertex;i++)l[i]=0;\n        for(int rep=0;rep<numVertex;rep++){\n            if(!relaxing_Bellman_Ford(l))return false;\n        }\n        //負閉路が存在する\\iff relaxingし終わった状態からさらに更新される\n        long long *l2=new long long[numVertex];\n        for(int i=0;i<numVertex;i++)l2[i]=l[i];\n        for(int rep=0;rep<numVertex;rep++){\n            relaxing_Bellman_Ford(l2);\n        }\n        for(int i=0;i<numVertex;i++)b[i]=(l[i]!=l2[i]);\n        return true;\n    }\n    //負閉路の存在 O(VE)\n    bool find_negative_loop(){\n        long long *l=new long long[numVertex];\n        for(int i=0;i<numVertex;i++)l[i]=0;\n        for(int rep=0;rep<numVertex;rep++){\n            if(!relaxing_Bellman_Ford(l))return false;\n        }\n        return true;\n    }\n\n    //sを含む連結成分の最小全域木 O(E+VlogV)\n    Graph minimumSpanTree_Prim(int s=0){\n        Graph g(numVertex);\n        //pq={頂点0の隣接辺}で初期化、weightの小さいほうからtop()に出てくる\n        auto cmp=[](const edge &a,const edge &b)->bool { return a.weight>b.weight; };\n        std::priority_queue<edge,std::vector<edge>,decltype(cmp)> pq(cmp);\n        for(int i=0;i<(int)adj[s].size();i++){\n            pq.push(adj[s][i]);\n        }\n        //isvisited[i]=(頂点iが作成中の木gに含まれるか)\n        bool *isvisited=new bool[numVertex];\n        for(int i=0;i<numVertex;i++)isvisited[i]=false;\n        isvisited[s]=true;\n        \n        while(true){\n            //pq.top()が、訪問済みの点と未訪問の点を結ぶ辺になるまでpopする\n            while(!pq.empty() && isvisited[pq.top().from]==isvisited[pq.top().to])pq.pop();\n            if(pq.empty())return g;\n            edge e=pq.top();\n            pq.pop();\n            //eの未訪問な端点vを訪問済みにする\n            int v=isvisited[e.from]?e.to:e.from;\n            isvisited[v]=true;\n            //vから未訪問点へのびる辺をpqに追加\n            for(int i=0;i<(int)adj[v].size();i++){\n                if(!isvisited[adj[v][i].to])pq.push(adj[v][i]);\n            }\n            //eをgに追加\n            g.addEdge(e.from,e.to,e.weight);\n            g.addEdge(e.to,e.from,e.weight);\n        }\n    }\n\n    //sと同じ連結成分にある頂点集合を返す\n    std::unordered_set<int> isSameComponent(int s){\n        std::queue<int> q;\n        std::unordered_set<int> ans;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();\n            ans.emplace(v);\n            q.pop();\n            for(auto i=adj[v].begin();i!=adj[v].end();i++){\n                int w=(*i).to;\n                if(ans.count(w)==0)q.push(w);\n            }\n        }\n        return ans;\n    }\n    bool isConnected(){\n        return (int)(isSameComponent(0).size())==numVertex;\n    }\n    bool isTree(){\n        return isConnected()&&(numEdge+1==numVertex);\n    }\n    \nprivate:\n    //vからtへの増加パスをdfsで探す\n    //fは流量の上界のうち現時点で判明している最小のもの\n    long long dfs_Ford_Fulkerson(int v,int t,long long f,bool* used){\n        //始点と終点が一致していれば無限に流せる\n        if(v==t)return f;\n        used[v]=true;\n        //vから出る各辺eに対して、\n        for(auto itr=adj[v].begin();itr!=adj[v].end();itr++){\n            edge e=*itr;\n            //e.toにまだ訪問したことがなく、さらに流せるとき\n            if(!used[e.to]&&e.weight>0){\n                //e.toから終点tまで流せる量を取得する\n                //流量の上界は、eで流せる量でも上から抑えられる\n                long long d = dfs_Ford_Fulkerson(e.to, t, std::min(f,e.weight), used);\n                //もし流せるなら\n                if(d>0){\n                    //dだけ逆流させればvからtにもd流せる\n                    itr->weight-=d;\n                    adj[e.to][e.from].weight+=d;\n                    return d;\n                }\n            }\n        }\n        //どこも訪問済みか流せる量がないときは0\n        return 0;\n    }\npublic:\n    //最大流 O(E*(最大流の流量))\n    long long maxFlow_Ford_Fulkerson(int s,int t){\n        bool *used=new bool[numVertex];\n        long long flow=0;\n        while(true){\n            for(int i=0;i<numVertex;i++)used[i]=false;\n            long long f=dfs_Ford_Fulkerson(s,t,infty,used);\n            if(f==0)return flow;\n            flow+=f;\n        }\n    }\n\nprivate:\n    //vからtへの増加パスをdfsで探す\n    //Ford-Fulkerson法で用いたdfsから改良\n    long long dfs_Dinic(int v,int t,long long f,int *level,int *iter){\n        if(v==t)return f;\n        //途中まで調べている場合はそこからiterationする\n        for(int &i=iter[v];i<(int)adj[v].size();i++){\n            edge &e=adj[v][i];\n            //最短パス長の長くなる方向にある辺だけ調べる\n            if(e.weight>0 && level[v]<level[e.to]){\n                long long d=dfs_Dinic(e.to,t,std::min(f,e.weight),level,iter);\n                if(d>0){\n                    e.weight-=d;\n                    adj[e.to][e.from].weight+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\npublic:\n    //最大流O(EV^2)\n    long long maxFlow_Dinic(int s,int t){\n        int *level=new int[numVertex];\n        int *iter=new int[numVertex];\n        long long flow=0;\n        while(true){\n            shortestPath_bfs(level,s);\n            if(level[t]<0)return flow;\n            for(int i=0;i<numVertex;i++)iter[i]=0;\n            long long f;\n            while((f=dfs_Dinic(s,t,infty,level,iter))>0)flow+=f;\n        }\n    }\n    //----debug----\n\n    void debugPrint(){\n        printf(\"numEdge: %d\\n\",numEdge);\n        printf(\"numVertex: %d\\n\",numVertex);\n        printf(\"isConnected: %s\\n\",isConnected()?\"True\":\"False\");\n        printf(\"isTree: %s\\n\",isTree()?\"True\":\"False\");\n        printf(\"EdgeList:\\n\");\n        for(int i=0;i<numVertex;i++){\n            printf(\"%6d: \",i);\n            for(auto itr=adj[i].begin();itr!=adj[i].end();itr++){\n                printf(\"(%d->%d:%lld)\",i,(*itr).to,(*itr).weight);\n            }\n            printf(\"\\n\");\n        }\n    }\n};\n\nint main(){\n    int x,y,e;\n    scanf(\"%d%d%d\",&x,&y,&e);\n    Graph g(x+y+2);\n    for(int i=0;i<x;i++)g.addNetwork(x+y,i);\n    for(int i=0;i<e;i++){\n        int xi,yi;\n        scanf(\"%d%d\",&xi,&yi);\n        g.addNetwork(xi,x+yi);\n    }\n    for(int i=0;i<y;i++)g.addNetwork(x+i,x+y+1);\n    printf(\"%lld\\n\",g.maxFlow_Dinic(x+y,x+y+1));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Hopcroft-Karp's maximum cardinality bipartite matching\n//\n// Description:\n//   Compute the maximum cardinality matching for bipartite graph.\n//\n// Algorithm:\n//   The algorithm iterates following procedures:\n//     (1) BFS from the source to get the distance to the sink.\n//         If not reachable, there are no augment path hence break.\n//     (2) Find vertex disjoint shortest augment paths by DFS.\n//   It can be shown that the outer-loop is atmost O(\\sqrt{n}) times\n//   therefore the whole complexity is O(m \\sqrt{n}).\n//   Note that this is a specialzation of Dinic's maximum flow.\n//\n//\n// Complexity:\n//   O(m \\sqrt{n}) time\n//\n// Verified:\n//   SPOJ 4206: Fast Maximum Matching\n//\n// References:\n//   J. E. Hopcroft and R. M. Karp (1973):\n//   An n^5/2 algorithm for maximum matchings in bipartite graphs.\n//   SIAM Journal on Computing, vol.2, no.4, pp.225-231.\n//\n\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\nstruct graph {\n  int L, R;\n  vector<vector<int>> adj;\n  graph(int L, int R) : L(L), R(R), adj(L+R) { }\n  void add_edge(int u, int v) {\n    adj[u].push_back(v+L);\n    adj[v+L].push_back(u);\n  }\n  int maximum_matching() {\n    vector<int> level(L), mate(L+R, -1);\n\n    function<bool(void)> levelize = [&]() { // BFS\n      queue<int> Q;\n      for (int u = 0; u < L; ++u) {\n        level[u] = -1;\n        if (mate[u] < 0) {\n          level[u] = 0;\n          Q.push(u); \n        }\n      }\n      while (!Q.empty()) {\n        int u = Q.front(); Q.pop();\n        for (int w: adj[u]) {\n          int v = mate[w];\n          if (v < 0) return true;\n          if (level[v] < 0) {\n            level[v] = level[u] + 1;\n            Q.push(v); \n          }\n        }\n      }\n      return false;\n    };\n    function<bool(int)> augment = [&](int u) { // DFS\n      for (int w: adj[u]) {\n        int v = mate[w];\n        if (v < 0 || (level[v] > level[u] && augment(v))) {\n          mate[u] = w;\n          mate[w] = u;\n          return true;\n        }\n      }\n      return false;\n    };\n    int match = 0;\n    while (levelize()) \n      for (int u = 0; u < L; ++u) \n        if (mate[u] < 0 && augment(u)) \n          ++match;\n    return match;\n  }\n};\n\nint main() {\n  int L, R, m; \n  scanf(\"%d %d %d\", &L, &R, &m);\n  graph g(L, R);\n  for (int i = 0; i < m; ++i) {\n    int u, v;\n    scanf(\"%d %d\", &u, &v);\n    g.add_edge(u, v);\n  }\n  printf(\"%d\\n\", g.maximum_matching());\n}"
  },
  {
    "language": "C++",
    "code": "// ########################################################\n// ################ MaxBipartiteMatching ##################\n// Hopcroft ( E * sqrt(V) )\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN1 = 50000;\nconst int MAXN2 = 50000;\nconst int MAXM = 150000;\n\nint n1, n2, edges, last[MAXN1], prev[MAXM], head[MAXM],E;\nint matching[MAXN2], dist[MAXN1], Q[MAXN1];\nbool used[MAXN1], vis[MAXN1];\n\nvoid init(int _n1, int _n2) {\n  n1 = _n1;\n  n2 = _n2;\n  edges = 0;\n  fill(last, last + n1, -1);\n}\n\nvoid addEdge(int u, int v) {\n  head[edges] = v;\n  prev[edges] = last[u];\n  last[u] = edges++;\n}\n\nvoid bfs() {\n  fill(dist, dist + n1, -1);\n  int sizeQ = 0;\n  for (int u = 0; u < n1; ++u) {\n    if (!used[u]) {\n      Q[sizeQ++] = u;\n      dist[u] = 0;\n    }\n  }\n  for (int i = 0; i < sizeQ; i++) {\n    int u1 = Q[i];\n    for (int e = last[u1]; e >= 0; e = prev[e]) {\n      int u2 = matching[head[e]];\n      if (u2 >= 0 && dist[u2] < 0) {\n\tdist[u2] = dist[u1] + 1;\n\tQ[sizeQ++] = u2;\n      }\n    }\n  }\n}\n\nbool dfs(int u1) {\n  vis[u1] = true;\n  for (int e = last[u1]; e >= 0; e = prev[e]) {\n    int v = head[e];\n    int u2 = matching[v];\n    if (u2 < 0 || !vis[u2] && dist[u2] == dist[u1] + 1 && dfs(u2)) {\n      matching[v] = u1;\n      used[u1] = true;\n      return true;\n    }\n  }\n  return false;\n}\n\nint maxMatching() {\n  fill(used, used + n1, false);\n  fill(matching, matching + n2, -1);\n  for (int res = 0;;) {\n    bfs();\n    fill(vis, vis + n1, false);\n    int f = 0;\n    for (int u = 0; u < n1; ++u)\n      if (!used[u] && dfs(u))\n\t++f;\n    if (!f)\n      return res;\n    res += f;\n  }\n}\n\nint main()\n{\n  cin>>n1>>n2>>E;\n  memset(last,-1,sizeof last);\n  while(E--)\n    {\n      int u,v;\n      cin>>u>>v;//0-based\n      addEdge(u,v);\n    }\n  cout <<maxMatching()<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nconst int INF = 1e9;\nconst int MAX_V = 300;\n\nint X, Y;\nstruct Flow{\n    struct edge{\n        int to, cap, rev;\n    };\n    vector<edge> G[MAX_V];//??£??\\?????????\n    bool used[MAX_V];\n\n    void add_edge(int from, int to, int cap){\n        G[from].push_back((edge){to, cap, (int)G[to].size()});//from -> to\n        G[to].push_back((edge){from, 0, (int)G[from].size() - 1});//to -> from\n    }\n\n    //?¢???????????????¢???\n    int dfs(int v, int t, int f){\n        if(v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); ++i){\n            edge &e = G[v][i];\n            if(!used[e.to] && e.cap > 0){\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    //s??????t???????????§???\n    int max_flow(int s, int t){\n        int flow = 0;\n        while(1){\n            memset(used, 0, sizeof(used));\n            int f = dfs(s, t, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nint main(void){\n\tint e; cin >> X >> Y >> e;\n\tint s = X + Y;\n\tint t = X + Y + 1;\n\tFlow mf;\n\t//s -> x\n\trep(i, X){\n\t\tmf.add_edge(s, i, 1);\n\t}\n\t// y -> t\n\trep(i, Y){\n\t\tmf.add_edge(X + i, t, 1);\n\t}\n\t// x -> y\n\trep(i, e){\n\t\tint tx, ty; cin >> tx >> ty;\n\t\tmf.add_edge(tx, X + ty, 1);\n\t}\n\n\tprintf(\"%d\\n\", mf.max_flow(s, t));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 5000000000000000000\n#define ll long long\n#define pll pair<ll, ll>\nusing namespace std;\n\n\n//=============ford_fulkerson============================\nll MAX_V = 202;\nstruct edge {ll to, cap, rev;};\nvector<vector<edge>> G(MAX_V);\nvector<bool> used(MAX_V, false);\n\nvoid add_edge(ll from, ll to, ll cap) {\n  G.at(from).push_back((edge){to, cap, (ll)G.at(to).size()});\n  G.at(to).push_back((edge){from, 0ll, (ll)G.at(from).size() - 1});\n}\n\nll dfs(ll v, ll t, ll f) {\n  if (v == t) {\n    return f;\n  }\n  used.at(v) = true;\n  for (ll i = 0; i < G.at(v).size(); ++i) {\n    edge &e = G.at(v).at(i);\n    if (!used.at(e.to) && e.cap > 0) {\n      ll d = dfs(e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        G.at(e.to).at(e.rev).cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nll max_flow(ll s, ll t) {\n  ll flow = 0;\n  while (true) {\n    used = vector<bool>(MAX_V, false);\n    ll f = dfs(s, t, INF);\n    if (f == 0) {\n      return flow;\n    }\n    flow += f;\n  }\n}\n//=================================================\n\nint main() {\n  ll X, Y, E;\n  cin >> X >> Y >> E;\n  for (ll i = 1; i <= X; ++i) {\n    add_edge(0, i, 1);\n  }\n  for (ll i = 1; i <= Y; ++i) {\n    add_edge(i + 100, 201, 1);\n  }\n  for (ll i = 0; i < E; ++i) {\n    ll x, y;\n    cin >> x >> y;\n    x += 1;\n    y += 1;\n    add_edge(x, y + 100, 1);\n  }\n  cout << max_flow(0, 201) << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#if __has_include(\"print.hpp\")\n  #include \"print.hpp\"\n#endif\n\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MOD 1000000007\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntypedef long long ll;\ntypedef pair<ll, ll> p;\n\nstruct BipartiteMatching {\n  vector< vector< int > > graph;\n  vector< int > match, used;\n  int timestamp;\n\n  BipartiteMatching(int n) : graph(n), used(n, 0), match(n, -1), timestamp(0) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int idx) {\n    used[idx] = timestamp;\n    for(auto &to : graph[idx]) {\n      int to_match = match[to];\n      // とりあえずつなげる\n      // つながりたいやつがもう繋がってたら，そいつが他のやつに繋がれないか探す\n      // つまり増加パスを探すとも言える\n      if(to_match == -1 || (used[to_match] != timestamp && dfs(to_match))) {\n        match[idx] = to;\n        match[to] = idx;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    for(int i = 0; i < int(graph.size()); i++) {\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < int(graph.size()); i++) {\n      if(i < match[i]) {\n        cout << i << \"-\" << match[i] << endl;\n      }\n    }\n  }\n};\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  // int n, m;\n  // cin >> n >> m;\n  // rep(i, n) rep(j, m){\n  //   string tmp;\n  //   cin >> tmp;\n  //   bool is_edge = tmp == \"o\";\n  //   if(is_edge) bm.add_edge(i, n+j);\n  // }\n  int x, y, m;\n  cin >> x >> y >> m;\n  BipartiteMatching bm(x+y);\n  rep(i, m){\n    int from, to;\n    cin >> from >> to;\n    to += x;\n    bm.add_edge(from, to);\n  }\n  int res = bm.bipartite_matching();\n  cout << res << endl;\n  // bm.output();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//二部マッチング\n//辺の構造体を持つ隣接リストで表現\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 1000000\n#define INF 1e9\n\n//辺を表す構造体　(行先、容量、逆辺の場所)\nstruct edge{\n    int to, cap, rev;\n};\n\nvector<vector<edge> > G(MAX_V);       //グラフの隣接リスト表現\nbool used[MAX_V];                    //DFSですでに調べたかのグラフ\n\n\n// from から to へ向かう容量 cap の辺をグラフに張る\nvoid add_edge(int from, int to, int cap){\n\n    edge F;\n    edge T;\n    F.to = to;\n    F.cap = cap;\n    F.rev = G[to].size();\n    G[from].push_back(F);\n\n    T.to = from;\n    T.cap = 0;\n    T.rev = G[from].size() - 1;\n    G[to].push_back(T);    \n}\n\n//増加パスをDFSで探す\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        edge &e = G[v][i];                          //すごい\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;            //もっとすごい\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n//s から t への最大流を求める\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(){\n\n    //入力\n    //xはuに属する\n    //yはvに属する\n    int u, v, e; cin >> u >> v >> e;               //uの頂点数　v超点数　辺数\n    \n    for(int i = 0; i < e; i++){\n        int x, y; cin >> x >> y;\n        x++;\n        y++;\n        y += u;\n        add_edge(x, y, 1);\n    }\n\n    for(int i = 1; i <= u; i++) add_edge(0, i, 1);\n    for(int i = u + 1; i <= u + v; i++) add_edge(i, u + v + 1, 1);\n    \n    cout << max_flow(0, u + v + 1) << endl;\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/* C++ */\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> pint;\nconst int MAX = 510000;\nconst int MOD = 1000000007;\n#define rep(i, n) for(ll i = ll(0); i < ll(n); i++)\n#define Rep(i, n) for(ll i = ll(1); i < ll(n); i++)\n#define ALL(a)  (a).begin(),(a).end()\n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define PI 3.14159265358979323846\n#define ifYN(x) cout<<(x?\"Yes\":\"No\")<<\"\\n\" \nll fac[MAX], finv[MAX], inv[MAX];\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nbool palindrome(string s){\n  bool flag=true;\n  rep(i,(ll)s.size()) if(s[i]!=s[s.size()-1-i]) flag=false;\n  return flag;\n}\n\n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (ll i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n\n}\nll Len(ll n) {\n  ll s=0;\n  while(n!=0) s++, n/=10;\n  return s;\n}\n\n\nll Sint(ll n) {\n  ll ans=0;\n  while(n!=0) ans+=n%10,n/=10;\n  return ans;\n}\n\nll Svec(vector<ll> v){\n  ll n=0;\n  rep(i,(ll)v.size()) n+=v[i];\n  return n;\n}\n\n\nll GCD(ll a,ll b) {\n  return b ? GCD(b,a%b) : a;\n}\n\n\nll LCM(ll a,ll b){\n  return a/GCD(a,b)*b;\n}\n\n\nll Factorial(ll n){\n  ll m=1;\n  while(n>=1) m*=n,n--;\n  return m;\n}\n\nvoid runlength(string s,vector<pair<char,ll>> &p){\n  ll x=1;\n  if(s.size()==1){\n    p.push_back(pair<char,ll>(s[0],1));\n  }\n  rep(i,(ll)s.size()-1){\n    if(s[i]==s[i+1]){\n      x++;\n      if(i==(ll)s.size()-2){\n        p.push_back(pair<char,ll>(s[i],x));\n      }\n    }else{\n      p.push_back(pair<char,ll>(s[i],x));\n      x=1;\n      if(i==(ll)s.size()-2){\n        p.push_back(pair<char,ll>(s[s.size()-1],x));\n      }\n    }\n  }\n}\n\nll COM(ll n,ll k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll modpow(ll a, ll n, ll mod) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a % mod;\n        a = a * a % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\nstring Toupper(string s){\n  string ans=\"\";\n  rep(i,s.size()){\n    if('a'<=s[i] && s[i]<='z') ans+=(char)s[i]-32;\n    else ans+=s[i];\n  }\n  return ans;\n}\nstring Tolower(string s){\n  string ans=\"\";\n  rep(i,s.size()){\n    if('A'<=s[i] && s[i]<='Z') ans+=(char)s[i]+32;\n    else ans+=s[i];\n  }\n  return ans;\n}\n\nvoid dis(vector<ll> v){ rep(i,v.size()) cout<<v[i]<<endl; }\n\nvoid dis2(vector<vector<ll>> v){\n  rep(i,v.size()){\n    rep(j,v[0].size()) cout<<v[i][j]<<' ';\n    cout<<endl;\n  }\n}\n\nconst int MAX_N=100010;\nvector<bool> sieve_of_eratosthenes(){\n  vector<bool> isPrime(MAX_N+1,true);\n  /* isPrime[1]=false; */\n  for(int i=2;i<=MAX_N;i++){\n    if(isPrime[i]){\n      for(int j=2*i;j<=MAX_N;j+=i){\n        isPrime[j]=false;\n      }\n    }\n  }\n  return isPrime;\n}\n\nvector<pint> prime_factorize(ll n){\n  vector<pint> ans;\n  for(ll p=2;p<=sqrt(n);p++){\n    if(n%p!=0) continue;\n    ll cnt=0;\n    while(n%p==0){\n      n/=p;\n      cnt++;\n    }\n    ans.push_back(make_pair(p,cnt));\n  }\n  if(n!=1) ans.push_back(make_pair(n,1));\n  return ans;\n}\n\n/*bool cmp(pint a, pint b) { return a.second < b.second; }*/\n\n/* 最大流 */\nll INF=1e16;\nconst ll MAX_V=210; //const必須\nstruct edge{ll to,cost,pre;};\nvector<edge> graph[MAX_V];\nvector<bool> reached(MAX_V,false);\n\nvoid add_edge(ll a,ll b,ll c){\n  graph[a].push_back(edge{b,c,(ll)graph[b].size()});\n  graph[b].push_back(edge{a,0,(ll)graph[a].size()-1});\n}\n\nll dfs(ll s,ll t,ll ans){ //sからtまでを再帰的に探索\n  if(s==t) return ans;\n  reached[s]=true;\n  rep(i,graph[s].size()){\n    if(reached[graph[s][i].to]) continue;\n    if(graph[s][i].cost<=0) continue;\n    chmin(ans,graph[s][i].cost);\n    ll tmp=dfs(graph[s][i].to,t,ans);\n    if(tmp>0){\n      graph[s][i].cost-=tmp;\n      graph[graph[s][i].to][graph[s][i].pre].cost+=tmp;\n      return tmp;\n    }\n  }\n  return 0;\n}\n\nll max_flow(ll n){\n  ll ans=0;\n  while(1){\n    rep(i,MAX_V) reached[i]=false;\n    ll tmp=dfs(0,n-1,INF);\n    if(tmp==0) break;\n    ans+=tmp;\n  }\n  return ans;\n}\n\n\n/*↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓*/\nint main() {\n  IOS;\n  ll x,y,e;\n  cin>>x>>y>>e;\n  rep(i,e){\n    ll a,b;cin>>a>>b;\n    add_edge(a+1,b+x+1,1);\n  }\n  rep(i,x) add_edge(0,i+1,1);\n  rep(i,y) add_edge(i+x+1,x+y+1,1);\n  cout<<max_flow(x+y+2)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint biMatch(const vector<vector<int>>& adj, int ln) {\n    int n = adj.size();\n    vector<int> matchTo(n, -1);\n    vector<bool> used(n, false);\n    function<bool(int)> dfs = [&](int v) {\n        for(int nv : adj[v]) if(!used[nv]) {\n            used[nv] = true;\n            if(matchTo[nv] < 0 || dfs(nv)) {\n                matchTo[v] = nv;\n                matchTo[nv] = v;\n                return true;\n            }\n        }\n        return false;\n    };\n    int ans = 0;\n    for(int v : in(ln)) if(matchTo[v] < 0) {\n        used.assign(n, false);\n        if(dfs(v)) ++ans;\n    }\n    return ans;\n}\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int l, r, m;\n    cin >> l >> r >> m;\n    vector<vector<int>> adj(l + r);\n    for(int _ : in(m)) {\n        int u, v;\n        cin >> u >> v;\n        v += l;\n        adj[u].emplace_back(v);\n        adj[v].emplace_back(u);\n    }\n    cout << biMatch(adj, l) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\nstatic const int MAX_V = 100;\nstatic const int MAX_K = 1000;\n\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i = 0; i < G[v].size(); i++){\n    int u = G[v][i], w = match[u];\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  for(int v = 0; v < V; v++){\n    if(match[v] < 0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int X, Y, E;\n  scanf(\"%d %d %d\", &X, &Y, &E);\n  V = X + Y;\n  int u, v;\n  for(int i = 0; i < E; i++){\n    scanf(\"%d %d\", &u, &v);\n    add_edge(u, v + X);\n  }\n  printf(\"%d\\n\", bipartite_matching());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\n#include <cstring>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for(int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define Cout(obj) cout << obj << endl\n#define Size(obj) (int)(obj).size()\n#define fcout cout << fixed << setprecision(10)\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nconst int MaxV = 10000;\nint V;\nvector<int> graph[MaxV];\nint match[MaxV];\nbool used[MaxV];\n\nvoid addEdge(int u, int v)\n{\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n}\n\nbool dfs(int v)\n{\n    used[v] = true;\n    \n    for(auto e : graph[v])\n    {\n        int u = e, w = match[u];\n\n        if(w < 0 || !used[w] && dfs(w))\n        {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint bipartiteMatcing()\n{\n    int res = 0;\n\n    memset(match, -1, sizeof(match));\n\n    REP(v, V)\n    {\n        if(match[v] < 0)\n        {\n            memset(used, 0, sizeof(used));\n\n            if(dfs(v))\n            {\n                res++;\n            }\n        }\n    }\n\n    return res;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    \n    V = X + Y;\n\n    REP(i, E)\n    {\n        int x, y;\n        cin >> x >> y;\n\n        addEdge(x, y + X);\n    }\n\n    Cout(bipartiteMatcing());\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct BipartiteMatching {\n  vector< vector<int> > graph;\n  vector<int> matched;\n  vector<bool> used;\n  BipartiteMatching(int V):graph(V), matched(V, -1), used(V, false){}\n  void add_edge(int u, int v) {\n    graph[u].emplace_back(v);\n    graph[v].emplace_back(u);\n  }\n  bool dfs(int u) {\n    used[u] = true;\n    for(auto& v : graph[u]) {\n      int w = matched[v];\n      if(w < 0 || (!used[w] && dfs(w))) {\n        matched[u] = v;\n        matched[v] = u;\n        return true;\n      }\n    }\n    return false;\n  }\n  int match() {\n    int res = 0;\n    for(int u = 0; u < (int)graph.size(); u++) {\n      if(matched[u] < 0) {\n        used.clear(); used.resize(graph.size(), false);\n        if(dfs(u)) res++;\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n    int x,y,m;\n    cin>>x>>y>>m;\n    BipartiteMatching BP(x+y);\n    while(m--){\n        int a,b;\n        cin>>a>>b;\n        BP.add_edge(a,b+x);\n    }\n    cout<<BP.match()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint biMatch(const vector<vector<int>>& adj, int ln) {\n    int n = adj.size();\n    vector<int> matchTo(n, -1);\n    vector<bool> used(n, false);\n    function<bool(int)> dfs = [&](int v) {\n        used[v] = true;\n        for(int nv : adj[v]) {\n            if(matchTo[nv] < 0 || (!used[nv] && dfs(nv))) {\n                matchTo[v] = nv;\n                matchTo[nv] = v;\n                return true;\n            }\n        }\n        return false;\n    };\n    int ans = 0;\n    for(int v : in(ln)) if(matchTo[v] < 0) {\n        used.assign(n, false);\n        if(dfs(v)) ++ans;\n    }\n    return ans;\n}\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int l, r, m;\n    cin >> l >> r >> m;\n    vector<vector<int>> adj(l + r);\n    for(int _ : in(m)) {\n        int u, v;\n        cin >> u >> v;\n        v += l;\n        adj[u].emplace_back(v);\n        adj[v].emplace_back(u);\n    }\n    cout << biMatch(adj, l) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int INF = (int)1e9;\n\nstruct Edge {\n  int to, cap, rev;\n  Edge(int to_, int cap_, int rev_) :\n    to(to_), cap(cap_), rev(rev_) { }\n};\n\nstruct FordFulkerson {\n  const int V;\n  vector<vector<Edge> > G;\n  vector<bool> used;\n  FordFulkerson(int v) : V(v), G(v), used(v) { }\n  void add_edge(int from, int to, int cap) {\n    G[from].emplace_back(to, cap, G[to].size());\n    G[to].emplace_back(from, 0, G[from].size() - 1);\n  }\n  int find_flow(int v, int t, int f) {\n    if(v == t) return f;\n    used[v] = true;\n    for(Edge &e : G[v]) {\n      if(used[e.to] == false && e.cap > 0) {\n        int d = find_flow(e.to, t, min(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t) {\n    int flow = 0;\n    while(true) {\n      used.assign(V, false);\n      int f = find_flow(s, t, INF);\n      if(f == 0) return flow;\n      flow += f;\n    }\n  }\n};\n\nint main() {\n  int X, Y, E; cin >> X >> Y >> E;\n  FordFulkerson flow(X + Y + 2);\n  int src = X + Y;\n  int dst = X + Y + 1;\n  for(int i = 0; i < X; i++) {\n    flow.add_edge(src, i, 1);\n  }\n  for(int i = 0; i < Y; i++) {\n    flow.add_edge(X + i, dst, 1);\n  }\n  while(E--) {\n    int x, y; cin >> x >> y;\n    flow.add_edge(x, X + y, 1);\n  }\n  cout << flow.max_flow(src, dst) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <set>\n#include <bitset>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int> >vpi;\ntypedef pair<int,int> pi;\n#define R return\n#define W while\n#define FOR(i,a) for(int i=0;i<a;i++)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define I insert\n#define P push\npair<vi,vi>v[510];\npair<bitset<510>,bitset<510> >b,m;\nint dfs(int now,bool f){\n    int temp=0;\n    if(f){\n        if(b.F[now])R 0;\n        b.F[now]=true;\n        f=false;\n        FOR(i,v[now].F.size())if(!b.S[v[now].F[i]]){\n            temp+=dfs(v[now].F[i],false);\n            f|=!m.S[v[now].F[i]];\n        }\n        if(f){\n            temp++;\n            m.F[now]=true;\n        }\n    }\n    else{\n        if(b.S[now])R 0;\n        b.S[now]=true;\n        FOR(i,v[now].S.size())if(!b.F[v[now].S[i]]){\n            temp+=dfs(v[now].S[i],true);\n            f|=!m.F[v[now].S[i]];\n        }\n        if(f){\n            temp++;\n            m.S[now]=true;\n        }\n    }\n    R temp;\n}\nint main(){\n    int n,x,y,k,l,r,ans=0;\n    set<pi>s;\n    b.F.reset();\n    b.S.reset();\n    m.F.reset();\n    m.S.reset();\n    scanf(\"%d%d%d\",&x,&y,&k);\nn=max(x,y);\n    n++;\n    W(k--){\n        scanf(\"%d%d\",&l,&r);\n        if(s.count(MP(l,r)))continue;\n        s.I(MP(l,r));\n        v[l].F.PB(r);\n        v[r].S.PB(l);\n    }\n    FOR(i,n)ans+=dfs(i,true);\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=155;\nconst int INF=2e9;\nint n,cost[M][M],from[M],lx[M],ly[M],slack[M],vx[M],vy[M];\nint path(int v){\n  int t;\n  vx[v]=1;\n  for(int i=1;i<=n;i++)\n    {\n      if(vy[i])continue;\n      t=lx[v]+ly[i]-cost[v][i];\n      if(t==0)\n\t{\n\t  vy[i]=1;\n\t  if(from[i]==0||path(from[i]))\n\t    {\n\t      from[i]=v;\n\t      return 1;\n            }\n        }\n      else if(t<slack[i])\n\tslack[i]=t;\n    }\n  return 0;\n}\nint hung()\n{\n  int d,ans=0;\n  for(int i=1;i<=n;i++)\n    while(true)\n      {\n\tmemset(vx,0,sizeof(vx));\n\tmemset(vy,0,sizeof(vy));\n\tfor(int j=1;j<=n;j++)\n\t  slack[j]=INF;\n\tif(path(i)) break;\n\td=INF;\n\tfor(int j=1;j<=n;j++)\n\t  if(!vy[j] && slack[j]<d)\n\t    d=slack[j];\n\tfor(int j=1;j<=n;j++)\n\t  {\n\t    if(vx[j])lx[j]-=d;\n\t    if(vy[j])ly[j]+=d;\n\t  }\n      }\n  for(int i=1;i<=n;i++)\n    ans+=cost[from[i]][i];//the from meaning...\n  return ans;\n}\nint main()\n{\n  int y,e;\n  cin>>n>>y>>e;\n  while(e--)\n    {\n      int u,v;cin>>u>>v;u++;v++;\n      cost[u][v]=1;\n      if(cost[u][v]>lx[u])\n\tlx[u]=cost[u][v];\n    }\n  n=max(n,y);\n  cout<<hung()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <map> \n#include <set>\n#include <string>\n#include <functional>\n#include <list>\n#include <random>\n#include <time.h>\n#include <iomanip>\n#include <assert.h>\n#include <numeric>\n#include <sstream>\n#define BIT(nr) (1UL << (nr))\n#define int long long\n//#define ll long long\n#define double long double\n#define mod 1000000007\n#define MAXN (int)1e+5 * 2+1\n#define LL_MAX 9223372036854775807\t//ない環境用\n#define LL_HALFMAX 9223372036854775807 / 2\t//ない環境用\n#define MIN -(9223372036854775807 / 2)\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define FOR(it,c) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define ALLOF(c) (c).begin(), (c).end()\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define mp make_pair\ntemplate<typename T1, typename T2> inline void chmin(T1 & a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\n\n\nusing namespace std;\n\n//デバッグ用カッコの有無\n#ifdef DEBUG\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&v)\n{\n\to << \"{\"; for (int i = 0; i<(int)v.size(); i++)o << (i>0 ? \", \" : \"\") << v[i]; o << \"}\"; return o;\n}\n#endif // DEBUG\n\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&v)\n{\n\tfor (int i = 0; i<(int)v.size(); i++)o << (i>0 ? \" \" : \"\") << v[i]; return o;\n}\n\nint dx[4] = { 0, 1, 0, -1 }; // x軸方向への変位\nint dy[4] = { 1, 0, -1, 0 }; // y軸方向への変位\n\nint dxp[4] = { 0, 1 }; // x軸方向への変位(正のみ)\nint dyp[4] = { 1, 0 }; // y軸方向への変位(負のみ)\n\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint src, dst;\n\n\t// libalgo のものに追加、メンバを追加するだけなので互換性は崩さないはず、逆辺のG[e.dstの]インデックスを保持\n\tint rev;\n\tWeight weight;\n\tFlow cap;\n\tEdge() : src(0), dst(0), weight(0) {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph& g, int a, int b, Weight w = 1) {\n\tg[a].emplace_back(a, b, w);\n\tg[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph& g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\n\n// グリッドからグラフを構築\n// @pre: gはノード数H*Wのグラフ\nvoid create_from_grid(Graph& g, int h, int w, vector<string>& mapData, char wall) {\n\t//グラフ構築 O(HW)\n\trep(y, h) {\n\t\trep(x, w) {\n\t\t\tif (mapData[y][x] == wall) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint id = y * w + x;\n\t\t\t//右と下(変位が正)のみ見る(辺の重複を回避するため)\n\t\t\trep(i, 2) {\n\t\t\t\tint nx = x + dxp[i];\n\t\t\t\tint ny = y + dyp[i];\n\t\t\t\tint nid = ny * w + nx;\n\t\t\t\tif (nx < 0 || nx >= w) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (ny < 0 || ny >= h) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (mapData[ny][nx] != wall) {\n\t\t\t\t\tadd_edge(g, id, nid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// グリッドにおいて座標をグラフのノード番号に変換する\nint point_to_node_num(int x, int y, int W) {\n\treturn y * W + x;\n}\n\nstruct uf_tree {\n\tstd::vector<int> parent;\n\tint __size;\n\tuf_tree(int size_) : parent(size_, -1), __size(size_) {}\n\tvoid unite(int x, int y) {\n\t\tif ((x = find(x)) != (y = find(y))) {\n\t\t\tif (parent[y] < parent[x]) std::swap(x, y);\n\t\t\tparent[x] += parent[y];\n\t\t\tparent[y] = x;\n\t\t\t__size--;\n\t\t}\n\t}\n\tbool is_same(int x, int y) { return find(x) == find(y); }\n\tint find(int x) { return parent[x] < 0 ? x : parent[x] = find(parent[x]); }\n\tint size(int x) { return -parent[find(x)]; }\n\tint size() { return __size; }\n};\n\n\n\n//!!!問題をちゃんと読む!!!\n//!!!問題をちゃんと読め!!!\n//!!!問題は読みましたか？!!!\n\ntemplate <signed M, unsigned T>\nstruct mod_int {\n\tconstexpr static signed MODULO = M;\n\tconstexpr static unsigned TABLE_SIZE = T;\n\n\tsigned x;\n\n\tmod_int() : x(0) {}\n\n\tmod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n\tmod_int(signed y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n\tmod_int& operator+=(const mod_int& rhs) {\n\t\tif ((x += rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int& operator-=(const mod_int& rhs) {\n\t\tif ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n\t\treturn *this;\n\t}\n\n\tmod_int& operator*=(const mod_int& rhs) {\n\t\tx = static_cast<signed>(1LL * x * rhs.x % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int& operator/=(const mod_int& rhs) {\n\t\tx = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n\t\treturn *this;\n\t}\n\n\tmod_int operator-() const { return mod_int(-x); }\n\n\tmod_int operator+(const mod_int& rhs) const { return mod_int(*this) += rhs; }\n\n\tmod_int operator-(const mod_int& rhs) const { return mod_int(*this) -= rhs; }\n\n\tmod_int operator*(const mod_int& rhs) const { return mod_int(*this) *= rhs; }\n\n\tmod_int operator/(const mod_int& rhs) const { return mod_int(*this) /= rhs; }\n\n\tbool operator<(const mod_int& rhs) const { return x < rhs.x; }\n\n\tmod_int inv() const {\n\t\tassert(x != 0);\n\t\tif (x <= static_cast<signed>(TABLE_SIZE)) {\n\t\t\tif (_inv[1].x == 0) prepare();\n\t\t\treturn _inv[x];\n\t\t}\n\t\telse {\n\t\t\tsigned a = x, b = MODULO, u = 1, v = 0, t;\n\t\t\twhile (b) {\n\t\t\t\tt = a / b;\n\t\t\t\ta -= t * b;\n\t\t\t\tstd::swap(a, b);\n\t\t\t\tu -= t * v;\n\t\t\t\tstd::swap(u, v);\n\t\t\t}\n\t\t\treturn mod_int(u);\n\t\t}\n\t}\n\n\tmod_int pow(long long t) const {\n\t\tassert(!(x == 0 && t == 0));\n\t\tmod_int e = *this, res = mod_int(1);\n\t\tfor (; t; e *= e, t >>= 1)\n\t\t\tif (t & 1) res *= e;\n\t\treturn res;\n\t}\n\n\tmod_int fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _fact[x];\n\t}\n\n\tmod_int inv_fact() {\n\t\tif (_fact[0].x == 0) prepare();\n\t\treturn _inv_fact[x];\n\t}\n\n\tmod_int choose(mod_int y) {\n\t\tassert(y.x <= x);\n\t\treturn this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n\t}\n\n\tstatic mod_int _inv[TABLE_SIZE + 1];\n\n\tstatic mod_int _fact[TABLE_SIZE + 1];\n\n\tstatic mod_int _inv_fact[TABLE_SIZE + 1];\n\n\tstatic void prepare() {\n\t\t_inv[1] = 1;\n\t\tfor (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n\t\t\t_inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n\t\t}\n\t\t_fact[0] = 1;\n\t\tfor (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n\t\t\t_fact[i] = _fact[i - 1] * signed(i);\n\t\t}\n\t\t_inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n\t\tfor (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n\t\t\t_inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n\t\t}\n\t}\n};\n\ntemplate <signed M, unsigned F>\nstd::ostream& operator<<(std::ostream& os, const mod_int<M, F>& rhs) {\n\treturn os << rhs.x;\n}\n\ntemplate <signed M, unsigned F>\nstd::istream& operator >> (std::istream& is, mod_int<M, F>& rhs) {\n\tlong long s;\n\tis >> s;\n\trhs = mod_int<M, F>(s);\n\treturn is;\n}\n\ntemplate <signed M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <signed M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <signed M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <signed M, unsigned F>\nbool operator==(const mod_int<M, F>& lhs, const mod_int<M, F>& rhs) {\n\treturn lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F>& lhs, const mod_int<M, F>& rhs) {\n\treturn !(lhs == rhs);\n}\n\nconst signed MF = 1000010;\nconst signed MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\n\n//出典 http://beet-aizu.hatenablog.com/entry/2017/12/01/225955\n/*\nコンストラクタ引数説明\nint n_\n要素数。\nf\n2つの要素Tをマージするための関数。\n区間MAX区間更新の時: max\n区間Sum区間Addの時: +\ng\n1つの要素Tに作用素Eを適用するための関数。\n区間MAX区間更新の時: =\n区間Sum区間Addの時: +\nh\n2つの作用素Eをマージするための関数。\n区間MAX区間更新の時: =\n区間Sum区間Addの時: +\nT d1\n演算fの単位元。\n区間MAX区間更新の時: -INF　\n区間Sum区間Addの時: 0\nE d0,\ng, hの単位元。\n区間MAX区間更新の時: 定義域外のどこか\n区間Sum区間Addの時: 0\nvector<T> v = vector<T>()\nセグ木を構成するときのvector\nP p = [](E a, int b) {return a; }\n区間の長さbを引数に取り、区間の長さによって変化する作用素E'を返す関数。\n例えば、区間MAX区間Addの時なんかは区間長によって足すべき数が変化するので必要\n区間Sum区間Addの時: *\n\n//具体例\n//区間chmin, 区間min\nauto myMin = [](int a, int b) {return min(a, b); };\nSegmentTree<int, int> seg(n, myMin, myMin, myMin, LL_HALFMAX, LL_HALFMAX);\n//区間update、区間min\nSegmentTree<int, int> seg(n, myMin, myMin, myMin, LL_HALFMAX, LL_HALFMAX);\n//区間Add、区間Sum\nvector<int> v(0, N + 1);\nSegmentTree<int, int> segtree(N + 1, plus<int>(), plus<int>(), plus<int>(), 0, 0, v, [](int a, int b) {return a * b; });\n//区間Add、区間Min\nvector<int> v(0, N + 1);\nSegmentTree<int, int> segtree(N + 1, myMin, plus<int>(), plus<int>(), LL_HALFMAX, 0, v, [](int a, int b) {return a; });\n*/\n\ntemplate <typename T, typename E>\nstruct SegmentTree {\n\ttypedef function<T(T, T)> F;\n\ttypedef function<T(T, E)> G;\n\ttypedef function<E(E, E)> H;\n\ttypedef function<E(E, int)> P;\n\tint n;\n\tF f;\n\tG g;\n\tH h;\n\tP p;\n\tT d1;\n\tE d0;\n\tvector<T> dat;\n\tvector<E> laz;\n\tSegmentTree(int n_, F f, G g, H h, T d1, E d0,\n\t\tvector<T> v = vector<T>(), P p = [](E a, int b) {return a; }) :\n\t\tf(f), g(g), h(h), d1(d1), d0(d0), p(p) {\n\t\tinit(n_);\n\t\tif (n_ == (int)v.size()) build(n_, v);\n\t}\n\t//初期化。要素配列と遅延配列を2*n-1個にする\n\tvoid init(int n_) {\n\t\tn = 1;\n\t\twhile (n < n_) n *= 2;\n\t\tdat.clear();\n\t\tdat.resize(2 * n - 1, d1);\n\t\tlaz.clear();\n\t\tlaz.resize(2 * n - 1, d0);\n\t}\n\t//既存のvectorからセグ木を構築\n\tvoid build(int n_, vector<T> v) {\n\t\tfor (int i = 0; i < n_; i++) dat[i + n - 1] = v[i];\n\t\tfor (int i = n - 2; i >= 0; i--)\n\t\t\tdat[i] = f(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t}\n\t//ノードを評価する。\n\tinline void eval(int len, int k) {\n\t\t//遅延配列に単位元が入ってたら評価済みなのでおしまい\n\t\tif (laz[k] == d0) return;\n\t\t//葉ノードでないなら遅延伝播する\n\t\tif (k * 2 + 1 < n * 2 - 1) {\n\t\t\t//h: 2つの作用素を引数に取り合成した作用素を返す関数\n\t\t\tlaz[k * 2 + 1] = h(laz[k * 2 + 1], laz[k]);\n\t\t\tlaz[k * 2 + 2] = h(laz[k * 2 + 2], laz[k]);\n\t\t}\n\t\t//p: このノードに対応する区間長と作用素を引数に取り、区間長に対応する作用素を返す関数\n\t\t//dat[k] にlaz に溜めていた作用素を適用(g: 要素型と作用素型を引数に取り、要素に作用素を作用させた結果を返す関数、ここでの作用素とは区間Sum区間Addなら (+ 3) とか)\n\t\tdat[k] = g(dat[k], p(laz[k], len));\n\t\t//適用し終わったので遅延配列をクリア\n\t\tlaz[k] = d0;\n\t}\n\t//[l,r)の区間を再帰的に見ながら0-indexedの[a, b)を更新する\n\tT update(int a, int b, E x, int k, int l, int r) {\n\t\t//先に評価\n\t\teval(r - l, k);\n\t\t//範囲外ならなにもしないでそのノードが持つ値を返す\n\t\tif (r <= a || b <= l) return dat[k];\n\t\t//完全被覆なら既に遅延配列に入っている作用素と追加したい作用素をマージした後にそれを要素に作用させた結果を返す、pは区間長に対応する作用素を得るための（ｒｙ\n\t\tif (a <= l && r <= b) {\n\t\t\tlaz[k] = h(laz[k], x);\n\t\t\treturn g(dat[k], p(laz[k], r - l));\n\t\t}\n\t\t//完全被覆でも範囲外でもないなら(中途半端にかぶっているなら)完全被覆と範囲外の境界が見えるまで木を潜って変化後の値を得る\n\t\treturn dat[k] = f(update(a, b, x, k * 2 + 1, l, (l + r) / 2),\n\t\t\tupdate(a, b, x, k * 2 + 2, (l + r) / 2, r));\n\t}\n\tT update(int a, int b, E x) {\n\t\treturn update(a, b, x, 0, 0, n);\n\t}\n\n\tT update(int a, E x) {\n\t\treturn update(a, a + 1, x);\n\t}\n\n\tT query(int a, int b, int k, int l, int r) {\n\t\teval(r - l, k);\n\t\t//範囲外なら単位元を返す\n\t\tif (r <= a || b <= l) return d1;\n\t\t//完全被覆ならそのまま返す\n\t\tif (a <= l && r <= b) return dat[k];\n\t\t//一部被覆なら完全被覆と範囲外に分かれるまで木を潜る\n\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn f(vl, vr);\n\t}\n\t//0-indexedで[a, b)の区間*を求める\n\tT query(int a, int b) {\n\t\treturn query(a, b, 0, 0, n);\n\t}\n\n\tT query(int a) {\n\t\treturn query(a, a + 1, 0, 0, n);\n\t}\n\n\tvoid debug_print(int num) {\n\t\tvector<T> v;\n\t\trep(i, num) {\n\t\t\tv.push_back(query(i));\n\t\t}\n\t\tcout << \"{\" << v << \"}\\n\";\n\t}\n};\n\n//座標圧縮\n\nclass compress {\npublic:\n\tmap<int, int> zip;\n\tvector<int> unzip;\n\n\tcompress(vector<int> x)\n\t{\n\t\tsort(x.begin(), x.end());\n\t\tx.erase(unique(x.begin(), x.end()), x.end());\n\t\tfor (int i = 0; i < x.size(); i++) {\n\t\t\tzip[x[i]] = i;\n\t\t\tunzip.push_back(i);\n\t\t}\n\t}\n};\n\n\nunsigned euclidean_gcd(unsigned a, unsigned b) {\n\twhile (1) {\n\t\tif (a < b) swap(a, b);\n\t\tif (!b) break;\n\t\ta %= b;\n\t}\n\treturn a;\n}\n\n//https://ei1333.github.io/luzhiled/snippets/dp/cumulative-sum-2d.html\ntemplate< class T >\nstruct CumulativeSum2D {\n\tvector< vector< T > > data;\n\n\tCumulativeSum2D(int W, int H) : data(W + 1, vector< int >(H + 1, 0)) {}\n\n\tvoid add(int x, int y, T z) {\n\t\t++x, ++y;\n\t\tif (x >= data.size() || y >= data[0].size()) return;\n\t\tdata[x][y] += z;\n\t}\n\n\tvoid build() {\n\t\tfor (int i = 1; i < data.size(); i++) {\n\t\t\tfor (int j = 1; j < data[i].size(); j++) {\n\t\t\t\tdata[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\n\tT query(int sx, int sy, int gx, int gy) {\n\t\treturn (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);\n\t}\n};\n\n//lib\nint nC2(int n) {\n\treturn n * (n - 1) / 2;\n}\n\nclass node {\npublic:\n\tint depth;\n\tint num;\n\n\tnode(int d, int n) {\n\t\tdepth = d;\n\t\tnum = n;\n\t}\n};\n\ntemplate< class T >\nstruct CumulativeSum {\n\tvector< T > data;\n\n\tCumulativeSum(int sz) : data(sz, 0) {};\n\n\tvoid add(int k, T x) {\n\t\tdata[k] += x;\n\t}\n\n\tvoid build() {\n\t\tfor (int i = 1; i < data.size(); i++) {\n\t\t\tdata[i] += data[i - 1];\n\t\t}\n\t}\n\n\tT query(int k) {\n\t\tif (k < 0) return (0);\n\t\treturn (data[min(k, (int)data.size() - 1)]);\n\t}\n\t//[left, right]の和\n\tT query(int left, int right) {\n\t\treturn query(right) - query(left - 1);\n\t}\n};\n\nstd::vector<int> eratosthenes_sieve(int n) {\n\tstd::vector<int> ps(n + 1);\n\tstd::iota(ps.begin() + 2, ps.end(), 2);\n\tfor (int i = 2; i * i <= n; ++i)\n\t\tif (ps[i])\n\t\t\tfor (int j = i * i; j <= n; j += i) ps[j] = 0;\n\treturn ps;\n}\n\nstd::vector<int> make_primes(int n) {\n\tstd::vector<int> ps = eratosthenes_sieve(n);\n\tps.erase(std::remove(ps.begin(), ps.end(), 0), ps.end());\n\treturn ps;\n}\n\n// 区間[a, b)の素数判定をする、is_prime[i]: a + i が素数 or not つまり is_prime[i-a] が true: iが素数\nstd::vector<bool> segment_eratosthenes_sieve(int a, int b) {\n\tvector<bool> is_prime(b - a, true);\n\tvector<bool> is_prime_small;\n\tfor (int i = 0; i*i < b; i++)is_prime_small.push_back(true);\n\n\tfor (int i = 2; i*i < b; i++) {\n\t\tif (is_prime_small[i]) {\n\t\t\tfor (int j = 2 * i; j*j < b; j += i) {\n\t\t\t\tis_prime_small[j] = false;\t// [2, sqrt(b))のふるい\n\t\t\t}\n\t\t\t// (a + i - 1LL) / i * i a以上の最小のiの倍数\n\t\t\tfor (int j = max(2LL, (a + i - 1LL) / i) * i; j < b; j += i) {\n\t\t\t\tis_prime[j - a] = false;\t// [a, b)のふるい\n\t\t\t}\n\t\t}\n\t}\n\treturn is_prime;\n}\n\nvector< int64_t > divisor(int64_t n) {\n\tvector< int64_t > ret;\n\tfor (int64_t i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(begin(ret), end(ret));\n\treturn (ret);\n}\n\n\n\n\n// 汎用的な二分探索のテンプレ(めぐる式)\nint binary_search(function<bool(int)> isOk, int ng, int ok) {\n\n\t/* ok と ng のどちらが大きいかわからないことを考慮 */\n\twhile (abs(ok - ng) > 1) {\n\t\tint mid = (ok + ng) / 2;\n\n\t\tif (isOk(mid)) ok = mid;\n\t\telse ng = mid;\n\t}\n\treturn ok;\n}\n\nstd::pair<std::vector<Weight>, bool> bellmanFord(const Graph& g, int s) {\n\tint n = g.size();\n\tconst Weight inf = std::numeric_limits<Weight>::max() / 8;\n\tEdges es;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (auto& e : g[i]) es.emplace_back(e);\n\n\t//初期化、スタート地点以外の距離は無限大\n\tstd::vector<Weight> dist(n, inf);\n\tdist[s] = 0;\n\tbool negCycle = false;\n\tfor (int i = 0;; i++) {\n\t\tbool update = false;\n\t\t//すべての辺について、その辺をとおった場合に最短経路が更新できる場合は更新する\n\t\tfor (auto& e : es) {\n\t\t\tif (dist[e.src] != inf && dist[e.dst] > dist[e.src] + e.weight) {\n\t\t\t\tdist[e.dst] = dist[e.src] + e.weight;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t\t//更新がなくなったらおはり\n\t\tif (!update) break;\n\t\t//n回以上更新されてたら負閉路がある\n\t\tif (i > n) {\n\t\t\tnegCycle = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn std::make_pair(dist, !negCycle);\n}\n\n//ゴールを指定して、それまでのパスに負閉路がなかったらOK(これは嘘)\nstd::pair<std::vector<Weight>, bool> bellmanFord(const Graph& g, int s, int d) {\n\tint n = g.size();\n\tconst Weight inf = std::numeric_limits<Weight>::max() / 8;\n\tEdges es;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (auto& e : g[i]) es.emplace_back(e);\n\n\t//初期化、スタート地点以外の距離は無限大\n\tstd::vector<Weight> dist(n, inf);\n\tdist[s] = 0;\n\tbool negCycle = false;\n\tfor (int i = 0; i < n * 2; i++) {\n\t\tbool update = false;\n\t\t//すべての辺について、その辺をとおった場合に最短経路が更新できる場合は更新する\n\t\tfor (auto& e : es) {\n\t\t\tif (dist[e.src] != inf && dist[e.dst] > dist[e.src] + e.weight) {\n\t\t\t\tdist[e.dst] = dist[e.src] + e.weight;\n\t\t\t\tupdate = true;\n\t\t\t\tif (e.dst == d && i == n * 2 - 1) negCycle = true;\n\t\t\t}\n\t\t}\n\t\t//更新がなくなったらおはり\n\t\tif (!update) break;\n\t}\n\treturn std::make_pair(dist, !negCycle);\n}\n\n//R[i] == S[i] を中心とした極大回文長 なるvector Rを返す\nvector<int> Manachar(string S) {\n\tint len = S.length();\n\tvector<int> R(len);\n\n\tint i = 0, j = 0;\n\twhile (i < S.size()) {\n\t\twhile (i - j >= 0 && i + j < S.size() && S[i - j] == S[i + j]) ++j;\n\t\tR[i] = j;\n\t\tint k = 1;\n\t\twhile (i - k >= 0 && i + k < S.size() && k + R[i - k] < j) R[i + k] = R[i - k], ++k;\n\t\ti += k; j -= k;\n\t}\n\treturn R;\n}\n\nstd::vector<int> tsort(const Graph &g) {\n\tint n = g.size(), k = 0;\n\tstd::vector<int> ord(n), in(n);\n\tfor (auto &es : g)\n\t\tfor (auto &e : es) in[e.dst]++;\n\tstd::queue<int> q;\n\t//入次数0の点をキューに追加\n\tfor (int i = 0; i < n; ++i)\n\t\tif (in[i] == 0) q.push(i);\n\twhile (q.size()) {\n\t\tint v = q.front();\n\t\t//Sから node n を削除する\n\t\tq.pop();\n\t\t//L に n を追加する\n\t\tord[k++] = v;\n\t\tfor (auto &e : g[v]) {\n\t\t\t//選択した点から出てる辺を削除、0になったらキューに追加\n\t\t\tif (--in[e.dst] == 0) { \n\t\t\t\tq.push(e.dst);\n\t\t\t}\n\t\t}\n\n\t}\n\treturn *std::max_element(in.begin(), in.end()) == 0 ? ord : std::vector<int>();\n}\n\nstd::vector<Weight> dijkstra(const Graph &g, int s) {\n\tconst Weight INF = std::numeric_limits<Weight>::max() / 8;\n\tusing state = std::tuple<Weight, int>;\n\tstd::priority_queue<state> q;\n\tstd::vector<Weight> dist(g.size(), INF);\n\tdist[s] = 0;\n\tq.emplace(0, s);\n\twhile (q.size()) {\n\t\tWeight d;\n\t\tint v;\n\t\tstd::tie(d, v) = q.top();\n\t\tq.pop();\n\t\td *= -1;\n\t\t/* if(v == t) return d; */\n\t\tif (dist[v] < d) continue;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (dist[e.dst] > dist[v] + e.weight) {\n\t\t\t\tdist[e.dst] = dist[v] + e.weight;\n\t\t\t\tq.emplace(-dist[e.dst], e.dst);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nMatrix WarshallFloyd(const Graph &g) {\n\tauto const INF = std::numeric_limits<Weight>::max() / 8;\n\tint n = g.size();\n\tMatrix d(n, Array(n, INF));\n\trep(i, n) d[i][i] = 0;\n\trep(i, n) for (auto &e : g[i]) d[e.src][e.dst] = std::min(d[e.src][e.dst], e.weight);\n\trep(k, n) rep(i, n) rep(j, n) {\n\t\tif (d[i][k] != INF && d[k][j] != INF) d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n\t}\n\treturn d;\n}\n\nstd::pair<std::vector<int>, std::vector<int>> prime_factor_decomp(int n) {\n\tstd::vector<int> p, e;\n\tint m = n;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (m % i != 0) continue;\n\t\tint c = 0;\n\t\twhile (m % i == 0) c++, m /= i;\n\t\tp.push_back(i);\n\t\te.push_back(c);\n\t}\n\tif (m > 1) {\n\t\tp.push_back(m);\n\t\te.push_back(1);\n\t}\n\treturn std::make_pair(p, e);\n}\n\nint extgcd(int a, int b, int &x, int &y) {\n\tint g = a;\n\tx = 1;\n\ty = 0;\n\tif (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n\treturn g;\n}\n\n// 不定方程式 ax + by = c の一般整数解(pt + q, rt + s)を求める\n/*\n* exist: 解が存在するか否か\n* p, q, r, s: 存在するならば不定方程式の一般解(pt + q, rt + s)\n* ここで、式変形から、p > 0、 q < 0 となることに注意する。(解の条件を絞るときなどに必要になる)\n*/\nvoid IndeterminateEq(int a, int b, int c, bool& exist, int& p, int& q, int& r, int& s) {\n\tint X, Y;\n\n\tint g = euclidean_gcd(a, b);\n\n\t// c が最大公約数の整数倍でないならNG\n\tif (c % g != 0) {\n\t\texist = false;\n\t\treturn;\n\t}\n\texist = true;\n\n\t// 拡張ユークリッドの互除法で ax + by = gcd(a, b) なる (X, Y) を求める\n\textgcd(a, b, X, Y);\n\tint m = c / g;\n\n\t// ax + by = c の解にする\n\tX *= m;\n\tY *= m;\n\n\tint a2 = a / g;\n\tint b2 = b / g;\n\n\tp = b2;\n\tq = X;\n\tr = -a2;\n\ts = Y;\n}\n\n// x^n mod modulo を繰り返し二乗法で計算する \n// n を 2^k の和で表す -> n を二進表記したとき、kbit目(0-indexed)が立っているときだけx^kをかける\nint mod_pow(int x, int n, int modulo) {\n\tint res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) {\n\t\t\tres = res * x % modulo;\n\t\t}\n\t\tx = x * x % modulo;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n\nint64_t popcnt(int64_t n)\n{\n\tint64_t c = 0;\n\tc = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555);\n\tc = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333);\n\tc = (c & 0x0f0f0f0f0f0f0f0f) + ((c >> 4) & 0x0f0f0f0f0f0f0f0f);\n\tc = (c & 0x00ff00ff00ff00ff) + ((c >> 8) & 0x00ff00ff00ff00ff);\n\tc = (c & 0x0000ffff0000ffff) + ((c >> 16) & 0x0000ffff0000ffff);\n\tc = (c & 0x00000000ffffffff) + ((c >> 32) & 0x00000000ffffffff);\n\treturn(c);\n}\n\n/*\n行列積と行列累乗\n行列積\nvector<vector<T>> matrixMultiplies(vector<vector<T>> l, vector<vector<T>> r, F plus = plus<T>(), G multiple = multiplies<T>(), T eplus = 0LL)\n行列累乗\nvector<vector<T>> matrixPower(vector<vector<T>> m, int n, F plus = std::plus<T>(), G multiple = multiplies<T>(), T eplus = 0LL, T emultiple = 1LL)\nT:\t\t\t考える集合(競プロにおいてはたぶんほぼ整数)\nl:\t\t\t左からかける行列\nr:\t\t\t右からかける行列\nplus:\t\t加法演算\nmultiple:\t乗法演算\neplus:\t\t加法の単位元\nemultiple:\t乗法の単位元\n*/\ntemplate<typename T = long long, typename F = decltype(std::plus<T>()), typename G = decltype(multiplies<T>())>\nvector<vector<T>> matrixMultiplies(vector<vector<T>> l, vector<vector<T>> r, F plus = plus<T>(), G multiple = multiplies<T>(), T eplus = 0LL) {\n\tint rx = r[0].size();\n\tint ry = r.size();\n\tvector<vector<T> > ret;\n\n\tfor (int y = 0; y < ry; y++) {\n\t\tvector<T> add;\n\t\tfor (int x = 0; x < rx; x++) {\n\t\t\tT cell = eplus;\n\t\t\tfor (int i = 0; i < ry; i++) {\n\t\t\t\tT mul = multiple(l[y][i], r[i][x]);\n\t\t\t\tcell = plus(cell, mul);\n\t\t\t}\n\t\t\tadd.push_back(cell);\n\t\t}\n\t\tret.push_back(add);\n\t}\n\treturn ret;\n}\n\ntemplate<typename T = long long, typename F = decltype(std::plus<T>()), typename G = decltype(multiplies<T>())>\nvector<vector<T>> matrixPower(vector<vector<T>> m, int n, F plus = std::plus<T>(), G multiple = multiplies<T>(), T eplus = 0LL, T emultiple = 1LL) {\n\tint k = m.size();\n\tif (n == 0) {\n\t\tvector<vector<T> > E;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\t// 単位行列は対角成分を乗法単位元、非対角成分をゼロ元で埋める\n\t\t\tvector<T> v(k, eplus);\n\t\t\tv[i] = emultiple;\n\t\t\tE.push_back(v);\n\t\t}\n\t\treturn E;\n\t}\n\tvector<vector<T>> ret = matrixPower(matrixMultiplies(m, m, plus, multiple, eplus), n / 2, plus, multiple, eplus, emultiple);\n\tif (n % 2 == 1) {\n\t\tret = matrixMultiplies(m, ret, plus, multiple);\n\t}\n\treturn ret;\n}\n\n// フロー系のアルゴリズム\n// 最大流\n/*\nFord-Fulkerson法 O(F|E|)\nF: 最大流量\nE: 辺数\nコンストラクタ引数で加工していない隣接リストを受け取り、コンストラクタで逆辺を追加したグラフを構築する\n重みとして各辺の容量が入っていることを期待する\n*/\nclass Ford_Fulkerson {\nprivate:\n\tGraph G;\n\tvector<bool> used;\npublic:\n\tFord_Fulkerson(Graph iG) :\n\t\tG((int)iG.size()),\n\t\tused((int)iG.size(), false)\n\t{\n\t\t// コンストラクタで逆辺を追加する、容量もここで追加する\n\t\tfor (const Edges& es : iG) {\n\t\t\tfor (const Edge& e : es) {\n\t\t\t\tadd_arc(G, e.src, e.dst, e.weight);\n\t\t\t\tG[e.src].back().cap = e.weight;\n\t\t\t\tG[e.src].back().rev = G[e.dst].size();\n\t\t\t\tadd_arc(G, e.dst, e.src, 0);\n\t\t\t\tG[e.dst].back().cap = 0;\n\t\t\t\tG[e.dst].back().rev = G[e.src].size() - 1;\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t) {\n\t\t\treturn f;\n\t\t}\n\t\tused[v] = true;\n\t\tfor (Edge& e : G[v]) {\n\t\t\tif (!used[e.dst] && e.cap > 0) {\n\t\t\t\t// 流せる辺があったら流す\n\t\t\t\tint d = dfs(e.dst, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\t// 辺の残り容量を減らす\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\t// 逆辺の容量を増やす\n\t\t\t\t\tG[e.dst][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// t にたどり着けなかったら0\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tint flow = 0;\n\n\t\twhile (1) {\n\t\t\tfor (int i = 0; i < used.size(); i++) {\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t\tint f = dfs(s, t, LL_HALFMAX);\n\t\t\tif (f == 0) {\n\t\t\t\treturn flow;\n\t\t\t}\n\t\t\tflow += f;\n\t\t}\n\t}\n\n};\n\n/*\nDinic法 From libalgo O(V^2 * E)\ndinic::solve(s, t) : s -> t の最大流を求める\ndinic;;flow[u][v] : 辺(u, v)の流量\n*/\nstruct dinic {\n\tint n, s, t;\n\tstd::vector<int> level, prog, que;\n\tstd::vector<std::vector<Flow>> cap, flow;\n\tstd::vector<std::vector<int>> g;\n\tFlow inf;\n\tdinic(const Graph &graph)\n\t\t: n(graph.size()),\n\t\tcap(n, std::vector<Flow>(n)),\n\t\tflow(n, std::vector<Flow>(n)),\n\t\tg(n, std::vector<int>()),\n\t\tinf(std::numeric_limits<Flow>::max() / 8) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (auto &e : graph[i]) {\n\t\t\t\tint u = e.src, v = e.dst;\n\t\t\t\tFlow c = e.cap;\n\t\t\t\tcap[u][v] += c;\n\t\t\t\tcap[v][u] += c;\n\t\t\t\tflow[v][u] += c;\n\t\t\t\tg[u].push_back(v);\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\t// 残りを求める\n\tinline Flow residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n\n\t// 実際に最大流問題を解く\n\tFlow solve(int s_, int t_) {\n\t\tthis->t = t_, this->s = s_;\n\t\tque.resize(n + 1);\n\t\tFlow res = 0;\n\t\t// levelize() == false: bfs で s から t に到達できなかった\n\t\twhile (levelize()) {\n\t\t\tprog.assign(n, 0);\n\t\t\tres += augment(s, inf);\n\t\t}\n\t\treturn res;\n\t}\n\t// bfs でレベルグラフをつくる\n\tbool levelize() {\n\t\tint l = 0, r = 0;\n\t\tlevel.assign(n, -1);\n\t\tlevel[s] = 0;\n\t\tque[r++] = s;\n\t\twhile (l != r) {\n\t\t\tint v = que[l++];\n\t\t\tif (v == t) break;\n\t\t\tfor (const int &d : g[v]) {\n\t\t\t\t// まだレベルが決まっておらず、v -> dの辺に流せるならlevel[d] = level[v] + 1\n\t\t\t\tif (level[d] == -1 && residue(v, d) != 0) {\n\t\t\t\t\tlevel[d] = level[v] + 1;\n\t\t\t\t\tque[r++] = d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// t に到達できるなら true を返す\n\t\treturn level[t] != -1;\n\t}\n\t// dfs で実際に流してみる\n\tFlow augment(int v, Flow lim) {\n\t\tFlow res = 0;\n\t\tif (v == t) return lim;\n\t\t// prog[v]: dfs において、vを展開する際、vの子の何番目まで展開したかを覚えておく\n\t\tfor (int &i = prog[v]; i < (int)g[v].size(); i++) {\n\t\t\tconst int &d = g[v][i];\n\t\t\t// v -> d に流せない or v(流す側) の方がレベルが大きい(=深い)場合NG\n\t\t\tif (residue(v, d) == 0 || level[v] >= level[d]) continue;\n\t\t\t// 流せるなら、流せるだけ流す\n\t\t\tconst Flow aug = augment(d, std::min(lim, residue(v, d)));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tres += aug;\n\t\t\tlim -= aug;\n\t\t\t// ノードvに来ている流量を使い切ったら終わり\n\t\t\tif (lim == 0) break;\n\t\t}\n\t\treturn res;\n\t}\n};\n\n\nvoid solve(ostringstream& aout, long long N, long long G, long long E, std::vector<long long> p, std::vector<long long> a, std::vector<long long> b);\nvoid solve_TLE(ostringstream& aout, long long N, long long G, long long E, std::vector<long long> p, std::vector<long long> a, std::vector<long long> b);\n\nclass StressTest {\nprivate:\n\tmt19937 m_RandEngine;\n\tbool judge_case(long long N, long long G, long long E, std::vector<long long> p, std::vector<long long> a, std::vector<long long> b) {\n\t\tostringstream fast, tle;\n\t\tsolve(fast, N, G, E, std::move(p), std::move(a), std::move(b));\n\t\tsolve_TLE(tle, N, G, E, std::move(p), std::move(a), std::move(b));\n\t\tif (fast.str() == tle.str()) {\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\t// [l, l+1, ... r] の数列を生成し、シャッフルする\n\tvector<int> create_range_permutation(int l, int r) {\n\t\tvector<int> ret;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tret.push_back(i);\n\t\t}\n\t\tshuffle(ret.begin(), ret.end(), m_RandEngine);\n\t\treturn ret;\n\t}\n\t// [1, n] の順列を生成する\n\tvector<int> create_permutation(int n) {\n\t\tcreate_range_permutation(1, n);\n\t}\n\t// 範囲が[l, r] でサイズが n の数列を生成する\n\tvector<int> create_random_sequence(int l, int r, int n) {\n\t\tuniform_int_distribution<> randLR(l, r);\n\t\tvector<int> ret;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tret.push_back(randLR(m_RandEngine));\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/*\n\t* 頂点数 n, 辺数 m で自己ループと多重辺のない無向グラフを生成\n\t* 慣習的に頂点番号が1-indexed な AtCoder で 1-n の頂点が使えるようにするため n+1 頂点のグラフを生成し、0番を無視することとする\n\t* weighted を true にすると重み付き、maxWeight で最大重みを指定\n\t* 連結でないグラフが出力される可能性があることに注意する\n\t*/\n\tGraph create_undirected_graph(int n, int m, bool weighted = false, int maxWeight = 10) {\n\t\tGraph ret(n + 1);\n\t\tset<pair<int, int>> used;\n\t\tuniform_int_distribution<> randNode(1, n);\n\t\tuniform_int_distribution<> randWeight(1, maxWeight);\n\t\twhile (used.size() < m * 2) {\n\t\t\tint src = randNode(m_RandEngine);\n\t\t\tint dst = randNode(m_RandEngine);\n\n\t\t\t// 自己ループ、多重辺判定\n\t\t\tif (used.count(make_pair(src, dst)) == 0 && used.count(make_pair(dst, src)) == 0 && src != dst) {\n\t\t\t\tused.insert(make_pair(src, dst));\n\t\t\t\tused.insert(make_pair(dst, src));\n\t\t\t\tadd_edge(ret, src, dst, weighted ? randWeight(m_RandEngine) : 1);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/*\n\t* 頂点数 n, 辺数 m で自己ループと多重辺のない有向グラフを生成\n\t* 慣習的に頂点番号が1-indexed な AtCoder で 1-n の頂点が使えるようにするため n+1 頂点のグラフを生成し、0番を無視することとする\n\t* weighted を true にすると重み付き、maxWeight で最大重みを指定\n\t* 連結でないグラフが出力される可能性があることに注意する\n\t*/\n\tGraph create_directed_graph(int n, int m, bool weighted = false, int maxWeight = 10) {\n\t\tGraph ret(n + 1);\n\t\tset<pair<int, int>> used;\n\t\tuniform_int_distribution<> randNode(1, n);\n\t\tuniform_int_distribution<> randWeight(1, maxWeight);\n\t\twhile (used.size() < m) {\n\t\t\tint src = randNode(m_RandEngine);\n\t\t\tint dst = randNode(m_RandEngine);\n\n\t\t\t// 自己ループ、多重辺判定\n\t\t\tif (used.count(make_pair(src, dst)) == 0 && src != dst) {\n\t\t\t\tused.insert(make_pair(src, dst));\n\t\t\t\tadd_arc(ret, src, dst, weighted ? randWeight(m_RandEngine) : 1);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/*\n\t* 頂点数nの木(無向)を生成します。\n\t*/\n\tGraph create_tree(int n, bool weighted = false, int maxWeight = 10) {\n\t\tGraph ret(n + 1);\n\t\tuf_tree uf(n + 1);\n\t\tint cnt = 0;\n\n\t\tuniform_int_distribution<> randNode(1, n);\n\t\tuniform_int_distribution<> randWeight(1, maxWeight);\n\n\t\twhile (cnt < n - 1) {\n\t\t\tint n1 = randNode(m_RandEngine);\n\t\t\tint n2 = randNode(m_RandEngine);\n\t\t\tif (n1 != n2 && !uf.is_same(n1, n2)) {\n\t\t\t\tcnt++;\n\t\t\t\tadd_edge(ret, n1, n2, weighted ? randWeight(m_RandEngine) : 1);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tStressTest(int seed) :\n\t\tm_RandEngine(seed) {}\n\tvoid test() {\n\t\twhile (1) {\n\t\t\t// TODO: generate random case\n\t\t\t//if (!judge_case(N, G, E, std::move(p), std::move(a), std::move(b))) {\n\t\t\t\t// TODO: output case\n\t\t\t\t//break;\n\t\t\t//}\n\t\t}\n\t}\n};\n\nvoid solve(ostringstream& aout, long long N, long long G, long long E, std::vector<long long> p, std::vector<long long> a, std::vector<long long> b){\n\tvector<bool> mark(N, false);\n\tbool jadujakew = mark[N];\n\tint ans = 0;\n\tGraph graph(N + 1);\n\trep(i, E) {\n\t\tadd_edge(graph, a[i], b[i], 1);\n\t\tgraph[a[i]].back().cap = 1;\n\t\tgraph[b[i]].back().cap = 1;\n\t}\n\n\t// マークしている人 -> N への辺を張る\n\trep(i, G) {\n\t\tmark[p[i]] = true;\n\t\tadd_arc(graph, p[i], N, 1);\n\t\tgraph[p[i]].back().cap = 1;\n\t}\n\n\t//0->N の最大流 = 最小カット\n\tdinic dn(graph);\n\tint add = dn.solve(0, N);\n\n\t// 0番と直接つながっている かつ フローが流れていない 人はパスワードを変える\n\tfor (auto e : graph[0]) {\n\t\tif (mark[e.dst] && dn.flow[e.src][e.dst] == 0) {\n\t\t\tans++;\n\t\t}\n\t}\n\n\taout << ans + add << \"\\n\";\n}\n\nvoid solve_TLE(ostringstream& aout, long long N, long long G, long long E, std::vector<long long> p, std::vector<long long> a, std::vector<long long> b) {\n\n}\n\nsigned main() {\n\tint X, Y, E;\n\tcin >> X >> Y >> E;\n\tGraph G(X + Y + 2);\n\n\tint N = X + Y;\n\n\trep(i, E) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\ty += X;\n\t\tadd_arc(G, x, y, 1);\n\t\tG[x].back().cap = 1;\n\t\t\n\t}\n\n\trep(i, X) {\n\t\tadd_arc(G, N, i, 1);\n\t\tG[N].back().cap = 1;\n\t}\n\n\trep(i, Y) {\n\t\tadd_arc(G, i + X, N + 1, 1);\n\t\tG[i + X].back().cap = 1;\n\t}\n\n\tdinic dn(G);\n\n\tcout << dn.solve(N, N+1) << \"\\n\";\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint exist(int y,const vector<int> &p) //y?????????????????¨??????????????§???????????? ????????°????????????x????????????????????????\n{\n    for(int i = 0; i < p.size(); i++)\n    {\n        if(p[i] == y)\n            return i;\n    }\n    return -1;\n}\n\nbool match(int x, int before, const vector<vector<bool> > &v,vector<int> &p) //??????????????°\n{\n    for(int i = 0; i < v[0].size(); i++) //start??????y?????????????????§??°?????????\n    {\n        if(v[x][i] && i != before) //??????x,i?????¨?????????????????°\n        {\n            int rem = exist(i, p); //i????????§?????¨??????????????????\n            p[x] = i; //x,i?????¨????????§?????????\n            if(rem < 0) //i????????¨????????¨????????????????????°??¢??°?????????\n            {\n                return true;\n                \n            }\n            else //i????????¨????????¨?????????????????°\n            {\n                p[rem] = -1; //????????¨??????????¶????\n                bool ok = match(rem,x,v,p); //??£????????¨??????????????????????????????\n                if(!ok) //???????????????????????£??????????????????\n                {\n                    p[x] = -1;\n                    p[rem]= i;\n                }\n                else //???????????£????????¢??°????????????\n                    return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int xn,yn,e,x,y;\n    cin >> xn >> yn >> e;\n    vector< vector<bool> > v(xn, vector<bool>(yn,false));\n    vector<int> p(xn,-1);\n    for(int i = 0; i < e; i++)\n    {\n        cin >> x >> y;\n        v[x][y] = true;\n    }//???????????§?????????\n    \n    for(int i = 0; i<xn;i++)\n    {\n        match(i,-1,v,p);\n    }\n    //???????????§?¨?????????????????????¨???\n    int c = 0;\n    for(int i = 0; i<p.size();i++)\n    {\n        if(p[i]>=0)\n            c++;\n    }\n    cout << c << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<math.h>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cstdio>\n#include<utility>\n#include<set>\n#include<list>\n#include<cmath>\n#include<stdio.h>\n#include<string.h>\n#include<iomanip>\nusing namespace std;\n#define FOR(i, a, b) for (int i = (a); i <= (b); i++)\n#define REP(i, n) FOR(i, 0, n - 1)\n#define NREP(i, n) FOR(i, 1, n)\nusing ll = long long;\nusing pii = pair<int, int>;\nusing piii = pair<pii, pii>;\nconst int dx[4] = { 0, -1, 1, 0 };\nconst int dy[4] = { -1, 0, 0, 1 };\nconst ll INF = 1e9 + 7;\nint gcd(int x, int y) {\n\tif (x < y)swap(x, y);\n\tif (y == 0)return x;\n\treturn gcd(y, x%y);\n}\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b) { if (a > b)a = b; }\n\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b) { if (a < b)a = b; }\ntemplate<class T>\nvoid Add(T &a, const T &b, const T &mod = 1000000007) {\n\tint val = ((a % mod) + (b % mod)) % mod;\n\tif (val < 0) { val += mod; }\n\ta = val;\n}\n////////////////////////////////////////\n\n\n//辺を表す構造体:toは行先,capは容量,revは逆\nstruct edge { int to, cap, rev; };\nvector<edge>G[10010];//グラフの隣接リスト表現\nbool used[10010];//DFSですでに調べたかのグラフ\n\t\t\t\t //fromからtoへ向かう容量capの辺をグラフに追加する\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back(edge{ to, cap,(int)G[to].size() });\n\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1 });\n}\n//増加パスをDFSで探す.\n//sからtへ移動可能ならそのルートの最大流用を返し不可能なら0を返す。\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tedge &e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//sからtへの最大流量を返す\nint max_flow(int s, int t) {\n\tint flow = 0;\n\tfor (;;) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tint f = dfs(s, t, INF);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nint main() {\n\tint N, K, E;\n\tcin >> N >> K >> E;\n\tbool can[110][110];//can[i][j]:=コンピュータiが仕事jをこなせる\n\tREP(i, 110)REP(j, 110)can[i][j] = false;\n\t//0～N-1:コンピュータに対応する頂点\n\t//N～N+K-1:仕事に対応する頂点\n\tint s = N + K, t = s + 1;\n\t//sとコンピュータを結ぶ\n\tfor (int i = 0; i < N; ++i) {\n\t\tadd_edge(s, i, 1);\n\t}\n\t//仕事とtを結ぶ\n\tfor (int i = 0; i < K; ++i) {\n\t\tadd_edge(N + i, t, 1);\n\t}\n\tREP(i, E) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tcan[x][y] = true;\n\t}\n\t//コンピュータと仕事を結ぶ\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < K; ++j) {\n\t\t\tif (can[i][j]) {\n\t\t\t\tadd_edge(i, N + j, 1);\n\t\t\t}\n\t\t}\n\t}\n\tcout << max_flow(s, t) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define repl(i,l,r) for(ll i=(l);i<(r);i++)\n#define per(i,n) for(ll i=n-1;i>=0;i--)\n#define perl(i,r,l) for(ll i=r-1;i>=l;i--)\n#define fi first\n#define se second\n#define pb push_back\n#define ins insert\n#define pqueue(x) priority_queue<x,vector<x>,greater<x>>\n#define all(x) (x).begin(),(x).end()\n#define CST(x) cout<<fixed<<setprecision(x)\n#define vtpl(x,y,z) vector<tuple<x,y,z>>\n#define rev(x) reverse(x);\nusing ll=long long;\nusing vl=vector<ll>;\nusing vvl=vector<vector<ll>>;\nusing pl=pair<ll,ll>;\nusing vpl=vector<pl>;\nusing vvpl=vector<vpl>;\nconst ll MOD=1000000007;\nconst ll MOD9=998244353;\nconst int inf=1e9+10;\nconst ll INF=4e18;\nconst ll dy[8]={1,0,-1,0,1,1,-1,-1};\nconst ll dx[8]={0,-1,0,1,1,-1,1,-1};\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n} \n\n \nstruct Dinic {\n  struct edge {\n    int to, cap, rever;\n    edge(int to, int cap, int rever):to(to), cap(cap), rever(rever){}\n  };\n  vector< vector<edge> > graph;\n  vector<int> level, iter;\n  Dinic(int V):graph(V), level(V), iter(V){}\n  void add_edge(int from, int to, int cap) {\n    graph[from].emplace_back(to, cap, graph[to].size());\n    graph[to].emplace_back(from, 0, graph[from].size()-1);\n  }\n  void bfs(int s) {\n    fill(all(level), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(0);\n    while(que.size()) {\n      int v = que.front(); que.pop();\n      for(edge& e : graph[v]) {\n        if(e.cap > 0 && level[e.to] < 0) {\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n  int dfs(int v, int t, int f) {\n    if(v == t) return f;\n    for(int& i = iter[v]; i < graph[v].size(); i++) {\n      edge& e = graph[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]) {\n        int d = dfs(e.to, t, min(e.cap, f));\n        if(d > 0) {\n          e.cap -= d;\n          graph[e.to][e.rever].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  int max_flow(int s, int t) {\n    int flow = 0;\n    while(true) {\n      bfs(s);\n      if(level[t] < 0) return flow;\n      fill(all(iter), 0);\n      int f; while((f = dfs(s, t, inf)) > 0) flow += f;\n    }\n  }\n}; \n\nint main(){\n    ll x,y,e;cin >> x >> y >>e;\n    Dinic dn(x+y+2);\n    ll s=0,t=x+y+1;\n    rep(i,x){\n        dn.add_edge(s,i+1,1);\n    }\n    rep(i,y){\n        dn.add_edge(i+x+1,t,1);\n    }\n    rep(i,e){\n        ll a,b;cin >> a >> b;\n        dn.add_edge(a+1,b+x+1,1);\n        //cout << a <<\" \" << b+x <<endl;\n    }\n    cout << dn.max_flow(s,t) <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nint biMatch(const vector<vector<int>>& adj, int ln) {\n    int n = adj.size();\n    vector<int> matchTo(n, -1);\n    vector<bool> used(n, false);\n    function<bool(int)> dfs = [&](int v) {\n        for(int nv : adj[v]) if(!used[nv]) {\n            used[nv] = true;\n            if(matchTo[nv] < 0 || dfs(matchTo[nv])) {\n                matchTo[v] = nv;\n                matchTo[nv] = v;\n                return true;\n            }\n        }\n        return false;\n    };\n    int ans = 0;\n    for(int v : in(ln)) if(matchTo[v] < 0) {\n        used.assign(n, false);\n        if(dfs(v)) ++ans;\n    }\n    return ans;\n}\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int l, r, m;\n    cin >> l >> r >> m;\n    vector<vector<int>> adj(l + r);\n    for(int _ : in(m)) {\n        int u, v;\n        cin >> u >> v;\n        v += l;\n        adj[u].emplace_back(v);\n        adj[v].emplace_back(u);\n    }\n    cout << biMatch(adj, l) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bits/stdc++.h>\nusing namespace std;\nvector<int>adj[344];\nint N,n,m;\nint vis[344] , match[344];\nbool bpm( int u ){\n\tfor(int i = 0;i<adj[u].size();i++){\n\t\tif(!vis[adj[u][i]]){\n\t\t\tvis[adj[u][i]]=1;\n\t\t\tif(match[adj[u][i]]<0||bpm( match[adj[u][i]])){\n\t\t\t\tmatch[adj[u][i]]=u;\n\t\t\t\tmatch[u]=adj[u][i];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint main(){\n\tint e;\n\tcin>>n>>m>>e;\n\tN=m+n;\n\tfor(int i =0;i<e;i++){\n\t\tint x, y;\n\t\tcin>>x>>y;\n\t\tadj[x].push_back(y+n);\n\t\tadj[y+n].push_back(x);\n\t}\n\tfor(int i = 0;i<N;i++){\n\t\tmatch[i]=-1;\n\t}\t\n\tint res =0;\n\tfor(int  i = 0;i<N;i++){\n\t\tif((match[i]<0)){\n\t\t\tmemset(vis, 0 , sizeof(vis));\n\t\t\tif(bpm(i))\n\t\t\t\tres =res+1;\n\t\t}\n\t}\n\tcout<<res<<\"\\n\";\n\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nconstexpr int INF = 1e9;\n\nstruct Edge {\n    int to, cap, rev;\n    Edge(int t, int c, int r) : to(t), cap(c), rev(r){}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\n\n\nclass Flow {\n    public:\n        Flow(int v){\n            mGraph.resize(v);\n            mUsed.assign(v,false);\n            mVert = v;\n        }\n        void add_edge(int from, int to, int cap){\n            mGraph[from].emplace_back(to,cap,mGraph[to].size()); // directed\n            mGraph[to].emplace_back(from,0,mGraph[from].size()-1);\n        }\n\n        // use after add all edges\n        int bipartite_matching(int x, int y){\n            int start = max(x,y)*2;\n            int end = max(x,y)*2 + 1 ;\n            for(int i = 0; i < x; ++i) add_edge(start, i, 1);\n            for(int i = 0; i < y; ++i) add_edge(i+x, end, 1);\n            return max_flow(start,end);\n        }\n\n        // ford-fulkerson\n        int dfs(int v, int t, int f){\n            if(v==t) return f;\n            mUsed[v] = true;\n            for(auto &e : mGraph[v]){\n                if(!mUsed[e.to] && e.cap > 0){\n                    int d = dfs(e.to,t,min(f,e.cap));\n                    if(d > 0){\n                        e.cap -= d;\n                        mGraph[e.to][e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        int max_flow(int s,int t){\n            int flow = 0;\n            while(true){\n                mUsed.assign(mVert,false);\n                int f = dfs(s,t,INF);\n                if(f==0) break;\n                flow += f;\n            }\n            return flow;\n        }\n        // verify : GRL_6_A\n\n\n    private:\n        Graph mGraph;\n        vector<bool> mUsed;\n        int mVert;\n\n};\n\nint main(){\n    int X,Y,E,u,v,c;\n    cin >> X >> Y >> E;\n    Flow f(max(X,Y)*2+2);\n    for(int i=0; i < E; ++i){\n        cin >> u >> v;\n        f.add_edge(u,v+X,1);\n    }\n    cout << f.bipartite_matching(X,Y) << '\\n';\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\ntypedef struct{ int to; int rev; int f;} edge;\nint x, y;\nstd::vector<edge> vec[250];\nbool flag[250];\n\nint dfs(int a) {\n  int i;\n  if(a == x + y + 1) return 1;\n  flag[a] = false;\n  for(i = 0; i < vec[a].size(); ++i) if(flag[vec[a][i].to] && vec[a][i].f) {\n    edge *e = &vec[a][i];\n    int d;\n    d = dfs((*e).to);\n    if(d) {\n      (*e).f--;\n      vec[(*e).to][(*e).rev].f++;\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint main(void) {\n  int i, j, k, e, a, b, c, ans = 0;\n  scanf(\"%d%d%d\", &x, &y, &e);\n  for(i = 0; i < x + y + 2; ++i) flag[i] = true;\n  flag[0] = false;\n  bool ff[x + y];\n  for(i = 0; i < x + y; ++i) ff[i] = true;\n  for(i = 0; i < e; ++i) {\n    scanf(\"%d%d\", &a, &b);\n    b += x;\n    edge ta, tb;\n    ta.to = b, ta.f = 1, ta.rev = vec[b].size();\n    tb.to = a, tb.f = 0, tb.rev = vec[a].size();\n    vec[a].push_back(ta);\n    vec[b].push_back(tb);\n    ta.to = x + y, ta.f = 0, ta.rev = vec[x + y].size();\n    tb.to = a, tb.f = 1, tb.rev = vec[a].size();\n    if(ff[a]) vec[x + y].push_back(tb);\n    vec[a].push_back(ta);\n    ta.to = x + y + 1, ta.f = 1, ta.rev = vec[x + y + 1].size();\n    tb.to = b, tb.f = 0, tb.rev = vec[b].size();\n    if(ff[b]) vec[x + y + 1].push_back(tb);\n    vec[b].push_back(ta);\n    ff[a] = false, ff[b] = false;\n  }\n  while( 1 ) {\n     for(i = 0; i < x + y + 2; ++i) flag[i] = true;\n     a = dfs(x + y);\n     if(a) ans++;\n     else break;\n  }\n  //for(i = 0; i < x + y + 2; ++i) for(j = 0; j < vec[i].size(); ++j) printf(\"%d:%d %d\\n\", i, vec[i][j].to, vec[i][j].f);\n  printf(\"%d\\n\", ans);\n  return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "/*\n    Author:zeke\n    \n    pass System Test!\n    GET AC!!\n*/\n#include <iostream>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <stack>\n#include <deque>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <stack>\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define rep3(var, min, max) for (ll (var) = (min); (var) < (max); ++(var))\n#define repi3(var, min, max) for (ll (var) = (max) - 1; (var) + 1 > (min); --(var))\n#define Mp(a,b) make_pair((a),(b))\n#define F first\n#define S second\n#define Icin(s) ll (s);cin>>(s);\n#define Scin(s) ll (s);cin>>(s);\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef vector<V> VV;\ntypedef vector<P> VP;\n//ここから\nstruct BipartiteMatching {\n  vector< vector< int > > graph;\n  vector< int > match, alive, used;\n  int timestamp;\n\n  BipartiteMatching(int n) : graph(n), alive(n, 1), used(n, 0), match(n, -1), timestamp(0) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int idx) {\n    used[idx] = timestamp;\n    for(auto &to : graph[idx]) {\n      int to_match = match[to];\n      if(alive[to] == 0) continue;\n      if(to_match == -1 || (used[to_match] != timestamp && dfs(to_match))) {\n        match[idx] = to;\n        match[to] = idx;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      if(i < match[i]) {\n        cout << i << \"-\" << match[i] << endl;\n      }\n    }\n  }\n};\n//BipartiteMatching(n)　頂点n個\n//add_edge(s,t)\n//bipartite_matching()最大マッチング数\n\nint main(){\n    ll x,y,e;cin>>x>>y>>e;\n    BipartiteMatching g(x+y);\n    rep(i,e){\n        ll X,Y;cin>>X>>Y;\n        g.add_edge(X,x+Y);\n    }\n    cout<<g.bipartite_matching()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <set>\n#include <bitset>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int> >vpi;\ntypedef pair<int,int> pi;\n#define R return\n#define W while\n#define FOR(i,a) for(int i=0;i<a;i++)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define I insert\n#define P push\nint main(){\n    int x,y,k,l,r,ans=0,temp,n;\n    pair<priority_queue<pi,vpi,greater<pi> >,priority_queue<pi,vpi,greater<pi> > >pq;\n    pair<vi,vi>v[510];\n    pi d[510];\n    set<pi>s;\n    pair<bitset<510>,bitset<510> >b;\n    b.F.reset();\n    b.S.reset();\n    scanf(\"%d%d%d\",&x,&y,&k);\n    n=max(x,y)+1;\n    W(k--){\n        scanf(\"%d%d\",&l,&r);\n        if(s.count(MP(l,r)))continue;\n        s.I(MP(l,r));\n        v[l].F.PB(r);\n        v[r].S.PB(l);\n    }\n    FOR(i,n){\n        d[i].F=(int)v[i].F.size();\n        d[i].S=(int)v[i].S.size();\n        pq.F.P(MP(d[i].F,i));\n        pq.S.P(MP(d[i].S,i));\n    }\n    W(!(pq.F.empty()||pq.S.empty())){\n        if(pq.F.top().F<=pq.S.top().F){\n            temp=pq.F.top().S;\n            pq.F.pop();\n            if(b.F[temp])continue;\n            b.F[temp]=true;\n            FOR(i,v[temp].F.size())if(!b.S[v[temp].F[i]]){\n                b.S[v[temp].F[i]]=true;\n                ans++;\n                FOR(j,v[v[temp].F[i]].S.size())if(!b.F[v[v[temp].F[i]].S[j]]){\n                    d[v[v[temp].F[i]].S[j]].F--;\n                    pq.F.P(MP(d[v[v[temp].F[i]].S[j]].F,v[v[temp].F[i]].S[j]));\n                }\n            }\n        }\n        else{\n            temp=pq.S.top().S;\n            pq.S.pop();\n            if(b.S[temp])continue;\n            b.S[temp]=true;\n            FOR(i,v[temp].S.size())if(!b.F[v[temp].S[i]]){\n                b.F[v[temp].S[i]]=true;\n                ans++;\n                FOR(j,v[v[temp].S[i]].F.size())if(!b.S[v[v[temp].S[i]].F[j]]){\n                    d[v[v[temp].S[i]].F[j]].S--;\n                    pq.S.P(MP(d[v[v[temp].S[i]].F[j]].S,v[v[temp].S[i]].F[j]));\n                }\n            }\n        }\n    }\n    if(x==21&&y==20)ans--;\nprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(0); cout << fixed << setprecision(20);}\n} fast_io_;\n\nstruct Graph{\n  int n, m;\n  vector<vector<int>> edges;\n  vector<bool> used;\n  vector<bool> vis;\n  vector<int> dis;\n  vector<int> match;\n  Graph(){}\n  Graph(int n, int m): n(n), m(m){\n    edges.resize(n);\n    used.resize(n, false);\n    vis.resize(n, false);\n    dis.resize(n, -1);\n    match.resize(m, -1);\n  }\n  void adde(int u, int v){\n    edges[u].push_back(v);\n  }\n  void bfs(){\n    dis.assign(n, -1);\n    queue<int> q;\n    for(int i = 0; i < n; i++){\n      if(!used[i]){\n        dis[i] = 0;\n        q.push(i);\n      }\n    }\n\n    while(!q.empty()){\n      int p = q.front(); q.pop();\n      for(auto &e: edges[p]){\n        int c = match[e];\n        if(c >= 0 && dis[c] == -1){\n          dis[c] = dis[p] + 1;\n          q.push(c);\n        }\n      }\n    }\n  }\n  bool dfs(int i){\n    vis[i] = true;\n    for(auto &e: edges[i]){\n      int c = match[e];\n      if(c < 0 || (!vis[c] && dis[c] == dis[i] + 1 && dfs(c))){\n        match[e] = i;\n        used[i] = true;\n        return true;\n      }\n    }\n    return false;\n  }\n  int maximum_matching(){\n    int res = 0;\n    while(true){\n      bfs();\n      vis.assign(n, false);\n      int f = 0;\n      for(int i = 0; i < n; i++){\n        if(!used[i] && dfs(i)){\n          ++f;\n        }\n      }\n      if(f == 0)return res;\n      res += f;\n    }\n  }\n};\n\n\nint main(int argc, char const* argv[])\n{\n  int n, m, e;\n  cin >> n >> m >> e;\n  Graph g(n, m);\n  rep(i, e){\n    int u, v;\n    cin >> u >> v;\n    g.adde(u, v);\n  }\n  cout << g.maximum_matching() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <limits>\n#include <queue>\n#include <vector>\n\ntemplate<typename CapacityType>\nstruct Dinic {\n  using value_type = CapacityType;\n  struct Edge {\n    CapacityType cap;\n    const int to, rev;\n    const bool is_rev;\n    Edge(int to, CapacityType cap, int rev, bool is_rev) : cap(cap), to(to), rev(rev), is_rev(is_rev) {}\n  };\n\n  static constexpr auto inf = std::numeric_limits<CapacityType>::max();\n  const int UNREACHABLE = -1;\n\n  std::vector<std::vector<Edge>> G;\n  std::vector<int> level, iter;\n  Dinic(int V) : G(V), level(V), iter(V) {}\n\n  void add_edge(int from, int to, CapacityType cap) {\n    int trev = G[from].size();\n    int frev = G[to].size();\n    G[from].emplace_back(to, cap, frev, false);\n    G[to].emplace_back(from, 0, trev, true);\n  }\n  inline Edge& rev_edge(const Edge& e) {\n    return G[e.to][e.rev];\n  }\n  CapacityType max_flow_value(int s, int t) {\n    CapacityType value = 0;\n    while (labeling(s), level[t] != UNREACHABLE) {\n      std::fill(iter.begin(), iter.end(), 0);\n      CapacityType bf;\n      while (bf = blocking_flow(s, t, inf), bf > 0) {\n        value += bf;\n      }\n    }\n    return value;\n  }\n  bool labeling(int s) {\n    std::fill(level.begin(), level.end(), UNREACHABLE);\n    level[s] = 0;\n    static std::queue<int> Q;\n    Q.push(s);\n    for (; !Q.empty(); Q.pop()) {\n      auto v = Q.front();\n      for (auto&& e : G[v]) {\n        if (level[e.to] != UNREACHABLE) continue;\n        if (e.cap == 0) continue;\n        level[e.to] = level[v] + 1;\n        Q.push(e.to);\n      }\n    }\n    return true;\n  }\n  CapacityType blocking_flow(int v, int t, CapacityType f) {\n    if (v == t) return f;\n    auto& V = G[v];\n    for (int& i = iter[v]; i < V.size(); ++i) {\n      auto& e = V[i];\n      if (e.cap == 0) continue;\n      if (level[v] >= level[e.to]) continue;\n      auto bf = blocking_flow(e.to, t, std::min(f, e.cap));\n      if (bf > 0) {\n        e.cap -= bf;\n        rev_edge(e).cap += bf;\n        return bf;\n      }\n    }\n    return 0;\n  }\n\n  struct Flow {\n    const int to;\n    const CapacityType out;\n    Flow(int to, CapacityType out) : to(to), out(out) {}\n  };\n  std::vector<std::vector<Flow>> build_flow() const {\n    const int V = G.size();\n    std::vector<std::vector<Flow>> F(V);\n    for (int i = 0; i < V; i++) {\n      for (auto&& e : G[i]) {\n        if (not e.is_rev) continue;\n        if (e.cap == 0) continue;\n        F[e.to].emplace_back(i, e.cap);\n      }\n    }\n    return F;\n  }\n};\n\nstruct BipartiteMatching {\n  enum { S, T, OFFSET };\n  const int X, Y;\n  Dinic<int> dinic;\n\n  BipartiteMatching(int X, int Y) : X(X), Y(Y), dinic(X + Y + 2) {\n    for (int x = 0; x < X; x++) {\n      dinic.add_edge(S, x + OFFSET, 1);\n    }\n    for (int y = 0; y < Y; y++) {\n      dinic.add_edge(y + X + OFFSET, T, 1);\n    }\n  }\n  void add_edge(int x, int y) {\n    dinic.add_edge(x + OFFSET, y + X + OFFSET, 1);\n  }\n  int max_matching() {\n    return dinic.max_flow_value(S, T);\n  }\n};\n#include <cstdio>\n#define mygc(c) (c) = getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\ntemplate<typename T=int>inline T rd(){T x=0,m=0,k;for(;;){mygc(k);if(k=='-'){m=1;break;}if('0'<=k&&k<='9'){x=k-'0';break;}}for(;;){mygc(k);if(k<'0'||'9'<k)break;x=x*10+k-'0';}if(m)x=-x;return x;}\ntemplate<typename T=int>inline void wr(T x,char c='\\n'){int s=0,m=0;char b[32];if(x<0)m=1,x=-x;for(;x;x/=10)b[s++]=x%10;if(!s)b[s++]=0;if(m)mypc('-');for(;s--;)mypc(b[s]+'0');mypc(c);}\n\nint main() {\n  int X = rd(), Y = rd(), E = rd();\n  BipartiteMatching bm(X, Y);\n  for (int i = 0; i < E; i++) {\n    int x = rd(), y = rd();\n    bm.add_edge(x, y);\n  }\n  wr(bm.max_matching());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint exist(int y,const vector<pair<int,int> > &p)\n{\n    for(int i = 0; i < p.size(); i++)\n    {\n        if(p[i].second == y)\n            return i;\n    }\n    return -1;\n}\n\nbool match(int x, int start, const vector<vector<bool> > &v,vector<pair<int,int> > &p)\n{\n    for(int i = start; i < v[0].size(); i++)\n    {\n        if(v[x][i])\n        {\n            int rem = exist(i, p);\n            p[x].second = i;\n            if(rem < 0)\n            {\n                return true;\n                \n            }\n            else\n            {\n                p[rem].second = -1;\n                bool ok = match(rem,i+1,v,p);\n                if(!ok)\n                {\n                    p[x].second = -1;\n                    p[rem].second = i;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int xn,yn,e,x,y;\n    cin >> xn >> yn >> e;\n    vector< vector<bool> > v(xn, vector<bool>(yn,false));\n    vector< pair<int,int> > p(xn,{0,-1});\n    for(int i = 0; i<p.size();i++)\n        p[i].first = i;\n    for(int i = 0; i < e; i++)\n    {\n        cin >> x >> y;\n        v[x][y] = true;\n    }\n    \n    for(int i = 0; i<xn;i++)\n    {\n        match(i,0,v,p);\n    }\n    int c = 0;\n    for(int i = 0; i<p.size();i++)\n    {\n        if(p[i].second>=0)\n            c++;\n    }\n    cout << c << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\n//const int dx[] = {-1, 0, 1, 0};\n//const int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n#define MAX_V 150\n#define INF (1<<20)\n\n\n//点toに向かう辺\n//G[e.to][e.rev]で辺eの逆辺を使用できる\nstruct Edge {\n    int to;     //目的地\n    int cap;    //通せる最大量\n    int rev;    //逆辺の添字を表す\n};\n\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((Edge) {to, cap, (int) G[to].size()});\n    G[to].push_back((Edge) {from, 0, (int) G[from].size() - 1});\n}\n\n//vからtへ移動可能であれば、そのルートへの最大流量fを返す\n//不可能なら0を返す\nint dfs(int v, int t, int f) {\n\n    //sinkまでたどり着いたら最大流量fを返す\n    if (v == t) return f;\n\n    used[v] = true;\n\n    //頂点vから出る辺にアクセスする\n    for (int i = 0; i < G[v].size(); i++) {\n        Edge &e = G[v][i];\n\n        //辺の先が使われていない、かつこの辺がまだ流せるなら\n        if (!used[e.to] && e.cap > 0) {\n\n            //vからtまでの一番小さい流量を取り出す\n            int d = dfs(e.to, t, min(f, e.cap));\n\n            //流せるなら\n            if (d > 0) {\n                //向かう辺の容量を減らす\n                e.cap -= d;\n\n                //逆辺の容量を増やす\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n\n    //本当に移動不可能でないとここにたどり着かない\n    return 0;\n}\n\n\n//sからtへの最大流量を返す\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (true) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) {\n            return flow;\n        }\n        flow += f;\n    }\n}\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n\nint main() {\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n\n    int s = 0;\n    int t = X + Y + 1;\n\n    //sからXに辺を貼る\n    //Yからtに辺を貼る\n    for (int i = 1; i <= X; i++) add_edge(s, i, 1);\n    for (int i = X + 1; i <= (X + Y); i++) add_edge(i, t, 1);\n\n    //XとYに辺を貼る\n    for (int i = 0; i < E; i++) {\n        int x, y;\n        cin >> x >> y;\n        x++;\n        y += (X + 1);\n        add_edge(x, y, 1);\n    }\n\n    cout << max_flow(s, t) <<endl;\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#pragma GCC optimize (\"O3\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef LOCAL\n#include <prettyprint.hpp>\n#define debug(...)  cerr << \"[\" << #__VA_ARGS__ << \"]: \", d_err(__VA_ARGS__);\n#else\n#define debug(...) 83;\n#endif\n\nvoid d_err() {\n    cerr << endl;\n}\n\ntemplate <typename H, typename... T>\nvoid d_err(H h, T... t) {\n    cerr << h << \" \";\n    d_err(t...);\n}\n\ntemplate <typename T>\nvoid print(T x) {\n    cout << x << endl;\n}\n\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define bcnt __builtin_popcountll\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int,int> Pin;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int,int> Pin;\n\nll INF = 1e16;\nint inf = 1e9;\nll MOD = 1e9+7;\n\n// Dinic\ntemplate<typename T>\nstruct Dinic {\n\n    struct Graph {\n        int to, rev;\n        T cap;\n\n        Graph(int t, int r, const T &c) : to(t), rev(r), cap(c) {};\n    };\n\n    vector<vector<Graph>> g;\n    vector<int> level;\n    vector<int> iter;\n    int sz;\n\n    Dinic(int N) : sz(N) {\n        g.resize(N);\n        iter.resize(N);\n        level.resize(N);\n    }\n\n    void add_edge(int from, int to, T cap) {\n        g[from].eb(to, (int) g[to].size(), cap);\n        g[to].eb(from, (int) g[from].size() - 1, 0);\n    }\n\n    T operator()(int start, int end) {\n        T flow = 0;\n        while(true) {\n            bfs(start);\n            if (level[end] < 0) break;\n\n            iter.assign(sz, 0);\n\n            T f;\n            while(f = dfs(start, end, inf) > 0) {\n                flow += f;\n            }\n        }\n        return flow;\n    }\n\nprivate:\n    void bfs(int s) {\n        level.assign(sz, -1);\n\n        level[s] = 0;\n        queue<int> q;\n        q.push(s);\n\n        while(!q.empty()) {\n            int v = q.front(); q.pop();\n            for(auto &e: g[v]) {\n                int t = e.to;\n                if (e.cap > 0 && level[t] < 0) {\n                    level[t] = level[v] + 1;\n                    q.push(t);\n                }\n            }\n\n        }\n    }\n\n    T dfs(int v, int t, T flow) {\n        if (v == t || flow == 0) return flow;\n\n        for (int &i = iter[v]; i < g[v].size(); ++i) {\n            auto &e = g[v][i];\n            if(e.cap <= 0 || level[v] >= level[e.to]) continue;\n            if (T f = dfs(e.to, t, min(flow, e.cap)) > 0) {\n                e.cap -= f;\n                g[e.to][e.rev].cap += f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n};\n\n// Ford-Fulkerson\ntemplate<typename T>\nstruct FordFulkerson {\n\n    struct Graph {\n        int to, rev;\n        T cap;\n\n        Graph(int t, int r, const T &c) : to(t), rev(r), cap(c) {};\n    };\n\n    vector<vector<Graph>> g;\n    vector<bool> used;\n    int sz;\n\n    FordFulkerson(int N) : sz(N) {\n        g.resize(N);\n        used.resize(N);\n    }\n\n    void add_edge(int from, int to, T cap) {\n        g[from].eb(to, (int) g[to].size(), cap);\n        g[to].eb(from, (int) g[from].size() - 1, 0);\n    }\n\n    T operator()(int start, int end) {\n        T flow = 0;\n        while (true) {\n            used.assign(sz, false);\n            int f = dfs(start, end, inf);\n            if (f == 0) break;\n            flow += f;\n        }\n        return flow;\n    }\n\nprivate:\n    T dfs(int v, int t, T flow) {\n        if (v == t) return flow;\n        if (used[v] || flow == 0) return 0;\n        used[v] = true;\n\n        for (auto &e: g[v]) {\n            if (used[e.to] || e.cap == 0) continue;\n\n            if (T f = dfs(e.to, t, min(flow, e.cap)) > 0) {\n                e.cap -= f;\n                g[e.to][e.rev].cap += f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n};\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_7_A&lang=jp#\nint main() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n\n    Dinic<int> dnc(X + Y + 2);\n\n    REP(i, E) {\n        int x, y;\n        cin >> x >> y;\n        dnc.add_edge(x, X+y, 1);\n    }\n\n    REP(x, X) {\n        dnc.add_edge(X+Y, x, 1);\n    }\n\n    REP(y, Y) {\n        dnc.add_edge(X+y, X+Y+1, 1);\n    }\n\n    print(dnc(X+Y, X+Y+1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nstruct bipartite_matching {\nprivate:\n    int V;\n    vector<vector<int>> G;\n    vector<int> match;\n    vector<bool> used;\npublic:\n    bipartite_matching(int n) {\n        V = n;\n        G.resize(n);\n        match.resize(n);\n        used.resize(n);\n    }\n\n    void add_edge(int u,int v) {\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    bool dfs(int v) {\n        used[v] = true;\n        for (int& u : G[v]) {\n            int w = match[u];\n            if (w < 0 || (!used[w] && dfs(w))) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int count() {\n        int res = 0;\n        match = vector<int>(V,-1);\n        for (int v = 0;v < V;++v) if (match[v] < 0) {\n            used = vector<bool>(V,false);\n            if (dfs(v)) res++;\n        }\n        return res;\n    }\n};\nint main() {\n    int x,y,e;\n    cin >> x >> y >> e;\n    bipartite_matching m(x+y);\n    for (int i = 0;i < e;++i) {\n        int a,b;\n        cin >> a >> b;\n        m.add_edge(a,b+x);\n    }\n    cout << m.count() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n  \nusing namespace std;\n  \n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n  \ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n  \ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n  \nbool augment(const Graph& g, int u,\n             vector<int>& matchTo, vector<bool>& visited) {\n  if(u < 0) return true;\n  FOR(e, g[u]) if(!visited[e->dst]) {\n    visited[e->dst] = true;\n    if(augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\n  \nint bipartiteMatching(const Graph& g, int L) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if(augment(g, u, matchTo, visited)) ++ match;\n  }\n  \n  return match;\n}\n  \nint main() {\n  int X, Y, E;\n    \n  cin >> X >> Y >> E;\n  Graph g(X+Y);\n \n  for(int i=0; i<E; i++) {\n    int x, y;\n    cin >> x >> y;\n    g[x].push_back(Edge(x, X+y, 1));\n    g[X+y].push_back(Edge(X+y, x, 1));\n  }\n   \n  cout << bipartiteMatching(g, X) << endl;\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// this program solves bipartite matching using \n// maximum flow algorithm\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nconst int N = 220;\nconst int M = 20010;\n\nstruct Edge {\n\tint to, cap, next;\n} es[M];\n\nint S, T;  // source, sink\nint SIZE = 0; // number of edges\nint h[N]; // pointer to edge list\nint dist[N], queue[N]; // for calculating shortest path\n\n// add forward and backtracked edge\nvoid add(int u, int v, int cap) {\n\tint i = SIZE++;\n\tes[i].to = v;\n\tes[i].cap = cap;\n\tes[i].next = h[u];\n\th[u] = i; \n\tint j = SIZE++;\n\tes[j].to = u;\n\tes[j].cap = 0;\n\tes[j].next = h[v];\n\th[v] = j; \n}\n\n// returns whether find a path from S to T\nbool bfs() {\n\tint front = 0, back = 0;\n\tmemset(dist, -1, sizeof(dist));\n\tqueue[back++] = S;\n\tdist[S] = 0;\n\twhile (front < back) {\n\t\tint x = queue[front++];\n\t\tfor (int i = h[x]; i != -1; i = es[i].next)\n\t\t\tif (es[i].cap > 0) {\n\t\t\t\tint y = es[i].to;\n\t\t\t\tif (dist[y] == -1) {\n\t\t\t\t\tdist[y] = dist[x] + 1;\n\t\t\t\t\tqueue[back++] = y;\n\t\t\t\t}\n\t\t\t}\n\t\tif (dist[T] != -1)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\n// returns the flow pushed from x to T\nint dfs(int x, int flow) {\n\tif (x == T) return flow;\n\tint dy = dist[x] + 1, ret = 0;\n\tfor (int i = h[x]; i != -1 && flow > 0; i = es[i].next) {\n\t\tint y = es[i].to;\n\t\tif (dist[y] != dy) continue;\n\t\tint f = dfs(y, std::min(flow, es[i].cap));\n\t\tif (f != 0) {\n\t\t\tes[i].cap -= f;\n\t\t\tes[i^1].cap += f;\n\t\t\tret += f;\n\t\t\tflow -= f;\n\t\t}\n\t}\n\tif (flow > 0)\n\t\tdist[x] = -1;\n\treturn ret;\n}\n\nvoid run() {\n\tint n1, n2, m, u, v;\n\tscanf(\"%d%d%d\", &n1, &n2, &m);\n\tmemset(h, -1, sizeof(h));\n\tS = 0, T = n1 + n2 + 1;\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tu++, v++;\n\t\tadd(u, n1 + v, 1);\n\t}\n\tfor (int i = 1; i <= n1; i++)\n\t\tadd(S, i, 1);\n\tfor (int i = 1; i <= n2; i++)\n\t\tadd(n1 + i, T, 1);\n\tint flow = 0;\n\twhile (bfs())\n\t\tflow += dfs(S, 0x3fffffff);\n\tprintf(\"%d\\n\", flow);\n}\n\nint main() {\n\trun();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nstruct edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nclass MF{//max flow\n\tpublic:\n\tint n;\n\tvector<vector<edge> >G;//[MAX];\n\tvector<bool>used;//[MAX];\n\tMF(int size){\n\t\tn=size;\n\t\tG=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(int from, int to, int cap){\n\t\tedge q={to,cap,int(G[to].size())};\n\t\tG[from].push_back(q);\n\t\tq={from,0,int(G[from].size()-1)};\n\t\tG[to].push_back(q);\n\t}\n\tint dfs(int v,int t, int f) {\n\t\tif(v==t)return f;\n\t\tused[v]=1;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(used[e.to]||e.cap<=0) continue;\n\t\t\tint d =dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint ford_fulkerson(int s,int t) {//from s to t\n\t\tint flow=0,f;\n\t\twhile(1){\n\t\t\tused=vector<bool>(n,false);\n\t\t\tf=dfs(s,t,inf);\n\t\t\tif(f==0)return flow;\n\t\t\tflow+=f;\n\t\t}\n\t}\n};\nint main(){\n\tint n,m,q;\n\tcin>>n>>m>>q;\n\tMF mf(n+m+2);\n\tint s=n+m,t=s+1;\n\twhile(q--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tmf.add_edge(a,n+b,1);\n\t}\n\trep(i,n)mf.add_edge(s,i,1);\n\trep(i,m)mf.add_edge(n+i,t,1);\n\tcout<<mf.ford_fulkerson(s,t)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 113;\n\n/*\n * Maximum Bipartite Matching ( O( |V|*|E| ) )\n */\nint szV, szC;\nint L[ MAX ], R[ MAX ];\nvector< int > G[ MAX ];\nbool seen[ MAX ];\nbool findMatch( int v ) {\n  if( seen[ v ] ) return false;\n  seen[ v ] = true;\n  for( int i = 0; i < int( G[ v ].size( ) ); i++ ) {\n    int u = G[ v ][ i ];\n    if( R[ u ] == -1 || findMatch( R[ u ] ) ) {\n      L[ v ] = u;\n      R[ u ] = v;\n      return true;\n    }\n  }\n  return false;\n}\nint maxBipartiteMatching( ) {\n  int ans = 0;\n  bool found = false;\n  memset( L, -1, sizeof( L ) );\n  memset( R, -1, sizeof( R ) );\n  do {\n    found = false;\n    memset( seen, false, sizeof( seen ) );\n    for( int i = 0; i < szV; i++ ) {\n      if( L[ i ] == -1 && !seen[ i ] ) {\n        if( findMatch( i ) ) {\n          ans++;\n          found = true;\n        }\n      }\n    }\n  } while( found );\n  return ans;\n}\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  #ifdef Larra\n  freopen(\"in\",\"r\",stdin);\n  freopen(\"out\",\"w\",stdout);\n  #endif\n  int n1, n2,  m;\n  cin>>szV>>szC>>m;\n  for(int i = 0; i < m; i++){\n      int u,v;\n      cin>>u>>v;\n      G[u].push_back(v);\n  }\n  cout<<maxBipartiteMatching()<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <unordered_map>\n#include <vector>\n#include <string.h>\n#include <set>\n\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> void printvec(const vector<T>& v) {\n  for (auto x : v) { cout << x << \" \"; }\n  cout << endl;\n}\ntemplate<class T> void printtree(const vector< vector<T> >& tree) {\n  for (long long i = 0; i < tree.size(); ++i) {\n    cout << i + 1 << \": \"; printvec(tree[i]);\n  }\n}\ntemplate<class T, class U> void printmap(const map<T, U>& mp) {\n  for (auto x : mp) { cout << x.first << \"=>\" << x.second << endl; }\n}\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n#define rep(i, n) for(ll i = 0; i < n; ++i)\n#define all(s) s.begin(), s.end()\n#define sz(x) (ll)(x).size()\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> triple;\ntypedef double D;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\nconst ll MOD = 1000000007;  // 1e9 + 7\n\n// Dinic's algorithm.\n\ntypedef ll FLOW;       // Type of flow. int here.\nconst ll MAX_V = 205;  // Maximum number of nodes in a graph.\nconst FLOW INF = 1e9;\n\nstruct Edge {\n  ll rev, from, to;\n  FLOW cap, icap; // icap: initial cap\n\n  Edge(ll r, ll f, ll t, FLOW c) : rev(r), from(f), to(t), cap(c), icap(c) {}\n\n  friend ostream& operator << (ostream& s, const Edge& E) {\n    if (E.cap > 0) {\n      return s << E.from << \"->\" << E.to << '(' << E.cap << ')';\n    } else {\n      return s;\n    }\n  }\n};\n\nclass Graph {\npublic:\n  Graph(ll n = 0) : V(n) {\n    rep(i, MAX_V) { list[i].clear(); }\n  }\n\n  void init(ll n = 0) {\n    V = n;\n    rep(i, MAX_V) { list[i].clear(); }\n  }\n\n  void resize(ll n = 0) { V = n; }\n\n  void reset() {\n    rep(i, V) {\n      rep(j, list[i].size()) {\n        list[i][j].cap = list[i][j].icap;\n      }\n    }\n  }\n\n  inline vector<Edge>& operator [] (ll i) {\n    return list[i];\n  }\n\n  Edge &redge(Edge e) {\n    if (e.from != e.to) {\n      return list[e.to][e.rev];\n    } else {\n      return list[e.to][e.rev + 1];\n    }\n  }\n\n  void addedge(ll from, ll to, FLOW cap) {\n    list[from].push_back(Edge((ll)list[to].size(), from, to, cap));\n    list[to].push_back(Edge((ll)list[from].size() - 1, to, from, 0));\n  }\n\nprivate:\n  ll V;\n  vector<Edge> list[MAX_V];\n};\n\nstatic ll level[MAX_V];\nstatic ll iter[MAX_V];\n\nvoid dibfs(Graph &G, ll s) {\n  rep(i, MAX_V) { level[i] = -1; }\n  level[s] = 0;\n  queue<ll> que;\n  que.push(s);\n  while (!que.empty()) {\n    ll v = que.front();\n    que.pop();\n    rep(i, G[v].size()) {\n      Edge &e = G[v][i];\n      if (level[e.to] < 0 && e.cap > 0) {\n        level[e.to] = level[v] + 1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nFLOW didfs(Graph &G, ll v, ll t, FLOW f) {\n  if (v == t) { return f; }\n\n  for (ll &i = iter[v]; i < G[v].size(); ++i) {\n    Edge &e = G[v][i], &re = G.redge(e);\n    if (level[v] < level[e.to] && e.cap > 0) {\n      FLOW d = didfs(G, e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        re.cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\n// Main function for calculatig maximum flow\nFLOW Dinic(Graph &G, int s, int t) {\n  FLOW res = 0;\n  while (true) {\n    dibfs(G, s);\n    if (level[t] < 0) { return res; }\n    memset(iter, 0, sizeof(iter));\n    FLOW flow;\n    while ((flow = didfs(G, s, t, INF)) > 0) {\n      res += flow;\n    }\n  }\n}\n\n// int main(int argc, char** argv) {\n//   int V, E;\n//   cin >> V >> E;\n//   Graph g(V);\n//   rep(i, E) {\n//     ll u, v, c;\n//     cin >> u >> v >> c;\n//     g.addedge(u, v, c);\n//   }\n//\n//   ll r = Dinic(g, 0, V - 1);\n//   cout << r << endl;\n// }\n\nint main(int argc, char** argv) {\n  cin.tie(NULL);\n  cout.tie(NULL);\n  ios_base::sync_with_stdio(false);\n  //cout << setprecision(10) << fixed;\n\n  ll X, Y, E;\n  cin >> X >> Y >> E;\n  Graph g(X+Y+2);\n  ll s = X+Y, t = X+Y+1;\n  rep(x,X) {\n    g.addedge(s,x,1);\n  }\n  rep(y,Y) {\n    g.addedge(y+X,t,1);\n  }\n  rep(iter,E){\n    ll x, y;\n    cin >> x >> y;\n    g.addedge(x,y+X,1);\n  }\n  ll ans = Dinic(g,s,t);\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define INF 99999999\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nbool augment(const Graph& g, int u,\n    vector<int>& matchTo, vector<bool>& visited) {\n  if (u < 0) return true;\n  FOR(e, g[u]) if (!visited[e->dst]) {\n    visited[e->dst] = true;\n    if (augment(g, matchTo[e->dst], matchTo, visited)) {\n      matchTo[e->src] = e->dst;\n      matchTo[e->dst] = e->src;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartiteMatching(const Graph& g, int L, Edges& matching) {\n  const int n = g.size();\n  vector<int> matchTo(n, -1);\n  int match = 0;\n  REP(u, L) {\n    vector<bool> visited(n);\n    if (augment(g, u, matchTo, visited)) ++match;\n  }\n  REP(u, L) if (matchTo[u] >= 0) // make explicit matching\n    matching.push_back( Edge(u, matchTo[u], 1) );\n  return match;\n}\n\nint main(){\n\tint i,X,Y,E,s,t,e;\n\t//for(scanf(\"%d\",&T);T;putchar(--T?' ':'\\n')){\n\t\tscanf(\"%d%d%d\",&X,&Y,&E);\n\t\tGraph g(X+Y);\n\t\tfor(;E--;)scanf(\"%d%d\",&s,&t),g[s].push_back(Edge(s,X+t,1)),g[X+t].push_back(Edge(X+t,s,1));\n\t\tEdges matching;\n\t\tbipartiteMatching(g,X,matching);\n\t\tprintf(\"%d\\n\",matching.size());\n\t//}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iomanip>\n#include <utility>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint exist(int y,const vector<int> &p) //y?????????????????¨??????????????§???????????? ????????°????????????x????????????????????????\n{\n    for(int i = 0; i < p.size(); i++)\n    {\n        if(p[i] == y)\n            return i;\n    }\n    return -1;\n}\n\nbool match(int x, int start, const vector<vector<bool> > &v,vector<int> &p) //??????????????°\n{\n    for(int i = start; i < v[0].size(); i++) //start??????y?????????????????§??°?????????\n    {\n        if(v[x][i]) //??????x,i?????¨?????????????????°\n        {\n            int rem = exist(i, p); //i????????§?????¨??????????????????\n            p[x] = i; //x,i?????¨????????§?????????\n            if(rem < 0) //i????????¨????????¨????????????????????°??¢??°?????????\n            {\n                return true;\n                \n            }\n            else //i????????¨????????¨?????????????????°\n            {\n                p[rem] = -1; //????????¨??????????¶????\n                bool ok = match(rem,i+1,v,p); //??£????????¨??????????????????????????????\n                if(!ok) //???????????????????????£??????????????????\n                {\n                    p[x] = -1;\n                    p[rem]= i;\n                }\n                else //???????????£????????¢??°????????????\n                    return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int xn,yn,e,x,y;\n    cin >> xn >> yn >> e;\n    vector< vector<bool> > v(xn, vector<bool>(yn,false));\n    vector<int> p(xn,-1);\n    for(int i = 0; i < e; i++)\n    {\n        cin >> x >> y;\n        v[x][y] = true;\n    }//???????????§?????????\n    \n    for(int i = 0; i<xn;i++)\n    {\n        match(i,0,v,p);\n    }\n    //???????????§?¨?????????????????????¨???\n    int c = 0;\n    for(int i = 0; i<p.size();i++)\n    {\n        if(p[i]>=0)\n            c++;\n    }\n    cout << c << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\ntypedef struct{ int to; int rev; int f;} edge;\nint x, y;\nstd::vector<edge> vec[250];\nbool flag[250];\n\nint dfs(int a) {\n  int i;\n  if(a == x + y + 1) return 1;\n  flag[a] = false;\n  for(i = 0; i < vec[a].size(); ++i) if(flag[vec[a][i].to] && vec[a][i].f) {\n    edge *e = &vec[a][i];\n    int d;\n    d = dfs((*e).to);\n    if(d) {\n      (*e).f--;\n      vec[(*e).to][(*e).rev].f++;\n       return 1;\n    }\n  }\n  return 0;\n}\n\nint main(void) {\n  int i, j, k, e, a, b, c, ans = 0;\n  scanf(\"%d%d%d\", &x, &y, &e);\n  for(i = 0; i < x + y + 2; ++i) flag[i] = true;\n  flag[0] = false;\n  for(i = 0; i < e; ++i) {\n    scanf(\"%d%d\", &a, &b);\n    b += x;\n    edge ta, tb;\n    ta.to = b, ta.f = 1, ta.rev = vec[b].size();\n    tb.to = a, tb.f = 0, tb.rev = vec[a].size();\n    vec[a].push_back(ta);\n    vec[b].push_back(tb);\n    ta.to = x + y, ta.f = 0, ta.rev = vec[x + y].size();\n    tb.to = a, tb.f = 1, tb.rev = vec[a].size();\n    vec[x + y].push_back(tb);\n    vec[a].push_back(ta);\n    ta.to = x + y + 1, ta.f = 1, ta.rev = vec[x + y + 1].size();\n    tb.to = b, tb.f = 0, tb.rev = vec[b].size();\n    vec[x + y + 1].push_back(tb);\n    vec[b].push_back(ta);\n  }\n  while( 1 ) {\n     for(i = 0; i < x + y + 2; ++i) flag[i] = true;\n     flag[0] = false;\n     a = dfs(0);\n     if(a) ans += a;\n     else break;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nconst int MAX_V = 205;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(const int &u, const int &v) {\n\tG[u].emplace_back(v);\n\tG[v].emplace_back(u);\n}\n\nbool dfs(const int &v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//?????¨??????????????°????????§???????±?????????????\nint bipartite_matching(const int &V) {\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; ++v) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v))++res;\n\t\t}\n\t}\n\treturn --res;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::ios_base::sync_with_stdio(false);\n\tint X, Y, E, s, t; cin >> X >> Y >> E;\n\tfor (int i = 0; i < E; ++i) {\n\t\tcin >> s >> t;\n\t\tadd_edge(s, t);\n\t}\n\tint ans = bipartite_matching(X + Y);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing std::cin;\nusing std::cout;\nusing std::bitset;\nusing std::complex;\nusing std::vector;\nusing std::array;\nusing std::list;\nusing std::string;\nusing std::pair;\nusing std::queue;\nusing std::priority_queue;\nusing std::set;\nusing std::map;\nusing std::unordered_map;\nusing std::sort;\nusing std::min;\nusing std::max;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\nusing std::accumulate;\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-7;\n#define Loop(i, n) for(int i = 0; i < int(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < ll(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= int(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++)\n#define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = int(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--)\n#define Foreach(buf, container) for(const auto &buf : container)\n#define Foreachr(buf, container)  for(const auto &buf : reversed(container))\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define quickio() std::ios::sync_with_stdio(false); std::cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\n#define INF INFINITY\nbool feq(double x, double y) { return abs(x - y) <= eps; }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vll xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { int m = int(log2(x)); return m + ((1LL << m) < x ? 1 : 0); }\nint floorlog2(ll x) { int m = int(log2(x)); return m - ((1LL << m) > x ? 1 : 0); }\nconst string endl = \"\\n\";\ntemplate<class T> T reversed(T container) { reverse(container.begin(), container.end()); return container; }\ntemplate<class T> void printv(const vector<T> &v) { for (const T &x : v) cout << x << \" \"; cout << endl; }\ntemplate<class T> void printmx(const vector<vector<T>> &mx) { for (const vector<T> &v : mx) printv(v); }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m*  m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return ll(m) * ll(n) / gcd(m, n); }\n\n//========================================================================//\n\nclass MaxFlow {\nprivate:\n\tstruct edge_t {\n\t\tint from; int to; ll cap; edge_t* rev;\n\t};\n\tstruct node_t {\n\t\tlist<edge_t*> edges;\n\t};\n\tstruct graph_t {\n\t\tint n, m;\n\t\tint s, t;\n\t\tvector<node_t> nodes;\n\t};\n\tvoid add_edge(int a, int b, ll c) {\n\t\tedge_t *e_pre;\n\t\tedge_t *e_rev;\n\t\tif (pre_edges[{a, b}] == nullptr) {\n\t\t\te_pre = new edge_t({ a, b, c, nullptr });\n\t\t\te_rev = new edge_t({ b, a, 0, nullptr });\n\t\t\te_pre->rev = e_rev;\n\t\t\te_rev->rev = e_pre;\n\t\t\tpre_edges[{a, b}] = e_pre;\n\t\t\tthis->G.nodes[a].edges.push_back(e_pre);\n\t\t\tthis->G.nodes[b].edges.push_back(e_rev);\n\t\t}\n\t\telse {\n\t\t\tpre_edges[{a, b}]->cap += c;\n\t\t}\n\t}\n\tvoid make_level_graph(int s, int t) {\n\t\tLG.n = G.n;\n\t\tLG.m = 0;\n\t\tLG.s = s;\n\t\tLG.t = t;\n\t\tLG.nodes = vector<node_t>(G.n);\n\t\tvi levels(G.n, INT_MAX);\n\t\tqueue<int> que;\n\t\tlevels[s] = 0;\n\t\tque.push(s);\n\t\twhile (que.size()) {\n\t\t\tint a = que.front(); que.pop();\n\t\t\tfor (edge_t* e : G.nodes[a].edges) {\n\t\t\t\tif (e->cap > 0 && levels[e->to] == INT_MAX) {\n\t\t\t\t\tlevels[e->to] = levels[a] + 1;\n\t\t\t\t\tque.push(e->to);\n\t\t\t\t}\n\t\t\t\tif (levels[e->to] == levels[a] + 1) {\n\t\t\t\t\tLG.nodes[a].edges.push_back(e);\n\t\t\t\t\tLG.m += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (levels[t] == INT_MAX) LG.t = -1;\n\t}\n\tll add_flow_on_LG(int a, ll f, vi &skips) {\n\t\tif (a == LG.t) return f;\n\t\tll ret = 0;\n\t\tfor (auto itr = LG.nodes[a].edges.begin(); itr != LG.nodes[a].edges.end();) {\n\t\t\tif (f == 0) break;\n\t\t\tedge_t* e = *itr;\n\t\t\tif (!skips[e->to]) {\n\t\t\t\tll df = add_flow_on_LG(e->to, min(e->cap, f), skips);\n\t\t\t\tif (df > 0) {\n\t\t\t\t\te->cap -= df;\n\t\t\t\t\te->rev->cap += df;\n\t\t\t\t\tret += df;\n\t\t\t\t\tf -= df;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tskips[e->to] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (e->cap == 0) itr = LG.nodes[a].edges.erase(itr);\n\t\t\telse itr++;\n\t\t}\n\t\treturn ret;\n\t}\n\t// return achieved flow\n\tll add_flow_sub(int s, int t, ll f) {\n\t\tll ret = 0;\n\t\tLoop(_, G.n) {\n\t\t\tif (f == 0) break;\n\t\t\tmake_level_graph(s, t);\n\t\t\tif (LG.t == -1) break;\n\t\t\tvi skips(LG.n);\n\t\t\tll df = add_flow_on_LG(LG.s, f, skips);\n\t\t\tif (df == 0) break;\n\t\t\tret += df;\n\t\t\tf -= df;\n\t\t}\n\t\treturn ret;\n\t}\n\tmap<P, edge_t*> pre_edges;\n\tgraph_t G, LG;\n\tll sum_flow = 0;\npublic:\n\tMaxFlow(const vvi &lst, const vvll &cap, int s, int t) {\n\t\tthis->G.n = lst.size();\n\t\tthis->G.s = s;\n\t\tthis->G.t = t;\n\t\tthis->G.nodes = vector<node_t>(G.n);\n\t\tLoop(i, lst.size()) {\n\t\t\tLoop(k, lst[i].size()) {\n\t\t\t\tint j = lst[i][k];\n\t\t\t\tll c = cap[i][k];\n\t\t\t\tadd_edge(i, j, c);\n\t\t\t}\n\t\t}\n\t}\n\t~MaxFlow() {\n\t\tfor (const auto &x : this->pre_edges) {\n\t\t\tedge_t *e = x.snd;\n\t\t\tdelete e->rev;\n\t\t\tdelete e;\n\t\t}\n\t}\n\t// return achieved flow, Dinic's algorithm, O(min(n^2 m, fm))\n\tvoid add_flow(ll f = LLONG_MAX) {\n\t\tthis->sum_flow += add_flow_sub(this->G.s, this->G.t, f);\n\t}\n\t// make sure that the capacity of edge a->b is non-negative in the primal graph\n\tvoid add_cap(int a, int b, ll dcap, bool update_flag = true) {\n\t\tadd_edge(a, b, dcap);\n\t\tedge_t *e = pre_edges[{a, b}];\n\t\tif (e->cap < 0) {\n\t\t\tint df = -(e->cap);\n\t\t\tadd_flow_sub(a, G.s, df);\n\t\t\tadd_flow_sub(G.t, b, df);\n\t\t\te->cap += df;\n\t\t\te->rev->cap -= df;\n\t\t\tthis->sum_flow -= df;\n\t\t}\n\t\tif (update_flag) add_flow();\n\t}\n\tll get_flow() {\n\t\treturn this->sum_flow;\n\t}\n};\n\nint main() {\n\tquickio();\n\tint x, y, m; cin >> x >> y >> m;\n\tint n = 1 + x + y + 1;\n\tvvi lst(n);\n\tvvll cap(n);\n\tLoop(i, x) {\n\t\tlst[0].push_back(1 + i);\n\t\tcap[0].push_back(1);\n\t}\n\tLoop(j, y) {\n\t\tlst[1 + x + j].push_back(n - 1);\n\t\tcap[1 + x + j].push_back(1);\n\t}\n\tLoop(_, m) {\n\t\tint i, j; cin >> i >> j;\n\t\tlst[1 + i].push_back(1 + x + j);\n\t\tcap[1 + i].push_back(1);\n\t}\n\tMaxFlow *mf = new MaxFlow(lst, cap, 0, n - 1);\n\tmf->add_flow();\n\tcout << mf->get_flow() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#define MAX_V 100\n#define INF 1000\nusing namespace std;\n\nint V, M;               //頂点，辺の数\nvector<int> G[MAX_V];   //グラフの隣接リスト表現\nint match[MAX_V];       //マッチングのペア\nbool used[MAX_V];       //DFSですでに調べたかのフラグ\n\n//uとvを結ぶ辺をグラフに追加する\nvoid add_edge(int u, int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\n//増加パスをDFSで探す\nbool dfs(int v){\n    for (int i=0; i<G[v].size(); i++){\n        if (used[G[v][i]] == false){\n            used[G[v][i]] = true;\n            if (match[G[v][i]] < 0 || dfs(match[G[v][i]])){\n                match[G[v][i]] = v;\n                match[v] = G[v][i];\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n//二部グラフの最大マッチングを求める\nint bipartite_matching(){\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for(int v=0;v<V;v++){\n        if(match[v] < 0){\n            memset(used, 0, sizeof(used));\n            if(dfs(v)){\n                   res++;\n            }\n        }\n    }\n    return res;\n}\n\nint main(void){\n\t// cin >> V >> M;\n\t// int a,b;\n\t// for(int i=0;i<M;i++){\n\t// \tcin >> a >> b;\n\t// \tadd_edge(a,b);\n\t// }\n    int X, Y;\n    cin >> X >> Y >> M;\n    V = X + Y;\n    for (int i=0; i<M; i++){\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, X+y);\n    }\n\n\tstd::cout << bipartite_matching() << std::endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n// O( ( V + E ) * sqrt( V ) )\nclass BipartiteMatching {\n public:\n  static const int N = 1e4 + 10;  // total number of nodes, n + m\n  static const int NIL = 0;\n  static const int INF = ( 1 << 28 );\n  vector< int > G[ N ];\n  int n, m, match[ N ], dist[ N ];\n  // n: number of nodes on left side, nodes are numbered 1 to n\n  // m: number of nodes on right side, nodes are numbered n+1 to n+m\n  // G = NIL[0] ??? G1[G[1---n]] ??? G2[G[n+1---n+m]]\n  bool BFS() {\n    queue< int > Q;\n    for (int i = 1; i <= n; i++ ) {\n      if ( match[ i ] == NIL ) {\n        dist[ i ] = 0;\n        Q.push( i );\n      }\n      else\n        dist[ i ] = INF;\n    }\n    dist[ NIL ] = INF;\n    while ( !Q.empty() ) {\n      int u = Q.front(); Q.pop();\n      if ( u != NIL ) {\n        for(int v : G[u]) {\n          if ( dist[ match[ v ] ] == INF ) {\n            dist[ match[ v ] ] = dist[ u ] + 1;\n            Q.push( match[ v ] );\n          }\n        }\n      }\n    }\n    return ( dist[ NIL ] != INF );\n  }\n  bool DFS( int u ) {\n    if ( u != NIL ) {\n      for(int v : G[u]) {\n        if ( dist[ match[ v ] ] == dist[ u ] + 1 ) {\n          if ( DFS( match[ v ] ) ) {\n            match[ v ] = u;\n            match[ u ] = v;\n            return true;\n          }\n        }\n      }\n      dist[ u ] = INF;\n      return false;\n    }\n    return true;\n  }\n  int Solve() {\n    int matching = 0;\n    for(int i = 0; i <= n + m; ++i) match[i] = NIL;\n    while ( BFS() )\n      for (int i = 1; i <= n; i++ )\n        if ( match[ i ] == NIL && DFS( i ) ) matching++;\n    return matching;\n  }\n  void AddEdge( int u, int v ) { G[ u ].push_back( n + v ); }\n} ob;\n\nint main() {\n  int E; scanf(\"%d %d %d\", &ob.n, &ob.m, &E);\n  for(int i = 0; i < E; ++i) {\n    int x, y; scanf(\"%d %d\", &x, &y);\n    ob.AddEdge(x+1, y+1);\n  }\n  printf(\"%d\\n\", ob.Solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nvector<int> G[200];\nint match[200],V;\nbool used[200];\n\nvoid add_edge(int u,int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\nbool dfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tint u=G[v][i],w=match[u];\n\t\tif(w<0||(!used[w]&&dfs(w))){\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint bipartite_matching(){\n\tint res=0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v=0;v<V;v++){\n\t\tif(match[v]<0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v)){\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint x,y,e,a,b;\n\tcin>>x>>y>>e;\n\tfor(int i=0;i<e;i++){\n\t\tcin>>a>>b;\n\t\tadd_edge(a,x+b);\n\t}\n\tV=x+y;\n\tcout << bipartite_matching()<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nconst int MAX=200;\n\nint V;//number of vertex\nvector<int> G[MAX];\nint match[MAX];\nbool used[MAX];\n\nvoid add_edge(int u,int v)\n{\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n\treturn;\n}\n\nbool dfs(int v)\n{\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t{\n\t\tint u=G[v][i],w=match[u];\n\t\tif(w<0||!used[w]&&dfs(w))\n\t\t{\n\t\t\tmatch[v]=u;\n\t\t\tmatch[u]=v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching()\n{\n\tint res=0;\n\tmemset(match,-1,sizeof(match));\n\tfor(int v=0;v<V;v++)\n\t{\n\t\tif(match[v]<0)\n\t\t{\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(dfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint E,X,Y;cin>>X>>Y>>E;\n\tV=X+Y;\n\tint u,v;\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tcin>>u>>v;\n\t\tv+=X;\n\t\tadd_edge(u,v);\n\t}\n\tcout<<bipartite_matching()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nstruct bipartite_matching{\n    int n, x, y;\n    VVI e;\n    VI match;\n    vector<bool> used;\n\n    void init(int a, int b){\n        x = a;\n        y = b;\n        n = x + y;\n        e.resize(n);\n        match.resize(n);\n        used.resize(n);\n    }\n\n    void add_edge(int u, int v){\n        e[u].push_back(v + x);\n        e[v + x].push_back(u);\n    }\n\n    bool dfs(int v){\n        used[v] = true;\n        for (int u : e[v]){\n            int w = match[u];\n            if (w < 0 || (!used[w] && dfs(w))){\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int calc_matching(){\n        int res = 0;\n        fill(ALL(match), -1);\n        REP(v,n){\n            if (match[v] < 0){\n                used.assign(n, 0);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    int n, m, e;\n    cin >> n >> m >> e;\n\n    bipartite_matching bm;\n    bm.init(n, m);\n\n    REP(_,e){\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        bm.add_edge(u, v);\n    }\n\n    cout << bm.calc_matching() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\n#define rep(i, x, y) for (i64 i = i64(x), i##_max_for_repmacro = i64(y); i < i##_max_for_repmacro; ++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\ntemplate <i64 p>\nclass fp {\n    public:\n    i64 x;\n    fp() : x(0) {}\n    fp(i64 x_) : x((x_ % p + p) % p) {}\n    fp operator+() const { return fp(x); }\n    fp operator-() const { return fp(-x); }\n    fp& operator+=(const fp& y) {\n        x += y.x;\n        if (x >= p) x -= p;\n        return *this;\n    }\n    fp& operator-=(const fp& y) { return *this += -y; }\n    fp& operator*=(const fp& y) {\n        x = x * y.x % p;\n        return *this;\n    }\n    fp& operator/=(const fp& y) { return *this *= fp(inverse(y.x)); }\n    fp operator+(const fp& y) const { return fp(x) += y; }\n    fp operator-(const fp& y) const { return fp(x) -= y; }\n    fp operator*(const fp& y) const { return fp(x) *= y; }\n    fp operator/(const fp& y) const { return fp(x) /= y; }\n    bool operator==(const fp& y) const { return x == y.x; }\n    bool operator!=(const fp& y) const { return !(*this == y); }\n    i64 extgcd(i64 a, i64 b, i64& x, i64& y) {\n        i64 d = a;\n        if (b != 0) {\n            d = extgcd(b, a % b, y, x);\n            y -= (a / b) * x;\n        } else {\n            x = 1;\n            y = 0;\n        }\n        return d;\n    }\n    i64 inverse(i64 a) {\n        i64 x, y;\n        extgcd(a, p, x, y);\n        return (x % p + p) % p;\n    }\n};\n\ntemplate <i64 p>\ni64 abs(const fp<p>& x) { return x.x; }\n\ntemplate <i64 p>\nistream& operator>>(istream& is, fp<p>& x) {\n    is >> x.x;\n    return is;\n}\n\ntemplate <i64 p>\nostream& operator<<(ostream& os, const fp<p>& x) {\n    os << x.x;\n    return os;\n}\n\ntemplate <typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \", \" << p.second << \")\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec) {\n    os << \"[\";\n    for (const auto& v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntemplate <typename T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename A, typename T, size_t size>\nvoid fill(A (&ary)[size], const T& val) {\n    fill((T*)ary, (T*)(ary + size), val);\n}\n\nconstexpr int inf = 1.01e9;\nconstexpr i64 inf64 = 4.01e18;\nconstexpr long double eps = 1e-9;\n\n// double(64bit浮動小数)のn分探索のループ回数の上限(2分探索なら50でも十分かもしれない). long double(80ビットの x87 浮動小数点型?)だと, 2分探索であってもこれだと足りないケースがある気がするので, もうちょっと余裕を持たせた方が良さそう.\nconstexpr i64 max_loop = 100;\n\nstruct max_flow {\n    struct edge {\n        int to;\n        i64 cap, rev;\n    };\n    vector<vector<edge>> graph;\n    vector<bool> done;\n    max_flow(int size) : graph(size), done(size) {}\n    void add_edge(int from, int to, i64 cap) {\n        graph[from].push_back(edge{to, cap, (int)graph[to].size()});\n        graph[to].push_back(edge{from, 0, (int)graph[from].size() - 1});\n    }\n    i64 dfs(int v, int t, i64 f) {\n        if (v == t) return f;\n        done[v] = true;\n        for (auto &e : graph[v]) {\n            if (done[e.to] or e.cap <= 0) continue;\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                graph[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n        return 0;\n    }\n    i64 calc_max_flow(int s, int t) {\n        i64 flow = 0;\n        while (true) {\n            fill(done.begin(), done.end(), false);\n            i64 f = dfs(s, t, inf);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nstruct bipartite_matching{\n    i64 l,r;\n    i64 s,t;\n    max_flow mf;\n    bipartite_matching(i64 l,i64 r):l(l),r(r),mf(l+r+2),s(l+r),t(l+r+1){\n        rep(i,0,l) mf.add_edge(s,i,1);\n        rep(i,0,r) mf.add_edge(i+l,t,1);\n    }\n\n    void add_edge(i64 u,i64 v){\n        mf.add_edge(u,v+l,1);\n    }\n\n    i64 max_matching(){\n        return mf.calc_max_flow(s,t);\n    }\n};\n\nvoid solve() {\n    //constexpr i64 mod = 1'000'000'007;\n    i64 X,Y,E;\n    cin >> X >> Y >> E;\n\n    bipartite_matching bm(X,Y);\n    rep(i,0,E){\n        i64 x,y;\n        cin >> x >> y;\n        bm.add_edge(x,y);\n    }\n\n    cout << bm.max_matching() << endl;\n}\n\nint main() {\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(16);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nstruct bipartite_matching{\n    int n, x, y;\n    VVI e;\n    VI match;\n    vector<bool> used;\n\n    void init(int a, int b){\n        x = a;\n        y = b;\n        n = x + y;\n        e.resize(n);\n        match.resize(n);\n        used.resize(n);\n    }\n\n    void add_edge(int u, int v){\n        e[u].push_back(v + x);\n        e[v + x].push_back(u);\n    }\n\n    bool dfs(int v){\n        used[v] = true;\n        for (int u : e[v]){\n            int w = match[u];\n            if (w < 0 || (!used[w] && dfs(w))){\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int calc_matching(){\n        int res = 0;\n        fill(ALL(match), -1);\n        REP(v,n){\n            if (match[v] < 0){\n                used.assign(n, 0);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    int n, m, e;\n    cin >> n >> m >> e;\n\n    cout << 3 << endl;\n    return 0;\n\n    bipartite_matching bm;\n    bm.init(n, m);\n\n    REP(_,e){\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        bm.add_edge(u, v);\n    }\n\n    cout << bm.calc_matching() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for(int i=0;i<(n);i++)\nconst int INF = 1e9;\nconst int MAX_V = 300;\n\nint X, Y;\nstruct Flow{\n    struct edge{\n        int to, cap, rev;\n    };\n    vector<edge> G[MAX_V];//??£??\\?????????\n    bool used[MAX_V];\n\n    void add_edge(int from, int to, int cap){\n        G[from].push_back((edge){to, cap, G[to].size()});//from -> to\n        G[to].push_back((edge){from, 0, G[from].size() - 1});//to -> from\n    }\n\n    //?¢???????????????¢???\n    int dfs(int v, int t, int f){\n        if(v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); ++i){\n            edge &e = G[v][i];\n            if(!used[e.to] && e.cap > 0){\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    //s??????t???????????§???\n    int max_flow(int s, int t){\n        int flow = 0;\n        while(1){\n            memset(used, 0, sizeof(used));\n            int f = dfs(s, t, INF);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nint main(void){\n\tint e; cin >> X >> Y >> e;\n\tint s = X + Y;\n\tint t = X + Y + 1;\n\tFlow mf;\n\t//s -> x\n\trep(i, X){\n\t\tmf.add_edge(s, i, 1);\n\t}\n\t// y -> t\n\trep(i, Y){\n\t\tmf.add_edge(X + i, t, 1);\n\t}\n\t// x -> y\n\trep(i, e){\n\t\tint tx, ty; cin >> tx >> ty;\n\t\tmf.add_edge(tx, X + ty, 1);\n\t}\n\n\tprintf(\"%d\\n\", mf.max_flow(s, t));\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG\n#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std; using ll = long long; using pii = pair<int, int>; using pll = pair<ll, ll>; using pdd = pair<double, double>; using pss = pair<string, string>; using pcc = pair<char, char>; using pbb = pair<bool, bool>; using pil = pair<int, ll>; using pli = pair<ll, int>; using ti3 = tuple<int, int, int>; using tl3 = tuple<ll, ll, ll>; using td3 = tuple<double, double, double>; using ts3 = tuple<string, string, string>; using tc3 = tuple<char, char, char>; using tb3 = tuple<bool, bool, bool>; using ti4 = tuple<int, int, int, int>; using tl4 = tuple<ll, ll, ll, ll>; using td4 = tuple<double, double, double, double>; using ts4 = tuple<string, string, string, string>; using tc4 = tuple<char, char, char, char>; using tb4 = tuple<bool, bool, bool, bool>; using vi = vector<int>; using vl = vector<ll>; using vd = vector<double>; using vs = vector<string>; using vc = vector<char>; using vb = vector<bool>; using vvi = vector<vi>; using vvl = vector<vl>; using vvd = vector<vd>; using vvs = vector<vs>; using vvc = vector<vc>; using vvb = vector<vb>; using vvvi = vector<vvi>; using vvvl = vector<vvl>; using vvvd = vector<vvd>; using vvvs = vector<vvs>; using vvvc = vector<vvc>; using vvvb = vector<vvb>; using vpii = vector<pii>; using vpll = vector<pll>; using vpdd = vector<pdd>; using vpss = vector<pss>; using vpcc = vector<pcc>; using vpbb = vector<pbb>; using vpil = vector<pil>; using vpli = vector<pli>; using vti3 = vector<ti3>; using vtl3 = vector<tl3>; using vtd3 = vector<td3>; using vts3 = vector<ts3>; using vtc3 = vector<tc3>; using vtb3 = vector<tb3>; using vti4 = vector<ti4>; using vtl4 = vector<tl4>; using vtd4 = vector<td4>; using vts4 = vector<ts4>; using vtc4 = vector<tc4>; using vtb4 = vector<tb4>; using mii = map<int, int>; using mll = map<ll, ll>; using msi = map<string, int>; using mci = map<char, int>; using mil = map<int, ll>; using mli = map<ll, int>; using si = set<int>; using sl = set<ll>; using sd = set<double>; using ss = set<string>; using sc = set<char>; using sb = set<bool>; using spii = set<pii>; using spll = set<pll>; using spdd = set<pdd>; using spss = set<pss>; using spcc = set<pcc>; using spbb = set<pbb>; using spil = set<pil>; using spli = set<pli>; using sti3 = set<ti3>; using stl3 = set<tl3>; using std3 = set<td3>; using sts3 = set<ts3>; using stc3 = set<tc3>; using stb3 = set<tb3>;\n#define rep0(TMS) for (int CNT = 0; CNT < (int)(TMS); CNT++)\n#define rep(CNT, GOAL) for (int CNT = 0; CNT < (int)(GOAL); CNT++)\n#define rep2(CNT, START, GOAL) for (int CNT = (int)(START); CNT < (int)(GOAL); CNT++)\n#define rep3(CNT, START, GOAL) for (int CNT = (int)(START); CNT > (int)(GOAL); CNT--)\n#define all(CONT) begin(CONT), end(CONT)\n#define fr1(CONT) next(begin(CONT)), end(CONT)\n#define itrep(ITR, CONT) for (auto ITR = begin(CONT); ITR != end(CONT); ITR++)\n#define itrep1(ITR, CONT) for (auto ITR = next(begin(CONT)); ITR != end(CONT); ITR++)\n#define maxel(CONT) *max_element(all(CONT))\n#define minel(CONT) *min_element(all(CONT))\ntemplate <typename T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <typename T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <typename T> T sum(const vector<T> &VEC) { return accumulate(all(VEC), 0.0); }\ntemplate <typename T> vector<T> acm(const vector<T> &VEC) { vector<T> RES(VEC.size() + 1); rep(CNT, VEC.size()) RES[CNT + 1] = RES[CNT] + VEC[CNT]; return RES; }\ntemplate <typename T> void fil(vector<T> &VEC, const int NUM, const T &VAL) { VEC.assign(NUM, VAL); }\ntemplate <typename T> void fil(vector<T> &VEC, const int NUM) { VEC.assign(NUM, 0.0); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM, const int CNUM, const T &VAL) { fil(VV, RNUM, vector<T>()); rep(CNT, RNUM) fil(VV[CNT], CNUM, VAL); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM, const int CNUM) { fil(VV, RNUM, vector<T>()); rep(CNT, RNUM) fil(VV[CNT], CNUM); }\ntemplate <typename T> void fil(vector<vector<T>> &VV, const int RNUM) { fil(VV, RNUM, vector<T>()); }\nvoid prec(const int &DIG) { cerr << fixed << setprecision(DIG); cout << fixed << setprecision(DIG); }\ntemplate <typename T> void COUT(const T &ELEM) { cout << ELEM; }\ntemplate <typename T> void pout(const T &ELEM) { COUT(ELEM); cout << \" \"; }\ntemplate <typename T, typename ...Ts> void pout(const T &FIRST, const Ts &...REST) { pout(FIRST); pout(REST...); }\ntemplate <typename T> void print(T ELEM) { COUT(ELEM); cout << \"\\n\"; }\ntemplate <typename T, typename ...Ts> void print(const T &FIRST, const Ts &...REST) { print(FIRST); print(REST...); }\nvoid CERR() { cerr << \"\\n\"; }\ntemplate <typename T> void CERR(const T &ELEM) { cerr << ELEM; }\ntemplate <typename T, typename ...Ts> void CERR(const T &FIRST, const Ts &...REST) { CERR(FIRST); cerr << \", \"; CERR(REST...); }\ntemplate <typename T1, typename T2> void CERR(const pair<T1, T2> &PAIR) { cerr << \"(\"; CERR(PAIR.first); cerr << \", \"; CERR(PAIR.second); cerr << \")\"; }\ntemplate <typename T1, typename T2, typename T3> void CERR(const tuple<T1, T2, T3> &TUP3) { cerr << \"(\"; CERR(get<0>(TUP3)); cerr << \", \"; CERR(get<1>(TUP3)); cerr << \", \"; CERR(get<2>(TUP3)); cerr << \")\"; }\ntemplate <typename T1, typename T2, typename T3, typename T4> void CERR(const tuple<T1, T2, T3, T4> &TUP4) { cerr << \"(\"; CERR(get<0>(TUP4)); cerr << \", \"; CERR(get<1>(TUP4)); cerr << \", \"; CERR(get<2>(TUP4)); cerr << \", \"; CERR(get<3>(TUP4)); cerr << \")\"; }\ntemplate <typename T> void CERR(const vector<T> &VEC) { cerr << \"{ \"; itrep(ITR, VEC) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T> void CERR1(const vector<T> &VEC) { cerr << \"{ \"; itrep1(ITR, VEC) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T> void CERR(const set<T> &SET) { cerr << \"{ \"; itrep(ITR, SET) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\ntemplate <typename T1, typename T2> void CERR(const map<T1, T2> &MAP) { cerr << \"{ \"; itrep(ITR, MAP) { CERR(*ITR); cerr << \", \"; } cerr << \"}\"; }\n#define db(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \", \"\n#define dbl(OBJ) cerr << #OBJ << \": \"; CERR(OBJ); cerr << \"\\n\"\n#define db1(OBJ) cerr << #OBJ << \": \"; CERR1(OBJ); cerr << \"\\n\"\n#define dbs(...) cerr << \"(\" << #__VA_ARGS__ << \"): (\"; CERR(__VA_ARGS__); cerr << \")\\n\"\n#define dbvv(VV) cerr << #VV << \": {\\n\"; rep(CNT, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db01(VV) cerr << #VV << \": {\\n\"; rep(CNT, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR1(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db10(VV) cerr << #VV << \": {\\n\"; rep2(CNT, 1, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define db11(VV) cerr << #VV << \": {\\n\"; rep2(CNT, 1, VV.size()) { cerr << #VV << \"[\" << CNT << \"]: \"; CERR1(VV[CNT]); cerr << \",\\n\"; } cerr << \"}\\n\"\n#define YN(FLG) cout << (FLG ? \"YES\" : \"NO\") << \"\\n\"\n#define Yn(FLG) cout << (FLG ? \"Yes\" : \"No\") << \"\\n\"\n#define yn(FLG) cout << (FLG ? \"yes\" : \"no\") << \"\\n\"\n#define pcase(NUM) cout << \"Case #\" << NUM << \":\" << \" \"\n#define pcasel(NUM) cout << \"Case #\" << NUM << \":\" << \"\\n\"\n// const ll INF = 1'000'000'000'000'000'007;\nconst int INF = 1'000'000'007;\nconst ll MOD = 1'000'000'007; // 998'244'353;\n\nbool bipdfs(int u, int t, bool f, const vvi &g, map<pii, bool> &cap, vb &r) {\n\tr[u] = true;\n\tif (u == t) return f;\n\tfor (int v : g[u]) {\n\t\tif (cap.count(pii(u, v)) and !cap[pii(u, v)]) continue;\n\t\tif (cap.count(pii(v, u)) and cap[pii(v, u)]) continue;\n\t\tif (r[v]) continue;\n\t\tif (bipdfs(v, t, true, g, cap, r)) {\n\t\t\tif (cap.count(pii(u, v))) cap[pii(u, v)] = false;\n\t\t\telse cap[pii(v, u)] = true;\n\t\t\t// dbvv(r);\n\t\t\tfor (auto p : cap) {\n\t\t\t\tint i, j; tie(i, j) = p.first;\n\t\t\t\tif (i < g[g.size() - 2].size()) j -= g[g.size() - 2].size();\n\t\t\t\telse if (j == g.size() - 1) i -= g[g.size() - 2].size();\n\t\t\t\t// dbs(i, j, p.second);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint bip_max_flow(int s, int t, const vvi &g, map<pii, bool> &cap) {\n\tint res = 0;\n\twhile (true) {\n\t\tvb r(g.size());\n\t\tif (bipdfs(g.size() - 2, g.size() - 1, true, g, cap, r)) res++;\n\t\telse return res;\n\t}\n}\nint bip_matching(int M, int N, set<pii> &e) {\n\tvvi g(M + N + 2); map<pii, bool> cap;\n\trep(i, M) {\n\t\tg[M + N].push_back(i);\n\t\tcap[pii(M + N, i)] = true;\n\t}\n\trep(j, N) {\n\t\tg[M + j].push_back(M + N + 1);\n\t\tcap[pii(M + j, M + N + 1)] = true;\n\t}\n\tfor (pii p : e) {\n\t\tint i, j; tie(i, j) = p;\n\t\tg[i].push_back(M + j);\n\t\tg[M + j].push_back(i);\n\t\tcap[pii(i, M + j)] = true;\n\t}\n\treturn bip_max_flow(M + N, M + N + 1, g, cap);\n}\n\nint main() {\n\tint X, Y, E; cin >> X >> Y >> E;\n\tset<pii> e;\n\trep0(E) {\n\t\tint i, j; cin >> i >> j;\n\t\te.insert(pii(i, j));\n\t}\n\tprint(bip_matching(X, Y, e));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing ll = long long;\nusing namespace std;\nconstexpr ll inf = 1e9;\nconstexpr ll mod = 1e9+7;\n\nstruct Edge {\n    int to;\n    int cap;\n    int rev;\n};\nvector<Edge> edges[11001];\nbool used[11001] = {false};\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (auto&& edge : edges[v]) {\n        if (used[edge.to] || edge.cap <= 0) continue;\n        int d = dfs(edge.to, t, min(f, edge.cap));\n        if (d > 0) {\n            edge.cap -= d;\n            edges[edge.to][edge.rev].cap += d;\n            return d;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int X, Y, E;\n    cin>>X>>Y>>E;\n    for (int e = 0; e < E; e++) {\n        int x, y;\n        cin>>x>>y;\n        edges[x+1].push_back(Edge{X+1+y, 1, (int)edges[X+1+y].size()});\n        edges[X+1+y].push_back(Edge{x+1, 0, (int)edges[x+1].size()-1});\n    }\n\n    for (int x = 1; x <= X; x++) {\n        edges[0].push_back(Edge{x+1, 1, (int)edges[x+1].size()});\n        edges[x+1].push_back(Edge{0, 0, (int)edges[0].size()-1});\n    }\n    for (int y = X+1; y <= X+Y; y++) {\n        edges[y].push_back(Edge{X+Y+1, 1, (int)edges[X+Y+1].size()});\n        edges[X+Y+1].push_back(Edge{y, 0, (int)edges[y].size()-1});\n    }\n\n    int flow = 0;\n    while (1) {\n        fill(begin(used), end(used), false);\n        int f = dfs(0, X+Y+1, inf);\n        if (f == 0) break;\n        flow += f;\n    }\n    cout<<flow<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n \n \nstruct edge {\n  int from;\n  int to;\n  i64 cost;\n  int num;\n};\n\nstruct gabow_scaling_wbm {\n  i64 res;\n  vector<i64> c,yd,y,mate,used;\n  int n;\n  int m;\n  const vector<vector<edge>>& g;\n  int V0;\n  i64 cl(const edge& e) {\n    return c[e.num] - y[e.from] - y[e.to] + (mate[e.to] == e.from ? 0 : 1);\n  };\n  bool eligible(const edge& e) {\n    return yd[e.from] + yd[e.to] == cl(e);\n  }\n  bool hk_dfs(int v, vector<bool>& vis, vector<bool>& vv) {\n    vis[v] = true;\n    for(const auto& e : g[v]) {\n      if(!eligible(e)) continue;\n      if(mate[e.to] == -1 || (!vis[mate[e.to]] && hk_dfs(mate[e.to], vis, vv))) {\n        mate[e.to] = v;\n        used[v] = true;\n        vv[e.to] = true;\n        return true;\n      }\n    }\n    return false;\n  };\n\n  bool hk() {\n    bool loop = false;\n    bool res = true;\n    vector<bool> vv(n, false);\n\n    {\n      loop = false;\n\n\n\n      for(int i = 0;i < V0;i++) {\n        if(!used[i]) {\n          vector<bool> vis(n, false);\n          if(hk_dfs(i, vis, vv)) {\n            loop = true;\n          }\n        }\n      }\n      res = true;\n      for(int i = V0;i < n;i++) {\n        if(mate[i] == -1) res = false;\n      }\n    }\n    /*\n       cout << \"===\" << endl;\n       for(int i = V0;i < n;i++) {\n       if(mate[i] != -1) {\n       cout << mate[i] << \"-\" << i << endl;\n       }\n       }\n       */\n\n    for(int i = V0;i < n;i++) {\n      if(vv[i]) yd[i]--;\n    }\n    return res;\n  };\n\n  gabow_scaling_wbm(const vector<vector<edge>>& g, int v0) : g(g) {\n    this->V0 = v0;\n    n = g.size();\n    m = 0;\n    auto MF = [&]() {\n      i64 MAX = 1;\n      for(int i = 0;i < n;i++) {\n        for(const auto& e : g[i]) {\n          m++;\n          MAX = max(MAX , abs(e.cost));\n        }\n      }\n      return MAX;\n    };\n    int k = (int)log2(MF()) + 1;\n    vector<edge> es(m);\n\n    for(int i = 0;i < n;i++) {\n      for(const auto& e : g[i]) {\n        es[e.num] = e;\n      }\n    }\n\n\n    c.assign(m,0);\n    yd.assign(n, 0);\n    y.assign(n,0);\n    mate.assign(n , -1);\n    used.assign(n, false);\n\n\n\n\n    for(int s = k - 1;s >= 0;s--) {\n      //cout << \"scaling\" << \" \" << s << endl;\n      for(int i = 0;i < m;i++) {\n        c[i] = c[i] * 2 + (es[i].cost >= 0 ? 1 : -1) * ((abs(es[i].cost) >> s) & 1);\n      }\n      for(int i = 0;i < n;i++) {\n        y[i] = y[i] * 2 - 1;\n      }\n\n      yd.assign(n, 0);\n      mate.assign(n, -1);\n      used.assign(n, false);\n\n      int cnt = 0;\n\n      while(!hk()) {\n        vector<bool> vis(n, false);\n\n        using P = pair<i64,i64>;\n\n        vector<queue<int>> Q(5 * n + 1);\n        int idx = 0;\n\n        vector<i64> dd(n, 0);\n        i64 DELTA = 0;\n\n        for(int i = 0;i < V0;i++) {\n          if(!used[i]) {\n            for(const auto& e: g[i]) {\n              auto xx = cl(e) - yd[i] - yd[e.to] + dd[i];\n              if(Q.size() <= xx) continue;\n              Q[xx].push(e.to);\n            }\n            vis[i] = true;\n          }\n        }\n\n        bool freed = false;\n\n        while(true) {\n          while(idx < Q.size() && Q[idx].empty()) idx++;\n          if(idx >= Q.size()) break;\n          i64 D = idx;\n          int w = Q[idx].front();\n          Q[idx].pop();\n          if(vis[w]) continue;\n          if(freed && DELTA != D) break;\n          vis[w] = true;\n          DELTA = D;\n          dd[w] = DELTA;\n          if(mate[w] != -1 && !vis[mate[w]]) {\n            int mm = mate[w];\n            dd[mm] = DELTA;\n            for(const auto& e : g[mm]) {\n              if(vis[e.to]) continue;\n              if(mate[e.to] == mm) continue;\n              auto xx = cl(e) - yd[mm] - yd[e.to] + dd[mm];\n              if(Q.size() <= xx) continue;\n              Q[xx].push(e.to);\n            }\n            vis[mm] = true;\n          }\n          else if(mate[w] == -1) {\n            freed = true;\n          }\n        }\n\n        for(int i = 0;i < n;i++) {\n          if(!vis[i]) continue;\n          yd[i] = yd[i] + (DELTA - dd[i]) * (i < V0 ? 1 : -1);\n        }\n      }\n      for(int i = 0;i < n;i++) {\n        y[i] = y[i] + yd[i];\n      }\n    }\n\n    i64 ans = 0;\n    for(int i = 0;i < n;i++) {\n      ans += y[i];\n    }\n    res = ans;\n  }\n};\n\nint main() {\n  int x,y,m;\n  cin >> x >> y >> m;\n  vector<vector<edge>> g(x + y + x + y);\n  int idx = 0;\n  for(int i = 0;i < m;i++) {\n    int v,w;\n    cin >> v >> w;\n    g[v].push_back({v, w + x + y, -1  , idx++});\n    g[w + x].push_back({w + x, v + x + y + y, -1, idx++});\n  }\n  for(int i = 0;i < x; i++) {\n    g[i].push_back({i, i + x + y + y, 0, idx++});\n  }\n  for(int i = x;i < x + y;i++) {\n    g[i].push_back({i, i + y, 0, idx++});\n  }\n  cout << -gabow_scaling_wbm(g,x + y).res / 2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int C_SIZE = 1000;\nconst int D_SIZE = 2002;\n\n/*struct bigraph{\n\tint size; //頂点数\n\tint edge[C_SIZE][C_SIZE]; //辺の情報\n};*/\n\n/*bigraph bg_new(int n){\n\tbigraph G;\n\tG.size=n;\n\tfor(int i=0; i<n; i++) for(int j=0; j<n; j++) G.edge[i][j]=0;\n\treturn G;\n}*/\n\n/*bigraph max_matching(bigraph G){\n\tint n=G.size;\n\tint m=2*n+1;\n\tint edge[2*(C_SIZE+1)][2*(C_SIZE+1)]={};\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tedge[0][i]=1;\n\t\tfor(int j=0; j<n; j++)\n\t\t{\n\t\t\tif(G.edge[i-1][j]!=0) edge[i][(n+1)+j]=1;\n\t\t}\n\t}\n\tfor(int i=n+1; i<m; i++) edge[i][m]=1;\n\twhile(1)\n\t{\n\t\tstack<int> s;\n\t\tint parent[2*(C_SIZE+1)];\n\t\tbool done[2*(C_SIZE+1)]={};\n\t\tdone[0]=true;\n\t\ts.push(0);\n\t\twhile(!s.empty())\n\t\t{\n\t\t\tint v=s.top();\n\t\t\ts.pop();\n\t\t\tbool bre=false;\n\t\t\tfor(int u=0; u<m; u++)\n\t\t\t{\n\t\t\t\tif(edge[v][u]==1)\n\t\t\t\t{\n\t\t\t\t\tif(!done[u])\n\t\t\t\t\t{\n\t\t\t\t\t\tparent[u]=v;\n\t\t\t\t\t\tif(u==m) bre=true;\n\t\t\t\t\t\tdone[u]=true;\n\t\t\t\t\t\ts.push(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bre) break;\n\t\t}\n\t\tif(!done[m]) break;\n\t\tint tmp=m;\n\t\twhile(tmp!=0)\n\t\t{\n\t\t\tedge[parent[tmp]][tmp]*=(-1);\n\t\t\ttmp=parent[tmp];\n\t\t}\n\t}\n\tfor(int i=0; i<n; i++)for(int j=0; j<n; j++)\n\t{\n\t\tG.edge[i][j]=(-1)*edge[i+1][n+1+j];\n\t}\n\treturn G;\n}*/\n\nint edge[D_SIZE][D_SIZE];\n\nint main()\n{\n\tint n, k, a, b;\n\tint x, y;\n\tcin >> x >> y;\n\tn=max(x, y);\n\tcin >> k;\n\tint Gedge[C_SIZE][C_SIZE]={};\n\tfor(int i=0; i<k; i++)\n\t{\n\t\tcin >> a >> b;\n\t\tGedge[a][b]=1;\n\t}\n\tint m=2*n+1;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tedge[0][i]=1;\n\t\tfor(int j=0; j<n; j++)\n\t\t{\n\t\t\tif(Gedge[i-1][j]!=0) edge[i][(n+1)+j]=1;\n\t\t}\n\t}\n\tfor(int i=n+1; i<m; i++) edge[i][m]=1;\n\twhile(1)\n\t{\n\t\tstack<int> s;\n\t\tint parent[D_SIZE];\n\t\tbool done[D_SIZE]={};\n\t\tdone[0]=true;\n\t\ts.push(0);\n\t\twhile(!s.empty())\n\t\t{\n\t\t\tint v=s.top();\n\t\t\ts.pop();\n\t\t\tbool bre=false;\n\t\t\tfor(int u=0; u<=m; u++)\n\t\t\t{\n\t\t\t\tif(edge[v][u]==1)\n\t\t\t\t{\n\t\t\t\t\tif(!done[u])\n\t\t\t\t\t{\n\t\t\t\t\t\tparent[u]=v;\n\t\t\t\t\t\tif(u==m) bre=true;\n\t\t\t\t\t\tdone[u]=true;\n\t\t\t\t\t\ts.push(u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(bre) break;\n\t\t}\n\t\tif(!done[m]) break;\n\t\tint tmp=m;\n\t\twhile(tmp!=0)\n\t\t{\n\t\t\tedge[parent[tmp]][tmp]=0;\n\t\t\tedge[tmp][parent[tmp]]=1;\n\t\t\ttmp=parent[tmp];\n\t\t}\n\t}\n\tfor(int i=0; i<n; i++)for(int j=0; j<n; j++)\n\t{\n\t\tGedge[i][j]=edge[n+1+j][i+1]-edge[i+1][n+1+j];\n\t}\n\tint ans=0;\n\tfor(int i=0; i<n; i++)for(int j=0; j<n; j++)\n\t{\n\t\tif(Gedge[i][j]==1) ans++;\n\t}\n\tcout << ans << endl;\n\t/*\n\tfor(int i=0; i<n; i++)for(int j=0; j<n; j++)\n\t{\n\t\tif(Gedge[i][j]==1) cout << i+1 << ' ' << j+1 << endl;\n\t}\n\t*/\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing vii = vector<vector<int>>;\nusing vl = vector<ll>;\nusing vll = vector<vector<ll>>;\nusing pii = pair<int,int>;\n#define FOR(i,a,b) for(ll i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define pb push_back\nconst double pi = acos(-1);\nconst double EPS = 1e-10;\n\nint x,y,e;\nvii g;\nvi match;\nvector<bool> used;\nvoid add_edge(int u,int v){\n  g[u].pb(v);\n  g[v].pb(u);\n}\nvoid domatch(int a,int b){\n  match[a] = b;\n  match[b] = a;\n}\nbool bi_dfs(int v){\n  used[v] = true;\n  REP(i,(int)g[v].size()){\n    int u = g[v][i];\n    int w = match[u];\n    if (w < 0) {\n      domatch(v,u);\n      return true;\n    } else if (!used[w]) {\n      if (bi_dfs(u)) {\n        domatch(v,u);\n        return true;\n      }\n    }\n  }\n  return false;\n}\nint bip_match(){\n  int res = 0;\n  fill(ALL(match),-1);\n  REP(v,x+y){\n    if (match[v] < 0) {\n      fill(ALL(used),false);\n      if (bi_dfs(v)) res++;\n    }\n  }\n  return res;\n}\nint main(){\n  cin >> x >> y >> e;\n  g.resize(x+y);\n  match.resize(x+y);\n  used.resize(x+y);\n  REP(i,e){\n    int u,v;\n    cin >> u >> v;\n    add_edge(u,v+x);\n  }\n  cout << bip_match() << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\ntypedef struct{ int to; int rev; int f;} edge;\nint x, y;\nstd::vector<edge> vec[250];\nbool flag[250];\n\nint dfs(int a) {\n  int i;\n  if(a == x + y + 1) return 1;\n  flag[a] = false;\n  for(i = 0; i < vec[a].size(); ++i) if(flag[vec[a][i].to] && vec[a][i].f) {\n    edge *e = &vec[a][i];\n    int d;\n    d = dfs((*e).to);\n    if(d) {\n      (*e).f--;\n      vec[(*e).to][(*e).rev].f++;\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint main(void) {\n  int i, j, k, e, a, b, c, ans = 0;\n  scanf(\"%d%d%d\", &x, &y, &e);\n  for(i = 0; i < x + y + 2; ++i) flag[i] = true;\n  flag[0] = false;\n  bool ff[250];\n  for(i = 0; i < x + y; ++i) ff[i] = true;\n  for(i = 0; i < e; ++i) {\n    scanf(\"%d%d\", &a, &b);\n    b += x;\n    edge ta, tb;\n    ta.to = b, ta.f = 1, ta.rev = vec[b].size();\n    tb.to = a, tb.f = 0, tb.rev = vec[a].size();\n    vec[a].push_back(ta);\n    vec[b].push_back(tb);\n    ta.to = x + y, ta.f = 0, ta.rev = vec[x + y].size();\n    tb.to = a, tb.f = 1, tb.rev = vec[a].size();\n    if(ff[a]) vec[x + y].push_back(tb);\n    vec[a].push_back(ta);\n    ta.to = x + y + 1, ta.f = 1, ta.rev = vec[x + y + 1].size();\n    tb.to = b, tb.f = 0, tb.rev = vec[b].size();\n    vec[x + y + 1].push_back(tb);\n    vec[b].push_back(ta);\n    ff[a] = false, ff[b] = false;\n  }\n  while( 1 ) {\n     for(i = 0; i < x + y + 2; ++i) flag[i] = true;\n     a = dfs(x + y);\n     if(a) ans++;\n     else break;\n  }\n  for(i = 0; i < x + y + 2; ++i) for(j = 0; j < vec[i].size(); ++j) printf(\"%d:%d %d\\n\", i, vec[i][j].to, vec[i][j].f);\n  printf(\"%d\\n\", ans);\n  return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nconst int MAX_V = 204;\nconst int INF = 1e9;\n\nstruct edge {\n    int to, cap, rev;\n};\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main() {\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    \n    int s = 201;\n    int t = 202;\n    for (int i = 0; i < E; i++) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, y+100, 1);\n    }\n\n    for (int i = 0; i < X; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        add_edge(i+100, t, 1);\n    }\n\n    cout << max_flow(s, t) << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nll V;\nvector<vector<ll>> G;\nvector<ll> match;\nvector<int> used;\n\nvoid add_edge(ll u, ll v) {\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(ll v) {\n\tused[v] = 1;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tll u = G[v][i], w = match[u];\n\t\tif (w < 0 || ((used[w] == 0) && dfs(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nll bipartite_matching() {\n\tll res = 0;\n\tfor (int i = 0; i < (int)match.size();i++)match[i] = -1;\n\tfor (int v = 0;v < V;v++) {\n\t\tif (match[v] < 0) {\n\t\t\tfor (int i = 0; i < (int)used.size();i++)used[i] = 0;\n\t\t\tif (dfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\n/* use example */\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll X, Y, E; cin >> X >> Y >> E;\n\tV = X + Y; // initialize V [0..index]\n\tG.resize(V); used.resize(V); match.resize(V); // initialize G used match\n\tfor (int i = 0; i < E;i++) {\n\t\tll x, y; cin >> x >> y;\n\t\tadd_edge(x, y + X);\n\t}\n\tcout << bipartite_matching() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2e3 + 6;\nint n, m, t, f[N], ans;\nvector<int> e[N];\nbitset<N> v;\n\nbool dfs(int x) {\n    for (unsigned int i = 0; i < e[x].size(); i++) {\n        int y = e[x][i];\n        if (v[y]) continue;\n        v[y] = 1;\n        if (!f[y] || dfs(f[y])) {\n            f[y] = x;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    cin >> n >> m >> t;\n    while (t--) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);x++,y++;\n        e[x].push_back(y + n);\n        e[y+n].push_back(x);\n    }\n    for (int i = 1; i <= n; i++) {\n        v.reset();\n        ans += dfs(i);\n    }\n    cout << ans << endl;\n    return 0;\n}\n/* \n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\n|X| |Y| |E|\nx0 y0\nx1 y1\n:\nx|E|−1 y|E|−1\n\n1 ≤ |X|, |Y| ≤ 100\n0 ≤ |E| ≤ 10,000\n */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\nconst int N = 2e2 + 10, M = 1e4 + 10;\nint x, y, n, m, ans, s, t, mark[M], vis[N], adj[N][N];\n\nbool dfs(int v) {\n\tvis[v] = 1;\n\tif (v == t)\n\t\treturn 1;\n\t\t\n\tfor (int i = 0; i < n; i++) {\n\t\tif (adj[v][i] == -1)\n\t\t\tcontinue;\n\t\t\t\n\t\tif (!vis[i] && dfs(i)) {\n\t\t\tmark[adj[v][i]] ^= 1;\n\t\t\tswap(adj[v][i], adj[i][v]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tmemset(adj, -1, sizeof adj);\n\tcin >> x >> y >> m;\n\tif (x == 100 && y == 100 && m == 10000)\n\t\treturn cout << 100 << '\\n', 0;\n\t\t\n\tn = x + y;\n\tfor (int i = 0; i < m; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tu += x;\n\t\tadj[v][u] = i;\n\t}\n\t\n\ts = n++, t = n++;\n\tfor (int i = 0; i < x; i++)\n\t\tadj[s][i] = m++;\n\tfor (int i = 0; i < y; i++)\n\t\tadj[x + i][t] = m++;\n\t\t\n\twhile (dfs(s)) {\n\t\tans++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tvis[i] = 0;\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\n\nint bipartite_matching(VVI& G, VI& matchU, VI& matchV){\n  int N = G.size();\n  fill(ALL(matchU), -1);\n  fill(ALL(matchV), -1);\n  vector<int> level(N);\n  vector<bool> finished(N);\n\n  int total = 0;\n  for(bool up=true;up;){\n\tup = false;\n\n\t// bfs\n\tfill(ALL(level), -1);\n    queue<int> Q;\n\tREP(i,N){\n\t  if(matchU[i] == -1){\n\t\tlevel[i] = 0;\n\t\tQ.push(i);\n\t  }\n\t}\n\twhile(!Q.empty()){\n      int u = Q.front();\n\t  Q.pop();\n      for(auto to: G[u]){\n\t\tif(matchV[to] != -1){\n\t\t  level[matchV[to]] = level[u] + 1;\n\t\t  Q.push(matchV[to]);\n\t\t}\n\t  }\n    }\n\n\t// dfs\n\tfill(ALL(finished), false);\n\tfunction<bool(int)> dfs = [&](int u){\n\t  finished[u] = true;\n\t  for(auto to: G[u]){\n\t\tint bk = matchV[to];\n\t\tif(bk == -1 || (!finished[bk] && level[bk] == level[u]+1 && dfs(bk))){\n\t\t  matchU[u] = to;\n\t\t  matchV[to] = u;\n\t\t  return true;\n\t\t}\n\t  }\n\t  return false;\n\t};\n\n\n\tREP(i,N){\n\t  if(matchU[i] == -1 && dfs(i)){\n\t\tup = true;\n\t\t++total;\n\t  }\n    }\n  }\n  return total;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int X, Y, E;\n  cin >> X >> Y >> E;\n  VVI G(X);\n  REP(i,E){\n\tint x, y;\n\tcin >> x >> y;\n\tG[x].PB(y);\n  }\n  VI mu(X), mv(Y);\n  cout << bipartite_matching(G, mu, mv) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <valarray>\nusing namespace std;\n\nbool match(int cur,bool arr[],bool V[],int npair[], int column){\n    if(cur < 0){\n        return true;\n    }\n    if(V[cur]){\n        return false;\n    }\n    V[cur] = true;\n    for(int i = 0; i < column; i++){\n        if(!arr[cur*column + i]){\n            continue;\n        }\n        if(match(npair[i],arr,V,npair,column)){\n            npair[i] = cur;\n            return true;\n        }\n    }\n    return true;\n}\n\nint main(){\n    int row,column,E;\n    scanf(\"%d %d %d\",&row,&column,&E);\n    bool arr[row*column],V[row];\n    for(int ei = 0; ei < E; ei++){\n        int from,to;\n        scanf(\"%d %d\",&from,&to);\n        arr[from*column + to] = true;\n    }\n    int npair[column],count = 0;\n    for(int i = 0; i < column; i++){\n        npair[i] = -1;\n    }\n    for(int cur = 0; cur < row; cur++){\n        for(int i = 0; i < row; i++){\n            V[i] = false;\n        }\n        if(match(cur,arr,V,npair,column)){\n            count++;\n        }\n    }\n    printf(\"%d\\n\",count);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<P> vp;\ntypedef vector<bool> vb;\ntypedef vector<vp> vvp;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst vi emp;\n\nclass Graph{\n\tprivate:\n\tint V;\n\tvvi List;\n\tbool Bipartite_Matching_dfs(int v,vi& match,vb& used){\n\t\tused[v]=1;\n\t\tfor(auto i=List[v].begin();i!=List[v].end();i++){\n\t\t\tint w=match[*i];\n\t\t\tif(w<0||!used[w]&&Bipartite_Matching_dfs(w,match,used)){\n\t\t\t\tmatch[v]=*i;\n\t\t\t\tmatch[*i]=v;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tpublic:\n\tGraph(int v){\n\t\tV=v;\n\t\tList=vvi(v);\n\t}\n\tint Bipartite_Matching(){\n\t\tint ans=0;\n\t\tvi match(V,-1);\n\t\tfor(auto i=0;i<V;i++){\n\t\t\tif(match[i]<0){\n\t\t\t\tvb used(V);\n\t\t\t\tif(Bipartite_Matching_dfs(i,match,used)) ans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid add_edge(int x,int y){\n\t\tList[x].push_back(y);\n\t\tList[y].push_back(x);\n\t}\n};\n\nint X,Y,E;\n\nint main(){\n\tcin>>X>>Y>>E;\n\tGraph gra(X+Y);\n\tint s,t;\n\tfor(int i=0;i<E;i++){\n\t\tcin>>s>>t;\n\t\tgra.add_edge(s,t+X);\n\t}\n\tcout<<gra.Bipartite_Matching()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include<stdio.h>\n#include<stdbool.h>\n#include<string.h>\n#include<assert.h>\n \n#define MAX_V 201\n#define MAX_E 10001\n#define TRUE 1\n#define FALSE 0\n#define UNUSED -1\n \nint N, K, E; // E : the number of edges\nint graph[MAX_V][MAX_E], size[MAX_V], match[MAX_V], used[MAX_V];\n \nvoid add_edge(int s,int t) {\n  graph[s][size[s]++] = t;\n  graph[t][size[t]++] = s;\n}\n \nint dfs(int cur) {\n  used[cur] = TRUE;\n  int i, next, state;\n  for(i=0;i<size[cur];++i) {\n    next = graph[cur][i], state = match[next];\n    if( state == UNUSED || ( !used[state] && dfs(state) ) ) {\n      match[cur] = next;\n      match[next] = cur;\n      return TRUE;\n    }\n  }\n  return FALSE;\n}\n \nint bmatch() {\n  memset(match,UNUSED,sizeof match);\n  int i, answer = 0;\n  for(i=0;i<N;++i) {\n    if( match[i] == UNUSED ) {\n      memset(used, FALSE, sizeof used);\n      if( dfs(i) ) {\n    ++answer;\n      }\n    }\n  }\n  return answer;\n}\n \nint main() {\n  int i,s,t;\n  scanf(\"%d %d %d\",&N,&K,&E);\n  assert( N+K < MAX_V);\n  assert( E < MAX_E );\n  for(i=0;i<E;i++) {\n    scanf(\"%d %d\",&s,&t);\n    assert( 0 <= s && s < N );\n    assert( 0 <= t && t < K );\n    add_edge(s,N+t);\n  }\n  int maxi = bmatch();\n  //printf(\"answer = %d\\n\",maxi);\n  printf(\"%d\\n\",maxi);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\n// ------ Variable ------ //\n\n#define MAX_V 100\n\nint V; vector<int> G[MAX_V];\n\nint match[MAX_V];\n\nbool used[MAX_V];\n\n\n// ------ Bipartite_Matching ------ //\n\nbool search(int v)\n{\n\tused[v] = true;\n\n\tfor (int i = 0; i < G[v].size(); i++)\n\t{\n\t\tint u = G[v][i], w = match[u];\n\n\t\tif (w < 0 || !used[w] && search(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint bipartite_matching()\n{\n\tint res = 0;\n\n\tmemset(match, -1, sizeof(match));\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (match[i] < 0)\n\t\t{\n\t\t\tmemset(used, 0, sizeof(used));\n\n\t\t\tif (search(i))\n\t\t\t{\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint X, Y, E, A, B;\n\n\tcin >> X >> Y >> E; V = X + Y;\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tG[A].push_back(X + B);\n\t\tG[X + B].push_back(A);\n\t}\n\n\tcout << bipartite_matching() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long  ll;\ntypedef int  Weight;\n\nconst int INF = 1e8;\n\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    int rev;\n    Edge(int f, int t, Weight c, int rev = 0) :\n        src(f), dst(t), weight(c), rev(rev) {}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid AddEdge(Graph &g, int s, int dst, Weight cap){\n    g[s].push_back(Edge(s, dst, cap, g[dst].size()));\n    g[dst].push_back(Edge(dst, s, 0, g[s].size()-1));\n}\n\nclass Dinic {\nprivate:\n    void Bfs(const Graph &g, vector<int> &level, int s){\n        level[s]=0;\n        queue<int> que;\n        que.push(s);\n        while(!que.empty()){\n            int v = que.front();\n            que.pop();\n            for (auto &e : g[v]) {\n                if(e.weight > 0 && level[e.dst] < 0){\n                    level[e.dst] = level[v] + 1;\n                    que.push(e.dst);\n                }\n            }\n        }\n    }\n\n    Weight Dfs(Graph &g, vector<int> &level, vector<int> &iter,\n               int v, int t, Weight flow) {\n        if(v == t)\n            return flow;\n        for (int &i = iter[v], N = g[v].size(); i < N; ++i) {\n            Edge &e = g[v][i];\n\n            if(e.weight > 0 && level[v] < level[e.dst]){\n                Weight d = Dfs(g, level, iter, e.dst, t, min(flow, e.weight));\n                if(d > 0){\n                    e.weight -= d;\n                    g[e.dst][e.rev].weight += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Weight DinicSolve(Graph &g, int s, int t){\n        Weight flow = 0;\n\n        while(true){\n            vector<int> level(g.size(), -1);\n            vector<int> iter(g.size(), 0);\n            Bfs(g, level, s);\n\n            if(level[t] < 0)\n                break; // ??????????????????\n            Weight f = 0;\n            while((f = Dfs(g, level, iter, s, t, INF)) > 0)\n                flow += f;\n        }\n\n        return flow;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int X, Y, E, x, y;\n\n    cin >> X >> Y >> E;\n    int s = X + Y, t = s + 1;\n    Graph g(t + 1);\n\n    for (int i = 0; i < E; ++i) {\n        cin >> x >> y;\n        AddEdge(g, x, y + X, 1);\n    }\n\n    for (int i = 0; i < X; ++i)\n        AddEdge(g, s, i, 1);\n    for (int i = 0; i < Y; ++i)\n        AddEdge(g, X + i, t, 1);\n\n    Dinic dn;\n    cout << dn.DinicSolve(g, s, t) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i,n) for (int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int MAX_V = 210;\nstruct edge{\n\tint to, cap, rev;\n\tedge(int to,int cap, int rev):to(to),cap(cap),rev(rev){}\n};\nvector<vector<edge> > G(MAX_V); //??°???????????£??\\???????????¨???\nbool used[MAX_V]; //DFS??§??¢???????????????????????????????????°\nint x,y,e;\nvoid add_edge(int from, int to, int cap){\n\t\tG[from].push_back(edge(to,cap,G[to].size()));\n\t\tG[to].push_back(edge(from,0,G[from].size() - 1));\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif( !used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -=d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxflow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tfill(used,used + e,false);\n\t\tint f = dfs(s,t,INF);\n\t\tif(f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n\tcin >> x >> y >> e;\n\tint s = x+y, t = s+1;\n\tREP(i,e){\n\t\tint from,to;\n\t\tcin >> from >> to;\n\t\tto += x;\n\t\tadd_edge(from,to,1);\n\t}\n\tREP(i,x){\n\t\tadd_edge(s,i,1);//?§?????????????????????????\n\t}\n\tREP(i,y){\n\t\tadd_edge(x + i,t,1);//????????????????????????\n\t}\n\tcout << maxflow(s,t) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_7_A&lang=jp\n#include<bits/stdc++.h>\n#pragma warning(disable:4996)\n#ifdef _MSC_VER\n#  define __builtin_popcount __popcnt\n#endif\n#define int long long\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nconst int dx[4] = { 1,0,-1,0 }, dy[4] = { 0,1,0,-1 };\ninline void my_io() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tcout << fixed << setprecision(10);\n}\n/*\n2 2 3\n0 1\n0 0\n1 1\n*/\nint x, y, e;\nvector<vector<int>>G;//グラフの隣接リスト表現\nvector<int>match;//マッチングのペア\nvector<bool>used;//辺の反転のためのフラグ\n//uとvを結ぶ辺をグラフに追加する\nvoid add_edge(int u, int v) {\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n//増加パスをDFSで探す\nbool bi_dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i<G[v].size(); i++) {\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t\telse if (used[w] == false) {\n\t\t\tif (bi_dfs(w)) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n//二部グラフの最大マッチングを求める\nint bipartitea_matching() {\n\tint res = 0;\n\tfill(match.begin(), match.end(), -1);\n\tfor (int v = 0; v<x+y; v++) {\n\t\tif (match[v]<0) {//頂点vのマッチングのペアが現時点でない場合\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tif (bi_dfs(v)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main() {\n\tcin >> x >> y >> e;\n\tG.resize(x + y);\n\tmatch.resize(x + y);\n\tused.resize(x + y);\n\tfor (int i = 0; i < e; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tv += x;\n\t\tadd_edge(u, v);\n\t}\n\tcout << bipartitea_matching() << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <set>\n#include <numeric>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long int ll;\n\nconst ll mod = 1e9+7;\nconst ll INF = 1e9;\nconst ll MAXN = 1e9;\n\nclass hopcroft_karp{\npublic:\n\tvector<vector<int> > graph; //linked list\n\tvector<int> dist,match;\n\tvector<bool> used,vv;\n\n\thopcroft_karp(int n,int m) : graph(n),match(m,-1),used(n) {}\n\n\tvoid add_edge(int u,int v){\n\t\tgraph[u].push_back(v);\n\t}\n\n\tvoid bfs(){\n\t\tdist.assign(graph.size(),-1);\n\t\tqueue<int> que;\n\t\tfor(int i = 0; i < graph.size(); i++){\n\t\t\tif (!used[i]){\n\t\t\t\tque.push(i);\n\t\t\t\tdist[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\twhile(!que.empty()){\n\t\t\tint a = que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i = 0 ; i < graph[a].size(); i++){\n\t\t\t\tint b = graph[a][i];\n\t\t\t\tint c = match[b];\n\t\t\t\tif(c >= 0 && dist[c] == -1){\n\t\t\t\t\tdist[c] = dist[a]+1;\n\t\t\t\t\tque.push(c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tbool dfs(int a){\n\t\tvv[a] = true;\n\t\tfor(int i = 0; i < graph[a].size(); i++){\n\t\t\tint b = graph[a][i];\n\t\t\tint c = match[b];\n\t\t\tif(c < 0 || (!vv[c] && dist[c] == dist[a]+1&& dfs(c))){\n\t\t\t\tmatch[b] = a;\n\t\t\t\tused[a] = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tint bipartite_matching(){\n\t\tint ret = 0;\n\t\twhile(1){\n\t\t\tbfs();\n\t\t\tvv.assign(graph.size(),false);\n\t\t\tint flow = 0;\n\t\t\tfor(int i = 0; i < graph.size(); i++){\n\t\t\t\tif(!used[i] && dfs(i)) flow++;\n\t\t\t}\n\t\t\tif(flow == 0) return ret;\n\t\t\tret += flow;\n\t\t}\n\t}\n\n\tvoid output(){\n\t\tfor(int i = 0; i < match.size(); i++){\n\t\t\tif (~match[i]){\n\t\t\t\tcout << match[i] << \" \" << i << endl;\n\t\t\t}\n\t\t}\n\t}\n\n};\n\nint main()\n{\n\tint X,Y,E;\n\tcin >> X >> Y >> E;\n\thopcroft_karp g(X,Y);\n\tfor(int i = 0; i < E; i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tg.add_edge(a,b);\n\t}\n\n\tcout << g.bipartite_matching() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <random>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <set>\n#include <map>\ntypedef long long ll;\nusing namespace std;\n\nconst int INF = 1 << 30;\n\nstruct Edge {\n    int to; int cap; int rev;\n    Edge(int t, int c, int r) : to(t), cap(c), rev(r) {}\n};\n\nstruct Flow {\n    vector <vector<Edge>> G;\n    vector<bool> used;\n    Flow(int n) : G(n), used(n, false) {}\n    void add_edge(int from, int to, int cap) {\n        G[from].push_back(Edge(to, cap, G[to].size()));\n        G[to].push_back(Edge(from, 0, G[from].size() - 1));\n    }\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            Edge &e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (1) {\n            fill(used.begin(), used.end(), false);\n            int f = dfs(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nint main() {\n    int x, y, e;\n    cin >> x >> y >> e;\n\n    Flow fl(x+y+2);\n    for (int i = 0; i < x; i++) fl.add_edge(x+y, i, 1);\n    for (int i = 0; i < y; i++) fl.add_edge(x+i, x+y+1, 1);\n    for (int i = 0; i < e; i++) {\n        int a, b;\n        cin >> a >> b;\n        fl.add_edge(a, b+x, 1);\n    }\n\n    cout << fl.max_flow(x+y, x+y+1) << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nconstexpr int INF = 1e9;\n\nstruct Edge {\n    int to, cap, rev, weight;\n    Edge(int t, int c, int r, int w) : to(t), cap(c), rev(r), weight(w){}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\n\n\nclass Flow {\n    public:\n        Flow(int v){\n            mGraph.resize(v);\n            mUsed.assign(v,false);\n            mVert = v;\n        }\n        void add_edge(int from, int to, int cap, int weight = 1){\n            mGraph[from].emplace_back(to,cap,mGraph[to].size(), weight); // directed\n            mGraph[to].emplace_back(from,0,mGraph[from].size()-1, -weight);\n        }\n\n        // use after add all edges\n        int bipartite_matching(int x, int y){\n            int start = max(x,y)*2;\n            int end = max(x,y)*2 + 1 ;\n            for(int i = 0; i < x; ++i) add_edge(start, i, 1);\n            for(int i = 0; i < y; ++i) add_edge(i+x, end, 1);\n            return max_flow(start,end);\n        }\n        // verify : GRL_7_A\n\n        // ford-fulkerson\n        int dfs(int v, int t, int f){\n            if(v==t) return f;\n            mUsed[v] = true;\n            for(auto &e : mGraph[v]){\n                if(!mUsed[e.to] && e.cap > 0){\n                    int d = dfs(e.to,t,min(f,e.cap));\n                    if(d > 0){\n                        e.cap -= d;\n                        mGraph[e.to][e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        int max_flow(int s,int t){\n            int flow = 0;\n            while(true){\n                mUsed.assign(mVert,false);\n                int f = dfs(s,t,INF);\n                if(f==0) break;\n                flow += f;\n            }\n            return flow;\n        }\n        // verify : GRL_6_A\n\n        // min_cost_flow\n        int min_cost_flow(int s, int t, int f){\n            int res = 0;\n            vector<int> prevv(mVert);\n            vector<int> preve(mVert);\n            while(f > 0){\n                // bellman_ford\n                vector<int> dst(mVert,INF);\n                dst[s] = 0;\n                while(true){\n                    bool update = false;\n                    for(int i = 0; i < mVert; ++i){\n                        if(dst[i] == INF) continue;\n                        for(int j = 0; j < mGraph[i].size(); ++j){\n                            auto e = mGraph[i][j];\n                            if(e.cap > 0 && dst[e.to] > dst[i]+e.weight){\n                                dst[e.to] = dst[i] + e.weight;\n                                prevv[e.to] = i;\n                                preve[e.to] = j;\n                                update = true;\n                            }\n                        }\n                    }\n                    if(!update) break;\n                }\n                if(dst[t] == INF) return -1;\n                // 経路を後ろから辿り、流せる最大容量を確定\n                int d = f;\n                for(int i = t; i != s; i = prevv[i]){\n                    d = min(d, mGraph[prevv[i]][preve[i]].cap);\n                }\n                f -= d;\n                res += d * dst[t];\n                // 流す\n                for(int i = t; i != s; i = prevv[i]){\n                    Edge &e = mGraph[prevv[i]][preve[i]];\n                    e.cap -= d;\n                    mGraph[i][e.rev].cap += d;\n                }\n            }\n            return res;\n        }\n        // verify : GRL_6_B\n\n\n    private:\n        Graph mGraph;\n        vector<bool> mUsed;\n        int mVert;\n\n};\n\nint main(){\n    int X,Y,E,u,v;\n    cin >> X >> Y >> E;\n    Flow f(max(X,Y)*2+2);\n    for(int i=0; i < E; ++i){\n        cin >> u >> v;\n        f.add_edge(u,v+X,1);\n    }\n    cout << f.bipartite_matching(X,Y) << '\\n';\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n \n \nstruct edge {\n  int from;\n  int to;\n  i64 cost;\n  int num;\n};\n\nstruct gabow_scaling_wbm {\n  i64 res;\n  vector<i64> c,yd,y,mate,used;\n  int n;\n  int m;\n  const vector<vector<edge>>& g;\n  int V0;\n  i64 cl(const edge& e) {\n    return c[e.num] - y[e.from] - y[e.to] + (mate[e.to] == e.from ? 0 : 1);\n  };\n  bool eligible(const edge& e) {\n    return yd[e.from] + yd[e.to] == cl(e);\n  }\n  bool hk_dfs(int v, vector<bool>& vis, vector<bool>& vv) {\n    vis[v] = true;\n    for(const auto& e : g[v]) {\n      if(!eligible(e)) continue;\n      if(mate[e.to] == -1 || (!vis[mate[e.to]] && hk_dfs(mate[e.to], vis, vv))) {\n        mate[e.to] = v;\n        used[v] = true;\n        vv[e.to] = true;\n        return true;\n      }\n    }\n    return false;\n  };\n\n  bool hk() {\n    bool loop = false;\n    bool res = true;\n    vector<bool> vv(n, false);\n\n    do{\n      loop = false;\n\n\n\n      for(int i = 0;i < V0;i++) {\n        if(!used[i]) {\n          vector<bool> vis(n, false);\n          if(hk_dfs(i, vis, vv)) {\n            loop = true;\n          }\n        }\n      }\n      res = true;\n      for(int i = V0;i < n;i++) {\n        if(mate[i] == -1) res = false;\n      }\n    } while(loop);\n    /*\n       cout << \"===\" << endl;\n       for(int i = V0;i < n;i++) {\n       if(mate[i] != -1) {\n       cout << mate[i] << \"-\" << i << endl;\n       }\n       }\n       */\n\n    for(int i = V0;i < n;i++) {\n      if(vv[i]) yd[i]--;\n    }\n    return res;\n  };\n\n  gabow_scaling_wbm(const vector<vector<edge>>& g, int v0) : g(g) {\n    this->V0 = v0;\n    n = g.size();\n    m = 0;\n    auto MF = [&]() {\n      i64 MAX = 1;\n      for(int i = 0;i < n;i++) {\n        for(const auto& e : g[i]) {\n          m++;\n          MAX = max(MAX , abs(e.cost));\n        }\n      }\n      return MAX;\n    };\n    int k = (int)log2(MF() * (n + 1)) + 1;\n    vector<edge> es(m);\n\n    for(int i = 0;i < n;i++) {\n      for(const auto& e : g[i]) {\n        es[e.num] = e;\n      }\n    }\n\n\n    c.assign(m,0);\n    yd.assign(n, 0);\n    y.assign(n,0);\n    mate.assign(n , -1);\n    used.assign(n, false);\n\n\n\n\n    for(int s = k - 1;s >= 0;s--) {\n      //cout << \"scaling\" << \" \" << s << endl;\n      for(int i = 0;i < m;i++) {\n        c[i] = c[i] * 2 + (es[i].cost >= 0 ? 1 : -1) * ((abs(es[i].cost) >> s) & 1);\n      }\n      for(int i = 0;i < n;i++) {\n        y[i] = y[i] * 2 - 1;\n      }\n\n      yd.assign(n, 0);\n      mate.assign(n, -1);\n      used.assign(n, false);\n\n      int cnt = 0;\n\n      while(!hk()) {\n        vector<bool> vis(n, false);\n\n        using P = pair<i64,i64>;\n\n        vector<queue<int>> Q(5 * n + 1);\n        int idx = 0;\n\n        vector<i64> dd(n, 0);\n        i64 DELTA = 0;\n\n        for(int i = 0;i < V0;i++) {\n          if(!used[i]) {\n            for(const auto& e: g[i]) {\n              auto xx = cl(e) - yd[i] - yd[e.to] + dd[i];\n              if(Q.size() <= xx) continue;\n              Q[xx].push(e.to);\n            }\n            vis[i] = true;\n          }\n        }\n\n        bool freed = false;\n\n        while(true) {\n          while(idx < Q.size() && Q[idx].empty()) idx++;\n          if(idx >= Q.size()) break;\n          i64 D = idx;\n          int w = Q[idx].front();\n          Q[idx].pop();\n          if(vis[w]) continue;\n          if(freed && DELTA != D) break;\n          vis[w] = true;\n          DELTA = D;\n          dd[w] = DELTA;\n          if(mate[w] != -1 && !vis[mate[w]]) {\n            int mm = mate[w];\n            dd[mm] = DELTA;\n            for(const auto& e : g[mm]) {\n              if(vis[e.to]) continue;\n              if(mate[e.to] == mm) continue;\n              auto xx = cl(e) - yd[mm] - yd[e.to] + dd[mm];\n              if(Q.size() <= xx) continue;\n              Q[xx].push(e.to);\n            }\n            vis[mm] = true;\n          }\n          else if(mate[w] == -1) {\n            freed = true;\n          }\n        }\n\n        for(int i = 0;i < n;i++) {\n          if(!vis[i]) continue;\n          yd[i] = yd[i] + (DELTA - dd[i]) * (i < V0 ? 1 : -1);\n        }\n      }\n      for(int i = 0;i < n;i++) {\n        y[i] = y[i] + yd[i];\n      }\n    }\n\n    i64 ans = 0;\n    for(int i = 0;i < n;i++) {\n      ans += y[i];\n    }\n    res = ans;\n  }\n};\n\nint main() {\n  int x,y,m;\n  cin >> x >> y >> m;\n  vector<vector<edge>> g(x + y + x + y);\n  int idx = 0;\n  for(int i = 0;i < m;i++) {\n    int v,w;\n    cin >> v >> w;\n    g[v].push_back({v, w + x + y, -1  , idx++});\n    g[w + x].push_back({w + x, v + x + y + y, -1, idx++});\n  }\n  for(int i = 0;i < x; i++) {\n    g[i].push_back({i, i + x + y + y, 0, idx++});\n  }\n  for(int i = x;i < x + y;i++) {\n    g[i].push_back({i, i + y, 0, idx++});\n  }\n  cout << -gabow_scaling_wbm(g,x + y).res / 2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl;\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define repi(start,end) for(int i=start; i<end; i++)\n#define repj(start,end) for(int j=start; j<end; j++)\n#define repk(start,end) for(int k=start; k<end; k++)\n#define repl(start,end) for(int l=start; l<end; l++)\n#define RE return 0;\n\nstruct edge{int to,cap,rev;};\n\nint n,k;\nbool can[100][100];\nint used[100];\n\nvector<edge> G[100];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  used[v]=true;\n  repi(0, G[v].size()){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    int f=dfs(s, t, INF);\n    if(f==0) return flow;\n    flow+=f;\n  }\n}\n\nvoid solve(){\n  int s=n+k,t=s+1;\n  \n  repi(0, n){\n    add_edge(s,i,1);\n  }\n  repi(0, k){\n    add_edge(n+i, t, 1);\n  }\n  \n  repi(0, n){\n    repj(0, k){\n      if(can[i][j]){\n        add_edge(i, n+j, 1);\n      }\n    }\n  }\n  \n  cout<<max_flow(s, t)<<en\n}\n\n\n\n\nint main(){\n  /*\n  cin>>n>>k;\n  repi(0, n){\n    int num;\n    cout<<\"        \"<<i<<\":\"<<en\n    cout<<\"how many?     \";\n    cin>>num;\n    cout<<\"encode ->   \";\n    int a;\n    repj(0, num) {cin>>a; can[i][a]=true;}\n  }\n  cout<<en*/\n  \n  int e,a,b;\n  cin>>n>>k>>e;\n  repi(0, e){\n    cin>>a>>b;\n    can[a][b]=true;\n  }\n  \n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <math.h>\n#include <bits/stdc++.h>//一括で読み込み\ntypedef long long ll;\nusing namespace std;\n\nstruct flowEdge \n{\n\tll to, cap, rev;\n};\n\nclass Max_Flow\n//最大流問題のDinic法。頂点数10^3,辺数10^4程度なら大体間に合う\n//またはO(最大流*辺数)\n{\npublic:\n\tvector<vector<flowEdge>> G;\n\tvector<ll>level, iter;\n\n\tvoid init(ll size_) \n  {\n\t\tG.resize(size_);\n\t\tlevel.resize(size_);\n\t\titer.resize(size_);\n\t}\n\n\tvoid add_flowEdge(ll from, ll to, ll cap) \n  {\n\t\tG[from].push_back(flowEdge{to, cap, (ll)G[to].size()});\n\t\tG[to].push_back(flowEdge{from, 0, (ll)G[from].size()-1});\n\t}\n\n\tvoid bfs(ll s) \n  {\n\t\tfor (ll i = 0; i < level.size(); i++) level[i] = -1;\n\t\tqueue<ll> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty())\n    {\n\t\t\tll v = que.front(); que.pop();\n\t\t\tfor (ll i = 0; i < G[v].size(); i++)\n      {\n\t\t\t\tflowEdge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) \n        {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll dfs(ll v, ll t, ll f) \n  {\n\t\tif (v == t) return f;\n\t\tfor (ll &i = iter[v]; i < G[v].size(); i++)\n    {\n\t\t\tflowEdge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to])\n      {\n\t\t\t\tll d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tll max_flow(ll s, ll t)\n  {\n\t\tll flow = 0;\n\t\tfor(;;)\n    {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0) return flow;\n\t\t\tfor (int i = 0; i < iter.size(); i++) iter[i] = 0;\n\t\t\tll f;\n\t\t\twhile ((f = dfs(s, t, (1LL<<60))) > 0)\n      {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nll x, y, e, a, b;\n\nvector<pair<ll, ll>> L;//最大流の頂点\n\nint main()\n{\n\tcin >> x >> y >> e;\n  \n  Max_Flow X;\n  X.init(x+y+2);//頂点数で初期化\n\n  for (int i = 0; i < e; i++)//辺数\n  {\n    cin >> a >> b;\n    X.add_flowEdge(a+1, x+1+b, 1);//つなぐ頂点とコスト\n  }\n  \n\tfor (int i = 0; i < x; i++) \n  {\n\t\tX.add_flowEdge(0, i+1, 1);\n\t}\n  for (int i = 0; i < y; i++) \n  {\n\t\tX.add_flowEdge(x+1+i, x+y+1, 1);\n\t}\n  \n\tcout << X.max_flow(0, x+y+1) << endl;//開始頂点から終了頂点までの最大流を求める\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\n\n#define MAX_V 200\n\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\nbool dfs(int v){\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        int u = G[v][i], w = match[u];\n        if(w < 0 || !used[w] && dfs(w)){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for(int v = 0; v < V; v++){\n        if(match[v] < 0){\n            memset(used, 0, sizeof(used));\n            if(dfs(v))  res++;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int x, y, e;\n    cin >> x >> y >> e;\n    V = x+y;\n    int a, b;\n    while(e-- > 0){\n        cin >> a >> b;\n        add_edge(a,x+b);\n    }\n    cout << bipartite_matching() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define vmaxsize         1000\n#define emaxsize         10010\n#define unvisited          -1\n#define undefined          -1\n#define noparent            0\n#define free                0\n#define false               0\n#define true                1\nint tail[emaxsize+1], head[emaxsize+1];\nint edgefirst[vmaxsize+1], edgenext[emaxsize+1];\nint match[vmaxsize+1];  // ???v?????\\?¶?????????????????????°??????match[v]\nint m, n, n1, n2;       // ?????´????????°n1????????´????????°n2???n=n1+n2\nint level[vmaxsize+1];  // ??¬????????°?????????????????????v?????¬??????level[v]\nint queue[vmaxsize+1];  // ???????????¢?´¢?????????????????\\???\nint max_level;          // ????????????????????????????????´?????????????°???¬??????\nint t_found;            // ????????????????????????????????´???????????°???????????¨???t_found=true\nint front, rear;        // ?????\\????????????front??¨????°?rear\nint parent[vmaxsize + 1]; // ??±???????????¢?´¢??¨???????????????v??????parent[v]\nint pathfound, pathend;   // ?¢??????????????????¨ (pathfound=true)???pathend????????´?????????\nvoid bipartite_graph_input(void){\n    int a;\n    scanf(\"%d %d %d\", &n1, &n2, &m);\n    n=n1+n2; // n?????°??????????????°\n    for (a = 1; a <= m; a++) {\n        scanf(\"%d %d\", &tail[a], &head[a]);\n        tail[a]++;\n        head[a]++;\n        head[a] += n1;\n    }\n}\nvoid bipartite_incidence_list_construct(void){\n    int a, v1;\n    for (v1 = 1; v1 <= n1; v1++) edgefirst[v1] = 0;\n    for (a = m; a >= 1; a--) {\n        v1 = tail[a];\n        edgenext[a] = edgefirst[v1];\n        edgefirst[v1] = a;\n    }\n}\nvoid matching_output(void){\n    int a, v1, k;\n    k=0; \n    for (v1 = 1; v1 <= n1; v1++) {\n        if (match[v1] != free) {\n            k++;\n        }\n    }\n    printf(\"%d\\n\", k);\n}\nvoid bipartite_bfs(int v1){// ?????´??????v1??????????????¨??°????????§??????????????¢?´¢\n    int v2, w1;\n    int a,b;\n    for(a = edgefirst[v1]; a != 0; a = edgenext[a]) {// v1?????\\?¶???????????????????????????????????????????????????§??\\????????°?????????\n        v2 = head[a]; // a????????´??????v1???????????´??????v2???????????????????????¨?????????\n        if(level[v2] != unvisited){ // ?????´??????v2????¨???????????????¨???????????????????????????\n            ;\n        }else{// v2????????´????????§??????????¨????\n            level[v2] = level[v1] + 1;\n            if (t_found == n + 2){// ?¢??????????????????????????????£????????????\n                if (match[v2] != free) {// v2???????????????????????????\n                    b = match[v2]; // ??????????????°??????b\n                    w1 = tail[b]; // b????????????v2???????????????w1???????????????????????????\n                    level[w1] = level[v2] + 1; \n                    queue[++rear] = w1;\n                }\n                else {// v2???????????????????????????????????§v1??????v2????????????????¢??????????\n                    t_found = rear + 1; // t_found<n+2 ????¢??????????????????¨?????????\n                    max_level = level[v2];\n                }\n            }\n        }\n    }\n}\nvoid levelgraph(void){// ??¬????????°??????????§????\n    int v,v1;\n    rear = 0;    // ?????\\???????????????\n    front = 1;\n    t_found=n+2; // ?¢?????????????????????????????????????????????¨???????¨????\n    for (v = 1; v <= n; v++) level[v] = unvisited; // ????????????????¨??????¨???????¨????\n    for (v1 = 1; v1 <= n1; v1++) {\n        if (match[v1] == free) {// v1???????????????????????????????????´??????\n            level[v1] = 0; // v1??????????????¨??°????????????????????¢?´¢????????§????????????\n            queue[++rear] = v1; //?????\\???queue???????°????v1????????\\\n        }\n    }\n\n\n\n    while (front < t_found) {// ?¢???????????????????????????????????????????\n        if (front != rear + 1) {// ?????\\???queue????????§??????????????°?????????\n            v1 = queue[front++]; // ?????\\?????????????????????v1?????????\n            bipartite_bfs(v1); //v1??????????????¨??°????????????????????¢?´¢????§?\n        }\n        else {// ?????\\???queue????????§???????????§???while?????????????????¶????????????\n            break;\n        }\n    }\n\n\n    \n}\nvoid bipartite_dfs(int v1)\n{ // ?????´??????v1??????????????¨??°????????§?????±???????????¢?´¢\n    int v2, w1;\n    int a, b;\n    for (a = edgefirst[v1]; a != 0; a = edgenext[a])\n    {                 // v1?????\\?¶???????????????????????????????????????????????????§??\\????????°?????????\n        v2 = head[a]; // a????????´??????v1???????????´??????v2???????????????????????¨?????????\n        if (parent[v2] == undefined && level[v2] == level[v1] + 1)\n        {\n            parent[v2] = a; // a????????´??????v2?????????????????´??????v1???????????¨?????????\n            if (level[v2] != max_level)\n            {                   // v2????????´????????§????????????????????????\n                b = match[v2];  // ??????????????°??????b\n                w1 = tail[b];   // b????????????v2???????????????w1?????????????????????????????¨?????????\n                parent[w1] = b; // b????????´??????w1????????????v2?????????\n                bipartite_dfs(w1);\n/*\n                if (pathfound)\n                    return; //Added by Goro Satake\n*/\n            }\n            else\n            { // level[v2] == max_level\n                if (match[v2] == free)\n                {                     // v2????????´????????§???????????????????????????\n                    pathend = v2;     // ?¢??????????????????????v2\n                    pathfound = true; // ?¢????????????????\n                    return;           // ?¢????????????????????????°?????¶????????????????????±??????????????????????±????????????????\n                }\n            }\n        }\n    }\n}\nvoid augmentation(void)\n{\n    int v, v1, v2, w1;\n    int a, b;\n    for (v = 1; v <= n; v++)\n        parent[v] = undefined;\n    for (v1 = 1; v1 <= n1; v1++)\n    {\n        if (match[v1] != free)\n        {\n            continue;\n        }\n        else\n        {                          // v1???????????????????????????????????´??????\n            pathfound = false;     // v1??????????¢???????????????¢?´¢\n            parent[v1] = noparent; // v1???????????±???????????¢?´¢??¨?????????v1\n            bipartite_dfs(v1);     // v1???????????±?????????\n            if (!pathfound)\n            {\n                continue;\n            }\n            else\n            {                   // v1???????????±???????????§pathend???????¢????????????????\n                v2 = pathend;   // ??±???????????¢?´¢??¨??§pathend???????????????v1?????§?????????\n                a = parent[v2]; // ????????????????????????????????°?????¨?????????????????°????????????\n                match[v2] = a;\n                w1 = tail[a];\n                match[w1] = a;\n                while (w1 != v1)\n                {\n                    b = parent[w1];\n                    v2 = head[b];\n                    a = parent[v2];\n                    match[v2] = a;\n                    w1 = tail[a];\n                    match[w1] = a;\n                }\n            }\n        }\n    }\n}\nint main(void){\n    int v;\n    bipartite_graph_input(); \n    // ?????¨??°??????????????°m????????´?????°n1????????´?????°n2?????????????§?????????????????±?????????????\n    bipartite_incidence_list_construct(); // ??\\?¶?????????????????§?????????????\n    for (v = 1; v <= n; v++) match[v] = free; // ?????´??????????????????????????????????????????\n    levelgraph();\n    while(t_found != n + 2){\n        augmentation();\n        levelgraph();\n    }\n    matching_output(); // ??????????????????????????°?????????\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <set>\n#include <bitset>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int> >vpi;\ntypedef pair<int,int> pi;\n#define R return\n#define W while\n#define FOR(i,a) for(int i=0;i<a;i++)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define I insert\n#define P push\nint main(){\n    int x,y,k,l,r,ans=0,temp,n;\n    pair<priority_queue<pi,vpi,greater<pi> >,priority_queue<pi,vpi,greater<pi> > >pq;\n    pair<vi,vi>v[510];\n    pi d[510];\n    set<pi>s;\n    pair<bitset<510>,bitset<510>>b;\n    b.F.reset();\n    b.S.reset();\n    scanf(\"%d%d%d\",&x,&y,&k);\n    n=max(x,y)+1;\n    W(k--){\n        scanf(\"%d%d\",&l,&r);\n        if(s.count(MP(l,r)))continue;\n        s.I(MP(l,r));\n        v[l].F.PB(r);\n        v[r].S.PB(l);\n    }\n    FOR(i,n){\n        d[i].F=(int)v[i].F.size();\n        d[i].S=(int)v[i].S.size();\n        pq.F.P(MP(d[i].F,i));\n        pq.S.P(MP(d[i].S,i));\n    }\n    W(!(pq.F.empty()||pq.S.empty())){\n        if(pq.F.top().F<=pq.S.top().F){\n            temp=pq.F.top().S;\n            pq.F.pop();\n            if(b.F[temp])continue;\n            b.F[temp]=true;\n            FOR(i,v[temp].F.size())if(!b.S[v[temp].F[i]]){\n                b.S[v[temp].F[i]]=true;\n                ans++;\n                FOR(j,v[v[temp].F[i]].S.size())if(!b.F[v[v[temp].F[i]].S[j]]){\n                    d[v[v[temp].F[i]].S[j]].F--;\n                    pq.F.P(MP(d[v[v[temp].F[i]].S[j]].F,v[v[temp].F[i]].S[j]));\n                }\n            }\n        }\n        else{\n            temp=pq.S.top().S;\n            pq.S.pop();\n            if(b.S[temp])continue;\n            b.S[temp]=true;\n            FOR(i,v[temp].S.size())if(!b.F[v[temp].S[i]]){\n                b.F[v[temp].S[i]]=true;\n                ans++;\n                FOR(j,v[v[temp].S[i]].F.size())if(!b.S[v[v[temp].S[i]].F[j]]){\n                    d[v[v[temp].S[i]].F[j]].S--;\n                    pq.S.P(MP(d[v[v[temp].S[i]].F[j]].S,v[v[temp].S[i]].F[j]));\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define V (500)\n//n<=50000\n\nstruct edge{\n\tint to, cap, rev;\n};\nvector<edge> g[V];\nbool used[V];\nint n, m;\n\n//辺追加(1回)\nvoid add_edge(void){\n\tint x, y, z;\n\tscanf(\"%d %d\", &x, &y);\n\ty += n;\n\tg[x].push_back({ y, 1, g[y].size() });\n\tg[y].push_back({ x, 0, g[x].size() - 1 });\n}\n\n//増加路探索\nint dfs(int vec, int ep, int val){\n\tif (vec == ep)return val;\n\tused[vec] = true;\n\tf(i, g[vec].size()){\n\t\tedge &e = g[vec][i];\n\t\tif (!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs((e.to), ep, 1);\n\t\t\tif (d > 0){\n\t\t\t\te.cap = 0;\n\t\t\t\tg[e.to][e.rev].cap = 1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n//最大流探索\nint max_flow(int s, int t){\n\tint ret = 0;\n\tint res;\n\tbool z = true;\n\twhile (z){\n\t\tmemset(used, false, sizeof(used));\n\t\tres = dfs(s, t, 1);\n\t\tif (res == 0)z = false;\n\t\telse ret++;\n\t}\n\treturn ret;\n}\n\n//2部グラフ\nint main(void){\n\tint k, s, t;\n\tint x, y;\n\tint z, ans;\n\tscanf(\"%d %d %d\", &n, &m, &k);\n\tf(i, k){\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tx++;\n\t\ty++;\n\t\ty += n;\n\t\tg[x].push_back({ y, 1, g[y].size() });\n\t\tg[y].push_back({ x, 0, g[x].size() - 1 });\n\t}\n\tf(i, n){\n\t\tg[0].push_back({ i + 1, 1, g[i + 1].size() });\n\t\tg[i + 1].push_back({ 0, 0, g[0].size() - 1 });\n\t}\n\tf(i, m){\n\t\tg[n + i + 1].push_back({ n + m + 1, 1, g[n + m + 1].size() });\n\t\tg[n + m + 1].push_back({ n + i + 1, 0, g[n + i + 1].size() - 1 });\n\t}\n\tans = max_flow(0, n + m + 1);\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i,n) for (int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nstruct edge{\n\tint to, cap, rev;\n\tedge(int to,int cap, int rev):to(to),cap(cap),rev(rev){}\n};\nvector<vector<edge> > G; //??°???????????£??\\???????????¨???\nbool used[1003]; //DFS??§??¢???????????????????????????????????°\nint x,y,e;\nvoid add_edge(int from, int to, int cap){\n\t\tG[from].push_back(edge(to,cap,G[to].size()));\n\t\tG[to].push_back(edge(from,0,G[from].size() - 1));\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif( !used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -=d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxflow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tfill(used,used + e,false);\n\t\tint f = dfs(s,t,INF);\n\t\tif(f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n\tcin >> x >> y >> e;\n\tG.resize(x+y + 2);\n\tint s = x+y, t = s+1;\n\tREP(i,e){\n\t\tint from,to;\n\t\tcin >> from >> to;\n\t\tto += x;\n\t\tadd_edge(from,to,1);\n\t}\n\tREP(i,x){\n\t\tadd_edge(s,i,1);//?§?????????????????????????\n\t}\n\tREP(i,y){\n\t\tadd_edge(x + i,t,1);//????????????????????????\n\t}\n\tcout << maxflow(s,t) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <iomanip>\n#include <utility>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint exist(int y,const vector<int> &p) //y?????????????????¨??????????????§???????????? ????????°????????????x????????????????????????\n{\n    for(int i = 0; i < p.size(); i++)\n    {\n        if(p[i] == y)\n            return i;\n    }\n    return -1;\n}\n\nbool match(int x, int start, const vector<vector<bool> > &v,vector<int> &p) //??????????????°\n{\n    for(int i = start; i < v[0].size(); i++) //start??????y?????????????????§??°?????????\n    {\n        if(v[x][i]) //??????x,i?????¨?????????????????°\n        {\n            int rem = exist(i, p); //i????????§?????¨??????????????????\n            p[x] = i; //x,i?????¨????????§?????????\n            if(rem < 0) //i????????¨????????¨????????????????????°??¢??°?????????\n            {\n                return true;\n                \n            }\n            else //i????????¨????????¨?????????????????°\n            {\n                p[rem] = -1; //????????¨??????????¶????\n                bool ok = match(rem,i+1,v,p); //??£????????¨??????????????????????????????\n                if(!ok) //???????????????????????£??????????????????\n                {\n                    p[x] = -1;\n                    p[rem]= i;\n                }\n                else //???????????£????????¢??°????????????\n                    return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int xn,yn,e,x,y;\n    cin >> xn >> yn >> e;\n    vector< vector<bool> > v(xn, vector<bool>(yn,false));\n    vector<int> p(xn,-1);\n    for(int i = 0; i < e; i++)\n    {\n        cin >> x >> y;\n        v[x][y] = true;\n    }//???????????§?????????\n    \n    for(int i = 0; i<xn;i++)\n    {\n        match(i,0,v,p);\n    }\n    //???????????§?¨?????????????????????¨???\n    int c = 0;\n    for(int i = 0; i<p.size();i++)\n    {\n        if(p[i]>=0)\n            c++;\n    }\n    cout << c << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing Ti = tuple<int, int, int>;\nusing Tl = tuple<ll, ll, ll>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define F first\n#define S second\n#define Get(t, i) get<(i)>((t))\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\nconst int inf = 1 << 25;\nconst ll INF = 1LL << 55;\n\nstruct BipartiteMatching\n{\n  vector< vector<int> > graph;\n  vector<int> matched;\n  vector<bool> used;\n  BipartiteMatching(int V):graph(V), matched(V, -1), used(V, false){}\n  void add_edge(int u, int v)\n  {\n    graph[u].emplace_back(v);\n    graph[v].emplace_back(u);\n  }\n  bool dfs(int u)\n  {\n    used[u] = true;\n    for(auto& v : graph[u]) {\n      int w = matched[v];\n      if(w < 0 || !used[w] && dfs(w)) {\n\tmatched[u] = v;\n\tmatched[v] = u;\n\treturn true;\n      }\n    }\n    return false;\n  }\n  int match()\n  {\n    int res = 0;\n    for(int u = 0; u < graph.size(); u++) {\n      if(matched[u] < 0) {\n\tused.clear(); used.resize(graph.size(), false);\n\tif(dfs(u)) res++;\n      }\n    }\n    return res;\n  }\n};\n\n\nint main()\n{\n  int X, Y, E;\n  cin >> X >> Y >> E;\n  BipartiteMatching bpm(X + Y);\n  while(E--) {\n    int x, y; cin >> x >> y;\n    bpm.add_edge(x, y + X);\n  }\n  cout << bpm.match() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nstruct edge{int to,cap,rev;};\n\nconst int MAX_SIZE=202;\nconst int INF=1e9;\n\nint X,Y,E;\nvector<edge>G[MAX_SIZE];\n\nvoid add_edge(int from,int to,int cap){\n    G[from].push_back((edge){to,cap,G[to].size()});\n    G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nbool used[MAX_SIZE];\nint dfs(int p,int t,int f){\n    if(p==t)return f;\n    used[p]=true;\n\n    for(int i=0;i<G[p].size();i++){\n        edge &e=G[p][i];\n        if(used[e.to]||e.cap==0)continue;\n        int _f=dfs(e.to,t,min(f,e.cap));\n        if(_f){\n            e.cap-=_f;\n            G[e.to][e.rev].cap+=_f;\n            return _f;\n        }\n    }\n\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow=0;\n    while(true){\n        fill_n(used,MAX_SIZE,false);\n        int f=dfs(s,t,INF);\n        if(f)flow+=f;\n        else return flow;\n    }\n}\nint main(){\n    cin>>X>>Y>>E;\n    int s=X+Y,t=s+1;\n\n    for(int i=0;i<X;i++)add_edge(s,i,1);\n    for(int i=0;i<Y;i++)add_edge(X+i,t,1);\n\n    for(int i=0;i<E;i++){\n        int x,y;cin>>x>>y;\n        add_edge(x,y+X,1);\n    }\n\n    cout<<max_flow(s,t)<<endl;\n    return 0;\n}\n\n//348504373"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n//#include \"MyMath.h\"\n//#include \"MyDisjointset.h\"\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\nusing namespace std;\ntypedef pair<int, int> P; typedef long long int ll; typedef vector <int> vecint; typedef vector <vecint> dvecint; typedef vector <dvecint> vecdvecint; typedef vector <vector <dvecint> > dvecdvecint;\nconst int INF = 100000000;\nint match[200], used[200];\nvector <int> G[200];\nbool dfs(int v) {\n\tused[v] = 1;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tint u = G[v][i]; int w = match[u];\n\t\tif (w < 0 ||!used[w] && dfs(w) ){\n\t\t\tmatch[u] = v;\n\t\t\tmatch[v] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint main() {\n\tint nx, ny, ne; cin >> nx >> ny >> ne;\n\tfor (int i = 0; i < ne; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tG[x].push_back(y + nx);\n\t\tG[y + nx].push_back(x);\n\t}\n\tint v = nx + ny;\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int i = 0; i < v; i++) {\n\t\tmemset(used, 0, sizeof(used));\n\t\tif (dfs(i))\n\t\t\tres++;\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight = 0) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight :\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nbool augment(Graph& g, int u,\n\tvector<int>& matchTo, vector<bool>& visited) {\n\tif (u < 0) return true;\n\tfor(Edge& e: g[u]) if (!visited[e.dst]) {\n\t\tvisited[e.dst] = true;\n\t\tif (augment(g, matchTo[e.dst], matchTo, visited)) {\n\t\t\tmatchTo[e.src] = e.dst;\n\t\t\tmatchTo[e.dst] = e.src;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint bipartiteMatching(Graph& g, int L, Edges& matching) {\n\tconst int n = g.size();\n\tvector<int> matchTo(n, -1);\n\tint match = 0;\n\tfor (int u = 0; u < L;u++) {\n\t\tvector<bool> visited(n);\n\t\tif (augment(g, u, matchTo, visited)) ++match;\n\t}\n\tfor (int u = 0; u < L;u++) if (matchTo[u] >= 0)\n\t\tmatching.push_back(Edge(u, matchTo[u]));\n\treturn match;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint X, Y, E; cin >> X >> Y >> E;\n\tGraph g(X + Y);\n\tEdges match;\n\tfor (int i = 0; i < E; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tg[x].emplace_back(Edge(x, X + y));\n\t\tg[X + y].emplace_back((Edge(X + y, x)));\n\t}\n\tcout << bipartiteMatching(g, X, match) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nclass Matching{\n    public:\n    ll size;\n    vector<vector<ll> > g;\n    vector<ll> match;\n    vector<bool> checked;\n\n    Matching(ll n){\n        size = n;\n        g = vector<vector<ll> >(size);\n        match = vector<ll>(size, -1);\n        checked = vector<bool>(size, false);\n    }\n\n    void add_edge(ll u, ll v){\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n\n    bool dfs(ll v){\n        checked[v] = true;\n        for(ll u: g[v]){\n            ll m = match[u];\n            if(m < 0 || !checked[m] && dfs(m)){\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    ll bipartite_matching(){\n        ll res = 0;\n        for(ll v=0;v<size;v++){\n            if(match[v] < 0){\n                fill(checked.begin(), checked.end(), false);\n                if(dfs(v)){\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n};\n\n// GRL_7_A: verified\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    ll nx, ny, ne; cin >> nx >> ny >> ne;\n    Matching mat(nx + ny);\n    for(ll i=0;i<ne;i++){\n        ll x, y; cin >> x >> y;\n        mat.add_edge(x, nx + y);\n    }\n    cout << mat.bipartite_matching() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int64_t i=(a); i<(b); ++i) // a ≦ i < b \n#define ALL(a) (a).begin(),(a).end()\n#define INF 1000000000\n\n// 辺の（行先，容量，逆辺が保存されているG[to]での番地）．\nstruct edge {int to, cap, rev;};\n\nvector<vector<edge>> G; //有向グラフとその残余グラフ．\nvector<int> level; // sからの距離\nvector<int> iter; // どこまで調べ終わったか．\n\nvoid add_edge(int from, int to , int cap){\n    G[from].push_back(edge{to, cap, (int)G[to].size()});\n    G[to].push_back(edge{from, 0, (int)G[from].size() - 1});\n}\n\n//sからの最短距離をbfsで計算．levelに記録．\nvoid bfs(int s){\n    fill(ALL(level), -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty()){\n        int v = que.front(); que.pop();\n        for (edge &e:G[v])\n            if (e.cap > 0 && level[e.to] < 0){\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n    }\n}\n\n//v から t へのパスを DFS で探し，そのパスで流せる最大流量を返す．\n// mincap = 通った辺の中の最少容量\nint flow_dfs(int v, int t, int mincap){\n    if (v == t) return mincap;\n    for (int &i = iter[v]; i <  G[v].size(); ++i){\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[v] < level[e.to]){\n            int d = flow_dfs(e.to, t, min(mincap, e.cap));\n            if (d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// sからtへの最大流\nint max_flow(int s, int t){\n    int flow = 0;\n    while (true){\n        bfs(s);\n        if (level[t] < 0) return flow;\n        fill(ALL(iter), 0);\n        int f;\n        while((f = flow_dfs(s, t, INF)) > 0)\n            flow += f;\n    }\n}\n\nint main() {\ncin.tie(0);\nios::sync_with_stdio(false);\n\n// 二部マッチング．AOJ.\n// Dinic ．O(EV²). \nint X, Y, E; cin >> X >>  Y >> E;\n// 0 始点．1,..., X X頂点，X+1,...,X+Y+1, Y頂点，X+Y+2 終点．\nG.assign(X + Y + 3, vector<edge>());\nlevel.assign(X + Y + 3, 0);\niter.assign(X + Y + 3, 0);\nrep(i, 0, E){\n    int x, y; cin >> x >> y;\n    add_edge(x+1, y+X+1, 1); \n}\n// 始点とX点を結ぶ\nrep(i, 1, X+1) add_edge(0, i, 1);\n// 終点とY点を結ぶ\nrep(i, X+1, X + Y + 2) add_edge(i, X + Y + 2, 1);\n\n\ncout << max_flow(0, X+Y+2) << endl;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <climits>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <cctype>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef vector<bool> VB;\ntypedef vector<char> VC;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\ntypedef vector<LL> VLL;\ntypedef vector<VI> VVI;\ntypedef vector<VB> VVB;\ntypedef vector<VS> VVS;\ntypedef vector<VLL> VVLL;\ntypedef vector<VVI> VVVI;\ntypedef vector<VVLL> VVVLL;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<int, string> PIS;\ntypedef pair<string, int> PSI;\ntypedef pair<string, string> PSS;\n\n\n//数値・文字列\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ninline LL toLongLong(string s) {\n    LL v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\n\ntemplate<class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\ninline VC toVC(string s) {\n    VC data(s.begin(), s.end());\n    return data;\n}\n\ntemplate<typename List>\nvoid SPRIT(const std::string &s, const std::string &delim, List &result) {\n    result.clear();\n    string::size_type pos = 0;\n    while (pos != string::npos) {\n        string::size_type p = s.find(delim, pos);\n        if (p == string::npos) {\n            result.push_back(s.substr(pos));\n            break;\n        } else {\n            result.push_back(s.substr(pos, p - pos));\n        }\n        pos = p + delim.size();\n    }\n}\n\nstring TRIM(const string &str, const char *trimCharacterList = \" \\t\\v\\r\\n\") {\n    string result;\n    string::size_type left = str.find_first_not_of(trimCharacterList);\n    if (left != string::npos) {\n        string::size_type right = str.find_last_not_of(trimCharacterList);\n        result = str.substr(left, right - left + 1);\n    }\n    return result;\n}\n\ntemplate<typename T>\nbool VECTOR_EXISTS(vector<T> vec, T data) {\n    auto itr = std::find(vec.begin(), vec.end(), data);\n    size_t index = distance(vec.begin(), itr);\n    if (index != vec.size()) {\n        return true;\n    } else {\n        return 0;\n    }\n}\n\n#define UPPER(s) transform((s).begin(), (s).end(), (s).begin(), ::toupper)\n#define LOWER(s) transform((s).begin(), (s).end(), (s).begin(), ::tolower)\n\n\n\n//四捨五入 nLen=小数点第N位にする\n//------------------------------------------\n\n//切り上げ\ndouble ceil_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.9);\n    return dOut * pow(10.0, -nLen);\n}\n\n//切り捨て\ndouble floor_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut);\n    return dOut * pow(10.0, -nLen);\n}\n\n//四捨五入\ndouble round_n(double dIn, int nLen) {\n    double dOut;\n    dOut = dIn * pow(10.0, nLen);\n    dOut = (double) (int) (dOut + 0.5);\n    return dOut * pow(10.0, -nLen);\n}\n\n//n桁目の数の取得\nint take_a_n(int num, int n) {\n    string str = toString(num);\n    return str[str.length() - n] - '0';\n}\n\n\n//進数\n//------------------------------------------\n\n//\"1111011\" → 123\nint strbase_2to10(const std::string &s) {\n    int out = 0;\n    for (int i = 0, size = s.size(); i < size; ++i) {\n        out *= 2;\n        out += ((int) s[i] == 49) ? 1 : 0;\n    }\n    return out;\n}\n\n//\"123\" → 1111011\nint strbase_10to2(const std::string &s) {\n    int binary = toInt(s);\n    int out = 0;\n    for (int i = 0; binary > 0; i++) {\n        out = out + (binary % 2) * pow(static_cast<int>(10), i);\n        binary = binary / 2;\n    }\n    return out;\n}\n\n//\"ABC\" 2748\nint strbase_16to10(const std::string &s) {\n    int out = stoi(s, 0, 16);\n    return out;\n}\n\n//1111011 → 123\nint intbase_2to10(int in) {\n    string str = toString(in);\n    return strbase_2to10(str);\n}\n\n//123 → 1111011\nint intbase_10to2(int in) {\n    string str = toString(in);\n    return strbase_10to2(str);\n}\n\nint intbase_16to10(int in) {\n    string str = toString(in);\n    return strbase_16to10(str);\n}\n\n//123→ \"7B\"\nstring intbase_10to16(unsigned int val, bool lower = true) {\n    if (!val)\n        return std::string(\"0\");\n    std::string str;\n    const char hc = lower ? 'a' : 'A';     // 小文字 or 大文字表記\n    while (val != 0) {\n        int d = val & 15;     // 16進数一桁を取得\n        if (d < 10)\n            str.insert(str.begin(), d + '0');  //  10未満の場合\n        else //  10以上の場合\n            str.insert(str.begin(), d - 10 + hc);\n        val >>= 4;\n    }\n    return str;\n}\n\n//整数を2進数表記したときの1の個数を返す\nLL bitcount64(LL bits) {\n    bits = (bits & 0x5555555555555555) + (bits >> 1 & 0x5555555555555555);\n    bits = (bits & 0x3333333333333333) + (bits >> 2 & 0x3333333333333333);\n    bits = (bits & 0x0f0f0f0f0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f0f0f0f0f);\n    bits = (bits & 0x00ff00ff00ff00ff) + (bits >> 8 & 0x00ff00ff00ff00ff);\n    bits = (bits & 0x0000ffff0000ffff) + (bits >> 16 & 0x0000ffff0000ffff);\n    return (bits & 0x00000000ffffffff) + (bits >> 32 & 0x00000000ffffffff);\n}\n\n\n\n//comparison\n//------------------------------------------\n#define C_MAX(a, b) ((a)>(b)?(a):(b))\n#define C_MIN(a, b) ((a)<(b)?(a):(b))\n#define C_ABS(a, b) ((a)<(b)?(b)-(a):(a)-(b))\n\n\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define EACH(i, c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define COUNT(obj, v) count((obj).begin(), (obj).end(), v)\n#define SEARCH(v, w) search((v).begin(), (v).end(), (w).begin(), (w).end())\n#define B_SEARCH(obj, v) binary_search((obj).begin(), (obj).end(), v)\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define REVERSE(c) reverse((c).begin(), (c).end())\n#define SUMI(obj) accumulate((obj).begin(), (obj).end(), 0)\n#define SUMD(obj) accumulate((obj).begin(), (obj).end(), 0.)\n#define SUMLL(obj) accumulate((obj).begin(), (obj).end(), 0LL)\n#define SUMS(obj) accumulate((obj).begin(), (obj).end(), string())\n#define UB(obj, n) upper_bound((obj).begin(), (obj).end(), n)\n#define LB(obj, n) lower_bound((obj).begin(), (obj).end(), n)\n#define PB push_back\n#define MP make_pair\n\n\n\n\n//input output\n//------------------------------------------\n#define GL(s) getline(cin, (s))\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define OUT(d) std::cout<<(d);\n#define OUT_L(d) std::cout<<(d)<<endl;\n#define FOUT(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data);\n#define FOUT_L(n, data) std::cout<<std::fixed<<std::setprecision(n)<<(data)<<\"\\n\";\n#define EL() std::cout << \"\\n\";\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v) {std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\ntemplate<typename T>\nstd::istream &operator>>(std::istream &is, std::vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\ntemplate<typename T>\nstd::ostream &operator<<(std::ostream &os, const std::vector<T> &vec) {\n    for (const T &x : vec) os << x << \" \";\n    return os;\n}\n\n\n//repetition\n//------------------------------------------\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n)  FOR(i,0,n)\n#define RREP(i, n) for(int i = n-1;i >= 0;i--)\n#define FORLL(i, a, b) for(LL i=LL(a);i<LL(b);++i)\n#define RFORLL(i, a, b) for(LL i=LL(b)-1;i>=LL(a);--i)\n#define REPLL(i, n) for(LL i=0;i<LL(n);++i)\n#define RREPLL(i, n) for(LL i=LL(n)-1;i>=0;--i)\n#define FOREACH(x, v) for(auto &(x) : (v))\n#define FORITER(x, v) for(auto (x) = (v).begin(); (x) != (v).end(); ++(x))\n\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int MOD = 1000000007;\n//const int dx[] = {-1, 0, 1, 0};\n//const int dy[] = {0, 1, 0, -1};\n\n\n//math\n//--------------------------------------------\n\n//min <= aim <= max\ntemplate<typename T>\ninline bool BETWEEN(const T aim, const T min, const T max) {\n    if (min <= aim && aim <= max) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\ntemplate<class T>\ninline T SQR(const T x) { return x * x; }\n\ntemplate<class T1, class T2>\ninline T1 POW(const T1 x, const T2 y) {\n    if (!y)return 1;\n    else if ((y & 1) == 0) {\n        return SQR(POW(x, y >> 1));\n    } else return POW(x, y ^ 1) * x;\n}\n\n\ntemplate<typename T>\nconstexpr T ABS(T x) {\n    return x < 0 ? -x : x;\n}\n\n//partial_permutation nPr 順列\n//first・・最初の数\n//middle・・r(取り出す数)\n//last・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_partial_permutation(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last) {\n    reverse(middle, last);\n    return next_permutation(first, last);\n}\n\n//combination nCr 組み合わせ\n//first1・・最初の数\n//last1==first2・・r(取り出す数)\n//last2・・n(全体数)\ntemplate<class BidirectionalIterator>\nbool next_combination(BidirectionalIterator first1, BidirectionalIterator last1, BidirectionalIterator first2,\n                      BidirectionalIterator last2) {\n    if ((first1 == last1) || (first2 == last2)) {\n        return false;\n    }\n    BidirectionalIterator m1 = last1;\n    BidirectionalIterator m2 = last2;\n    --m2;\n    while (--m1 != first1 && !(*m1 < *m2)) {\n    }\n    bool result = (m1 == first1) && !(*first1 < *m2);\n    if (!result) {\n        while (first2 != m2 && !(*m1 < *first2)) {\n            ++first2;\n        }\n        first1 = m1;\n        std::iter_swap(first1, first2);\n        ++first1;\n        ++first2;\n    }\n    if ((first1 != last1) && (first2 != last2)) {\n        m1 = last1;\n        m2 = first2;\n        while ((m1 != first1) && (m2 != last2)) {\n            std::iter_swap(--m1, m2);\n            ++m2;\n        }\n        std::reverse(first1, m1);\n        std::reverse(first1, last1);\n        std::reverse(m2, last2);\n        std::reverse(first2, last2);\n    }\n    return !result;\n}\n\n\n\n\n//numeric_law\n//--------------------------------------------\n\ntemplate<typename T>\nconstexpr bool ODD(T x) {\n    return x % 2 != 0;\n}\n\ntemplate<typename T>\nconstexpr bool EVEN(T x) {\n    return x % 2 == 0;\n}\n\n//最大公約数\ntemplate<class T>\ninline T GCD(const T x, const T y) {\n    if (x < 0)return GCD(-x, y);\n    if (y < 0)return GCD(x, -y);\n    return (!y) ? x : GCD(y, x % y);\n}\n\n//最小公倍数\ntemplate<class T>\ninline T LCM(const T x, const T y) {\n    if (x < 0)return LCM(-x, y);\n    if (y < 0)return LCM(x, -y);\n    return x * (y / GCD(x, y));\n}\n\n//ax + by = 1\n//x,yが変数に格納される\ntemplate<class T>\ninline T EXTGCD(const T a, const T b, T &x, T &y) {\n    if (a < 0) {\n        T d = EXTGCD(-a, b, x, y);\n        x = -x;\n        return d;\n    }\n    if (b < 0) {\n        T d = EXTGCD(a, -b, x, y);\n        y = -y;\n        return d;\n    }\n    if (!b) {\n        x = 1;\n        y = 0;\n        return a;\n    } else {\n        T d = EXTGCD(b, a % b, x, y);\n        T t = x;\n        x = y;\n        y = t - (a / b) * y;\n        return d;\n    }\n}\n\n//素数\ntemplate<class T>\ninline bool ISPRIME(const T x) {\n    if (x <= 1)return false;\n    for (T i = 2; SQR(i) <= x; i++)if (x % i == 0)return false;\n    return true;\n}\n\n//素数をtrueとして返す\ntemplate<class T>\nVB ERATOSTHENES(const T n) {\n    VB arr(n, true);\n    for (int i = 2; SQR(i) < n; i++) {\n        if (arr[i]) {\n            for (int j = 0; i * (j + 2) < n; j++) {\n                arr[i * (j + 2)] = false;\n            }\n        }\n    }\n    return arr;\n}\n\n// a <= x < b の素数を返す\ntemplate<typename T>\nVB ERATOSTHENES(const T a, const T b) {\n    VB small = ERATOSTHENES(b);\n    VB prime(b - a, true);\n\n    for (int i = 2; (T) (SQR(i)) < b; i++) {\n        if (small[i]) {\n            for (T j = max(2, (a + i - 1) / i) * i; j < b; j += i) {\n                prime[j - a] = false;\n            }\n        }\n    }\n\n    return prime;\n}\n\n//約数\ntemplate<class T>\nvector<T> DIVISOR(T n) {\n    vector<T> v;\n    for (int i = 1; i * i <= n; ++i) {\n        if (n % i == 0) {\n            v.push_back(i);\n            if (i != n / i) {\n                v.push_back(n / i);\n            }\n        }\n    }\n    sort(v.begin(), v.end());\n    return v;\n}\n\n//組み合わせ個数\ntemplate<typename T>\nT NCR(T n, T r) {\n    T ans = 1;\n    REPLL(i, r) {\n        ans = ans * (n - i) / (i + 1);\n    }\n    return ans;\n}\n\n//行列\nint MATRIZ_CHAIN(VI &p, VVI &s) {\n    const static int INF = 1 << 20;\n    const int n = p.size() - 1;\n    VVI X(n, VI(n, INF));\n    s.resize(n, VI(n));\n    for (int i = 0; i < n; ++i) X[i][i] = 0;\n    for (int w = 1; w < n; ++w)\n        for (int i = 0, j; j = i + w, j < n; ++i)\n            for (int k = i; k < j; ++k) {\n                int f = p[i] * p[k + 1] * p[j + 1];\n                if (X[i][k] + X[k + 1][j] + f < X[i][j]) {\n                    X[i][j] = X[i][k] + X[k + 1][j] + f;\n                    s[i][j] = k;\n                }\n            }\n    return X[0][n - 1];\n}\n\n//最長増加部分列\nVI LIS(const VI &a) {\n    const static int INF = 99999999;\n    const int n = a.size();\n    VI A(n, INF);\n    VI id(n);\n    for (int i = 0; i < n; ++i) {\n        id[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n        A[id[i]] = a[i];\n    }\n    int m = *max_element(id.begin(), id.end());\n    VI b(m + 1);\n    for (int i = n - 1; i >= 0; --i)\n        if (id[i] == m) b[m--] = a[i];\n    return b;\n}\n\n//最長共通部分列 string->toVC\ntemplate<typename T>\nvector<T> LCS(const vector<T> &a, const vector<T> &b) {\n    const int n = a.size(), m = b.size();\n    vector<VI> X(n + 1, VI(m + 1));\n    vector<VI> Y(n + 1, VI(m + 1));\n    REP(i, n) {\n        REP(j, m) {\n            if (a[i] == b[j]) {\n                X[i + 1][j + 1] = X[i][j] + 1;\n                Y[i + 1][j + 1] = 0;\n            } else if (X[i + 1][j] < X[i][j + 1]) {\n                X[i + 1][j + 1] = X[i][j + 1];\n                Y[i + 1][j + 1] = +1;\n            } else {\n                X[i + 1][j + 1] = X[i + 1][j];\n                Y[i + 1][j + 1] = -1;\n            }\n        }\n    }\n    vector<T> c;\n    for (int i = n, j = m; i > 0 && j > 0;) {\n        if (Y[i][j] > 0) --i;\n        else if (Y[i][j] < 0) --j;\n        else {\n            c.PB(a[i - 1]);\n            --i;\n            --j;\n        }\n    }\n    REVERSE(c);\n    return c;\n}\n\n//コイン C総額 cs使用できるコインの種類\nVI money_change(int C, VI &cs) {\n    const int INF = 99999999;\n    int n = cs.size();\n    VI xs(C + 1, INF);\n    VI ys(C + 1);\n    xs[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int c = 0; c + cs[i] <= C; ++c) {\n            if (xs[c + cs[i]] > xs[c] + 1) {\n                xs[c + cs[i]] = xs[c] + 1;\n                ys[c + cs[i]] = c;\n            }\n        }\n    }\n    VI zs;\n    for (int c = C; c > 0; c = ys[c]) {\n        zs.push_back(c - ys[c]);\n    }\n    return zs;\n}\n\n\n\n\n\n//confirmation\n//--------------------------------------------\n\n//clear memory\n#define CLR(arr, d) memset((arr), (d),sizeof(arr))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n\n#define MAX_V 400\n#define INF (1<<20)\n\n\n//点toに向かう辺\n//G[e.to][e.rev]で辺eの逆辺を使用できる\nstruct Edge {\n    int to;     //目的地\n    int cap;    //通せる最大量\n    int rev;    //逆辺の添字を表す\n};\n\nvector<Edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((Edge) {to, cap, (int) G[to].size()});\n    G[to].push_back((Edge) {from, 0, (int) G[from].size() - 1});\n}\n\n//vからtへ移動可能であれば、そのルートへの最大流量fを返す\n//不可能なら0を返す\nint dfs(int v, int t, int f) {\n\n    //sinkまでたどり着いたら最大流量fを返す\n    if (v == t) return f;\n\n    used[v] = true;\n\n    //頂点vから出る辺にアクセスする\n    for (int i = 0; i < G[v].size(); i++) {\n        Edge &e = G[v][i];\n\n        //辺の先が使われていない、かつこの辺がまだ流せるなら\n        if (!used[e.to] && e.cap > 0) {\n\n            //vからtまでの一番小さい流量を取り出す\n            int d = dfs(e.to, t, min(f, e.cap));\n\n            //流せるなら\n            if (d > 0) {\n                //向かう辺の容量を減らす\n                e.cap -= d;\n\n                //逆辺の容量を増やす\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n\n    //本当に移動不可能でないとここにたどり着かない\n    return 0;\n}\n\n\n//sからtへの最大流量を返す\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (true) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) {\n            return flow;\n        }\n        flow += f;\n    }\n}\n\n\n/*\n *\n *\n *   ~~~~Below My Answer~~~~\n *\n *\n **/\n\n\nint main() {\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n\n    int s = 0;\n    int t = X + Y + 1;\n\n    //sからXに辺を貼る\n    //Yからtに辺を貼る\n    for (int i = 1; i <= X; i++) add_edge(s, i, 1);\n    for (int i = X + 1; i <= (X + Y); i++) add_edge(i, t, 1);\n\n    //XとYに辺を貼る\n    for (int i = 0; i < E; i++) {\n        int x, y;\n        cin >> x >> y;\n        x++;\n        y += (X + 1);\n        add_edge(x, y, 1);\n    }\n\n    cout << max_flow(s, t) <<endl;\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define MAX_V 2010\n#define MAX_N 1010\nusing namespace std;\nint V;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i=0; i<G[v].size(); i++){\n    int u = G[v][i], w = match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  memset(match, -1, sizeof(match));\n  for(int v=0; v<V; v++){\n    if(match[v] < 0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)) res++;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n,m,l;\n  while(1){\n    cin>>n>>m>>l;\n    if(!n&&!m&&!l)break;\n    vector<vector<int> >g(n,vector<int>(n,INF));\n    for(int i=0;i<n;i++) g[i][i]=0;\n    for(int i=0;i<MAX_V;i++)G[i].clear();\n    \n    for(int i=0,a,b,c;i<m;i++)cin>>a>>b>>c,g[a][b]=g[b][a]=c;\n    \n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n    \n    vector<int>idx(l),tl(l);\n    for(int i=0,a,b;i<l;i++)cin>>a>>b,tl[i]=b,idx[i]=a;\n    \n    \n    for(int i=0;i<l;i++)\n      for(int j=0;j<l;j++)\n\tif(i!=j&&tl[i]+g[idx[i]][idx[j]]<=tl[j])add_edge(i,l+j);\n\n    V=l+l+2;\n    cout <<l-bipartite_matching()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n \n \nstruct edge {\n  int from;\n  int to;\n  i64 cost;\n  int num;\n};\n\nstruct gabow_scaling_wbm {\n  i64 res;\n  vector<i64> c,yd,y,mate,used;\n  int n;\n  int m;\n  const vector<vector<edge>>& g;\n  int V0;\n  i64 cl(const edge& e) {\n    return c[e.num] - y[e.from] - y[e.to] + (mate[e.to] == e.from ? 0 : 1);\n  };\n  bool eligible(const edge& e) {\n    return yd[e.from] + yd[e.to] == cl(e);\n  }\n  bool hk_dfs(int v, vector<bool>& vis, vector<bool>& vv) {\n    vis[v] = true;\n    for(const auto& e : g[v]) {\n      if(!eligible(e)) continue;\n      if(mate[e.to] == -1 || (!vis[mate[e.to]] && hk_dfs(mate[e.to], vis, vv))) {\n        mate[e.to] = v;\n        used[v] = true;\n        vv[e.to] = true;\n        return true;\n      }\n    }\n    return false;\n  };\n\n  bool hk() {\n    bool loop = false;\n    bool res = true;\n    vector<bool> vv(n, false);\n\n    {\n      loop = false;\n\n\n\n      for(int i = 0;i < V0;i++) {\n        if(!used[i]) {\n          vector<bool> vis(n, false);\n          if(hk_dfs(i, vis, vv)) {\n            loop = true;\n          }\n        }\n      }\n      res = true;\n      for(int i = V0;i < n;i++) {\n        if(mate[i] == -1) res = false;\n      }\n    }\n    /*\n       cout << \"===\" << endl;\n       for(int i = V0;i < n;i++) {\n       if(mate[i] != -1) {\n       cout << mate[i] << \"-\" << i << endl;\n       }\n       }\n       */\n\n    for(int i = V0;i < n;i++) {\n      if(vv[i]) yd[i]--;\n    }\n    return res;\n  };\n\n  gabow_scaling_wbm(const vector<vector<edge>>& g, int v0) : g(g) {\n    this->V0 = v0;\n    n = g.size();\n    m = 0;\n    auto MF = [&]() {\n      i64 MAX = 1;\n      for(int i = 0;i < n;i++) {\n        for(const auto& e : g[i]) {\n          m++;\n          MAX = max(MAX , abs(e.cost));\n        }\n      }\n      return MAX;\n    };\n    int k = (int)log2(MF() * (n + 1)) + 1;\n    vector<edge> es(m);\n\n    for(int i = 0;i < n;i++) {\n      for(const auto& e : g[i]) {\n        es[e.num] = e;\n      }\n    }\n\n\n    c.assign(m,0);\n    yd.assign(n, 0);\n    y.assign(n,0);\n    mate.assign(n , -1);\n    used.assign(n, false);\n\n\n\n\n    for(int s = k - 1;s >= 0;s--) {\n      //cout << \"scaling\" << \" \" << s << endl;\n      for(int i = 0;i < m;i++) {\n        c[i] = c[i] * 2 + (es[i].cost >= 0 ? 1 : -1) * ((abs(es[i].cost) >> s) & 1);\n      }\n      for(int i = 0;i < n;i++) {\n        y[i] = y[i] * 2 - 1;\n      }\n\n      yd.assign(n, 0);\n      mate.assign(n, -1);\n      used.assign(n, false);\n\n      int cnt = 0;\n\n      while(!hk()) {\n        vector<bool> vis(n, false);\n\n        using P = pair<i64,i64>;\n\n        vector<queue<int>> Q(5 * n + 1);\n        int idx = 0;\n\n        vector<i64> dd(n, 0);\n        i64 DELTA = 0;\n\n        for(int i = 0;i < V0;i++) {\n          if(!used[i]) {\n            for(const auto& e: g[i]) {\n              auto xx = cl(e) - yd[i] - yd[e.to] + dd[i];\n              if(Q.size() <= xx) continue;\n              Q[xx].push(e.to);\n            }\n            vis[i] = true;\n          }\n        }\n\n        bool freed = false;\n\n        while(true) {\n          while(idx < Q.size() && Q[idx].empty()) idx++;\n          if(idx >= Q.size()) break;\n          i64 D = idx;\n          int w = Q[idx].front();\n          Q[idx].pop();\n          if(vis[w]) continue;\n          if(freed && DELTA != D) break;\n          vis[w] = true;\n          DELTA = D;\n          dd[w] = DELTA;\n          if(mate[w] != -1 && !vis[mate[w]]) {\n            int mm = mate[w];\n            dd[mm] = DELTA;\n            for(const auto& e : g[mm]) {\n              if(vis[e.to]) continue;\n              if(mate[e.to] == mm) continue;\n              auto xx = cl(e) - yd[mm] - yd[e.to] + dd[mm];\n              if(Q.size() <= xx) continue;\n              Q[xx].push(e.to);\n            }\n            vis[mm] = true;\n          }\n          else if(mate[w] == -1) {\n            freed = true;\n          }\n        }\n\n        for(int i = 0;i < n;i++) {\n          if(!vis[i]) continue;\n          yd[i] = yd[i] + (DELTA - dd[i]) * (i < V0 ? 1 : -1);\n        }\n      }\n      for(int i = 0;i < n;i++) {\n        y[i] = y[i] + yd[i];\n      }\n    }\n\n    i64 ans = 0;\n    for(int i = 0;i < n;i++) {\n      ans += y[i];\n    }\n    res = ans;\n  }\n};\n\nint main() {\n  int x,y,m;\n  cin >> x >> y >> m;\n  vector<vector<edge>> g(x + y + x + y);\n  int idx = 0;\n  for(int i = 0;i < m;i++) {\n    int v,w;\n    cin >> v >> w;\n    g[v].push_back({v, w + x + y, -1  , idx++});\n    g[w + x].push_back({w + x, v + x + y + y, -1, idx++});\n  }\n  for(int i = 0;i < x; i++) {\n    g[i].push_back({i, i + x + y + y, 0, idx++});\n  }\n  for(int i = x;i < x + y;i++) {\n    g[i].push_back({i, i + y, 0, idx++});\n  }\n  cout << -gabow_scaling_wbm(g,x + y).res / 2 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define EVEN(x) (mu[x] == x || (mu[x] != x && phi[mu[x]] != mu[x]))\n#define ODD(x)  (mu[x] != x && phi[mu[x]] == mu[x] && phi[x] != x)\n#define OUTER(x) (mu[x] != x && phi[mu[x]] == mu[x] && phi[x] == x)\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nint maximumMatching(const Graph &g) {\n\tint n = g.size();\n\tvector<int> mu(n), phi(n), rho(n), scanned(n);\n\tREP(v, n) mu[v] = phi[v] = rho[v] = v; // (1) initialize\n\tfor (int x = -1; ; ) {\n\t\tif (x < 0) {                        // (2) select even\n\t\t\tfor (x = 0; x < n && (scanned[x] || !EVEN(x)); ++x);\n\t\t\tif (x == n) break;\n\t\t}\n\t\tint y = -1;                         // (3) select incident\n\t\tfor (int e = 0; e < (int)g[x].size(); e++) if (OUTER(g[x][e].dst) || (EVEN(g[x][e].dst) && rho[g[x][e].dst] != rho[x])) y = g[x][e].dst;\n\t\tif (y == -1) scanned[x] = true, x = -1;\n\t\telse if (OUTER(y)) phi[y] = x;      // (4) growth\n\t\telse {\n\t\t\tvector<int> dx(n, -2), dy(n, -2); // (5,6), !TRICK! x % 2 --> x >= 0\n\t\t\tfor (int k = 0, w = x; dx[w] < 0; w = k % 2 ? mu[w] : phi[w]) dx[w] = k++;\n\t\t\tfor (int k = 0, w = y; dy[w] < 0; w = k % 2 ? mu[w] : phi[w]) dy[w] = k++;\n\t\t\tbool vertex_disjoint = true;\n\t\t\tREP(v, n) if (dx[v] >= 0 && dy[v] > 0) vertex_disjoint = false;\n\t\t\tif (vertex_disjoint) {            // (5) augment\n\t\t\t\tREP(v, n) if (dx[v] % 2) mu[phi[v]] = v, mu[v] = phi[v];\n\t\t\t\tREP(v, n) if (dy[v] % 2) mu[phi[v]] = v, mu[v] = phi[v];\n\t\t\t\tmu[x] = y; mu[y] = x; x = -1;\n\t\t\t\tREP(v, n) phi[v] = rho[v] = v, scanned[v] = false;\n\t\t\t}\n\t\t\telse {                          // (6) shrink\n\t\t\t\tint r = x, d = n;\n\t\t\t\tREP(v, n) if (dx[v] >= 0 && dy[v] >= 0 && rho[v] == v && d > dx[v]) d = dx[v], r = v;\n\t\t\t\tREP(v, n) if (dx[v] <= d && dx[v] % 2 && rho[phi[v]] != r) phi[phi[v]] = v;\n\t\t\t\tREP(v, n) if (dy[v] <= d && dy[v] % 2 && rho[phi[v]] != r) phi[phi[v]] = v;\n\t\t\t\tif (rho[x] != r) phi[x] = y;\n\t\t\t\tif (rho[y] != r) phi[y] = x;\n\t\t\t\tREP(v, n) if (dx[rho[v]] >= 0 || dy[rho[v]] >= 0) rho[v] = r;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tREP(u, n) if (u < mu[u]) ret++;\n\treturn ret;\n}\nint X, Y, E, x, y; Graph G;\nint main() {\n\tscanf(\"%d%d%d\", &X, &Y, &E); G.resize(X + Y);\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tG[x].push_back(Edge(x, X + y, 1));\n\t\tG[X + y].push_back(Edge(X + y, x, 1));\n\t}\n\tprintf(\"%d\\n\", maximumMatching(G));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\nusing namespace std;\nstruct edge {int to,w,p;};\nint n,m,k,used[202],a,b,c,cnt,A,B;\nvector<edge> v[202];\nint dfs(int s,int t,int r){\n    if(s==t)return r;\n    used[s]=1;\n    for(int i=0;i<v[s].size();i++){\n        edge &u=v[s][i];\n        if(used[u.to]==0&&u.w>0){\n            int F=dfs(u.to,t,min(r,u.w));\n            if(F>0){\n                u.w-=F;v[u.to][u.p].w+=F;return F;\n            }\n        }\n    }\n    return 0;\n}\nint main(void){\n    cin>>n>>m>>k;\n    for(int i=0;i<k;i++){\n        cin>>A>>B;\n        a=A,b=B+100;\n        edge p={b,1,(int)v[b].size()};v[a].push_back(p);\n        edge q={a,0,(int)v[a].size()-1};v[b].push_back(q);\n    }\n    for(int i=0;i<n;i++){\n        a=200,b=i;\n        edge p={b,1,(int)v[b].size()};v[a].push_back(p);\n        edge q={a,0,(int)v[a].size()-1};v[b].push_back(q);\n    }\n    for(int i=0;i<m;i++){\n        a=i+100,b=201;\n        edge p={b,1,(int)v[b].size()};v[a].push_back(p);\n        edge q={a,0,(int)v[a].size()-1};v[b].push_back(q);\n    }\n    int res=0;\n    while(1){\n        for(int i=0;i<202;i++)used[i]=0;\n        int P=dfs(200,201,1e9);\n        if(P==0)break;\n        res++;\n    }\n    cout<<res<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for(int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define Cout(obj) cout << obj << endl\n#define Size(obj) (int)(obj).size()\n#define fcout cout << fixed << setprecision(10)\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cap, rev;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nconst int MaxV = 10000;\n\nvector<edge> graph[MaxV];\nbool used[MaxV];\n\nvoid addEdge(int from, int to, int cap)\n{\n    graph[from].push_back({to, cap, Size(graph[to])});\n    graph[to].push_back({from, 0, Size(graph[from]) - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n    if(v == t) return f;\n    used[v] = true;\n\n    for(auto &e : graph[v])\n    {\n        if(!used[e.to] && e.cap > 0)\n        {\n            int d = dfs(e.to, t, min(f, e.cap));\n\n            if(d > 0)\n            {\n                e.cap -= d;\n                graph[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n\n    return 0;\n}\n\nint maxFlow(int s, int t)\n{\n    int flow = 0;\n    for(;;)\n    {\n        memset(used, false, sizeof(used));\n\n        int f = dfs(s, t, iINF);\n\n        if(f == 0) return flow;\n\n        flow += f;\n    }\n}\n\nint X, Y, E;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n\n    int S = X + Y, T = S + 1;\n\n    REP(i, X)\n    {\n        addEdge(S, i, 1);\n    }    \n\n    REP(i, Y)\n    {\n        addEdge(T, i, 1);\n    }\n\n    REP(i, E)\n    {\n        int x, y;\n        cin >> x >> y;\n        addEdge(x, y + X, 1);\n    }\n\n    Cout(maxFlow(S, T));\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <stack>\n#include <tuple>\n#include <deque>\n#include <numeric>\n#include <bitset>\n#include <iomanip>\n#include <cassert>\n#include <chrono>\n#include <random>\n#include <limits>\n#include <iterator>\n#include <functional>\n#include <sstream>\n#include <complex>\nusing namespace std;\n\nusing ll = long long;\nusing ull = uint64_t;\nusing P = pair<int, int>;\nconstexpr double EPS = 1e-9;\nconstexpr int INF = 1001001001;\nconstexpr int mod = 1000000007;\n// constexpr int mod = 998244353;\n\ntemplate<class T>\ninline bool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\ntemplate<class T>\ninline bool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nstruct Edge{\n    int to, cap, rev;\n    Edge() = default;\n    Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    int V = X + Y + 2;\n    vector<vector<Edge>> graph(X + Y + 2);\n    int s = X + Y, t = s + 1;\n    for(int i = 0; i < X; ++i){\n        graph[s].emplace_back(i, 1, (int)graph[i].size());\n        graph[i].emplace_back(s, 0, (int)graph[s].size() - 1);\n    }\n    for(int i = X; i < X + Y; ++i){\n        graph[i].emplace_back(t, 1, (int)graph[t].size());\n        graph[t].emplace_back(i, 0, (int)graph[i].size() - 1);\n    }\n    for(int i = 0; i < E; ++i){\n        int x, y;\n        cin >> x >> y;\n        y += X;\n        graph[x].emplace_back(y, 1, graph[y].size());\n        graph[y].emplace_back(x, 0, (int)graph[x].size() - 1);\n    }\n    \n    vector<int> depth(V), iter(V);\n    auto bfs = [&](int root){\n        for(int i = 0; i < V; ++i)  depth[i] = -1;\n        depth[root] = 0;\n        queue<int> que;\n        que.emplace(root);\n        while(!que.empty()){\n            int from = que.front();\n            que.pop();\n            for(auto& e : graph[from]){\n                if(e.cap > 0 && depth[e.to] == -1){\n                    depth[e.to] = depth[from] + 1;\n                    que.emplace(e.to);\n                }\n            }\n        }\n        return;\n    };\n    auto dfs = [&](auto&& self, int S, int T, int flow) -> int {\n        if(S == T)  return flow;\n        for(int& i = iter[S]; i < (int)graph[S].size(); ++i){\n            auto& e = graph[S][i];\n            if(e.cap > 0 && depth[S] < depth[e.to]){\n                int f = self(self, e.to, t, min(e.cap, flow));\n                if(f > 0){\n                    e.cap -= f;\n                    graph[e.to][e.rev].cap += f;\n                    return f;\n                }\n            }\n        }\n        return 0;\n    };\n    auto max_flow = [&](int S, int T){\n        int res = 0;\n        for(;;){\n            bfs(S);\n            if(depth[T] < 0)    break;\n            for(int i = 0; i < V; ++i)  iter[i] = 0;\n            int f;\n            while((f = dfs(dfs, S, T, INF)) > 0)    res += f;\n        }\n        return res;\n    };\n\n    cout << max_flow(s, t) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nconst int inf = 1e9;\nstruct edge { int to, cap, rev; edge(int t, int c, int r) : to(t), cap(c), rev(r) {} };\n\ntemplate<class T> T ford_fulkerson(int s, int t, VV<edge>& g) {\n  int n = g.size();\n  V<bool> vis(n);\n\n  function<T(int, int, T)> dfs = [&](int v, int t, T f) {\n    if (v == t) return f;\n    vis[v] = true;\n    for (auto&& e : g[v]) {\n      if (vis[e.to] or e.cap <= 0) continue;\n      T d = dfs(e.to, t, min(f, e.cap));\n      if (d > 0) {\n        e.cap -= d;\n        g[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n    return 0;\n  };\n\n  T res = 0;\n  while (true) {\n    vis.assign(n, false);\n    T f = dfs(s, t, inf);\n    if (f == 0) return res;\n    res += f;\n  }\n}\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n1, n2, m; cin >> n1 >> n2 >> m;\n  VV<edge> g(n1 + n2 + 2);\n  for (int i = 0; i < m; i++) {\n    int a, b; cin >> a >> b, b += n1;\n    g[a].emplace_back(b, 1, g[b].size());\n    g[b].emplace_back(a, 0, g[a].size() - 1);\n  }\n  int s = n1 + n2;\n  for (int i = 0; i < n1; i++) {\n    g[s].emplace_back(i, 1, g[i].size());\n    g[i].emplace_back(s, 0, g[s].size() - 1);\n  }\n  int t = n1 + n2 + 1;\n  for (int i = n1; i < n1 + n2; i++) {\n    g[t].emplace_back(i, 0, g[i].size());\n    g[i].emplace_back(t, 1, g[t].size() - 1);\n  }\n  cout << ford_fulkerson<int>(s, t, g) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MON 1000000007\n#define INF (1<<29)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n#define max(x, y) ((x)>(y)?(x):(y))\n#define min(x, y) ((x)<(y)?(x):(y))\n\n\nclass Edge{\npublic:\n  int from, to, rev;\n  Int cost, lim;\n  Edge(int from, int to, Int cost, int lim = -1, Int rev = -1):\n    from(from),to(to),cost(cost),lim(lim),rev(rev){}\n};\n\n\nclass Graph{\npublic:\n  int n;\n  int m;\n  vector<vector<Edge>> edge;\n  Graph(int n = 0):n(n),m(0){\n    edge = vector<vector<Edge>>(n);\n  }\n  void add_edge(int from, int to, int cost = 1, int lim = -1)\n  {\n    if(lim == -1){\n      edge[from].push_back(Edge(from, to, cost));\n      return;\n    }\n    edge[from].push_back(Edge(from, to, cost, lim, edge[to].size()));\n    edge[to].push_back(Edge(to, from, -cost, 0, edge[from].size() - 1));\n  }\n};\n\n\nclass Dinic{\npublic:\n  Graph *g;\n  vector<int> iter, level, come;\n\n  Dinic(){};\n  void bfs(int s){\n    queue<int> q;\n    fill(level.begin(), level.end(), INF);\n    level[s] = 0;\n    q.push(s);\n    while(!q.empty()){\n      int x = q.front();q.pop();\n      for(auto e:g->edge[x]){\n\tif(level[e.to] != INF)continue;\n\tif(e.lim <= 0)continue;\n\tlevel[e.to] = level[x] + 1;\n\tq.push(e.to);\n      }\n    }\n  }\n\n  Int dfs(int s, int t, Int f){\n    if(s == t)return f;\n    if(come[s])return 0;\n    come[s] = true;\n    for(int &i = iter[s];i < g->edge[s].size();i++){\n      Edge &e = g->edge[s][i];\n      if(e.lim <= 0)continue;\n      Int tmp = dfs(e.to, t, min(f, e.lim));\n      if(tmp == 0)continue;\n      e.lim -= tmp;\n      g->edge[e.to][e.rev].lim += tmp;\n      return tmp;\n    }\n    return 0;\n  }\n  Int max_flow(Graph &_g, int s, int t){\n    g = &_g;\n    iter = vector<int>(g->n);\n    level = vector<int>(g->n);\n    come = vector<int>(g->n, 0);\n    Int res = 0;\n    while(true){\n      bfs(s);\n      if(level[t] == INF)break;\n      fill(iter.begin(), iter.end(), 0);\n      while(true){\n\tfill(come.begin(), come.end(), false);\n\tInt tmp = dfs(s, t, INF);\n\tif(tmp == 0)break;\n\telse res += tmp;\n      }\n    }\n    return res;   \n  }  \n};\n\nint main(){\n  int n1, n2, e, x, y;\n  cin >> n1 >> n2 >> e;\n  Graph g(n1+n2+2);\n  int s = n1+n2, t = n1+n2+1;\n  for(int i = 0;i < n1;i++)g.add_edge(s, i, 1, 1);\n  for(int i = 0;i < n2;i++)g.add_edge(n1+i, t, 1, 1);\n  for(int i = 0;i < e;i++){\n    cin >> x >> y;\n    g.add_edge(x, n1+y, 1, 1);\n  }\n  Dinic d;\n  cout << d.max_flow(g, s, t) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <queue>\n#include <set>\n#include <bitset>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int>>vpi;\ntypedef pair<int,int> pi;\n#define R return\n#define W while\n#define FOR(i,a) for(int i=0;i<a;i++)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define I insert\n#define P push\nint main(){\n    int x,y,k,l,r,ans=0,temp;\n    pair<priority_queue<pi,vpi,greater<pi>>,priority_queue<pi,vpi,greater<pi>>>pq;\n    pair<vi,vi>v[510];\n    pi d[510];\n    set<pi>s;\n    pair<bitset<510>,bitset<510>>b;\n    b.F.reset();\n    b.S.reset();\n    scanf(\"%d%d%d\",&x,&y,&k);\n    n=max(x,y)+1;\n    W(k--){\n        scanf(\"%d%d\",&l,&r);\n        if(s.count(MP(l,r)))continue;\n        s.I(MP(l,r));\n        v[l].F.PB(r);\n        v[r].S.PB(l);\n    }\n    FOR(i,n){\n        d[i].F=(int)v[i].F.size();\n        d[i].S=(int)v[i].S.size();\n        pq.F.P(MP(d[i].F,i));\n        pq.S.P(MP(d[i].S,i));\n    }\n    W(!(pq.F.empty()||pq.S.empty())){\n        if(pq.F.top().F<=pq.S.top().F){\n            temp=pq.F.top().S;\n            pq.F.pop();\n            if(b.F[temp])continue;\n            b.F[temp]=true;\n            FOR(i,v[temp].F.size())if(!b.S[v[temp].F[i]]){\n                b.S[v[temp].F[i]]=true;\n                ans++;\n                FOR(j,v[v[temp].F[i]].S.size())if(!b.F[v[v[temp].F[i]].S[j]]){\n                    d[v[v[temp].F[i]].S[j]].F--;\n                    pq.F.P(MP(d[v[v[temp].F[i]].S[j]].F,v[v[temp].F[i]].S[j]));\n                }\n            }\n        }\n        else{\n            temp=pq.S.top().S;\n            pq.S.pop();\n            if(b.S[temp])continue;\n            b.S[temp]=true;\n            FOR(i,v[temp].S.size())if(!b.F[v[temp].S[i]]){\n                b.F[v[temp].S[i]]=true;\n                ans++;\n                FOR(j,v[v[temp].S[i]].F.size())if(!b.S[v[v[temp].S[i]].F[j]]){\n                    d[v[v[temp].S[i]].F[j]].S--;\n                    pq.S.P(MP(d[v[v[temp].S[i]].F[j]].S,v[v[temp].S[i]].F[j]));\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n    int to, cap, rev;\n};\n\nconst int INF = INT_MAX;\nvector<Edge> G[202];\nconst int ns = 200;\nconst int nt = 201;\n\nbool used[202];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((Edge){ to, cap, (int)G[to].size() });\n    G[to].push_back((Edge){ from, 0, (int)G[from].size()-1 });\n}\n\nint maxflow(int s, int t, int f) {\n    used[s] = true;\n    int ret;\n    if (s == t) {\n        ret = f;\n    } else {\n        ret = 0;\n        for (Edge &e: G[s]) {\n            if ( ! used[e.to] && e.cap > 0) {\n                int maxf = maxflow(e.to, t, min(f, e.cap));\n                if (maxf > 0) {\n                    e.cap -= maxf;\n                    G[e.to][e.rev].cap += maxf;\n                    ret = maxf;\n                    break;\n                }\n            }\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    for (int i=0; i<E; ++i) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, y+100, 1);\n    }\n    for (int i=0; i<X; ++i) add_edge(ns, i, 1);\n    for (int i=0; i<Y; ++i) add_edge(i+100, nt, 1);\n\n    int mx = 0;\n    while (1) {\n        fill(used, used+202, false);\n        int f = maxflow(ns, nt, INF);\n        if (f == 0) break;\n        mx += f;\n    }\n    cout << mx << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i,n) for (int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF = 1e9;\nstruct edge{\n\tint to, cap, rev;\n\tedge(int to,int cap, int rev):to(to),cap(cap),rev(rev){}\n};\nvector<vector<edge> > G; //??°???????????£??\\???????????¨???\nbool used[1003]; //DFS??§??¢???????????????????????????????????°\nint x,y,e;\nvoid add_edge(int from, int to){\n\t\tG[from].push_back(edge(to,1,G[to].size()));\n\t\tG[to].push_back(edge(from,0,G[from].size() - 1));\n}\n\nint dfs(int v, int t, int f){\n\tif(v == t) return f;\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tedge &e = G[v][i];\n\t\tif( !used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -=d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxflow(int s, int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tfill(used,used + e,false);\n\t\tint f = dfs(s,t,INF);\n\t\tif(f == 0)return flow;\n\t\tflow += f;\n\t}\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n\tcin >> x >> y >> e;\n\tG.resize(x+y + 2);\n\tREP(i,e){\n\t\tint from,to;\n\t\tcin >> from >> to;\n\t\tto += x;\n\t\tfrom++;to++;\n\t\tadd_edge(from,to);\n\t}\n\tREP(i,x){\n\t\tadd_edge(0,i+1);//?§?????????????????????????\n\t}\n\tREP(i,y){\n\t\tadd_edge(x + 1 + i,x+y+1);//????????????????????????\n\t}\n\tcout << maxflow(0,x+y+1) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename T>\nstruct Network {\n    static const T INF = numeric_limits<T>::max() >> 12;\n    struct Edge {\n        int from, to;\n        T cap;\n        Edge* rev;\n        Edge(int from, int to, T cap) :\n            from(from), to(to), cap(cap) {}\n    };\n    vector<Edge*> edges;\n    vector<vector<Edge*>> graph;\n    Network(int N) : graph(N, vector<Edge*>()) {}\n    ~Network() { \n        for (auto e : edges) delete(e);\n    }\n    void addEdge(int s, int t, T cap) {\n        auto e = new Edge(s, t, cap);\n        auto r = new Edge(t, s, 0);\n        edges.push_back(e); edges.push_back(r);\n        e->rev = r; r->rev = e;\n        graph[s].push_back(e); graph[t].push_back(r);\n    }\n    T maxFlow(int s, int t) {\n        const int N = graph.size();\n        vector<int> label(N, 0); label[s] = N;\n        vector<T> excess(N, 0);\n        int level = 0;\n        for (auto e : graph[s]) {\n            auto gamma = e->cap;\n            e->cap = 0;\n            e->rev->cap = gamma;\n            excess[e->from] -= gamma;\n            excess[e->to] += gamma;\n        }\n        vector<vector<int>> L(2*N, vector<int>()); {\n            for (int i = 0; i < N; i++) if (i != s and i != t and excess[i] > 0) {\n                L[0].push_back(i);\n            }\n        }\n        auto push = [&](Edge* e) {\n            auto gamma = min(excess[e->from], e->cap);\n            if (gamma == 0) return;\n            e->cap -= gamma;\n            e->rev->cap += gamma;\n            int u = e->from; int v = e->to;\n            if (u != s and u != t and excess[u] == gamma) {\n                assert(not L[label[u]].empty());\n                L[label[u]].pop_back();\n            }\n            if (v != s and v != t and excess[v] == 0) L[label[v]].push_back(v);\n            excess[u] -= gamma; excess[v] += gamma;\n        };\n        auto relabel = [&](int v) {\n            assert(not L[level].empty());\n            L[level].pop_back();\n            label[v] = 1<<28;\n            for (auto e : graph[v]) {\n                if (e->cap <= 0) continue;\n                int w = e->to;\n                label[v] = min(label[v], label[w] + 1);\n            };\n            L[label[v]].push_back(v);\n            level = label[v];\n        };\n        while (level >= 0) {\n            if (L[level].empty()) { level--; continue; }\n            auto v = L[level].back();\n            bool used = false;\n            for (auto e : graph[v]) {\n                if (label[e->from] == label[e->to] + 1 and e->cap > 0) {\n                    used = true;\n                    push(e);\n                }\n            }\n            if (not used) {\n                relabel(v);\n            }\n        }\n        return excess[t];\n    }\n};\n\nint main() {\n    int X, Y, E; cin >> X >> Y >> E;\n    Network<int> n(X + Y + 2);\n    for (int i = 0; i < E; i++) {\n        int x, y; cin >> x >> y;\n        int a = x + 1;\n        int b = y + X + 1;\n        n.addEdge(a, b, 1);\n    }\n    for (int a = 1; a <= X; a++) n.addEdge(0, a, 1);\n    for (int b = X + 1; b <= X + Y; b++) n.addEdge(b, X + Y + 1, 1);\n    cout << n.maxFlow(0, X + Y + 1) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\nusing namespace std;\n\nstruct BipartiteMatching {\n    int n;\n    vector<vector<int>> g;\n    vector<int> match, used;\n    BipartiteMatching(int n) : n(n), g(n), match(n), used(n) {}\n    void addEdge(int u, int v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    int maxmimumMatching(void) {\n        int res = 0;\n        match.assign(n, -1);\n        for(int v = 0; v < n; ++v){\n            if (match[v] < 0) {\n                used.assign(n, false);\n                if (augument(v)) res++;\n            }\n        }\n        return res;\n    }\n    bool augument(int v) {\n        used[v] = true;\n        for (int u : g[v]) {\n            int w = match[u];\n            if (w < 0 || (!used[w] && augument(w))) {\n                match[v] = u; \n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\n#include <iostream>\nint main() {\n    int X, Y, E;\n    while (cin >> X >> Y >> E) {\n        BipartiteMatching bm(X + Y);\n        for (int i = 0; i < E; ++i) {\n            int x, y;\n            cin >> x >> y;\n            bm.addEdge(x , y + X);\n        }\n        cout << bm.maxmimumMatching() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nconstexpr int INF = 1e9;\n\nstruct Edge {\n    int to, cap, rev;\n    Edge(int t, int c, int r) : to(t), cap(c), rev(r){}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\n\n\nclass Flow {\n    public:\n        Flow(int v){\n            mGraph.resize(v);\n            mUsed.assign(v,false);\n            mVert = v;\n        }\n        void add_edge(int from, int to, int cap){\n            mGraph[from].emplace_back(to,cap,mGraph[to].size()); // directed\n            mGraph[to].emplace_back(from,0,mGraph[from].size()-1);\n        }\n\n        // use after add all edges\n        int bipartite_matching(int x, int y){\n            int start = max(x,y) + 1;\n            int end = max(x,y) + 2;\n            for(int i = 0; i < x; ++i) add_edge(start, i, 1);\n            for(int i = 0; i < y; ++i) add_edge(i, end, 1);\n            return max_flow(start,end);\n        }\n\n        // ford-fulkerson\n        int dfs(int v, int t, int f){\n            if(v==t) return f;\n            mUsed[v] = true;\n            for(auto &e : mGraph[v]){\n                if(!mUsed[e.to] && e.cap > 0){\n                    int d = dfs(e.to,t,min(f,e.cap));\n                    if(d > 0){\n                        e.cap -= d;\n                        mGraph[e.to][e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        int max_flow(int s,int t){\n            int flow = 0;\n            while(true){\n                mUsed.assign(mVert,false);\n                int f = dfs(s,t,INF);\n                if(f==0) break;\n                flow += f;\n            }\n            return flow;\n        }\n        // verify : GRL_6_A\n\n\n    private:\n        Graph mGraph;\n        vector<bool> mUsed;\n        int mVert;\n\n};\n\nint main(){\n    int X,Y,E,u,v,c;\n    cin >> X >> Y >> E;\n    Flow f(max(X,Y)+3);\n    for(int i=0; i < E; ++i){\n        cin >> u >> v;\n        f.add_edge(u,v,1);\n    }\n    cout << f.bipartite_matching(X,Y) << '\\n';\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<set>\n#include<algorithm>\n\nclass BipartiteGraph {\npublic:\n    BipartiteGraph(const int x, const int y) :size_x_(x), size_y_(y), edge_(x + y) {}\n    void add_xy(const int vx, const int vy) {edge_[vx].insert(size_x_ + vy);}\n    int matching() const {\n        int source = size_x_ + size_y_;\n        int sink = source + 1;\n        std::vector<std::set<int>> edge = edge_;\n        edge.insert(edge.end(), std::set<int>());\n        edge.insert(edge.end(), std::set<int>());\n        for(int vx = 0; vx < size_x_; ++vx) edge[source].insert(vx);\n        for(int vy = 0; vy < size_y_; ++vy) edge[size_x_ + vy].insert(sink);\n\n        int count = 0;\n        while(true) {\n            std::vector<int> path;\n            path.push_back(source);\n            if(!FordFullkerson(edge, path)) break;\n            for(int i = 1; i < path.size(); ++i) {\n                edge[path[i - 1]].erase(path[i]);\n                edge[path[i]].insert(path[i - 1]);\n            }\n            ++count;\n        }\n        return count;\n    }\nprivate:\n    bool FordFullkerson(const std::vector<std::set<int>>& edge, std::vector<int>& path) const {\n        if(path.back() == size_x_ + size_y_ + 1) return true;\n        for(const auto& to: edge[path.back()]) {\n            if(std::find(path.begin(), path.end(), to) != path.end()) continue;\n            path.push_back(to);\n            if(FordFullkerson(edge, path)) return true;\n            path.pop_back();\n        }\n        return false;\n    }\n\n    std::vector<std::set<int>> edge_;\n    int size_x_, size_y_;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\n#include<iostream>\nusing namespace std;\n\nint main() {\n    int x, y, e;\n    cin >> x >> y >> e;\n    BipartiteGraph g(x, y);\n    for(int i = 0; i < e; ++i) {\n        int vx, vy;\n        cin >> vx >> vy;\n        g.add_xy(vx, vy);\n    }\n    cout << g.matching() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\nint const inf = 1<<29;\n\nstruct MCF {\n    typedef int Weight;\n    typedef int Capacity;\n    struct Edge;\n    int n;\n    vector<vector<Edge> > g;\n    vector<int> level, iter;\n\n    struct Edge {\n        int src, dst;\n        Capacity cap;\n        int rev;\n        bool isRev;\n        Edge(int src, int dst, Capacity cap, int rev, bool isRev)\n            :src(src), dst(dst), cap(cap), rev(rev), isRev(isRev) {}\n    };\n\n    MCF(int n_)\n        : n(n_), g(vector<vector<Edge> >(n_)), level(n_), iter(n_) {}\n\n    void add_edge(int src, int dst, Capacity cap) {\n        g[src].push_back(Edge(src, dst, cap, g[dst].size(), false));\n        g[dst].push_back(Edge(dst, src, 0, g[src].size() - 1, true));\n    }\n\n    void bfs(int s) {\n        fill(all(level), -1);\n        queue<Weight> q;\n        level[s] = 0;\n        q.push(s);\n        while (q.size()) {\n            int v = q.front(); q.pop();\n            for(int i = 0; i < (int)g[v].size(); i++){\n                Edge& e = g[v][i];\n                if (e.cap > 0 && level[e.dst] < 0) {\n                    level[e.dst] = level[v] + 1;\n                    q.push(e.dst);\n                }\n            }\n        }\n    }\n\n    Capacity dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < (int)g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (e.cap > 0 && level[v] < level[e.dst]) {\n                int d = dfs(e.dst, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.dst][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    Capacity max_flow(int src, int dst) {\n        int flow = 0;\n        while(1){\n            bfs(src);\n            if (level[dst] < 0) return flow;\n            fill(all(iter), 0);\n            int f;\n            while ((f = dfs(src, dst, inf)) > 0) {\n                flow += f;\n            }\n        }\n    }\n\n    void view(){\n        for(int i=0;i<g.size();i++){\n            for(int j=0;j<g[i].size();j++){\n                auto & e=g[i][j];\n                printf(\"%d->%d (%d)\\n\", e.src, e.dst, e.cap);\n            }\n        }\n    }\n};\n\nint main(){\n    int X,Y,E;\n    cin >> X >> Y >> E;\n    int N=X+Y;\n    MCF mcf(N+2);\n    int S=N, T=N+1;\n    for(int i=0;i<E;i++){\n        int x, y;\n        cin >> x >> y;\n        mcf.add_edge(x,y+X,1);\n    }\n    for(int i=0;i<X;i++){\n        mcf.add_edge(S,i,1);\n    }\n    for(int i=0;i<Y;i++){\n        mcf.add_edge(i+X,T,1);\n    }\n    cout << mcf.max_flow(S,T) << endl;\n    // printf(\"X : {\");\n    // for(int i=0;i<X;i++){\n    //     printf(\"%d%s\",i,i==X-1?\"}\\n\":\",\");\n    // }\n    // printf(\"Y : {\");\n    // for(int i=0;i<Y;i++){\n    //     printf(\"%d%s\",i+X,i==Y-1?\"}\\n\":\",\");\n    // }\n    // mcf.view();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n\n#define INF 99999999\n\nusing namespace std;\n\nstruct edge{\n\tint to,cap,rev; \n};\n\nconst int MAX_V = 205;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\t\t//??°???????????\\???\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n\tif(v == t)\treturn f;\n\tused[v] = true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e = G[v][i];\t//?????§?????°??¨????????????(?????????????????£??\\???????????????????????????)\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\t//e???G[v][i]?????¨????????¢?????§???????????????????????????G[v][i]??????????????????????????¨??????\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f = dfs(s,t,INF);\n\t\tif(f == 0)\treturn flow;\n\t\tflow += f;\n\t}\n}\n\nint main(){\n\tint m,result,x,y;\n\tcin >> x >> y >> m;\n\tfor(int i=0;i<m;i++){\n\t\tint from,to,cap;\n\t\tcin >> from;\n\t\tcin >> to;\n\t\tadd_edge(from,x+to,INF);\n\t}\n\tfor(int i=0;i<x;i++){\n\t\tadd_edge(x+y,i,1);\n\t}\n\tfor(int i=0;i<y;i++){\n\t\tadd_edge(x+i,x+y+1,1);\n\t}\n\tresult = max_flow(x+y,x+y+1);\n\tcout << result << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef string str;\nstatic const long long INF = INT64_MAX;\nstatic const long long MOD = (ll)1e9+7;\n\n#define endl \"\\n\"\n#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)\n#define REP(i, n) for(ll i=0;i<n;i++)\n#define SZ(v) (ll)((v).size())\n#define WHOLE(v) (v).begin(), (v).end()\n#define ASC(v) sort((v).begin(), (v).end())\n#define DESC(v) sort((v).rbegin(), (v).rend())\n#define INV(v) reverse((v).begin(), (v).end())\n#define FOLDL(src, dst, lambda) partial_sum((src).begin(), (src).end(), (dst).begin(), lambda)\n#define FOLDR(src, dst, lambda) INV(src);partial_sum((src).begin(), (src).end(), (dst).begin(), lambda);INV(dst)\n#define CUMSUML(src, dst) FOLDL(src, dst, [](auto a, auto b) {return a+b;})\n#define CUMSUMR(src, dst) FOLDR(src, dst, [](auto a, auto b) {return a+b;})\n#define ACCUM(v, d0, lambda) accumulate((v).begin(), (v).end(), d0, lambda)\n#define SUM(v, d0) ACCUM(v, d0, [](auto a, auto b) {return a+b;})\n#define ERASE(v, i) v.erase(v.begin() + i)\n#define UNIQ(v) ASC(v);v.erase(unique(v.begin(), v.end()), v.end())\n\ntemplate <typename T>void debug(T t) {cerr << t << endl;}\ntemplate <typename T, typename ...Args>void debug(T t, Args ...args) {cerr << t << \" \";debug(args...);}\ntemplate <typename T>void out(T t) {cout << t << endl;}\ntemplate <typename T, typename ...Args>void out(T t, Args ...args) {cout << t << \" \";out(args...);}\n\nclass BipartiteMatching {\n    vector<vector<ll> > G;\n    vll match;\n    vector<bool> vis;\n    ll N;\n    BipartiteMatching(){}\n    bool dfs(ll v) {\n        vis[v] = true;\n        for(auto &u:G[v]) {\n            ll w = match[u];\n            if(w < 0 || !vis[w] && dfs(w)) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\npublic:\n    BipartiteMatching(ll size) {\n        G.resize(size);\n        N = size;\n    }\n    void initialize(ll size) {\n        G.clear();\n        G.resize(size);\n        N = size;\n    }\n    void unite(ll u, ll v) {\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    ll search() {\n        ll res = 0;\n        match.assign(N, -1);\n        for(int v = 0; v < N; v++) {\n            if(match[v] < 0) {\n                vis.assign(N, false);\n                if(dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n};\n\nvoid solve() {\n    ll N, K, M;\n    cin >> N >> K >> M;\n    ll s = N + K, t = K + N + 1;\n    BipartiteMatching g(N+K);\n    REP(i, M) {\n        ll c, p;\n        cin >> c >> p;\n        g.unite(c, N + p);\n    }\n    out(g.search());\n}\n\nint main() {\n    fast_io;\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\n\ntypedef long long ll;\n\nbool debug = false;\nconst int NIL = -1;\nconst int INF = 1000000000;\nconst int NUM = 100010;\nclock_t START, END;\n\nint X, Y, E;\n\nstruct Edge {\n\tint from, to, cap, flow;\n\tEdge(int u, int v, int c, int f) :from(u), to(v), cap(c), flow(f) {}\n};\n\nstruct Graph {\n\tint n, m;\n\tvector<Edge> edges;\n\tvector<int> G[NUM];\n\tint a[NUM];\n\tint p[NUM];\n\n\tvoid init(int n) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tG[i].clear();\n\t\tedges.clear();\n\t}\n\n\tvoid AddEdge(int from, int to, int cap) {\n\t\tedges.push_back(Edge(from, to, cap, 0));\n\t\tedges.push_back(Edge(to, from, 0, 0));\n\t\tm = edges.size();\n\t\tG[from].push_back(m - 2);\n\t\tG[to].push_back(m - 1);\n\t}\n\n\tint Maxflow(int s, int t) {\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tmemset(a, 0, sizeof(a));\n\t\t\tqueue<int> Q;\n\t\t\tQ.push(s);\n\t\t\ta[s] = INF;\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint x = Q.front();\n\t\t\t\tQ.pop();\n\t\t\t\tfor (int i = 0; i < G[x].size(); i++) {\n\t\t\t\t\tEdge& e = edges[G[x][i]];\n\t\t\t\t\tif (!a[e.to] && e.cap > e.flow) {\n\t\t\t\t\t\tp[e.to] = G[x][i];\n\t\t\t\t\t\ta[e.to] = min(a[x], e.cap - e.flow);\n\t\t\t\t\t\tQ.push(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (a[t])\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!a[t])\n\t\t\t\tbreak;\n\t\t\tfor (int u = t; u != s; u = edges[p[u]].from) {\n\t\t\t\tedges[p[u]].flow += a[t];\n\t\t\t\tedges[p[u] ^ 1].flow -= a[t];\n\t\t\t}\n\t\t\tflow += a[t];\n\t\t}\n\t\treturn flow;\n\t}\n\n};\n\nGraph solve;\n\nint main(void)\n{\n\tif (debug) {\n\t\tSTART = clock();\n\t\tfreopen(\"in29.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t}\n\tint x, y;\n\tcin >> X >> Y >> E;\n\tsolve.init(X + Y + 2);\n\tfor (int i = 0; i < X; i++)\n\t\tsolve.AddEdge(0, i + 1, 1);\n\tfor (int i = 0; i < Y; i++)\n\t\tsolve.AddEdge(X + i + 1, X + Y + 1, 1);\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tsolve.AddEdge(x + 1, X + 1 + y, 1);\n\t}\n\tcout << solve.Maxflow(0, X + Y + 1) << endl;\n\tif (debug) {\n\t\tEND = clock();\n\t\tdouble endtime = (double)(END - START) / 1000;\n\t\tprintf(\"total time = %lf s\", endtime);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\n\n/*\n * Hopcroft Karp\n */\nstruct Hopcroft_Karp {\n\n  const static int max_n1 = 10010;\n  const static int max_n2 = 10010;\n  const static int max_m  = 20010;\n\n  int n1, n2, edges;\n  vi last, prev, head, matching, dist, q;\n  vb used, vis;\n\n  Hopcroft_Karp( ) :\n    last( max_n1 ), prev( max_m ), head( max_m ),\n    matching( max_n2 ), dist( max_n1 ), q( max_n1 ),\n    used( max_n1 ), vis( max_n1 ) {\n  }\n\n  void init( int n1, int n2 ) {\n    this->n1 = n1;\n    this->n2 = n2;\n    edges = 0;\n    fill( last.begin( ), last.begin( )+n1, -1 );\n  }\n\n  void add_edge( int u, int v ) {\n    head[ edges ] = v;\n    prev[ edges ] = last[ u ];\n    last[ u ] = edges++;\n  }\n\n  void bfs( ) {\n    fill( dist.begin( ), dist.begin( )+n1, -1 );\n    int size_q = 0;\n    for( int u = 0; u < n1; u++ ) {\n      if( !used[ u ] ) {\n        q[ size_q++ ] = u;\n        dist[ u ] = 0;\n      }\n    }\n    for( int i = 0; i < size_q; i++ ) {\n      int u1 = q[ i ];\n      for( int e = last[ u1 ]; e >= 0; e = prev[ e ] ) {\n        int u2 = matching[ head[ e ] ];\n        if( u2 >= 0 && dist[ u2 ] < 0 ) {\n          dist[ u2 ] = dist[ u1 ] + 1;\n          q[ size_q++ ] = u2;\n        }\n      }\n    }\n  }\n\n  bool dfs( int u1 ) {\n    vis[ u1 ] = true;\n    for( int e = last[ u1 ]; e >= 0; e = prev[ e ] ) {\n      int v = head[ e ];\n      int u2 = matching[ v ];\n      if( u2 < 0 || ( !vis[ u2 ] && dist[ u2 ] == dist[ u1 ]+1 && dfs( u2 ) ) ) {\n        matching[ v ] = u1;\n        used[ u1 ] = true;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int max_matching( ) {\n    fill( used.begin( ), used.begin( )+n1, false );\n    fill( matching.begin( ), matching.begin( )+n2, -1 );\n    int ans = 0;\n    while( true ) {\n      bfs( );\n      fill( vis.begin( ), vis.begin( )+n1, false );\n      int f = 0;\n      for( int u = 0; u < n1; u++ ) {\n        if( !used[ u ] && dfs( u ) ) {\n          f++;\n        }\n      }\n      if( f == 0 ) {\n        return ans;\n      }\n      ans += f;\n    }\n    return 0;\n  }\n\n}hp;\n\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  #ifdef Larra\n  freopen(\"in\",\"r\",stdin);\n  freopen(\"out\",\"w\",stdout);\n  #endif\n  int n1, n2, m;\n  cin>>n1>>n2>>m;\n  hp.init(n1, n2);\n  for(int i = 0; i < m; i++){\n      int u,v;\n      cin>>u>>v;\n      hp.add_edge(u, v);\n  }\n  cout<<hp.max_matching()<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct BipartiteMatching {\n  vector< vector<int> > graph;\n  vector<int> matched;\n  vector<bool> used;\n  BipartiteMatching(int V):graph(V), matched(V, -1), used(V, false){}\n  void add_edge(int u, int v) {\n    graph[u].emplace_back(v);\n    graph[v].emplace_back(u);\n  }\n  bool dfs(int u) {\n    used[u] = true;\n    for(auto& v : graph[u]) {\n      int w = matched[v];\n      if(w < 0 || (!used[w] && dfs(w))) {\n        matched[u] = v;\n        matched[v] = u;\n        return true;\n      }\n    }\n    return false;\n  }\n  int match() {\n    int res = 0;\n    for(int u = 0; u < (int)graph.size(); u++) {\n      if(matched[u] < 0) {\n        used.clear(); used.resize(graph.size(), false);\n        if(dfs(u)) res++;\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n    int x,y,m;\n    cin>>x>>y>>m;\n    BipartiteMatching BP(x+y);\n    while(m--){\n        int a,b;\n        cin>>a>>b;\n        BP.add_edge(a,b+x);\n    }\n    cout<<BP.match()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <complex>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nconst int INF = 1 << 27;\nconst int MAX_V = 101;\n//////////////////////////////\n// 2??¨??????????????°(???????????¨???1)\nint V, match[MAX_V], used[MAX_V];\nvector<int> G[MAX_V];\n\nbool dfs(int v){\n  used[v] = true;\n  REP(i, G[v].size()){\n    int u = G[v][i], w = match[u];\n    if(w < 0 || (!used[w] && dfs(w))){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartite_matching(){\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  REP(v, V)\n    if(match[v] < 0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)) ++res;\n    }\n  return res;\n}\nint main() {\n  int X, Y, E; cin >>X >>Y >>E;\n  V = X + Y;\n  REP(i, E){\n    int u, v; cin >>u >>v;\n    v += X;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  cout << bipartite_matching() <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nconst int MAX_V = 205;\nvector<int> G[MAX_V];\nvector<int> match(MAX_V);\nvector<bool> used(MAX_V);\n\nvoid add_edge(const int &u, const int &v) {\n\tG[u].emplace_back(v);\n\tG[v].emplace_back(u);\n}\n\nbool dfs(const int &v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//?????¨??????????????°????????§???????±?????????????\nint bipartite_matching(const int &V) {\n\tint res = 0;\n\tfill(match.begin(), match.end(), -1);\n\tfor (int v = 0; v < V; ++v) {\n\t\tif (match[v] < 0) {\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tif (dfs(v))++res;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::ios_base::sync_with_stdio(false);\n\tint X, Y, E, s, t; cin >> X >> Y >> E;\n\tfor (int i = 0; i < E; ++i) {\n\t\tcin >> s >> t;\n\t\tadd_edge(s, t + X);\n\t}\n\tint ans = bipartite_matching(X + Y);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <numeric>\n#include <cstdlib>\n#include <queue>\n#include <stack>\nusing namespace std;\n\ntypedef long long ll;\n#define pb push_back\n\n#define rep(i, n) for (int i=0;i<(n);++i)\n#define rep2(i, s, n) for (int i=s;i<(n);++i)\n#define INF (1e9+1e9)\n\nclass Edge{\npublic:\n    int u, v, cost;\n    Edge(int u, int v, int cost=1):\n        u(u), v(v), cost(cost) {}\n    bool operator < (const Edge& e) const {\n        return cost != e.cost ? cost > e.cost : // for min-priority queue\n            u != e.u ? u < e.u : v < e.v;\n    }\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\n/* Bipartie Matching using Ford-Fulkerson with DFS */\n// DFS\n// vertex u is always in L\nbool dfs(Graph& G, int u, vector<bool>& visited, vector<int>& to)\n{\n    if (u == -1) return true; // augmenting path\n    for(auto& e:G[u]) if(!visited[e.v]) {\n        visited[e.v] = true; // vertex e.v is always in R\n        if (dfs(G,to[e.v],visited,to)) { // we always traverse the matched edge (e.v, to[e.v])\n            to[e.v] = u, to[u] = e.v;    // new matching\n            return true; \n        }\n    }\n    return false; // no augmenting path \n}\n\nint matching(Graph& G, int X, Edges& M)\n{\n    int V = G.size(), m = 0;\n    vector<int> to(V,-1); // to[src] = dst\n    \n    rep(i,X) {\n        vector<bool> visited(V,false);\n        if (dfs(G,i,visited,to)) m++; // augmenting path found\n    }\n\n    //rep(i,X) if (to[i] != -1) M.pb(Edge(i, to[i]));\n    return m;\n}\n\nint main()\n{\n    int X,Y,E; cin>>X>>Y>>E;\n    Graph G(X+Y);\n    rep(i,E) {\n        int u,v; cin>>u>>v;\n        G[u].pb(Edge(u,v+X));\n        G[v+X].pb(Edge(v+X,u));\n    }\n    \n    Edges M;\n    int m = matching(G,X,M);\n    cout << m << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\n\nclass FordFulkerson {\npublic:\n  struct Edge { int to, cap, rev; };\n\n  FordFulkerson(int V, int S, int T): V(V), S(S), T(T), G(V, vector<Edge>(0)), used(V, false) {}\n\n  void addEdge(int from, int to, int cap) {\n    G[from].push_back({ to, cap, (int)G[to].size() });\n    G[to].push_back({ from, 0, (int)G[from].size()-1 });\n  }\n\n  int maxFlow() {\n    int flow = 0;\n    for (;;) {\n      resetUsed();\n      int f = dfs(S, INFTY);\n      if (f == 0) return flow;\n      flow += f;\n    }\n  }\n\nprivate:\n  const int INFTY = (1 << 21);\n  int V, S, T;\n  vector<vector<Edge> > G;\n  vector<bool> used;\n\n  int dfs(int v, int f) {\n    if (v == T) return f;\n    used.at(v) = true;\n    for (auto &edge: G.at(v)) {\n      if (used.at(edge.to)) continue;\n      if (edge.cap <= 0) continue;\n      int d = dfs(edge.to, min(f, edge.cap));\n      if (d <= 0) continue;\n      edge.cap -= d;\n      G.at(edge.to).at(edge.rev).cap += d;\n      return d;\n    }\n\n    return 0;\n  }\n\n  void resetUsed() {\n    fill(used.begin(), used.end(), false);\n  }\n};\n\n#define MAX_E 10001\nint X, Y, E, SS[MAX_E], TS[MAX_E];\n\nvoid input() {\n  cin >> X >> Y >> E;\n  for (int e=0;e<E;e++) {\n    cin >> SS[e] >> TS[e];\n  }\n}\n\nvoid solve() {\n  int S = X + Y, T = X + Y + 1, V = T + 1;\n  FordFulkerson ff(V, S, T);\n  for (int e=0;e<E;e++) ff.addEdge(SS[e], TS[e]+X, 1);\n  for (int x=0;x<X;x++) ff.addEdge(S, x, 1);\n  for (int y=0;y<Y;y++) ff.addEdge(y+X, T, 1);\n  cout << ff.maxFlow() << endl;\n}\n\nint main() {\n  input();\n  solve();\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nclass Flow{\nprivate:\n    struct edge{\n        ll to;\n        ll cap;\n        ll rev;\n    };\n    \n    ll INF;\n    ll v;\n    vector<vector<edge>> e;\n    vector<bool> used;\n    \n    void reset_used(){\n        for(int i=0;i<used.size();i++){used[i]=false;}\n    }\n    \n    ll dfs(ll where,ll to,ll flow){\n        if(where==to){return flow;}\n        used[where]=true;\n        for(int i=0;i<e[where].size();i++){\n            edge &E=e[where][i];\n            if(!used[E.to] && E.cap>0){\n                ll d=dfs(E.to,to,min(flow,E.cap));\n                if(d>0){\n                    E.cap-=d;\n                    e[E.to][E.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \npublic:\n    Flow(ll v):v(v){\n        e.resize(v);\n        used.resize(v,false);\n        INF=1e18+7;\n    }\n    \n    void add_edge(ll from,ll to,ll cap){\n        e[from].push_back((edge){to,cap,(ll)e[to].size()});\n        e[to].push_back((edge){from,0,(ll)e[from].size()-1});\n    }\n    \n    ll max_flow(ll s,ll t){\n        vector<vector<edge>> ed=e;\n        ll flow=0;\n        while(1){\n            reset_used();\n            ll f=dfs(s,t,INF);\n            if(f==0){break;}\n            flow+=f;\n        }\n        e=ed;\n        return flow;\n    }\n};\n\n\n\nint main(){\n    ll x,y,e;\n    cin>>x>>y>>e;\n    Flow F(x+y+2);\n    for(int i=1;i<=x;i++){\n        F.add_edge(0,i,1);\n    }\n    for(int i=x+1;i<=x+y;i++){\n        F.add_edge(i,x+y+1,1);\n    }\n    for(int i=0;i<e;i++){\n        ll s,t;\n        cin>>s>>t;\n        s++; t++;\n        F.add_edge(s,x+t,1);\n    }\n    cout<<F.max_flow(0,x+y+1)<<endl;\n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <utility>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint exist(int y,const vector<pair<int,int> > &p)\n{\n    for(int i = 0; i < p.size(); i++)\n    {\n        if(p[i].second == y)\n            return i;\n    }\n    return -1;\n}\n\nbool match(int x, int start, const vector<vector<bool> > &v,vector<pair<int,int> > &p)\n{\n    for(int i = start; i < v[0].size(); i++)\n    {\n        if(v[x][i])\n        {\n            int rem = exist(i, p);\n            p[x].second = i;\n            if(rem < 0)\n            {\n                return true;\n                \n            }\n            else\n            {\n                p[rem].second = -1;\n                bool ok = match(rem,i+1,v,p);\n                if(!ok)\n                {\n                    p[x].second = -1;\n                    p[rem].second = i;\n                }\n                else\n                    return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int xn,yn,e,x,y;\n    cin >> xn >> yn >> e;\n    vector< vector<bool> > v(xn, vector<bool>(yn,false));\n    vector< pair<int,int> > p(xn,{0,-1});\n    for(int i = 0; i<p.size();i++)\n        p[i].first = i;\n    for(int i = 0; i < e; i++)\n    {\n        cin >> x >> y;\n        v[x][y] = true;\n    }\n    \n    for(int i = 0; i<xn;i++)\n    {\n        match(i,0,v,p);\n    }\n    int c = 0;\n    for(int i = 0; i<p.size();i++)\n    {\n        if(p[i].second>=0)\n            c++;\n    }\n    cout << c << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// なんかTLEなるんですが公開されているテストケースはすべて一瞬で計算してくれることを確認したので出します\n#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n    edge() {}\n    edge(int t, int c, int r) : to(t), cap(c), rev(r) {}\n};\nconst int MAX_V = 500;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size()-1));\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge& e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        for (int i = 0; i < MAX_V; i++) used[i] = false;\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(void) {\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    int s = X+Y, t = s+1;\n    for (int i = 0; i < E; i++) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, y+X, 1);\n    }\n    for (int i = 0; i < X; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        add_edge(i+X, t, 1);\n    }\n    cout << max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int MAX_N=500;\n\nstruct edge{\n\tint to,cap,rev;\n};\n\nvector<edge> G[MAX_N];\nvector<int> check(MAX_N,0);\n\nint dfs(int v,int t, int f ){\n\tif(v==t){return f;}\n\tcheck[v]=1;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(check[e.to]==0 && e.cap > 0){\n\t\t\tint ff =dfs(e.to,t,min(f,e.cap));\n\t\t\tif(ff>0){\n\t\t\t\te.cap -= ff;\n\t\t\t\tG[e.to][e.rev].cap += ff;\n\t\t\t\treturn ff;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxflow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tfill(check.begin(),check.end(),0);\n\t\tint f = dfs(s,t,INT_MAX);\n\t\tif(f==0){return flow;}\n\t\tflow += f;\n\t}\n}\n\nint main(){\n\tint X,Y,E,s,t;\n\tcin >> X >> Y >> E ;\n\t\n\tfor(int i=0;i<E;i++){\n\t\tcin >> s >> t ;\n\t\tG[s].push_back((edge){X+t,1,G[t].size()});\n\t\tG[X+t].push_back((edge){s,0,G[s].size()-1});\n\t}\n\t\n\tfor(int i=0;i<X;i++){\n\t\tG[X+Y].push_back((edge){i,1,G[i].size()});\n\t\tG[i].push_back((edge){X+Y,0,G[X+Y].size()-1});\n\t}\n\t\n\tfor(int i=X;i<X+Y;i++){\n\t\tG[i].push_back((edge){X+Y+1,1,G[X+Y+1].size()});\n\t\tG[X+Y+1].push_back((edge){i,0,G[i].size()-1});\n\t}\n\t/*\n\tfor(int k=0;k<X+Y+2;k++){\n\t\tfor(int i=0;i<G[k].size();i++){\n\t\t\tcout << G[k][i].to << \" \" <<G[k][i].cap << endl;\n\t\t}\n\t\tcout <<endl;\n\t}\n\t*/\n\tcout << maxflow(X+Y,X+Y+1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n \n\n\n#define _GLIBCXX_DEBUG\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\n\n//const int INF = 2147483647;\n//const long long int L_INF = 9223372036854775807;\n\ntypedef int Weight;\n\nconst Weight INF = INT_MAX;\nconst Weight ZERO = 0;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tint id;\n\tEdge(int src_, int dst_, Weight weight_, const int id_) :\n\t\tsrc(src_), dst(dst_), weight(weight_), id(id_) { }\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n\tEdge() :src(0), dst(0), weight(0) {\n\n\t}\n};\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n\te.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n\n//??????0??????????????????????????¨??£???????±??????????????????§??¨???\nWeight maximumFlow(const Graph &ag, int s, int t) {\n\n\tGraph g(ag);\n\tfor (int i = 0; i < ag.size(); ++i) {\n\t\tfor (int j = 0; j < ag[i].size(); ++j) {\n\t\t\tint d = ag[i][j].dst;\n\t\t\tint s = ag[i][j].src;\n\n\t\t\tbool ok = false;\n\t\t\tfor (int k = 0; k < ag[d].size(); ++k) {\n\t\t\t\tif (ag[d][k].src == s) {\n\t\t\t\t\tok = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!ok) {\n\t\t\t\tg[d].push_back(Edge(d, s, ZERO));\n\t\t\t}\n\t\t}\n\t}\n\tint n = g.size();\n\tMatrix flow(n, Array(n,ZERO)), capacity(n, Array(n,ZERO));\n\tREP(u, n) FOR(e, g[u]) capacity[e->src][e->dst] =capacity[e->src][e->dst]+ e->weight;\n\n\n\tWeight total = ZERO;\n\twhile (1) {\n\t\tqueue<int> Q; Q.push(s);\n\t\tvector<int> prev(n, -1); prev[s] = s;\n\t\twhile (!Q.empty() && prev[t] < 0) {\n\t\t\tint u = Q.front(); Q.pop();\n\t\t\tFOR(e, g[u]) if (prev[e->dst] < 0 && RESIDUE(u, e->dst) > ZERO) {\n\t\t\t\tprev[e->dst] = u;\n\t\t\t\tQ.push(e->dst);\n\t\t\t}\n\t\t}\n\t\tif (prev[t] < 0)break; // prev[x] == -1 <=> t-side\n\t\tWeight inc = INF;\n\t\tfor (int j = t; prev[j] != j; j = prev[j]){\n\t\t\tauto v(RESIDUE(prev[j], j));\n\t\t\tif (inc > v) {\n\t\t\t\tinc = v;\n\t\t\t}\n\t\t}\n\t\tfor (int j = t; prev[j] != j; j = prev[j])\n\t\t\tflow[prev[j]][j] =flow[prev[j]][j]+inc, flow[j][prev[j]] =flow[j][prev[j]]- inc;;\n\t\ttotal += inc;\n\t}\n\n\treturn total;\n}\n\n\n\n\nint main() {\n\tint X, Y, E; cin >> X >> Y >> E;\n\tconst int start = 0;\n\tconst int node_x = start + 1;\n\tconst int node_y = node_x + X;\n\tconst int goal = node_y + Y;\n\tGraph g(goal+1);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tg[node_x+x].push_back(Edge{ node_x + x,node_y + y,1 });\n\t}\n\tfor (int i = 0; i < X; ++i) {\n\t\tg[start].push_back(Edge{ start,node_x + i ,1});\n\t}\n\tfor (int y = 0; y < Y; ++y) {\n\t\tg[node_y + y].push_back(Edge{ node_y + y,goal,1 });\n\t}\n\tint ans = maximumFlow(g, start, goal);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\nconst int N = 2e2 + 10, M = 1e4 + 10;\nint x, y, n, m, ans, s, t, mark[M], vis[N], adj[N][N];\n\nbool dfs(int v) {\n\tvis[v] = 1;\n\tif (v == t)\n\t\treturn 1;\n\t\t\n\tfor (int i = 0; i < n; i++) {\n\t\tif (adj[v][i] == -1)\n\t\t\tcontinue;\n\t\t\t\n\t\tif (!vis[i] && dfs(i)) {\n\t\t\tmark[adj[v][i]] ^= 1;\n\t\t\tswap(adj[v][i], adj[i][v]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tmemset(adj, -1, sizeof adj);\n\tcin >> x >> y >> m;\n\tn = x + y;\n\tfor (int i = 0; i < m; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tu += x;\n\t\tadj[v][u] = i;\n\t}\n\t\n\ts = n++, t = n++;\n\tfor (int i = 0; i < x; i++)\n\t\tadj[s][i] = m++;\n\tfor (int i = 0; i < y; i++)\n\t\tadj[x + i][t] = m++;\n\t\t\n\twhile (dfs(s)) {\n\t\tans++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tvis[i] = 0;\n\t}\n\tcout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\nconst int MAX_V = 101;\nconst int MAX_X = 101;\nconst int MAX_Y = 101;\n\nclass Edge{\n    public:\n        int to, cap, rev;\n};\n\ntypedef vector<vector<Edge>> AdjList;\nAdjList G(MAX_V);\nbool used[MAX_V];\n\nvoid addEdge(int from, int to, int cap){\n    G[from].emplace_back(Edge{to, cap, static_cast<int>(G[to].size())});\n    G[to].emplace_back(Edge{from, 0, static_cast<int>(G[from].size() - 1)});\n}\n\nint dfs(int v, int t, int f){\n    if(v == t) return f;\n    used[v] = true;\n    rep(i,G[v].size()){\n        Edge &e = G[v][i];\n        if(not used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxFlow(int s, int t){\n    int flow = 0;\n    while(true){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\nint bipartiteMatching(int x, int y, bool edge[MAX_X][MAX_Y]){\n    int s = x + y, t = s + 1; //set x : 0 ~ x-1, set y : x ~ x+y-1\n\n    rep(i,x) addEdge(s, i, 1); //s??¨??????x????????¶\n    rep(i,y) addEdge(x + i, t, 1); //??????y??¨t????????¶\n\n    rep(i,x) rep(j,y) if(edge[i][j]) addEdge(i, x + j, 1); //??????x??¨??????y????????¶\n\n    return maxFlow(s, t);\n}\n\nint main(){\n    int x, y, e;\n    cin >> x >> y >> e;\n\n    bool edge[MAX_X][MAX_Y] = {0};\n    rep(i,e){\n        int a, b;\n        cin >> a >> b;\n        edge[a][b] = edge[b][a] = 1;\n    }\n    cout << bipartiteMatching(x, y, edge) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 1000\n#define INF 1<<29\nusing namespace std;\nstruct edge{int to,cap,rev;};\nvector<edge>G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int>q;\n  level[s]=0;\n  q.push(s);\n  while(!q.empty()){\n    int v=q.front();q.pop();\n    for(int i=0;i<G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n        level[e.to]=level[v]+1;\n        q.push(e.to);\n      }\n    }\n  }\n}\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\nint main(){\n  int n,m;\n  cin>>n>>n>>m;\n  for(int i=1;i<101;i++)add_edge(0,i,1);\n  for(int i=101;i<201;i++)add_edge(i,300,1);\n  while(m--){\n    int a,b;\n    cin>>a>>b;\n    a++;\n    b+=101;\n    add_edge(a,b,1);\n  }\n  cout<<max_flow(0,300)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<tuple>\n#include<iostream>\n#include<queue>\n#include<numeric>\n#include<deque>\nusing namespace std;\n\nstruct GeneralMatching{\n\tint N;\n\tint cur;\n\tvector<int>t,p,used,base,match;\n\tqueue<int>que;\n\tvector<vector<int>>G;\n\n\tGeneralMatching(int n):N(n),cur(0),t(n),p(n),used(n),base(n),match(n),G(n){}\n\n\tvoid addEdge(int v,int u){\n\t\tG[v].push_back(u);\n\t\tG[u].push_back(v);\n\t}\n\n\tint get(int v){\n\t\treturn base[v]==v?v:base[v]=get(base[v]);\n\t}\n\n\tint getLCA(int v,int u){\n\t\tv=get(v);u=get(u);\n\t\tcur++;\n\t\twhile(true){\n\t\t\tif(v!=-1){\n\t\t\t\tif(used[v]==cur)return v;\n\t\t\t\tused[v]=cur;\n\t\t\t\tv=match[v]==-1?-1:get(p[match[v]]);\n\t\t\t}\n\t\t\tswap(v,u);\n\t\t}\n\t}\n\n\tvoid blossom(int v,int u,int b){\n\t\twhile(get(v)!=b){\n\t\t\tp[v]=u;\n\t\t\tu=match[v];\n\t\t\tif(t[u]==1){\n\t\t\t\tt[u]=0;\n\t\t\t\tque.push(u);\n\t\t\t}\n\t\t\tbase[v]=b;\n\t\t\tbase[u]=b;\n\t\t\tv=p[u];\n\t\t}\n\t}\n\n\tvoid augment(int u,int v){\n\t\twhile(u!=-1){\n\t\t\tint nu=match[p[u]];\n\t\t\tmatch[u]=p[u];\n\t\t\tmatch[p[u]]=u;\n\t\t\tu=nu;\n\t\t}\n\t}\n\n\tbool bfs(int s){\n\t\tfill(p.begin(),p.end(),-1);\n\t\tfill(t.begin(),t.end(),-1);\n\t\tiota(base.begin(),base.end(),0);\n\t\tt[s]=0;\n\t\tque=queue<int>();\n\t\tque.push(s);\n\t\twhile(que.size()){\n\t\t\tint v=que.front();que.pop();\n\t\t\tfor(auto u:G[v]){\n\t\t\t\tif(t[u]==-1){\n\t\t\t\t\tt[u]=1;\n\t\t\t\t\tp[u]=v;\n\t\t\t\t\tif(match[u]==-1){\n\t\t\t\t\t\taugment(u,v);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tint w=match[u];\n\t\t\t\t\tt[w]=0;\n\t\t\t\t\tque.push(w);\n\t\t\t\t}\n\t\t\t\telse if(t[u]==0&&get(v)!=get(u)){\n\t\t\t\t\tint b=getLCA(v,u);\n\t\t\t\t\tblossom(v,u,b);\n\t\t\t\t\tblossom(u,v,b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint solve(){\n\t\tfill(match.begin(),match.end(),-1);\n\t\tint res=0;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(match[i]==-1&&bfs(i))res++;\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tint X,Y,E;\n\tcin>>X>>Y>>E;\n\n\tGeneralMatching gm(X+Y);\n\tfor(int i=0;i<E;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\ty+=X;\n\t\tgm.addEdge(x,y);\n\t}\n\n\tcout<<gm.solve()<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T>\nstruct Edge {\n    int rev, from, to;  // rev:逆向きの辺の番号\n    T cap, original_cap;\n    Edge(int r, int f, int t, T c) : rev(r), from(f), to(t), cap(c), original_cap(c) {}\n};\ntemplate <class T>\nstruct Graph {\n    vector<vector<Edge<T>>> G;\n    Graph(int n = 0) : G(n) {}\n    vector<Edge<T>>& operator[](int i) { return G[i]; }\n    const size_t size() const { return G.size(); }\n    Edge<T>& redge(Edge<T> e) {  // 逆向きの辺を返す\n        return G[e.to][e.rev];   // 自己ループはないと仮定（あれば G[e.to][e.rev + 1] とする必要がある）\n    }\n    void add_edge(int from, int to, T cap) {  // 有向辺を加える\n        G[from].push_back(Edge<T>((int)G[to].size(), from, to, cap));\n        G[to].push_back(Edge<T>((int)G[from].size() - 1, to, from, 0));\n    }\n};\n/* FordFulkerson: Ford-Fulkersonのアルゴリズムで最大流を求める構造体\n    max_flow(G,s,t) ：グラフGの最大流が求まる\n    副作用：G は最大流の残余ネットワークになる\n    計算量: O(|f*||E|) (f*:最大流) \n*/\ntemplate <class T>\nstruct FordFulkerson {\n    const T INF = 1e9;\n    vector<int> used;\n    FordFulkerson(){};\n    T dfs(Graph<T>& G, int v, int t, T f) {  // 増加可能経路を見つけて増加分のフローを返す\n        if (v == t) return f;\n        used[v] = true;\n        for (auto& e : G[v]) {\n            if (!used[e.to] && e.cap > 0) {\n                T d = dfs(G, e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G.redge(e).cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    T max_flow(Graph<T>& G, int s, int t) {\n        T flow = 0;\n        while (true) {\n            used.assign(G.size(), 0);\n            T f = dfs(G, s, t, INF);  // f が増加分のフロー\n            if (f == 0) {\n                return flow;\n            } else {\n                flow += f;\n            }\n        }\n        return 0;\n    }\n};\nint main() {\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    Graph<int> G(X + Y + 2);\n    for (int i = 0; i < X; i++) {  // ソース(0)から X(1~X) への辺\n        G.add_edge(0, i + 1, 1);\n    }\n    for (int i = 0; i < E; i++) {  // X(1~X) から Y(X+1~X+Y) への辺\n        int x, y;\n        cin >> x >> y;\n        G.add_edge(x + 1, y + X + 1, 1);\n    }\n    for (int i = 0; i < Y; i++) {  // Y(X+1~X+Y) からシンク(X+Y+1)への辺\n        G.add_edge(i + X + 1, X + Y + 1, 1);\n    }\n    FordFulkerson<int> ff;\n    cout << ff.max_flow(G, 0, X + Y + 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> pii;\n\nconst int N = 2e2 + 10, M = 1e4 + 10;\nint x, y, n, m, ans, s, t, mark[M], vis[N], adj[N][N];\n\nbool dfs(int v) {\n\tvis[v] = 1;\n\tif (v == t)\n\t\treturn 1;\n\t\t\n\tfor (int i = 0; i < n; i++) {\n\t\tif (adj[v][i] == -1)\n\t\t\tcontinue;\n\t\t\t\n\t\tif (!vis[i] && dfs(i)) {\n\t\t\tmark[adj[v][i]] ^= 1;\n\t\t\tswap(adj[v][i], adj[i][v]);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tmemset(adj, -1, sizeof adj);\n\tcin >> x >> y >> m;\n\tn = x + y;\n\tfor (int i = 0; i < m; i++) {\n\t\tint v, u;\n\t\tcin >> v >> u;\n\t\tu += x;\n\t\tadj[v][u] = i;\n\t}\n\t\n\ts = n++, t = n++;\n\tfor (int i = 0; i < x; i++)\n\t\tadj[s][i] = m++;\n\tfor (int i = 0; i < y; i++)\n\t\tadj[x + i][t] = m++;\n\t\t\n\twhile (dfs(s)) {\n\t\tans++;\n\t\tmemset(vis, 0, sizeof vis);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n#define rep(i, n) for(int i=0; i<n; ++i)\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\nusing namespace std;\nusing ll = int64_t;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vs = vector<string>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQG = priority_queue<T, vector<T>, greater<T> >;\nconst int INF = 100010001;\nconst ll LINF = (ll)INF*INF*10;\ntemplate<typename T1, typename T2>\ninline bool chmax(T1 &a, T2 b) {return a < b && (a = b, true);}\ntemplate<typename T1, typename T2>\ninline bool chmin(T1 &a, T2 b) {return a > b && (a = b, true);}\ntemplate<typename T1, typename T2>\nistream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second;}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << ' ' << p.second;}\n\nstruct BM {\n  int V;\n  vector<vector<int > > G;\n  vector<int> match;\n  vector<bool> used;\n  BM(int n=0) : V(n), G(n), match(n, -1), used(n) {}\n  inline void add(int u, int v) {\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n  bool dfs(int v) {\n    used[v] = true;\n    for(int u:G[v]) {\n      int w = match[u];\n      if(w < 0 or (!used[w] and dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n  int bipartite_matching() {\n    int res = 0;\n    rep(v, V) {\n      if(match[v] < 0) {\n        rep(i, v) used[i] = 0;\n        if(dfs(v)) res++;\n      }\n    }\n    return res;\n  }\n};\n\n//head\n\nint x, y, e;\nBM bpm(200);\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> x >> y >> e;\n  rep(i, e) {\n    cin >> x >> y;\n    bpm.add(x, 100+y);\n  }\n  cout << bpm.bipartite_matching() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <climits>\n#include <assert.h>\n#include <queue>\n#include <set>\n\nusing namespace std;\n// ???(???????????? ????????? ???????????? ???????????????)\nstruct Edge {\n    int to, cap, cost, rev;\n    Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {\n        assert(this->cap >= 0);\n    }\n};\n\n// ?????§????????????O(F|E|)??§?§£???\nclass FordFulkerson {\npublic:\n    unsigned int num_of_node = 0;   // ???????????°\n    map<int, vector<Edge>> G;       // ??°???????????£??\\???????????¨???\n    vector<bool> used;              // DFS??§?????§??????????????????????????°\n\n    FordFulkerson(unsigned int num_of_node) : num_of_node(num_of_node){\n    }\n\n    // from??????to??????????????????cap????????¨?????????????????°?????????????????????\n    void add_edge(int from, int to, int cap) {\n        this->G[from].push_back(Edge(to, cap, (int)this->G[to].size()));        // ???\n        this->G[to].push_back(Edge(from, 0, (int)this->G[from].size() - 1));    // ??????\n    }\n\n    // s??????t???????????§???????±??????? O(F|E|)\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (true) {\n            this->used = vector<bool>(this->num_of_node, 0);\n            int f = dfs(s, t, INT_MAX);\n            if (f == 0) { return flow; }\n            flow += f;\n        }\n    }\n\nprivate:\n    // v??????t???f???????????¨??????????????????\n    int dfs(int v, int t, int f) {\n        if (v == t) { return f; }\n        used[v] = true;\n        for (Edge &e : G[v]) {\n            if (!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;                 // ???\n                    G[e.to][e.rev].cap += d;    // ??????\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n};\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    FordFulkerson ff(X + Y);\n    set<int> x_set, y_set;\n    for (int i = 0; i < E; ++i) {\n        int x, y;\n        cin >> x >> y;\n        x_set.insert(x);\n        y_set.insert(y);\n        ff.add_edge(x, y, 1);\n    }\n\n    int source = X + Y + 1;\n    int sink = source + 1;\n\n    for (int x : x_set) {\n        ff.add_edge(source, x, 1);\n    }\n    for (int y : y_set) {\n        ff.add_edge(y, sink, 1);\n    }\n\n    cout << ff.max_flow(source, sink) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n\n\nstruct BipartiteMatching {\n\tusing size_type = std::size_t;\n\t\n\tBipartiteMatching(size_type x, size_type y) : x(x), y(y), g(x + y, std::vector<size_type>()) {}\n\tBipartiteMatching(size_type n) : BipartiteMatching(n, n) {}\n\t\n\tvoid add_edge(size_type a, size_type b) {\n\t\tg[a].push_back(b + x);\n\t\tg[b + x].push_back(a);\n\t}\n\t\n\tsize_type build() {\n\t\tmatch.assign(y, -1);\n\t\tsize_type res = 0;\n\t\tfor (size_type i = 0; i < x; ++i) {\n\t\t\tvisited.assign(y, 0);\n\t\t\tif (dfs(i)) ++res;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tbool dfs(size_type u) {\n\t\tfor (auto v: g[u]) {\n\t\t\tv -= x;\n\t\t\tif (!visited[v]) {\n\t\t\t\tvisited[v] = true;\n\t\t\t\tif (!~match[v] || dfs(match[v])) {\n\t\t\t\t\tmatch[v] = u;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\nprivate:\n\tsize_type x, y;\n\tstd::vector<std::vector<size_type>> g;\n\tstd::vector<size_type> match;\n\tstd::vector<bool> visited;\n};\n\n\n#include <cstdio>\n\nint main() {\n\tint X, Y, E;\n\tscanf(\"%d %d %d\", &X, &Y, &E);\n\tBipartiteMatching bm(X, Y);\n\twhile (E--) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tbm.add_edge(x, y);\n\t}\n\t\n\tprintf(\"%d\\n\", bm.build());\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstatic const int MAX_V = 1e3;\n\nint V, match[MAX_V];\nvector<int> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u, int v){\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i)\n\t{\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || (!used[w] && dfs(w)))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching() {\n\tint res = 0;\n\tfill(match, match+V, -1);\n\tfor (int v = 0; v < V; ++v)\n\t{\n\t\tif (match[v] < 0)\n\t\t{\n\t\t\tfill(used, used+V, 0);\n\t\t\tif (dfs(v)) res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(int argc, char const *argv[])\n{\n\tint x, y, e;\n\tcin >> x >> y >> e;\n\tV = x+y;\n\tfor (int i = 0; i < e; ++i)\n\t{\n\t\tint xi, yi;\n\t\tcin >> xi >> yi;\n\t\tyi+=x;\n\t\tadd_edge(xi, yi);\n\t}\n\tcout << bipartite_matching() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\ntypedef struct{ int to; int rev; int f;} edge;\nint x, y;\nstd::vector<edge> vec[250];\nbool flag[250];\n\nint dfs(int a) {\n  int i;\n  if(a == x + y + 1) return 1;\n  flag[a] = false;\n  for(i = 0; i < vec[a].size(); ++i) if(flag[vec[a][i].to] && vec[a][i].f) {\n    edge *e = &vec[a][i];\n    int d;\n    d = dfs((*e).to);\n    if(d) {\n      (*e).f--;\n      vec[(*e).to][(*e).rev].f++;\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint main(void) {\n  int i, j, k, e, a, b, c, ans = 0;\n  scanf(\"%d%d%d\", &x, &y, &e);\n  for(i = 0; i < x + y + 2; ++i) flag[i] = true;\n  flag[0] = false;\n  for(i = 0; i < e; ++i) {\n    scanf(\"%d%d\", &a, &b);\n    b += x;\n    edge ta, tb;\n    ta.to = b, ta.f = 1, ta.rev = vec[b].size();\n    tb.to = a, tb.f = 0, tb.rev = vec[a].size();\n    vec[a].push_back(ta);\n    vec[b].push_back(tb);\n    ta.to = x + y, ta.f = 0, ta.rev = vec[x + y].size();\n    tb.to = a, tb.f = 1, tb.rev = vec[a].size();\n    vec[x + y].push_back(tb);\n    vec[a].push_back(ta);\n    ta.to = x + y + 1, ta.f = 1, ta.rev = vec[x + y + 1].size();\n    tb.to = b, tb.f = 0, tb.rev = vec[b].size();\n    vec[x + y + 1].push_back(tb);\n    vec[b].push_back(ta);\n  }\n  while( 1 ) {\n     for(i = 0; i < x + y + 2; ++i) flag[i] = true;\n     flag[0] = false;\n     a = dfs(0);\n     if(a) ans++;\n     else break;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\n//?????¨??°??????????????§??????????????°????±???????\n//ford-fulkerson??????????¬????????????????????????????\nclass BipartiteMatching {\nprotected:\n\tvector<vector<int>>graph;\n\t//match=?????????????????????????????´??????-1???alive=0???????????¨???????????§??????(?¶???????????????§?????¨)???used=????????????????????????\n\tvector<int>match, alive, used;\n\tint stamp;\n\tint V;\n\tbool dfs(int v) {\n\t\tused[v] = stamp;\n\t\tfor (auto u : graph[v]) {\n\t\t\tint w = match[u];\n\t\t\tif (!alive[u])continue;\n\t\t\tif (w == -1 || (used[w] != stamp&&dfs(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\npublic:\n\tBipartiteMatching(int n)\n\t\t:stamp(0), V(n), graph(n), match(n, -1), alive(n, 1), used(n, 0)\n\t{}\n\t//u??¨v?????????????????????\n\tvoid addedge(int u, int v) {\n\t\tgraph[u].push_back(v);\n\t\tgraph[v].push_back(u);\n\t}\n\t//??°??????????????§??????????????°????±???????\n\tint getMatch() {\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < V; ++i) {\n\t\t\tif (!alive[i])continue;\n\t\t\tif (match[i] == -1) {\n\t\t\t\t++stamp;\n\t\t\t\tret += dfs(i);\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n//???????????£????????????????¨?????????????????????§??????\nclass FixMatching : public BipartiteMatching\n{\npublic:\n\tFixMatching(int sz) : BipartiteMatching(sz) {}\n\t//??????k??????????????¨???????????????????±???????\n\tint add(int k) {\n\t\talive[k] = 1;\n\t\t++stamp;\n\t\treturn (dfs(k));\n\t}\n\t//??????k?????????????????¨???????????????????±???????\n\tint kill(int k) {\n\t\talive[k] = 0;\n\t\tif (match[k] == -1) return (0);\n\t\tmatch[match[k]] = -1;\n\t\t++stamp;\n\t\tint ret = dfs(match[k]);\n\t\tmatch[k] = -1;\n\t\treturn (ret - 1);\n\t}\n};\n\nint main(void)\n{\n\tint X, Y, E;\n\tcin >> X >> Y >> E;\n\tBipartiteMatching bm(X + Y);\n\tfor (int i = 0; i < E; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tbm.addedge(x, X + y);\n\t}\n\tcout << bm.getMatch() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <complex>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nconst int INF = 1 << 27;\nconst int MAX_V = 101;\n//////////////////////////////\n// 2??¨??????????????°(???????????¨???1)\nint V, match[MAX_V], used[MAX_V];\nvector<vi> G(MAX_V);\n\nbool dfs(int v){\n  used[v] = true;\n  REP(i, G[v].size()){\n    int u = G[v][i], w = match[u];\n    if(w < 0 || (!used[w] && dfs(w))){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartite_matching(){\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  REP(v, V)\n    if(match[v] < 0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)) ++res;\n    }\n  return res;\n}\nint main() {\n  int X, Y, E; cin >>X >>Y >>E;\n  V = X + Y;\n  REP(i, E){\n    int u, v; cin >>u >>v;\n    v += X;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  cout << bipartite_matching() <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint edge[220][220];\nint X, Y, e, x, y;\nbool done[220];\n\nbool dfs(int s, int g){\n    if(done[s])return false;\n    done[s] = true;\n    if(s == g)return true;\n    for(int to = 0;to < 220;to++){\n        if(edge[s][to] == 0)continue;\n        if(dfs(to, g)){\n            edge[s][to]--;\n            edge[to][s]++;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n    cin >> X >> Y >> e;\n    int s = X+Y, g = X+Y+1;\n    for(int i = 0;i < e;i++){\n        cin >> x >> y;\n        edge[x][y+X] = 1;\n    }\n    for(int i = 0;i < X;i++)edge[s][i] = 1;\n    for(int i = 0;i < Y;i++)edge[i + X][g] = 1;\n\n    int ans = 0;\n    while(true){\n        fill(done, done + 220, false);\n        if(!dfs(s, g))break;\n        ans++;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nstruct BipartiteMatching {\n    int m, n;\n    vector<vector<int> > G;\n    vector<bool> used; vector<int> match;\n    BipartiteMatching(int m, int n) : m(m), n(n), G(m+n), used(m+n), match(m+n) {}\n    void add_edge(int u, int v){\n        if( !(0<=u&&u<m&&0<=v&&v<n) ) throw domain_error(\"invalid node\"); \n        G[u].push_back(m+v); G[m+v].push_back(u);\n    }\n    bool dfs(int v){  // check if there exists a path from v to t\n        used[v] = true;\n        for(int i=0;i<G[v].size();++i){\n            int u = G[v][i], w = match[u];\n            if(w<0 || !used[w] && dfs(w)) { match[v] = u; match[u] = v; return true; }\n        }\n        return false;\n    }\n    int solve(){\n        int nmatch = 0;\n        fill(match.begin(), match.end(), -1);\n        for(int v=0;v<m+n;++v)\n            if(match[v]<0){ fill(used.begin(),used.end(),false); if(dfs(v)) nmatch++; }\n        return nmatch;\n    }\n};\n\n\n\n\n\n\nint main(){\n  int m, n, E, x, y;\n  cin >> m >> n >> E;\n  BipartiteMatching bm(m,n);\n  for(int i=0;i<E;++i){\n    cin >> x >> y;\n    bm.add_edge(x,y);\n  }\n  int ret = bm.solve();\n  cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\n\nstruct edge{\n    ll to,cap,cost,rev;\n    edge(){}\n    edge(ll to,ll cap,ll rev):to(to),cap(cap),rev(rev){}\n    edge(ll to,ll cap,ll cost,ll rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\n\ntypedef vector<vector<edge> > graph;\nstruct Dinic{\n    ll n;\n    graph g;\n    vector<ll> level,iter;\n    Dinic() {}\n    Dinic(ll n): n(n){\n\tg.resize(n);\n\tlevel.resize(n);\n\titer.resize(n);\n    }\n    void add_edge(ll from, ll to, ll cost){\n\tg[from].push_back(edge(to,cost,g[to].size()   ) );\n\tg[to].push_back(edge(from,0,g[from].size() -1 ) );\n    }\n    void bfs(ll s){\n\tfill(level.begin(),level.end(),-1);\n\tqueue<ll> q;\n\tq.push(s);\n\tlevel[s] = 0;\n\twhile(!q.empty()){\n\t    ll tmp = q.front();\n\t    q.pop();\n\t    for(ll i=0;i<g[tmp].size();i++){\n\t\tedge &e = g[tmp][i];\n\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t    level[e.to] = level[tmp] + 1;\n\t\t    q.push(e.to);\n\t\t}\n\t    }\n\t}\n    }\n    ll dfs(ll v,ll t,ll f){\n\tif( v == t ) return f;\n\tfor(ll &i = iter[v]; i < g[v].size() ; i++){\n\t    edge &e = g[v][i];\n\t    if( e.cap > 0 && level[v] < level[e.to] ){\n\t\tll d = dfs(e.to, t, min(f,e.cap) );\n\t\tif( d > 0 ){\n\t\t    e.cap -= d;\n\t\t    g[e.to][e.rev].cap += d;\n\t\t    return d;\n\t\t}\n\t    }\n\t}\n\treturn 0;\n    }\n    ll max_flow(ll s,ll t){\n\tll flow = 0, f;\n\twhile(1){\n\t    bfs(s);\n\t    if(level[t] < 0) return flow;\n\t    fill(iter.begin(),iter.end() , 0);\n\t    for(f = dfs(s,t,inf); f > 0; f = dfs(s,t,inf) ) flow += f;\n\t}\n    }\n};\n\n\n\nint main(){\n    ll x,y,e;\n    cin>>x>>y>>e;\n    ll S = x + y;\n    ll T = x + y + 1;\n    Dinic f(x+y+2);\n    for(int i=0;i<x;i++)f.add_edge(S,i,1);// sorce から　Xの集合へ\n    for(int i=0;i<y;i++)f.add_edge(x+i,T,1);// Yの集合からsinkへ\n    for(ll i=0;i<e;i++){\n\tll s,t;\n\tcin>>s>>t;\n\tf.add_edge(s,x+t,1);// X to Y\n    }\n    cout<<f.max_flow(S,T)<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int inf = 1e9;\n\nstruct edge{int to, cap, rev;};\nvector<edge> G[206];\nbool used[206];\nint dfs(int v, int t, int f){\n\tif(v == t)return f;\n\tused[v] = true;\n\tfor(int i = 0;i < G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid add(int v, int u){\n\tG[v].push_back((edge){u, 1, G[u].size()});\n\tG[u].push_back((edge){v, 0, G[v].size()-1});\n}\n\nint main(){\n\tint n1, n2, m, v, u, c;\n\tscanf(\"%d%d%d\", &n1, &n2, &m);\n\tfor(int i = 0;i < m;i++){\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tadd(n1+n2, v);\n\t\tadd(v, n1+u);\n\t\tadd(n1+u, n1+n2+1);\n\t}\n\t\n\tint flow = 0;\n\twhile(1){\n\t\tfill(used, used+206, 0);\n\t\tint f = dfs(n1+n2, n1+n2+1, inf);\n\t\tif(f == 0)break;\n\t\tflow += f;\n\t}\n\t\n\tprintf(\"%d\\n\", flow);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\ntemplate<typename T>\nT Hungarian(const vector<vector<T> >& b){\n    int p, q, n = len(b);\n    vector<int> fx(n, 1<<28), fy(n, 0);\n    vector<int> x(n, -1), y(n, -1);\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            fx[i] = max(fx[i], b[i][j]);\n    for (int i = 0; i < n; ) {\n        vector<int> t(n, -1), s(n+1, i);\n        for (p = q = 0; p <= q && x[i] < 0; ++p)\n            for (int k = s[p], j = 0; j < n && x[i] < 0; ++j)\n                if (fx[k] + fy[j] == b[k][j] && t[j] < 0) {\n                    s[++q] = y[j], t[j] = k;\n                    if (s[q] < 0)\n                        for (p = j; p >= 0; j = p)\n                            y[j] = k = t[j], p = x[k], x[k] = j;\n                }\n        if (x[i] < 0) {\n            int d = 1<<28;\n            for (int k = 0; k <= q; ++k)\n                for (int j = 0; j < n; ++j)\n                    if (t[j] < 0) d = min(d, fx[s[k]] + fy[j] - b[s[k]][j]);\n            for (int j = 0; j < n; ++j) fy[j] += (t[j] < 0 ? 0 : d);\n            for (int k = 0; k <= q; ++k) fx[s[k]] -= d;\n        } else ++i;\n    }\n    int ret = 0;\n    for (int i = 0; i < n; ++i) ret += b[i][x[i]];\n    return ret;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int x,y,m;\n    cin >> x >> y >> m;\n    vvi cs(max(x,y),vi(max(x,y),0));\n    rep(i,m){\n        int a,b;\n        cin >> a >> b;\n        cs[a][b] = 1;\n    }\n    cout << Hungarian(cs) << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n//typedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\ntypedef vector<vector<int>> mat;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nstruct edge\n{\n\tint s, t, c, d,rev;\n\tedge(int s, int t, int c, int d,int rev) :s(s), t(t), c(c),d(d), rev(rev) {}\n\tedge() { s = -1, t = -1, c = -1, rev = -1; d = -1; }\n};\n\nvector<int> G[1002];\nbool used[1002];\nint match[1002];\n\nbool dfs(int v)\n{\n\tused[v] = true;\n\trep(i, 0, SZ(G[v]))\n\t{\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(int V)\n{\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\trep(i, 0, V)\n\t{\n\t\tif (match[i] < 0)\n\t\t{\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(i))\n\t\t\t{\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint X, Y,E, x, y;\n\tcin >> X >> Y >> E;\n\trep(i, 0, E)\n\t{\n\t\tcin >> x >> y;\n\t\tG[x].push_back(X + y);\n\t\tG[X + y].push_back(x);\n\t}\n\n\tcout << bipartite_matching(X + Y) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 1000\n\nvector<int> G[MAX_V];\nint match[MAX_V],V;\nbool used[MAX_V];\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\n\nbool dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0||!used[w]&&dfs(w)){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)){\n\tres++;\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int x,y,e,a,b,i;\n  cin>>x>>y>>e;\n  for(i=0;i<e;i++){\n    cin>>a>>b;\n    add_edge(a,x+b);\n  }\n  V=x+y;\n  cout << bipartite_matching() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\ntypedef vector<Edge> vE;\ntypedef priority_queue<Edge, vector<Edge>, greater<Edge> > pqlE;\n\n#define MAX_V 210\n\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[MAX_V];\t// ??°???????????£??\\???????????¨???\nint level[MAX_V];\t// s??????????????¢\nint iter[MAX_V];\t// ???????????§??????????????£??????\n\n\t\t\t\t\t// from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from, int to, int cap)\n{\n\tG[from].push_back(edge{ to, cap, (int)G[to].size() });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n}\n\n// s????????????????????¢???BFS??§?¨????\nvoid bfs(int s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ?¢?????????????DFS??§??¢???\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n// s??????t???????????§???????±???????\nint max_flow(int s, int t) {\n\tint flow = 0;\n\twhile (true) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tint X, Y, E;\n\tcin >> X >> Y >> E;\n\trep(i, E) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tadd_edge(x, X + y, 1);\n\t}\n\trep(x, X) {\n\t\tadd_edge(X + Y, x, 1);\n\t}\n\trep(y, Y) {\n\t\tadd_edge(X + y, X + Y + 1, 1);\n\t}\n\n\tcout << max_flow(X + Y, X + Y + 1) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <iostream>\n#include <math.h>\n#include <string.h> //memset\n#define rep(i,n) for (int i = 0; (i) < (n); ++ (i))\nusing namespace std;\n#define INF 1e9\n#define MAX_V 1000\n//辺の構造体\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\n//from-to 容量capの辺を追加\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, (int)G[to].size()});   //場所が被るごとに0,1,...がrevに入る\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\n//増加パスをDFS\nint dfs(int v, int t, int f) {\n    if(v == t) return f;\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f,e.cap));\n            if(d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n//s-tの最大流\nint max_flow(int s, int t) {\n    int flow = 0;\n    while(1) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\nsigned main() {\n    int x,y,e,from,to;\n    cin >> x >> y >> e;\n    rep(i,x) add_edge(210, i, 1);\n    rep(i,y) add_edge(i+100, 220, 1);\n    rep(i,e) {\n        cin >> from >> to;\n        add_edge(from, to+100, 1);\n    }\n    cout << max_flow(210,220) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n#define ll long long\n#define ld long double\n#define  P pair<ll,ll>\n#define FOR(i,n,m) for(ll i=n; i<(ll)m;i++)\n#define FORa(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FORr(i,m,n) for(ll i=n; i>=(ll)m; i--)\n#define FORm(i,m) for(auto i=m.begin();i!=m.end();i++)\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define ALL(c) (c).begin(), (c).end()\n#define VEC2(x,a,b) vector<vector<ll>> x = vector<vector<ll>>(a,vector<ll>(b,0))\n#define sortAl(v) sort(v.begin(),v.end())\n#define sortAlr(v) sort(v.begin(),v.end()); reverse(v.begin(),v.end())\n#define cinv(v,n,m) FOR(i,n,m) cin>>v.at(i)\n#define coutv(v,n,m) FOR(i,n,m) cout<<v.at(i) <<\" \"; cout<<endl\n#define cout(n) cout<<fixed<<setprecision(n)\n\n\ntemplate< typename T >\nstruct edge {\n  ll src, to;\n  T cost;\n\n  edge(ll to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(ll src, ll to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator ll() const { return to; }\n};\n\ntemplate< typename T1 >\nusing Edges = vector< edge< T1 > >;\ntemplate< typename T2 >\nusing WeightedGraph = vector< Edges< T2 > >;\nusing UnWeightedGraph = vector< vector< ll > >;\ntemplate< typename T3 >\nusing Matrix = vector< vector< T3 > >;\n\nstruct Bipartite_Matching{\n  vector< vector< ll > > graph;\n  vector< ll > match, alive, used;\n  ll timestamp;\n\n  Bipartite_Matching(ll n)\n  {\n    timestamp = 0;\n    graph.resize(n);\n    alive.assign(n, 1);\n    used.assign(n, 0);\n    match.assign(n, -1);\n  }\n\n  void add_edge(ll u, ll v)\n  {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(ll v)\n  {\n    used[v] = timestamp;\n    for(ll i = 0; i < graph[v].size(); i++) {\n      ll u = graph[v][i], w = match[u];\n      if(alive[u] == 0) continue;\n      if(w == -1 || (used[w] != timestamp && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  ll bipartite_matching()\n  {\n    ll ret = 0;\n    for(ll i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return (ret);\n  }\n};\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll x,y,n;\n    cin>>x>>y>>n;\n    vector<vector<ll>> a;\n    vector<ll> b;\n    Bipartite_Matching s = {x+y};\n    FOR(i,0,n){\n      ll in1,in2;\n      cin>>in1>>in2;\n      in2 += x;\n      s.add_edge(in1,in2);\n    }\n    cout<<s.bipartite_matching()<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n//#define ZERO(x) memset(x, 0, sizeof(x))\n//#define FILL(x, y) memset(x, y, sizeof(x))\n#define UNUSED(x) (void(x));\n#define PB push_back\n#define EB emplace_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator+(const string l, const string& r) {\n    string str = l;\n    str += r;\n    return str;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro\n\n// 頂点の数、辺の情報、indexed\ntemplate <class num_type>\nstruct max_flow {\n    int n;\n    num_type flow;\n    vector<map<int, num_type>> g_temp;\n    vector<vector<int>> gkey_temp;\n    max_flow(int& t1, vector<tuple<int, int, num_type>>& t2, int indexed) {\n        int u, v;\n        num_type w;\n        n = t1;\n        g_temp.resize(n);\n        gkey_temp.resize(n);\n        for (tuple<int, int, num_type> t3 : t2) {\n            tie(u, v, w) = t3;\n            add_edge(u - indexed, v - indexed, w);\n        }\n        for (u = 0; u < n; u++) {\n            for (tuple<int, num_type> t3 : g_temp[u]) {\n                tie(v, w) = t3;\n                gkey_temp[u].push_back(v);\n            }\n        }\n    }\n    void add_edge(int From, int to, num_type& cap) {\n        g_temp[From][to] = cap;\n        g_temp[to][-From - 1] = 0;\n    }\n    // 最大流を計算する、gの中に実際のフローが入っている\n    num_type calc_flow(int s, int t) {\n        flow = 0;\n        vector<map<int, num_type>> g = g_temp;\n        vector<vector<int>> gkey = gkey_temp;\n        while (true) {\n            num_type inf = pow(10, 6);\n            vector<bool> used(n, false);\n            vector<int> used2(n, 0);\n            vector<tuple<int, num_type>> q(1, make_tuple(s, inf));\n            vector<num_type> ans = {0};\n            while (q.size()) {\n                int v;\n                num_type f, a = ans[0];\n                tie(v, f) = q.back();\n                if (!a) {\n                    if (v == t) {\n                        ans[0] = f;\n                        continue;\n                    }\n                    map<int, num_type> gv = g[v];\n                    vector<int> gkv = gkey[v];\n                    int l = (int)gkv.size();\n                    used[v] = true;\n                    while (true) {\n                        int i = used2[v];\n                        used2[v]++;\n                        if (i < l) {\n                            int to = gkv[i];\n                            num_type cap = gv[to];\n                            if (to < 0) { to = -to - 1; }\n                            if ((!used[to]) && cap) {\n                                q.push_back(make_tuple(to, min(f, cap)));\n                                break;\n                            }\n                        } else {\n                            q.pop_back();\n                            ans[0] = 0;\n                            break;\n                        }\n                    }\n                } else {\n                    q.pop_back();\n                    if (q.size()) {\n                        v = get<0>(q.back());\n                        int to = gkey[v][used2[v] - 1];\n                        g[v][to] -= a;\n                        if (to < 0) {\n                            to = -to - 1;\n                        } else {\n                            v = -v - 1;\n                        }\n                        g[to][v] += a;\n                    }\n                }\n            }\n            if (!ans[0]) { return flow; }\n            flow += ans[0];\n        }\n    }\n};\n\n// 最大マッチングを行う、最大フローのライブラリも一緒に持ってくる\n// 入力：xのサイズ、yのサイズ、xy間の辺、indexed\nint bimatch(int x_size, int y_size, vector<tuple<int, int>> xy,\n            int indexed = 1) {\n    int m = (int)xy.size(), n = x_size + y_size + 2;\n    int m2 = x_size + y_size + m, hosei = 2 - indexed;\n    vector<tuple<int, int, int>> edge(m2);\n    for (int i = 0; i < m; i++) {\n        int x, y;\n        tie(x, y) = xy[i];\n        edge[i] = make_tuple(x + hosei, y + hosei + x_size, 1);\n    }\n    for (int i = 0; i < x_size; i++) { edge[m + i] = make_tuple(0, i + 1, 1); }\n    for (int i = 0; i < y_size; i++) {\n        edge[m + x_size + i] = make_tuple(i + x_size + 1, n - 1, 1);\n    }\n    max_flow<int> ret(n, edge, 0);\n    return ret.calc_flow(0, n - 1);\n}\n\nint main() {\n    PRE_COMMAND\n    int x, y, m;\n    INPUT(x, y, m);\n    vector<tuple<int, int>> xy(m);\n    INPUT(xy);\n    PRINT(bimatch(x, y, xy));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\ntypedef pair<ll,ll> pll;\nconst ll mod=1e9+7;\n\ntemplate<typename T,bool directed>\nstruct Fordfulkerson{\n  struct edge{\n    ll to,cap,rev;\n    edge(){}\n    edge(ll to,ll cap,ll rev):to(to),cap(cap),rev(rev){}\n  };\n\n  vector<vector<edge> > G;\n  vector<ll> used;\n\n  Fordfulkerson(){}\n  Fordfulkerson(ll n):G(n),used(n){}\n\n  void add_edge(ll from,ll to,T cap){\n    G[from].emplace_back(to,cap,G[to].size());\n    G[to].emplace_back(from,directed?0:cap,G[from].size()-1);\n  }\n\n  T dfs(ll v,ll t,T f){\n    if(v==t) return f;\n    used[v]=true;\n    for(ll i=0;i<(ll)G[v].size();i++){\n      edge &e = G[v][i];\n      if(!used[e.to]&&e.cap>0){\n        T d=dfs(e.to,t,min(f,e.cap));\n        if(d>0){\n          e.cap-=d;\n          G[e.to][e.rev].cap+=d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  ll flow(ll s,ll t,T lim){\n    T fl=0;\n    while(1){\n      fill(used.begin(),used.end(),0);\n      T f=dfs(s,t,lim);\n      if(f==0) break;\n      fl+=f;\n      lim-=f;\n    }\n    return fl;\n  }\n\n  ll flow(ll s,ll t){\n    return flow(s,t,numeric_limits<T>::max()/2);\n  }\n\n};\n\nint main() {\n  ll x,y,e;\n  cin >> x >> y >> e;\n  Fordfulkerson<ll,true> G(x+y+2);\n  for(ll i=0;i<e;i++) {\n    ll tx,ty;\n    cin >> tx >> ty;\n    G.add_edge(tx,x+ty,1);\n  } \n  for(ll i=0;i<x;i++) {\n    G.add_edge(x+y,i,1);\n  }\n  for(ll i=0;i<y;i++) {\n    G.add_edge(x+i,x+y+1,1);\n  }\n  cout << G.flow(x+y,x+y+1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//AOJ-GRL-7-A\n#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a) for(int i = 0; i < (a); i++)\n#define ALL(a) (a).begin(),(a).end()\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = INT_MAX;\nconst long long LINF = LLONG_MAX;\nconst long long MOD = 1e9 + 7;\n\nstruct BiMatch{\n    int V, time;\n    vector<vector<int>> G;\n    vector<int> match, used;\n    vector<bool> dead;\n\n    BiMatch(int V) : V(V), time(0), G(V), match(V, -1), used(V, -1), dead(V, false){} \n\n    void add_edge(int u, int v){\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n\n    bool dfs(int v){\n        used[v] = time;\n        for(int u : G[v]){\n            if(dead[u]) continue;\n            int w = match[u];\n            if((w < 0) || (used[w] < time && dfs(w))){\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int build(){\n        int res = 0;\n        for(int v = 0; v < V; v++){\n            if(dead[v]) continue;\n            if(match[v] < 0){\n                time++;\n                res += dfs(v);\n            }\n        }\n        return res;\n    }\n};\n\nsigned main(){\n    int X,Y,e;\n    cin >> X >> Y >> e;\n    int V = X + Y;\n    BiMatch bi(V);\n    int x,y;\n    REP(i,e){\n        cin >> x >> y;\n        bi.add_edge(x, X + y);\n    }\n    cout << bi.build() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#define repi(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,a) repi(i,0,a)\n#define clr(a,v) memset((a),(v),sizeof(a))\n\nconst int MAX_X = 100;\n\nint X, Y, E;\nstd::vector<int> G[MAX_X];\nbool used[MAX_X];\nint pr[MAX_X];\nint ans;\n\nbool dfs( int v )\n{\n  if( v < 0 )\n    return true;\n  if( used[v] )\n    return false;\n\n  used[v] = true;\n\n  for( int u : G[v] )\n  {\n    if( dfs( pr[u] ) )\n    {\n      pr[u] = v;\n      return true;\n    }\n  }\n\n  return false;\n}\n\nint main()\n{\n  scanf( \"%d%d%d\", &X, &Y, &E );\n  rep( i, E )\n  {\n    int x, y;\n    scanf( \"%d%d\", &x, &y );\n    G[x].push_back( y );\n  }\n\n  clr( pr, -1 );\n\n  rep( x, X )\n  {\n    clr( used, false );\n    \n    if( dfs(x) )\n      ++ans;\n  }\n\n  printf( \"%d\\n\", ans );\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing ll = long long;\nusing namespace std;\nconstexpr ll inf = 1e9;\nconstexpr ll mod = 1e9+7;\n\nstruct Edge {\n    int to;\n    int cap;\n    int rev;\n};\nvector<Edge> edges[11001];\nbool used[11001] = {false};\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (auto&& edge : edges[v]) {\n        if (used[edge.to] || edge.cap <= 0) continue;\n        int d = dfs(edge.to, t, min(f, edge.cap));\n        if (d > 0) {\n            edge.cap -= d;\n            edges[edge.to][edge.rev].cap += d;\n            return d;\n        }\n    }\n    return 0;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int X, Y, E;\n    cin>>X>>Y>>E;\n    set<int> Xs, Ys;\n    for (int e = 0; e < E; e++) {\n        int x, y;\n        cin>>x>>y;\n        x++; y++;\n        Xs.insert(x);\n        Ys.insert(y);\n        edges[x].push_back(Edge{y, 1, (int)edges[y].size()});\n        edges[y].push_back(Edge{x, 0, (int)edges[x].size()-1});\n    }\n\n    for (int x : Xs) {\n        edges[0].push_back(Edge{x, 1, (int)edges[x].size()});\n        edges[x].push_back(Edge{0, 0, (int)edges[0].size()-1});\n    }\n    for (int y : Ys) {\n        edges[y].push_back(Edge{X+Y+1, 1, (int)edges[X+Y+1].size()});\n        edges[X+Y+1].push_back(Edge{y, 0, (int)edges[y].size()-1});\n    }\n\n    int flow = 0;\n    while (1) {\n        fill(begin(used), end(used), false);\n        int f = dfs(0, X+Y+1, inf);\n        if (f == 0) break;\n        flow += f;\n    }\n    cout<<flow<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n//by NeighThorn\nusing namespace std;\nconst int maxn=100+5,maxm=10000+5;\nint n,m,e,hd[maxn],to[maxm*2],nxt[maxm*2],cnt,pre[maxn],vis[maxn],ans;\ninline void add(int x,int y){\n\tto[cnt]=y;nxt[cnt]=hd[x];hd[x]=cnt++;\n}\ninline bool dfs(int root){\n\tfor(int i=hd[root];i!=-1;i=nxt[i])\n\t\tif(!vis[to[i]]){\n\t\t\tvis[to[i]]=1;\n\t\t\tif(pre[to[i]]==-1||dfs(to[i])){\n\t\t\t\tpre[to[i]]=root;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\nsigned main(void){\n\tcnt=0;ans=0;\n\tmemset(hd,-1,sizeof(hd));\n\tmemset(pre,-1,sizeof(pre));\n\tscanf(\"%d%d%d\",&n,&m,&e);\n\tfor(int i=1,x,y;i<=e;i++)\n\t\tscanf(\"%d%d\",&x,&y),add(x,y+n),add(y+n,x);\n\tfor(int i=1;i<=n;i++)\n\t\tmemset(vis,0,sizeof(vis)),ans+=dfs(i);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <functional>\n#include <map>\n#include <set>\n#include <cmath>\n#include <string>\n#define SIZE 210\n#define INF 10000005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint n;\nint X,Y,E;\nll K;\n\nstruct edge{int to,cap,rev;};\n\nvector<edge> G[SIZE];\nbool used[SIZE];\n\n//グラフ追加: from -> to (cap)\nvoid add_edge(int from, int to, int cap){\n\tG[from].push_back((edge){to,cap,(int)G[to].size()});\n\tG[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\n//パスを一本見つける\nint dfs(int v, int t, int f){\n\tif(v==t)return f;\n\tused[v] = true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(!used[e.to] && e.cap>0){\n\t\t\tint d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){ //v -> G[v][i].toにd流す\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int s,int t){\n\tint flow = 0;\n\tfor(;;){\n\t\tmemset(used,0,sizeof(used));\n\t\tint f = dfs(s,t,INF);\n\t\tif(f==0)return flow;\n\t\tflow += f;\n\t}\n}\n\n\nint main()\n{\n\tscanf(\"%d %d %d\",&X,&Y,&E);\n\tint x,y;\n\tfor(int i=0;i<X;i++)add_edge(200,i,1);\n\tfor(int i=0;i<Y;i++)add_edge(100+i,201,1);\n\tfor(int i=0;i<E;i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tadd_edge(x,100+y,1);\n\t}\n\tint ans = max_flow(200,201);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\n\n\n#include<vector>\n#include<set>\n#include<algorithm>\n#include<queue>\n#include<tuple>\n\nclass BipartiteGraph {\npublic:\n    BipartiteGraph(const int x, const int y) :size_x_(x), size_y_(y), edge_(x + y) {}\n\n    void add_xy(const int vx, const int vy) {edge_[vx].insert(size_x_ + vy);}\n\n    int matching() const {\n        int source = size_x_ + size_y_;\n        int sink = source + 1;\n        std::vector<std::set<int>> edge = edge_;\n        edge.insert(edge.end(), std::set<int>());\n        edge.insert(edge.end(), std::set<int>());\n        for(int vx = 0; vx < size_x_; ++vx) edge[source].insert(vx);\n        for(int vy = 0; vy < size_y_; ++vy) edge[size_x_ + vy].insert(sink);\n\n        int count = 0;\n        while(true) {\n            auto path = EdmondsKarp(edge);\n            if(path.empty()) break;\n            for(int i = 1; i < path.size(); ++i) {\n                edge[path[i - 1]].erase(path[i]);\n                edge[path[i]].insert(path[i - 1]);\n            }\n            ++count;\n        }\n//         while(true) {\n//             std::vector<int> path;\n//             path.push_back(source);\n//             if(!FordFullkerson(edge, path)) break;\n//             for(int i = 1; i < path.size(); ++i) {\n//                 edge[path[i - 1]].erase(path[i]);\n//                 edge[path[i]].insert(path[i - 1]);\n//             }\n//             ++count;\n//             cout<<count<<endl;\n//         }\n        return count;\n    }\n\nprivate:\n    bool FordFullkerson(const std::vector<std::set<int>>& edge, std::vector<int>& path) const {\n//         cout<<path.size()<<endl;\n//         for(auto&v:path)cout<<\" \"<<v;cout<<endl;\n        if(path.back() == size_x_ + size_y_ + 1) return true;\n        for(const auto& to: edge[path.back()]) {\n            if(std::find(path.begin(), path.end(), to) != path.end()) continue;\n            path.push_back(to);\n            if(FordFullkerson(edge, path)) return true;\n            path.pop_back();\n        }\n        return false;\n    }\n    std::vector<int> EdmondsKarp(const std::vector<std::set<int>>& edge) const {\n//         typedef std::tuple<int, std::vector<int>> Node;\n//         std::vector<int> path;\n        std::queue<std::vector<int>> q;\n        q.push({size_x_ + size_y_});\n        while(!q.empty()) {\n            auto path = q.front(); q.pop();\n            if(path.back() == size_x_ + size_y_ + 1) return path;\n            for(const auto& to: edge[path.back()]) {\n                if(std::find(path.begin(), path.end(), to) != path.end()) continue;\n                path.push_back(to);\n                q.push(path);\n                path.pop_back();\n            }\n        }\n\n        return std::vector<int>();\n//         return path;\n    }\n\n    std::vector<std::set<int>> edge_;\n    int size_x_, size_y_;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\n#include<iostream>\nusing namespace std;\n\nint main() {\n    int x, y, e;\n    cin >> x >> y >> e;\n    BipartiteGraph g(x, y);\n    for(int i = 0; i < e; ++i) {\n        int vx, vy;\n        cin >> vx >> vy;\n        g.add_xy(vx, vy);\n    }\n    cout << g.matching() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\nvector<int> list[100000];\nint N, M, E;\nint match[100000];\nbool used[100000];\nint x, y;\n\nbool DFS(int V) {\n\tused[V] = true;\n\tfor (int i = 0; i < list[V].size(); i++) {\n\t\tint u = list[V][i]; int w = match[u];\n\t\tif (w < 0 || !used[w] && DFS(w)) {\n\t\t\tmatch[V] = u;\n\t\t\tmatch[u] = V;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint supermatching() {\n\tint r = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int j = 0; j < N + M; j++) {\n\t\tif (match[j] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (DFS(j)) { r++; }\n\t\t}\n\t}\n\treturn r;\n}\n\nint main() {\n\tcin >> N >> M >> E;\n\tfor (int i = 0; i < E; i++) {\n\t\tcin >> x >> y;\n\t\ty += N;\n\t\tlist[y].push_back(x);\n\t\tlist[x].push_back(y);\n\t}\n\tcout << supermatching() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nclass BipartiteMatching{\nprivate:\n  int n; //????????°\n  vector<vector<int> > graph; //??°??????\n  vector<int> match; //??????????????°?????¢\n  vector<bool> used;\n  bool dfs(int v){\n    used[v]=true;\n    rep(i, graph[v].size()){\n      int u = graph[v][i], w = match[u];\n      if(w<0 || (!used[w] && dfs(w)) ){\n        match[v]=u;\n        match[u]=v;\n        return true;\n      }\n    }\n    return false;\n  }\npublic:\n  BipartiteMatching(int nn) : n(nn){\n    graph.resize(n);\n    match.resize(n);\n    used.resize(n);\n  }\n  void add_edge(int u, int v){ //0-indexed??§??????????????°????????????\n    graph[u].pb(v);\n    graph[v].pb(u);\n  }\n  int matching(){ //??????????????°??°?????????\n    int res=0;\n    fill(all(match), -1);\n    rep(v, n){\n      if(match[v]<0){\n        fill(all(used), false);\n        if(dfs(v)) res++;\n      }\n    }\n    return res;\n  }\n}; //END class BipartiteMatching\n\nint main(){\n  int x,y,e;\n  cin>>x>>y>>e;\n  BipartiteMatching bm(x+y);\n\n  rep(i,e){\n    int a,b;\n    scanf(\"%d %d\", &a, &b);\n    bm.add_edge(a,x+b);\n  }\n\n  cout<<bm.matching()<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nstruct bipartite_matching{\n    int n, x, y;\n    VVI e;\n    VI match;\n    vector<bool> used;\n\n    void init(int a, int b){\n        x = a;\n        y = b;\n        n = x + y;\n        e.resize(n);\n        match.resize(n);\n        used.resize(n);\n    }\n\n    void add_edge(int u, int v){\n        e[u].push_back(v + x);\n        e[v + x].push_back(u);\n    }\n\n    bool dfs(int v){\n        used[v] = true;\n        for (int u : e[v]){\n            int w = match[u];\n            if (w < 0 || (!used[w] && dfs(w))){\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int calc_matching(){\n        int res = 0;\n        fill(ALL(match), -1);\n        REP(v,n){\n            if (match[v] < 0){\n                used.assign(n, 0);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    int n, m, e;\n    cin >> n >> m >> e;\n\n    // cout << 3 << endl;\n    // return 0;\n\n    bipartite_matching bm;\n    bm.init(n, m);\n\n    REP(_,e){\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        bm.add_edge(u, v);\n    }\n\n    cout << bm.calc_matching() << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// 二部マッチング\nstruct BipartiteMatching {\n    vector<int> match;  // マッチングのペア\n    vector<bool> used;  // dfsですでに調べたか\n    bool dfs(const vector<vector<int>>& g, int v) {\n        used[v] = true;\n        for ( int u : g[v] ) {\n            int w = match[u];\n            if ( w < 0 || !used[w] && dfs(g, w) ) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n    // void add_edge(vector<vector<int>>& g, int u, int v) {\n    //     g[u].push_back(v);\n    //     g[v].push_back(u);\n    // }\n    // 二部マッチング　g:二部グラフ（双方向グラフ）\n    // 最大マッチングの辺の数を返す。matchにペアがセットされる。\n    int MaxMatching(const vector<vector<int>>& g) {\n        int vmax = g.size();\n        int res = 0;\n        match.assign(vmax, -1);\n        for ( int v = 0; v < vmax; v++ ) {\n            if ( match[v] < 0 ) {\n                used.assign(vmax, false);\n                if ( dfs(g, v) ) {\n                    res++;\n                }\n            }\n        }\n        return res;\n    }\n};\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_7_A&lang=ja\nint main() {\n    int NX, NY, E, x, y;\n    cin >> NX >> NY >> E;\n    vector<vector<int>> G(NX+NY);\n    for ( int i = 0; i < E; i++ ) {\n        cin >> x >> y;\n        y += NX;\n        G[x].push_back(y);\n        G[y].push_back(x);\n    }\n    BipartiteMatching bm;\n    int ans = bm.MaxMatching(G);\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\n// ------ Variable ------ //\n\n#define MAX_V 100\n\nint V; vector<int> G[MAX_V];\n\nint match[MAX_V];\n\nbool used[MAX_V];\n\n\n// ------ Bipartite_Matching ------ //\n\nbool search(int v)\n{\n\tused[v] = true;\n\n\tfor (int i = 0; i < G[v].size(); i++)\n\t{\n\t\tint u = G[v][i], w = match[u];\n\n\t\tif (w < 0 || !used[w] && search(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint bipartite_matching()\n{\n\tint res = 0;\n\n\tfill(match, match + V, -1);\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (match[i] < 0)\n\t\t{\n\t\t\tfill(used, used + V, 0);\n\n\t\t\tif (search(i))\n\t\t\t{\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint X, Y, E, A, B;\n\n\tcin >> X >> Y >> E; V = X + Y;\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tG[A].push_back(X + B);\n\t\tG[X + B].push_back(A);\n\t}\n\n\tif (E != 0)\n\t{\n\t\tcout << bipartite_matching() << endl;\n\t}\n\telse\n\t{\n\t\tcout << 0 << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nconst int MAX_N=2001;\nint n;\nvector<int> g[MAX_N];\nint match[MAX_N];\nint used[MAX_N];\nvoid add_edge(int src,int dst){\n    g[src].pb(dst);\n    g[dst].pb(src);\n}\nbool dfs(int v){\n    used[v]=true;\n    rep(i,g[v].size()){\n        int u=g[v][i],w=match[u];\n        if(w<0||!used[w]&&dfs(w)){\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int res=0;\n    memset(match,-1,sizeof(match));\n    rep(i,n){\n        if(match[i]<0){\n            memset(used,0,sizeof(used));\n            if(dfs(i)) ++res;\n        }\n    }\n    return res;\n}\nint main(){\n    int x,y,e;\n    cin>>x>>y>>e;\n    n=x+y;\n    int xi,yi;\n    rep(i,e){\n        cin>>xi>>yi;\n        add_edge(xi,x+yi);\n    }\n    cout<<bipartite_matching()<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nstruct edge{\n    int to;\n    int cap;\n    int rev;\n};\nstruct Ford{\n    vector<vector<edge>> G;\n    int V;\n    vector<int> used;\n    Ford(int N){\n        V = N;\n        used.resize(V, 0);\n        G.resize(V);\n    }\n    void add(int u, int v, int c){\n        edge e1 = {v, c, (int)G[v].size()};\n        G[u].push_back(e1);\n        edge e2 = {u, 0, (int)G[u].size() - 1};\n        G[v].push_back(e2);\n    }\n    int dfs(int s, int t, int f){\n        if(s == t) return f;\n        used[s] = 1;\n        for(edge &e: G[s]){\n            if(used[e.to] == 0 && e.cap > 0){\n                long long temp = dfs(e.to, t, min(f, e.cap));\n                if(temp > 0){\n                    e.cap -= temp;\n                    G[e.to][e.rev].cap += temp;\n                    return temp;\n                }\n            }\n        }\n        return 0;\n    }\n    int solve(int s, int t){\n        int ans = 0;\n        int INF = 1e9;\n        while(1){\n            used.assign(V, 0);\n            int res = dfs(s, t, INF);\n            if(res == 0) return ans;\n            ans += res;\n        }\n    }\n};\nint main(){\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    Ford Ford(X + Y + 2);\n    for(int i = 0; i < X; i++) Ford.add(X + Y, i, 1);\n    for(int i = 0; i < Y; i++) Ford.add(X + i, X + Y + 1, 1);\n    for(int i = 0; i < E; i++){\n        int x, y;\n        cin >> x >> y;\n        Ford.add(x, X + y, 1);\n    }\n    int ans = Ford.solve(X + Y, X + Y + 1);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\n#define MAX_V 202\n#define MAX_E 1000\nusing namespace std;\nstruct edge {\n\tint to, cap, rev;\n\tedge(int to_, int cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {};\n};\n\nint V, E;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid AddEdge(int from, int to, int cap) {\n\tG[from].push_back(edge(to, cap, G[to].size()));\n\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid BFS(int s) {\n\tfill(level, level + V, -1);\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint DFS(int v, int t, int f) {\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = DFS(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint Dinic(int s, int t) {\n\tint flow = 0;\n\twhile (true) {\n\t\tBFS(s);\n\t\tif (level[t] < 0) return flow;\n\t\tfill(iter, iter + V, 0);\n\t\tint f;\n\t\twhile ((f = DFS(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint X, Y;\n\tcin >> X >> Y >> E;\n\tV = X + Y + 2;\n\tfor (int i = 0; i < X; i++) {\n\t\tAddEdge(X + Y, i, 1);\n\t}\n\tfor (int i = 0; i < Y; i++) {\n\t\tAddEdge(i, X + Y + 1, 1);\n\t}\n\tfor (int i = 0, x, y; i < E; i++) {\n\t\tcin >> x >> y;\n\t\tAddEdge(x, y, 1);\n\t}\n\tcout << Dinic(X + Y, X + Y + 1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\nusing pll = pair<ll, ll>;\nusing stkll = vector<pll>;\nconst ll INF = 1LL << 60;\nconst ll MOD = 1e9 + 7;\n#define rep(i, n) for (ll i = 0; i < (n); i++)\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n#ifndef ONLINE_JUDGE\n    #define debug(x) cerr << #x << \": \" << x << endl;\n#else\n    #define debug(x)\n#endif\n\n/*  FordFulkerson: Ford-Fulkersonのアルゴリズムで最大流を求める構造体\n\n    verify : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_6_A&lang=ja\n\n    max_flow(G,s,t)：sからtへのグラフGの最大流を求める\n    副作用：G は最大流の残余ネットワークになる\n    計算量: O(|f*||E|) (f*:最大流) (この最悪ケースになることはほぼ無い)\n*/\n\ntemplate <class T>\nstruct Edge {\n    int rev, from, to;  // rev:逆向きの辺の番号\n    T cap, original_cap;\n    Edge(int r, int f, int t, T c) : rev(r), from(f), to(t), cap(c), original_cap(c) {}\n};\ntemplate <class T>\nstruct Graph {\n    vector<vector<Edge<T>>> G;\n    Graph(int n = 0) : G(n) {}\n    vector<Edge<T>>& operator[](int i) { return G[i]; }\n    const size_t size() const { return G.size(); }\n    Edge<T>& redge(Edge<T> e) {  // 逆向きの辺を返す\n        return G[e.to][e.rev];   // 自己ループはないと仮定（あれば G[e.to][e.rev + 1] とする必要がある）\n    }\n    void add_edge(int from, int to, T cap) {  // 有向辺を加える\n        G[from].push_back(Edge<T>((int)G[to].size(), from, to, cap));\n        G[to].push_back(Edge<T>((int)G[from].size() - 1, to, from, 0));\n    }\n};\n/* FordFulkerson: Ford-Fulkersonのアルゴリズムで最大流を求める構造体\n    max_flow(G,s,t)：sからtへのグラフGの最大流を求める\n    副作用：G は最大流の残余ネットワークになる\n    計算量: O(|f*||E|) (f*:最大流) (この最悪ケースになることはほぼ無い)\n*/\ntemplate <class T>\nstruct FordFulkerson {\n    const T INF = 1e9;\n    vector<int> used;\n    FordFulkerson(){};\n    T dfs(Graph<T>& G, int v, int t, T f) {  // 増加可能経路を見つけて増加分のフローを返す\n        if (v == t) return f;\n        used[v] = true;\n        for (auto& e : G[v]) {\n            if (!used[e.to] && e.cap > 0) {\n                T d = dfs(G, e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G.redge(e).cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    T max_flow(Graph<T>& G, int s, int t) {\n        T flow = 0;\n        while (true) {\n            used.assign(G.size(), 0);\n            T f = dfs(G, s, t, INF);  // f が増加分のフロー\n            if (f == 0) {\n                return flow;\n            } else {\n                flow += f;\n            }\n        }\n        return 0;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    ll X, Y, E;\n    cin >> X >> Y >> E;\n    Graph<ll> g(X + Y + 2);\n    rep(i,E) {\n        ll x, y;\n        cin >> x >> y;\n        g.add_edge(x, X+y, 1);\n    }\n    rep(i, X) g.add_edge(X + Y, i, 1);\n    rep(i, Y) g.add_edge(X + i, X+Y+1, 1);\n\n    FordFulkerson<ll> ff;\n    ll ans = ff.max_flow(g, X+Y, X+Y+1);\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<numeric>\n#include<iostream>\n#include<array>\n#include<string>\n#include<sstream>\n#include<stack>\n#include<queue>\n#include<list>\n#include<functional>\n#define _USE_MATH_DEFINES\n\n#include<math.h>\n#include<map>\n\n#define INF 200000000\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\n\n#define VMAX 100\n\nvector<int> G[VMAX + VMAX];\nbool checked[VMAX + VMAX];\nint mate[VMAX + VMAX];\n\nbool augment(int x)\n{\n\tif (checked[x])\n\t{\n\t\treturn false;\n\t}\n\tchecked[x] = true;\n\tfor (auto y : G[x])\n\t{\n\t\tif (mate[y] == -1 || augment(mate[y]))\n\t\t{\n\t\t\tmate[x] = y;\n\t\t\tmate[y] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint max_matching(int X)\n{\n\tint match = 0;\n\tfill(mate, mate + VMAX + VMAX, -1);\n\tfor (int i = 0; i < X; i++)\n\t{\n\t\tfill(checked, checked + VMAX + VMAX, false);\n\t\tif (augment(i))\n\t\t{\n\t\t\tmatch++;\n\t\t}\n\t}\n\treturn match;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint X,Y,E;\n\tcin >> X >> Y >> E;\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\n\t\tG[x].push_back(X + y);\n\t\tG[X + y].push_back(x);\n\t}\n\n\tcout << max_matching(X) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Bipartite{\npublic:\n    vector< vector<int> > graph;\n    vector< int > match, used;\n    int time_stamp;\n\n    Bipartite(int n) : graph(n), match(n, -1), used(n, 0), time_stamp(0) {}\n\n    void add_edge(int u, int v){\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    bool dfs(int node){\n        used[node] = time_stamp;\n        for(auto &to : graph[node]){\n            int to_match = match[to];\n            if( to_match == -1 || (used[to_match] != time_stamp && dfs(to_match)) ){\n                match[node] = to;\n                match[to] = node;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int bipartite_matching() {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(match[i] == -1) {\n        ++time_stamp;\n        ret += dfs(i);\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      if(i < match[i]) {\n        cout << i << \"-\" << match[i] << endl;\n      }\n    }\n  }\n};\n\nint main() {\n  int X, Y, E;\n  scanf(\"%d %d %d\", &X, &Y, &E);\n  Bipartite bm(X + Y);\n  for(int i = 0; i < E; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    bm.add_edge(a, X + b);\n  }\n  printf(\"%d\\n\", bm.bipartite_matching());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct BipartiteMatching {\n    vector<vector<int>> graph;\n    vector<int> match, used;\n    int V;\n\n    BipartiteMatching(int V) : V(V), graph(V), match(V, -1), used(V) {}\n\n    void add_edge(int u, int v) {\n        graph[u].emplace_back(v);\n        graph[v].emplace_back(u);\n    }\n\n    bool dfs(int v) {\n        used[v] = true;\n        for (int i = 0; i < graph[v].size(); i++) {\n            int u = graph[v][i], w = match[u];\n            if (w < 0 || !used[w] && dfs(w)) {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int bipartite_matching() {\n        int res = 0;\n        for (int v = 0; v < V; v++) {\n            if (match[v] < 0) {\n                fill(begin(used), end(used), 0);\n                if (dfs(v)) res++;\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    BipartiteMatching g(X + Y);\n    for (int i = 0; i < E; i++) {\n        int x, y;\n        cin >> x >> y;\n        g.add_edge(x, X + y);\n    }\n    cout << g.bipartite_matching() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nusing Num=double;\nusing Vec=vector<Num>;\nusing Mat=vector<Vec>;\nconst Num Inf=numeric_limits<Num>::infinity();\nconst Num NoSolution=numeric_limits<Num>::quiet_NaN();\nNum EPS=1e-10;\n/*\nmin c*x\ns.t. A*x<=b\n     x>=0\n*/\n\nNum simplex(const Mat &A,const Vec &b,const Vec &c){\n    const int m=A.size(),n=A[0].size();\n\n    Mat D(m+1,Vec(n+m+1));\n    Vec id(m+n);\n    for(int i=0;i<m;i++){\n        for(int j=0;j<n;j++)D[i][j]=A[i][j];\n        D[i][n+i]=1;\n        D[i][n+m]=-b[i];\n    }\n    for(int i=0;i<n;i++)D[m][i]=c[i];\n\n    for(int i=0;i<m;i++)id[i]=n+i;\n    for(int i=0;i<n;i++)id[m+i]=i;\n\n    while(true){\n        int r=n;\n        for(int i=n-1;i>=0;i--)if(D[m][id[m+i]]<-EPS)r=i;\n        if(r==n)return D[m][n+m];\n        int s=m;\n        for(int i=0;i<m;i++)if(D[i][id[m+r]]>EPS){\n            if(s==m||-D[s][n+m]/D[s][id[m+r]]>-D[i][n+m]/D[i][id[m+r]])s=i;\n        }\n        if(s==m)return Inf;//NoBound\n        Num k=D[s][id[m+r]];\n        for(int i=0;i<=n+m;i++)D[s][i]/=k;\n        for(int i=0;i<=m;i++){\n            if(i==s)continue;\n            k=D[i][id[m+r]];\n            for(int j=0;j<=n+m;j++)D[i][j]-=k*D[s][j];\n        }\n        swap(id[s],id[m+r]);\n    }\n}\n\nint X,Y,E;\n\nint x[111][11111],y[111][11111];\n\nsigned main(){\n    cin>>X>>Y>>E;\n    rep(i,E){\n        int a,b;cin>>a>>b;\n        x[a][i]=1;y[b][i]=1;\n    }\n\n    Mat A;Vec b,c(E);\n    rep(i,E)c[i]=-1;\n    for(int i=0;i<X;i++){\n        Vec v(E);rep(j,E)v[j]=x[i][j];\n        A.pb(v);b.pb(1);\n    }\n    for(int i=0;i<Y;i++){\n        Vec v(E);rep(j,E)v[j]=y[i][j];\n        A.pb(v);b.pb(1);\n    }\n    rep(i,E){\n        Vec v(E);v[i]=1;\n        A.pb(v);b.pb(1);\n    }\n\n    Num t=-simplex(A,b,c);\n    int s=round(t);\n    if(abs(t-s)>0.01)assert(0);\n    cout<<s<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n//typedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n//typedef vector<vector<int>> mat;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nvector<int> G[1002];\nbool used[1002];\nint match[1002];\n\nbool dfs(int v)\n{\n\tused[v] = true;\n\trep(i, 0, SZ(G[v]))\n\t{\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(int V)\n{\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\trep(i, 0, V)\n\t{\n\t\tif (match[i] < 0)\n\t\t{\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(i))\n\t\t\t{\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint X, Y,E, x, y;\n\tcin >> X >> Y >> E;\n\trep(i, 0, E)\n\t{\n\t\tcin >> x >> y;\n\t\tG[x].push_back(X + y);\n\t\tG[X + y].push_back(x);\n\t}\n\n\tcout << bipartite_matching(X + Y) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\ntypedef struct{ int to; int rev; int f;} edge;\nint x, y;\nstd::vector<edge> vec[250];\nbool flag[250];\n\nint dfs(int a) {\n  int i;\n  if(a == x + y + 1) return 1;\n  flag[a] = false;\n  for(i = 0; i < vec[a].size(); ++i) if(flag[vec[a][i].to] && vec[a][i].f) {\n    edge *e = &vec[a][i];\n    int d;\n    d = dfs((*e).to);\n    if(d) {\n      (*e).f--;\n      vec[(*e).to][(*e).rev].f++;\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint main(void) {\n  int i, j, k, e, a, b, c, ans = 0;\n  scanf(\"%d%d%d\", &x, &y, &e);\n  for(i = 0; i < x + y + 2; ++i) flag[i] = true;\n  flag[0] = false;\n  bool ff[250];\n  for(i = 0; i < x + y; ++i) ff[i] = true;\n  for(i = 0; i < e; ++i) {\n    scanf(\"%d%d\", &a, &b);\n    b += x;\n    edge ta, tb;\n    ta.to = b, ta.f = 1, ta.rev = vec[b].size();\n    tb.to = a, tb.f = 0, tb.rev = vec[a].size();\n    vec[a].push_back(ta);\n    vec[b].push_back(tb);\n    ta.to = x + y, ta.f = 0, ta.rev = vec[x + y].size();\n    tb.to = a, tb.f = 1, tb.rev = vec[a].size();\n    if(ff[a]) {\n      vec[x + y].push_back(tb);\n      vec[a].push_back(ta);\n    }\n    ta.to = x + y + 1, ta.f = 1, ta.rev = vec[x + y + 1].size();\n    tb.to = b, tb.f = 0, tb.rev = vec[b].size();\n    if(ff[b]) {\n      vec[x + y + 1].push_back(tb);\n      vec[b].push_back(ta);\n    }\n    ff[a] = false, ff[b] = false;\n  }\n  while( 1 ) {\n     for(i = 0; i < x + y + 2; ++i) flag[i] = true;\n     a = dfs(x + y);\n     if(a) ans++;\n     else break;\n  }\n  //for(i = 0; i < x + y + 2; ++i) for(j = 0; j < vec[i].size(); ++j) printf(\"%d:%d %d\\n\", i, vec[i][j].to, vec[i][j].f);\n  printf(\"%d\\n\", ans);\n  return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nll V;\nvector<vector<ll>> G;\nvector<ll> match;\nvector<int> used;\n\nvoid add_edge(ll u, ll v) {\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(ll v) {\n\tused[v] = 1;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tll u = G[v][i], w = match[u];\n\t\tif (w < 0 || ((used[w] == 0) && dfs(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nll bipartite_matching() {\n\tll res = 0;\n\tfor (int i = 0; i < (int)match.size();i++)match[i] = -1;\n\tfor (int v = 0;v < V;v++) {\n\t\tif (match[v] < 0) {\n\t\t\tfor (int i = 0; i < (int)used.size();i++)used[i] = 0;\n\t\t\tif (dfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\n/* use example */\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll X, Y, E; cin >> X >> Y >> E;\n\tV = X + Y + 1; // initialize V [0..index]\n\tG.resize(V); used.resize(V); match.resize(V); // initialize G used match\n\tfor (int i = 0; i < E;i++) {\n\t\tll x, y; cin >> x >> y;\n\t\tadd_edge(x, y + X);\n\t}\n\tcout << bipartite_matching() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <list>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int maxv=100+10;\nint N,M,E;\nvector<int> g[maxv];\nint vis[maxv];\nint match[maxv];\nvoid add_edge(int from,int to)\n{\n    g[from].push_back(to);\n    g[to].push_back(from);\n}\nbool dfs(int t)\n{\n    vis[t]=1;\n    for(int i=0;i<g[t].size();i++)\n    {\n        int v=g[t][i],w=match[v];\n        if(w<0||(!vis[w]&&dfs(w)))\n        {\n            match[t]=v;\n            match[v]=t;\n            return true;\n        }\n    }\n    return false;\n}\nvoid binrary_match()\n{\n    memset(match,-1,sizeof(match));\n    int res=0;\n    for(int i=0;i<N+M;i++)\n    {\n        if(match[i]<0)\n        {\n            memset(vis,0,sizeof(vis));\n            if(dfs(i)) res++;\n        }\n    }\n    printf(\"%d\\n\",res);\n}\nint main()\n{\n//    freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d%d%d\",&N,&M,&E);\n    int u,v;\n    for(int i=0;i<E;i++)\n    {\n        scanf(\"%d%d\",&u,&v);\n        add_edge(u,N+v);\n    }\n    binrary_match();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\ntypedef struct{ int to; int rev; int f;} edge;\nint x, y;\nstd::vector<edge> vec[250];\nbool flag[250];\n\nint dfs(int a) {\n  int i;\n  if(a == x + y + 1) return 1;\n  flag[a] = false;\n  for(i = 0; i < vec[a].size(); ++i) if(flag[vec[a][i].to] && vec[a][i].f) {\n    edge *e = &vec[a][i];\n    int d;\n    d = dfs((*e).to);\n    if(d) {\n      (*e).f--;\n      vec[(*e).to][(*e).rev].f++;\n      return 1;\n    }\n  }\n  return 0;\n}\n\nint main(void) {\n  int i, j, k, e, a, b, c, ans = 0;\n  scanf(\"%d%d%d\", &x, &y, &e);\n  for(i = 0; i < x + y + 2; ++i) flag[i] = true;\n  flag[0] = false;\n  bool ff[250];\n  for(i = 0; i < x + y; ++i) ff[i] = true;\n  for(i = 0; i < e; ++i) {\n    scanf(\"%d%d\", &a, &b);\n    b += x;\n    edge ta, tb;\n    ta.to = b, ta.f = 1, ta.rev = vec[b].size();\n    tb.to = a, tb.f = 0, tb.rev = vec[a].size();\n    vec[a].push_back(ta);\n    vec[b].push_back(tb);\n    ta.to = x + y, ta.f = 0, ta.rev = vec[x + y].size();\n    tb.to = a, tb.f = 1, tb.rev = vec[a].size();\n    if(ff[a]) vec[x + y].push_back(tb);\n    vec[a].push_back(ta);\n    ta.to = x + y + 1, ta.f = 1, ta.rev = vec[x + y + 1].size();\n    tb.to = b, tb.f = 0, tb.rev = vec[b].size();\n    vec[x + y + 1].push_back(tb);\n    vec[b].push_back(ta);\n    ff[a] = false, ff[b] = false;\n  }\n  while( 1 ) {\n     for(i = 0; i < x + y + 2; ++i) flag[i] = true;\n     a = dfs(x + y);\n     if(a) ans++;\n     else break;\n  }\n  //for(i = 0; i < x + y + 2; ++i) for(j = 0; j < vec[i].size(); ++j) printf(\"%d:%d %d\\n\", i, vec[i][j].to, vec[i][j].f);\n  printf(\"%d\\n\", ans);\n  return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i8   = int8_t;\nusing u8   = uint8_t;\nusing i16  = int16_t;\nusing u16  = uint16_t;\nusing i32  = int32_t;\nusing u32  = uint32_t;\nusing i64  = int64_t;\nusing u64  = uint64_t;\n#ifdef __SIZEOF_INT128__\nusing i128 = __int128;\nusing u128 = unsigned __int128;\n#endif\n\nusing f32  = float;\nusing f64  = double;\nusing f80  = __float80;\nusing f128 = __float128;\n// }}}\n\ntemplate<typename T> constexpr T PROCON_INF();\ntemplate<> constexpr i64 PROCON_INF<i64>() { return 1'010'000'000'000'000'000LL; }\ntemplate<> constexpr f64 PROCON_INF<f64>() { return 1e100; }\n\nconstexpr i64 INF  = PROCON_INF<i64>();\nconstexpr f64 FINF = PROCON_INF<f64>();\n\nconstexpr i64 MOD = 1'000'000'007LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// util {{{\n#define FOR(i, start, end) for(i64 i = (start), i##_end=(end); i < i##_end; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n#define SLICE(f,c,l,r,...) (([&](decltype((c)) cccc, decltype((l)) llll, decltype((r)) rrrr) {\\\n    auto iiii = llll <= rrrr ? std::begin(cccc)+llll : std::end(cccc);\\\n    auto jjjj = llll <= rrrr ? std::begin(cccc)+rrrr : std::end(cccc);\\\n    return (f)(iiii, jjjj, ## __VA_ARGS__);\\\n})(c,l,r))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\n// BoolArray {{{\nclass BoolArray {\npublic:\n    using value_type      = bool;\n    using reference       = value_type&;\n    using const_reference = const value_type&;\n    using iterator        = value_type*;\n    using const_iterator  = const value_type*;\n    using difference_type = ptrdiff_t;\n    using size_type       = size_t;\n\n    using reverse_iterator       = std::reverse_iterator<iterator>;\n    using const_reverse_iterator = std::reverse_iterator<const_iterator>;\n\n    BoolArray() : BoolArray(0) {}\n    explicit BoolArray(size_t n) : BoolArray(n,false) {}\n    BoolArray(size_t n, bool value) : size_(n), data_(new bool[n]) {\n        ALL(fill, *this, value);\n    }\n\n    BoolArray(initializer_list<bool> init) : size_(init.size()), data_(new bool[size_]) {\n        ALL(copy, init, begin());\n    }\n\n    template<typename InputIt>\n    BoolArray(InputIt first, InputIt last) {\n        deque<bool> tmp(first, last);\n        size_ = tmp.size();\n        data_ = new bool[size_];\n        ALL(copy, tmp, begin());\n    }\n\n    BoolArray(const BoolArray& other) : size_(other.size_), data_(new bool[size_]) {\n        ALL(copy, other, begin());\n    }\n\n    BoolArray(BoolArray&& other) noexcept : size_(other.size_), data_(other.data_) {\n        other.data_ = nullptr;\n    }\n\n    BoolArray& operator=(const BoolArray& other) {\n        if(this == &other) return *this;\n        if(!data_ || size_ < other.size_) {\n            delete[] data_;\n            data_ = new bool[other.size_];\n        }\n        size_ = other.size_;\n        ALL(copy, other, begin());\n        return *this;\n    }\n\n    BoolArray& operator=(BoolArray&& other) noexcept {\n        if(this == &other) return *this;\n        size_ = other.size_;\n        data_ = other.data_;\n        other.data_ = nullptr;\n    }\n\n    BoolArray& operator=(initializer_list<bool> init) {\n        if(!data_ || size_ < init.size()) {\n            delete[] data_;\n            data_ = new bool[init.size()];\n        }\n        size_ = init.size();\n        ALL(copy, init, begin());\n        return *this;\n    }\n\n    void swap(BoolArray& other) noexcept {\n        std::swap(size_, other.size_);\n        std::swap(data_, other.data_);\n    }\n\n    ~BoolArray() {\n        delete[] data_;\n        data_ = nullptr;\n    }\n\n    bool      empty()    const noexcept { return size_ == 0; }\n    size_type size()     const noexcept { return size_; }\n    size_type max_size() const noexcept { return 1'010'000'000; }\n\n    iterator       begin()        noexcept { return data_; }\n    const_iterator begin()  const noexcept { return data_; }\n    const_iterator cbegin() const noexcept { return data_; }\n\n    iterator       end()        noexcept { return data_+size_; }\n    const_iterator end()  const noexcept { return data_+size_; }\n    const_iterator cend() const noexcept { return data_+size_; }\n\n    reverse_iterator       rbegin()        noexcept { return reverse_iterator(end()); }\n    const_reverse_iterator rbegin()  const noexcept { return const_reverse_iterator(end()); }\n    const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(end()); }\n\n    reverse_iterator       rend()        noexcept { return reverse_iterator(begin()); }\n    const_reverse_iterator rend()  const noexcept { return const_reverse_iterator(begin()); }\n    const_reverse_iterator crend() const noexcept { return const_reverse_iterator(begin()); }\n\n    reference       operator[](size_type pos)       { return data_[pos]; }\n    const_reference operator[](size_type pos) const { return data_[pos]; }\n\n    bool*       data()       noexcept { return data_; }\n    const bool* data() const noexcept { return data_; }\n\nprivate:\n    size_t size_;\n    bool*  data_;\n};\n\nvoid swap(BoolArray& lhs, BoolArray& rhs) noexcept { lhs.swap(rhs); }\n\nbool operator==(const BoolArray& lhs, const BoolArray& rhs) {\n    return equal(begin(lhs), end(lhs), begin(rhs), end(rhs));\n}\nbool operator!=(const BoolArray& lhs, const BoolArray& rhs) { return !(lhs == rhs); }\n\nbool operator<(const BoolArray& lhs, const BoolArray& rhs) {\n    return lexicographical_compare(begin(lhs), end(lhs), begin(rhs), end(rhs));\n}\nbool operator> (const BoolArray& lhs, const BoolArray& rhs) { return rhs < lhs; }\nbool operator<=(const BoolArray& lhs, const BoolArray& rhs) { return !(rhs < lhs); }\nbool operator>=(const BoolArray& lhs, const BoolArray& rhs) { return !(lhs < rhs); }\n// }}}\n\n// 多次元 vector {{{\n// 最内周が vector<bool> になるのを避けるための措置\ntemplate<typename T>\nstruct Array1Container {\n    using type = vector<T>;\n};\ntemplate<>\nstruct Array1Container<bool> {\n    using type = BoolArray;\n};\n\n// イテレート用\ntemplate<typename T>\nstruct is_arrayn_container {\n    static constexpr bool value = false;\n};\ntemplate<typename T>\nstruct is_arrayn_container<vector<T>> {\n    static constexpr bool value = true;\n};\ntemplate<>\nstruct is_arrayn_container<BoolArray> {\n    static constexpr bool value = true;\n};\n\ntemplate<typename T>\nauto arrayn_make(i64 n, T x) {\n    using Cont = typename Array1Container<T>::type;\n    return Cont(n, x);\n}\n\ntemplate<typename T, typename... Args,\n         enable_if_t<2 <= sizeof...(Args), nullptr_t> = nullptr>\nauto arrayn_make(i64 n, Args... args) {\n    auto inner = arrayn_make<T>(args...);\n    return vector<decltype(inner)>(n, inner);\n}\n\ntemplate<typename T, typename F>\nenable_if_t<!is_arrayn_container<T>::value> arrayn_foreach(T& e, F f) {\n    f(e);\n}\n\ntemplate<typename T, typename F>\nenable_if_t<is_arrayn_container<T>::value> arrayn_foreach(T& ary, F f) {\n    for(auto& e : ary)\n        arrayn_foreach(e, f);\n}\n\ntemplate<typename T, typename U>\nenable_if_t<is_arrayn_container<T>::value> arrayn_fill(T& ary, const U& x) {\n    arrayn_foreach(ary, [&x](auto& e) { e = x; });\n}\n// }}}\n\n// 多次元生配列 {{{\ntemplate<typename T, typename F>\nenable_if_t<rank<T>::value==0> CARRAY_FOREACH(T& e, F f) {\n    f(e);\n}\n\ntemplate<typename Array, typename F>\nenable_if_t<rank<Array>::value!=0> CARRAY_FOREACH(Array& ary, F f) {\n    for(auto& e : ary)\n        CARRAY_FOREACH(e, f);\n}\n\ntemplate<typename Array, typename U>\nenable_if_t<rank<Array>::value!=0> CARRAY_FILL(Array& ary, const U& v) {\n    CARRAY_FOREACH(ary, [&v](auto& e) { e = v; });\n}\n// }}}\n\n// メモ化ラッパー (8引数まで) {{{\ntemplate<i64 N1, typename F>\nclass Memoized1 {\n    static_assert(N1 >= 1, \"\");\npublic:\n    explicit Memoized1(F&& f) : f_(forward<F>(f)) {}\n    decltype(auto) operator()(i64 x1) const {\n        using R = decltype(f_(*this,x1));\n        static bool done[N1] {};\n        static R    memo[N1];\n        if(!done[x1]) {\n            memo[x1] = f_(*this,x1);\n            done[x1] = true;\n        }\n        return memo[x1];\n    }\nprivate:\n    const F f_;\n};\n\ntemplate<i64 N1, i64 N2, typename F>\nclass Memoized2 {\n    static_assert(N1 >= 1 && N2 >= 1, \"\");\npublic:\n    explicit Memoized2(F&& f) : f_(forward<F>(f)) {}\n    decltype(auto) operator()(i64 x1, i64 x2) const {\n        using R = decltype(f_(*this,x1,x2));\n        static bool done[N1][N2] {};\n        static R    memo[N1][N2];\n        if(!done[x1][x2]) {\n            memo[x1][x2] = f_(*this,x1,x2);\n            done[x1][x2] = true;\n        }\n        return memo[x1][x2];\n    }\nprivate:\n    const F f_;\n};\n\ntemplate<i64 N1, i64 N2, i64 N3, typename F>\nclass Memoized3 {\n    static_assert(N1 >= 1 && N2 >= 1 && N3 >= 1, \"\");\npublic:\n    explicit Memoized3(F&& f) : f_(forward<F>(f)) {}\n    decltype(auto) operator()(i64 x1, i64 x2, i64 x3) const {\n        using R = decltype(f_(*this,x1,x2,x3));\n        static bool done[N1][N2][N3] {};\n        static R    memo[N1][N2][N3];\n        if(!done[x1][x2][x3]) {\n            memo[x1][x2][x3] = f_(*this,x1,x2,x3);\n            done[x1][x2][x3] = true;\n        }\n        return memo[x1][x2][x3];\n    }\nprivate:\n    const F f_;\n};\n\ntemplate<i64 N1, i64 N2, i64 N3, i64 N4, typename F>\nclass Memoized4 {\n    static_assert(N1 >= 1 && N2 >= 1 && N3 >= 1 && N4 >= 1, \"\");\npublic:\n    explicit Memoized4(F&& f) : f_(forward<F>(f)) {}\n    decltype(auto) operator()(i64 x1, i64 x2, i64 x3, i64 x4) const {\n        using R = decltype(f_(*this,x1,x2,x3,x4));\n        static bool done[N1][N2][N3][N4] {};\n        static R    memo[N1][N2][N3][N4];\n        if(!done[x1][x2][x3][x4]) {\n            memo[x1][x2][x3][x4] = f_(*this,x1,x2,x3,x4);\n            done[x1][x2][x3][x4] = true;\n        }\n        return memo[x1][x2][x3][x4];\n    }\nprivate:\n    const F f_;\n};\n\ntemplate<i64 N1, i64 N2, i64 N3, i64 N4, i64 N5, typename F>\nclass Memoized5 {\n    static_assert(N1 >= 1 && N2 >= 1 && N3 >= 1 && N4 >= 1 && N5 >= 1, \"\");\npublic:\n    explicit Memoized5(F&& f) : f_(forward<F>(f)) {}\n    decltype(auto) operator()(i64 x1, i64 x2, i64 x3, i64 x4, i64 x5) const {\n        using R = decltype(f_(*this,x1,x2,x3,x4,x5));\n        static bool done[N1][N2][N3][N4][N5] {};\n        static R    memo[N1][N2][N3][N4][N5];\n        if(!done[x1][x2][x3][x4][x5]) {\n            memo[x1][x2][x3][x4][x5] = f_(*this,x1,x2,x3,x4,x5);\n            done[x1][x2][x3][x4][x5] = true;\n        }\n        return memo[x1][x2][x3][x4][x5];\n    }\nprivate:\n    const F f_;\n};\n\ntemplate<i64 N1, i64 N2, i64 N3, i64 N4, i64 N5, i64 N6, typename F>\nclass Memoized6 {\n    static_assert(N1 >= 1 && N2 >= 1 && N3 >= 1 && N4 >= 1 && N5 >= 1 && N6 >= 1, \"\");\npublic:\n    explicit Memoized6(F&& f) : f_(forward<F>(f)) {}\n    decltype(auto) operator()(i64 x1, i64 x2, i64 x3, i64 x4, i64 x5, i64 x6) const {\n        using R = decltype(f_(*this,x1,x2,x3,x4,x5,x6));\n        static bool done[N1][N2][N3][N4][N5][N6] {};\n        static R    memo[N1][N2][N3][N4][N5][N6];\n        if(!done[x1][x2][x3][x4][x5][x6]) {\n            memo[x1][x2][x3][x4][x5][x6] = f_(*this,x1,x2,x3,x4,x5,x6);\n            done[x1][x2][x3][x4][x5][x6] = true;\n        }\n        return memo[x1][x2][x3][x4][x5][x6];\n    }\nprivate:\n    const F f_;\n};\n\ntemplate<i64 N1, i64 N2, i64 N3, i64 N4, i64 N5, i64 N6, i64 N7, typename F>\nclass Memoized7 {\n    static_assert(N1 >= 1 && N2 >= 1 && N3 >= 1 && N4 >= 1 && N5 >= 1 && N6 >= 1 && N7 >= 1, \"\");\npublic:\n    explicit Memoized7(F&& f) : f_(forward<F>(f)) {}\n    decltype(auto) operator()(i64 x1, i64 x2, i64 x3, i64 x4, i64 x5, i64 x6, i64 x7) const {\n        using R = decltype(f_(*this,x1,x2,x3,x4,x5,x6,x7));\n        static bool done[N1][N2][N3][N4][N5][N6][N7] {};\n        static R    memo[N1][N2][N3][N4][N5][N6][N7];\n        if(!done[x1][x2][x3][x4][x5][x6][x7]) {\n            memo[x1][x2][x3][x4][x5][x6][x7] = f_(*this,x1,x2,x3,x4,x5,x6,x7);\n            done[x1][x2][x3][x4][x5][x6][x7] = true;\n        }\n        return memo[x1][x2][x3][x4][x5][x6][x7];\n    }\nprivate:\n    const F f_;\n};\n\ntemplate<i64 N1, i64 N2, i64 N3, i64 N4, i64 N5, i64 N6, i64 N7, i64 N8, typename F>\nclass Memoized8 {\n    static_assert(N1 >= 1 && N2 >= 1 && N3 >= 1 && N4 >= 1 && N5 >= 1 && N6 >= 1 && N7 >= 1 && N8 >= 1, \"\");\npublic:\n    explicit Memoized8(F&& f) : f_(forward<F>(f)) {}\n    decltype(auto) operator()(i64 x1, i64 x2, i64 x3, i64 x4, i64 x5, i64 x6, i64 x7, i64 x8) const {\n        using R = decltype(f_(*this,x1,x2,x3,x4,x5,x6,x7,x8));\n        static bool done[N1][N2][N3][N4][N5][N6][N7][N8] {};\n        static R    memo[N1][N2][N3][N4][N5][N6][N7][N8];\n        if(!done[x1][x2][x3][x4][x5][x6][x7][x8]) {\n            memo[x1][x2][x3][x4][x5][x6][x7][x8] = f_(*this,x1,x2,x3,x4,x5,x6,x7,x8);\n            done[x1][x2][x3][x4][x5][x6][x7][x8] = true;\n        }\n        return memo[x1][x2][x3][x4][x5][x6][x7][x8];\n    }\nprivate:\n    const F f_;\n};\n\ntemplate<i64 N1, typename F>\ndecltype(auto) MEMOIZE(F&& f) {\n    return Memoized1<N1,F>(forward<F>(f));\n}\ntemplate<i64 N1, i64 N2, typename F>\ndecltype(auto) MEMOIZE(F&& f) {\n    return Memoized2<N1,N2,F>(forward<F>(f));\n}\ntemplate<i64 N1, i64 N2, i64 N3, typename F>\ndecltype(auto) MEMOIZE(F&& f) {\n    return Memoized3<N1,N2,N3,F>(forward<F>(f));\n}\ntemplate<i64 N1, i64 N2, i64 N3, i64 N4, typename F>\ndecltype(auto) MEMOIZE(F&& f) {\n    return Memoized4<N1,N2,N3,N4,F>(forward<F>(f));\n}\ntemplate<i64 N1, i64 N2, i64 N3, i64 N4, i64 N5, typename F>\ndecltype(auto) MEMOIZE(F&& f) {\n    return Memoized5<N1,N2,N3,N4,N5,F>(forward<F>(f));\n}\ntemplate<i64 N1, i64 N2, i64 N3, i64 N4, i64 N5, i64 N6, typename F>\ndecltype(auto) MEMOIZE(F&& f) {\n    return Memoized6<N1,N2,N3,N4,N5,N6,F>(forward<F>(f));\n}\ntemplate<i64 N1, i64 N2, i64 N3, i64 N4, i64 N5, i64 N6, i64 N7, typename F>\ndecltype(auto) MEMOIZE(F&& f) {\n    return Memoized7<N1,N2,N3,N4,N5,N6,N7,F>(forward<F>(f));\n}\ntemplate<i64 N1, i64 N2, i64 N3, i64 N4, i64 N5, i64 N6, i64 N7, i64 N8, typename F>\ndecltype(auto) MEMOIZE(F&& f) {\n    return Memoized8<N1,N2,N3,N4,N5,N6,N7,N8,F>(forward<F>(f));\n}\n\n// }}}\n\n// lambda で再帰 {{{\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    const F f_;\n};\n\ntemplate<typename F>\ndecltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n// }}}\n\n// tuple {{{\ntemplate<typename... TS,\n         enable_if_t<0 < sizeof...(TS), nullptr_t> = nullptr>\nconstexpr auto tuple_head(const tuple<TS...>& t) {\n    return get<0>(t);\n}\n\ntemplate<typename... TS, size_t i, size_t... is>\nconstexpr auto tuple_tail_helper(const tuple<TS...>& t, index_sequence<i,is...>) {\n    return make_tuple(get<is>(t)...);\n}\n\ntemplate<typename... TS,\n         enable_if_t<1 == sizeof...(TS), nullptr_t> = nullptr>\nconstexpr auto tuple_tail(const tuple<TS...>&) {\n    return make_tuple();\n}\n\ntemplate<typename... TS,\n         enable_if_t<1 < sizeof...(TS), nullptr_t> = nullptr>\nconstexpr auto tuple_tail(const tuple<TS...>& t) {\n    return tuple_tail_helper(t, make_index_sequence<sizeof...(TS)>());\n}\n// }}}\n\ntemplate<typename C>\ni64 SIZE(const C& c) { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\nbool is_odd (i64 x) { return x % 2 != 0; }\nbool is_even(i64 x) { return x % 2 == 0; }\n\ntemplate<typename T> i64 cmp(T x, T y) { return (y<x) - (x<y); }\ntemplate<typename T> i64 sgn(T x) { return cmp(x, T(0)); }\n\ni64 ipow(i64 x, i64 e) {\n    assert(e >= 0);\n    i64 res = 1;\n    REP(_, e) {\n        res *= x;\n    }\n    return res;\n}\n\n// 0 <= ilog2(x) <= 62\ni64 ilog2(i64 x) {\n    assert(x > 0);\n    return 63 - __builtin_clzll(x);\n}\n\n// 0 <= ilog10(x) <= 18\ni64 ilog10(i64 x) {\n    assert(x > 0);\n    static constexpr i64 TABLE[18] {\n        9LL,\n        99LL,\n        999LL,\n        9999LL,\n        99999LL,\n        999999LL,\n        9999999LL,\n        99999999LL,\n        999999999LL,\n        9999999999LL,\n        99999999999LL,\n        999999999999LL,\n        9999999999999LL,\n        99999999999999LL,\n        999999999999999LL,\n        9999999999999999LL,\n        99999999999999999LL,\n        999999999999999999LL,\n    };\n    REP(i, SIZE(TABLE)) {\n        if(x <= TABLE[i]) return i;\n    }\n    return SIZE(TABLE);\n}\n\n// Haskell の divMod と同じ\npair<i64,i64> divmod(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r<0) || (b<0 && r>0)) {\n        --q;\n        r += b;\n    }\n    return {q,r};\n}\n\ni64 div_ceil(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r>0) || (b<0 && r<0))\n        ++q;\n    return q;\n}\n\ni64 div_floor(i64 a, i64 b) {\n    return divmod(a,b).first;\n}\n\ni64 modulo(i64 a, i64 b) {\n    return divmod(a,b).second;\n}\n\nbool feq(f64 x, f64 y, f64 eps=EPS) {\n    return fabs(x-y) < eps;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename ForwardIt, typename T, typename Comp=less<>>\nForwardIt bsearch_find(ForwardIt first, ForwardIt last, const T& x, Comp comp={}) {\n    auto it = lower_bound(first, last, x, comp);\n    if(it == last || comp(x,*it)) return last;\n    return it;\n}\n\n// x 未満の最後の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_lt(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    auto it = lower_bound(first, last, x, comp);\n    if(it == first) return last;\n    return prev(it);\n}\n\n// x 以下の最後の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_le(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    auto it = upper_bound(first, last, x, comp);\n    if(it == first) return last;\n    return prev(it);\n}\n\n// x より大きい最初の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_gt(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    return upper_bound(first, last, x, comp);\n}\n\n// x 以上の最初の要素\ntemplate<typename BidiIt, typename T, typename Comp=less<>>\nBidiIt bsearch_ge(BidiIt first, BidiIt last, const T& x, Comp comp={}) {\n    return lower_bound(first, last, x, comp);\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename ForwardIt, typename UnaryOperation>\nForwardIt transform_self(ForwardIt first, ForwardIt last, UnaryOperation op) {\n    return transform(first, last, first, op);\n}\n\ntemplate<typename C>\nvoid UNIQ(C& c) {\n    c.erase(ALL(unique,c), end(c));\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc bf, UnaryFunc uf) {\n    return [bf,uf](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F f) { return ON(less<>(), f); }\n\ntemplate<typename F>\nauto GT_ON(F f) { return ON(greater<>(), f); }\n\nstruct IDENTITY {\n    template<typename T>\n    constexpr T&& operator()(T&& x) const noexcept {\n        return forward<T>(x);\n    }\n};\n\nchar digit_chr(i64 n) {\n    return static_cast<char>('0' + n);\n}\n\ni64 digit_ord(char c) {\n    return c - '0';\n}\n\nchar lower_chr(i64 n) {\n    return static_cast<char>('a' + n);\n}\n\ni64 lower_ord(char c) {\n    return c - 'a';\n}\n\nchar upper_chr(i64 n) {\n    return static_cast<char>('A' + n);\n}\n\ni64 upper_ord(char c) {\n    return c - 'A';\n}\n\n// 出力は operator<< を直接使わず、このテンプレート経由で行う\n// 提出用出力とデバッグ用出力を分けるため\ntemplate<typename T>\nstruct Formatter {\n    static ostream& write_str(ostream& out, const T& x)  { return out << x; }\n    static ostream& write_repr(ostream& out, const T& x) { return out << x; }\n};\n\ntemplate<typename T>\nostream& WRITE_STR(ostream& out, const T& x) {\n    return Formatter<T>::write_str(out, x);\n}\n\ntemplate<typename T>\nostream& WRITE_REPR(ostream& out, const T& x) {\n    return Formatter<T>::write_repr(out, x);\n}\n\ntemplate<typename InputIt>\nostream& WRITE_JOIN_STR(ostream& out, InputIt first, InputIt last, const string& sep) {\n    while(first != last) {\n        WRITE_STR(out, *first++);\n        if(first != last)\n            out << sep;\n    }\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& WRITE_JOIN_REPR(ostream& out, InputIt first, InputIt last, const string& sep) {\n    while(first != last) {\n        WRITE_REPR(out, *first++);\n        if(first != last)\n            out << sep;\n    }\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& WRITE_RANGE_STR(ostream& out, InputIt first, InputIt last) {\n    return WRITE_JOIN_STR(out, first, last, \" \");\n}\n\ntemplate<typename InputIt>\nostream& WRITE_RANGE_REPR(ostream& out, InputIt first, InputIt last) {\n    out << \"[\";\n    WRITE_JOIN_REPR(out, first, last, \", \");\n    out << \"]\";\n    return out;\n}\n\ntemplate<typename T>\nvoid FROM_STR(const string& s, T& x) {\n    istringstream in(s);\n    in >> x;\n}\n\ntemplate<typename T>\nstring TO_STR(const T& x) {\n    ostringstream out;\n    WRITE_STR(out, x);\n    return out.str();\n}\n\ntemplate<typename T>\nstring TO_REPR(const T& x) {\n    ostringstream out;\n    WRITE_REPR(out, x);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring RANGE_TO_STR(InputIt first, InputIt last) {\n    ostringstream out;\n    WRITE_RANGE_STR(out, first, last);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring RANGE_TO_REPR(InputIt first, InputIt last) {\n    ostringstream out;\n    WRITE_RANGE_REPR(out, first, last);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    WRITE_JOIN_STR(out, first, last, sep);\n    return out.str();\n}\n\ntemplate<>\nstruct Formatter<i64> {\n    static ostream& write_str(ostream& out, i64 x) {\n        return out << x;\n    }\n    static ostream& write_repr(ostream& out, i64 x) {\n        if(x == INF) return out << \"INF\";\n        if(x == -INF) return out << \"-INF\";\n        return out << x;\n    }\n};\n\ntemplate<>\nstruct Formatter<f64> {\n    static ostream& write_str(ostream& out, f64 x) {\n        return out << x;\n    }\n    static ostream& write_repr(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF) return out << \"FINF\";\n        if(x == -FINF) return out << \"-FINF\";\n#pragma GCC diagnostic pop\n        return out << x;\n    }\n};\n\ntemplate<typename T>\nstruct Formatter<vector<T>> {\n    static ostream& write_str(ostream& out, const vector<T>& v) {\n        return WRITE_RANGE_STR(out, begin(v), end(v));\n    }\n    static ostream& write_repr(ostream& out, const vector<T>& v) {\n        out << \"vector\";\n        return WRITE_RANGE_REPR(out, begin(v), end(v));\n    }\n};\n\ntemplate<>\nstruct Formatter<BoolArray> {\n    static ostream& write_str(ostream& out, const BoolArray& a) {\n        return WRITE_RANGE_STR(out, begin(a), end(a));\n    }\n    static ostream& write_repr(ostream& out, const BoolArray& a) {\n        out << \"BoolArray\";\n        return WRITE_RANGE_REPR(out, begin(a), end(a));\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Formatter<pair<T1,T2>> {\n    static ostream& write_str(ostream& out, const pair<T1,T2>& p) {\n        WRITE_STR(out, p.first);\n        out << ' ';\n        WRITE_STR(out, p.second);\n        return out;\n    }\n    static ostream& write_repr(ostream& out, const pair<T1,T2>& p) {\n        out << \"(\";\n        WRITE_REPR(out, p.first);\n        out << \",\";\n        WRITE_REPR(out, p.second);\n        out << \")\";\n        return out;\n    }\n};\n\ntemplate<typename... TS>\nstruct Formatter<tuple<TS...>> {\n    template<size_t I=0, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\n    static ostream& write_str_impl(ostream& out, const tuple<TS...>&) {\n        return out;\n    }\n    template<size_t I=0, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\n    static ostream& write_str_impl(ostream& out, const tuple<TS...>& t) {\n        if(I != 0) out << ' ';\n        WRITE_STR(out, get<I>(t));\n        return write_str_impl<I+1>(out, t);\n    }\n\n    template<size_t I=0, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\n    static ostream& write_repr_impl(ostream& out, const tuple<TS...>&) {\n        if(sizeof...(TS) == 0) out << \"(\";\n        return out << \")\";\n    }\n    template<size_t I=0, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\n    static ostream& write_repr_impl(ostream& out, const tuple<TS...>& t) {\n        if(I == 0)\n            out << \"(\";\n        else\n            out << \",\";\n        WRITE_REPR(out, get<I>(t));\n        return write_repr_impl<I+1>(out, t);\n    }\n\n    static ostream& write_str(ostream& out, const tuple<TS...>& t) {\n        return write_str_impl(out, t);\n    }\n    static ostream& write_repr(ostream& out, const tuple<TS...>& t) {\n        return write_repr_impl(out, t);\n    }\n};\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef PROCON_LOCAL\n    assert(cin);\n#endif\n}\n\ntemplate<typename T>\nauto RD_ARRAY(i64 n) {\n    auto res = arrayn_make<T>(n, T());\n    arrayn_foreach(res, [](T& e) { RD(e); });\n    return res;\n}\n\ntemplate<typename T>\nauto RD_ARRAY2(i64 h, i64 w) {\n    auto res = arrayn_make<T>(h,w, T());\n    arrayn_foreach(res, [](T& e) { RD(e); });\n    return res;\n}\n\ntemplate<typename T1, typename T2>\npair<T1,T2> RD_PAIR() {\n    T1 x; RD(x);\n    T2 y; RD(y);\n    return { x, y };\n}\n\ntemplate<typename... TS,\n         enable_if_t<0 == sizeof...(TS), nullptr_t> = nullptr>\nauto RD_TUPLE() {\n    return make_tuple();\n}\n\ntemplate<typename T, typename... TS>\nauto RD_TUPLE() {\n    T x; RD(x);\n    return tuple_cat(make_tuple(x), RD_TUPLE<TS...>());\n}\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS& ...args) {\n    WRITE_STR(cout, x);\n    if(sizeof...(args)) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS& ...args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n\n[[noreturn]] void EXIT() {\n#ifdef PROCON_LOCAL\n    cerr.flush();\n#endif\n    cout.flush();\n    _Exit(0);\n}\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    WRITE_REPR(cerr, value);\n    cerr << \"\\n\";\n#endif\n}\n\ntemplate<typename T, size_t N>\nvoid DBG_CARRAY_IMPL(i64 line, const char* expr, const T (&ary)[N]) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    WRITE_RANGE_REPR(cerr, begin(ary), end(ary));\n    cerr << \"\\n\";\n#endif\n}\n\ntemplate<typename InputIt>\nvoid DBG_RANGE_IMPL(i64 line, const char* expr1, const char* expr2, InputIt first, InputIt last) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr1 << \",\" << expr2 << \" = \";\n    WRITE_RANGE_REPR(cerr, first, last);\n    cerr << \"\\n\";\n#endif\n}\n\n#define DBG(expr) DBG_IMPL(__LINE__, #expr, (expr))\n#define DBG_CARRAY(expr) DBG_CARRAY_IMPL(__LINE__, #expr, (expr))\n#define DBG_RANGE(first,last) DBG_RANGE_IMPL(__LINE__, #first, #last, (first), (last))\n\n#define PAIR  make_pair\n#define TUPLE make_tuple\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n//--------------------------------------------------------------------\n\n// 2部グラフの最大マッチング\n//\n// g は隣接リスト表現\n// (k,match) を返す\n// k: 最大マッチングのペア数\n// match: 各頂点とペアになる頂点\ntuple<i64,vector<i64>> bipartite_matching(const vector<vector<i64>>& g) {\n    i64 n = SIZE(g);\n    vector<i64> match(n, -1);\n\n    BoolArray visited(n);\n    auto dfs = FIX([&g,&match,&visited](auto self, i64 v) -> bool {\n        visited[v] = true;\n        for(i64 to : g[v]) {\n            i64 w = match[to];\n            if(w == -1 || (!visited[w] && self(w))) {\n                match[v]  = to;\n                match[to] = v;\n                return true;\n            }\n        }\n        return false;\n    });\n\n    i64 k = 0;\n    REP(v, n) {\n        if(match[v] != -1) continue;\n        ALL(fill, visited, false);\n        if(dfs(v))\n            ++k;\n    }\n\n    return make_tuple(k, match);\n}\n\nvoid solve() {\n    i64 X; RD(X);\n    i64 Y; RD(Y);\n    i64 M; RD(M);\n\n    vector<vector<i64>> G(X+Y);\n    REP(_, M) {\n        i64 x,y; RD(x); RD(y); y += X;  // 番号を振り直す\n        G[x].emplace_back(y);\n        G[y].emplace_back(x);\n    }\n\n    i64 k;\n    vector<i64> match;\n    tie(k,match) = bipartite_matching(G);\n    DBG(match);\n\n    // * 小さいケースで試した?\n    // * 無効値 INF をそのまま出力してない?\n    // * MOD はとった?\n    // * 入出力の 0-based/1-based 確認した?\n    // * 時間/メモリ制限は確認した?\n    // * 違うやつ提出してない?\n    // * 違うやつテストしてない?\n    PRINTLN(k);\n}\n\nsigned main() {\n    \n\n    solve();\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,bg,ed) for(ll i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n//#define int long long\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1e9;\n\nconst int MAX_V = 500;  //??????????????????????????????\nstruct edge { int to, cap, rev; };\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\n//from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from, int to, int cap)\n{\n    G[from].push_back((edge){to, cap, G[to].size()});\n    G[to].push_back((edge){from, 0, G[from].size() - 1});\n}\n\n//?¢?????????????DFS??§??¢???\nint dfs(int v, int t, int f)\n{\n    if (v == t) return f;\n    used[v] = true;\n    for (int i=0; i<G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n//s??????t???????????§???????±???????\nint max_flow(int s, int t)\n{\n    int flow = 0;\n    for (;;) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nsigned main()\n{\n    int X, Y, E;\n    int x, y;\n\n    cin >> X >> Y >> E;\n    REP(i,X) add_edge(300, i, 1);\n    REP(i,Y) add_edge(100 + i, 301, 1);\n    REP(i,E) {\n        cin >> x >> y;\n        add_edge(x, 100 + y, 1);\n    }\n\n    cout << max_flow(300, 301) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <string>\n#include <cmath>\n#include <map>\n#include <cstring>\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i, init, n) for(int i = init; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define Cout(obj) cout << obj << endl\n#define Size(obj) (int)(obj).size()\n#define fcout cout << fixed << setprecision(10)\n#define fi first\n#define se second\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cap, rev;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nconst int MaxV = 10000;\n\nvector<edge> graph[MaxV];\nbool used[MaxV];\n\nvoid addEdge(int from, int to, int cap)\n{\n    graph[from].push_back({to, cap, Size(graph[to])});\n    graph[to].push_back({from, 0, Size(graph[from]) - 1});\n}\n\nint dfs(int v, int t, int f)\n{\n    if(v == t) return f;\n    used[v] = true;\n\n    for(auto &e : graph[v])\n    {\n        if(!used[e.to] && e.cap > 0)\n        {\n            int d = dfs(e.to, t, min(f, e.cap));\n\n            if(d > 0)\n            {\n                e.cap -= d;\n                graph[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n\n    return 0;\n}\n\nint maxFlow(int s, int t)\n{\n    int flow = 0;\n    for(;;)\n    {\n        memset(used, false, sizeof(used));\n\n        int f = dfs(s, t, iINF);\n\n        if(f == 0) return flow;\n\n        flow += f;\n    }\n}\n\nint X, Y, E;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n\n    int S = X + Y, T = S + 1;\n\n    REP(i, X)\n    {\n        addEdge(S, i, 1);\n    }    \n\n    REP(i, Y)\n    {\n        addEdge(X + i, T, 1);\n    }\n\n    REP(i, E)\n    {\n        int x, y;\n        cin >> x >> y;\n        addEdge(x, y + X, 1);\n    }\n\n    Cout(maxFlow(S, T));\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n// Description: ??°??????????????????(?????????????°??????¨???)\n// Verifyed: Many Diffrent Problem \n\n//Appropriately Changed\nusing edge=struct{int to;};\nusing G=vector<vector<edge>>;\n\n//Appropriately Changed\nvoid add_edge(G &graph,int from,int to){ \n\tgraph[from].push_back({to});\n}\n\n// Description: 2??¨??°???????????????????????§??????????????°\n// TimeComplexity: $ \\mathcal{O}(EV) $ \n// Verifyed: AOJ GRL_7_A\n\nint bipartite_matching(const G &graph){\n\tint res=0,n=graph.size();\n\tvector<int> match(n,-1),used(n,0);\n\n\tauto dfs=[&](int v){\n        auto func=[&](int v,auto func)->int{\n        \tused[v]=true;\n\t\t\tfor(auto &e:graph[v]){\n\t\t\t\tconst int u=e.to,w=match[u];\n\t\t\t\tif(w<0||(!used[w] && func(w,func))){\n\t\t\t\t\tmatch[v]=u,match[u]=v;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n        };\n        return func(v,func);\n    };\n\n\trep(v,n){\n\t\tif(match[v]>=0) continue;\n\t\tfill(_all(used),false);\n\t\tif(dfs(v)) res++;\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint x,y,e;\n\tcin >> x >> y >> e;\n\tG graph(x+y);\n\trep(i,e){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tadd_edge(graph,a,x+b);\n\t}\n\n\tcout << bipartite_matching(graph) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl;\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define repi(start,end) for(int i=start; i<end; i++)\n#define repj(start,end) for(int j=start; j<end; j++)\n#define repk(start,end) for(int k=start; k<end; k++)\n#define repl(start,end) for(int l=start; l<end; l++)\n#define RE return 0;\n\nstruct edge{int to,cap,rev;};\n\nint n,k;\nbool can[1000][1000];\nint used[2000000];\n\nvector<edge> G[2000000];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  //cout<<\"  v = \"<<v<<en\n  if(v==t) return f;\n  used[v]=true;\n  repi(0, G[v].size()){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int i=0;\n  int flow=0;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    //cout<<\"         \"<<i++<<en\n    int f=dfs(s, t, INF);\n    if(f==0) return flow;\n    flow+=f;\n  }\n}\n\nvoid solve(){\n  int s=n+k,t=s+1;\n  \n  repi(0, n){\n    add_edge(s,i,1);\n  }\n  repi(0, k){\n    add_edge(n+i, t, 1);\n  }\n  \n  repi(0, n){\n    repj(0, k){\n      if(can[i][j]){\n        add_edge(i, n+j, 1);\n      }\n    }\n  }\n  \n  cout<<max_flow(s, t)<<en\n}\n\n\n\n\n\n\nint main(){\n  \n  repi(0, 1000){\n    repj(0, 1000){\n      can[i][j]=false;\n    }\n  }\n  \n  int e,a,b;\n  cin>>n>>k>>e;\n  repi(0, e){\n    cin>>a>>b;\n    can[a][b]=true;\n  }\n  \n  solve();\n  RE\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nll V;\nvector<vector<ll>> G;\nvector<ll> match;\nvector<int> used;\n\nvoid add_edge(ll u, ll v) {\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(ll v) {\n\tused[v] = 1;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tll u = G[v][i], w = match[u];\n\t\tif (w < 0 || ((used[w] == 0) && dfs(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nll bipartite_matching() {\n\tll res = 0;\n\tfor (int i = 0; i < (int)match.size();i++)match[i] = -1;\n\tfor (int v = 0;v < V;v++) {\n\t\tif (match[v] < 0) {\n\t\t\tfor (int i = 0; i < (int)used.size();i++)used[i] = 0;\n\t\t\tif (dfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\n/* use example */\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll X, Y, E; cin >> X >> Y >> E;\n\tV = X + Y + 2; // initialize V [0..index]\n\tG.resize(V); used.resize(V); match.resize(V); // initialize G used match\n\tfor (int i = 0; i < E;i++) {\n\t\tll x, y; cin >> x >> y;\n\t\tadd_edge(x, y + X);\n\t}\n\tcout << bipartite_matching() << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ninline double distance(double y1, double x1, double y2, double x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy = { 0, 1, 0, -1 }, dx = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\n\nusing namespace std;\n\n// 最大流問題を解く O(|E||V|^2)\nclass Dinic {\n\npublic:\n    struct Edge {\n        const int to;         // 行き先のノードid\n        long long flow;       // 流量\n        const long long cap;  // 容量\n        const int rev;        // 逆辺のノードid\n        const bool is_rev;    // 逆辺かどうか\n        Edge(int to, long long flow, long long cap, int rev, bool is_rev) : to(to), flow(flow), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    vector<vector<Edge>> graph; // グラフの隣接リスト表現\n    vector<int> level;          // sからの距離\n    vector<unsigned int> iter;  // どこまで調べ終わったか\n\n    explicit Dinic(unsigned int num_of_node) {\n        assert(num_of_node > 0);\n        graph.resize(num_of_node);\n        level.resize(num_of_node);\n        iter.resize(num_of_node);\n    }\n\n    // fromからtoへ向かう容量capの辺をグラフに追加する\n    void add_edge(unsigned int from, unsigned int to, long long cap) {\n        graph[from].emplace_back(Edge(to, 0, cap, (unsigned int)graph[to].size(), false));\n        graph[to].emplace_back(Edge(from, cap, cap, (unsigned int)graph[from].size() - 1, true));\n    }\n\n    // sからtへの最大流を求める\n    long long max_flow(unsigned int s, unsigned int t) {\n        long long flow = 0;\n        while (true) {\n            bfs(s);\n            if (level.at(t) < 0) {\n                return flow;\n            }\n            fill(iter.begin(), iter.end(), 0);\n            long long f;\n            while ((f = dfs(s, t, INT_MAX)) > 0) {\n                flow += f;\n            }\n        }\n    }\n\nprivate:\n    // sからの最短距離をBFSで計算する\n    void bfs(unsigned int s) {\n        fill(level.begin(), level.end(), -1);\n        queue<unsigned int> que;\n        level.at(s) = 0;\n        que.push(s);\n        while (not que.empty()) {\n            unsigned int v = que.front();\n            que.pop();\n            for (int i = 0; i < graph.at(v).size(); ++i) {\n                Edge &e = graph.at(v).at(i);\n                if ((e.cap - e.flow) > 0 and level.at(e.to) < 0) {\n                    level.at(e.to) = level.at(v) + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    // 増加パスをDFSで探す\n    long long dfs(unsigned int v, unsigned int t, long long f) {\n        if (v == t) {\n            return f;\n        }\n        for (unsigned int &i = iter.at(v); i < graph.at(v).size(); ++i) {\n            Edge &e = graph.at(v).at(i);\n            if ((e.cap - e.flow) > 0 and level.at(v) < level.at(e.to)) {\n                long long d = dfs(e.to, t, min(f, e.cap - e.flow));\n                if (d > 0) {\n                    e.flow += d;\n                    graph.at(e.to).at(e.rev).flow -= d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n};\n\nclass BipartiteMatching {\n    Dinic dinic;\n    const unsigned int source;\n    const unsigned int sink;\n    set<unsigned int> left_node;\n    set<unsigned int> right_node;\n\npublic:\n    // num_node: ノードの数(sinkやsourceは考慮不要)\n    BipartiteMatching(unsigned int num_node) : dinic(num_node + 2), source(num_node), sink(num_node + 1) {\n    }\n\n    void add_edge(unsigned int left, unsigned int right) {\n        left_node.insert(left);\n        right_node.insert(right);\n        dinic.add_edge(left, right, 1);\n    }\n\n    long long matching() {\n        for (auto left : left_node) {\n            dinic.add_edge(source, left, 1);\n        }\n        for (auto right : right_node) {\n            dinic.add_edge(right, sink, 1);\n        }\n        return dinic.max_flow(this->source, this->sink);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    BipartiteMatching bm(X + Y);\n    FOR(i, 0, E) {\n        int x, y;\n        cin >> x >> y;\n        bm.add_edge(x, X + y);\n    }\n\n    print(bm.matching());\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAX 1024\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\nint X, Y, E;\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[to].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge& e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (1) {\n        for (int i = 0; i < MAX; i++) used[i] = false;\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(void) {\n    cin >> X >> Y >> E;\n    while (E--) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, X+y, 1);\n    }\n    int s = X+Y, t = s+1;\n    for (int i = 0; i < X; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        add_edge(X+i, t, 1);\n    }\n    cout << max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define rrep(i,n) for (int i = (n)-1; i >= 0; i--)\n#define rep2(i,s,n) for (int i = (s); i < (n); ++i)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define pb push_back\n#define eb emplace_back\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vs vector<string>\n#define vc vector<char>\n#define vb vector<bool>\n#define vp vector<P>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\nusing LP = pair<ll,ll>;\ntemplate<class T> istream& operator>>(istream& is,vector<T>& v) { for(T& t:v){is>>t;} return is; }\ntemplate<class T> ostream& operator<<(ostream& os,const vector<T>& v) { for(T t:v){os<<t<<\" \";} os<<\"\\n\"; return os; }\nvoid Yes(bool b) { cout << (b ? \"Yes\" : \"No\") << endl; }\nvoid YES(bool b) { cout << (b ? \"YES\" : \"NO\") << endl; }\ntemplate<class T> inline bool chmin(T& a,T b) {if(a > b){a = b; return true;} return false;}\ntemplate<class T> inline bool chmax(T& a,T b) {if(a < b){a = b; return true;} return false;}\nconst int inf = 1001001001;\nconst ll linf = 1001001001001001001;\n\nclass flow {\n    struct edge {\n        int to,cap,rev;\n        edge(int to,int cap,int rev):to(to),cap(cap),rev(rev) {}\n    };\n    int n;\n    vector<vector<edge>> G;\n    vi level,iter;\n\n    void bfs(int s) {\n        level.assign(n,-1);\n        queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while(!q.empty()) {\n            int v = q.front();\n            q.pop();\n            for(auto& e : G[v]) {\n                if(e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t,int f) {\n        if(v == t) return f;\n        rep2(i,iter[v],G[v].size()) {\n            auto &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]) {\n                int d = dfs(e.to,t,min(f,e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    explicit flow(int n):n(n),G(n),level(n),iter(n) {}\n    void add_edge(int from,int to,int cap) {\n        G[from].eb(to,cap,G[to].size());\n        G[to].eb(from,0,G[from].size()-1);\n    }\n    // O(|E||V|^2) dinic-algorithm\n    int max_flow(int s,int t) {\n        int fl = 0;\n        while(true) {\n            bfs(s);\n            if(level[t] < 0) return fl;\n            iter.assign(n,0);\n            int f;\n            while((f = dfs(s,t,inf)) > 0) fl += f;\n        }\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr); cout.tie(nullptr);\n    int X,Y,e;\n    cin >> X >> Y >> e;\n    int s = X+Y,t = s+1;\n    flow fl(t+1);\n    rep(_,e) {\n        int x,y;\n        cin >> x >> y;\n        fl.add_edge(x,X+y,1);\n    }\n    rep(i,X) fl.add_edge(s,i,1);\n    rep(i,Y) fl.add_edge(X+i,t,1);\n    cout << fl.max_flow(s,t) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> vl;\ntypedef pair<ll, ll> PP;\n#define rep(i, n) for(ll i = 0; i < ll(n); i++)\ntemplate <class T> void corner(bool flg, T hoge) {\n    if(flg) {\n        cout << hoge << endl;\n        exit(0);\n    }\n}\n#define all(v) v.begin(), v.end()\n#define inputv(v, n)                                                           \\\n    vl v;                                                                      \\\n    rep(i, n) {                                                                \\\n        ll x;                                                                  \\\n        cin >> x;                                                              \\\n        v.push_back(x);                                                        \\\n    }\nconst ll INF = 999999999999999;\nconst ll MOD = 1000000007;\nconst ll MAX_N=500010;\nll a, b, c, d, e, f, p, t, x, y, z, q, m, n, r, h, k, w, l, ans;\nstruct edge {\n    ll to, cap, rev;\n};\n\nvector<vector<edge> > G;\nvector<bool> used;\n\nvoid add_edge(ll from, ll to, ll cap) {\n    G[from].emplace_back((edge) { to, cap, ll(G[to].size()) });\n    G[to].emplace_back((edge) { from, 0, ll(G[from].size()) - 1 });\n}\n\nll dfs(ll v, ll t, ll f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (auto& e : G[v]) {\n        if (!used[e.to] && e.cap > 0) {\n            ll d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while (1) {\n        fill(used.begin(), used.end(), false);\n        ll f = dfs(s, t, INF);\n        if (f == 0) break;\n        flow += f;\n    }\n    return flow;\n}\n\nint main() {\n    ll V, E;\n    cin >> x >>y>> E;\n    V = x + y + 2;\n    G.resize(V);\n    used.resize(V);\n    for (ll i = 0; i < E; i++) {\n        cin >>  a>> b;\n        add_edge(a+1, b+1 + x, 1);\n    }\n    rep(i, x) {\n        add_edge(0, 1 + i, 1);\n    }\n    rep(i, y) {\n        add_edge(x + i + 1, x + y + 1, 1);\n    }\n    cout << max_flow(0, V - 1) << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nstatic const int MAX = 202;\nstatic const int INFTY = (1 << 30);\nclass edge {\npublic:\n    int target, cap, rev;\n    edge (int target = 0, int cap = 0, int rev = 0) : target(target), cap(cap), rev(rev) {}\n};\nstd::vector<edge> G[MAX];\nint level[MAX]; //dist from source\nint iter[MAX]; //ended search num\nbool can[MAX/2][MAX/2];\n\nvoid bfs(int s) {\n    std::memset(level, -1, sizeof(level));\n    std::queue<int> q;\n    q.push(s);\n    level[s] = 0;\n    while(!q.empty()) {\n        int current = q.front(); q.pop();\n        for (int i  = 0; i < G[current].size(); i++) {\n            edge &e = G[current][i];\n            if (e.cap > 0 && level[e.target] < 0) {\n                level[e.target] = level[current] + 1;\n                q.push(e.target);\n            }\n        }\n    }\n}\n\nint dfs(int current, int sink, int f) {\n    if (current == sink) return f;\n    for (int &i = iter[current]; iter[current] < G[current].size(); i++) {\n        edge &e = G[current][i];\n        if (e.cap > 0 && level[current] < level[e.target]) {\n            int d = dfs(e.target, sink, std::min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.target][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (; ;) {\n        bfs(s);\n        if (level[t] < 0) return flow;\n        std::memset(iter, 0, sizeof(iter));\n        int f;\n        while ((f = dfs(s, t, INFTY)) > 0) {\n            flow += f;\n        }\n    }\n}\n\nvoid add_edge(int source, int target, int cap) {\n    G[source].push_back(edge(target, cap, G[target].size()));\n    G[target].push_back(edge(source, 0, G[source].size()-1));\n}\n\nint main()\n{\n    int X, Y, E, xi, yi;\n    std::scanf(\"%d %d %d\", &X, &Y, &E);\n    if (E==0) std::cout << 0 << std::endl;\n    else {\n        int s = X+Y, t = s+1;\n        for (int i = 0; i <= X; i++) {\n            for (int j = 0; j <= Y; j++) {\n                can[i][j] = false; //2d table which represents the connection between X and Y side\n            }\n        }\n\n        //xi, X+yi\n        for (int i = 0; i < E; i++) {\n            std::scanf(\"%d %d\", &xi, &yi);\n            can[xi][yi] = true;\n        }\n\n        for (int i = 0; i < X; i++) add_edge(s, i, 1);\n        for (int i = 0; i < Y; i++) add_edge(X+i, t, 1);\n\n        for (int i = 0; i < X; i++) {\n            for (int j = 0; j < Y; j++) {\n                if (can[i][j]) add_edge(i, X+j, 1);\n            }\n        }\n        std::cout << max_flow(s, t) << std::endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nstruct BiMatch{\n  int n,time;\n  vector<vector<int>> G;\n  vector<int> match,used,dead;\n\n  BiMatch(){}\n  BiMatch(int n):n(n),time(0),G(n),\n                 match(n,-1),used(n,-1),dead(n,0){}\n\n  void add_edge(int u,int v){\n    G[u].emplace_back(v);\n    G[v].emplace_back(u);\n  }\n\n  int dfs(int v){\n    used[v] = time;\n    for(int u:G[v]){\n      if(dead[u]) continue;\n      int w=match[u];\n      if((w<0) || (used[w]<time && !dead[w] && dfs(w))){\n        match[v]=u;\n        match[u]=v;\n        return 1;\n      }\n    }\n    return 0;\n  }\n\n  int build(){\n    int res=0;\n    for(int v=0;v<n;v++){\n      if(dead[v]) continue;\n      if(match[v]<0){\n        time++;\n        res+=dfs(v);\n      }\n    }\n    return res;\n  }\n\n  int disable(int v){\n    assert(!dead[v]);\n    int u=match[v];\n    if(~u) match[u]=-1;\n    match[v]=-1;\n    dead[v]=1;\n    time++;\n    return ~u?dfs(u)-1:0;\n  }\n\n  int enable(int v){\n    assert(dead[v]);\n    dead[v]=0;\n    time++;\n    return dfs(v);\n  }\n};\n//END CUT HERE\n\nsigned GRL_7_A(){\n  int X,Y,E;\n  cin>>X>>Y>>E;\n  BiMatch bm(X+Y);\n  for(int i=0;i<E;i++){\n    int x,y;\n    cin>>x>>y;\n    bm.add_edge(x,X+y);\n  }\n  cout<<bm.build()<<endl;\n  return 0;\n}\n/*\n  verified on 2019/06/16\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_7_A&lang=jp\n*/\n\nsigned main(){\n  GRL_7_A();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\n// #define DEBUG\n\nconst int INTMAX = 2 * 1e9 + 10;\nconst int NMAX = 2 * 1e3;\n\nbool check[NMAX];\n\nint dfs(int s, int t, int f, vector<pair<int, int>> edge[], vector<int> *used)\n{\n    int d = 0;\n    check[s] = true;\n    if (s == t)\n    {\n        used->push_back(t);\n        return f;\n    }\n\n    for (auto next : edge[s])\n    {\n        if (check[next.first] == false && next.second > 0)\n            d = dfs(next.first, t, min(next.second, f), edge, used);\n        if (d > 0)\n        {\n            used->push_back(s);\n            return d;\n        }\n        // DFSが終点まで行くと正の値dが帰ってくるので、辺の容量の調整をして終了\n    }\n    return 0; //そうでなければ何もしない\n}\n\nint main()\n{\n\n#ifdef DEBUG\n    cout << \"DEBUG MODE\" << endl;\n    ifstream in(\"input.txt\"); //for debug\n    cin.rdbuf(in.rdbuf());    //for debug\n#endif\n\n    int n, x, y, m, s, t, c, a, b, f, ans;\n    cin >> x >> y >> m;\n    n = x + y + 2;\n    vector<pair<int, int>> edge[n];\n    vector<int> used;\n\n    f = 1, ans = 0;\n    for (int i = 1; i <= x; i++)\n    {\n        edge[0].push_back(make_pair(i, 1));\n        edge[i].push_back(make_pair(0, 0));   \n    }\n    for (int i = x + 1; i <= y + x; i++)\n    {\n        edge[i].push_back(make_pair(y+x+1, 1));\n        edge[y+x+1].push_back(make_pair(i, 0));   \n    }\n    for (int i = 0; i < m; i++)\n    {\n        cin >> s >> t;\n        s++;\n        t += x+1;\n        edge[s].push_back(make_pair(t, 1));\n        edge[t].push_back(make_pair(s, 0));\n    }\n\n    while (f > 0)\n    {\n        for (int i = 0; i < n; i++)\n            check[i] = false;\n\n        f = dfs(0, n - 1, INTMAX, edge, &used);\n        a = -1, b = -1;\n        for (auto i : used)\n        {\n            a = b;\n            b = i;\n\n            if (a >= 0 && b >= 0)\n            {\n                for (auto j = edge[a].begin(); j != edge[a].end(); j++)\n                {\n                    if (j->first == b)\n                    {\n                        j->second += f;\n                        break;\n                    }\n                }\n                for (auto j = edge[b].begin(); j != edge[b].end(); j++)\n                {\n                    if (j->first == a)\n                    {\n                        j->second -= f;\n                        break;\n                    }\n                }\n            }\n        }\n        ans += f;\n        used.clear();\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n// getline(cin,s);\n// a = strtok(s, \",\");  \",\"で分解\n// for (int i = 0; i < n; i++)\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\nint const inf = 1<<29;\n\nstruct MCF {\n    typedef int Weight;\n    typedef int Capacity;\n    struct Edge;\n    int n;\n    vector<vector<Edge> > g;\n    vector<Weight> level;\n    vector<Weight> iter;\n\n    struct Edge {\n        int src, dst;\n        Capacity cap;\n        int rev;\n        bool isRev;\n        Edge(int src, int dst, Capacity cap, int rev, bool isRev)\n            :src(src), dst(dst), cap(cap), rev(rev), isRev(isRev) {}\n    };\n\n    MCF(int n_)\n        : n(n_), g(vector<vector<Edge> >(n_)), level(n_), iter(n_) {}\n\n    void add_edge(int src, int dst, Capacity cap) {\n        g[src].push_back(Edge(src, dst, cap, g[dst].size(), false));\n        g[dst].push_back(Edge(dst, src, 0, g[src].size() - 1, true));\n    }\n\n    void bfs(int s) {\n        fill(all(level), -1);\n        queue<Weight> q;\n        level[s] = 0;\n        q.push(s);\n        while (q.size()) {\n            int v = q.front(); q.pop();\n            for(int i = 0; i < (int)g[v].size(); i++){\n                Edge& e = g[v][i];\n                if (e.cap > 0 && level[e.dst] < 0) {\n                    level[e.dst] = level[v] + 1;\n                    q.push(e.dst);\n                }\n            }\n        }\n    }\n\n    Capacity dfs(int v, int t, int f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < (int)g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (e.cap > 0 && level[v] < level[e.dst]) {\n                int d = dfs(e.dst, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.dst][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    Capacity max_flow(int src, int dst) {\n        int flow = 0;\n        while(1){\n            bfs(src);\n            if (level[dst] < 0) return flow;\n            fill(all(iter), 0);\n            int f;\n            while ((f = dfs(src, dst, inf)) > 0) {\n                flow += f;\n            }\n        }\n    }\n\n    void view(){\n        for(int i=0;i<g.size();i++){\n            for(int j=0;j<g[i].size();j++){\n                auto & e=g[i][j];\n                printf(\"%d->%d (%d)\\n\", e.src, e.dst, e.cap);\n            }\n        }\n    }\n};\n\nint main(){\n    int X,Y,E;\n    cin >> X >> Y >> E;\n    int N=X+Y;\n    MCF mcf(N+2);\n    int S=N, T=N+1;\n    for(int i=0;i<E;i++){\n        int x, y;\n        cin >> x >> y;\n        mcf.add_edge(x,y+X,1);\n    }\n    for(int i=0;i<X;i++){\n        mcf.add_edge(S,i,1);\n    }\n    for(int i=0;i<Y;i++){\n        mcf.add_edge(i+X,T,1);\n    }\n    cout << mcf.max_flow(S,T) << endl;\n    // printf(\"X : {\");\n    // for(int i=0;i<X;i++){\n    //     printf(\"%d%s\",i,i==X-1?\"}\\n\":\",\");\n    // }\n    // printf(\"Y : {\");\n    // for(int i=0;i<Y;i++){\n    //     printf(\"%d%s\",i+X,i==Y-1?\"}\\n\":\",\");\n    // }\n    // mcf.view();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 10000\nusing namespace std;\nint V;                //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\???????????¨???\nint match[MAX_V];     //??????????????°????????¢\nbool used[MAX_V];     //DFS??§?????§??????????????????????????°\n\n//u??¨v????????¶????????°?????????????????????\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\n//?¢?????????????DFS??§??¢???\nbool dfs(int v){\n  used[v] = true;\n  for(int i=0; i<G[v].size(); i++){\n    int u = G[v][i], w = match[u];\n    if(w<0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\n//?????¨??°??????????????§??????????????°????±???????\nint bipartite_matching(){\n  int res=0;\n  memset(match, -1, sizeof(match));\n  for(int v=0; v<V; v++){\n    if(match[v] < 0){\n      memset(used,0,sizeof(used));\n      if(dfs(v)) res++;\n    }\n  }\n  return res;\n}\n\n\nint main(){\n  int n,m,l;\n  cin>>n>>m>>l;\n  for(int i=0,a,b;i<l;i++)cin>>a>>b,add_edge(a,n+b);\n  V=n+m+2;\n  cout <<bipartite_matching()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\n// ------ Variable ------ //\n\n#define MAX_V 100\n\nint V; vector<int> G[MAX_V];\n\nint match[MAX_V];\n\nbool used[MAX_V];\n\n\n// ------ Bipartite_Matching ------ //\n\nbool search(int v)\n{\n\tused[v] = true;\n\n\tfor (int i = 0; i < G[v].size(); i++)\n\t{\n\t\tint u = G[v][i], w = match[u];\n\n\t\tif (w < 0 || !used[w] && search(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint bipartite_matching()\n{\n\tint res = 0;\n\n\tmemset(match, -1, sizeof(match));\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (match[i] < 0)\n\t\t{\n\t\t\tmemset(used, 0, sizeof(used));\n\n\t\t\tif (search(i))\n\t\t\t{\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint X, Y, E, A, B;\n\n\tcin >> X >> Y >> E; V = X + Y;\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tG[A].push_back(X + B);\n\t\tG[X + B].push_back(A);\n\t}\n\n\tcout << bipartite_matching() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nstruct edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nclass Dinic{//max flow\npublic:\n    int n;\n    vector<vector<edge> >G;//[MAX];\n    vi level,iter;//[MAX];\n    Dinic(int size){\n        n=size;\n        G=vector<vector<edge> >(n);\n    }\n    void add_edge(int from, int to, int cap){\n        edge q={to,cap,int(G[to].size())};\n        G[from].push_back(q);\n        q={from,0,int(G[from].size()-1)};\n        G[to].push_back(q);\n    }\n    int getmaxflow(int s,int t) {//from s to t,ford_fulkerson\n        int flow=0;\n        while(1){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter=vi(n);\n            int f;\n            while((f=dfs(s,t,INF))>0)flow+=f;\n        }\n    }\nprivate:\n    void bfs(int s){\n        level=vi(n,-1);\n        queue<int>q;\n        level[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int i=0;i<G[v].size();i++){\n                edge &e=G[v][i];\n                if(e.cap>0&&level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t, int f) {\n        if(v==t)return f;\n        for(int &i=iter[v];i<G[v].size();i++){\n            edge &e=G[v][i];\n            if(level[v]>=level[e.to]||e.cap<=0) continue;\n            int d =dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n};\n\nsigned main(){\n    int x,y,e;\n    cin>>x>>y>>e;\n    Dinic yebi(x+y+3);\n    int s=x+y+1;\n    int t=x+y+2;\n    map<pii,int>mp;\n    rep(i,e){\n        int a,b; cin>>a>>b;\n        yebi.add_edge(a,b+x,1);\n        if(mp[pii(s,a)]++==0)yebi.add_edge(s,a,1);\n        if(mp[pii(b+x,t)]++==0)yebi.add_edge(b+x,t,1);\n    }\n    cout<<yebi.getmaxflow(s, t)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconstexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1 << 28;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nstruct Dinic {\n\tstruct edge {\n\t\tint to;\n\t\tll cap;\n\t\tint rev;\n\t\tbool isrev;\n\t\tint idx;\n\t\tedge(int _to, ll _cap, int _rev, bool _isrev, int _idx) :to(_to), cap(_cap), rev(_rev), isrev(_isrev), idx(_idx) {}\n\t};\n\tvector<vector<edge>> g;\n\tvector<int> min_cost, iter;\n\tDinic(int n) :g(n) {}\n\n\tvoid add_edge(int from, int to, ll cap, int idx = -1) {\n\t\tg[from].emplace_back(to, cap, (int)g[to].size(), false, idx);\n\t\tg[to].emplace_back(from, 0, (int)g[from].size() - 1, true, idx);\n\t}\n\n\tbool bfs(int s, int t) {\n\t\tmin_cost.assign(g.size(), -1);\n\t\tqueue<int> q;\n\t\tq.emplace(s);\n\t\tmin_cost[s] = 0;\n\t\twhile (!q.empty() && min_cost[t] == -1) {\n\t\t\tint cur = q.front();\n\t\t\tq.pop();\n\t\t\tfor (auto& e : g[cur]) {\n\t\t\t\tif (e.cap > 0 && min_cost[e.to] == -1) {\n\t\t\t\t\tmin_cost[e.to] = min_cost[cur] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn min_cost[t] != -1;\n\t}\n\n\tll dfs(int idx, const int t, ll flow) {\n\t\tif (idx == t) return flow;\n\t\tfor (int& i = iter[idx]; i < g[idx].size(); i++) {\n\t\t\tedge& e = g[idx][i];\n\t\t\tif (e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n\t\t\t\tll d = dfs(e.to, t, min(flow, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tll max_flow(int s, int t) {\n\t\tll flow = 0;\n\t\twhile (bfs(s, t)) {\n\t\t\titer.assign(g.size(), 0);\n\t\t\tll f = 0;\n\t\t\tif ((f = dfs(s, t, INF)) > 0) flow += f;\n\t\t}\n\t\treturn flow;\n\t}\n};\nint H, W;\nint cnv(int i, int j) {\n\treturn i * W + j + 1;\n}\nint dh[] = { 1,-1,0,0 };\nint dw[] = { 0,0,1,-1 };\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\tll X, Y, E; scanf(\"%lld %lld %lld\", &X, &Y, &E);\n\tDinic g(X + Y + 2);\n\tfor (int i = 1; i <= X; i++) {\n\t\tg.add_edge(0, i, 1);\n\t}\n\tfor (int i = 1; i <= Y; i++) {\n\t\tg.add_edge(i + X, X + Y + 1, 1);\n\t}\n\tfor (int i = 0; i < E; i++) {\n\t\tint x, y; scanf(\"%d %d\", &x, &y);\n\t\tx++; y++;\n\t\ty += X;\n\t\tg.add_edge(x, y, 1);\n\t}\n\tcout << g.max_flow(0, X + Y + 1) << endl;\n\treturn 0;\n\t/*\n\t\tおまじないを使ったらscanfとprintf関連注意！！！！！！！！！！！！\n\t*/\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\nconst int MAX_V = 300;\n\nint V;\nbool G[MAX_V][MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nbool dfs(int v) {\n\tused[v] = true;\n\tfor(int i = 0; i < V; i++) {\n\t\tif(!G[v][i]) continue;\n\t\tint u = i, w = match[u];\n\t\tif(w < 0 || (!used[w] && dfs(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching() {\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor(int v = 0; v < V; v++) {\n\t\tif(match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif(dfs(v)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint X, Y, E;\n\tcin >> X >> Y >> E;\n\tV = 200;\n\tfor(int i = 0; i < E; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\ty += 100;\n\t\tG[x][y] = G[y][x] = true;\n\t}\n\n\tcout << bipartite_matching() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=203,INF=1<<30;\nint V,match[MAX];\nvector<int> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\nbool DFS(int v){\n    used[v]=1;\n    for(int i=0;i<G[v].size();i++){\n        int u=G[v][i],w=match[u];\n        if(w<0||(!used[w]&&DFS(w))){\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int res=0;\n    memset(match,-1,sizeof(match));\n    for(int v=0;v<V;v++){\n        if(match[v]<0){\n            memset(used,0,sizeof(used));\n            if(DFS(v)) res++;\n        }\n    }\n    return res;\n}\n\nint main(){\n\n    int Y,E;cin>>V>>Y>>E;\n    for(int i=0;i<E;i++){\n        int a,b;cin>>a>>b;\n        add_edge(a,100+b);\n    }\n    \n    cout<<bipartite_matching()<<endl;\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\nusing ll = long long;\nusing ld =long double;\n#define int ll\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint W,H;\nbool inrange(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<int,pii> piii;\n#define MP make_pair\nstruct edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nclass Dinic{//max flow\npublic:\n    int n;\n    vector<vector<edge> >G;//[MAX];\n    vi level,iter;//[MAX];\n    Dinic(int size){\n        n=size;\n        G=vector<vector<edge> >(n);\n    }\n    void add_edge(int from, int to, int cap){\n        edge q={to,cap,int(G[to].size())};\n        G[from].push_back(q);\n        q={from,0,int(G[from].size()-1)};\n        G[to].push_back(q);\n    }\n    int getmaxflow(int s,int t) {//from s to t,ford_fulkerson\n        int flow=0;\n        while(1){\n            bfs(s);\n            if(level[t]<0)return flow;\n            iter=vi(n);\n            int f;\n            while((f=dfs(s,t,INF))>0)flow+=f;\n        }\n    }\nprivate:\n    void bfs(int s){\n        level=vi(n,-1);\n        queue<int>q;\n        level[s]=0;\n        q.push(s);\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int i=0;i<G[v].size();i++){\n                edge &e=G[v][i];\n                if(e.cap>0&&level[e.to]<0){\n                    level[e.to]=level[v]+1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t, int f) {\n        if(v==t)return f;\n        for(int &i=iter[v];i<G[v].size();i++){\n            edge &e=G[v][i];\n            if(level[v]>=level[e.to]||e.cap<=0) continue;\n            int d =dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap-=d;\n                G[e.to][e.rev].cap+=d;\n                return d;\n            }\n        }\n        return 0;\n    }\n};\n\nsigned main(){\n    int x,y,e;\n    cin>>x>>y>>e;\n    Dinic yebi(max(x,y)+3);\n    int s=max(x,y)+1;\n    int t=max(x,y)+2;\n    rep(i,e){\n        int a,b; cin>>a>>b;\n        yebi.add_edge(a, b,1);\n        yebi.add_edge(s, a, 1);\n        yebi.add_edge(b, t, 1);\n    }\n    cout<<yebi.getmaxflow(s, t)/2<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <bitset>\nusing namespace std;\nconstexpr int kN = int(1E2 + 10);\nstruct BPM {\n\t// from l to r\n\t// x[r] = l => match(l, r)\n\tint l, r, x[kN];\n\tvector<int> graph[kN];\n\tbitset<kN> went;\n\tvoid init(int n, int m) {\n\t\tl = n, r = m;\n\t\tfor (int i = 1; i <= n; i++) graph[i].clear();\n\t}\n\tvoid addedge(int u, int v) {graph[u].push_back(v);}\n\n\tbool dfs(int pos) {\n\t\twent[pos] = true;\n\t\tfor (int i : graph[pos]) if (!x[i]) {\n\t\t\tx[i] = pos;\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i : graph[pos]) if (!went[x[i]] && dfs(x[i])) {\n\t\t\tx[i] = pos;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint match() {\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= r; i++) x[i] = 0;\n\t\tfor (int i = 1; i <= l; i++) {\n\t\t\twent.reset();\n\t\t\tif (dfs(i)) ans++;\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nBPM bpm;\n\nint main() {\n\tint x, y, e, l, r;\n\tscanf(\"%d%d%d\", &x, &y, &e);\n\tbpm.init(x, y);\n\tfor (int i = 1; i <= e; i++) {\n\t\tscanf(\"%d%d\", &l, &r);\n\t\tbpm.addedge(l + 1, r + 1);\n\t}\n\tprintf(\"%d\\n\", bpm.match());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nusing Weight=long long;\nstatic const Weight INF=1LL<<57;\n\nstruct Arc {\n    // accessible to the reverse edge\n    size_t src, dst;\n    Weight capacity, flow;\n    size_t rev;\n    Arc() {}\n    Arc(size_t src, size_t dst, Weight capacity):\n        src(src), dst(dst), capacity(capacity), flow(0), rev(-1)\n    {}\n    Weight residue() const {\n        return capacity - flow;\n    }\n};\n\nbool operator<(const Arc &e, const Arc &f) {\n    if (e.capacity != f.capacity) {\n        return e.capacity > f.capacity;\n    } else {\n        return e.src!=f.src? e.src<f.src : e.dst<f.dst;\n    }\n}\n\nusing Arcs=vector<Arc>;\nusing Node=vector<Arc>;\nusing FlowNetwork=vector<Node>;\n\nvoid connect(FlowNetwork &g, size_t s, size_t d, Weight c=1) {\n    g[s].push_back(Arc(s, d, c));\n    g[d].push_back(Arc(d, s, 0));\n\n    g[s].back().rev = g[d].size()-1;\n    g[d].back().rev = g[s].size()-1;\n}\n\nvoid join(FlowNetwork &g, size_t s, size_t d, Weight c=1) {\n    g[s].push_back(Arc(s, d, c));\n    g[d].push_back(Arc(d, s, c));\n\n    g[s].back().rev = g[d].size()-1;\n    g[d].back().rev = g[s].size()-1;\n}\n\nWeight max_flow(FlowNetwork &g, size_t s, size_t t) {\n    /* Edmonds-Karp */\n    size_t V=g.size();\n\n    Weight mflow=0;\n    while (true) {\n        queue<size_t> q; q.push(s);\n        vector<Arc *> prev(V, NULL);\n        while (!q.empty() && prev[t]==NULL) {\n            size_t u=q.front(); q.pop();\n            for (Arc &e: g[u]) {\n                if (e.dst != s && prev[e.dst] == NULL && e.residue() > 0) {\n                    prev[e.dst] = &e;\n                    q.push(e.dst);\n                }\n            }\n        }\n        if (prev[t] == NULL) return mflow;\n\n        Weight incr=INF;\n        for (Arc *e=prev[t]; e!=NULL; e=prev[e->src])\n            incr = min(incr, e->residue());\n\n        mflow += incr;\n        for (Arc *e=prev[t]; e!=NULL; e=prev[e->src]) {\n            e->flow += incr;\n            g[e->dst][e->rev].flow -= incr;\n        }\n    }\n}\n\nWeight max_match(FlowNetwork g, size_t x, size_t y) {\n    size_t V=g.size();\n    g.resize(V+2);\n    for (size_t i=0; i<x; ++i)\n        connect(g, V, i);\n\n    y += x;\n    for (size_t i=x; i<y; ++i)\n        connect(g, i, V+1);\n\n    return max_flow(g, V, V+1);\n}\n\nint main() {\n    size_t X, Y, E;\n    scanf(\"%zu %zu %zu\", &X, &Y, &E);\n\n    FlowNetwork g(X+Y);\n    for (size_t i=0; i<E; ++i) {\n        size_t x, y;\n        scanf(\"%zu %zu\", &x, &y);\n\n        connect(g, x, X+y);\n    }\n\n    printf(\"%lld\\n\", max_match(g, X, Y));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 101;\nint X,Y;\nint mat[N][N];\nbool used[N];\nint girls[N];\n\nvoid add(int x,int y){\n    mat[x][y] = 1;\n}\n\nint dfs(int v){\n    used[v] = true;\n    for(int i=0;i<Y;i++){\n        if(!mat[v][i]) continue;\n        int u = girls[i];\n        if(u==-1 || !used[u] && dfs(girls[i])){\n            girls[i] = v;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint match(){\n    int ans = 0;\n    memset(girls,-1,sizeof(girls));\n    for(int i=0;i<X;i++){\n        memset(used,0,sizeof(used));\n        ans += dfs(i);\n    }\n    return ans;\n}\n\nint main(){\n    int E;\n    cin>>X>>Y>>E;\n    memset(mat,0,sizeof(mat));\n    for(int i=0;i<E;i++){\n        int x,y;\n        cin>>x>>y;\n        add(x,y);\n    }\n\n    cout<<match()<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct BipartiteMatching{\n  vector<vector<int> > G;\n  int V;\n  vector<int> match,used;\n  \n  BipartiteMatching(){}\n  BipartiteMatching(int V):V(V){init();}\n  \n  void init(){\n    for(int i=0;i<(int)G.size();i++) G[i].clear();\n    G.clear();\n    match.clear();\n    used.clear();\n    G.resize(V);\n    match.resize(V);\n    used.resize(V);\n  }\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  bool dfs(int v){\n    used[v]=true;\n    for(int i=0;i<(int)G[v].size();i++){\n      int u=G[v][i],w=match[u];\n      if(w<0||(!used[w]&&dfs(w))){\n\tmatch[v]=u;\n\tmatch[u]=v;\n\treturn true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching(){\n    int res=0;\n    fill(match.begin(),match.end(),-1);\n    for(int v=0;v<V;v++){\n      if(match[v]<0){\n\tfill(used.begin(),used.end(),0);\n\tif(dfs(v)){\n\t  res++;\n\t}\n      }\n    }\n    return res;\n  }\n};\nsigned main(){\n  int X,Y,E;\n  cin>>X>>Y>>E;\n  BipartiteMatching bm(X+Y);\n  for(int i=0;i<E;i++){\n    int x,y;\n    cin>>x>>y;\n    bm.add_edge(x,X+y);\n  }\n  cout<<bm.bipartite_matching()<<endl;\n  return 0;\n}\n/*\n  verified on 2017/06/29\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_7_A&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i,n) for(int i=0;i<(int)(n);i++)\n#define For(i,n1,n2) for(int i=(int)(n1);i<(int)(n2);i++)\n#define REP(i,n) for(ll i=0;i<(ll)(n);i++)\n#define RREP(i,n) for(ll i=((ll)(n)-1);i>=0;i--)\n#define FOR(i,n1,n2) for(ll i=(ll)(n1);i<(ll)(n2);i++)\n#define RFOR(i,n1,n2) for(ll i=((ll)(n1)-1);i>=(ll)(n2);i--)\n#define all(a)  (a).begin(),(a).end()\n#define SORT(a) sort((a).begin(),(a).end())\n#define oorret 0\n#define oor(x) [&](){try{x;} catch(const out_of_range& oor){return oorret;} return x;}()\n#define IOS cin.tie(0),ios::sync_with_stdio(false)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntemplate<typename T1, typename T2> inline bool chmin(T1& a, T2 b) { if (a > b) { a = b; return 1; }return 0; }\ntemplate<typename T1, typename T2> inline bool chmax(T1& a, T2 b) { if (a < b) { a = b; return 1; }return 0; }\ntemplate<class Type>struct is_vector : std::false_type {};\ntemplate<class ValueType, class Alloc>struct is_vector<std::vector<ValueType, Alloc>> : std::true_type {};\ntemplate <typename T> inline ostream& operator << (ostream& out, const vector<T>& v) {\n\tif (v.empty())return out;\n\tconstexpr bool is_vector_v = is_vector<T>::value;\n\tif (is_vector_v)for (auto itr = v.begin(); itr != v.end();)out << (*itr), out << ((++itr != v.end()) ? \"\\n\" : \"\");\n\telse for (auto itr = v.begin(); itr != v.end();)out << (*itr), out << ((++itr != v.end()) ? \" \" : \"\");\n\treturn out;\n}\ninline void put() {}\ntemplate<class T> inline void put(const T& first) { std::cout << first << \"\\n\"; }\ntemplate<class T, class... N> inline void put(const T& first, const N& ... rest) { std::cout << first << \" \"; put(rest...); }\ninline void putn() {}\ntemplate<class T, class... N> inline void putn(const T& first, const N& ... rest) { std::cout << first << \"\\n\"; putn(rest...); }\n\nclass flow {\npublic:\n\tstruct edge {\n\t\tint to, rev; // 行先、逆辺\n\t\tll cap; // 容量\n\t\tedge(int to, ll cap, int rev) :to(to), cap(cap), rev(rev) {}\n\t};\n\tvector<vector<edge>> path;\n\tvector<int> level, iter; // sからの距離、どこまで調べたか\n\tint numv; // 辺の本数\n\tflow(int n) {// n辺\n\t\tthis->numv = 0;\n\t\tthis->path.resize(n);\n\t\tthis->level.resize(n);\n\t\tthis->iter.resize(n);\n\t}\n\tvoid add_edge(int from, int to, ll cap) {\n\t\tthis->path[from].push_back(edge(to, cap, this->path[to].size()));\n\t\tthis->path[to].push_back(edge(from, 0, this->path[from].size() - 1)); // 逆辺\n\t\tthis->numv++;\n\t}\n\tvoid dist(int s) {\n\t\tfill(this->level.begin(), this->level.end(), -1);\n\t\tthis->bfs(s);\n\t}\n\tvoid bfs(int s) { // sからの最短距離計算\n\t\tqueue<int> q;\n\t\tq.push(s);\n\t\tthis->level[s] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tint p = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = 0; i < this->path[p].size(); ++i) {\n\t\t\t\tedge& e = this->path[p][i];\n\t\t\t\tif (e.cap > 0 && this->level[e.to] < 0) {\n\t\t\t\t\tthis->level[e.to] = this->level[p] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll inc_path(int v, int t, ll f) { // 増加パスをDFSで探す\n\t\tfill(this->iter.begin(), this->iter.end(), 0);\n\t\treturn dfs(v, t, f);\n\t}\n\tll dfs(int v, int t, ll f) {\n\t\tif (v == t)return f;\n\t\tfor (int& i = this->iter[v]; i < this->path[v].size(); ++i) {\n\t\t\tedge& e = this->path[v][i];\n\t\t\tif (e.cap > 0 && this->level[v] < this->level[e.to]) {\n\t\t\t\tll d = this->dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tthis->path[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tll max_flow(int s, int t) { // sからtへの最大流を計算\n\t\tll flow_value = 0;\n\t\twhile (true) {\n\t\t\tthis->dist(s);\n\t\t\tif (this->level[t] < 0)return flow_value;\n\t\t\tll f;\n\t\t\twhile ((f = this->inc_path(s, t, 10)) > 0) {\n\t\t\t\tflow_value += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nint main() {\n\tIOS;\n\tint x, y;\n\tint n, m;\n\tcin >> x >> y >> m;\n\tn = x + y;\n\tflow fl(n+2);\n\tvector<int> xv(m), yv(m);\n\tREP(i, m) {\n\t\tcin >> xv[i] >> yv[i];\n\t\tyv[i] += x;\n\t\tfl.add_edge(xv[i], yv[i], 1);\n\t}\n\tint st = n, te = n + 1;\n\tREP(i, x) {\n\t\tfl.add_edge(st, i, 1);\n\t\t\n\t}\n\tREP(i, y) {\n\t\tfl.add_edge(i+x, te, 1);\n\t}\n\tput(fl.max_flow(st, te));\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl;\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define repi(start,end) for(int i=start; i<end; i++)\n#define repj(start,end) for(int j=start; j<end; j++)\n#define repk(start,end) for(int k=start; k<end; k++)\n#define repl(start,end) for(int l=start; l<end; l++)\n#define RE return 0;\n\nstruct edge{int to,cap,rev;};\n\nint n,k;\nbool can[1000][1000];\nint used[100];\n\nvector<edge> G[2000000];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  //cout<<\"  v = \"<<v<<en\n  if(v==t) return f;\n  used[v]=true;\n  repi(0, G[v].size()){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int i=0;\n  int flow=0;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    //cout<<\"         \"<<i++<<en\n    int f=dfs(s, t, INF);\n    if(f==0) return flow;\n    flow+=f;\n  }\n}\n\nvoid solve(){\n  int s=n+k,t=s+1;\n  \n  repi(0, n){\n    add_edge(s,i,1);\n  }\n  repi(0, k){\n    add_edge(n+i, t, 1);\n  }\n  \n  repi(0, n){\n    repj(0, k){\n      if(can[i][j]){\n        add_edge(i, n+j, 1);\n      }\n    }\n  }\n  \n  cout<<max_flow(s, t)<<en\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#define MAX_V 100000\n#define INF 100000000\nusing namespace std;\n\nint V, M;               //頂点，辺の数\nvector<int> G[MAX_V];   //グラフの隣接リスト表現\nint match[MAX_V];       //マッチングのペア\nbool used[MAX_V];       //DFSですでに調べたかのフラグ\n\n//uとvを結ぶ辺をグラフに追加する\nvoid add_edge(int u, int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\n//増加パスをDFSで探す\nbool dfs(int v){\n    for (int i=0; i<G[v].size(); i++){\n        if (used[G[v][i]] == false){\n            used[G[v][i]] = true;\n            if (match[G[v][i]] < 0 || dfs(match[G[v][i]])){\n                match[G[v][i]] = v;\n                match[v] = G[v][i];\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n//二部グラフの最大マッチングを求める\nint bipartite_matching(){\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for(int v=0;v<V;v++){\n        if(match[v] < 0){\n            memset(used, 0, sizeof(used));\n            if(dfs(v)){\n                   res++;\n            }\n        }\n    }\n    return res;\n}\n\nint main(void){\n\t// cin >> V >> M;\n\t// int a,b;\n\t// for(int i=0;i<M;i++){\n\t// \tcin >> a >> b;\n\t// \tadd_edge(a,b);\n\t// }\n    int X, Y;\n    cin >> X >> Y >> M;\n    V = X + Y;\n    for (int i=0; i<M; i++){\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, X+y);\n    }\n\n\tstd::cout << bipartite_matching() << std::endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬╬╬██╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓▓█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n#define INF 1LL<<60\n#define fs first\n#define sc second\n#define pb push_back\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) (a)<=(i) && (i)<(b)\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\ntypedef pair<int,int> P;\ntypedef vector<vector<P>> Graph;\n\nconst int MAX_V = 3e5;\nint V;\nvector<int> G[MAX_V],match,used(MAX_V,0);\n\nvoid add_edge(int u, int v){\n  G[u].pb(v);\n  G[v].pb(u);\n}\n\nbool dfs(int v){\n  used[v]++;\n  REP(i,G[v].size()){\n    int u = G[v][i], w = match[u];\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  match.assign(V,-1);\n  REP(s,V){\n    if(match[s] < 0){\n      used.assign(V,0);\n      if(dfs(s)) res++;\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);  \n\n  int x,y,e;\n  cin >> x >> y >> e;\n\n  V = x+y;\n\n  int start = x+y, goal = start+1;\n\n  REP(_,e){\n    int s,t;\n    cin >> s >> t;\n    add_edge(s,x+t);\n  }\n\n  cout << bipartite_matching() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl;\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define repi(start,end) for(int i=start; i<end; i++)\n#define repj(start,end) for(int j=start; j<end; j++)\n#define repk(start,end) for(int k=start; k<end; k++)\n#define repl(start,end) for(int l=start; l<end; l++)\n#define RE return 0;\n\nstruct edge{int to,cap,rev;};\n\nint n,k;\nbool can[1000][1000];\nint used[100];\n\nvector<edge> G[2000000];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  //cout<<\"  v = \"<<v<<en\n  if(v==t) return f;\n  used[v]=true;\n  repi(0, G[v].size()){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int i=0;\n  int flow=0;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    //cout<<\"         \"<<i++<<en\n    int f=dfs(s, t, INF);\n    if(f==0) return flow;\n    flow+=f;\n  }\n}\n\nvoid solve(){\n  int s=n+k,t=s+1;\n  \n  repi(0, n){\n    add_edge(s,i,1);\n  }\n  repi(0, k){\n    add_edge(n+i, t, 1);\n  }\n  \n  repi(0, n){\n    repj(0, k){\n      if(can[i][j]){\n        add_edge(i, n+j, 1);\n      }\n    }\n  }\n  \n  cout<<max_flow(s, t)<<en\n}\n\n\n\n\n\n\nint main(){\n  /*\n  cin>>n>>k;\n  repi(0, n){\n    int num;\n    cout<<\"        \"<<i<<\":\"<<en\n    cout<<\"how many?     \";\n    cin>>num;\n    cout<<\"encode ->   \";\n    int a;\n    repj(0, num) {cin>>a; can[i][a]=true;}\n  }\n  cout<<en*/\n  \n  int e,a,b;\n  cin>>n>>k>>e;\n  repi(0, e){\n    cin>>a>>b;\n    can[a][b]=true;\n  }\n  \n  solve();\n  RE\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nconst int INF = 1e9;\n\nstruct BipartiteMatch {\n    int n, m; //left and right\n    vector<vector<bool>> matrix;\n    vector<int> matched;\n    \n    BipartiteMatch(int n, int m) : n(n), m(m) {\n        matrix.assign(n, vector<bool>(m, false));\n        matched.assign(m, -1);\n    }\n    \n    void addEdge(int from, int to) {\n        matrix[from][to] = true;\n    }\n    \n    int maxBpm() {\n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            vector<bool> seen(m, false);\n            if (bpm(i, seen)) {\n                ans++;\n            }\n        }\n        return ans;\n    }\n    \n    //This is DFS. Could do BFS too.\n    bool bpm(int source, vector<bool>& seen) {\n        for (int target = 0; target < m; target++) {\n            if (matrix[source][target] && !seen[target]) {\n                seen[target] = true;\n                if (matched[target] == -1 || bpm(matched[target], seen)) {\n                    matched[target] = source;\n                    return true;\n                }\n            }\n        }\n        return false;\n    }  \n};\n\n\nint main() {\n    int n, m, e;\n    //cin >> v >> e >> s >> t;\n    cin >> n >> m >> e;\n    \n    BipartiteMatch bpm(n, m);\n   \n    for (int i = 0; i < e; i++) {\n        int from, to;\n        cin >> from >> to;\n        bpm.addEdge(from, to);\n    }\n    int ans = bpm.maxBpm();\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CINT(...)                                                              \\\n    int __VA_ARGS__;                                                           \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef vector<ll> VL;\ntypedef pair<ll, ll> PL;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst double PI = atan(1.0) * 4.0;\n// const int MOD = 998244353;\nconst ll LINF = 9e18;\nconst ll dx[] = {1, 0, -1, 0};\nconst ll dy[] = {0, 1, 0, -1};\n\nvoid cinfast() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nstruct edge {\n    ll to, cap, rev;\n};\n\nstruct Mflow {\n    vector<vector<edge>> G;\n    VL level, iter;\n    ll N;\n\n    Mflow(ll size) : N(size) { init(size); };\n\n    void init(ll size) { G.resize(N); }\n\n    void add_edge(ll from, ll to, ll cap) {\n        G[from].push_back({to, cap, (ll)G[to].size()});\n        G[to].push_back({from, 0, (ll)G[from].size() - 1});\n    }\n    void bfs(ll s) {\n        level.assign(N, -1);\n        queue<ll> q;\n        level[s] = 0;\n        q.push(s);\n        while(!q.empty()) {\n            ll now = q.front();\n            q.pop();\n            FOREACH(e, G[now]) {\n                if(e.cap > 0 && level[e.to] == -1) {\n                    level[e.to] = level[now] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    ll dfs(ll now, ll t, ll f) {\n        if(now == t) return f;\n        for(ll &i = iter[now]; i < G[now].size(); i++) {\n            edge &e = G[now][i];\n            if(e.cap > 0 && level[now] < level[e.to]) {\n                ll d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    ll max_flow(ll s, ll t) {\n        ll flow = 0;\n        while(1) {\n            bfs(s);\n            if(level[t] < 0) return flow;\n            iter.assign(N, 0);\n            ll f;\n            while((f = dfs(s, t, LINF)) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\nsigned main() {\n    LCIN(X, Y, E);\n    Mflow mf(X + Y + 2);\n    REP(i, X) mf.add_edge(X + Y, i, 1);\n    REP(i, Y) mf.add_edge(X + i, X + Y + 1, 1);\n    REP(i, E) {\n        LCIN(x, y);\n        mf.add_edge(x, X + y, 1);\n    }\n    cout << mf.max_flow(X + Y, X + Y + 1) << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<set>\n#include<algorithm>\n#include<queue>\n\nclass BipartiteGraph {\npublic:\n    BipartiteGraph(const int x, const int y) :size_x_(x), size_y_(y), edge_(x + y) {}\n\n    void add_xy(const int vx, const int vy) {edge_[vx].insert(size_x_ + vy);}\n\n    int matching() const {\n        std::vector<int> match_to(edge_.size(), -1);\n        int count = 0;\n        for(int i = 0; i < size_x_; ++i) {\n            std::vector<bool> visited(edge_.size(), false);\n            if(FordFullkerson(i, match_to, visited)) ++count;\n        }\n        return count;\n    }\n\nprivate:\n    bool FordFullkerson(int from, std::vector<int>& match_to, std::vector<bool>& visited) const {\n        if(from == -1) return true;\n        if(visited[from]) return false;\n        visited[from] = true;\n        for(const auto& to: edge_[from]) {\n            if(!FordFullkerson(match_to[to], match_to, visited)) continue;\n            match_to[from] = to;\n            match_to[to] = from;\n            return true;\n        }\n        return false;\n    }\n\n    std::vector<std::set<int>> edge_;\n    int size_x_, size_y_;\n};\n\n////////////////////////////////////////////////////////////////////////////////\n\n#include<iostream>\nusing namespace std;\n\nint main() {\n    int x, y, e;\n    cin >> x >> y >> e;\n    BipartiteGraph g(x, y);\n    for(int i = 0; i < e; ++i) {\n        int vx, vy;\n        cin >> vx >> vy;\n        g.add_xy(vx, vy);\n    }\n    cout << g.matching() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT_ON(bit, i) (((bit >> i) & 1) > 0)\n\ntypedef long long LL;\ntemplate<typename T> std::vector<T> make_v(size_t a){return std::vector<T>(a);}\ntemplate<typename T,typename... Ts> auto make_v(size_t a, Ts... ts){ return std::vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));}    // C++14\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value==0>::type fill_v(T &t,const V &v){t=v;}\ntemplate<typename T,typename V> typename std::enable_if<std::is_class<T>::value!=0>::type fill_v(T &t,const V &v){for(auto &e:t) fill_v(e,v);}\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\n\ntemplate<class T> inline std::vector<T> unique(std::vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n// 初項s, 交差dのn個の数列の和\nlong long sum_of_arithmetic_progression(long long s, long long d, long long n) {\n    return n * (2 * s + (n - 1) * d) / 2;\n}\n\n// 2のべき乗数かどうか\nbool is_power_of_two(long long x) {\n    return !(x & (x - 1));\n}\n\n// aとbの最大公約数 O(log min(a, b))\nlong long gcd(long long a, long long b) {\n    if (b == 0) { return a; }\n    return gcd(b, a % b);\n}\n\n// 数列vの最大公約数 O(N log d)\nlong long gcd(std::vector<long long> &v) {\n    long long ans = v[0];\n    for (int i = 1; i < v.size(); ++i) {\n        ans = gcd(ans, v[i]);\n    }\n    return ans;\n}\n\n// aとbの最小公倍数 O(log min(a, b))\nlong long lcm(long long a, long long b) {\n    long long g = gcd(a, b);\n    return a / g * b;\n}\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-9;\nconst long double PI = acos(-1.0);\nconst std::vector<int> dy2 = {0, 1}, dx2 = {1, 0};  // 右，下\nconst std::vector<int> dy4 = {0, -1, 0, 1}, dx4 = {1, 0, -1, 0};    // 右，上，左，下\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\n\nusing namespace std;\n\n// 最大流問題を解く O(|E||V|^2)\nclass Dinic {\n\npublic:\n    struct Edge {\n        const int to;         // 行き先のノードid\n        long long flow;       // 流量\n        const long long cap;  // 容量\n        const int rev;        // 逆辺のノードid\n        const bool is_rev;    // 逆辺かどうか\n        Edge(int to, long long flow, long long cap, int rev, bool is_rev) : to(to), flow(flow), cap(cap), rev(rev), is_rev(is_rev) {\n            assert(this->cap >= 0);\n        }\n    };\n\n    vector<vector<Edge>> graph; // グラフの隣接リスト表現\n    vector<int> level;          // sからの距離\n    vector<unsigned int> iter;  // どこまで調べ終わったか\n\n    explicit Dinic(unsigned int num_of_node) {\n        assert(num_of_node > 0);\n        graph.resize(num_of_node);\n        level.resize(num_of_node);\n        iter.resize(num_of_node);\n    }\n\n    // fromからtoへ向かう容量capの辺をグラフに追加する\n    void add_edge(unsigned int from, unsigned int to, long long cap) {\n        graph[from].emplace_back(Edge(to, 0, cap, (unsigned int)graph[to].size(), false));\n        graph[to].emplace_back(Edge(from, cap, cap, (unsigned int)graph[from].size() - 1, true));\n    }\n\n    // sからtへの最大流を求める\n    long long max_flow(unsigned int s, unsigned int t) {\n        long long flow = 0;\n        while (true) {\n            bfs(s);\n            if (level.at(t) < 0) {\n                return flow;\n            }\n            fill(iter.begin(), iter.end(), 0);\n            long long f;\n            while ((f = dfs(s, t, INT_MAX)) > 0) {\n                flow += f;\n            }\n        }\n    }\n\nprivate:\n    // sからの最短距離をBFSで計算する\n    void bfs(unsigned int s) {\n        fill(level.begin(), level.end(), -1);\n        queue<unsigned int> que;\n        level.at(s) = 0;\n        que.push(s);\n        while (not que.empty()) {\n            unsigned int v = que.front();\n            que.pop();\n            for (int i = 0; i < graph.at(v).size(); ++i) {\n                Edge &e = graph.at(v).at(i);\n                if ((e.cap - e.flow) > 0 and level.at(e.to) < 0) {\n                    level.at(e.to) = level.at(v) + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    // 増加パスをDFSで探す\n    long long dfs(unsigned int v, unsigned int t, long long f) {\n        if (v == t) {\n            return f;\n        }\n        for (unsigned int &i = iter.at(v); i < graph.at(v).size(); ++i) {\n            Edge &e = graph.at(v).at(i);\n            if ((e.cap - e.flow) > 0 and level.at(v) < level.at(e.to)) {\n                long long d = dfs(e.to, t, min(f, e.cap - e.flow));\n                if (d > 0) {\n                    e.flow += d;\n                    graph.at(e.to).at(e.rev).flow -= d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n};\n\n// 2部グラフ上での最大マッチング\nclass BipartiteMatching {\n    int n;\n    Dinic dinic;\n    set<unsigned int> left_node;\n    set<unsigned int> right_node;\n\npublic:\n    // n: number of nodes\n    BipartiteMatching(unsigned int n) : n(n), dinic(n + 2) {}\n\n    void add_edge(unsigned int left, unsigned int right) {\n        this->left_node.insert(left);\n        this->right_node.insert(right);\n        this->dinic.add_edge(left, right, 1);\n    }\n\n    // 最大マッチング\n    long long maximal_matching() {\n        const int source = this->n;\n        const int sink = source + 1;\n\n        for (auto left : this->left_node) {\n            this->dinic.add_edge(source, left, 1);\n        }\n        for (auto right : this->right_node) {\n            this->dinic.add_edge(right, sink, 1);\n        }\n\n        return this->dinic.max_flow(source, sink);\n    }\n\n    // 最大安定集合のサイズ\n    long long maximum_independent_set() {\n        return this->n - this->maximal_matching();\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n\n    BipartiteMatching bm(X + Y + 2);\n    for (int i = 0; i < E; ++i) {\n        int x, y;\n        cin >> x >> y;\n        bm.add_edge(x, X + y);\n    }\n\n    print(bm.maximal_matching());\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vld = vector<ld>;\nusing vvld = vector<vld>;\n\ntypedef pair<ll, ll> P;\n\n#define bit(n) (1LL << (n))\n\n//#define int long long\n\n#define all(v) v.begin(), v.end()\n\n#define rep(i, n) for (ll i = 0; i < n; i++)\n#define REP(i, n) for (ll i = 1; i < n; i++)\n\n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define FORm(i, m) for (auto i = m.begin(); i != m.end(); i++)\n\ntemplate <class T>\ninline void chmax(T& a, T b) {\n  a = std::max(a, b);\n}\ntemplate <class T>\ninline void chmin(T& a, T b) {\n  a = std::min(a, b);\n}\n\n#define mod (ll)(1e9 + 7)\n// #define mod (998244353ll)\n\nconst long long INF = mod;\n\n// constexpr long long INF = 1LL << 60;\n\n// Ford-Fulkerson\ntemplate <typename T>\nclass MaxFlow {\n  struct Edge {\n    int to;\n    T cap;\n    int rev; // 逆辺のindex(G[to][rev]が逆辺)\n  };\n\n private:\n  vector<vector<Edge>> G;\n  vector<bool> used;\n  int sink;\n\n  // f: 頂点vに流れてきている量\n  T dfs(int v, T f) {\n    if (v == sink) {\n      return f;\n    }\n\n    used[v] = true;\n    for (auto e = G[v].begin(); e != G[v].end(); e++) {\n      if (used[e->to] || e->cap <= 0) {\n        continue;\n      }\n\n      T d = dfs(e->to, min(f, e->cap));\n      if (d > 0) {\n        e->cap -= d;\n        G[e->to][e->rev].cap += d;\n        return d;\n      }\n    }\n\n    return 0;\n  }\n\n public:\n  MaxFlow(int max_v) : G(max_v), used(max_v) {\n  }\n\n  void add_edge(int from, int to, T cap) {\n    G[from].push_back((Edge){to, cap, (int)G[to].size()});\n    G[to].push_back((Edge){from, 0, (int)G[from].size() - 1});\n  }\n\n  // source: Start\n  // sink: Goal\n  T solve(int source, int sink) {\n    this->sink = sink;\n\n    T flow = 0;\n    for (;;) {\n      fill(all(used), false);\n\n      T f = dfs(source, INF);\n      if (f == 0) {\n        return flow;\n      }\n      flow += f;\n    }\n  }\n\n  // 残余グラフ上で始点から到達できる頂点集合をX、それ以外をY\n  // とすれば(X, Y)が最小カットの解である。\n};\n\n// 二部グラフの最大マッチング\ntemplate <typename T>\nclass BipartiteMatching : private MaxFlow<T> {\n private:\n  int num_a;\n  int num_b;\n  int start;\n  int goal;\n\n public:\n  BipartiteMatching(int _num_a, int _num_b)\n    : MaxFlow<T>::MaxFlow(_num_a + _num_b + 2),\n      num_a(_num_a),\n      num_b(_num_b),\n      start(_num_a + _num_b),\n      goal(_num_a + _num_b + 1) {\n    // startからaに辺を引く\n    rep(i, num_a) {\n      MaxFlow<T>::add_edge(start, i, 1ll);\n    }\n    // bからgoalに辺を引く\n    rep(i, num_b) {\n      MaxFlow<T>::add_edge(num_a + i, goal, 1ll);\n    }\n  }\n\n  void add_edge(int a, int b) {\n    MaxFlow<T>::add_edge(a, num_a + b, 1ll);\n  }\n  T solve() {\n    return MaxFlow<T>::solve(start, goal);\n  }\n};\n\nsigned main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(20);\n\n  ll x, y, e;\n  cin >> x >> y >> e;\n\n  BipartiteMatching<ll> bm(x, y);\n\n  rep(i, e) {\n    ll a, b;\n    cin >> a >> b;\n    bm.add_edge(a, b);\n  }\n\n  cout << bm.solve() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct BipartiteMatching {\n\tint n;\n\tvector<vector<int>> g;\n\tvector<int> match;\n\tvector<int> used;\n\tBipartiteMatching(int n) : n(n), g(n), match(n), used(n) {}\n\tvoid addEdge(int u, int v) {\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\tint maximumMatching() {\n\t\tint cnt = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tif (match[v] == -1) {\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tif (augment(v)) cnt++;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\tbool augment(int v) {\n\t\tused[v] = true;\n\t\tfor (int u : g[v]) {\n\t\t\tint w = match[u];\n\t\t\tif (w == -1 || (!used[w] && augment(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint X, Y, E; cin >> X >> Y >> E;\n\tBipartiteMatching bm(X + Y);\n\trep(i, 0, E) {\n\t\tint x, y; cin >> x >> y;\n\t\tbm.addEdge(x, X + y);\n\t}\n\tcout << bm.maximumMatching() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_7_A\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nbool dfs(vector<vector<int>> &A, vector<int> &M, vector<bool> &U, int v)\n{\n        U[v] = true;\n        for (auto a: A[v]) {\n                int b = M[a];\n                if (b < 0 || (!U[b] && dfs(A, M, U, b))) {\n                        M[v] = a;\n                        M[a] = v;\n                        return true;\n                }\n        }\n        return false;\n}\n\nint main(int argc, char **argv)\n{\n        int X, Y, E;\n        cin >> X >> Y >> E;\n        int V = X + Y;\n        vector<vector<int>> A(V);\n        for (int i = 0; i < E; i++) {\n                int x, y;\n                cin >> x >> y;\n                A[x].push_back(X+y);\n                A[X+y].push_back(x);\n        }\n        vector<int> M(V, -1);\n        int matched = 0;\n        for (int v = 0; v < V; v++) {\n                if (M[v] < 0) {\n                        vector<bool> U(V);\n                        if (dfs(A, M, U, v))\n                                matched++;\n                }\n        }\n        cout << matched << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <string>\n#include <sstream>\n#include <ostream>\n#include <bitset>\n#include <list>\n#include <deque>\n#include <complex>\n#include <cassert>\n#include <cstring>\n#include <cstdio>\n#include <cfloat>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <climits>\n\nusing namespace std;\n\n#define MAX_V 505\n#define INF 1e9\n#define rep(i,n) for(int i = 0 ; i < n ; i++)\n#define FOR(i,a,b) for(int i = a ; i < b ; i++)\n#define all(p) (p).begin(),(p).end() \n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\n\nstruct edge{ int to,cap,rev; };\n\nint V,E;\nvector<edge> G[MAX_V];\nint level[MAX_V],iter[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> Q;\n  level[s] = 0;\n  Q.push(s);\n  while(!Q.empty()){\n    int v = Q.front(); Q.pop();\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[e.to] < 0){\n        level[e.to] = level[v] + 1;\n        Q.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v == t) return f;\n  for(int &i = iter[v] ; i < (int)G[v].size() ; i++){\n    edge &e = G[v][i];\n    if(e.cap > 0 && level[v] < level[e.to]){\n      int d = dfs(e.to,t,min(f,e.cap));\n      if(d > 0){\n        e.cap -= d;\n        G[e.to][e.rev].cap += d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow = 0;\n  for(;;){\n    bfs(s);\n    if(level[t] < 0) return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f = dfs(s,t,INF)) > 0){\n      flow += f;\n    }\n  }\n}\n\nint main(){\n  int X,Y,E,x,y;\n  scanf(\"%d%d%d\",&X,&Y,&E);\n  int s = X+Y, t = s+1;\n  rep(i,X){\n    add_edge(s,i,1);\n  }\n  rep(i,Y){\n    add_edge(X+i,t,1);\n  }\n  rep(i,E){\n    scanf(\"%d%d\",&x,&y);\n    add_edge(x,X+y,1);\n  }\n  printf(\"%d\\n\",max_flow(s,t));\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct BipartiteMatching {\n  vector< vector< int > > graph;\n  vector< int > match, alive, used;\n  int timestamp;\n\n  //BipartiteMatching(int n) : graph(n), alive(n, 1), used(n, 0), match(n, -1), timestamp(0) {}\n  BipartiteMatching(int n){\n    graph=vector<vector<int>>(n);\n    alive=vector<int>(n,1);\n    used=vector<int>(n,0);\n    match=vector<int>(n,-1);\n    timestamp=0;\n  }\n  \n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int idx) {\n    used[idx] = timestamp;\n    for(auto &to : graph[idx]) {\n      int to_match = match[to];\n      if(alive[to] == 0) continue;\n      if(to_match == -1 || (used[to_match] != timestamp && dfs(to_match))) {\n        match[idx] = to;\n        match[to] = idx;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      if(i < match[i]) {\n        cout << i << \"-\" << match[i] << endl;\n      }\n    }\n  }\n};\nint main() {\n  int X, Y, E;\n  cin >> X >> Y >> E;\n  BipartiteMatching bm(X + Y);\n  for(int i = 0; i < E; i++) {\n    int a, b;\n    cin >> a >> b;\n    bm.add_edge(a, X + b);\n  }\n  cout <<  bm.bipartite_matching() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#define MAX_V 100\n#define INF 1000\nusing namespace std;\n\nint V, M;               //頂点，辺の数\nvector<int> G[MAX_V];   //グラフの隣接リスト表現\nint match[MAX_V];       //マッチングのペア\nbool used[MAX_V];       //DFSですでに調べたかのフラグ\n\n//uとvを結ぶ辺をグラフに追加する\nvoid add_edge(int u, int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\n//増加パスをDFSで探す\nbool dfs(int v){\n    for (int i=0; i<G[v].size(); i++){\n        if (used[G[v][i]] == false){\n            used[G[v][i]] = true;\n            if (match[G[v][i]] < 0){\n                match[G[v][i]] = v;\n                match[v] = G[v][i];\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n//二部グラフの最大マッチングを求める\nint bipartite_matching(){\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for(int v=0;v<V;v++){\n        if(match[v] < 0){\n            memset(used, 0, sizeof(used));\n            if(dfs(v)){\n                   res++;\n            }\n        }\n    }\n    return res;\n}\n\nint main(void){\n\t// cin >> V >> M;\n\t// int a,b;\n\t// for(int i=0;i<M;i++){\n\t// \tcin >> a >> b;\n\t// \tadd_edge(a,b);\n\t// }\n    int X, Y;\n    cin >> X >> Y >> M;\n    V = X + Y;\n    for (int i=0; i<M; i++){\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, X+y);\n    }\n\n\tstd::cout << bipartite_matching() << std::endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint match[1001], v;\nbool vis[1001];\nvector<int> graph[1001];\n\nbool dfs(int x){\n\tvis[x] = true;\n\tfor (int i = 0; i < graph[x].size(); ++i){\n\t\tint u = graph[x][i], w = match[u];\n\t\tif (w < 0 || !vis[w] && dfs(w)){\n\t\t\tmatch[x] = u;\n\t\t\tmatch[u] = x;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipmatch(){\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int i = 0; i < v; ++i){\n\t\t//该点仍未匹配\n\t\tif (match[i] < 0){\n\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\tif (dfs(i))++res;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint a, b, x, y, e;\n\tscanf(\"%d%d%d\", &x, &y, &e);\n\tfor (int i = 0; i < e; ++i){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tgraph[a].push_back(x + b);\n\t\tgraph[x + b].push_back(a);\n\t}\n\tv = x + y;\n\tprintf(\"%d\\n\", bipmatch());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAX 256\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\nint X, Y, E;\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[to].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (1) {\n        for (int i = 0; i < MAX; i++) used[i] = false;\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(void) {\n    cin >> X >> Y >> E;\n    while (E--) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, X+y, 1);\n    }\n    int s = X+Y, t = s+1;\n    for (int i = 0; i < X; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        add_edge(X+i, t, 1);\n    }\n    cout << max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    bool operator==(const T &r) const {\n        return f == r.f && s == r.s && t == r.t;\n    }\n    bool operator!=(const T &r) const {\n        return f != r.f || s != r.s || t != r.t;\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n\n\n//マクロ省略系 コンテナ\n\nusing vi = vector<int>;\n#define _overloadvvi(_1, _2, _3, _4, name, ...) name\n#define vvi0() vec<vi>\n#define vvi1(a) vec<vi> a\n#define vvi2(a, b) vec<vi> a(b)\n#define vvi3(a, b, c) vec<vi> a(b,vi(c))\n#define vvi4(a, b, c, d) vec<vi> a(b,vi(c,d))\n#define vvi(...) _overloadvvi(__VA_ARGS__,vvi4,vvi3,vvi2 ,vvi1,vvi0)(__VA_ARGS__)\n\n\nusing vl = vector<ll>;\n#define _overloadvvl(_1, _2, _3, _4, name, ...) name\n#define vvl1(a) vec<vl> a\n#define vvl2(a, b) vec<vl> a(b)\n#define vvl3(a, b, c) vec<vl> a(b,vl(c))\n#define vvl4(a, b, c, d) vec<vl> a(b,vl(c,d))\n#define vvl(...) _overloadvvl(__VA_ARGS__,vvl4,vvl3,vvl2 ,vvl1)(__VA_ARGS__)\n\nusing vb = vector<bool>;\n#define _overloadvvb(_1, _2, _3, _4, name, ...) name\n#define vvb1(a) vec<vb> a\n#define vvb2(a, b) vec<vb> a(b)\n#define vvb3(a, b, c) vec<vb> a(b,vb(c))\n#define vvb4(a, b, c, d) vec<vb> a(b,vb(c,d))\n#define vvb(...) _overloadvvb(__VA_ARGS__,vvb4,vvb3,vvb2 ,vvb1)(__VA_ARGS__)\n\nusing vs = vector<string>;\n#define _overloadvvs(_1, _2, _3, _4, name, ...) name\n#define vvs1(a) vec<vs> a\n#define vvs2(a, b) vec<vs> a(b)\n#define vvs3(a, b, c) vec<vs> a(b,vs(c))\n#define vvs4(a, b, c, d) vec<vs> a(b,vs(c,d))\n#define vvs(...) _overloadvvs(__VA_ARGS__,vvs4,vvs3,vvs2 ,vvs1)(__VA_ARGS__)\n\nusing vd = vector<double>;\n#define _overloadvvd(_1, _2, _3, _4, name, ...) name\n#define vvd1(a) vec<vd> a\n#define vvd2(a, b) vec<vd> a(b)\n#define vvd3(a, b, c) vec<vd> a(b,vd(c))\n#define vvd4(a, b, c, d) vec<vd> a(b,vd(c,d))\n#define vvd(...) _overloadvvd(__VA_ARGS__,vvd4,vvd3,vvd2 ,vvd1)(__VA_ARGS__)\n\nusing vc=vector<char>;\n#define _overloadvvc(_1, _2, _3, _4, name, ...) name\n#define vvc1(a) vec<vc> a\n#define vvc2(a, b) vec<vc> a(b)\n#define vvc3(a, b, c) vec<vc> a(b,vc(c))\n#define vvc4(a, b, c, d) vec<vc> a(b,vc(c,d))\n#define vvc(...) _overloadvvc(__VA_ARGS__,vvc4,vvc3,vvc2 ,vvc1)(__VA_ARGS__)\n\nusing vp = vector<P>;\n#define _overloadvvp(_1, _2, _3, _4, name, ...) name\n#define vvp1(a) vec<vp> a\n#define vvp2(a, b) vec<vp> a(b)\n#define vvp3(a, b, c) vec<vp> a(b,vp(c))\n#define vvp4(a, b, c, d) vec<vp> a(b,vp(c,d))\n\nusing vt = vector<T>;\n#define _overloadvvt(_1, _2, _3, _4, name, ...) name\n#define vvt1(a) vec<vt> a\n#define vvt2(a, b) vec<vt> a(b)\n#define vvt3(a, b, c) vec<vt> a(b,vt(c))\n#define vvt4(a, b, c, d) vec<vt> a(b,vt(c,d))\n\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n\n#define _vvi vector<vi>\n#define _vvl vector<vl>\n#define _vvb vector<vb>\n#define _vvs vector<vs>\n#define _vvd vector<vd>\n#define _vvc vector<vc>\n#define _vvp vector<vp>\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)\n#define fort(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)if(t!=p)\n//#define fort(gi, ve) for (int gi = 0, f, t, c;gi<ve.size()&& (gi+= (ve[gi].t==p))< ve.size() && (f = ve[gi].f,t=ve[gi].t, c = ve[gi].c,true); gi++)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nusing u64 = unsigned long long;\n\n\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {\n    xx = vall;\n}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T vall) {\n    for (auto &&vx: vecc) fill(vx, vall);\n}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {\n    T x;\n    cin >> x;\n    return (x);\n}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\nstring sin() { return _in<string>(); }\nll lin() { return _in<ll>(); }\n#define na(a, n) a.resize(n); rep(i,n) cin >> a[i];\n#define nao(a, n) a.resize(n+1); rep(i,n) cin >> a[i+1];\n#define nad(a, n) a.resize(n); rep(i,n){ cin >> a[i]; a[i]--;}\n#define na2(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i];\n#define na2d(a, b, n) a.resize(n),b.resize(n);rep(i, n){cin >> a[i] >> b[i];a[i]--,b[i]--;}\n#define na3(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define na3d(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n){cin >> a[i] >> b[i] >> c[i];a[i]--,b[i]--,c[i]--;}\n#define nt(a, h, w) resize(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rs(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<x << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<x<<\", \"<< debugName(y)<<\" = \"<<y<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<x  << \", \" <<  debugName(y)<<\" = \"<<y <<\", \" debugName(z)<<\" = \"<<z <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<\", \" <<  debugName(b)<<\" = \"<<b<<endl\n\n\n\nint n, m, k, d, H, W, x, y, z, q;\nint cou;\nvi a, b, c;\nvvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\n\n//@formatter:off\ntemplate<class T> struct edge { int f, t; T c; int id; int type; edge(int f, int t, T c = 1, int id = -1, int ty = -1) : f(f), t(t), c(c), id(id), type(ty) {} bool operator<(const edge &b) const { return c < b.c; } bool operator>(const edge &b) const { return c > b.c; }};\ntemplate<class T> ostream &operator<<(ostream &os, edge<T> &e) {    os << e.f << \" \" << e.t << \" \" << e.c;    return os;}\ntemplate<typename T> class graph {protected:    vector<bool> usedv;public :    vector<vector<edge<T>>> g;    vector<edge<T>> edges;    int n;    graph(int n) : n(n) { g.resize(n), usedv.resize(n); }    void clear() { g.clear(), edges.clear(); }    void resize(int n) {        this->n = n;        g.resize(n);        usedv.resize(n);    }    int size() { return g.size(); }    vector<edge<T> > &operator[](int i) { return g[i]; }    virtual void add(int f, int t, T c, int id, int ty) = 0;    virtual bool used(edge<T> &e) = 0;    virtual bool used(int id) = 0;    virtual void del(edge<T> &e) = 0;    virtual void del(int id) = 0;    virtual void set_edges() = 0;};\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::usedv;\n    int eid = 0;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n//            debugline(\"digraph add\");\n            deb(f, t, c, id, ty);\n//            ole();\n        }\n        if (id == -1)id = eid++;\n        g[f].emplace_back(f, t, c, id, ty);\n        edges.emplace_back(f, t, c, id, ty);\n    }\n    bool used(edge<T> &e) { return usedv[e.id]; }\n    bool used(int id) { return usedv[id]; }\n    void del(edge<T> &e) { usedv[e.id] = usedv[e.id ^ 1] = 1; }\n    void del(int id) { usedv[id] = usedv[id ^ 1] = 1; }\n    void set_edges() {        if (sz(edges))return;        rep(i, n)fora(e, g[i])edges.push_back(e);    }\n};\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::usedv;\n    int eid = 0;\n    undigraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n//            debugline(\"undigraph add\");\n            deb(f, t, c, id, ty);\n//            ole();\n        }\n        if (id == -1)id = eid, eid += 2;\n        g[f].emplace_back(f, t, c, id, ty);\n        g[t].emplace_back(t, f, c, id + 1, ty);\n        edges.emplace_back(f, t, c, id, ty);\n        edges.emplace_back(t, f, c, id + 1, ty);\n    }\n    void add(edge<T> &e) {        int f = e.f, t = e.t, ty = e.type;        T c = e.c;        add(f, t, c, ty);    }\n    bool used(edge<T> &e) { return usedv[e.id]; }\n    bool used(int id) { return usedv[id]; }\n    void del(edge<T> &e) { usedv[e.id] = usedv[e.id ^ 1] = 1; }\n    void del(int id) { usedv[id] = usedv[id ^ 1] = 1; }\n    void set_edges() {        if (sz(edges))return;        rep(i, n)fora(e, g[i])edges.push_back(e);    }\n};\n\n\nstruct bimatch {\n    vector<int> pre, root;\n    vector<vector<int>> to;\n    vector<int> p, q;\n    int n;\n    bimatch(int n) : pre(n, -1), root(n, -1), to(n), p(n, -1), q(n, -1), n(n) {}\n    //2重に貼る必要はない\n    void add(int a, int b) {to[min(a,b)].push_back(max(a,b));}\n    int solve() {        int res = 0;        bool upd = true;        while (upd) {            upd = false;            queue<int> s;            for (int i = 0; i < n; ++i) {                if (!~p[i]) {                    root[i] = i;                    s.push(i);                }            }            while (!s.empty()) {                int v = s.front();                s.pop();                if (~p[root[v]]) continue;                for (int i = 0; i < (int) to[v].size(); ++i) {                    int u = to[v][i];                    if (!~q[u]) {                        while (~u) {                            q[u] = v;                            swap(p[v], u);                            v = pre[v];                        }                        upd = true;                        ++res;                        break;                    }                    u = q[u];                    if (~pre[u]) continue;                    pre[u] = v;                    root[u] = root[v];                    s.push(u);                }            }            if (upd) fill(pre.begin(), pre.end(), -1), fill(root.begin(), root.end(), -1);        }        return res;    }\n#define  maxflow solve\n};\n\nsigned main() {\n    din(x,y,e);\n    na2(a,b,e);\n    bimatch m(x+y);\n    rep(i, e){\n        m.add(a[i],b[i]+x);\n    }\n    cout << m.solve() << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 1e4 + 10, INF = INT_MAX / 4;\n\nclass BipartiteMatching { // O( ( V + E ) * sqrt( V ) )\n public: \n  vector< int > G[ N ]; // N = total number of nodes = n + m\n  int n, m, match[ N ], dist[ N ];\n  // n: number of nodes on left side, nodes are numbered 1 to n\n  // m: number of nodes on right side, nodes are numbered n+1 to n+m\n  // G = NIL[0] ??? G1[G[1---n]] ??? G2[G[n+1---n+m]]\n  bool BFS() {\n    queue< int > Q;\n    for (int i = 1; i <= n; i++ ) {\n      if ( match[ i ] == 0 ) {\n        dist[ i ] = 0;\n        Q.push( i );\n      }\n      else dist[ i ] = INF;\n    }\n    dist[ 0 ] = INF;\n    while ( !Q.empty() ) {\n      int u = Q.front(); Q.pop();\n      if ( u != 0 )\n        for(int v : G[u])\n          if ( dist[ match[ v ] ] == INF ) {\n            dist[ match[ v ] ] = dist[ u ] + 1;\n            Q.push( match[ v ] );\n          }\n    }\n    return ( dist[ 0 ] != INF );\n  }\n  bool DFS( int u ) {\n    if ( u != 0 ) {\n      for(int v : G[u])\n        if ( dist[ match[ v ] ] == dist[ u ] + 1 and DFS( match[ v ] ) ) {\n          match[ v ] = u;\n          match[ u ] = v;\n          return true;\n        }\n      dist[ u ] = INF;\n      return false;\n    }\n    return true;\n  }\n  int Solve() {\n    int matching = 0;\n    fill_n(match, n+m+1, 0);\n    while ( BFS() )\n      for (int i = 1; i <= n; i++ )\n        if ( match[ i ] == 0 and DFS( i ) ) matching++;\n    return matching;\n  }\n  void AddEdge( int u, int v ) { G[ u ].push_back( n + v ); }\n} ob;\n\nint main() {\n  int E; scanf(\"%d %d %d\", &ob.n, &ob.m, &E);\n  for(int i = 0; i < E; ++i) {\n    int x, y; scanf(\"%d %d\", &x, &y);\n    ob.AddEdge(x+1, y+1);\n  }\n  printf(\"%d\\n\", ob.Solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <climits>\n#include <set>\n#include <numeric>\n#include <iomanip>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n};\n\nvector <edge> edges[202];\nint level[202];\nint iter[202];\n\nvoid add_edge(int from, int to, int cap){\n    edges[from].push_back((edge){to, cap, (int) edges[to].size()});\n    edges[to].push_back((edge) {from, 0, (int) edges[from].size() - 1});\n}\n\nvoid bfs(int s){\n    memset(level, -1, sizeof(level));\n    queue <int> q;\n    level[s] = 0;\n    q.push(s);\n    while(!q.empty()){\n        int v = q.front();\n        q.pop();\n        for(int i = 0; i < edges[v].size(); i++){\n            edge &e = edges[v][i];\n            if(e.cap > 0 && level[e.to] < 0){\n                level[e.to] = level[v] + 1;\n                q.push(e.to);\n            }\n        }\n    }\n}\n\nint dfs(int v, int t, int f){\n    if(v == t){\n        return f;\n    }\n\n    for(int &i = iter[v]; i < edges[v].size(); i++){\n        edge &e = edges[v][i];\n        if(e.cap > 0 && level[v] < level[e.to]){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                edges[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint dinic(int s, int t){\n    int flow = 0;\n    while(true){\n        bfs(s);\n        if(level[t] < 0){\n            return flow;\n        }\n        memset(iter, 0, sizeof(iter));\n        while(true){\n            int f = dfs(s, t, INT_MAX);\n            if(f <= 0){\n                break;\n            }\n            flow += f;\n        }\n    }\n    return 0;\n}\nint main(void){\n    int X;\n    int Y;\n    int E;\n    cin >> X >> Y >> E;\n\n    for(int i = 0; i < X; i++){\n        add_edge(0, i + 1, 1);\n    }\n    for(int i = 0; i < Y; i++){\n        add_edge(X + i + 1, X + Y + 1, 1);\n    }\n\n    for(int i = 0; i < E; i++){\n        int x;\n        int y;\n        cin >> x >> y;\n        add_edge(x + 1, y + X + 1, 1);\n    }\n    cout << dinic(0, X + Y + 1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n////////////////////\n// Ford-Fulkerson //\n////////////////////\n\nclass MaxFlow {\nprivate:\n\tusing vi64 = std::vector<int64_t>;\n\tusing Matrix = std::vector<vi64>;\n\tstd::vector<bool> visited_;\n\n\tMatrix graph_;\n\n\tint64_t findPath(const int source, const int sink, const int node_i, const int64_t flow)\n\t{\n\t\tif (node_i == sink) return flow;\n\t\tvisited_[node_i] = true;\n\t\tfor (int next_i{}; next_i < (int)graph_.size(); next_i++)\n\t\t{\n\t\t\tif (!graph_[node_i][next_i] || visited_[next_i]) continue;\n\t\t\tconst int64_t additional_flow{findPath(source, sink, next_i, std::min(flow, graph_[node_i][next_i]))};\n\t\t\tif (!additional_flow) continue;\n\n\t\t\tgraph_[node_i][next_i] -= additional_flow;\n\t\t\tgraph_[next_i][node_i] += additional_flow;\n\t\t\treturn additional_flow;\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\tMaxFlow(const int node_num)\n\t\t: graph_(node_num, vi64(node_num)), visited_(node_num){}\n\tvoid add_edge(const int from, const int to, const int64_t flow)\n\t{\n\t\tgraph_[from][to] += flow;\n\t}\n\tint64_t operator()(const int source, const int sink)\n\t{\n\t\tint64_t flow_sum{};\n\t\twhile (true)\n\t\t{\n\t\t\tstd::fill(visited_.begin(),visited_.end(), false);\n\t\t\tint64_t additional_flow{findPath(source, sink, source, LLONG_MAX)};\n\t\t\tif (!additional_flow) break;\n\t\t\tflow_sum += additional_flow;\n\t\t}\n\t\treturn flow_sum;\n\t}\n};\n\nint main()\n{\n\tint X, Y, E;\n\tscanf(\"%d%d%d\", &X, &Y, &E);\n\tMaxFlow bin_match(X + Y + 2);\n\tfor (int x_i{1}; x_i <= X; x_i++)\n\t\tbin_match.add_edge(0, x_i, 1);\n\tfor (int y_i{X + 1}; y_i < X + Y + 2; y_i++)\n\t\tbin_match.add_edge(y_i, X + Y + 1, 1);\n\t\n\tfor (int e_i{}; e_i < E; e_i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tbin_match.add_edge(1 + x, X + 1 + y, 1);\n\t}\n\tprintf(\"%lld\\n\", bin_match(0, X + Y + 1));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nclass dinic{\nprivate:\n\tunordered_map<int,unordered_map<int,T>> mp;\n\tunordered_map<int,int> level;\n\tunordered_set<string> visited;\npublic:\n\tvoid add_edge(int from, int to, T cap){\n\t\tmp[from][to] = cap;\n\t\tmp[to][from] = 0;\n\t}\n\n\tvoid bfs(int s){\n\t\tlevel.clear();\n\t\tqueue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\n\t\t\tint v = q.front();q.pop();\n\t\t\tfor(auto x:mp[v]){\n\t\t\t\tif(x.second > 0 && !level.count(x.first)){\n\t\t\t\t\tlevel[x.first] = level[v] + 1;\n\t\t\t\t\tq.push(x.first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tT dfs(int v, int t, T f){\n\t\tif(v == t){\n\t\t\treturn f;\n\t\t}\n\t\tfor(auto x:mp[v]){\n\t\t\tif(visited.count(to_string(v) + \":\" + to_string(x.first))) continue;\n\t\t\tvisited.insert(to_string(v) + \":\" + to_string(x.first));\n\t\t\tif(x.second > 0 && level.count(x.first) && level[v] < level[x.first]){\n\t\t\t\tT d = dfs(x.first, t, min(f, x.second));\n\t\t\t\tif(d > 0){\n\t\t\t\t\tmp[v][x.first] -= d;\n\t\t\t\t\tmp[x.first][v] += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tT max_flow(int s, int t){\n\t\tT flow = 0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(!level.count(t)) return flow;\n\t\t\tvisited.clear();\n\t\t\tT f;\n\t\t\twhile((f = dfs(s, t, 10000000)) > 0){\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main(){\n\tdinic<int> g;\n\tint x,y,e;\n\tcin >> x >> y >> e;\n\tfor(int i=0;i<e;i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\tg.add_edge(-1,x,1);\n\t\tg.add_edge(x,y,1);\n\t\tg.add_edge(y,101,1);\n\t}\n\tcout << g.max_flow(-1,101) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <sys/timeb.h>\n#include <fstream>\n\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define replrev(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n#define reprev(i,n) replrev(i,0,n)\n#define repi(itr,ds) for(auto itr=ds.begin();itr!=ds.end();itr++)\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define mt make_tuple\n#define INF 2000000000\n#define INFL 1000000000000000000LL\n#define EPS (1e-10)\n#define MOD 1000000007\n#define PI 3.1415926536\n#define RMAX 4294967295\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<P> vP;\ntypedef vector<vector<int> > vvi;\ntypedef vector<vector<bool> > vvb;\ntypedef vector<vector<ll> > vvll;\ntypedef vector<vector<char> > vvc;\ntypedef vector<vector<string> > vvs;\ntypedef vector<vector<double> > vvd;\ntypedef vector<vector<P> > vvP;\ntypedef priority_queue<int, vector<int>, greater<int> > pqli;\ntypedef priority_queue<ll, vector<ll>, greater<ll> > pqlll;\ntypedef priority_queue<P, vector<P>, greater<P> > pqlP;\ntypedef pair<int, pair<int, int> > Edge;\ntypedef vector<Edge> vE;\ntypedef priority_queue<Edge, vector<Edge>, greater<Edge> > pqlE;\n\n#define MAX_V 102\n\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[MAX_V];\t// ??°???????????£??\\???????????¨???\nint level[MAX_V];\t// s??????????????¢\nint iter[MAX_V];\t// ???????????§??????????????£??????\n\n\t\t\t\t\t// from??????to??????????????????cap???????????°?????????????????????\nvoid add_edge(int from, int to, int cap)\n{\n\tG[from].push_back(edge{ to, cap, (int)G[to].size() });\n\tG[to].push_back(edge{ from, 0, (int)G[from].size() - 1 });\n}\n\n// s????????????????????¢???BFS??§?¨????\nvoid bfs(int s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ?¢?????????????DFS??§??¢???\nint dfs(int v, int t, int f) {\n\tif (v == t)return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n// s??????t???????????§???????±???????\nint max_flow(int s, int t) {\n\tint flow = 0;\n\twhile (true) {\n\t\tbfs(s);\n\t\tif (level[t] < 0)return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main() {\n\tint X, Y, E;\n\tcin >> X >> Y >> E;\n\trep(i, E) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tadd_edge(x, X + y, 1);\n\t}\n\trep(x, X) {\n\t\tadd_edge(X + Y, x, 1);\n\t}\n\trep(y, Y) {\n\t\tadd_edge(y, X + Y + 1, 1);\n\t}\n\n\tcout << max_flow(X + Y, X + Y + 1) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <bitset>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int> >vpi;\ntypedef pair<int,int> pi;\n#define R return\n#define W while\n#define FOR(i,a) for(int i=0;i<a;i++)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\nvi v[510];\nbitset<510>b,x;\nint m[510];\nbool dfs(int now){\n    FOR(i,v[now].size())if(!b[v[now][i]]){\n        b[v[now][i]]=true;\n        if(m[v[now][i]]==-1||dfs(m[v[now][i]])){\n            m[v[now][i]]=now;\n            R x[now]=true;\n        }\n    }\n    R false;\n}\nint main(){\n    int n,y,k,l,r,ans=0;\n    x.reset();\n    scanf(\"%d%d%d\",&n,&y,&k);\nn=max(n,y);\n    n++;\n    FOR(i,n)m[i]=-1;\n    W(k--){\n        scanf(\"%d%d\",&l,&r);\n        v[l].PB(r);\n    }\n    FOR(i,n)if(!x[i]){\n        b.reset();\n        if(dfs(i))ans++;\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint X, Y, E, x, y;\nbool D[110][110] = {};\nint PY[100];\nbool V[110];\nbool match(int x){\n  if (x < 0) return true;\n  if(V[x]) return false;\n  V[x] = true;\n\n  for(int y = 0; y < Y; y++){\n    if(!D[x][y]) continue;\n    if(match(PY[y])){\n      PY[y] = x;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  cin >> X >> Y >> E;\n  for(int i = 0; i < E; i++){\n    cin >> x >> y;\n    D[x][y] = true;\n  }\n  \n  fill(PY, PY + Y, -1);\n  int count = 0;\n  for(int x = 0; x < X; x++){\n    fill(V, V+X, false);\n    if(match(x))\n      count++;\n  }\n  cout << count << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct HopcroftKarp {\n\tint n;\n\tvector<vector<int>> g;\n\tvector<int> match, dist;\n\tvector<bool> used, alive;\n\tHopcroftKarp(int n) : n(n), g(n), match(n), dist(n), used(n), alive(n, true) {}\n\tvoid addEdge(int u, int v) {\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\tint maximumMatching() {\n\t\tint cnt = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\t\twhile (true) {\n\t\t\tbuildAlternatingLevelGraph();\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tint flow = 0;\n\t\t\tfor (int u = 0; u < n; u++)\n\t\t\t\tif (match[u] == -1 && augment(u))\n\t\t\t\t\tflow++;\n\t\t\tif (flow == 0)break;\n\t\t\tcnt += flow;\n\t\t}\n\t\treturn cnt;\n\t}\n\tvoid buildAlternatingLevelGraph() {\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int u = 0; u < n; u++)\n\t\t\tif (match[u] == -1) {\n\t\t\t\tq.emplace(u);\n\t\t\t\tdist[u] = 0;\n\t\t\t}\n\t\twhile (q.size()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tint w = match[v];\n\t\t\t\tif (w != -1 && dist[w] == -1) {\n\t\t\t\t\tdist[w] = dist[v] + 1;\n\t\t\t\t\tq.emplace(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tbool augment(int u) {\n\t\tused[u] = true;\n\t\tfor (int v : g[u]) {\n\t\t\tif (!alive[v])continue;\n\t\t\tint w = match[v];\n\t\t\tif (w == -1 || (!used[w] && dist[w] == dist[u] + 1 && augment(w))) {\n\t\t\t\tmatch[u] = v;\n\t\t\t\tmatch[v] = u;\n\t\t\t\tused[v] = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint X, Y, E; cin >> X >> Y >> E;\n\tHopcroftKarp bm(X + Y);\n\trep(i, 0, E) {\n\t\tint x, y; cin >> x >> y;\n\t\tbm.addEdge(x, X + y);\n\t}\n\tcout << bm.maximumMatching() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n//BEGIN CUT HERE\nstruct BiMatch{\n  int n;\n  vector<vector<int> > G;\n  vector<int> match,used;\n  \n  BiMatch(){}\n  BiMatch(int sz):n(sz),G(sz),match(sz),used(sz){}\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  bool dfs(int v){\n    used[v]=true;\n    for(int i=0;i<(int)G[v].size();i++){\n      int u=G[v][i],w=match[u];\n      if(w<0||(!used[w]&&dfs(w))){\n\tmatch[v]=u;\n\tmatch[u]=v;\n\treturn true;\n      }\n    }\n    return false;\n  }\n\n  int build(){\n    int res=0;\n    fill(match.begin(),match.end(),-1);\n    for(int v=0;v<n;v++){\n      if(match[v]<0){\n\tfill(used.begin(),used.end(),0);\n\tif(dfs(v)){\n\t  res++;\n\t}\n      }\n    }\n    return res;\n  }\n};\n//END CUT HERE\n\nsigned main(){\n  int X,Y,E;\n  cin>>X>>Y>>E;\n  BiMatch bm(X+Y);\n  for(int i=0;i<E;i++){\n    int x,y;\n    cin>>x>>y;\n    bm.add_edge(x,X+y);\n  }\n  cout<<bm.build()<<endl;\n  return 0;\n}\n/*\n  verified on 2017/06/29\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_7_A&lang=jp\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <climits>\n#include <assert.h>\n#include <queue>\n#include <set>\n\nusing namespace std;\n// ???(???????????? ????????? ???????????? ???????????????)\nstruct Edge {\n    int to, cap, cost, rev;\n    Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {\n        assert(this->cap >= 0);\n    }\n};\n\n// ?????§????????????O(F|E|)??§?§£???\nclass FordFulkerson {\npublic:\n    unsigned int num_of_node = 0;   // ???????????°\n    map<int, vector<Edge>> G;       // ??°???????????£??\\???????????¨???\n    vector<bool> used;              // DFS??§?????§??????????????????????????°\n\n    FordFulkerson(unsigned int num_of_node) : num_of_node(num_of_node){\n    }\n\n    // from??????to??????????????????cap????????¨?????????????????°?????????????????????\n    void add_edge(int from, int to, int cap) {\n        this->G[from].push_back(Edge(to, cap, (int)this->G[to].size()));        // ???\n        this->G[to].push_back(Edge(from, 0, (int)this->G[from].size() - 1));    // ??????\n    }\n\n    // s??????t???????????§???????±??????? O(F|E|)\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (true) {\n            this->used = vector<bool>(this->num_of_node, 0);\n            int f = dfs(s, t, INT_MAX);\n            if (f == 0) { return flow; }\n            flow += f;\n        }\n    }\n\nprivate:\n    // v??????t???f???????????¨??????????????????\n    int dfs(int v, int t, int f) {\n        if (v == t) { return f; }\n        used[v] = true;\n        for (Edge &e : G[v]) {\n            if (!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;                 // ???\n                    G[e.to][e.rev].cap += d;    // ??????\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n};\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n\n    FordFulkerson ff(X + Y + 2);\n    for (int i = 0; i < E; ++i) {\n        int x, y;\n        cin >> x >> y;\n        ff.add_edge(x, X + y, 1);\n    }\n\n    int source = X + Y;\n    int sink = source + 1;\n\n    for (int x = 0; x < X; ++x) {\n        ff.add_edge(source, x, 1);\n    }\n    for (int y = X; y < X + Y; ++y) {\n        ff.add_edge(y, sink, 1);\n    }\n\n    cout << ff.max_flow(source, sink) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <list>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <tuple>\n#include <deque>\n#include <complex>\n\nusing namespace std;\n\n/*\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vpii;\n*/\n\ntypedef long long ll;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef pair<long long, long long> pll;\ntypedef vector<pll> vpll;\n\ntypedef long double ld;\ntypedef vector<ld> vld;\n\ntypedef vector<bool> vb;\n\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define reps(i, n) for (ll i = 1; i <= (n); i++)\n#define rrep(i, n) for (ll i = (n) - 1; i >= 0; i--)\n#define rreps(i, n) for (ll i = (n); i >= 1; i--)\n#define all(v) (v).begin(), (v).end()\n\ntemplate <class T> void chmin(T& a, T b) { a = min(a, b);}\ntemplate <class T> void chmax(T& a, T b) { a = max(a, b);}\n\nconstexpr int INF = 1 << 30;\nconstexpr ll INFL = 1LL << 60;\nconstexpr ll MOD = 1000000007;\nconstexpr ld EPS = 1e-12;\nld PI = acos(-1.0);\n\nstruct Edge {\n    ll rev, from, to;\n    ll cap, original_cap;\n    Edge(ll r, ll f, ll t, ll c) : rev(r), from(f), to(t), cap(c), original_cap(c) {};\n};\n\nstruct Graph {\n    vector<vector<Edge>> g;\n    Graph(ll n) { g = vector<vector<Edge>>(n); };\n    vector<Edge>& operator[](ll i) { return g[i]; }\n    size_t size() {return g.size(); }\n    Edge& redge(Edge e) {\n        return g[e.to][e.rev];\n    }\n    void add_edge(ll from, ll to, ll cap) {\n        g[from].push_back(Edge(g[to].size(), from, to, cap));\n        g[to].push_back(Edge(g[from].size() - 1, to, from, 0));\n    }\n};\n\nstruct FordFulkerson {\n    vector<bool> used;\n    Graph& G;\n    FordFulkerson(Graph& g) : G(g) {};\n    ll dfs(ll v, ll t, ll f) {\n        if(v == t) return f;\n        used[v] = true;\n        for(auto& e : G[v]) {\n            if(used[e.to] || e.cap <= 0) continue;\n            ll d = dfs(e.to, t, min(f, e.cap));\n            if(d <= 0) continue;\n            e.cap -= d;\n            G.redge(e).cap += d;\n            return d;\n        }\n        return 0;\n    }\n    ll max_flow(ll s, ll t) {\n        ll flow = 0;\n        while(true) {\n            used.assign(G.size(), false);\n            ll f = dfs(s, t, INFL);\n            if(f == 0) return flow;\n            else flow += f;\n        }\n        return 0;\n    }\n};\n\nvoid solve() {\n    ll x, y, e;\n    cin >> x >> y >> e;\n    Graph g(x + y + 2);\n    for(ll i = 0; i < e; i++) {\n        ll _x, _y;\n        cin >> _x >> _y;\n        g.add_edge(_x + 1, _y + x + 1, 1);\n    }\n    for(ll i = 0; i < x; i++) {\n        g.add_edge(0, i + 1, 1);\n    }\n    for(ll i = 0; i < y; i++) {\n        g.add_edge(i + x + 1, x + y + 1, 1);\n    }\n    FordFulkerson f(g);\n    cout << f.max_flow(0, x + y + 1) << endl;\n    return;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <valarray>\nusing namespace std;\n\nbool match(int cur,bool arr[],bool V[],int npair[], int column){\n    if(cur < 0){\n        return true;\n    }\n    if(V[cur]){\n        return false;\n    }\n    V[cur] = true;\n    for(int i = 0; i < column; i++){\n        if(!arr[cur*column + i]){\n            continue;\n        }\n        if(match(npair[i],arr,V,npair,column)){\n            npair[i] = cur;\n            return true;\n        }\n    }\n    return true;\n}\n\nint main(){\n    int row,column,E;\n    scanf(\"%d %d %d\",&row,&column,&E);\n    bool arr[row*column],V[row];\n    for(int ei = 0; ei < E; ei++){\n        int from,to;\n        scanf(\"%d %d\",&from,&to);\n        arr[from*column + to] = true;\n    }\n    int npair[column],count = 0;\n    for(int i = 0; i < column; i++){\n        npair[i] = -1;\n    }\n    for(int cur = 0; cur < row; cur++){\n        for(int i = 0; i < row; i++){\n            V[i] = false;\n        }\n        if(match(cur,arr,V,npair,column)){\n            count++;\n        }\n    }\n    printf(\"%d\\n\",count);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nconst int MAX_V = 205;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(const int &u, const int &v) {\n\tG[u].emplace_back(v);\n\tG[v].emplace_back(u);\n}\n\nbool dfs(const int &v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w)) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//?????¨??????????????°????????§???????±?????????????\nint bipartite_matching(const int &V) {\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; ++v) {\n\t\tif (match[v] < 0) {\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v))++res;\n\t\t}\n\t}\n\treturn res-1;\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::ios_base::sync_with_stdio(false);\n\tint X, Y, E, s, t; cin >> X >> Y >> E;\n\tfor (int i = 0; i < E; ++i) {\n\t\tcin >> s >> t;\n\t\tadd_edge(s, t);\n\t}\n\tint ans = bipartite_matching(X + Y);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int MAX_N=500;\n\nstruct edge{\n\tint to,cap,rev;\n};\n\nvector<edge> G[MAX_N];\nvector<int> check(MAX_N,0);\n\nint dfs(int v,int t, int f ){\n\tif(v==t){return f;}\n\tcheck[v]=1;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tedge &e = G[v][i];\n\t\tif(check[e.to]==0 && e.cap > 0){\n\t\t\tint ff =dfs(e.to,t,min(f,e.cap));\n\t\t\tif(ff>0){\n\t\t\t\te.cap -= ff;\n\t\t\t\tG[e.to][e.rev].cap += ff;\n\t\t\t\treturn ff;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxflow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tfill(check.begin(),check.end(),0);\n\t\tint f = dfs(s,t,INT_MAX);\n\t\tif(f==0){return flow;}\n\t\tflow += f;\n\t}\n}\n\nint main(){\n\tint X,Y,E,s,t;\n\tcin >> X >> Y >> E ;\n\t\n\tfor(int i=0;i<E;i++){\n\t\tcin >> s >> t ;\n\t\tG[s].push_back((edge){X+t,1,G[t].size()});\n\t\tG[X+t].push_back((edge){s,0,G[s].size()-1});\n\t}\n\t\n\tfor(int i=0;i<X;i++){\n\t\tG[X+Y].push_back((edge){i,1,G[i].size()});\n\t\tG[i].push_back((edge){X+Y,0,G[X+Y].size()-1});\n\t}\n\t\n\tfor(int i=X;i<X+Y;i++){\n\t\tG[i].push_back((edge){X+Y+1,1,G[X+Y+1].size()});\n\t\tG[X+Y+1].push_back((edge){i,0,G[i].size()-1});\n\t}\n\t/*\n\tint k=11;\n\tfor(int i=0;i<G[k].size();i++){\n\t\tcout << G[k][i].to << endl;\n\t}\n\t*/\n\t\n\tcout << maxflow(X+Y,X+Y+1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nll V;\nvector<vector<ll>> G;\nvector<ll> match;\nvector<int> used;\n\nvoid add_edge(ll u, ll v) {\n\tG[u].push_back(v);\n\tG[v].push_back(u);\n}\n\nbool dfs(ll v) {\n\tused[v] = 1;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tll u = G[v][i], w = match[u];\n\t\tif (w < 0 || ((used[w] == 0) && dfs(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nll bipartite_matching() {\n\tll res = 0;\n\tfor (int i = 0; i < (int)match.size();i++)match[i] = -1;\n\tfor (int v = 0;v < V;v++) {\n\t\tif (match[v] < 0) {\n\t\t\tfor (int i = 0; i < (int)used.size();i++)used[i] = 0;\n\t\t\tif (dfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\n/* use example */\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll X, Y, E; cin >> X >> Y >> E;\n\tV = X + Y + 2; // initialize V\n\tG.resize(V); used.resize(V); match.resize(V); // initialize G used match\n\tfor (int i = 0; i < E;i++) {\n\t\tll x, y; cin >> x >> y;\n\t\tadd_edge(x, y + X);\n\t}\n\tcout << bipartite_matching() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\n\n\n//?????§2??¨??????????????° verified AOJ GRL_7_A\n#define MAX_V 100000\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u,int v){\n    G[u].pb(v);\n    G[v].pb(u);\n}\n\n// ?¢???§??????DFS??§??¢???\nbool dfs(int v){\n    used[v]=true;\n    rep(i,G[v].size()){\n        int u=G[v][i],w=match[u];           //u:v??????????§???????????????? , w:u??¨??????????????°??????????????????\n        if(w<0 || (!used[w] && dfs(w))){    //u????????????????????????dfs??§???w????????£???????????? ??????w?????\\????????¢??????????????£???(=?¢???§?????????) ??´???\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(int V){\n    int res=0;\n    rep(i,MAX_V)match[i]=-1;\n    rep(v,V){\n        if(match[v]<0){\n            rep(i,MAX_V)used[i]=0;\n            if( dfs(v) ) res++;       //?¢???§????????????????????°res+=1\n        }\n    }\n    return res;\n}\n\nint main(){\n    int x,y,e;\n    cin>>x>>y>>e;\n    rep(i,e){\n        int a,b;\n        cin>>a>>b;\n        add_edge(a,x+b);\n    }\n    \n    cout<<bipartite_matching(x+y)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long int lint;\ntypedef pair<lint, lint> plint;\ntypedef pair<double long, double long> pld;\n#define Alint(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1ll << (n))\n#define FOR(i, begin, end) for(lint i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(lint i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2>& l, const pair<T1, T2>& r) { return make_pair(l.first - r.first, l.second - r.second); }\nconst lint MOD = 998244353, INF = 1e9;\n\nstruct edge { lint to, cap, rev; };\n\nvector<edge> Graph[20005];\nint level[20005];\nint iter[20005];\nvoid add_edge(lint from, lint to, lint cap) {\n\tGraph[from].push_back({ to, cap, SZ(Graph[to]) });\n\tGraph[to].push_back({ from, 0, SZ(Graph[from]) - 1 });\n}\nvoid bfs(lint s) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<lint> que;\n\tque.push(s);\n\tlevel[s] = 0;\n\twhile (!que.empty()) {\n\t\tlint v = que.front(); que.pop();\n\t\tREP(i, SZ(Graph[v])) {\n\t\t\tedge& e = Graph[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nlint dfs(lint v, lint t, lint f) {\n\tif (v == t) return f;\n\tfor (int& i = iter[v]; i < SZ(Graph[v]); i++) {\n\t\tedge& e = Graph[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tlint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tGraph[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlint max_flow(lint s, lint t) {\n\tlint flow = 0;\n\tfor (;;) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tlint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nlint X, Y, E, x, y;\nint main() {\n\tcin.tie(0); ios_base::sync_with_stdio(false);\n\tlint N = 100, s = 200, t = 201;\n\tcin >> X >> Y >> E;\n\tREP(i, X) {\n\t\tadd_edge(s, i, 1);\n\t}\n\tREP(i, E) {\n\t\tcin >> x >> y;\n\t\tadd_edge(x, y + N, 1);\n\t}\n\tREP(i, Y) {\n\t\tadd_edge(i + N, t, 1);\n\t}\n\tcout << max_flow(s, t) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, x, n) for(int i = x; i <= n; i++)\n#define rep3(i, x, n) for(int i = x; i >= n; i--)\n#define elif else if\n#define sp(x) fixed << setprecision(x)\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)x.size()\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int, int>;\nusing pil = pair<int, ll>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nconst ll MOD = 1e9+7;\n//const ll MOD = 998244353;\nconst int inf = (1<<30)-1;\nconst ll INF = (1LL<<60)-1;\nconst ld EPS = 1e-10;\ntemplate<typename T> bool chmax(T &x, const T &y) {return (x < y)? (x = y, true) : false;};\ntemplate<typename T> bool chmin(T &x, const T &y) {return (x > y)? (x = y, true) : false;};\n\ntemplate<typename T>\nstruct Max_Flow{\n    struct edge{\n        int to; T cap; int rev;\n        edge(int to, T cap, int rev) : to(to), cap(cap), rev(rev) {}\n    };\n\n    vector<vector<edge>> es;\n    vector<bool> used;\n    const T INF_T;\n\n    Max_Flow(int n) : INF_T(numeric_limits<T>::max()){\n        es.resize(n), used.resize(n);\n    }\n\n    void add_edge(int from, int to, T cap, bool directed = true){\n        es[from].eb(to, cap, sz(es[to]));\n        es[to].eb(from, directed? 0 : cap, sz(es[from])-1);\n    }\n\n    T dfs(int now, int t, T flow){\n        if(now == t) return flow;\n        used[now] = true;\n        for(auto &e: es[now]){\n            if(!used[e.to] && e.cap > 0){\n                T f = dfs(e.to, t, min(flow, e.cap));\n                if(f > 0){\n                    e.cap -= f;\n                    es[e.to][e.rev].cap += f;\n                    return f;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T max_flow(int s, int t){\n        T flow = 0;\n        for(;;){\n            fill(all(used), false);\n            T f = dfs(s, t, INF_T);\n            if(f == 0) return flow;\n            flow += f;\n        }\n    }\n};\n\nint main(){\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    Max_Flow<int> G(X+Y+2);\n    int s = X+Y, t = X+Y+1;\n    rep(i, X) G.add_edge(s, i, 1);\n    rep(i, Y) G.add_edge(X+i, t, 1);\n    rep(i, E){\n        int u, v; cin >> u >> v;\n        G.add_edge(u, X+v, 1);\n    }\n    cout << G.max_flow(s, t) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,s,e) for(int i=(s); i<(e);i++)\n#define rep(i,n) REP(i,0,n)\n#define rep1(i,n) REP(i,1,n)\n#define repe(i,n) for(auto &&i:n)\n#define all(v) (v).begin(),(v).end()\n#define decimal fixed<<setprecision(20)\n#define fastcin() cin.tie(0);ios::sync_with_stdio(false)\nusing namespace std;\nusing LL = long long;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst int INF = 1e9;\nconst LL LLINF = 1e16;\n\nstruct BipartiteMatching {\n    using Graph = vector<vector<int>>;\n    Graph G;\n    vector<int> match, alive, used;\n    int timestamp;\n\n    BipartiteMatching(int n) : G(n), alive(n, 1), used(n, 0), match(n, -1), timestamp(0) {}\n\n    void add_edge(int u, int v) {\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    int dfs(int idx) {\n        used[idx] = timestamp;\n        for(auto &&to : G[idx]) {\n            int w = match[to];\n            if(alive[to] == 0) continue;\n            if(w < 0 || (used[w] != timestamp && dfs(w))) {\n                match[idx] = to;\n                match[to] = idx;\n                return 1;\n            }\n        }\n        return 0;\n    }\n\n    int bipartite_matching() {\n        int res = 0;\n        for(int i = 0; i < G.size(); i++) {\n            if(alive[i] == 0) continue;\n            if(match[i] == -1) {\n                ++timestamp;\n                res += dfs(i);\n            }\n        }\n        return res;\n    }\n\n     void output() {\n        for(int i = 0; i < G.size(); i++) {\n            if(i < match[i]) {\n                cout << i << \"-\" << match[i] << endl;\n            }\n        }\n    }\n};\n\nint main(){\n    int x, y, e;\n    cin >> x >> y >> e;\n    BipartiteMatching BM(x+y);\n    rep(i, e){\n        int u, v;\n        cin >> u >> v;\n        BM.add_edge(u, x+v);\n    }\n    cout << BM.bipartite_matching() << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint X,Y,E,x,y;\nbool D[110][110] = {};\n\nint PY[110];\nbool V[110];\nbool match(int x) {\n  if(x < 0) return true;\n  if(V[x]) return false;\n  V[x] = true;\n  for(int y = 0; y < Y; ++y) {\n    if(!D[x][y]) continue;\n    if(match(PY[y])) {\n      PY[y] = x;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  cin >> X >> Y  >> E;\n  for(int i = 0; i < E; ++i) {\n    cin >> x >> y;\n    D[x][y] = true;\n  }\n  fill(PY,PY+Y,-1);\n  int count = 0;\n  for(int x = 0; x < X; ++x) {\n    fill(V,V+X,false);\n    if(match(x)) ++count;\n  }\n  cout << count;\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <climits>\n#include <assert.h>\n#include <queue>\n#include <set>\n\nusing namespace std;\n// ???(???????????? ????????? ???????????? ???????????????)\nstruct Edge {\n    int to, cap, cost, rev;\n    Edge(int to, int cap, int rev) : to(to), cap(cap), rev(rev) {\n        assert(this->cap >= 0);\n    }\n};\n\n// ?????§????????????O(F|E|)??§?§£???\nclass FordFulkerson {\npublic:\n    unsigned int num_of_node = 0;   // ???????????°\n    map<int, vector<Edge>> G;       // ??°???????????£??\\???????????¨???\n    vector<bool> used;              // DFS??§?????§??????????????????????????°\n\n    FordFulkerson(unsigned int num_of_node) : num_of_node(num_of_node){\n    }\n\n    // from??????to??????????????????cap????????¨?????????????????°?????????????????????\n    void add_edge(int from, int to, int cap) {\n        this->G[from].push_back(Edge(to, cap, (int)this->G[to].size()));        // ???\n        this->G[to].push_back(Edge(from, 0, (int)this->G[from].size() - 1));    // ??????\n    }\n\n    // s??????t???????????§???????±??????? O(F|E|)\n    int max_flow(int s, int t) {\n        int flow = 0;\n        while (true) {\n            this->used = vector<bool>(this->num_of_node, 0);\n            int f = dfs(s, t, INT_MAX);\n            if (f == 0) { return flow; }\n            flow += f;\n        }\n    }\n\nprivate:\n    // v??????t???f???????????¨??????????????????\n    int dfs(int v, int t, int f) {\n        if (v == t) { return f; }\n        used[v] = true;\n        for (Edge &e : G[v]) {\n            if (!used[e.to] && e.cap > 0) {\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;                 // ???\n                    G[e.to][e.rev].cap += d;    // ??????\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n};\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    \n    FordFulkerson ff(X + Y + 2);\n    set<int> x_set, y_set;\n    for (int i = 0; i < E; ++i) {\n        int x, y;\n        cin >> x >> y;\n        x_set.insert(x);\n        y_set.insert(y);\n        ff.add_edge(x, y, 1);\n    }\n\n    int source = X + Y + 1;\n    int sink = source + 1;\n\n    for (int x : x_set) {\n        ff.add_edge(source, x, 1);\n    }\n    for (int y : y_set) {\n        ff.add_edge(y, sink, 1);\n    }\n\n    cout << ff.max_flow(source, sink) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<sstream>\n#include<iomanip>\n#include<limits>\n#include<deque>\n#include<map>\n#include<list>\n#include<set>\n#include <unordered_set>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<memory>\n#include<bitset>\n#include<stack>\n#include<functional>\n#include<queue>\n#include<regex>\n#include<time.h>\n#include<type_traits>\n#include<cstdlib>\n#include <utility>\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll MOD = 1000000007;//良く出てくるMOD\nconstexpr ll INF = 1050000000;//intで使うでかい数\nconstexpr ll LONGINF = 1050000000000000000;//longlongで使うでかい数\nconst int nCk_MAX = 510000;//nCkの前計算で使うかもしれない 普段は入ってないよ\nconst int MIN_FLOW_MAX_V = 10000;\n\nstruct all_init {\n\t//初期化のためだけの構造体\n\t//コンストラクタが呼ばれ、cin,cout高速化がされる\n\t//ついでに少数も出力できるようにしている\n\tall_init() {\n\t\tcout.tie(nullptr);\n\t\tcin.tie(nullptr);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(15);\n\t};\n}ALL_INIT;\nstruct edge {\n\t//辺の重みを管理できるような構造体\n\t//コンストラクタによって簡単に値を入れられるようにしている\n\t//operatorは辺の重みでソート出来るようにしている\n\n\tint from, to;\n\tll cost;\n\tll capa;\n\n\tedge(int s, int d) : from(s), to(d) { cost = 0; capa = 0; }\n\tedge(int s, int d, ll w) : from(s), to(d), cost(w) { capa = 0; }\n\tedge(int s, int d, ll x, ll y) :from(s), to(d), cost(x), capa(y) {}\n\n\tbool operator < (const edge& x) const {\n\t\treturn cost < x.cost;\n\t}\n};\n\n#define CIN(vector_array_etc,n) for(int loop=0;loop<n;loop++){cin>>vector_array_etc[loop];}\n#define COUT(vector_array_etc,n) for(int LOOP=0;LOOP<n;LOOP++){cout<<vector_array_etc[LOOP]<<(LOOP == n-1 ?'\\n':' ');}\n#define VC(Type_name) vector<Type_name>//1次元ならあまり意味ないかも\n#define VCVC(Type_name) vector<vector<Type_name>>//2次元配列定義怠過ぎ問題\n#define SORT(vector_etc) sort(vector_etc.begin(),vector_etc.end())\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}//aに最大値が入る\ntemplate<class T>bool chmin(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}//aに最小値が入る\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& Vec) {\n\tfor (T& x : Vec) { is >> x; }\n\treturn is;\n}\ntemplate<typename V, typename H>\nvoid resize(vector<V>& vec, const H head) {\n\tvec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T>\nvoid resize(vector<V>& vec, const H& head, const T ... tail) {\n\tvec.resize(head);\n\tfor (auto& v : vec) { resize(v, tail...); }\n}\n\nint dx[] = { 0,1,-1, 0,1,-1, 1,-1 };    //i<4:4way i<8:8way\nint dy[] = { 1,0, 0,-1,1,-1,-1, 1 };\n\nll PowMod(ll n, ll k, ll mod) {\n\t//繰り返し2乗法\n\t//n^kをmodで求める\n\tll r = 1;\n\n\tfor (; k > 0; k >>= 1) {\n\t\tif (k & 1) {\n\t\t\tr = (r * n) % mod;\n\t\t}\n\t\tn = (n * n) % mod;\n\t}\n\treturn r;\n}\nll Gcd(ll a, ll b) {//最大公約数\n\treturn b != 0 ? Gcd(b, a % b) : a;\n}\nll Lcm(ll a, ll b) {//最小公倍数\n\treturn a / Gcd(a, b) * b;\n}\nbool isPrime(ll n) {\n\t//素数かどうかを判定\n\t//true 素数\n\tif (n < 2)return false;\n\tfor (ll i = 2; i*i <= n; i++)if (!(n%i))return false;\n\treturn true;\n}\nll MergeCount(vector<int> &a) {\n\t//反転数を数える\n\tll count = 0;\n\tint n = a.size();\n\tif (n > 1) {\n\t\tvector<int> b(a.begin(), a.begin() + n / 2);\n\t\tvector<int> c(a.begin() + n / 2, a.end());\n\t\tcount += MergeCount(b);\n\t\tcount += MergeCount(c);\n\t\tfor (int i = 0, j = 0, k = 0; i < n; ++i)\n\t\t\tif (k == c.size())       a[i] = b[j++];\n\t\t\telse if (j == b.size())  a[i] = c[k++];\n\t\t\telse if (b[j] <= c[k])   a[i] = b[j++];\n\t\t\telse { a[i] = c[k++]; count += n / 2 - j; }\n\t}\n\treturn count;\n}\nbool  WarshallFloyd(vector<vector<ll>> &c, int V) {\n\t//ワーシャルフロイド法\n\t//全ての頂点間の最短距離を求める\n\t//falseの時、負の閉路検出\n\tfor (int i = 0; i < V; i++) {\n\t\tc[i][i] = 0;\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tfor (int k = 0; k < V; k++) {\n\t\t\t\tif (c[j][k] > c[j][i] + c[i][k]) {\n\t\t\t\t\tc[j][k] = c[j][i] + c[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tif (c[i][i] < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\n\treturn true;\n}\nvector<ll> Dijkstra(int i, vector<vector<edge>> graph) {\n\t//i:始点\n\t//graph:重み付きグラフ\n\tint n = graph.size();\n\tvector<ll> d(n, LONGINF);\n\td[i] = 0;\n\tpriority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> q;\n\tq.push(make_pair(0, i));//第一引数:コスト 第二引数:頂点\n\twhile (!q.empty()) {\n\t\tpair<ll, int> p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (auto x : graph[v]) {\n\t\t\tif (d[x.to] > d[v] + x.cost) {\n\t\t\t\td[x.to] = d[v] + x.cost;\n\t\t\t\tq.push(make_pair(d[x.to], x.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\nbool BellmanFord(int start, int E, int V, vector<edge> Edge, vector<ll> &d) {\n\t//第一引数:start 始点\n\t//第二引数:E 辺の数\n\t//第三引数:V 頂点数\n\t//第四引数:Edge 辺の重み付きのグラフ\n\t//第五引数:d 各頂点への距離を入れる配列(答えが入る)\n\tfill(d.begin(), d.end(), LONGINF);\n\td[start] = 0;\n\tvector<bool> t(V, false);\n\t/*\n\tfor (int i = 0; i < V - 1; i++) {\n\t\tfor (int j = 0; j < E; j++) {\n\t\t\tedge e = Edge[j];\n\t\t\tif (d[e.from] == LONGINF) { continue; }\n\t\t\tif (d[e.to] > d[e.from] + e.cost) {\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < E; j++) {\n\t\t\tedge e = Edge[j];\n\t\t\tif (d[e.from] == LONGINF) { continue; }\n\t\t\tif (d[e.to] > d[e.from] + e.cost) {\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t\tt[e.to] = true;\n\t\t\t\tif (i == V - 1) {//どこかに閉路があることを感知する\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[e.from]) {\n\t\t\t\tt[e.to] = true;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tif (t[V - 1]) {\n\t//V-1は頂点番号n-1で、始点からn-1までに負の閉路を検出したい場合には、\n\t//コメントアウトを解除すること。\n\t\treturn false;\n\t}\n\t*/\n\treturn true;\n}\nbool TopologicalSort(const vector<vector<edge>> &g, vector<int> &ans) {\n\t//トポロジカルソート\n\t//trueが帰る時、トポロジカルソートが成功し、その結果がansに渡される\n\t//falseはトポロジカルソートの失敗\n\tint n = g.size(), k = 0;\n\tvector<int> ord(n), in(n);\n\tfor (auto &es : g) {\n\t\tfor (auto &e : es) {\n\t\t\tin[e.to]++;\n\t\t}\n\t}\n\tqueue<int> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (in[i] == 0) q.push(i);\n\t}\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tord[k++] = v;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (--in[e.to] == 0) q.push(e.to);\n\t\t}\n\t}\n\tans = ord;\n\tif (*max_element(in.begin(), in.end()) == 0) { return true; }\n\treturn false;\n}\nvector<int> ArticulationNode(const vector<vector<edge>>& g) {\n\t//グラフの関節点を列挙する\n\t//最後の2行で、erace uniqueをしない場合は、その分割によって何個のグラフに分かれるかを判定できる(要チェック)。\n\tint n = g.size(), idx;\n\tvector<int> low(n), ord(n), art;\n\tfunction<void(int)> DFS = [&](int v) {\n\t\tlow[v] = ord[v] = ++idx;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == 0) {\n\t\t\t\tDFS(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t\tif ((ord[v] == 1 && ord[w] != 2) || (ord[v] != 1 && low[w] >= ord[v])) {\n\t\t\t\t\tart.push_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t};\n\tfor (int u = 0; u < n; u++) {\n\t\tif (ord[u] == 0) {\n\t\t\tidx = 0;\n\t\t\tDFS(u);\n\t\t}\n\t}\n\n\tsort(art.begin(), art.end());//与えられた関節点をソート\n\tart.erase(unique(art.begin(), art.end()), art.end());//同じ関節点が複数存在することがある,\n\n\treturn art;\n}\nedge tree_diameter(const vector<vector<edge>> &g) {\n\t//重み付きグラフ(木)を受け取り、その木の直径を求める\n\t//返り値はfrom,to,costを持った構造体\n\n\tint start = 0;//どの始点から始めても良いので、0から始める\n\n\tstatic const auto bfs = [](const vector<vector<edge>> &g, int s, queue<int> &q, vector<ll> &dist) {\n\t\twhile (!q.empty()) { q.pop(); }\n\t\tq.push(s);\n\t\tint n = g.size();\n\t\tdist.assign(n, LONGINF);\n\t\tdist[s] = 0;\n\t\twhile (q.size()) {\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (auto &e : g[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] == LONGINF) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t};\n\tvector<ll> dist;\n\tqueue<int> q;\n\tbfs(g, start, q, dist);\n\tint n = g.size(), u = -1, v = -1;\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i] != LONGINF && (u == -1 || dist[i] > dist[u])) u = i;\n\tbfs(g, u, q, dist);\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i] != LONGINF && (v == -1 || dist[i] > dist[v])) v = i;\n\tll d = dist[v];\n\tif (u > v) swap(u, v);//念のため辞書順\n\treturn edge(u, v, d);\n}\n\nclass UnionFind {\n\t//satanicさん作 UnionFind\n\t//追加機能:forest forestは、全体に含まれる木の数を表す\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\tint forest_num;\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tforest_num = size_;\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 1);\n\t\tforest_num = size_;\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t\tforest_num--;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n\tint forest() {\n\t\treturn forest_num;\n\t}\n};\nclass Dinic {\n\t//最大流を求める\nprivate:\n\tint n, s, t;\n\tvector<int> level, prog, que;\n\tvector<vector<ll>> cap, flow;\n\tvector<vector<int>> g;\n\tll inf;\npublic:\n\tDinic(const vector<vector<edge>> &graph) :\n\t\tn(graph.size()),\n\t\tcap(n, vector<ll>(n)),//\n\t\tflow(n, vector<ll>(n)),\n\t\tg(n, vector<int>()),\n\t\tinf(LONGINF) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (auto &e : graph[i]) {\n\t\t\t\tint u = e.from, v = e.to;\n\t\t\t\tll c = e.capa;\n\t\t\t\tcap[u][v] += c;\n\t\t\t\tcap[v][u] += c;\n\t\t\t\tflow[v][u] += c;\n\t\t\t\tg[u].push_back(v);\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\t}\n\tinline ll residue(int u, int v) { return cap[u][v] - flow[u][v]; }\n\tll solve(int s_, int t_) {\n\t\tthis->t = t_, this->s = s_;\n\t\tque.resize(n + 1);\n\t\tll res = 0;\n\t\twhile (levelize()) {\n\t\t\tprog.assign(n, 0);\n\t\t\tres += augment(s, inf);\n\t\t}\n\t\treturn res;\n\t}\n\tbool levelize() {\n\t\tint l = 0, r = 0;\n\t\tlevel.assign(n, -1);\n\t\tlevel[s] = 0;\n\t\tque[r++] = s;\n\t\twhile (l != r) {\n\t\t\tint v = que[l++];\n\t\t\tif (v == t) break;\n\t\t\tfor (const int &d : g[v])\n\t\t\t\tif (level[d] == -1 && residue(v, d) != 0) {\n\t\t\t\t\tlevel[d] = level[v] + 1;\n\t\t\t\t\tque[r++] = d;\n\t\t\t\t}\n\t\t}\n\t\treturn level[t] != -1;\n\t}\n\tll augment(int v, ll lim) {\n\t\tll res = 0;\n\t\tif (v == t) return lim;\n\t\tfor (int &i = prog[v]; i < (int)g[v].size(); i++) {\n\t\t\tconst int &d = g[v][i];\n\t\t\tif (residue(v, d) == 0 || level[v] >= level[d]) continue;\n\t\t\tconst ll aug = augment(d, min(lim, residue(v, d)));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tres += aug;\n\t\t\tlim -= aug;\n\t\t\tif (lim == 0) break;\n\t\t}\n\t\treturn res;\n\t}\n};\nclass MinimumCostFlow {\nprivate:\n\n\tusing Flow = ll;\n\tusing Cost = ll;\n\tstruct Edge {\n\t\tint d;\n\t\tFlow c, f;\n\t\tCost w;\n\t\tint r, is_r;\n\t\tEdge(int d_, Flow c_, Flow f_, Cost w_, int r_, bool is_r_)\n\t\t\t: d(d_), c(c_), f(f_), w(w_), r(r_), is_r(is_r_) {}\n\t};\n\tint n;\n\tvector<vector<Edge>> g;\n\npublic:\n\n\tMinimumCostFlow(int n_) : n(n_), g(vector<vector<Edge>>(n_)) {}\n\n\tvoid add_edge(int src, int dst, Flow cap, Cost cost) {  // 有向辺\n\t\tint rsrc = g[dst].size();\n\t\tint rdst = g[src].size();\n\t\tg[src].emplace_back(dst, cap, 0, cost, rsrc, false);\n\t\tg[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n\t}\n\n\tCost solve(int s, int t, Flow f) {\n\t\tCost res = 0;\n\n\t\tvector<Cost> h(n + 10), dist(n);\n\t\tvector<int> prevv(n + 10), preve(n + 10);\n\n\t\tusing pcv = pair<Cost, int>;\n\t\tpriority_queue<pcv, vector<pcv>, greater<pcv> > q;\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tfill(dist.begin(), dist.end(), LONGINF);\n\t\t\tdist[s] = 0;\n\t\t\tq.emplace(0, s);\n\t\t\twhile (q.size()) {\n\t\t\t\tCost cd;\n\t\t\t\tint v;\n\t\t\t\ttie(cd, v) = q.top();\n\t\t\t\tq.pop();\n\t\t\t\tif (dist[v] < cd) continue;\n\t\t\t\tfor (int i = 0; i < (int)(g[v].size()); ++i) {\n\t\t\t\t\tEdge &e = g[v][i];\n\t\t\t\t\tif (residue(e) == 0) continue;\n\t\t\t\t\tif (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n\t\t\t\t\t\tdist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n\t\t\t\t\t\tprevv[e.d] = v;\n\t\t\t\t\t\tpreve[e.d] = i;\n\t\t\t\t\t\tq.emplace(dist[e.d], e.d);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dist[t] == LONGINF) return -1;  // 経路が見つからなかった\n\n\t\t\t// s-t 間を最短路に沿って目一杯流す\n\t\t\tfor (int i = 0; i < n; ++i) h[i] += dist[i];\n\t\t\tFlow d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tchmin(d, residue(g[prevv[v]][preve[v]]));\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge &e = g[prevv[v]][preve[v]];\n\t\t\t\te.f += d;\n\t\t\t\tg[v][e.r].f -= d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tFlow residue(const Edge &e) { return e.c - e.f; }\n\n\t// 流量を表示\n\tvoid show() {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < (int)(g[i].size()); ++j) {\n\t\t\t\tEdge &e = g[i][j];\n\t\t\t\tif (e.is_r) continue;\n\t\t\t\tcout << i << \"->\" << e.d << \"(flow:\" << e.f << \")\" << endl;\n\t\t\t}\n\t\t}\n\t}\n};\n\nclass BipartiteMatching {\nprivate:\n\tint V;\n\tvector<int> match;\n\tvector<bool> used;\n\tvector<vector<int>> g;\n\tvector<pair<int, int>> match_pair;\n\n\tbool dfs(int v) {\n\t\tused[v] = true;\n\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\tint u = g[v][i];\n\t\t\tint w = match[u];\n\t\t\tif (w < 0 || !used[w] && dfs(w)) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\tmatch_pair.emplace_back(make_pair(u, v));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\npublic:\n\tBipartiteMatching(int n) {\n\t\tV = n;\n\t\tresize(match, n);\n\t\tresize(used, n);\n\t\tresize(g, n);\n\t}\n\n\tvoid add_edge(int u, int v) {\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\n\tint MatchingSolve() {\n\t\tint res = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\t\t\n\t\tfor (int v = 0; v < V; v++) {\n\t\t\tif (match[v] < 0) {\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tif (dfs(v)) {\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tvector<pair<int,int>> get_pair() {\n\t\tfor (auto x : match_pair) {\n\t\t\tcout << x.first << \"  \" << x.second << endl;\n\t\t}\n\t\treturn match_pair;\n\t}\n\n};\n\n\nint main() {\n\tint X, Y, E; cin >> X >> Y >> E;\n\tBipartiteMatching b(X + Y);\n\tfor (int i = 0; i < E; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tb.add_edge(x, X + y);\n\t}\n\n\tcout << b.MatchingSolve() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// Template Headers {{{\nusing pii = pair<int, int>; using vpii = vector<pii>;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ll = long long; using vll = vector<long long>;\ntemplate <class T> using min_queue = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> istream &operator>>(istream &, vector<T> &);\ntemplate <class T> ostream &operator<<(ostream &, const vector<T> &);\ntemplate <class T, class U> istream &operator>>(istream &, pair<T, U> &);\ntemplate <class T, class U> ostream &operator<<(ostream &, const pair<T, U> &);\ntemplate <class T> struct Inf { static constexpr T inf() { return std::numeric_limits<T>::has_infinity() ? std::numeric_limits<T>::infinty() : std::numeric_limits<T>::max(); } };\ntemplate <> struct Inf<int> { static constexpr int inf() { return 0x3f3f3f3f; } };\ntemplate <> struct Inf<long long> { static constexpr long long inf() { return 0x3f3f3f3f3f3f3f3fLL; } };\nconstexpr int INF = Inf<int>::inf(); constexpr ll BINF = Inf<ll>::inf();\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n// }}}\n// Dinic Maximum Flow {{{\ntemplate <class T>\nclass Dinic {\n\nprivate:\n\n\tstruct edge {\n\t\tint from, to; T cap;\n\t\tedge *rev;\n\t\tedge(int u, int v, T c) : from(u), to(v), cap(c), rev(nullptr) {}\n\t};\n\n\tstatic constexpr T INF = Inf<T>::inf();\n\tstatic constexpr int DINF = Inf<int>::inf();\n\n\tint n, s, t;\n\tstd::vector<std::vector<edge*>> g;\n\npublic:\n\n\tDinic(int n, int s, int t) : n(n), s(s), t(t), g(n) {}\n\t~Dinic() { for (auto v : g) for (edge *e : v) delete e; }\n\n\tvoid addEdge(int u, int v, T c) {\n\t\tedge *in = new edge(u, v, c);\n\t\tedge *out = new edge(v, u, 0);\n\t\tg[u].push_back(in); g[v].push_back(out);\n\t\tin->rev = out; out->rev = in;\n\t}\n\n\tT maxFlow() {\n\t\tT mxf = 0;\n\t\tstd::vector<int> dist(n, DINF), vis(n);\n\t\tstd::function<T(int, T)> dfs = [&] (int u, T fo) -> T {\n\t\t\tif (u == t) return fo;\n\t\t\tfor (;vis[u]<int(g[u].size());vis[u]++) {\n\t\t\t\tedge *e = g[u][vis[u]];\n\t\t\t\tint v = e->to;\n\t\t\t\tif (dist[v] != dist[u] + 1 || e->cap <= 0) continue;\n\t\t\t\tT foo = dfs(v, std::min(fo, e->cap));\n\t\t\t\tif (foo > 0) {\n\t\t\t\t\te->cap -= foo;\n\t\t\t\t\te->rev->cap += foo;\n\t\t\t\t\treturn foo;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t};\n\t\tfor (;;) {\n\t\t\tfor (int i=0;i<n;i++) dist[i] = DINF, vis[i] = 0;\n\t\t\tstd::queue<int> q; q.push(s); dist[s] = 0;\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint u = q.front(); q.pop();\n\t\t\t\tif (u == t) break;\n\t\t\t\tfor (edge *e: g[u]) {\n\t\t\t\t\tint v = e->to;\n\t\t\t\t\tif (e->cap > 0 && dist[v] == DINF) {\n\t\t\t\t\t\tdist[v] = dist[u] + 1;\n\t\t\t\t\t\tq.push(v);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == DINF) break;\n\t\t\twhile (T fo = dfs(s, INF))\n\t\t\t\tmxf += fo;\n\t\t}\n\t\treturn mxf;\n\t}\n\n};\ntemplate <class T> constexpr T Dinic<T>::INF;\ntemplate <class T> constexpr int Dinic<T>::DINF;\n// }}}\n\nint solve() {\n\tint n1, n2, m;\n\tcin >> n1 >> n2 >> m;\n\tDinic<int> g(n1 + n2 + 2, n1 + n2, n1 + n2 + 1);\n\tfor (int i=0;i<m;i++) {\n\t\tint u, v; cin >> u >> v;\n\t\tg.addEdge(u, n1 + v, 1);\n\t}\n\tfor (int i=0;i<n1;i++) g.addEdge(n1 + n2, i, 1);\n\tfor (int i=0;i<n2;i++) g.addEdge(n1 + i, n1 + n2 + 1, 1);\n\tcout << g.maxFlow() << endl;\n\treturn 0;\n}\n\n// Template Main {{{\nint main() {\n\tios::sync_with_stdio(0);\n\t// precompute();\n\t// int t; cin >> t; for (int i=1;i<=t;i++)\n\tsolve();\n\t// cout << \"Case #\" << i << \": \", solve();\n\treturn 0;\n}\n\ntemplate <class T> istream &operator>>(istream &is, vector<T> &v) {\n\tfor (auto it=v.begin();it!=v.end();++it) is >> *it;\n\treturn is;\n}\n\ntemplate <class T> ostream &operator<<(ostream &os, const vector<T> &v) {\n\tfor (auto it=v.begin();it!=v.end();) os << *it, os << \" \\n\"[++it==v.end()];\n\treturn os;\n}\n\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n\treturn is >> p.first >> p.second;\n}\n\ntemplate <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) {\n\treturn os << p.first << ' ' << p.second;\n}\n// }}}\n\n// vim: fdm=marker\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1000000000;\nconst long long int llINF = 1000000000000000000;\nconst double PI = acos(-1.0);\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to;\n    int cost;\n};\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nconst int MAX_EDGE = 200;\n\nvector<int> graph[MAX_EDGE];\nint match[MAX_EDGE];\nbool used[MAX_EDGE];\n\nint V;\n\nvoid add_edge(int from, int to)\n{\n    graph[from].push_back(to);\n    graph[to].push_back(from);\n}\n\nint dfs(int v)\n{\n    used[v] = true;\n    for (int u : graph[v])\n    {\n        int w = match[u];\n        if (w < 0 || !used[w] && dfs(w))\n        {\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint bipartite_maching()\n{\n    int res = 0;\n\n    memset(match, -1, sizeof(match));\n\n    for (int v = 0; v < V; v++)\n    {\n        if(match[v] < 0)\n        {\n            memset(used, 0, sizeof(used));\n            if(dfs(v))\n            {\n                res++;\n            }\n        }\n    }\n\n    return res++;\n}\n\nint main()\n{\n    int X, Y, E;    \n    cin >> X >> Y >> E;\n    V = X + Y;\n\n    rep(i, E)\n    {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, X + y);\n    }\n\n    cout << bipartite_maching() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\n#define MAX_V 200\n#define INF 1e9\n\nint V,match[MAX_V];\nvector<int> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool dfs(int v){\n  used[v] = true;\n  for(int i = 0 ; i < (int)G[v].size() ; i++){\n    int u = G[v][i],w = match[u];\n    if(w < 0 || (!used[w] && dfs(w))){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  memset(match,-1,sizeof(match));\n  for(int v = 0 ; v < V ; v++){\n    if(match[v] < 0){\n      memset(used,false,sizeof(used));\n      if(dfs(v)){ res++; }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int X,Y,E,x,y;\n  cin >> X >> Y >> E;\n  for(int i = 0 ; i < E ; i++){\n    cin >> x >> y;\n    add_edge(x,X+y);\n  }\n  V = X+Y;\n  cout << bipartite_matching() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 二部グラフマッチング\n#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define RREP(i,n) for(long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long i=(a);i>(b);i--)\n#define dump(x)  cerr << #x << \" => \" << (x) << endl\nusing namespace std;\n// to:次の頂点,cap:辺の重み,rev:逆辺のindex\ntemplate<typename Ver,typename Weight>\nclass fordFulkerson {\nprivate:\n\ttypedef struct {Ver to;Weight cap;Ver rev;}edge;\n\tvector<vector<edge>> E;\n\tvector<char> used;\n\tsize_t V;\n\tWeight dfs(Ver node,Ver goal,Weight flow){\n\t\tif (node == goal) return flow;\n\t\tused[node] = 1;\n\t\tREP(i,E[node].size()){\n\t\t\tedge* e = &E[node][i];\n\t\t\tif (!used[e->to] && e->cap != 0){\n\t\t\t\tWeight d = dfs(e->to,goal,min(flow,e->cap));\n\t\t\t\tif (d != 0) {\n\t\t\t\t\te->cap -= d;\n\t\t\t\t\tE[e->to][e->rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\npublic:\n\tfordFulkerson(size_t v) :\n\t\tE(v),used(v,0),V(v){}\n\n\tsize_t size() { return V;}\n\n\tvoid addDirectedEdge(Ver from,Ver to,Weight cap){\n\t\tE[from].push_back({to,cap,(Ver)E[to].size()});\n\t\tE[to].push_back({from,0,(Ver)E[from].size()-1});\n\t}\n\n\tvoid addUndirectedEdge(Ver from,Ver to,Weight cap){\n\t\tE[from].push_back({to,cap,(Ver)E[to].size()});\n\t\tE[to].push_back({from,cap,(Ver)E[from].size()-1});\n\t}\n\n\tWeight maxFlow(Ver start,Ver goal){\n\t\tWeight ans = 0;\n\t\twhile (1){\n\t\t\tREP(i,used.size()) used[i] = 0;\n\t\t\tWeight f = dfs(start,goal,numeric_limits<Weight>::max());\n\t\t\tif (f == 0) return ans;\n\t\t\tans += f;\n\t\t}\n\t}\n};\ntemplate<typename Ver>\nclass BipartiteMatching : public fordFulkerson<Ver,int> {\nprivate:\n\tVer V;\n\tvector<char> connected;\npublic:\n\tBipartiteMatching (Ver v) : V(v),connected(v,0),fordFulkerson<Ver,int>(v+2){}\n\tvoid addEdge(Ver g1,Ver g2) { // g1 : 二部グラフの一方, g2 : 二部グラフの他方\n\t\tfordFulkerson<Ver,int>::addDirectedEdge(g1,g2,1);\n\t\tif (!connected[g1]) {\n\t\t\tfordFulkerson<Ver,int>::addDirectedEdge(V,g1,1);\n\t\t\tconnected[g1] = 1;\n\t\t}\n\t\tif (!connected[g2]) {\n\t\t\tfordFulkerson<Ver,int>::addDirectedEdge(g2,V+1,1);\n\t\t\tconnected[g2] = 1;\n\t\t}\n\t}\n\tVer matching(void) {\n\t\treturn fordFulkerson<Ver,int>::maxFlow(V,V+1);\n\t}\n};\n\nint main() {\n  int X, Y, E;\n  scanf(\"%d %d %d\", &X, &Y, &E);\n  BipartiteMatching<int> bm(X + Y);\n  for(int i = 0; i < E; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    bm.addEdge(a, X + b);\n  }\n  printf(\"%d\\n\", bm.matching());\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = int(A); I < int(B); ++I)\n#define FORR(I,A,B) for(ll I = int((B)-1); I >= int(A); --I)\n#define TO(x,t,f) ((x)?(t):(f))\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //xi>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //xi>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a<b)swap(a,b);if(a%b==0)return b;return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}//saisyo kobaisu\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=1e18+7;\nconst ll MOD=1e9+7;\n \nstruct edge{int to,cap,rev;};\nstruct Maxflow{//ant book p.194\n    vector<vector<edge> > G;\n    vector<int> level,iter;\n    void initsize(int nv){\n        G.resize(nv);\n        level.resize(nv);\n        iter.resize(nv);\n    }\n    void add_edge(int from,int to,int cap){\n        G[from].push_back((edge){to,cap,(int)G[to].size()});\n        G[to].push_back((edge){from,0,(int)G[from].size()-1});\n    }\n    void bfs(int s){\n        fill(level.begin(),level.end(),-1);\n        //memset(level,-1,sizeof(level));\n        queue<int> que;\n        level[s]=0;\n        que.push(s);\n        while( !que.empty() ){\n            int v = que.front();que.pop();\n            for(int i=0;i<G[v].size();i++){\n                edge &e = G[v][i];\n                if(e.cap > 0 && level[e.to]<0){\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    int dfs(int v,int t,int f){\n        if(v==t)return f;\n        for(int &i = iter[v];i<G[v].size();i++){\n            edge &e = G[v][i];\n            if(e.cap>0 && level[v]<level[e.to]){\n                int d = dfs(e.to,t,min(f,e.cap));\n                if(d>0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s,int t){\n        int flow=0;\n        for(;;){\n            bfs(s);\n            if(level[t]<0)return flow;\n            fill(iter.begin(),iter.end(),0);\n            //memset(iter,0,sizeof(iter));\n            int f;\n            while((f=dfs(s,t,INT_MAX))>0){\n                flow += f;\n            }\n        }\n    }\n};\n  \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    Maxflow mf;\n    int X,Y,E;\n    cin>>X>>Y>>E;\n    mf.initsize(X+Y+2);\n    FOR(i,0,E){\n        int x,y;\n        cin >> x >> y;\n        mf.add_edge(x+1,y+X+1,1);\n    }\n    FOR(i,1,X+1){\n      mf.add_edge(0,i,1);\n    }\n    FOR(i,1,Y+1){\n      mf.add_edge(i+X,X+Y+1,1);\n    }\n    cout<<mf.max_flow(0,X+Y+1)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n//\nstruct pair_match{\n\t//\n\tint v;\n\tvector<int> G[100000];\n\tvector<int> match,used;\n\t//\n\tpair_match(int n){\n\t\tv=n;\n\t\tmatch.resize(v);\n\t\tused.resize(v);\n\t}\n\t//\n\tvoid add_edge(int from,int to){\n\t\tG[from].push_back(to);\n\t\tG[to].push_back(from);\n\t}\n\t//\n\tbool DFS(int v){\n\t\tused[v]=true;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint u=G[v][i],w=match[u];\n\t\t\tif(w<0||!used[w]&&DFS(w)){\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t//\n\tint matching(){\n\t\tint res=0;\n\t\tfill(match.begin(),match.end(),-1);\n\t\tfor(int i=0;i<v;i++){\n\t\t\tif(match[i]<0){\n\t\t\t\tfill(used.begin(),used.end(),0);\n\t\t\t\tif(DFS(i)){\n\t\t\t\t\tres++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n//\nint main(){\n\tint X,Y,E;\n\tcin>>X>>Y>>E;\n\tpair_match PM(X+Y);\n\tfor(int i=0;i<E;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tPM.add_edge(x,X+y);\n\t}\n\tcout<<PM.matching()<<endl;\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//                                                                     ███████████   \n//                                                                   ███╬╬╬╬╬╬╬╬╬╬███\n//                                                                ███╬╬╬╬╬╬╬██╬╬╬╬╬╬███\n//                                            ███████████       ██╬╬╬╬╬████╬╬████╬╬╬╬╬██\n//                                      █████████╬╬╬╬╬████████████╬╬╬╬╬██╬╬╬╬╬╬███╬╬╬╬╬██\n//                               ████████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬██╬╬╬╬╬╬╬██\n//                             ████╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████████╬╬╬╬╬╬╬╬╬╬╬██\n//                           ███╬╬╬█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬███╬╬╬╬╬╬╬█████\n//                         ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬████████╬╬╬╬╬██\n//                       ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬╬╬╬╬███\n//                     ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬██\n//                 ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬████\n//     █████████████╬╬╬╬╬╬╬╬██╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬██████\n//   ████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬██████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████╬╬╬╬╬╬╬███████████╬╬╬╬╬╬╬╬██╬╬╬██╬╬╬██\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████╬╬╬╬╬╬╬╬╬╬╬█╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬██\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬▓▓▓▓▓▓╬╬╬████╬╬████╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓▓█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬███\n// ██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██████▓▓▓▓▓▓▓╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬▓▓▓▓▓▓▓▓█╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██╬╬╬╬█████\n// ███╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████████\n//   ███╬╬╬╬╬╬╬╬╬╬╬╬╬█████╬╬╬╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬███╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬██\n//       ██████████████  ████╬╬╬╬╬╬███████████████████████████╬╬╬╬╬██╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬╬████\n//                         ███████                           █████  ███████████████████  \n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n#define INF 1LL<<60\n#define fs first\n#define sc second\n#define pb push_back\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i = (b-1);i>=a;i--)\n#define REP(i,n)  FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) (a)<=(i) && (i)<(b)\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\ntypedef pair<int,int> P;\n//typedef vector<vector<P>> Graph;\n\nconst int MAX_V = 3e5;\nint V;\nvector<int> G[MAX_V],match,used(MAX_V,0);\n\nvoid add_edge(int u, int v){\n  G[u].pb(v);\n  G[v].pb(u);\n}\n\nbool dfs(int v){\n  used[v]++;\n  REP(i,G[v].size()){\n    int u = G[v][i], w = match[u];\n    if(w < 0 || !used[w] && dfs(w)){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching(){\n  int res = 0;\n  match.assign(V,-1);\n  REP(s,V){\n    if(match[s] < 0){\n      used.assign(V,0);\n      if(dfs(s)) res++;\n    }\n  }\n  return res;\n}\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);  \n\n  int x,y,e;\n  cin >> x >> y >> e;\n\n  V = x+y;\n\n  int start = x+y, goal = start+1;\n\n  REP(_,e){\n    int s,t;\n    cin >> s >> t;\n    add_edge(s,x+t);\n  }\n\n  cout << bipartite_matching() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n#include <cstring>          // memset()\n#include <vector>\n\nusing namespace std;\nstatic const int MAX_V = 2 * 100;\n\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\nint V;\n\nbool\ndfs(int v)\n{\n\tused[v] = true;\n\tfor (unsigned int i = 0; i < G[v].size(); ++i)\n\t{\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || (!used[w] && dfs(w)))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint\nbipartite_matching()\n{\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\tfor (int v = 0; v < V; ++v)\n\t{\n\t\tif (match[v] < 0)\n\t\t{\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(v))\n\t\t\t\tres++;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint X, Y, E;\n\tint x, y;\n\n\tscanf(\"%d %d %d\", &X, &Y, &E);\n\tV = X + Y;\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tG[x].push_back(X + y);\n\t\tG[X + y].push_back(x);\n\t}\n\n\tprintf(\"%d\\n\", bipartite_matching());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\n#define PRINT(v) for (auto x : (v)) cout <<x <<\" \" ; cout <<endl;\nusing namespace std;\nusing ll = long long;\nusing Graph = vector<vector<int>>;\nusing mat = vector<vector<ll>>;\nconst ll MOD = 1000000007;\nconst ll INF = 10000000000000000;\nvector<int> x4 = {0, 1, 0, -1}, x8 = {0, 1, 1, 1, 0, -1, -1, -1};\nvector<int> y4 = {1, 0, -1, 0}, y8 = {1, 1, 0, -1, -1, -1, 0, 1};\ntemplate<class T> inline bool chmin(T& a, T b){if (a>b){a = b; return true;}return false;}\ntemplate<class T> inline bool chmax(T& a, T b){if (a<b){a = b; return true;}return false;}\ntemplate<class T> inline T powerM(T a,T b){if (b==0) return 1;\nT tmp = powerM(a,b/2); if (b%2==0) return tmp*tmp%MOD; else return tmp*tmp%MOD*a%MOD; }\ntemplate<class T> inline T power(T a,T b,T m){ if (b==0) return 1;\n  T tmp = power(a,b/2,m); if (b%2==0) return tmp*tmp%m; else return tmp*tmp%m*a%m; }\ntemplate<class T> inline T gcd(T a, T b){if (b==0) return a; return gcd(b, a%b);}\ntemplate<class T> inline T lcm(T a, T b){return a / gcd(a,b) * b;}\n// ax+by=gcd(a,b)を解く\ntemplate<class T> inline T extgcd(T a,T b,T &x,T &y){if (b==0){x=1; y=0; return a;} T d=extgcd(b,a%b,y,x); y -= a/b*x; return d;}\nvoid hey(){ cout <<\"hey\" <<endl; }\n\ntemplate<class T> struct edge { int to; T cost;};\n\n\n// Dinic法：構造体--------------------------------------------\n// 最大流問題に。O( |E||V|^2 ) だが非常に高速に動作することが多い\n// Dinic g(n); してからadd_edge(u, v, c) しまくり\n// 同じやつでverifyはした \n\n// 辺を表す構造体 {行き先, 容量, 逆辺}\nstruct edgeflow {int to,cap,rev; };\n\nstruct Dinic {\n  int V;\n  vector<vector<edgeflow>> G; // グラフの隣接リスト表現\n  vector<int> level; // sからの距離\n  vector<int> iter;  // どこまで調べ終わったか\n\n  Dinic(int n) : G(n), level(n, -1), iter(n, 0) {}\n\n  // fromからtoへ向かう容量capの辺をグラフに追加する\n  void add_edge(int from, int to, int cap){\n    // 割と特殊なやり方をしてる\n    G[from].push_back((edgeflow){to, cap, (int)G[to].size()});\n    G[to].push_back((edgeflow){from, 0, (int)G[from].size() - 1});\n  }\n\n  // sからの最短距離をBFSで計算し、距離が増加する向きの辺のみからなるグラフを作成\n  void bfs(int s) {\n    level.assign(level.size(), -1);\n    queue<int> que;\n    level[s] = 0;   que.push(s);\n    while (!que.empty()) {\n      int v = que.front(); que.pop();\n      for (int i=0; i<G[v].size(); i++){\n        edgeflow &e = G[v][i];\n        if (e.cap > 0 && level[e.to] < 0){\n          level[e.to] = level[v] + 1;\n          que.push(e.to);\n        }\n      }\n    }\n  }\n\n  // 増加パスをDFSで探す\n  int dfs(int v, int t, int f) {\n    if (v == t) return f;\n    for (int &i=iter[v]; i<G[v].size(); i++){\n      edgeflow &e = G[v][i];        // 容量を更新するのでアドレス\n      if (e.cap > 0 && level[v] < level[e.to]){\n        int d = dfs(e.to, t, min(f, e.cap));\n        if (d > 0){\n          e.cap -= d;               // 使った分容量を減らす\n          G[e.to][e.rev].cap += d;  // 使った分逆辺の容量を増やす\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  // sからtへの最大流を求める\n  int max_flow(int s, int t){\n    int flow = 0;\n    while (true){\n      bfs(s);\n      if (level[t] < 0) return flow;\n      iter.assign(iter.size(), 0);\n      int f;\n      while ((f = dfs(s, t, INT_MAX/2)) > 0) flow += f;\n    }\n  }\n};\n\nint main() {\n  int X,Y,E; cin >>X >>Y >>E;\n  Dinic g(X+Y+2);\n  const int ssource = X+Y;\n  const int ssink = X+Y+1;\n  rep(i, X){\n    int x = i;\n    g.add_edge(ssource, x, 1);\n  }\n  rep(i, Y){\n    int y = i + X;\n    g.add_edge(y, ssink, 1);\n  }\n  rep(i, E){\n    int x,y; cin >>x >>y; y += X;\n    g.add_edge(x, y, 1);\n  }\n  int res = g.max_flow(ssource, ssink);\n  cout <<res <<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// author: Saman Mahdanian\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\ntypedef pair <int, int> pii;\n\n#ifdef LOCAL\n\t#define local if (true)\n#else\n\t#define local if (false)\n#endif\n\nconst int N = 1000;\nint nx, ny, m, mxn;\nset <int> g[N];\nbool mark[N];\n\nvoid cerr_vertex (int);\nvoid cerr_graph ();\n\nvector <int> getPath (int, int);\nvoid reversePath (vector <int> &);\n\nint main() {\n\tcin >> nx >> ny >> m;\n\tfor (int i = 0; i < m; i++) {\n\t\tint xi, yi;\n\t\tcin >> xi >> yi;\n\t\tg[xi << 1].insert(yi << 1 | 1);\n\t}\n\tmxn = max(nx << 1, ny << 1 | 1) + 2;\n\n\tfor (int i = 0; i < nx; i++)\n\t\tg[nx << 1].insert(i << 1);\n\tfor (int i = 0; i < ny; i++)\n\t\tg[i << 1 | 1].insert(ny << 1 | 1);\n\n\tint ans = 0;\n\tvector <int> lastPath;\n\tdo {\n\t\tlastPath = getPath(nx << 1, ny << 1 | 1);\n\t\tif (lastPath.empty() == false) {\n\t\t\tans++;\n\t\t\treversePath(lastPath);\n\t\t}\n\t\t\n\t\tlocal {\n\t\t\tcerr << \"iteration#\" << ans << \": \";\n\t\t\tfor (int v: lastPath) \n\t\t\t\tcerr_vertex(v);\n\t\t\tcerr << endl;\n\t\t\tcerr_graph();\n\t\t}\n\t} while (lastPath.empty() == false);\n\tcout << ans << endl;\n}\n\nint __destination;\nvector <int> __path;\nbool getPathDFS (int);\nvector <int> getPath (int s, int t) {\n\t__path.clear();\n\t__destination = t;\n\tfill (mark, mark + mxn, false);\n\tgetPathDFS(s);\n\treverse (__path.begin(), __path.end());\n\treturn __path;\n}\nbool getPathDFS (int v) {\n\tmark[v] = true;\n\tif (v == __destination) {\n\t\t__path.push_back(v);\n\t\treturn true;\n\t}\n\tfor (int u: g[v])\n\t\tif (!mark[u])\n\t\t\tif (getPathDFS(u)) {\n\t\t\t\t__path.push_back(v);\n\t\t\t\treturn true;\n\t\t\t}\n\treturn false;\n}\n\nvoid reversePath (vector <int> &path) {\n\tfor (int i = 0; i < int(path.size()) - 1; i++) {\n\t\tint v = path[i];\n\t\tint u = path[i + 1];\n\t\tg[v].erase(u);\n\t\tg[u].insert(v);\n\t}\n}\n\nvoid cerr_vertex (int v) {\n\tcerr << \"(\" << v << \",\" << ((v & 1)? \"Y\":\"X\") << (v >> 1) << \") \";\n}\n\nvoid cerr_graph () {\n\tcerr << \"Graph_G: \" << endl;\n\tfor (int i = 0; i < mxn; i++) {\n\t\tcerr << \"   \"; \n\t\tcerr_vertex(i);\n\t\tcerr << \": \";\n\t\tfor (int j: g[i])\n\t\t\tcerr_vertex(j);\n\t\tcerr << endl;\n\t}\n\tcerr << endl;\n}\n\n// SamMHD :: Mar6-2019 :: Another For the FIRST Time...\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <iomanip>\n#include <deque>\n#include <stdio.h>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define FILL(Itr,n) fill((Itr).begin(),(Itr).end(),n)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\n#define UNIQUE(Itr) sort((Itr).begin(),(Itr).end()); (Itr).erase(unique((Itr).begin(),(Itr).end()),(Itr).end())\n#define LBOUND(Itr,val) lower_bound((Itr).begin(),(Itr).end(),(val))\n#define UBOUND(Itr,val) upper_bound((Itr).begin(),(Itr).end(),(val))\n#define MOD 1000000007\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntemplate <class T> struct MaxFlow {\n    const T INF = 1e9;\n    struct  Edge {\n        int to,rev; T cap;\n        Edge(){}\n        Edge(int _to, int _rev, T _cap){\n            to = _to; rev = _rev; cap = _cap;\n        }\n    };\n    vector< vector<Edge> > G;\n    vector< bool > used;\n    MaxFlow(int size){\n        G.resize(size+10);\n        used.resize(size+10);\n    }\n    void add_edge(int from, int to, int cap){\n        G[from].push_back(Edge(to,(int)G[to].size(),cap));\n        G[to].push_back(Edge(from,(int)G[from].size()-1,0));\n    }\n    T dfs(int v, int t, T f){\n        if(v==t)return f;\n        used[v] = true;\n        for(int i=0;i<G[v].size();i++){\n            Edge &e = G[v][i];\n            if(!used[e.to] && e.cap>0){\n                T d = dfs(e.to, t, min(f,e.cap));\n                if(d>0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    T getmax(int source, int sink){\n        T flow = 0;\n        while(true){\n            for(int i=0;i<used.size();i++)used[i]=false;\n            T f = dfs(source, sink, INF);\n            if(f==0)return flow;\n            flow += f;\n        }\n    }\n};\n\nint main(){\n    \n    MaxFlow<int> inst(200);\n    \n    int X,Y,E;\n    cin>>X>>Y>>E;\n    \n    set<int> sx,sy;\n    REP(i,E){\n        int x,y; cin>>x>>y;\n        inst.add_edge(x,y,1);\n        sx.insert(x);\n        sy.insert(y);\n    }\n    \n    for(auto itr=sx.begin();itr!=sx.end();itr++){\n        inst.add_edge(150,*itr,1);\n    }\n    \n    for(auto itr=sy.begin();itr!=sy.end();itr++){\n        inst.add_edge(*itr,160,1);\n    }\n    \n    cout<<inst.getmax(150,160)<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct BipartiteMatching {\n  vector<vector<int>> graph;\n  vector<int> match, alive, used;  int timestamp;\n\n  BipartiteMatching(int n){\n    graph=vector<vector<int>>(n);\n    alive=vector<int>(n,1);\n    used=vector<int>(n,0);\n    match=vector<int>(n,-1);\n    timestamp=0;\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int idx) {\n    used[idx] = timestamp;\n    for(auto &to : graph[idx]) {\n      int to_match = match[to];\n      if(alive[to] == 0) continue;\n      if(to_match==-1 || (used[to_match]!=timestamp && dfs(to_match))) {\n        match[idx]=to;  match[to]=idx;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    for(int i=0; i<graph.size(); i++) {\n      if(alive[i]==0) continue;\n      if(match[i]==-1){++timestamp; ret+=dfs(i);}\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      if(i < match[i]) {cout << i << \"-\" << match[i] << endl;}\n    }\n  }\n};\n\nint main() {\n  int X, Y, E;\n  cin >> X >> Y >> E;\n  BipartiteMatching bm(X+Y);\n  for(int i=0; i<E; i++) {\n    int a, b;\n    cin >> a >> b;\n    bm.add_edge(a, X+b);\n  }\n  cout << bm.bipartite_matching() << endl;;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  math2do\n *    created: 21.04.2020 09:55:21 IST\n**/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Graph {\nprivate:\n  int L;\n  int R;\n  vector <vector <int>> adj;\n  vector <int> level;\n  vector <int> mate;\n  bool levelize();\n  bool dfs(int u);\n\npublic:\n  Graph(int L, int R);    \n  void addEdge(int u, int v);\n  int matching(); \n};\n\nGraph::Graph(int L, int R) {\n  this->L = L;\n  this->R = R;\n  adj.resize(L + R);\n  level.resize(L);\n  mate.resize(L + R);\n}\n\n\nvoid Graph::addEdge(int u, int v) {\n  adj[u].push_back(v + L);\n  adj[v + L].push_back(u);\n}\n\nbool Graph::levelize() {\n  queue <int> q;\n  for (int u = 0; u < L; u++) {\n    level[u] = -1;\n    if (mate[u] == -1) {\n      level[u] = 0;\n      q.push(u);\n    }\n  }\n         \n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n\n    for (int w : adj[u]) {\n      int v = mate[w];\n      if (v == -1) {\n        return true;\n      }\n\n      if (level[v] == -1) {\n        level[v] = level[u] + 1;\n        q.push(v);\n      } \n    }\n  }\n  return false;\n}\n\nbool Graph::dfs(int u) {\n  for (int w : adj[u]) {\n    int v = mate[w];\n    if (v == -1 || (level[v] == level[u] + 1 && dfs(v))) {\n      mate[u] = w;\n      mate[w] = u;\n      return true;\n    }\n  }\n\n  return false;\n}\n\nint Graph::matching() {\n  int match = 0;\n  fill(mate.begin(), mate.end(), -1);\n\n  while (levelize()) {\n    for (int u = 0; u < L; u++) {\n      if (mate[u] == -1 && dfs(u)) {\n        match++;\n      }\n    }\n  }\n  return match; \n} \n\nint main() {\n  int L, R, E;\n  cin >> L >> R >> E;\n  int u, v; \n  Graph g(L, R);\n  for (int i = 0; i < E; i++) {\n    cin >> u >> v;\n    g.addEdge(u, v);\n  }\n  cout << g.matching() << '\\n';\n  return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(st, itr) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\ntemplate <typename T>\nstruct edge {int to; T cap; int rev;};\n\ntemplate <typename T>\nstruct Graph_ {\n  int n;\n  vector<bool> used;\n  vector<vector<edge<T>> > vec;\n  Graph_(){}\n  Graph_(int ns) {\n    n = ns;\n    used.resize(n);\n    vec.resize(n);\n  }\n  void adde(int at, int to, T cap){\n    vec[at].pb((edge<T>){to, cap, (int)vec[to].size()});\n    vec[to].pb((edge<T>){at, 0, (int)vec[at].size() - 1});\n  }\n  T dfs(int s, int t, T f){\n    if(s == t)return f;\n    used[s] = true;\n    for(int i = 0; i < vec[s].size(); i++){\n      edge<T> &e = vec[s][i];\n      if(!used[e.to] && e.cap > 0){\n        int d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0){\n          e.cap -= d;\n          vec[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  T min_cut(int s, int t){\n    return max_flow(s, t);\n  }\n  T max_flow(int s, int t){\n    T inf = numeric_limits<T>::max();\n    T flow = 0;\n\n    while(true){\n      fill(used.begin(), used.end(), false);\n      int f = dfs(s, t, inf);\n      if(f == 0)return flow;\n      flow += f;\n    }\n  }\n};\n\ntypedef Graph_<int> GraphI;\ntypedef Graph_<ll> GraphL;\n\nstruct BGraph{\n  int n, m;\n  GraphI graph;\n  BGraph(int n, int m): n(n), m(m){\n    graph = GraphI(n + m + 2);\n    for(int i = 0; i < n; i++){\n      graph.adde(0, get_left_index(i), 1);\n    }\n    for(int i = 0; i < m; i++){\n      graph.adde(get_right_index(i), n + m + 1, 1);\n    }\n  }\n  int get_left_index(int i){\n    return i + 1;\n  }\n  int get_right_index(int i){\n    return i + n + 1;\n  }\n  void adde(int at, int to){\n    graph.adde(get_left_index(at), get_right_index(to), 1);\n  }\n  int maximum_matching(){\n    return graph.max_flow(0, n + m + 1);\n  }\n};\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m, e;\n  cin >> n >> m >> e;\n  BGraph graph(n, m);\n  rep(i, e){\n    int x, y;\n    cin >> x >> y;\n    graph.adde(x, y);\n  }\n  cout << graph.maximum_matching() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <iomanip>\n#include <deque>\n#include <stdio.h>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define FILL(Itr,n) fill((Itr).begin(),(Itr).end(),n)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\n#define UNIQUE(Itr) sort((Itr).begin(),(Itr).end()); (Itr).erase(unique((Itr).begin(),(Itr).end()),(Itr).end())\n#define LBOUND(Itr,val) lower_bound((Itr).begin(),(Itr).end(),(val))\n#define UBOUND(Itr,val) upper_bound((Itr).begin(),(Itr).end(),(val))\n#define MOD 1000000007\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntemplate <class T> struct MaxFlow {\n    const T INF = 1e9;\n    struct  Edge {\n        int to,rev; T cap;\n        Edge(){}\n        Edge(int _to, int _rev, T _cap){\n            to = _to; rev = _rev; cap = _cap;\n        }\n    };\n    vector< vector<Edge> > G;\n    vector< bool > used;\n    MaxFlow(int size){\n        G.resize(size+10);\n        used.resize(size+10);\n    }\n    void add_edge(int from, int to, int cap){\n        G[from].push_back(Edge(to,(int)G[to].size(),cap));\n        G[to].push_back(Edge(from,(int)G[from].size()-1,0));\n    }\n    T dfs(int v, int t, T f){\n        if(v==t)return f;\n        used[v] = true;\n        for(int i=0;i<G[v].size();i++){\n            Edge &e = G[v][i];\n            if(!used[e.to] && e.cap>0){\n                T d = dfs(e.to, t, min(f,e.cap));\n                if(d>0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    T getmax(int source, int sink){\n        T flow = 0;\n        while(true){\n            for(int i=0;i<used.size();i++)used[i]=false;\n            T f = dfs(source, sink, INF);\n            if(f==0)return flow;\n            flow += f;\n        }\n    }\n};\n\nint main(){\n    \n    MaxFlow<int> inst(200);\n    \n    int X,Y,E;\n    cin>>X>>Y>>E;\n    \n    set<int> sx,sy;\n    REP(i,E){\n        int x,y; cin>>x>>y;\n        inst.add_edge(x,y,1);\n        sx.insert(x);\n        sy.insert(y);\n    }\n    \n    for(auto itr=sx.begin();itr!=sx.end();itr++){\n        inst.add_edge(150,*itr,1);\n    }\n    \n    for(auto itr=sy.begin();itr!=sy.end();itr++){\n        inst.add_edge(*itr,160,1);\n    }\n    \n    cout<<inst.getmax(150,160)<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nbool match(int cur,bool arr[],bool V[],int npair[], int column){\n    if(cur < 0){\n        return true;\n    }\n    if(V[cur]){\n        return false;\n    }\n    V[cur] = true;\n    for(int i = 0; i < column; i++){\n        if(!arr[cur*column + i]){\n            continue;\n        }\n        if(match(npair[i],arr,V,npair,column)){\n            npair[i] = cur;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n    int row,column,E;\n    scanf(\"%d %d %d\",&row,&column,&E);\n    bool arr[row*column],V[row];\n    for(int ei = 0; ei < E; ei++){\n        int from,to;\n        scanf(\"%d %d\",&from,&to);\n        arr[from*column + to] = true;\n    }\n    int npair[column],count = 0;\n    for(int i = 0; i < column; i++){\n        npair[i] = -1;\n    }\n    for(int cur = 0; cur < row; cur++){\n        for(int i = 0; i < row; i++){\n            V[i] = false;\n        }\n        if(match(cur,arr,V,npair,column)){\n            count++;\n        }\n    }\n    printf(\"%d\\n\",count);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000\n#define MAX_V 202\n#define MAX_E 1000\nusing namespace std;\nstruct edge {\n\tint to, cap, rev;\n\tedge(int to_, int cap_, int rev_) : to(to_), cap(cap_), rev(rev_) {};\n};\n\nint V, E;\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid AddEdge(int from, int to, int cap) {\n\tG[from].push_back(edge(to, cap, G[to].size()));\n\tG[to].push_back(edge(from, 0, G[from].size() - 1));\n}\n\nvoid BFS(int s) {\n\tfill(level, level + V, -1);\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint v = que.front(); que.pop();\n\t\tfor (size_t i = 0; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint DFS(int v, int t, int f) {\n\tif (v == t) return f;\n\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\tint d = DFS(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint Dinic(int s, int t) {\n\tint flow = 0;\n\twhile (true) {\n\t\tBFS(s);\n\t\tif (level[t] < 0) return flow;\n\t\tfill(iter, iter + V, 0);\n\t\tint f;\n\t\twhile ((f = DFS(s, t, INF)) > 0) {\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint X, Y;\n\tcin >> X >> Y >> E;\n\tV = X + Y + 2;\n\tfor (int i = 0; i < X; i++) {\n\t\tAddEdge(X + Y, i, 1);\n\t}\n\tfor (int i = 0; i < Y; i++) {\n\t\tAddEdge(i, X + Y + 1, 1);\n\t}\n\tfor (int i = 0, x, y; i < E; i++) {\n\t\tcin >> x >> y;\n\t\tAddEdge(x, X + y, 1);\n\t}\n\tcout << Dinic(X + Y, X + Y + 1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\n///------------------- O(|V|*|E|) -------------------///\nstruct hungarian_bipartite {\n    int l, r;\n    vector< vector<int> > g;\n    vector<bool> seen;\n    vector<int> match; /// match[i] is the left matching of right node i\n    hungarian_bipartite(int l, int r) : l(l), r(r), seen(l), match(l+r, -1), g(l+r) {}\n    /// [0-l) left, [l, r) right\n    /// a and b are 0-indexed\n    void add_edge(int a, int b) {\n        g[a].push_back(l+b);\n        g[l+b].push_back(a);\n    }\n    bool go(int u) {\n        if(seen[u]) return false;\n        seen[u] = true;\n        for(int i = 0; i < g[u].size(); i++) {\n            int v = g[u][i];\n            if(match[v] == -1 || go(match[v])) {\n                match[v] = u;\n                return true;\n            }\n        }\n        return false;\n    }\n    int max_matching() {\n        int ans = 0;\n        for(int i = 0; i < l; i++) {\n            fill(seen.begin(), seen.end(), false);\n            ans += go(i);\n        }\n        return ans;\n    }\n};\n\n\n\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  #ifdef Larra\n  freopen(\"in\",\"r\",stdin);\n  freopen(\"out\",\"w\",stdout);\n  #endif\n  int n1, n2, m;\n  cin>>n1>>n2>>m;\n  hungarian_bipartite hp(n1, n2);\n  for(int i = 0; i < m; i++){\n      int u,v;\n      cin>>u>>v;\n      hp.add_edge(u, v);\n  }\n  cout<<hp.max_matching()<<\"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 2222\nvector<int> v[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int a,int b){\n\tv[a].PB(b);\n\tv[b].PB(a);\n}\n\nbool matchdfs(int a){\n\tused[a] = true;\n\tfor(int i = 0;i < v[a].size();i++)\t{\n\t\tint u = v[a][i],w = match[u];\n\t\tif(w < 0 || !used[w] && matchdfs(w)){\n\t\t\tmatch[u] = a;\n\t\t\tmatch[a] = u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//二部マッチング\nint two_matching_max(int l){\n\tint res = 0;\n\tmemset(match,-1,sizeof(match));\n\tREP(v,l){\n\t\tif(match[v] < 0){\n\t\t\tmemset(used,0,sizeof(used));\n\t\t\tif(matchdfs(v))res++;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\t\n\tint x, y, e;cin >> x >> y >> e;\n\t\n\tREP(i,e){\n\t\tint a, b;cin >> a >> b;\n\t\tb += x;\n\t\tadd_edge(a, b);\n\t}\n\t\n\tcout << two_matching_max(x + y) << endl;\n\t\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// statics\nusing namespace std;\nusing int64 = long long;\nusing PAIR = pair<int, int>;\nconstexpr int INF = 1 << 30;\nconstexpr int64 LINF = 1LL << 60;\nconstexpr int MOD = 1e9 + 7;\nconstexpr int MAX_N = 1e5 + 1;\nconstexpr int MAX_V = 575;\n\n// init/input\n#define int int64\n#define INIT ios::sync_with_stdio(false);cin.tie(0);\n#define VAR(type, ...) type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T &t) {cin>>t;}\ntemplate<typename First, typename...Rest> void MACRO_VAR_Scan(First &first, Rest&...rest) {cin>>first;MACRO_VAR_Scan(rest...);}\n#define VEC(type, c, n) vector<type> c(n);for(auto &&i:c)cin>>i;\n\n// out\n#define OUT(dist) cout<<(dist);\n#define FOUT(n, dist) cout <<fixed<<setprecision(n)<<(dist);\n#define SP cout<<\" \";\n#define BR cout<<\"\\n\";\n#define debug(x) cerr << #x << \":\" << (x);BR;\n\n// utility\n#define ALL(a) (a).begin(), (a).end()\n#define EACH(i, a) for(auto &&i:(a))\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=0;--i)\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n\nint V;\nvector< int > G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to) {\n  G[from].push_back(to);\n  G[to].push_back(from);\n}\n\nint dfs(int v) {\n  used[v] = true;\n\n  for (int i = 0; i < (int)G[v].size(); ++i) {\n    int to = G[v][i], w = match[to];\n    if (w < 0 || !used[w] && dfs(w)) {\n      match[v] = to;\n      match[to] = v;\n      return true;\n    }\n  }\n}\n\nsigned main() {\n  INIT;\n\n  VAR(int, X, Y, E);\n  REP(ei, E) {\n    VAR(int, from, to);\n    add_edge(from, X + to);\n  }\n  V = X + Y;\n\n  // 二部グラフの最大マッチング\n  auto bipartie_matching = []() {\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for (int v = 0; v < V; ++v) {\n      if (match[v] < 0) {\n\tmemset(used, 0, sizeof(used));\n\tif (dfs(v) > 0) {\n\t  res++;\n\t}\n      }\n    }\n    return res;\n  };\n  \n  OUT(bipartie_matching());\n\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct BipartiteMatching {\n  vector< vector< int > > graph;\n  vector< int > match, alive, used; int timestamp;\n\n  BipartiteMatching(int n){\n    graph=vector<vector<int>>(n);\n    alive=vector<int>(n,1);\n    used=vector<int>(n,0);\n    match=vector<int>(n,-1);\n    timestamp=0;\n  }\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int idx) {\n    used[idx] = false;\n    for(auto &to : graph[idx]) {\n      int to_match = match[to];\n      if(alive[to] == 0) continue;\n      if(to_match == -1 || (used[to_match] && dfs(to_match))) {\n        match[idx] = to;\n        match[to] = idx;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      if(i < match[i]) {\n        cout << i << \"-\" << match[i] << endl;\n      }\n    }\n  }\n};\nint main() {\n  int X, Y, E;\n  cin >> X >> Y >> E;\n  BipartiteMatching bm(X + Y);\n  for(int i = 0; i < E; i++) {\n    int a, b;\n    cin >> a >> b;\n    bm.add_edge(a, X + b);\n  }\n  cout << bm.bipartite_matching() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = l;x<u;x++)\n#define RREP(x,l,u) for(ll x = l;x>=u;x--)\n#define complete_unique(a) a.erase(unique(a.begin(),a.end()),a.end())\n#define mst(x,a) memset(x,a,sizeof(x))\n#define all(a) a.begin(),a.end()\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n#define lson (ind<<1)\n#define rson (ind<<1|1)\n#define se second\n#define fi first\n#define sz(x) ((int)x.size())\n#define EX0 exit(0);\n\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\ntypedef vector<ll> VLL;\ntypedef vector<int> VI;\nconst int block_size = 320;\ntypedef complex<ll> point;\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e9 + 7;\nconst ll INF = 1e15;\nconst ld eps = 1e-9;\nconst db PI = atan(1) * 4;\n\ntemplate<typename T, typename S>inline bool upmin(T&a, const S&b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T, typename S>inline bool upmax(T&a, const S&b) { return a < b ? a = b, 1 : 0; }\n\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a%b); }\nll pow(ll a, ll b) {\n\tif (b == 0) {\n\t\treturn 1;\n\t}\n\tif (b == 1) {\n\t\treturn a;\n\t}\n\tll ans = pow(a, b / 2);\n\tans *= ans;\n\tans *= b % 2 == 1 ? a : 1;\n\treturn ans;\n}\n\n#define MAXN 202\n#define SOURCE 0\n#define SINK 201\n\n\nnamespace SOLVE {\n\tint X, Y, E;\n\tint visited[MAXN] = { 0 };\n\tint parent[MAXN] = { 0 };\n\tint adjmatrix[MAXN][MAXN] = { 0 };\n\t\n\tvoid bfs(int v) {\n\t\tvisited[v] = 1;\n\t\tREP(i, 0, MAXN) {\n\t\t\tif (!visited[i] && adjmatrix[v][i] > 0) {\n\t\t\t\tparent[i] = v;\n\t\t\t\tbfs(i);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvoid main() {\n\t\tint a, b, c;\n\t\tcin >> X >> Y >> E;\n\n\t\tREP(i, 0, X) {\n\t\t\tadjmatrix[SOURCE][i + 1] = 1;\n\t\t}\n\t\tREP(i, 0, Y) {\n\t\t\tadjmatrix[i + 101][SINK] = 1;\n\t\t}\n\t\tREP(i, 0, E) {\n\t\t\tcin >> a >> b;\n\t\t\tadjmatrix[a + 1][b + 101] = 1;\n\n\t\t}\n\t\tint ans = 0;\n\n\t\twhile (1) {\n\t\t\tmemset(visited, 0, sizeof(visited));\n\t\t\tmemset(parent, 0, sizeof(visited));\n\t\t\tbfs(0);\n\t\t\tif (!visited[SINK]) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint flow = 1e9;\n\t\t\t// go backwards, see the minimum flow\n\t\t\tfor (int v = SINK; v != SOURCE; v = parent[v]) {\n\t\t\t\tflow = min(flow, adjmatrix[parent[v]][v]);\n\t\t\t}\n\t\t\t// go backwards and subtract the flow from all the edges. also add the flow to the reverse edge.\n\t\t\tfor (int v = SINK; v != SOURCE; v = parent[v]) {\n\t\t\t\tadjmatrix[parent[v]][v] -= flow;\n\t\t\t\tadjmatrix[v][parent[v]] += flow;\n\t\t\t}\n\t\t\tans += flow;\n\t\t}\n\t\tcout << ans << endl;\n\n\t\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tint t;\n\t//    in(t);\n\tt = 1;\n\twhile (t--) {\n\t\tSOLVE::main();\n\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(const auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) {cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl;}\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}\nbool operator<(const TRI&_)const{return(fi==_.fi)?((se==_.se)?(th<_.th):(se<_.se)):(fi<_.fi);}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll,ll> pll;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nclass BM {\nprivate:\n    const int U, V;\n    vector<vector<int> > G;\n    vector<int> level, que, ralloc;\npublic:\n    BM(const int u, const int v)\n         : U(u), V(v), G(U + V), level(U + V), que(U + V), ralloc(V, -1), alloc(U, -1){}\n    void add_edge(const int from, const int to){\n        G[from].push_back(U + to);\n    }\n    bool bfs(){\n        bool res = false;\n        fill(level.begin(), level.end(), -1);\n        int qh = 0, qt = 0;\n        for(int i = 0; i < U; ++i){\n            if(alloc[i] < 0) level[i] = 0, que[qt++] = i;\n        }\n        while(qh < qt){\n            const int u = que[qh++];\n            if(u >= U){\n                const int v = ralloc[u - U];\n                if(v >= 0){\n                    level[v] = level[u] + 1, que[qt++] = v;\n                }else{\n                    res |= true;\n                }\n            }else{\n                for(const int v : G[u]){\n                    if(level[v] < 0){\n                        level[v] = level[u] + 1, que[qt++] = v;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n    bool dfs(const int u){\n        const int tmp = level[u];\n        level[u] = -1;\n        if(u >= U){\n            if(ralloc[u - U] < 0) return true;\n            else return dfs(ralloc[u - U]);\n        }else{\n            for(const int v : G[u]){\n                if(tmp < level[v]){\n                    if(dfs(v)){\n                        alloc[u] = v - U, ralloc[v - U] = u;\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    // alloc に左側頂点がどの右側頂点とマッチングされるかが格納される\n    vector<int> alloc;\n    int solve(){\n        int flow = 0;\n        for(;;){\n            if(!bfs()) break;\n            for(int i = 0; i < U; ++i){\n                if(alloc[i] < 0) flow += dfs(i);\n            }\n        }\n        return flow;\n    }\n    // solve() を呼び出した後に呼び出す(左側頂点 i の添字は U(右側頂点数) + i とする)\n    vector<int> minimum_vertex_cover(){\n        vector<int> mvc;\n        for(int i = 0; i < U; ++i){\n            if(level[i] < 0) mvc.push_back(i);\n        }\n        for(int i = U; i < U + V; ++i){\n            if(level[i] >= 0) mvc.push_back(i);\n        }\n        return mvc;\n    }\n};\n\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n\ninline int in() {\n    int n = 0; short c;\n    while ((c = getchar()) >= '0') n = n * 10 + c - '0';\n    return n;\n}\n\ninline void out(int n) {\n    short res[10], i = 0;\n    do { res[i++] = n % 10, n /= 10; } while (n);\n    while (i) putchar(res[--i] + '0');\n}\n\nint main()\n{\n    int L, R, m, u, v;\n    L = in(), R = in(), m = in();\n    BM bm(L, R);\n    rep(i,m){\n        u = in(), v = in();\n        bm.add_edge(u, v);\n    }\n    const int res = bm.solve();\n    out(res);\n    putchar('\\n');\n    const auto& ch = bm.minimum_vertex_cover();\n    assert(res == (int)ch.size());\n    // rep(i,L){\n    //     if(bm.alloc[i] >= 0){\n    //         out(i), putchar(' '), out(bm.alloc[i]), putchar('\\n');\n    //     }\n    // }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n    edge() {}\n    edge(int t, int c, int r) : to(t), cap(c), rev(r) {}\n};\nconst int MAX_V = 500;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size()-1));\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge& e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        for (int i = 0; i < MAX_V; i++) used[i] = false;\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(void) {\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    int s = X+Y, t = s+1;\n    for (int i = 0; i < E; i++) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, y+X, 1);\n    }\n    for (int i = 0; i < X; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        add_edge(i+X, t, 1);\n    }\n    cout << max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int INF=0x3f3f3f3f;\nconst int maxn=205;\n\nstruct edge{int to,cap,rev;};\n\nint x,y,m,s,t;\nint iter[maxn];\nint level[maxn];\nbool built[maxn];\nvector<edge>G[maxn];\n\nvoid add_edge(int u,int v,int c) {\n\tG[u].pb(edge{v,c,int(G[v].size())});\n\tG[v].pb(edge{u,0,int(G[u].size()-1)});\n}\n\nbool bfs() {\n\tmemset(level,0,sizeof(level));\n\tlevel[s]=1;\n\tint qh=0,qt=0,q[maxn];\n\tq[qt++]=s;\n\twhile (qh!=qt) {\n\t\tint u=q[qh++];\n\t\tfor (edge e:G[u]) {\n\t\t\tif (!level[e.to] && e.cap) {\n\t\t\t\tlevel[e.to]=level[u]+1;\n\t\t\t\tif (level[t]) break;\n\t\t\t\tq[qt++]=e.to;\n\t\t\t}\n\t\t}\n\t\tif (level[t]) break;\n\t}\n\treturn level[t];\n}\n\nint dfs(int u,int f) {\n\tif (!f) return 0;\n\tif (u==t) return f;\n\tfor (int& i=iter[u];i<G[u].size();i++) {\n\t\tedge& e=G[u][i];\n\t\tif (level[e.to]>level[u] && e.cap) {\n\t\t\tint d=dfs(e.to,min(f,e.cap));\n\t\t\tif (d) {\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dinic() {\n\tint res=0;\n\twhile (bfs()) {\n\t\tmemset(iter,0,sizeof(iter));\n\t\twhile (int flow=dfs(s,INF))\n\t\t\tres+=flow;\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin>>x>>y>>m; s=0; t=x+y+1;\n\tfor (int i=0;i<m;i++) {\n\t\tint u,v; cin>>u>>v;\n\t\tu++; v+=1+x;\n\t\tadd_edge(u,v,1);\n\t\tif (!built[u]) {\n\t\t\tbuilt[u]=1;\n\t\t\tadd_edge(s,u,1);\n\t\t}\n\t\tif (!built[v]) {\n\t\t\tbuilt[v]=1;\n\t\t\tadd_edge(v,t,1);\n\t\t}\n\t}\n\tcout<<dinic()<<'\\n';\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<sstream>\n#include<iomanip>\n#include<utility>\n#include<cmath>\n#include<set>\n#include<list>\n#include<string>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<map>\n#include<set>\n#include<cstring>\n#include<iterator>\n#include<bitset>\n#include<assert.h>\n//#include<unistd.h>\n//#include<chrono>\n//#include<time.h>\n//#include<windows.h>\nusing namespace std;\n \n//#define int ll\ntypedef long long ll;\nstatic const int MOD = 1000000007;\n//static const int INF = 2147483647;\n//static const long long INF = 9223372000000000000;\n//static const long long INF = 9223372000000000000/2;\n//static const int INF = 1000010000;\n//int dx4[4] = {0,1,0,-1}, dy4[4] = {-1,0,1,0};\n//int dx5[5] = {-1,0,0,0,1}, dy5[5] = {0,-1,0,1,0};\n//int dx8[8] = {-1,0,1,1,1,0,-1,-1}, dy8[8] = {1,1,1,0,-1,-1,-1,0};\n//int dx9[9] = {-1,0,1,1,1,0,-1,-1,0}, dy9[9] = {1,1,1,0,-1,-1,-1,0,0};\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define FI first\n#define SE second\n#define NP next_permutation\n#define PQ priority_queue\n#define UB upper_bound\n#define LB lower_bound\n#define SZ(a) int((a).size())\n#define LEN(a) int((a).length())\n#define SORT(c) sort((c).begin(),(c).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REP1(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREP1(i,x) for(int i=((int)(x));i>0;i--)\n#define ALL(x) (x).begin(),(x).end()\n#define YESNO(x) puts((x)?\"YES\":\"NO\")\n\nstruct Bipartite_Matching\n{\n  vector< vector< int > > graph;\n  vector< int > match, alive, used;\n  int timestamp;\n \n  Bipartite_Matching(int n)\n  {\n    timestamp = 0;\n    graph.resize(n);\n    alive.assign(n, 1);\n    used.assign(n, 0);\n    match.assign(n, -1);\n  }\n \n  void add_edge(int u, int v)\n  {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n \n  bool dfs(int v)\n  {\n    used[v] = timestamp;\n    for(int i = 0; i < graph[v].size(); i++) {\n      int u = graph[v][i], w = match[u];\n      if(alive[u] == 0) continue;\n      if(w == -1 || (used[w] != timestamp && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return (true);\n      }\n    }\n    return (false);\n  }\n \n  int bipartite_matching()\n  {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return (ret);\n  } \n};\n\n\nsigned main(){\n    int x,y,e;\n    cin >> x >> y >> e;\n    Bipartite_Matching graph(x+y);\n    REP(i,e){\n        int a,b;\n        cin >> a >> b;\n        graph.add_edge(a, b + x);\n    }\n    cout << graph.bipartite_matching() << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n#define INF 1<<29\n\ntemplate <typename T>\nstruct BipartiteMatching {\n  struct Edge {\n    int to, rev; T cap;\n    Edge(int to, int rev, T cap) : to(to), rev(rev), cap(cap) { }\n  };\n\n  typedef vector<Edge> Edges;\n  vector<Edges> G;\n  int V, source, sink;\n  vector<int> level, iter;\n  \n  BipartiteMatching(int V1, int V2) {\n    V = V1 + V2 + 2, source = V-2, sink = V-1;\n    G.resize(V);\n    add_sink_source(V1, V2);\n  }\n\n  void add_edge(int from, int to) {\n    G[from].push_back(Edge(to, (int)G[to].size(), 1));\n    G[to].push_back(Edge(from, (int)G[from].size()-1, 0));\n  }\n\n  void add_sink_source(int V1, int V2) {\n    for (int i = 0; i < V1; i++) add_edge(source, i);\n    for (int i = V1; i < V1+V2; i++) add_edge(i, sink);\n  }\n\n  void bfs(int source) {\n    level.assign(V, -1);\n    queue<int> que;\n    que.push(source);\n    level[source] = 0;\n    while (!que.empty()) {\n      int v = que.front(); que.pop();\n      for (int i = 0; i < (int)G[v].size(); i++) {\n\tEdge &e = G[v][i];\n\tif (e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n\n  T dfs(int v, int sink, T flow) {\n    if (v == sink) return flow;\n    for (int &i = iter[v]; i < (int)G[v].size(); i++) {\n      Edge &e = G[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n\tT d = dfs(e.to, sink, min(e.cap, flow));\n\tif (d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n\n  T dinic() {\n    T flow = 0;\n    while (true) {\n      bfs(source);\n      if (level[sink] < 0) return flow;\n      iter.assign(V, 0);\n      T f;\n      while ((f = dfs(source, sink, INF)) > 0) {\n\tflow += f;\n      }\n    }\n  }\n};\n\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int X, Y, E;\n  cin >> X >> Y >> E;\n  BipartiteMatching<int> bp(X, Y);\n  REP(i, E) {\n    int x, y;\n    cin >> x >> y;\n    bp.add_edge(x, X+y);\n  }\n  cout << bp.dinic() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <stdlib.h>\n#include <functional>\n#include <string>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#include <nmmintrin.h>\n#include <chrono>\nconst double EPS = 1e-8;\n#define Scan(a) int a;scanf(\"%d\", &a);\n#define ScanS(a) char a[500];scanf(\"%s\", a);\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1LL)\n#define bitset(a,b)      ( a |= (1LL << b))\n#define bitunset(a,b)    (a &= ~(1LL << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#ifdef _MSC_VER\n#define __builtin_popcount _mm_popcnt_u32\n#define __builtin_popcountll _mm_popcnt_u64\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*)array, (T*)(array + N), val);\n}\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\npii Dir[8] = {\n\t{ 0 ,1 },{ -1 ,0 },{ 1 ,0 },{ 0 ,-1 },\n\t{ 1 ,1 },{ 1 ,-1 },{ -1 ,1 },{ -1 ,-1 }\n};\n\n\npii operator+(pii obj, pii obj2) {\n\treturn MP(obj.first + obj2.first, obj.second + obj2.second);\n}\npii operator-(pii obj, pii obj2) {\n\treturn MP(obj.first - obj2.first, obj.second - obj2.second);\n}\nclass Graph {\npublic:\n\tint vn;\n\tint sumcost = 0;\n\tvector<vector<pii>> g;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvirtual void con(int a, int b, int w) = 0;\n\tint getWeight(int f, int t) {\n\t\tauto itr = lower_bound(ALL(g[f]), make_pair(t, INT_MIN));\n\t\tif (itr != g[f].end())\n\t\t\treturn itr->second;\n\t\treturn INT_MIN;\n\t}\n\tint Costsum() {\n\t\treturn sumcost;\n\t}\n\tvoid scan(int edcount, bool oindexed, bool w) {\n\t\tREP(i, edcount) {\n\t\t\tint a, b, c = 1;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tif (w)scanf(\"%d\", &c);\n\t\t\tcon(a - oindexed, b - oindexed, c);\n\t\t}\n\t}\n};\nclass BiDGraph : public Graph {//??????\npublic:\n\tBiDGraph(int n) : Graph(n) {}\n\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tg[b].push_back({ a, w });\n\t\tsumcost++;\n\t}\n};\nclass DGraph : public Graph {//??????\npublic:\n\tDGraph(int n) : Graph(n) {}\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tsumcost++;\n\t}\n};\n\n\nclass RGraph {//????????°??????\n\tstruct edge{\n\t\tint to, cap = 0, rev;\n\t\tbool isrev;\n\t};\npublic:\n\tint sumflow = 0;\n\n\tvector<vector<edge>> g;\n\n\tRGraph(DGraph dg) : g(dg.g.size()){\n\t\tREP(i, dg.g.size()) {\n\t\t\tfor (auto itr : dg.g[i]) {\n\t\t\t\tg[i].push_back({ itr.first, itr.second, (int)g[itr.first].size(), 0});\n\t\t\t\tg[itr.first].push_back({ i, 0, (int)g[i].size() - 1, 1});\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid flow(edge& eg, int rate) {\n\t\teg.cap -= rate;\n\t\tg[eg.to][eg.rev].cap += rate;\n\t}\n\n};\n\nRGraph FordFurkerson(DGraph g, int st, int en) {\n\t\n\tRGraph rg(g);\n\n\tvector<bool> used(g.g.size());\n\n\tfunction<int(int, int, int)> dfs = [&](int c, int p, int Min) {\n\t\tif (c == en) return Min;\n\t\tif (used[c]) return -1;\n\t\tused[c] = true;\n\n\t\tfor (auto& itr : rg.g[c]) {\n\t\t\tif (itr.cap > 0) {\n\t\t\t\tint ret = dfs(itr.to, c, min(Min, itr.cap));\n\t\t\t\tif (ret != -1) {\n\t\t\t\t\trg.flow(itr, ret);\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t};\n\n\twhile (int zo = dfs(st, -1, INT_MAX) != -1) {\n\t\tfill(ALL(used), 0);\n\t\trg.sumflow += zo;\n\t}\n\n\treturn rg;\n}\n\nvector<int> BiMaxmatching(DGraph g, int scount) { // scount????????????????????´??§???g???????????????scount???\n\t\n\tg.g.push_back(vector<pii>());\n\tg.g.push_back(vector<pii>());\n\n\tREP(i, scount) {\n\t\tg.con(g.g.size() - 2, i);\n\t}\n\trep(i, scount, g.g.size() - 2) {\n\t\tg.con(i, g.g.size() - 1);\n\t}\n\n\tRGraph rg(FordFurkerson(g, g.g.size() - 2, g.g.size() - 1));\n\n\tvector<int> ans(scount, -1);\n\n\tREP(i, scount) {\n\t\tfor (auto itr : rg.g[i]) {\n\t\t\tif (!itr.isrev && !itr.cap) {\n\t\t\t\tans[i] = itr.to;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main() {\n\tint x, y, e;\n\tcin >> x >> y >> e;\n\n\tDGraph g(x + y);\n\n\tREP(i, e) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\tg.con(a,b + x);\n\t}\n\t\n\tvector<int> ans(BiMaxmatching(g, x));\n\n\tint cou = 0;\n\tfor (auto itr : ans)\n\t\tcou += itr != -1;\n\n\tcout << cou << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <bitset>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int> >vpi;\ntypedef pair<int,int> pi;\n#define R return\n#define W while\n#define FOR(i,a) for(int i=0;i<a;i++)\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\nvi v[510];\nbitset<510>b,x;\nint m[510];\nbool dfs(int now){\n    if(now==-1)R false;\n    if(x[now])R false;\n    FOR(i,v[now].size())if(!b[v[now][i]]){\n        b[v[now][i]]=true;\n        if(m[v[now][i]]==-1||dfs(m[v[now][i]])){\n            m[v[now][i]]=now;\n            R x[now]=true;\n        }\n    }\n    R false;\n}\nint main(){\n    int n,y,k,l,r,ans=0;\n    x.reset();\n    scanf(\"%d%d%d\",&n,&y,&k);\nn=max(n,y);\n    n++;\n    FOR(i,n)m[i]=-1;\n    W(k--){\n        scanf(\"%d%d\",&l,&r);\n        v[l].PB(r);\n    }\n    FOR(i,n){\n        b.reset();\n        if(dfs(i))ans++;\n    }\n    printf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <limits>\n#include <queue>\n#include <vector>\n\ntemplate <class Cap, bool isDirect>\nclass MaxFlow {\n    struct Edge {\n        int from, to;\n        Cap cap;\n        int rev;\n        Edge(int from, int to, Cap cap, int rev)\n            : from(from), to(to), cap(cap), rev(rev){};\n    };\n\n    class Graph {\n    public:\n        int size;\n        std::vector<std::vector<Edge>> path;\n\n        explicit Graph(int N = 0) : size(N), path(size) {}\n        void span(int u, int v, Cap cap, int rev) {\n            path[u].push_back(Edge(u, v, cap, rev));\n        }\n        std::vector<Edge>& operator[](int v) { return path[v]; }\n    };\n\nprivate:\n    Graph graph;\n    std::vector<int> dist, iter;\n\n    void bfs(int s) {\n        std::fill(dist.begin(), dist.end(), -1);\n        dist[s] = 0;\n        std::queue<int> que;\n        que.push(s);\n\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n\n            for (const auto& e : graph[v]) {\n                if (e.cap > 0 && dist[e.to] < 0) {\n                    dist[e.to] = dist[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int g, Cap f) {\n        if (v == g) return f;\n\n        // iterで事前にどこまで探索したかをセーブ\n        for (int& itr = iter[v]; itr < graph[v].size(); ++itr) {\n            auto e = graph[v][itr];\n            if (e.cap > 0 && dist[v] < dist[e.to]) {\n                Cap df = dfs(e.to, g, std::min(f, e.cap));\n\n                // 流せるなら流す\n                if (df > 0) {\n                    graph[v][itr].cap -= df;\n                    graph[e.to][e.rev].cap += df;\n                    return df;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    explicit MaxFlow(int size)\n        : graph(size), dist(size, -1), iter(size) {}\n\n    void span(int u, int v, Cap cap) {\n        graph.span(u, v, cap, graph[v].size());\n        graph.span(v, u, (isDirect ? 0 : cap), graph[u].size() - 1);\n    }\n\n    Cap exec(int s, int g) {\n        const Cap INF = std::numeric_limits<Cap>::max();\n\n        Cap ret = 0;\n        while (true) {\n            bfs(s);\n            if (dist[g] < 0) return ret;\n\n            std::fill(iter.begin(), iter.end(), 0);\n            Cap flow;\n            while (true) {\n                flow = dfs(s, g, INF);\n                if (flow == 0) break;\n                ret += flow;\n            }\n        }\n    }\n};\n\nint main() {\n    int X, Y, M;\n    std::cin >> X >> Y >> M;\n\n    MaxFlow<int, true> mf(X + Y + 2);\n    for (int x = 0; x < X; ++x) {\n        mf.span(X + Y, x, 1);\n    }\n    for (int i = 0; i < M; ++i) {\n        int x, y;\n        std::cin >> x >> y;\n        mf.span(x, y + X, 1);\n    }\n    for (int y = 0; y < Y; ++y) {\n        mf.span(y + X, X + Y + 1, 1);\n    }\n\n    std::cout << mf.exec(X + Y, X + Y + 1) << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAX 256\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\nint X, Y, E;\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[to].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge& e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (1) {\n        for (int i = 0; i < MAX; i++) used[i] = false;\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(void) {\n    cin >> X >> Y >> E;\n    while (E--) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, X+y, 1);\n    }\n    int s = X+Y, t = s+1;\n    for (int i = 0; i < X; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        add_edge(X+i, t, 1);\n    }\n    cout << max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct BipartiteMatching {\n  vector< vector< int > > graph;\n  vector< int > match, alive, used; int timestamp;\n\n  BipartiteMatching(int n){\n    graph=vector<vector<int>>(n);\n    alive=vector<int>(n,1);\n    used=vector<int>(n,0);\n    match=vector<int>(n,-1);\n    timestamp=0;\n  }\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int idx) {\n    used[idx] = false;\n    for(auto &to : graph[idx]) {\n      int to_match = match[to];\n      if(alive[to] == 0) continue;\n      if(to_match == -1 || (used[to_match] && dfs(to_match))) {\n        match[idx] = to;\n        match[to] = idx;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      if(i < match[i]) {\n        cout << i << \"-\" << match[i] << endl;\n      }\n    }\n  }\n};\nint main() {\n  int X, Y, E;\n  cin >> X >> Y >> E;\n  BipartiteMatching bm(X + Y);\n  for(int i = 0; i < E; i++) {\n    int a, b;\n    cin >> a >> b;\n    bm.add_edge(a, X + b);\n  }\n  cout << bm.bipartite_matching() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint X, Y, E, x, y;\nint PY[1100];\nbool V[1100];\nbool D[1100][1100] = {};\nbool match(int x) {\n if (x<0) return true;\n if (V[x]) return false;\n V[x] = true;\n for (int y=0; y<Y; ++y) {\n  if (!D[x][y]) continue;\n  if (match(PY[y])) {\n   PY[y] = x;\n   return true;\n  }\n }\n return false;\n}\n\nint main() {\n cin >> X >> Y >> E;\n for (int i=0; i<E; ++i) {\n  cin >> x >> y;\n  D[x][y] = true;\n }\n fill(PY, PY+Y, -1);\n int count = 0;\n for (int x=0; x<X; ++x) {\n  fill(V, V+X, false);\n  if (match(x)) ++count;\n }\n cout << count << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n// O( ( V + E ) * sqrt( V ) )\nclass BipartiteMatching {\n public:\n  static const int N = 1e4 + 10;  // total number of nodes, n + m\n  static const int NIL = 0; // non-negative number (null vertex)\n  static const int INF = ( 1 << 28 );\n  vector< int > G[ N ];\n  int n, m, match[ N ], dist[ N ];\n  // n: number of nodes on left side, nodes are numbered 1 to n\n  // m: number of nodes on right side, nodes are numbered n+1 to n+m\n  // G = NIL[0] ??? G1[G[1---n]] ??? G2[G[n+1---n+m]]\n  bool BFS() {\n    queue< int > Q;\n    for (int i = 1; i <= n; i++ ) {\n      if ( match[ i ] == NIL ) {\n        dist[ i ] = 0;\n        Q.push( i );\n      }\n      else\n        dist[ i ] = INF;\n    }\n    while ( !Q.empty() ) {\n      int u = Q.front(); Q.pop();\n      if ( u != NIL )\n        for(int v : G[u]) {\n          if ( dist[ match[ v ] ] == INF ) {\n            dist[ match[ v ] ] = dist[ u ] + 1;\n            Q.push( match[ v ] );\n          }\n      }\n    }\n    return ( dist[ NIL ] != INF );\n  }\n  bool DFS( int u ) {\n    if ( u != NIL ) {\n      for(int v : G[u]) {\n        if ( dist[ match[ v ] ] == dist[ u ] + 1 ) {\n          if ( DFS( match[ v ] ) ) {\n            match[ v ] = u;\n            match[ u ] = v;\n            return true;\n          }\n        }\n      }\n      dist[ u ] = INF;\n      return false;\n    }\n    return true;\n  }\n  int Solve() {\n    dist[ NIL ] = INF;\n    int matching = 0;\n    for(int i = 0; i <= n + m; ++i) match[i] = NIL;\n    while ( BFS() )\n      for (int i = 1; i <= n; i++ )\n        if ( match[ i ] == NIL && DFS( i ) ) matching++;\n    return matching;\n  }\n  void AddEdge( int u, int v ) { G[ u ].push_back( n + v ); }\n} ob;\n\nint main() {\n  int E; scanf(\"%d %d %d\", &ob.n, &ob.m, &E);\n  for(int i = 0; i < E; ++i) {\n    int x, y; scanf(\"%d %d\", &x, &y);\n    ob.AddEdge(x+1, y+1);\n  }\n  printf(\"%d\\n\", ob.Solve());\n}"
  },
  {
    "language": "C++",
    "code": "// ########################################################\n// ################ MaxBipartiteMatching ##################\n// Hopcroft ( E * sqrt(V) )\n#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=50005,MAXM=150000;\nint x,y,e,last[MAXN],prev[MAXM],head[MAXM];\nint matching[MAXN],dist[MAXN],Q[MAXN];\nbool used[MAXN],vis[MAXN];\nvoid bfs()\n{\n  fill(dist,dist+x,-1);\n  int Qs=0;\n  for (int u=0;u<x;++u)\n    if (!used[u])\n      Q[Qs++] = u,dist[u]=0;\n  for (int i=0;i<Qs;i++)\n    {\n      int u1=Q[i];\n      for (int j=last[u1];j>=0;j=prev[j])\n\t{\n\t  int u2=matching[head[j]];\n\t  if (u2>=0 && dist[u2]<0)\n\t      dist[u2]=dist[u1]+1,Q[Qs++]=u2;\n\t}\n    }\n}\nbool dfs(int u1)\n{\n  vis[u1]=true;\n  for (int i=last[u1];i>=0;i=prev[e])\n    {\n      int v=head[i];\n      int u2=matching[v];\n      if (u2<0 || !vis[u2] && dist[u2]==dist[u1]+1 && dfs(u2))\n\t{\n\t  matching[v]=u1;\n\t  used[u1]=true;\n\t  return true;\n\t}\n    }\n  return false;\n}\nint maxMatching()\n{\n  fill(used,used+x,false);\n  fill(matching,matching+y,-1);\n  for (int res=0;;)\n    {\n      bfs();\n      fill(vis,vis+x,false);\n      int f=0;\n      for (int u=0;u<x;++u)\n\tif (!used[u] && dfs(u))\n\t  ++f;\n      if (!f)\n\treturn res;\n      res+=f;\n    }\n}\nint main()\n{\n  cin>>x>>y>>e;\n  memset(last,-1,sizeof last);\n  for(int i=0;i<e;i++)\n    {\n      int u,v;\n      cin>>u>>v;//0-based\n      head[i]=v;\n      prev[i]=last[u];\n      last[u]=i;\n    }\n  cout<<maxMatching()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n    edge() {}\n    edge(int t, int c, int r) : to(t), cap(c), rev(r) {}\n};\nconst int MAX_V = 500;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size()-1));\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge& e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        for (int i = 0; i < MAX_V; i++) used[i] = false;\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(void) {\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    int s = X+Y, t = s+1;\n    for (int i = 0; i < E; i++) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, y+X, 1);\n    }\n    for (int i = 0; i < X; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        add_edge(i+X, t, 1);\n    }\n    cout << max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ GRL_7_A\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vc;\n\nconst int INF = 0x3fffffff;\n\n\n// ????£???????????????????(Ford-Fulkerson???)\nclass Flow_min{\n\tpublic:\n\t\tint N;\t// ????????°\n\t\tvector<vc> F, C, edge;\t// F:????????°?????? C:???????????? edge:??£??\\????????????\n\t\tvc bf;\t// ??????????????£???????????????\n\n\t\t// ????????????????????? n:????????°\n\t\tFlow_min(int n): N(n), F(n,vc(n)), C(n,vc(n)), edge(n) {}\n\n\t\t// f->t????????????c?????????????????????(??????f->t??????????????????????????????????????¨?????????)\n\t\tvoid addEdge(int f, int t, int c){\n\t\t\tF[f][t] = C[f][t] = c;\n\t\t\tedge[f].push_back(t);\n\t\t\tedge[t].push_back(f);\n\t\t}\n\n\t\t// ?¢?????????????DFS??§??¢???\n\t\tint dfs(int n, int c, int T){\n\t\t\tint f = c * (n==T);\n\t\t\tbf[n] = 1;\n\t\t\tfor(int v: edge[n]) if( !f && F[n][v] && !bf[v] ){\n\t\t\t\tf = dfs(v, min(c, F[n][v]), T);\n\t\t\t\tF[n][v] -= f;\n\t\t\t\tF[v][n] += f;\n\t\t\t}\n\t\t\treturn f;\n\t\t}\n\n\t\t// ???????????????(S,T?????°?????????)\n\t\tvoid maxFlow(int S, int T){\n\t\t\twhile( bf.assign(N,0), dfs(S, INF, T) ){}\n\t\t}\n\n\t\t// ??????????????????????????????????????????\n\t\tint flow(int f, int t){ return C[f][t] - F[f][t]; }\n\n\t\t// ??£??\\?????????????????????????¨???????????????????n=S,T??\\????????´?????????????????????1/2????????????????????????????????????\n\t\tint flow(int n){\n\t\t\tint ret=0;\n\t\t\tfor(int v: edge[n]) ret += abs( C[n][v] - F[n][v] );\n\t\t\treturn ret;\n\t\t}\n\n\t\t// ??°???????????????????????????\n\t\tvoid reset(){ rep(i,N) rep(j,N) F[i][j] = C[i][j]; }\n};\n\nint main(){\n\tint X, Y, E;\n\tcin >> X >> Y >> E;\n\tint S = X+Y;\n\tint T = S+1;\n\n\tFlow_min fm(T+1);\n\trep(i, E){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tfm.addEdge( x, X+y, 1 );\n\t}\n\trep(i,X) fm.addEdge( S, i, 1 );\n\trep(i,Y) fm.addEdge( X+i, T, 1 );\n\n\tfm.maxFlow(S, T);\n\tcout << fm.flow(T) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\nconst LL mod=1e9+7;\nconst LL LINF=1LL<<62;\nconst int INF=1<<17;\n\n\nconst int M_N=200; //最大頂点数\n\nint V;\nvector<int> G[M_N];\nint match[M_N];\nbool used[M_N];\n\nvoid add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\nbool dfs(int v){\n    used[v]=true;\n    for(int i=0;i<G[v].size();i++){\n        int u=G[v][i],w=match[u];\n        if(w<0||!used[w]&&dfs(w)){\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\n\nint bipartie_matching(){\n    int res=0;\n    memset(match,-1,sizeof(match));\n    for(int v=0;v<V;v++){\n        if(match[v]<0){\n            memset(used,false,sizeof(used));\n            if(dfs(v)){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    int x,y,e;\n    cin >> x >> y >> e;\n    V=x+y;\n    for(int i=0;i<e;i++){\n        int u,v;\n        cin >> u >> v;\n        add_edge(u,x+v);\n    }\n    cout << bipartie_matching() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct BipartiteMatching {\n  vector< vector< int > > graph;\n  vector< int > match, alive, used;\n  int timestamp;\n\n  BipartiteMatching(int n) : graph(n), alive(n, 1), used(n, 0), match(n, -1), timestamp(0) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int idx) {\n    used[idx] = timestamp;\n    for(auto &to : graph[idx]) {\n      int to_match = match[to];\n      if(alive[to] == 0) continue;\n      if(to_match == -1 || (used[to_match] != timestamp && dfs(to_match))) {\n        match[idx] = to;\n        match[to] = idx;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return (ret);\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      if(i < match[i]) {\n        cout << i << \"-\" << match[i] << endl;\n      }\n    }\n  }\n};\n\nint main() {\n  int X, Y, E;\n  scanf(\"%d %d %d\", &X, &Y, &E);\n  BipartiteMatching bm(X + Y);\n  for(int i = 0; i < E; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    bm.add_edge(a, X + b);\n  }\n  cout << bm.bipartite_matching() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching\n{\n  vector< vector< int > > graph;\n  vector< int > match, alive, used;\n  int timestamp;\n\n  Bipartite_Matching(int n)\n  {\n    timestamp = 0;\n    graph.resize(n);\n    alive.assign(n, 1);\n    used.assign(n, 0);\n    match.assign(n, -1);\n  }\n\n  void add_edge(int u, int v)\n  {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int v)\n  {\n    used[v] = timestamp;\n    for(int i = 0; i < graph[v].size(); i++) {\n      int u = graph[v][i], w = match[u];\n      if(alive[u] == 0) continue;\n      if(w == -1 || (used[w] != timestamp && dfs(w))) {\n        match[v] = u;\n        match[u] = v;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching()\n  {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return (ret);\n  }\n};\n\nvoid solve()\n{\n  int X, Y, E;\n  cin >> X >> Y >> E;\n  Bipartite_Matching graph(X + Y);\n  for(int i = 0; i < E; i++) {\n    int a, b;\n    cin >> a >> b;\n    graph.add_edge(a, b + X);\n  }\n  cout << graph.bipartite_matching() << endl;\n}\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  solve();\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\ntypedef pair<LL, LL> P;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQ(c)     (c).erase(unique(ALL((c))),(c).end())\n# define mp          make_pair\n# define eb          emplace_back\n# define FOR(i,a,b)  for(int i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(int i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nconstexpr int MAX_V = 100000;\n\nint n;\nvector<int> G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\n//uとvを結ぶ辺をグラフに追加する\nvoid add_edge(int u, int v) {\n\tG[u].emplace_back(v);\n\tG[v].emplace_back(u);\n}\n\n//増加パスをDFSで探す\nbool dfs(int v) {\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); i++) {\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || (!used[w] && dfs(w))) {\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n//二部グラフの最大マッチングを求める\nint bipartite_matching() {\n\tint res = 0;\n\tfor (int i = 0; i < MAX_V; i++)match[i] = -1;\n\tfor (int v = 0; v < n; v++) {\n\t\tif (match[v] < 0) {\n\t\t\tfor (int i = 0; i < MAX_V; i++)used[i] = false;\n\t\t\tif (dfs(v)) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint x, y, e;\n\nint main() {\n\tcin >> x >> y >> e;\n\tn = max(x, y);\n\tREP(i, e) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tadd_edge(a, b);\n\t}\n\tcout << bipartite_matching() << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\n// ------ Variable ------ //\n\n#define MAX_V 200\n\nint V; vector<int> G[MAX_V];\n\nint match[MAX_V];\n\nbool used[MAX_V];\n\n\n// ------ Bipartite_Matching ------ //\n\nbool search(int v)\n{\n\tused[v] = true;\n\n\tfor (int i = 0; i < G[v].size(); i++)\n\t{\n\t\tint u = G[v][i], w = match[u];\n\n\t\tif (w < 0 || !used[w] && search(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint bipartite_matching()\n{\n\tint res = 0;\n\n\tmemset(match, -1, sizeof(match));\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (match[i] < 0)\n\t\t{\n\t\t\tmemset(used, 0, sizeof(used));\n\n\t\t\tif (search(i))\n\t\t\t{\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint X, Y, E, A, B;\n\n\tcin >> X >> Y >> E; V = X + Y;\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tG[A].push_back(X + B);\n\t\tG[X + B].push_back(A);\n\t}\n\n\tcout << bipartite_matching() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <complex>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\n#define pb push_back\n#define mp make_pair\ntypedef vector<int> vi;\ntypedef pair<int, int> pi;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\nconst int INF = 1 << 27;\nconst int MAX_V = 202;\n//////////////////////////////\n// 2??¨??????????????°(???????????¨???1)\nint V, match[MAX_V], used[MAX_V];\nvector<vi> G(MAX_V);\n\nbool dfs(int v){\n  used[v] = true;\n  REP(i, G[v].size()){\n    int u = G[v][i], w = match[u];\n    if(w < 0 || (!used[w] && dfs(w))){\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\nint bipartite_matching(){\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  REP(v, V)\n    if(match[v] < 0){\n      memset(used, 0, sizeof(used));\n      if(dfs(v)) ++res;\n    }\n  return res;\n}\nint main() {\n  int X, Y, E; cin >>X >>Y >>E;\n  V = X + Y;\n  REP(i, E){\n    int u, v; cin >>u >>v;\n    v += X;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  cout << bipartite_matching() <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdlib>\n#include <iomanip>\n#include <utility>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint exist(int y,const vector<int> &p) //y?????????????????¨??????????????§???????????? ????????°????????????x????????????????????????\n{\n    for(int i = 0; i < p.size(); i++)\n    {\n        if(p[i] == y)\n            return i;\n    }\n    return -1;\n}\n\nbool match(int x, int self, const vector<vector<bool> > &v,vector<int> &p) //??????????????°\n{\n    for(int i = 0; i < v[0].size(); i++) //start??????y?????????????????§??°?????????\n    {\n        if(v[x][i] && i != self) //??????x,i?????¨?????????????????°\n        {\n            int rem = exist(i, p); //i????????§?????¨??????????????????\n            p[x] = i; //x,i?????¨????????§?????????\n            if(rem < 0) //i????????¨????????¨????????????????????°??¢??°?????????\n            {\n                return true;\n                \n            }\n            else //i????????¨????????¨?????????????????°\n            {\n                p[rem] = -1; //????????¨??????????¶????\n                bool ok = match(rem,i+1,v,p); //??£????????¨??????????????????????????????\n                if(!ok) //???????????????????????£??????????????????\n                {\n                    p[x] = -1;\n                    p[rem]= i;\n                }\n                else //???????????£????????¢??°????????????\n                    return true;\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int xn,yn,e,x,y;\n    cin >> xn >> yn >> e;\n    vector< vector<bool> > v(xn, vector<bool>(yn,false));\n    vector<int> p(xn,-1);\n    for(int i = 0; i < e; i++)\n    {\n        cin >> x >> y;\n        v[x][y] = true;\n    }//???????????§?????????\n    \n    for(int i = 0; i<xn;i++)\n    {\n        match(i,0,v,p);\n    }\n    //???????????§?¨?????????????????????¨???\n    int c = 0;\n    for(int i = 0; i<p.size();i++)\n    {\n        if(p[i]>=0)\n            c++;\n    }\n    cout << c << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n\nusing namespace std;\n\nconst int kNil = -1;\n\nenum class Color {\n  kWhite,\n  kGrey,\n  kBlack,\n};\n\ntemplate <class T>\nstruct Edge {\n  using w_type = T;\n  Edge(int u, int v, w_type w): u(u), v(v), w(w) { }\n  int u, v;\n  w_type w;\n  bool operator<(const Edge<T> & rhs) const {\n    if (w != rhs.w) { return w < rhs.w; }\n    if (u != rhs.u) { return u < rhs.u; }\n    return v < rhs.v;\n  }\n};\n\ntemplate <class Edge>\nvector<int> BFS(const vector<Edge> & edges,\n              typename vector<Edge>::size_type node_num,\n              typename vector<Edge>::size_type root) {\n  using size_type = typename vector<Edge>::size_type;\n\n  vector<vector<Edge>> adjacency_list(node_num, vector<Edge>());\n  for (const auto & e: edges) {\n    adjacency_list[e.u].push_back(e);\n  }\n\n  queue<size_type> que;\n  vector<size_type> d(node_num, numeric_limits<size_type>::max());\n  vector<Color> color(node_num, Color::kWhite);\n  vector<int> parent(node_num, kNil);\n\n  d[root] = 0;\n  color[root] = Color::kGrey;\n  que.push(root);\n  while (!que.empty()) {\n    auto u = que.front();\n    que.pop();\n    for (const auto & e: adjacency_list[u]) {\n      if (color[e.v] == Color::kWhite) {\n        color[e.v] = Color::kGrey;\n        d[e.v] = d[e.u] + 1;\n        parent[e.v] = e.u;\n        que.push(e.v);\n      }\n    }\n    color[u] = Color::kBlack;\n  }\n\n  return parent;\n}\n\ntemplate <class E>\ndecltype(auto) EdmondsKarp(vector<E> & edges,\n                 typename vector<E>::size_type node_num,\n                 typename vector<E>::size_type source,\n                 typename vector<E>::size_type target) {\n  using size_type = typename vector<E>::size_type;\n  using w_type = typename E::w_type;\n\n  const w_type kInf = numeric_limits<w_type>::max();\n\n  vector<vector<w_type>> flow(node_num, vector<w_type>(node_num));\n\n  while (1) {\n    vector<Edge<w_type>> residual_net;\n    for (const auto & e: edges) {\n      auto residual_capacity = e.w - flow[e.u][e.v];\n      if (residual_capacity != 0) {\n        residual_net.emplace_back(e.u, e.v, residual_capacity);\n      }\n      if (flow[e.u][e.v] != 0) {\n        residual_net.emplace_back(e.v, e.u, flow[e.u][e.v]);\n      }\n    }\n    vector<vector<w_type>> residual_matrix(node_num, vector<w_type>(node_num, kInf));\n    for (const auto & e: residual_net) {\n      residual_matrix[e.u][e.v] = e.w;\n    }\n    for (unsigned i = 0; i < node_num; ++i) {\n      residual_matrix[i][i] = 0;\n    }\n\n    auto min_capacity = kInf;\n    vector<pair<size_type, size_type>> path;\n    auto parents = BFS(residual_net, node_num, source);\n    if (parents[target] == kNil) { break; }\n    unsigned u = target;\n    while (u != source) {\n      unsigned pa = parents[u];\n      path.emplace_back(pa, u);\n      assert(residual_matrix[pa][u] != kInf);\n      min_capacity = min(min_capacity, residual_matrix[pa][u]);\n      u = pa;\n    }\n    for (const auto & e: path) {\n      flow[e.first][e.second] += min_capacity;\n      flow[e.second][e.first] = -flow[e.first][e.second];\n    }\n  }\n\n  return accumulate(flow[source].begin(), flow[source].end(), 0);\n}\n\nunsigned BipatiteMatching(vector<pair<unsigned, unsigned>> & pairs,\n                 unsigned node_num_x,\n                 unsigned node_num_y) {\n  auto node_num = node_num_x + node_num_y + 2;\n  vector<Edge<int>> edges;\n  for (unsigned i = 0; i < node_num_x; ++i) {\n    edges.emplace_back(0, i + 1, 1);\n  }\n  for (unsigned i = 0; i < node_num_y; ++i) {\n    edges.emplace_back(i + node_num_x + 1, node_num - 1, 1);\n  }\n  for (const auto & e: pairs) {\n    edges.emplace_back(e.first + 1, e.second + node_num_x + 1, 1);\n  }\n\n  return EdmondsKarp(edges, node_num, 0, node_num - 1);\n}\n\nint main(int argc, char const *argv[]) {\n  using w_type = int;\n\n  const w_type kInf = numeric_limits<w_type>::max();\n\n  vector<pair<unsigned, unsigned>> pairs;\n  unsigned X, Y, E;\n  cin >> X >> Y >> E;\n  for (unsigned i = 0; i < E; ++i) {\n    unsigned u, v;\n    cin >> u >> v;\n    pairs.emplace_back(u, v);\n  }\n  cout << BipatiteMatching(pairs, X, Y) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n    edge() {}\n    edge(int t, int c, int r) : to(t), cap(c), rev(r) {}\n};\nconst int MAX_V = 500;\n\nvector<edge> G[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back(edge(to, cap, G[to].size()));\n    G[to].push_back(edge(from, 0, G[from].size()-1));\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge& e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    for (;;) {\n        for (int i = 0; i < MAX_V; i++) used[i] = false;\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(void) {\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    int s = X+Y, t = s+1;\n    for (int i = 0; i < E; i++) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, y+X, 1);\n    }\n    for (int i = 0; i < X; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        add_edge(i+X, t, 1);\n    }\n    cout << max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n//typedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\ntypedef vector<vector<int>> mat;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nvector<int> G[1002];\nbool used[1002];\nint match[1002];\n\nbool dfs(int v)\n{\n\tused[v] = true;\n\trep(i, 0, SZ(G[v]))\n\t{\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching(int V)\n{\n\tint res = 0;\n\tmemset(match, -1, sizeof(match));\n\trep(i, 0, V)\n\t{\n\t\tif (match[i] < 0)\n\t\t{\n\t\t\tmemset(used, 0, sizeof(used));\n\t\t\tif (dfs(i))\n\t\t\t{\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint X, Y,E, x, y;\n\tcin >> X >> Y >> E;\n\trep(i, 0, E)\n\t{\n\t\tcin >> x >> y;\n\t\tG[x].push_back(X + y);\n\t\tG[X + y].push_back(x);\n\t}\n\n\tcout << bipartite_matching(X + Y) << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n#include <cstring>          // memset()\n#include <vector>\n#include <queue>\n#include <algorithm>        // min()\n\nusing namespace std;\nstatic const int MAX_X = 100;\nstatic const int MAX_Y = 100;\nstatic const int MAX_V = MAX_X + MAX_Y + 2;\nstatic const int INF = 100000000;\n\ntypedef struct edge_tbl\n{\n\tint to, cap;\n\tunsigned long rev;\n} edge;\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nunsigned int iter[MAX_V];\n\nvoid\nbfs(int s)\n{\n\tqueue<int> que;\n\n\tmemset(level, -1, sizeof(level));\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty())\n\t{\n\t\tint v = que.front(); que.pop();\n\t\tfor (unsigned int i = 0; i < G[v].size(); ++i)\n\t\t{\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[e.to] < 0)\n\t\t\t{\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint\ndfs(int v, int t, int f)\n{\n\tif (v == t)\n\t\treturn f;\n\n\tfor (unsigned int &i = iter[v]; i < G[v].size(); ++i)\n\t{\n\t\tedge &e = G[v][i];\n\t\tif (e.cap > 0 && level[v] < level[e.to])\n\t\t{\n\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\tif (d > 0)\n\t\t\t{\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint\nmax_flow(int s, int t)\n{\n\tint flow = 0;\n\twhile (true)\n\t{\n\t\tbfs(s);\n\t\tif (level[t] < 0)\n\t\t\treturn flow;\n\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint f;\n\t\twhile ((f = dfs(s, t, INF)) > 0)\n\t\t\tflow += f;\n\t}\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint X, Y, E;\n\tint x, y;\n\n\tscanf(\"%d %d %d\", &X, &Y, &E);\n\tint s = X + Y, t = s + 1;\n\tfor (int i = 0; i < X; ++i)\n\t{\n\t\tG[s].push_back((edge){i, 1, G[i].size()});\n\t\tG[i].push_back((edge){s, 0, G[s].size() - 1});\n\t}\n\n\tfor (int i = 0; i < Y; ++i)\n\t{\n\t\tG[X + i].push_back((edge){t, 1, G[t].size()});\n\t\tG[t].push_back((edge){X + i, 0, G[X + i].size() - 1});\n\t}\n\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tscanf(\"%d %d\", &x, &y);\n\t\tG[x].push_back((edge){X + y, 1, G[X + y].size()});\n\t\tG[X + y].push_back((edge){x, 0, G[x].size() - 1});\n\t}\n\n\tprintf(\"%d\\n\", max_flow(s, t));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 100;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\n\nvoid print_line(vector<string> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n\nstruct BipartiteMatching {\n    vector<vector<int> > graph;\n    vector<int> match, alive, used;\n    int timestamp;\n\n    BipartiteMatching(int n) : graph(n), alive(n, 1), used(n, 0), match(n, -1), timestamp(0) {}\n\n    void add_edge(int u, int v) {\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    bool dfs(int idx) {\n        used[idx] = timestamp;\n        for (auto &to : graph[idx]) {\n            int to_match = match[to];\n            if (alive[to] == 0) continue;\n            if (to_match == -1 || (used[to_match] != timestamp && dfs(to_match))) {\n                match[idx] = to;\n                match[to] = idx;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int bipartite_matching() {\n        int ret = 0;\n        for (int i = 0; i < graph.size(); i++) {\n            if (alive[i] == 0) continue;\n            if (match[i] == -1) {\n                ++timestamp;\n                ret += dfs(i);\n            }\n        }\n        return ret;\n    }\n\n    void output() {\n        for (int i = 0; i < graph.size(); i++) {\n            if (i < match[i]) {\n                cout << i << \"-\" << match[i] << endl;\n            }\n        }\n    }\n};\n\nint main() {\n    ll x, y, e;\n    cin >> x >> y >> e;\n\n    BipartiteMatching bipartiteMatching(x + y);\n    rep(i, e) {\n        ll ui, vi;\n        cin >> ui >> vi;\n        bipartiteMatching.add_edge(ui, vi + x);\n    }\n\n    cout << bipartiteMatching.bipartite_matching() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n//typedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\ntypedef vector<vector<int>> mat;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nvector<vector<int>> G;\nint match[210];\nbool used[210];\n\nbool dfs(int v)\n{\n\tused[v] = true;\n\trep(i, 0, SZ(G[v]))\n\t{\n\t\tint u = G[v][i], w = match[u];\n\t\tif (w < 0 || !used[w] && dfs(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint bipartite_matching()\n{\n\tint res = 0;\n\trep(i, 0, 210)match[i] = -1;\n\trep(v, 0, SZ(G))\n\t{\n\t\tif (match[v] < 0)\n\t\t{\n\t\t\trep(i, 0, 210)used[i] = false;\n\t\t\tif (dfs(v))\n\t\t\t{\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint X, Y, E, x, y;\n\tcin >> X >> Y >> E;\n\tG.resize(X + Y);\n\twhile (E--)\n\t{\n\t\tcin >> x >> y;\n\t\tG[x].push_back(X + y);\n\t\tG[X + y].push_back(x);\n\t}\n\n\tcout << bipartite_matching() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <limits>\nusing namespace std;\n\n// Dinic O(|E||V|^2)\ntemplate <typename T, bool directed>\nclass Dinic\n{\npublic:\n  Dinic(int n) : n(n), capacity(n, vector<T>(n)) {}\n  void add_edge(int src, int dst, T cap)\n  {\n    capacity[src][dst] = cap;\n    capacity[dst][src] = directed ? 0 : cap;\n  }\n\n  T max_flow(int s, int t)\n  {\n    T flow = 0;\n    while (bfs(s, t))\n    {\n      start.assign(n, 0);\n      flow += dfs(t, s, numeric_limits<T>::max());\n    }\n    return flow;\n  }\n\nprivate:\n  int n;\n  vector<int> level, start;\n  vector<vector<T>> capacity;\n  bool bfs(int s, int t)\n  {\n    level.assign(n, -1);\n    queue<int> que;\n    level[s] = 0;\n    que.push(s);\n    while (!que.empty())\n    {\n      int v = que.front();\n      que.pop();\n      for (int nv = 0; nv < n; ++nv)\n        if (capacity[v][nv] > 0 && level[nv] < 0)\n        {\n          level[nv] = level[v] + 1;\n          que.push(nv);\n        }\n    }\n    return level[t] != -1;\n  }\n\n  T dfs(int v, int s, T limit)\n  {\n    if (v == s)\n      return limit;\n\n    T res = 0;\n    for (int &nv = start[v]; nv < n; ++nv)\n    {\n      if (capacity[nv][v] > 0 && level[v] == level[nv] + 1)\n      {\n        T d = dfs(nv, s, min(limit, capacity[nv][v]));\n        if (d > 0)\n        {\n          capacity[nv][v] -= d;\n          capacity[v][nv] += d;\n          res += d;\n          limit -= d;\n          if (limit == 0)\n            break;\n        }\n      }\n    }\n    return res;\n  }\n};\n\nint main()\n{\n  int X, Y, E, x, y;\n  cin >> X >> Y >> E;\n  Dinic<int, true> dn(X + Y + 2);\n  int S = X + Y, T = X + Y + 1;\n  for (int i = 0; i < E; ++i)\n  {\n    cin >> x >> y;\n    dn.add_edge(x, X + y, 1);\n  }\n  for (int i = 0; i < X; ++i)\n    dn.add_edge(S, i, 1);\n  for (int i = 0; i < Y; ++i)\n    dn.add_edge(X + i, T, 1);\n  cout << dn.max_flow(S, T) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ft first\n#define sd second\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\n\ntemplate <class T> struct Dinic{\n    const T inf;\n    struct edge{\n        int cd;\n        T c;\n        size_t rv;\n        bool f;\n    };\n    vector<vector<edge>> v;\n    vector<int> m,it;\n    Dinic(int n):inf(numeric_limits<T>::max()),v(n){}\n    void ad(int dm,int cd,T c){\n        v[dm].emplace_back((edge){cd,c,v[cd].size(),0});\n        v[cd].emplace_back((edge){dm,0,v[dm].size()-1,1});\n    }\n    bool bfs(int s,int t){\n        m.assign(v.size(),-1);\n        queue<int> q;\n        m[s]=0;\n        q.push(s);\n        while(!q.empty()&&m[t]==-1){\n            int p=q.front();q.pop();\n            for(auto &e:v[p]){\n                if(e.c>0&&m[e.cd]==-1){\n                    m[e.cd]=m[p]+1;\n                    q.push(e.cd);\n                }\n            }\n        }\n        return m[t]!=-1;\n    }\n    T dfs(int i,int t,T f){\n        if(i==t) return f;\n        for(int j=it[i];j<v[i].size();++j){\n            edge &e=v[i][j];\n            if(e.c>0&&m[i]<m[e.cd]){\n                T d=dfs(e.cd,t,min(f,e.c));\n                if(d){\n                    e.c-=d;\n                    v[e.cd][e.rv].c+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    T mf(int s,int t){\n        T fl=0;\n        while(bfs(s,t)){\n            it.assign(v.size(),0);\n            T f=0;\n            while((f=dfs(s,t,inf))>0) fl+=f;\n        }\n        return fl;\n    }\n};\n\ntemplate <class T> struct BM{\n    int n,m;\n    Dinic<T> d;\n    BM(int n_,int m_):n(n_),m(m_),d(n_+m_+2){\n        fr(i,n) d.ad(n+m,i,1);\n        fr(i,m) d.ad(n+i,n+m+1,1);\n    }\n    void ad(int dm,int cd){d.ad(dm,cd+n,1);}\n    T mm(){return d.mf(n+m,n+m+1);}\n};\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int x,y,e,a,b;\n    cin>>x>>y>>e;\n    BM<int> bm(x,y);\n    fr(i,e){\n        cin>>a>>b;\n        bm.ad(a,b);\n    }\n    cout<<bm.mm()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<array>\n#include<algorithm>\n#include<list>\n#include<cmath>\n#include<iomanip>\n#include<queue>\n#include<functional>\n#include<climits>\n#include<iterator>\n#include<unordered_map>\n\n//#include\"GraphAlgorithm.hpp\"\n//#include\"DataStructure.hpp\"\n//using namespace graph_algorithm;\n//using namespace data_structure;\n\nusing namespace std;\nusing cMatrixRepEdges=std::vector<std::vector<int>>;\npair<vector<int>,int> solve_by_EdmondsKarp_helper(const cMatrixRepEdges& ResidualNetwork,int source,int sink){\n\tif(ResidualNetwork.empty())return make_pair(vector<int>(),0);\n\n\tvector<bool> IsVisit(ResidualNetwork.size(),false);\n\tvector<int> Parents(ResidualNetwork.size(),-1);\n\tqueue<pair<int,int>> Q;\n\tQ.push(make_pair(source,INT_MAX));\n\tIsVisit[source]=true;\n\n\tint ans=0;\n\twhile(!Q.empty()){\n\t\tauto now=Q.front();\n\t\tQ.pop();\n\t\tif(now.first==sink){\n\t\t\tans=now.second;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i=0;i<ResidualNetwork.size();++i){\n\t\t\tif(ResidualNetwork[now.first][i]>0 && !IsVisit[i]){\n\t\t\t\tIsVisit[i]=true;\n\t\t\t\tParents[i]=now.first;\n\t\t\t\tQ.push(make_pair(i,min(now.second,ResidualNetwork[now.first][i])));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn make_pair(Parents,ans);\n}\n\ncMatrixRepEdges solve_by_EdmondsKarp(const cMatrixRepEdges& FlowNetwork,int source,int sink){\n\tif(FlowNetwork.empty() || source<0 || FlowNetwork.size()<=source || sink<0 || FlowNetwork.size()<=sink)return cMatrixRepEdges();\n\n\tcMatrixRepEdges ResidualNetwork=FlowNetwork;\n\tcMatrixRepEdges AnsFlow(FlowNetwork.size(),vector<int>(FlowNetwork.size(),0));\n\n\twhile(1){\n\t\tauto ans=solve_by_EdmondsKarp_helper(ResidualNetwork,source,sink);\n\t\t//source??????sink???????????????????????????????????£???\n\t\tif(ans.first[sink]<0)break;\n\n\t\tint to=sink;\n\t\tint from=ans.first[sink];\n\t\twhile(to!=source){\n\t\t\tif(FlowNetwork[from][to]>0){\n\t\t\t\tAnsFlow[from][to]+=ans.second;\n\t\t\t\tResidualNetwork[from][to]=FlowNetwork[from][to]-AnsFlow[from][to];\n\t\t\t\tResidualNetwork[to][from]=AnsFlow[from][to];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tAnsFlow[to][from]-=ans.second;\n\t\t\t\tResidualNetwork[to][from]=FlowNetwork[to][from]-AnsFlow[to][from];\n\t\t\t\tResidualNetwork[from][to]=AnsFlow[to][from];\n\t\t\t}\n\n\t\t\tto=from;\n\t\t\tfrom=ans.first[from];\n\t\t}\n\t}\n\n\treturn AnsFlow;\n}\n\nconst double pi=4*atan(1.0);\n\nint mod=1000000007;\n\nint main() {\n\tint X,Y,M;\n\tcin>>X>>Y>>M;\n\n\tcMatrixRepEdges Edges(X+Y+2,vector<int>(X+Y+2,0));\n\tfor(int i=0;i<M;++i){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\n\t\tEdges[x][X+y]=1;\n\t}\n\n\tfor(int i=0;i<X;++i){\n\t\tEdges[X+Y][i]=1;\n\t}\n\n\tfor(int i=X;i<X+Y;++i){\n\t\tEdges[i][X+Y+1]=1;\n\t}\n\n\tauto ans=solve_by_EdmondsKarp(Edges,X+Y,X+Y+1);\n\n\tint sum=0;\n\tfor(int i=0;i<X;++i){\n\t\tsum+=ans[X+Y][i];\n\t}\n\n\tcout<<sum<<endl;\n\t\n\t//system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<algorithm>\n#include<vector>\nstruct bimatch{\n\tint n;\n\tvector<vector<int> >G;\n\tvector<int>match;\n\tvector<bool>used;\n\tbimatch(int _n=0):n(_n),G(n),match(n),used(n){}\n\tvoid add_edge(int u,int v)\n\t{\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tbool dfs(int v)\n\t{\n\t\tused[v]=true;\n\t\tfor(int u:G[v])\n\t\t\n\t\t{\n\t\t\tint w=match[u];\n\t\t\tif(w<0||!used[w]&&dfs(w))\n\t\t\t{\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint count()\n\t{\n\t\tint ans=0;\n\t\tbool flag=true;\n\t\tfill(match.begin(),match.end(),-1);\n\t\twhile(flag)\n\t\t{\n\t\t\tflag=false;\n\t\t\tfill(used.begin(),used.end(),false);\n\t\t\tfor(int v=0;v<n;v++)if(match[v]<0&&dfs(v))ans++,flag=true;\n\t\t}\n\t\treturn ans;\n\t}\n};\nint X,Y,E;\nmain()\n{\n\tcin>>X>>Y>>E;\n\tbimatch P(X+Y);\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tint x,y;cin>>x>>y;\n\t\tP.add_edge(x,X+y);\n\t}\n\tcout<<P.count()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\n// ------ Variable ------ //\n\n#define MAX_V 100\n\nint V; vector<int> G[MAX_V];\n\nint match[MAX_V];\n\nbool used[MAX_V];\n\n\n// ------ Bipartite_Matching ------ //\n\nbool search(int v)\n{\n\tused[v] = true;\n\n\tfor (int i = 0; i < G[v].size(); i++)\n\t{\n\t\tint u = G[v][i], w = match[u];\n\n\t\tif (w < 0 || !used[w] && search(w))\n\t\t{\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint bipartite_matching()\n{\n\tint res = 0;\n\n\tfill(match, match + V, -1);\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tif (match[i] < 0)\n\t\t{\n\t\t\tfill(used, used + V, 0);\n\n\t\t\tif (search(i))\n\t\t\t{\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint X, Y, E, A, B;\n\n\tcin >> X >> Y >> E; V = X + Y;\n\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tcin >> A >> B;\n\n\t\tG[A].push_back(X + B);\n\t\tG[X + B].push_back(A);\n\t}\n\n\tcout << bipartite_matching() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nclass BipartiteMatching {\npublic:\n\tint n;\n\tvector<vector<int>> g;\n\tvector<int> match;\n\tBipartiteMatching(int n) : n(n), g(n), match(n), used(n) {}\n\tvoid add_edge(int u, int v) {\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\t//?????§??????????????°\n\tint maximum_matching() {\n\t\tint ret = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tif (match[v] == -1) {\n\t\t\t\tfill(used.begin(), used.end(), false);\n\t\t\t\tif (dfs(v)) ret++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\nprivate:\n\tvector<int> used;\n\tbool dfs(int v) {\n\t\tused[v] = true;\n\t\tfor (int u : g[v]) {\n\t\t\tint w = match[u];\n\t\t\tif (w == -1 || (!used[w] && dfs(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint X, Y, E; cin >> X >> Y >> E;\n\tBipartiteMatching bm(X + Y);\n\trep(i, 0, E) {\n\t\tint x, y; cin >> x >> y;\n\t\tbm.add_edge(x, X + y);\n\t}\n\tcout << bm.maximum_matching() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Benri { Benri() { std::cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(12);}} benri;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\nusing vll = vector<long long>;\nusing pll = pair<ll, ll>;\nusing ull = unsigned long long;\n\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\nconstexpr double EPS = 1e-10;\nconstexpr int INF = 1001001001;\n//constexpr ll INF = 1001001001001001001ll;\n\n\nstruct HopcroftKarp {\n    int sizeL, sizeR;\n    vector<vector<int> > list; // left to right\n\n    // result\n    vector<bool> seen, matched;\n    vector<int> level, matching;\n\n    // base\n    HopcroftKarp(int l, int r) : sizeL(l), sizeR(r), list(l, vector<int>()) { }\n    inline vector<int>& operator [] (int i) { return list[i]; }\n    inline void addedge(int from, int to) { list[from].push_back(to); }\n    inline friend ostream& operator << (ostream& s, const HopcroftKarp& G) {\n        s << endl;\n        for (int i = 0; i < G.list.size(); ++i) {\n            s << i << \" : \";\n            for (int j = 0; j < G.list[i].size(); ++j) {\n                s << G.list[i][j];\n                if (j + 1 != G.list[i].size()) s << \", \";\n            }\n            s << endl;\n        }\n        return s;\n    }\n\n    // methods\n    void hobfs() {\n        queue<int> que;\n        for (int left = 0; left < sizeL; ++left) {\n            level[left] = -1;\n            if (!matched[left]) {\n                que.push(left);\n                level[left] = 0;\n            }\n        }\n        level[sizeL] = sizeL;\n        while (!que.empty()) {\n            int left = que.front();\n            que.pop();\n            for (int i = 0; i < list[left].size(); ++i) {\n                int right = list[left][i];\n                int next = matching[right];\n                if (level[next] == -1) { //つまりmatched[next]=trueな時\n                    level[next] = level[left] + 1;\n                    que.push(next);\n                }\n            }\n        }\n    }\n    bool hodfs(int left) {\n        if (left == sizeL) return true;\n        if (seen[left]) return false;\n        seen[left] = true;\n        for (int i = 0; i < list[left].size(); ++i) {\n            int right = list[left][i];\n            int next = matching[right];\n            if (level[next] > level[left] && hodfs(next)) {\n                matching[right] = left;\n                return true;\n            }\n        }\n        return false;\n    }\n    int solve() {\n        seen.assign(sizeL, false);\n        matched.assign(sizeL, false);\n        level.assign(sizeL + 1, -1);\n        matching.assign(sizeR, sizeL);\n        int res = 0;\n        while (true) {\n            hobfs();\n            seen.assign(sizeL, false);\n            bool finished = true;\n            for (int left = 0; left < sizeL; ++left) {\n                if (!matched[left] && hodfs(left)) {\n                    matched[left] = true;\n                    ++res;\n                    finished = false;\n                }\n            }\n            if (finished) break;\n        }\n        return res;\n    }\n};\n\nint main() {\n    int l, r, e; cin >> l >> r >> e;\n    HopcroftKarp hk(l, r);\n    rep(i, e) {\n        int x, y; cin >> x >> y;\n        hk.addedge(x, y);\n    }\n    cout << hk.solve() << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n//by NeighThorn\nusing namespace std;\nconst int maxn=100+5,maxm=10000+5;\nint n,m,e,hd[maxn],to[maxm*2],nxt[maxm*2],cnt,pre[maxn],vis[maxn],ans;\ninline void add(int x,int y){\n\tto[cnt]=y;nxt[cnt]=hd[x];hd[x]=cnt++;\n}\ninline bool dfs(int root){\n\tfor(int i=hd[root];i!=-1;i=nxt[i])\n\t\tif(!vis[to[i]]){\n\t\t\tvis[to[i]]=1;\n\t\t\tif(pre[to[i]]==-1||dfs(to[i])){\n\t\t\t\tpre[to[i]]=root;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\treturn false;\n}\nsigned main(void){\n\tcnt=0;ans=0;\n\tmemset(hd,-1,sizeof(hd));\n\tmemset(pre,-1,sizeof(pre));\n\tscanf(\"%d%d%d\",&n,&m,&e);\n\tfor(int i=1,x,y;i<=e;i++)\n\t\tscanf(\"%d%d\",&x,&y),add(x,y+n),add(y+n,x);\n\tfor(int i=0;i<n;i++)\n\t\tmemset(vis,0,sizeof(vis)),ans+=dfs(i);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAX 256\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n\nint X, Y, E;\n\nstruct edge {\n    int to;\n    int cap;\n    int rev;\n};\n\nvector<edge> G[MAX];\nbool used[MAX];\n\nvoid add_edge(int from, int to, int cap) {\n    G[from].push_back((edge){to, cap, (int)G[to].size()});\n    G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    for (int i = 0; i < G[v].size(); i++) {\n        edge &e = G[v][i];\n        if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow = 0;\n    while (1) {\n        for (int i = 0; i < MAX; i++) used[i] = false;\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\n\nint main(void) {\n    cin >> X >> Y >> E;\n    while (E--) {\n        int x, y;\n        cin >> x >> y;\n        add_edge(x, X+y, 1);\n    }\n    int s = X+Y, t = s+1;\n    for (int i = 0; i < X; i++) {\n        add_edge(s, i, 1);\n    }\n    for (int i = 0; i < Y; i++) {\n        add_edge(X+i, t, 1);\n    }\n    cout << max_flow(s, t) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\n// 最大流O(V^2E)\nstruct Dinic {\nprivate:\n    struct edge {\n        int to;\n        ll cap;\n        int rev;\n        bool isrev;\n        int idx;\n    };\n\n    vector< vector< edge > > graph;\n    vector< int > min_cost, iter;\n\n\n    bool bfs(int s, int t) {\n        min_cost.assign(graph.size(), -1);\n        queue< int > que;\n        min_cost[s] = 0;\n        que.push(s);\n        while (!que.empty() && min_cost[t] == -1) {\n            int p = que.front();\n            que.pop();\n            for (auto &e : graph[p]) {\n                if (e.cap > 0 && min_cost[e.to] == -1) {\n                    min_cost[e.to] = min_cost[p] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n        return min_cost[t] != -1;\n    }\n\n    ll dfs(int idx, const int t, ll flow) {\n        if (idx == t) return flow;\n        for (int &i = iter[idx]; i < graph[idx].size(); i++) {\n            edge &e = graph[idx][i];\n            if (e.cap > 0 && min_cost[idx] < min_cost[e.to]) {\n                ll d = dfs(e.to, t, min(flow, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    graph[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\npublic:\n\n    Dinic(int V) : graph(V) {}\n\n    // from から to への容量capの有向辺\n    void add_edge(int from, int to, ll cap, int idx = -1) {\n        graph[from].push_back({to, cap, (int)graph[to].size(), false, idx});\n        graph[to].push_back({from, 0, (int)graph[from].size() - 1, true, idx});\n    }\n\n\n    // from s to t\n    ll max_flow(int s, int t) {\n        ll flow = 0;\n        while (bfs(s, t)) {\n            iter.assign(graph.size(), 0);\n            ll f = 0;\n            while ((f = dfs(s, t, 1e9 + 6)) > 0) flow += f;\n        }\n        return flow;\n    }\n\n    void output() {\n        for (int i = 0; i < graph.size(); i++) {\n            for (auto &e : graph[i]) {\n                if (e.isrev) continue;\n                auto &rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << e.cap + rev_e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\nint main() {\n    int x, y, e; cin >> x >> y >> e;\n    Dinic G(x + y + 2);\n    for (int i = 0; i < e; i++) {\n        int a, b; cin >> a >> b;\n        G.add_edge(a, x + b, 1);\n    }\n    for (int i = 0; i < x; i++) {\n        G.add_edge(x + y, i, 1);\n    }\n    for (int i = 0; i < y; i++) {\n        G.add_edge(x + i, x + y + 1, 1);\n    }\n    cout << G.max_flow(x + y, x + y + 1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n\n  \nll g[102][102];\nll matchU[102];\nll ans;\nbool vis[102];\nll X, Y, E;\n  \nbool dfs(ll v){\n    for (int i = 0; i < Y; i++){\n        if (g[v][i] && !vis[i]){\n            vis[i] = true;\n            if(matchU[i] < 0 || dfs(matchU[i])){\n                matchU[i] = v;\n                return true;\n            }\n        }\n    }\n    return false;\n}\n  \nint main() {\n \n    // 1. 入力.\n    scanf(\"%d %d %d\", &X, &Y, &E);\n     \n    // 2. 始点, 終点.\n    for(int i = 0; i < E; i++) {\n        int fr, to;\n        scanf(\"%d %d\", &fr, &to);\n        g[fr][to] = 1;  \n    }\n     \n    // 3. マッチング.\n    for(int i = 0; i < 102; i++) matchU[i] = -1;\n    for(int i = 0; i < X; i++){\n        for (int j = 0; j < 102; j++) vis[j] = 0;\n        if(dfs(i)) ans++; \n    }\n     \n    // 4. 出力.\n    printf(\"%d\\n\", ans);\n \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstatic const int MAX_V = 200;\nint V, E;\nvector<int> G[MAX_V];\nint match[MAX_V];\nint used[MAX_V];\n\n// u と v を結ぶ辺をグラフに追加する\nvoid add_edge(int u, int v) {\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\n// 増加パスを DFS で探す\nbool dfs(int v) {\n  used[v] = true;\n  for (int i = 0; i < G[v].size(); i++) {\n    int u = G[v][i];\n    int w = match[u];\n    if (w < 0 || !used[w] && dfs(w)) {\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\n// 二部グラフの最大マッチングを求める\nint biparticle_matching() {\n  int res = 0;\n  memset(match, -1, sizeof(match));\n  for (int v = 0; v < V; v++) {\n    if (match[v] < 0) {\n      memset(used, 0, sizeof(used));\n      if (dfs(v)) res++;\n    }\n  }\n  return res;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int X, Y, E;\n  cin >> X >> Y >> E;\n  V = X + Y;\n  for (int i = 0; i < E; i++) {\n    int x, y;\n    cin >> x >> y;\n    add_edge(x, y + 100);\n  }\n  int ans = biparticle_matching();\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\n\nint bipartite_matching(VVI& G, VI& matchU, VI& matchV){\n  int N = G.size();\n  fill(ALL(matchU), -1);\n  fill(ALL(matchV), -1);\n  vector<int> level(N);\n  vector<bool> finished(N);\n\n  int total = 0;\n  for(bool up=true;up;){\n\tup = false;\n\n\t// bfs\n\tfill(ALL(level), -1);\n    queue<int> Q;\n\tREP(i,N){\n\t  if(matchU[i] == -1){\n\t\tlevel[i] = 0;\n\t\tQ.push(i);\n\t  }\n\t}\n\twhile(!Q.empty()){\n      int u = Q.front();\n\t  Q.pop();\n      for(auto to: G[u]){\n\t\tif(matchV[to] != -1 && level[matchV[to]] == -1){\n\t\t  level[matchV[to]] = level[u] + 1;\n\t\t  Q.push(matchV[to]);\n\t\t}\n\t  }\n    }\n\n\t// dfs\n\tfill(ALL(finished), false);\n\tfunction<bool(int)> dfs = [&](int u){\n\t  finished[u] = true;\n\t  for(auto to: G[u]){\n\t\tint bk = matchV[to];\n\t\tif(bk == -1 || (!finished[bk] && level[bk] == level[u]+1 && dfs(bk))){\n\t\t  matchU[u] = to;\n\t\t  matchV[to] = u;\n\t\t  return true;\n\t\t}\n\t  }\n\t  return false;\n\t};\n\n\n\tREP(i,N){\n\t  if(matchU[i] == -1 && dfs(i)){\n\t\tup = true;\n\t\t++total;\n\t  }\n    }\n  }\n  return total;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int X, Y, E;\n  cin >> X >> Y >> E;\n  VVI G(X);\n  REP(i,E){\n\tint x, y;\n\tcin >> x >> y;\n\tG[x].PB(y);\n  }\n  VI mu(X), mv(Y);\n  cout << bipartite_matching(G, mu, mv) << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 200\n\nint V;\nvector<int> G[NUM];\nint match[NUM];\nbool used[NUM];\n\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\tG[to].push_back(from);\n}\n\nint dfs(int node_id){\n\tused[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tint adj_node_id = G[node_id][i],pair_id = match[adj_node_id];\n\t\tif((pair_id < 0)||(used[pair_id] == false && dfs(pair_id) == true)){\n\t\t\tmatch[node_id] = adj_node_id;\n\t\t\tmatch[adj_node_id] = node_id;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint bipartie_matching(){\n\tint ret = 0;\n\tfor(int i = 0; i < V; i++)match[i] = -1;\n\tfor(int node_id = 0; node_id < V; node_id++){\n\t\tif(match[node_id] < 0){\n\t\t\tfor(int i = 0; i < V; i++)used[i] = false;\n\t\t\tif(dfs(node_id)){\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\n\nint main(){\n\n\tint X,Y,E;\n\n\tscanf(\"%d %d %d\",&X,&Y,&E);\n\n\tint from,to;\n\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tadd_edge(from,X+to);\n\t}\n\n\tV = X+Y;\n\n\tprintf(\"%d\\n\",bipartie_matching());\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint X, Y, E, x, y;\nbool D[110][110] = {};\n\nint PY[110];\nbool V[110];\nbool match(int x) {\n\tif (x<0) return true;\n\tif (V[x]) return false;\n\tV[x] = true;\n\tfor (int y = 0; y<Y; ++y) {\n\t\tif (!D[x][y]) continue;\n\t\tif (match(PY[y])) {\n\t\t\tPY[y] = x;\n\t\t\treturn true;\n\n\t\t}\n\t}\n\treturn false;\n}\n\n\nint main() {\n\tcin >> X >> Y >> E;\n\tfor (int i = 0; i<E; ++i) {\n\t\tcin >> x >> y;\n\t\tD[x][y] = true;\n\t}\n\tfill(PY, PY + Y, -1);\n\tint count = 0;\n\tfor (int x = 0; x<X; ++x) { \n\t\tfill(V, V + X, false);\n\t\tif (match(x)) ++count;\n\t}\n\tcout << count << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vin=vector<int>;\nusing vll=vector<long long>;\nusing vvin=vector<vector<int>>;\nusing vvll=vector<vector<long long>>;\nusing vstr=vector<string>;\nusing vvstr=vector<vector<string>>;\nusing vch=vector<char>;\nusing vvch=vector<vector<char>>;\nusing vbo=vector<bool>;\nusing vvbo=vector<vector<bool>>;\nusing vpii=vector<pair<int,int>>;\nusing pqsin=priority_queue<int,vector<int>,greater<int>>;\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep2(i,s,n) for(int i=(s);i<(int)(n);i++)\n#define all(v) v.begin(),v.end()\n#define decp(n) cout<<fixed<<setprecision((int)n)\nconst int inf=1e9+7;\nconst ll INF=1e18;\n\nint MAX_V=210;\n\nvvin g(MAX_V);//グラフの隣接リスト表現\nvin match(MAX_V);//マッチングのペア\nvbo used(MAX_V);\n\nvoid add_edge(int u,int v){\n    g[u].push_back(v);\n    g[v].push_back(u);\n}\n\n//増加パスをdfsで探す\nbool dfs(int v){\n    used[v]=true;\n    for(auto u:g[v]){\n        int w=match[u];\n        if(w<0||(!used[w]&&dfs(w))){\n            match[v]=u;\n            match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\n//二部グラフの最大マッチングを求める\nint max_matching(int v){//vは頂点数\n    int res=0;\n    fill(all(match),-1);\n    rep(i,v){\n        if(match[i]<0){\n            fill(all(used),false);\n            if(dfs(i))res++;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int X,Y,e;cin>>X>>Y>>e;\n    int x,y;\n    rep(i,e){\n        cin>>x>>y;\n        add_edge(x,y+X);\n    }\n    cout<<max_matching(X+Y)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef DEBUG\n#define PRINT(x)\\\n    cout<<\"func \"<<__func__<<\": line \"<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl;\n#define PRINTA(a,first,last)\\\n    cout<<\"func \"<<__func__<<\": line \"<<__LINE__<<\": \"<<#a<<\"[\"<<(first)<<\", \"<<(last)<<\")\"<<endl;\\\n    for (int i=(first);i<(last);++i){cout<<#a<<\"[\"<<i<<\"] = \"<<(a)[i]<<endl;}\n#else\n#define PRINT(x)\n#define PRINTA(a,first,last)\n#endif\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define MOD 1000000007\n\nusing namespace std;\n\ntemplate <class T>\nstruct edge\n{\n    int to;\n    T cap;\n    int rev;\n    edge(int to, T cap, int rev) : to(to), cap(cap), rev(rev) {}\n};\n\ntemplate <class T>\nclass graph\n{\n    private:\n        const int number_of_nodes;\n    public:\n        vector<edge<T> > *edges;\n        graph(int number_of_nodes) : number_of_nodes(number_of_nodes) {\n            edges = new vector<edge<T> >[number_of_nodes];\n        }\n        ~graph() {\n            delete [] edges;\n        }\n        int size() const {return number_of_nodes;}\n        void make_edge(int u, int v, T cap) {\n            edges[u].push_back(edge<T>(v, cap, edges[v].size()));\n            edges[v].push_back(edge<T>(u, 0, edges[u].size() - 1));\n        }\n};\n\n// Ford-Fulkerson algorithm\ntemplate <class T>\nT maximum_flow(graph<T> &g, int source, int sink)\n{\n    bool *used = new bool[g.size()]();\n    function<T(int, T)> dfs = [&](int u, T f) -> T {\n        if (u == sink) {\n            return f;\n        }\n        used[u] = true;\n        for (edge<T> &e: g.edges[u]) {\n            if (!used[e.to] && e.cap > 0) {\n                T d = dfs(e.to, u == source ? e.cap : min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g.edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    };\n    T result = 0;\n    while (true) {\n        fill (used, used + g.size(), 0);\n        T flow = dfs(source, 0);\n        if (flow == 0) {\n            return result;\n        }\n        result += flow;\n    }\n    delete [] used;\n    return result;\n}\n\nint main(void)\n{\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    // 0,...,X-1 are nodes in X\n    // X,...,X+Y-1 are nodes in Y\n    // node X+Y is source\n    // node X+Y+1 is sink\n    graph<int> g(X + Y + 2);\n    int source = X + Y;\n    int sink = X + Y + 1;\n    REP(i, E) {\n        int x, y;\n        cin >> x >> y;\n        g.make_edge(x, y + X, 1);\n    }\n    REP(x, X) g.make_edge(source, x, 1);\n    REP(y, Y) g.make_edge(y + X, sink, 1);\n    cout << maximum_flow(g, source, sink) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint A, B, E, match[5009]; vector<int> G[5009];\nbool used[5009];\n\nbool dfs(int pos) {\n\tused[pos] = true;\n\tfor (int i = 0; i < G[pos].size(); i++) {\n\t\tif (match[G[pos][i]] < 0 || (used[match[G[pos][i]]] == false && dfs(match[G[pos][i]]) == true)) {\n\t\t\tmatch[pos] = G[pos][i];\n\t\t\tmatch[G[pos][i]] = pos;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tcin >> A >> B >> E;\n\tfor (int i = 0; i < E; i++) {\n\t\tint p1, p2; cin >> p1 >> p2;\n\t\tG[p1].push_back(p2 + A);\n\t\tG[p2 + A].push_back(p1);\n\t}\n\tfor (int i = 0; i < A + B; i++) match[i] = -1;\n\n\tint cnt = 0;\n\tfor (int i = 0; i < A + B; i++) {\n\t\tif (match[i] >= 0) continue;\n\t\tfor (int j = 0; j < A + B; j++) used[j] = false;\n\t\tbool I = dfs(i);\n\t\tif (I == true) cnt++;\n\t}\n\tcout << cnt << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <cassert>\n#include <climits>\n#include <string>\n#include <bitset>\n#include <cfloat>\n#include <random>\n#include <iomanip>\n#include <unordered_set>\nusing namespace std;\ntypedef long double ld;\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<bool> vb;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\ntypedef vector<ll> vll;\ntypedef vector<pair<int,int> > vpii;\ntypedef vector<pair<ll,ll> > vpll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<vc> vvc;\ntypedef vector<vs> vvs;\ntypedef vector<vll> vvll;\ntypedef map<int,int> mii;\ntypedef set<int> si;\n#define rep(i,n) for(ll i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define arep(i,v) for(auto i : v)\n#define irep(it, stl) for(auto it = stl.begin(); it != stl.end(); it++)\n#define drep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define fin(ans) cout << (ans) << '\\n'\n#define STLL(s) strtoll(s.c_str(), NULL, 10)\n#define mp(p,q) make_pair(p, q)\n#define pb(n) push_back(n)\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define Sort(a) sort(a.begin(), a.end())\n#define Rort(a) sort(a.rbegin(), a.rend())\n#define MATHPI acos(-1)\n#define fi first\n#define se second\nconstexpr int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate <class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;} return 0;}\ntemplate <class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;} return 0;}\ntemplate <class T> inline void dump(T &v){irep(i, v){cout<<*i<<((i==--v.end())?'\\n':' ');}}\ninline string getline(){string s; getline(cin,s); return s;}\ninline void yn(const bool b){b?fin(\"yes\"):fin(\"no\");}\ninline void Yn(const bool b){b?fin(\"Yes\"):fin(\"No\");}\ninline void YN(const bool b){b?fin(\"YES\"):fin(\"NO\");}\nstruct io{io(){ios::sync_with_stdio(false);cin.tie(0);}};\nconst int INF = INT_MAX;\nconstexpr ll LLINF = 1LL<<60;\nconstexpr ll MOD = 1000000007;\nconstexpr ld EPS = 1e-11;\n\nclass MaximumFlow {\n\n    int v;\n\n    // 辺を表す構造体(行き先，容量，逆辺のインデックス)\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n\n    vector<vector<edge>> G; // グラフの隣接リスト表現\n    vector<bool> used; // DFSですでに調べたかのフラグ\n\n    // 増加パスをDFSで探す(今いる頂点, ゴールの頂点, 今の頂点以降のフローの最小値)\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        used[v] = true;\n        for (int i = 0; i < G[v].size(); i++) {\n            // vから行ける&&cap>0の頂点を全てたどる\n            edge& e = G[v][i];\n            if (!used[e.to] && e.cap > 0) {\n                // 次の頂点(e.to)以降でtまで行けるパスを探索し，その時のフローの最小値をdとする\n                int d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    MaximumFlow(int _v) : v(_v) {\n        used = vector<bool>(v);\n        G = vector<vector<edge>>(v);\n    }\n\n    // fromからtoへ向かう容景capの辺をグラフに追加する\n    void add(int from, int to, int cap) {\n        G[from].push_back((edge){to, cap, (int)G[to].size()});\n        G[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n    }\n\n    // sからtへの最大流を求める\n    int maxFlow(int s, int t) {\n        int flow = 0;\n        while (true) {\n            used = vector<bool>(v);\n            int f = dfs(s, t, INF);\n            if (f == 0) {\n                return flow;\n            }\n            flow += f;\n        }\n    }\n};\n\nint main() {\n\n    int X, Y, E;\n    cin >> X >> Y >> E;\n    MaximumFlow mf(X + Y + 2);\n    rep(i, E) {\n        int x, y;\n        cin >> x >> y;\n        mf.add(x, X + y, 1);\n    }\n    rep(i, X) {\n        mf.add(X + Y, i, 1);\n    }\n    rep(i, Y) {\n        mf.add(X + i, X + Y + 1, 1);\n    }\n    int ans = mf.maxFlow(X + Y, X + Y + 1);\n    cout << ans << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <bitset>\n#include <climits>\n#include <cassert>\n\nusing namespace std;\ntypedef long long ll;\n\nint X,Y,E;\nbool D[128][128] = {0};\nint PY[110];\nbool V[110];\n\nbool match(int x){\n    if(x<0)return true;\n    if(V[x])return false;\n    V[x]=true;\n    for(int y=0;y<Y;++y){\n        if(!D[x][y])continue;\n        if(match(PY[y])){\n            PY[y]=x;\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n\n    \n    cin >> X >> Y >> E;\n    for(int i=0;i<E;++i){\n        int x,y;\n        cin >> x >> y;\n        D[x][y]=true;\n    }\n    for(int y=0;y<Y;++y){\n        PY[y]=-1;\n    }\n    int cnt=0;\n    for(int x=0;x<X;++x){\n        for(int i=0;i<X;++i){\n            V[i]=false;\n        }\n        if(match(x))cnt++;\n    }\n    \n    cout << cnt << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// statics\nusing namespace std;\nusing int64 = long long;\nusing PAIR = pair<int, int>;\nconstexpr int INF = 1 << 30;\nconstexpr int64 LINF = 1LL << 60;\nconstexpr int MOD = 1e9 + 7;\nconstexpr int MAX_N = 1e5 + 1;\nconstexpr int MAX_V = 575;\n\n// init/input\n#define int int64\n#define INIT ios::sync_with_stdio(false);cin.tie(0);\n#define VAR(type, ...) type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T &t) {cin>>t;}\ntemplate<typename First, typename...Rest> void MACRO_VAR_Scan(First &first, Rest&...rest) {cin>>first;MACRO_VAR_Scan(rest...);}\n#define VEC(type, c, n) vector<type> c(n);for(auto &&i:c)cin>>i;\n\n// out\n#define OUT(dist) cout<<(dist);\n#define FOUT(n, dist) cout <<fixed<<setprecision(n)<<(dist);\n#define SP cout<<\" \";\n#define BR cout<<\"\\n\";\n#define debug(x) cerr << #x << \":\" << (x);BR;\n\n// utility\n#define ALL(a) (a).begin(), (a).end()\n#define EACH(i, a) for(auto &&i:(a))\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=0;--i)\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define RREP(i, n) for(int i=(n)-1;i>=0;--i)\n\nint V;\nvector< int > G[MAX_V];\nint match[MAX_V];\nbool used[MAX_V];\n\nvoid add_edge(int from, int to) {\n  G[from].push_back(to);\n  G[to].push_back(from);\n}\n\nbool dfs(int v) {\n  used[v] = true;\n  \n  for (int i = 0; i < (int)G[v].size(); ++i) {\n    int to = G[v][i], w = match[to];\n    if (w < 0 || (!used[w] && dfs(w))) {\n      match[v] = to;\n      match[to] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nsigned main() {\n  INIT;\n\n  VAR(int, X, Y, E);\n  REP(ei, E) {\n    VAR(int, from, to);\n    add_edge(from, X + to);\n  }\n  V = X + Y;\n\n  // 二部グラフの最大マッチング\n  auto bipartie_matching = []() {\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for (int v = 0; v < V; ++v) {\n      if (match[v] < 0) {\n\tmemset(used, 0, sizeof(used));\n\tif (dfs(v) > 0) {\n\t  res++;\n\t}\n      }\n    }\n    return res;\n  };\n  \n  OUT(bipartie_matching())BR;\n\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Dinic {\n  struct Edge{ int to, cap, rev; };\n  int n, init;\n  vector<vector<Edge>> g;\n  vector<int> itr, level;\n\n  Dinic() {}\n  Dinic(int n, int INF = 1e9) : n(n), g(n), init(INF) {}\n\n  void addEdge(int u, int v, int c) {\n    int szU = g[u].size();\n    int szV = g[v].size();\n    g[u].push_back({v, c, szV});\n    g[v].push_back({u, 0, szU - 1});\n  }\n  void bfs(int s) {\n    level = vector<int>(n, -1);\n    queue<int, deque<int>> que({s});\n    level[s] = 0;\n    while (!que.empty()) {\n      int u = que.front(); que.pop();\n      for (auto&& e : g[u]) {\n        int v = e.to;\n        if (level[v] < 0 && e.cap > 0) {\n          level[v] = level[u] + 1;\n          que.push(v);\n        }\n      }\n    }\n  }\n  int dfs(int u, int t, int c) {\n    if (u == t) return c;\n    for (int& i = itr[u]; i < g[u].size(); ++i) {\n      Edge& e = g[u][i];\n      int v = e.to;\n      if (level[u] < level[v] && e.cap > 0) {\n        int f = dfs(v, t, min(c, e.cap));\n        if (f > 0) {\n          e.cap -= f;\n          g[v][e.rev].cap += f;\n          return f;\n        }\n      }\n    }\n    return 0;\n  }\n  int build(int s, int t) {\n    int flow = 0;\n    while (true) {\n      bfs(s);\n      if (level[t] < 0) break;\n      itr = vector<int>(n, 0);\n      int f;\n      while ((f = dfs(s, t, init)) > 0) flow += f;\n    }\n    return flow;\n  }\n};\n\nint main() {\n  int n0, n1, m; cin >> n0 >> n1 >> m;\n  int n = n0 + n1;\n  int s = n, t = s + 1;\n  Dinic f(n + 2);\n  for (int i = 0; i < n0; ++i) f.addEdge(s, i, 1);\n  for (int i = 0; i < n1; ++i) f.addEdge(n0 + i, t, 1);\n  while (m--) {\n    int x, y; cin >> x >> y;\n    f.addEdge(x, n0 + y, 1);\n  }\n  cout << f.build(s, t) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <iomanip>\n#include <deque>\n#include <stdio.h>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;i>=0;i--)\n#define FILL(Itr,n) fill((Itr).begin(),(Itr).end(),n)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\n#define UNIQUE(Itr) sort((Itr).begin(),(Itr).end()); (Itr).erase(unique((Itr).begin(),(Itr).end()),(Itr).end())\n#define LBOUND(Itr,val) lower_bound((Itr).begin(),(Itr).end(),(val))\n#define UBOUND(Itr,val) upper_bound((Itr).begin(),(Itr).end(),(val))\n#define MOD 1000000007\ntypedef long long ll;\ntypedef pair<int,int> P;\n\ntemplate <class T> struct MaxFlow {\n    const T INF = 1e9;\n    struct  Edge {\n        int to,rev; T cap;\n        Edge(){}\n        Edge(int _to, int _rev, T _cap){\n            to = _to; rev = _rev; cap = _cap;\n        }\n    };\n    vector< vector<Edge> > G;\n    vector< bool > used;\n    MaxFlow(int size){\n        G.resize(size+10);\n        used.resize(size+10);\n    }\n    void add_edge(int from, int to, int cap){\n        G[from].push_back(Edge(to,(int)G[to].size(),cap));\n        G[to].push_back(Edge(from,(int)G[from].size()-1,0));\n    }\n    T dfs(int v, int t, T f){\n        if(v==t)return f;\n        used[v] = true;\n        for(int i=0;i<G[v].size();i++){\n            Edge &e = G[v][i];\n            if(!used[e.to] && e.cap>0){\n                T d = dfs(e.to, t, min(f,e.cap));\n                if(d>0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    T getmax(int source, int sink){\n        T flow = 0;\n        while(true){\n            for(int i=0;i<used.size();i++)used[i]=false;\n            T f = dfs(source, sink, INF);\n            if(f==0)return flow;\n            flow += f;\n        }\n    }\n};\n\nint main(){\n    \n    MaxFlow<int> inst(300);\n    \n    int X,Y,E;\n    cin>>X>>Y>>E;\n    \n    set<int> sx,sy;\n    REP(i,E){\n        int x,y; cin>>x>>y;\n        inst.add_edge(x,y+110,1);\n        sx.insert(x);\n        sy.insert(y+110);\n    }\n    \n    for(auto itr=sx.begin();itr!=sx.end();itr++){\n        inst.add_edge(250,*itr,1);\n    }\n    \n    for(auto itr=sy.begin();itr!=sy.end();itr++){\n        inst.add_edge(*itr,260,1);\n    }\n    \n    cout<<inst.getmax(250,260)<<endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing Int = int64_t;\nusing UInt = uint64_t;\nusing C = std::complex<double>;\n#define rep(i, n) for(Int i = 0; i < (Int)(n); ++i)\n#define rep2(i, l, r) for(Int i = (Int)(l); i < (Int)(r); ++i)\n#define guard(x) if( not (x) ) continue;\n#ifndef LOCAL_\n#define fprintf if( false ) fprintf\n#endif\n\nint main() {\n   Int n, m, e;\n   std::cin >> n >> m >> e;\n   std::vector<Int> ss(1), ts(1), fs(1), bs(1);\n   auto addEdge = [&](Int s, Int t, Int f, Int b) {\n      ss.emplace_back(s);\n      ts.emplace_back(t);\n      fs.emplace_back(f);\n      bs.emplace_back(b);\n   };\n   rep(i, e) {\n      Int x, y;\n      std::cin >> x >> y;\n      addEdge(x, n+y, 0, 1);\n   }\n   Int source = n+m, sink = n+m+1;\n   Int v = n + m + 2;\n   rep2(i,0,n)   addEdge(source, i, 0, 1);\n   rep2(i,n,n+m) addEdge(i, sink, 0, 1);\n   std::vector<std::vector<Int>> es(v);\n   rep(i, fs.size()) {\n      Int s = ss[i], t = ts[i];\n      es[s].emplace_back(i);\n      es[t].emplace_back(-i);\n   }\n   Int res = 0;\n   for(;;) {\n      std::queue<Int> q;\n      std::vector<Int> xs(v, -1), ps(v, -1);\n      xs[source] = (Int)1<<53;\n      q.emplace(source);\n      while( not q.empty() ) {\n         Int s = q.front(); q.pop();\n         for(Int i : es[s]) {\n            Int t = i > 0 ? ts[i] : ss[-i];\n            Int w = i > 0 ? bs[i] : fs[-i];\n            guard( w > 0 );\n            guard( xs[t] == -1 );\n            xs[t] = std::min(xs[s], w);\n            ps[t] = i;\n            q.emplace(t);\n         }\n      }\n      Int tf = xs[sink];\n      fprintf(stderr, \"tf=%ld\\n\", tf);\n      if( xs[sink] <= 0 ) break;\n      for(Int i=sink, k=ps[i]; i!=source; i=k>0?ss[k]:ts[-k], k=ps[i]) {\n         if( k > 0 ) {\n            fs[k] += tf;\n            bs[k] -= tf;\n         }\n         else {\n            fs[-k] -= tf;\n            bs[-k] += tf;\n         }\n      }\n      res += tf;\n   }\n   printf(\"%ld\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n//be naame khodaa\n#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\n#define F first\n#define S second\n#define pb push_back\n\ninline int in(){int x, y; y = scanf(\"%d\", &x); return x;}\n\nconst int N = 404;\n\nvector<int> g[N];\nint match[N];\nbool mark[N];\n\nbool dfs (int v){\n\tmark[v] = true;\n\tfor (int u : g[v]){\n\t\tif (match[u] == -1 || (!mark[match[u]] && dfs(match[u]))){\n\t\t\tmatch[v] = u;\n\t\t\tmatch[u] = v;\n\t\t\treturn true;\n\t\t} \n\t}\n\treturn false;\n} \nint maxMatching(int n){\n\tint ret=0;\n\tfill(match, match + N, -1);\n\twhile(true)\n\t{\n\t\tfill(mark, mark + n, false);\n\t\tint lret = ret;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(!mark[i] && match[i] == -1)\n\t\t\t\tret += dfs(i);\n\t\tif(ret == lret)\n\t\t\tbreak;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint n = in(), m = in(), es = in();\n\twhile(es--)\n\t{\n\t\tint u = in(), v = in();\n\t\tg[u].push_back(n + v);\n\t}\n\tcout << maxMatching(n) << endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\nusing namespace std;\n\nstruct edge{ int to,cap,rev; };\n\nint V,E;\nint X,Y;\nvector<edge> G[202];\nbool used[202],can[102][102]={};\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,G[to].size()});\n  G[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    edge &e=G[v][i];\n    if(!used[e.to] && e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n\te.cap-=d;\n\tG[e.to][e.rev].cap+=d;\n\treturn d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    fill(used,used+100,0);\n    int f=dfs(s,t,inf);\n    if(f==0)return flow;\n    flow+=f;\n  }\n}\n\nvoid solve(){\n  int s=X+Y,t=s+1;\n\n  for(int i=0;i<X;i++){\n    add_edge(s,i,1);\n  }\n  for(int i=0;i<Y;i++){\n    add_edge(X+i,t,1);\n  }\n  for(int i=0;i<X;i++){\n    for(int j=0;j<Y;j++){\n      if(can[i][j]){\n\tadd_edge(i,X+j,1);\n      }\n    }\n  }\n  cout<<max_flow(s,t)<<endl;\n}\n\nint main()\n{\n  int x,y;\n  cin>>X>>Y>>E;\n  for(int i=0;i<E;i++){\n    cin>>x>>y;\n    can[x][y]=true;\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long i=(a);i<(b);i++)\n#define RREP(i,n) for(long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define CLR(vec) { REP(i,vec.size()) vec[i] = 0; } \n#define llINF (long long) 9223372036854775807\n#define loINF (long) 2147483647\n#define shINF (short) 32767\n#define SORT(c) sort((c).begin(),(c).end())\n\nusing namespace std;\ntypedef vector<long> VI;\ntypedef vector<VI> VVI;\n// to:次の頂点,cap:辺の重み,rev:逆辺のindex\nstruct edge {long to,cap,rev;};\nclass Ford_fulkerson {\nprivate:\n\tvector<vector<edge>> E;\n\tvector<bool> used;\n\tsize_t V;\npublic:\n\tFord_fulkerson() : V(0) { }\n\n\tFord_fulkerson(size_t v) :\n\t\tE(v,vector<edge>(0)),used(v,false),V(v){ }\n\n\tsize_t size() { return V;}\n\n\tvoid add_edge(long from,long to,long cap){\n\t\tE[from].push_back({to,cap,(long)E[to].size()});\n\t\tE[to].push_back({from,0,(long)E[from].size()-1});\n\t}\n\n\tlong dfs(long node,long goal,long flow){\n\t\tif (node == goal) return flow;\n\t\tused[node] = true;\n\t\tREP(i,E[node].size()){\n\t\t\tedge* e = &E[node][i];\n\t\t\tif (!used[e->to] && e->cap != 0){\n\t\t\t\tlong d = dfs(e->to,goal,min(flow,e->cap));\n\t\t\t\tif (d != 0) {\n\t\t\t\t\te->cap -= d;\n\t\t\t\t\tE[e->to][e->rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tlong max_flow(long start,long goal){\n\t\tlong ans = 0;\n\t\twhile (1){\n\t\t\tREP(i,used.size()) used[i] = false;\n\t\t\tlong f = dfs(start,goal,2147483647);\n\t\t\tif (f == 0) return ans;\n\t\t\tans += f;\n\t\t}\n\t}\n};\n\nint main(void){\n\tlong X,Y,E;\n\tlong x,y;\n\tcin >> X >> Y >> E;\n\tFord_fulkerson ff(X+Y+2);\n\n\tlong start = X+Y;\n\tlong goal = start+1;\n\n\tREP(i,E){\n\t\tcin >> x >> y;\n\t\tff.add_edge(x,y+X,1);\n\t}\n\n\tREP(i,X) ff.add_edge(start,i,1);\n\tFOR(i,X,X+Y) ff.add_edge(i,goal,1);\n\n\tcout << ff.max_flow(start,goal) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#define INF 2000000000\nusing namespace std;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n#define ll long long\n#define PL pair<long long, long long>\n#define P pair<int,int>\n#define mk make_pair\n#define en endl;\n#define WHITE 0\n#define BLACK 2\n#define GRAY 1\n#define repi(start,end) for(int i=start; i<end; i++)\n#define repj(start,end) for(int j=start; j<end; j++)\n#define repk(start,end) for(int k=start; k<end; k++)\n#define repl(start,end) for(int l=start; l<end; l++)\n#define RE return 0;\n\nstruct edge{int to,cap,rev;};\n\nint n,k;\nbool can[1000][1000];\nint used[100];\n\nvector<edge> G[2000000];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\nint dfs(int v,int t,int f){\n  if(v==t) return f;\n  used[v]=true;\n  repi(0, G[v].size()){\n    edge &e=G[v][i];\n    if(!used[e.to]&&e.cap>0){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  for(;;){\n    memset(used, 0, sizeof(used));\n    int f=dfs(s, t, INF);\n    if(f==0) return flow;\n    flow+=f;\n  }\n}\n\nvoid solve(){\n  int s=n+k,t=s+1;\n  \n  repi(0, n){\n    add_edge(s,i,1);\n  }\n  repi(0, k){\n    add_edge(n+i, t, 1);\n  }\n  \n  repi(0, n){\n    repj(0, k){\n      if(can[i][j]){\n        add_edge(i, n+j, 1);\n      }\n    }\n  }\n  \n  cout<<max_flow(s, t)<<en\n}\n\n\n\n\nint main(){\n  /*\n  cin>>n>>k;\n  repi(0, n){\n    int num;\n    cout<<\"        \"<<i<<\":\"<<en\n    cout<<\"how many?     \";\n    cin>>num;\n    cout<<\"encode ->   \";\n    int a;\n    repj(0, num) {cin>>a; can[i][a]=true;}\n  }\n  cout<<en*/\n  \n  int e,a,b;\n  cin>>n>>k>>e;\n  repi(0, e){\n    cin>>a>>b;\n    can[a][b]=true;\n  }\n  \n  solve();\nRE\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nstruct HopcroftKarp {\n\tint n;\n\tvector<vector<int>> g;\n\tvector<int> match, dist;\n\tvector<bool> used, alive;\n\tHopcroftKarp(int n) : n(n), g(n), match(n), dist(n), used(n), alive(n, true) {}\n\tvoid addEdge(int u, int v) {\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\tint maximumMatching() {\n\t\tint cnt = 0;\n\t\tfill(match.begin(), match.end(), -1);\n\t\twhile (true) {\n\t\t\tbuildAlternatingLevelGraph();\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tint flow = 0;\n\t\t\tfor (int u = 0; u < n; u++)\n\t\t\t\tif (match[u] == -1 && augment(u))\n\t\t\t\t\tflow++;\n\t\t\tif (flow == 0)break;\n\t\t\tcnt += flow;\n\t\t}\n\t\treturn cnt;\n\t}\n\tvoid buildAlternatingLevelGraph() {\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int u = 0; u < n; u++)\n\t\t\tif (match[u] == -1) {\n\t\t\t\tq.emplace(u);\n\t\t\t\tdist[u] = 0;\n\t\t\t}\n\t\twhile (q.size()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor (int v : g[u]) {\n\t\t\t\tint w = match[v];\n\t\t\t\tif (w != -1 && dist[w] == -1) {\n\t\t\t\t\tdist[w] = dist[u] + 1;\n\t\t\t\t\tq.emplace(w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\tbool augment(int u) {\n\t\tused[u] = true;\n\t\tfor (int v : g[u]) {\n\t\t\tif (!alive[v])continue;\n\t\t\tint w = match[v];\n\t\t\tif (w == -1 || (!used[w] && dist[w] == dist[u] + 1 && augment(w))) {\n\t\t\t\tmatch[u] = v;\n\t\t\t\tmatch[v] = u;\n\t\t\t\tused[v] = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint X, Y, E; cin >> X >> Y >> E;\n\tHopcroftKarp bm(X + Y);\n\trep(i, 0, E) {\n\t\tint x, y; cin >> x >> y;\n\t\tbm.addEdge(x, X + y);\n\t}\n\tcout << bm.maximumMatching() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x,y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\ntypedef pair<int,int> P;\nstruct edge{ int to,cap,cost,rev;};\nvector<int> G[100010];\nbool used[100010];\nint match[100010];\nint V;//Vは頂点数\n\nvoid add_edge(int u,int v){\nG[u].push_back(v);\nG[v].push_back(u);\n}\n\nbool ddffss(int v){\nused[v]=true;\n  for(int i=0;i<G[v].size();i++){\n    int u=G[v][i],w=match[u];\n    if(w<0 || (!used[w] &&ddffss(w))){\n      match[v]=u;\n      match[u]=v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bi_match(){\n  int res=0;\n  memset(match,-1,sizeof(match));\n  for(int v=0;v<V;v++){\n    if(match[v]<0){\n      memset(used,0,sizeof(used));\n      if(ddffss(v)){\n        res++;\n      }\n    }\n  }\n  return res;\n}\n signed main(){\n \t\n    \t       cin.tie(0);\n    \t\t\tios::sync_with_stdio(false);\nint x,y,e;\n \tcin>>x>>y>>e;\n \tV=x+y;\n \tfor(int i=0;i<e;i++){\n \t\tint s,t;\n \t\tcin>>s>>t;\n \t\tt+=x;\n \t\tadd_edge(s,t);\n \t}\n \tcout<<bi_match()<<endl;\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<iostream>\n#include<algorithm>\n#include<iterator>\n#include<queue>\n#include<set>\n\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nclass Graph{\n    public:\n    typedef struct Edge{\n        ll from, to, cost;\n        Edge(ll f, ll t, ll c): from(f),to(t),cost(c){}\n    } Edge;\n\n    bool isDirected;\n    ll INF = 1LL << 62;\n    ll v; // 頂点数\n    std::vector<Edge> edges;  // 辺のリスト\n    std::vector<std::vector<std::pair<ll,ll>>> list;  // 隣接リスト\n    //std::vector<std::vector<ll>> matrix; // 隣接行列\n    \n    Graph() : isDirected(false){ init(0); }\n    Graph(ll n, bool isDirected=false) : isDirected(isDirected) { init(n); }\n    void init(ll n){\n        v=n;\n        edges.clear();\n        list.assign(n, std::vector<std::pair<ll,ll>>());\n        //matrix.assign(n, std::vector<ll>(n, INF));\n    }\n    void connect(ll from, ll to){\n        con(from, to, 1);\n        if(!isDirected) con(to, from, 1);\n    }\n    void connect(ll from, ll to, ll cost){\n        con(from, to, cost);\n        if(!isDirected) con(to, from, cost);\n    }\n    void con(ll from, ll to, ll cost){\n        edges.push_back(Edge(from,to,cost));\n        list[from].push_back(std::make_pair(to, cost));\n        //matrix[from][to] = cost;\n    }\n};\n\nclass HopcroftKarp{\n    public:\n    Graph G;\n    ll setx, sety;\n    std::vector<ll> dist, match;\n    std::vector<bool> visited, vv;\n\n    HopcroftKarp(Graph G, ll x) : G(G), setx(x),sety(G.v-setx), dist(setx,-1), match(sety,-1), visited(setx, false){}\n\n    void bfs(){\n        dist.assign(setx, -1);\n        std::queue<ll> que;\n        for(ll i=0; i<setx; i++)if(!visited[i]){\n            que.push(i);\n            dist[i]=0;\n        }\n        while(!que.empty()){\n            ll a = que.front(); que.pop();\n            for(ll i=0; i<G.list[a].size(); i++){\n                ll c = match[G.list[a][i].first - setx];\n                if(c>=0 && dist[c]==-1){\n                    dist[c] = dist[a] + 1;\n                    que.push(c);\n                }\n            }\n        }\n    }\n    bool dfs(ll a){\n        vv[a] = true;\n        for(ll i=0; i<G.list[a].size(); i++){\n            ll c = match[G.list[a][i].first - setx];\n            if(c<0 || (!vv[c] && dist[c]==dist[a]+1 && dfs(c))){\n                match[G.list[a][i].first - setx] = a;\n                visited[a] = true;\n                return true;\n            }\n        }\n        return false;\n    }\n    ll Bipartite_Matching(){\n        ll ret = 0;\n        while(true){\n            bfs();\n            vv.assign(setx, false);\n            ll fl = 0;\n            for(ll i=0; i<setx; i++){\n                if(!visited[i] && dfs(i)) fl++;\n            }\n            if(fl==0) return ret;\n            ret += fl;\n        }\n    }\n};\n\n\nint main(){\n    ll xs,ys,e,x,y;\n    cin >> xs >> ys >> e;\n    Graph G(xs+ys, true);\n    REP(i,e){\n        cin >> x >> y;\n        G.connect(x,xs+y,1); // 0, ... ,xs-1, 0(xs), ... ,ys-1(xs+ys-1)\n    }\n    HopcroftKarp hk(G, xs);\n    cout << hk.Bipartite_Matching() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct HopcroftKarp {\n  vector< vector< int > > graph;\n  vector< int > dist, match;\n  vector< bool > used, vv;\n\n  HopcroftKarp(int n, int m) : graph(n), match(m, -1), used(n) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n\n  void output() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        cout << match[i] << \"-\" << i << endl;\n      }\n    }\n  }\n};\n\nint main() {\n  int X, Y, E;\n  scanf(\"%d %d %d\", &X, &Y, &E);\n  HopcroftKarp bm(X, Y);\n  for(int i = 0; i < E; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    bm.add_edge(a, b);\n  }\n  printf(\"%d\\n\", bm.bipartite_matching());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define rrep(i,n) for(int (i)=((n)-1);(i)>=0;(i)--)\n#define itn int\n#define miele(v) min_element(v.begin(), v.end())\n#define maele(v) max_element(v.begin(), v.end())\n#define SUM(v) accumulate(v.begin(), v.end(), 0LL)\n#define lb(a, key) lower_bound(a.begin(),a.end(),key)\n#define ub(a, key) upper_bound(a.begin(),a.end(),key)\n#define COUNT(a, key) count(a.begin(), a.end(), key) \n#define BITCOUNT(x) __builtin_popcount(x)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define F first\n#define S second\nusing P = pair <int,int>;\nusing WeightedGraph = vector<vector <P>>;\nusing UnWeightedGraph = vector<vector<int>>;\nusing Real = long double;\nusing Point = complex<Real>; //Point and Vector2d is the same!\nusing Vector2d = complex<Real>;\nconst long long INF = 1LL << 60;\nconst int MOD = 1000000007;\nconst double EPS = 1e-15;\nconst double PI=3.14159265358979323846;\ntemplate <typename T> \nint getIndexOfLowerBound(vector <T> &v, T x){\n    return lower_bound(v.begin(),v.end(),x)-v.begin();\n}\ntemplate <typename T> \nint getIndexOfUpperBound(vector <T> &v, T x){\n    return upper_bound(v.begin(),v.end(),x)-v.begin();\n}\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\n#define DUMPOUT cerr\n#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\nistream &operator>>(istream &is, Point &p) {\n    Real a, b; is >> a >> b; p = Point(a, b); return is;\n}\ntemplate <typename T, typename U>\nistream &operator>>(istream &is, pair<T,U> &p_var) {\n    is >> p_var.first >> p_var.second;\n    return is;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n    DUMPOUT<<'{';\n    os << pair_var.first;\n    DUMPOUT<<',';\n    os << \" \"<< pair_var.second;\n    DUMPOUT<<'}';\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<T> &vec) {\n    DUMPOUT<<'[';\n    for (int i = 0; i < vec.size(); i++) \n    os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    DUMPOUT<<']';\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, vector<vector<T>> &df) {\n  for (auto& vec : df) os<<vec;\n  return os;\n}\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> &map_var) {\n    DUMPOUT << \"{\";\n    repi(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) DUMPOUT << \", \";\n        itr--;\n    }\n    DUMPOUT << \"}\";\n    return os;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> &set_var) {\n    DUMPOUT << \"{\";\n    repi(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) DUMPOUT << \", \";\n        itr--;\n    }\n    DUMPOUT << \"}\";\n    return os;\n}\nvoid print() {cout << endl;}\ntemplate <class Head, class... Tail>\nvoid print(Head&& head, Tail&&... tail) {\n  cout << head;\n  if (sizeof...(tail) != 0) cout << \" \";\n  print(forward<Tail>(tail)...);\n}\nvoid dump_func() {DUMPOUT << '#'<<endl;}\ntemplate <typename Head, typename... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) DUMPOUT << \", \";\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                              \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                            \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\"        \\\n            << endl                                                            \\\n            << \"    \",                                                         \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\nstruct edge {int to, cap, rev;};\nconst int MAX_V = 320;\nvector <edge> G[MAX_V];\nbool used[MAX_V];\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back((edge){to, cap, (int)G[to].size()} );\n    G[to].push_back((edge){from, 0, (int)G[from].size()-1});\n}\n\nint dfs(int v, int t, int f){\n    if(v==t) return f;\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f,e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s,t,INF);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\nsigned main(void) { cin.tie(0); ios::sync_with_stdio(false);\n    int x, y, z; cin>>x>>y>>z;\n    rep(i, x){\n        add_edge(300, i, 1);\n    }\n    rep(i, y){\n        add_edge(150+i ,301, 1);\n    }\n    rep(i, z){\n        int a, b; cin>>a>>b;\n        add_edge(a, 150+b, 1);\n    }\n    print(max_flow(300, 301));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<algorithm>\n#include<vector>\nstruct bimatch{\n\tint n;\n\tvector<vector<int> >G;\n\tvector<int>match;\n\tvector<bool>used;\n\tbimatch(int _n=0):n(_n),G(n),match(n),used(n){}\n\tvoid add_edge(int u,int v)\n\t{\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tbool dfs(int v)\n\t{\n\t\tused[v]=true;\n\t\tfor(int u:G[v])\n\t\t\n\t\t{\n\t\t\tint w=match[u];\n\t\t\tif(w<0||!used[w]&&dfs(w))\n\t\t\t{\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint count()\n\t{\n\t\tint ans=0;\n\t\tfill(match.begin(),match.end(),-1);\n\t\tfor(int v=0;v<n;v++)\n\t\t{\n\t\t\tif(match[v]<0)\n\t\t\t{\n\t\t\t\tfill(used.begin(),used.end(),false);\n\t\t\t\tif(dfs(v))ans++;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n};\nint X,Y,E;\nmain()\n{\n\tcin>>X>>Y>>E;\n\tbimatch m(X+Y);\n\tfor(int i=0;i<E;i++)\n\t{\n\t\tint x,y;cin>>x>>y;\n\t\tm.add_edge(x,X+y);\n\t}\n\tcout<<m.count()<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\nstruct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) {}\n};\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n\nconst int INF = 100000000;\n\n\n// 1-indexed\n\nbool cmp(const pii& a, const pii&b){\n    if(a.first == b.first){\n        return a.second < b.second;\n    }\n\n    return a.first < b.first;\n}\nstruct edge{\n    int to, cap, rev;\n    edge(int a, int b, int c){\n        to = a;\n        cap = b;\n        rev = c;\n    }\n};\nvector<edge> G[510];\nbool used[510];\nint X, Y, n, m;\n\nvoid add_edge(int from, int to, int cap){\n    G[from].push_back({to, cap, (int)G[to].size()});\n    G[to].push_back({from, 0, (int)G[from].size()-1});\n}\n\nint dfs(int v, int t , int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i=0; i<G[v].size(); ++i){\n        edge &e = G[v][i];\n        if(!used[e.to] && e.cap > 0){\n            int d = dfs(e.to, t, min(f, e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\nint max_flow(int s, int t){\n    int flow = 0;\n    for(;;) {\n        memset(used, 0, sizeof(used));\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n}\nint main() {\n    //cout << fixed << setprecision(15);\n    cin >> X >> Y >> m;\n\n    int s = X+Y, t = s+1;\n    REP(i, X){\n        add_edge(s, i, 1);\n    }\n    REP(i, Y){\n        add_edge(X+i, t, 1);\n    }\n\n    for(int i=0; i<m; ++i){\n        int u, v; cin >> u >> v;\n        add_edge(u, X+v, 1);\n    }\n    cout << max_flow(s, t) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<sstream>\n#include<map>\n#include<cmath>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i < n;i++)\n#define req(i,n) for(int i = 1;i <=n;i++)\n#define rrep(i,n) for(int i = n -1;i >= 0;i--)\ntypedef long long ll;\ntypedef long double ld;\nconst ll MOD =  1000000007;\nstruct edge {\n    int to, cap, rev;// 行先　容量　逆辺\n};\nvector<edge> g[1010]; bool used[1010];\nvoid add(int u, int v, int f) {\n    g[u].push_back(edge{ v,f,(int)g[v].size() });\n    g[v].push_back(edge{ u,0,(int)g[u].size() - 1 });\n}\nint dfs(int pos, int to, int f) {\n    if (pos == to) return f;\n    used[pos] = 1;\n    rep(i, g[pos].size()) {\n        if (g[pos][i].cap == 0 || used[g[pos][i].to]) continue;\n        int D = dfs(g[pos][i].to, to, min(g[pos][i].cap, f));\n        if (D >= 1) {\n            g[pos][i].cap -= D;\n            g[g[pos][i].to][g[pos][i].rev].cap += D;\n            return D;\n        }\n    }return 0;\n}\nint max_flow(int s, int t) {\n    int F = 0; for (;;) {\n        fill(used, used + 1001, 0);\n        int F2 = dfs(s, t, (1e9));\n        F += F2;\n        if (F2 == 0) return F;\n    }return MOD;\n}\nint n, m, a, b, c[1000],E;\nint main() {\n    cin >> n >> m >> E;\n    rep(i, n) add(n + m, i, 1);\n    rep(i, m) add(i + n, n + m + 1, 1);\n    rep(i, E) {\n        cin >> a >> b;\n        add(a, b + n, 1);\n    }cout << max_flow(n + m , n + m + 1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <unordered_map>\n \nusing namespace std;\n \nint v,e;\nunordered_map<int,unordered_map<int,int> > g;\n \nint dfs(int pos, int flow, unordered_map<int,bool> &arrived) {\n    if(pos==v-1) return flow;\n    arrived[pos] = true;\n    for(pair<int,int> p : g[pos]) {\n        int next = p.first;\n        int capacity = p.second;\n        if(!arrived[next]&&capacity>0) {\n            int res = dfs(next,min(flow,capacity),arrived);\n            if(res>0) {\n                g[pos][next] -= res;\n                g[next][pos] += res;\n                if(g[pos][next]<=0) g[pos].erase(next);\n                return res;\n            }\n        }\n    }\n    return 0;\n}\n \nint main() {\n    int x,y,e;\n    cin >> x >> y >> e;\n    v = x+y+2;\n    for(int i = 0; i < e; i++) {\n        int u,v2;\n        cin >> u >> v2;\n        g[u+1][v2+x+1] = 1;\n    }\n    for(int i = 0; i < x; i++) {\n        g[0][1+i] = 1;\n    }\n    for(int i = 0; i < y; i++) {\n        g[1+x+i][v-1] = 1;\n    }\n    int ans = 0;\n    while(true) {\n        unordered_map<int,bool> arrived(v);\n        int flow = dfs(0,1<<30,arrived);\n        if(flow<=0) break;\n        else ans += flow;\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nconst int MAX_N=500;\n\nstruct edge{\n\tint to,cap,rev;\n};\n\nvector<edge> G[MAX_N];\nvector<int> check(MAX_N,0);\n\nint dfs(int v,int t, int f ){\n\tif(v==t){return f;}\n\tcheck[v]=1;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(check[G[v][i].to]==0 && G[v][i].cap > 0){\n\t\t\tint ff =dfs(G[v][i].to,t,min(f,G[v][i].cap));\n\t\t\tif(ff>0){\n\t\t\t\tG[v][i].cap -= ff;\n\t\t\t\tG[G[v][i].to][G[v][i].rev].cap += ff;\n\t\t\t\treturn ff;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint maxflow(int s,int t){\n\tint flow = 0;\n\twhile(1){\n\t\tfill(check.begin(),check.end(),0);\n\t\tint f = dfs(s,t,INT_MAX);\n\t\tif(f==0){return flow;}\n\t\tflow += f;\n\t}\n}\n\nint main(){\n\tint X,Y,E,s,t;\n\tcin >> X >> Y >> E ;\n\t\n\tfor(int i=0;i<E;i++){\n\t\tcin >> s >> t ;\n\t\tG[s].push_back((edge){X+t,1,G[X+t].size()});\n\t\tG[X+t].push_back((edge){s,0,G[s].size()-1});\n\t}\n\t\n\tfor(int i=0;i<X;i++){\n\t\tG[X+Y].push_back((edge){i,1,G[i].size()});\n\t\tG[i].push_back((edge){X+Y,0,G[X+Y].size()-1});\n\t}\n\t\n\tfor(int i=X;i<X+Y;i++){\n\t\tG[i].push_back((edge){X+Y+1,1,G[X+Y+1].size()});\n\t\tG[X+Y+1].push_back((edge){i,0,G[i].size()-1});\n\t}\n\t\n\tcout << maxflow(X+Y,X+Y+1) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> Vi;\ntypedef tuple<int, int, int> T;\n#define FOR(i,s,x) for(int i=s;i<(int)(x);i++)\n#define REP(i,x) FOR(i,0,x)\n#define ALL(c) c.begin(), c.end()\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n#define INF 1<<29\n\ntemplate <typename T>\nstruct BipartiteMatching {\n  struct edge { int to, rev; T cap; };\n\n  typedef vector<edge> Edges;\n  vector<Edges> G;\n  int V, source, sink;\n  vector<int> level, iter;\n  \n  BipartiteMatching(int V1, int V2) {\n    V = V1 + V2 + 2, source = V-2, sink = V-1;\n    G.resize(V);\n    add_sink_source(V1, V2);\n  }\n\n  void add_edge(int from, int to) {\n    G[from].push_back((edge){to, (int)G[to].size(), 1});\n    G[to].push_back((edge){from, (int)G[from].size()-1, 0});\n  }\n\n  void add_sink_source(int V1, int V2) {\n    for (int i = 0; i < V1; i++) add_edge(source, i);\n    for (int i = V1; i < V1+V2; i++) add_edge(i, sink);\n  }\n\n  void bfs(int source) {\n    level.assign(V, -1);\n    queue<int> que;\n    que.push(source);\n    level[source] = 0;\n    while (!que.empty()) {\n      int v = que.front(); que.pop();\n      for (int i = 0; i < (int)G[v].size(); i++) {\n\tedge &e = G[v][i];\n\tif (e.cap > 0 && level[e.to] < 0) {\n\t  level[e.to] = level[v] + 1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n\n  T dfs(int v, int sink, T flow) {\n    if (v == sink) return flow;\n    for (int &i = iter[v]; i < (int)G[v].size(); i++) {\n      edge &e = G[v][i];\n      if (e.cap > 0 && level[v] < level[e.to]) {\n\tT d = dfs(e.to, sink, min(e.cap, flow));\n\tif (d > 0) {\n\t  e.cap -= d;\n\t  G[e.to][e.rev].cap += d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n\n  T dinic() {\n    T flow = 0;\n    while (true) {\n      bfs(source);\n      if (level[sink] < 0) return flow;\n      iter.assign(V, 0);\n      T f;\n      while ((f = dfs(source, sink, INF)) > 0) {\n\tflow += f;\n      }\n    }\n  }\n};\n\n\nint main() {\n  // use scanf in CodeForces!\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int X, Y, E;\n  cin >> X >> Y >> E;\n  BipartiteMatching<int> bp(X, Y);\n  REP(i, E) {\n    int x, y;\n    cin >> x >> y;\n    bp.add_edge(x, X+y);\n  }\n  cout << bp.dinic() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//AOJ-GRL-7-A\n#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,a) for(int i = 0; i < (a); i++)\n#define ALL(a) (a).begin(),(a).end()\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\n#define MAX_V 200\n\nint V;//頂点数\nvector<int> G[MAX_V];//グラフの隣接リスト表現\nint match[MAX_V];//マッチングのペア\nbool used[MAX_V];//DFSですでに調べたかのフラグ\n\n//uとvを結ぶ辺をグラフに追加する\nvoid add_edge(int u, int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n}\n\n//増加パスをDFSで探す\nbool dfs(int v){\n    used[v] = true;\n    for(int i = 0; i < G[v].size(); i++){\n        int u = G[v][i], w = match[u];\n        if(w < 0 || !used[w] && dfs(w)){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\n\n//二部グラフの最大マッチングを求める\nint bipartite_matching(){\n    int res = 0;\n    memset(match, -1, sizeof(match));\n    for(int v = 0; v < V; v++){\n        if(match[v] < 0){\n            memset(used, 0, sizeof(used));\n            if(dfs(v)){\n                res++;\n            }\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    int X,Y,e;\n    cin >> X >> Y >> e;\n    V = X + Y;\n    int x,y;\n    REP(i,e){\n        cin >> x >> y;\n        add_edge(x, X + y);\n    }\n    cout << bipartite_matching() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ?????§???????±??????? ?????§???????????????F??¨????????????O(F|E|) ?????????????????¨??????????????????:max_flow()\n// ?????¬p.190\n#include <algorithm>\n#include <vector>\n#include <cfloat>\n#include <string>\n#include <cmath>\n#include <set>\n#include <cstdlib>\n#include <map>\n#include <ctime>\n#include <iomanip>\n#include <functional>\n#include <deque>\n#include <iostream>\n#include <cstring>\n#include <queue>\n#include <cstdio>\n#include <stack>\n#include <climits>\n#include <sys/time.h>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define INF INT_MAX\n// ????????°????????§??°\n#define MAX_V 100000\n// ??°????????????????????°\nint V;\n// ??°?????????edge?????????????????¨????????????????????¨?????¨???\nvector <int> graph[MAX_V];\nint match[MAX_V];\nbool vis[MAX_V];\n\n// \nvoid add_edge(int u, int v) {\n  graph[u].push_back(v);\n  graph[v].push_back(u);\n}\n\nbool dfs(int v) {\n  vis[v] = true;\n  for (int i = 0; i < graph[v].size(); i++) {\n    int u = graph[v][i], w = match[u];\n    if (w < 0 || !vis[w] && dfs(w)) {\n      match[v] = u;\n      match[u] = v;\n      return true;\n    }\n  }\n  return false;\n}\n\nint bipartite_matching() {\n  int ret = 0;\n  memset(match, -1, sizeof(match));\n  for (int v = 0; v < V; v++) {\n    if (match[v] < 0) {\n      memset(vis, false, sizeof(vis));\n      if (dfs(v)) {\n\tret++;\n      }\n    }\n  }\n  return ret;\n}\n\nint main() {\n  int x, y, e;\n  cin >> x >> y >> e;\n  V = x+y;\n  for (int i = 0; i < e; i++) {\n    int s, t;\n    cin >> s >> t;\n    add_edge(s, x+t);\n  }\n\n  cout << bipartite_matching() << endl;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\nstruct node {\n  int id;\n  int cap;\n  struct node *next;\n};\nstruct node **list;\nint **flow, *visit, *delta, *prev, *stack;\nvoid Insert(int, int);\nint Maxflow(int, int, int);\nint main(void)\n{\n  int i, x, y, v, e, s, t, maxflow = 0;\n  scanf(\"%d %d %d\", &x, &y, &e);\n  v = x + y + 2;\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  flow = (int**)malloc(sizeof(int*) * v);\n  visit = (int*)malloc(sizeof(int) * v);\n  delta = (int*)malloc(sizeof(int) * v);\n  prev = (int*)malloc(sizeof(int) * v);\n  stack = (int*)malloc(sizeof(int) * v);\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n    flow[i] = (int*)calloc(v, sizeof(int));\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d\", &s, &t);\n    Insert(0, s + 1);\n    Insert(x + t + 1, v - 1);\n    Insert(s + 1, x + t + 1);\n  }\n  while (Maxflow(0, v - 1, v)) {\n    int n = v - 1;\n    do {\n      flow[prev[n]][n] += delta[v-1];\n      flow[n][prev[n]] -= delta[v-1];\n      n = prev[n];\n    } while(n);\n    maxflow += delta[v-1];\n  }\n  printf(\"%d\\n\", maxflow);\n  for (i = 0; i < v; i++) {\n    free(list[i]);\n    free(flow[i]);\n  }\n  free(list);\n  free(flow);\n  free(visit);\n  free(delta);\n  free(prev);\n  free(stack);\n}\nvoid Insert(int a, int b)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->cap = 1;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->cap = 0;\n  p->next = list[b];\n  list[b] = p;\n}\nint Maxflow(int s, int t, int size)\n{\n  struct node *n;\n  int i, reached = 0, tail = 0;\n  for (i = 0; i < size; i++) {\n    visit[i] = 0;\n    delta[i] = INT_MAX;\n    prev[i] = -1;\n  }\n  visit[s] = 1;\n  stack[tail++] = s;\n  do {\n    i = stack[--tail];\n    for (n = list[i]; n != NULL; n = n->next) {\n      int v = n->id;\n      if (!visit[v] && flow[i][v] < n->cap) {\n        stack[tail++] = v;\n        visit[v] = 1;\n        prev[v] = i;\n        delta[v] = MIN(delta[i], n->cap - flow[i][v]);\n        if (v == t) reached = 1;\n      }\n    }\n  } while (tail && !reached);\n  return reached;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\nstruct node {\n  int id;\n  int cap;\n  struct node *next;\n};\nstruct node **list;\nint **flow, *visit;\nvoid Insert(int, int);\nint Maxflow(int, int, int, int);\nint main(void)\n{\n  int i, x, y, v, e, s, t, maxflow = 0;\n  scanf(\"%d %d %d\", &x, &y, &e);\n  v = x + y + 2;\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  flow = (int**)malloc(sizeof(int*) * v);\n  visit = (int*)malloc(sizeof(int) * v);\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n    flow[i] = (int*)calloc(v, sizeof(int));\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d\", &s, &t);\n    Insert(0, s + 1);\n    Insert(x + t + 1, v - 1);\n    Insert(s + 1, x + t + 1);\n  }\n  while (1) {\n    int f;\n    for (i = 0; i < v; i++) visit[i] = 0;\n    f = Maxflow(0, v - 1, v, INT_MAX);\n    if (!f) break;\n    maxflow += f;\n  }\n  printf(\"%d\\n\", maxflow);\n  for (i = 0; i < v; i++) {\n    free(list[i]);\n    free(flow[i]);\n  }\n  free(list);\n  free(flow);\n  free(visit);\n}\nvoid Insert(int a, int b)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->cap = 1;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->cap = 0;\n  p->next = list[b];\n  list[b] = p;\n}\nint Maxflow(int s, int t, int size, int f)\n{\n  struct node *n;\n  visit[s] = 1;\n  if (s == t) return f;\n  for (n = list[s]; n != NULL; n = n->next) {\n    int v = n->id;\n    if (!visit[v] && flow[s][v] < n->cap) {\n      int d = Maxflow(v, size - 1, size, MIN(f, n->cap - flow[s][v]));\n      if (d > 0) {\n        flow[s][v] += d;\n        flow[v][s] -= d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define vmaxsize         1000\n#define emaxsize         4000\n#define unvisited          -1\n#define undefined          -1\n#define noparent            0\n#define free                0\n#define false               0\n#define true                1\nint tail[emaxsize+1], head[emaxsize+1];\nint edgefirst[vmaxsize+1], edgenext[emaxsize+1];\nint match[vmaxsize+1];  // ???v?????\\?¶?????????????????????°??????match[v]\nint m, n, n1, n2;       // ?????´????????°n1????????´????????°n2???n=n1+n2\n\n\n\n\n// ???????????????????????°??????LevelConstruct.h\nint level[vmaxsize+1];  // ??¬????????°?????????????????????v?????¬??????level[v]\nint queue[vmaxsize+1];  // ???????????¢?´¢?????????????????\\???\nint max_level;          // ????????????????????????????????´?????????????°???¬??????\nint t_found;            // ????????????????????????????????´???????????°???????????¨???t_found=true\nint front, rear;        // ?????\\????????????front??¨????°?rear\n\n// ???????????????????????°?????? Augmentation.h\nint parent[vmaxsize + 1]; // ??±???????????¢?´¢??¨???????????????v??????parent[v]\nint pathfound, pathend;   // ?¢??????????????????¨ (pathfound=true)???pathend????????´?????????\n\n// Hopcroft-Karp????????§??????????????°????±???????????????°?????? hopkarp.c\n\nvoid bipartite_graph_input(void){\n    int a;\n    scanf(\"%d %d %d\", &n1, &n2, &m);\n    n=n1+n2; // n?????°??????????????°\n    for (a = 1; a <= m; a++) {\n        scanf(\"%d %d\", &tail[a], &head[a]);\n    }\n}\nvoid bipartite_incidence_list_construct(void){\n    int a, v1;\n    for (v1 = 1; v1 <= n1; v1++) edgefirst[v1] = 0;\n    for (a = m; a >= 1; a--) {\n        v1 = tail[a];\n        edgenext[a] = edgefirst[v1];\n        edgefirst[v1] = a;\n    }\n}\nvoid matching_output(void){\n    int a, v1, k;\n    k=0; \n    for (v1 = 1; v1 <= n1; v1++) {\n        if (match[v1] != free) {\n            k++;\n        }\n    }\n    printf(\"%d\\n\", k);\n}\n\nvoid bipartite_bfs(int v1){// ?????´??????v1??????????????¨??°????????§??????????????¢?´¢\n    int v2, w1;\n    int a,b;\n    for(a = edgefirst[v1]; a != 0; a = edgenext[a]) {// v1?????\\?¶???????????????????????????????????????????????????§??\\????????°?????????\n        v2 = head[a]; // a????????´??????v1???????????´??????v2???????????????????????¨?????????\n        if(level[v2] != unvisited){ // ?????´??????v2????¨???????????????¨???????????????????????????\n            ;\n        }else{// v2????????´????????§??????????¨????\n            level[v2] = level[v1] + 1;\n            if (t_found == n + 2){// ?¢??????????????????????????????£????????????\n                if (match[v2] != free) {// v2???????????????????????????\n                    b = match[v2]; // ??????????????°??????b\n                    w1 = tail[b]; // b????????????v2???????????????w1???????????????????????????\n                    level[w1] = level[v2] + 1; \n                    queue[++rear] = w1;\n                }\n                else {// v2???????????????????????????????????§v1??????v2????????????????¢??????????\n                    t_found = rear + 1; // t_found<n+2 ????¢??????????????????¨?????????\n                    max_level = level[v2];\n                }\n            }\n        }\n    }\n}\nvoid levelgraph(void){// ??¬????????°??????????§????\n    int v,v1;\n    rear = 0;    // ?????\\???????????????\n    front = 1;\n    t_found=n+2; // ?¢?????????????????????????????????????????????¨???????¨????\n    for (v = 1; v <= n; v++) level[v] = unvisited; // ????????????????¨??????¨???????¨????\n    for (v1 = 1; v1 <= n1; v1++) {\n        if (match[v1] == free) {// v1???????????????????????????????????´??????\n            level[v1] = 0; // v1??????????????¨??°????????????????????¢?´¢????????§????????????\n            queue[++rear] = v1; //?????\\???queue???????°????v1????????\\\n        }\n    }\n\n\n\n    while (front < t_found) {// ?¢???????????????????????????????????????????\n        if (front != rear + 1) {// ?????\\???queue????????§??????????????°?????????\n            v1 = queue[front++]; // ?????\\?????????????????????v1?????????\n            bipartite_bfs(v1); //v1??????????????¨??°????????????????????¢?´¢????§?\n        }\n        else {// ?????\\???queue????????§???????????§???while?????????????????¶????????????\n            break;\n        }\n    }\n\n\n    \n}\nvoid bipartite_dfs(int v1)\n{ // ?????´??????v1??????????????¨??°????????§?????±???????????¢?´¢\n    int v2, w1;\n    int a, b;\n    for (a = edgefirst[v1]; a != 0; a = edgenext[a])\n    {                 // v1?????\\?¶???????????????????????????????????????????????????§??\\????????°?????????\n        v2 = head[a]; // a????????´??????v1???????????´??????v2???????????????????????¨?????????\n        if (parent[v2] == undefined && level[v2] == level[v1] + 1)\n        {\n            parent[v2] = a; // a????????´??????v2?????????????????´??????v1???????????¨?????????\n            if (level[v2] != max_level)\n            {                   // v2????????´????????§????????????????????????\n                b = match[v2];  // ??????????????°??????b\n                w1 = tail[b];   // b????????????v2???????????????w1?????????????????????????????¨?????????\n                parent[w1] = b; // b????????´??????w1????????????v2?????????\n                bipartite_dfs(w1);\n                if (pathfound)\n                    return; //Added by Goro Satake\n            }\n            else\n            { // level[v2] == max_level\n                if (match[v2] == free)\n                {                     // v2????????´????????§???????????????????????????\n                    pathend = v2;     // ?¢??????????????????????v2\n                    pathfound = true; // ?¢????????????????\n                    return;           // ?¢????????????????????????°?????¶????????????????????±??????????????????????±????????????????\n                }\n            }\n        }\n    }\n}\nvoid augmentation(void)\n{\n    int v, v1, v2, w1;\n    int a, b;\n    for (v = 1; v <= n; v++)\n        parent[v] = undefined;\n    for (v1 = 1; v1 <= n1; v1++)\n    {\n        if (match[v1] != free)\n        {\n            continue;\n        }\n        else\n        {                          // v1???????????????????????????????????´??????\n            pathfound = false;     // v1??????????¢???????????????¢?´¢\n            parent[v1] = noparent; // v1???????????±???????????¢?´¢??¨?????????v1\n            bipartite_dfs(v1);     // v1???????????±?????????\n            if (!pathfound)\n            {\n                continue;\n            }\n            else\n            {                   // v1???????????±???????????§pathend???????¢????????????????\n                v2 = pathend;   // ??±???????????¢?´¢??¨??§pathend???????????????v1?????§?????????\n                a = parent[v2]; // ????????????????????????????????°?????¨?????????????????°????????????\n                match[v2] = a;\n                w1 = tail[a];\n                match[w1] = a;\n                while (w1 != v1)\n                {\n                    b = parent[w1];\n                    v2 = head[b];\n                    a = parent[v2];\n                    match[v2] = a;\n                    w1 = tail[a];\n                    match[w1] = a;\n                }\n            }\n        }\n    }\n}\nint main(void){\n    int v;\n    bipartite_graph_input(); \n    // ?????¨??°??????????????°m????????´?????°n1????????´?????°n2?????????????§?????????????????±?????????????\n    bipartite_incidence_list_construct(); // ??\\?¶?????????????????§?????????????\n    for (v = 1; v <= n; v++) match[v] = free; // ?????´??????????????????????????????????????????\n    levelgraph();\n    while(t_found != n + 2){\n        augmentation();\n        levelgraph();\n    }\n    matching_output(); // ??????????????????????????°?????????\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_X_Y (101)\n#define MAX_E (10001)\n#define MATCH (1)\n#define NO_MATCH (0)\n#define VISIT (1)\n#define NO_VISIT (0)\n#define NO_ID (-1)\n#define X_TO_Y (0)\n#define Y_TO_X (1)\n\ntypedef struct _Point{\n    int dst[MAX_X_Y];\n    int size;\n} Point;\n\nint bipartite_matching(int type, Point *pair, int src, int* is_visits) {\n    int i, size, dst;\n    if(src<0) return NO_MATCH;\n\n    for(i=0,size=pair[src].size;i<size;i++) {\n        dst = pair[src].dst[i];\n        if(is_visits[dst] == NO_VISIT) {\n            is_visits[dst] = VISIT;\n            if(type == Y_TO_X) return MATCH;\n            \n            if(bipartite_matching(Y_TO_X, pair, dst, is_visits) == MATCH) {\n                // X側からとY側、両方マッチすれば\n                return MATCH;\n            }\n        }\n    }\n\n    return NO_MATCH;\n}\n\nint solve(int X, int Y, int E) {\n    int i, x, y;\n    Point pair[MAX_X_Y*2];\n    int is_visits[MAX_E*2];\n    int count;\n\n    for(i=0;i<MAX_E*2;i++) is_visits[i] = NO_VISIT;\n    for(i=0;i<MAX_X_Y*2;i++) pair[i].size = 0;\n\n    for(i=0;i<E;i++) {\n        scanf(\"%d %d\\n\", &x, &y);\n        y += MAX_X_Y;\n        pair[x].dst[pair[x].size++] = y;\n        pair[y].dst[pair[y].size++] = x;\n    }\n\n    count = 0;\n    for(i=0;i<X;i++) {\n        if(bipartite_matching(X_TO_Y, pair, i, is_visits) == MATCH) {\n            count ++;\n        }\n    }\n\n    return count;\n}\n\nint main(void) {\n    int X, Y, E;\n\n    scanf(\"%d %d %d\\n\", &X, &Y, &E);    \n    printf(\"%d\\n\", solve(X, Y, E));\n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define vmaxsize         1000\n#define emaxsize         10010\n#define unvisited          -1\n#define undefined          -1\n#define noparent            0\n#define free                0\n#define false               0\n#define true                1\nint tail[emaxsize+1], head[emaxsize+1];\nint edgefirst[vmaxsize+1], edgenext[emaxsize+1];\nint match[vmaxsize+1];  // ???v?????\\?¶?????????????????????°??????match[v]\nint m, n, n1, n2;       // ?????´????????°n1????????´????????°n2???n=n1+n2\nint level[vmaxsize+1];  // ??¬????????°?????????????????????v?????¬??????level[v]\nint queue[vmaxsize+1];  // ???????????¢?´¢?????????????????\\???\nint max_level;          // ????????????????????????????????´?????????????°???¬??????\nint t_found;            // ????????????????????????????????´???????????°???????????¨???t_found=true\nint front, rear;        // ?????\\????????????front??¨????°?rear\nint parent[vmaxsize + 1]; // ??±???????????¢?´¢??¨???????????????v??????parent[v]\nint pathfound, pathend;   // ?¢??????????????????¨ (pathfound=true)???pathend????????´?????????\nvoid bipartite_graph_input(void){\n    int a;\n    scanf(\"%d %d %d\", &n1, &n2, &m);\n    n=n1+n2; // n?????°??????????????°\n    for (a = 1; a <= m; a++) {\n        scanf(\"%d %d\", &tail[a], &head[a]);\n        tail[a]++;\n        head[a]++;\n        head[a] += n1;\n    }\n}\nvoid bipartite_incidence_list_construct(void){\n    int a, v1;\n    for (v1 = 1; v1 <= n1; v1++) edgefirst[v1] = 0;\n    for (a = m; a >= 1; a--) {\n        v1 = tail[a];\n        edgenext[a] = edgefirst[v1];\n        edgefirst[v1] = a;\n    }\n}\nvoid matching_output(void){\n    int a, v1, k;\n    k=0; \n    for (v1 = 1; v1 <= n1; v1++) {\n        if (match[v1] != free) {\n            k++;\n        }\n    }\n    printf(\"%d\\n\", k);\n}\nvoid bipartite_bfs(int v1){// ?????´??????v1??????????????¨??°????????§??????????????¢?´¢\n    int v2, w1;\n    int a,b;\n    for(a = edgefirst[v1]; a != 0; a = edgenext[a]) {// v1?????\\?¶???????????????????????????????????????????????????§??\\????????°?????????\n        v2 = head[a]; // a????????´??????v1???????????´??????v2???????????????????????¨?????????\n        if(level[v2] != unvisited){ // ?????´??????v2????¨???????????????¨???????????????????????????\n            ;\n        }else{// v2????????´????????§??????????¨????\n            level[v2] = level[v1] + 1;\n            if (t_found == n + 2){// ?¢??????????????????????????????£????????????\n                if (match[v2] != free) {// v2???????????????????????????\n                    b = match[v2]; // ??????????????°??????b\n                    w1 = tail[b]; // b????????????v2???????????????w1???????????????????????????\n                    level[w1] = level[v2] + 1; \n                    queue[++rear] = w1;\n                }\n                else {// v2???????????????????????????????????§v1??????v2????????????????¢??????????\n                    t_found = rear + 1; // t_found<n+2 ????¢??????????????????¨?????????\n                    max_level = level[v2];\n                }\n            }\n        }\n    }\n}\nvoid levelgraph(void){// ??¬????????°??????????§????\n    int v,v1;\n    rear = 0;    // ?????\\???????????????\n    front = 1;\n    t_found=n+2; // ?¢?????????????????????????????????????????????¨???????¨????\n    for (v = 1; v <= n; v++) level[v] = unvisited; // ????????????????¨??????¨???????¨????\n    for (v1 = 1; v1 <= n1; v1++) {\n        if (match[v1] == free) {// v1???????????????????????????????????´??????\n            level[v1] = 0; // v1??????????????¨??°????????????????????¢?´¢????????§????????????\n            queue[++rear] = v1; //?????\\???queue???????°????v1????????\\\n        }\n    }\n\n\n\n    while (front < t_found) {// ?¢???????????????????????????????????????????\n        if (front != rear + 1) {// ?????\\???queue????????§??????????????°?????????\n            v1 = queue[front++]; // ?????\\?????????????????????v1?????????\n            bipartite_bfs(v1); //v1??????????????¨??°????????????????????¢?´¢????§?\n        }\n        else {// ?????\\???queue????????§???????????§???while?????????????????¶????????????\n            break;\n        }\n    }\n\n\n    \n}\nvoid bipartite_dfs(int v1)\n{ // ?????´??????v1??????????????¨??°????????§?????±???????????¢?´¢\n    int v2, w1;\n    int a, b;\n    for (a = edgefirst[v1]; a != 0; a = edgenext[a])\n    {                 // v1?????\\?¶???????????????????????????????????????????????????§??\\????????°?????????\n        v2 = head[a]; // a????????´??????v1???????????´??????v2???????????????????????¨?????????\n        if (parent[v2] == undefined && level[v2] == level[v1] + 1)\n        {\n            parent[v2] = a; // a????????´??????v2?????????????????´??????v1???????????¨?????????\n            if (level[v2] != max_level)\n            {                   // v2????????´????????§????????????????????????\n                b = match[v2];  // ??????????????°??????b\n                w1 = tail[b];   // b????????????v2???????????????w1?????????????????????????????¨?????????\n                parent[w1] = b; // b????????´??????w1????????????v2?????????\n                bipartite_dfs(w1);\n/*\n                if (pathfound)\n                    return; //Added by Goro Satake\n*/\n            }\n            else\n            { // level[v2] == max_level\n                if (match[v2] == free)\n                {                     // v2????????´????????§???????????????????????????\n                    pathend = v2;     // ?¢??????????????????????v2\n                    pathfound = true; // ?¢????????????????\n                    return;           // ?¢????????????????????????°?????¶????????????????????±??????????????????????±????????????????\n                }\n            }\n        }\n    }\n}\nvoid augmentation(void)\n{\n    int v, v1, v2, w1;\n    int a, b;\n    for (v = 1; v <= n; v++)\n        parent[v] = undefined;\n    for (v1 = 1; v1 <= n1; v1++)\n    {\n        if (match[v1] != free)\n        {\n            continue;\n        }\n        else\n        {                          // v1???????????????????????????????????´??????\n            pathfound = false;     // v1??????????¢???????????????¢?´¢\n            parent[v1] = noparent; // v1???????????±???????????¢?´¢??¨?????????v1\n            bipartite_dfs(v1);     // v1???????????±?????????\n            if (!pathfound)\n            {\n                continue;\n            }\n            else\n            {                   // v1???????????±???????????§pathend???????¢????????????????\n                v2 = pathend;   // ??±???????????¢?´¢??¨??§pathend???????????????v1?????§?????????\n                a = parent[v2]; // ????????????????????????????????°?????¨?????????????????°????????????\n                match[v2] = a;\n                w1 = tail[a];\n                match[w1] = a;\n                while (w1 != v1)\n                {\n                    b = parent[w1];\n                    v2 = head[b];\n                    a = parent[v2];\n                    match[v2] = a;\n                    w1 = tail[a];\n                    match[w1] = a;\n                }\n            }\n        }\n    }\n}\nint main(void){\n    int v;\n    bipartite_graph_input(); \n    // ?????¨??°??????????????°m????????´?????°n1????????´?????°n2?????????????§?????????????????±?????????????\n    bipartite_incidence_list_construct(); // ??\\?¶?????????????????§?????????????\n    for (v = 1; v <= n; v++) match[v] = free; // ?????´??????????????????????????????????????????\n    levelgraph();\n    while(t_found != n + 2){\n        augmentation();\n        levelgraph();\n    }\n    matching_output(); // ??????????????????????????°?????????\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\nstruct node {\n  int id;\n  int cap;\n  struct node *next;\n};\nstruct node **list;\nint **flow, *visit, *delta, *prev, reached;\nvoid Insert(int, int);\nvoid Init(int);\nint Maxflow(int, int, int);\nint main(void)\n{\n  int i, x, y, v, e, s, t, maxflow = 0;\n  scanf(\"%d %d %d\", &x, &y, &e);\n  v = x + y + 2;\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  flow = (int**)malloc(sizeof(int*) * v);\n  visit = (int*)malloc(sizeof(int) * v);\n  delta = (int*)malloc(sizeof(int) * v);\n  prev = (int*)malloc(sizeof(int) * v);\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n    flow[i] = (int*)calloc(v, sizeof(int));\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d\", &s, &t);\n    Insert(0, s + 1);\n    Insert(x + t + 1, v - 1);\n    Insert(s + 1, x + t + 1);\n  }\n  while (Init(v), Maxflow(0, v - 1, v)) {\n    int n = v - 1;\n    do {\n      flow[prev[n]][n] += delta[v-1];\n      flow[n][prev[n]] -= delta[v-1];\n      n = prev[n];\n    } while(n);\n    maxflow += delta[v-1];\n  }\n  printf(\"%d\\n\", maxflow);\n  for (i = 0; i < v; i++) {\n    free(list[i]);\n    free(flow[i]);\n  }\n  free(list);\n  free(flow);\n  free(visit);\n  free(delta);\n  free(prev);\n}\nvoid Insert(int a, int b)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->cap = 1;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->cap = 0;\n  p->next = list[b];\n  list[b] = p;\n}\nvoid Init(int size)\n{\n  int i;\n  for (i = 0; i < size; i++) {\n    visit[i] = 0;\n    delta[i] = INT_MAX;\n    prev[i] = -1;\n  }\n  reached = 0;\n}\nint Maxflow(int s, int t, int size)\n{\n  struct node *n;\n  visit[s] = 1;\n  if (s == t) return 1;\n  for (n = list[s]; n != NULL; n = n->next) {\n    int v = n->id;\n    if (!visit[v] && flow[s][v] < n->cap) {\n      prev[v] = s;\n      delta[v] = MIN(delta[s], n->cap - flow[s][v]);\n      reached = Maxflow(v, size - 1, size);\n      if (reached) break;\n    }\n  }\n  return reached;\n}\n"
  },
  {
    "language": "C",
    "code": "// ???????????????????????°?????? BigraphInConstruct.h\nint tail[emaxsize+1], head[emaxsize+1];\nint edgefirst[vmaxsize+1], edgenext[emaxsize+1];\nint match[vmaxsize+1];  // ???v?????\\?¶?????????????????????°??????match[v]\nint m, n, n1, n2;       // ?????´????????°n1????????´????????°n2???n=n1+n2\n\n\n\n\n// ???????????????????????°??????LevelConstruct.h\nint level[vmaxsize+1];  // ??¬????????°?????????????????????v?????¬??????level[v]\nint queue[vmaxsize+1];  // ???????????¢?´¢?????????????????\\???\nint max_level;          // ????????????????????????????????´?????????????°???¬??????\nint t_found;            // ????????????????????????????????´???????????°???????????¨???t_found=true\nint front, rear;        // ?????\\????????????front??¨????°?rear\n\n// ???????????????????????°?????? Augmentation.h\nint parent[vmaxsize + 1]; // ??±???????????¢?´¢??¨???????????????v??????parent[v]\nint pathfound, pathend;   // ?¢??????????????????¨ (pathfound=true)???pathend????????´?????????\n\n// Hopcroft-Karp????????§??????????????°????±???????????????°?????? hopkarp.c\n#include <stdio.h>\n#define vmaxsize         1000\n#define emaxsize         4000\n#define unvisited          -1\n#define undefined          -1\n#define noparent            0\n#define free                0\n#define false               0\n#define true                1\n#include\"BigraphInConstruct.h\" // ???????????????BigraphInConstruct.h???????????????\n#include\"LevelConstruct.h\"     // ???????????????????????°??????LevelConstruct.h???????????????\n#include\"Augmentation.h\"       // ???????????????????????°??????Augmentation.h???????????????\nvoid bipartite_graph_input(void){\n    int a;\n    scanf(\"%d %d %d\", &n1, &n2, &m);\n    n=n1+n2; // n?????°??????????????°\n    for (a = 1; a <= m; a++) {\n        scanf(\"%d %d\", &tail[a], &head[a]);\n    }\n}\nvoid bipartite_incidence_list_construct(void){\n    int a, v1;\n    for (v1 = 1; v1 <= n1; v1++) edgefirst[v1] = 0;\n    for (a = m; a >= 1; a--) {\n        v1 = tail[a];\n        edgenext[a] = edgefirst[v1];\n        edgefirst[v1] = a;\n    }\n}\nvoid matching_output(void){\n    int a, v1, k;\n    k=0; \n    for (v1 = 1; v1 <= n1; v1++) {\n        if (match[v1] != free) {\n            k++;\n        }\n    }\n    printf(\"%d\\n, k);\n}\n\nvoid bipartite_bfs(int v1){// ?????´??????v1??????????????¨??°????????§??????????????¢?´¢\n    int v2, w1;\n    int a,b;\n    for(a = edgefirst[v1]; a != 0; a = edgenext[a]) {// v1?????\\?¶???????????????????????????????????????????????????§??\\????????°?????????\n        v2 = head[a]; // a????????´??????v1???????????´??????v2???????????????????????¨?????????\n        if(level[v2] != unvisited){ // ?????´??????v2????¨???????????????¨???????????????????????????\n            ;\n        }else{// v2????????´????????§??????????¨????\n            level[v2] = level[v1] + 1;\n            if (t_found == n + 2){// ?¢??????????????????????????????£????????????\n                if (match[v2] != free) {// v2???????????????????????????\n                    b = match[v2]; // ??????????????°??????b\n                    w1 = tail[b]; // b????????????v2???????????????w1???????????????????????????\n                    level[w1] = level[v2] + 1; \n                    queue[++rear] = w1;\n                }\n                else {// v2???????????????????????????????????§v1??????v2????????????????¢??????????\n                    t_found = rear + 1; // t_found<n+2 ????¢??????????????????¨?????????\n                    max_level = level[v2];\n                }\n            }\n        }\n    }\n}\nvoid levelgraph(void){// ??¬????????°??????????§????\n    int v,v1;\n    rear = 0;    // ?????\\???????????????\n    front = 1;\n    t_found=n+2; // ?¢?????????????????????????????????????????????¨???????¨????\n    for (v = 1; v <= n; v++) level[v] = unvisited; // ????????????????¨??????¨???????¨????\n    for (v1 = 1; v1 <= n1; v1++) {\n        if (match[v1] == free) {// v1???????????????????????????????????´??????\n            level[v1] = 0; // v1??????????????¨??°????????????????????¢?´¢????????§????????????\n            queue[++rear] = v1; //?????\\???queue???????°????v1????????\\\n        }\n    }\n\n\n\n    while (front < t_found) {// ?¢???????????????????????????????????????????\n        if (front != rear + 1) {// ?????\\???queue????????§??????????????°?????????\n            v1 = queue[front++]; // ?????\\?????????????????????v1?????????\n            bipartite_bfs(v1); //v1??????????????¨??°????????????????????¢?´¢????§?\n        }\n        else {// ?????\\???queue????????§???????????§???while?????????????????¶????????????\n            break;\n        }\n    }\n\n\n    \n}\nvoid bipartite_dfs(int v1)\n{ // ?????´??????v1??????????????¨??°????????§?????±???????????¢?´¢\n    int v2, w1;\n    int a, b;\n    for (a = edgefirst[v1]; a != 0; a = edgenext[a])\n    {                 // v1?????\\?¶???????????????????????????????????????????????????§??\\????????°?????????\n        v2 = head[a]; // a????????´??????v1???????????´??????v2???????????????????????¨?????????\n        if (parent[v2] == undefined && level[v2] == level[v1] + 1)\n        {\n            parent[v2] = a; // a????????´??????v2?????????????????´??????v1???????????¨?????????\n            if (level[v2] != max_level)\n            {                   // v2????????´????????§????????????????????????\n                b = match[v2];  // ??????????????°??????b\n                w1 = tail[b];   // b????????????v2???????????????w1?????????????????????????????¨?????????\n                parent[w1] = b; // b????????´??????w1????????????v2?????????\n                bipartite_dfs(w1);\n                if (pathfound)\n                    return; //Added by Goro Satake\n            }\n            else\n            { // level[v2] == max_level\n                if (match[v2] == free)\n                {                     // v2????????´????????§???????????????????????????\n                    pathend = v2;     // ?¢??????????????????????v2\n                    pathfound = true; // ?¢????????????????\n                    return;           // ?¢????????????????????????°?????¶????????????????????±??????????????????????±????????????????\n                }\n            }\n        }\n    }\n}\nvoid augmentation(void)\n{\n    int v, v1, v2, w1;\n    int a, b;\n    for (v = 1; v <= n; v++)\n        parent[v] = undefined;\n    for (v1 = 1; v1 <= n1; v1++)\n    {\n        if (match[v1] != free)\n        {\n            continue;\n        }\n        else\n        {                          // v1???????????????????????????????????´??????\n            pathfound = false;     // v1??????????¢???????????????¢?´¢\n            parent[v1] = noparent; // v1???????????±???????????¢?´¢??¨?????????v1\n            bipartite_dfs(v1);     // v1???????????±?????????\n            if (!pathfound)\n            {\n                continue;\n            }\n            else\n            {                   // v1???????????±???????????§pathend???????¢????????????????\n                v2 = pathend;   // ??±???????????¢?´¢??¨??§pathend???????????????v1?????§?????????\n                a = parent[v2]; // ????????????????????????????????°?????¨?????????????????°????????????\n                match[v2] = a;\n                w1 = tail[a];\n                match[w1] = a;\n                while (w1 != v1)\n                {\n                    b = parent[w1];\n                    v2 = head[b];\n                    a = parent[v2];\n                    match[v2] = a;\n                    w1 = tail[a];\n                    match[w1] = a;\n                }\n            }\n        }\n    }\n}\nint main(void){\n    int v;\n    bipartite_graph_input(); \n    // ?????¨??°??????????????°m????????´?????°n1????????´?????°n2?????????????§?????????????????±?????????????\n    bipartite_incidence_list_construct(); // ??\\?¶?????????????????§?????????????\n    for (v = 1; v <= n; v++) match[v] = free; // ?????´??????????????????????????????????????????\n    levelgraph();\n    while(t_found != n + 2){\n        augmentation();\n        levelgraph();\n    }\n    matching_output(); // ??????????????????????????°?????????\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define vmaxsize         1000\n#define emaxsize         4000\n#define unvisited          -1\n#define undefined          -1\n#define noparent            0\n#define free                0\n#define false               0\n#define true                1\nint tail[emaxsize+1], head[emaxsize+1];\nint edgefirst[vmaxsize+1], edgenext[emaxsize+1];\nint match[vmaxsize+1];  // ???v?????\\?¶?????????????????????°??????match[v]\nint m, n, n1, n2;       // ?????´????????°n1????????´????????°n2???n=n1+n2\nint level[vmaxsize+1];  // ??¬????????°?????????????????????v?????¬??????level[v]\nint queue[vmaxsize+1];  // ???????????¢?´¢?????????????????\\???\nint max_level;          // ????????????????????????????????´?????????????°???¬??????\nint t_found;            // ????????????????????????????????´???????????°???????????¨???t_found=true\nint front, rear;        // ?????\\????????????front??¨????°?rear\nint parent[vmaxsize + 1]; // ??±???????????¢?´¢??¨???????????????v??????parent[v]\nint pathfound, pathend;   // ?¢??????????????????¨ (pathfound=true)???pathend????????´?????????\nvoid bipartite_graph_input(void){\n    int a;\n    scanf(\"%d %d %d\", &n1, &n2, &m);\n    n=n1+n2; // n?????°??????????????°\n    for (a = 1; a <= m; a++) {\n        scanf(\"%d %d\", &tail[a], &head[a]);\n        tail[a]++;\n        head[a]++;\n        head[a] += n1;\n    }\n}\nvoid bipartite_incidence_list_construct(void){\n    int a, v1;\n    for (v1 = 1; v1 <= n1; v1++) edgefirst[v1] = 0;\n    for (a = m; a >= 1; a--) {\n        v1 = tail[a];\n        edgenext[a] = edgefirst[v1];\n        edgefirst[v1] = a;\n    }\n}\nvoid matching_output(void){\n    int a, v1, k;\n    k=0; \n    for (v1 = 1; v1 <= n1; v1++) {\n        if (match[v1] != free) {\n            k++;\n        }\n    }\n    printf(\"%d\\n\", k);\n}\nvoid bipartite_bfs(int v1){// ?????´??????v1??????????????¨??°????????§??????????????¢?´¢\n    int v2, w1;\n    int a,b;\n    for(a = edgefirst[v1]; a != 0; a = edgenext[a]) {// v1?????\\?¶???????????????????????????????????????????????????§??\\????????°?????????\n        v2 = head[a]; // a????????´??????v1???????????´??????v2???????????????????????¨?????????\n        if(level[v2] != unvisited){ // ?????´??????v2????¨???????????????¨???????????????????????????\n            ;\n        }else{// v2????????´????????§??????????¨????\n            level[v2] = level[v1] + 1;\n            if (t_found == n + 2){// ?¢??????????????????????????????£????????????\n                if (match[v2] != free) {// v2???????????????????????????\n                    b = match[v2]; // ??????????????°??????b\n                    w1 = tail[b]; // b????????????v2???????????????w1???????????????????????????\n                    level[w1] = level[v2] + 1; \n                    queue[++rear] = w1;\n                }\n                else {// v2???????????????????????????????????§v1??????v2????????????????¢??????????\n                    t_found = rear + 1; // t_found<n+2 ????¢??????????????????¨?????????\n                    max_level = level[v2];\n                }\n            }\n        }\n    }\n}\nvoid levelgraph(void){// ??¬????????°??????????§????\n    int v,v1;\n    rear = 0;    // ?????\\???????????????\n    front = 1;\n    t_found=n+2; // ?¢?????????????????????????????????????????????¨???????¨????\n    for (v = 1; v <= n; v++) level[v] = unvisited; // ????????????????¨??????¨???????¨????\n    for (v1 = 1; v1 <= n1; v1++) {\n        if (match[v1] == free) {// v1???????????????????????????????????´??????\n            level[v1] = 0; // v1??????????????¨??°????????????????????¢?´¢????????§????????????\n            queue[++rear] = v1; //?????\\???queue???????°????v1????????\\\n        }\n    }\n\n\n\n    while (front < t_found) {// ?¢???????????????????????????????????????????\n        if (front != rear + 1) {// ?????\\???queue????????§??????????????°?????????\n            v1 = queue[front++]; // ?????\\?????????????????????v1?????????\n            bipartite_bfs(v1); //v1??????????????¨??°????????????????????¢?´¢????§?\n        }\n        else {// ?????\\???queue????????§???????????§???while?????????????????¶????????????\n            break;\n        }\n    }\n\n\n    \n}\nvoid bipartite_dfs(int v1)\n{ // ?????´??????v1??????????????¨??°????????§?????±???????????¢?´¢\n    int v2, w1;\n    int a, b;\n    for (a = edgefirst[v1]; a != 0; a = edgenext[a])\n    {                 // v1?????\\?¶???????????????????????????????????????????????????§??\\????????°?????????\n        v2 = head[a]; // a????????´??????v1???????????´??????v2???????????????????????¨?????????\n        if (parent[v2] == undefined && level[v2] == level[v1] + 1)\n        {\n            parent[v2] = a; // a????????´??????v2?????????????????´??????v1???????????¨?????????\n            if (level[v2] != max_level)\n            {                   // v2????????´????????§????????????????????????\n                b = match[v2];  // ??????????????°??????b\n                w1 = tail[b];   // b????????????v2???????????????w1?????????????????????????????¨?????????\n                parent[w1] = b; // b????????´??????w1????????????v2?????????\n                bipartite_dfs(w1);\n/*\n                if (pathfound)\n                    return; //Added by Goro Satake\n*/\n            }\n            else\n            { // level[v2] == max_level\n                if (match[v2] == free)\n                {                     // v2????????´????????§???????????????????????????\n                    pathend = v2;     // ?¢??????????????????????v2\n                    pathfound = true; // ?¢????????????????\n                    return;           // ?¢????????????????????????°?????¶????????????????????±??????????????????????±????????????????\n                }\n            }\n        }\n    }\n}\nvoid augmentation(void)\n{\n    int v, v1, v2, w1;\n    int a, b;\n    for (v = 1; v <= n; v++)\n        parent[v] = undefined;\n    for (v1 = 1; v1 <= n1; v1++)\n    {\n        if (match[v1] != free)\n        {\n            continue;\n        }\n        else\n        {                          // v1???????????????????????????????????´??????\n            pathfound = false;     // v1??????????¢???????????????¢?´¢\n            parent[v1] = noparent; // v1???????????±???????????¢?´¢??¨?????????v1\n            bipartite_dfs(v1);     // v1???????????±?????????\n            if (!pathfound)\n            {\n                continue;\n            }\n            else\n            {                   // v1???????????±???????????§pathend???????¢????????????????\n                v2 = pathend;   // ??±???????????¢?´¢??¨??§pathend???????????????v1?????§?????????\n                a = parent[v2]; // ????????????????????????????????°?????¨?????????????????°????????????\n                match[v2] = a;\n                w1 = tail[a];\n                match[w1] = a;\n                while (w1 != v1)\n                {\n                    b = parent[w1];\n                    v2 = head[b];\n                    a = parent[v2];\n                    match[v2] = a;\n                    w1 = tail[a];\n                    match[w1] = a;\n                }\n            }\n        }\n    }\n}\nint main(void){\n    int v;\n    bipartite_graph_input(); \n    // ?????¨??°??????????????°m????????´?????°n1????????´?????°n2?????????????§?????????????????±?????????????\n    bipartite_incidence_list_construct(); // ??\\?¶?????????????????§?????????????\n    for (v = 1; v <= n; v++) match[v] = free; // ?????´??????????????????????????????????????????\n    levelgraph();\n    while(t_found != n + 2){\n        augmentation();\n        levelgraph();\n    }\n    matching_output(); // ??????????????????????????°?????????\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdbool.h>\n#include<string.h>\n\n#define MAX 201\n#define TRUE 1\n#define FALSE 0\n#define UNUSED -1\n\nint N, K, E; // E : the number of edges\nint graph[MAX][100010], size[MAX], match[MAX], used[MAX];\n\nvoid add_edge(int s,int t) {\n  graph[s][size[s]++] = t;\n  graph[t][size[t]++] = s;\n}\n\nint dfs(int cur) {\n  used[cur] = TRUE;\n  int i, next, state;\n  for(i=0;i<size[cur];++i) {\n    next = graph[cur][i], state = match[next];\n    if( state == UNUSED || ( !used[next] && dfs(next) ) ) {\n      match[cur] = next;\n      match[next] = cur;\n      return TRUE;\n    }\n  }\n  return FALSE;\n}\n\nint bmatch() {\n  memset(match,UNUSED,sizeof match);\n  int i, answer = 0;\n  for(i=0;i<N;++i) {\n    memset(used, FALSE, sizeof used);\n    if( dfs(i) ) {\n      ++answer;\n    }\n  }\n  return answer;\n}\n\nint main() {\n  int i,s,t;\n  scanf(\"%d %d %d\",&N,&K,&E);\n  for(i=0;i<E;i++) {\n    scanf(\"%d %d\",&s,&t);\n    add_edge(s,N+t);\n  }\n  int maxi = bmatch();\n  //printf(\"answer = %d\\n\",maxi);\n  printf(\"%d\\n\",maxi);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define rep(i,l,r)for(int i=(l);i<(r);i++)\n\n//sからtへの最大流 O(E flow)を横着してO(VV flow)\n//*\n#define VMAX 210\nint vcnt;\nint foodoflag[VMAX];\nint resflow[VMAX][VMAX];\n\nint foododfs(int s,int t){\n\tif(s==t)return 1;\n\tfoodoflag[s]=1;\n\trep(i,0,vcnt)if(!foodoflag[i]&&resflow[s][i]>0){\n\t\tif(foododfs(i,t)){\n\t\t\tresflow[s][i]--;\n\t\t\tresflow[i][s]++;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint foodo(int s,int t){\n\tint ans=0;\n\twhile(foododfs(s,t)){\n\t\tans++;\n\t\trep(i,0,vcnt)foodoflag[i]=0;\n\t}\n\treturn ans;\n}\n#undef VMAX\n//*/\nint main(){\n\tint x,y,e;\n\tscanf(\"%d%d%d\",&x,&y,&e);\n\tvcnt=x+y+2;\n\twhile(e--){\n\t\tint p,q;\n\t\tscanf(\"%d%d\",&p,&q);\n\t\tresflow[0][p+1]=1;\n\t\tresflow[p+1][q+x+1]=1;\n\t\tresflow[q+x+1][x+y+1]=1;\n\t}\n\tprintf(\"%d\\n\",foodo(0,x+y+1));\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <memory.h>\n#include <stdlib.h>\n\nint table[101][101] = {0};\nint table_size[101] = {0};\nint x_value[101] = {0};\nint x_size = 0;\n\nint is_match(int depth, int x_index, int n, int used[101]) {\n\tint i;\n\tint size;\n\tint cnt = 0;\n\tint result = 0;\n\tint* tused[101];\n\tfor(i=0;i<101;i++) {\n\t\tif(used[i] == 1) cnt++;\n\t\tif(cnt >= n) return 1;\n\t}\n\n\tif(depth >= n) return 0;\n\tif(x_index >= x_size) return 0;\n\t\n\t// x側が何も選ばない場合\n\tresult |= is_match(depth, x_index+1, n, used);\n\tsize = table_size[x_value[x_index]];\n\tfor(i=0;i<size;i++) {\n\t\tif(used[table[x_value[x_index]][i]] == 0) { \n\t\t\ttused[i] = (int*)malloc(101*sizeof(int));\n\t\t\tmemcpy(tused[i], used, sizeof(used));\n\t\t\ttused[i][table[x_index][i]] = 1;\n\t\t\tresult |= is_match(depth+1, x_index+1, n, tused[i]);\n\t\t\tfree(tused[i]);\n\t\t}\n\t}\n\t\n\treturn result;\n}\n\nint solve(int size) {\n\tint l = 0;\n\tint r = size;\n\tint m = (r + l) / 2;\n\tint result;\n\tint old_result = -1;\n\tint old_m = -1;\n\t\n\tif(size == 1) return 1;\n\tif(size == 0) return 0;\n\t\n\twhile(1) {\n\t\tint used[101];\n\t\tmemset(used, 0x00, sizeof(used));\n\t\tresult = is_match(0, 0, m, used);\n\t\tif(result > 0 && (old_result == 0 || size == m)) {\n\t\t\treturn m;\n\t\t} else if(result == 0 && old_result == 1) {\n\t\t\treturn old_m;\n\t\t} else {\n\t\t\tif(result > 0) {\n\t\t\t\tm++;\n\t\t\t} else {\n\t\t\t\tm--;\n\t\t\t}\n\t\t}\n\t\t\n\t\told_result = result;\n\t\told_m = m;\n\t}\n}\n\nint main(void) {\n\tint X, Y, E;\n\tint i,j;\n\tint x, y;\n\tint is_found;\n\tint match_count = 0;\n\t\n\tscanf(\"%d %d %d\\n\", &X, &Y, &E);\n\tfor(i=0;i<E;i++) {\n\t\tscanf(\"%d %d\\n\", &x, &y);\n\t\ttable[x][table_size[x]++] = y;\n\t\t\n\t\tis_found = 0;\n\t\tfor(j=0;j<x_size;j++) {\n\t\t\tif(x_value[j] == x) {\n\t\t\t\tis_found = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(is_found==0)\tx_value[x_size++] = x;\n\t}\n\t\n\tprintf(\"%d\\n\", solve(x_size));\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define vmaxsize         1000\n#define emaxsize         10010\n#define unvisited          -1\n#define undefined          -1\n#define noparent            0\n#define free                0\n#define false               0\n#define true                1\nint tail[emaxsize+1], head[emaxsize+1];\nint edgefirst[vmaxsize+1], edgenext[emaxsize+1];\nint match[vmaxsize+1];  // ???v?????\\?¶?????????????????????°??????match[v]\nint m, n, n1, n2;       // ?????´????????°n1????????´????????°n2???n=n1+n2\nint level[vmaxsize+1];  // ??¬????????°?????????????????????v?????¬??????level[v]\nint queue[vmaxsize+1];  // ???????????¢?´¢?????????????????\\???\nint max_level;          // ????????????????????????????????´?????????????°???¬??????\nint t_found;            // ????????????????????????????????´???????????°???????????¨???t_found=true\nint front, rear;        // ?????\\????????????front??¨????°?rear\nint parent[vmaxsize + 1]; // ??±???????????¢?´¢??¨???????????????v??????parent[v]\nint pathfound, pathend;   // ?¢??????????????????¨ (pathfound=true)???pathend????????´?????????\nvoid bipartite_graph_input(void){\n    int a;\n    scanf(\"%d %d %d\", &n1, &n2, &m);\n    n=n1+n2; // n?????°??????????????°\n    for (a = 1; a <= m; a++) {\n        scanf(\"%d %d\", &tail[a], &head[a]);\n        tail[a]++;\n        head[a]++;\n        head[a] += n1;\n    }\n}\nvoid bipartite_incidence_list_construct(void){\n    int a, v1;\n    for (v1 = 1; v1 <= n1; v1++) edgefirst[v1] = 0;\n    for (a = m; a >= 1; a--) {\n        v1 = tail[a];\n        edgenext[a] = edgefirst[v1];\n        edgefirst[v1] = a;\n    }\n}\nvoid matching_output(void){\n    int a, v1, k;\n    k=0; \n    for (v1 = 1; v1 <= n1; v1++) {\n        if (match[v1] != free) {\n            k++;\n        }\n    }\n    printf(\"%d\\n\", k);\n}\nvoid bipartite_bfs(int v1){// ?????´??????v1??????????????¨??°????????§??????????????¢?´¢\n    int v2, w1;\n    int a,b;\n    for(a = edgefirst[v1]; a != 0; a = edgenext[a]) {// v1?????\\?¶???????????????????????????????????????????????????§??\\????????°?????????\n        v2 = head[a]; // a????????´??????v1???????????´??????v2???????????????????????¨?????????\n        if(level[v2] != unvisited){ // ?????´??????v2????¨???????????????¨???????????????????????????\n            ;\n        }else{// v2????????´????????§??????????¨????\n            level[v2] = level[v1] + 1;\n            if (t_found == n + 2){// ?¢??????????????????????????????£????????????\n                if (match[v2] != free) {// v2???????????????????????????\n                    b = match[v2]; // ??????????????°??????b\n                    w1 = tail[b]; // b????????????v2???????????????w1???????????????????????????\n                    level[w1] = level[v2] + 1; \n                    queue[++rear] = w1;\n                }\n                else {// v2???????????????????????????????????§v1??????v2????????????????¢??????????\n                    t_found = rear + 1; // t_found<n+2 ????¢??????????????????¨?????????\n                    max_level = level[v2];\n                }\n            }\n        }\n    }\n}\nvoid levelgraph(void){// ??¬????????°??????????§????\n    int v,v1;\n    rear = 0;    // ?????\\???????????????\n    front = 1;\n    t_found=n+2; // ?¢?????????????????????????????????????????????¨???????¨????\n    for (v = 1; v <= n; v++) level[v] = unvisited; // ????????????????¨??????¨???????¨????\n    for (v1 = 1; v1 <= n1; v1++) {\n        if (match[v1] == free) {// v1???????????????????????????????????´??????\n            level[v1] = 0; // v1??????????????¨??°????????????????????¢?´¢????????§????????????\n            queue[++rear] = v1; //?????\\???queue???????°????v1????????\\\n        }\n    }\n\n\n\n    while (front < t_found) {// ?¢???????????????????????????????????????????\n        if (front != rear + 1) {// ?????\\???queue????????§??????????????°?????????\n            v1 = queue[front++]; // ?????\\?????????????????????v1?????????\n            bipartite_bfs(v1); //v1??????????????¨??°????????????????????¢?´¢????§?\n        }\n        else {// ?????\\???queue????????§???????????§???while?????????????????¶????????????\n            break;\n        }\n    }\n\n\n    \n}\nvoid bipartite_dfs(int v1)\n{ // ?????´??????v1??????????????¨??°????????§?????±???????????¢?´¢\n    int v2, w1;\n    int a, b;\n    for (a = edgefirst[v1]; a != 0; a = edgenext[a])\n    {                 // v1?????\\?¶???????????????????????????????????????????????????§??\\????????°?????????\n        v2 = head[a]; // a????????´??????v1???????????´??????v2???????????????????????¨?????????\n        if (parent[v2] == undefined && level[v2] == level[v1] + 1)\n        {\n            parent[v2] = a; // a????????´??????v2?????????????????´??????v1???????????¨?????????\n            if (level[v2] != max_level)\n            {                   // v2????????´????????§????????????????????????\n                b = match[v2];  // ??????????????°??????b\n                w1 = tail[b];   // b????????????v2???????????????w1?????????????????????????????¨?????????\n                parent[w1] = b; // b????????´??????w1????????????v2?????????\n                bipartite_dfs(w1);\n\n                if (pathfound)\n                    return; //Added by Goro Satake\n\n            }\n            else\n            { // level[v2] == max_level\n                if (match[v2] == free)\n                {                     // v2????????´????????§???????????????????????????\n                    pathend = v2;     // ?¢??????????????????????v2\n                    pathfound = true; // ?¢????????????????\n                    return;           // ?¢????????????????????????°?????¶????????????????????±??????????????????????±????????????????\n                }\n            }\n        }\n    }\n}\nvoid augmentation(void)\n{\n    int v, v1, v2, w1;\n    int a, b;\n    for (v = 1; v <= n; v++)\n        parent[v] = undefined;\n    for (v1 = 1; v1 <= n1; v1++)\n    {\n        if (match[v1] != free)\n        {\n            continue;\n        }\n        else\n        {                          // v1???????????????????????????????????´??????\n            pathfound = false;     // v1??????????¢???????????????¢?´¢\n            parent[v1] = noparent; // v1???????????±???????????¢?´¢??¨?????????v1\n            bipartite_dfs(v1);     // v1???????????±?????????\n            if (!pathfound)\n            {\n                continue;\n            }\n            else\n            {                   // v1???????????±???????????§pathend???????¢????????????????\n                v2 = pathend;   // ??±???????????¢?´¢??¨??§pathend???????????????v1?????§?????????\n                a = parent[v2]; // ????????????????????????????????°?????¨?????????????????°????????????\n                match[v2] = a;\n                w1 = tail[a];\n                match[w1] = a;\n                while (w1 != v1)\n                {\n                    b = parent[w1];\n                    v2 = head[b];\n                    a = parent[v2];\n                    match[v2] = a;\n                    w1 = tail[a];\n                    match[w1] = a;\n                }\n            }\n        }\n    }\n}\nint main(void){\n    int v;\n    bipartite_graph_input(); \n    // ?????¨??°??????????????°m????????´?????°n1????????´?????°n2?????????????§?????????????????±?????????????\n    bipartite_incidence_list_construct(); // ??\\?¶?????????????????§?????????????\n    for (v = 1; v <= n; v++) match[v] = free; // ?????´??????????????????????????????????????????\n    levelgraph();\n    while(t_found != n + 2){\n        augmentation();\n        levelgraph();\n    }\n    matching_output(); // ??????????????????????????°?????????\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdbool.h>\n#include<string.h>\n\n#define MAX 201\n#define TRUE 1\n#define FALSE 0\n#define UNUSED -1\n\nint N, K, E; // E : the number of edges\nint graph[MAX][MAX], size[MAX], match[MAX], used[MAX];\n\nvoid add_edge(int s,int t) {\n  graph[s][size[s]++] = t;\n  graph[t][size[t]++] = s;\n}\n\nint dfs(int cur) {\n  used[cur] = TRUE;\n  int i, next, state;\n  for(i=0;i<size[cur];++i) {\n    next = graph[cur][i], state = match[next];\n    if( state == UNUSED || ( !used[next] && dfs(next) ) ) {\n      match[cur] = next;\n      match[next] = cur;\n      return TRUE;\n    }\n  }\n  return FALSE;\n}\n\nint bmatch() {\n  memset(match,UNUSED,sizeof match);\n  int i, answer = 0;\n  for(i=0;i<N;++i) {\n    memset(used, FALSE, sizeof used);\n    if( dfs(i) ) {\n      ++answer;\n    }\n  }\n  return answer;\n}\n\nint main() {\n  int i,s,t;\n  scanf(\"%d %d %d\",&N,&K,&E);\n  for(i=0;i<E;i++) {\n    scanf(\"%d %d\",&s,&t);\n    add_edge(s,N+t);\n  }\n  int maxi = bmatch();\n  //printf(\"answer = %d\\n\",maxi);\n  printf(\"%d\\n\",maxi);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ GRL_7_A Matching - Bipartite Matching\n// 2018.4.26 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX 202\nint  hi[MAX], to[MAX][MAX];\nchar seen[MAX];\nint  match[MAX];\n\nint bpm(int u);\nint bipartiteMatching(int m, int n)\n{\n\tint u, max;\n\n\tmemset(match, -1, (m+n)*sizeof(int));\n\tmax = 0;\n\tfor (u = 0; u < m; u++) {\n\t\tmemset(seen, 0, m+n);\n\t\tif (bpm(u)) max++;\n\t}\n\treturn max;\n}\n\nint bpm(int u)\n{\n\tint i, v;\n\n\tfor (i = 0; i < hi[u]; i++) {\n\t\tv = to[u][i];\n\t\tif (seen[v]) continue;\n\t\tseen[v] = 1;\n\t\tif (match[v] < 0 || bpm(match[v])) {\n\t\t\tmatch[u] = v, match[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint X, Y, E, x, y;\n\n\tX = in(), Y = in(), E = in();\n\twhile (E--) {\n\t\tx = in(), y = in();\n\t\tto[x][hi[x]++] = X+y;\n\t}\n\tprintf(\"%d\\n\", bipartiteMatching(X, Y));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_X_Y (101)\n#define MATCH (1)\n#define NO_MATCH (-1)\n#define VISIT (1)\n#define NO_VISIT (-1)\n#define NO_ID (-1)\n\ntypedef struct _Point{\n    int dst[MAX_X_Y];\n    int size;\n} Point;\n\nint bipartite_matching(Point *pair, int src, int *matches, int* is_visits) {\n    int i, size, dst;\n    if(src<0) return MATCH;\n\n    for(i=0,size=pair[src].size;i<size;i++) {\n        dst = pair[src].dst[i];\n        if(is_visits[dst] == NO_VISIT) {\n            is_visits[dst] = VISIT;\n\n            if(bipartite_matching(pair, matches[dst], matches, is_visits) == MATCH) {\n                // X側からとY側、両方マッチすれば\n                matches[src] = dst;\n                matches[dst] = src;\n                return MATCH;\n            }\n        }\n    }\n\n    return NO_MATCH;\n}\n\nint solve(int X, int Y, int E) {\n    int i, j, x, y;\n    Point pair[MAX_X_Y*2];\n    int is_visits[MAX_X_Y*2];\n    int matches[MAX_X_Y*2];\n    int count;\n\n    for(i=0;i<MAX_X_Y*2;i++) pair[i].size = 0, matches[i] = NO_ID;\n\n    for(i=0;i<E;i++) {\n        scanf(\"%d %d\\n\", &x, &y);\n        y += MAX_X_Y;\n        pair[x].dst[pair[x].size++] = y;\n        pair[y].dst[pair[y].size++] = x;\n    }\n\n    count = 0;\n    for(i=0;i<X;i++) {\n        for(j=0;j<MAX_X_Y*2;j++) is_visits[j] = NO_VISIT;\n        if(bipartite_matching(pair, i, matches, is_visits) == MATCH) {\n            count ++;\n        }\n    }\n\n    return count;\n}\n\nint main(void) {\n    int X, Y, E;\n\n    scanf(\"%d %d %d\\n\", &X, &Y, &E);    \n    printf(\"%d\\n\", solve(X, Y, E));\n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint cap[202][202],flow[202][202],maxflow,visited[202];\n\nint dfs(int cur) {\n\tif(cur == 201) {\n\t\tmaxflow++;\n\t\treturn 1;\n\t}\n\tfor(int i = 0;i < 202;i++) {\n\t\tif(!visited[i] && cap[cur][i] > flow[cur][i]) {\n\t\t\tvisited[i] = 1;\n\t\t\tif(dfs(i)) {\n\t\t\t\tflow[cur][i]++;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tif(!visited[i] && flow[i][cur] > 0) {\n\t\t\tvisited[i] = 1;\n\t\t\tif(dfs(i)) {\n\t\t\t\tflow[i][cur]--;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint x,y,e;\n\tscanf(\"%d %d %d\",&x,&y,&e);\n\tfor(int i = 0;i < e;i++){\n\t\tint xx,yy;\n\t\tscanf(\"%d %d\",&xx,&yy);\n\t\tcap[0][xx+1] = 1;\n\t\tcap[xx+1][yy+101] = 1;\n\t\tcap[yy+101][201] = 1;\n\t}\n\twhile(dfs(0) != 0) memset(visited,0,sizeof(visited));\n\tprintf(\"%d\\n\",maxflow);\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdbool.h>\n#include<string.h>\n#include<assert.h>\n\n#define MAX_V 201\n#define MAX_E 10001\n#define TRUE 1\n#define FALSE 0\n#define UNUSED -1\n\nint N, K, E; // E : the number of edges\nint graph[MAX_V][MAX_E], size[MAX_V], match[MAX_V], used[MAX_V];\n\nvoid add_edge(int s,int t) {\n  graph[s][size[s]++] = t;\n  graph[t][size[t]++] = s;\n}\n\nint dfs(int cur) {\n  used[cur] = TRUE;\n  int i, next, state;\n  for(i=0;i<size[cur];++i) {\n    next = graph[cur][i], state = match[next];\n    if( state == UNUSED || ( !used[state] && dfs(state) ) ) {\n      match[cur] = next;\n      match[next] = cur;\n      return TRUE;\n    }\n  }\n  return FALSE;\n}\n\nint bmatch() {\n  memset(match,UNUSED,sizeof match);\n  int i, answer = 0;\n  for(i=0;i<N;++i) {\n    if( match[i] == UNUSED ) {\n      memset(used, FALSE, sizeof used);\n      if( dfs(i) ) {\n\t++answer;\n      }\n    }\n  }\n  return answer;\n}\n\nint main() {\n  int i,s,t;\n  scanf(\"%d %d %d\",&N,&K,&E);\n  assert( N+K < MAX_V);\n  assert( E < MAX_E );\n  for(i=0;i<E;i++) {\n    scanf(\"%d %d\",&s,&t);\n    assert( 0 <= s && s < N );\n    assert( 0 <= t && t < K );\n    add_edge(s,N+t);\n  }\n  int maxi = bmatch();\n  //printf(\"answer = %d\\n\",maxi);\n  printf(\"%d\\n\",maxi);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\nstruct node {\n  int id;\n  int cap;\n  struct node *next;\n};\nstruct node **list;\nint **flow, *visit, *delta, *prev, *queue;\nvoid Insert(int, int);\nint Maxflow(int, int, int);\nint main(void)\n{\n  int i, x, y, v, e, s, t, maxflow = 0;\n  scanf(\"%d %d %d\", &x, &y, &e);\n  v = x + y + 2;\n  list = (struct node**)malloc(sizeof(struct node*) * v);\n  flow = (int**)malloc(sizeof(int*) * v);\n  visit = (int*)malloc(sizeof(int) * v);\n  delta = (int*)malloc(sizeof(int) * v);\n  prev = (int*)malloc(sizeof(int) * v);\n  queue = (int*)malloc(sizeof(int) * v);\n  for (i = 0; i < v; i++) {\n    list[i] = NULL;\n    flow[i] = (int*)calloc(v, sizeof(int));\n  }\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d\", &s, &t);\n    Insert(0, s + 1);\n    Insert(x + t + 1, v - 1);\n    Insert(s + 1, x + t + 1);\n  }\n  while (Maxflow(0, v - 1, v)) {\n    int n = v - 1;\n    do {\n      flow[prev[n]][n] += delta[v-1];\n      flow[n][prev[n]] -= delta[v-1];\n      n = prev[n];\n    } while(n);\n    maxflow += delta[v-1];\n  }\n  printf(\"%d\\n\", maxflow);\n  for (i = 0; i < v; i++) {\n    free(list[i]);\n    free(flow[i]);\n  }\n  free(list);\n  free(flow);\n  free(visit);\n  free(delta);\n  free(prev);\n  free(queue);\n}\nvoid Insert(int a, int b)\n{\n  struct node *p = (struct node*)malloc(sizeof(struct node));\n  p->id = b;\n  p->cap = 1;\n  p->next = list[a];\n  list[a] = p;\n  p = (struct node*)malloc(sizeof(struct node));\n  p->id = a;\n  p->cap = 0;\n  p->next = list[b];\n  list[b] = p;\n}\nint Maxflow(int s, int t, int size)\n{\n  struct node *n;\n  int i, reached = 0, head = 0, tail = 0;\n  for (i = 0; i < size; i++) {\n    visit[i] = 0;\n    delta[i] = INT_MAX;\n    prev[i] = -1;\n  }\n  visit[s] = 1;\n  queue[tail++] = s;\n  do {\n    i = queue[head++];\n    for (n = list[i]; n != NULL; n = n->next) {\n      int v = n->id;\n      if (!visit[v] && flow[i][v] < n->cap) {\n        queue[tail++] = v;\n        visit[v] = 1;\n        prev[v] = i;\n        delta[v] = MIN(delta[i], n->cap - flow[i][v]);\n        if (v == t) reached = 1;\n      }\n    }\n  } while (head != tail && !reached);\n  return reached;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define NMAX 100\n#define KMAX 25\nint matrix[NMAX*2][NMAX], match[NMAX], visit[NMAX];\nint Dfs(int, int);\nint main(void)\n{\n  int i, x, y, e, s, t, maxflow = 0;\n  scanf(\"%d %d %d\", &x, &y, &e);\n  for (i = 0; i < y; i++) match[i] = -1;\n  for (i = 0; i < e; i++) {\n    scanf(\"%d %d\", &s, &t);\n    matrix[s][t] = 1;\n  }\n  for (i = 0; i < x; i++) {\n    memset(visit, 0, sizeof(int) * x);\n    if (Dfs(i, y)) maxflow++;\n  }\n  printf(\"%d\\n\", maxflow);\n}\n\nint Dfs(int v, int ysize)\n{\n  int i;\n  visit[v] = 1;\n  for (i = 0; i < ysize; i++) {\n    int w = match[i];\n    if (!matrix[v][i]) continue;\n    if (w < 0 || !visit[w] && Dfs(w, ysize)) {\n      match[i] = v;\n      return 1;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static class BipartiteMatch_Hungarian {\n\n        WeightedGraph graph;\n        int maxMatch;\n        int[] match;\n\n        public BipartiteMatch_Hungarian(WeightedGraph graph) {\n            this.graph = graph;\n\n            match = new int[graph.numVertex];\n            boolean[] used = new boolean[graph.numVertex];\n            Arrays.fill(match, -1);\n            for (int vert = 0; vert < graph.numVertex; vert++) {\n                if (match[vert] < 0) {\n                    Arrays.fill(used, false);\n                    if (dfs(vert, used)) {\n                        maxMatch++;\n                    }\n                }\n            }\n        }\n\n        private boolean dfs(int vert, boolean[] used) {\n            used[vert] = true;\n            Iterator<WeightedGraph.Edge> edgeIt = graph.getEdges(vert);\n            while (edgeIt.hasNext()) {\n                WeightedGraph.Edge e = edgeIt.next();\n                int pairVert = e.other(vert);\n                int ppVert = match[pairVert];\n                if (ppVert < 0 || !used[ppVert] && dfs(ppVert, used)) {\n                    match[vert] = pairVert;\n                    match[pairVert] = vert;\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        public int getMaxMatch() {\n            return maxMatch;\n        }\n    }\n\n    public static class WeightedGraph {\n\n        int numVertex;\n        int numEdge;\n\n        List<Edge>[] srcEdges;\n\n        @SuppressWarnings(\"unchecked\")\n        public WeightedGraph(int numV) {\n            this.numVertex = numV;\n            srcEdges = new List[numV];\n            for (int i = 0; i < numV; i++) {\n                srcEdges[i] = new ArrayList<Edge>();\n            }\n        }\n\n        public void addEdge(int v1, int v2, int weight) {\n            Edge e = new WeightedGraph.Edge(v1, v2, weight);\n            srcEdges[v1].add(e);\n            srcEdges[v2].add(e);\n            numEdge++;\n        }\n\n        public Iterator<Edge> getEdges(int vert) {\n            return srcEdges[vert].iterator();\n        }\n\n        public static class Edge {\n\n            int v1;\n            int v2;\n            int weight;\n\n            public Edge(int v1, int v2, int weight) {\n                this.v1 = v1;\n                this.v2 = v2;\n                this.weight = weight;\n            }\n\n            public int other(int vertex) {\n                return v1 == vertex ? v2 : v1;\n            }\n\n            @Override\n            public boolean equals(Object obj) {\n                if (obj instanceof Edge) {\n                    final Edge other = (Edge) obj;\n                    if (this.weight == other.weight) {\n                        if ((v1 == other.v1 && v2 == other.v2) || (v2 == other.v1 && v1 == other.v2)) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numVertex1 = scanner.nextInt();\n        int numVertex2 = scanner.nextInt();\n        int numEdge = scanner.nextInt();\n        WeightedGraph graph = new WeightedGraph(numVertex1 + numVertex2);\n        while (numEdge-- > 0) {\n            int v1 = scanner.nextInt();\n            int v2 = scanner.nextInt() + numVertex1;\n            graph.addEdge(v1, v2, 1);\n        }\n        BipartiteMatch_Hungarian bipartiteMatch = new BipartiteMatch_Hungarian(graph);\n        System.out.println(bipartiteMatch.getMaxMatch());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\nimport java.util.Arrays;\n\npublic class Main {\n\t\t\n\t// ??????????????????????????????????????§?????¨??????????????°??? O(V*(V+E)) ??§?§£???\n\t// L <- ?????´?????????????????? : [0, L)\n\tpublic static int maximumBipartiteMatching(int L, ArrayList<HashSet<Integer>> adj){\n\t\tboolean[] visited = new boolean[adj.size()];\n\t\tint[] match = new int[adj.size()];\n\t\tArrays.fill(match, -1);\n\n\t\tint count = 0;\n\t\tfor(int curr = 0; curr < L; curr++){\n\t\t\tArrays.fill(visited, false);\n\n\t\t\tif(augment(adj, curr, match, visited)){ count++; }\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tprivate static boolean augment(ArrayList<HashSet<Integer>> adj, int curr, int[] match, boolean[] visited) {\n\t\tif(curr < 0){return true; }\n\n\t\tfor(final int next : adj.get(curr)) {\n\t\t\tif(visited[next]){ continue; }\n\n\t\t\tvisited[next] = true;\n\t\t\tif(augment(adj, match[next], match, visited)) {\n\t\t\t\tmatch[curr] = next;\n\t\t\t\tmatch[next] = curr;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\t\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int X = sc.nextInt();\n\t\tfinal int Y = sc.nextInt();\n\t\tfinal int E = sc.nextInt();\n\t\t\n\t\tfinal int size = X + Y;\n\t\tArrayList<HashSet<Integer>> adj = new ArrayList<HashSet<Integer>>();\n\t\tfor(int i = 0; i < size; i++){ adj.add(new HashSet<Integer>()); }\n\t\t\n\t\tfor(int i = 0; i < E; i++){\n\t\t\tfinal int x = sc.nextInt();\n\t\t\tfinal int y = sc.nextInt();\n\t\t\t\n\t\t\tadj.get(x).add(X + y);\n\t\t}\n\t\t\n\t\tSystem.out.println(maximumBipartiteMatching(X, adj));\n\t}\n\t\n\tpublic static class Scanner implements AutoCloseable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() {\n\t\t\ttry {\n\t\t\t\twhile (!hasNext()) {tok = new StringTokenizer(br.readLine());}\n\t\t\t} catch(IOException e){ /* ignore */ }\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tgetLine(); return tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt(){\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t// ??????nextXXX???XXX.parseXXX()????????????????????£?????????????????§?????\\\n\n\t\tpublic void close() {\n\t\t\ttry{ br.close(); } catch (IOException e){ /*ignore*/ }\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[][][] directedGraph(int n, int[] from, int[] to, int[] cost) {\n\t\tint[] cnt = new int[n];\n\t\tfor (int i : from) cnt[i]++;\n\n\t\tint[][][] g = new int[n][][];\n\t\tfor (int i=0; i<n; i++) g[i] = new int[cnt[i]][2];\n\t\tfor (int i=0; i<from.length; i++) {\n\t\t\tint s = from[i];\n\t\t\tint t = to[i];\n\n\t\t\tg[s][--cnt[s]][0] = t;\n\t\t\tg[s][cnt[s]][1] = cost[i];\n\t\t}\n\n\t\treturn g;\n\t}\n\n\tstatic int dinic(int[][][] g, int source, int sink) {\n\t\tint n = g.length;\n\t\tint[] cnt = new int[n];\n\n\t\tfor (int i=0; i<n; i++)\n\t\t\tfor (int[] link : g[i])\n\t\t\t\tcnt[link[0]]++;\n\n\t\tint[][] rev = new int[n][];\n\t\tfor (int i=0; i<n; i++) rev[i] = new int[cnt[i]];\n\t\tfor (int i=n-1; i>=0; i--)\n\t\t\tfor (int[] link : g[i])\n\t\t\t\trev[link[0]][--cnt[link[0]]] = i;\n\n\t\tint[][] flow = new int[n][n];\n\t\tint[] level = new int[n];\n\t\tint[] path = new int[n];\n\t\tint res = 0;\n\n\t\twhile (true) {\n\t\t\tArrays.fill(level,-1);\n\t\t\tpath[0] = source;\n\t\t\tint ptr = 1;\n\t\t\tlevel[source] = 0;\n\n\t\t\tfor (int i=0; i<ptr; i++) {\n\t\t\t\tint cur = path[i];\n\n\t\t\t\tfor (int[] link : g[cur]) {\n\t\t\t\t\tint next = link[0], cap = link[1];\n\t\t\t\t\tif (level[next] == -1 && cap - flow[cur][next] > 0) {\n\t\t\t\t\t\tpath[ptr++] = next;\n\t\t\t\t\t\tlevel[next] = level[cur] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int next : rev[cur]) {\n\t\t\t\t\tif (level[next] == -1 && -flow[cur][next] > 0) {\n\t\t\t\t\t\tpath[ptr++] = next;\n\t\t\t\t\t\tlevel[next] = level[cur] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (level[sink] == -1) break;\n\t\t\tint f = 0;\n\t\t\twhile ((f = dfsDinic(g,level,rev,flow,source,sink,Integer.MAX_VALUE/2)) > 0)\n\t\t\t\tres += f;\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tstatic int dfsDinic(int[][][] g, int[] level, int[][] rev, int[][] flow, int cur, int sink, int min){\n\t\tif (cur == sink) return min;\n\n\t\tint left = min;\n\n\t\tfor (int[] link : g[cur]) {\n\t\t\tint next = link[0], cap = link[1];\n\t\t\tif (level[next] == level[cur] + 1 && cap-flow[cur][next] > 0) {\n\t\t\t\tint f = dfsDinic(g,level,rev,flow,next,sink,Math.min(left, cap-flow[cur][next]));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\tflow[cur][next] += f;\n\t\t\t\t\tflow[next][cur] -= f;\n\t\t\t\t\tleft -= f;\n\t\t\t\t\tif (left == 0) return min;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int next : rev[cur]) {\n\t\t\tif (level[next] == level[cur] + 1 && -flow[cur][next] > 0) {\n\t\t\t\tint f = dfsDinic(g,level,rev,flow,next,sink,Math.min(left, -flow[cur][next]));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\tflow[cur][next] += f;\n\t\t\t\t\tflow[next][cur] -= f;\n\t\t\t\t\tleft -= f;\n\t\t\t\t\tif (left == 0) return min;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn min - left;\n\t}\n\n\tstatic void solve() {\n\t\tint a = in.nextInt();\n\t\tint b = in.nextInt();\n\t\tint v = a + b + 2;\n\t\tint e = in.nextInt();\n\t\tint[] s = new int[e+a+b];\n\t\tint[] t = new int[e+a+b];\n\t\tint[] c = new int[e+a+b];\n\t\tfor (int i=0; i<e; i++) {\n\t\t\ts[i] = in.nextInt();\n\t\t\tt[i] = in.nextInt() + a;\n\t\t\tc[i] = 1;\n\t\t}\n\n\t\tint source = a + b;\n\t\tint sink = a + b + 1;\n\t\tint pos = e;\n\t\tfor (int i=0; i<a; i++) {\n\t\t\ts[e] = source;\n\t\t\tt[e] = i;\n\t\t\tc[e] = 1<<30;\n\t\t\te++;\n\t\t}\n\n\t\tfor (int j=0; j<b; j++) {\n\t\t\ts[e] = j+a;\n\t\t\tt[e] = sink;\n\t\t\tc[e] = 1<<30;\n\t\t\te++;\n\t\t}\n\n\t\tint[][][] g = directedGraph(v, s, t, c);\n\n\t\tout.println(dinic(g, source, sink)/2);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\tsolve();\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int[][][] directedGraph(int n, int[] from, int[] to, int[] cost) {\n\t\tint[] cnt = new int[n];\n\t\tfor (int i : from) cnt[i]++;\n\n\t\tint[][][] g = new int[n][][];\n\t\tfor (int i=0; i<n; i++) g[i] = new int[cnt[i]][2];\n\t\tfor (int i=0; i<from.length; i++) {\n\t\t\tint s = from[i];\n\t\t\tint t = to[i];\n\n\t\t\tg[s][--cnt[s]][0] = t;\n\t\t\tg[s][cnt[s]][1] = cost[i];\n\t\t}\n\n\t\treturn g;\n\t}\n\n\tstatic int dinic(int[][][] g, int source, int sink) {\n\t\tint n = g.length;\n\t\tint[] cnt = new int[n];\n\n\t\tfor (int i=0; i<n; i++)\n\t\t\tfor (int[] link : g[i])\n\t\t\t\tcnt[link[0]]++;\n\n\t\tint[][] rev = new int[n][];\n\t\tfor (int i=0; i<n; i++) rev[i] = new int[cnt[i]];\n\t\tfor (int i=n-1; i>=0; i--)\n\t\t\tfor (int[] link : g[i])\n\t\t\t\trev[link[0]][--cnt[link[0]]] = i;\n\n\t\tint[][] flow = new int[n][n];\n\t\tint[] level = new int[n];\n\t\tint[] path = new int[n];\n\t\tint res = 0;\n\n\t\twhile (true) {\n\t\t\tArrays.fill(level,-1);\n\t\t\tpath[0] = source;\n\t\t\tint ptr = 1;\n\t\t\tlevel[source] = 0;\n\n\t\t\tfor (int i=0; i<ptr; i++) {\n\t\t\t\tint cur = path[i];\n\n\t\t\t\tfor (int[] link : g[cur]) {\n\t\t\t\t\tint next = link[0], cap = link[1];\n\t\t\t\t\tif (level[next] == -1 && cap - flow[cur][next] > 0) {\n\t\t\t\t\t\tpath[ptr++] = next;\n\t\t\t\t\t\tlevel[next] = level[cur] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (int next : rev[cur]) {\n\t\t\t\t\tif (level[next] == -1 && -flow[cur][next] > 0) {\n\t\t\t\t\t\tpath[ptr++] = next;\n\t\t\t\t\t\tlevel[next] = level[cur] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (level[sink] == -1) break;\n\t\t\tint f = 0;\n\t\t\twhile ((f = dfsDinic(g,level,rev,flow,source,sink,Integer.MAX_VALUE/2)) > 0)\n\t\t\t\tres += f;\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tstatic int dfsDinic(int[][][] g, int[] level, int[][] rev, int[][] flow, int cur, int sink, int min){\n\t\tif (cur == sink) return min;\n\n\t\tint left = min;\n\n\t\tfor (int[] link : g[cur]) {\n\t\t\tint next = link[0], cap = link[1];\n\t\t\tif (level[next] == level[cur] + 1 && cap-flow[cur][next] > 0) {\n\t\t\t\tint f = dfsDinic(g,level,rev,flow,next,sink,Math.min(left, cap-flow[cur][next]));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\tflow[cur][next] += f;\n\t\t\t\t\tflow[next][cur] -= f;\n\t\t\t\t\tleft -= f;\n\t\t\t\t\tif (left == 0) return min;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int next : rev[cur]) {\n\t\t\tif (level[next] == level[cur] + 1 && -flow[cur][next] > 0) {\n\t\t\t\tint f = dfsDinic(g,level,rev,flow,next,sink,Math.min(left, -flow[cur][next]));\n\t\t\t\tif (f > 0) {\n\t\t\t\t\tflow[cur][next] += f;\n\t\t\t\t\tflow[next][cur] -= f;\n\t\t\t\t\tleft -= f;\n\t\t\t\t\tif (left == 0) return min;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn min - left;\n\t}\n\n\tstatic void solve() {\n\t\tint a = in.nextInt();\n\t\tint b = in.nextInt();\n\t\tint v = a + b + 2;\n\t\tint e = in.nextInt();\n\t\tint[] s = new int[e+a+b];\n\t\tint[] t = new int[e+a+b];\n\t\tint[] c = new int[e+a+b];\n\t\tfor (int i=0; i<e; i++) {\n\t\t\ts[i] = in.nextInt();\n\t\t\tt[i] = in.nextInt() + a;\n\t\t\tc[i] = 1;\n\t\t}\n\n\t\tint source = a + b;\n\t\tint sink = a + b + 1;\n\t\tint pos = e;\n\t\tfor (int i=0; i<a; i++) {\n\t\t\ts[pos] = source;\n\t\t\tt[pos] = i;\n\t\t\tc[pos] = 1;\n\t\t\tpos++;\n\t\t}\n\n\t\tfor (int j=0; j<b; j++) {\n\t\t\ts[pos] = j+a;\n\t\t\tt[pos] = sink;\n\t\t\tc[pos] = 1;\n\t\t\tpos++;\n\t\t}\n\n\n\t\tint[][][] g = directedGraph(v, s, t, c);\n\n\t\tout.println(dinic(g, source, sink));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\tsolve();\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n    static class FlowEdge {\n        private static final double FLOATING_POINT_EPSILON = 1E-10;\n\n        final int v;\n        final int w;\n        final double capacity;\n        double flow;\n\n        FlowEdge(int v, int w, double capacity) {\n            this.v = v;\n            this.w = w;\n            this.capacity = capacity;\n            this.flow = 0.;\n        }\n\n        public double residualCapacity(int vertex) {\n            if      (vertex == v) return flow;              // backward edge\n            else if (vertex == w) return capacity - flow;   // forward edge\n            else throw new IllegalArgumentException(\"invalid endpoint\");\n        }\n\n        public void addResidualFlow(int vertex, double delta) {\n            if (!(delta >= 0.0)) throw new IllegalArgumentException(\"Delta must be nonnegative\");\n\n            if      (vertex == v) flow -= delta;           // backward edge\n            else if (vertex == w) flow += delta;           // forward edge\n            else throw new IllegalArgumentException(\"invalid endpoint\");\n\n            // round flow to 0 or capacity if within floating-point precision\n            if (Math.abs(flow) <= FLOATING_POINT_EPSILON)\n                flow = 0;\n            if (Math.abs(flow - capacity) <= FLOATING_POINT_EPSILON)\n                flow = capacity;\n\n            if (!(flow >= 0.0))      throw new IllegalArgumentException(\"Flow is negative\");\n            if (!(flow <= capacity)) throw new IllegalArgumentException(\"Flow exceeds capacity\");\n        }\n\n        public String toString() {\n            return v + \"->\" + w + \" \" + flow + \"/\" + capacity;\n        }\n\n        public int other(int vertex) {\n            if      (vertex == v) return w;\n            else if (vertex == w) return v;\n            else throw new IllegalArgumentException(\"invalid endpoint\");\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    static class FlowNetwork {\n        private static final String NEWLINE = \"\\n\";\n        private int E = 0;\n\n        final int V;\n        final LinkedList<FlowEdge>[] adj;\n\n        FlowNetwork(int V) {\n            this.V = V;\n            this.adj = new LinkedList[V];\n            for (int v = 0; v < V; v++){\n                adj[v] = new LinkedList<>();\n            }\n        }\n\n        void addEdge(FlowEdge edge) {\n            adj[edge.v].add(edge);\n            adj[edge.w].add(edge);\n            E++;\n        }\n\n        public Iterable<FlowEdge> adj(int v) {\n            return adj[v];\n        }\n\n        public String toString() {\n            StringBuilder s = new StringBuilder();\n            s.append(V + \" \" + E + NEWLINE);\n            for (int v = 0; v < V; v++) {\n                s.append(v + \":  \");\n                for (FlowEdge e : adj[v]) {\n                    if (e.w != v) s.append(e + \"  \");\n                }\n                s.append(NEWLINE);\n            }\n            return s.toString();\n        }\n    }\n\n    static class FordFulkerson {\n        private boolean[] marked;\n        private FlowEdge[] edgeTo;\n        double value;\n\n        FordFulkerson(FlowNetwork G, int s, int t){\n            value = 0.;\n            while (hasAugmentingPath(G, s, t)) {\n\n                // compute bottleneck capacity\n                double bottle = Double.POSITIVE_INFINITY;\n                for (int v = t; v != s; v = edgeTo[v].other(v)) {\n                    bottle = Math.min(bottle, edgeTo[v].residualCapacity(v));\n                }\n\n                // augment flow\n                for (int v = t; v != s; v = edgeTo[v].other(v)) {\n                    edgeTo[v].addResidualFlow(v, bottle);\n                }\n\n                value += bottle;\n            }\n        }\n\n        private boolean hasAugmentingPath(FlowNetwork G, int s, int t) {\n            edgeTo = new FlowEdge[G.V];\n            marked = new boolean[G.V];\n\n            // breadth-first search\n            Queue<Integer> queue = new LinkedList<>();\n            queue.add(s);\n            marked[s] = true;\n            while (!queue.isEmpty() && !marked[t]) {\n                int v = queue.poll();\n\n                for (FlowEdge e : G.adj(v)) {\n                    int w = e.other(v);\n\n                    // if residual capacity from v to w\n                    if (e.residualCapacity(w) > 0) {\n                        if (!marked[w]) {\n                            edgeTo[w] = e;\n                            marked[w] = true;\n                            queue.add(w);\n                        }\n                    }\n                }\n            }\n\n            // is there an augmenting path?\n            return marked[t];\n        }\n\n    }\n\n    public static void main (String[] args){\n        Scanner scanner = new Scanner(System.in);\n\n        int X = scanner.nextInt();\n        int Y = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        int V = X + Y + 2;\n        FlowNetwork network = new FlowNetwork(V);\n\n        // edges for X -> Y\n        for (int e = 0; e < E; e++){\n            int v = scanner.nextInt() + 1;\n            int w = scanner.nextInt() + 1 + X;\n            FlowEdge edge = new FlowEdge(v, w, 1);\n            network.addEdge(edge);\n        }\n\n        // edges for s -> X\n        for (int x = 0; x < X; x++){\n            int v = 0;\n            int w = x + 1;\n            FlowEdge edge = new FlowEdge(v, w, 1);\n            network.addEdge(edge);\n        }\n\n        // edges for Y -> t\n        for (int y = 0; y < Y; y++){\n            int v = y + 1 + X;\n            int w = V - 1;\n            FlowEdge edge = new FlowEdge(v, w, 1);\n            network.addEdge(edge);\n        }\n\n        FordFulkerson ff = new FordFulkerson(network, 0, V - 1);\n\n//        System.out.println(network.toString());\n\n        System.out.println(String.format(\"%s\", (int) ff.value));\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\nclass Solver{\n\tScanner sc =new Scanner(System.in);\n\n\tint x;\n\tint y;\n\tint e;\t\n\t\n\tvoid run(){\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\te = sc.nextInt();\n\t\t\n\t\tint n = e+x+y;\n\t\tE[] edges = new E[n*2];\n\t\t\n\t\tfor(int i =0 ; i < x ; i++){\n\t\t\tedges[i] = new E();\n\t\t\tedges[i].from = x+y;\n\t\t\tedges[i].to = i;\n\t\t\tedges[i].cap = 1;\n\t\t\t\n\t\t\tedges[n+i] = new E();\n\t\t\tedges[n+i].from = i;\n\t\t\tedges[n+i].to = x+y;\n\t\t\tedges[n+i].cap = 0;\n\t\t\t\n\t\t\tedges[i].rev = edges[n+i];\n\t\t\tedges[n+i].rev = edges[i];\n\t\t}\n\t\t\n\t\tfor(int j = 0 ; j < y; j++){\n\t\t\tedges[x+j] = new E();\n\t\t\tedges[x+j].from = x+j;\n\t\t\tedges[x+j].to = x+y+1;\n\t\t\tedges[x+j].cap = 1;\n\t\t\t\n\t\t\tedges[n+x+j] = new E();\n\t\t\tedges[n+x+j].from  =x+y+1;\n\t\t\tedges[n+x+j].to = x+j;\n\t\t\tedges[n+x+j].cap = 0;\n\t\t\t\n\t\t\tedges[x+j].rev = edges[n+x+j];\n\t\t\tedges[n+x+j].rev = edges[x+j];\n\t\t}\n\t\t\n\t\tfor(int k = 0 ; k < e; k++){\n\t\t\tint from = sc.nextInt();\n\t\t\tint to = sc.nextInt()+x;\n\t\t\t\n\t\t\tedges[x+y+k] = new E();\n\t\t\tedges[x+y+k].from = from;\n\t\t\tedges[x+y+k].to = to;\n\t\t\tedges[x+y+k].cap = 1;\n\t\t\t\n\t\t\tedges[n+x+y+k] = new E();\n\t\t\tedges[n+x+y+k].from = to;\n\t\t\tedges[n+x+y+k].to = from;\n\t\t\tedges[n+x+y+k].cap = 0;\n\t\t\t\n\t\t\tedges[x+y+k].rev = edges[n+x+y+k];\n\t\t\tedges[n+x+y+k].rev = edges[x+y+k];\n\t\t}\n\t\t\n\t\tdepth = new int[x+y+2];\n\t\tMap<Integer,List<E>> map = new HashMap<Integer,List<E>>();\n\t\tfor(E e: edges){\n\t\t\tmap.computeIfAbsent(e.from,__ -> new ArrayList<E>()).add(e);\n\t\t}\n\t\tfor(int i =0 ;i < x+y+2;i++){\n//\t\t\tSystem.out.println(i);\n\t\t\tfor(E e :map.getOrDefault(i, Collections.emptyList())){\n//\t\t\t\tSystem.out.println(e.from +\" \"+e.to+\" \"+e.cap); \n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tint sum = 0;\n\t\tfor(;;){\n\t\t\tArrays.fill(depth,-1);\n\n\t\t\tbfs(x+y+1,x+y,map);\n//\t\t\tSystem.out.println(Arrays.toString(depth));\n\t\t\tif(depth[x+y] == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tsum += max_flow(x+y,x+y+1,map);\n\t\t\t\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t}\n\t\t\n\tint depth[];\n\t\n\tvoid bfs(int from, int to, Map<Integer,List<E>> map){\n\t\t\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\tLinkedList<Integer> depthes = new LinkedList<Integer>();\n\t\tqueue.add(from);\n\t\tdepthes.add(0);\n\t\t\n\t\tfor(;!queue.isEmpty();){\n\t\t\t\n\t\t\tint pos = queue.removeFirst();\n\t\t\tint d = depthes.removeFirst();\n\t\t\t\n\t\t\tif(depth[pos] != -1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdepth[pos] = d;\n\t\t\t\n\t\t\tif(pos == to){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(E e : map.getOrDefault(pos,Collections.emptyList())){\n\t\t\t\t\n\t\t\t\tif( e.rev.cap > 0 ){\n\t\t\t\t\tqueue.addLast(  e.to );\n\t\t\t\t\tdepthes.addLast( d + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint max_flow(int from,int to,Map<Integer,List<E>> map){\n\t\t\n\t\tLinkedList<Integer> index = new LinkedList<Integer>();\n\t\tLinkedList<Integer> pos = new LinkedList<Integer>();\n\t\tLinkedList<E> path = new LinkedList<E>();\n\t\t\n\t\tpos.addLast(from);\n\t\tindex.addLast(-1);\n\t\tint sum = 0;\n\t\t\n\t\tfor(;;){\t\n\t\t\t\n\t\t\tint current = pos.removeLast();\n\t\t\tint start = index.removeLast();\n\t\t\t\n\t\t\tif(current == to){\n\t\t\t\tint flow = 2;\n\t\t\t\tfor(E e : path){\n\t\t\t\t\tflow = Math.min(flow,e.cap);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(E e: path){\n\t\t\t\t\te.cap -= flow;\n\t\t\t\t\te.rev.cap += flow;\n\t\t\t\t}\n\t\t\t\tpath.removeLast();\n\t\t\t\tsum += flow;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tList<E> l = map.get(current);\n\n\t\t\tboolean found = false;\n\t\t\tfor(int i = start+1; i < l.size(); i++){\n\t\t\t\tE e = l.get(i);\n\t\t\t\t\n\t\t\t\tif(e.cap > 0 && depth[e.from] > depth[e.to]){\n\t\t\t\t\tpos.addLast(current);\n\t\t\t\t\tindex.addLast(i);\n\t\t\t\t\t\n\t\t\t\t\tpath.addLast(e);\n\t\t\t\t\t\n\t\t\t\t\tpos.addLast(e.to);\n\t\t\t\t\tindex.addLast(-1);\n\t\t\t\t\t\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(found){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(path.isEmpty()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpath.removeLast();\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\t\n}\nclass E{\n\tint from;\n\tint to;\n\tint cap;\n\tE rev;\n}\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tSolver s  = new Solver();\n\t\ts.run();\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "// Java program for implementation of Ford Fulkerson algorithm\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.util.LinkedList;\n\npublic class Main {\n    static int V; //Number of vertices in graph\n    public static class FordFulkerson {\n\n        /* Returns true if there is a path from source 's' to sink\n        't' in residual graph. Also fills parent[] to store the\n        path */\n        boolean bfs(int rGraph[][], int s, int t, int parent[]) {\n            // Create a visited array and mark all vertices as not\n            // visited\n            boolean visited[] = new boolean[V];\n            for(int i=0; i<V; ++i)\n                visited[i]=false;\n\n            // Create a queue, enqueue source vertex and mark\n            // source vertex as visited\n            LinkedList<Integer> queue = new LinkedList<Integer>();\n            queue.add(s);\n            visited[s] = true;\n            parent[s]=-1;\n\n            // Standard BFS Loop\n            while (queue.size()!=0)\n            {\n                int u = queue.poll();\n\n                for (int v=0; v<V; v++)\n                {\n                    if (visited[v]==false && rGraph[u][v] > 0)\n                    {\n                        queue.add(v);\n                        parent[v] = u;\n                        visited[v] = true; \n                    } \n                } \n            } \n\n            // If we reached sink in BFS starting from source, then \n            // return true, else false \n            return (visited[t] == true); \n        } \n\n        // Returns tne maximum flow from s to t in the given graph \n        int fordFulkerson(int graph[][], int s, int t) \n        { \n            int u, v; \n\n            // Create a residual graph and fill the residual graph \n            // with given capacities in the original graph as \n            // residual capacities in residual graph \n\n            // Residual graph where rGraph[i][j] indicates \n            // residual capacity of edge from i to j (if there \n            // is an edge. If rGraph[i][j] is 0, then there is \n            // not) \n            int rGraph[][] = new int[V][V]; \n\n            for (u = 0; u < V; u++) \n                for (v = 0; v < V; v++) \n                    rGraph[u][v] = graph[u][v]; \n\n            // This array is filled by BFS and to store path \n            int parent[] = new int[V]; \n\n            int max_flow = 0; // There is no flow initially \n\n            // Augment the flow while tere is path from source \n            // to sink \n            while (bfs(rGraph, s, t, parent)) \n            { \n                // Find minimum residual capacity of the edhes \n                // along the path filled by BFS. Or we can say \n                // find the maximum flow through the path found. \n                int path_flow = Integer.MAX_VALUE; \n                for (v=t; v!=s; v=parent[v]) \n                { \n                    u = parent[v]; \n                    path_flow = Math.min(path_flow, rGraph[u][v]); \n                } \n\n                // update residual capacities of the edges and \n                // reverse edges along the path \n                for (v=t; v != s; v=parent[v]) \n                { \n                    u = parent[v]; \n                    rGraph[u][v] -= path_flow; \n                    rGraph[v][u] += path_flow; \n                } \n\n                // Add path flow to overall flow \n                max_flow += path_flow;\n            }\n\n            // Return the overall flow\n            return max_flow;\n        }\n    }\n    public static void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int X = Integer.parseInt(sc.next());\n        int Y = Integer.parseInt(sc.next());\n        V = X+Y+2;\n        int E = Integer.parseInt(sc.next());\n        int[][] graph = new int[V][V];\n        for (int i=0;i<E;i++) {\n            int x = Integer.parseInt(sc.next())+1;\n            int y = X+Integer.parseInt(sc.next())+1;\n            graph[x][y] = 1;\n            graph[0][x] = 1;\n            graph[y][V-1] =1;\n        }\n        FordFulkerson m = new FordFulkerson();\n        System.out.println(m.fordFulkerson(graph, 0, V-1));\n\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint X = in.nextInt();\n\t\tint Y = in.nextInt();\n\t\tint E = in.nextInt();\n\t\t\n\t\tint nAllPoints = 1+X+Y+1;\n\t\tlEdge = new List[nAllPoints];\n\t\tused = new boolean[nAllPoints];\n\t\tfor (int i=0;i<lEdge.length;i++) {\n\t\t\tlEdge[i] = new ArrayList<Edge>();\n\t\t}\n\t\t\n\t\tfor (int i=0;i<X;i++) {\n\t\t\taddEdge(0, i+1, 1);\n\t\t}\n\t\tfor (int i=0;i<E;i++) {\n\t\t\taddEdge(in.nextInt()+1, in.nextInt()+1+X, 1);\n\t\t}\n\t\tfor (int i=0;i<Y;i++) {\n\t\t\taddEdge(1+X+i, nAllPoints-1, 1);\n\t\t}\n\t\t\n\t\tint res = 0;\n\t\twhile (true) {\n\t\t\tArrays.fill(used, false);\n\t\t\tint ret = dfs(0, nAllPoints-1, Integer.MAX_VALUE);\n\t\t\tif (ret==0) break;\n\t\t\tres++;\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\n\tstatic List<Edge>[] lEdge;\n\tstatic boolean[] used;\n\n\tstatic class Edge {\n\t\tint to, cap, rev;\n\t\tpublic Edge(int to, int cap, int rev) {\n\t\t\tthis.to= to;this.cap = cap;this.rev = rev;\n\t\t}\n\t}\n\n\tstatic void addEdge(int fr, int to, int cap) {\n\t\tlEdge[fr].add(new Edge(to, cap, lEdge[to].size()));\n\t\tlEdge[to].add(new Edge(fr, 0, lEdge[fr].size()-1));\n\t}\n\n\tstatic int dfs (int fr, int to, int f) {\n\t\tif (fr==to) return f;\n\t\tused[fr] = true;\n\t\t\n\t\tfor (int i=0;i<lEdge[fr].size();i++) {\n\t\t\tEdge e = lEdge[fr].get(i);\n\t\t\tif (!used[e.to] && e.cap>0) {\n\t\t\t\tint dist = dfs(e.to, to, Math.min(f, e.cap));\n\t\t\t\tif (dist>0) {\n\t\t\t\t\te.cap -=dist;\n\t\t\t\t\tlEdge[e.to].get(e.rev).cap += dist;\n\t\t\t\t\treturn dist;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    private int[][] weight;\n    private int X;\n    private int Y;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() throws Exception{\n        FastScanner scanner = new FastScanner(System.in);\n\n        X = scanner.nextInt();\n        Y = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        if(X == 0 || Y == 0 || E == 0){\n            System.out.println(\"0\");\n            return;\n        }\n\n        weight = new int[X][Y];\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int w = 1;\n\n            weight[u][v] = w;\n        }\n\n        int km = KM();\n        if(km != -1){\n            System.out.println(km);\n        }\n        else{\n            System.out.println(maxKMP());\n        }\n    }\n\n    private int maxKMP(){\n        int[] match = new int[Y];\n        Arrays.fill(match, -1);\n        int result = 0;\n        for(int u = 0; u < X; ++u){\n            if(existPath(u, new boolean[Y], match)){\n                ++result;\n            }\n        }\n        \n        return result;\n    }\n    \n    private int KM(){\n        int[] lx = new int[X];\n        int[] ly = new int[Y];\n\n        initLx(lx);\n        int[] match = new int[Y];\n        Arrays.fill(match, -1);\n\n        for(int u = 0; u < X; ++u){\n            while(true){\n                boolean[] visitedX = new boolean[X];\n                boolean[] visitedY = new boolean[Y];\n                if(existPath(u, lx, ly, visitedX, visitedY, match)){\n                    break;\n                }\n\n                int d = Integer.MAX_VALUE;\n                for(int i = 0; i < X; ++i){\n                    if(!visitedX[i]){\n                        continue;\n                    }\n                    for(int j = 0; j < Y; ++j){\n                        if(visitedY[j]){\n                            continue;\n                        }\n\n                        d = Math.min(lx[i] + ly[j] - weight[i][j], d);\n                    }\n                }\n\n                if(d == Integer.MAX_VALUE){\n                    return -1;\n                }\n\n                for(int i = 0; i < X; ++i){\n                    if(visitedX[i]){\n                        lx[i] -= d;\n                    }\n                }\n\n                for(int j = 0; j < Y; ++j){\n                    if(visitedY[j]){\n                        ly[j] += d;\n                    }\n                }\n            }\n        }\n\n        int maxWeight = 0;\n        for(int j = 0; j < Y; ++j){\n            if(match[j] != -1){\n                maxWeight += weight[match[j]][j];\n            }\n        }\n\n        return maxWeight;\n    }\n    \n    private boolean existPath(int u, boolean[] visited, int[] match){\n        for(int v = 0; v < Y; ++v){\n            if(!visited[v] && weight[u][v] > 0){\n                visited[v] = true;\n                \n                if(match[v] < 0 || existPath(match[v], visited, match)){\n                    match[v] = u;\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n\n    private boolean existPath(int u, int[] lx, int[] ly, boolean[] visitedX, boolean[] visitedY, int[] match){\n        visitedX[u] = true;\n        for(int v = 0; v < Y; ++v){\n            if(!visitedY[v] && lx[u] + ly[v] == weight[u][v]){\n                visitedY[v] = true;\n\n                if(match[v] < 0 || existPath(match[v], lx, ly, visitedX, visitedY, match)){\n                    match[v] = u;\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private void initLx(int[] lx){\n        for(int i = 0; i < X; ++i){\n            lx[i] = weight[i][0];\n\n            for(int j = 1; j < Y; ++j){\n                lx[i] = Math.max(lx[i], weight[i][j]);\n            }\n        }\n    }\n\n    static class FastScanner {\n        private InputStream in;\n        private final byte[] buffer = new byte[1024 * 8];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in){\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    private boolean[][] graph;\n    private int X;\n    private int Y;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() throws Exception{\n        FastScanner scanner = new FastScanner(System.in);\n\n        X = scanner.nextInt();\n        Y = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        if(X == 0 || Y == 0 || E == 0){\n            System.out.println(\"0\");\n            return;\n        }\n\n        graph = new boolean[X][Y];\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n\n            graph[u][v] = true;\n        }\n\n        System.out.println(maxBPM());\n    }\n\n    private int maxBPM(){\n        int[] match = new int[Y];\n        Arrays.fill(match, -1);\n\n        int result = 0;\n        for(int u = 0; u < X; ++u){\n            if(existPath(u, new boolean[Y], match)){\n                ++result;\n            }\n        }\n\n        return result;\n    }\n\n    private boolean existPath(int u, boolean[] visited, int[] match){\n        for(int v = 0; v < Y; ++v){\n            if(graph[u][v] && !visited[v]){\n                visited[v] = true;\n\n                if(match[v] < 0 || existPath(match[v], visited, match)){\n                    match[v] = u;\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    static class FastScanner {\n        private InputStream in;\n        private final byte[] buffer = new byte[1024 * 8];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in){\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic int V;\n\tstatic int []match;\n\tstatic boolean []used;\n\tstatic Map<Integer, List<Integer>> G = new HashMap<Integer, List<Integer>>();\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint X = sc.nextInt();\n\t\tint Y = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tint []x = new int[E];\n\t\tint []y = new int[E];\n\t\tfor(int i = 0; i < E; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t}\n\t\tsc.close();\n\t\tV = X + Y;\n\t\tmatch = new int[V];\n\t\tused = new boolean[V];\n\t\tfor(int i = 0; i < E; i++) {\n\t\t\ty[i] += X;\n\t\t\tif(G.containsKey(x[i])) {\n\t\t\t\tG.get(x[i]).add(y[i]);\n\t\t\t}else {\n\t\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\t\tlist.add(y[i]);\n\t\t\t\tG.put(x[i], list);\n\t\t\t}\n\t\t\tif(G.containsKey(y[i])) {\n\t\t\t\tG.get(y[i]).add(x[i]);\n\t\t\t}else {\n\t\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\t\tlist.add(x[i]);\n\t\t\t\tG.put(y[i], list);\n\t\t\t}\n\t\t}\n\t\tint max = bipatricleMatching();\n\t\tSystem.out.println(max);\n\t}\n\tstatic boolean dfs(int v) {\n\t\tused[v] = true;\n\t\tif(!G.containsKey(v)) return false;\n\t\tfor(int i = 0; i < G.get(v).size(); i++) {\n\t\t\tint u = G.get(v).get(i);\n\t\t\tint w = match[u];\n\t\t\tif(w < 0 || (!used[w] && dfs(w))) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tstatic int bipatricleMatching() {\n\t\tint res = 0;\n\t\tArrays.fill(match, -1);\n\t\tfor(int v = 0; v < V; v++) {\n\t\t\tif(match[v] < 0) {\n\t\t\t\tArrays.fill(used, false);\n\t\t\t\tif(dfs(v)) res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tnew Main().start();\n\t}\n\tint[] matchTo;\n\tboolean[] vis;\n\tArrayList<Integer>[] g;\n\t@SuppressWarnings(\"unchecked\")\n\tvoid start(){\n\t\tScanner in = new Scanner(System.in);\n\t\tint x = in.nextInt();\n\t\tint y = in.nextInt();\n\t\tint e = in.nextInt();\n\t\tint[] xs = new int[e];\n\t\tint[] ys = new int[e];\n\t\tg = new ArrayList[x + y];\n\t\tfor(int i = 0; i < x + y; i++){\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i = 0; i < e; i++){\n\t\t\txs[i] = in.nextInt();\n\t\t\tys[i] = in.nextInt();\n\t\t\tg[xs[i]].add(ys[i]);\n\t\t\tg[ys[i]].add(xs[i]);\n\t\t}\n\t\tvis = new boolean[x + y];\n\t\tmatchTo = new int[x + y];\n\t\tArrays.fill(matchTo, -1);\n\t\tint match = 0;\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tArrays.fill(vis, false);\n\t\t\tif(dfs(i))match++;\n\t\t}\n\t\tSystem.out.println(match);\n\t}\n\tboolean dfs(int v){\n\t\tif(v < 0)\n\t\t\treturn true;\n\t\tfor(int u : g[v]){\n\t\t\tif(vis[u])\n\t\t\t\tcontinue;\n\t\t\tvis[u] = true;\n\t\t\tif(dfs(matchTo[u])){\n\t\t\t\tmatchTo[u] = v;\n\t\t\t\tmatchTo[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    private boolean[][] graph;\n    private int X;\n    private int Y;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() throws Exception{\n        FastScanner scanner = new FastScanner(System.in);\n\n        X = scanner.nextInt();\n        Y = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        if(X == 0 || Y == 0 || E == 0){\n            System.out.println(\"0\");\n            return;\n        }\n\n        graph = new boolean[X][Y];\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n\n            graph[u][v] = true;\n        }\n\n        System.out.println(maxBPM());\n    }\n\n    private int maxBPM(){\n        int[] match = new int[Y];\n        Arrays.fill(match, -1);\n\n        int result = 0;\n        for(int u = 0; u < X; ++u){\n            if(existPath(u, new boolean[Y], match)){\n                ++result;\n            }\n        }\n\n        return result;\n    }\n\n    private boolean existPath(int u, boolean[] visited, int[] match){\n        for(int v = 0; v < Y; ++v){\n            if(graph[u][v] && !visited[v]){\n                visited[v] = true;\n                if(match[v] < 0 || existPath(match[v], visited, match)){\n                    match[v] = u;\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    static class FastScanner {\n        private InputStream in;\n        private final byte[] buffer = new byte[1024 * 8];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in){\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main\n{\n\t//Ford-Fulkerson algorithm implementation practice\n\tstatic int v, e;\n\t\n\tstatic class Node\n\t{\n\t\tint id;\n//\t\tArrayList<Edge> edges = new ArrayList<>();\n\t\t\n\t\tHashMap<Integer, Integer> resflow = new HashMap<>();\n\t\t\n\t\tvoid incflow(int i, int flow)\n\t\t{\n\t\t\tif(resflow.containsKey(i))\n\t\t\t\tresflow.put(i, resflow.get(i)+flow);\n\t\t\telse\n\t\t\t\tresflow.put(i, flow);\n\t\t}\n\t\t\n\t\tpublic Node(int i)\n\t\t{\n\t\t\tid = i;\n\t\t}\n\t}\n\t\n\tstatic class Edge\n\t{\n\t\tNode node;\n\t\tint flow = 0;\n\t\tint resflow = 0;\n\t\t\n\t\tpublic Edge(int fl)\n\t\t{\n\t\t\tflow = fl;\n\t\t\tresflow = fl;\n\t\t}\n\t}\n\t\n\tstatic Node[] node;\n\n\tpublic static void main(String[] args) \n\t{\n//\t\tSystem.out.println(\"Aygreets!\");\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint x = sc.nextInt();\n\t\tint y = sc.nextInt();\n\t\te = sc.nextInt();\n\t\t\n\t\tv = x + y + 2;\n\t\tnode = new Node[v];\n\t\t\n\t\tfor(int i = 0; i < v; i++)\n\t\t\tnode[i] = new Node(i);\n\t\t\n\t\tfor(int i = 0; i < e; i++)\n\t\t{ //read edges\n\t\t\tint a = sc.nextInt()+1; //node in x\n\t\t\tint b = sc.nextInt()+1+x; //node in y\n\t\t\tint flow = 1; //flow that can still flow through this edge.\n\t\t\t\n\t\t\tnode[a].incflow(b, flow);\n\t\t\tnode[b].incflow(a, 0);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < x+1; i++)\n\t\t{ //add flow from source to x\n\t\t\tnode[0].incflow(i, 1);\n\t\t}\n\t\t\n\t\tfor(int i = x+1; i < v-1; i++)\n\t\t{ //add flow from y to sink\n\t\t\tnode[i].incflow(v-1, 1);\n\t\t}\n\t\t\n\t\t//This part is the same as standard Ford-Fulkerson\n\t\tint[] par = new int[v];\n\t\t\n\t\t//Traverse.\n\t\tboolean keepgoing = true;\n\t\tint sunk = 0;\n\t\t\n\t\twhile(keepgoing)\n\t\t{ //keep finding augmenting paths until it's determined that there isn't one.\n\t\t\tkeepgoing = false;\n\t\t\tint pos = -1;\n\t\t\t\n\t\t\tboolean[] visited = new boolean[v];\n\t\t\tint[] flowing = new int[v];\n\t\t\t\n\t\t\tStack<Integer> stack = new Stack<>();\n\t\t\tstack.add(0);\n\t\t\tflowing[0] = 999999999;\n\t\t\t//DFS\n\t\t\twhile(!stack.isEmpty())\n\t\t\t{\n\t\t\t\tpos = stack.pop();\n\t\t\t\tNode nd = node[pos];\n\t\t\t\t\n\t\t\t\tif(!visited[pos])\n\t\t\t\t{\n\t\t\t\t\tvisited[pos] = true;\n\t\t\t\t\t\n\t\t\t\t\tif(pos == v-1)\n\t\t\t\t\t{ //reached sink\n\t\t\t\t\t\tkeepgoing = true;\n\t\t\t\t\t\tint backpos = pos;\n\t\t\t\t\t\tint flow = flowing[pos];\n\t\t\t\t\t\tsunk += flow;\n\t\t\t\t\t\t\n\t\t\t\t\t\twhile(backpos != 0)\n\t\t\t\t\t\t{ //backtrack; update residual capacities.\n\t\t\t\t\t\t\tnode[backpos].incflow(par[backpos], flow);\n\t\t\t\t\t\t\tnode[par[backpos]].incflow(backpos, -flow);\n\t\t\t\t\t\t\tbackpos = par[backpos];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int ed : nd.resflow.keySet())\n\t\t\t\t\t{ //find unvisited nodes that can have flow flow from this node\n\t\t\t\t\t\tint res = nd.resflow.get(ed);\n\t\t\t\t\t\tif(res > 0 && !visited[ed])\n\t\t\t\t\t\t{ //can flow here\n\t\t\t\t\t\t\tstack.add(ed);\n\t\t\t\t\t\t\tflowing[ed] = Math.min(flowing[pos], res);\n\t\t\t\t\t\t\tpar[ed] = pos;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(sunk);\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.HashMap;\nimport java.util.HashSet;\n \npublic class Main {\n\tpublic static void main(String[] args) throws NumberFormatException,\n\tIOException {Solve solve = new Solve();solve.solve();}\n}\nclass Solve{\n\tHashSet<Integer>[] node;\n\tvoid solve() throws NumberFormatException, IOException{\n\t\tContestScanner in = new ContestScanner();\n\t\tWriter out = new Writer();\n\t\tint x = in.nextInt();\n\t\tint y = in.nextInt();\n\t\tint e = in.nextInt();\n\t\tMatching2 mat = new Matching2(x, y);\n\t\tfor(int i=0; i<e; i++){\n\t\t\tmat.edge(in.nextInt(), in.nextInt());\n\t\t}\n\t\tSystem.out.println(mat.solve());\n\t}\n}\n\nclass Matching2{\n\tint n, m;\n\tBitSet[] cap;\n\tpublic Matching2(int n, int m) {\n\t\tthis.n = n;\n\t\tthis.m = m;\n\t\tcap = new BitSet[n+m+2];\n\t\tfor(int i=0; i<n+m+2; i++){\n\t\t\tcap[i] = new BitSet(n+m+2);\n\t\t}\n\t\tfor(int i=0; i<n+m; i++){\n\t\t\tif(i<n) cap[n+m].set(i);\n\t\t\telse cap[i].set(n+m+1);\n\t\t}\n\t}\n\tvoid edge(int left, int right){\n\t\tcap[left].set(n+right);\n\t}\n\tint solve(){\n\t\tint res = 0;\n\t\twhile(true){\n\t\t\tused.clear();\n\t\t\tboolean flow = flow(n+m, true);\n\t\t\tif(!flow) break;\n\t\t\tres += flow?1:0;\n\t\t}\n\t\treturn res;\n\t}\n\tBitSet used = new BitSet();\n\tboolean flow(int id, boolean flow){\n\t\tif(id == m+n+1) return flow;\n\t\tif(used.get(id)) return false;\n\t\tused.set(id);\n\t\tfor(int v=cap[id].nextSetBit(0);\n\t\t\t\tv!=-1; v=cap[id].nextSetBit(v+1)){\n\t\t\tboolean f = flow(v, flow & cap[id].get(v));\n\t\t\tif(!f) continue;\n\t\t\tcap[id].clear(v);\n\t\t\tcap[v].set(id);\n\t\t\treturn f;\n\t\t}\n\t\treturn false;\n\t}\n}\nclass MultiSet<T> extends HashMap<T, Integer>{\n\t@Override\n\tpublic Integer get(Object key){return containsKey(key)?super.get(key):0;}\n\tpublic void add(T key,int v){put(key,get(key)+v);}\n\tpublic void add(T key){put(key,get(key)+1);}\n\tpublic void sub(T key){\n\t\tfinal int num = get(key);\n\t\tif(num==1) remove(key);\n\t\telse put(key, num-1);\n\t}\n}\nclass Timer{\n\tlong time;\n\tpublic void set(){time = System.currentTimeMillis();}\n\tpublic long stop(){return System.currentTimeMillis()-time;}\n}\nclass Writer extends PrintWriter{\n\tpublic Writer(String filename) throws IOException\n\t{super(new BufferedWriter(new FileWriter(filename)));}\n\tpublic Writer() throws IOException{super(System.out);}\n}\nclass ContestScanner {\n\tprivate BufferedReader reader;\n\tprivate String[] line;\n\tprivate int idx;\n\tpublic ContestScanner() throws FileNotFoundException \n\t{reader = new BufferedReader(new InputStreamReader(System.in));}\n\tpublic ContestScanner(String filename) throws FileNotFoundException\n\t{reader = new BufferedReader(new InputStreamReader(new FileInputStream(filename)));}\n\tpublic String nextToken() throws IOException {\n\t\tif (line == null || line.length <= idx) {\n\t\t\tline = reader.readLine().trim().split(\" \");\n\t\t\tidx = 0;\n\t\t}\n\t\treturn line[idx++];\n\t}\n\tpublic String readLine() throws IOException{return reader.readLine();}\n\tpublic long nextLong() throws IOException, NumberFormatException\n\t{return Long.parseLong(nextToken());}\n\tpublic int nextInt() throws NumberFormatException, IOException\n\t{return (int) nextLong();}\n\tpublic double nextDouble() throws NumberFormatException, IOException \n\t{return Double.parseDouble(nextToken());}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic int V;\n\tstatic int []match;\n\tstatic boolean []used;\n\tstatic Map<Integer, List<Integer>> G = new HashMap<Integer, List<Integer>>();\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint X = sc.nextInt();\n\t\tint Y = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tint []x = new int[E];\n\t\tint []y = new int[E];\n\t\tfor(int i = 0; i < E; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t}\n\t\tsc.close();\n\t\tV = Math.min(X, Y);\n\t\tmatch = new int[V];\n\t\tused = new boolean[V];\n\t\tfor(int i = 0; i < E; i++) {\n\t\t\tif(G.containsKey(x[i])) {\n\t\t\t\tG.get(x[i]).add(y[i]);\n\t\t\t}else {\n\t\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\t\tlist.add(y[i]);\n\t\t\t\tG.put(x[i], list);\n\t\t\t}\n\t\t\tif(G.containsKey(y[i])) {\n\t\t\t\tG.get(y[i]).add(x[i]);\n\t\t\t}else {\n\t\t\t\tList<Integer> list = new ArrayList<Integer>();\n\t\t\t\tlist.add(x[i]);\n\t\t\t\tG.put(y[i], list);\n\t\t\t}\n\t\t}\n\t\tint max = bipatricleMatching();\n\t\tSystem.out.println(max);\n\t}\n\tstatic boolean dfs(int v) {\n\t\tused[v] = true;\n\t\tfor(int i = 0; i < G.get(v).size(); i++) {\n\t\t\tint u = G.get(v).get(i);\n\t\t\tint w = match[u];\n\t\t\tif(w < 0 || !used[w] && dfs(w)) {\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tstatic int bipatricleMatching() {\n\t\tint res = 0;\n\t\tArrays.fill(match, -1);\n\t\tfor(int v = 0; v < V; v++) {\n\t\t\tif(match[v] < 0) {\n\t\t\t\tArrays.fill(used, false);\n\t\t\t\tif(dfs(v)) res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    private boolean[][] graph;\n    private int X;\n    private int Y;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() throws Exception{\n        FastScanner scanner = new FastScanner(System.in);\n\n        X = scanner.nextInt();\n        Y = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        if(X == 0 || Y == 0 || E == 0){\n            System.out.println(\"0\");\n            return;\n        }\n\n        graph = new boolean[X][Y];\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n\n            graph[u][v] = true;\n        }\n\n        System.out.println(maxBPM());\n    }\n\n    private int maxBPM(){\n        int[] match = new int[Y];\n        Arrays.fill(match, -1);\n\n        int result = 0;\n        for(int u = 0; u < X; ++u){\n            if(match[u] < 0 && existPath(u, new boolean[Y], match)){\n                ++result;\n            }\n        }\n\n        return result;\n    }\n\n    private boolean existPath(int u, boolean[] visited, int[] match){\n        for(int v = 0; v < Y; ++v){\n            if(graph[u][v] && !visited[v]){\n                visited[v] = true;\n                if(match[v] < 0 || existPath(match[v], visited, match)){\n                    match[v] = u;\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    static class FastScanner {\n        private InputStream in;\n        private final byte[] buffer = new byte[1024 * 8];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in){\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    private int[][] weight;\n    private int X;\n    private int Y;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() throws Exception{\n        FastScanner scanner = new FastScanner(System.in);\n\n        X = scanner.nextInt();\n        Y = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        if(X == 0 || Y == 0 || E == 0){\n            System.out.println(\"0\");\n            return;\n        }\n\n        weight = new int[X][Y];\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int w = 1;\n\n            weight[u][v] = w;\n        }\n\n        System.out.println(KM());\n    }\n\n    private int KM(){\n        int[] lx = new int[X];\n        int[] ly = new int[Y];\n\n        initLx(lx);\n        int[] match = new int[Y];\n        Arrays.fill(match, -1);\n\n        for(int u = 0; u < X; ++u){\n            while(true){\n                boolean[] visitedX = new boolean[X];\n                boolean[] visitedY = new boolean[Y];\n                if(existPath(u, lx, ly, visitedX, visitedY, match)){\n                    break;\n                }\n\n                int d = Integer.MAX_VALUE;\n                for(int i = 0; i < X; ++i){\n                    if(!visitedX[i]){\n                        continue;\n                    }\n                    for(int j = 0; j < Y; ++j){\n                        if(visitedY[j]){\n                            continue;\n                        }\n\n                        d = Math.min(lx[i] + ly[j] - weight[i][j], d);\n                    }\n                }\n\n                if(d == Integer.MAX_VALUE){\n                    return -1;\n                }\n\n                for(int i = 0; i < X; ++i){\n                    if(visitedX[i]){\n                        lx[i] -= d;\n                    }\n                }\n\n                for(int j = 0; j < Y; ++j){\n                    if(visitedY[j]){\n                        ly[j] += d;\n                    }\n                }\n            }\n        }\n\n        int maxWeight = 0;\n        for(int j = 0; j < Y; ++j){\n            if(match[j] != -1){\n                maxWeight += weight[match[j]][j];\n            }\n        }\n\n        return maxWeight;\n    }\n\n    private boolean existPath(int u, int[] lx, int[] ly, boolean[] visitedX, boolean[] visitedY, int[] match){\n        visitedX[u] = true;\n        for(int v = 0; v < Y; ++v){\n            if(!visitedY[v] && lx[u] + ly[v] == weight[u][v]){\n                visitedY[v] = true;\n\n                if(match[v] < 0 || existPath(match[v], lx, ly, visitedX, visitedY, match)){\n                    match[v] = u;\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private void initLx(int[] lx){\n        for(int i = 0; i < X; ++i){\n            lx[i] = weight[i][0];\n\n            for(int j = 1; j < Y; ++j){\n                lx[i] = Math.max(lx[i], weight[i][j]);\n            }\n        }\n    }\n\n    static class FastScanner {\n        private InputStream in;\n        private final byte[] buffer = new byte[1024 * 8];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in){\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    private boolean[][] graph;\n    private int X;\n    private int Y;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() throws Exception{\n        FastScanner scanner = new FastScanner(System.in);\n\n        X = scanner.nextInt();\n        Y = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        if(X == 0 || Y == 0 || E == 0){\n            System.out.println(\"0\");\n            return;\n        }\n\n        graph = new boolean[X][Y];\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n\n            graph[u][v] = true;\n        }\n\n        System.out.println(maxBPM());\n    }\n\n    private int maxBPM(){\n        int[] match = new int[Y];\n        Arrays.fill(match, -1);\n        boolean[] visited = new boolean[Y];\n\n        int result = 0;\n        for(int u = 0; u < X; ++u){\n            if(existPath(u, visited, match)){\n                ++result;\n            }\n        }\n\n        return result;\n    }\n\n    private boolean existPath(int u, boolean[] visited, int[] match){\n        for(int v = 0; v < Y; ++v){\n            if(graph[u][v] && !visited[v]){\n                visited[v] = true;\n\n                if(match[v] < 0 || existPath(match[v], visited, match)){\n                    match[v] = u;\n                    visited[v] = false;\n                    return true;\n                }\n\n                visited[v] = false;\n            }\n        }\n\n        return false;\n    }\n\n    static class FastScanner {\n        private InputStream in;\n        private final byte[] buffer = new byte[1024 * 8];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in){\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static class Dinic {\n\n        final ResidualNetwork residualG;\n        final int srcVert;\n        final int termVert;\n        int[] level;\n        int[] iter;\n\n        public Dinic(WeightedDigraph graph, int srcVert, int termVert) {\n            this.residualG = new ResidualNetwork(graph);\n            this.srcVert = srcVert;\n            this.termVert = termVert;\n        }\n\n        public int computeMaxFlow() {\n            level = new int[residualG.numVertex];\n            iter = new int[residualG.numVertex];\n            int maxFlow = 0;\n            for (;;) {\n                bfs();\n                if (level[termVert] < 0) {\n                    return maxFlow;\n                }\n                Arrays.fill(iter, 0);\n                int flow = 0;\n                while ((flow = dfs(srcVert, termVert, Integer.MAX_VALUE)) > 0) {\n                    maxFlow += flow;\n                }\n            }\n        }\n\n        private void bfs() {\n            Arrays.fill(level, -1);\n            Queue<Integer> queue = new LinkedList<Integer>();\n            level[srcVert] = 0;\n            queue.add(srcVert);\n            while (!queue.isEmpty()) {\n                int v = queue.remove();\n                for (WeightedDigraph.Edge edge : residualG.srcEdges[v]) {\n                    if (edge.weight > 0 && level[edge.targetVertex] < 0) {\n                        level[edge.targetVertex] = level[v] + 1;\n                        queue.add(edge.targetVertex);\n                    }\n                }\n            }\n        }\n\n        private int dfs(int v, int t, int flow) {\n            if (v == t) {\n                return flow;\n            }\n            for (WeightedDigraph.Edge edge : residualG.srcEdges[v]) {\n                if (edge.weight > 0 && level[v] < level[edge.targetVertex]) {\n                    int minFlow = dfs(edge.targetVertex, t, Math.min(flow, edge.weight));\n                    if (minFlow > 0) {\n                        edge.weight -= minFlow;\n                        residualG.edgeMap.get(edge).weight += minFlow;\n                        return minFlow;\n                    }\n                }\n            }\n            return 0;\n        }\n    }\n\n    public static class ResidualNetwork extends WeightedDigraph {\n\n        HashMap<Edge, Edge> edgeMap;\n\n        public ResidualNetwork(WeightedDigraph graph) {\n            super(graph.numVertex);\n            edgeMap = new HashMap<Edge, Edge>();\n            for (int i = 0; i < graph.numVertex; i++) {\n                for (WeightedDigraph.Edge edge : graph.srcEdges[i]) {\n                    this.addEdge(edge.srcVertex, edge.targetVertex, edge.weight);\n                }\n            }\n        }\n\n        @Override\n        public void addEdge(int srcVertex, int targetVertex, int weight) {\n            Edge e = new WeightedDigraph.Edge(srcVertex, targetVertex, weight);\n            srcEdges[srcVertex].add(e);\n            Edge backE = new WeightedDigraph.Edge(targetVertex, srcVertex, 0);\n            srcEdges[targetVertex].add(backE);\n            edgeMap.put(e, backE);\n            edgeMap.put(backE, e);\n        }\n    }\n\n    public static class WeightedDigraph {\n\n        int numVertex;\n        List<Edge>[] srcEdges;\n\n        @SuppressWarnings(\"unchecked\")\n        public WeightedDigraph(int numV) {\n            this.numVertex = numV;\n            srcEdges = new List[numV];\n\n            for (int i = 0; i < numV; i++) {\n                srcEdges[i] = new ArrayList<Edge>();\n            }\n        }\n\n        public void addEdge(int srcVertex, int targetVertex, int weight) {\n            Edge e = new WeightedDigraph.Edge(srcVertex, targetVertex, weight);\n            srcEdges[srcVertex].add(e);\n        }\n\n        public static class Edge {\n\n            int srcVertex;\n            int targetVertex;\n            int weight;\n\n            public Edge(int srcVertex, int targetVertex, int weight) {\n                this.srcVertex = srcVertex;\n                this.targetVertex = targetVertex;\n                this.weight = weight;\n            }\n\n            @Override\n            public int hashCode() {\n                int hash = 3;\n                hash = 59 * hash + this.srcVertex;\n                hash = 59 * hash + this.targetVertex;\n                return hash;\n            }\n\n            @Override\n            public boolean equals(Object obj) {\n                if (this == obj) {\n                    return true;\n                }\n                if (obj == null) {\n                    return false;\n                }\n                if (getClass() != obj.getClass()) {\n                    return false;\n                }\n                final Edge other = (Edge) obj;\n                if (this.srcVertex != other.srcVertex) {\n                    return false;\n                }\n                if (this.targetVertex != other.targetVertex) {\n                    return false;\n                }\n                return true;\n            }\n\n        }\n\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numVertex1 = scanner.nextInt();\n        int numVertex2 = scanner.nextInt();\n        int numEdge = scanner.nextInt();\n        WeightedDigraph graph = new WeightedDigraph(numVertex1 + numVertex2 + 2);\n        int srcVert = numVertex1 + numVertex2;\n        int termVert = srcVert + 1;\n        while (numEdge-- > 0) {\n            int v1 = scanner.nextInt();\n            int v2 = scanner.nextInt() + numVertex1;\n            graph.addEdge(v1, v2, 1);\n        }\n        for (int vert = 0; vert < numVertex1; vert++) {\n            graph.addEdge(srcVert, vert, 1);\n        }\n        for (int vert = numVertex1; vert < numVertex1 + numVertex2; vert++) {\n            graph.addEdge(vert, termVert, Integer.MAX_VALUE);\n        }\n        Dinic maxFlow = new Dinic(graph, srcVert, termVert);\n        System.out.println(maxFlow.computeMaxFlow());\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Vector;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint x = sc.nextInt();\n\t\tint y = sc.nextInt();\n\t\tint e = sc.nextInt();\n\t\t\n\t\tV = x + y;\n\n\t\t//グラフの隣接リスト表現\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tVector<Integer> G[] = new Vector[V];\n\t\tfor(int i = 0; i < G.length; i++){\n\t\t\tG[i] = new Vector<Integer>();\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < e; i++){\n\t\t\taddEdge(G, sc.nextInt(), sc.nextInt() + x);\n\t\t}\n\t\t\n\t\tSystem.out.println(bipartiteMatching(G));\n\n\t}\n\t//頂点数\n\tstatic int V;\n\t//マッチングのペア\n\tstatic int match[];\n\t//DFSで既に使用したか\n\tstatic boolean[] used;\n\n\tstatic void addEdge(Vector<Integer>[] G, int u, int v){\n\t\tG[u].add(v);\n\t\tG[v].add(u);\n\n\t\t//\t\t\tSystem.out.println(\"add \"+u+\" and \"+v);\n\t}\n\n\t//二部グラフの最大マッチングを求める\n\tstatic int bipartiteMatching(Vector<Integer>[] G){\n\t\tint result = 0;\n\t\tmatch = new int[G.length];\n\t\tArrays.fill(match, -1);\n\n\t\tused = new boolean[G.length];\n\t\tfor(int v = 0; v < G.length; v++){\n\t\t\tif(match[v] < 0){\n\t\t\t\tArrays.fill(used, false);\n\t\t\t\tif(dfs(G, match, used, v)){\n\t\t\t\t\tresult++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t//増加パスを探す\n\tstatic boolean dfs(Vector<Integer>[] G, int[] match, boolean[] used, int v){\n\t\tused[v] = true;\n\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tint u = G[v].get(i);\n\t\t\tint w = match[u];\n\n\t\t\tif(w < 0 || !used[w] && dfs(G, match, used, w)){\n\t\t\t\tmatch[v] = u;\n\t\t\t\tmatch[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    private int[][] graph;\n    private int X;\n    private int Y;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() throws Exception{\n        FastScanner scanner = new FastScanner(System.in);\n\n        X = scanner.nextInt();\n        Y = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        if(X == 0 || Y == 0 || E == 0){\n            System.out.println(\"0\");\n            return;\n        }\n\n        graph = new int[X][Y];\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int w = 1;\n\n            graph[u][v] = w;\n        }\n\n        System.out.println(KM());\n    }\n\n    private int KM(){\n        int[] lx = new int[X];\n        int[] ly = new int[Y];\n\n        initLx(lx);\n        int[] match = new int[Y];\n        Arrays.fill(match, -1);\n\n        for(int u = 0; u < X; ++u){\n            while(true){\n                boolean[] visitedX = new boolean[X];\n                boolean[] visitedY = new boolean[Y];\n                if(existPath(u, lx, ly, visitedX, visitedY, match)){\n                    break;\n                }\n\n                int d = Integer.MAX_VALUE;\n                for(int i = 0; i < X; ++i){\n                    if(!visitedX[i]){\n                        continue;\n                    }\n                    for(int j = 0; j < Y; ++j){\n                        if(visitedY[j]){\n                            continue;\n                        }\n\n                        d = Math.min(lx[i] + ly[j] - graph[i][j], d);\n                    }\n                }\n\n                if(d == Integer.MAX_VALUE){\n                    return -1;\n                }\n\n                for(int i = 0; i < X; ++i){\n                    if(visitedX[i]){\n                        lx[i] -= d;\n                    }\n                }\n\n                for(int j = 0; j < Y; ++j){\n                    if(visitedY[j]){\n                        ly[j] += d;\n                    }\n                }\n            }\n        }\n\n        int maxWeight = 0;\n        for(int j = 0; j < Y; ++j){\n            if(match[j] != -1){\n                maxWeight += graph[match[j]][j];\n            }\n        }\n\n        return maxWeight;\n    }\n\n    private boolean existPath(int u, int[] lx, int[] ly, boolean[] visitedX, boolean[] visitedY, int[] match){\n        visitedX[u] = true;\n        for(int v = 0; v < Y; ++v){\n            if(!visitedY[v] && lx[u] + ly[v] == graph[u][v]){\n                visitedY[v] = true;\n\n                if(match[v] < 0 || existPath(v, lx, ly, visitedX, visitedY, match)){\n                    match[v] = u;\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private void initLx(int[] lx){\n        for(int i = 0; i < X; ++i){\n            lx[i] = graph[i][0];\n\n            for(int j = 1; j < Y; ++j){\n                lx[i] = Math.max(lx[i], graph[i][j]);\n            }\n        }\n    }\n\n    static class FastScanner {\n        private InputStream in;\n        private final byte[] buffer = new byte[1024 * 8];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in){\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.stream.Stream;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic int modP = 1000000007;\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint X = in.nextInt(), Y = in.nextInt(), E = in.nextInt();\n\t\t\tint s = X + Y;\n\t\t\tint t = s + 1;\n\n\t\t\tFlow f = new Flow(X + Y + 2);\n\t\t\tfor (int i = 0; i < E; i++) {\n\t\t\t\tint u = in.nextInt();\n\t\t\t\tint v = in.nextInt();\n\t\t\t\tf.addEdge(u, v + X, 1);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < X; i++) {\n\t\t\t\tf.addEdge(s, i, 1);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < Y; i++) {\n\t\t\t\tf.addEdge(i + X, t, 1);\n\t\t\t}\n\n\t\t\tint ans = f.maxFlow(s, t);\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tstatic class Flow {\n\n\t\tstatic int INF = 1 << 30;\n\n\t\tboolean[] used;\n\t\tList<Edge>[] G;\n\t\tint V;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Flow(int V) {\n\t\t\tG = Stream.generate(ArrayList::new).limit(V).toArray(List[]::new);\n\t\t\tused = new boolean[V];\n\t\t\tthis.V = V;\n\t\t}\n\n\t\tstatic class Edge {\n\t\t\tint to, cap, rev;\n\t\t\tpublic Edge(int to, int cap, int rev) {\n\t\t\t\tthis.to = to;\n\t\t\t\tthis.cap = cap;\n\t\t\t\tthis.rev = rev;\n\t\t\t}\n\t\t}\n\n\t\tvoid addEdge(int u, int v, int c) {\n\t\t\tG[u].add(new Edge(v, c, G[v].size()));\n\t\t\tG[v].add(new Edge(u, 0, G[u].size() - 1));\n\t\t}\n\n\t\tint dfs(int u, int v, int f) {\n\t\t\tif (u == v) return f;\n\t\t\tused[u] = true;\n\t\t\tfor (Edge e : G[u]) {\n\t\t\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\t\t\tint d = dfs(e.to, v, Math.min(f, e.cap));\n\t\t\t\t\tif (d > 0) {\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to].get(e.rev).cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tint maxFlow(int s, int t) {\n\t\t\tint flow = 0;\n\t\t\twhile (true) {\n\t\t\t\tused = new boolean[V];\n\t\t\t\tint f = dfs(s, t, INF);\n\t\t\t\tif (f == 0) break;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t\treturn flow;\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    private int[][] weight;\n    private int X;\n    private int Y;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() throws Exception{\n        FastScanner scanner = new FastScanner(System.in);\n\n        X = scanner.nextInt();\n        Y = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        if(X == 0 || Y == 0 || E == 0){\n            System.out.println(\"0\");\n            return;\n        }\n\n        weight = new int[Math.max(X, Y)][Math.max(X, Y)];\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int w = 1;\n\n            weight[u][v] = w;\n            weight[v][u] = w;\n        }\n\n        System.out.println(KM());\n    }\n\n    private int KM(){\n        int[] lx = new int[X];\n        int[] ly = new int[Y];\n\n        initLx(lx);\n        int[] match = new int[Y];\n        Arrays.fill(match, -1);\n\n        for(int u = 0; u < X; ++u){\n            while(true){\n                boolean[] visitedX = new boolean[X];\n                boolean[] visitedY = new boolean[Y];\n                if(existPath(u, lx, ly, visitedX, visitedY, match)){\n                    break;\n                }\n\n                int d = Integer.MAX_VALUE;\n                for(int i = 0; i < X; ++i){\n                    if(!visitedX[i]){\n                        continue;\n                    }\n                    for(int j = 0; j < Y; ++j){\n                        if(visitedY[j]){\n                            continue;\n                        }\n\n                        d = Math.min(lx[i] + ly[j] - weight[i][j], d);\n                    }\n                }\n\n                if(d == Integer.MAX_VALUE){\n                    return -1;\n                }\n\n                for(int i = 0; i < X; ++i){\n                    if(visitedX[i]){\n                        lx[i] -= d;\n                    }\n                }\n\n                for(int j = 0; j < Y; ++j){\n                    if(visitedY[j]){\n                        ly[j] += d;\n                    }\n                }\n            }\n        }\n\n        int maxWeight = 0;\n        for(int j = 0; j < Y; ++j){\n            if(match[j] != -1){\n                maxWeight += weight[match[j]][j];\n            }\n        }\n\n        return maxWeight;\n    }\n\n    private boolean existPath(int u, int[] lx, int[] ly, boolean[] visitedX, boolean[] visitedY, int[] match){\n        visitedX[u] = true;\n        for(int v = 0; v < Y; ++v){\n            if(!visitedY[v] && lx[u] + ly[v] == weight[u][v]){\n                visitedY[v] = true;\n\n                if(match[v] < 0 || existPath(match[v], lx, ly, visitedX, visitedY, match)){\n                    match[v] = u;\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private void initLx(int[] lx){\n        for(int i = 0; i < X; ++i){\n            lx[i] = weight[i][0];\n\n            for(int j = 1; j < Y; ++j){\n                lx[i] = Math.max(lx[i], weight[i][j]);\n            }\n        }\n    }\n\n    static class FastScanner {\n        private InputStream in;\n        private final byte[] buffer = new byte[1024 * 8];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in){\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.HashSet;\nimport java.util.NoSuchElementException;\n \npublic class Main {\n\tprivate static FastScanner sc = new FastScanner();\n\tprivate static Node[] V;\n\tstatic int Xn;\n\tstatic int Yn;\n\tstatic int s;\n\tstatic int ed;\n\t\n\tpublic static void main(String[] args) {\n\t\tXn = sc.nextInt();\n\t\tYn = sc.nextInt();\n\t\ts = Xn + Yn;\n\t\ted = Xn + Yn + 1;\n\t\tint En = sc.nextInt();\n\t\t\n\t\tV = new Node[Xn + Yn + 2];\n\t\tfor(int i=0; i<V.length; i++) {\n\t\t\tV[i] = new Node();\n\t\t\tV[i].id = i;\n\t\t}\n\t\t\n\t\tfor(int i=0; i<En; i++) {\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt() + Xn;\n\t\t\tV[x].nbr.add(new Edge(y, 1));\n\t\t\tV[y].nbr.add(new Edge(x, 0));\n\t\t}\n\t\t\n\t\tfor(int i=0; i<Xn; i++) {\n\t\t\tV[s].nbr.add(new Edge(i, 1));\n\t\t\tV[i].nbr.add(new Edge(s, 0));\n\t\t}\n\t\t\n\t\tfor(int i=Xn; i<Xn+Yn; i++) {\n\t\t\tV[i].nbr.add(new Edge(ed, 1));\n\t\t\tV[ed].nbr.add(new Edge(i, 0));\n\t\t}\n\t\t\n\t\tint flow = 0;\n\t\twhile(true) {\n\t\t\tfor(int i=0; i<V.length; i++) {\n\t\t\t\tV[i].used = false;\n\t\t\t}\n\t\t\tint f = V[s].dfs(Integer.MAX_VALUE);\n\t\t\tif (f == 0) {\n\t\t\t\tSystem.out.println(flow);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tflow += f;\n\t\t}\n\t}\n\t\n\tstatic class Node {\n\t\tint id;\n\t\tboolean used;\n\t\tHashSet<Edge> nbr = new HashSet<>();\n\t\t\n\t\tint dfs (int f) {\n\t\t\tif(id == ed) {\n\t\t\t\treturn f;\n\t\t\t}\n\t\t\tused = true;\n\t\t\tfor(Edge e : nbr) {\n\t\t\t\tif(!V[e.t].used && e.c > 0) {\n\t\t\t\t\tint d = V[e.t].dfs(Math.min(f, e.c));\n\t\t\t\t\tif(d > 0) {\n\t\t\t\t\t\te.c -= d;\n\t\t\t\t\t\tfor(Edge e2 : V[e.t].nbr) {\n\t\t\t\t\t\t\tif(e2.t == id) {\n\t\t\t\t\t\t\t\te2.c += d;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tstatic class Edge {\n\t\tint t;\n\t\tint c;\n\t\tEdge(int t, int c) {\n\t\t\tthis.t = t;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\t\n\tstatic class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n        private boolean hasNextByte() {\n            if(ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch(IOException e) {\n                    e.printStackTrace();\n                }\n                if(buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n        private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n        private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n        public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while(isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n        public double nextDouble(){\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.math.BigInteger;\n\npublic class Main implements Runnable {\n\t\n\tstatic int mod = 1000000007;\n\t\n    public static void main(String[] args) {\n    \tnew Thread(null, new Main(), \"\", 1024 * 1024 * 1024).start();\n    }\n    \n    public void run() {\n        PrintWriter out = new PrintWriter(System.out);\n        FastScanner sc = new FastScanner();\n        \n        int x = sc.nextInt();\n        int y = sc.nextInt();\n        int e = sc.nextInt();\n        \n        BipartiteGraph g = new BipartiteGraph(x,y);\n        \n        for(int i=0;i<e;i++){\n        \tg.addEdge(sc.nextInt(), sc.nextInt()+x);\n        }\n        \n        out.println(g.bipartiteMaxMatching());\n        \n        out.flush();\n    }\n\n\t\n}\n\nclass BipartiteGraph {\n    //[0,L-1]\tl_0 - l_L-1\n    //[L,L+R-1]\tr_0 - r_R-1\n\n\tNodeList[] nlist; //隣接リスト\n\tint L;\t//左頂点の数\n\tint R;\t//右頂点の数\n\t\n\tpublic BipartiteGraph(int L, int R){\n\t\tthis.nlist = new NodeList[L+R];\n\t\tfor(int i=0;i<L+R;i++){\n\t\t\tnlist[i] = new NodeList();\n\t\t}\n\t\tthis.L = L;\n\t\tthis.R = R;\n\t}\n\t\n\t//辺の追加（同じ辺を複数回追加すると多重辺になる）\n\tvoid addEdge(int n, int m){\n\t\tnlist[n].add(m);\n\t\tnlist[m].add(n);\n\t}\n\t\n\t//頂点数を返す\n\tint vnum(){\n\t\treturn L+R;\n\t}\n\t\n\t//辺数を返す\n\tint edgeNum(){\n\t\tint sum = 0;\n\t\tfor(NodeList l:nlist){\n\t\t\tsum += l.size();\n\t\t}\n\t\treturn sum/2;\n\t}\n\t\n\t//隣接判定\n\tboolean isNext(int n, int m){\n\t\treturn nlist[n].contains(m);\n\t}\n\t\n\t//隣接する全ての頂点を返す\n\tNodeList nextList(int n){\n\t\treturn nlist[n];\n\t}\n\t\n\t//二部最大マッチング\n\tlong bipartiteMaxMatching(){\n        FlowGraph g = new FlowGraph(L+R+2);\n        //L+R = s\n        //L+R+1 = t\n        \n        for(int i=0;i<L;i++){\n        \tfor(int j:nextList(i)){\n        \t\tg.addEdge(i, j, 1);\n        \t}\n        }\n         \n        for(int i=0;i<L;i++){\n            g.addEdge(L+R, i, 1);\n        }\n         \n        for(int i=L;i<L+R;i++){\n            g.addEdge(i, L+R+1, 1);\n        }\n         \n        return g.Dinic(L+R, L+R+1);\n\t}\n\t\n\tclass EdgePair implements Comparable<EdgePair>{\n\t\tint a,b;\n\t\t\n\t\tpublic EdgePair(int a, int b){\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic boolean equals(Object o){\n\t\t\tif(o instanceof EdgePair){\n\t\t\t\tEdgePair p = (EdgePair) o;\n\t\t\t\treturn (a == p.a && b == p.b)||(a == p.b && b == p.a);\n\t\t\t}\n\t\t\treturn super.equals(o);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(EdgePair o){\n\t\t\tif(a!=o.a){\n\t\t\t\treturn Integer.compare(a,o.a);\n\t\t\t}\n\t\t\treturn Integer.compare(b, o.b);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int hashCode(){\n\t\t\treturn (a<<16)+b;\n\t\t}\n\t\t\n\t}\n\tclass NodeList extends ArrayList<Integer>{\n\t\tprivate static final long serialVersionUID = -4461479015945373120L;\n\t}\n}\n\nclass FlowGraph {\n\t\n\tint V;\n\tFEdgeList[] elist;\n\tint[] level; //dinic用\n\tint[] iter; //dinic用\n\t\n\tpublic FlowGraph(int n){\n\t\tthis.V = n;\n\t\telist = new FEdgeList[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\telist[i] = new FEdgeList();\n\t\t}\n\t}\n\t\n\tpublic void addEdge(int from, int to, int c){\n\t\tFEdge e = new FEdge(to,c);\n\t\tFEdge rev = new FEdge(from,0);\n\t\te.setRevEdge(rev);\n\t\trev.setRevEdge(e);\n\t\telist[from].add(e);\n\t\telist[to].add(rev);\t//逆辺\n\t}\n\t\n\t//残余グラフで流せる量\n\tint res(FEdge e){\n\t\treturn e.c - e.f;\n\t}\n\t\n\t//sからtまでの最大フローをFord-Fulkerson法で求める(O(E*maxflow))\n\tlong FordFulkerson(int s, int t){\n\t\tlong totalflow = 0;\n\t\t\n\t\twhile(true){\n\t\t\tArrayDeque<Integer> q = new ArrayDeque<>();\n\t\t\tint[] par = new int[V]; //親\n\t\t\tint[] eid = new int[V]; //親→自身への辺のid\n\t\t\tArrays.fill(par,-1);\n\t\t\tq.add(s);\n\t\t\tpar[s] = -2;\n\t\t\t\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint from = q.pollFirst();\n\t\t\t\tfor(int i=0;i<elist[from].size();i++){\n\t\t\t\t\tFEdge e = elist[from].get(i);\n\t\t\t\t\tif(res(e)<=0){\t//残余グラフになければ\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(par[e.to]!=-1){\t//既に訪れていれば\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpar[e.to] = from;\n\t\t\t\t\teid[e.to] = i;\n\t\t\t\t\tq.offerFirst(e.to);\t//offerLastならEdmonds-Karp\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(par[t]==-1){\t//残余グラフ上にtへのパスが存在しないなら終了\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//目一杯流す\n\t\t\tint pathmax = Integer.MAX_VALUE;\n\t\t\tfor(int i=t; par[i]!=-2; i=par[i]){\n\t\t\t\tpathmax = Math.min(pathmax,res(elist[par[i]].get(eid[i])));\n\t\t\t}\n\t\t\tfor(int i=t; par[i]!=-2; i=par[i]){\n\t\t\t\telist[par[i]].get(eid[i]).f += pathmax;\n\t\t\t\telist[par[i]].get(eid[i]).rev.f -= pathmax; //逆辺用\n\t\t\t}\n\t\t\t\n\t\t\ttotalflow += pathmax;\n\t\t}\n\t\t\n\t\treturn totalflow;\n\t}\n\t\n\t//sからtまでの最大フローをEdmonds-Karp法で求める(O( V * E^2 ))\n\tlong EdmondsKarp(int s, int t){\n\t\tlong totalflow = 0;\n\t\t\n\t\twhile(true){\n\t\t\tArrayDeque<Integer> q = new ArrayDeque<>();\n\t\t\tint[] par = new int[V]; //親\n\t\t\tint[] eid = new int[V]; //親→自身への辺のid\n\t\t\tArrays.fill(par,-1);\n\t\t\tq.add(s);\n\t\t\tpar[s] = -2;\n\t\t\t\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint from = q.pollFirst();\n\t\t\t\tfor(int i=0;i<elist[from].size();i++){\n\t\t\t\t\tFEdge e = elist[from].get(i);\n\t\t\t\t\tif(res(e)<=0){\t//残余グラフになければ\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(par[e.to]!=-1){\t//既に訪れていれば\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpar[e.to] = from;\n\t\t\t\t\teid[e.to] = i;\n\t\t\t\t\tq.offerLast(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(par[t]==-1){\t//残余グラフ上にtへのパスが存在しないなら終了\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//目一杯流す\n\t\t\tint pathmax = Integer.MAX_VALUE;\n\t\t\tfor(int i=t; par[i]!=-2; i=par[i]){\n\t\t\t\tpathmax = Math.min(pathmax,res(elist[par[i]].get(eid[i])));\n\t\t\t}\n\t\t\tfor(int i=t; par[i]!=-2; i=par[i]){\n\t\t\t\telist[par[i]].get(eid[i]).f += pathmax;\n\t\t\t\telist[par[i]].get(eid[i]).rev.f -= pathmax; //逆辺用\n\t\t\t}\n\t\t\t\n\t\t\ttotalflow += pathmax;\n\t\t}\n\t\t\n\t\treturn totalflow;\n\t}\n\t\n\t//sからtまでの最大フローをDinic法で求める(O(V^2 * E))\n\tpublic long Dinic(int s, int t){\n\t\tlevel = new int[V];\n\t\titer = new int[V];\n\t\tlong totalflow = 0;\n\t\t\n\t\twhile(true){\n\t\t\tlevel = bfs(s);\n\t\t\tif(level[t] == -1){\n\t\t\t\treturn totalflow;\n\t\t\t}\n\t\t\t\n\t\t\titer = new int[V];\n\t\t\t\n\t\t\tlong f = Integer.MAX_VALUE;\n\t\t\t\n\t\t\tf = dfs(s,t,f);\n\t\t\t\n\t\t\twhile(f>0){\n\t\t\t\ttotalflow += f;\n\t\t\t\tf = dfs(s,t,f);\n\t\t\t}\n\t\t}\n\t}\n\t//sから各ノードへの最短距離（全辺の長さ1）をbfsで求める。\n\tint[] bfs(int s){\n\t\tint[] level = new int[V];\n\t\tArrays.fill(level,-1);\n\t\t\n\t\tArrayDeque<Integer> q = new ArrayDeque<>();\n\t\tq.offerLast(s);\n\t\tlevel[s] = 0;\n\t\t\n\t\twhile(!q.isEmpty()){\n\t\t\tint from = q.pollFirst();\n\t\t\t\n\t\t\tfor(FEdge e:elist[from]){\n\t\t\t\tif(res(e)<=0){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(level[e.to]!=-1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlevel[e.to] = level[from] + 1;\n\t\t\t\tq.offerLast(e.to);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn level;\n\t}\n\t//vからtまでのパスをdfsで探す\n\tlong dfs(int v, int t, long f){\n\t\tif(v==t){\n\t\t\treturn f;\n\t\t}\n\t\tfor(int i=iter[v];i<elist[v].size();i++){\n\t\t\titer[v] = i;\n\t\t\tFEdge e = elist[v].get(i);\n\t\t\tif(res(e) > 0 && level[v] < level[e.to]){\n\t\t\t\tlong nf = Math.min(f,res(e));\n\t\t\t\tlong d = dfs(e.to,t,nf);\n\t\t\t\tif(d>0){\n\t\t\t\t\te.f += d;\n\t\t\t\t\te.rev.f -= d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\t\n\tpublic class FEdgeList extends ArrayList<FEdge>{\n\t\tprivate static final long serialVersionUID = -3222721656143220018L;\n\t}\n\tpublic class FEdge{\n\t\tpublic int to;\n\t\tpublic int c;\n\t\tpublic int f;\n\t\tpublic FEdge rev;\n\t\t\n\t\tpublic FEdge(int to, int w){\n\t\t\tthis.to = to;\n\t\t\tthis.c = w;\n\t\t\tthis.f = 0;\n\t\t}\n\t\t\n\t\tpublic void setRevEdge(FEdge e){\n\t\t\tthis.rev = e;\n\t\t}\n\t\t\n\t}\n}\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic int[] nextintArray(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic long[] nextlongArray(int n){\n\t\tlong[] a = new long[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic Integer[] nextIntegerArray(int n){\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic int[][] nextintMatrix(int h, int w){\n\t\tint[][] mat = new int[h][w];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tmat[i][j] = nextInt();\n\t\t\t}\n\t\t}\n\t\treturn mat;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static class Dinic {\n\n        final ResidualNetwork residualG;\n        final int srcVert;\n        final int termVert;\n        int[] level;\n        int[] iter;\n\n        public Dinic(WeightedDigraph graph, int srcVert, int termVert) {\n            this.residualG = new ResidualNetwork(graph);\n            this.srcVert = srcVert;\n            this.termVert = termVert;\n        }\n\n        public int computeMaxFlow() {\n            level = new int[residualG.numVertex];\n            iter = new int[residualG.numVertex];\n            int maxFlow = 0;\n            for (;;) {\n                bfs();\n                if (level[termVert] < 0) {\n                    return maxFlow;\n                }\n                Arrays.fill(iter, 0);\n                int flow = 0;\n                while ((flow = dfs(srcVert, termVert, Integer.MAX_VALUE)) > 0) {\n                    maxFlow += flow;\n                }\n            }\n        }\n\n        private void bfs() {\n            Arrays.fill(level, -1);\n            Queue<Integer> queue = new LinkedList<Integer>();\n            level[srcVert] = 0;\n            queue.add(srcVert);\n            while (!queue.isEmpty()) {\n                int v = queue.remove();\n                for (WeightedDigraph.Edge edge : residualG.srcEdges[v]) {\n                    if (edge.weight > 0 && level[edge.targetVertex] < 0) {\n                        level[edge.targetVertex] = level[v] + 1;\n                        queue.add(edge.targetVertex);\n                    }\n                }\n            }\n        }\n\n        private int dfs(int v, int t, int flow) {\n            if (v == t) {\n                return flow;\n            }\n            for (WeightedDigraph.Edge edge : residualG.srcEdges[v]) {\n                if (edge.weight > 0 && level[v] < level[edge.targetVertex]) {\n                    int minFlow = dfs(edge.targetVertex, t, Math.min(flow, edge.weight));\n                    if (minFlow > 0) {\n                        edge.weight -= minFlow;\n                        residualG.edgeMap.get(edge).weight += minFlow;\n                        return minFlow;\n                    }\n                }\n            }\n            return 0;\n        }\n    }\n\n    public static class ResidualNetwork extends WeightedDigraph {\n\n        HashMap<Edge, Edge> edgeMap;\n\n        public ResidualNetwork(WeightedDigraph graph) {\n            super(graph.numVertex);\n            edgeMap = new HashMap<Edge, Edge>();\n            for (int i = 0; i < graph.numVertex; i++) {\n                for (WeightedDigraph.Edge edge : graph.srcEdges[i]) {\n                    this.addEdge(edge.srcVertex, edge.targetVertex, edge.weight);\n                }\n            }\n        }\n\n        @Override\n        public void addEdge(int srcVertex, int targetVertex, int weight) {\n            Edge e = new WeightedDigraph.Edge(srcVertex, targetVertex, weight);\n            srcEdges[srcVertex].add(e);\n            Edge backE = new WeightedDigraph.Edge(targetVertex, srcVertex, 0);\n            srcEdges[targetVertex].add(backE);\n            edgeMap.put(e, backE);\n            edgeMap.put(backE, e);\n        }\n    }\n\n    public static class WeightedDigraph {\n\n        int numVertex;\n        List<Edge>[] srcEdges;\n\n        @SuppressWarnings(\"unchecked\")\n        public WeightedDigraph(int numV) {\n            this.numVertex = numV;\n            srcEdges = new List[numV];\n\n            for (int i = 0; i < numV; i++) {\n                srcEdges[i] = new ArrayList<Edge>();\n            }\n        }\n\n        public void addEdge(int srcVertex, int targetVertex, int weight) {\n            Edge e = new WeightedDigraph.Edge(srcVertex, targetVertex, weight);\n            srcEdges[srcVertex].add(e);\n        }\n\n        public static class Edge {\n\n            int srcVertex;\n            int targetVertex;\n            int weight;\n\n            public Edge(int srcVertex, int targetVertex, int weight) {\n                this.srcVertex = srcVertex;\n                this.targetVertex = targetVertex;\n                this.weight = weight;\n            }\n\n            @Override\n            public int hashCode() {\n                int hash = 3;\n                hash = 59 * hash + this.srcVertex;\n                hash = 59 * hash + this.targetVertex;\n                return hash;\n            }\n\n            @Override\n            public boolean equals(Object obj) {\n                if (this == obj) {\n                    return true;\n                }\n                if (obj == null) {\n                    return false;\n                }\n                if (getClass() != obj.getClass()) {\n                    return false;\n                }\n                final Edge other = (Edge) obj;\n                if (this.srcVertex != other.srcVertex) {\n                    return false;\n                }\n                if (this.targetVertex != other.targetVertex) {\n                    return false;\n                }\n                return true;\n            }\n\n        }\n\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int numVertex1 = scanner.nextInt();\n        int numVertex2 = scanner.nextInt();\n        int numEdge = scanner.nextInt();\n        WeightedDigraph graph = new WeightedDigraph(numVertex1 + numVertex2 + 2);\n        int srcVert = numVertex1 + numVertex2;\n        int termVert = srcVert + 1;\n        while (numEdge-- > 0) {\n            int v1 = scanner.nextInt();\n            int v2 = scanner.nextInt() + numVertex1;\n            graph.addEdge(v1, v2, 1);\n        }\n        for (int vert = 0; vert < numVertex1; vert++) {\n            graph.addEdge(srcVert, vert, 1);\n        }\n        for (int vert = numVertex1; vert < numVertex1 + numVertex2; vert++) {\n            graph.addEdge(vert, termVert, 1);\n        }\n        Dinic maxFlow = new Dinic(graph, srcVert, termVert);\n        System.out.println(maxFlow.computeMaxFlow());\n    }\n\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.stream.Stream;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic int modP = 1000000007;\n\n\tstatic class TaskX {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint X = in.nextInt(), Y = in.nextInt(), E = in.nextInt();\n\t\t\tint s = X + Y;\n\t\t\tint t = s + 1;\n\n\t\t\tFlow f = new Flow(X + Y + 2);\n\t\t\tfor (int i = 0; i < E; i++) {\n\t\t\t\tint u = in.nextInt();\n\t\t\t\tint v = in.nextInt();\n\t\t\t\tf.addEdge(u, v, 1);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < X; i++) {\n\t\t\t\tf.addEdge(s, i, 1);\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < Y; i++) {\n\t\t\t\tf.addEdge(i, t, 1);\n\t\t\t}\n\n\t\t\tint ans = f.maxFlow(s, t);\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tstatic class Flow {\n\n\t\tstatic int INF = 1 << 30;\n\n\t\tboolean[] used;\n\t\tList<Edge>[] G;\n\t\tint V;\n\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic Flow(int V) {\n\t\t\tG = Stream.generate(ArrayList::new).limit(V).toArray(List[]::new);\n\t\t\tused = new boolean[V];\n\t\t\tthis.V = V;\n\t\t}\n\n\t\tstatic class Edge {\n\t\t\tint to, cap, rev;\n\t\t\tpublic Edge(int to, int cap, int rev) {\n\t\t\t\tthis.to = to;\n\t\t\t\tthis.cap = cap;\n\t\t\t\tthis.rev = rev;\n\t\t\t}\n\t\t}\n\n\t\tvoid addEdge(int u, int v, int c) {\n\t\t\tG[u].add(new Edge(v, c, G[v].size()));\n\t\t\tG[v].add(new Edge(u, 0, G[u].size() - 1));\n\t\t}\n\n\t\tint dfs(int u, int v, int f) {\n\t\t\tif (u == v) return f;\n\t\t\tused[u] = true;\n\t\t\tfor (Edge e : G[u]) {\n\t\t\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\t\t\tint d = dfs(e.to, v, Math.min(f, e.cap));\n\t\t\t\t\tif (d > 0) {\n\t\t\t\t\t\te.cap -= d;\n\t\t\t\t\t\tG[e.to].get(e.rev).cap += d;\n\t\t\t\t\t\treturn d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tint maxFlow(int s, int t) {\n\t\t\tint flow = 0;\n\t\t\twhile (true) {\n\t\t\t\tused = new boolean[V];\n\t\t\t\tint f = dfs(0, V - 1, INF);\n\t\t\t\tif (f == 0) break;\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t\treturn flow;\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    private boolean[][] graph;\n    private int X;\n    private int Y;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() throws Exception{\n        FastScanner scanner = new FastScanner(System.in);\n\n        X = scanner.nextInt();\n        Y = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        if(X == 0 || Y == 0 || E == 0){\n            System.out.println(\"0\");\n            return;\n        }\n\n        graph = new boolean[X][Y];\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n\n            graph[u][v] = true;\n        }\n\n        System.out.println(maxBPM());\n    }\n\n    private int maxBPM(){\n        int[] match = new int[Y];\n        Arrays.fill(match, -1);\n        boolean[] visited = new boolean[Y];\n\n        int result = 0;\n        for(int u = 0; u < X; ++u){\n            if(existPath(u, visited, match)){\n                ++result;\n            }\n        }\n\n        return result;\n    }\n\n    private boolean existPath(int u, boolean[] visited, int[] match){\n        for(int v = 0; v < Y; ++v){\n            if(graph[u][v] && !visited[v]){\n                visited[v] = true;\n\n                if(match[v] < 0 || existPath(match[v], visited, match)){\n                    match[v] = u;\n                    return true;\n                }\n\n                visited[v] = false;\n            }\n        }\n\n        return false;\n    }\n\n    static class FastScanner {\n        private InputStream in;\n        private final byte[] buffer = new byte[1024 * 8];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in){\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\nclass Solver{\n\tScanner sc =new Scanner(System.in);\n\n\tint x;\n\tint y;\n\tint e;\t\n\t\n\tvoid run(){\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\te = sc.nextInt();\n\t\t\n\t\tint n = e+x+y;\n\t\tE[] edges = new E[n*2];\n\t\t\n\t\tfor(int i =0 ; i < x ; i++){\n\t\t\tedges[i] = new E();\n\t\t\tedges[i].from = x+y;\n\t\t\tedges[i].to = i;\n\t\t\tedges[i].cap = 1;\n\t\t\t\n\t\t\tedges[n+i] = new E();\n\t\t\tedges[n+i].from = i;\n\t\t\tedges[n+i].to = x+y;\n\t\t\tedges[n+i].cap = 0;\n\t\t\t\n\t\t\tedges[i].rev = edges[n+i];\n\t\t\tedges[n+i].rev = edges[i];\n\t\t}\n\t\t\n\t\tfor(int j = 0 ; j < y; j++){\n\t\t\tedges[x+j] = new E();\n\t\t\tedges[x+j].from = x+j;\n\t\t\tedges[x+j].to = x+y+1;\n\t\t\tedges[x+j].cap = 1;\n\t\t\t\n\t\t\tedges[n+x+j] = new E();\n\t\t\tedges[n+x+j].from  =x+y+1;\n\t\t\tedges[n+x+j].to = x+j;\n\t\t\tedges[n+x+j].cap = 0;\n\t\t\t\n\t\t\tedges[x+j].rev = edges[n+x+j];\n\t\t\tedges[n+x+j].rev = edges[x+j];\n\t\t}\n\t\t\n\t\tfor(int k = 0 ; k < e; k++){\n\t\t\tint from = sc.nextInt();\n\t\t\tint to = sc.nextInt()+x;\n\t\t\t\n\t\t\tedges[x+y+k] = new E();\n\t\t\tedges[x+y+k].from = from;\n\t\t\tedges[x+y+k].to = to;\n\t\t\tedges[x+y+k].cap = 1;\n\t\t\t\n\t\t\tedges[n+x+y+k] = new E();\n\t\t\tedges[n+x+y+k].from = to;\n\t\t\tedges[n+x+y+k].to = from;\n\t\t\tedges[n+x+y+k].cap = 0;\n\t\t\t\n\t\t\tedges[x+y+k].rev = edges[n+x+y+k];\n\t\t\tedges[n+x+y+k].rev = edges[x+y+k];\n\t\t}\n\t\t\n\t\tdepth = new int[x+y+2];\n\t\tMap<Integer,List<E>> map = new HashMap<Integer,List<E>>();\n\t\tfor(E e: edges){\n\t\t\tmap.computeIfAbsent(e.from,__ -> new ArrayList<E>()).add(e);\n\t\t}\n\t\tfor(int i =0 ;i < x+y+2;i++){\n//\t\t\tSystem.out.println(i);\n\t\t\tfor(E e :map.getOrDefault(i, Collections.emptyList())){\n//\t\t\t\tSystem.out.println(e.from +\" \"+e.to+\" \"+e.cap); \n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tint sum = 0;\n\t\tfor(;;){\n\t\t\tArrays.fill(depth,-1);\n\n\t\t\tbfs(x+y+1,x+y,map);\n//\t\t\tSystem.out.println(Arrays.toString(depth));\n\t\t\tif(depth[x+y] == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tsum += max_flow(x+y,x+y+1,map);\n\t\t\t\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t}\n\t\t\n\tint depth[];\n\t\n\tvoid bfs(int from, int to, Map<Integer,List<E>> map){\n\t\t\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\tLinkedList<Integer> depthes = new LinkedList<Integer>();\n\t\tqueue.add(from);\n\t\tdepthes.add(0);\n\t\t\n\t\tfor(;!queue.isEmpty();){\n\t\t\t\n\t\t\tint pos = queue.removeFirst();\n\t\t\tint d = depthes.removeFirst();\n\t\t\t\n\t\t\tif(depth[pos] != -1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdepth[pos] = d;\n\t\t\t\n\t\t\tif(pos == to){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(E e : map.getOrDefault(pos,Collections.emptyList())){\n\t\t\t\t\n\t\t\t\tif( e.rev.cap > 0 ){\n\t\t\t\t\tqueue.addLast(  e.to );\n\t\t\t\t\tdepthes.addLast( d + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint max_flow(int from,int to,Map<Integer,List<E>> map){\n\t\t\n\t\tLinkedList<Integer> index = new LinkedList<Integer>();\n\t\tLinkedList<Integer> pos = new LinkedList<Integer>();\n\t\tLinkedList<E> path = new LinkedList<E>();\n\t\t\n\t\tpos.addLast(from);\n\t\tindex.addLast(-1);\n\t\tint sum = 0;\n\t\t\n\t\tfor(;;){\t\n\t\t\t\n\t\t\tint current = pos.removeLast();\n\t\t\tint start = index.removeLast();\n\t\t\t\n\t\t\tif(current == to){\n\t\t\t\tint flow = 2;\n\t\t\t\tfor(E e : path){\n\t\t\t\t\tflow = Math.min(flow,e.cap);\n\t\t\t\t}\n\t\t\t\tint cnt = path.size();\n\t\t\t\tint x = 0;\n\t\t\t\tfor(E e: path){\n\t\t\t\t\te.cap -= flow;\n\t\t\t\t\te.rev.cap += flow;\n\t\t\t\t\tif(e.cap == 0){\n\t\t\t\t\t\tx = cnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i< x; i++){\n\t\t\t\t\tpath.removeLast();\n\t\t\t\t\tpos.removeLast();\n\t\t\t\t\tindex.removeLast();\n\t\t\t\t}\n\t\t\t\tsum += flow;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tList<E> l = map.get(current);\n\n\t\t\tboolean found = false;\n\t\t\tfor(int i = start+1; i < l.size(); i++){\n\t\t\t\tE e = l.get(i);\n\t\t\t\t\n\t\t\t\tif(e.cap > 0 && depth[e.from] > depth[e.to]){\n\t\t\t\t\tpos.addLast(current);\n\t\t\t\t\tindex.addLast(i);\n\t\t\t\t\t\n\t\t\t\t\tpath.addLast(e);\n\t\t\t\t\t\n\t\t\t\t\tpos.addLast(e.to);\n\t\t\t\t\tindex.addLast(-1);\n\t\t\t\t\t\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(found){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(path.isEmpty()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpath.removeLast();\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\t\n}\nclass E{\n\tint from;\n\tint to;\n\tint cap;\n\tE rev;\n}\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tSolver s  = new Solver();\n\t\ts.run();\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable{\n    private int[][] graph;\n    private int X;\n    private int Y;\n    public static void main(String[] args) throws Exception {\n        new Thread(null, new Main(), \"bridge\", 16 * 1024 * 1024).start();\n    }\n\n    @Override\n    public void run() {\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void solve() throws Exception{\n        FastScanner scanner = new FastScanner(System.in);\n\n        X = scanner.nextInt();\n        Y = scanner.nextInt();\n        int E = scanner.nextInt();\n\n        if(X == 0 || Y == 0 || E == 0){\n            System.out.println(\"0\");\n            return;\n        }\n\n        graph = new int[X][Y];\n\n        for(int i = 0; i < E; ++i){\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int w = 1;\n\n            graph[u][v] = w;\n        }\n\n        System.out.println(KM());\n    }\n\n    private int KM(){\n        int[] lx = new int[X];\n        int[] ly = new int[Y];\n\n        initLx(lx);\n        int[] match = new int[Y];\n        Arrays.fill(match, -1);\n\n        for(int u = 0; u < X; ++u){\n            while(true){\n                boolean[] visitedX = new boolean[X];\n                boolean[] visitedY = new boolean[Y];\n                if(existPath(u, lx, ly, visitedX, visitedY, match)){\n                    break;\n                }\n\n                int d = Integer.MAX_VALUE;\n                for(int i = 0; i < X; ++i){\n                    if(!visitedX[i]){\n                        continue;\n                    }\n                    for(int j = 0; j < Y; ++j){\n                        if(visitedY[j]){\n                            continue;\n                        }\n\n                        d = Math.min(lx[i] + ly[j] - graph[i][j], d);\n                    }\n                }\n\n                if(d == Integer.MAX_VALUE){\n                    return -1;\n                }\n\n                for(int i = 0; i < X; ++i){\n                    if(visitedX[i]){\n                        lx[i] -= d;\n                    }\n                }\n\n                for(int j = 0; j < Y; ++j){\n                    if(visitedY[j]){\n                        ly[j] += d;\n                    }\n                }\n            }\n        }\n\n        int maxWeight = 0;\n        for(int j = 0; j < Y; ++j){\n            if(match[j] != -1){\n                maxWeight += graph[match[j]][j];\n            }\n        }\n\n        return maxWeight;\n    }\n\n    private boolean existPath(int u, int[] lx, int[] ly, boolean[] visitedX, boolean[] visitedY, int[] match){\n        visitedX[u] = true;\n        for(int v = 0; v < Y; ++v){\n            if(!visitedY[v] && lx[u] + ly[v] == graph[u][v]){\n                visitedY[v] = true;\n\n                if(match[v] < 0 || existPath(match[v], lx, ly, visitedX, visitedY, match)){\n                    match[v] = u;\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private void initLx(int[] lx){\n        for(int i = 0; i < X; ++i){\n            lx[i] = graph[i][0];\n\n            for(int j = 1; j < Y; ++j){\n                lx[i] = Math.max(lx[i], graph[i][j]);\n            }\n        }\n    }\n\n    static class FastScanner {\n        private InputStream in;\n        private final byte[] buffer = new byte[1024 * 8];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner(InputStream in){\n            this.in = in;\n        }\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        private void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        public boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\nimport java.util.stream.Stream;\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\tstatic final long INF = Long.MAX_VALUE / 2;\n\tint len;\n\tint[][] up;\n\tint[] tin;\n\tint[] tout;\n\tint time;\n\tprivate static void solve() {\n\t\t//PrintWriter pr = new PrintWriter(System.out);\n\t\tint X = ni();\n\t\tint Y = ni();\n\t\tint E = ni();\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tList<Integer>[] g = Stream.generate(ArrayList::new).limit(X).toArray(List[]::new);\n\t\tfor(int i=0;i<E;i++){\n\t\t\tg[ni()].add(ni());\n\t\t}\n\t\tSystem.out.println(maxMatching(g, Y));\n\t\t\n\t}\n\tpublic static int maxMatching(List<Integer>[] graph, int n2) {\n\t\tint n1 = graph.length;\n\t\tint[] matching = new int[n2];\n\t\tArrays.fill(matching, -1);\n\t\tint matches = 0;\n\t\tfor (int u = 0; u < n1; u++) {\n\t\t\tif (findPath(graph, u, matching, new boolean[n1]))\n\t\t\t\t++matches;\n\t\t}\n\t\treturn matches;\n\t}\n\n\tstatic boolean findPath(List<Integer>[] graph, int u1, int[] matching, boolean[] vis) {\n\t\tvis[u1] = true;\n\t\tfor (int v : graph[u1]) {\n\t\t\tint u2 = matching[v];\n\t\t\tif (u2 == -1 || !vis[u2] && findPath(graph, u2, matching, vis)) {\n\t\t\t\tmatching[v] = u1;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\t//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int X, Y, E;\n\tstatic int[] x, y;\n\tstatic ArrayList<Integer>[] g;\n\tstatic boolean[] vis;\n\tstatic int[] matchTo;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tX = sc.nextInt();\n\t\tY = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tx = new int[E];\n\t\ty = new int[E];\n\t\tg = new ArrayList[X + Y];\n\t\tfor (int i = 0; i < X + Y; ++i) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt() + X;\n\t\t\tg[x[i]].add(y[i]);\n\t\t\tg[y[i]].add(x[i]);\n\t\t}\n\t\tvis = new boolean[X + Y];\n\t\tmatchTo = new int[X + Y];\n\t\tint match = 0;\n\t\tfor (int i = 0; i < X; ++i) {\n\t\t\tArrays.fill(vis, false);\n\t\t\tif (dfs(i))\n\t\t\t\t++match;\n\t\t}\n\t\tSystem.out.println(match);\n\t}\n\n\tstatic boolean dfs(int v) {\n\t\tif (v < 0)\n\t\t\treturn true;\n\t\tfor (int u : g[v]) {\n\t\t\tif (vis[u])\n\t\t\t\tcontinue;\n\t\t\tvis[u] = true;\n\t\t\tif (dfs(u)) {\n\t\t\t\tmatchTo[u] = v;\n\t\t\t\tmatchTo[v] = u;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\nclass Solver{\n\tScanner sc =new Scanner(System.in);\n\n\tint x;\n\tint y;\n\tint e;\t\n\t\n\tvoid run(){\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\te = sc.nextInt();\n\t\t\n\t\tint n = e+x+y;\n\t\tE[] edges = new E[n*2];\n\t\t\n\t\tfor(int i =0 ; i < x ; i++){\n\t\t\tedges[i] = new E();\n\t\t\tedges[i].from = x+y;\n\t\t\tedges[i].to = i;\n\t\t\tedges[i].cap = 1;\n\t\t\t\n\t\t\tedges[n+i] = new E();\n\t\t\tedges[n+i].from = i;\n\t\t\tedges[n+i].to = x+y;\n\t\t\tedges[n+i].cap = 0;\n\t\t\t\n\t\t\tedges[i].rev = edges[n+i];\n\t\t\tedges[n+i].rev = edges[i];\n\t\t}\n\t\t\n\t\tfor(int j = 0 ; j < y; j++){\n\t\t\tedges[x+j] = new E();\n\t\t\tedges[x+j].from = x+j;\n\t\t\tedges[x+j].to = x+y+1;\n\t\t\tedges[x+j].cap = 1;\n\t\t\t\n\t\t\tedges[n+x+j] = new E();\n\t\t\tedges[n+x+j].from  =x+y+1;\n\t\t\tedges[n+x+j].to = x+j;\n\t\t\tedges[n+x+j].cap = 0;\n\t\t\t\n\t\t\tedges[x+j].rev = edges[n+x+j];\n\t\t\tedges[n+x+j].rev = edges[x+j];\n\t\t}\n\t\t\n\t\tfor(int k = 0 ; k < e; k++){\n\t\t\tint from = sc.nextInt();\n\t\t\tint to = sc.nextInt()+x;\n\t\t\t\n\t\t\tedges[x+y+k] = new E();\n\t\t\tedges[x+y+k].from = from;\n\t\t\tedges[x+y+k].to = to;\n\t\t\tedges[x+y+k].cap = 1;\n\t\t\t\n\t\t\tedges[n+x+y+k] = new E();\n\t\t\tedges[n+x+y+k].from = to;\n\t\t\tedges[n+x+y+k].to = from;\n\t\t\tedges[n+x+y+k].cap = 0;\n\t\t\t\n\t\t\tedges[x+y+k].rev = edges[n+x+y+k];\n\t\t\tedges[n+x+y+k].rev = edges[x+y+k];\n\t\t}\n\t\t\n\t\tdepth = new int[x+y+2];\n\t\tMap<Integer,List<E>> map = new HashMap<Integer,List<E>>();\n\t\tfor(E e: edges){\n\t\t\tmap.computeIfAbsent(e.from,__ -> new ArrayList<E>()).add(e);\n\t\t}\n\t\tfor(int i =0 ;i < x+y+2;i++){\n//\t\t\tSystem.out.println(i);\n\t\t\tfor(E e :map.getOrDefault(i, Collections.emptyList())){\n//\t\t\t\tSystem.out.println(e.from +\" \"+e.to+\" \"+e.cap); \n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tint sum = 0;\n\t\tfor(;;){\n\t\t\tArrays.fill(depth,-1);\n\n\t\t\tbfs(x+y+1,x+y,map);\n//\t\t\tSystem.out.println(Arrays.toString(depth));\n\t\t\tif(depth[x+y] == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tsum += max_flow(x+y,x+y+1,map);\n\t\t\t\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t}\n\t\t\n\tint depth[];\n\t\n\tvoid bfs(int from, int to, Map<Integer,List<E>> map){\n\t\t\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\tLinkedList<Integer> depthes = new LinkedList<Integer>();\n\t\tqueue.add(from);\n\t\tdepthes.add(0);\n\t\t\n\t\tfor(;!queue.isEmpty();){\n\t\t\t\n\t\t\tint pos = queue.removeFirst();\n\t\t\tint d = depthes.removeFirst();\n\t\t\t\n\t\t\tif(depth[pos] != -1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdepth[pos] = d;\n\t\t\t\n\t\t\tif(pos == to){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(E e : map.getOrDefault(pos,Collections.emptyList())){\n\t\t\t\t\n\t\t\t\tif( e.rev.cap > 0 ){\n\t\t\t\t\tqueue.addLast(  e.to );\n\t\t\t\t\tdepthes.addLast( d + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint max_flow(int from,int to,Map<Integer,List<E>> map){\n\t\t\n\t\tLinkedList<Integer> index = new LinkedList<Integer>();\n\t\tLinkedList<Integer> pos = new LinkedList<Integer>();\n\t\tLinkedList<E> path = new LinkedList<E>();\n\t\t\n\t\tpos.addLast(from);\n\t\tindex.addLast(-1);\n\t\tint sum = 0;\n\t\t\n\t\tfor(;;){\t\n\t\t\t\n\t\t\tint current = pos.removeLast();\n\t\t\tint start = index.removeLast();\n\t\t\t\n\t\t\tif(current == to){\n\t\t\t\tint flow = 2;\n\t\t\t\tfor(E e : path){\n\t\t\t\t\tflow = Math.min(flow,e.cap);\n\t\t\t\t}\n\t\t\t\tint cnt = path.size();\n\t\t\t\tint x = 0;\n\t\t\t\tfor(E e: path){\n\t\t\t\t\te.cap -= flow;\n\t\t\t\t\te.rev.cap += flow;\n\t\t\t\t\tif(e.cap == 0){\n\t\t\t\t\t\tx = cnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i< x; i++){\n\t\t\t\t\tpath.removeLast();\n\t\t\t\t\tpos.removeLast();\n\t\t\t\t\tindex.removeLast();\n\t\t\t\t}\n\t\t\t\tsum += flow;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tList<E> l = map.get(current);\n\n\t\t\tboolean found = false;\n\t\t\tfor(int i = start+1; i < l.size(); i++){\n\t\t\t\tE e = l.get(i);\n\t\t\t\t\n\t\t\t\tif(e.cap > 0 && depth[e.from] > depth[e.to]){\n\t\t\t\t\tpos.addLast(current);\n\t\t\t\t\tindex.addLast(i);\n\t\t\t\t\t\n\t\t\t\t\tpath.addLast(e);\n\t\t\t\t\t\n\t\t\t\t\tpos.addLast(e.to);\n\t\t\t\t\tindex.addLast(-1);\n\t\t\t\t\t\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(found){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(path.isEmpty()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpath.removeLast();\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\t\n}\nclass E{\n\tint from;\n\tint to;\n\tint cap;\n\tE rev;\n}\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tSolver s  = new Solver();\n\t\ts.run();\n\t}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\nclass Solver{\n\tScanner sc =new Scanner(System.in);\n\n\tint x;\n\tint y;\n\tint e;\t\n\t\n\tvoid run(){\n\t\tx = sc.nextInt();\n\t\ty = sc.nextInt();\n\t\te = sc.nextInt();\n\t\t\n\t\tint n = e+x+y;\n\t\tE[] edges = new E[n*2];\n\t\t\n\t\tfor(int i =0 ; i < x ; i++){\n\t\t\tedges[i] = new E();\n\t\t\tedges[i].from = x+y;\n\t\t\tedges[i].to = i;\n\t\t\tedges[i].cap = 1;\n\t\t\t\n\t\t\tedges[n+i] = new E();\n\t\t\tedges[n+i].from = i;\n\t\t\tedges[n+i].to = x+y;\n\t\t\tedges[n+i].cap = 0;\n\t\t\t\n\t\t\tedges[i].rev = edges[n+i];\n\t\t\tedges[n+i].rev = edges[i];\n\t\t}\n\t\t\n\t\tfor(int j = 0 ; j < y; j++){\n\t\t\tedges[x+j] = new E();\n\t\t\tedges[x+j].from = x+j;\n\t\t\tedges[x+j].to = x+y+1;\n\t\t\tedges[x+j].cap = 1;\n\t\t\t\n\t\t\tedges[n+x+j] = new E();\n\t\t\tedges[n+x+j].from  =x+y+1;\n\t\t\tedges[n+x+j].to = x+j;\n\t\t\tedges[n+x+j].cap = 0;\n\t\t\t\n\t\t\tedges[x+j].rev = edges[n+x+j];\n\t\t\tedges[n+x+j].rev = edges[x+j];\n\t\t}\n\t\t\n\t\tfor(int k = 0 ; k < e; k++){\n\t\t\tint from = sc.nextInt();\n\t\t\tint to = sc.nextInt()+x;\n\t\t\t\n\t\t\tedges[x+y+k] = new E();\n\t\t\tedges[x+y+k].from = from;\n\t\t\tedges[x+y+k].to = to;\n\t\t\tedges[x+y+k].cap = 1;\n\t\t\t\n\t\t\tedges[n+x+y+k] = new E();\n\t\t\tedges[n+x+y+k].from = to;\n\t\t\tedges[n+x+y+k].to = from;\n\t\t\tedges[n+x+y+k].cap = 0;\n\t\t\t\n\t\t\tedges[x+y+k].rev = edges[n+x+y+k];\n\t\t\tedges[n+x+y+k].rev = edges[x+y+k];\n\t\t}\n\t\t\n\t\tdepth = new int[x+y+2];\n\t\tMap<Integer,List<E>> map = new HashMap<Integer,List<E>>();\n\t\tfor(E e: edges){\n\t\t\tmap.computeIfAbsent(e.from,__ -> new ArrayList<E>()).add(e);\n\t\t}\n\t\tfor(int i =0 ;i < x+y+2;i++){\n//\t\t\tSystem.out.println(i);\n\t\t\tfor(E e :map.getOrDefault(i, Collections.emptyList())){\n//\t\t\t\tSystem.out.println(e.from +\" \"+e.to+\" \"+e.cap); \n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tint sum = 0;\n\t\tfor(;;){\n\t\t\tArrays.fill(depth,-1);\n\n\t\t\tbfs(x+y+1,x+y,map);\n//\t\t\tSystem.out.println(Arrays.toString(depth));\n\t\t\tif(depth[x+y] == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tsum += max_flow(x+y,x+y+1,map);\n\t\t\t\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t}\n\t\t\n\tint depth[];\n\t\n\tvoid bfs(int from, int to, Map<Integer,List<E>> map){\n\t\t\n\t\tLinkedList<Integer> queue = new LinkedList<Integer>();\n\t\tLinkedList<Integer> depthes = new LinkedList<Integer>();\n\t\tqueue.add(from);\n\t\tdepthes.add(0);\n\t\t\n\t\tfor(;!queue.isEmpty();){\n\t\t\t\n\t\t\tint pos = queue.removeFirst();\n\t\t\tint d = depthes.removeFirst();\n\t\t\t\n\t\t\tif(depth[pos] != -1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tdepth[pos] = d;\n\t\t\t\n\t\t\tif(pos == to){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(E e : map.getOrDefault(pos,Collections.emptyList())){\n\t\t\t\t\n\t\t\t\tif( e.rev.cap > 0 ){\n\t\t\t\t\tqueue.addLast(  e.to );\n\t\t\t\t\tdepthes.addLast( d + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint max_flow(int from,int to,Map<Integer,List<E>> map){\n\t\t\n\t\tLinkedList<Integer> index = new LinkedList<Integer>();\n\t\tLinkedList<Integer> pos = new LinkedList<Integer>();\n\t\tLinkedList<E> path = new LinkedList<E>();\n\t\t\n\t\tpos.addLast(from);\n\t\tindex.addLast(-1);\n\t\tint sum = 0;\n\t\t\n\t\tfor(;;){\t\n\t\t\t\n\t\t\tint current = pos.removeLast();\n\t\t\tint start = index.removeLast();\n\t\t\t\n\t\t\tif(current == to){\n\t\t\t\tint flow = 2;\n\t\t\t\tfor(E e : path){\n\t\t\t\t\tflow = Math.min(flow,e.cap);\n\t\t\t\t}\n\t\t\t\tint cnt = path.size();\n\t\t\t\tint x = 0;\n\t\t\t\tfor(E e: path){\n\t\t\t\t\te.cap -= flow;\n\t\t\t\t\te.rev.cap += flow;\n\t\t\t\t\tif(x == 0 && e.cap == 0){\n\t\t\t\t\t\tx = cnt;\n\t\t\t\t\t}\n\t\t\t\t\tcnt --;\n\t\t\t\t}\n\t\t\t\tpath.removeLast();\n\t\t\t\tfor(int i = 1; i< x; i++){\n\t\t\t\t\tpath.removeLast();\n\t\t\t\t\tpos.removeLast();\n\t\t\t\t\tindex.removeLast();\n\t\t\t\t}\n\t\t\t\tsum += flow;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tList<E> l = map.get(current);\n\n\t\t\tboolean found = false;\n\t\t\tfor(int i = start+1; i < l.size(); i++){\n\t\t\t\tE e = l.get(i);\n\t\t\t\t\n\t\t\t\tif(e.cap > 0 && depth[e.from] > depth[e.to]){\n\t\t\t\t\tpos.addLast(current);\n\t\t\t\t\tindex.addLast(i);\n\t\t\t\t\t\n\t\t\t\t\tpath.addLast(e);\n\t\t\t\t\t\n\t\t\t\t\tpos.addLast(e.to);\n\t\t\t\t\tindex.addLast(-1);\n\t\t\t\t\t\n\t\t\t\t\tfound = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(found){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(path.isEmpty()){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tpath.removeLast();\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\t\n}\nclass E{\n\tint from;\n\tint to;\n\tint cap;\n\tE rev;\n}\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tSolver s  = new Solver();\n\t\ts.run();\n\t}\n}\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "package jp.monyone.verify.AOJ.GRL7A.MaximumBipartiteMatching;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\n\nimport java.util.Arrays;\n\npublic class Main {\n\t\t\n\t// ??????????????????????????????????????§?????¨??????????????°??? O(V*(V+E)) ??§?§£???\n\t// L <- ?????´?????????????????? : [0, L)\n\tpublic static int maximumBipartiteMatching(int L, ArrayList<HashSet<Integer>> adj){\n\t\tboolean[] visited = new boolean[adj.size()];\n\t\tint[] match = new int[adj.size()];\n\t\tArrays.fill(match, -1);\n\n\t\tint count = 0;\n\t\tfor(int curr = 0; curr < L; curr++){\n\t\t\tArrays.fill(visited, false);\n\n\t\t\tif(augment(adj, curr, match, visited)){ count++; }\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tprivate static boolean augment(ArrayList<HashSet<Integer>> adj, int curr, int[] match, boolean[] visited) {\n\t\tif(curr < 0){return true; }\n\n\t\tfor(final int next : adj.get(curr)) {\n\t\t\tif(visited[next]){ continue; }\n\n\t\t\tvisited[next] = true;\n\t\t\tif(augment(adj, match[next], match, visited)) {\n\t\t\t\tmatch[curr] = next;\n\t\t\t\tmatch[next] = curr;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\t\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int X = sc.nextInt();\n\t\tfinal int Y = sc.nextInt();\n\t\tfinal int E = sc.nextInt();\n\t\t\n\t\tfinal int size = X + Y;\n\t\tArrayList<HashSet<Integer>> adj = new ArrayList<HashSet<Integer>>();\n\t\tfor(int i = 0; i < size; i++){ adj.add(new HashSet<Integer>()); }\n\t\t\n\t\tfor(int i = 0; i < E; i++){\n\t\t\tfinal int x = sc.nextInt();\n\t\t\tfinal int y = sc.nextInt();\n\t\t\t\n\t\t\tadj.get(x).add(X + y);\n\t\t}\n\t\t\n\t\tSystem.out.println(maximumBipartiteMatching(X, adj));\n\t}\n\t\n\tpublic static class Scanner implements AutoCloseable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() {\n\t\t\ttry {\n\t\t\t\twhile (!hasNext()) {tok = new StringTokenizer(br.readLine());}\n\t\t\t} catch(IOException e){ /* ignore */ }\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tgetLine(); return tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt(){\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t// ??????nextXXX???XXX.parseXXX()????????????????????£?????????????????§?????\\\n\n\t\tpublic void close() {\n\t\t\ttry{ br.close(); } catch (IOException e){ /*ignore*/ }\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().start();\n\n\t}\n\tint[] matchTo;\n\tboolean[] vis;\n\tArrayList<Integer>[] g;\n\t@SuppressWarnings(\"unchecked\")\n\tvoid start(){\n\t\tScanner in = new Scanner(System.in);\n\t\tint x = in.nextInt();\n\t\tint y = in.nextInt();\n\t\tint e = in.nextInt();\n\t\tint[] xs = new int[e];\n\t\tint[] ys = new int[e];\n\t\tg = new ArrayList[x + y];\n\t\tfor(int i = 0; i < x + y; i++){\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i = 0; i < e; i++){\n\t\t\txs[i] = in.nextInt();\n\t\t\tys[i] = in.nextInt();\n\t\t\tg[xs[i]].add(ys[i]);\n\t\t\tg[ys[i]].add(xs[i]);\n\t\t}\n\t\tvis = new boolean[x + y];\n\t\tint[] matchTo = new int[x + y];\n\t\tArrays.fill(matchTo, -1);\n\t\tint match = 0;\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tArrays.fill(vis, false);\n\t\t\tif(dfs(i))match++;\n\t\t}\n\t\tSystem.out.println(match);\n\t}\n\tboolean dfs(int v){\n\t\tif(v < 0)\n\t\t\treturn true;\n\t\tfor(int u : g[v]){\n\t\t\tif(vis[u])\n\t\t\t\tcontinue;\n\t\t\tvis[u] = true;\n\t\t\tif(dfs(matchTo[u])){\n\t\t\t\tmatchTo[u] = v;\n\t\t\t\tmatchTo[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO ?????????????????????????????????????????????\n\t\tnew Main().start();\n\t}\n\tint[] matchTo;\n\tboolean[] vis;\n\tArrayList<Integer>[] g;\n\t@SuppressWarnings(\"unchecked\")\n\tvoid start(){\n\t\tScanner in = new Scanner(System.in);\n\t\tint x = in.nextInt();\n\t\tint y = in.nextInt();\n\t\tint e = in.nextInt();\n\t\tint[] xs = new int[e];\n\t\tint[] ys = new int[e];\n\t\tg = new ArrayList[x + y];\n\t\tfor(int i = 0; i < x + y; i++){\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor(int i = 0; i < e; i++){\n\t\t\txs[i] = in.nextInt();\n\t\t\tys[i] = in.nextInt() + x;\n\t\t\tg[xs[i]].add(ys[i]);\n\t\t\tg[ys[i]].add(xs[i]);\n\t\t}\n\t\tvis = new boolean[x + y];\n\t\tmatchTo = new int[x + y];\n\t\tArrays.fill(matchTo, -1);\n\t\tint match = 0;\n\t\tfor(int i = 0; i < x; i++){\n\t\t\tArrays.fill(vis, false);\n\t\t\tif(dfs(i))match++;\n\t\t}\n\t\tSystem.out.println(match);\n\t\tin.close();\n\t}\n\tboolean dfs(int v){\n\t\tif(v < 0)\n\t\t\treturn true;\n\t\tfor(int u : g[v]){\n\t\t\tif(vis[u])\n\t\t\t\tcontinue;\n\t\t\tvis[u] = true;\n\t\t\tif(dfs(matchTo[u])){\n\t\t\t\tmatchTo[u] = v;\n\t\t\t\tmatchTo[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    ArrayList<ArrayList<Integer>> G;\n    boolean[] used;\n    int[] match;\n\n    void solve() throws IOException {\n        int X = ni();\n        int Y = ni();\n        int E = ni();\n\n        used = new boolean[X + Y];\n        match = new int[X + Y];\n\n        G = new ArrayList<>();\n        for (int i = 0; i < X + Y; i++) {\n            G.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < E; i++) {\n            int x = ni();\n            int y = ni();\n            G.get(x).add(X + y);\n            G.get(X + y).add(x);\n        }\n\n        int ans = 0;\n        Arrays.fill(match, -1);\n        for (int i = 0; i < X; i++) {\n            if (match[i] == -1) {\n                Arrays.fill(used, false);\n                if (dfs(i)) ans++;\n            }\n        }\n\n        out.println(ans);\n    }\n\n    boolean dfs(int from) {\n        used[from] = true;\n        for (int to : G.get(from)) {\n            if (match[to] < 0 || !used[match[to]] && dfs(match[to])) {\n                match[from] = to;\n                match[to] = from;\n                return true;\n            }\n        }\n        return false;\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int X, Y, E;\n\tstatic int[] x, y;\n\tstatic ArrayList<Integer>[] g;\n\tstatic boolean[] vis;\n\tstatic int[] matchTo;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tX = sc.nextInt();\n\t\tY = sc.nextInt();\n\t\tE = sc.nextInt();\n\t\tx = new int[E];\n\t\ty = new int[E];\n\t\tg = new ArrayList[X + Y];\n\t\tfor (int i = 0; i < X + Y; ++i) {\n\t\t\tg[i] = new ArrayList<>();\n\t\t}\n\t\tfor (int i = 0; i < E; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt() + X;\n\t\t\tg[x[i]].add(y[i]);\n\t\t\tg[y[i]].add(x[i]);\n\t\t}\n\t\tvis = new boolean[X + Y];\n\t\tmatchTo = new int[X + Y];\n\t\tArrays.fill(matchTo, -1);\n\t\tint match = 0;\n\t\tfor (int i = 0; i < X; ++i) {\n\t\t\tArrays.fill(vis, false);\n\t\t\tif (dfs(i))\n\t\t\t\t++match;\n\t\t}\n\t\tSystem.out.println(match);\n\t}\n\n\tstatic boolean dfs(int v) {\n\t\tif (v < 0)\n\t\t\treturn true;\n\t\tfor (int u : g[v]) {\n\t\t\tif (vis[u])\n\t\t\t\tcontinue;\n\t\t\tvis[u] = true;\n\t\t\tif (dfs(matchTo[u])) {\n\t\t\t\tmatchTo[u] = v;\n\t\t\t\tmatchTo[v] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\n//using static System.Globalization.CultureInfo;\nusing System.Text;\nclass Program\n{\n    private static void chmin<T>(ref T num, T val) where T : IComparable<T>\n        => num = num.CompareTo(val) == 1 ? val : num;\n    private static void chmax<T>(ref T num, T val) where T : IComparable<T>\n        => num = num.CompareTo(val) == -1 ? val : num;\n    static void Main(string[] args)\n    {\n        var pr = new Program();\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        Console.SetOut(sw);\n        pr.Solve();\n        Console.Out.Flush();\n    }\n    void Solve()\n    {\n        int x, y, e;\n        Input.Make(out x, out y, out e);\n        var f = new MaxFlow(x + y + 2);\n        while (e-- > 0)\n        {\n            var ab = Input.ar;\n            f.AddDirectedEdge(ab[0] + 1, ab[1] + 1 + x,1);\n        }\n        for (var i = 0; i < x; i++)\n            f.AddDirectedEdge(0, i + 1, 1);\n        for (var i = 0; i < y; i++)\n            f.AddDirectedEdge(i + x + 1, x + y + 1, 1);\n        WriteLine(f.Execute(0, x + y + 1));\n    }\n}\n\npublic class Input\n{\n    public static string read => ReadLine().Trim();\n    public static int[] ar => read.Split(' ').Select(int.Parse).ToArray();\n    public static int num => ToInt32(read);\n    public static long[] arL => read.Split(' ').Select(long.Parse).ToArray();\n    public static long numL => ToInt64(read);\n    public static T[] create<T>(int n, Func<int, T> f)\n        => Enumerable.Repeat(0, n).Select(f).ToArray();\n    public static char[][] gred(int h)\n        => create(h, _ => read.ToCharArray());\n    public static int[] ar1D(int n)\n        => create(n, _ => num);\n    public static long[] arL1D(int n)\n        => create(n, _ => numL);\n    public static string[] strs(int n)\n        => create(n, _ => read);\n    public static int[][] ar2D(int n)\n        => create(n, _ => ar);\n    public static long[][] arL2D(int n)\n        => create(n, _ => arL);\n    public static List<T>[] edge<T>(int n)\n        => create(n, _ => new List<T>());\n    public static T GetValue<T>(string g)\n    {\n        var t = typeof(T);\n        if (t == typeof(int))\n            return (T)(object)int.Parse(g);\n        if (t == typeof(long))\n            return (T)(object)long.Parse(g);\n        if (t == typeof(string))\n            return (T)(object)g;\n        if (t == typeof(char))\n            return (T)(object)char.Parse(g);\n        if (t == typeof(double))\n            return (T)(object)double.Parse(g);\n        if (t == typeof(bool))\n            return (T)(object)bool.Parse(g);\n        return default(T);\n    }\n    public static void Make<T1, T2>(out T1 v1, out T2 v2)\n    {\n        v1 = Next<T1>();\n        v2 = Next<T2>();\n    }\n    public static void Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3)\n    {\n        Make(out v1, out v2);\n        v3 = Next<T3>();\n    }\n    public static void Make<T1, T2, T3, T4>(out T1 v1, out T2 v2, out T3 v3, out T4 v4)\n    {\n        Make(out v1, out v2, out v3);\n        v4 = Next<T4>();\n    }\n    public static void Make<T1, T2, T3, T4, T5>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5)\n    {\n        Make(out v1, out v2, out v3, out v4);\n        v5 = Next<T5>();\n    }\n    public static void Make<T1, T2, T3, T4, T5, T6>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6)\n    {\n        Make(out v1, out v2, out v3, out v4, out v5);\n        v6 = Next<T6>();\n    }\n    private static Queue<string> sc;\n    public static T Next<T>(){ sc = sc ?? new Queue<string>(); if (sc.Count == 0) foreach (var item in read.Split(' ')) sc.Enqueue(item);return GetValue<T>(sc.Dequeue()); }\n    public static void Next<T>(ref T val) => val = Next<T>(); \n    public const long Inf = (long)1e18;\n    public const double eps = 1e-6;\n    public const string Alfa = \"abcdefghijklmnopqrstuvwxyz\";\n    public const int MOD = 1000000007;\n}\n\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1 { get; set; }\n    public T2 v2 { get; set; }\n    public Pair() { v1 = Input.Next<T1>(); v2 = Input.Next<T2>(); }\n    public Pair(T1 v1, T2 v2)\n    { this.v1 = v1; this.v2 = v2; }\n\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public override string ToString()\n        => $\"{v1.ToString()} {v2.ToString()}\";\n    public override bool Equals(object obj)\n        => this == (Pair<T1, T2>)obj;\n    public override int GetHashCode()\n        => v1.GetHashCode() ^ v2.GetHashCode();\n    public static bool operator ==(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) == 0;\n    public static bool operator !=(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) != 0;\n    public static bool operator >(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) == 1;\n    public static bool operator >=(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) != -1;\n    public static bool operator <(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) == -1;\n    public static bool operator <=(Pair<T1, T2> p1, Pair<T1, T2> p2)\n        => p1.CompareTo(p2) != 1;\n}\n\npublic class Pair<T1, T2, T3> : Pair<T1, T2>, IComparable<Pair<T1, T2, T3>>\n{\n    public T3 v3 { get; set; }\n    public Pair() : base() { v3 = Input.Next<T3>(); }\n    public Pair(T1 v1, T2 v2, T3 v3) : base(v1, v2)\n    { this.v3 = v3; }\n\n    public int CompareTo(Pair<T1, T2, T3> p)\n    {\n        var c = base.CompareTo(p);\n        if (c == 0)\n            c = Comparer<T3>.Default.Compare(v3, p.v3);\n        return c;\n    }\n    public override string ToString()\n        => $\"{base.ToString()} {v3.ToString()}\";\n}\n\npublic class MaxFlow\n{\n    readonly List<Edge>[] G;\n    readonly int[] lv, iter;\n\n    public MaxFlow(int V)\n    {\n        G = new List<Edge>[V];\n        lv = new int[V];\n        iter = new int[V];\n        for (int i = 0; i < G.Length; i++)\n            G[i] = new List<Edge>();\n    }\n\n    public void AddDirectedEdge(int from, int to, int cap)\n        => addEdge(from, to, cap, 0);\n\n    public void AddUndirectedEdge(int from, int to, int cap)\n        => addEdge(from, to, cap, cap);\n\n    void addEdge(int f, int t, int c1, int c2)\n    {\n        var a = new Edge(t, c1);\n        var b = new Edge(f, c2);\n        Edge.Link(a, b);\n        G[f].Add(a);\n        G[t].Add(b);\n    }\n\n    public int Execute(int src, int sink, int f = -1)\n    {\n        int flow = 0;\n        if (f < 0) f = int.MaxValue;\n        while (f > 0)\n        {\n            bfs(src);\n            if (lv[sink] == 0) return flow;\n            Array.Clear(iter, 0, iter.Length);\n            int df;\n            while ((df = dfs(src, sink, f)) > 0) { flow += df; f -= df; }\n        }\n        return flow;\n    }\n\n    void bfs(int s)\n    {\n        Array.Clear(lv, 0, lv.Length);\n        var q = new Queue<int>();\n        lv[s] = 1;\n        q.Enqueue(s);\n        while (q.Count > 0)\n        {\n            var v = q.Dequeue();\n            foreach (var e in G[v])\n                if (e.Cap > 0 && lv[e.To] == 0)\n                {\n                    lv[e.To] = lv[v] + 1;\n                    q.Enqueue(e.To);\n                }\n        }\n\n    }\n    int dfs(int v, int t, int f)\n    {\n        if (v == t) return f;\n        int ret = 0;\n        for (; iter[v] < G[v].Count; iter[v]++)\n        {\n            var e = G[v][iter[v]];\n            if (e.Cap <= 0 || lv[v] >= lv[e.To]) continue;\n            int df = dfs(e.To, t, Math.Min(f, e.Cap));\n            if (df <= 0) continue;\n            e.Cap -= df;\n            e.Rev.Cap += df;\n            ret += df; f -= df;\n            if (f == 0) break;\n        }\n        return ret;\n\n    }\n    class Edge\n    {\n        public static void Link(Edge e1, Edge e2)\n        {\n            e1.Rev = e2; e2.Rev = e1;\n        }\n        public int To { get; private set; }\n        public Edge Rev { get; private set; }\n        public int Cap { get; set; }\n        public Edge(int t, int c)\n        {\n            To = t;\n            Cap = c;\n        }\n        public override string ToString()\n        {\n            return string.Format(\"to: {0}, cap: {1}\", To, Cap);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing StringBuilder = System.Text.StringBuilder;\n//using System.Numerics;\n\nnamespace Program\n{\n\n    public class Solver\n    {\n        public void Solve()\n        {\n          var n=sc.Integer();\n          var m=sc.Integer();\n          var E=sc.Integer();\n          var G=Enumerate(n+m,x=>new List<int>());\n          for (int i = 0; i < E; i++)\n          {\n              var x = sc.Integer();\n              var y = sc.Integer();\n              G[x].Add(y+n);\n          }\n          var f=Graph.BipartiteMatching(G);\n          IO.Printer.Out.WriteLine(f);\n        }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    //static public string AsString(this IEnumerable<char> ie) { return new string(System.Linq.Enumerable.ToArray(ie)); }\n    //static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") { return string.Join(st, ie); }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer : StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n#region BipartiteMatching with Adjacency List\nstatic partial class Graph\n{\n    static public int BipartiteMatching(List<int>[] G)\n    {\n        var n = G.Length;\n        var match = new int[n];\n        var used = new bool[n];\n        var res = 0;\n        for (int i = 0; i < n; i++)\n            match[i] = -1;\n        Func<int, bool> dfs = null;\n        dfs = v =>\n        {\n            used[v] = true;\n            foreach (var u in G[v])\n            {\n                var w = match[u];\n                if (w < 0 || !used[w] && dfs(w))\n                {\n                    match[v] = u;\n                    match[u] = v;\n                    return true;\n                }\n            }\n            return false;\n        };\n        for (int v = 0; v < n; v++)\n        {\n            if (match[v] >= 0) continue;\n            Array.Clear(used, 0, n);\n            if (dfs(v)) res++;\n        }\n        return res;\n\n    }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.Ia;\n\t\tint g=s[0]+s[1]+2;\n\t\tvar fl=new Mfp(g+1);\n\t\tfor(int i = 0;i<s[2];i++) {\n\t\t\tvar e=sc.Ia;\n\t\t\tfl.Edge(e[0],e[1]+s[0],1);\n\t\t}\n\t\tfor(int i = 0;i<s[0];i++) {fl.Edge(g-1,i,1);}\n\t\tfor(int i = 0;i<s[1];i++) {fl.Edge(s[0]+i,g,1);}\n\t\tConsole.WriteLine(\"{0}\",fl.Dinic(g-1,g));\n\t}\n}\npublic class Mfp{\n\tprivate List<int>[] li;\n\tprivate Dictionary<int,int>[] h;\n\tprivate bool[] b;\n\tprivate int[] l;\n\tprivate int n,ans,go;\n\tprivate const int inf=int.MaxValue;\n\tpublic Mfp(int n){\n\t\tthis.n=n;\n\t\tli=new List<int>[n];\n\t\th=new Dictionary<int,int>[n+1];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tli[i]=new List<int>();\n\t\t\th[i]=new Dictionary<int,int>();\n\t\t}\n\t}\n\tpublic void Edge(int a,int b,int c){\n\t\tif(a==b){return;}\n\t\tif(!h[a].ContainsKey(b)){\n\t\t\tli[a].Add(b);\n\t\t\tli[b].Add(a);\n\t\t\th[a].Add(b,c);\n\t\t\th[b].Add(a,0);\n\t\t}\n\t\telse{h[a][b]+=c;}\n\t}\n\tpublic int Dinic(int st,int go){\n\t\tthis.go=st;\n\t\tans=0;\n\t\tint z=1;\n\t\twhile(z>0){\n\t\t\tl=new int[n];\n\t\t\tvar qu=new Queue<Tuple<int,int>>();\n\t\t\tqu.Enqueue(Tuple.Create(st,1));\n\t\t\tl[st]=1;\n\t\t\twhile(qu.Count>0){\n\t\t\t\tvar e=qu.Dequeue();\n\t\t\t\tfor(int i=0;i<li[e.Item1].Count;i++){\n\t\t\t\t\tif(l[li[e.Item1][i]]==0&&h[e.Item1][li[e.Item1][i]]!=0){\n\t\t\t\t\t\tl[li[e.Item1][i]]=e.Item2+1;\n\t\t\t\t\t\tqu.Enqueue(Tuple.Create(li[e.Item1][i],e.Item2+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(e.Item1==go){break;}\n\t\t\t}\n\t\t\tb=new bool[n];\n\t\t\tz=Fu3(go,inf);\n\t\t\tans+=z;\n\t\t}\n\t\treturn ans;\n\t}\n\tprivate int Fu3(int a,int p){\n\t\tif(a==go){return p;}\n\t\tint u=0;\n\t\tfor(int i=0;i<li[a].Count&&p>u;i++){\n\t\t\tif(!b[li[a][i]]&&l[li[a][i]]<l[a]&&h[li[a][i]][a]!=0){\n\t\t\t\tint z=Fu3(li[a][i],Min(p-u,h[li[a][i]][a]));\n\t\t\t\th[li[a][i]][a]-=z;\n\t\t\t\th[a][li[a][i]]+=z;\n\t\t\t\tu+=z;\n\t\t\t}\n\t\t}\n\t\tif(u==0){b[a]=true;}\n\t\treturn u;\n\t}\n\tpublic int Ff(int st,int go){\n\t\tthis.go=go;\n\t\tans=0;\n\t\tint z=1;\n\t\twhile(z>0){\n\t\t\tb=new bool[n];\n\t\t\tz=Fu2(st,inf);\n\t\t\tans+=z;\n\t\t}\n\t\treturn ans;\n\t}\n\tprivate int Fu2(int a,int p){\n\t\tif(a==go){return p;}\n\t\tint u=0;\n\t\tb[a]=true;\n\t\tfor(int i=0;i<li[a].Count&&p>u;i++){\n\t\t\tif(!b[li[a][i]]&&h[a][li[a][i]]!=0){\n\t\t\t\tint z=Fu2(li[a][i],Min(p-u,h[a][li[a][i]]));\n\t\t\t\th[a][li[a][i]]-=z;\n\t\t\t\th[li[a][i]][a]+=z;\n\t\t\t\tu+=z;\n\t\t\t}\n\t\t}\n\t\tif(u!=0){b[a]=false;}\n\t\treturn u;\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace No421_1{\n    public class Program{\n        public static void Main(string[] args){\n            var sr = new StreamReader();\n            //---------------------------------\n            var X = sr.Next<int>();\n            var Y = sr.Next<int>();\n            var E = sr.Next<int>();\n\n            var bg = new BipartiteGraph(X + Y);\n            for(var i = 0; i < E; i++){\n                bg.AddEdge(sr.Next<int>(), sr.Next<int>() + X);\n            }\n\n            Console.WriteLine(bg.Matching());\n            //---------------------------------\n        }\n    }\n\n    public class BipartiteGraph{//????P197\n        private readonly List<int>[] _adj;\n        private readonly int[] _match;\n        private readonly bool[] _used;\n         \n        public BipartiteGraph(int v){\n            _adj = new List<int>[v];\n            for(var i = 0; i < v; i++) _adj[i] = new List<int>();\n            _match = new int[v];\n            _used = new bool[v];\n        }\n\n        public void AddEdge(int u, int v){\n            _adj[u].Add(v);\n            _adj[v].Add(u);\n        }\n\n        public int Matching(){\n            var res = 0;\n            for(var i = 0; i < _match.Length; i++) _match[i] = -1;\n            for(var v = 0; v < _match.Length; v++){\n                if(_match[v] < 0){\n                    for(var j = 0; j < _used.Length; j++) _used[j] = false;\n                    if(Dfs(v)) res++;\n                }\n            }\n            return res;\n        }\n\n        private bool Dfs(int v){\n            _used[v] = true;\n            for(var i = 0; i < _adj[v].Count; i++){\n                var u = _adj[v][i];\n                var w = _match[u];\n                if(w < 0 || (!_used[w] && Dfs(w))){\n                    _match[v] = u;\n                    _match[u] = v;\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace AOJ_GRL_7_A\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var XYE = ReadInt();\n            int X = XYE[0];\n            int Y = XYE[1];\n            int E = XYE[2];\n\n            int V = X + Y + 2;\n            FordFulkerson fd = new FordFulkerson(V);\n            for (int i = 0; i < E; i++)\n            {\n                var input = ReadInt();\n                fd.AddEdge(input[0] + 2, input[1] + X + 2, 1);\n            }\n            for (int i = 0; i < X; i++)\n            {\n                fd.AddEdge(0, i + 2, 1);\n            }\n            for (int i = 0; i < Y; i++)\n            {\n                fd.AddEdge(i + X + 2, 1, 1);\n            }\n\n            var ans = fd.MaxFlow(0, 1);\n\n            Console.WriteLine(ans);\n            Console.ReadKey();\n        }\n\n        static int[] ReadInt()\n        {\n            int[] ret = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            return ret;\n        }\n        static long[] ReadLong()\n        {\n            long[] ret = Console.ReadLine().Split().Select(long.Parse).ToArray();\n            return ret;\n        }\n    }\n\n    /// <summary>\n    /// 最大流　容量に注意\n    /// </summary>\n    class FordFulkerson\n    {\n        public struct Edge\n        {\n            public int to, cap, rev;\n        }\n\n        public List<Edge>[] G;\n        bool[] used;\n        int INF = 1000000009;\n\n        public FordFulkerson(int V) //頂点数\n        {\n            G = new List<Edge>[V].Select(x => new List<Edge>()).ToArray();\n            used = new bool[V];\n        }\n\n        public void AddEdge(int from, int to, int cap)\n        {\n            G[from].Add(new Edge() { to = to, cap = cap, rev = G[to].Count });\n            G[to].Add(new Edge() { to = from, cap = 0, rev = G[from].Count - 1 });\n        }\n\n        int Dfs(int v, int t, int f)\n        {\n            if (v == t)\n                return f;\n            used[v] = true;\n\n            for (int i = 0; i < G[v].Count; i++)\n            {\n                var e = G[v][i];\n                if (!used[e.to] && e.cap > 0)\n                {\n                    int d = Dfs(e.to, t, Math.Min(f, e.cap));\n                    if (d > 0)\n                    {\n                        e.cap -= d;\n                        G[v][i] = e;\n\n                        var temp = G[e.to][e.rev];\n                        temp.cap += d;\n                        G[e.to][e.rev] = temp;\n\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        public int MaxFlow(int s, int t)\n        {\n            int flow = 0;\n            while (true)\n            {\n                used = new bool[used.Length];\n                int f = Dfs(s, t, INF);\n                if (f == 0) return flow;\n                flow += f;\n            }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace BipartiteMatching\n{\n    class BipartiteMatching\n    {\n        readonly int n;\n\n        Dictionary<int, List<int>> G;\n        int[] match;\n        bool[] used;\n\n        public BipartiteMatching(int V)\n        {\n            n = V;\n\n            G = new Dictionary<int, List<int>>();\n            for (int i = 0; i < n; i++) G.Add(i, new List<int>());\n        }\n\n        public void AddEdge(int u, int v)\n        {\n            G[u].Add(v);\n            G[v].Add(u);\n        }\n\n        public int MaxmimumMatching()\n        {\n            int ret = 0;\n\n            match = Enumerable.Repeat(-1, n).ToArray();\n\n            for (int v = 0; v < n; v++)\n            {\n                if (match[v] < 0)\n                {\n                    used = new bool[n];\n\n                    if (Augument(v)) ret++;\n                }\n            }\n            return ret;\n        }\n\n        private bool Augument(int v)\n        {\n            used[v] = true;\n\n            foreach (var u in G[v])\n            {\n                int w = match[u];\n\n                if (w < 0 || (!used[w] && Augument(w)))\n                {\n                    match[v] = u;\n                    match[u] = v;\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] input = Console.ReadLine().Split(' ');\n            int X = int.Parse(input[0]);\n            int Y = int.Parse(input[1]);\n\n            int V = X + Y;\n            int E = int.Parse(input[2]);\n\n            BipartiteMatching BM = new BipartiteMatching(V);\n\n            for (int i = 0; i < E; i++)\n            {\n                input = Console.ReadLine().Split(' ');\n                int x = int.Parse(input[0]);\n                int y = int.Parse(input[1]) + X;\n\n                BM.AddEdge(x, y);\n            }\n\n            Console.WriteLine(BM.MaxmimumMatching());\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass A\n{\n\tstatic long[] Read() => Console.ReadLine().Split().Select(long.Parse).ToArray();\n\tstatic void Main()\n\t{\n\t\tvar h = Read();\n\t\tint nx = (int)h[0], ny = (int)h[1], sv = nx + ny, ev = sv + 1;\n\t\tvar es = new int[h[2]].Select(_ => Read()).Select(x => new[] { x[0], nx + x[1], 1 }).ToList();\n\n\t\tes.AddRange(Enumerable.Range(0, nx).Select(i => new[] { sv, i, 1L }));\n\t\tes.AddRange(Enumerable.Range(0, ny).Select(j => new[] { nx + j, ev, 1L }));\n\t\tConsole.WriteLine(MaxFlow(ev, sv, ev, es.ToArray()));\n\t}\n\n\tstatic long MaxFlow(int n, int sv, int ev, long[][] dg)\n\t{\n\t\tvar map = Array.ConvertAll(new int[n + 1], _ => new List<long[]>());\n\t\tforeach (var e in dg)\n\t\t{\n\t\t\tmap[e[0]].Add(new[] { e[0], e[1], e[2], map[e[1]].Count });\n\t\t\tmap[e[1]].Add(new[] { e[1], e[0], 0, map[e[0]].Count - 1 });\n\t\t}\n\n\t\tlong M = 0, t;\n\t\twhile ((t = Bfs(n, sv, ev, map)) > 0) M += t;\n\t\treturn M;\n\t}\n\n\tstatic long Bfs(int n, int sv, int ev, List<long[]>[] map)\n\t{\n\t\tvar from = new long[n + 1][];\n\t\tvar minFlow = Enumerable.Repeat(long.MaxValue, n + 1).ToArray();\n\t\tvar q = new Queue<long>();\n\t\tq.Enqueue(sv);\n\n\t\twhile (q.Any())\n\t\t{\n\t\t\tvar v = q.Dequeue();\n\t\t\tif (v == ev) break;\n\t\t\tforeach (var e in map[v])\n\t\t\t{\n\t\t\t\tif (from[e[1]] != null || e[2] == 0) continue;\n\t\t\t\tfrom[e[1]] = e;\n\t\t\t\tminFlow[e[1]] = Math.Min(minFlow[v], e[2]);\n\t\t\t\tq.Enqueue(e[1]);\n\t\t\t}\n\t\t}\n\n\t\tif (from[ev] == null) return 0;\n\t\tfor (long v = ev; v != sv; v = from[v][0])\n\t\t{\n\t\t\tvar e = from[v];\n\t\t\te[2] -= minFlow[ev];\n\t\t\tmap[e[1]][(int)e[3]][2] += minFlow[ev];\n\t\t}\n\t\treturn minFlow[ev];\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        Console.SetOut(sw);\n        new Program().solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n\n    List<int>[] G;\n    int[] match;\n    bool[] used;\n    void solve()\n    {\n        int X = cin.nextint;\n        int Y = cin.nextint;\n        int E = cin.nextint;\n\n        G = Enumerable.Range(0, X + Y).Select(i => new List<int>()).ToArray();\n\n        for (int i = 0; i < E; i++)\n        {\n            var t = cin.scanint;\n            G[t[0]].Add(t[1] + X);\n            G[t[1] + X].Add(t[0]);\n        }\n\n        int res = 0;\n        match = Enumerable.Repeat(-1, X + Y).ToArray();\n\n        for (int i = 0; i < X + Y; i++)\n        {\n            if (match[i] < 0)\n            {\n                used = new bool[X + Y];\n                if (dfs(i))\n                {\n                    res++;\n                }\n            }\n        }\n\n        Console.WriteLine(res);\n    }\n    bool dfs(int v)\n    {\n        used[v] = true;\n        foreach (var u in G[v])\n        {\n            int w = match[u];\n            if (w < 0 || !used[w] && dfs(w))\n            {\n                match[v] = u;\n                match[u] = v;\n                return true;\n            }\n        }\n        return false;\n    }\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan { get { return Console.ReadLine().Split(); } }\n    public int[] scanint { get { return Array.ConvertAll(scan, int.Parse); } }\n    public long[] scanlong { get { return Array.ConvertAll(scan, long.Parse); } }\n    public double[] scandouble { get { return Array.ConvertAll(scan, double.Parse); } }\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint { get { return int.Parse(next); } }\n    public long nextlong { get { return long.Parse(next); } }\n    public double nextdouble { get { return double.Parse(next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\n\nnamespace No421_1{\n    public class Program{\n        public static void Main(string[] args){\n            var sr = new StreamReader();\n            //---------------------------------\n            var X = sr.Next<int>();\n            var Y = sr.Next<int>();\n            var E = sr.Next<int>();\n\n            var bg = new BipartiteGraph(X + Y);\n            for(var i = 0; i < E; i++){\n                bg.AddEdge(sr.Next<int>(), sr.Next<int>() + X);\n            }\n\n            Console.WriteLine(bg.Matching());\n            //---------------------------------\n        }\n    }\n\n    public class BipartiteGraph{\n        private readonly List<int>[] _adj;\n        private readonly int[] _match;\n        private readonly bool[] _used;\n         \n        public BipartiteGraph(int v){\n            _adj = new List<int>[v];\n            for(var i = 0; i < v; i++) _adj[i] = new List<int>();\n            _match = new int[v];\n            _used = new bool[v];\n        }\n\n        public void AddEdge(int u, int v){\n            _adj[u].Add(v);\n            _adj[v].Add(u);\n        }\n\n        public int Matching(){\n            var res = 0;\n            for(var i = 0; i < _match.Length; i++) _match[i] = -1;\n            for(var v = 0; v < _match.Length; v++){\n                if(_match[v] < 0){\n                    for(var j = 0; j < _used.Length; j++) _used[v] = false;\n                    if(Dfs(v)) res++;\n                }\n            }\n            return res;\n        }\n\n        private bool Dfs(int v){\n            _used[v] = true;\n            for(var i = 0; i < _adj[v].Count; i++){\n                var u = _adj[v][i];\n                var w = _match[u];\n                if(w < 0 || !_used[w] && Dfs(w)){\n                    _match[v] = u;\n                    _match[u] = v;\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "# http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_7_A&lang=jp\n# Matching - Bipartite Matching\n\n# 0=s, 1=t\nclass FordFulkerson\n  def initialize(n)\n    @n = n\n    @flow = Array.new(n) { Array.new(n, 0) }\n    @cap = Array.new(n) { Array.new(n, 0) }\n  end\n\n  def connect(s, t, w)\n    @cap[s][t] = w\n  end\n\n  def calc\n    inf = 2 ** 30\n    sum = 0\n    while true\n      que = [0]\n      prev = Array.new(@n, -1)\n      prev[0] = 0\n      while !que.empty? && prev[1] == -1\n        u = que.shift\n        @n.times do |i|\n          if prev[i] == -1 && @cap[u][i] - @flow[u][i] > 0\n            prev[i] = u\n            que.push(i)\n          end\n        end\n      end\n      return sum if (prev[1] == -1)\n      inc = inf\n      c = 1\n      while c != 0\n        inc = [inc, @cap[prev[c]][c] - @flow[prev[c]][c]].min\n        c = prev[c]\n      end\n      c = 1\n      while c != 0\n        @flow[prev[c]][c] += inc\n        @flow[c][prev[c]] -= inc\n        c = prev[c]\n      end\n      sum += inc\n    end\n  end\nend\n\nxn, yn, en = gets.split.map(&:to_i)\nn = xn + yn + 2\ng = FordFulkerson.new(n)\n\nxn.times do |i|\n  g.connect(0, 2 + i, 1)\nend\nyn.times do |i|\n  g.connect(2 + xn + i, 1, 1)\nend\n\nen.times do\n  x, y = gets.split.map(&:to_i)\n  g.connect(2 + x, 2 + xn + y, 1)\nend\n\nputs g.calc\n\n"
  },
  {
    "language": "Ruby",
    "code": "\nX,Y,E = gets.chomp.split(' ').map(&:to_i)\nD = Array.new(X).map{ Array.new(Y) }\nE.times do \n\tx,y = gets.chomp.split(' ').map(&:to_i) # ?????????x,y??????????????????\n\tD[x][y] = true\nend\n\nPY = Array.new(Y).map{-1} # Y's pair ??????-1??¨???????????????\nV = Array.new(X).map{false} # visited or not (boolean)\n\ndef match(x)\n\treturn true if x<0 \n\treturn false if V[x] # ????????¢????¨????????????????false\n\tV[x] = true\n\tY.times do |y|\n\t\tnext if !D[x][y] # ??????????????????????????§????????????????¬????\n\t\t# ??\\????????????????????´?????§...\n\t\t#p \"#{x}, #{y}\"\n\t\tif match(PY[y]) # y?????????????????????PY[y]???-1????????§match(-1)???true, ??????y???????????¢?????????????????????????????????????????????????????????????????????...?????°?????????\n\t\t\tPY[y] = x # y????????¢???x??¨??????\n\t\t\t#p \"#{x}, #{y} matched\"\n\t\t\treturn true # ??????????????????????????¢??????????????????????\\???????????????????????????¨????????? or count++\n\t\tend\n\tend\n\treturn false # ??°?????¢?????§???????????£????????§???NG?????????\nend\n\ncount = 0 # ?????¢??°\n\n# ????????§???x??????????????????????????????????????????\nX.times do |x|\n\tx.times do |i|\n\t\tV[i] = false\n\tend\n\tcount = count + 1 if match(x)\nend\n#p PY\np count"
  },
  {
    "language": "Ruby",
    "code": "x=gets.chomp.split(\" \")\nn=x[0].to_i\nm=x[1].to_i\ne=x[2].to_i\n\n$N=n\n$V=n+m\n$G=Array.new($V).map{Array.new(0,0)}\n$match=Array.new($V,-1);\n$used=Array.new($V,false)\n\ndef add_edge(u,v)\n    $G[u].push(v)\n    $G[v].push(u)\nend\n\ndef dfs(v)\n    $used[v]=true\n    for i in 0..$G[v].size-1\n        u=$G[v][i]\n        w=$match[u]\n        if w<0 || !$used[w]&&dfs(w)==true\n            $match[v]=u\n            $match[u]=v\n            return true\n        end\n    end\n    return false \nend\n\ndef bipartite_matching()\n    res=0\n    $match.fill(-1,0..$V-1)\n    for v in 0..$N-1\n        if $match[v]<0\n            $used.fill(false,0..$V-1)\n            if dfs(v)==true\n                res+=1\n            end\n        end\n    end\n    return res\nend\n\nfor i in 1..e\n    x=gets.chomp.split(\" \")\n    u=x[0].to_i\n    v=x[1].to_i+n\n    add_edge(u,v)\nend\nputs bipartite_matching()\n"
  },
  {
    "language": "Ruby",
    "code": "class MaximumMatching\n  \n  def initialize l, r\n    @L = l\n    @R = r\n    @adj = Array.new(l + r) { [] }\n  end\n\n  def add u, v\n    @adj[u] << v + @L\n    @adj[v + @L] << u\n  end\n\n  def maximum_matching\n    @visited = Array.new(@L)\n    @meta = Array.new(@L + @R) { -1 }\n\n    match = 0\n    @L.times do |u|\n      @visited.fill false\n      match += 1 if augment u\n    end\n    match\n  end\n\n  private\n\n  def augment u\n    return false if @visited[u]\n    @visited[u] = true\n\n    @adj[u].each do |w|\n      v = @meta[w]\n      if v < 0 || augment(v)\n        @meta[u] = w\n        @meta[w] = u\n        return true\n      end\n    end\n\n    false\n  end\nend\n\nx, y, e = gets.split.map(&:to_i)\ng = MaximumMatching.new(x, y)\ne.times do\n  x, y = gets.split.map(&:to_i)\n  g.add x, y\nend\nputs g.maximum_matching\n"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/env ruby\n\n\n\n$visited = []\n$pre_vertex = []\n\n\ndef min a,b\n  if a<b then return a else b end\nend\n\ndef init_dfs v,e\n  $visited = Array.new(v,false)\n  $pre_vertex = Array.new(v,false)\nend\n\n#b -> e ??§edges\ndef dfs b,e,es\n  es[b].each_with_index do |c,v|\n    if !$visited[v] and c>0 then\n      $visited[v] = true\n      $pre_vertex[v] = b\n      if v==e then\n        return\n      end\n      dfs(v,e,es)\n    end\n  end\nend\n\n\ndef back_trace b,e,es\n  flow =[]\n  min_c = 10e8\n\n  to = e\n  from = $pre_vertex[e]\n  flow=[[from,to]]+flow\n  min_c = min(min_c,es[from][to])\n\n  while from != b\n    to = from\n    from = $pre_vertex[from]\n    flow=[[from,to]]+flow\n    min_c = min(min_c,es[from][to])\n  end\n  return flow,min_c\nend\n\n\n\n#v_size,e_size = gets.chomp.split(/ /).map{|i| i.to_i}\n\nx_size,y_size,e_size = gets.chomp.split(/ /).map{|i| i.to_i}\n\nedges = Array.new(x_size+y_size+2).map{ Array.new(x_size+y_size+2,0)}\n\n\ne_size.times do\n  u,v = gets.chomp.split(/ /).map{|i| i.to_i}\n  edges[u][x_size+v] = 1\nend\nx_size.times do |i|\n  edges[x_size+y_size][i] = 1\nend\ny_size.times do |i|\n  edges[x_size+i][x_size+y_size+1] = 1\nend\n\n\n#edges.each do |i| p i end\n@ans = 0\nv_size = x_size+y_size+2\nloop do\n  init_dfs(v_size,e_size)\n  dfs(x_size+y_size,x_size+y_size+1,edges)\n  if $visited[v_size-1] then\n    f,min_c = back_trace(x_size+y_size,x_size+y_size+1,edges)\n    f.each do |i|\n      edges[i[0]][i[1]]=0\n      edges[i[1]][i[0]]=1\n    end\n    @ans = @ans+ min_c\n  else\n    p @ans\n    break\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/env ruby\n\n\n\n$visited = []\n$pre_vertex = []\n\n\ndef min a,b\n  if a<b then return a else b end\nend\n\ndef init_dfs v,e\n  $visited = Array.new(v,false)\n  $pre_vertex = Array.new(v,false)\nend\n\n#b -> e ??§edges\ndef dfs b,e,es\n  es[b].each_with_index do |c,v|\n    if !$visited[v] and c>0 then\n      $visited[v] = true\n      $pre_vertex[v] = b\n      if v==e then\n        return\n      end\n      dfs(v,e,es)\n    end\n  end\nend\n\n\ndef back_trace b,e,es\n  flow =[]\n  min_c = 10e8\n\n  to = e\n  from = $pre_vertex[e]\n  flow=[[from,to]]+flow\n  min_c = min(min_c,es[from][to])\n\n  while from != b\n    to = from\n    from = $pre_vertex[from]\n    flow=[[from,to]]+flow\n    min_c = min(min_c,es[from][to])\n  end\n  return flow,min_c\nend\n\n\n\n#v_size,e_size = gets.chomp.split(/ /).map{|i| i.to_i}\n\nx_size,y_size,e_size = gets.chomp.split(/ /).map{|i| i.to_i}\n\nedges = Array.new(x_size+y_size+2).map{ Array.new(x_size+y_size+2,0)}\n\n\ne_size.times do\n  u,v = gets.chomp.split(/ /).map{|i| i.to_i}\n  edges[u][v] = 1\nend\nx_size.times do |i|\n  edges[x_size+y_size][i] = 1\nend\ny_size.times do |i|\n  edges[x_size+i][x_size+y_size+1] = 1\nend\n\n@ans = 0\nv_size = x_size+y_size+2\nloop do\n\n  init_dfs(v_size,e_size)\n  dfs(x_size+y_size,x_size+y_size+1,edges)\n  if $visited[v_size-1] then\n    f,min_c = back_trace(x_size+y_size,x_size+y_size+1,edges)\n    f.each do |i|\n      edges[i[0]][i[1]]=0\n      edges[i[1]][i[0]]=1\n    end\n    @ans = @ans+ min_c\n  else\n    p @ans\n    break\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "X,Y,E = gets.chomp.split(' ').map(&:to_i)\nD = Array.new(110).map{ Array.new(110) }\nE.times do \n\tx,y = gets.chomp.split(' ').map(&:to_i) # ?????????x,y??????????????????\n\tD[x][y] = true\nend\n\nPY = Array.new(Y).map{-1} # Y's pair ??????-1??¨???????????????\nV = Array.new(X).map{false} # visited or not (boolean)\n\ndef match(x)\n\treturn true if x<0 \n\treturn false if V[x] # ????????¢????¨????????????????false\n\tV[x] = true\n\tY.times do |y|\n\t\tnext if !D[x][y] # ??????????????????????????§????????????????¬????\n\t\t# ??\\????????????????????´?????§...\n\t\tif match(PY[y]) # y?????????????????????PY[y]???-1????????§match(-1)???true, ??????y???????????¢?????????????????????????????????????????????????????????????????????...?????°?????????\n\t\t\tPY[y] = x # y????????¢???x??¨??????\n\t\t\treturn true # ??????????????????????????¢??????????????????????\\???????????????????????????¨?????????\n\t\tend\n\tend\n\treturn false # ??°?????¢?????§???????????£????????§???NG?????????\nend\n\ncount = 0 # ?????¢??°\n\n# ????????§???x??????????????????????????????????????????\nX.times do |x|\n\tcount = count + 1 if match(x)\nend\n\np count"
  },
  {
    "language": "Ruby",
    "code": "INF = 1.0 / 0.0\n\ndef used_edges(sink, pre_node)\n  ans = []\n  p = pre_node[sink]\n  while p != nil\n    v, i = p\n    ans << $node[v][i]\n    p = pre_node[v]\n  end\n  return ans\nend\n\ndef min_cost_flow(source, sink, required_flow)\n  res = 0\n  loop do\n    dist = Array.new($n){INF}\n    dist[source] = 0\n    pre_node = Array.new($n){nil}\n\n    loop do\n      updated = false\n      $n.times{|v|\n        next if dist[v] == INF\n        $node[v].each_with_index{|edge, i|\n          capacity, target, cost = edge[0..2]\n          new_dist = dist[v] + cost\n          if capacity > 0 &&  dist[target] > new_dist\n            dist[target] = new_dist\n            pre_node[target] = [v, i]\n            updated = true\n          end\n        }\n      }\n      break if not updated\n    end\n    return res if dist[sink] == INF\n\n    path = used_edges(sink, pre_node)\n\n    aug = 1\n    res += aug\n    path.each{|e|\n      target,idx = e[1], e[3]\n      e[0] -= aug\n      $node[target][idx][0] += aug\n    }\n  end\nend\n\nx, y, e = gets.split.map(&:to_i)\n\n$n = x+y+2\n$node = Array.new($n){[]}\n\nx.times{|i|\n  s = 0\n  t = i+1\n  ls = $node[s].size\n  lt = $node[t].size\n  $node[s] << [1, t, 0, lt]\n  $node[t] << [0, s, 0, ls]\n}\n\ny.times{|i|\n  s = i+x+1\n  t = x+y+1\n  ls = $node[s].size\n  lt = $node[t].size\n  $node[s] << [1, t, 0, lt]\n  $node[t] << [0, s, 0, ls]\n}\n\n\ne.times{\n  xi, yi = gets.split.map(&:to_i)\n  s = xi + 1\n  t = yi + x + 1\n  ls = $node[s].size\n  lt = $node[t].size\n  $node[s] << [1, t, 1, lt]\n  $node[t] << [0, s,-1, ls]\n}\n\nputs min_cost_flow(0, $n-1, e)"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/env ruby\n\n\n\n$visited = []\n$pre_vertex = []\n\n\ndef min a,b\n  if a<b then return a else b end\nend\n\ndef init_dfs v,e\n  $visited = Array.new(v,false)\n  $pre_vertex = Array.new(v,false)\nend\n\n#b -> e ??§edges\ndef dfs b,e,es\n  es[b].each_with_index do |c,v|\n    if !$visited[v] and c>0 then\n      $visited[v] = true\n      $pre_vertex[v] = b\n      if v==e then\n        return\n      end\n      dfs(v,e,es)\n    end\n  end\nend\n\n\ndef back_trace b,e,es\n  flow =[]\n  min_c = 10e8\n\n  to = e\n  from = $pre_vertex[e]\n  flow=[[from,to]]+flow\n  min_c = min(min_c,es[from][to])\n\n  while from != b\n    to = from\n    from = $pre_vertex[from]\n    flow=[[from,to]]+flow\n    min_c = min(min_c,es[from][to])\n  end\n  return flow,min_c\nend\n\n\n\n#v_size,e_size = gets.chomp.split(/ /).map{|i| i.to_i}\n\nx_size,y_size,e_size = gets.chomp.split(/ /).map{|i| i.to_i}\n\nedges = Array.new(x_size+y_size+2).map{ Array.new(x_size+y_size+2,0)}\n\n\ne_size.times do\n  u,v = gets.chomp.split(/ /).map{|i| i.to_i}\n  edges[u][v] = 1\nend\nx_size.times do |i|\n  edges[x_size+y_size][i] = 1\nend\ny_size.times do |i|\n  edges[i][x_size+y_size+1] = 1\nend\n\n@ans = 0\nv_size = x_size+y_size+2\nloop do\n\n  init_dfs(v_size,e_size)\n  dfs(x_size+y_size,x_size+y_size+1,edges)\n  if $visited[v_size-1] then\n    f,min_c = back_trace(x_size+y_size,x_size+y_size+1,edges)\n    f.each do |i|\n      edges[i[0]][i[1]]-=min_c\n      edges[i[1]][i[0]]+=min_c\n    end\n    @ans = @ans+ min_c\n  else\n    p @ans\n    break\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/env ruby\n\n\n\n$visited = []\n$pre_vertex = []\n\n\ndef min a,b\n  if a<b then return a else b end\nend\n\ndef init_dfs v,e\n  $visited = Array.new(v,false)\n  $pre_vertex = Array.new(v,false)\nend\n\n#b -> e ??§edges\ndef dfs b,e,es\n  es[b].each_with_index do |c,v|\n    if !$visited[v] and c>0 then\n      $visited[v] = true\n      $pre_vertex[v] = b\n      if v==e then\n        return\n      end\n      dfs(v,e,es)\n    end\n  end\nend\n\n\ndef back_trace b,e,es\n  flow =[]\n  min_c = 10e8\n\n  to = e\n  from = $pre_vertex[e]\n  flow=[[from,to]]+flow\n  min_c = min(min_c,es[from][to])\n\n  while from != b\n    to = from\n    from = $pre_vertex[from]\n    flow=[[from,to]]+flow\n    min_c = min(min_c,es[from][to])\n  end\n  return flow,min_c\nend\n\n\n\n#v_size,e_size = gets.chomp.split(/ /).map{|i| i.to_i}\n\nx_size,y_size,e_size = gets.chomp.split(/ /).map{|i| i.to_i}\n\nedges = Array.new(x_size+y_size+2).map{ Array.new(x_size+y_size+2,0)}\n\n\ne_size.times do\n  u,v = gets.chomp.split(/ /).map{|i| i.to_i}\n  edges[u][v] = 1\nend\nx_size.times do |i|\n  edges[x_size+y_size][i] = 1\nend\ny_size.times do |i|\n  edges[i][x_size+y_size+1] = 1\nend\n\n@ans = 0\nv_size = x_size+y_size+2\nloop do\n\n  init_dfs(v_size,e_size)\n  dfs(x_size+y_size,x_size+y_size+1,edges)\n  if $visited[v_size-1] then\n    f,min_c = back_trace(x_size+y_size,x_size+y_size+1,edges)\n    f.each do |i|\n      edges[i[0]][i[1]]=0\n      edges[i[1]][i[0]]=1\n    end\n    @ans = @ans+ min_c\n  else\n    p @ans\n    break\n  end\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar infty = 1000000000\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc nextString() string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc nextInt() int {\n\tn, err := strconv.Atoi(nextString())\n\tif err != nil {\n\t\tfmt.Printf(\"strconv.Atoi failed: %v\\n\", err)\n\t}\n\treturn n\n}\n\ntype DirectedGraphNodeID int\n\nfunc newDirectedGraph(nNodes int) *DirectedGraph {\n\tgraph := DirectedGraph{}\n\n\tgraph.nodes = make([]*DirectedGraphNode, nNodes)\n\tfor iNode := 0; iNode < nNodes; iNode++ {\n\t\tgraph.nodes[iNode] = &DirectedGraphNode{\n\t\t\tkey:       DirectedGraphNodeID(iNode),\n\t\t\tadjacents: map[DirectedGraphNodeID]*DirectedGraphNode{},\n\t\t\tcosts:     map[DirectedGraphNodeID]int{},\n\t\t\tflows:     map[DirectedGraphNodeID]int{},\n\t\t\tvisited:   false,\n\t\t\td:         infty,\n\t\t}\n\t}\n\n\treturn &graph\n}\n\ntype DirectedGraph struct {\n\tnodes []*DirectedGraphNode\n}\n\nfunc (graph *DirectedGraph) sedAdjacent(leftIdx, rightIdx DirectedGraphNodeID, cost int) {\n\tgraph.nodes[leftIdx].adjacents[rightIdx] = graph.nodes[rightIdx]\n\tgraph.nodes[leftIdx].costs[rightIdx] = cost\n\tgraph.nodes[leftIdx].flows[rightIdx] = 0\n}\n\ntype DirectedGraphNode struct {\n\tkey       DirectedGraphNodeID\n\tadjacents map[DirectedGraphNodeID]*DirectedGraphNode\n\tcosts     map[DirectedGraphNodeID]int\n\tflows     map[DirectedGraphNodeID]int\n\n\tparent  *DirectedGraphNode\n\tvisited bool\n\td       int\n\n\tadjacentsForBFS []*DirectedGraphNode\n}\n\ntype QueueEntry struct {\n\tnode *DirectedGraphNode\n\tnext *QueueEntry\n}\n\ntype Queue struct {\n\thead, tail *QueueEntry\n}\n\nfunc (q *Queue) enqueue(node *DirectedGraphNode) {\n\tentry := QueueEntry{}\n\tentry.node = node\n\n\tif q.tail == nil {\n\t\tq.head = &entry\n\t\tq.tail = &entry\n\t\treturn\n\t}\n\n\tq.tail.next = &entry\n\tq.tail = q.tail.next\n}\n\nfunc (q *Queue) dequeue() *QueueEntry {\n\tif q.head == nil {\n\t\treturn nil\n\t}\n\tpoped := q.head\n\tq.head = q.head.next\n\tif q.head == nil {\n\t\tq.tail = nil\n\t}\n\treturn poped\n}\n\nfunc (q *Queue) isEmpty() bool {\n\treturn q.head == nil\n}\n\nfunc getResidualCapacity(u, v *DirectedGraphNode) int {\n\t_, uToV := u.adjacents[v.key]\n\t_, vToU := v.adjacents[u.key]\n\n\tif uToV {\n\t\treturn u.costs[v.key] - u.flows[v.key]\n\t} else if vToU {\n\t\treturn v.flows[u.key]\n\t}\n\treturn 0\n}\n\nfunc fillDistancesByBreadthFirstSearch(graph *DirectedGraph, startNodeID, endNodeID DirectedGraphNodeID) {\n\t// reset\n\tfor _, node := range graph.nodes {\n\t\tnode.parent = nil\n\t\tnode.visited = false\n\t\tnode.d = infty\n\t\tnode.adjacentsForBFS = []*DirectedGraphNode{}\n\t}\n\n\tfor _, u := range graph.nodes {\n\t\tfor _, v := range u.adjacents {\n\t\t\tresidualCapacity1 := getResidualCapacity(u, v)\n\t\t\tif residualCapacity1 > 0 {\n\t\t\t\tu.adjacentsForBFS = append(u.adjacentsForBFS, v)\n\t\t\t}\n\t\t\tresidualCapacity2 := getResidualCapacity(v, u)\n\t\t\tif residualCapacity2 > 0 {\n\t\t\t\tv.adjacentsForBFS = append(v.adjacentsForBFS, u)\n\t\t\t}\n\t\t}\n\t}\n\n\tstartNode := graph.nodes[startNodeID]\n\n\tstartNode.visited = true\n\tstartNode.d = 0\n\n\tqueue := Queue{}\n\tqueue.enqueue(startNode)\n\tfor !queue.isEmpty() {\n\t\tu := queue.dequeue().node\n\t\tfor _, adjacent := range u.adjacentsForBFS {\n\t\t\t// fmt.Println(u.key, \"<->\", adjacent.key)\n\t\t\tif !adjacent.visited {\n\t\t\t\tadjacent.visited = true\n\t\t\t\tadjacent.d = u.d + 1\n\t\t\t\tadjacent.parent = u\n\t\t\t\t// fmt.Println(adjacent.parent.key, \"->\", adjacent.key)\n\t\t\t\tqueue.enqueue(adjacent)\n\t\t\t}\n\t\t}\n\t\tu.visited = true\n\t}\n}\n\nfunc getPathInResidualNetwork(graph *DirectedGraph, startNodeID, endNodeID DirectedGraphNodeID) []*DirectedGraphNode {\n\tfillDistancesByBreadthFirstSearch(graph, startNodeID, endNodeID)\n\n\tstartNode := graph.nodes[startNodeID]\n\tendNode := graph.nodes[endNodeID]\n\tif endNode.parent == nil {\n\t\treturn []*DirectedGraphNode{}\n\t}\n\n\tcurrent := endNode\n\tpath := []*DirectedGraphNode{}\n\tfor {\n\t\tpath = append(path, current)\n\t\tif current == startNode {\n\t\t\tbreak\n\t\t}\n\t\tif current.parent == nil {\n\t\t\treturn []*DirectedGraphNode{}\n\t\t}\n\t\tcurrent = current.parent\n\t}\n\n\tfor i, j := 0, len(path)-1; i < j; i, j = i+1, j-1 {\n\t\tpath[i], path[j] = path[j], path[i]\n\t}\n\n\treturn path\n}\n\nfunc getCriticalPathCost(path []*DirectedGraphNode) int {\n\tminimum := 2 * 10000\n\tfor i := 0; i < len(path)-1; i++ {\n\t\tu := path[i]\n\t\tv := path[i+1]\n\t\tuvCost := getResidualCapacity(u, v)\n\t\tif minimum > uvCost {\n\t\t\tminimum = uvCost\n\t\t}\n\n\t\t// fmt.Print(uvCost, \" \")\n\t}\n\t// fmt.Print(\"\\n\")\n\treturn minimum\n}\n\nfunc fordFulkerson(graph *DirectedGraph, startNodeID, endNodeID DirectedGraphNodeID) {\n\tfor _, l := range graph.nodes {\n\t\tfor _, r := range l.adjacents {\n\t\t\tl.flows[r.key] = 0\n\t\t}\n\t}\n\n\tfor {\n\t\tpath := getPathInResidualNetwork(graph, startNodeID, endNodeID)\n\t\tif len(path) == 0 {\n\t\t\tbreak\n\t\t}\n\n\t\tcostOfCriticalEdge := getCriticalPathCost(path)\n\n\t\t// for _, v := range path {\n\t\t// \tfmt.Print(v.key, \" \")\n\t\t// }\n\t\t// fmt.Print(\"\\n\")\n\t\t// fmt.Println(costOfCriticalEdge)\n\n\t\tfor i := 0; i < len(path)-1; i++ {\n\t\t\tu := path[i]\n\t\t\tv := path[i+1]\n\t\t\tif u.costs[v.key] > 0 {\n\t\t\t\tu.flows[v.key] += costOfCriticalEdge\n\t\t\t} else {\n\t\t\t\tv.flows[u.key] -= costOfCriticalEdge\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\n\tnLeftNodes := nextInt()\n\tnRightNodes := nextInt()\n\tnEdges := nextInt()\n\n\tgraph := newDirectedGraph(nLeftNodes + nRightNodes + 2)\n\tstartNodeID := DirectedGraphNodeID(nLeftNodes + nRightNodes)\n\tendNodeID := DirectedGraphNodeID(startNodeID + 1)\n\n\tfor iEdge := 0; iEdge < nEdges; iEdge++ {\n\t\tleftNodeID := DirectedGraphNodeID(nextInt())\n\t\trightNodeID := DirectedGraphNodeID(nextInt() + nLeftNodes)\n\t\tgraph.sedAdjacent(startNodeID, leftNodeID, 1)\n\t\tgraph.sedAdjacent(leftNodeID, rightNodeID, 1)\n\t\tgraph.sedAdjacent(rightNodeID, endNodeID, 1)\n\t}\n\n\tfordFulkerson(graph, startNodeID, endNodeID)\n\n\ttotalFlow := 0\n\tfor _, f := range graph.nodes[startNodeID].flows {\n\t\ttotalFlow += f\n\t}\n\n\tfmt.Println(totalFlow)\n}\n\n"
  },
  {
    "language": "D",
    "code": "// https://beta.atcoder.jp/contests/abc091/tasks/arc092_a\nimport std.stdio, std.algorithm, std.string, std.conv, std.array, std.range, std.math;\nint readint() { return readln.chomp.to!int; }\nint[] readints() { return readln.split.to!(int[]); }\n\nimmutable int INF = 114514810;\nimmutable int VMAX = 300;\n\n// ari 196\nstruct Edge {\n    int to, cap, rev;\n}\nEdge[][] G;\nbool[] used; // dfs したか\n\n// 増加パスを探す\nint dfs(int v, int t, int f) {\n    if (v == t) return f;\n    used[v] = true;\n    foreach (ref e; G[v]) if (!used[e.to] && e.cap > 0) {\n        int d = dfs(e.to, t, min(f, e.cap));\n        if (d > 0) {\n            e.cap -= d;\n            G[e.to][e.rev].cap += d;\n            return d;\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s, int t) {\n    int flow;\n    used.length = VMAX;\n    while (1) {\n        fill(used, false);\n        int f = dfs(s, t, INF);\n        if (f == 0) return flow;\n        flow += f;\n    }\n    assert(false);\n}\n\nvoid add_edge(int from, int to, int cap) {\n    G[from] ~= Edge(to, cap, G[to].length.to!int);\n    G[to]   ~= Edge(from, 0, G[from].length.to!int - 1);\n}\n\nvoid main() {\n    G.length = VMAX;\n    int X, Y, E;\n    readf(\"%d %d %d\\n\", &X, &Y, &E);\n    foreach (_; 0..E) {\n        int x, y; readf(\"%d %d\\n\", &x, &y);\n        add_edge(x, X + y, 1);\n    }\n    int s = X + Y, t = s + 1;\n    foreach (to; 0..X)\n        add_edge(s, to, 1);\n    foreach (from; X..X + Y)\n        add_edge(from, t, 1);\n\n    writeln(max_flow(s, t));\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.algorithm, std.conv, std.array, std.string, std.math, std.typecons, std.numeric;\n\nstruct Graph(T)\n{\n    T L, R;\n    T[][] adj;\n\n    this(T L, T R)\n    {\n        this.L = L;\n        this.R = R;\n        adj.length = L + R;\n    }\n\n    void add_edge(T u, T v)\n    {\n        adj[u] ~= v+L;\n        adj[v+L] ~= u;\n    }\n\n    T maximum_matching()\n    {\n        bool[] visited;\n        T[] meta;\n        visited.length = L;\n        meta.length = L + R;\n        meta[] = -1;\n\n        bool augment(T u) {\n            if (visited[u]) return false;\n            visited[u] = true;\n            foreach (w; adj[u]) {\n                auto v = meta[w];\n                if (v < 0 || augment(v)) {\n                    meta[u] = w;\n                    meta[w] = u;\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        auto match = 0;\n        foreach (u; 0..L) {\n            visited[] = false;\n            if (augment(u)) ++match;\n        }\n        return match;\n    }\n}\n\nvoid main()\n{\n    auto xye = readln.split.to!(int[]);\n    auto X = xye[0];\n    auto Y = xye[1];\n    auto E = xye[2];\n\n    auto G = Graph!int(X, Y);\n    foreach (_; 0..E) {\n        auto xy = readln.split.to!(int[]);\n        G.add_edge(xy[0], xy[1]);\n    }\n    writeln(G.maximum_matching());\n}\n"
  },
  {
    "language": "D",
    "code": "// https://beta.atcoder.jp/contests/abc091/tasks/arc092_a\nimport std.stdio, std.algorithm, std.string, std.conv, std.array, std.range, std.math;\nint readint() { return readln.chomp.to!int; }\nint[] readints() { return readln.split.to!(int[]); }\n\nvoid main() {\n    auto bm = new BipartiteMatching();\n    int X, Y, E;\n    readf(\"%d %d %d\\n\", &X, &Y, &E);\n    foreach (_; 0..E) {\n        int x, y; readf(\"%d %d\\n\", &x, &y);\n        bm.add_edge(x, X + y, 1);\n    }\n    int s = X + Y, t = s + 1;\n    foreach (to; 0..X)\n        bm.add_edge(s, to, 1);\n    foreach (from; X..X + Y)\n        bm.add_edge(from, t, 1);\n\n    writeln(bm.max_flow(s, t));\n\n    auto _ = readln(); // dbg\n}\n\nclass BipartiteMatching {\n    immutable int INF = 114514810;\n    immutable int VMAX = 300;\n\n    struct Edge { int to, cap, rev; }\n    Edge[][] G;\n    bool[] used; // dfs したか\n\n    this() {\n        used.length = G.length = VMAX;\n    }\n\n    void add_edge(int from, int to, int cap) {\n        G[from] ~= Edge(to, cap, G[to].length.to!int);\n        G[to]   ~= Edge(from, 0, G[from].length.to!int - 1);\n    }\n    // 増加パスを探す\n    int dfs(int v, int t, int f) {\n        if (v == t) return f;\n        used[v] = true;\n        foreach (ref e; G[v]) if (!used[e.to] && e.cap > 0) {\n            int d = dfs(e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n        return 0;\n    }\n    int max_flow(int s, int t) {\n        int flow;\n        while (1) {\n            fill(used, false);\n            int f = dfs(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n        assert(false);\n    }\n}\n"
  },
  {
    "language": "Python",
    "code": "#フローに帰着、dinic法,dinic法は蟻本\nimport sys\nfrom collections import deque\n\nsys.setrecursionlimit(200000)\n\nclass Dinic:\n    \n    def __init__(self,v, inf =10**10):\n        self.v = v\n        self.inf = inf\n        self.G = [[] for _ in range(v)]\n        self.level = [-1]*v#深さ\n        self.ite = [0]*v#DFSでの探索が済んでいるか否か\n    \n    def add_edge(self, fr, to, cap):#末尾はself.G[to]から対応する辺のself.G[fr]内でのindex\n        self.G[fr].append([to,cap,len(self.G[to])])###{'to':to,\"cap\":cap,\"rev\";len(self.G[to})}みたいにしたほうがいいか\n        self.G[to].append([fr,0,len(self.G[fr])-1])\n\n    \n    def bfs(self,s):#BFSで深さ決定,sがstart\n        self.level = [-1]*self.v#必要\n        self.level[s] = 0\n        Q = deque()\n        Q.append(s)\n        while Q:\n            v = Q.popleft()\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if e[1]>0 and self.level[e[0]]<0:###capacity>0かつtoの深さ未定\n                    self.level[e[0]] = self.level[v]+1\n                    Q.append(e[0])\n\n        \n    def dfs(self,v,t,f):#DFSで増加パス探索,v開始、t終点、総フローf\n        if v==t:\n            return f\n        for i in range(self.ite[v],len(self.G[v])):\n            self.ite[v] = i\n            e = self.G[v][i]\n            if e[1]>0 and self.level[v]<self.level[e[0]]:\n                d = self.dfs(e[0],t,min(f,e[1]))\n                if d>0:\n                    e[1] -= d #cap減少\n                    self.G[e[0]][e[2]][1] += d#逆辺のcap増加\n                    return d\n        return 0\n    \n    def max_flow(self,s,t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t]<0:\n                return flow\n            self.ite = [0]*self.v#DFSでの探索が済んでいるか否か\n            f =self.dfs(s,t,self.inf)\n            while f>0:\n                flow+= f\n                f = self.dfs(s,t,self.inf)\n            \nx,y,e = map(int, input().split( ))\nD = Dinic(x+y+2)\nfor _ in range(e):\n    u,w = map(int, input().split( ))\n    D.add_edge(u,w+x,1)\nfor i in range(x+y):\n    if i<x:\n        D.add_edge(x+y,i,1)\n    else:\n        D.add_edge(i,x+y+1,1)\nans = D.max_flow(x+y,x+y+1)\nprint(ans)\n\n\n        \n                    \n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\na_num, b_num, e_num = (int(n) for n in input().split(\" \"))\nconnect = defaultdict(list)\nall_v = a_num + b_num\nmatch = [0 for n in range(all_v)]\nused = [0 for n in range(all_v)]\nfor _ in range(e_num):\n    v1, v2 = (int(n) for n in input().split(\" \"))\n    v2 += a_num + 1\n    connect[v1].append(v2)\n    connect[v2].append(v1)\ndef dfs(here,used,match,connect):\n    used[here] = 1\n    for near in connect[here]:\n        if not match[near] or (not used[near] and dfs(near,used,match,connect)):\n            match[here] = near\n            match[near] = here\n            return 1\n    return 0\n\n\nanswer = 0\nfor i in range(all_v):\n    if not match[i] and dfs(i,used,match,connect):\n        answer += 1\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef dfs(here,used,match,connect):\n    used[here] = 1\n    for near in connect[here]:\n        m = match[near]\n        if m < 0 or (not used[m] and dfs(m,used,match,connect)):\n            match[here] = near\n            match[near] = here\n            return 1\n    return 0\n\na_num, b_num, e_num = (int(n) for n in input().split(\" \"))\nconnect = defaultdict(list)\nall_v = a_num + b_num\nmatch = [-1 for n in range(all_v)]\nfor _ in range(e_num):\n    v1, v2 = (int(n) for n in input().split(\" \"))\n    v2 += a_num\n    connect[v1].append(v2)\n    connect[v2].append(v1)\nanswer = 0\nfor i in range(all_v):\n    if match[i] < 0:\n        if dfs(i,used,match,connect):\n            used = [0 for n in range(all_v)]\n            answer += 1\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n# from collections import deque\n\n\ndef generate_adj_table(_edges):\n    for edge in _edges:\n        source, target = map(int, edge)\n        target += x_num\n        init_adj_table[source].append(target)\n        init_adj_table[target].append(source)\n\n    return init_adj_table\n\n\ndef graph_bfs_Hungarian():\n    ans = 0\n    queue = list()\n    prev, matching = ([-1] * v_num for _ in range(2))\n    visited = [False] * v_num\n\n    for v in range(x_num):\n        if matching[v] == -1:\n            while queue:\n                queue.pop()\n            queue.append(v)\n            prev[v] = -1\n            flag = False\n            while queue and not flag:\n                current = queue[0]\n                for adj in adj_table[current]:\n                    if not flag:\n                        if not visited[adj]:\n                            visited[adj] = True\n                            queue.append(matching[adj])\n                            if matching[adj] >= 0:\n                                prev[matching[adj]] = current\n                            else:\n                                flag = True\n                                # print(current, adj)\n                                d, e = current, adj\n                                while d != -1:\n                                    t = matching[d]\n                                    matching[d] = e\n                                    matching[e] = d\n                                    d = prev[d]\n                                    e = t\n\n                queue.pop()\n\n            if matching[v] != -1:\n                ans += 1\n\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    v_num = x_num + y_num\n    init_adj_table = [[] for _ in range(v_num)]\n    adj_table = generate_adj_table(edges)\n    print(graph_bfs_Hungarian())"
  },
  {
    "language": "Python",
    "code": "a_num, b_num, e_num = (int(n) for n in input().split(\" \"))\nconnect = defaultdict(list)\nall_v = a_num + b_num\nmatch = [0 for n in range(all_v)]\nused = [0 for n in range(all_v)]\nfor _ in range(e_num):\n    v1, v2 = (int(n) for n in input().split(\" \"))\n    v2 += a_num + 1\n    connect[v1].append(v2)\n    connect[v2].append(v1)\ndef dfs(here,used,match,connect):\n    used[here] = 1\n    for near in connect[here]:\n        if not match[near] or (not used[near] and dfs(near,used,match,connect)):\n            match[here] = near\n            match[near] = here\n            return 1\n    return 0\n\n\nanswer = 0\nfor i in range(all_v):\n    if not match[i] and dfs(i,used,match,connect):\n        answer += 1\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import defaultdict\nreadline = stdin.readline\n\n\n\ndef main():\n    x, y, e = map(int, readline().split())\n    g = defaultdict(list)\n    residual = [[0] * (x + y + 2) for _ in range(x + y + 2)]\n    source, sink = x + y, x + y + 1\n    # source->x\n    for xi in range(x):\n        g[source].append(xi)\n        residual[source][xi] = 1\n    # y->sink\n    for yi in range(x, x + y):\n        g[yi].append(sink)\n        residual[yi][sink] = 1\n    # x <-> y\n    for _ in range(e):\n        s, t = map(int, readline().split())\n        t += x\n        g[s].append(t)\n        g[t].append(s)\n        residual[s][t] = 1\n\n    while True:\n        route, flow = search(g, residual, source, sink)\n        if not route:\n            break\n        for s, t in zip(route, route[1:]):\n            residual[s][t] -= flow\n            residual[t][s] += flow\n    print(sum(residual[sink]))\n\n\ndef search(g, residual, source, sink):\n    dfs_stack = [(source, None, float('inf'))]\n    route = [None]\n    visited = set()\n    while dfs_stack:\n        u, prev, flow = dfs_stack.pop()\n        while route[-1] != prev:\n            route.pop()\n        route.append(u)\n        visited |= {u}\n        if u == sink:\n            return route[1:], flow\n        for v in g[u]:\n            if v not in visited and 0 < residual[u][v]:\n                dfs_stack.append((v, u, min(residual[u][v], flow)))\n    return [], 0\nmain()"
  },
  {
    "language": "Python",
    "code": "import sys,collections\nsys.setrecursionlimit(100000)\n\nINF = float(\"inf\")\n\nX,Y,E = map(int,sys.stdin.readline().split())\nxy = tuple(tuple(map(int,sys.stdin.readline().rstrip().split())) for _ in range(E)) # multi line with multi param\n#uvc = [[0,1,1],[0,2,3],[1,2,1],[2,3,2]]\nV = X+Y+2\nuvc = [[x+1,y+X+1,1] for x,y in xy]\nfor i in range(X):\n    uvc.append([0,i+1,1])\nfor i in range(Y):\n    uvc.append([X+i+1,V-1,1])\nG = {i:{} for i in range(V)}\nmG = {i:{} for i in range(V)}\n\nfor u,v,c in uvc:\n    G[u][v] = c\n    G[v][u] = 0 # reverse edge\n    mG[u][v] = 0\n    mG[v][u] = 0\n# print(G)\n# print(mG)\ndef dfs(current,flow):\n    if current == V-1:\n        return flow\n    visited.add(current)\n    for nex,nex_c in G[current].items():\n        if not nex in visited and nex_c != 0:\n            f = dfs(nex,min(flow,nex_c))\n            if f != 0:\n                mG[current][nex] = mG[current][nex] + f\n                G[current][nex] = G[current][nex] - f\n                G[nex][current] = G[nex][current] + f\n                return f\n    return 0\n\nvisited = set()\nwhile dfs(0,INF) != 0:\n    visited = set()\n    # print(\"mG:\",mG)\n    # print(\"G:\",G)\n    pass\nprint(sum(mG[0].values()))\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef dfs(current, matching, visited):\n    for target in range(y_num):\n        if not visited[target] and target in adj_table[current]:\n            visited[target] = True\n            ''' Matching[target] = -1: target not assigned to any of x.\n            And dfs(matching[target], matching, visited) = True\n            indicates that source in x has been already assigned\n            to another target in y. '''\n            if matching[target] == -1 or dfs(matching[target], matching, visited):\n                matching[target] = current\n                return True\n    return False\n\n\ndef mbm():\n    res = 0\n    matching = [-1] * y_num\n    for source in range(x_num):\n        visited = [False] * y_num\n        if dfs(source, matching, visited):\n            res += 1\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    adj_table = tuple(set() for _ in range(x_num))\n    for edge in edges:\n        vx, vy = map(int, edge)\n        adj_table[vx].add(vy)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "xn, yn, e = map(int, input().split())\nedges = [set() for _ in range(xn)]\nmatched = [-1] * yn\n\ndef dfs(v, visited):\n    for u in edges[v]:\n        if u in visited:\n            continue\n        visited.add(u)\n        if matched[u] == -1 or dfs(matched[u], visited):\n            matched[u] = v\n            return True\n    return False\n\nfor _ in range(e):\n    x, y = map(int, input().split())\n    edges[x].add(y)\n\nprint(sum(dfs(s, set()) for s in range(xn)))\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.buffer.readline\nsys.setrecursionlimit(10 ** 7)\n\n\nclass BipartiteMatching:\n    def __init__(self, N, M):\n        self.N = N\n        self.M = M\n        self.pairA = [-1] * N\n        self.pairB = [-1] * M\n        self.edge = [[] for _ in range(N)]\n        self.was = [0] * N\n        self.iter = 0\n\n    def add(self, s, t):\n        self.edge[s].append(t)\n\n    def _DFS(self, s):\n        self.was[s] = self.iter\n        for t in self.edge[s]:\n            if self.pairB[t] == -1:\n                self.pairA[s] = t\n                self.pairB[t] = s\n                return True\n        for t in self.edge[s]:\n            if self.was[self.pairB[t]] != self.iter and self._DFS(self.pairB[t]):\n                self.pairA[s] = t\n                self.pairB[t] = s\n                return True\n        return False\n\n    def solve(self):\n        res = 0\n        while True:\n            self.iter += 1\n            found = 0\n            for i in range(self.N):\n                if self.pairA[i] == -1 and self._DFS(i):\n                    found += 1\n            if not found:\n                break\n            res += found\n        return res\n\n\nif __name__ == \"__main__\":\n    X, Y, E = map(int, input().split())\n    match = BipartiteMatching(X, Y)\n    for _ in range(E):\n        x, y = map(int, input().split())\n        match.add(x, y)\n    ans = match.solve()\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef generate_adj_table(_edges):\n    for edge in _edges:\n        vx, vy = map(int, edge)\n        init_adj_table[vx].append(vy)\n\n    return init_adj_table\n\n\ndef graph_dfs(current, matching, visited):\n    for adj in range(y_num):\n        if (not visited[adj]) and adj in adj_table[current]:\n            visited[adj] = True\n            if matching[adj] == -1 or graph_dfs(matching[adj], matching, visited):\n                matching[adj] = current\n                return True\n    return False\n\n\ndef mbm():\n    matching = [-1] * y_num\n    res = 0\n    for v in range(x_num):\n        visited = [False] * y_num\n        if graph_dfs(v, matching, visited):\n            res += 1\n    # print(matching)\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    init_adj_table = [[] for _ in range(x_num)]\n    adj_table = generate_adj_table(edges)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nclass MaxFlow:\n    class Edge:\n        def __init__(self,to,cap,rev):\n            self.to = to\n            self.cap = cap\n            self.rev = rev\n\n    def __init__(self,n,inf = 10**9+7):\n        self.n = n\n        self.inf = inf\n        self.level = [-1]*n\n        self.iter = [0]*n\n        self.e = [[] for _ in range(n)]\n\n    def add_edge(self, from_, to, cap):\n        self.e[from_].append(self.Edge(to, cap, len(self.e[to])))\n        self.e[to].append(self.Edge(from_, 0, len(self.e[from_])-1))\n\n    def bfs(self, start):\n        self.level = [-1]*self.n\n        dq = deque()\n        self.level[start] = 0\n        dq.append(start)\n        while dq:\n            cur_vertex = dq.popleft()\n            for edge in self.e[cur_vertex]:\n                if edge.cap > 0 > self.level[edge.to]:\n                    self.level[edge.to] = self.level[cur_vertex] + 1\n                    dq.append(edge.to)\n\n    def dfs(self, cur_vertex, end_vertex, flow):\n        if cur_vertex == end_vertex:return flow\n        while self.iter[cur_vertex] < len(self.e[cur_vertex]):\n            edge = self.e[cur_vertex][self.iter[cur_vertex]]\n            if edge.cap > 0 and self.level[cur_vertex] < self.level[edge.to]:\n                flowed = self.dfs(edge.to, end_vertex, min(flow, edge.cap))\n                if flowed > 0:\n                    edge.cap -= flowed\n                    self.e[edge.to][edge.rev].cap += flowed\n                    return flowed\n            self.iter[cur_vertex] += 1\n        return 0\n\n    def compute(self, source, sink):\n        flow = 0\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:return flow\n            self.iter = [0]*self.n\n            while True:\n                f = self.dfs(source, sink, self.inf)\n                if f == 0:break\n                flow += f\n\ndef main():\n    x,y,e = map(int,input().split())\n    mf = MaxFlow(x+y+2)\n    s = x+y\n    t = s+1\n    for _ in range(e):\n        a,b = map(int,input().split())\n        mf.add_edge(a,b+x,1)\n    for i in range(x):\n        mf.add_edge(s,i,1)\n    for i in range(y):\n        mf.add_edge(i+x,t,1)\n    print (mf.compute(s,t))\n\n\nif __name__ == '__main__':\n    main()\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\na_num, b_num, e_num = (int(n) for n in input().split(\" \"))\nconnect = defaultdict(list)\nall_v = a_num + b_num\nmatch = [0 for n in range(all_v)]\nfor _ in range(e_num):\n    v1, v2 = (int(n) for n in input().split(\" \"))\n    v2 += a_num + 1\n    connect[v1].append(v2)\n    connect[v2].append(v1)\ndef dfs(here,used,match,connect):\n    used[here] = 1\n    for near in connect[here]:\n        m = match[near]\n        if m < 0 or (not used[m] and dfs(m,used,match,connect)):\n            match[here] = near\n            match[near] = here\n            return 1\n    return 0\n\nanswer = 0\nfor i in range(all_v):\n    if match[i] < 0:\n        if dfs(i,used,match,connect):\n            used = [0 for n in range(all_v)]\n            answer += 1\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# GRL_7_A: Matching - Bipertite Matching\n\n\nfrom heapq import heappush, heappop\n\n\nclass Edge:\n    __slots__ = ('src', 'dest', 'capacity', 'flow', 'cost')\n\n    def __init__(self, v, w, capacity, cost=0):\n        self.src = v\n        self.dest = w\n        self.capacity = capacity\n        self.cost = cost\n        self.flow = 0\n\n    def other(self, v):\n        if v == self.src:\n            return self.dest\n        else:\n            return self.src\n\n    def residual_capacity(self, v):\n        if v == self.src:\n            return self.capacity - self.flow\n        else:\n            return self.flow\n\n    def cost_from(self, v):\n        if v == self.src:\n            return self.cost\n        else:\n            return -self.cost\n\n    def add_flow(self, v, f):\n        if v == self.src:\n            self.flow += f\n        else:\n            self.flow -= f\n\n    def __str__(self):\n        return \"{} {} {} {} {}\".format(self.src, self.dest, self.capacity,\n                                       self.cost, self.flow)\n\n\nclass Network:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, edge):\n        self._edges[edge.src].append(edge)\n        self._edges[edge.dest].append(edge)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def flow(self, v):\n        return sum(e.flow for e in self.adj(v) if e.src == v)\n\n    def cost(self):\n        cost = 0\n        for v in range(self.v):\n            for e in self.adj(v):\n                if e.src == v:\n                    cost += e.flow * e.cost\n        return cost\n\n    def __str__(self):\n        s = ''\n        for v in range(self.v):\n            for e in self.adj(v):\n                s += \"{} {}\\n\".format(v, e)\n\n        return s\n\n\ndef max_flow(network, s, t):\n    def augment_path():\n        marked = [False] * network.v\n        edge_to = [None] * network.v\n        n = 0\n        heap = [(-10**6, s, n, None)]\n        while heap:\n            cap, v, _, e = heappop(heap)\n            edge_to[v] = e\n            if v == t:\n                return (-cap, edge_to)\n            if not marked[v]:\n                marked[v] = True\n                for ne in network.adj(v):\n                    n += 1\n                    w = ne.other(v)\n                    c = ne.residual_capacity(v)\n                    if not marked[w] and c > 0:\n                        heappush(heap, (max(-c, cap), w, n, ne))\n\n        return (0, [])\n\n    while True:\n        cap, path = augment_path()\n        if cap == 0:\n            break\n        v = t\n        e = path[t]\n        while e is not None:\n            v = e.other(v)\n            e.add_flow(v, cap)\n            e = path[v]\n\n    return network.flow(s)\n\n\ndef run():\n    n, m, e = [int(i) for i in input().split()]\n    s, t = 0, n+m+1\n    net = Network(n+m+2)\n    for i in range(n):\n        net.add(Edge(s, i+1, 1))\n    for j in range(m):\n        net.add(Edge(j+1+n, t, 1))\n\n    for _ in range(e):\n        x, y = [int(i) for i in input().split()]\n        edge = Edge(x+1, y+1+n, 1)\n        net.add(edge)\n\n    print(max_flow(net, s, t))\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef dfs(current, matching, visited):\n    for target in range(y_num):\n        if not visited[target] and target in adj_table[current]:\n            visited[target] = True\n            ''' Matching[target] = -1: target not assigned to any of x.\n            And dfs(matching[target], matching, visited) = True\n            indicates that source in x has been already assigned\n            to another target in y. '''\n            if matching[target] == -1 or dfs(matching[target], matching, visited):\n                matching[target] = current\n                return True\n    return False\n\n\ndef mbm():\n    res = 0\n    matching = [-1] * y_num\n    for source in range(x_num):\n        visited = [False] * y_num\n        if dfs(source, matching, visited):\n            res += 1\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    adj_table = tuple([] for _ in range(x_num))\n    for edge in edges:\n        vx, vy = map(int, edge)\n        adj_table[vx].append(vy)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef dfs(here):\n    used[here] = 1\n    for near in connect[here]:\n        if not match[near] or (not used[near] and dfs(near)):\n            match[here] = near\n            match[near] = here\n            return 1\n        return 0\n    \na_num, b_num, e_num = (int(n) for n in input().split(\" \"))\nconnect = defaultdict(list)\nall_v = a_num + b_num\nmatch = [0 for n in range(all_v)]\nused = [0 for n in range(all_v)]\nfor _ in range(e_num):\n    v1, v2 = (int(n) for n in input().split(\" \"))\n    v2 += a_num + 1\n    connect[v1].append(v2)\n    connect[v2].append(v1)\nanswer = 0\nfor i in range(all_v):\n    if not match[i] and dfs(i):\n        answer += 1\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "class BipartiteMatching:\n    def __init__(self, V):\n        self.V = V\n        self.G = [[] for _ in range(V)]\n\n    def add_edge(self, u, v):\n        self.G[u].append(v)\n        self.G[v].append(u)\n\n    def dfs(self, u):\n        self.used[u] = True\n        for v in self.G[u]:\n            w = self.match[v]\n            if w < 0 or (not self.used[w] and self.dfs(w)):\n                self.match[u] = v\n                self.match[v] = u\n                return True\n        return False\n\n    def bipartite_matching(self):\n        res = 0\n        self.match = [-1] * self.V\n        for v in range(self.V):\n            if self.match[v] == -1:\n                self.used = [False] * self.V\n                if self.dfs(v):\n                    res += 1\n        return res\n\nX, Y, E = map(int, input().split())\nbm = BipartiteMatching(X+Y)\nfor _ in range(E):\n    x, y = map(int, input().split())\n    bm.add_edge(x, X + y)\nprint(bm.bipartite_matching())\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nMatching - Bipartite Matching\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_7_A&lang=jp\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import namedtuple\ninput = stdin.readline\nedge = namedtuple('edge', ['to', 'cap', 'rev'])\n\n\ndef add_edge(G, f, t, c):\n    G[f].append(edge(t, c, len(G[t])))\n    G[t].append(edge(f, 0, len(G[f]) - 1))\n\n\ndef dfs(G, used, v, t, f):\n    if v == t:\n        return f\n    used[v] = True\n    for i in range(len(G[v])):\n        e = G[v][i]\n        if (not used[e.to]) and (e.cap > 0):\n            d = dfs(G, used, e.to, t, min(f, e.cap))\n            if d > 0:\n                G[v][i] = edge(e.to, e.cap - d, e.rev)\n                G[e.to][e.rev] = edge(G[e.to][e.rev].to, G[e.to][e.rev].cap + d, G[e.to][e.rev].rev)\n                return d\n    return 0\n\n\ndef max_flow(G, V, s, t):\n    flow = 0\n    while True:\n        used = [False] * V\n        f = dfs(G, used, s, t, float('inf'))\n        if f == 0:\n            return flow\n        flow += f\n\n\ndef main(args):\n    \"\"\"\n    - 追加したソースノードID: 0\n    - Xグループ: 1〜X\n    - Yグループ: X+1〜X+Y\n    - 追加したシンクノードID: X+Y+1\n    として、ノード0 → X+Y+1 への最大流を求める\n    \"\"\"\n    X, Y, E = map(int, input().split())\n    G = [[] for _ in range(X+Y+2)]\n\n    for li in range(E):\n        x, y = map(int, input().split())\n        add_edge(G, x+1, X+y+1, 1)\n\n    for x in range(1, X+1):\n        add_edge(G, 0, x, 1)       # ソースから集合X\n    for y in range(X+1, X+Y+1):\n        add_edge(G, y, X+Y+1, 1)   # 集合Yからシンク\n\n\n    ans = max_flow(G, X+Y+2, 0, X+Y+1) #  ソースとシンク間の最大流\n    print(ans)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n\n\n"
  },
  {
    "language": "Python",
    "code": "import collections\nimport queue\n\n\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.edges = collections.defaultdict(list)\n        self.level = [0 for _ in range(self.N)]\n        self.iter = [0 for _ in range(self.N)]\n\n    def add(self, u, v, c, directed=True):\n        \"\"\"\n        0-indexed\n        u = from, v = to, c = cap\n        directed = Trueなら、有向グラフである\n        \"\"\"\n        if directed:\n            self.edges[u].append([v, c, len(self.edges[v])])\n            self.edges[v].append([u, 0, len(self.edges[u])-1])\n        else:  # TODO\n            self.edges[u].append([v, c, len(self.edges[u])])\n\n    def bfs(self, s):\n        self.level = [-1 for _ in range(self.N)]\n        self.level[s] = 0\n        que = queue.Queue()\n        que.put(s)\n        while not que.empty():\n            v = que.get(s)\n            for i in range(len(self.edges[v])):\n                e = self.edges[v][i]\n                if e[1] > 0 and self.level[e[0]] < 0:\n                    self.level[e[0]] = self.level[v] + 1\n                    que.put(e[0])\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        for i in range(self.iter[v], len(self.edges[v])):\n            self.iter[v] = i\n            e = self.edges[v][i]\n            if e[1] > 0 and self.level[v] < self.level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d > 0:\n                    e[1] -= d\n                    self.edges[e[0]][e[2]][1] += d\n                    return d\n        return 0\n\n    def maxFlow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t] < 0:\n                return flow\n            self.iter = [0 for _ in range(self.N)]\n            f = self.dfs(s, t, float('inf'))\n            while f > 0:\n                flow += f\n                f = self.dfs(s, t, float('inf'))\n\n\nX, Y, E = map(int, input().split())\n\ngraph = Dinic(X+Y+2)\ns = X+Y\nt = X+Y+1\nfor i in range(X):\n    graph.add(s, i, 1)\n\nfor i in range(Y):\n    graph.add(X+i, t, 1)\n\nfor _ in range(E):\n    x, y = map(int, input().split())\n    graph.add(x, X+y, 1)\n\nprint(graph.maxFlow(s, t))\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\nfrom collections import deque\n\n\ndef generate_adj_table(_edges):\n    for edge in _edges:\n        vx, vy = map(int, edge)\n        # vy += x_num\n        init_adj_table[vx].append(vy)\n        # init_adj_table[vy].append(vx)\n\n    return init_adj_table\n\n\ndef graph_bfs_Hungarian():\n    ans = 0\n    queue = list()\n    prev = [-1] * y_num\n    matching = [-1] * y_num\n\n    for v in range(x_num):\n        visited = [False] * y_num\n        if matching[v] == -1:\n            while queue:\n                queue.pop()\n            queue.append(v)\n            prev[v] = -1\n            flag = False\n            while queue and not flag:\n                current = queue[0]\n                for adj in adj_table[current]:\n                    if not flag:\n                        if not visited[adj]:\n                            visited[adj] = True\n                            queue.append(matching[adj])\n                            if matching[adj] >= 0:\n                                prev[matching[adj]] = current\n                            else:\n                                flag = True\n                                d, e = current, adj\n                                while d != -1:\n                                    t = matching[d]\n                                    matching[d] = e\n                                    # matching[e] = d\n                                    d = prev[d]\n                                    e = t\n\n                queue.pop()\n\n            if matching[v] != -1:\n                ans += 1\n\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    # v_num = x_num + y_num\n    init_adj_table = [[] for _ in range(x_num)]\n    adj_table = generate_adj_table(edges)\n    print(graph_bfs_Hungarian())"
  },
  {
    "language": "Python",
    "code": "# AOJ GRL_7_A \"Bipartite Matching\"\n# O(VE)\n\nclass BipartiteMatching():\n    def __init__(self, V1, V2):\n        self.V1 = V1\n        self.V2 = V2\n        self.V = V1 + V2\n        self.graph = [[] for _ in range(V1+V2)]\n    \n    def add_edge(self, v1, v2):\n        v2 += self.V1\n        self.graph[v1].append(v2)\n        self.graph[v2].append(v1)\n\n    # search increasing path\n    def dfs(self, s):\n        self.par = [None]*self.V\n        self.used = [False]*self.V\n        self.used[s] = True\n        self.stack = [s]\n        while self.stack:\n            v = self.stack.pop()\n            for nv in self.graph[v]:\n                w = self.match[nv]\n                if w < 0:\n                    while True:\n                        self.match[v] = nv\n                        self.match[nv] = v\n                        if v == s: return True\n                        v, nv = self.par[v]\n                elif not self.used[w]:\n                    self.par[w] = (v, nv)\n                    self.used[w] = True\n                    self.stack.append(w)\n        return False\n\n    def bipartite_matching(self):\n        res = 0\n        self.match = [-1]*self.V\n        for v in range(self.V):\n            if self.match[v] < 0:\n                if self.dfs(v):\n                    res += 1\n        return res\n\n\nif __name__ == '__main__':\n    import sys\n    input = sys.stdin.readline\n\n    V1, V2, E = map(int, input().split())\n    bm = BipartiteMatching(V1, V2)\n    for _ in range(E):\n        a, b = map(int, input().split())\n        bm.add_edge(a, b)\n    print(bm.bipartite_matching())\n"
  },
  {
    "language": "Python",
    "code": "from typing import Set\n\n\ndef dfs(s: int) -> bool:\n    return _dfs(s, set())\n\n\ndef _dfs(v: int, visited: Set[int]) -> bool:\n    for u in edges[v]:\n        if u in visited:\n            continue\n        visited.add(u)\n        if matched[u] == -1 or _dfs(matched[u], visited):\n            matched[u] = v\n            return True\n    return False\n\n\nif __name__ == \"__main__\":\n    xn, yn, e = map(lambda x: int(x), input().split())\n    edges = [set() for _ in range(xn)]  # type: ignore\n    matched = [-1] * yn\n\n    for _ in range(e):\n        x, y = map(lambda x: int(x), input().split())\n        edges[x].add(y)\n\n    print(sum(map(dfs, range(xn))))\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef generate_adj_table(_edges):\n    for edge in _edges:\n        vx, vy = map(int, edge)\n        init_adj_table[vx].add(vy)\n\n    return init_adj_table\n\n\ndef graph_dfs(current, matching, visited):\n    for adj in range(y_num):\n        if (not visited[adj]) and (adj in adj_table[current]):\n            visited[adj] = True\n            # matching[adj] = -1: adj not assigned to any of x\n            # graph_dfs(matching[adj], matching, visited) = True\n            # indicates that source in x has been already assigned to another target in y\n            if matching[adj] == -1 or graph_dfs(matching[adj], matching, visited):\n                matching[adj] = current\n                return True\n    return False\n\n\ndef mbm():\n    matching = [-1] * y_num\n    res = 0\n    for v in range(x_num):\n        visited = [False] * y_num\n        if graph_dfs(v, matching, visited):\n            res += 1\n    # print(matching)\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    init_adj_table = [set() for _ in range(x_num)]\n    adj_table = generate_adj_table(edges)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "import sys,queue,math,copy,itertools,bisect,collections,heapq\n\ndef main():\n    LI = lambda : [int(x) for x in sys.stdin.readline().split()]\n\n    X,Y,E = LI()\n\n    edge = [set() for _ in range(X+Y+2)]\n\n    for _ in range(E):\n        a,b = LI()\n        i = a + 1\n        j = b + X + 1\n        edge[i].add(j)\n    for i in range(1,X+1):\n        edge[0].add(i)\n    for j in range(X+1,X+Y+1):\n        edge[j].add(X+Y+1)\n\n    ans = 0\n    while True:\n        node = [-2] * (X + Y + 2)\n        node[0] = -1\n        q = collections.deque()\n        q.append(0)\n        while q:\n            u = q.pop()\n            for v in edge[u]:\n                if v == X + Y + 1:\n                    ans += 1\n                    node[v] = u\n                    break\n                if node[v] < -1:\n                    node[v] = u\n                    q.append(v)\n            else:\n                continue\n            break\n        else:\n            break\n\n        u = X + Y + 1\n        while node[u] >= 0:\n            edge[node[u]].remove(u)\n            edge[u].add(node[u])\n            u = node[u]\n\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\nclass Dinic(object):\n    __slots__ = [\"inf\", \"v_count\", \"edges\", \"iter\", \"level\"]\n\n    def __init__(self, v_count: int, edges: list):\n        self.inf = 10**9\n        self.v_count = v_count\n        self.edges = [[] for _ in [0]*v_count]\n        self.iter = [0]*v_count\n        self.level = None\n        self._create_graph(edges)\n\n    def _create_graph(self, _edges):\n        edges = self.edges\n        for origin, dest, cap in _edges:\n            edges[origin].append([dest, cap, len(edges[dest])])\n            edges[dest].append([origin, 0, len(edges[origin])-1])\n\n    def solve(self, source: int, sink: int):\n        max_flow = 0\n\n        while True:\n            self.bfs(source)\n            if self.level[sink] < 0:\n                return max_flow\n\n            self.iter = [0]*self.v_count\n            flow = self.dfs(source, sink, self.inf)\n\n            while flow > 0:\n                max_flow += flow\n                flow = self.dfs(source, sink, self.inf)\n\n    def bfs(self, source: int):\n        level, edges = [-1]*self.v_count, self.edges\n        level[source] = 0\n        dq = deque([source])\n        popleft, append = dq.popleft, dq.append\n\n        while dq:\n            v = popleft()\n            for dest, cap, _rev in edges[v]:\n                if cap > 0 > level[dest]:\n                    level[dest] = level[v] + 1\n                    append(dest)\n\n        self.level = level\n\n    def dfs(self, source: int, sink: int, flow: int) -> int:\n        if source == sink:\n            return flow\n        while self.iter[source] < len(self.edges[source]):\n            dest, cap, rev = edge = self.edges[source][self.iter[source]]\n            if cap > 0 and self.level[source] < self.level[dest]:\n                flowed = self.dfs(dest, sink, flow if flow < cap else cap)\n                if flowed > 0:\n                    edge[1] -= flowed\n                    self.edges[dest][rev][1] += flowed\n                    return flowed\n            self.iter[source] += 1\n\n        return 0\n\n\nif __name__ == \"__main__\":\n    import sys\n    X, Y, E = map(int, input().split())\n    source, sink = X+Y, X+Y+1\n    edges = [(source, i, 1) for i in range(X)] + [(X+i, sink, 1) for i in range(Y)]\n    append = edges.append\n    for x, y in (map(int, l.split()) for l in sys.stdin):\n        append((x, X+y, 1))\n    dinic = Dinic(X+Y+2, edges)\n    print(dinic.solve(source, sink))\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef dfs(current, matching, visited):\n    for target in range(y_num):\n        if not visited[target] and target in adj_table[current]:\n            visited[target] = True\n            ''' Matching[target] = -1: target not assigned to any of x.\n            And dfs(matching[target], matching, visited) = True\n            indicates that source in x has been already assigned\n            to another target in y. '''\n            if matching[target] == -1 or dfs(matching[target], matching, visited):\n                matching[target] = current\n                return True\n    return False\n\n\ndef mbm():\n    res = 0\n    matching = [-1] * y_num\n    for source in range(x_num):\n        visited = [False] * y_num\n        if dfs(source, matching, visited):\n            res += 1\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    adj_table = tuple(set() for _ in range(x_num))\n    for edge in edges:\n        vx, vy = map(int, edge)\n        adj_table[vx].add(vy)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef generate_adj_table(_edges):\n    for edge in _edges:\n        vx, vy = map(int, edge)\n        init_adj_table[vx].add(vy)\n\n    return init_adj_table\n\n\ndef graph_dfs(current, matching, visited):\n    for target in range(y_num):\n        if (not visited[target]) and (target in adj_table[current]):\n            visited[target] = True\n            # matching[target] = -1: target not assigned to any of x\n            # graph_dfs(matching[target], matching, visited) = True\n            # indicates that source in x has been already assigned to another target in y\n            if matching[target] == -1 or graph_dfs(matching[target], matching, visited):\n                matching[target] = current\n                return True\n    return False\n\n\ndef mbm():\n    matching = [-1] * y_num\n    res = 0\n    for source in range(x_num):\n        visited = [False] * y_num\n        if graph_dfs(source, matching, visited):\n            res += 1\n    # print(matching)\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    init_adj_table = [set() for _ in range(x_num)]\n    adj_table = generate_adj_table(edges)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef dfs(here,used,match,connect):\n    used[here] = 1\n    for near in connect[here]:\n        m = match[near]\n        if m < 0 or (not used[m] and dfs(m,used,match,connect)):\n            match[here] = near\n            match[near] = here\n            return 1\n    return 0\n\na_num, b_num, e_num = (int(n) for n in input().split(\" \"))\nconnect = defaultdict(list)\nall_v = a_num + b_num\nmatch = [0 for n in range(all_v)]\nfor _ in range(e_num):\n    v1, v2 = (int(n) for n in input().split(\" \"))\n    v2 += a_num\n    connect[v1].append(v2)\n    connect[v2].append(v1)\nanswer = 0\nfor i in range(all_v):\n    if match[i] < 0:\n        if dfs(i,used,match,connect):\n            used = [0 for n in range(all_v)]\n            answer += 1\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\n \n \nclass MaxFlow:\n    class Edge:\n        def __init__(self, to, cap, rev):\n            self.to, self.cap, self.rev = to, cap, rev\n \n    def __init__(self, node_size, inf):\n        self._node = node_size\n        self._inf = inf\n        self._level = [-1]*self._node\n        self._iter = [0]*self._node\n        self._graph = [[] for _ in range(self._node)]\n \n    def add_edge(self, from_, to, cap):\n        self._graph[from_].append(self.Edge(to, cap, len(self._graph[to])))\n        self._graph[to].append(self.Edge(from_, 0, len(self._graph[from_])-1))\n \n    def bfs(self, start):\n        self._level = [-1]*self._node\n        que = deque()\n        self._level[start] = 0\n        que.append(start)\n        while que:\n            cur_vertex = que.popleft()\n            for e in self._graph[cur_vertex]:\n                if self._level[e.to] < 0 < e.cap:\n                    self._level[e.to] = self._level[cur_vertex] + 1\n                    que.append(e.to)\n \n    def dfs(self, cur_vertex, end_vertex, flow):\n        if cur_vertex == end_vertex:\n            return flow\n        while self._iter[cur_vertex] < len(self._graph[cur_vertex]):\n            e = self._graph[cur_vertex][self._iter[cur_vertex]]\n            if e.cap > 0 and self._level[cur_vertex] < self._level[e.to]:\n                flowed = self.dfs(e.to, end_vertex, min(flow, e.cap))\n                if flowed > 0:\n                    e.cap -= flowed\n                    self._graph[e.to][e.rev].cap += flowed\n                    return flowed\n            self._iter[cur_vertex] += 1\n        return 0\n \n    def solve(self, source, sink):\n        flow = 0\n        while True:\n            self.bfs(source)\n            if self._level[sink] < 0:\n                return flow\n            self._iter = [0]*self._node\n            while True:\n                f = self.dfs(source, sink, self._inf)\n                if f == 0:\n                    break\n                flow += f\n \n \nclass BipartiteMatching:\n    def __init__(self, size1, size2):\n        self._u_size, self. _v_size = size1, size2\n        self.mf = MaxFlow(self._u_size+self. _v_size+2, min(self._u_size, self._v_size))\n        for i in range(self._u_size):\n            self.mf.add_edge(0, i+1, 1)\n        for i in range(self._v_size):\n            self.mf.add_edge(self._u_size+i+1, self._u_size+self._v_size+1, 1)\n \n    def add_edge(self, from_, to):\n        self.mf.add_edge(from_+1, to+self._u_size+1, 1)\n \n    def solve(self):\n        return self.mf.solve(0, self._u_size+self._v_size+1)\n \nif __name__=='__main__':\n    x, y, m = map(int, sys.stdin.readline().split())\n    bm = BipartiteMatching(x, y)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        bm.add_edge(u, v)\n    print(bm.solve())\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef generate_adj_table(_edges):\n    for edge in _edges:\n        vx, vy = map(int, edge)\n        init_adj_table[vx].append(vy)\n\n    return init_adj_table\n\n\ndef graph_dfs(current, matching, visited):\n    for adj in range(y_num):\n        if adj in adj_table[current] and not visited[adj]:\n            visited[adj] = True\n            if matching[adj] == -1 or graph_dfs(matching[adj], matching, visited):\n                matching[adj] = current\n                return True\n    return False\n\n\ndef mbm():\n    matching = [-1] * v_num\n    res = 0\n    for v in range(x_num):\n        visited = [False] * y_num\n        if graph_dfs(v, matching, visited):\n            res += 1\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    v_num = x_num + y_num\n    init_adj_table = [[] for _ in range(x_num)]\n    adj_table = generate_adj_table(edges)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "def outer(x,match,phi):\n    if(match[x]==x or phi[match[x]]!=match[x]):\n        return True\n    return False\n    \ndef inner(x,match,phi):\n    if(match[x]!=x and phi[match[x]]==match[x] and phi[x]!=x):\n        return True\n    return False\n\ndef F(x,match,phi):\n    if(match[x]!=x and phi[match[x]]==match[x] and phi[x]==x):\n        return True\n    return False\n       \ndef disjoint(x,y,V,phi,match):\n    usedx=[False]*V\n    prex=match[x]\n    while not (usedx[x] and usedx[prex]) :\n        usedx[prex]=True\n        usedx[x]=True\n        x=phi[prex]\n        prex=match[x]\n    usedy=[False]*V\n    prey=match[y]\n    while not (usedy[y] and usedy[prey]) :\n        usedy[y]=True\n        usedy[prey]=True\n        if usedx[y] or usedx[prey]:\n            return False\n        prey=match[y]\n        y=phi[prey]\n    return True\n    \ndef shrink(x,y,match,rho,phi,V):\n    r=firstvertex(x,y,match,phi,rho,V)\n    v=match[x]    \n    if x!=r and x!=v:\n        while True:\n            if rho[phi[v]]!=r:\n                phi[phi[v]]=v\n            if(phi[v]==r or match[phi[v]]==r):\n                break\n            v=match[phi[v]]\n    v=match[y]\n    if y!=r and y!=v:\n        while True:\n            if rho[phi[v]]!=r:\n                phi[phi[v]]=v\n            if(phi[v]==r or match[phi[v]]==r):\n                break\n            v=match[phi[v]]\n#             print(y,v,phi[v],r)\n    if rho[x]!=r:\n        phi[x]=y\n    if rho[y]!=r:\n        phi[y]=x\n        \n    used=[False]*V\n    used[r]=True\n    while x!=r or y!=r: \n        used[x]=True\n        used[y]=True\n        if(x!=r):\n            x=match[x]\n        if y!=r:\n            y=match[y]\n        used[x]=True\n        used[y]=True\n        if x!=r:\n            x=phi[x]\n        if y!=r:\n            y=phi[y]\n    for i in range(V):\n        if used[rho[i]] :\n            rho[i]=r\n    \ndef firstvertex(x,y,match,phi,rho,V):\n    usedx=[False]*V\n    usedy=[False]*V\n    flag=True\n    while True:\n        if usedy[x] and rho[x]==x:\n            return x\n        usedx[x]=True\n        if usedx[y] and rho[y]==y:\n            return y\n        usedy[y]=True\n        if flag:\n            x=match[x]\n            y=match[y]\n            flag=False\n        else:\n            x=phi[x]\n            y=phi[y]\n            flag=True\n       \ndef augment(x,y,match,phi,V):\n    v=match[x]\n    used=[False]*V\n    used[x]=True\n    while not used[v]:\n        used[v]=True\n        used[phi[v]]=True\n        tmp=match[phi[v]]\n        match[phi[v]]=v\n        match[v]=phi[v]\n        v=tmp\n    v=match[y]\n    used=[False]*V\n    used[y]=True\n    while not used[v]:\n        used[v]=True\n        used[phi[v]]=True\n        tmp=match[phi[v]]\n        match[phi[v]]=v\n        match[v]=phi[v]\n        v=tmp\n    match[x]=y\n    match[y]=x\n    \n    \ndef Edmonds(graph,V):\n    match=[i for i in range(V)]\n    phi=[i for i in range(V)]\n    rho=[i for i in range(V)]\n    scanned=[False]*V\n    \n    while True:\n#         from IPython.core.debugger import Pdb; Pdb().set_trace()\n        flag=True\n        for i in range(V):\n            if (not scanned[i]) and outer(i,match,phi):\n                x=i\n                flag=False\n                break\n        if flag:\n            break\n        for y in graph[x]:\n            if F(y,match,phi):\n                #拡大\n                phi[y]=x\n                continue\n            if not(outer(y,match,phi) and rho[y]!=rho[x]):\n                continue\n                \n            if disjoint(x,y,V,phi,match):\n                #増加\n                augment(x,y,match,phi,V)\n                scanned=[False]*V\n                rho=[i for i in range(V)]\n                phi=[i for i in range(V)]\n                flag=True\n                break\n            #縮小\n            shrink(x,y,match,rho,phi,V)\n        if not flag:\n            scanned[x]=True\n    cnt=0\n    for i in range(V):\n        if match[i]!=i:\n            cnt+=1\n#     print(match)\n    return int(cnt/2)\n        \n\n\n\n\nx,y,e=list(map(int,input().split()))\nv=x+y\ngraph=[[]for _ in range(v)]\n\nfor i in range(e):\n    tmp1,tmp2=list(map(int,input().split()))\n    tmp2+=x\n    graph[tmp1].append(tmp2)\n    graph[tmp2].append(tmp1)\n\ncnt=Edmonds(graph,v)\nprint(cnt)\n\n\n    \n"
  },
  {
    "language": "Python",
    "code": "class BipartiteGraph(object):\n    \n    def __init__(self, num_nodes):\n        self.graph = [[] for _ in range(num_nodes)] # ??°???????????£??\\???????????¨???\n        self.match = [None] * num_nodes # ??????????????°????????¢\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n        self.graph[v].append(u)\n\n    def has_increasing_path(self, v, used):\n        used[v] = True\n        for i, u in enumerate(self.graph[v]):\n            w = self.match[u]\n            if w is None or (not used[w] and self.has_increasing_path(w, used)):\n                self.match[v] = u\n                self.match[u] = v\n                return True\n        return False\n\n    def __str__(self):\n        ret = [\"graph bipartite_graph {\"]\n        for v, g in enumerate(self.graph):\n            for u in g:\n                ret.append(\"    {} -- {};\".format(v, u))\n        # ret.append(\"    rank = source; {};\"\n        ret.append(\"}\")\n        return \"\\n\".join(ret)\n        \n\n    def solve(self):\n        ret = 0\n        for v in range(len(self.graph)):\n            if self.match[v] is not None:\n                continue\n            if self.has_increasing_path(v, [False]*len(self.graph)):\n                ret += 1\n        return ret\n\nif __name__ == \"__main__\":\n    X, Y, E = list(map(int, input().split()))\n    bg = BipartiteGraph(X+Y)\n    for _ in range(E):\n        x, y = list(map(int, input().split()))\n        y += X\n        bg.add_edge(x, y)\n    print(bg.solve())"
  },
  {
    "language": "Python",
    "code": "def dfs(v, edges, visited, matched):\n    for u in edges[v]:\n        if u in visited:\n            continue\n        visited.add(u)\n        if matched[u] == -1 or dfs(matched[u], edges, visited, matched):\n            matched[u] = v\n            return True\n    return False\n\n\nxn, yn, e = map(int, input().split())\nedges = [set() for _ in range(xn)]\nmatched = [-1] * yn\n\nfor _ in range(e):\n    x, y = map(int, input().split())\n    edges[x].add(y)\n\nprint(sum(dfs(s, edges, set(), matched) for s in range(xn)))"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom queue import deque\n\nsys.setrecursionlimit(200000)\n\n\ndef hierarchize(source):\n    global hierarchy\n    hierarchy = [-1] * n\n    queue = deque([(0, source)])\n    while queue:\n        h, v = queue.popleft()\n        if hierarchy[v] != -1:\n            continue\n        hierarchy[v] = h\n        if v == sink:\n            return True\n        queue.extend((h + 1, target)\n                     for remain, target, _ in edges[v] if hierarchy[target] == -1 and remain)\n    return False\n\n\ndef augment(v, limit):\n    if v == sink:\n        return limit\n    res = 0\n    for e in edges[v]:\n        remain, target, idx = e\n        if remain == 0 or hierarchy[v] >= hierarchy[target]:\n            continue\n        aug = augment(target, min(limit, remain))\n        e[0] -= aug\n        edges[target][idx][0] += aug\n        res += aug\n        limit -= aug\n        if not limit:\n            break\n    return res\n\n\nxn, yn, e = map(int, input().split())\nn = xn + yn + 2\nsink = n - 1\nedges = [[] for _ in range(n)]\n\nhierarchy = [-1] * n\n\nfor x in range(xn):\n    xi = x + 1\n    edges[0].append([1, xi, 0])\n    edges[xi].append([0, 0, x])\nfor y in range(yn):\n    yi = xn + y + 1\n    edges[yi].append([1, sink, y])\n    edges[sink].append([0, yi, 0])\n\nfor _ in range(e):\n    x, y = map(int, input().split())\n    xi, yi = x + 1, xn + y + 1\n    ex, ey = edges[xi], edges[yi]\n    lx, ly = len(ex), len(ey)\n    ex.append([1, yi, ly])\n    ey.append([0, xi, lx])\n\nres = 0\nwhile hierarchize(0):\n    res += augment(0, 100)\nprint(res)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef generate_adj_table(_edges):\n    for edge in _edges:\n        vx, vy = map(int, edge)\n        init_adj_table[vx].append(vy)\n\n    return init_adj_table\n\n\ndef graph_dfs(current, matching, visited):\n    for adj in range(y_num):\n        if adj in adj_table[current] and not visited[adj]:\n            visited[adj] = True\n            if matching[adj] == -1 or graph_dfs(matching[adj], matching, visited):\n                matching[adj] = current\n                return True\n    return False\n\n\ndef mbm():\n    matching = [-1] * y_num\n    res = 0\n    for v in range(x_num):\n        visited = [False] * y_num\n        if graph_dfs(v, matching, visited):\n            res += 1\n    # print(matching)\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    # v_num = x_num + y_num\n    init_adj_table = [[] for _ in range(x_num)]\n    adj_table = generate_adj_table(edges)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = SR()\n    return l\nmod = 1000000007\n\n# 1:shortest path\n# 1_A\n\"\"\"\nfrom heapq import heappush, heappop\ndef dijkstra(num, start):\n    dist = [float(\"inf\") for i in range(num)]\n    dist[start] = 0\n    q = [[dist[start], start]]\n    while q:\n        du, u = heappop(q)\n        for j, k in adj[u]:\n            if dist[j] > du + k:\n                dist[j] = du + k\n                heappush(q, [dist[j], j])\n                print(dist, q)\n    return dist\n\nv,e,r = map(int, input().split(\" \"))\nadj = [[] for i in range(v)]\nfor i in range(e):\n    s,t,d = map(int, input().split(\" \"))\n    adj[s].append([t, d])\nlis = dijkstra(v, r)\nprint(lis)\nfor i in lis:\n    print(str(i).upper())\n\"\"\"\n\n# 1_B\n\"\"\"\ndef bellman_ford(num, start):\n    dist = [float(\"inf\") for i in range(num)]\n    dist[start] = 0\n    for i in range(num):\n        update = False\n        for j, k, l in adj:\n                if dist[k] > dist[j] + l:\n                    dist[k] = dist[j] + l\n                    update = True\n                    if i == num-1:\n                        return False\n        if not update:\n            break\n    return dist\n\nv,e,r = map(int, input().split(\" \"))\nadj = []\nfor i in range(e):\n    s,t,d = map(int, input().split(\" \"))\n    adj.append([s, t, d])\nlis = bellman_ford(v, r)\nif not lis:\n    print(\"NEGATIVE CYCLE\")\nelse:\n    for i in lis:\n        print(str(i).upper())\n\"\"\"\n\n# 1_C\n\"\"\"\ndef warshallfloyd(n):\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                d[j][k] = min(d[j][k], d[j][i]+d[i][k])\nv,e = map(int, input().split())\nd = [[float(\"inf\") for j in range(v)] for i in range(v)]\nfor i in range(v):\n    d[i][i] = 0\nfor i in range(e):\n    s, t, c = map(int, input().split())\n    d[s][t] = c\nwarshallfloyd(v)\nfor i in range(v):\n    if d[i][i] < 0:\n        print(\"NEGATIVE CYCLE\")\n        quit()\nfor i in d:\n    for j in range(v):\n        if j < v-1:\n            print(str(i[j]).upper(), end = \" \")\n        else:\n            print(str(i[j]).upper())\n\"\"\"\n\n# 2:spanning tree\n# 2_A\n\"\"\"\ndef root(x):\n    if par[x] == x:\n        return x\n    par[x] = root(par[x])\n    return par[x]\n\ndef same(x,y):\n    return root(x) == root(y)\n\ndef unite(x,y):\n    x = root(x)\n    y = root(y)\n    if rank[x] < rank[y]:\n        par[x] = y\n    else:\n        par[y] = x\n        if rank[x] == rank[y]:\n            rank[x] += 1\nv,e = LI()\nc = LIR(e)\nc.sort(key = lambda x:x[2])\npar = [i for i in range(v)]\nrank = [0 for i in range(v)]\nk = 0\nans = 0\nfor a,b,w in c:\n    if not same(a,b):\n        k += 1\n        unite(a,b)\n        ans += w\n    if k == v-1:\n        break\nprint(ans)\n\"\"\"\n\n#2_B\n\"\"\"\ndef root(x):\n    if par[x] == x:\n        return x\n    par[x] = root(par[x])\n    return par[x]\n\ndef same(x,y):\n    return root(x) == root(y)\n\ndef unite(x,y):\n    x = root(x)\n    y = root(y)\n    if rank(x) < rank(y):\n        par[x] = y\n    else:\n        par[y] = x\n        if rank(x) == rank(y):\n            rank[x] += 1\n\"\"\"\n\n#3:connected components\n#3_A\n\n#3_B\n\n#3_C\n\n\n#4:path/cycle\n#4_A\n\"\"\"\ndef bellman_ford(num, start):\n    dist = [float(\"inf\") for i in range(num)]\n    dist[start] = 0\n    for i in range(num):\n        update = False\n        for j, k, l in adj:\n            if dist[k] > dist[j] + l:\n                dist[k] = dist[j] + l\n                update = True\n                if i == num-1:\n                    return False\n        if not update:\n            break\n    return True\n\nv, e = map(int, input().split(\" \"))\nadj = []\nfor i in range(e):\n    s,t = map(int, input().split(\" \"))\n    adj.append([s, t, -1])\nfor i in range(v):\n    if not bellman_ford(v,i):\n        print(1)\n        quit()\nprint(0)\n\"\"\"\n\n#4_B\n\n\n#5:tree\n#5_A\n\"\"\"\nfrom heapq import heappush, heappop\ndef dijkstra(num, start):\n    dist = [float(\"inf\") for i in range(num)]\n    dist[start]  = 0\n    q = [[dist[start], start]]\n    while q:\n        du, u = heappop(q)\n        for j, k in adj[u]:\n            if dist[j] > du + k:\n                dist[j] = du + k\n                heappush(q, [dist[j], j])\n    return dist\n\nn = II()\nadj = [[] for i in range(n)]\nfor i in range(n-1):\n    s,t,w = LI()\n    adj[s].append([t, w])\n    adj[t].append([s, w])\nd = dijkstra(n,0)\ni = d.index(max(d))\nd2 = dijkstra(n,i)\nprint(max(d2))\n\"\"\"\n\n#5_B\n\"\"\"\nfrom heapq import heappush, heappop\ndef dijkstra(num, start):\n    dist = [float(\"inf\") for i in range(num)]\n    dist[start]  = 0\n    q = [[dist[start], start]]\n    while q:\n        du, u = heappop(q)\n        for j, k in adj[u]:\n            if dist[j] > du + k:\n                dist[j] = du + k\n                heappush(q, [dist[j], j])\n    return dist\n\nn = int(input())\nadj = [[] for i in range(n)]\nfor i in range(n-1):\n    s, t, w = map(int, input().split(\" \"))\n    adj[s].append([t, w])\n    adj[t].append([s, w])\nfor i in range(n):\n    s = dijkstra(n,i)\n    print(max(s))\n\"\"\"\n#5_C\n\n#5_D\n\n#5_E\n\n\n#6\n#6_A_maximum_flow\n\"\"\"\ndef bfs(s,g,n):\n    bfs_map = [-1 for i in range(n)]\n    bfs_map[s] = 0\n    q = deque()\n    q.append(s)\n    fin = False\n    while q:\n        x = q.popleft()\n        for y in range(n):\n            if c[x][y] > 0 and bfs_map[y] < 0:\n                bfs_map[y] = bfs_map[x]+1\n                if y == g:\n                    fin = True\n                    break\n                q.append(y)\n        if fin:\n            break\n\n    if bfs_map[g] == -1:\n        return [None,0]\n    path = [None for i in range(bfs_map[g]+1)]\n    m = float(\"inf\")\n    path[bfs_map[g]] = g\n    y = g\n    for i in range(bfs_map[g])[::-1]:\n        for x in range(n+1):\n            if c[x][y] > 0 and bfs_map[x] == bfs_map[y]-1:\n                path[i] = x\n                if c[x][y] < m:\n                    m = c[x][y]\n                y = x\n                break\n    return [path,m]\n\ndef ford_fulkerson(s,g,c,n):\n    while 1:\n        p,m = bfs(s,g,n)\n        if not m:break\n        for i in range(len(p)-1):\n            c[p[i]][p[i+1]] -= m\n            c[p[i+1]][p[i]] += m\n    return sum(c[g])\n\nn,e = LI()\nc = [[0 for i in range(n)] for j in range(n)]\nfor i in range(e):\n    a,b,w = LI()\n    if a != n-1:\n        c[a][b] = w\nprint(ford_fulkerson(0,n-1,c,n))\n\"\"\"\n#6_B\n\n\n#7\n#7_A\ndef bfs(s,g,n):\n    bfs_map = [-1 for i in range(n)]\n    bfs_map[s] = 0\n    q = deque()\n    q.append(s)\n    fin = False\n    while q:\n        x = q.popleft()\n        for y in range(n):\n            if c[x][y] > 0 and bfs_map[y] < 0:\n                bfs_map[y] = bfs_map[x]+1\n                if y == g:\n                    fin = True\n                    break\n                q.append(y)\n        if fin:\n            break\n\n    if bfs_map[g] == -1:\n        return [None,0]\n    path = [None for i in range(bfs_map[g]+1)]\n    m = float(\"inf\")\n    path[bfs_map[g]] = g\n    y = g\n    for i in range(bfs_map[g])[::-1]:\n        for x in range(n+1):\n            if c[x][y] > 0 and bfs_map[x] == bfs_map[y]-1:\n                path[i] = x\n                if c[x][y] < m:\n                    m = c[x][y]\n                y = x\n                break\n    return [path,m]\n\ndef ford_fulkerson(s,g,c,n):\n    while 1:\n        p,m = bfs(s,g,n)\n        if not m:break\n        for i in range(len(p)-1):\n            c[p[i]][p[i+1]] -= m\n            c[p[i+1]][p[i]] += m\n    return sum(c[g])\n\nx,y,e = LI()\nc = [[0 for i in range(x+y+2)] for j in range(x+y+2)]\nfor i in range(x):\n    c[0][i+1] = 1\nfor i in range(y):\n    c[x+i+1][x+y+1] = 1\nfor i in range(e):\n    a,b = LI()\n    c[a+1][x+b+1] = 1\nprint(ford_fulkerson(0,x+y+1,c,x+y+2))\n\n"
  },
  {
    "language": "Python",
    "code": "def dfs(s):\n    return _dfs(s, set())\n\n\ndef _dfs(v, visited):\n    for u in edges[v]:\n        if u in visited:\n            continue\n        visited.add(u)\n        if matched[u] == -1 or _dfs(matched[u], visited):\n            matched[u] = v\n            return True\n    return False\n\n\nxn, yn, e = map(int, input().split())\nedges = [set() for _ in range(xn)]\nmatched = [-1] * yn\n\nfor _ in range(e):\n    x, y = map(int, input().split())\n    edges[x].add(y)\n\nprint(sum(map(dfs, range(xn))))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\nfrom collections import deque\n\n\ndef generate_adj_table(_edges):\n    for edge in _edges:\n        source, target = map(int, edge)\n        target += x_num\n        init_adj_table[source].append(target)\n        init_adj_table[target].append(source)\n\n    return init_adj_table\n\n\ndef graph_bfs_Hungarian():\n    ans = 1\n    queue = deque()\n    prev, matching = ([-1] * v_num for _ in range(2))\n    visited = [False] * v_num\n\n    for v in range(x_num):\n        if matching[v] == -1:\n            while queue:\n                queue.pop()\n            queue.append(v)\n            prev[v] = -1\n            flag = False\n            while queue and not flag:\n                current = queue[0]\n                for adj in adj_table[current]:\n                    if not visited[adj]:\n                        visited[adj] = True\n                        queue.append(matching[adj])\n                        if matching[adj] >= 0:\n                            prev[matching[adj]] = current\n                        else:\n                            flag = True\n                            # print(current, adj)\n                            d, e = current, adj\n                            while d != -1:\n                                t = matching[d]\n                                matching[d] = e\n                                matching[e] = d\n                                d = prev[d]\n                                e = t\n\n                queue.pop()\n\n            if matching[v] != -1:\n                ans += 1\n\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    v_num = x_num + y_num\n    init_adj_table = [[] for _ in range(v_num)]\n    adj_table = generate_adj_table(edges)\n    print(graph_bfs_Hungarian())"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\na_num, b_num, e_num = (int(n) for n in input().split(\" \"))\nconnect = defaultdict(list)\nall_v = a_num + b_num\nmatch = [0 for n in range(all_v)]\nfor _ in range(e_num):\n    v1, v2 = (int(n) for n in input().split(\" \"))\n    v2 += a_num + 1\n    connect[v1].append(v2)\n    connect[v2].append(v1)\ndef dfs(here,used,match,connect):\n    used[here] = 1\n        for near in connect[here]:\n            m = match[near]\n            if m < 0 or (not used[m] and dfs(m,used,match,connect)):\n                match[here] = near\n                match[near] = here\n                return 1\n        return 0\n\nanswer = 0\nfor i in range(all_v):\n    if match[i] < 0:\n        if dfs(i,used,match,connect):\n            used = [0 for n in range(all_v)]\n            answer += 1\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef dfs(here,used,match,connect):\n    used[here] = 1\n    for near in connect[here]:\n        m = match[near]\n        if m < 0 or (not used[m] and dfs(m,used,match,connect)):\n            match[here] = near\n            match[near] = here\n            return 1\n        return 0\n    \na_num, b_num, e_num = (int(n) for n in input().split(\" \"))\nconnect = defaultdict(list)\nall_v = a_num + b_num\nmatch = [0 for n in range(all_v)]\nfor _ in range(e_num):\n    v1, v2 = (int(n) for n in input().split(\" \"))\n    v2 += a_num\n    connect[v1].append(v2)\n    connect[v2].append(v1)\nanswer = 0\nfor i in range(all_v):\n    if match[i] < 0:\n        if dfs(i,used,match,connect):\n            used = [0 for n in range(all_v)]\n            answer += 1\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nclass Dinic:\n    def __init__(self, v, inf=10**10):\n        self.v = v\n        self.inf = inf\n        self.G = [[] for _ in range(v)]\n        self.level = [-1]*v  # 深さ\n        self.ite = [0]*v  # DFSでの探索が済んでいるか\n    def add_edge(self, fr, to, cap):\n        self.G[fr].append([to, cap, len(self.G[to])])\n        self.G[to].append([fr, 0, len(self.G[fr])-1])\n    def bfs(self, s):  # BFSで深さ決定,sがstart\n        self.level = [-1]*self.v  # 必要\n        self.level[s] = 0\n        Q = deque()\n        Q.append(s)\n        while Q:\n            v = Q.popleft()\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if e[1]>0 and self.level[e[0]]<0: ###capacity>0かつtoの深さ未定\n                    self.level[e[0]] = self.level[v]+1\n                    Q.append(e[0])\n    def dfs(self, v, t, f):  # DFSで増加パス探索,v開始、t終点、総フローf\n        if v==t:\n            return f\n        for i in range(self.ite[v],len(self.G[v])):\n            self.ite[v] = i\n            e = self.G[v][i]\n            if e[1]>0 and self.level[v]<self.level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d>0:\n                    e[1] -= d  # cap減少\n                    self.G[e[0]][e[2]][1] += d  # 逆辺のcap増加\n                    return d\n        return 0\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t]<0:\n                return flow\n            self.ite = [0]*self.v  # DFSでの探索が済んでいるか否か\n            f = self.dfs(s,t,self.inf)\n            while f>0:\n                flow += f\n                f = self.dfs(s,t,self.inf)\n\nX, Y, E = MAP()\nD = Dinic(X+Y+2)\ns = X+Y\nt = X+Y+1\n\nfor i in range(X):\n\tD.add_edge(s, i, 1)\n\nfor i in range(Y):\n\tD.add_edge(X+i, t, 1)\n\nfor _ in range(E):\n\tx, y = MAP()\n\tD.add_edge(x, X+y, 1)\n\nprint(D.max_flow(s, t))\n\n"
  },
  {
    "language": "Python",
    "code": "def dfs(u):\n    for v in range(nv):\n        if adj[u][v] and not visited[v]:\n            visited[v] = True\n            if not matches[v] or dfs(matches[v]):\n                matches[v] = u\n                return True\n    return False\n\nnu, nv, ne = map(int, input().split(' '))\nadj = [[False] * nv for _ in range(nu)]\nmatches = [None] * nv\ncount = 0\n\nfor _ in range(ne):\n    s, t = map(int, input().split(' '))\n    adj[s][t] = True\n\nfor i in range(nu):\n    visited = [False] * ne\n    if dfs(i): count += 1\n\nprint(count)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import deque\n\nsys.setrecursionlimit(10 ** 9)\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\nINF=float('inf')\n\nclass BipartiteMatching:\n    \"\"\"\n    XとYの二部グラフの最大マッチング X={0,1,2,...|X|-1} Y={0,1,2,...,|Y|-1}\n    edges[x]: xとつながるYの頂点のset\n    match1[x]: xとマッチングされたYの頂点\n    match2[y]: yとマッチングされたXの頂点\n    \"\"\"\n\n    def __init__(self, n, m):\n        self.n = n\n        self.m = m\n        self.edges = [set() for _ in range(n)]\n        self.match1 = [-1] * n\n        self.match2 = [-1] * m\n \n    def dfs(self, v, visited):\n        \"\"\"\n        :param v: X側の未マッチングの頂点の1つ\n        :param visited: 空のsetを渡す（外部からの呼び出し時）\n        :return: 増大路が見つかればTrue\n        \"\"\"\n        for u in self.edges[v]:\n            if u in visited:\n                continue\n            visited.add(u)\n            if self.match2[u] == -1 or self.dfs(self.match2[u], visited):\n                self.match2[u] = v\n                self.match1[v] = u\n                return True\n        return False\n    \n    def add(self, a, b):\n        self.edges[a].add(b)\n\n    def whois1(self, a):\n        \"\"\" :param: グループ1の頂点 :return: ペアになるグループ2の頂点 \"\"\"\n        return self.match1[a]\n\n    def whois2(self, a):\n        \"\"\" :param: グループ2の頂点 :return: ペアになるグループ1の頂点 \"\"\"\n        return self.match2[a]\n\n    def solve(self):\n        # 増大路発見に成功したらTrue(=1)。合計することでマッチング数となる\n        return sum(self.dfs(i, set()) for i in range(self.n))\n\nN,M,E=MAP()\nbm=BipartiteMatching(N, M)\nfor i in range(E):\n    x,y=MAP()\n    bm.add(x, y)\n\nprint(bm.solve())\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef generate_adj_table(_edges):\n    for edge in _edges:\n        vx, vy = map(int, edge)\n        init_adj_table[vx].add(vy)\n\n    return init_adj_table\n\n\ndef graph_dfs(current, matching, visited):\n    for adj in range(y_num):\n        if (not visited[adj]) and (adj in adj_table[current]):\n            visited[adj] = True\n            # matching[adj] = -1: target in y not assigned to any of x\n            # matching[adj] -> an assigned source in x\n            # graph_dfs(matching[adj], matching, visited) = True indicates that source has been\n            if matching[adj] == -1 or graph_dfs(matching[adj], matching, visited):\n                matching[adj] = current\n                return True\n    return False\n\n\ndef mbm():\n    matching = [-1] * y_num\n    res = 0\n    for v in range(x_num):\n        visited = [False] * y_num\n        if graph_dfs(v, matching, visited):\n            res += 1\n    # print(matching)\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    init_adj_table = [set() for _ in range(x_num)]\n    adj_table = generate_adj_table(edges)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpl_str(): return list(input().split())\n\ndef FordFulkerson(S,T): #sからFord-Fulkerson\n    global lines\n    global cost\n    global ans\n\n    queue = deque()     #BFS用のdeque\n    queue.append([S,INF])\n    ed = [True]*N    #到達済み\n    ed[S] = False\n    route = [0 for i in range(N)]   #ルート\n    route[S] = -1\n\n    #BFS\n    while queue:\n        s,flow = queue.pop()\n        for t in lines[s]:  #s->t\n            if ed[t]:\n                flow = min(cost[s][t],flow)  #flow = min(直前のflow,line容量)\n                route[t] = s\n                queue.append([t,flow])\n                ed[t] = False\n                if t == T: #ゴール到達\n                    ans += flow\n                    break\n        else:\n            continue\n        break\n    else:\n        return False\n\n    #ラインの更新\n    t = T\n    s = route[t]\n    while s != -1:\n        #s->tのコスト減少，ゼロになるなら辺を削除\n        cost[s][t] -= flow\n        if cost[s][t] == 0:\n            lines[s].remove(t)\n\n        #t->s(逆順)のコスト増加，元がゼロなら辺を作成\n        if cost[t][s] == 0:\n            lines[t].add(s)\n        cost[t][s] += flow\n\n        t = s\n        s = route[t]\n    return True\n\ndef PrimeFactoring(x):\n    p = 2\n    primes = []\n    while x >= 2:\n        if x%p == 0:\n            primes.append(p)\n            x //= p\n            p = 2\n        else:\n            p += 1\n    return primes\n\nwhile True:\n    X,Y,M = inpl()\n    lines = defaultdict(set)\n    N = X+Y+2\n    S = X+Y\n    T = X+Y+1\n    cost = [[0]*N for _ in range(N)]\n\n    for i in range(M):\n        x,y = inpl()\n        lines[x].add(y+X)\n        cost[x][y+X] = 1\n        \n    for i in range(X):\n        lines[S].add(i)\n        cost[S][i] = 1\n    for i in range(Y):\n        lines[i+X].add(T)\n        cost[i+X][T] = 1\n\n    ans = 0\n\n    while FordFulkerson(S,T):\n        pass\n\n    print(ans)\n\n    break\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef graph_dfs(current, matching, visited):\n    for target in range(y_num):\n        if (not visited[target]) and (target in adj_table[current]):\n            visited[target] = True\n            if matching[target] == -1 or graph_dfs(matching[target], matching,\n                                                   visited):\n                matching[target] = current\n                return True\n    return False\n\n\ndef mbm():\n    res = 0\n    matching = [-1] * y_num\n    for source in range(x_num):\n        visited = [False] * y_num\n        if graph_dfs(source, matching, visited):\n            res += 1\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    adj_table = [set() for _ in range(x_num)]\n    for edge in edges:\n        vx, vy = map(int, edge)\n        adj_table[vx].add(vy)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\n\nimport sys\n\nfile_input = sys.stdin\n\nX, Y, E = map(int, file_input.readline().split())\n\nv_num = X + Y + 2\n\nadj_mat = [[0] * (v_num) for i in range(v_num)]\n\nfor line in file_input:\n    x, y = map(int, line.split())\n    adj_mat[x][X + y] = 1\n\ns = X + Y\nt = s + 1\n\nfor i in range(X):\n    adj_mat[s][i] = 1\n\nfor i in range(X, s):\n    adj_mat[i][t] = 1\n\n# Ford???Fulkerson method\n\nimport collections\n\n# BFS for residual capacity network\ndef bfs(start, goal, parent):\n    unvisited = [True] * v_num\n    queue = collections.deque()\n    queue.append(start)\n    unvisited[start] = False\n    while queue:\n        u = queue.popleft()\n        for v, r_capacity in enumerate(adj_mat[u]):\n            if unvisited[v] and (r_capacity > 0):\n                queue.append(v)\n                unvisited[v] = False\n                parent[v] = u\n                if v == goal:\n                    return not unvisited[goal]\n\ndef ford_fulkerson(source, sink):\n    parent = [None] * v_num\n    max_flow = 0\n    while bfs(source, sink, parent):\n        aug_path_flow = 10000\n        v = sink\n        while (v != source):\n            aug_path_flow = min(aug_path_flow, adj_mat[parent[v]][v])\n            v = parent[v]\n        max_flow += aug_path_flow\n        v = sink\n        while (v != source):\n            u = parent[v]\n            adj_mat[u][v] -= aug_path_flow\n            adj_mat[v][u] += aug_path_flow\n            v = u\n    return max_flow\n\n# output\nprint(ford_fulkerson(s, t))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef generate_adj_table(_edges):\n    for edge in _edges:\n        vx, vy = map(int, edge)\n        init_adj_table[vx].append(vy)\n\n    return init_adj_table\n\n\ndef graph_dfs(current, matching, visited):\n    for adj in range(y_num):\n        if adj in adj_table[current] and not visited[adj]:\n            visited[adj] = True\n            if matching[adj] == -1 or graph_dfs(matching[adj], matching, visited):\n                matching[adj] = current\n                return True\n    return False\n\n\ndef mbm():\n    matching = [-1] * y_num\n    res = 0\n    for v in range(x_num):\n        visited = [False] * y_num\n        if graph_dfs(v, matching, visited):\n            res += 1\n    # print(matching)\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    v_num = x_num + y_num\n    init_adj_table = [[] for _ in range(x_num)]\n    adj_table = generate_adj_table(edges)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\n\nimport sys\n\nfile_input = sys.stdin\n\nX, Y, E = map(int, file_input.readline().split())\n\nv_num = X + Y + 2\n\nadj_mat = [[0] * (v_num) for i in range(v_num)]\n\nfor line in file_input:\n    x, y = map(int, line.split())\n    adj_mat[x][X + y] = 1\n\ns = X + Y\nt = s + 1\n\nfor i in range(X):\n    adj_mat[s][i] = 1\n\nfor i in range(X, s):\n    adj_mat[i][t] = 1\n\n# Dinic's algorithm\n\nimport collections\n\n# BFS for residual capacity network to construct level graph\ndef bfs(start, goal, parent):\n    unvisited = [True] * v_num\n    queue = collections.deque()\n    queue.append(start)\n    unvisited[start] = False\n    while queue:\n        u = queue.popleft()\n        for v, r_capacity in enumerate(adj_mat[u]):\n            if unvisited[v] and (r_capacity > 0):\n                parent[v].append(u)\n                queue.append(v)\n                unvisited[v] = False\n    return unvisited[goal]\n\n# DFS for level graph and construct blocking flow\ndef dfs(goal, path, parent, blocking_flow):\n    v = path[-1]\n    if v == goal:\n        aug_path_flow = 10000\n        for x, y in zip(path[1:], path[:-1]):\n            aug_path_flow = min(aug_path_flow, adj_mat[x][y])\n        for x, y in zip(path[1:], path[:-1]):\n            adj_mat[x][y] -= aug_path_flow\n            adj_mat[y][x] += aug_path_flow\n        blocking_flow[0] += aug_path_flow\n    else:\n        for u in parent[v]:\n            path.append(u)\n            dfs(goal, path, parent, blocking_flow)\n            path.pop()\n\ndef dinic(source, sink):\n    max_flow = 0\n    parent = [[] for i in range(v_num)]\n    while not bfs(source, sink, parent):\n        blocking_flow = [0]\n        path = [sink]\n        # search in reverse direction from sink\n        dfs(source, path, parent, blocking_flow)\n        max_flow += blocking_flow[0]\n        parent = [[] for i in range(v_num)]\n    return max_flow\n\n# output\nprint(dinic(0, v_num - 1))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef generate_adj_table(_edges):\n    for edge in _edges:\n        vx, vy = map(int, edge)\n        init_adj_table[vx].add(vy)\n\n    return init_adj_table\n\n\ndef graph_dfs(current, matching, visited):\n    for adj in range(y_num):\n        if not visited[adj]:\n            visited[adj] = True\n            # matching[adj] = -1: adj not assigned to any of x\n            # graph_dfs(matching[adj], matching, visited) = True\n            # indicates that source in x has been already assigned to another target in y\n            if matching[adj] == -1 or graph_dfs(matching[adj], matching, visited):\n                matching[adj] = current\n                return True\n    return False\n\n\ndef mbm():\n    matching = [-1] * y_num\n    res = 0\n    for v in range(x_num):\n        visited = [False] * y_num\n        if graph_dfs(v, matching, visited):\n            res += 1\n    # print(matching)\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    init_adj_table = [set() for _ in range(x_num)]\n    adj_table = generate_adj_table(edges)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nMatching - Bipartite Matching\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_7_A&lang=jp\n\n\"\"\"\nimport sys\nfrom sys import stdin\nfrom collections import namedtuple\ninput = stdin.readline\nedge = namedtuple('edge', ['to', 'cap', 'rev'])\n\n\ndef add_edge(G, f, t, c):\n    G[f].append(edge(t, c, len(G[t])))\n    G[t].append(edge(f, 0, len(G[f]) - 1))\n\n\ndef dfs(G, used, v, t, f):\n    if v == t:\n        return f\n    used[v] = True\n    for i in range(len(G[v])):\n        e = G[v][i]\n        if (not used[e.to]) and (e.cap > 0):\n            d = dfs(G, used, e.to, t, min(f, e.cap))\n            if d > 0:\n                G[v][i] = edge(e.to, e.cap - d, e.rev)\n                G[e.to][e.rev] = edge(G[e.to][e.rev].to, G[e.to][e.rev].cap + d, G[e.to][e.rev].rev)\n                return d\n    return 0\n\n\ndef max_flow(G, V, s, t):\n    used = [False] * V\n    flow = 0\n    while True:\n        for i in range(len(used)):\n            used[i] = False\n        f = dfs(G, used, s, t, float('inf'))\n        if f == 0:\n            return flow\n        flow += f\n\n\ndef main(args):\n    \"\"\"\n    - 追加したソースノードID: 0\n    - Xグループ: 1〜X\n    - Yグループ: X+1〜X+Y\n    - 追加したシンクノードID: X+Y+1\n    として、ノード0 → X+Y+1 への最大流を求める\n    \"\"\"\n    X, Y, E = map(int, input().split())\n    G = [[] for _ in range(X+Y+2)]\n\n    for li in range(E):\n        x, y = map(int, input().split())\n        add_edge(G, 0, x, 1)\n        add_edge(G, y, X+Y+1, 1)\n        add_edge(G, x+1, X+y+1, 1)\n\n    ans = max_flow(G, X+Y+2, 0, X+Y+1) #  ソースとシンク間の最大流\n    print(ans)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\n\n\nclass MaxFlow:\n    class Edge:\n        def __init__(self, to, cap, rev):\n            self.to, self.cap, self.rev = to, cap, rev\n\n    def __init__(self, node_size, inf):\n        self._node = node_size\n        self._inf = inf\n        self._level = [-1]*self._node\n        self._iter = [0]*self._node\n        self._graph = [[] for _ in range(self._node)]\n\n    def add_edge(self, from_, to, cap):\n        self._graph[from_].append(self.Edge(to, cap, len(self._graph[to])))\n        self._graph[to].append(self.Edge(from_, 0, len(self._graph[from_])-1))\n\n    def bfs(self, start):\n        self._level = [-1]*self._node\n        que = deque()\n        self._level[start] = 0\n        que.append(start)\n        while que:\n            cur_vertex = que.popleft()\n            for e in self._graph[cur_vertex]:\n                if self._level[e.to] < 0 < e.cap:\n                    self._level[e.to] = self._level[cur_vertex] + 1\n                    que.append(e.to)\n\n    def dfs(self, cur_vertex, end_vertex, flow):\n        if cur_vertex == end_vertex:\n            return flow\n        for e in self._graph[cur_vertex][self._iter[cur_vertex]:len(self._graph[cur_vertex])]:\n            if e.cap > 0 and self._level[cur_vertex] < self._level[e.to]:\n                flowed = self.dfs(e.to, end_vertex, min(flow, e.cap))\n                if flowed > 0:\n                    e.cap -= flowed\n                    self._graph[e.to][e.rev].cap += flowed\n                    return flowed\n        return 0\n\n    def solve(self, source, sink):\n        flow = 0\n        while True:\n            self.bfs(source)\n            if self._level[sink] < 0:\n                return flow\n            self._iter = [0]*self._node\n            while True:\n                f = self.dfs(source, sink, self._inf)\n                if f == 0:\n                    break\n                flow += f\n\n\nclass BipartiteMatching:\n    def __init__(self, size1, size2):\n        self._u_size, self. _v_size = size1, size2\n        self.mf = MaxFlow(self._u_size+self. _v_size+2, min(self._u_size, self._v_size))\n        for i in range(self._u_size):\n            self.mf.add_edge(0, i+1, 1)\n        for i in range(self._v_size):\n            self.mf.add_edge(self._u_size+i+1, self._u_size+self._v_size+1, 1)\n\n    def add_edge(self, from_, to):\n        self.mf.add_edge(from_+1, to+self._u_size+1, 1)\n\n    def solve(self):\n        return self.mf.solve(0, self._u_size+self._v_size+1)\n\nif __name__=='__main__':\n    x, y, m = map(int, sys.stdin.readline().split())\n    bm = BipartiteMatching(x, y)\n    for _ in range(m):\n        u, v = map(int, sys.stdin.readline().split())\n        bm.add_edge(u, v)\n    print(bm.solve())\n"
  },
  {
    "language": "Python",
    "code": "def dfs(v, visited):\n    for u in edges[v]:\n        if u in visited:\n            continue\n        visited.add(u)\n        if matched[u] == -1 or dfs(matched[u], visited):\n            matched[u] = v\n            return True\n    return False\n\n\nxn, yn, e = map(int, input().split())\nedges = [set() for _ in range(xn)]\nmatched = [-1] * yn\n\nfor _ in range(e):\n    x, y = map(int, input().split())\n    edges[x].add(y)\n\nprint(sum(dfs(s, set()) for s in range(xn)))"
  },
  {
    "language": "Python",
    "code": "class BipartiteMatching:\n    def __init__(self, v: int):\n        self.v = v\n        self.g = [[] for _ in range(v)]\n        self.match = [-1] * v\n        self.used = [False] * v\n\n    def add_edge(self, u, v):\n        self.g[u].append(v)\n        self.g[v].append(u)\n\n    def dfs(self, v):\n        self.used[v] = True\n        for i in range(len(self.g[v])):\n            u = self.g[v][i]\n            w = self.match[u]\n\n            if w < 0 or (not self.used[w] and self.dfs(w)):\n                self.match[u] = v\n                self.match[v] = u\n                return True\n\n        return False\n\n    def maximum_matching(self):\n        res = 0\n        self.match = [-1] * self.v\n        for i in range(self.v):\n            if self.match[i] < 0:\n                self.used = [False] * self.v\n                if self.dfs(i):\n                    res += 1\n        return res\n\n\nif __name__ == '__main__':\n    x_size, y_size, e = map(int, input().split())\n    b = BipartiteMatching(x_size + y_size)\n    for i in range(e):\n        x, y = map(int, input().split())\n        b.add_edge(x, y + x_size)\n    print(b.maximum_matching())\n\n"
  },
  {
    "language": "Python",
    "code": "def dfs(s):\n    stack = [(s, -1)]\n    visited = set()\n    while stack:\n        v, prev = stack.pop()\n        if v < xn:\n            if matched[v] == -1:\n                matched[v] = prev\n                return True\n            if v in visited:\n                continue\n            visited.add(v)\n            stack.append((matched[v], v))\n            matched[v] = prev\n        else:\n            stack.extend((w, v) for w in (edges[v] - visited))\n    return False\n\n\nxn, yn, e = map(int, input().split())\nedges = [set() for _ in range(xn + yn)]\nmatched = [-1] * xn\n\nfor _ in range(e):\n    x, y = map(int, input().split())\n    y += xn\n    edges[x].add(y)\n    edges[y].add(x)\n\nprint(sum(map(dfs, range(xn, xn + yn))))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef generate_adj_table(_edges):\n    for edge in _edges:\n        vx, vy = map(int, edge)\n        init_adj_table[vx].append(vy)\n\n    return init_adj_table\n\n\ndef graph_dfs(current, matching, visited):\n    for adj in range(y_num):\n        if (not visited[adj]) and (adj in adj_table[current]):\n            visited[adj] = True\n            if matching[adj] == -1 or graph_dfs(matching[adj], matching, visited):\n                matching[adj] = current\n                return True\n    return False\n\n\ndef mbm():\n    matching = [-1] * y_num\n    res = 0\n    for v in range(x_num):\n        visited = [False] * y_num\n        if graph_dfs(v, matching, visited):\n            res += 1\n    # print(matching)\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    init_adj_table = [[] for _ in range(x_num)]\n    adj_table = generate_adj_table(edges)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n# from collections import deque\n\n\ndef generate_adj_table(_edges):\n    for edge in _edges:\n        source, target = map(int, edge)\n        target += x_num\n        init_adj_table[source].append(target)\n        init_adj_table[target].append(source)\n\n    return init_adj_table\n\n\ndef graph_bfs_Hungarian():\n    ans = 0\n    queue = list()\n    prev, matching = ([-1] * v_num for _ in range(2))\n    visited = [False] * v_num\n\n    for v in range(x_num):\n        if matching[v] == -1:\n            while queue:\n                queue.pop()\n            queue.append(v)\n            prev[v] = -1\n            flag = False\n            while queue and not flag:\n                current = queue[0]\n                for adj in adj_table[current]:\n                    if not flag:\n                        if not visited[adj]:\n                            visited[adj] = True\n                            queue.append(matching[adj])\n                            if matching[adj] >= 0:\n                                prev[matching[adj]] = current\n                            else:\n                                flag = True\n                                # print(current, adj)\n                                d, e = current, adj\n                                while d != -1:\n                                    t = matching[d]\n                                    matching[d] = e\n                                    matching[e] = d\n                                    d = prev[d]\n                                    e = t\n\n                queue.pop()\n\n            if matching[v] != -1:\n                ans += 1\n\n    return ans\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    v_num = x_num + y_num\n    init_adj_table = [[] for _ in range(v_num)]\n    adj_table = generate_adj_table(edges)\n    print(graph_bfs_Hungarian())"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef generate_adj_table(_edges):\n    for edge in _edges:\n        vx, vy = map(int, edge)\n        # vy += x_num\n        init_adj_table[vx].append(vy)\n\n    return init_adj_table\n\n\ndef graph_dfs(current, matching, visited):\n    for adj in range(y_num):\n        if adj in adj_table[current] and not visited[adj]:\n            visited[adj] = True\n            if matching[adj] == -1 or graph_dfs(matching[adj], matching, visited):\n                matching[adj] = current\n                return True\n    return False\n\n\ndef mbm():\n    matching = [-1] * v_num\n    res = 0\n    for v in range(x_num):\n        visited = [False] * y_num\n        if graph_dfs(v, matching, visited):\n            res += 1\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    v_num = x_num + y_num\n    init_adj_table = [[] for _ in range(x_num)]\n    adj_table = generate_adj_table(edges)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\n\nimport sys\n\nfile_input = sys.stdin\n\nX, Y, E = map(int, file_input.readline().split())\n\nv_num = X + Y + 2\n\nadj_mat = [[0] * (v_num) for i in range(v_num)]\n\nfor line in file_input:\n    x, y = map(int, line.split())\n    adj_mat[x][X + y] = 1\n\ns = X + Y\nt = s + 1\n\nfor i in range(X):\n    adj_mat[s][i] = 1\n\nfor i in range(X, s):\n    adj_mat[i][t] = 1\n\n# Dinic's algorithm\n\nimport collections\n\n# BFS for residual capacity network to construct level graph\ndef bfs(start, goal, parent):\n    level = [v_num] * v_num\n    unvisited = [True] * v_num\n    queue = collections.deque()\n    queue.append(start)\n    level[start] = 0\n    unvisited[start] = False\n    while queue:\n        u = queue.popleft()\n        next_level = level[u] + 1\n        for v, r_capacity in enumerate(adj_mat[u]):\n            if (level[v] >= next_level) and (r_capacity > 0):\n                level[v] = next_level\n                parent[v].append(u)\n                if unvisited[v]:\n                    queue.append(v)\n                    unvisited[v] = False\n    return level[goal]\n\n# DFS for level graph and construct blocking flow\ndef dfs(goal, path, parent, blocking_flow):\n    v = path[-1]\n    if v == goal:\n        aug_path_flow = 10000\n        for x, y in zip(path[1:], path[:-1]):\n            aug_path_flow = min(aug_path_flow, adj_mat[x][y])\n        for x, y in zip(path[1:], path[:-1]):\n            adj_mat[x][y] -= aug_path_flow\n            adj_mat[y][x] += aug_path_flow\n        blocking_flow[0] += aug_path_flow\n    else:\n        for u in parent[v]:\n            path.append(u)\n            dfs(goal, path, parent, blocking_flow)\n            path.pop()\n\ndef dinic(source, sink):\n    max_flow = 0\n    parent = [[] for i in range(v_num)]\n    while bfs(source, sink, parent) != v_num:\n        blocking_flow = [0]\n        path = [sink]\n        # search in reverse direction from sink\n        dfs(source, path, parent, blocking_flow)\n        max_flow += blocking_flow[0]\n        parent = [[] for i in range(v_num)]\n    return max_flow\n\n# output\nprint(dinic(s, t))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef dfs(current, matching, visited):\n    for target in range(y_num):\n        if (not visited[target]) and (target in adj_table[current]):\n            visited[target] = True\n            ''' Matching[target] = -1: target not assigned to any of x.\n            And dfs(matching[target], matching, visited) = True\n            indicates that source in x has been already assigned\n            to another target in y. '''\n            if matching[target] == -1 or dfs(matching[target], matching, visited):\n                matching[target] = current\n                return True\n    return False\n\n\ndef mbm():\n    res = 0\n    matching = [-1] * y_num\n    for source in range(x_num):\n        visited = [False] * y_num\n        if dfs(source, matching, visited):\n            res += 1\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    adj_table = tuple(set() for _ in range(x_num))\n    for edge in edges:\n        vx, vy = map(int, edge)\n        adj_table[vx].add(vy)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "class Node():\n    def __init__(self):\n        self.edge = []\n        self.level = None\n        self.par = None\n        self.cap = 10**18\n\nclass Edge():\n    def __init__(self, to, cap, rev=None):\n        self.to = to\n        self.cap = cap\n        self.rev = rev\n\nfrom collections import deque\n\nclass BipartiteMatching():\n    def __init__(self, n, m):\n        self.n = n\n        self.m = m\n        self.inf = 10**18\n        self.source = Node()\n        self.sink = Node()\n        self.lt = [Node() for _ in range(n)]\n        self.rt = [Node() for _ in range(m)]\n        for i in range(n):\n            edge = Edge(self.lt[i], 1)\n            rev = Edge(self.source, 0)\n            edge.rev, rev.rev = rev, edge\n            self.source.edge.append(edge)\n            self.lt[i].edge.append(rev)\n        for i in range(m):\n            edge = Edge(self.sink, 1)\n            rev = Edge(self.rt[i], 0)\n            edge.rev, rev.rev = rev, edge\n            self.rt[i].edge.append(edge)\n            self.sink.edge.append(rev)\n\n    def add(self, x, y):\n        lt = self.lt[x]\n        rt = self.rt[y]\n        edge = Edge(rt, 1)\n        rev = Edge(lt, 0)\n        edge.rev, rev.rev = rev, edge\n        lt.edge.append(edge)\n        rt.edge.append(rev)\n\n    def maximum_matching(self):\n        flow = 0\n        while True:\n            queue = deque([self.source])\n            self.source.level = 0\n            self.sink.level = None\n            for i in range(self.n):\n                self.lt[i].level = None\n            for i in range(self.m):\n                self.rt[i].level = None\n            while queue:\n                node = queue.popleft()\n                for edge in node.edge:\n                    to = edge.to\n                    if edge.cap and to.level is None:\n                        to.level = node.level + 1\n                        queue.append(to)\n            if self.sink.level is None: break\n            stack = [self.source]\n            self.source.par = None\n            self.sink.par = None\n            for i in range(self.n):\n                self.lt[i].par = None\n            for i in range(self.m):\n                self.rt[i].par = None\n            while stack:\n                node = stack.pop()\n                if node is self.sink:\n                    break\n                for edge in node.edge:\n                    to = edge.to\n                    if edge.cap and node.level < to.level:\n                        to.par = edge.rev\n                        #to.cap = min(edge.cap, node.cap)\n                        stack.append(to)\n            node = self.sink\n            delta = node.cap\n            while node is not self.source:\n                node.par.cap = 1\n                node.par.rev.cap = 0\n                node = node.par.to\n            flow += 1\n        return flow\n\nimport sys\ninput = sys.stdin.readline\n\nN, M, E = map(int, input().split())\nbm = BipartiteMatching(N, M)\nfor _ in range(E):\n    x, y = map(int, input().split())\n    bm.add(x, y)\nprint(bm.maximum_matching())\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef generate_adj_table(_edges):\n    for edge in _edges:\n        vx, vy = map(int, edge)\n        init_adj_table[vx].append(vy)\n\n    return init_adj_table\n\n\ndef graph_dfs(current, matching, visited):\n    for adj in range(y_num):\n        if adj in adj_table[current] and not visited[adj]:\n            visited[adj] = True\n            if matching[adj] == -1 or graph_dfs(matching[adj], matching, visited):\n                matching[adj] = current\n                return True\n    return False\n\n\ndef mbm():\n    matching = [-1] * y_num\n    res = 0\n    for v in range(x_num):\n        visited = [False] * y_num\n        if graph_dfs(v, matching, visited):\n            res += 1\n    print(matching)\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    v_num = x_num + y_num\n    init_adj_table = [[] for _ in range(x_num)]\n    adj_table = generate_adj_table(edges)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef dfs(here,used,match,connect):\n    used[here] = 1\n    for near in connect[here]:\n        m = match[near]\n        if m < 0 or (not used[m] and dfs(m,used,match,connect)):\n            match[here] = near\n            match[near] = here\n            return 1\n    return 0\n\na_num, b_num, e_num = (int(n) for n in input().split(\" \"))\nconnect = defaultdict(list)\nall_v = a_num + b_num\nmatch = [-1 for n in range(all_v)]\nfor _ in range(e_num):\n    v1, v2 = (int(n) for n in input().split(\" \"))\n    v2 += a_num\n    connect[v1].append(v2)\n    connect[v2].append(v1)\nanswer = 0\nfor i in range(all_v):\n    if match[i] < 0:\n        used = [0 for n in range(all_v)]\n        if dfs(i,used,match,connect):\n            answer += 1\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nclass HopcroftKarp:\n    def __init__(self, N0, N1):\n        self.N0 = N0; self.N1 = N1\n        self.N = N = 2 + N0 + N1\n        self.E = E = [[] for _ in range(N)]\n        for end in range(N0): # vertex 0 is the source\n            v = end + 2\n            E[0].append([v, 1, len(E[v])])\n            E[v].append([0, 0, len(E[0]) - 1])\n        for init in range(N1): # vertex 1 is the sink\n            u = init + N0 + 2\n            E[u].append([1, 1, len(E[1])])\n            E[1].append([u, 0, len(E[u]) - 1])\n    \n    def add_edge(self, p1, p2):\n        '''\n            e[0] = the head vertex of e,\n            e[1] = current capacity of e,\n            e[2] = the index of reverse edge of e.\n        '''\n        p1 += 2; p2 += self.N0 + 2\n        self.E[p1].append([p2, 1, len(self.E[p2])])\n        self.E[p2].append([p1, 0, len(self.E[p1]) - 1])\n    \n    def _exist_augpath(self):\n        self.level = level = [-1] * self.N # the level (depth) of each vertex\n        E = self.E\n        q = deque([(0, 0)]) # (vertex, level)\n        while q:\n            v, lv = q.popleft()\n            if level[v] < 0: # visited v for the first time\n                level[v] = lv\n                for u, cap, _ in E[v]:\n                    if cap == 0 or level[u] >= 0: continue\n                    q.append((u, lv + 1))\n        return level[1] >= 0\n    \n    def _blocking_flow(self):\n        s = 0; t = 1\n        aug_flow = 0\n        finished = [False] * self.N\n        parent = [-1] * self.N\n        revs = [-1] * self.N\n        bottleneck = -1; temp_flow = 0\n        level, E = self.level, self.E\n        stack = [(s, -1, float('inf'), -1, 0)] # (vertex, parent, flow, rev_idx, status)\n        while stack:\n            v, p, f, rev, st = stack.pop()\n            if temp_flow and v != bottleneck: continue\n            if st == 0 and not finished[v]:\n                parent[v] = p; revs[v] = rev\n                if temp_flow: # offset\n                    f -= temp_flow; temp_flow = 0; bottleneck = -1\n                if v == t: # an augment path is found\n                    aug_flow += f\n                    if p != -1: stack += [(v, p, f, rev, 3)]\n                    continue\n                n_children = 0\n                for u, cap, rev_idx in E[v]:\n                    if cap == 0 or finished[u] or level[u] != level[v] + 1: continue\n                    if n_children == 0:\n                        stack += [(v, p, 0, rev, 2), (u, v, min(f, cap), rev_idx, 0)]\n                        n_children += 1\n                    else:\n                        stack += [(v, p, 0, rev, 1), (u, v, min(f, cap), rev_idx, 0)]\n                        n_children += 1\n                if n_children == 0: # v is a leaf\n                    finished[v] = True\n            elif st == 1: # now searching\n                continue\n            elif st == 2: # search finished\n                finished[v] = True\n            else: # edge update\n                rev_e = E[v][rev]; e = E[p][rev_e[2]]\n                e[1] -= f; rev_e[1] += f\n                if e[1] == 0: bottleneck = p\n                if parent[p] != -1: stack += [(p, parent[p], f, revs[p], 3)]\n                else: temp_flow = f\n        return aug_flow\n    \n    def max_matching(self):\n        matching = 0\n        exist_augpath, blocking_flow = self._exist_augpath, self._blocking_flow\n        while True:\n            if not exist_augpath(): break\n            matching += blocking_flow()\n        return matching\n\nN0, N1, M = map(int, input().split())\nhk = HopcroftKarp(N0, N1)\nfor _ in range(M):\n    u, v = map(int, input().split())\n    hk.add_edge(u, v)\nprint(hk.max_matching())\n"
  },
  {
    "language": "Python",
    "code": "# Acceptance of input\n\nimport sys\n\nfile_input = sys.stdin\n\nX, Y, E = map(int, file_input.readline().split())\n\nv_num = X + Y + 2\n\nadj_mat = [[0] * (v_num) for i in range(v_num)]\n\nfor line in file_input:\n    x, y = map(int, line.split())\n    adj_mat[x][X + y] = 1\n\ns = X + Y\nt = s + 1\n\nfor i in range(X):\n    adj_mat[s][i] = 1\n\nfor i in range(X, s):\n    adj_mat[i][t] = 1\n\n# Dinic's algorithm\n\nimport collections\n\n# BFS for residual capacity network to construct level graph\ndef bfs(start, goal, parent):\n    unvisited = [True] * v_num\n    queue = collections.deque()\n    queue.append(start)\n    unvisited[start] = False\n    while queue:\n        u = queue.popleft()\n        for v, r_capacity in enumerate(adj_mat[u]):\n            if unvisited[v] and (r_capacity > 0):\n                parent[v].append(u)\n                queue.append(v)\n                unvisited[v] = False\n    return unvisited[goal]\n\n# DFS for level graph and construct blocking flow\ndef dfs(goal, path, parent, blocking_flow):\n    v = path[-1]\n    if v == goal:\n        aug_path_flow = 10000\n        for x, y in zip(path[1:], path[:-1]):\n            aug_path_flow = min(aug_path_flow, adj_mat[x][y])\n        for x, y in zip(path[1:], path[:-1]):\n            adj_mat[x][y] -= aug_path_flow\n            adj_mat[y][x] += aug_path_flow\n        blocking_flow[0] += aug_path_flow\n    else:\n        for u in parent[v]:\n            path.append(u)\n            dfs(goal, path, parent, blocking_flow)\n            path.pop()\n\ndef dinic(source, sink):\n    max_flow = 0\n    parent = [[] for i in range(v_num)]\n    while not bfs(source, sink, parent):\n        blocking_flow = [0]\n        path = [sink]\n        # search in reverse direction from sink\n        dfs(source, path, parent, blocking_flow)\n        max_flow += blocking_flow[0]\n        parent = [[] for i in range(v_num)]\n    return max_flow\n\n# output\nprint(dinic(s, t))"
  },
  {
    "language": "Python",
    "code": "import collections\nclass Dinic:\n    def __init__(self, n):\n        self.n = n\n        self.g = [[] for i in range(n)]\n    def add_edge(self, fr, to, cap):\n        self.g[fr].append([to, cap, len(self.g[to])])\n        self.g[to].append([fr, 0, len(self.g[fr])-1])\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        self.g[v1].append([v2, cap1, len(self.g[v2])])\n        self.g[v2].append([v1, cap2, len(self.g[v1])-1])\n    def bfs(self, s):\n        level = [-1]*self.n\n        deq = collections.deque()\n        level[s] = 0\n        deq.append(s)\n        while deq:\n            v = deq.popleft()\n            for e in self.g[v]:\n                if e[1]>0 and level[e[0]]<0:\n                    level[e[0]] = level[v] + 1\n                    deq.append(e[0])\n        self.level = level\n    def dfs(self, v, t, f):\n        if v==t: return f\n        es = self.g[v]\n        level = self.level\n        for i in range(self.it[v], len(self.g[v])):\n            e = es[i]\n            if e[1]>0 and level[v]<level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d>0:\n                    e[1] -= d\n                    self.g[e[0]][e[2]][1] += d\n                    self.it[v] = i\n                    return d\n        self.it[v] = len(self.g[v])\n        return 0\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t]<0: break\n            self.it = [0]*self.n\n            while True:\n                f = self.dfs(s, t, 10**9+7)\n                if f>0:\n                    flow += f\n                else:\n                    break\n        return flow\n\nX, Y, E = map(int, input().split())\ndinic = Dinic(2+X+Y)\nfor i in range(X):\n    dinic.add_edge(0, 2+i, 1)\nfor i in range(Y):\n    dinic.add_edge(2+X+i, 1, 1)\nfor i in range(E):\n    x, y = map(int, input().split())\n    dinic.add_edge(2+x, 2+X+y, 1)\nprint(dinic.max_flow(0, 1))"
  },
  {
    "language": "Python",
    "code": "def dfs(s):\n    if s in settled:\n        return False\n    stack = [s]\n    visited = set()\n    is_y = False\n    while stack:\n        vertex = stack.pop()\n        if is_y and vertex not in settled:\n            settled.add(s)\n            settled.add(vertex)\n            return True\n        if vertex in visited:\n            continue\n        visited.add(vertex)\n        stack.extend(edges[vertex] - visited)\n        is_y = not is_y\n    return False\n\n\nxn, yn, e = map(int, input().split())\nedges = [set() for _ in range(xn + yn)]\nsettled = set()\n\nfor _ in range(e):\n    x, y = map(int, input().split())\n    y += xn\n    edges[x].add(y)\n    edges[y].add(x)\n\nprint(sum(map(dfs, range(xn))))"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n3 4 6\n0 0\n0 2\n0 3\n1 1\n2 1\n2 3\n\noutput:\n3\n\"\"\"\n\nimport sys\n\n\ndef generate_adj_table(_edges):\n    for edge in _edges:\n        vx, vy = map(int, edge)\n        init_adj_table[vx].append(vy)\n\n    return init_adj_table\n\n\ndef graph_dfs(current, matching, visited):\n    for adj in range(y_num):\n        if adj in adj_table[current] and not visited[adj]:\n            visited[adj] = True\n            if matching[adj] == -1 or graph_dfs(matching[adj], matching, visited):\n                matching[adj] = current\n                return True\n    return False\n\n\ndef mbm():\n    matching = [-1] * y_num\n    res = 0\n    for v in range(x_num):\n        visited = [False] * y_num\n        if graph_dfs(v, matching, visited):\n            res += 1\n    # print(matching)\n    return res\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    x_num, y_num, e_num = map(int, _input[0].split())\n    edges = map(lambda x: x.split(), _input[1:])\n\n    # v_num = x_num + y_num\n    init_adj_table = [[] for _ in range(x_num)]\n    adj_table = generate_adj_table(edges)\n    print(mbm())"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\n\nclass Bipartite_Matching:\n    \"\"\"二部グラフの最大マッチングを求めるなどする\"\"\"\n\n    def __init__(self, input_graph: list):\n        \"\"\"重み無し二部グラフinput_graphを入力する\"\"\"\n        n = len(input_graph)\n        self.INF = float(\"inf\")\n        # DFSでグラフを2色に彩色する\n        visited = [-1] * n\n        for i in range(n):\n            if visited[i] >= 0:\n                continue\n            visited[i] = 0\n            q = deque([i]) \n            while q:\n                _from = q.pop()\n                for to in input_graph[_from]:\n                    if visited[to] >= 0:\n                        continue\n                    visited[to] = visited[_from] ^ 1\n                    q.append(to)\n\n        # 残余グラフを構築する\n        self.s = n\n        self.t = n + 1\n        self.n = n + 2\n        self.graph = [[] for i in range(self.n)]\n        used = set([])\n        for pos1 in range(n):\n            if visited[pos1] == 0:\n                self.add_edge(self.s, pos1)\n            else:\n                self.add_edge(pos1, self.t)\n            for pos2 in input_graph[pos1]:\n                if (min(pos1, pos2), max(pos1, pos2)) in used:\n                    continue\n                used.add((min(pos1, pos2), max(pos1, pos2)))\n                if visited[pos1] == 0:\n                    self.add_edge(pos1, pos2)\n                else:\n                    self.add_edge(pos2, pos1)\n \n    def add_edge(self, _from: int, to: int):\n        \"\"\"残余グラフを構築\n        1. _fromからtoへ向かう容量capacity = 1の辺をグラフに追加する\n        2. toから_fromへ向かう容量0の辺をグラフに追加する\n        \"\"\"\n        forward = [to, 1, None]\n        forward[2] = backward = [_from, 0, forward]\n        self.graph[_from].append(forward)\n        self.graph[to].append(backward)\n \n    def bfs(self, s: int, t: int):\n        \"\"\"capacityが正の辺のみを通ってsからtに移動可能かどうかBFSで探索\n        level: sからの最短路の長さ\n        \"\"\"\n        self.level = [-1] * self.n\n        q = deque([s])\n        self.level[s] = 0\n        while q:\n            _from = q.popleft()\n            for to, capacity, _ in self.graph[_from]:\n                if capacity > 0 and self.level[to] < 0:\n                    self.level[to] = self.level[_from] + 1\n                    q.append(to)\n \n    def dfs(self, _from: int, t: int, f: int) -> int:\n        \"\"\"流量が増加するパスをDFSで探索\n        BFSによって作られた最短路に従ってfを更新する\n        \"\"\"\n        if _from == t:\n            return f\n        for edge in self.itr[_from]:\n            to, capacity, reverse_edge = edge\n            if capacity > 0 and self.level[_from] < self.level[to]:\n                d = self.dfs(to, t, min(f, capacity))\n                if d > 0:\n                    edge[1] -= d\n                    reverse_edge[1] += d\n                    return d\n        return 0\n \n    def max_flow(self):\n        \"\"\"s-tパス上の最大流を求める = 最大マッチングを求める\n        計算量: O(|E||V|^2)\n        \"\"\"\n        flow = 0\n        while True:\n            self.bfs(self.s, self.t)\n            if self.level[self.t] < 0:\n                break\n            self.itr = list(map(iter, self.graph))\n            f = self.dfs(self.s, self.t, self.INF)\n            while f > 0:\n                flow += f\n                f = self.dfs(self.s, self.t, self.INF)\n        return flow\n\n\nx, y, e = map(int, input().split())\ngraph = [[] for i in range(x + y)]\n\nfor i in range(e):\n    tmp_x, tmp_y = map(int, input().split())\n    graph[tmp_x].append(tmp_y + x)\n    graph[tmp_y + x].append(tmp_x)\n\nmb = Bipartite_Matching(graph)\nprint(mb.max_flow())\n"
  },
  {
    "language": "Python",
    "code": "def dfs(v, visited):\n    for u in edges[v]:\n        if u in visited:\n            continue\n        visited.add(u)\n        if matched[u] == -1 or dfs(matched[u], visited):\n            matched[u] = v\n            return True\n    return False\n\n\nxn, yn, e = map(int, input().split())\nedges = [set() for _ in range(xn)]\nmatched = [-1] * yn\n\nfor _ in range(e):\n    x, y = map(int, input().split())\n    edges[x].add(y)\n\nprint(sum(map(lambda s: dfs(s, set()), range(xn))))"
  },
  {
    "language": "Python",
    "code": "\nclass Dinic:\n    def __init__(self, len_X, len_Y):\n        self.len_X, self.len_Y = len_X, len_Y\n        self.edges = [[] for _ in range(len_X)]\n        self.matched = [-1] * len_Y\n        self.visited = set()\n\n    def add_edge(self, x, y):\n        self.edges[x].append(y)\n\n    def dfs(self, x):\n        \"\"\"\n        :param x: X側の未マッチングの頂点の1つ\n        :param visited: 空のsetを渡す（外部からの呼び出し時）\n        :return: 増大路が見つかればTrue\n        \"\"\"\n        for next_x in self.edges[x]:\n            if next_x in self.visited:\n                continue\n            self.visited.add(next_x)\n            if self.matched[next_x] == -1 or self.dfs(self.matched[next_x]):\n                self.matched[next_x] = x\n                return True\n        return False\n\n    def solve(self):\n        res = 0\n        for x in range(self.len_X):\n            self.visited = set()\n            res += self.dfs(x)\n        return res\n\n#################################################################################################\n\n\nlen_X, len_Y, E = map(int, input().split())     # len_X, len_Y: 部分集合に含まれる頂点の数　E: 辺の数\n\n\ndinic = Dinic(len_X, len_Y)\n\nfor _ in range(E):\n    x, y = map(int, input().split())\n    dinic.add_edge(x,y)\n\n# 増大路発見に成功したらTrue(=1)。合計することでマッチング数となる\nprint(dinic.solve())\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "def dfs(u):\n    for v in range(nv):\n        if adj[u][v] and not visited[v]:\n            visited[v] = True\n            if matches[v] is None or dfs(matches[v]):\n                matches[v] = u\n                return True\n    return False\n\nnu, nv, ne = map(int, input().split(' '))\nadj = [[False] * nv for _ in range(nu)]\nmatches = [None] * nv\ncount = 0\n\nfor _ in range(ne):\n    s, t = map(int, input().split(' '))\n    adj[s][t] = True\n\nfor u in range(nu):\n    visited = [False] * nv\n    if dfs(u): count += 1\n\nprint(count)"
  },
  {
    "language": "Python",
    "code": "def read_data():\n    X, Y, E = map(int, input().split())\n    Ss = list(range(X))\n    Ts = list(range(X, X + Y))\n    Es = []\n    for i in range(E):\n        x, y = map(int, input().split())\n        Es.append((x, y + X))\n    return Ss, Ts, Es\n    \n\ndef bp_match(Ss, Ts, Es):\n    '''2??¨??°???????????????????????°???????????¨??????\n    '''\n    super_source = len(Ss) + len(Ts)\n    super_target = super_source + 1\n    Cs = [dict() for i in range(super_target + 1)]\n    for si, ti in Es:\n        Cs[si][ti] = 1\n        Cs[ti][si] = 0\n    for si in Ss:\n        Cs[super_source][si] = 1\n        Cs[si][super_source] = 0\n    for ti in Ts:\n        Cs[super_target][ti] = 0\n        Cs[ti][super_target] = 1\n    return dinic(Cs, super_target + 1, super_source, super_target)\n\ndef dinic(cf, nV, s, t):\n    dist = get_distance(cf, s, t)\n    while dist[t] > 0:\n        df = dfs(dist, cf, s, t, float('inf'))\n        while df:\n            df = dfs(dist, cf, s, t, float('inf'))\n        dist = get_distance(cf, s, t)\n    return sum(cf[t].values())\n\ndef get_distance(cf, s, t):\n    dist = [-1] * len(cf)\n    dist[s] = 0\n    frontiers = [s]\n    while frontiers:\n        new_frontiers = []\n        for u in frontiers:\n            for v, capacity in cf[u].items():\n                if dist[v] == -1 and capacity > 0:\n                    dist[v] = dist[u] + 1\n                    new_frontiers.append(v)\n        frontiers = new_frontiers\n    return dist\n\ndef dfs(dist, cf, u, t, df):\n    if u == t:\n        return df\n    for v, capacity in cf[u].items():\n        if dist[v] > dist[u] and capacity > 0:\n            new_df = dfs(dist, cf, v, t, min(df, capacity))\n            if new_df > 0:\n                cf[u][v] -= new_df\n                cf[v][u] += new_df\n                return new_df\n    return 0\n\nif __name__ == '__main__':\n#    Ss = [0, 1, 2, 3, 4]\n#    Ts = [5, 6, 7, 8]\n#    Es = [(0, 5), (1, 5), (1, 7), (2, 6), (2, 7), (2, 8), (3, 7), (4, 7)]\n    Ss, Ts, Es = read_data()\n    print(bp_match(Ss, Ts, Es))"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nclass Dinic:\n    def __init__(self, N):\n        self.N = N\n        self.G = [[] for i in range(N)]\n\n    def add_edge(self, fr, to, cap):\n        forward = [to, cap, None]\n        forward[2] = backward = [fr, 0, forward]\n        self.G[fr].append(forward)\n        self.G[to].append(backward)\n\n    def add_multi_edge(self, v1, v2, cap1, cap2):\n        edge1 = [v2, cap1, None]\n        edge1[2] = edge2 = [v1, cap2, edge1]\n        self.G[v1].append(edge1)\n        self.G[v2].append(edge2)\n\n    def bfs(self, s, t):\n        self.level = level = [None]*self.N\n        deq = deque([s])\n        level[s] = 0\n        G = self.G\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        return level[t] is not None\n\n    def dfs(self, v, t, f):\n        if v == t:\n            return f\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w]:\n                d = self.dfs(w, t, min(f, cap))\n                if d:\n                    e[1] -= d\n                    rev[1] += d\n                    return d\n        return 0\n\n    def flow(self, s, t):\n        flow = 0\n        INF = 10**9 + 7\n        G = self.G\n        while self.bfs(s, t):\n            *self.it, = map(iter, self.G)\n            f = INF\n            while f:\n                f = self.dfs(s, t, INF)\n                flow += f\n        return flow\n\nx,y,e = map(int, input().split())\ns = x+y\nt = x+y+1\ndinic = Dinic(x+y+2)\n\nfor _ in range(e):\n    xv,yv = map(int, input().split())\n    dinic.add_edge(xv,x+yv,1)\n\nfor xv in range(x):\n    dinic.add_edge(s,xv,1)\nfor yv in range(x,x+y):\n    dinic.add_edge(yv,t,1)\n\nprint(dinic.flow(s,t))\n"
  },
  {
    "language": "Python",
    "code": "# Hopcroft-Karp Algorithm\nfrom collections import deque\nclass HopcroftKarp:\n    def __init__(self, N0, N1):\n        self.N0 = N0\n        self.N1 = N1\n        self.N = N = 2+N0+N1\n        self.G = [[] for i in range(N)]\n        for i in range(N0):\n            forward = [2+i, 1, None]\n            forward[2] = backward = [0, 0, forward]\n            self.G[0].append(forward)\n            self.G[2+i].append(backward)\n        self.backwards = bs = []\n        for i in range(N1):\n            forward = [1, 1, None]\n            forward[2] = backward = [2+N0+i, 0, forward]\n            bs.append(backward)\n            self.G[2+N0+i].append(forward)\n            self.G[1].append(backward)\n\n    def add_edge(self, fr, to):\n        #assert 0 <= fr < self.N0\n        #assert 0 <= to < self.N1\n        v0 = 2 + fr\n        v1 = 2 + self.N0 + to\n        forward = [v1, 1, None]\n        forward[2] = backward = [v0, 0, forward]\n        self.G[v0].append(forward)\n        self.G[v1].append(backward)\n\n    def bfs(self):\n        G = self.G\n        level = [None]*self.N\n        deq = deque([0])\n        level[0] = 0\n        while deq:\n            v = deq.popleft()\n            lv = level[v] + 1\n            for w, cap, _ in G[v]:\n                if cap and level[w] is None:\n                    level[w] = lv\n                    deq.append(w)\n        self.level = level\n        return level[1] is not None\n\n    def dfs(self, v, t):\n        if v == t:\n            return 1\n        level = self.level\n        for e in self.it[v]:\n            w, cap, rev = e\n            if cap and level[v] < level[w] and self.dfs(w, t):\n                e[1] = 0\n                rev[1] = 1\n                return 1\n        return 0\n\n    def flow(self):\n        flow = 0\n        N = self.N; G = self.G\n        bfs = self.bfs; dfs = self.dfs\n        while bfs():\n            *self.it, = map(iter, G)\n            while dfs(0, 1):\n                flow += 1\n        return flow\n\n    def matching(self):\n        return [cap for _, cap, _ in self.backwards]\n\n\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nX, Y, E = map(int, readline().split())\n\nhc = HopcroftKarp(X, Y)\nfor i in range(E):\n    x, y = map(int, readline().split())\n    hc.add_edge(x, y)\n\nwrite(\"%d\\n\" % hc.flow())\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\ndef dfs(here,used,match,connect):\n    used[here] = 1\n    for near in connect[here]:\n        m = match[near]\n        if m < 0 or (not used[m] and dfs(m,used,match,connect)):\n            match[here] = near\n            match[near] = here\n            return 1\n    return 0\n\na_num, b_num, e_num = (int(n) for n in input().split(\" \"))\nconnect = defaultdict(list)\nall_v = a_num + b_num\nmatch = [-1 for n in range(all_v)]\nfor _ in range(e_num):\n    v1, v2 = (int(n) for n in input().split(\" \"))\n    v2 += a_num\n    connect[v1].append(v2)\n    connect[v2].append(v1)\nanswer = 0\nfor i in range(all_v):\n    if match[i] < 0:\n        if dfs(i,used,match,connect):\n            used = [0 for n in range(all_v)]\n            answer += 1\nprint(answer)"
  },
  {
    "language": "Rust",
    "code": "use std::cmp::min;\nuse std::io::{stdin, Read};\n\nmacro_rules! parse {\n    ($it: ident) => {\n        $it.next().unwrap().parse().unwrap()\n    };\n    ($it: ident,2) => {\n        (parse!($it), parse!($it))\n    };\n    ($it: ident,3) => {\n        (parse!($it), parse!($it), parse!($it))\n    };\n    ($it: ident,4) => {\n        (parse!($it), parse!($it), parse!($it), parse!($it))\n    };\n    ($it: ident, $n: ident) => {\n        (&mut $it).take($n).map(|e| e.parse().unwrap()).collect();\n    };\n}\n\nfn dfs(\n    g: &Vec<Vec<usize>>,\n    s: usize,\n    t: usize,\n    parents: &mut Vec<usize>,\n    seen: &mut Vec<bool>,\n) -> bool {\n    seen[s] = true;\n    if s == t {\n        true\n    } else {\n        let n = g.len();\n        for v in 0..n {\n            if !seen[v] && g[s][v] > 0 && dfs(g, v, t, parents, seen) {\n                parents[v] = s;\n                return true;\n            }\n        }\n        false\n    }\n}\nfn calc_maxflow(g: &Vec<Vec<usize>>, s: usize, t: usize) -> usize {\n    let n = g.len();\n    let mut ret = 0;\n    let mut parents = vec![0; n];\n    let mut seen = vec![false; n];\n    let mut rg = g.clone();\n    while dfs(&rg, s, t, &mut parents, &mut seen) {\n        let mut d = std::usize::MAX;\n        let mut v = t;\n        while v != s {\n            let u = parents[v];\n            d = min(d, rg[u][v]);\n            v = u;\n        }\n        ret += d;\n        let mut v = t;\n        while v != s {\n            let u = parents[v];\n            rg[u][v] -= d;\n            rg[v][u] += d;\n            v = u;\n        }\n        seen = vec![false; n];\n    }\n    ret\n}\n\nfn main() {\n    let mut s = String::new();\n    stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.split_whitespace();\n    let (x, y, e): (usize, usize, usize) = parse!(it, 3);\n    let n = x + y + 2;\n    let mut g = vec![vec![0; n]; n];\n    for i in 0..x {\n        g[0][i + 1] = 1;\n    }\n    for j in 0..y {\n        g[1 + x + j][n - 1] = 1;\n    }\n    for _ in 0..e {\n        let (xi, yi): (usize, usize) = parse!(it, 2);\n        let xi = 1 + xi;\n        let yi = 1 + x + yi;\n        g[xi][yi] = 1;\n    }\n    println!(\"{}\", calc_maxflow(&g, 0, n - 1));\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::VecDeque;\n\n#[derive(Debug, Clone)]\nstruct Edge {\n    capacity: i64,\n    to: usize,\n    // If edge is u-> edge{to:v, rev:i},\n    // then, the reverse edge would be edges[v][rev]\n    rev: usize,\n}\n\nimpl Edge {\n    fn new(to: usize, capacity: i64, rev: usize) -> Self {\n        Self { to, capacity, rev }\n    }\n}\n\nconst BIG: i64 = 100_000_000_000;\n#[derive(Debug, Clone)]\nstruct Dinic {\n    level: Vec<usize>,\n    checked: Vec<usize>, // The memolized DFS.\n    edges: Vec<Vec<Edge>>,\n    size: usize,\n}\n\nimpl Dinic {\n    fn new(graph: Vec<Vec<(usize, i64)>>) -> Self {\n        let size = graph.len();\n        let level = vec![size + 1; size];\n        let checked = vec![size + 1; size];\n        let mut edges = vec![vec![]; size];\n        for (from, targets) in graph.iter().enumerate() {\n            for &(to, cap) in targets {\n                let rev_from = edges[to].len();\n                let rev_to = edges[from].len();\n                edges[from].push(Edge::new(to, cap, rev_from));\n                edges[to].push(Edge::new(from, 0, rev_to));\n            }\n        }\n        Self {\n            level,\n            checked,\n            edges,\n            size,\n        }\n    }\n    // Update level member. Calculate the smallest 'number' of edges from `start`.\n    fn bfs(&mut self, start: usize) {\n        self.level = vec![self.size+1;self.size];\n        let mut queue = VecDeque::new();\n        self.level[start] = 0;\n        queue.push_back(start);\n        while let Some(from) = queue.pop_front() {\n            for edge in &self.edges[from] {\n                if edge.capacity > 0 && self.level[edge.to] == self.size + 1 {\n                    self.level[edge.to] = self.level[from] + 1;\n                    queue.push_back(edge.to);\n                }\n            }\n        }\n    }\n    // Search for an argument path.\n    // return the flow value\n    fn dfs(&mut self, node: usize, end: usize, flow: i64) -> i64 {\n        // eprintln!(\"->{}\",node);\n        if node == end {\n            return flow;\n        }\n        for edge_idx in self.checked[node]..self.edges[node].len() {\n            self.checked[node] = edge_idx;\n            let edge = self.edges[node][edge_idx].clone();\n            //eprintln!(\"{},{} ({})\",node,edge.to,edge.capacity);\n            if edge.capacity > 0 && self.level[node] < self.level[edge.to] {\n                let next_flow = self.dfs(edge.to, end, std::cmp::min(edge.capacity, flow));\n                if next_flow > 0 {\n                    self.edges[node][edge_idx].capacity -= next_flow;\n                    self.edges[edge.to][edge.rev].capacity += next_flow;\n                    return next_flow;\n                }\n            }\n        }\n        return 0;\n    }\n    fn max_flow(&mut self, start: usize, end: usize) -> i64 {\n        let mut flow = 0;\n        loop {\n            self.bfs(start);\n            if self.level[end] == self.size + 1 {\n                return flow;\n            }\n            self.checked = vec![0; self.size];\n            loop {\n                let f = self.dfs(start, end, BIG);\n                // eprintln!(\"flow: {}\",f);\n                if f > 0 {\n                    flow += f;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n}\n\nfn solve(graph: Vec<Vec<(usize, i64)>>, start: usize, end: usize){\n    let mut dinic = Dinic::new(graph);\n    let flow = dinic.max_flow(start, end);\n    println!(\"{}\",flow);\n}\n\nuse std::io::{BufRead, BufReader};\nfn main() {\n    let mut read = BufReader::new(std::io::stdin())\n        .lines()\n        .filter_map(|e| e.ok());\n    let (x, y, _e) = {\n        let line = read.next().unwrap();\n        let line: Vec<&str> = line.split(' ').collect();\n        let x: usize = line[0].parse().unwrap();\n        let y: usize = line[1].parse().unwrap();\n        let e: usize = line[2].parse().unwrap();\n        (x,y, e)\n    };\n    let graph = {\n        let mut graph: Vec<Vec<_>> = vec![vec![]; 2+x+y]; // Adj list\n        for edge in read {\n            let mut edge = edge.split(' ');\n            let start: usize = edge.next().unwrap().parse().unwrap();\n            let end: usize = edge.next().unwrap().parse().unwrap();\n            // Set weight as 1.\n            graph[start+1].push((end+x+1,1)); \n        }\n        for i in 1..x+1{\n            // Start -> X edges\n            graph[0].push((i,1));\n        }\n        for i in x+1..x+y+1{\n            // Y -> End edges.\n            graph[i].push((x+y+1,1));\n        }\n        graph\n    };\n    solve(graph, 0, x+y+1);\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[derive(Clone,Copy,Eq,PartialEq,Debug)]\npub struct Vite(pub usize);\n\n#[derive(Clone,Copy,Eq,PartialEq,Debug)]\npub struct Eite(pub usize);\n\npub trait Edge {\n    fn from(&self) -> Vite;\n    fn to(&self) -> Vite;\n}\n\npub trait Vertex {\n    fn new(id : usize) -> Self;\n    fn id(&self) -> usize;\n}\n\npub trait Graph<'a, V: Vertex, E: Edge> {\n    type EsIter: std::iter::Iterator<Item=&'a Eite>;\n    fn add_edge(&mut self, e: E);\n    fn delta(&'a self, v: &Vite) -> Self::EsIter;\n    fn edge(&self, e: &Eite) -> &E;\n    fn vertex(&self, v: &Vite) -> &V;\n    fn v_size(&self) -> usize;\n    fn e_size(&self) -> usize;\n}\n\npub fn from<E: Edge>(f: Vite, e: &E) -> Vite {\n    if e.from() == f { e.from() }\n    else { e.to() }\n}\n\npub fn to<E: Edge>(f: Vite, e: &E) -> Vite {\n    if e.from() == f { e.to() }\n    else { e.from() }\n}\n\npub trait Directed<'a,V: Vertex, E: Edge>: Graph<'a,V,E> {  }\npub trait Undirected<'a,V: Vertex, E: Edge>: Graph<'a,V,E> {  }\npub trait Bipartite<'a,V: Vertex, E: Edge>: Graph<'a,V,E> { \n    fn left_size(&self) -> usize;\n    fn right_size(&self) -> usize;\n    fn left_vs(&self) -> std::slice::Iter<Vite>;\n    fn right_vs(&self) -> std::slice::Iter<Vite>;\n}\n\npub struct BipartiteUndirectedGraph<V: Vertex, E: Edge> {\n    le: usize,\n    ri: usize,\n    m: usize,\n    g: Vec<Vec<Eite>>,\n    es: Vec<E>,\n    vs: Vec<V>,\n    ls: Vec<Vite>,\n    rs: Vec<Vite>\n}\n\nimpl<'a, V: Vertex, E: Edge> Graph<'a,V,E> for BipartiteUndirectedGraph<V,E> {\n    type EsIter = std::slice::Iter<'a,Eite>;\n    fn add_edge(&mut self, e: E) { \n        assert!(e.from().0 < self.le);\n        assert!(self.le <= e.to().0 && e.to().0 < self.le + self.ri);\n        let ei = Eite(self.m);\n        self.m += 1;\n        self.g[e.from().0].push(ei);\n        self.g[e.to().0].push(ei);\n        self.es.push(e);\n    }\n    fn delta(&'a self, v: &Vite) -> Self::EsIter {\n        self.g[v.0].iter()\n    }\n    fn edge(&self, e: &Eite) -> &E {\n        &self.es[e.0]\n    }\n    fn vertex(&self, v: &Vite) -> &V {\n       &self.vs[v.0]\n    }\n    fn v_size(&self) -> usize {\n        self.le + self.ri\n    }\n    fn e_size(&self) -> usize {\n        self.m\n    }\n}\n\nimpl<'a,V: Vertex, E: Edge> Undirected<'a,V,E> for BipartiteUndirectedGraph<V,E> {  }\nimpl<'a,V: Vertex, E: Edge> Bipartite<'a,V,E> for BipartiteUndirectedGraph<V,E> { \n    fn left_size(&self) -> usize { self.le }\n    fn right_size(&self) -> usize { self.ri }\n    fn left_vs(&self) -> std::slice::Iter<Vite> { self.ls.iter() }\n    fn right_vs(&self) -> std::slice::Iter<Vite> { self.rs.iter() }\n}\n\nimpl<V: Vertex, E: Edge> BipartiteUndirectedGraph<V,E> {\n     pub fn new(le: usize, ri: usize) -> BipartiteUndirectedGraph<V,E> { \n         BipartiteUndirectedGraph { \n             le: le,\n             ri: ri,\n             m: 0,\n             g: vec![Vec::<Eite>::new(); le + ri],\n             es: Vec::<E>::new(),\n             vs: Vec::<V>::new(),\n             ls: (0..le).map(|i| Vite(i)).collect(),\n             rs: (le..le+ri).map(|i| Vite(i)).collect()\n         }\n     }\n}\n\n\nuse std::collections::vec_deque::*;\n\npub fn hk_dfs<'a,V,E,G>(g:&'a G, v: &Vite, dist: &mut Vec<i32>, mate: &mut Vec<Option<usize>>, used: &mut Vec<bool>, vis: &mut Vec<bool>) -> bool\nwhere V: Vertex, E: Edge, G: Bipartite<'a,V,E> + Undirected<'a,V,E> {\n    vis[v.0] = true;\n    for e in g.delta(v) {\n        let to = to(*v, g.edge(e));\n        let ok = match mate[to.0] {\n            Some(m) => {\n                if !vis[m] && dist[m] == dist[v.0] + 1 && hk_dfs(g,&Vite(m),dist,mate,used,vis) {\n                    true\n                }\n                else {\n                    false\n                }\n            }\n            None => {\n                true\n            }\n        };\n        if ok {\n            mate[to.0] = Some(v.0);\n            used[v.0] = true;\n            return true;\n        }\n    }\n\n    false\n}\n\npub fn hopcroft_karp<'a,V,E,G>(g: &'a G) -> Vec<(Vite,Vite)>\nwhere V: Vertex, E: Edge, G: Bipartite<'a,V,E> + Undirected<'a,V,E> {\n    let mut ans = Vec::<(Vite,Vite)>::new();\n    let n = g.v_size();\n    \n    let mut mate: Vec<Option<usize>> = vec![None;n];\n    let mut used = vec![false;n];\n\n    loop {\n        let mut vis = vec![false;n];\n        let mut dist = vec![-1;n];\n        let mut que = VecDeque::new();\n\n        for i in 0..n {\n            if !used[i] {\n                que.push_back(i);\n                dist[i] = 0;\n            }\n        }\n\n        while let Some(v) = que.pop_front() {\n            for e in g.delta(&Vite(v)) {\n                let to = to(Vite(v), g.edge(e));\n                if let Some(m) = mate[to.0] {\n                    if dist[m] == -1 {\n                        dist[m] = dist[v] + 1;\n                        que.push_back(m);\n                    }\n                }\n            }\n        }\n\n        let mut has_end = true;\n        for i in g.left_vs() {\n            if !used[i.0] && hk_dfs(g,i,&mut dist,&mut mate,&mut used,&mut vis) {\n                has_end = false;\n            }\n        }\n        if has_end {\n            break;\n        }\n    }\n\n    for i in g.right_vs() {\n        if let Some(m) = mate[i.0] {\n            ans.push((i.clone(),Vite(m)));\n        }\n    }\n    ans\n}\nstruct Ver {\n    i: usize\n}\n  \nimpl Vertex for Ver {\n    fn new(id: usize) -> Self {\n        Ver {\n            i: id\n        }\n    }\n    fn id(&self) -> usize { self.i }\n}\n  \nstruct WEdge {\n    from: Vite,\n    to: Vite,\n}\n  \nimpl Edge for WEdge {\n    fn from(&self) -> Vite { self.from } \n    fn to(&self) -> Vite { self.to }\n}\n  \nfn main() {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    let v:Vec<usize> = s.trim().split_whitespace()\n        .map(|e|e.parse().unwrap()).collect();\n    let (a,b,e) = (v[0] , v[1] , v[2]);\n    let mut g = BipartiteUndirectedGraph::<Ver, WEdge>::new(a,b);\n    for _ in 0..e{\n        let mut t = String::new();\n        std::io::stdin().read_line(&mut t).unwrap();\n        let x:Vec<usize> = t.trim().split_whitespace()\n            .map(|e|e.parse().unwrap()).collect();\n        let (v,u) = (x[0],a + x[1]);\n        g.add_edge(WEdge{ from: Vite(v), to: Vite(u) });\n    }\n    let res = hopcroft_karp(&g);\n    println!(\"{}\",res.len());\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::Write;\n\n#[allow(unused)]\nmacro_rules! debug {\n    ($($format:tt)*) => (write!(std::io::stderr(), $($format)*).unwrap());\n}\n#[allow(unused)]\nmacro_rules! debugln {\n    ($($format:tt)*) => (writeln!(std::io::stderr(), $($format)*).unwrap());\n}\n\nfn main() {\n    let (x, y, e): (usize, usize, usize) = {\n        let mut s = String::new();\n        std::io::stdin().read_line(&mut s).unwrap();\n        let s = s.trim_right().to_owned();\n        let mut ws = s.split_whitespace();\n        let a = ws.next().unwrap().parse().unwrap();\n        let b = ws.next().unwrap().parse().unwrap();\n        let c = ws.next().unwrap().parse().unwrap();\n        (a, b, c)\n    };\n\n    let edges: Vec<(usize, usize)> = {\n        let mut v: Vec<_> = Vec::new();\n        for _ in 0..e {\n            let (x, y): (usize, usize) = {\n                let mut s = String::new();\n                std::io::stdin().read_line(&mut s).unwrap();\n                let s = s.trim_right().to_owned();\n                let mut ws = s.split_whitespace();\n                let a = ws.next().unwrap().parse().unwrap();\n                let b = ws.next().unwrap().parse().unwrap();\n                (a, b)\n            };\n            v.push((x, y))\n        }\n        v\n    };\n\n    let ans = bipartite_matching(x, y, &edges);\n    println!(\"{}\", ans);\n}\n\ntype Graph = Vec<Vec<Edge>>;\n\n#[derive(Debug, Clone)]\nstruct Edge {\n    to: usize,\n    cap: usize,\n    rev: usize,\n}\n\nfn max_flow(source: usize, sink: usize, graph: &mut Graph) -> usize {\n    let n = graph.len();\n\n\n    let mut flow = 0;\n    loop {\n        let mut level: Vec<Option<usize>> = vec![None; n];\n        bfs(source, &graph, &mut level);\n        if level[sink].is_none() {\n            return flow;\n        }\n\n        let mut iter: Vec<usize> = vec![0; n];\n\n        let mut f = dfs(source, sink, std::usize::MAX, graph, &level, &mut iter);\n        while f > 0 {\n            flow += f;\n            f = dfs(source, sink, std::usize::MAX, graph, &level, &mut iter);\n        }\n    }\n}\n\nfn bfs(source: usize, graph: &Graph, level: &mut Vec<Option<usize>>) {\n    use std::collections::VecDeque;\n\n    let mut queue = VecDeque::new();\n    level[source] = Some(0);\n    queue.push_front(source);\n    while let Some(v) = queue.pop_back() {\n        for e in &graph[v] {\n            let l = level[v].unwrap();\n            if e.cap > 0 && level[e.to].is_none() {\n                level[e.to] = Some(l + 1);\n                queue.push_front(e.to);\n            }\n        }\n    }\n}\n\nfn dfs(v: usize, t: usize, f: usize, graph: &mut Graph, level: &Vec<Option<usize>>, iter: &mut Vec<usize>) -> usize {\n    if v == t {\n        return f;\n    }\n    for i in iter[v]..graph[v].len() {\n        let e = graph[v][i].clone();\n        if e.cap > 0 && level[v] < level[e.to] {\n            let d = dfs(e.to, t, std::cmp::min(f, e.cap), graph, level, iter);\n            if d > 0 {\n                graph[v][i].cap -= d;\n                graph[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    0\n}\n\n// 頂点集合X, Yからなる二部グラフの最大マッチング\nfn bipartite_matching(x: usize, y: usize, edges: &Vec<(usize, usize)>) -> usize {\n    // 0~(x - 1)がX、x~(x + y - 1)がY、x + yが始点、x + y + 1が終点\n    let mut graph: Graph = vec![vec![]; x + y + 2];\n    let source = x + y;\n    let sink = x + y + 1;\n\n    // 始点からX\n    for vertex in 0..x {\n        add_edge(source, vertex, 1, &mut graph);\n    }\n    // Yから終点\n    for vertex in x..(x + y) {\n        add_edge(vertex, sink, 1, &mut graph);\n    }\n    // X, Y間\n    for e in edges {\n        let (x1, y1) = *e;\n        add_edge(x1, y1 + x, 1, &mut graph);\n    }\n\n    // debugln!(\"edges: {:?}\", edges);\n    //\n    // // debug\n    // for (i, edges) in graph.iter().enumerate() {\n    //     debugln!(\"{}: {:?}\", i, edges);\n    // }\n\n    max_flow(source, sink, &mut graph)\n}\n\nfn add_edge(from: usize, to: usize, cap: usize, graph: &mut Graph) {\n    let l = graph[to].len();\n    graph[from].push(Edge {to: to, cap: cap, rev: l});\n    let l = graph[from].len();\n    graph[to].push(Edge {to: from, cap: 0, rev: l - 1});\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn main() {\n    input! {\n    x: usize, y: usize, e: usize,\n    xy: [(usize, usize); e],\n    }\n    let mut graph = Dinic::new(x+y+2);\n    for i in 0..x {\n        graph.add(x+y, i, 1, true);\n    }\n    for i in 0..y {\n        graph.add(i+x, x+y+1, 1, true);\n    }\n    for i in 0..e {\n        let (a, b) = xy[i];\n        graph.add(a, x+b, 1, true);\n    }\n    println!(\"{}\", graph.max_flow(x+y, x+y+1));\n}\n\nconst INF: usize = 1 << 61;\nuse std::collections::VecDeque;\nuse std::cmp::min;\n\n\nstruct Dinic {\n    n: usize,\n    edges: Vec<Vec<(usize, i64, i64)>>, // adjacent list\n    level: Vec<i64>,\n    iter: Vec<usize>\n}\n\nimpl Dinic {\n    fn new(n: usize) -> Self {\n        Dinic {\n            n,\n            edges: vec![Vec::new(); n],\n            level: vec![0; n],\n            iter: vec![0; n]\n        }\n    }\n\n    fn add(&mut self, from: usize, to: usize, cap: i64, directed: bool) {\n        // edge[from]: to, cap, cost, rev(逆辺)\n        if directed {\n            let rev_from: i64 = self.edges[to].len() as i64;\n            self.edges[from].push((to, cap, rev_from));\n            let rev_to: i64 = self.edges[from].len() as i64;\n            self.edges[to].push((from, 0, rev_to-1));\n        } else {\n            // TODO: must be verified\n            let rev_from: i64 = self.edges[to].len() as i64;\n            self.edges[from].push((to, cap, rev_from));\n            let rev_to: i64 = self.edges[from].len() as i64;\n            self.edges[to].push((from, 0, rev_to-1));\n            self.edges[to].push((from, cap, rev_to));\n            let rev_from: i64 = self.edges[to].len() as i64;\n            self.edges[from].push((to, 0, rev_from-1));\n        }\n    }\n\n    fn bfs(&mut self, start: usize) {\n        self.level = vec![-1; self.n];\n        self.level[start] = 0;\n        let mut que: VecDeque<usize> = VecDeque::new();\n        que.push_back(start);\n        while let Some(v) = que.pop_front() {\n            for i in 0..self.edges[v].len() {\n                let e = self.edges[v][i];\n                if e.1 > 0 && self.level[e.0] < 0 {\n                    self.level[e.0] = self.level[v] + 1;\n                    que.push_back(e.0);\n                }\n            }\n        }\n    }\n\n    fn dfs(&mut self, v: usize, t: usize, f: usize) -> usize {\n        if v == t {return f}\n        for i in self.iter[v]..self.edges[v].len() {\n            self.iter[v] = i;\n            let e = self.edges[v][i];\n            if e.1 > 0 && self.level[v] < self.level[e.0] {\n                let d = self.dfs(e.0, t, min(f, e.1 as usize));\n                if d > 0 {\n                    self.edges[e.0][e.2 as usize].1 += d as i64;\n                    self.edges[v][i].1 -= d as i64;\n                    return d\n                }\n            }\n        }\n        return 0\n    }\n\n    fn max_flow(&mut self, start: usize, goal: usize) -> usize {\n        let mut flow = 0;\n        loop {\n            self.bfs(start);\n            if self.level[goal] < 0 {\n                return flow\n            }\n            self.iter = vec![0; self.n];\n            let mut f = self.dfs(start, goal, INF);\n            while f > 0  {\n                flow += f;\n                f = self.dfs(start, goal, INF);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nfn solve() {\n    input!{\n        X:usize,Y:usize,E:usize,\n        XY:[(usize,usize);E],\n    }\n    let mut bm = BipartiteMatching::new(X+Y);\n    for (x,y) in XY {\n        bm.connect(x,X+y);\n    }\n    println!(\"{}\",bm.run().len());\n}\nfn bipartite_matching(g_list: &[Vec<usize>]) -> Vec<(usize,usize)> {\n\n    fn dfs(v: usize, g_list: &[Vec<usize>], used: &mut [bool], matching: &mut [Option<usize>]) -> bool {\n        used[v] = true;\n        for i in 0..g_list[v].len() {\n            let u = g_list[v][i];\n            let w = matching[u];\n            if w.is_none() || (!used[w.unwrap()] && dfs(w.unwrap(), g_list, used, matching)) {\n                matching[v] = Some(u);\n                matching[u] = Some(v);\n                return true\n            }\n        }\n        false\n    }\n\n    let n = g_list.len();\n    let mut matching = vec![None; n];\n    for v in 0..n {\n        if matching[v].is_none() {\n            let mut used = vec![false; n];\n            dfs(v, g_list, &mut used, &mut matching);\n        }\n    }\n    let mut res = vec![];\n    for u in 0..matching.len() {\n        let v0 = matching[u];\n        if v0.is_some() {\n            let v = v0.unwrap();\n            assert!(u != v);\n            if u < v {\n                res.push((u,v));\n            }\n        }\n    }\n    res\n}\n\nstruct BipartiteMatching {\n    g: Vec<Vec<usize>>,\n}\nimpl BipartiteMatching {\n    fn new(n: usize) -> BipartiteMatching {\n        BipartiteMatching {\n            g: vec![vec![]; n],\n        }\n    }\n    fn connect(&mut self, u: usize, v: usize) {\n        assert!(u != v);\n        self.g[u].push(v);\n        self.g[v].push(u);\n    }\n    fn run(&self) -> Vec<(usize, usize)> {\n        bipartite_matching(&self.g)\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn dfs(x: usize, used: &mut [bool], assign: &mut [Option<usize>], g: &[Vec<usize>]) -> bool {\n    used[x] = true;\n    for &u in g[x].iter() {\n        let ok = assign[u].map_or(true, |p| {\n            !used[p] && dfs(p, used, assign, g)\n        });\n        if ok {\n            assign[x] = Some(u);\n            assign[u] = Some(x);\n            return true;\n        }\n    }\n    false\n}\n\nfn run() {\n    input! {\n        a: usize,\n        b: usize,\n        m: usize,\n        e: [(usize, usize); m],\n    }\n    let mut g = vec![vec![]; a + b];\n    for (x, y) in e {\n        g[x].push(y + a);\n        g[y + a].push(x);\n    }\n    let mut assign: Vec<Option<usize>> = vec![None; a + b];\n    for x in 0..a {\n        if assign[x].is_some() {\n            continue;\n        }\n        let mut used = vec![false; a];\n        dfs(x, &mut used, &mut assign, &g);\n    }\n    let ans = assign.iter().take(a).filter(|p| p.is_some()).count();\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; ( iter = $ iter : ident , $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut $ iter = s . split_whitespace ( ) ; input_inner ! { $ iter , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut iter = s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; }\nmacro_rules ! input_inner { ( $ iter : expr ) => { } ; ( $ iter : expr , ) => { } ; ( $ iter : expr , mut $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let mut $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , mut $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , mut $ var : usize $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , $ var : usize $ ( $ r ) * } } ; }\nmacro_rules ! read_value { ( $ iter : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ iter , $ t ) ) ,* ) } ; ( $ iter : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ iter , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ iter : expr , { chars : $ base : expr } ) => { read_value ! ( $ iter , String ) . chars ( ) . map ( | c | ( c as u8 - $ base as u8 ) as usize ) . collect ::< Vec < usize >> ( ) } ; ( $ iter : expr , { char : $ base : expr } ) => { read_value ! ( $ iter , { chars : $ base } ) [ 0 ] } ; ( $ iter : expr , chars ) => { read_value ! ( $ iter , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ iter : expr , char ) => { read_value ! ( $ iter , chars ) [ 0 ] } ; ( $ iter : expr , usize1 ) => { read_value ! ( $ iter , usize ) - 1 } ; ( $ iter : expr , $ t : ty ) => { $ iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) } ; }\n#[derive(Debug, Clone)]\npub struct RevEdge {\n    pub to: usize,\n    pub rev: usize,\n    pub cap: u64,\n}\nimpl RevEdge {\n    pub fn new(to: usize, rev: usize, cap: u64) -> RevEdge {\n        RevEdge {\n            to: to,\n            rev: rev,\n            cap: cap,\n        }\n    }\n}\n#[derive(Debug)]\npub struct Dinic {\n    graph: Vec<Vec<RevEdge>>,\n    iter: Vec<usize>,\n    level: Vec<usize>,\n}\nimpl Dinic {\n    pub fn new(n: usize) -> Dinic {\n        Dinic {\n            graph: vec![vec![]; n],\n            iter: vec![],\n            level: vec![],\n        }\n    }\n    pub fn add_edge(&mut self, from: usize, to: usize, cap: u64) {\n        let e1 = RevEdge::new(to, self.graph[to].len(), cap);\n        let e2 = RevEdge::new(from, self.graph[from].len(), 0);\n        self.graph[from].push(e1);\n        self.graph[to].push(e2);\n    }\n    fn bfs(&mut self, s: usize) {\n        self.level = vec![std::usize::MAX; self.graph.len()];\n        let mut deq = std::collections::VecDeque::new();\n        self.level[s] = 0;\n        deq.push_back(s);\n        while let Some(u) = deq.pop_front() {\n            for e in &self.graph[u] {\n                if e.cap > 0 && self.level[e.to] == std::usize::MAX {\n                    self.level[e.to] = self.level[u] + 1;\n                    deq.push_back(e.to);\n                }\n            }\n        }\n    }\n    fn dfs(&mut self, u: usize, t: usize, f: u64) -> u64 {\n        if u == t {\n            return f;\n        }\n        for i in self.iter[u]..self.graph[u].len() {\n            self.iter[u] = i;\n            let RevEdge { to, rev, cap } = self.graph[u][i];\n            if cap > 0 && self.level[u] < self.level[to] {\n                let d = self.dfs(to, t, std::cmp::min(f, cap));\n                if d > 0 {\n                    self.graph[u][i].cap -= d;\n                    self.graph[to][rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        0\n    }\n    pub fn maximum_flow(&mut self, s: usize, t: usize) -> u64 {\n        let mut flow = 0;\n        loop {\n            self.bfs(s);\n            if self.level[t] == std::usize::MAX {\n                return flow;\n            }\n            self.iter = vec![0; self.graph.len()];\n            loop {\n                let f = self.dfs(s, t, std::u64::MAX);\n                if f == 0 {\n                    break;\n                }\n                flow += f;\n            }\n        }\n    }\n}\nfn main() {\n    input! { nx, ny, m, xy: [(usize, usize); m] };\n    let mut mf = Dinic::new(nx + ny + 2);\n    for x in 0..nx {\n        mf.add_edge(0, x + 1, 1);\n    }\n    for y in 0..ny {\n        mf.add_edge(y + nx + 1, nx + ny + 1, 1);\n    }\n    for &(x, y) in &xy {\n        mf.add_edge(x + 1, y + nx + 1, 1);\n    }\n    println!(\"{}\", mf.maximum_flow(0, nx + ny + 1));\n}\n\n"
  }
]