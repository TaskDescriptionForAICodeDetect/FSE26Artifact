[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n\nlong long extGcd(long long a, long long b, long long &p, long long &q) {  \n    if (b == 0) { p = 1; q = 0; return a; }  \n    long long d = extGcd(b, a%b, q, p);  \n    q -= a/b * p;  \n    return d;  \n}\n\npair<long long, long long> ChineseRem(const vector<long long> &b, const vector<long long> &m) {\n  long long r = 0, M = 1;\n  for (int i = 0; i < (int)b.size(); ++i) {\n\tlong long p, q;\n\tlong long d = extGcd(M, m[i], p, q); // p is inv of M/d (mod. m[i]/d)\n\tif ((b[i] - r) % d != 0) return make_pair(0, -1);\n\tlong long tmp = (b[i] - r) / d * p % (m[i]/d);\n\tr += M * tmp;\n\tM *= m[i]/d;\n  }\n  return make_pair(mod(r, M), M);\n}\n\nint main() {\n  int N, M, D;\n  cin >> N >> M >> D;\n  vector<long long> A(M);\n  for (int i = 0; i < M; ++i) cin >> A[i];\n  bool ok = true;\n  for (int i = 0; i < D; ++i) {\n\tvector<long long> b, m;\n\tfor (int j = 0; j < M; ++j) {\n\t  int R; cin >> R;\n\t  if (R != -1) b.push_back(R), m.push_back(A[j]);\n\t}\n\tif (b.empty()) continue;\n\n\tpair<long long, long long> tmp = ChineseRem(b, m);\n\n\tif (tmp.second == -1) ok = false;\n\tif (N < tmp.first) ok = false;\n\n\tN = N - (N - tmp.first) % tmp.second;\n  }\n  if (ok) cout << N << endl;\n  else cout << -1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint cal(int n,P p){\n  while(n%p.first!=p.second&&n>=0)n--;\n  return n;\n}\n\nint main(){\n  int n,m,d,a[10];\n  cin>>n>>m>>d;\n  for(int i=0;i<m;i++){\n    cin>>a[i];\n  }\n  P r[100][10];\n  for(int i=0;i<d;i++){\n    for(int j=0;j<m;j++){\n      cin>>r[i][j].second;\n      r[i][j].first=a[j];\n    }\n    sort(r[i],r[i]+m);\n    reverse(r[i],r[i]+m);\n    vector<int> v;\n    for(int j=0;j<m;j++){\n      if(r[i][j].second==-1)continue;\n      if(j){\n\tvector<int> nv;\n\tfor(int k=0;k<(int)v.size();k++){\n\t  if(v[k]%r[i][j].first==r[i][j].second)nv.push_back(v[k]);\n\t}\n\tv=nv;\n      }\n      else {\n\tint u=1e7;\n\tint p=cal(n,r[i][j]);\n\twhile((int)v.size()<u&&p>=0){\n\t  v.push_back(p);\n\t  p-=r[i][j].first;\n\t}\n      }\n    }\n    if(v.size())n=v[0];\n    else if(r[i][0].second!=-1)n=-1;\n  }\n  cout<<n<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n#define int long long\ntypedef pair<int, int> P;\n\nint extgcd(int a, int b, int& x, int& y) {\n  int d = a;\n  if (b != 0) {\n\td = extgcd(b, a % b, y, x);\n\ty -= (a / b) * x;\n  } else {\n\tx = 1; y = 0;\n  }\n  return d;\n}\n\nint mod_inverse(int a, int m) {\n  int x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\nbool allminus(vector<int> B) {\n  for (int i = 0; i < (int)B.size(); i++) {\n\tif (B[i] >= 0)\n\t  return false;\n  }\n  return true;\n}\n\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  else return gcd(b, a%b);\n}\n\nP linear_congruence(const vector<int>& B, const vector<int>& M) {\n  int x = 0, m = 1;\n  int n = B.size();\n  if (allminus(B)) return P(-1, -1);\n  for (int i = 0; i < n; i++) {\n\tif (B[i] < 0) continue;\n\tint a = m, b = B[i] - x, d = gcd(M[i], a);\n\tif (b % d != 0) return P(0, -1);\n\tint t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n\tx = x + m * t;\n\tm *= M[i] / d;\n  }\n  return P(x % m , m);\n}\n\nsigned main() {\n  int n, m, d;\n  cin >> n >> m >> d;\n  vector<int> M(m);\n  for (int i = 0; i < m; i++)\n\tcin >> M[i];\n\n  vector<int> B[d];\n  for (int i = 0; i < d; i++) {\n\tfor (int j = 0; j < m; j++) {\n\t  int r;\n\t  cin >> r;\n\t  B[i].push_back(r);\n\t}\n  }\n\n  for (int i = 0; i < d; i++) {\n\tP p = linear_congruence(B[i], M);\n\tif (p.first == -1 && p.second == -1) continue;\n\tif (p.first == 0 && p.second == -1) {\n\t  cout << -1 << endl;\n\t  return 0;\n\t}\n\tif (n >= p.first) {\n\t  int t = (n - p.first) / p.second;\n\t  n = p.first + p.second * t;\n\t} else {\n\t  cout << -1 << endl;\n\t  return 0;\n\t}\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_DEPRECATE\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <iterator>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef pair<ll, ll> Pll;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n#define ten(x) ((int)1e##x)\n#define tenll(x) ((ll)1e##x)\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) {\n\tfor (T u = y = 1, v = x = 0; a;) {\n\t\tT q = b / a;\n\t\tswap(x -= q * u, u);\n\t\tswap(y -= q * v, v);\n\t\tswap(b -= q * a, a);\n\t}\n\treturn b;\n}\n\ntemplate<class T> T md_inverse(T a, T m) {\n\tT x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\n\ntemplate<class T>\npair<T, T> liner_congruence(const vector<T>& A, const vector<T>& B, const vector<T>& M) {\n\tT x = 0, m = 1; // x = 0(mod 1)\n\tfor (int i = 0; i < sz(A); i++) {\n\t\tT a = A[i] * m, b = B[i] - A[i] * x;\n\t\tT d = gcd(M[i], a);\n\t\tif (b % d != 0) return pair<T, T>(0, -1); // no solution\n\t\tT t = b / d * md_inverse<T>(a / d, M[i] / d) % (M[i] / d);\n\t\tx = x + m * t;\n\t\tm *= M[i] / d;\n\t\tx %= m;\n\t}\n\treturn pair<T, T>(x, m);\n}\n\nint main() {\n\tll n;\n\tint m, d; cin >> n >> m >> d;\n\tvector<ll> va(m);\n\tFOR(i, m) cin >> va[i];\n\tFOR(i, d) {\n\t\tvector<ll> A, B, M;\n\t\tFOR(j, m) {\n\t\t\tint a; cin >> a;\n\t\t\tif (a == -1) continue;\n\t\t\tA.push_back(1);\n\t\t\tB.push_back(a);\n\t\t\tM.push_back(va[j]);\n\t\t}\n\t\tauto kv = liner_congruence(A, B, M);\n\t\tif (kv.second == -1) {\n\t\t\tn = -1;\n\t\t\tbreak;\n\t\t}\n\t\tauto cur_rem = n % kv.second;\n\t\tif (cur_rem > kv.first) {\n\t\t\tn -= cur_rem - kv.first;\n\t\t} else if( cur_rem < kv.first) {\n\t\t\tn -= (cur_rem + (kv.second - kv.first));\n\t\t}\n\t\tif (n < 0) break;\n\t}\n\n\tif (n < 0) puts(\"-1\");\n\telse cout << n << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define MAX_N 150\n#define INF 9999999999LL\n\nlong long p[MAX_N];\nlong long x[MAX_N][MAX_N];\nlong long z[MAX_N][2];\nlong long N, M, D;\n\nlong long gcd(long long X, long long Y) {\n\treturn Y ? gcd(Y, X % Y) : X;\n}\n\nint main() {\n\tcin >> N >> M >> D;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> p[i];\n\t}\n\tfor (int i = 0; i < D; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> x[i][j];\n\t\t}\n\t\tz[i][1] = 1;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tlong long a1 = z[i][0], a2 = z[i][1], cnt1 = 0;\n\t\t\tif (x[i][j] == -1) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (cnt1 >= 1000 || a1 >= INF) {\n\t\t\t\t\t\tz[i][0] = INF; z[i][1] = INF; break;\n\t\t\t\t\t}\n\t\t\t\t\tif (a1%p[j] == x[i][j]) {\n\t\t\t\t\t\tz[i][0] = a1;\n\t\t\t\t\t\tz[i][1] = a2*p[j] / gcd(a2, p[j]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ta1 += a2;\n\t\t\t\t\tcnt1++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = N;\n\tfor (int i = 0; i < D; i++) {\n\t\tint b1 = z[i][0], b2 = z[i][1];\n\t\tif (z[i][0] == INF) {\n\t\t\tres = -1;\n\t\t}\n\t\tif (res >= 0) {\n\t\t\tint k = (res - b1) / b2;\n\t\t\tk *= b2;\n\t\t\tk += b1;\n\t\t\tres = k;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll hoge = M[i]/d;\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % hoge;\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair( (x%m + m) % m , m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      ll  tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod==-1){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    if(n<mod)n = b;\n    else{\n      ll tmp = (n/mod+100) * mod + b;\n      while(tmp<n)tmp += mod;\n      while(n<tmp)tmp -= mod;\n      if(tmp<0){\n\tcout << -1 << endl;\n\treturn 0;\n      }\n      n = tmp;\n    }\n\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dump(x) cout << (#x) << \" = \" << (x) << \", \";\nusing namespace std;\ntypedef long long ll;\n\nint gcd(int a, int b){\n  if(b == 0) return a;\n  return gcd(b, a % b);\n}\n\nint extgcd(int a, int b, int& x, int& y){\n  int d = a;\n  if(b != 0){\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nint mod_inverse(int a, int m){\n  int x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<int, int> linear_congruece(const vector<int>& A, const vector<int>& B, const vector<int>& M){\n  int x = 0, m =1;\n  for(int i = 0; i < A.size(); ++i){\n    int a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0)return make_pair(0, -1);\n    int t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  int n, m, d;\n  cin >> n >> m >> d;\n  vector<int> A(m,1), M;\n  for(int i = 0; i < m; ++i){\n    int tmp;\n    cin >> tmp;\n    M.push_back(tmp);\n  }\n  for(int i = 0; i < d; ++i){\n    //dump(i);dump(d);\n    vector<int> B;\n\n    for(int j = 0; j < m; ++j){\n      int tmp;\n      cin >> tmp;\n      B.push_back(tmp);\n    }\n\n    if(B[0] < 0) continue;\n\n    pair<int, int> res = linear_congruece(A, B, M);\n\n    if(res.second == -1){\n      n = -1;\n      break;\n    }\n    \n    int now = n % res.second;\n    //dump(n);\n    //dump(now);\n    if(now >= res.first) n -= now - res.first;\n    else {\n      n -= res.second;\n      n += res.first - now;\n    }\n\n    //dump(res.first);\n    //dump(res.second);\n    //dump(n);\n    //cout << endl;\n    \n  }\n  cout << (n < 0 ? -1 : n) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll Int;\nll INF=1ll<<45;\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nint main(){\n  int i,j,k;\n  ll n,m,d;\n  cin>>n>>m>>d;\n  vector<ll> a(m),r(m),aa(m),gcda(m);\n  vector<vector<ll > > subs(m);\n  rep(i,m)\n    cin>>a[i];\n  aa[0]=1;\n  rep(i,m-1)\n    aa[i+1]=aa[i]*a[i]/__gcd(aa[i],a[i]);\n  rep(i,m)\n    gcda[i]=__gcd(aa[i],a[i]);\n  rep(i,m){\n    subs[i].resize(a[i],INF);\n    rep(j,a[i]){\n      ll &tmp=subs[i][j*aa[i]%a[i]];\n      tmp=min(tmp,j*aa[i]);\n    }\n//rep(j,a[i])cout<<subs[i][j]<<\",\";cout<<endl;\n  }\n  ll dd;\n  rep(i,d){\n    rep(j,m)\n      cin>>r[j];\n    rep(j,m){\n      if(r[j]<0)continue;\n      if((n+a[j]-r[j])%a[j]){\n        ll nn=(n+a[j]-r[j])%a[j];\n        if(nn%gcda[j] || subs[j][nn]==INF){\n          cout<<-1<<endl;\n          return 0;\n        }\n        n-=subs[j][nn];\n        if(n<0){\n          cout<<-1<<endl;\n          return 0;\n        }\n      }\n //     cout<<\"->\"<<n<<\":\"<<r[j]<<\"mod\"<<a[j]<<endl;\n    }\n  }\n  cout<<n<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\nusing namespace std;\ntypedef pair<int,int> pr;\ntypedef vector<pr > vpr;\nconst int INF=1<<30;\nint lcm(int a,int b){\n\tif(a%b==0)\n\treturn b;\n\telse\n\treturn lcm(b,a%b);\n}\nint GCD(int a,int b){\n\treturn (a*b)/lcm(a,b);\n}\nint main() {\n\tint N,M,D;\n\tint divi[10];\n\tint dived[100][10],gcd[10]={};\n\tcin >> N >> M >> D;\n\tREP(i,M){\n\tcin >> divi[i];\n\tif(i)\n\tgcd[i]=GCD(gcd[i-1],divi[i]);\n\telse\n\tgcd[i]=divi[i];\n\t}\n\tREP(i,D)\n\t\tREP(j,M)\n\t\t\tcin >> dived[i][j];\n\tint now=N;\n\tREP(i,D){\n\t\tint mn=0;\n\t\tbool ans=false;\n\t\tREP(j,M){\n\t\tif(dived[i][j]==-1)\t\n\t\tcontinue;\n\t\tans=true;\n\t\tif(mn==0)\n\t\t\tmn=dived[i][j];\n\t\twhile(mn%divi[j]!=dived[i][j] || N>mn) mn+=gcd[i];\n\t\t}\n\t\tif(now<mn){\n\t\t\tnow=-1;\n\t\t\tbreak;\n\t\t}\n\t\tif(ans){\n\t\tint alpha=(now-mn)/gcd[M-1];\n\t\tnow=mn+alpha*gcd[M-1];\n\t\t}\n\t}\n\tcout << now << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\n\nvector<ll> comb;\nvector<ll> A;\nll N;\nint M, D;\n\nint gcd(int x,int y){\n    if(y == 0)return x;\n    else return gcd(y, x % y);\n}\nint lcm(int x,int y){\n    return x*y / gcd(x,y);\n}\n\n\nvoid makeComb(){\n    for(int i = 0; i <= (1<<M); i++){\n        comb[i] = 1LL;\n        for(int j = 0; j < M; j++){\n            if((i >> j) & 1) comb[i] = lcm(comb[i], A[j]);\n        }     \n    }\n    return;\n}\n\nint main () {\n    cin >> N >> M >> D;\n    comb = vector<ll>((1<<M)+1, 0);\n    A = vector<ll>(M);\n    for(int i = 0; i < M; i++) cin >> A[i];\n    makeComb();\n    ll pre = N;\n    \n    for(int i = 0; i < D; i++){\n        ll ret = 0LL;\n        vector<ll> R(M);\n        int exist = 0;\n        for(int j = 0; j < M; j++){\n            cin >> R[j];\n            if(R[j] != -1) exist |= 1<<j;\n        }\n        bool update = false;\n        for(ll j = 100LL; j >= 0LL; j--){\n            int f = 0;\n            for(int k = 0; k < M; k++){\n                if(R[k] != -1 && (j % A[k]) != R[k]) f = 1;\n            }\n            if(f) continue;\n            if(pre - j < 0) continue;\n            update = true; \n            ret = max(ret, ((pre - j) / comb[exist]) * comb[exist] + j);\n        }\n        if(!update){\n            cout << -1 << endl;\n            return 0;\n        }\n        pre = ret;\n    }\n    cout << pre << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % (M[i]/d);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair( (x%m + m) % m , m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      ll  tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()!=m)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod<0){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    ll tmp = (n/mod+100) * mod + b;\n    while(tmp<n)tmp += mod;\n    while(n<tmp)tmp -= mod;\n    if(tmp<0){\n      cout << -1 << endl;\n      return 0;\n    }\n    n = tmp;\n\n  }\n\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef long long ll;\nstruct NT{\n  ll m;  // mod\n  vector<bool>ismrime;\n  vector<ll> euler;\n  vector<ll> fact;\n\n  NT(ll MOD){\n    m=MOD;\n    fact.resize(500005);\n    fact[0]=1;\n    for(ll i=1;i<500005;i++){\n      fact[i]=(fact[i-1]*i)%MOD;\n    }\n  }\n\n  void eratos(int n){\n    ismrime.resize(n+1);\n    for(int i=0;i<=n;i++) ismrime[i]=true;\n    ismrime[0]=0;\n    ismrime[1]=0;\n    for(int i=2;i<=n;i++){\n      if(ismrime[i]){\n        for(int j=i+i;j<=n;j+=i) ismrime[j]=false;\n      }\n    }\n  }\n\n  // 因数分解 √N\n  vector<int> mrime_decommosition(ll x){\n    vector<int>res;\n    for(int i=2;i*i<=x;i++){\n      while(x%i==0){\n        x/=i;\n        res.push_back(i);\n      }\n    }\n    if(x!=1) res.push_back(x);\n    return res;\n  }\n\n  // 約数列挙 √N\n  vector<ll> divisor(ll x){\n    vector<ll> res;\n    for(ll i=1; i*i<=x ;i++)\n      if(x%i==0){\n        res.push_back(i);\n        if(i*i!=x) res.push_back(x/i);\n      }\n    sort(res.begin(), res.end());\n    return res;\n  }\n\n  // a*b>LONG_MAX ? \n  bool overflow(ll a,ll b,ll LONGMAX){return a > LONGMAX/b;}\n\n  ll extgcd(ll a,ll b,ll& x,ll& y){\n    ll d = a ;\n    if ( b != 0 ) {\n      d = extgcd( b , a%b , y , x ) ;\n      y -= ( a / b ) * x ;\n    }else{\n      x = 1 ; y = 0 ;\n    }\n    return d;\n  }\n  ll mod_inverse(ll a){\n    ll x , y ;\n    extgcd( a , m , x , y ) ;\n    return ( m + x % m ) % m ;\n  }\n  ll mod_inverse_M(ll a,ll m){\n    ll x , y ;\n    extgcd( a , m , x , y ) ;\n    return ( m + x % m ) % m ;\n  }\n\n  pair<ll,ll> linear_congruence(const vector<ll> &A,const vector<ll> &B,const vector<ll> &M){\n  \tll x=0,m=1;\n  \tfor(int i=0;i<A.size();i++){\n  \t\tll a=A[i]*m;\n  \t\tll b=B[i]-A[i]*x;\n  \t\tll d=__gcd(M[i],a);\n  \t\tif(b%d!=0)return make_pair(0,-1);\n  \t\tll t=b/d*mod_inverse_M(a/d,M[i]/d)%(M[i]/d);\n  \t\tx=x+m*t;\n  \t\tm*=M[i]/d;\n  \t}\n  \treturn make_pair(x%m,m);\n  }\n\n  // オイラー関数√N\n  ll euler_mhi(ll n){\n    ll res = n;\n    for(ll i=2; i*i <= n ; i++){\n      if( n%i == 0 ){\n        res = res/i*(i-1);\n        for(;n%i==0;n/=i);\n      }\n    }\n    if(n!=1)res=res/n*(n-1);\n    return res;\n  }\n\n  void make_euler_table(int n){\n    euler.resize(n+1);\n    for(int i=0;i<n;i++) euler[i]=i;\n    for(int i=2;i<n;i++){\n      if(euler[i]==i){\n        for(int j=i;j<n;j+=i){\n          euler[j]=euler[j]/i*(i-1);\n        }\n      }\n    }\n  }\n\n  // n! と nCr \n  // mはmod\n  ll mod_fact(ll n,ll& e){\n    e=0;\n    if(n==0)return 1;\n\n    int res = mod_fact(n/m,e);\n    e+=n/m;\n\n    if(n/m%2 != 0)return res*(m-fact[n%m])%m;\n    return res*fact[n%m]%m;\n  }\n\n  ll combination(ll n,ll k){\n    if(n==k||k==0)return 1;\n    if(n<0 || k<0 || n<k)return 0;\n    ll e1,e2,e3;\n    ll a1 = mod_fact(n,e1);\n    ll a2 = mod_fact(k,e2);\n    ll a3 = mod_fact(n-k,e3);\n    return a1*mod_inverse(a2*a3%m)%m;\n  }\n\n  ll mod_mult(ll a, ll b,ll m) {\n    ll res = 0;\n    ll exm = a % m;\n    while (b) {\n      if (b & 1) {\n        res += exm;\n        if (res > m) res -= m;\n      }\n      exm <<= 1;\n      if (exm > m) exm -= m;\n      b >>= 1;\n    }\n    return res;\n  }\n\n  ll mod_exm(ll a, ll b,ll m) {\n    ll res = 1;\n    ll exm = a % m;\n    while (b) {\n      if (b & 1) res = mod_mult(res, exm,m);\n      exm = mod_mult(exm, exm,m);\n      b >>= 1;\n    }\n    return res;\n  }\n\n  // 確率的高速素数判定　\n  bool miller_rabin(ll n, ll times=10) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (!(n & 1)) return false;\n    ll q = n-1;\n    int k = 0;\n    while (q % 2 == 0) {\n      k++;\n      q >>= 1;\n    }\n    for (int i = 0; i < times; i++) {\n      ll a = rand() % (n-1) + 1;\n      ll x = mod_exm(a, q, n);\n      if (x == 1) continue;\n      bool found = false;\n      for (int j = 0; j < k; j++) {\n        if (x == n-1) {\n          found = true;\n          break;\n        }\n        x = mod_mult(x, x, n);\n      }\n      if (found) continue;\n      return false;\n    }\n    return true;\n  }\n\n  ll pollard_rho(ll n, int c) {\n    ll x = 2;\n    ll y = 2;\n    ll d = 1;\n    while (d == 1) {\n      x = mod_mult(x, x, n) + c;\n      y = mod_mult(y, y, n) + c;\n      y = mod_mult(y, y, n) + c;\n      d = __gcd((x-y >= 0 ? x-y : y-x), n);\n    }\n    if (d == n) return pollard_rho(n, c+1);\n    return d;\n  }\n};\n\nint n,m[11],d,M;\nsigned main(){\n\tNT N(1e9+7);\n\tcin>>n>>M>>d;\n\tr(i,M)cin>>m[i];\n\tr(i,d){\n\t\tvector<int>A,B,C;\n\t\tr(j,M){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tif(x!=-1){\n\t\t\t\tA.push_back(1);\n\t\t\t\tB.push_back(x);\n\t\t\t\tC.push_back(m[j]);\n\t\t\t}\n\t\t}\n\t\tpair<int,int> p=N.linear_congruence(A,B,C);\n\t\tif(p.second<0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint x=p.first;\n\t\t/*int l=0,r=1e9;\n\n\t\twhile(l<r){\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(x+mid*p.second>=n)r=mid;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tif(x+(l+2)*p.second<=n)n=x+(l+2)*p.second;\n\t\telse if(x+(l+1)*p.second<=n)n=x+(l+1)*p.second;\n\t\telse if(x+(l)*p.second<=n)n=x+(l)*p.second;\n\t\telse if(x+(l-1)*p.second<=n&&x+(l-1)*p.second>=0)n=x+(l-1)*p.second;\n\t\telse n=x+(l-2)*p.second;*/\n\t\tn=(n-x)/p.second;\n\t\tn+=p.second;\n\t\tn+=x;\n\t}\n\tcout<<n<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % (M[i]/d);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair( x%m , m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      long long  tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod==-1){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    assert(b>=0);\n    //cerr << b << \" \" << mod << endl;\n    if(n<mod)n = b;\n    else{\n      long long tmp = (n/mod+1) * mod + b;\n      while(tmp<(long long)n)tmp += (long long)mod;\n      while((long long)n<tmp)tmp -= (long long)mod;\n      if(tmp<0){\n\tcout << -1 << endl;\n\treturn 0;\n      }\n      n = tmp;\n    }\n\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ax+by = 1 になる x, y を求める\nll extgcd (ll a, ll b, ll &x, ll &y ){\n\tll d = a;\n\tif (b != 0 ){\n\t\td = extgcd (b, a%b, y, x ); y -= (a/b)*x;\n\t}else{\n\t\tx = 1LL; y = 0LL;\n\t} // end if\n\n\treturn d;\n}\n\nll mod_inverse (ll a, ll m ){\n\tll x, y;\n\textgcd (a, m, x, y );\n\n\treturn (m + x % m ) % m;\n}\n\nconst int MAX_M = 12;\nconst int MAX_D = 105;\n\nint a[MAX_M];\nint r[MAX_D][MAX_M];\nbool used[MAX_M];\nll n_[MAX_M];\nll u[MAX_M];\n\nint chinese_reminder_theorem (int di, int m, int curr ){\n\n\tmemset (n_, -1LL, sizeof (n_ ) );\n\tmemset (u, -1LL, sizeof (u ) );\n\n\tll N = 1LL;\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) N *= (ll)a[i];\n\n\tif (N == 1LL ) return curr;\n\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) n_[i] = N/(ll)a[i];\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) u[i] = mod_inverse (n_[i], (ll)a[i] );\n\n\tll res = 0LL;\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) res += n_[i]*u[i]*(ll)r[di][i];\n\n\tres %= N;\n\n\treturn (res != 0LL ? (int)res : -1 );\t\t\t\n}\n\nvoid used_ai (int id, int m ){\n\tfill (used, used + MAX_M, true );\n\n\trep (i, m ){\n\t\tif (!used[i] ) continue;\n\t\tif (r[id][i] == -1 ){\n\t\t\tused[i] = false;\n\t\t\tcontinue;\n\t\t} // end if\n\t\tfor (int j = i+1; j < m; j++ ){\n\t\t\tif (r[id][j] == -1 ){\n\t\t\t\tused[j] = false;\n\t\t\t\tcontinue;\n\t\t\t} // end if\n\t\t\tif (__gcd (a[i], a[j] ) != 1 ){\n\t\t\t\tused[j] = false;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end rep\n}\n\nint main()\n{\n\tmemset (a, 0, sizeof (a ) );\n\tmemset (r, -1, sizeof (r ) );\n\n\tios_base::sync_with_stdio(0);\n\tint n, m, d; cin >> n >> m >> d;\n\n\trep (i, m ) cin >> a[i];\n\trep (i, d ) rep (j, m ) cin >> r[i][j];\n\n\tint res = n;\n\trep (i, d ){\n\t\tused_ai (i, m );\n\t\tint curr = chinese_reminder_theorem (i, m, res );\n\t\tif (curr > res ){\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}else{\n\t\t\tres = curr;\n\t\t} // end if\n\t} // end rep\n\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef long long LL;\n\nLL extgcd(LL a, LL b, LL& x, LL& y){\n    LL d = a;\n    if(b != 0){\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nLL mul_mod(LL a, LL b, LL mod){\n    if(b == 0) return 0;\n    LL res = mul_mod((a + a) % mod, b / 2, mod);\n    if(b & 1) res = (res + a) % mod;\n    return res;\n}\n\nLL pow_mod(LL a, LL b, LL mod){\n    if(b == 0) return 1;\n    LL res = pow_mod(mul_mod(a, a, mod), b / 2, mod);\n    if(b & 1) res = mul_mod(res, a, mod);\n    return res;\n}\n\nLL inv_mod(LL a, LL mod){\n    LL x, y;\n    extgcd(a, mod, x, y);\n    return (x % mod + mod) % mod;\n}\n\nvector<LL> inverse_list(int n, int p){\n    vector<LL> inv(n + 1);\n    inv[1] = 1;\n    for (int i = 2; i <= n; ++i){\n        inv[i] = inv[p % i] * (p - p / i) % p;\n    }\n    return inv;\n}\n\nLL chinese(LL a, LL b, LL m1, LL m2) {\n    LL m = m1 / __gcd(m1, m2) * m2;\n    LL X = (m2 * a % m * inv_mod(m2, m1) % m + m1 * b % m * inv_mod(m1, m2) % m) % m;\n    // cout << \"---\" << endl;\n    // cout << a << \" (mod \" << m1 << \")\" << endl;\n    // cout << b << \" (mod \" << m2 << \")\" << endl;\n    // cout << X << \" (mod \" << m << \")\" << endl;\n    // cout << __gcd(m1, m2) << \" (mod \" << m << \")\" << endl;\n    // cout << inv_mod(__gcd(m1, m2), m) << \" (mod \" << m << \")\" << endl;\n    // cout << \"---\" << endl;\n    assert(X % __gcd(m1, m2) == 0);\n    return X / __gcd(m1, m2);\n}\n\nint main(){\n    int N, M, D;\n    while(cin >> N >> M >> D) {\n\n        int A[10];\n        REP(i, M) cin >> A[i];\n\n        for(int t = 0; t < D; t++) {\n            int B[10];\n            REP(i, M) cin >> B[i];\n            LL a = 0;\n            LL m = 1;\n\n            for(int i = 0; i < M; i++) if(B[i] != -1) {\n                a = chinese(a, B[i], m, A[i]);\n                m = m / __gcd(m, (LL)A[i]) * A[i];\n                // cout << a << \" (mod \" << m << \")\" << endl;\n            }\n\n            // cout << a << \" (mod \" << m << \")\" << endl;\n            // cout << \"N : \" << N << \" -> \";\n\n            if(a > N) {\n                N = -1;\n            } else {\n                LL k = (N - a) / m;\n                assert(a + m * k <= N);\n                assert(a + m * k + m > N);\n                N = a + m * k;\n            }\n            // cout << N << endl;\n            \n        }\n\n        cout << N << endl;\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dump(x) cout << (#x) << \" = \" << (x) << \", \";\nusing namespace std;\ntypedef long long lli;\n\nlli gcd(lli a, lli b){\n  if(b == 0) return a;\n  return gcd(b, a % b);\n}\n\nlli extgcd(lli a, lli b, lli& x, lli& y){\n  lli d = a;\n  if(b != 0){\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nlli mod_inverse(lli a, lli m){\n  lli x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<lli, lli> linear_congruece(const vector<lli>& A, const vector<lli>& B, const vector<lli>& M){\n  lli x = 0, m =1;\n  for(lli i = 0; i < A.size(); ++i){\n    lli a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0)return make_pair(0, -1);\n    lli t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  lli n, m, d;\n  cin >> n >> m >> d;\n  vector<lli> A(m,1), M;\n  for(lli i = 0; i < m; ++i){\n    lli tmp;\n    cin >> tmp;\n    M.push_back(tmp);\n  }\n  for(lli i = 0; i < d; ++i){\n    //dump(i);dump(d);\n    vector<lli> B;\n    bool f2 = false;\n\n    for(lli j = 0; j < m; ++j){\n      lli tmp;\n      cin >> tmp;\n      B.push_back(tmp);\n      if(tmp > 0) f2 = true;\n    }\n\n    if(B[0] < 0 || n < 0 || n == 0 && f2) {\n      if(n == 0 && f2) n = -1;\n      continue;\n    }\n\n    pair<lli, lli> res = linear_congruece(A, B, M);\n\n    if(res.second == -1){\n      n = -1;\n      break;\n    }\n    \n    lli modn = n % res.second;\n    lli mod = res.second;\n    lli modnext = res.first;\n    /*\n    dump(n);\n    dump(modn);\n    */\n    while(modnext < 0) modnext += mod;\n    modnext = (modnext + (llabs(modnext) / mod + 1) * mod) % mod;\n    if(modn >= modnext) n -= modn - modnext;\n    else {\n      n -= mod;\n      n += modnext - modn;\n    }\n\n    /*\n    dump(modnext);\n    dump(mod);\n    dump(n);\n    cout << endl;\n    */\n    \n  }\n  cout << (n < 0 ? -1 : n) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % (M[i]/d);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair(x%m, m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      ll tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod<0){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    ll tmp = (n/mod+1) * mod + b;\n    while(tmp<n)tmp += mod;\n    while(n<tmp)tmp -= mod;\n    if(tmp<0){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    n = tmp;\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dump(x) cout << (#x) << \" = \" << (x) << \", \";\nusing namespace std;\ntypedef long long lli;\n\nlli gcd(lli a, lli b){\n  if(b == 0) return a;\n  return gcd(b, a % b);\n}\n\nlli extgcd(lli a, lli b, lli& x, lli& y){\n  lli d = a;\n  if(b != 0){\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nlli mod_inverse(lli a, lli m){\n  lli x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<lli, lli> linear_congruece(const vector<lli>& A, const vector<lli>& B, const vector<lli>& M){\n  lli x = 0, m =1;\n  for(lli i = 0; i < A.size(); ++i){\n    lli a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0)return make_pair(0, -1);\n    lli t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  lli n, m, d;\n  cin >> n >> m >> d;\n  vector<lli> A(m,1), M;\n  for(lli i = 0; i < m; ++i){\n    lli tmp;\n    cin >> tmp;\n    M.push_back(tmp);\n  }\n  for(lli i = 0; i < d; ++i){\n    //dump(i);dump(d);\n    vector<lli> B;\n    bool f2 = false;\n\n    for(lli j = 0; j < m; ++j){\n      lli tmp;\n      cin >> tmp;\n      B.push_back(tmp);\n      if(tmp > 0) f2 = true;\n    }\n\n    if(B[0] < 0 || n < 0 || n && f2) continue;\n\n    pair<lli, lli> res = linear_congruece(A, B, M);\n\n    if(res.second == -1){\n      n = -1;\n      break;\n    }\n    \n    lli modn = n % res.second;\n    lli mod = res.second;\n    lli modnext = res.first;\n    /*\n    dump(n);\n    dump(modn);\n    */\n    while(modnext < 0) modnext += mod;\n    modnext = (modnext + (llabs(modnext) / mod + 1) * mod) % mod;\n    if(modn >= modnext) n -= modn - modnext;\n    else {\n      n -= mod;\n      n += modnext - modn;\n    }\n\n    /*\n    dump(modnext);\n    dump(mod);\n    dump(n);\n    cout << endl;\n    */\n    \n  }\n  cout << (n < 0 ? -1 : n) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-8;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<ll, ll> linear_congruence(const vector<ll>& A, const vector<ll>& B,\n                                 const vector<ll>& M) {\n  ll x = 0, m = 1;\n  for(ll i = 0; i < A.size(); i++){\n    if(B[i] == -1) continue;\n    ll a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0) return make_pair(0, -1);\n    ll t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  ll num_of_chopsticks;\n  int num_of_divisors;\n  int total_days;\n  while(~scanf(\"%lld %d %d\",\n               &num_of_chopsticks,\n               &num_of_divisors,\n               &total_days)){\n    vector<ll> divisors(num_of_divisors);\n    for(int div_i = 0; div_i < num_of_divisors; div_i++){\n      scanf(\"%lld\",&divisors[div_i]);\n    }\n    ll record[101][11];\n    for(int day = 0; day < total_days; day++){\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        scanf(\"%lld\",&record[day][div_i]);\n      }\n    }\n\n    vector<ll> A(num_of_divisors,1);\n    for(int day = 0; day < total_days; day++){\n      vector<ll> reminder;\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        reminder.push_back(record[day][div_i]);\n      }\n\n      pair<ll,ll> ans = linear_congruence(A,reminder,divisors);\n      num_of_chopsticks -= (num_of_chopsticks - ans.first + ans.second) % ans.second;\n      if(num_of_chopsticks < 0 || ans.second == -1){\n              num_of_chopsticks = -1;\n        break;\n      }\n    }\n    printf(\"%lld\\n\",num_of_chopsticks);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m, d;\n\tcin >> n >> m >> d;\n\tvector<ll> a(m);\n\tfor(int i = 0; i < m; ++i){ cin >> a[i]; }\n\tfor(int i = 0; i < d; ++i){\n\t\tvector<ll> b(m);\n\t\tfor(int j = 0; j < m; ++j){ cin >> b[j]; }\n\t\tif(b[0] < 0){ continue; }\n\t\tll mod = 1, x = 0;\n\t\tfor(int j = 0; x <= n && j < m; ++j){\n\t\t\tbool accept = false;\n\t\t\tfor(int k = 0; k < a[j]; ++k){\n\t\t\t\tconst ll t = mod * k + x;\n\t\t\t\tif(t <= n && t % a[j] == b[j]){\n\t\t\t\t\taccept = true;\n\t\t\t\t\tmod *= a[j];\n\t\t\t\t\tx = t % mod;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!accept){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(x > n){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tconst ll t = n / mod;\n\t\tif(t * mod + x <= n){\n\t\t\tn = t * mod + x;\n\t\t}else{\n\t\t\tn = (t - 1) * mod + x;\n\t\t}\n\t}\n\tcout << n << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m, d;\n\tcin >> n >> m >> d;\n\tvector<ll> a(m);\n\tfor(int i = 0; i < m; ++i){ cin >> a[i]; }\n\tfor(int i = 0; i < d; ++i){\n\t\tvector<ll> b(m);\n\t\tfor(int j = 0; j < m; ++j){ cin >> b[j]; }\n\t\tif(b[0] < 0){ continue; }\n\t\tll mod = 1, x = 0;\n\t\tfor(int j = 0; x <= n && j < m; ++j){\n\t\t\tbool accept = false;\n\t\t\tfor(int k = 0; k < a[j]; ++k){\n\t\t\t\tconst ll t = a[j] * k + b[j];\n\t\t\t\tif(t <= n && t % mod == x){\n\t\t\t\t\taccept = true;\n\t\t\t\t\tmod *= a[j];\n\t\t\t\t\tx = t % mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!accept){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(x > n){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tconst ll t = n / mod;\n\t\tif(t * mod + x <= n){\n\t\t\tn = t * mod + x;\n\t\t}else{\n\t\t\tn = (t - 1) * mod + x;\n\t\t}\n\t}\n\tcout << n << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nint extgcd(int a, int b, int &x, int &y) {\n\tint d = a;\n\tif(b != 0) {\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t} else {\n\t\tx = 1;\n\t\ty = 0;\n\t}\n\treturn d;\n}\n\nint mod_inverse(int a, int m) {\n\tint x, y;\n\textgcd(a, m, x, y);\n\treturn (x % m + m) % m;\n}\n\npair<int, int> linear_congruence(const vector<int> &A, const vector<int> &B, const vector<int> &M) {\n\tint x = 0, m = 1;\n\n\tfor(unsigned i = 0; i < A.size(); ++i) {\n\t\tif(B[i] == -1) continue;\n\n\t\tint a = A[i] * m, b = B[i] - A[i] * x, d = __gcd(M[i], a);\n\t\tif(b % d != 0) return make_pair(0, -1);\n\t\tint t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n\t\tx = x + m * t;\n\t\tm *= M[i] / d;\n\t}\n\n\treturn make_pair(x % m, m);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, m, d;\n\tcin >> n >> m >> d;\n\n\tvector<int> M(m);\n\tfor(auto &e : M) cin >> e;\n\n\tvector<int> A(m, 1);\n\n\tfor(int i = 0; i < d; ++i) {\n\t\tvector<int> B(m);\n\t\tfor(auto &e : B) cin >> e;\n\n\t\tint b, mod;\n\t\ttie(b, mod) = linear_congruence(A, B, M);\n\n\t\tconst int p = n / mod;\n\t\tconst int q = n % mod;\n\t\tconst int k = (q - b + mod) % mod;\n\n\t\tn = p * mod + q - k;\n\n\t\tif(mod == -1 || n < 0) {\n\t\t\tn = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << n << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//BEGIN CUT HERE\n\ntemplate<typename T>\nT extgcd(T a,T b,T &x,T &y){\n  T d=a;\n  if(b!=0){\n    d=extgcd(b,a%b,y,x);\n    y-=(a/b)*x;\n  }else{\n    x=1;\n    y=0;\n  }\n  return d;\n}\n\ntemplate<typename T>\nT mod_inverse(T a,T mod){\n  T x,y;\n  extgcd(a,mod,x,y);\n  return (mod+x%mod)%mod;\n}\n\ntemplate<typename T>\npair<T, T> linear_congruence(const vector<T> &A,\n                             const vector<T> &B,\n                             const vector<T> &M){\n  T x=0,m=1;\n  for(int i=0;i<(int)A.size();i++){\n    T a=A[i]*m,b=B[i]-A[i]*x,d=__gcd(M[i],a);\n    if(b%d!=0) return make_pair(0,-1);\n    T t=b/d*mod_inverse(a/d,M[i]/d)%(M[i]/d);\n    x=x+m*t;\n    m*=M[i]/d;\n  }\n  return make_pair((x%m+m)%m,m);\n}\n//END CUT HERE\n\nsigned AOJ_2659(){\n  Int r[111][111];\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m,d;\n  cin>>n>>m>>d;\n  vector<Int> a(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n\n  for(Int i=0;i<d;i++)\n    for(Int j=0;j<m;j++)\n      cin>>r[i][j];\n\n  for(Int i=0;i<d;i++){\n    vector<Int> A,B,M;\n    for(Int j=0;j<m;j++){\n      if(r[i][j]<0) continue;\n      A.emplace_back(1);\n      B.emplace_back(r[i][j]);\n      M.emplace_back(a[j]);\n    }\n    auto p=linear_congruence(A,B,M);\n    if(p.second<0){\n      n=-1;\n      break;\n    }\n    if(p.second<0) p.first+=p.second;\n    n=(n-p.first)/p.second*p.second+p.first;\n  }\n  \n  cout<<n<<endl;\n  return 0;\n}\n/* \n   verified on 2018/11/23\n   http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2659\n*/\n\n\nInt isprime(Int x){\n  if(x<=1) return 0;\n  for(Int i=2;i*i<=x;i++)\n    if(x%i==0) return 0;\n  return 1;\n}\n\nsigned DDCC2018QUALB_D(){  \n  const Int n = 30;\n  vector<Int> A,B,M;\n\n  vector<Int> x(n+1);\n  for(Int i=2;i<=n;i++){\n    cin>>x[i];\n    if(!isprime(i-1)) continue;\n    A.emplace_back(1);\n    B.emplace_back(x[i]%(i-1));\n    M.emplace_back(i-1);\n  }\n  auto p=linear_congruence(A,B,M);\n  if(p.second<Int(0)){\n    cout<<\"invalid\"s<<endl;\n    return 0;\n  }\n  Int res=p.first;\n  Int flg=1;\n  for(Int i=2;i<=n;i++){\n    Int sum=0,tmp=res;\n    while(tmp>Int(0)){\n      sum+=tmp%i;\n      tmp/=Int(i);\n    }\n    flg&=(sum==x[i]);\n  }\n  if(flg){\n    cout<<res<<endl;\n    return 0;\n  }\n  cout<<\"invalid\"s<<endl;\n  return 0;\n}\n/* \n   verified on 2018/11/23\n   https://beta.atcoder.jp/contests/ddcc2019-qual/tasks/ddcc2018_qual_d\n*/\n\nsigned YUKI_186(){\n  vector<Int> A(3,1),B(3),M(3);\n  for(Int i=0;i<3;i++) cin>>B[i]>>M[i];\n  auto p=linear_congruence(A,B,M);\n  if(p.second==-1) cout<<-1<<endl;\n  else cout<<(p.first?p.first:p.second)<<endl;\n  return 0;\n}\n/* \n   verified on 2019/03/26\n   https://yukicoder.me/problems/no/186\n*/\n\n//INSERT ABOVE HERE\nsigned main(){\n  AOJ_2659();\n  //DDCC2018QUALB_D();\n  //YUKI_186();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll hoge = M[i]/d;\n    ll t = (b/d * mod_inverse(a/d, M[i]/d) % hoge + hoge) % hoge;\n    assert(t>=0);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair( (x%m + m) % m , m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      long long  tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod==-1){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    //cerr << b << \" \" << mod << endl;\n    if(n<mod)n = b;\n    else{\n      long long tmp = (n/mod+1) * mod + b;\n      while(tmp<(long long)n)tmp += (long long)mod;\n      while((long long)n<tmp)tmp -= (long long)mod;\n      if(tmp<0){\n\tcout << -1 << endl;\n\treturn 0;\n      }\n      n = tmp;\n    }\n\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef long long ll;\nstruct NT{\n  ll m;  // mod\n  vector<bool>ismrime;\n  vector<ll> euler;\n  vector<ll> fact;\n\n  NT(ll MOD){\n    m=MOD;\n    fact.resize(500005);\n    fact[0]=1;\n    for(ll i=1;i<500005;i++){\n      fact[i]=(fact[i-1]*i)%MOD;\n    }\n  }\n\n  void eratos(int n){\n    ismrime.resize(n+1);\n    for(int i=0;i<=n;i++) ismrime[i]=true;\n    ismrime[0]=0;\n    ismrime[1]=0;\n    for(int i=2;i<=n;i++){\n      if(ismrime[i]){\n        for(int j=i+i;j<=n;j+=i) ismrime[j]=false;\n      }\n    }\n  }\n\n  // 因数分解 √N\n  vector<int> mrime_decommosition(ll x){\n    vector<int>res;\n    for(int i=2;i*i<=x;i++){\n      while(x%i==0){\n        x/=i;\n        res.push_back(i);\n      }\n    }\n    if(x!=1) res.push_back(x);\n    return res;\n  }\n\n  // 約数列挙 √N\n  vector<ll> divisor(ll x){\n    vector<ll> res;\n    for(ll i=1; i*i<=x ;i++)\n      if(x%i==0){\n        res.push_back(i);\n        if(i*i!=x) res.push_back(x/i);\n      }\n    sort(res.begin(), res.end());\n    return res;\n  }\n\n  // a*b>LONG_MAX ? \n  bool overflow(ll a,ll b,ll LONGMAX){return a > LONGMAX/b;}\n\n  ll extgcd(ll a,ll b,ll& x,ll& y){\n    ll d = a ;\n    if ( b != 0 ) {\n      d = extgcd( b , a%b , y , x ) ;\n      y -= ( a / b ) * x ;\n    }else{\n      x = 1 ; y = 0 ;\n    }\n    return d;\n  }\n  ll mod_inverse(ll a){\n    ll x , y ;\n    extgcd( a , m , x , y ) ;\n    return ( m + x % m ) % m ;\n  }\n  ll mod_inverse_M(ll a,ll m){\n    ll x , y ;\n    extgcd( a , m , x , y ) ;\n    return ( m + x % m ) % m ;\n  }\n\n  pair<ll,ll> linear_congruence(const vector<ll> &A,const vector<ll> &B,const vector<ll> &M){\n  \tll x=0,m=1;\n  \tfor(int i=0;i<A.size();i++){\n  \t\tll a=A[i]*m;\n  \t\tll b=B[i]-A[i]*x;\n  \t\tll d=__gcd(M[i],a);\n  \t\tif(b%d!=0)return make_pair(0,-1);\n  \t\tll t=b/d*mod_inverse_M(a/d,M[i]/d)%(M[i]/d);\n  \t\tx=x+m*t;\n  \t\tm*=M[i]/d;\n  \t}\n  \treturn make_pair(x%m,m);\n  }\n\n  // オイラー関数√N\n  ll euler_mhi(ll n){\n    ll res = n;\n    for(ll i=2; i*i <= n ; i++){\n      if( n%i == 0 ){\n        res = res/i*(i-1);\n        for(;n%i==0;n/=i);\n      }\n    }\n    if(n!=1)res=res/n*(n-1);\n    return res;\n  }\n\n  void make_euler_table(int n){\n    euler.resize(n+1);\n    for(int i=0;i<n;i++) euler[i]=i;\n    for(int i=2;i<n;i++){\n      if(euler[i]==i){\n        for(int j=i;j<n;j+=i){\n          euler[j]=euler[j]/i*(i-1);\n        }\n      }\n    }\n  }\n\n  // n! と nCr \n  // mはmod\n  ll mod_fact(ll n,ll& e){\n    e=0;\n    if(n==0)return 1;\n\n    int res = mod_fact(n/m,e);\n    e+=n/m;\n\n    if(n/m%2 != 0)return res*(m-fact[n%m])%m;\n    return res*fact[n%m]%m;\n  }\n\n  ll combination(ll n,ll k){\n    if(n==k||k==0)return 1;\n    if(n<0 || k<0 || n<k)return 0;\n    ll e1,e2,e3;\n    ll a1 = mod_fact(n,e1);\n    ll a2 = mod_fact(k,e2);\n    ll a3 = mod_fact(n-k,e3);\n    return a1*mod_inverse(a2*a3%m)%m;\n  }\n\n  ll mod_mult(ll a, ll b,ll m) {\n    ll res = 0;\n    ll exm = a % m;\n    while (b) {\n      if (b & 1) {\n        res += exm;\n        if (res > m) res -= m;\n      }\n      exm <<= 1;\n      if (exm > m) exm -= m;\n      b >>= 1;\n    }\n    return res;\n  }\n\n  ll mod_exm(ll a, ll b,ll m) {\n    ll res = 1;\n    ll exm = a % m;\n    while (b) {\n      if (b & 1) res = mod_mult(res, exm,m);\n      exm = mod_mult(exm, exm,m);\n      b >>= 1;\n    }\n    return res;\n  }\n\n  // 確率的高速素数判定　\n  bool miller_rabin(ll n, ll times=10) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (!(n & 1)) return false;\n    ll q = n-1;\n    int k = 0;\n    while (q % 2 == 0) {\n      k++;\n      q >>= 1;\n    }\n    for (int i = 0; i < times; i++) {\n      ll a = rand() % (n-1) + 1;\n      ll x = mod_exm(a, q, n);\n      if (x == 1) continue;\n      bool found = false;\n      for (int j = 0; j < k; j++) {\n        if (x == n-1) {\n          found = true;\n          break;\n        }\n        x = mod_mult(x, x, n);\n      }\n      if (found) continue;\n      return false;\n    }\n    return true;\n  }\n\n  ll pollard_rho(ll n, int c) {\n    ll x = 2;\n    ll y = 2;\n    ll d = 1;\n    while (d == 1) {\n      x = mod_mult(x, x, n) + c;\n      y = mod_mult(y, y, n) + c;\n      y = mod_mult(y, y, n) + c;\n      d = __gcd((x-y >= 0 ? x-y : y-x), n);\n    }\n    if (d == n) return pollard_rho(n, c+1);\n    return d;\n  }\n};\n\nint n,m[11],d,M;\nsigned main(){\n\tNT N(1e9+7);\n\tcin>>n>>M>>d;\n\tr(i,M)cin>>m[i];\n\tr(i,d){\n\t\tvector<int>A,B,C;\n\t\tr(j,M){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tif(x!=-1){\n\t\t\t\tA.push_back(1);\n\t\t\t\tB.push_back(x);\n\t\t\t\tC.push_back(m[j]);\n\t\t\t}\n\t\t}\n\t\tpair<int,int> p=N.linear_congruence(A,B,C);\n\t\tif(p.second<0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint x=p.first;\n\t\t/*int l=0,r=1e9;\n\n\t\twhile(l<r){\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(x+mid*p.second>=n)r=mid;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tif(x+(l+2)*p.second<=n)n=x+(l+2)*p.second;\n\t\telse if(x+(l+1)*p.second<=n)n=x+(l+1)*p.second;\n\t\telse if(x+(l)*p.second<=n)n=x+(l)*p.second;\n\t\telse if(x+(l-1)*p.second<=n&&x+(l-1)*p.second>=0)n=x+(l-1)*p.second;\n\t\telse n=x+(l-2)*p.second;*/\n\t\tn=(n-x)/p.second;\n\t\tn*=p.second;\n\t\tn+=x;\n\t}\n\tcout<<n<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % (M[i]/d);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair(x%m, m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      ll tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod<0){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    ll tmp = (n/mod+1) * mod + b;\n    while(n<tmp)tmp -= mod;\n    if(tmp<0){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    n = tmp;\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.D\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\tios_base::sync_with_stdio(0);\n\tint n, m, d; cin >> n >> m >> d;\n\tvector<int> a(m, 0 );\n\n\trep (i, m ) cin >> a[i];\n\tvector<vector<int> > r(d, vector<int> (m, 0 ) );\n\trep (i, d ) rep (j, m ) cin >> r[i][j];\n\n\tvector<int> cand; cand.clear();\n\tcand.push_back (n );\n\tbool ok = true;\n\trep (i, d ){\n\t\tvector<int> next; next.clear();\n\t\trep (j, cand.size() ){\n\t\t\tfor (int l = 0; l <= cand[j]; l++ ){\n\t\t\t\tint cnt = 0;\n\t\t\t\trep (k, m ){\n\t\t\t\t\tif (r[i][k] != -1 ){\n\t\t\t\t\t\tif (l % a[k] == r[i][k] ) cnt++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t} // end if\n\t\t\t\t} // end rep\n\t\t\t\tif (cnt == m ) next.push_back (l );\n\t\t\t} // end for\n\t\t} // end rep\n\t\tif (next.empty() ){\n\t\t\tok = false;\n\t\t\tbreak;\n\t\t}else{\n\t\t\tsort (ALL (next ) );\n\t\t\tnext.erase (unique (ALL (next ) ), next.end() );\n\t\t} // end if\n\t\tcand = next;\n\t} // end rep\n\t\n\tif (!cand.empty() ) sort (ALL (cand ), greater<int>() );\n\n\tcout << (ok ? cand[0] : -1 ) << endl;\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\nconst ll INF = 1000000009LL;\n\nvector<ll> comb;\nvector<ll> A;\nll N;\nll M, D;\n\nll gcd(ll x,ll y){\n    if(y == 0)return x;\n    else return gcd(y, x % y);\n}\nll lcm(ll x,ll y){\n    return x*y / gcd(x,y);\n}\n\n\nvoid makeComb(){\n    for(ll i = 0; i <= (1<<M); i++){\n        comb[i] = 1LL;\n        for(ll j = 0; j < M; j++){\n            if(comb[i] >= INF) break;\n            if((i >> j) & 1) comb[i] = lcm(comb[i], A[j]);\n        }     \n    }\n    return;\n}\n\nint main () {\n    cin >> N >> M >> D;\n    comb = vector<ll>((1<<M)+1, 0);\n    A = vector<ll>(M);\n    for(ll i = 0; i < M; i++) cin >> A[i];\n    makeComb();\n    ll pre = N;\n    \n    for(ll i = 0; i < D; i++){\n        ll ret = 0LL;\n        vector<ll> R(M);\n        ll exist = 0;\n        for(ll j = 0; j < M; j++){\n            cin >> R[j];\n            if(R[j] != -1) exist |= 1<<j;\n        }\n        bool update = false;\n        for(ll j = comb[exist] - 1; j >= 0LL; j--){\n            ll f = 0;\n            for(ll k = 0; k < M; k++){\n                if(R[k] != -1 && (j % A[k]) != R[k]) f = 1;\n            }\n            if(f) continue;\n            if(pre < j) continue;\n            update = true; \n            ret = max(ret, ((pre - j) / comb[exist]) * comb[exist] + j);\n        }\n        if(!update){\n            //if(D != 2) while(1){}\n            cout << -1 << endl;\n            return 0;\n        }\n        pre = ret;\n    }\n    cout << pre << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long extgcd(long long a, long long b, long long &x, long long &y) {\n    for (long long u = y = 1, v = x = 0; a; ) {\n        long long q = b / a;\n        swap(x -= q * u, u);\n        swap(y -= q * v, v);\n        swap(b -= q * a, a);\n    }\n    return b;\n}\n\npair<long long, long long> chinese_rem(vector<long long> b, vector<long long> m) {\n    long long r = 0, M = 1;\n    for (int i = 0; i < (int)b.size(); i++) {\n        long long p, q, d = extgcd(M, m[i], p, q);\n        if ((b[i] - r) % d != 0) return {0, -1};\n        r += (b[i] - r) / d * p % (m[i] / d) * M;\n        M *= m[i] / d;\n    }\n    return {(r % M + M) % M, M};\n}\n\nint main() {\n    int N, M, D; cin >> N >> M >> D;\n    vector<long long> a(M);\n    for (auto &ai: a) cin >> ai;\n    bool ng = false;\n    while (D--) {\n        vector<long long> b, m;\n        for (int i = 0; i < M; i++) {\n            int r; cin >> r;\n            if (r != -1) b.emplace_back(r), m.emplace_back(a[i]);\n        }\n        if (ng || b.empty()) continue;\n        auto crt = chinese_rem(b, m);\n        if (crt.second == -1 || N < crt.first) {\n            ng = true;\n        } else {\n            N = N - (N - crt.first) % crt.second;\n        }\n    }\n    cout << (ng ? -1 : N) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N, M, D;\n    vector<int> A;\n    vector< vector<int> > R;\n    void input() {\n        cin >> N >> M >> D;\n        A.resize(M); cin >> A;\n        R.resize(D);\n        for (int i = 0; i < D; i++) {\n            R[i].resize(M); cin >> R[i];\n        }\n    }\n\n    ll lcm(ll a, ll b) {\n        return a / __gcd(a, b) * b;\n    }\n\n    bool check(int n, int d) {\n        for (int i = 0; i < M; i++) {\n            if (R[d][i] < 0) continue;\n            if (n % A[i] != R[d][i]) return false;\n        }\n        return true;\n    }\n\n    void solve() {\n        ll L = 1;\n        for (int i = 0; i < M; i++) L = lcm(L, A[i]);\n\n        ll x = N;\n        for (int d = 0; d < D; d++) {\n            int m = 0;\n            for (int i = 0; i < M; i++) {\n                if (A[m] < A[i]) {\n                    m = i;\n                }\n            }\n            int n = R[d][m];\n            if (n < 0) continue;\n            for (; ; n += A[m]) {\n                if (n > x) {\n                    cout << -1 << endl;\n                    return;\n                }\n                if (check(n, d)) {\n                    break;\n                }\n            }\n            x = (x - n) / L * L + n;\n        }\n        cout << x << endl;\n\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n \n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n \ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) { \n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\n// ax + by = gcd(a, b) となる {x, y, gcd(a, b)} を返す\n// O(log(min(a, b)))\nll extgcd(ll a, ll b, ll &x, ll &y) {\n    ll g = a; x = 1, y = 0;\n    if(b != 0) g = extgcd(b, a%b, y, x), y -= (a/b) * x;\n    return g;\n}\n\n// a^-1 mod n を返す　存在しなければ-1\n// O(log(n))\nll inv(ll a, ll n) {\n    ll s, t;\n    extgcd(a, n, s, t);\n    return (n+s) % n;\n}\n\n// O(a.size*logM)\n// 連立線形合同式 a[i] * x ≡ b[i] (mod m[i]) を解く\n// オーバーフローには注意\npair<ll, ll> crt(const vector<ll>& a, const vector<ll>& b, const vector<ll>& m) {\n    // (答えx, mod)\n    pair<ll, ll> ret(0, 1);\n    REP(i, a.size()) {\n        ll s = a[i] * ret.second;\n        ll t = b[i] - a[i] * ret.first;\n        ll d = __gcd(m[i], s);\n        if(t % d != 0) return make_pair(-1, -1);\n        ll u = t / d * inv(s / d, m[i] / d) % (m[i] / d);\n        ret.first += ret.second * u;\n        ret.second *= m[i] / d;\n        ret.first = (ret.first % ret.second + ret.second) % ret.second;\n    }\n    return ret;\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, m, d;\n    cin >> n >> m >> d;\n    vector<ll> a(m);\n    REP(i, m) cin >> a[i];\n    REP(i, d) {\n        vector<ll> x, y;\n        REP(j, m) {\n            ll r;\n            cin >> r;\n            if(r == -1) continue;\n            x.push_back(r);\n            y.push_back(a[j]);\n        }\n\n        vector<ll> v(x.size(), 1);\n        PII p = crt(v, x, y);\n        // p.second * k + p.first <= n である最大の整数\n        if(p.first == -1 || n < p.first) {\n            cout << -1 << endl;\n            return 0;\n        }\n        ll k = (n-p.first) / p.second;\n        n = p.second * k + p.first;\n        // cerr << \"x:\" << x << endl;\n        // cerr << \"y:\" << y << endl;\n        // cerr << p << \" \" << n << endl;\n    }\n    cout << n << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator &itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator &begin() {return i;}\n  Iterator &end() {return n;}\n};\n\ntemplate<class T> T at(vector<T> v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\nlong long mod_inverse(long long a, long long mod) {\n  long long b = mod, x = 1, y = 0;\n  while (b) {\n    long long t = a / b;\n    swap(a -= t * b, b);\n    swap(x -= t * y, y);\n  }\n  return (mod + x % mod) % mod;\n}\n\npair<long long, long long> linear_congruence(const vector<long long>& A, const vector<long long>& B, const vector<long long>& M) {\n  long long x = 0, m = 1;\n  for (int i : range(A.size())) {\n    long long a = A[i] * m;\n    long long b = B[i] - A[i] * x;\n    long long d = __gcd(M[i], a);\n    if (b % d != 0) return make_pair(0, -1);\n    int t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nconst long long INF = 1e9;\n\nint main() {\n  int n, m, d;\n  cin >> n >> m >> d;\n  long long a[m];\n  for (int i : range(m)) cin >> a[i];\n  long long r[d][m];\n  for (int i : range(d)) for (int j : range(m)) cin >> r[i][j];\n  vector<long long> A, B, M;\n  for (int i : range(d)) {\n    A.clear(); B.clear(); M.clear();\n    for (int j : range(m)) if (r[i][j] != -1) {\n      A.emplace_back(1);\n      B.emplace_back(r[i][j]);\n      M.emplace_back(a[j]);\n    }\n    if (A.empty()) continue;\n    auto x = linear_congruence(A, B, M);\n    if (x.second == -1) {\n      cout << -1 << endl;\n      return 0;\n    }\n    while (x.first + x.second < n) x.first += x.second;\n    if (x.first > n) {\n      cout << -1 << endl;\n      return 0;\n    }\n    n = x.first;\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % (M[i]/d);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair( (x%m + m) % m , m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      long long  tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod==-1){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    assert(b>=0);\n    //cerr << b << \" \" << mod << endl;\n    if(n<mod)n = b;\n    else{\n      long long tmp = (n/mod+1) * mod + b;\n      while(tmp<(long long)n)tmp += (long long)mod;\n      while((long long)n<tmp)tmp -= (long long)mod;\n      if(tmp<0){\n\tcout << -1 << endl;\n\treturn 0;\n      }\n      n = tmp;\n    }\n\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-8;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<ll, ll> linear_congruence(const vector<ll>& A, const vector<ll>& B,\n                                 const vector<ll>& M) {\n  ll x = 0, m = 1;\n  for(ll i = 0; i < A.size(); i++){\n    if(B[i] == -1) continue;\n    ll a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0) return make_pair(0, -1);\n    ll t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  ll num_of_chopsticks;\n  int num_of_divisors;\n  int total_days;\n  while(~scanf(\"%lld %d %d\",\n               &num_of_chopsticks,\n               &num_of_divisors,\n               &total_days)){\n    vector<ll> divisors(num_of_divisors);\n    for(int div_i = 0; div_i < num_of_divisors; div_i++){\n      scanf(\"%lld\",&divisors[div_i]);\n    }\n    ll record[101][11];\n    for(int day = 0; day < total_days; day++){\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        scanf(\"%lld\",&record[day][div_i]);\n      }\n    }\n\n    vector<ll> A(num_of_divisors,1);\n    for(int day = 0; day < total_days; day++){\n      vector<ll> reminder;\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        reminder.push_back(record[day][div_i]);\n      }\n\n      pair<ll,ll> ans = linear_congruence(A,reminder,divisors);\n      num_of_chopsticks = (num_of_chopsticks - ans.first) / ans.second + ans.first;\n      if(ans.second == -1 || num_of_chopsticks < 0) {\n        num_of_chopsticks = -1;\n        break;\n      }\n    }\n    printf(\"%lld\\n\",num_of_chopsticks);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef long long LL;\n\nLL extgcd(LL a, LL b, LL& x, LL& y){\n    LL d = a;\n    if(b != 0){\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nLL mul_mod(LL a, LL b, LL mod){\n    if(b == 0) return 0;\n    LL res = mul_mod((a + a) % mod, b / 2, mod);\n    if(b & 1) res = (res + a) % mod;\n    return res;\n}\n\nLL pow_mod(LL a, LL b, LL mod){\n    if(b == 0) return 1;\n    LL res = pow_mod(mul_mod(a, a, mod), b / 2, mod);\n    if(b & 1) res = mul_mod(res, a, mod);\n    return res;\n}\n\nLL inv_mod(LL a, LL mod){\n    LL x, y;\n    extgcd(a, mod, x, y);\n    return (x % mod + mod) % mod;\n}\n\nvector<LL> inverse_list(int n, int p){\n    vector<LL> inv(n + 1);\n    inv[1] = 1;\n    for (int i = 2; i <= n; ++i){\n        inv[i] = inv[p % i] * (p - p / i) % p;\n    }\n    return inv;\n}\n\npair<LL, LL> linear_congruence(const vector<LL>& A, const vector<LL>& B, const vector<LL>& M) {\n    LL x = 0, m = 1;\n\n    for(int i = 0; i < A.size(); i++) {\n        LL a = A[i] * m, b = B[i] - A[i] * x, d = __gcd(M[i], a);\n        if(b % d != 0) return make_pair(0, -1); // no solution\n        LL t = b / d * inv_mod(a / d , M[i] / d) % (M[i] / d);\n        x = x + m * t;\n        m *= M[i] / d;\n    }\n    return make_pair(x % m, m);\n}\n\nint main(){\n    int N, M, D;\n    while(cin >> N >> M >> D) {\n\n        int A[10];\n        REP(i, M) cin >> A[i];\n\n        for(int t = 0; t < D; t++) {\n            vector<LL> a, b, m;\n            REP(i, M) {\n                int y;\n                cin >> y;\n                if(y == -1) continue;\n                a.push_back(1);\n                b.push_back(y);\n                m.push_back(A[i]);\n            }\n\n            pair<LL, LL> p = linear_congruence(a, b, m);\n\n            if(p.first > N || p.second == -1) {\n                N = -1;\n            } else {\n                LL k = (N - p.first) / p.second;\n                N = p.first + p.second * k;\n            }\n            // cout << N << endl;\n            \n        }\n\n        cout << N << endl;\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T>ostream&operator<<(ostream &o,const vector<T>&t){o<<'[';FOR(i,t){if(i!=t.begin())o<<',';o<<*i;}return o<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)output(a[i],i!=n-1?',':10);}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a;\n  x = 1; y = 0;\n  if (b) {\n    g = extgcd(b, a%b, y, x);\n    y -= (a/b) * x;\n  }\n  return g;\n}\n\nll ChineseRemainderTheorem(const vector<ll> &B, const vector<ll> &M) {\n  ll all = 1;\n  FOR(it, M) all*=*it;\n  ll res = 0;\n  REP(i,B.size()) {\n    ll x,y;\n    extgcd(M[i], all/M[i], x, y);\n    y = (y%all+all)%all;\n    res = (res%all + B[i]*y*(all/M[i]) % all + all) % all;\n    // assert(res >= 0);\n  }\n  return res;\n}\nvector<int> factorize(ll n) {  // O(√n)\n  vector<int> res;\n  for (ll i=2; i*i<=n; ++i) {\n    int r = 1;\n    while (n%i==0) {\n      n /= i;\n      r *= i;\n    }\n    if (r>1) {\n      res.push_back(r);\n    }\n  }\n  if (n!=1) res.push_back(n);\n  return res;\n}\n\nint a[10];\nint x[100][10];\n\nint main() {\n  int n,m,d;\n  while(input(n,m,d)) {\n    vector<vector<int> > facts;\n    REP(i,m) {\n      input(a[i]);\n      facts.push_back(factorize(a[i]));\n    }\n    REP(i,d)REP(j,m)input(x[i][j]);\n    bool ng = 0;\n    ll cur = n;\n    REP(i,d) {\n      map<int,int> mp;\n      REP(j,m) {\n        if (x[i][j] == -1) continue;\n        FOR(it, facts[j]) {\n          if (mp.count(*it) && mp[*it] != x[i][j] % *it) ng = 1;\n          mp[*it] = x[i][j] % *it;\n        }\n      }\n      FOR(it, mp) {\n        FOR(jt, mp) {\n          if (jt->first % it->first == 0 &&\n              (it->second % it->first != jt->second % it->first)) {\n            ng = 1;\n          }\n        }\n      }\n      if (ng) break;\n      vector<ll> v1,v2;\n      FOR(it, mp) {\n        bool f = 0;\n        FOR(jt, mp) {\n          if (it->first < jt->first && jt->first % it->first == 0)\n            f = 1;\n        }\n        if (!f) {\n          v1.push_back(it->second);\n          v2.push_back(it->first);\n        }\n      }\n      ll res = ChineseRemainderTheorem(v1,v2);\n      ll md = 1;\n      FOR(it,v2) md *=*it;\n      FOR(it, v2) {\n        FOR(jt, v2) {\n          if (*it != *jt)\n            assert(__gcd(*it,*jt) == 1);\n        }\n      }\n      REP(i,v1.size()) {\n        assert(res % v2[i] == v1[i]);\n      }\n      \n      // cout << v1 << endl;\n      // cout << v2 << endl;\n      // cout << res << \" \" << md << endl;\n      // md*x + res <= cur\n      // x <= (cur - res) / md\n      if (res > cur) {\n        ng = 1;\n        break;\n      }\n      ll x = (cur - res) / md;\n      cur = x * md + res;\n      // cout << endl;\n    }\n    if (ng) cout << -1 << endl;\n    else cout << cur << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % (M[i]/d);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair(x%m, m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      ll tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod<0){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    ll left = -1, right = n+1;\n    while(right-left>1){\n      ll mid = (left+right)/2;\n      if(mid*mod+b <= n)left = mid;\n      else right = mid;\n    }\n    if(left<0){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    ll tmp = left*mod+b;\n    /*\n    ll tmp = (n/mod + 1) * mod + b;\n    while(n<tmp)tmp -= mod;\n    */\n    n = tmp;\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T>ostream&operator<<(ostream &o,const vector<T>&t){o<<'[';FOR(i,t){if(i!=t.begin())o<<',';o<<*i;}return o<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)output(a[i],i!=n-1?',':10);}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a;\n  x = 1; y = 0;\n  if (b) {\n    g = extgcd(b, a%b, y, x);\n    y -= (a/b) * x;\n  }\n  return g;\n}\n\nll ChineseRemainderTheorem(const vector<ll> &B, const vector<ll> &M) {\n  ll all = 1;\n  FOR(it, M) all*=*it;\n  ll res = 0;\n  REP(i,B.size()) {\n    ll x,y;\n    extgcd(M[i], all/M[i], x, y);\n    y = (y%all+all)%all;\n    res = (res%all + B[i]*y*(all/M[i]) % all + all) % all;\n    // assert(res >= 0);\n  }\n  return res;\n}\nvector<int> factorize(ll n) {  // O(√n)\n  vector<int> res;\n  for (ll i=2; i*i<=n; ++i) {\n    int r = 1;\n    while (n%i==0) {\n      n /= i;\n      r *= i;\n    }\n    if (r>1) {\n      res.push_back(r);\n    }\n  }\n  if (n!=1) res.push_back(n);\n  return res;\n}\n\nint a[10];\nint x[100][10];\n\nint main() {\n  int n,m,d;\n  while(input(n,m,d)) {\n    vector<vector<int> > facts;\n    REP(i,m) {\n      input(a[i]);\n      facts.push_back(factorize(a[i]));\n    }\n    REP(i,d)REP(j,m)input(x[i][j]);\n    bool ng = 0;\n    ll cur = n;\n    REP(i,d) {\n      map<int,int> mp;\n      REP(j,m) {\n        if (x[i][j] == -1) continue;\n        FOR(it, facts[j]) {\n          if (mp.count(*it) && mp[*it] != x[i][j] % *it) ng = 1;\n          mp[*it] = x[i][j] % *it;\n        }\n      }\n      FOR(it, mp) {\n        FOR(jt, mp) {\n          if (jt->first % it->first == 0 &&\n              (it->second % it->first != jt->second % it->first)) {\n            ng = 1;\n          }\n        }\n      }\n      if (ng) break;\n      vector<ll> v1,v2;\n      FOR(it, mp) {\n        bool f = 0;\n        FOR(jt, mp) {\n          if (it->first < jt->first && jt->first % it->first == 0)\n            f = 1;\n        }\n        if (!f) {\n          v1.push_back(it->second);\n          v2.push_back(it->first);\n        }\n      }\n      ll res = ChineseRemainderTheorem(v1,v2);\n      ll md = 1;\n      FOR(it,v2) md *=*it;\n      FOR(it, v2) {\n        FOR(jt, v2) {\n          if (*it != *jt)\n            assert(__gcd(*it,*jt) == 1);\n        }\n      }\n      // REP(i,v1.size()) {\n      //   assert(res % v2[i] == v1[i]);\n      // }\n      \n      // cout << v1 << endl;\n      // cout << v2 << endl;\n      // cout << res << \" \" << md << endl;\n      // md*x + res <= cur\n      // x <= (cur - res) / md\n      if (res > cur) {\n        ng = 1;\n        break;\n      }\n      ll x = (cur - res) / md;\n      cur = x * md + res;\n      // cout << endl;\n    }\n    if (ng) cout << -1 << endl;\n    else cout << cur << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pr;\ntypedef vector<pr > vpr;\nconst int INF=1<<30;\nll lcm(ll a,ll b){\n\tif(a%b==0)\n\treturn b;\n\telse\n\treturn lcm(b,a%b);\n}\nll GCD(ll a,ll b){\n\treturn (a*b)/lcm(a,b);\n}\nint main() {\n\tll N,M,D;\n\tll divi[10];\n\tll dived[100][10],gcd[10]={};\n\tcin >> N >> M >> D;\n\tREP(i,M){\n\tcin >> divi[i];\n\t}\n\tREP(i,D)\n\t\tREP(j,M)\n\t\t\tcin >> dived[i][j];\n\tll now=N;\n\tREP(i,D){\n\t\tll mn=0,ngcd=1;\n\t\tbool ans=false;\n\t\tREP(j,M){\n\t\t\tif(dived[i][j]==-1)\t\n\t\t\t\tcontinue;\n\t\t\tif(!ans)\n\t\t\t\tmn=dived[i][j];\n\t\t\tans=true;\n\t\t\twhile(mn%divi[j]!=dived[i][j] && now>=mn) mn+=ngcd;\n\t\t\tngcd=GCD(ngcd,divi[j]);\n\t\t}\n\t\tif(now<mn){\n\t\t\tnow=-1;\n\t\t\tbreak;\n\t\t}\n\t\tif(ans){\n\t\t\tll alpha=(now-mn)/ngcd;\n\t\t\tnow=mn+alpha*ngcd;\n\t\t}\n\t}\n\tcout << now << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll Int;\nll INF=1ll<<45;\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nint main(){\n  int i,j,k;\n  ll n,m,d;\n  cin>>n>>m>>d;\n  vector<ll> a(m),r(m),lcma(m+1);\n  vector<vector<ll > > subs(m);\n  rep(i,m)\n    cin>>a[i];\n  lcma[0]=1;\n  rep(i,m)\n    lcma[i+1]=lcma[i]*a[i]/__gcd(lcma[i],a[i]);\n//  rep(i,m)\n//    gcda[i]=__gcd(lcma[i],a[i]);\n  rep(i,m){\n    subs[i].resize(a[i],INF);\n    rep(j,a[i]){\n      ll &tmp=subs[i][j*lcma[i]%a[i]];\n      tmp=min(tmp,j*lcma[i]);\n    }\n//rep(j,a[i])cout<<subs[i][j]<<\",\";cout<<endl;\n  }\n  ll dd;\n  rep(i,d){\n    ll nnn=n;\n    rep(j,m)\n      cin>>r[j];\n    rep(j,m){\n      if(r[j]<0)continue;\n      ll nn=(n+a[j]-r[j])%a[j];\n      if(subs[j][nn]==INF){\n        cout<<-1<<endl;\n        return 0;\n      }\n      n-=subs[j][nn];\n      n+=(nnn-n)/lcma[j+1]*lcma[j+1];\n      if(n<0){\n        cout<<-1<<endl;\n        return 0;\n      }\n //     cout<<\"->\"<<n<<\":\"<<r[j]<<\"mod\"<<a[j]<<endl;\n    }\n  }\n  cout<<n<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll Int;\n\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nint main(){\n  int i,j,k;\n  ll n,m,d;\n  cin>>n>>m>>d;\n  vector<ll> a(m),r(m),aa(m),gcda(m);\n  rep(i,m)\n    cin>>a[i];\n  aa[0]=1;\n  rep(i,m-1)\n    aa[i+1]=aa[i]*a[i]/__gcd(aa[i],a[i]);\n  rep(i,m)\n    gcda[i]=__gcd(aa[i],a[i]);\n  ll dd;\n  rep(i,d){\n    rep(j,m)\n      cin>>r[j];\n    rep(j,m){\n      if(r[j]<0)continue;\n      if((n+a[j]-r[j])%a[j]){\n        ll nn=(n+a[j]-r[j])%a[j];\n        if(nn%gcda[j]){\n          cout<<-1<<endl;\n          return 0;\n        }\n        ll hoge,hogee;\n        extgcd(a[j],aa[j],hogee,hoge);\n        hoge=hoge % (a[j]/gcda[j]) + (a[j]/gcda[j]);\n        n-=aa[j]*( hoge %(a[j]/gcda[j]) )*(nn/gcda[j]);\n        if(n<0){\n          cout<<-1<<endl;\n          return 0;\n        }\n      }\n    //  cout<<\"->\"<<n<<\":\"<<r[j]<<\"mod\"<<a[j]<<endl;\n    }\n  }\n  cout<<n<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll Int;\nll INF=1ll<<45;\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nint main(){\n  int i,j,k;\n  ll n,m,d;\n  cin>>n>>m>>d;\n  vector<ll> a(m),r(m),aa(m+1),gcda(m);\n  vector<vector<ll > > subs(m);\n  rep(i,m)\n    cin>>a[i];\n  aa[0]=1;\n  rep(i,m)\n    aa[i+1]=aa[i]*a[i]/__gcd(aa[i],a[i]);\n  rep(i,m)\n    gcda[i]=__gcd(aa[i],a[i]);\n  rep(i,m){\n    subs[i].resize(a[i],INF);\n    rep(j,a[i]){\n      ll &tmp=subs[i][j*aa[i]%a[i]];\n      tmp=min(tmp,j*aa[i]);\n    }\n//rep(j,a[i])cout<<subs[i][j]<<\",\";cout<<endl;\n  }\n  ll dd;\n  rep(i,d){\n    ll nnn=n;\n    rep(j,m)\n      cin>>r[j];\n    rep(j,m){\n      if(r[j]<0)continue;\n      if((n+a[j]-r[j])%a[j]){\n        ll nn=(n+a[j]-r[j])%a[j];\n        if(nn%gcda[j] || subs[j][nn]==INF){\n          cout<<-1<<endl;\n          return 0;\n        }\n        n-=subs[j][nn];\n        n+=(nnn-n)/aa[j+1]*aa[j+1];\n        if(n<0){\n          cout<<-1<<endl;\n          return 0;\n        }\n      }\n //     cout<<\"->\"<<n<<\":\"<<r[j]<<\"mod\"<<a[j]<<endl;\n    }\n  }\n  cout<<n<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll Int;\nll INF=1ll<<45;\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nint main(){\n  int i,j,k;\n  ll n,m,d;\n  cin>>n>>m>>d;\n  vector<ll> a(m),r(m),aa(m),gcda(m);\n  vector<vector<ll > > subs(m);\n  rep(i,m)\n    cin>>a[i];\n  aa[0]=1;\n  rep(i,m-1)\n    aa[i+1]=aa[i]*a[i]/__gcd(aa[i],a[i]);\n  rep(i,m)\n    gcda[i]=__gcd(aa[i],a[i]);\n  rep(i,m){\n    subs[i].resize(a[i],INF);\n    rep(j,a[i])\n      subs[i][j]=min(subs[i][j],j*a[j]);\n//    rep(j,a[i])cout<<subs[i][j]<<\",\";cout<<endl;\n  }\n  ll dd;\n  rep(i,d){\n    rep(j,m)\n      cin>>r[j];\n    rep(j,m){\n      if(r[j]<0)continue;\n      if((n+a[j]-r[j])%a[j]){\n        ll nn=(n+a[j]-r[j])%a[j];\n        if(nn%gcda[j] || subs[j][nn]==INF){\n          cout<<-1<<endl;\n          return 0;\n        }\n        n-=subs[j][nn];\n        if(n<0){\n          cout<<-1<<endl;\n          return 0;\n        }\n      }\n //     cout<<\"->\"<<n<<\":\"<<r[j]<<\"mod\"<<a[j]<<endl;\n    }\n  }\n  cout<<n<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N, M, D;\n    vector<int> A;\n    vector< vector<int> > R;\n    void input() {\n        cin >> N >> M >> D;\n        A.resize(M); cin >> A;\n        R.resize(D);\n        for (int i = 0; i < D; i++) {\n            R[i].resize(M); cin >> R[i];\n        }\n    }\n\n    ll lcm(ll a, ll b) {\n        return a / __gcd(a, b) * b;\n    }\n\n    bool check(int n, int d) {\n        for (int i = 0; i < M; i++) {\n            if (R[d][i] < 0) continue;\n            if (n % A[i] != R[d][i]) return false;\n        }\n        return true;\n    }\n\n    void solve() {\n        ll L = 1;\n        for (int i = 0; i < M; i++) L = lcm(L, A[i]);\n\n        ll x = N;\n        for (int d = 0; d < D; d++) {\n            int a = 0;\n            int m = -1;\n            for (int i = 0; i < M; i++) {\n                if (R[d][i] < 0) continue;\n                if (a < A[i]) {\n                    a = A[i];\n                    m = i;\n                }\n            }\n            if (m < 0) continue;\n            int n = R[d][m];\n            for (; ; n += A[m]) {\n                if (n > x) {\n                    cout << -1 << endl;\n                    return;\n                }\n                if (check(n, d)) {\n                    break;\n                }\n            }\n            x = (x - n) / L * L + n;\n        }\n        cout << x << endl;\n\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\nusing namespace std;\ntypedef pair<int,int> pr;\ntypedef vector<pr > vpr;\nconst int INF=1<<30;\nint lcm(int a,int b){\n\tif(a%b==0)\n\treturn b;\n\telse\n\treturn lcm(b,a%b);\n}\nint GCD(int a,int b){\n\treturn (a*b)/lcm(a,b);\n}\nint main() {\n\tint N,M,D;\n\tint divi[10];\n\tint dived[100][10],gcd[10]={};\n\tcin >> N >> M >> D;\n\tREP(i,M){\n\tcin >> divi[i];\n\tif(i)\n\tgcd[i]=GCD(gcd[i-1],divi[i]);\n\telse\n\tgcd[i]=divi[i];\n\t}\n\tREP(i,D)\n\t\tREP(j,M)\n\t\t\tcin >> dived[i][j];\n\tint now=N;\n\tREP(i,D){\n\t\tint mn=0;\n\t\tbool ans=false;\n\t\tREP(j,M){\n\t\tif(dived[i][j]==-1)\t\n\t\tcontinue;\n\t\tans=true;\n\t\tif(mn==0)\n\t\t\tmn=dived[i][j];\n\t\twhile(mn%divi[j]!=dived[i][j] && N>mn) mn+=gcd[i];\n\t\t}\n\t\tif(now<mn){\n\t\t\tnow=-1;\n\t\t\tbreak;\n\t\t}\n\t\tif(ans){\n\t\tint alpha=(now-mn)/gcd[M-1];\n\t\tnow=mn+alpha*gcd[M-1];\n\t\t}\n\t}\n\tcout << now << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef long long LL;\n\nLL extgcd(LL a, LL b, LL& x, LL& y){\n    LL d = a;\n    if(b != 0){\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nLL mul_mod(LL a, LL b, LL mod){\n    if(b == 0) return 0;\n    LL res = mul_mod((a + a) % mod, b / 2, mod);\n    if(b & 1) res = (res + a) % mod;\n    return res;\n}\n\nLL pow_mod(LL a, LL b, LL mod){\n    if(b == 0) return 1;\n    LL res = pow_mod(mul_mod(a, a, mod), b / 2, mod);\n    if(b & 1) res = mul_mod(res, a, mod);\n    return res;\n}\n\nLL inv_mod(LL a, LL mod){\n    LL x, y;\n    extgcd(a, mod, x, y);\n    return (x % mod + mod) % mod;\n}\n\nvector<LL> inverse_list(int n, int p){\n    vector<LL> inv(n + 1);\n    inv[1] = 1;\n    for (int i = 2; i <= n; ++i){\n        inv[i] = inv[p % i] * (p - p / i) % p;\n    }\n    return inv;\n}\n\npair<LL, LL> linear_congruence(const vector<LL>& A, const vector<LL>& B, const vector<LL>& M) {\n    LL x = 0, m = 1;\n\n    for(int i = 0; i < A.size(); i++) {\n        LL a = A[i] * m, b = B[i] - A[i] * x, d = __gcd(M[i], a);\n        if(b % d != 0) return make_pair(0, -1); // no solution\n        LL t = b / d * inv_mod(a / d , M[i] / d) % (M[i] / d);\n        x = x + m * t;\n        m *= M[i] / d;\n    }\n    return make_pair(x % m, m);\n}\n\nint main(){\n    int N, M, D;\n    while(cin >> N >> M >> D) {\n\n        int A[10];\n        REP(i, M) cin >> A[i];\n\n        for(int t = 0; t < D; t++) {\n            vector<LL> a, b, m;\n            REP(i, M) {\n                int y;\n                cin >> y;\n                if(y == -1) continue;\n                a.push_back(1);\n                b.push_back(y);\n                m.push_back(A[i]);\n            }\n\n            pair<LL, LL> p = linear_congruence(a, b, m);\n\n            if(p.first > N || p.second == -1) {\n                N = -1;\n            } else {\n                LL k = (N - p.first) / p.second;\n                assert(p.first + p.second * k <= N);\n                assert(p.first + p.second * (k + 1) > N);\n                N = p.first + p.second * k;\n            }\n            // cout << N << endl;\n            \n        }\n\n        cout << N << endl;\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dump(x) cout << (#x) << \" = \" << (x) << \", \";\nusing namespace std;\ntypedef long long ll;\n\nint gcd(int a, int b){\n  if(b == 0) return a;\n  return gcd(b, a % b);\n}\n\nint extgcd(int a, int b, int& x, int& y){\n  int d = a;\n  if(b != 0){\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nint mod_inverse(int a, int m){\n  int x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<int, int> linear_congruece(const vector<int>& A, const vector<int>& B, const vector<int>& M){\n  int x = 0, m =1;\n  for(int i = 0; i < A.size(); ++i){\n    int a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0)return make_pair(0, -1);\n    int t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  int n, m, d;\n  cin >> n >> m >> d;\n  vector<int> A(m,1), M;\n  for(int i = 0; i < m; ++i){\n    int tmp;\n    cin >> tmp;\n    M.push_back(tmp);\n  }\n  for(int i = 0; i < d; ++i){\n    //dump(i);dump(d);\n    vector<int> B;\n\n    for(int j = 0; j < m; ++j){\n      int tmp;\n      cin >> tmp;\n      B.push_back(tmp);\n    }\n\n    if(B[0] < 0) continue;\n\n    pair<int, int> res = linear_congruece(A, B, M);\n\n    if(res.second == -1){\n      n = -1;\n      break;\n    }\n    \n    int modn = n % res.second;\n    int mod = res.second;\n    int modnext = res.first;\n    /*\n    dump(n);\n    dump(modn);\n    */\n    while(modnext < 0) modnext += mod;\n    modnext = (modnext + (abs(modnext) / mod + 1) * mod) % mod;\n    if(modn >= modnext) n -= modn - modnext;\n    else {\n      n -= mod;\n      n += modnext - modn;\n    }\n\n    /*\n    dump(modnext);\n    dump(mod);\n    dump(n);\n    cout << endl;\n    */\n    \n  }\n  cout << (n < 0 ? -1 : n) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint cal(int n,P p){\n  while(n%p.first!=p.second&&n>=0)n--;\n  return n;\n}\n\nint main(){\n  int n,m,d,a[10];\n  cin>>n>>m>>d;\n  for(int i=0;i<m;i++){\n    cin>>a[i];\n  }\n  P r[100][10];\n  for(int i=0;i<d;i++){\n    for(int j=0;j<m;j++){\n      cin>>r[i][j].second;\n      r[i][j].first=a[j];\n    }\n    sort(r[i],r[i]+m);\n    reverse(r[i],r[i]+m);\n    vector<int> v;\n    for(int j=0;j<m;j++){\n      if(r[i][j].second==-1)continue;\n      if(j){\n\tvector<int> nv;\n\tfor(int k=0;k<(int)v.size();k++){\n\t  if(v[k]%r[i][j].first==r[i][j].second)nv.push_back(v[k]);\n\t}\n\tv=nv;\n      }\n      else {\n\tint u=5e6;\n\tint p=cal(n,r[i][j]);\n\twhile((int)v.size()<u&&p>=0){\n\t  v.push_back(p);\n\t  p-=r[i][j].first;\n\t}\n      }\n    }\n    if(v.size())n=v[0];\n    else if(r[i][0].second!=-1)n=-1;\n  }\n  cout<<n<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll Int;\nll INF=1ll<<45;\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nint main(){\n  int i,j,k;\n  ll n,m,d;\n  cin>>n>>m>>d;\n  vector<ll> a(m),r(m),lcma(m+1);\n  vector<vector<ll > > subs(m);\n  rep(i,m)\n    cin>>a[i];\n  lcma[0]=1;\n  rep(i,m)\n    lcma[i+1]=lcma[i]*a[i]/__gcd(lcma[i],a[i]);\n//  rep(i,m)\n//    gcda[i]=__gcd(lcma[i],a[i]);\n  rep(i,m){\n    subs[i].resize(a[i],INF);\n    rep(j,a[i]){\n      ll &tmp=subs[i][j*lcma[i]%a[i]];\n      tmp=min(tmp,j*lcma[i]);\n    }\n//rep(j,a[i])cout<<subs[i][j]<<\",\";cout<<endl;\n  }\n  ll dd;\n  rep(i,d){\n    ll nnn=n;\n    rep(j,m)\n      cin>>r[j];\n    rep(j,m){\n      if(r[j]<0)continue;\n      if((n+a[j]-r[j])%a[j]){\n        ll nn=(n+a[j]-r[j])%a[j];\n        if(subs[j][nn]==INF){\n          cout<<-1<<endl;\n          return 0;\n        }\n        n-=subs[j][nn];\n        n+=(nnn-n)/lcma[j+1]*lcma[j+1];\n        if(n<0){\n          cout<<-1<<endl;\n          return 0;\n        }\n      }\n //     cout<<\"->\"<<n<<\":\"<<r[j]<<\"mod\"<<a[j]<<endl;\n    }\n  }\n  cout<<n<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef long long LL;\n\nLL extgcd(LL a, LL b, LL& x, LL& y){\n    LL d = a;\n    if(b != 0){\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nLL mul_mod(LL a, LL b, LL mod){\n    if(b == 0) return 0;\n    LL res = mul_mod((a + a) % mod, b / 2, mod);\n    if(b & 1) res = (res + a) % mod;\n    return res;\n}\n\nLL pow_mod(LL a, LL b, LL mod){\n    if(b == 0) return 1;\n    LL res = pow_mod(mul_mod(a, a, mod), b / 2, mod);\n    if(b & 1) res = mul_mod(res, a, mod);\n    return res;\n}\n\nLL inv_mod(LL a, LL mod){\n    LL x, y;\n    extgcd(a, mod, x, y);\n    return (x % mod + mod) % mod;\n}\n\nvector<LL> inverse_list(int n, int p){\n    vector<LL> inv(n + 1);\n    inv[1] = 1;\n    for (int i = 2; i <= n; ++i){\n        inv[i] = inv[p % i] * (p - p / i) % p;\n    }\n    return inv;\n}\n\nLL chinese(LL a, LL b, LL m1, LL m2) {\n    LL X = (m2 * a * inv_mod(m2, m1) + m1 * b * inv_mod(m1, m2)) % (m1*m2);\n    // cout << \"---\" << endl;\n    // cout << a << \" (mod \" << m1 << \")\" << endl;\n    // cout << b << \" (mod \" << m2 << \")\" << endl;\n    // cout << X << \" (mod \" << m1 * m2 << \")\" << endl;\n    // cout << \"---\" << endl;\n    return X / __gcd(m1, m2);\n}\n\nint main(){\n    int N, M, D;\n    while(cin >> N >> M >> D) {\n\n        int A[10];\n        REP(i, M) cin >> A[i];\n\n        for(int t = 0; t < D; t++) {\n            int B[10];\n            REP(i, M) cin >> B[i];\n            LL a = 0;\n            LL m = 1;\n\n            for(int i = 0; i < M; i++) if(B[i] != -1) {\n                a = chinese(a, B[i], m, A[i]);\n                m = m / __gcd(m, (LL)A[i]) * A[i];\n                // cout << a << \" (mod \" << m << \")\" << endl;\n            }\n\n            // cout << a << \" (mod \" << m << \")\" << endl;\n            // cout << \"N : \" << N << \" -> \";\n\n            if(a > N) {\n                N = -1;\n            } else {\n                LL k = (N - a) / m;\n                assert(a + m * k <= N);\n                assert(a + m * k + m > N);\n                N = a + m * k;\n            }\n            // cout << N << endl;\n            \n        }\n\n        cout << N << endl;\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint cal(int n,P p){\n  while(n%p.first!=p.second&&n>=0)n--;\n  return n;\n}\n\nint main(){\n  int n,m,d,a[10];\n  cin>>n>>m>>d;\n  for(int i=0;i<m;i++){\n    cin>>a[i];\n  }\n  P r[100][10];\n  for(int i=0;i<d;i++){\n    for(int j=0;j<m;j++){\n      cin>>r[i][j].second;\n      r[i][j].first=a[j];\n    }\n    sort(r[i],r[i]+m);\n    reverse(r[i],r[i]+m);\n    vector<int> v;\n    for(int j=0;j<m;j++){\n      if(r[i][j].second==-1)continue;\n      if(j){\n\tvector<int> nv;\n\tfor(int k=0;k<(int)v.size();k++){\n\t  if(v[k]%r[i][j].first==r[i][j].second)nv.push_back(v[k]);\n\t}\n\tv=nv;\n      }\n      else {\n\tint u=1e7;\n\tint p=cal(n,r[i][j]);\n\twhile((int)v.size()<u&&p>=0){\n\t  v.push_back(p);\n\t  p-=r[i][j].first;\n\t}\n      }\n    }\n    if(v.size())n=v[0];\n    else if(r[i][0].second!=-1)n=-1;\n  }\n  cout<<n<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <utility>\nusing namespace std;\ntypedef unsigned long ulong;\n\nclass Solver {\n\npublic:\n\tstatic void solve() {\n\t\tlong n, m, d;\n\t\tcin >> n >> m >> d;\n\n\t\tlong as[11];\n\t\tfor (int i = 0; i < m; i++)cin >> as[i];\n\n\t\tlong res = n;\n\t\tlong rs[1005][11];\n\t\tfor (int i = 0; i < d; i++) {\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tcin >> rs[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < d; i++) {\n\t\t\tlong lcm = 1;\n\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (rs[i][j] == -1)continue;\n\n\t\t\t\tlong firstMargin = res % as[j];\n\t\t\t\tlong margin = firstMargin;\n\t\t\t\twhile (margin != rs[i][j]) {\n\t\t\t\t\tmargin = margin + (lcm / as[j] + 1) * as[j] - lcm;\n\t\t\t\t\tmargin %= as[j];\n\t\t\t\t\tres -= lcm;\n\t\t\t\t\tif (res < 0 || margin == firstMargin) {\n\t\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlcm = LCM(lcm, as[j]);\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\tstatic long GCD(long a, long b) {\n\t\tif (b > a) {\n\t\t\tlong temp = b;\n\t\t\tb = a;\n\t\t\ta = temp;\n\t\t}\n\t\tlong c = b;\n\t\tdo {\n\t\t\tc = a % b;\n\t\t\ta = b;\n\t\t\tb = c;\n\t\t} while (c > 0);\n\t\treturn a;\n\t}\n\n\tstatic long LCM(long a, long b) {\n\t\tlong c = GCD(a, b);\n\t\treturn a / c * b;\n\t}\n\n};\n\nint main() {\n\tSolver::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define MAX_N 150\n#define INF 9999999999LL\n\nlong long p[MAX_N];\nlong long x[MAX_N][MAX_N];\nlong long z[MAX_N][2];\nlong long N, M, D;\n\nlong long gcd(long long X, long long Y) {\n\treturn Y ? gcd(Y, X % Y) : X;\n}\n\nint main() {\n\tcin >> N >> M >> D;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> p[i];\n\t}\n\tfor (int i = 0; i < D; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> x[i][j];\n\t\t}\n\t\tz[i][1] = 1;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tlong long a1 = z[i][0], a2 = z[i][1], cnt1 = 0;\n\t\t\twhile (true) {\n\t\t\t\tif (cnt1 >= 1000 || a1 >= INF) {\n\t\t\t\t\tz[i][0] = INF; z[i][1] = INF; break;\n\t\t\t\t}\n\t\t\t\tif (a1%p[j] == x[i][j]) {\n\t\t\t\t\tz[i][0] = a1;\n\t\t\t\t\tz[i][1] = a2*p[j] / gcd(a2, p[j]);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ta1 += a2;\n\t\t\t\tcnt1++;\n\t\t\t}\n\t\t}\n\t}\n\tint res = N;\n\tfor (int i = 0; i < D; i++) {\n\t\tint b1 = z[i][0], b2 = z[i][1];\n\t\tif (z[i][0] == INF) {\n\t\t\tres = -1;\n\t\t}\n\t\tif (res >= 0) {\n\t\t\tint k = (res - b1) / b2;\n\t\t\tk *= b2;\n\t\t\tk += b1;\n\t\t\tres = b1;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef long long ll;\nstruct NT{\n  ll m;  // mod\n  vector<bool>ismrime;\n  vector<ll> euler;\n  vector<ll> fact;\n\n  NT(ll MOD){\n    m=MOD;\n    fact.resize(500005);\n    fact[0]=1;\n    for(ll i=1;i<500005;i++){\n      fact[i]=(fact[i-1]*i)%MOD;\n    }\n  }\n\n  void eratos(int n){\n    ismrime.resize(n+1);\n    for(int i=0;i<=n;i++) ismrime[i]=true;\n    ismrime[0]=0;\n    ismrime[1]=0;\n    for(int i=2;i<=n;i++){\n      if(ismrime[i]){\n        for(int j=i+i;j<=n;j+=i) ismrime[j]=false;\n      }\n    }\n  }\n\n  // 因数分解 √N\n  vector<int> mrime_decommosition(ll x){\n    vector<int>res;\n    for(int i=2;i*i<=x;i++){\n      while(x%i==0){\n        x/=i;\n        res.push_back(i);\n      }\n    }\n    if(x!=1) res.push_back(x);\n    return res;\n  }\n\n  // 約数列挙 √N\n  vector<ll> divisor(ll x){\n    vector<ll> res;\n    for(ll i=1; i*i<=x ;i++)\n      if(x%i==0){\n        res.push_back(i);\n        if(i*i!=x) res.push_back(x/i);\n      }\n    sort(res.begin(), res.end());\n    return res;\n  }\n\n  // a*b>LONG_MAX ? \n  bool overflow(ll a,ll b,ll LONGMAX){return a > LONGMAX/b;}\n\n  ll extgcd(ll a,ll b,ll& x,ll& y){\n    ll d = a ;\n    if ( b != 0 ) {\n      d = extgcd( b , a%b , y , x ) ;\n      y -= ( a / b ) * x ;\n    }else{\n      x = 1 ; y = 0 ;\n    }\n    return d;\n  }\n  ll mod_inverse(ll a){\n    ll x , y ;\n    extgcd( a , m , x , y ) ;\n    return ( m + x % m ) % m ;\n  }\n  ll mod_inverse_M(ll a,ll m){\n    ll x , y ;\n    extgcd( a , m , x , y ) ;\n    return ( m + x % m ) % m ;\n  }\n\n  pair<ll,ll> linear_congruence(const vector<ll> &A,const vector<ll> &B,const vector<ll> &M){\n  \tll x=0,m=1;\n  \tfor(int i=0;i<A.size();i++){\n  \t\tll a=A[i]*m;\n  \t\tll b=B[i]-A[i]*x;\n  \t\tll d=__gcd(M[i],a);\n  \t\tif(b%d!=0)return make_pair(0,-1);\n  \t\tll t=b/d*mod_inverse_M(a/d,M[i]/d)%(M[i]/d);\n  \t\tx=x+m*t;\n  \t\tm*=M[i]/d;\n  \t}\n  \treturn make_pair(x%m,m);\n  }\n\n  // オイラー関数√N\n  ll euler_mhi(ll n){\n    ll res = n;\n    for(ll i=2; i*i <= n ; i++){\n      if( n%i == 0 ){\n        res = res/i*(i-1);\n        for(;n%i==0;n/=i);\n      }\n    }\n    if(n!=1)res=res/n*(n-1);\n    return res;\n  }\n\n  void make_euler_table(int n){\n    euler.resize(n+1);\n    for(int i=0;i<n;i++) euler[i]=i;\n    for(int i=2;i<n;i++){\n      if(euler[i]==i){\n        for(int j=i;j<n;j+=i){\n          euler[j]=euler[j]/i*(i-1);\n        }\n      }\n    }\n  }\n\n  // n! と nCr \n  // mはmod\n  ll mod_fact(ll n,ll& e){\n    e=0;\n    if(n==0)return 1;\n\n    int res = mod_fact(n/m,e);\n    e+=n/m;\n\n    if(n/m%2 != 0)return res*(m-fact[n%m])%m;\n    return res*fact[n%m]%m;\n  }\n\n  ll combination(ll n,ll k){\n    if(n==k||k==0)return 1;\n    if(n<0 || k<0 || n<k)return 0;\n    ll e1,e2,e3;\n    ll a1 = mod_fact(n,e1);\n    ll a2 = mod_fact(k,e2);\n    ll a3 = mod_fact(n-k,e3);\n    return a1*mod_inverse(a2*a3%m)%m;\n  }\n\n  ll mod_mult(ll a, ll b,ll m) {\n    ll res = 0;\n    ll exm = a % m;\n    while (b) {\n      if (b & 1) {\n        res += exm;\n        if (res > m) res -= m;\n      }\n      exm <<= 1;\n      if (exm > m) exm -= m;\n      b >>= 1;\n    }\n    return res;\n  }\n\n  ll mod_exm(ll a, ll b,ll m) {\n    ll res = 1;\n    ll exm = a % m;\n    while (b) {\n      if (b & 1) res = mod_mult(res, exm,m);\n      exm = mod_mult(exm, exm,m);\n      b >>= 1;\n    }\n    return res;\n  }\n\n  // 確率的高速素数判定　\n  bool miller_rabin(ll n, ll times=10) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (!(n & 1)) return false;\n    ll q = n-1;\n    int k = 0;\n    while (q % 2 == 0) {\n      k++;\n      q >>= 1;\n    }\n    for (int i = 0; i < times; i++) {\n      ll a = rand() % (n-1) + 1;\n      ll x = mod_exm(a, q, n);\n      if (x == 1) continue;\n      bool found = false;\n      for (int j = 0; j < k; j++) {\n        if (x == n-1) {\n          found = true;\n          break;\n        }\n        x = mod_mult(x, x, n);\n      }\n      if (found) continue;\n      return false;\n    }\n    return true;\n  }\n\n  ll pollard_rho(ll n, int c) {\n    ll x = 2;\n    ll y = 2;\n    ll d = 1;\n    while (d == 1) {\n      x = mod_mult(x, x, n) + c;\n      y = mod_mult(y, y, n) + c;\n      y = mod_mult(y, y, n) + c;\n      d = __gcd((x-y >= 0 ? x-y : y-x), n);\n    }\n    if (d == n) return pollard_rho(n, c+1);\n    return d;\n  }\n};\n\nint n,m[11],d,M;\nsigned main(){\n\tNT N(1e9+7);\n\tcin>>n>>M>>d;\n\tr(i,M)cin>>m[i];\n\tr(i,d){\n\t\tvector<int>A,B,C;\n\t\tr(j,M){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tif(x!=-1){\n\t\t\t\tA.push_back(1);\n\t\t\t\tB.push_back(x);\n\t\t\t\tC.push_back(m[j]);\n\t\t\t}\n\t\t}\n\t\tpair<int,int> p=N.linear_congruence(A,B,C);\n\t\tif(p.second<0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint x=p.first;\n\t\tint l=0,r=1e9;\n\n\t\twhile(l<r){\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(x+mid*p.second>=n)r=mid;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tif(x+(l)*p.second<=n)n=x+(l)*p.second;\n\t\telse n=x+(l-1)*p.second;\n\t}\n\tcout<<n<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\nconst ll INF = 1000000009LL;\n\nvector<ll> comb;\nvector<ll> A;\nll N;\nll M, D;\n\nll gcd(ll x,ll y){\n    if(y == 0)return x;\n    else return gcd(y, x % y);\n}\nll lcm(ll x,ll y){\n    return x*y / gcd(x,y);\n}\n\n\nvoid makeComb(){\n    for(ll i = 0; i <= (1<<M); i++){\n        comb[i] = 1LL;\n        for(ll j = 0; j < M; j++){\n            if(comb[i] >= INF) break;\n            if((i >> j) & 1) comb[i] = lcm(comb[i], A[j]);\n        }     \n    }\n    return;\n}\n\nint main () {\n    cin >> N >> M >> D;\n    comb = vector<ll>((1<<M)+1, 0);\n    A = vector<ll>(M);\n    for(ll i = 0; i < M; i++) cin >> A[i];\n    makeComb();\n    ll pre = N;\n    \n    for(ll i = 0; i < D; i++){\n        ll ret = 0LL;\n        vector<ll> R(M);\n        ll exist = 0;\n        for(ll j = 0; j < M; j++){\n            cin >> R[j];\n            if(R[j] != -1) exist |= 1<<j;\n        }\n        bool update = false;\n\n        ll step = 1LL;\n        ll use = 0;\n        for(ll j = 0; j <= comb[exist]; j+=step){\n            ll f = 0;\n            for(ll k = 0; k < M; k++){\n                if(R[k] != -1 && (j % A[k]) != R[k]) f = 1;\n                else if(R[k] != -1 && (j % A[k]) == R[k]){\n                    if((use>>k) & 1) continue;\n                    use |= (1<<k);\n                    step = lcm(step, A[k]);\n                }\n            }\n            if(f) continue;\n            if(pre < j) continue;\n            update = true; \n            ret = max(ret, ((pre - j) / comb[exist]) * comb[exist] + j);\n        }\n        if(!update){\n            //if(D != 2) while(1){}\n            cout << -1 << endl;\n            return 0;\n        }\n        pre = ret;\n    }\n    cout << pre << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dump(x) cout << (#x) << \" = \" << (x) << \", \";\nusing namespace std;\ntypedef long long lli;\n\nlli gcd(lli a, lli b){\n  if(b == 0) return a;\n  return gcd(b, a % b);\n}\n\nlli extgcd(lli a, lli b, lli& x, lli& y){\n  lli d = a;\n  if(b != 0){\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nlli mod_inverse(lli a, lli m){\n  lli x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<lli, lli> linear_congruece(const vector<lli>& A, const vector<lli>& B, const vector<lli>& M){\n  lli x = 0, m =1;\n  for(lli i = 0; i < A.size(); ++i){\n    lli a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0)return make_pair(0, -1);\n    lli t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  lli n, m, d;\n  cin >> n >> m >> d;\n  vector<lli> A(m,1), M;\n  for(lli i = 0; i < m; ++i){\n    lli tmp;\n    cin >> tmp;\n    M.push_back(tmp);\n  }\n  for(lli i = 0; i < d; ++i){\n    //dump(i);dump(d);\n    vector<lli> B;\n\n    for(lli j = 0; j < m; ++j){\n      lli tmp;\n      cin >> tmp;\n      B.push_back(tmp);\n    }\n\n    if(B[0] < 0) continue;\n\n    pair<lli, lli> res = linear_congruece(A, B, M);\n\n    if(res.second == -1){\n      n = -1;\n      break;\n    }\n    \n    lli modn = n % res.second;\n    lli mod = res.second;\n    lli modnext = res.first;\n    /*\n    dump(n);\n    dump(modn);\n    */\n    while(modnext < 0) modnext += mod;\n    modnext = (modnext + (llabs(modnext) / mod + 1) * mod) % mod;\n    if(modn >= modnext) n -= modn - modnext;\n    else {\n      n -= mod;\n      n += modnext - modn;\n    }\n\n    /*\n    dump(modnext);\n    dump(mod);\n    dump(n);\n    cout << endl;\n    */\n    if(n < 0) break;\n    \n  }\n  cout << (n < 0 ? -1 : n) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint extgcd(int a, int b, int& x, int& y) {\n  int d = a;\n  if (b != 0) {\n\td = extgcd(b, a % b, y, x);\n\ty -= (a / b) * x;\n  } else {\n\tx = 1; y = 0;\n  }\n  return d;\n}\n\nint mod_inverse(int a, int m) {\n  int x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\nbool allminus(vector<int> B) {\n  for (int i = 0; i < (int)B.size(); i++) {\n\tif (B[i] >= 0)\n\t  return false;\n  }\n  return true;\n}\n\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  else return gcd(b, a%b);\n}\n\nP linear_congruence(const vector<int>& B, const vector<int>& M) {\n  int x = 0, m = 1;\n  int n = B.size();\n  if (allminus(B)) return P(-1, -1);\n  for (int i = 0; i < n; i++) {\n\tif (B[i] < 0) continue;\n\tint a = m, b = B[i] - x, d = gcd(M[i], a);\n\tif (b % d != 0) return P(0, -1);\n\tint t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n\tx = x + m * t;\n\tm *= M[i] / d;\n  }\n  return P(x % m , m);\n}\n\nint main() {\n  int n, m, d;\n  cin >> n >> m >> d;\n  vector<int> M(m);\n  for (int i = 0; i < m; i++)\n\tcin >> M[i];\n\n  vector<int> B[d];\n  for (int i = 0; i < d; i++) {\n\tfor (int j = 0; j < m; j++) {\n\t  int r;\n\t  cin >> r;\n\t  B[i].push_back(r);\n\t}\n  }\n\n  for (int i = 0; i < d; i++) {\n\tP p = linear_congruence(B[i], M);\n\tif (p.first == -1 && p.second == -1) continue;\n\tif (p.first == 0 && p.second == -1) {\n\t  cout << -1 << endl;\n\t  return 0;\n\t}\n\tif (n >= p.first) {\n\t  int t = (n - p.first) / p.second;\n\t  n = p.first + p.second * t;\n\t} else {\n\t  cout << -1 << endl;\n\t  return 0;\n\t}\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef long long ll;\nstruct NT{\n  ll m;  // mod\n  vector<bool>ismrime;\n  vector<ll> euler;\n  vector<ll> fact;\n\n  NT(ll MOD){\n    m=MOD;\n    fact.resize(500005);\n    fact[0]=1;\n    for(ll i=1;i<500005;i++){\n      fact[i]=(fact[i-1]*i)%MOD;\n    }\n  }\n\n  void eratos(int n){\n    ismrime.resize(n+1);\n    for(int i=0;i<=n;i++) ismrime[i]=true;\n    ismrime[0]=0;\n    ismrime[1]=0;\n    for(int i=2;i<=n;i++){\n      if(ismrime[i]){\n        for(int j=i+i;j<=n;j+=i) ismrime[j]=false;\n      }\n    }\n  }\n\n  // 因数分解 √N\n  vector<int> mrime_decommosition(ll x){\n    vector<int>res;\n    for(int i=2;i*i<=x;i++){\n      while(x%i==0){\n        x/=i;\n        res.push_back(i);\n      }\n    }\n    if(x!=1) res.push_back(x);\n    return res;\n  }\n\n  // 約数列挙 √N\n  vector<ll> divisor(ll x){\n    vector<ll> res;\n    for(ll i=1; i*i<=x ;i++)\n      if(x%i==0){\n        res.push_back(i);\n        if(i*i!=x) res.push_back(x/i);\n      }\n    sort(res.begin(), res.end());\n    return res;\n  }\n\n  // a*b>LONG_MAX ? \n  bool overflow(ll a,ll b,ll LONGMAX){return a > LONGMAX/b;}\n\n  ll extgcd(ll a,ll b,ll& x,ll& y){\n    ll d = a ;\n    if ( b != 0 ) {\n      d = extgcd( b , a%b , y , x ) ;\n      y -= ( a / b ) * x ;\n    }else{\n      x = 1 ; y = 0 ;\n    }\n    return d;\n  }\n  ll mod_inverse(ll a){\n    ll x , y ;\n    extgcd( a , m , x , y ) ;\n    return ( m + x % m ) % m ;\n  }\n  ll mod_inverse_M(ll a,ll m){\n    ll x , y ;\n    extgcd( a , m , x , y ) ;\n    return ( m + x % m ) % m ;\n  }\n\n  pair<ll,ll> linear_congruence(const vector<ll> &A,const vector<ll> &B,const vector<ll> &M){\n  \tll x=0,m=1;\n  \tfor(int i=0;i<A.size();i++){\n  \t\tll a=A[i]*m;\n  \t\tll b=B[i]-A[i]*x;\n  \t\tll d=__gcd(M[i],a);\n  \t\tif(b%d!=0)return make_pair(0,-1);\n  \t\tll t=b/d*mod_inverse_M(a/d,M[i]/d)%(M[i]/d);\n  \t\tx=x+m*t;\n  \t\tm*=M[i]/d;\n  \t}\n  \treturn make_pair(x%m,m);\n  }\n\n  // オイラー関数√N\n  ll euler_mhi(ll n){\n    ll res = n;\n    for(ll i=2; i*i <= n ; i++){\n      if( n%i == 0 ){\n        res = res/i*(i-1);\n        for(;n%i==0;n/=i);\n      }\n    }\n    if(n!=1)res=res/n*(n-1);\n    return res;\n  }\n\n  void make_euler_table(int n){\n    euler.resize(n+1);\n    for(int i=0;i<n;i++) euler[i]=i;\n    for(int i=2;i<n;i++){\n      if(euler[i]==i){\n        for(int j=i;j<n;j+=i){\n          euler[j]=euler[j]/i*(i-1);\n        }\n      }\n    }\n  }\n\n  // n! と nCr \n  // mはmod\n  ll mod_fact(ll n,ll& e){\n    e=0;\n    if(n==0)return 1;\n\n    int res = mod_fact(n/m,e);\n    e+=n/m;\n\n    if(n/m%2 != 0)return res*(m-fact[n%m])%m;\n    return res*fact[n%m]%m;\n  }\n\n  ll combination(ll n,ll k){\n    if(n==k||k==0)return 1;\n    if(n<0 || k<0 || n<k)return 0;\n    ll e1,e2,e3;\n    ll a1 = mod_fact(n,e1);\n    ll a2 = mod_fact(k,e2);\n    ll a3 = mod_fact(n-k,e3);\n    return a1*mod_inverse(a2*a3%m)%m;\n  }\n\n  ll mod_mult(ll a, ll b,ll m) {\n    ll res = 0;\n    ll exm = a % m;\n    while (b) {\n      if (b & 1) {\n        res += exm;\n        if (res > m) res -= m;\n      }\n      exm <<= 1;\n      if (exm > m) exm -= m;\n      b >>= 1;\n    }\n    return res;\n  }\n\n  ll mod_exm(ll a, ll b,ll m) {\n    ll res = 1;\n    ll exm = a % m;\n    while (b) {\n      if (b & 1) res = mod_mult(res, exm,m);\n      exm = mod_mult(exm, exm,m);\n      b >>= 1;\n    }\n    return res;\n  }\n\n  // 確率的高速素数判定　\n  bool miller_rabin(ll n, ll times=10) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (!(n & 1)) return false;\n    ll q = n-1;\n    int k = 0;\n    while (q % 2 == 0) {\n      k++;\n      q >>= 1;\n    }\n    for (int i = 0; i < times; i++) {\n      ll a = rand() % (n-1) + 1;\n      ll x = mod_exm(a, q, n);\n      if (x == 1) continue;\n      bool found = false;\n      for (int j = 0; j < k; j++) {\n        if (x == n-1) {\n          found = true;\n          break;\n        }\n        x = mod_mult(x, x, n);\n      }\n      if (found) continue;\n      return false;\n    }\n    return true;\n  }\n\n  ll pollard_rho(ll n, int c) {\n    ll x = 2;\n    ll y = 2;\n    ll d = 1;\n    while (d == 1) {\n      x = mod_mult(x, x, n) + c;\n      y = mod_mult(y, y, n) + c;\n      y = mod_mult(y, y, n) + c;\n      d = __gcd((x-y >= 0 ? x-y : y-x), n);\n    }\n    if (d == n) return pollard_rho(n, c+1);\n    return d;\n  }\n};\n\nint n,m[11],d,M;\nsigned main(){\n\tNT N(1e9+7);\n\tcin>>n>>M>>d;\n\tr(i,M)cin>>m[i];\n\tr(i,d){\n\t\tvector<int>A,B,C;\n\t\tr(j,M){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tif(x!=-1){\n\t\t\t\tA.push_back(1);\n\t\t\t\tB.push_back(x);\n\t\t\t\tC.push_back(m[j]);\n\t\t\t}\n\t\t}\n\t\tpair<int,int> p=N.linear_congruence(A,B,C);\n\t\tif(p.second<0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint x=p.first;\n\t\t/*int l=0,r=1e9;\n\n\t\twhile(l<r){\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(x+mid*p.second>=n)r=mid;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tif(x+(l+2)*p.second<=n)n=x+(l+2)*p.second;\n\t\telse if(x+(l+1)*p.second<=n)n=x+(l+1)*p.second;\n\t\telse if(x+(l)*p.second<=n)n=x+(l)*p.second;\n\t\telse if(x+(l-1)*p.second<=n&&x+(l-1)*p.second>=0)n=x+(l-1)*p.second;\n\t\telse n=x+(l-2)*p.second;*/\n\t\tn=(n-x)/p.second+x;\n\t}\n\tcout<<n<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint extgcd(int a, int b, int& x, int& y){\n    int d=a;\n    if(b!=0){\n        d = extgcd(b,a%b,y,x);\n        y-=(a/b)*x;\n    }else{\n        x=1;y=0;\n    }\n    return d;\n}\n\nint mod_inverse(int a, int m){\n    int x, y;\n    extgcd(a,m,x,y);\n    return (m+x%m)%m;\n}\n\npair<int, int> linear_consequense(const vector<int>& a, const vector<int>& b, const vector<int>& m){\n   int x=0,M=1;\n\n   for(int i=0;i<a.size();++i){\n       if(b[i]==-1) continue;\n       int B=b[i]-a[i]*x, d=__gcd(m[i],1);\n       if(B%d!=0) return make_pair(0,-1);\n       int t = B / d * mod_inverse(1/d, m[i]/d) % (m[i]/d);\n       x = x + M * t;\n       M *= m[i] / d;\n   }\n   return make_pair(x%M,M);\n}\n\nint main() {\n\n    for(int n,m,d;cin>>n>>m>>d;){\n        vector<int> a(m);\n        for(int i=0;i<m;++i){\n            cin>>a[i];\n        }\n        vector<int> r(m);\n        vector<int> aa(m,1);\n        pair<int,int> aaa;\n        for(int i=0;i<d;++i){\n            for(int j=0;j<m;++j){\n                cin >> r[j];\n            }\n            aaa = linear_consequense(aa, r, a);\n            int p=n/aaa.second;\n            int q=n%aaa.second;\n            int k=(q-aaa.first+aaa.second) % aaa.second;\n            n=p*aaa.second-q-k;\n            if(n<0){\n                n=-1;\n                break;\n            }\n        }\n        cout << n << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass range {\nprivate:\n  struct Iterator {\n    int val;\n    int operator*() {return val;}\n    bool operator!=(Iterator &itr) {return val < itr.val;}\n    void operator++() {++val;}\n  };\n  Iterator i, n;\npublic:\n  range(int n) : i({0}), n({n}) {}\n  range(int i, int n) : i({i}), n({n}) {}\n  Iterator &begin() {return i;}\n  Iterator &end() {return n;}\n};\n\ntemplate<class T> T at(vector<T> v, int i) {return v[(i % (int)v.size() + v.size()) % v.size()];}\n\nlong long mod_inverse(long long a, long long mod) {\n  long long b = mod, x = 1, y = 0;\n  while (b) {\n    long long t = a / b;\n    swap(a -= t * b, b);\n    swap(x -= t * y, y);\n  }\n  return (mod + x % mod) % mod;\n}\n\npair<long long, long long> linear_congruence(const vector<long long>& A, const vector<long long>& B, const vector<long long>& M) {\n  long long x = 0, m = 1;\n  for (int i : range(A.size())) {\n    long long a = A[i] * m;\n    long long b = B[i] - A[i] * x;\n    long long d = __gcd(M[i], a);\n    if (b % d != 0) return make_pair(0, -1);\n    int t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nconst long long INF = 1e9;\n\nint main() {\n  int n, m, d;\n  cin >> n >> m >> d;\n  long long a[m];\n  for (int i : range(m)) cin >> a[i];\n  long long r[d][m];\n  for (int i : range(d)) for (int j : range(m)) cin >> r[i][j];\n  vector<long long> A, B, M;\n  for (int i : range(d)) {\n    A.clear(); B.clear(); M.clear();\n    for (int j : range(m)) if (r[i][j] != -1) {\n      A.emplace_back(1);\n      B.emplace_back(r[i][j]);\n      M.emplace_back(a[j]);\n    }\n    if (A.empty()) continue;\n    auto x = linear_congruence(A, B, M);\n    if (x.second == -1) {\n      cout << -1 << endl;\n      return 0;\n    }\n    while (x.first + x.second <= n) x.first += x.second;\n    if (x.first > n) {\n      cout << -1 << endl;\n      return 0;\n    }\n    n = x.first;\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n \nll imod(ll x, ll y) {\n  return (x % y) < 0 ? (x % y) + (y < 0 ? -y : y) : x % y;\n}\n\nll gcd(ll a, ll b){\n  return b?gcd(b,imod(a,b)):a;\n}\n \nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,imod(a,b),y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n \nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return imod((m+imod(x,m)),m);\n}\n \npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(imod(b,d) != 0)return make_pair(0,-1);\n    ll hoge = M[i]/d;\n    ll t = imod((imod(b/d * mod_inverse(a/d, M[i]/d), hoge) + hoge),hoge);\n    assert(t>=0);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair( imod((imod(x,m) + m), m) , m);\n}\n \nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n \n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      long long  tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n     \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod==-1){\n      cout << -1 << endl;\n      return 0;\n    }\n \n    //cerr << b << \" \" << mod << endl;\n    if(n<mod)n = b;\n    else{\n      long long tmp = (n/mod+1) * mod + b;\n      while(tmp<(long long)n)tmp += (long long)mod;\n      while((long long)n<tmp)tmp -= (long long)mod;\n      if(tmp<0){\n    cout << -1 << endl;\n    return 0;\n      }\n      n = tmp;\n    }\n \n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lli;\n\n//#################################################################\n//ユークリッドの互除法 O(log max(a, b))\n\nnamespace gcd{\n\nlli gcd(lli a, lli b){\n\tif(b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nlli extgcd(lli a, lli b, lli &x, lli &y){\n\tlli d = a;\n\tif(b != 0){\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t}else{\n\t\tx = 1;\n\t\ty = 0;\n\t}\n\treturn d;\n}\n\n}\n\nlli mod_inverse(lli a, lli m){\n\tlli x, y;\n\tgcd::extgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\n\n//a_i * x = b_i (mod m_i) (1 <= i <= n)を解く\npair<lli, lli> linear_congruence(const vector<lli> &A, const vector<lli> &B, const vector<lli> &M){\n\tlli x = 0, m = 1;\n\tfor(lli i=0;i<A.size();i++){\n\t\tlli a = A[i] * m, b = B[i] - A[i] * x, d = gcd::gcd(M[i], a);\n\t\tif(b % d != 0) return make_pair(0, -1); //解がない\n\t\tlli t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n\t\tx = x + m * t;\n\t\tm *= M[i] / d;\n\t}\n\treturn make_pair(x % m, m);\n}\n\nint main() {\n  lli N, M, D;\n  cin >> N >> M >> D;\n  vector<lli> A(M);\n  for(lli j = 0; j < M; ++j) {\n    cin >> A[j];\n  }\n  bool flag = false;\n  for(lli i = 0; i < D; ++i) {\n    vector<lli> R(M);\n    vector<lli> b, m;\n    for(lli j = 0; j < M; ++j) {\n      cin >> R[j];\n      if(R[j] != -1) {\n\tb.push_back(R[j]);\n\tm.push_back(A[j]);\n      }\n    }\n    if(flag) continue;\n    pair<lli,lli> p = linear_congruence(vector<lli>(b.size(), 1), b, m);\n    if(p.second == -1) {\n      flag = true;\n      continue;\n    }\n    lli k = (N - p.first) / p.second;\n    while(p.first + p.second * k <= N) ++k;\n    --k;\n    N = p.first + p.second * k;\n  }\n  if(flag) N = -1;\n  cout << N << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nll lcm(ll x, ll y){\n    return x/__gcd(x,y)*y;\n}\n\nint main(){\n    int n,m,d;\n    cin >>n >>m >>d;\n\n    vector<int> a(m);\n    rep(i,m) cin >>a[i];\n\n    vector<vector<int>> r(d, vector<int>(m));\n    rep(i,d)rep(j,m) cin >>r[i][j];\n\n    ll now = n;\n    rep(i,d){\n        ll nx = now;\n        ll L = 1;\n        rep(j,m){\n            if(r[i][j] == -1) continue;\n\n            vector<bool> vis(a[j]);\n            while(nx>=0 && !vis[nx%a[j]] && nx%a[j]!=r[i][j]){\n                vis[nx%a[j]] = true;\n                nx -= L;\n            }\n\n            if(nx<0 || nx%a[j]!=r[i][j]){\n                cout << -1 << endl;\n                return 0;\n            }\n\n            L = lcm(L, a[j]);\n        }\n        now = nx;\n    }\n    cout << now << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef long long ll;\nstruct NT{\n  ll m;  // mod\n  vector<bool>ismrime;\n  vector<ll> euler;\n  vector<ll> fact;\n\n  NT(ll MOD){\n    m=MOD;\n    fact.resize(500005);\n    fact[0]=1;\n    for(ll i=1;i<500005;i++){\n      fact[i]=(fact[i-1]*i)%MOD;\n    }\n  }\n\n  void eratos(int n){\n    ismrime.resize(n+1);\n    for(int i=0;i<=n;i++) ismrime[i]=true;\n    ismrime[0]=0;\n    ismrime[1]=0;\n    for(int i=2;i<=n;i++){\n      if(ismrime[i]){\n        for(int j=i+i;j<=n;j+=i) ismrime[j]=false;\n      }\n    }\n  }\n\n  // 因数分解 √N\n  vector<int> mrime_decommosition(ll x){\n    vector<int>res;\n    for(int i=2;i*i<=x;i++){\n      while(x%i==0){\n        x/=i;\n        res.push_back(i);\n      }\n    }\n    if(x!=1) res.push_back(x);\n    return res;\n  }\n\n  // 約数列挙 √N\n  vector<ll> divisor(ll x){\n    vector<ll> res;\n    for(ll i=1; i*i<=x ;i++)\n      if(x%i==0){\n        res.push_back(i);\n        if(i*i!=x) res.push_back(x/i);\n      }\n    sort(res.begin(), res.end());\n    return res;\n  }\n\n  // a*b>LONG_MAX ? \n  bool overflow(ll a,ll b,ll LONGMAX){return a > LONGMAX/b;}\n\n  ll extgcd(ll a,ll b,ll& x,ll& y){\n    ll d = a ;\n    if ( b != 0 ) {\n      d = extgcd( b , a%b , y , x ) ;\n      y -= ( a / b ) * x ;\n    }else{\n      x = 1 ; y = 0 ;\n    }\n    return d;\n  }\n  ll mod_inverse(ll a){\n    ll x , y ;\n    extgcd( a , m , x , y ) ;\n    return ( m + x % m ) % m ;\n  }\n  ll mod_inverse_M(ll a,ll m){\n    ll x , y ;\n    extgcd( a , m , x , y ) ;\n    return ( m + x % m ) % m ;\n  }\n\n  pair<ll,ll> linear_congruence(const vector<ll> &A,const vector<ll> &B,const vector<ll> &M){\n  \tll x=0,m=1;\n  \tfor(int i=0;i<A.size();i++){\n  \t\tll a=A[i]*m;\n  \t\tll b=B[i]-A[i]*x;\n  \t\tll d=__gcd(M[i],a);\n  \t\tif(b%d!=0)return make_pair(0,-1);\n  \t\tll t=b/d*mod_inverse_M(a/d,M[i]/d)%(M[i]/d);\n  \t\tx=x+m*t;\n  \t\tm*=M[i]/d;\n  \t}\n  \treturn make_pair(x%m,m);\n  }\n\n  // オイラー関数√N\n  ll euler_mhi(ll n){\n    ll res = n;\n    for(ll i=2; i*i <= n ; i++){\n      if( n%i == 0 ){\n        res = res/i*(i-1);\n        for(;n%i==0;n/=i);\n      }\n    }\n    if(n!=1)res=res/n*(n-1);\n    return res;\n  }\n\n  void make_euler_table(int n){\n    euler.resize(n+1);\n    for(int i=0;i<n;i++) euler[i]=i;\n    for(int i=2;i<n;i++){\n      if(euler[i]==i){\n        for(int j=i;j<n;j+=i){\n          euler[j]=euler[j]/i*(i-1);\n        }\n      }\n    }\n  }\n\n  // n! と nCr \n  // mはmod\n  ll mod_fact(ll n,ll& e){\n    e=0;\n    if(n==0)return 1;\n\n    int res = mod_fact(n/m,e);\n    e+=n/m;\n\n    if(n/m%2 != 0)return res*(m-fact[n%m])%m;\n    return res*fact[n%m]%m;\n  }\n\n  ll combination(ll n,ll k){\n    if(n==k||k==0)return 1;\n    if(n<0 || k<0 || n<k)return 0;\n    ll e1,e2,e3;\n    ll a1 = mod_fact(n,e1);\n    ll a2 = mod_fact(k,e2);\n    ll a3 = mod_fact(n-k,e3);\n    return a1*mod_inverse(a2*a3%m)%m;\n  }\n\n  ll mod_mult(ll a, ll b,ll m) {\n    ll res = 0;\n    ll exm = a % m;\n    while (b) {\n      if (b & 1) {\n        res += exm;\n        if (res > m) res -= m;\n      }\n      exm <<= 1;\n      if (exm > m) exm -= m;\n      b >>= 1;\n    }\n    return res;\n  }\n\n  ll mod_exm(ll a, ll b,ll m) {\n    ll res = 1;\n    ll exm = a % m;\n    while (b) {\n      if (b & 1) res = mod_mult(res, exm,m);\n      exm = mod_mult(exm, exm,m);\n      b >>= 1;\n    }\n    return res;\n  }\n};\n\nint n,m[11],d,M;\nsigned main(){\n\tNT N(1e9+7);\n\tcin>>n>>M>>d;\n\tr(i,M)cin>>m[i];\n\tr(i,d){\n\t\tvector<int>A,B,C;\n\t\tr(j,M){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tif(x!=-1){\n\t\t\t\tA.push_back(1);\n\t\t\t\tB.push_back(x);\n\t\t\t\tC.push_back(m[j]);\n\t\t\t}\n\t\t}\n\t\tpair<int,int> p=N.linear_congruence(A,B,C);\n\t\tif(p.second<0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint x=p.first;\n\t\t/*int l=0,r=1e9;\n\n\t\twhile(l<r){\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(x+mid*p.second>=n)r=mid;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tif(x+(l+2)*p.second<=n)n=x+(l+2)*p.second;\n\t\telse if(x+(l+1)*p.second<=n)n=x+(l+1)*p.second;\n\t\telse if(x+(l)*p.second<=n)n=x+(l)*p.second;\n\t\telse if(x+(l-1)*p.second<=n&&x+(l-1)*p.second>=0)n=x+(l-1)*p.second;\n\t\telse n=x+(l-2)*p.second;*/\n\t\tn=(n-x)/p.second;\n\t\tn*=p.second;\n\t\tn+=x;\n\t}\n\tcout<<n<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll Int;\nll INF=1ll<<45;\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nint main(){\n  int i,j,k;\n  ll n,m,d;\n  cin>>n>>m>>d;\n  vector<ll> a(m),r(m),lcma(m+1);\n  vector<vector<ll > > subs(m);\n  rep(i,m)\n    cin>>a[i];\n  lcma[0]=1;\n  rep(i,m)\n    lcma[i+1]=lcma[i]*a[i]/__gcd(lcma[i],a[i]);\n//  rep(i,m)\n//    gcda[i]=__gcd(lcma[i],a[i]);\n  rep(i,m){\n    subs[i].resize(a[i],INF);\n    rep(j,a[i]){\n      ll &tmp=subs[i][j*lcma[i]%a[i]];\n      tmp=min(tmp,j*lcma[i]);\n    }\n//rep(j,a[i])cout<<subs[i][j]<<\",\";cout<<endl;\n  }\n  ll dd;\n  rep(i,d){\n    ll nnn=n;\n    rep(j,m)\n      cin>>r[j];\n    rep(j,m){\n      if(r[j]<0)continue;\n      ll nn=(n+a[j]-r[j])%a[j];\n      if(subs[j].at(nn)==INF){\n        cout<<-1<<endl;\n        return 0;\n      }\n      n-=subs[j].at(nn);\n      n+=(nnn-n)/lcma[j+1]*lcma[j+1];\n      if(n<0){\n        cout<<-1<<endl;\n        return 0;\n      }\n //     cout<<\"->\"<<n<<\":\"<<r[j]<<\"mod\"<<a[j]<<endl;\n    }\n  }\n  cout<<n<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\nlong long gcd(long long x, long long y) {\n\tif (y == 0) return x;\n\treturn gcd(y, x % y);\n}\nint N, M, D, a[15], r[109][15];\nint main() {\n\tcin >> N >> M >> D;\n\tfor (int i = 0; i < M; i++) cin >> a[i];\n\tfor (int i = 0; i < D; i++) {\n\t\tfor (int j = 0; j < M; j++) cin >> r[i][j];\n\t}\n\tfor (int i = 0; i < D; i++) {\n\t\tlong long p = 0, q = 1;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (r[i][j] == -1) continue;\n\t\t\tint lim = 1000;\n\t\t\tfor (long long k = p; lim >= 0; k += q) {\n\t\t\t\tif (k % a[j] == r[i][j]) {\n\t\t\t\t\tp = k; q = q / gcd(q, a[j]) * a[j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlim--;\n\t\t\t}\n\t\t\tif (lim < 0) N = -1;\n\t\t}\n\t\tif (N < p) {\n\t\t\tN = -1; break;\n\t\t}\n\t\tN = (N - p) / q * q + p;\n\t}\n\tcout << N << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pr;\ntypedef vector<pr > vpr;\nconst int INF=1<<30;\nll lcm(int a,int b){\n\tif(a%b==0)\n\treturn b;\n\telse\n\treturn lcm(b,a%b);\n}\nll GCD(int a,int b){\n\treturn (a*b)/lcm(a,b);\n}\nint main() {\n\tll N,M,D;\n\tll divi[10];\n\tll dived[100][10],gcd[10]={};\n\tcin >> N >> M >> D;\n\tREP(i,M){\n\tcin >> divi[i];\n\t}\n\tREP(i,D)\n\t\tREP(j,M)\n\t\t\tcin >> dived[i][j];\n\tll now=N;\n\tREP(i,D){\n\t\tll mn=0,ngcd=1;\n\t\tbool ans=false;\n\t\tREP(j,M){\n\t\t\tif(dived[i][j]==-1)\t\n\t\t\t\tcontinue;\n\t\t\tans=true;\n\t\t\tif(mn==0)\n\t\t\t\tmn=dived[i][j];\n\t\t\twhile(mn%divi[j]!=dived[i][j] && now>=mn) mn+=ngcd;\n\t\t\tngcd=GCD(ngcd,divi[j]);\n\t\t}\n\t\tif(now<mn){\n\t\t\tnow=-1;\n\t\t\tbreak;\n\t\t}\n\t\tif(ans){\n\t\t\tint alpha=(now-mn)/ngcd;\n\t\t\tnow=mn+alpha*ngcd;\n\t\t}\n\t}\n\tcout << now << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N, M, D;\n    vector<ll> A;\n    vector< vector<ll> > R;\n    void input() {\n        cin >> N >> M >> D;\n        A.resize(M); cin >> A;\n        R.resize(D);\n        for (int i = 0; i < D; i++) {\n            R[i].resize(M); cin >> R[i];\n        }\n    }\n\n    ll lcm(ll a, ll b) {\n        return a / __gcd(a, b) * b;\n    }\n\n    bool check(ll n, int d) {\n        for (int i = 0; i < M; i++) {\n            if (R[d][i] < 0) continue;\n            if (n % A[i] != R[d][i]) return false;\n        }\n        return true;\n    }\n\n    void solve() {\n        ll L = 1;\n        for (int i = 0; i < M; i++) L = lcm(L, A[i]);\n\n        ll x = N;\n        for (int d = 0; d < D; d++) {\n            int a = 0;\n            int m = -1;\n            for (int i = 0; i < M; i++) {\n                if (R[d][i] < 0) continue;\n                if (a < A[i]) {\n                    a = A[i];\n                    m = i;\n                }\n            }\n            if (m < 0) continue;\n            ll n = R[d][m];\n            for (; ; n += A[m]) {\n                if (n > x) {\n                    cout << -1 << endl;\n                    return;\n                }\n                if (check(n, d)) {\n                    break;\n                }\n            }\n            x = (x - n) / L * L + n;\n        }\n        cout << x << endl;\n\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint cal(int n,P p){\n  while(n%p.first!=p.second&&n>=0)n--;\n  return n;\n}\n\nint main(){\n  int n,m,d,a[10];\n  cin>>n>>m>>d;\n  for(int i=0;i<m;i++){\n    cin>>a[i];\n  }\n  P r[100][10];\n  for(int i=0;i<d;i++){\n    for(int j=0;j<m;j++){\n      cin>>r[i][j].second;\n      r[i][j].first=a[j];\n    }\n    sort(r[i],r[i]+m);\n    reverse(r[i],r[i]+m);\n    vector<int> v;\n    for(int j=0;j<m;j++){\n      if(r[i][j].second==-1)continue;\n      if(j){\n\tvector<int> nv;\n\tfor(int k=0;k<(int)v.size();k++){\n\t  if(v[k]%r[i][j].first==r[i][j].second)nv.push_back(v[k]);\n\t}\n\tv=nv;\n      }\n      else {\n\tint u=1e7;\n\tint p=cal(n,r[i][j]);\n\twhile((int)v.size()<u&&p>=0){\n\t  v.push_back(p);\n\t  p-=r[i][j].first;\n\t}\n      }\n    }\n    if(v.size())n=v[0];\n    else if(r[i][0].second!=-1)n=-1;\n  }\n  cout<<n<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\nconst ll INF = 1000000009LL;\n\nvector<ll> comb;\nvector<ll> A;\nll N;\nll M, D;\n\nll gcd(ll x,ll y){\n    if(y == 0)return x;\n    else return gcd(y, x % y);\n}\nll lcm(ll x,ll y){\n    return x*y / gcd(x,y);\n}\n\n\nvoid makeComb(){\n    for(ll i = 0; i <= (1<<M); i++){\n        comb[i] = 1LL;\n        for(ll j = 0; j < M; j++){\n            if(comb[i] >= INF) break;\n            if((i >> j) & 1) comb[i] = lcm(comb[i], A[j]);\n        }     \n    }\n    return;\n}\n\nint main () {\n    cin >> N >> M >> D;\n    comb = vector<ll>((1<<M)+1, 0);\n    A = vector<ll>(M);\n    for(ll i = 0; i < M; i++) cin >> A[i];\n    makeComb();\n    ll pre = N;\n    \n    for(ll i = 0; i < D; i++){\n        ll ret = 0LL;\n        vector<ll> R(M);\n        ll exist = 0;\n        for(ll j = 0; j < M; j++){\n            cin >> R[j];\n            if(R[j] != -1) exist |= 1<<j;\n        }\n        bool update = false;\n        for(ll j = 10000LL; j >= 0LL; j--){\n            ll f = 0;\n            for(ll k = 0; k < M; k++){\n                if(R[k] != -1 && (j % A[k]) != R[k]) f = 1;\n            }\n            if(f) continue;\n            if(pre < j) continue;\n            update = true; \n            ret = max(ret, ((pre - j) / comb[exist]) * comb[exist] + j);\n        }\n        if(!update){\n            cout << -1 << endl;\n            return 0;\n        }\n        pre = ret;\n    }\n    cout << pre << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\nconst ll INF = 1000000009LL;\n\nvector<ll> comb;\nvector<ll> A;\nll N;\nll M, D;\n\nll gcd(ll x,ll y){\n    if(y == 0)return x;\n    else return gcd(y, x % y);\n}\nll lcm(ll x,ll y){\n    return x*y / gcd(x,y);\n}\n\n\nvoid makeComb(){\n    for(ll i = 0; i <= (1<<M); i++){\n        comb[i] = 1LL;\n        for(ll j = 0; j < M; j++){\n            if((i >> j) & 1) comb[i] = min(lcm(comb[i], A[j]), INF);\n        }     \n    }\n    return;\n}\n\nint main () {\n    cin >> N >> M >> D;\n    comb = vector<ll>((1<<M)+1, 0);\n    A = vector<ll>(M);\n    for(ll i = 0; i < M; i++) cin >> A[i];\n    makeComb();\n    ll pre = N;\n    \n    for(ll i = 0; i < D; i++){\n        ll ret = 0LL;\n        vector<ll> R(M);\n        ll exist = 0;\n        for(ll j = 0; j < M; j++){\n            cin >> R[j];\n            if(R[j] != -1) exist |= 1<<j;\n        }\n        bool update = false;\n        for(ll j = 100LL; j >= 0LL; j--){\n            ll f = 0;\n            for(ll k = 0; k < M; k++){\n                if(R[k] != -1 && (j % A[k]) != R[k]) f = 1;\n            }\n            if(f) continue;\n            if(pre < j) continue;\n            update = true; \n            ret = max(ret, ((pre - j) / comb[exist]) * comb[exist] + j);\n        }\n        if(!update){\n            cout << -1 << endl;\n            return 0;\n        }\n        pre = ret;\n    }\n    cout << pre << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll Int;\nll INF=1ll<<45;\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nint main(){\n  int i,j,k;\n  ll n,m,d;\n  cin>>n>>m>>d;\n  vector<ll> a(m),r(m),aa(m),gcda(m);\n  vector<vector<ll > > subs(m);\n  rep(i,m)\n    cin>>a[i];\n  aa[0]=1;\n  rep(i,m-1)\n    aa[i+1]=aa[i]*a[i]/__gcd(aa[i],a[i]);\n  rep(i,m)\n    gcda[i]=__gcd(aa[i],a[i]);\n  rep(i,m){\n    subs[i].resize(a[i],INF);\n    rep(j,aa[i]+1){\n      ll &tmp=subs[i][j*aa[i]%a[i]];\n      tmp=min(tmp,j*aa[i]);\n    }\n//rep(j,a[i])cout<<subs[i][j]<<\",\";cout<<endl;\n  }\n  ll dd;\n  rep(i,d){\n    rep(j,m)\n      cin>>r[j];\n    rep(j,m){\n      if(r[j]<0)continue;\n      if((n+a[j]-r[j])%a[j]){\n        ll nn=(n+a[j]-r[j])%a[j];\n        if(nn%gcda[j] || subs[j][nn]==INF){\n          cout<<-1<<endl;\n          return 0;\n        }\n        n-=subs[j][nn];\n        if(n<0){\n          cout<<-1<<endl;\n          return 0;\n        }\n      }\n //     cout<<\"->\"<<n<<\":\"<<r[j]<<\"mod\"<<a[j]<<endl;\n    }\n  }\n  cout<<n<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % (M[i]/d);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair( (x%m + m) % m , m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      ll  tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    assert(r.size()==m || r.size()==0);\n    if(r.size()==0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod<0){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    ll tmp = (n/mod+100) * mod + b;\n    while(tmp<n)tmp += mod;\n    while(n<tmp)tmp -= mod;\n    if(tmp<0){\n      cout << -1 << endl;\n      return 0;\n    }\n    n = tmp;\n\n  }\n\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n \nll imod(ll x, ll y) {\n  return (x % y) < 0 ? (x % y) + (y < 0 ? -y : y) : x % y;\n}\n\nll gcd(ll a, ll b){\n  return b?gcd(b,imod(a,b)):a;\n}\n \nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,imod(a,b),y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n \nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return imod((m+imod(x,m)),m);\n}\n \npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(imod(b,d) != 0)return make_pair(0,-1);\n    ll hoge = M[i]/d;\n    ll t = imod((imod(b/d * mod_inverse(a/d, M[i]/d), hoge) + hoge),hoge);\n    assert(t>=0);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair( imod((imod(x,m) + m), m) , m);\n}\n \nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n \n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      long long  tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n     \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod==-1){\n      cout << -1 << endl;\n      return 0;\n    }\n \n    //cerr << b << \" \" << mod << endl;\n    if(n<mod)n = b;\n    else{\n      long long tmp = (n/mod+1) * mod + b;\n      while(tmp<(long long)n)tmp += (long long)mod;\n      while((long long)n<tmp)tmp -= (long long)mod;\n      if(tmp<0){\n    cout << -1 << endl;\n    return 0;\n      }\n      n = tmp;\n    }\n \n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\n\nint a[11];\nint r[11];\n\nll gcd(ll m, ll n){\n\treturn n ? gcd(n, m%n) : m;\n}\nll lcm(ll m, ll n){\n\treturn m / gcd(m, n) * n;\n}\n\nint n, m, d;\nint calc_max(int rem){\n\tif (rem < 0) return -1;\n\n\tll x = 1;\n\tll val = 0;\n\trep(i, m){\n\t\tif (r[i] < 0) continue;\n\t\trep(j, 100) {\n\t\t\tif (val%a[i] == r[i]) break;\n\t\t\tval += x;\n\t\t}\n\t\tif (val > rem) return -1;\n\t\tif (val%a[i] != r[i]) return -1;\n\t\tx = lcm(x, a[i]);\n\t}\n\n\treturn (rem - val) / x*x + val;\n}\n\nint main(){\n\tcin >> n >> m >> d;\n\trep(i, m) cin >> a[i];\n\n\twhile (d--){\n\t\trep(i, m) cin >> r[i];\n\t\tn = calc_max(n);\n\t}\n\tcout << n << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\nusing namespace std;\ntypedef pair<int,int> pr;\ntypedef vector<pr > vpr;\nconst int INF=1<<30;\nint lcm(int a,int b){\n\tif(a%b==0)\n\treturn b;\n\telse\n\treturn lcm(b,a%b);\n}\nint GCD(int a,int b){\n\treturn (a*b)/lcm(a,b);\n}\nint main() {\n\tint N,M,D;\n\tint divi[10];\n\tint dived[100][10],gcd[10]={};\n\tcin >> N >> M >> D;\n\tREP(i,M){\n\tcin >> divi[i];\n\tif(i)\n\tgcd[i]=GCD(gcd[i-1],divi[i]);\n\telse\n\tgcd[i]=divi[i];\n\t}\n\tREP(i,D)\n\t\tREP(j,M)\n\t\t\tcin >> dived[i][j];\n\tint now=N;\n\tREP(i,D){\n\t\tint mn=0;\n\t\tbool ans=false;\n\t\tREP(j,M){\n\t\tif(dived[i][j]==-1)\t\n\t\tcontinue;\n\t\tans=true;\n\t\tif(mn==0)\n\t\t\tmn=dived[i][j];\n\t\twhile(mn%divi[j]!=dived[i][j]) mn+=gcd[i];\n\t\t}\n\t\tif(now<mn){\n\t\t\tnow=-1;\n\t\t\tbreak;\n\t\t}\n\t\tif(ans){\n\t\tint alpha=(now-mn)/gcd[M-1];\n\t\tnow=mn+alpha*gcd[M-1];\n\t\t}\n\t}\n\tcout << now << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N, M, D;\n    vector<int> A;\n    vector< vector<int> > R;\n    void input() {\n        cin >> N >> M >> D;\n        A.resize(M); cin >> A;\n        R.resize(D);\n        for (int i = 0; i < D; i++) {\n            R[i].resize(M); cin >> R[i];\n        }\n    }\n\n    ll lcm(ll a, ll b) {\n        return a / __gcd(a, b) * b;\n    }\n\n    bool check(int n, int d) {\n        for (int i = 0; i < M; i++) {\n            if (R[d][i] < 0) continue;\n            if (n % A[i] != R[d][i]) return false;\n        }\n        return true;\n    }\n\n    void solve() {\n        ll L = 1;\n        for (int i = 0; i < M; i++) L = lcm(L, A[i]);\n\n        ll x = N;\n        for (int d = 0; d < D; d++) {\n            int a = 0;\n            int m = -1;\n            for (int i = 0; i < M; i++) {\n                if (R[d][i] < 0) continue;\n                if (a < A[i]) {\n                    a = A[i];\n                    m = i;\n                }\n            }\n            if (m < 0) continue;\n            int n = R[d][m];\n            for (; ; n += A[m]) {\n                if (n > x) {\n                    cout << -1 << endl;\n                    return;\n                }\n                if (check(n, d)) {\n                    break;\n                }\n            }\n            x = (x - n) / L * L + n;\n        }\n        cout << x << endl;\n\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N, M, D;\n    vector<int> A;\n    vector< vector<int> > R;\n    void input() {\n        cin >> N >> M >> D;\n        A.resize(M); cin >> A;\n        R.resize(D);\n        for (int i = 0; i < D; i++) {\n            R[i].resize(M); cin >> R[i];\n        }\n    }\n\n    int lcm(int a, int b) {\n        return a / __gcd(a, b) * b;\n    }\n\n    bool check(int n, int d) {\n        for (int i = 0; i < M; i++) {\n            if (n % A[i] != R[d][i]) return false;\n        }\n        return true;\n    }\n\n    void solve() {\n        int L = 1;\n        for (int i = 0; i < M; i++) L = lcm(L, A[i]);\n\n        int m = 0;\n        for (int i = 0; i < M; i++) {\n            if (A[m] < A[i]) {\n                m = i;\n            }\n        }\n\n        int x = N;\n        for (int d = 0; d < D; d++) {\n            int n = R[d][m];\n            if (n < 0) continue;\n            for (; ; n += A[m]) {\n                if (n > x) {\n                    cout << -1 << endl;\n                    return;\n                }\n                if (check(n, d)) {\n                    break;\n                }\n            }\n            x = (x - n) / L * L + n;\n        }\n        cout << x << endl;\n\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll Int;\nll INF=1ll<<45;\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nint main(){\n  int i,j,k;\n  ll n,m,d;\n  cin>>n>>m>>d;\n  vector<ll> a(m),r(m),lcma(m+1);\n  vector<vector<ll > > subs(m);\n  rep(i,m)\n    cin>>a[i];\n  lcma[0]=1;\n  rep(i,m)\n    lcma[i+1]=lcma[i]*a[i]/__gcd(lcma[i],a[i]);\n//  rep(i,m)\n//    gcda[i]=__gcd(lcma[i],a[i]);\n  rep(i,m){\n    subs[i].resize(a[i],INF);\n    rep(j,a[i]){\n      ll &tmp=subs[i][j*lcma[i]%a[i]];\n      tmp=min(tmp,j*lcma[i]);\n    }\n//rep(j,a[i])cout<<subs[i][j]<<\",\";cout<<endl;\n  }\n  ll dd;\n  rep(i,d){\n    ll nnn=n;\n    rep(j,m)\n      cin>>r[j];\n    rep(j,m){\n      if(r[j]<0)continue;\n      ll nn=(n+a[j]-r[j])%a[j];\n      if(subs[j].at(nn)==INF){\n        cout<<-1<<endl;\n        return 0;\n      }\n      n-=subs[j].at(nn);\n      n+=(nnn-n)/lcma[j+1]*lcma[j+1];\n      if(n<0){\n        cout<<-1<<endl;\n        return 0;\n      }\n //     cout<<\"->\"<<n<<\":\"<<r[j]<<\"mod\"<<a[j]<<endl;\n    }\n  }\n  cout<<(n<0?-1:n)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt r[111][111];\n\nInt mod_pow(Int x,Int y,Int mod){\n  Int res = 1;\n  while(y){\n    if(y&1) res = res * x % mod;\n    x = x * x % mod;\n    y /= 2;\n  }\n  return res;\n}\n\nInt extgcd(Int a,Int b,Int &x,Int &y){\n  Int d = a;\n  if(b != 0){\n    d = extgcd(b, a%b, y,x);\n    y -= (a/b) * x;\n  } else{\n    x = 1, y = 0;\n  }\n  return d;\n}\n\nInt mod_inverse(Int a,Int mod){\n  Int x,y;\n  extgcd(a,mod,x,y);\n  return (mod+x%mod)%mod;\n  //return mod_pow(x, mod-2, mod);\n\n}\n\npair<Int, Int> linear_congruence(const vector<Int> &A, const vector<Int> &B,const vector<Int> &M){\n  Int x = 0 ,m = 1;\n  for(Int i=0;i<(Int)A.size();i++){\n    Int a = A[i] * m , b = B[i] - A[i] * x, d = __gcd(M[i], a);\n    if(b%d!=0) return make_pair(0,-1);\n    Int t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i]/d;\n  }\n  return make_pair(x%m,m);\n}\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m,d;\n  cin>>n>>m>>d;\n  vector<Int> a(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n\n  for(Int i=0;i<d;i++)\n    for(Int j=0;j<m;j++)\n      cin>>r[i][j];\n\n  for(Int i=0;i<d;i++){\n    vector<Int> A,B,M;\n    for(Int j=0;j<m;j++){\n      if(r[i][j]<0) continue;\n      A.emplace_back(1);\n      B.emplace_back(r[i][j]);\n      M.emplace_back(a[j]);\n    }\n    auto p=linear_congruence(A,B,M);\n    //cout<<i<<\":\"<<p.first<<\" \"<<p.second<<endl;\n    if(p.second<0){\n      n=-1;\n      break;\n    }\n    if(p.second<0) p.first+=p.second;\n    n=(n-p.first)/p.second*p.second+p.first;\n  }\n  \n  cout<<n<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ax+by = 1 になる x, y を求める\nll extgcd (ll a, ll b, ll &x, ll &y ){\n\tll d = a;\n\tif (b != 0 ){\n\t\td = extgcd (b, a%b, y, x ); y -= (a/b)*x;\n\t}else{\n\t\tx = 1LL; y = 0LL;\n\t} // end if\n\n\treturn d;\n}\n\nll mod_inverse (ll a, ll m ){\n\tll x, y;\n\textgcd (a, m, x, y );\n\n\treturn (m + x % m ) % m;\n}\nconst int MAX_D = 105;\nconst int MAX_M = 12;\n\nint a[MAX_M];\nint r[MAX_D][MAX_M];\nll n_[MAX_M];\nll u[MAX_M];\n\nbool used[MAX_M];\nvoid used_ai (int id, int m ){\n\tfill (used, used + MAX_M, true );\n\n\trep (i, m ) if (r[id][i] == -1 ) used[i] = false;\n}\n\nint chinese_reminder_theorem (int di, int m, int curr ){\n\n\tmemset (n_, 0LL, sizeof (n_ ) );\n\tmemset (u, 0LL, sizeof (u ) );\n\n\tll N = 1LL;\n\trep (i, m ) if (used[i]  ) N *= (ll)a[i];\n\n\tif (N == 1LL ) return curr;\n\n\trep (i, m ) if (used[i] ) n_[i] = N/(ll)a[i];\n\trep (i, m ) if (used[i] ) u[i] = mod_inverse (n_[i], (ll)a[i] );\n\n\tll res = 0LL;\n\trep (i, m ) if (used[i] ) res += n_[i]*u[i]*(ll)r[di][i];\n\n\tres %= N;\n\n\treturn (res != 0LL ? (int)res : -1 );\t\t\t\n}\n\nvoid calc_factor(int d, int m ){\n\trep (i, m ){\n\t\tfor (int j = i + 1; j < m; j++ ){\n\t\t\tint g = __gcd(a[i], a[j] );\n\t\t\tif (g != 1 ){\n\t\t\t\ta[i] /= g;\n\t\t\t\ta[j] /= g;\n\t\t\t\trep (k, d ){\n\t\t\t\t\tif (r[k][i] != -1 )\n\t\t\t\t\t\tr[k][i] %= a[i];\n\t\t\t\t\tif (r[k][j] != -1 )\n\t\t\t\t\t\tr[k][j] %= a[j];\n\t\t\t\t} // end rep\n\t\t\t} // end if\n\t\t} // end for\n\t} // end rep\n}\n\nint main()\n{\n\tmemset (a, 0, sizeof (a ) );\n\tmemset (r, -1, sizeof (r ) );\n\n\tios_base::sync_with_stdio(0);\n\tint n, m, d; cin >> n >> m >> d;\n\trep (i, m ) cin >> a[i];\n\trep (i, d ) rep (j, m ) cin >> r[i][j];\n\n\tcalc_factor(d, m );\n\tint res = n;\n\trep (i, d ){\n\t\tused_ai (i, m );\n\t\tint curr = chinese_reminder_theorem (i, m, res );\n\t\tif (curr > res ){\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}else{\n\t\t\tres = min (res, curr );\n\t\t} // end if\n\t} // end rep\n\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint cal(int n,P p){\n  while(n%p.first!=p.second&&n>=0)n--;\n  return n;\n}\n\nint main(){\n  int n,m,d,a[10];\n  cin>>n>>m>>d;\n  for(int i=0;i<m;i++){\n    cin>>a[i];\n  }\n  P r[100][10];\n  for(int i=0;i<d;i++){\n    for(int j=0;j<m;j++){\n      cin>>r[i][j].second;\n      r[i][j].first=a[j];\n    }\n    sort(r[i],r[i]+m);\n    reverse(r[i],r[i]+m);\n    vector<int> v;\n    for(int j=0;j<m;j++){\n      if(r[i][j].second==-1)continue;\n      if(j){\n\tvector<int> nv;\n\tfor(int k=0;k<(int)v.size();k++){\n\t  if(v[k]%r[i][j].first==r[i][j].second)nv.push_back(v[k]);\n\t}\n\tv=nv;\n      }\n      else {\n\tint u=1e7;\n\tint p=cal(n,r[i][j]);\n\twhile((int)v.size()<u&&p>=0){\n\t  v.push_back(p);\n\t  p-=r[i][j].first;\n\t}\n      }\n    }\n    if(v.size())n=v[0];\n    else if(r[i][0].second!=-1)n=-1;\n  }\n  cout<<n<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll hoge = M[i]/d;\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % hoge;\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair( (x%m + m) % m , m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      ll  tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod==-1){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    if(n<mod)n = b;\n    else{\n      ll tmp = (n/mod+100) * mod + b;\n      while(tmp<n)tmp += mod;\n      while(n<tmp)tmp -= mod;\n      if(tmp<0){\n\tcout << -1 << endl;\n\treturn 0;\n      }\n      n = tmp;\n    }\n\n  }\n  assert(n>0);\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_DEPRECATE\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <iterator>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef pair<ll, ll> Pll;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n#define ten(x) ((int)1e##x)\n#define tenll(x) ((ll)1e##x)\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) {\n\tfor (T u = y = 1, v = x = 0; a;) {\n\t\tT q = b / a;\n\t\tswap(x -= q * u, u);\n\t\tswap(y -= q * v, v);\n\t\tswap(b -= q * a, a);\n\t}\n\treturn b;\n}\n\ntemplate<class T> T md_inverse(T a, T m) {\n\tT x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\n\ntemplate<class T>\npair<T, T> liner_congruence(const vector<T>& B, const vector<T>& M) {\n\tT x = 0, m = 1; // x = 0(mod 1)\n\tfor (int i = 0; i < sz(B); i++) {\n\t\tT a = m, b = B[i] - x;\n\t\tT d = gcd(M[i], a);\n\t\tif (b % d != 0) return pair<T, T>(0, -1); // no solution\n\t\tT t = b / d * md_inverse<T>(a / d, M[i] / d) % (M[i] / d);\n\t\tx = x + m * t;\n\t\tm *= M[i] / d;\n\t\tx = (x % m + m) % m;\n\t}\n\treturn pair<T, T>(x, m);\n}\n\nint main() {\n\tll n;\n\tint m, d; cin >> n >> m >> d;\n\tvector<ll> va(m);\n\tFOR(i, m) cin >> va[i];\n\tFOR(i, d) {\n\t\tvector<ll> B, M;\n\t\tFOR(j, m) {\n\t\t\tint a; cin >> a;\n\t\t\tif (a == -1) continue;\n\t\t\tB.push_back(a);\n\t\t\tM.push_back(va[j]);\n\t\t}\n\t\tauto kv = liner_congruence(B, M);\n\t\tif (kv.second == -1) {\n\t\t\tn = -1;\n\t\t\tbreak;\n\t\t}\n\t\tauto cur_rem = n % kv.second;\n\t\tif (cur_rem > kv.first) {\n\t\t\tn -= cur_rem - kv.first;\n\t\t} else if (cur_rem < kv.first) {\n\t\t\tn -= (cur_rem + (kv.second - kv.first));\n\t\t}\n\t\tif (n < 0) break;\n\t}\n\n\tif (n < 0) n = -1;\n\tcout << n << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ax+by = 1 になる x, y を求める\nll extgcd (ll a, ll b, ll &x, ll &y ){\n\tll d = a;\n\tif (b != 0 ){\n\t\td = extgcd (b, a%b, y, x ); y -= (a/b)*x;\n\t}else{\n\t\tx = 1LL; y = 0LL;\n\t} // end if\n\n\treturn d;\n}\n\nll mod_inverse (ll a, ll m ){\n\tll x, y;\n\textgcd (a, m, x, y );\n\n\treturn (m + x % m ) % m;\n}\n\nconst int MAX_M = 12;\nconst int MAX_D = 105;\n\nint a[MAX_M];\nint r[MAX_D][MAX_M];\nbool used[MAX_M];\nll n_[MAX_M];\nll u[MAX_M];\n\nint chinese_reminder_theorem (int di, int m, int curr ){\n\n\tmemset (n_, -1LL, sizeof (n_ ) );\n\tmemset (u, -1LL, sizeof (u ) );\n\n\tll N = 1LL;\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) N *= (ll)a[i];\n\n\tif (N == 1LL ) return curr;\n\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) n_[i] = N/(ll)a[i];\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) u[i] = mod_inverse (n_[i], (ll)a[i] );\n\n\tll res = 0LL;\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) res += n_[i]*u[i]*(ll)r[di][i];\n\n\tres %= N;\n\n\treturn (res != 0LL ? (int)res : -1 );\t\t\t\n}\n\nint main()\n{\n\tmemset (a, 0, sizeof (a ) );\n\tmemset (r, 0, sizeof (r ) );\n\tmemset (used, false, sizeof (used ) );\n\n\tios_base::sync_with_stdio(0);\n\tint n, m, d; cin >> n >> m >> d;\n\n\trep (i, m ) cin >> a[i];\n\trep (i, d ) rep (j, m ) cin >> r[i][j];\n\n\trep (i, m ) used[i] = true;\n\tvector<int> sum_n (m, 0 );\n\trep (j, m ) {\n\t\tint cnt = 0;\n\t\trep (i, d ) if (r[i][j] == -1 ) cnt++;\n\t\tsum_n[j] = cnt;\n\t} // end rep\n\t\n\trep (i, m ){\n\t\tif (!used[i] ) continue;\n\t\tfor (int j = i+1; j < m; j++ ){\n\t\t\tif (__gcd (a[i], a[j] ) != 1 ){\n\t\t\t\tif (sum_n[i] <= sum_n[j] )\n\t\t\t\t\tused[j] = false;\n\t\t\t\telse\n\t\t\t\t\tused[i] = false;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end rep\n\n\tint res = n;\n\trep (i, d ){\n\t\tint curr = chinese_reminder_theorem (i, m, res );\n\t\tres = min (res, curr );\n\t} // end rep\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll hoge = M[i]/d;\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % hoge;\n    x = x+m*t;\n    m *= M[i]/d;\n    assert(m>=0);\n  }\n  return make_pair( (x%m + m) % m , m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      ll  tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod==-1){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    ll tmp = (n/mod+100) * mod + b;\n    while(tmp<n)tmp += mod;\n    while(n<tmp)tmp -= mod;\n    if(tmp<0){\n      cout << -1 << endl;\n      return 0;\n    }\n    n = tmp;\n\n  }\n\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[2001][3];\nint n,k,m=1000003;\n\nint dfs(int p,int f){\n  if(dp[p][f]!=-1)return dp[p][f];\n  if(p==n){\n    if(f==1)return 1;\n    return 0;\n  }\n  int nf;\n  if(f==-1)nf=0;\n  if(f==0)nf=2;\n  if(f==1)nf=2;\n  if(f==2)nf=1;\n  int res=0;\n  for(int i=1;i<=k&&p+i<=n;i++){\n    res=(res+dfs(p+i,nf))%m;\n  }\n  if(f==-1)return res;\n  return dp[p][f]=res;\n}\n\nint main(){\n  while(cin>>n>>k,n){\n    memset(dp,-1,sizeof(dp));\n    dfs(0,-1);\n    int ans=0;\n    for(int i=1;i<=k;i++){\n      if(dp[i][0]!=-1){\n\tif(i==n)ans=(ans+1)%m;\n\tans=(ans+dp[i][0]*i)%m;\n      }\n    }\n    cout<<ans*2%m<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef long long LL;\n\nLL extgcd(LL a, LL b, LL& x, LL& y){\n    LL d = a;\n    if(b != 0){\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nLL mul_mod(LL a, LL b, LL mod){\n    if(b == 0) return 0;\n    LL res = mul_mod((a + a) % mod, b / 2, mod);\n    if(b & 1) res = (res + a) % mod;\n    return res;\n}\n\nLL pow_mod(LL a, LL b, LL mod){\n    if(b == 0) return 1;\n    LL res = pow_mod(mul_mod(a, a, mod), b / 2, mod);\n    if(b & 1) res = mul_mod(res, a, mod);\n    return res;\n}\n\nLL inv_mod(LL a, LL mod){\n    LL x, y;\n    extgcd(a, mod, x, y);\n    return (x % mod + mod) % mod;\n}\n\nvector<LL> inverse_list(int n, int p){\n    vector<LL> inv(n + 1);\n    inv[1] = 1;\n    for (int i = 2; i <= n; ++i){\n        inv[i] = inv[p % i] * (p - p / i) % p;\n    }\n    return inv;\n}\n\npair<LL, LL> linear_congruence(const vector<LL>& A, const vector<LL>& B, const vector<LL>& M) {\n    LL x = 0, m = 1;\n\n    for(int i = 0; i < A.size(); i++) {\n        LL a = A[i] * m, b = B[i] - A[i] * x, d = __gcd(M[i], a);\n        if(b % d != 0) return make_pair(0, -1); // no solution\n        LL t = b / d * inv_mod(a / d , M[i] / d) % (M[i] / d);\n        x = x + m * t;\n        m *= M[i] / d;\n    }\n    return make_pair(x % m, m);\n}\n\nint main(){\n    LL N, M, D;\n    while(cin >> N >> M >> D) {\n\n        LL A[10];\n        REP(i, M) cin >> A[i];\n\n        for(int t = 0; t < D; t++) {\n            vector<LL> a, b, m;\n            REP(i, M) {\n                LL y;\n                cin >> y;\n                if(y == -1) continue;\n                a.push_back(1);\n                b.push_back(y);\n                m.push_back(A[i]);\n            }\n\n            pair<LL, LL> p = linear_congruence(a, b, m);\n\n            if(N == -1 || p.first > N || p.second == -1) {\n                N = -1;\n            } else {\n                LL k = (N - p.first) / p.second;\n                assert(p.first + p.second * k <= N);\n                assert(p.first + p.second * (k + 1) > N);\n                N = p.first + p.second * k;\n            }\n            // cout << N << endl;\n            \n        }\n\n        cout << N << endl;\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nlong long extgcd(long long a, long long b, long long &x, long long &y) {\n\tlong long d = a;\n\tif(b != 0) {\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t} else {\n\t\tx = 1;\n\t\ty = 0;\n\t}\n\treturn d;\n}\n\nlong long mod_inverse(long long a, long long m) {\n\tlong long x, y;\n\textgcd(a, m, x, y);\n\treturn (x % m + m) % m;\n}\n\npair<long long, long long> linear_congruence(const vector<long long> &A, const vector<long long> &B, const vector<long long> &M) {\n\tlong long x = 0, m = 1;\n\n\tfor(unsigned i = 0; i < A.size(); ++i) {\n\t\tif(B[i] == -1) continue;\n\n\t\tlong long a = A[i] * m, b = B[i] - A[i] * x, d = __gcd(M[i], a);\n\t\tif(b % d != 0) return make_pair(0, -1);\n\t\tlong long t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n\t\tx = x + m * t;\n\t\tm *= M[i] / d;\n\t}\n\n\treturn make_pair(x % m, m);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, m, d;\n\tcin >> n >> m >> d;\n\n\tvector<long long> M(m);\n\tfor(auto &e : M) cin >> e;\n\n\tvector<long long> A(m, 1);\n\n\tfor(int i = 0; i < d; ++i) {\n\t\tvector<long long> B(m);\n\t\tfor(auto &e : B) cin >> e;\n\n\t\tlong long b, mod;\n\t\ttie(b, mod) = linear_congruence(A, B, M);\n\n\t\tn = n - (n - b + mod) % mod;\n\n\t\tif(mod == -1 || n < 0) {\n\t\t\tn = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << n << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef long long LL;\n\nLL extgcd(LL a, LL b, LL& x, LL& y){\n    LL d = a;\n    if(b != 0){\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nLL mul_mod(LL a, LL b, LL mod){\n    if(b == 0) return 0;\n    LL res = mul_mod((a + a) % mod, b / 2, mod);\n    if(b & 1) res = (res + a) % mod;\n    return res;\n}\n\nLL pow_mod(LL a, LL b, LL mod){\n    if(b == 0) return 1;\n    LL res = pow_mod(mul_mod(a, a, mod), b / 2, mod);\n    if(b & 1) res = mul_mod(res, a, mod);\n    return res;\n}\n\nLL inv_mod(LL a, LL mod){\n    LL x, y;\n    extgcd(a, mod, x, y);\n    return (x % mod + mod) % mod;\n}\n\nvector<LL> inverse_list(int n, int p){\n    vector<LL> inv(n + 1);\n    inv[1] = 1;\n    for (int i = 2; i <= n; ++i){\n        inv[i] = inv[p % i] * (p - p / i) % p;\n    }\n    return inv;\n}\n\npair<LL, LL> linear_congruence(const vector<LL>& A, const vector<LL>& B, const vector<LL>& M) {\n    LL x = 0, m = 1;\n\n    for(int i = 0; i < A.size(); i++) {\n        LL a = A[i] * m, b = B[i] - A[i] * x, d = __gcd(M[i], a);\n        if(b % d != 0) return make_pair(0, -1); // no solution\n        LL t = b / d * inv_mod(a / d , M[i] / d) % (M[i] / d);\n        x = x + m * t;\n        m *= M[i] / d;\n    }\n    return make_pair(x % m, m);\n}\n\nint main(){\n    LL N, M, D;\n    while(cin >> N >> M >> D) {\n\n        LL A[10];\n        REP(i, M) cin >> A[i];\n\n        for(int t = 0; t < D; t++) {\n            vector<LL> a, b, m;\n            REP(i, M) {\n                LL y;\n                cin >> y;\n                if(y == -1) continue;\n                a.push_back(1);\n                b.push_back(y);\n                m.push_back(A[i]);\n            }\n\n            pair<LL, LL> p = linear_congruence(a, b, m);\n\n            if(p.first > N || p.second == -1) {\n                N = -1;\n            } else {\n                LL k = (N - p.first) / p.second;\n                assert(p.first + p.second * k <= N);\n                assert(p.first + p.second * (k + 1) > N);\n                N = p.first + p.second * k;\n            }\n            // cout << N << endl;\n            \n        }\n\n        cout << N << endl;\n    }\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll N,M,D;\nll A[10];\nll INF = 1e18;\n\nll lcm(ll a,ll b){\n  ll res= a/__gcd(a,b);\n  if( res > INF / b )return INF;\n  return res * b;\n}\n\nll solve(){\n\n  ll ans=N;\n  for(int i=0;i<D;i++){\n    ll a=0,b=1;\n    for(int j=0;j<M;j++){\n      ll k;\n      cin>>k;\n      if(k==-1)continue;\n      if(k>=A[j])return -1;\n\n      if(a==0 && b==1){\n        a=k;\n        b=A[j];\n        continue;\n      }\n\n      while( a%A[j]!=k ){\n        if(a+b > N)return -1;\n        a+=b;\n      }\n      b=lcm(b,A[j]);\n    }\n\n    \n    if(ans<a)return -1;\n    ll d=ans-a;\n    ll c=d/b;\n    ans=a+b*c;\n  }\n  return ans;\n}\n\nint main(){\n  cin>>N>>M>>D;\n  for(int i=0;i<M;i++)cin>>A[i];\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % (M[i]/d);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair(x%m, m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      ll tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod<0){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    ll tmp = (n/mod) * mod + b;\n    if(n<tmp)tmp -= mod;\n    if(tmp<0){\n      cout << -1 << endl;\n      return 0;\n    }\n    n = tmp;\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll hoge = M[i]/d;\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % hoge;\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair( (x%m + m) % m , m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      ll  tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod==-1){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    ll tmp = (n/mod+100) * mod + b;\n    while(tmp<n)tmp += mod;\n    while(n<tmp)tmp -= mod;\n    if(tmp<0){\n      cout << -1 << endl;\n      return 0;\n    }\n    n = tmp;\n\n  }\n\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long MAX_P = 200001;\nconst long long MOD = 1000000007;\ntypedef long long ll;\n\n// 入力はすべて正とする\n// 素数判定O(√n)\nbool is_prime(long long n) {\n\tfor (long long i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) return false;\n\t}\n\treturn n != 1; // 1の場合は例外\n}\n// 約数の列挙O(√n)\nvector<long long> divisor(long long n) {\n\tvector<long long> res;\n\tfor (long long i = 1; i * i <= n; i++) {\n  \tif (n % i == 0) {\n\t\t\tres.push_back(i);\n\t\t\tif (i != n / i) res.push_back(n / i);\n\t\t}\n\t}\n\treturn res;\n}\n// 素因数分解O(√n)\nmap<long long, long long> prime_factor(long long n) {\n\tmap<long long, long long> res;\n\tfor (long long i = 2; i * i <= n; i++) {\n\t\twhile (n % i == 0) {\n\t\t\t++res[i];\n\t\t\tn /= i;\n\t\t}\n\t}\n\tif (n != 1) res[n] = 1;\n\treturn res;\n}\n\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n\tlong long d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t} else {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\n\nlong long mod_inverse(long long a, long long m) {\n\tlong long x, y;\n\textgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\n\nlong long fact[MAX_P+1];\n// n! mod pのテーブルを作る O(p)\nvoid mod_fact(long long n, long long m) {\n\tfact[0] = 1;\n\tfor (long long i = 1; i <= n; i++) fact[i] = fact[i-1]*i%m;\n}\n\n// n!=a p^e としたときのa mod pを求める。O(log_p n)\nlong long mod_fact(long long n, long long p, long long& e) {\n\te = 0;\n\tif (n == 0) return 1;\n\t// pの倍数の部分を計算\n\tlong long res = mod_fact(n / p, p, e);\n\te += n / p;\n\t// (p-1)!≡-1なので(p-1)!^(n/p)はn/pの偶奇だけで計算できる\n\tif (n / p % 2 != 0) return res * (p - fact[n % p]) % p;\n\treturn res * fact[n % p] % p;\n}\n\n// nCk mod pを求める。O(log_p n)\nlong long mod_comb(long long n, long long k, long long p) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\tlong long e1, e2, e3;\n\tlong long a1 = mod_fact(n, p, e1), a2 = mod_fact(k, p, e2), a3 = mod_fact(n - k, p, e3);\n\t//if (a1 * mod_inverse(a2 * a3 % p, p) % p == 0) printf(\"%lld, %lld, %lld,%lld, %lld, %lld\\n\",n, p, e1,a1, a2, a3);\n\tif (e1 > e2 + e3) return 0;\n\treturn a1 * mod_inverse(a2 * a3 % p, p) % p;\n}\n\npair<long long, long long> crt(const vector<long long> &a, const vector<long long> &m) {\n\tlong long r = 0, M = 1;\n\tfor (int i = 0; i < (int)a.size(); ++i) {\n\t\tif (a[i] == -1) continue;\n\t\tlong long p, q;\n\t\tlong long d = extgcd(M, m[i], p, q);\n\t\tif ((a[i] - r) % d != 0) return make_pair(-1, -1);;\n\t\tlong long tmp = (a[i] - r) / d * p % (m[i]/d);\n\t\tr += M * tmp;\n\t\tM *= m[i]/d;\n\t}\n\treturn make_pair((r % M + M) % M, M);\n}\n\nint main(){\n\tll N,M,D;\n\tscanf(\"%lld\",&N);\n\tscanf(\"%lld\",&M);\n\tscanf(\"%lld\",&D);\n\tvector<ll> A(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tscanf(\"%lld\",&A[i]);\n\t}\n\tvector< vector<ll> > R;\n\tR = vector< vector<ll> >(D, vector<ll>(M, 0));\n\tfor (int i = 0; i < D; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tscanf(\"%lld\",&R[i][j]);\n\t\t}\n\t}\n\n\tll res = N;\n\tfor (int i = 0; i < D; i++) {\n\t\tpair<ll, ll> c = crt(R[i], A);\n\t\tif (c.first > res || c.first == -1) {\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}\n\t\tres = c.first+(res-c.first)/c.second*c.second;\n\t}\n\tcout << res << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//#################################################################\n//ユークリッドの互除法 O(log max(a, b))\n\nnamespace gcd{\n\nint gcd(int a, int b){\n\tif(b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint extgcd(int a, int b, int &x, int &y){\n\tint d = a;\n\tif(b != 0){\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t}else{\n\t\tx = 1;\n\t\ty = 0;\n\t}\n\treturn d;\n}\n\n}\n\nint mod_inverse(int a, int m){\n\tint x, y;\n\tgcd::extgcd(a, m, x, y);\n\treturn (m + x % m) % m;\n}\n\n//a_i * x = b_i (mod m_i) (1 <= i <= n)を解く\npair<int, int> linear_congruence(const vector<int> &A, const vector<int> &B, const vector<int> &M){\n\tint x = 0, m = 1;\n\tfor(int i=0;i<A.size();i++){\n\t\tint a = A[i] * m, b = B[i] - A[i] * x, d = gcd::gcd(M[i], a);\n\t\tif(b % d != 0) return make_pair(0, -1); //解がない\n\t\tint t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n\t\tx = x + m * t;\n\t\tm *= M[i] / d;\n\t}\n\treturn make_pair(x % m, m);\n}\n\nint main() {\n  int N, M, D;\n  cin >> N >> M >> D;\n  vector<int> A(M);\n  for(int j = 0; j < M; ++j) {\n    cin >> A[j];\n  }\n  bool flag = false;\n  for(int i = 0; i < D; ++i) {\n    vector<int> R(M);\n    vector<int> b, m;\n    for(int j = 0; j < M; ++j) {\n      cin >> R[j];\n      if(R[j] != -1) {\n\tb.push_back(R[j]);\n\tm.push_back(A[j]);\n      }\n    }\n    if(flag) continue;\n    pair<int,int> p = linear_congruence(vector<int>(b.size(), 1), b, m);\n    if(p.second == -1) {\n      flag = true;\n      continue;\n    }\n    int k = (N - p.first) / p.second;\n    while(p.first + p.second * k <= N) ++k;\n    --k;\n    N = p.first + p.second * k;\n  }\n  if(flag) N = -1;\n  cout << N << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ax+by = 1 になる x, y を求める\nll extgcd (ll a, ll b, ll &x, ll &y ){\n\tll d = a;\n\tif (b != 0 ){\n\t\td = extgcd (b, a%b, y, x ); y -= (a/b)*x;\n\t}else{\n\t\tx = 1LL; y = 0LL;\n\t} // end if\n\n\treturn d;\n}\n\nll mod_inverse (ll a, ll m ){\n\tll x, y;\n\textgcd (a, m, x, y );\n\n\treturn (m + x % m ) % m;\n}\n\nconst int MAX_M = 12;\nconst int MAX_D = 105;\n\nint a[MAX_M];\nint r[MAX_D][MAX_M];\nbool used[MAX_M];\nll n_[MAX_M];\nll u[MAX_M];\n\nint chinese_reminder_theorem (int di, int m, int curr ){\n\n\tmemset (n_, -1LL, sizeof (n_ ) );\n\tmemset (u, -1LL, sizeof (u ) );\n\n\tll N = 1LL;\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) N *= (ll)a[i];\n\n\tif (N == 1LL ) return curr;\n\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) n_[i] = N/(ll)a[i];\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) u[i] = mod_inverse (n_[i], (ll)a[i] );\n\n\tll res = 0LL;\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) res += n_[i]*u[i]*(ll)r[di][i];\n\n\tres %= N;\n\n\treturn (res != 0LL ? (int)res : -1 );\t\t\t\n}\n\nvoid used_ai (int id, int m ){\n\tfill (used, used + MAX_M, true );\n\n\trep (i, m ){\n\t\tif (!used[i] ) continue;\n\t\tif (r[id][i] == -1 ){\n\t\t\tused[i] = false;\n\t\t\tcontinue;\n\t\t} // end if\n\t\tfor (int j = i+1; j < m; j++ ){\n\t\t\tif (r[id][j] == -1 ){\n\t\t\t\tused[j] = false;\n\t\t\t\tcontinue;\n\t\t\t} // end if\n\t\t\tif (__gcd (a[i], a[j] ) != 1 ){\n\t\t\t\tused[j] = false;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end rep\n}\n\nint main()\n{\n\tmemset (a, 0, sizeof (a ) );\n\tmemset (r, -1, sizeof (r ) );\n\n\tios_base::sync_with_stdio(0);\n\tint n, m, d; cin >> n >> m >> d;\n\n\trep (i, m ) cin >> a[i];\n\trep (i, d ) rep (j, m ) cin >> r[i][j];\n\n\tint res = n;\n\trep (i, d ){\n\t\tused_ai (i, m );\n\t\tint curr = chinese_reminder_theorem (i, m, res );\n\t\tif (curr > res ){\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}else{\n\t\t\tres = min (res, curr );\n\t\t} // end if\n\t} // end rep\n\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T>ostream&operator<<(ostream &o,const vector<T>&t){o<<'[';FOR(i,t){if(i!=t.begin())o<<',';o<<*i;}return o<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)output(a[i],i!=n-1?',':10);}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a;\n  x = 1; y = 0;\n  if (b) {\n    g = extgcd(b, a%b, y, x);\n    y -= (a/b) * x;\n  }\n  return g;\n}\n\nll invMod(ll a, ll p) {\n  ll x, y;\n  if (extgcd(a,p,x,y) == 1) return (x+p)%p;\n  return 0;\n}\n\n// solve \"ax == b (mod M)\" for x\n// (x, m)\nbool divide(ll a, ll b, ll M, ll &x, ll &m) {\n  // a %= M; b%= M;\n  ll g = __gcd(a,M);\n  if (b%g) return 0;\n  // if g!=1, x has several answers.\n  m = M/g;\n  x = invMod(a/g, m)*(b/g)%m;\n  return 1;\n}\n// 蟻本\nbool linearCongruences(const vector<ll> &A, const vector<ll> &B,\n                       const vector<ll> &M, ll &x, ll &m) {\n  x=0; m=1;\n  REP(i, A.size()) {\n    ll a = A[i]*m, b=B[i]-A[i]*x;\n    ll t, mm;\n    if (!divide(a,b,M[i],t,mm)) return 0;\n    x = x+m*t;\n    m *= mm;\n  }\n  x = (x+m) % m;\n  return 1;\n}\n\n\nint a[10];\nint x[100][10];\n\nint main() {\n  int n,m,d;\n  while(input(n,m,d)) {\n    REP(i,m) {\n      input(a[i]);\n    }\n    REP(i,d)REP(j,m)input(x[i][j]);\n    bool ng = 0;\n    ll cur = n;\n    REP(i,d) {\n      vector<ll> A, B, M;\n      REP(j,m) {\n        if (x[i][j] == -1) continue;\n        A.push_back(1);\n        B.push_back(x[i][j]);\n        M.push_back(a[j]);\n      }\n      ll res, md;\n      if (linearCongruences(A,B,M,res,md)) {\n        if (res > cur) {\n          ng = 1;\n          break;\n        }\n        ll x = (cur - res) / md;\n        cur = x * md + res;        \n      } else {\n        ng = 1;\n        break;\n      }\n    }\n    if (ng) cout << -1 << endl;\n    else cout << cur << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-8;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<ll, ll> linear_congruence(const vector<ll>& A, const vector<ll>& B,\n                                 const vector<ll>& M) {\n  ll x = 0, m = 1;\n  for(ll i = 0; i < A.size(); i++){\n    if(B[i] == -1) continue;\n    ll a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0) return make_pair(0, -1);\n    ll t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  ll num_of_chopsticks;\n  int num_of_divisors;\n  int total_days;\n  while(~scanf(\"%lld %d %d\",\n               &num_of_chopsticks,\n               &num_of_divisors,\n               &total_days)){\n    vector<ll> divisors(num_of_divisors);\n    for(int div_i = 0; div_i < num_of_divisors; div_i++){\n      scanf(\"%lld\",&divisors[div_i]);\n    }\n    ll record[101][11];\n    for(int day = 0; day < total_days; day++){\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        scanf(\"%lld\",&record[day][div_i]);\n      }\n    }\n\n    vector<ll> A(num_of_divisors,1);\n    for(int day = 0; day < total_days; day++){\n      vector<ll> reminder;\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        reminder.push_back(record[day][div_i]);\n      }\n\n      pair<ll,ll> ans = linear_congruence(A,reminder,divisors);\n      if(ans.second == -1){\n        num_of_chopsticks = -1;\n        break;\n      }\n      \n      ll upper = 1000000000LL;\n      ll lower = -1;\n      for(int round = 0; round < 50; round++){\n        ll mid = lower + (upper - lower) / 2LL;\n        if(ans.second * mid + ans.first > num_of_chopsticks){\n          upper = mid;\n        }\n        else{\n          lower = mid;\n        }\n      }\n      num_of_chopsticks = ans.second * lower + ans.first;\n\n      if(num_of_chopsticks < 0){\n              num_of_chopsticks = -1;\n        break;\n      }\n    }\n    printf(\"%lld\\n\",num_of_chopsticks);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n \nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n \nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n \nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n \npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % (M[i]/d);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair( (x%m + m) % m , m);\n}\n \nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n \n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      ll  tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n     \n    pii ans = linear_congruence(e,r,aa);\n    ll b = ans.first, mod = ans.second;\n    if(mod<0){\n      cout << -1 << endl;\n      return 0;\n    }\n \n    ll tmp = (n/mod+100) * mod + b;\n    while(tmp<n)tmp += mod;\n    while(n<tmp)tmp -= mod;\n    if(tmp<0){\n      cout << -1 << endl;\n      return 0;\n    }\n    n = tmp;\n \n  }\n \n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\nlong long extgcd(long long a, long long b, long long &x, long long &y) {\n\tlong long d = a;\n\tif(b != 0) {\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t} else {\n\t\tx = 1;\n\t\ty = 0;\n\t}\n\treturn d;\n}\n\nlong long mod_inverse(long long a, long long m) {\n\tlong long x, y;\n\textgcd(a, m, x, y);\n\treturn (x % m + m) % m;\n}\n\npair<long long, long long> linear_congruence(const vector<long long> &A, const vector<long long> &B, const vector<long long> &M) {\n\tlong long x = 0, m = 1;\n\n\tfor(unsigned i = 0; i < A.size(); ++i) {\n\t\tif(B[i] == -1) continue;\n\n\t\tlong long a = A[i] * m, b = B[i] - A[i] * x, d = __gcd(M[i], a);\n\t\tif(b % d != 0) return make_pair(0, -1);\n\t\tlong long t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n\t\tx = x + m * t;\n\t\tm *= M[i] / d;\n\t}\n\n\treturn make_pair(x % m, m);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, m, d;\n\tcin >> n >> m >> d;\n\n\tvector<long long> M(m);\n\tfor(auto &e : M) cin >> e;\n\n\tvector<long long> A(m, 1);\n\n\tfor(int i = 0; i < d; ++i) {\n\t\tvector<long long> B(m);\n\t\tfor(auto &e : B) cin >> e;\n\n\t\tlong long b, mod;\n\t\ttie(b, mod) = linear_congruence(A, B, M);\n\n\t\tconst long long p = n / mod;\n\t\tconst long long q = n % mod;\n\t\tconst long long k = (q - b + mod) % mod;\n\n\t\tn = p * mod + q - k;\n\n\t\tif(mod == -1 || n < 0) {\n\t\t\tn = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << n << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.D\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\tios_base::sync_with_stdio(0);\n\tint n, m, d; cin >> n >> m >> d;\n\tvector<int> a(m, 0 );\n\n\trep (i, m ) cin >> a[i];\n\tvector<vector<int> > r(d, vector<int> (m, 0 ) );\n\trep (i, d ) rep (j, m ) cin >> r[i][j];\n\n\tint cand = n;\n\tbool ok = true;\n\trep (i, d ){\n\t\tint next = -1;\n\t\tfor (int l = cand; l >= 0; l-- ){\n\t\t\tint cnt = 0;\n\t\t\trep (k, m ){\n\t\t\t\tif (r[i][k] != -1 ){\n\t\t\t\t\tif (l % a[k] == r[i][k] ) cnt++;\n\t\t\t\t}else{\n\t\t\t\t\tcnt++;\n\t\t\t\t} // end if\n\t\t\t} // end rep\n\t\t\tif (cnt == m ){\n\t\t\t\tnext = l;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t} // end for\n\t\tif (next == -1 ){\n\t\t\tok = false;\n\t\t\tbreak;\n\t\t} // end if\n\t\tcand = next;\n\t} // end rep\n\n\tcout << (ok ? cand : -1 ) << endl;\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long extgcd(long long a, long long b, long long &x, long long &y) {\n    long long d = a;\n    if(b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1;\n        y = 0;\n    }\n    return d;\n}\n\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    extgcd(a, m, x, y);\n    return (x % m + m) % m;\n}\n\npair<long long, long long> linear_congruence(const vector<long long> &A, const vector<long long> &B, const vector<long long> &M) {\n    long long x = 0, m = 1;\n\n    for(unsigned i = 0; i < A.size(); ++i) {\n        if(B[i] == -1) continue;\n\n        long long a = A[i] * m, b = B[i] - A[i] * x, d = __gcd(M[i], a);\n        if(b % d != 0) return make_pair(0, -1);\n        long long t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n        x = x + m * t;\n        m *= M[i] / d;\n    }\n\n    return make_pair(x % m, m);\n}\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int n, m, d;\n    cin >> n >> m >> d;\n\n    vector<long long> M(m);\n    for(auto &e : M) cin >> e;\n\n    vector<long long> A(m, 1);\n\n    for(int i = 0; i < d; ++i) {\n        vector<long long> B(m);\n        for(auto &e : B) cin >> e;\n\n        long long b, mod;\n        tie(b, mod) = linear_congruence(A, B, M);\n\n        n = n - (n - b + mod) % mod;\n\n        if(mod == -1 || n < 0) {\n            n = -1;\n            break;\n        }\n    }\n\n    cout << n << endl;\n\n    return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-8;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<ll, ll> linear_congruence(const vector<ll>& A, const vector<ll>& B,\n                                 const vector<ll>& M) {\n  ll x = 0, m = 1;\n  for(ll i = 0; i < A.size(); i++){\n    if(B[i] == -1) continue;\n    ll a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0) return make_pair(0, -1);\n    ll t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  ll num_of_chopsticks;\n  int num_of_divisors;\n  int total_days;\n  while(~scanf(\"%lld %d %d\",\n               &num_of_chopsticks,\n               &num_of_divisors,\n               &total_days)){\n    vector<ll> divisors(num_of_divisors);\n    for(int div_i = 0; div_i < num_of_divisors; div_i++){\n      scanf(\"%lld\",&divisors[div_i]);\n    }\n    ll record[101][11];\n    for(int day = 0; day < total_days; day++){\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        scanf(\"%lld\",&record[day][div_i]);\n      }\n    }\n\n    vector<ll> A(num_of_divisors,1);\n    for(int day = 0; day < total_days; day++){\n      vector<ll> reminder;\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        reminder.push_back(record[day][div_i]);\n      }\n\n      pair<ll,ll> ans = linear_congruence(A,reminder,divisors);\n      if(ans.first > num_of_chopsticks){\n        num_of_chopsticks = -1;\n        break;\n      }\n      \n      ll upper = 10000000000LL;\n      ll lower = -1;\n      for(int round = 0; round < 50; round++){\n        ll mid = lower + (upper - lower) / 2LL;\n        if(ans.second * mid + ans.first > num_of_chopsticks){\n          upper = mid;\n        }\n        else{\n          lower = mid;\n        }\n      }\n      num_of_chopsticks = ans.second * lower + ans.first;\n\n      if(num_of_chopsticks < 0){\n              num_of_chopsticks = -1;\n        break;\n      }\n    }\n    printf(\"%lld\\n\",num_of_chopsticks);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n#include <tuple>\nusing namespace std;\n\n// 中国剰余定理\n// x = b_1 (mod_1), ..., x = b_k (mod_k), ... を満たす x を\n// 0 <= x < lcm(mod_1, mod_2, ..., mod_k, ...) の範囲で求める\n\ntemplate <typename NumType, NumType LIMIT = NumType(1e10)>\nstruct CRT {\n    pair<NumType, NumType> NIL;\n    CRT() : NIL(-1, -1) {}\n    \n    NumType extgcd(NumType a, NumType b, NumType &p, NumType &q) {\n        if(b == 0) {\n            p = 1, q = 0;\n            return a;\n        }\n        NumType d = extgcd(b, a%b, q, p);\n        q -= a / b * p;\n        return d;\n    }\n\n    pair<NumType, NumType> solve(NumType b1, NumType mod1, NumType b2, NumType mod2) {\n        NumType p, q;\n        NumType d = extgcd(mod1, mod2, p, q);\n        \n        if((b2 - b1) % d != 0) return NIL;\n        NumType s = (b2 - b1) / d;\n        NumType t = (s * p % (mod2 / d));\n\n        // get lcm\n        NumType lc = mod1 / d * mod2;\n        NumType so = (b1 + mod1 * t) % lc;\n        (so += lc) %= lc;\n        return make_pair(so, lc);\n    }\n\n    // m, mod の vector をもらって、\n    // CRT の解を (x, lcm(mod_1, mod_2, ..., mod_k, ...)) の形で返す\n    pair<NumType, NumType> solve(vector<NumType> m, vector<NumType> mod) {\n        assert(m.size() == mod.size());\n        NumType so = 0, lc = 1;\n        for(size_t i=0; i<m.size(); i++) {\n            tie(so, lc) = solve(so, lc, m[i], mod[i]);\n            if(so > LIMIT or so < 0) {\n                return NIL;\n            }\n        }\n        return make_pair(so, lc);\n    }\n};\n\n\nvoid yuki_186() {\n    using ll = long long int;\n    vector<ll> b(3), mod(3);\n    for(int i=0; i<3; i++) {\n        cin >> b[i] >> mod[i];\n    }\n\n    CRT<ll, (ll)2e18> crt;\n    auto ans = crt.solve(b, mod);\n    cout << ans.first + (ans.first == 0 ? ans.second : 0) << endl;\n}\n\nvoid AOJ2659() {\n    using ll = long long int;\n    ll N, M, D; cin >> N >> M >> D;\n    vector<int> A(M);\n    for(int i=0; i<M; i++) {\n        cin >> A[i];\n    }\n\n    CRT<ll, (ll)1e10> crt;\n    for(int i=0; i<D; i++) {\n        vector<ll> b, mod;\n        for(int j=0; j<M; j++) {\n            int val; cin >> val;\n            if(val < 0) continue;\n            b.push_back(val);\n            mod.push_back(A[j]);\n        }\n        ll so, lc; tie(so, lc) = crt.solve(b, mod);\n        if(so < 0 or so > N) {\n            cout << -1 << endl;\n            return;\n        }\n        N = (N - so) / lc * lc + so;\n    }\n    cout << N << endl;\n}\n\nint main() {\n    // yuki_186();\n    AOJ2659();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\n#include <cassert>\n#include <functional>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(...) ;\n#else\n#define debug(...) cerr << __LINE__ << \" : \" << #__VA_ARGS__ << \" = \" << _tostr(__VA_ARGS__) << endl;\n\ntemplate<typename T>\nostream &operator<<(ostream &out, const vector<T> &v);\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n\nvoid _tostr_rec(ostringstream &oss) {\n  oss << \"\\b\\b \\b\";\n}\n\ntemplate<typename Head, typename... Tail>\nvoid _tostr_rec(ostringstream &oss, Head &&head, Tail &&... tail) {\n  oss << head << \", \";\n  _tostr_rec(oss, forward<Tail>(tail)...);\n}\n\ntemplate<typename... T>\nstring _tostr(T &&... args) {\n  ostringstream oss;\n  int size = sizeof...(args);\n  if (size > 1) oss << \"{\";\n  _tostr_rec(oss, forward<T>(args)...);\n  if (size > 1) oss << \"}\";\n  return oss.str();\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 210\n\n// {a, {b, c}} : a = gcd(p, q) = bp + cq\npair<ll, pair<ll, ll>> ext_gcd(ll p, ll q) {\n  if (q == 0) return {p, {1, 0}};\n  auto r = ext_gcd(q, p % q);\n  return {r.first, {r.second.second, r.second.first - p / q * r.second.second}};\n}\n\n/* 中国剰余定理 */\n\npair<ll, ll> CRT(ll a1, ll m1, ll a2, ll m2) {\n  auto eg = ext_gcd(m1, m2);\n  ll d = eg.first;\n  if ((a2 - a1) % d) return {0, -1};\n  ll m = m1 / d * m2;\n  ll r = ((a1 + m1 * ((__int128_t)(a2 - a1) / d * eg.second.first % (m2 / d))) % m + m) % m;\n  return {r, m};\n}\n\nint N, M, D, A[SIZE], R[SIZE][20];\n\n\nint main() {\n  scanf(\"%d%d%d\", &N, &M, &D);\n\n  for (int i = 0; i < M; i++) {\n    scanf(\"%d\", A + i);\n  }\n\n  ll now = N;\n\n  for (int i = 0; i < D; i++) {\n    pair<ll, ll> x = {INF, INF};\n    for (int j = 0; j < M; j++) {\n      scanf(\"%d\", R[i] + j);\n      if (R[i][j] == -1) continue;\n      if (x.first == INF)\n        x = {R[i][j], A[j]};\n      else if (x.second != -1) {\n        x = CRT(x.first, x.second, R[i][j], A[j]);\n      }\n    }\n\n    if (x.first == INF) continue;\n\n    if (x.second == -1) {\n      puts(\"-1\");\n      return 0;\n    }\n\n    ll next = now / x.second * x.second + x.first;\n    while (next > now) next -= x.second;\n\n    debug(x, now);\n\n    if (next < 0) {\n      puts(\"-1\");\n      return 0;\n    }\n\n    now = next;\n  }\n\n  printf(\"%lld\\n\", now);\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N, M, D;\n    vector<int> A;\n    vector< vector<int> > R;\n    void input() {\n        cin >> N >> M >> D;\n        A.resize(M); cin >> A;\n        R.resize(D);\n        for (int i = 0; i < D; i++) {\n            R[i].resize(M); cin >> R[i];\n        }\n    }\n\n    ll lcm(ll a, ll b) {\n        return a / __gcd(a, b) * b;\n    }\n\n    bool check(int n, int d) {\n        for (int i = 0; i < M; i++) {\n            if (n % A[i] != R[d][i]) return false;\n        }\n        return true;\n    }\n\n    void solve() {\n        ll L = 1;\n        for (int i = 0; i < M; i++) L = lcm(L, A[i]);\n\n        int m = 0;\n        for (int i = 0; i < M; i++) {\n            if (A[m] < A[i]) {\n                m = i;\n            }\n        }\n\n        ll x = N;\n        for (int d = 0; d < D; d++) {\n            int n = R[d][m];\n            if (n < 0) continue;\n            for (; ; n += A[m]) {\n                if (n > x) {\n                    cout << -1 << endl;\n                    return;\n                }\n                if (check(n, d)) {\n                    break;\n                }\n            }\n            x = (x - n) / L * L + n;\n        }\n        cout << x << endl;\n\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m, d;\n\tcin >> n >> m >> d;\n\tvector<ll> a(m);\n\tfor(int i = 0; i < m; ++i){ cin >> a[i]; }\n\tfor(int i = 0; i < d; ++i){\n\t\tvector<ll> b(m);\n\t\tfor(int j = 0; j < m; ++j){ cin >> b[j]; }\n\t\tif(b[0] < 0){ continue; }\n\t\tll mod = 1, x = 0;\n\t\tfor(int j = 0; x <= n && j < m; ++j){\n\t\t\tbool accept = false;\n\t\t\tfor(int k = 0; k < a[j]; ++k){\n\t\t\t\tconst ll t = a[j] * k + b[j];\n\t\t\t\tif(t <= n && t % mod == x){\n\t\t\t\t\taccept = true;\n\t\t\t\t\tmod *= a[j];\n\t\t\t\t\tx = t % mod;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!accept){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(x > n){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tconst ll t = n / mod;\n\t\tif(t * mod + x <= n){\n\t\t\tn = t * mod + x;\n\t\t}else{\n\t\t\tn = (t - 1) * mod + x;\n\t\t}\n\t}\n\tcout << n << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint extgcd(int a, int b, int& x, int& y){\n    int d=a;\n    if(b!=0){\n        d = extgcd(b,a%b,y,x);\n        y-=(a/b)*x;\n    }else{\n        x=1;y=0;\n    }\n    return d;\n}\n\nint mod_inverse(int a, int m){\n    int x, y;\n    extgcd(a,m,x,y);\n    return (m+x%m)%m;\n}\n\npair<int, int> linear_consequense(const vector<int>& a, const vector<int>& b, const vector<int>& m){\n   int x=0,M=1;\n\n   for(int i=0;i<a.size();++i){\n       if(b[i]==-1) continue;\n       int B=b[i]-a[i]*x, d=__gcd(m[i],1);\n       if(B%d!=0) return make_pair(0,-1);\n       int t = B / d * mod_inverse(1/d, m[i]/d) % (m[i]/d);\n       x = x + M * t;\n       M *= m[i] / d;\n   }\n   return make_pair(x%M,M);\n}\n\nint main() {\n\n    for(int n,m,d;cin>>n>>m>>d;){\n        vector<int> a(m);\n        for(int i=0;i<m;++i){\n            cin>>a[i];\n        }\n        vector<int> r(m);\n        vector<int> aa(m,1);\n        pair<int,int> aaa;\n        for(int i=0;i<d;++i){\n            for(int j=0;j<m;++j){\n                cin >> r[j];\n            }\n            aaa = linear_consequense(aa, r, a);\n            int p=n/aaa.second;\n            int q=n%aaa.second;\n            int k=(q-aaa.first+aaa.second) % aaa.second;\n            n=p*aaa.second-q-k;\n            if(n<0){\n                n=-1;\n                break;\n            }\n        }\n        cout << n << endl;\n    }\n    return 0;"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T>ostream&operator<<(ostream &o,const vector<T>&t){o<<'[';FOR(i,t){if(i!=t.begin())o<<',';o<<*i;}return o<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)output(a[i],i!=n-1?',':10);}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a;\n  x = 1; y = 0;\n  if (b) {\n    g = extgcd(b, a%b, y, x);\n    y -= (a/b) * x;\n  }\n  return g;\n}\n\nll ChineseRemainderTheorem(const vector<ll> &B, const vector<ll> &M) {\n  ll all = 1;\n  FOR(it, M) all*=*it;\n  ll res = 0;\n  REP(i,B.size()) {\n    ll x,y;\n    extgcd(M[i], all/M[i], x, y);\n    y = (y%all+all)%all;\n    res = (res%all + B[i]*y*(all/M[i]) % all + all) % all;\n    // assert(res >= 0);\n  }\n  return res;\n}\nvector<int> factorize(ll n) {  // O(√n)\n  vector<int> res;\n  for (ll i=2; i*i<=n; ++i) {\n    int r = 1;\n    while (n%i==0) {\n      n /= i;\n      r *= i;\n    }\n    if (r>1) {\n      res.push_back(r);\n    }\n  }\n  if (n!=1) res.push_back(n);\n  return res;\n}\n\nint a[10];\nint x[100][10];\n\nint main() {\n  int n,m,d;\n  while(input(n,m,d)) {\n    vector<vector<int> > facts;\n    REP(i,m) {\n      input(a[i]);\n      facts.push_back(factorize(a[i]));\n    }\n    REP(i,d)REP(j,m)input(x[i][j]);\n    bool ng = 0;\n    ll cur = n;\n    REP(i,d) {\n      map<int,int> mp;\n      REP(j,m) {\n        if (x[i][j] == -1) continue;\n        FOR(it, facts[j]) {\n          if (mp.count(*it) && mp[*it] != x[i][j] % *it) ng = 1;\n          mp[*it] = x[i][j] % *it;\n        }\n      }\n      FOR(it, mp) {\n        FOR(jt, mp) {\n          if (jt->first % it->first == 0 &&\n              (it->second % it->first != jt->second % it->first)) {\n            ng = 1;\n          }\n        }\n      }\n      if (ng) break;\n      vector<ll> v1,v2;\n      FOR(it, mp) {\n        bool f = 0;\n        FOR(jt, mp) {\n          if (it->first < jt->first && jt->first % it->first == 0)\n            f = 1;\n        }\n        if (!f) {\n          v1.push_back(it->second);\n          v2.push_back(it->first);\n        }\n      }\n\n      ll res = ChineseRemainderTheorem(v1,v2);\n      ll md = 1;\n      FOR(it,v2) md *=*it;\n      // cout << v1 << endl;\n      // cout << v2 << endl;\n      // cout << res << \" \" << md << endl;\n      // md*x + res <= cur\n      // x <= (cur - res) / md\n      if (res > cur) {\n        ng = 1;\n        break;\n      }\n      ll x = (cur - res) / md;\n      cur = x * md + res;\n      // cout << endl;\n    }\n    if (ng) cout << -1 << endl;\n    else cout << cur << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[2001][3];\nint n,k,m=1000003;\n\nint dfs(int p,int f){\n  if(dp[p][f])return dp[p][f];\n  if(p==n){\n    if(f==1)return 1;\n    return 0;\n  }\n  int nf;\n  if(f==-1)nf=0;\n  if(f==0)nf=2;\n  if(f==1)nf=2;\n  if(f==2)nf=1;\n  int res=0;\n  for(int i=1;i<=k&&p+i<=n;i++){\n    res=(res+dfs(p+i,nf))%m;\n  }\n  if(f==-1)return res;\n  return dp[p][f]=res;  \n}\n\nint main(){\n  while(cin>>n>>k,n){\n    memset(dp,0,sizeof(dp));\n    dfs(0,-1);\n    int ans=0;\n    for(int i=1;i<=k;i++)ans=(ans+dp[i][0]*i)%m;\n    cout<<ans*2%m<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-8;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<ll, ll> linear_congruence(const vector<ll>& A, const vector<ll>& B,\n                                 const vector<ll>& M) {\n  ll x = 0, m = 1;\n  for(ll i = 0; i < A.size(); i++){\n    if(B[i] == -1) continue;\n    ll a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0) return make_pair(0, -1);\n    ll t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  ll num_of_chopsticks;\n  int num_of_divisors;\n  int total_days;\n  while(~scanf(\"%lld %d %d\",\n               &num_of_chopsticks,\n               &num_of_divisors,\n               &total_days)){\n    vector<ll> divisors(num_of_divisors);\n    for(int div_i = 0; div_i < num_of_divisors; div_i++){\n      scanf(\"%lld\",&divisors[div_i]);\n    }\n    ll record[101][11];\n    for(int day = 0; day < total_days; day++){\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        scanf(\"%lld\",&record[day][div_i]);\n      }\n    }\n\n    vector<ll> A(num_of_divisors,1);\n    for(int day = 0; day < total_days; day++){\n      vector<ll> reminder;\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        reminder.push_back(record[day][div_i]);\n      }\n\n      pair<ll,ll> ans = linear_congruence(A,reminder,divisors);\n      if(ans.first > num_of_chopsticks){\n        num_of_chopsticks = -1;\n        break;\n      }\n      \n      ll upper = 1000000000LL;\n      ll lower = -1;\n      for(int round = 0; round < 50; round++){\n        ll mid = lower + (upper - lower) / 2LL;\n        if(ans.second * mid + ans.first > num_of_chopsticks){\n          upper = mid;\n        }\n        else{\n          lower = mid;\n        }\n      }\n      num_of_chopsticks = ans.second * lower + ans.first;\n\n      if(num_of_chopsticks < 0){\n              num_of_chopsticks = -1;\n        break;\n      }\n    }\n    printf(\"%lld\\n\",num_of_chopsticks);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nstruct BiconectedGraph{\n  typedef pair<int,int> P;\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void input(int m,int offset=0){\n    int a,b;\n    for(int i=0;i<m;i++){\n      cin>>a>>b;\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n  bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int v,int p,int &k){\n    ord[v]=low[v]=k;\n    ++k;\n    for(int u:G[v]){\n      if(u==p) continue;\n      if(ord[u]>=0){\n\tlow[v]=min(low[v],ord[u]);\n      }else{\n\tdfs(u,v,k);\n\tlow[v]=min(low[v],low[u]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int v){\n    C[c].push_back(v);\n    belong[v]=c;\n    for(int u:G[v]){\n      if(belong[u]>=0||is_bridge(u,v)) continue;\n      fill_component(c,u);\n    }\n  }\n  \n  void add_component(int v,int &k){\n    if(belong[v]>=0) return;\n    fill_component(k++,v);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int v=0;v<n;v++){\n      if(ord[v]>=0) continue;\n      dfs(v,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int v=0;v<n;v++) add_component(v,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n//END CUT HERE\n\nint n,m,w[100009],x[100009],y[1000009];\n\nsigned main(){\n  cin>>n>>m;\n  r(i,n)cin>>w[i];\n  BiconectedGraph bcc(n);\n  r(i,m){\n    cin>>x[i]>>y[i];\n    x[i]--;y[i]--;\n    bcc.add_edge(x[i],y[i]);\n  }\n  bcc.build();\n  int cnt=0;\n  map<int,int>M,count,wei;\n  set<int>st;\n  r(i,n){\n    if(!st.count(bcc.belong[i])){\n      st.insert(bcc.belong[i]);\n      count[cnt]++;\n      wei[cnt]+=w[i];\n      M[bcc.belong[i]]=cnt++;\n    }\n    else{\n      w[M[bcc.belong[i]]]+=w[i];\n      count[M[bcc.belong[i]]]++;\n    }\n  }\n  \n  BiconectedGraph B(cnt+1);\n  int root = M[0];\n  r(i,m){\n    if(bcc.belong[x[i]]==bcc.belong[y[i]])continue;\n    B.add_edge(M[bcc.belong[x[i]]],M[bcc.belong[y[i]]]);\n  }\n  r(i,cnt){\n    if(count[i]>1){\n      B.add_edge(cnt,i);\n    }\n  }\n  B.build();\n  vector<vector<int> >v;\n  st.clear();\n  map<int,int>wei2;\n  int cnt2=0;\n  r(i,cnt+1){\n    if(!st.count(B.belong[i])){\n      st.insert(B.belong[i]);\n      count[cnt2]++;\n      wei2[cnt2]+=wei[i];\n      M[B.belong[i]]=cnt++;\n    }\n    else{\n      w[M[B.belong[i]]]+=wei[i];\n      count[M[B.belong[i]]]++;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint cal(int n,P p){\n  while(n%p.first!=p.second&&n>=0)n--;\n  return n;\n}\n\nint main(){\n  int n,m,d,a[10];\n  cin>>n>>m>>d;\n  for(int i=0;i<m;i++){\n    cin>>a[i];\n  }\n  P r[100][10];\n  for(int i=0;i<d;i++){\n    for(int j=0;j<m;j++){\n      cin>>r[i][j].second;\n      r[i][j].first=a[j];\n    }\n    sort(r[i],r[i]+m);\n    reverse(r[i],r[i]+m);\n    vector<int> v;\n    int u=1e6;\n    for(int j=0;j<m;j++){\n      if(r[i][j].second==-1)continue;\n      if(j){\n\tvector<int> nv;\n\tfor(int k=0;k<(int)v.size();k++){\n\t  if(v[k]%r[i][j].first==r[i][j].second)nv.push_back(v[k]);\n\t}\n\tv=nv;\n      }\n      else {\n\tint p=cal(n,r[i][j]);\n\twhile((int)v.size()<u&&p>=0){\n\t  v.push_back(p);\n\t  p-=r[i][j].first;\n\t}\n      }\n    }\n    if(v.size())n=v[0];\n    else if(r[i][0].second!=-1)n=-1;\n  }\n  cout<<n<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % (M[i]/d);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair(x%m, m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m),e(m);\n  rep(i,m)cin >> a[i], e[i] = 1;\n\n  rep(i,d){\n    vi r(m);\n    rep(j,m)cin >> r[j];\n    if(r[0]<0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod<0){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    ll tmp = (n/mod) * mod + b;\n    if(n<tmp)tmp -= mod;\n    if(tmp<0){\n      cout << -1 << endl;\n      return 0;\n    }\n    n = tmp;\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll Int;\n\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nint main(){\n  int i,j,k;\n  ll n,m,d;\n  cin>>n>>m>>d;\n  vector<ll> a(m),r(m),aa(m),gcda(m);\n  rep(i,m)\n    cin>>a[i];\n  aa[0]=1;\n  rep(i,m-1)\n    aa[i+1]=aa[i]*a[i]/__gcd(aa[i],a[i]);\n  rep(i,m)\n    gcda[i]=__gcd(aa[i],a[i]);\n  ll dd;\n  rep(i,d){\n    rep(j,m)\n      cin>>r[j];\n    rep(j,m){\n      if(r[j]<0)continue;\n      if((n+a[j]-r[j])%a[j]){\n        ll nn=(n+a[j]-r[j])%a[j];\n        if(nn%gcda[j]){\n          cout<<-1<<endl;\n          return 0;\n        }\n        ll hoge,hogee;\n        extgcd(a[j],aa[j],hogee,hoge);\n        hoge=hoge % (a[j]/gcda[j]) + (a[j]/gcda[j]);\n        n-=aa[j]*( hoge %(a[j]/gcda[j]) );\n        if(n<0){\n          cout<<-1<<endl;\n          return 0;\n        }\n      }\n    //  cout<<\"->\"<<n<<\":\"<<r[j]<<\"mod\"<<a[j]<<endl;\n    }\n  }\n  cout<<n<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll Int;\n\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nint main(){\n  int i,j,k;\n  ll n,m,d;\n  cin>>n>>m>>d;\n  vector<ll> a(m),r(m),aa(m),gcda(m);\n  rep(i,m)\n    cin>>a[i];\n  aa[0]=1;\n  rep(i,m-1)\n    aa[i+1]=aa[i]*a[i]/__gcd(aa[i],a[i]);\n  rep(i,m)\n    gcda[i]=__gcd(aa[i],a[i]);\n  ll dd;\n  rep(i,d){\n    rep(j,m)\n      cin>>r[j];\n    rep(j,m){\n      if(r[j]<0)continue;\n      if((n-r[j])%a[j]){\n        ll nn=(n-r[j])%a[j];\n        if(nn%gcda[j]){\n          cout<<-1<<endl;\n          return 0;\n        }\n        ll hoge,hogee;\n        extgcd(a[j],aa[j],hogee,hoge);\n        hoge=hoge % (a[j]/gcda[j]) + (a[j]/gcda[j]);\n        n-=aa[j]*( hoge %(a[j]/gcda[j]) );\n        if(n<0){\n          cout<<-1<<endl;\n          return 0;\n        }\n      }\n    //  cout<<\"->\"<<n<<\":\"<<r[j]<<\"mod\"<<a[j]<<endl;\n    }\n  }\n  cout<<n<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint gcd(int a, int b){\n  return b?gcd(b,a%b):a;\n}\n\nint extgcd(int a, int b, int& x, int& y){\n  int d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nint mod_inverse(int a, int m){\n  int x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  int x = 0, m = 1;\n  rep(i,A.size()){\n    int a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    int t = b/d * mod_inverse(a/d, M[i]/d) % (M[i]/d);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair(x%m, m);\n}\n\nint main(){\n  int n,m,d;\n  cin >> n >> m >> d;\n  vi a(m),e(m);\n  rep(i,m)cin >> a[i], e[i] = 1;\n\n  rep(i,d){\n    vi r(m);\n    rep(j,m)cin >> r[j];\n    if(r[0]<0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    int b = ans.first, mod = ans.second;\n    if(b == 0){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    int tmp = (n/mod) * mod + b;\n    if(n<tmp)tmp -= mod;\n    if(tmp<0){\n      cout << -1 << endl;\n      return 0;\n    }\n    n = tmp;\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\nlong long gcd(long long a, long long b) {\n    if (b == 0) return a;\n    else return gcd(b, a % b);\n}\n\nlong long lcm(long long a, long long b) {\n    long long g = gcd(a, b);\n    return a * b / g;\n}\n\nlong long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n\ninline long long inv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a/b;\n        a -= t*b; swap(a, b);\n        u -= t*v; swap(u, v);\n    }\n    return mod(u, m);\n}\n\npair<long long, long long> ChineseRem(vector<long long> vb, vector<long long> vm) {\n    long long x = 0, m = 1, a, b, d;\n    for (int i = 0; i < vb.size(); ++i) {\n        a = m, b = vb[i] - x, d = gcd(vm[i], a);\n        if (b % d != 0) return make_pair(0, -1);\n        long long t = mod(b/d * inv(a/d, vm[i]/d), vm[i]/d);\n        x += m * t;\n        m *= vm[i]/d;\n    }\n    return make_pair(x % m, m);\n}\n\n\n\n\nint N, M, D;\nint A[12];\nint r;\n\nint main() {\n    while (cin >> N >> M >> D) {\n        for (int i = 0; i < M; ++i) cin >> A[i];\n        \n        bool ok = true;\n        for (int i = 0; i < D; ++i) {\n            vector<ll> vb, vm;\n            for (int j = 0; j < M; ++j) {\n                cin >> r;\n                if (r == -1) continue;\n                vb.PB(r);\n                vm.PB(A[j]);\n            }\n            \n            pint res = ChineseRem(vb, vm);\n            int rem = res.first;\n            int mo = res.second;\n//            \n//            COUT(vb); COUT(vm);\n//            COUT(res);\n            \n            if (mo == -1) ok = false;\n            if (N < rem) ok = false;\n            \n            int NN = N - rem;\n            int r = NN%mo;\n            N = N - r;\n        }\n        \n        if (ok) cout << N << endl;\n        else cout << -1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nInt r[111][111];\n\nInt mod_pow(Int x,Int y,Int mod){\n  Int res = 1;\n  while(y){\n    if(y&1) res = res * x % mod;\n    x = x * x % mod;\n    y /= 2;\n  }\n  return res;\n}\n\nInt extgcd(Int a,Int b,Int &x,Int &y){\n  Int d = a;\n  if(b != 0){\n    d = extgcd(b, a%b, y,x);\n    y -= (a/b) * x;\n  } else{\n    x = 1, y = 0;\n  }\n  return d;\n}\n\nInt mod_inverse(Int a,Int mod){\n  Int x,y;\n  extgcd(a,mod,x,y);\n  return (mod+x%mod)%mod;\n  //return mod_pow(x, mod-2, mod);\n\n}\n\npair<Int, Int> linear_congruence(const vector<Int> &A, const vector<Int> &B,const vector<Int> &M){\n  Int x = 0 ,m = 1;\n  for(Int i=0;i<(Int)A.size();i++){\n    Int a = A[i] * m , b = B[i] - A[i] * x, d = __gcd(M[i], a);\n    if(b%d!=0) return make_pair(0,-1);\n    Int t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i]/d;\n  }\n  return make_pair(x%m,m);\n}\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  Int n,m,d;\n  cin>>n>>m>>d;\n  vector<Int> a(m);\n  for(Int i=0;i<m;i++) cin>>a[i];\n\n  for(Int i=0;i<d;i++)\n    for(Int j=0;j<m;j++)\n      cin>>r[i][j];\n\n  for(Int i=0;i<d;i++){\n    vector<Int> A,B,M;\n    for(Int j=0;j<m;j++){\n      if(r[i][j]<0) continue;\n      A.emplace_back(1);\n      B.emplace_back(r[i][j]);\n      M.emplace_back(a[j]);\n    }\n    auto p=linear_congruence(A,B,M);\n    //cout<<i<<\":\"<<p.first<<\" \"<<p.second<<endl;\n    if(p.second<0){\n      n=-1;\n      break;\n    }\n    if(p.second<0) p.first+=p.second;\n    n=(n-p.first)/p.second*p.second+p.first;\n  }\n  \n  cout<<n<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-8;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint gcd(int a, int b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nint extgcd(int a, int b, int &x, int &y) {\n  int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nint mod_inverse(int a, int m){\n  int x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<int, int> linear_congruence(const vector<int>& A, const vector<int>& B,\n                                 const vector<int>& M) {\n  int x = 0, m = 1;\n  for(int i = 0; i < A.size(); i++){\n    if(B[i] == -1) continue;\n    int a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0) return make_pair(0, -1);\n    int t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  int num_of_chopsticks;\n  int num_of_divisors;\n  int total_days;\n  while(~scanf(\"%d %d %d\",\n               &num_of_chopsticks,\n               &num_of_divisors,\n               &total_days)){\n    vector<int> divisors(num_of_divisors);\n    for(int div_i = 0; div_i < num_of_divisors; div_i++){\n      scanf(\"%d\",&divisors[div_i]);\n    }\n    int record[101][11];\n    for(int day = 0; day < total_days; day++){\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        scanf(\"%d\",&record[day][div_i]);\n      }\n    }\n\n    vector<int> A(num_of_divisors,1);\n    for(int day = 0; day < total_days; day++){\n      vector<int> reminder;\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        reminder.push_back(record[day][div_i]);\n      }\n\n      pair<int,int> ans = linear_congruence(A,reminder,divisors);\n      num_of_chopsticks = (num_of_chopsticks - ans.first) / ans.second + ans.first;\n      if(ans.second == -1 || num_of_chopsticks < 0) {\n        num_of_chopsticks = -1;\n        break;\n      }\n    }\n    printf(\"%d\\n\",num_of_chopsticks);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll hoge = M[i]/d;\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % hoge;\n    x = x+m*t;\n    m *= M[i]/d;\n    assert(m>=0);\n  }\n  return make_pair( (x%m + m) % m , m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      ll  tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod==-1){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    ll tmp = (n/mod+100) * mod + b;\n    while(tmp<n)tmp += mod;\n    while(n<tmp)tmp -= mod;\n    /*\n    if(tmp<0){\n      cout << -1 << endl;\n      return 0;\n    }\n    */\n    n = tmp;\n\n  }\n\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,0ULL-1);\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % (M[i]/d);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair( (x%m + m) %m , m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      long long  tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod==0ULL-1){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    //cerr << b << \" \" << mod << endl;\n    if(n<mod)n = b;\n    else{\n      long long tmp = (n/mod+1) * mod + b;\n      while(tmp<(long long)n)tmp += (long long)mod;\n      while((long long)n<tmp)tmp -= (long long)mod;\n      if(tmp<0){\n\tcout << -1 << endl;\n\treturn 0;\n      }\n      n = tmp;\n    }\n\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T>ostream&operator<<(ostream &o,const vector<T>&t){o<<'[';FOR(i,t){if(i!=t.begin())o<<',';o<<*i;}return o<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)output(a[i],i!=n-1?',':10);}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a;\n  x = 1; y = 0;\n  if (b) {\n    g = extgcd(b, a%b, y, x);\n    y -= (a/b) * x;\n  }\n  return g;\n}\n\nll mulmod(ll a, ll n, ll m) {\n  ll res = 0;\n  while(n>=1) {\n    if (n % 2 == 1)\n      res = (res + a) % m;\n    a = a*2%m;\n    n >>= 1;\n  }\n  return res;\n}\n\nll ChineseRemainderTheorem(const vector<ll> &B, const vector<ll> &M) {\n  ll all = 1;\n  FOR(it, M) all*=*it;\n  ll res = 0;\n  REP(i,B.size()) {\n    ll x,y;\n    extgcd(M[i], all/M[i], x, y);\n    y = (y%all+all)%all;\n    res = (res%all + mulmod(mulmod(B[i],y,all),(all/M[i]),all) % all + all) % all;\n    // assert(res >= 0);\n  }\n  return res;\n}\nvector<int> factorize(ll n) {  // O(√n)\n  vector<int> res;\n  for (ll i=2; i*i<=n; ++i) {\n    int r = 1;\n    while (n%i==0) {\n      n /= i;\n      r *= i;\n    }\n    if (r>1) {\n      res.push_back(r);\n    }\n  }\n  if (n!=1) res.push_back(n);\n  return res;\n}\n\nint a[10];\nint x[100][10];\n\nint main() {\n  int n,m,d;\n  while(input(n,m,d)) {\n    vector<vector<int> > facts;\n    REP(i,m) {\n      input(a[i]);\n      facts.push_back(factorize(a[i]));\n    }\n    REP(i,d)REP(j,m)input(x[i][j]);\n    bool ng = 0;\n    ll cur = n;\n    REP(i,d) {\n      map<int,int> mp;\n      REP(j,m) {\n        if (x[i][j] == -1) continue;\n        FOR(it, facts[j]) {\n          if (mp.count(*it) && mp[*it] != x[i][j] % *it) ng = 1;\n          mp[*it] = x[i][j] % *it;\n        }\n      }\n      FOR(it, mp) {\n        FOR(jt, mp) {\n          if (jt->first % it->first == 0 &&\n              (it->second % it->first != jt->second % it->first)) {\n            ng = 1;\n          }\n        }\n      }\n      if (ng) break;\n      vector<ll> v1,v2;\n      FOR(it, mp) {\n        bool f = 0;\n        FOR(jt, mp) {\n          if (it->first < jt->first && jt->first % it->first == 0)\n            f = 1;\n        }\n        if (!f) {\n          v1.push_back(it->second);\n          v2.push_back(it->first);\n        }\n      }\n      ll res = ChineseRemainderTheorem(v1,v2);\n      ll md = 1;\n      FOR(it,v2) md *=*it;\n      FOR(it, v2) {\n        FOR(jt, v2) {\n          if (*it != *jt)\n            assert(__gcd(*it,*jt) == 1);\n        }\n      }\n      REP(i,v1.size()) {\n        assert(res % v2[i] == v1[i]);\n      }\n      \n      // cout << v1 << endl;\n      // cout << v2 << endl;\n      // cout << res << \" \" << md << endl;\n      // md*x + res <= cur\n      // x <= (cur - res) / md\n      if (res > cur) {\n        ng = 1;\n        break;\n      }\n      ll x = (cur - res) / md;\n      cur = x * md + res;\n      // cout << endl;\n    }\n    if (ng) cout << -1 << endl;\n    else cout << cur << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T>ostream&operator<<(ostream &o,const vector<T>&t){o<<'[';FOR(i,t){if(i!=t.begin())o<<',';o<<*i;}return o<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)output(a[i],i!=n-1?',':10);}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a;\n  x = 1; y = 0;\n  if (b) {\n    g = extgcd(b, a%b, y, x);\n    y -= (a/b) * x;\n  }\n  return g;\n}\n\nll ChineseRemainderTheorem(const vector<ll> &B, const vector<ll> &M) {\n  ll all = 1;\n  FOR(it, M) all*=*it;\n  ll res = 0;\n  REP(i,B.size()) {\n    ll x,y;\n    extgcd(M[i], all/M[i], x, y);\n    y = (y+all)%all;\n    res = (res + B[i]*y*(all/M[i]) % all) % all;\n    assert(res >= 0);\n  }\n  return res;\n}\nvector<int> factorize(ll n) {  // O(√n)\n  vector<int> res;\n  for (ll i=2; i*i<=n; ++i) {\n    int r = 1;\n    while (n%i==0) {\n      n /= i;\n      r *= i;\n    }\n    if (r>1) {\n      res.push_back(r);\n    }\n  }\n  if (n!=1) res.push_back(n);\n  return res;\n}\n\nint a[10];\nint main() {\n  int n,m,d;\n  while(input(n,m,d)) {\n    vector<vector<int> > facts;\n    REP(i,m) {\n      input(a[i]);\n      facts.push_back(factorize(a[i]));\n    }\n    bool ng = 0;\n    ll cur = n;\n    REP(i,d) {\n      map<int,int> mp;\n      REP(j,m) {\n        int x;\n        input(x);\n        if (x == -1) continue;\n        FOR(it, facts[j]) {\n          if (mp.count(*it) && mp[*it] != x % *it) ng = 1;\n          mp[*it] = x % *it;\n        }\n      }\n      FOR(it, mp) {\n        FOR(jt, mp) {\n          if (jt->first % it->first == 0 &&\n              (it->second % it->first != jt->second % it->first)) {\n            ng = 1;\n          }\n        }\n      }\n      vector<ll> v1,v2;\n      FOR(it, mp) {\n        bool f = 0;\n        FOR(jt, mp) {\n          if (it->first < jt->first && jt->first % it->first == 0)\n            f = 1;\n        }\n        if (!f) {\n          v1.push_back(it->second);\n          v2.push_back(it->first);\n        }\n      }\n\n      ll res = ChineseRemainderTheorem(v1,v2);\n      ll md = 1;\n      FOR(it,v2) md *=*it;\n      // cout << v1 << endl;\n      // cout << v2 << endl;\n      // cout << res << \" \" << md << endl;\n      // md*x + res <= cur\n      // x <= (cur - res) / md\n      if (res > cur) ng = 1;\n      ll x = (cur - res) / md;\n      cur = x * md + res;\n      // cout << endl;\n    }\n    if (ng) cout << -1 << endl;\n    else cout << cur << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int64_t i = 0; i < (int64_t)(n); i++)\n#define irep(i, n) for (int64_t i = 0; i <= (int64_t)(n); i++)\n#define rrep(i, n) for (int64_t i = (n)-1; i >= 0; i--)\n#define rirep(i, n) for (int64_t i = n; i >= 0; i--)\n\n#define chmax(a, b) (a) = max(a, b)\n#define chmin(a, b) (a) = min(a, b)\n\ntuple<int64_t, int64_t, int64_t> xgcd(int64_t a, int64_t b) {\n  if (b == 0) {\n    return make_tuple(1, 0, a);\n  }\n  int64_t z, w, d;\n  tie(z, w, d) = xgcd(b, a % b);\n  return make_tuple(w, z - a / b * w, d);\n}\n\ntuple<int64_t, int64_t> chinese_rem(int64_t a1, int64_t a2, int64_t m1,\n                                    int64_t m2) {\n  int64_t x, y, d;\n  tie(x, y, d) = xgcd(m1, m2);\n\n  const int64_t c = a2 - a1;\n  if (c % d != 0) {\n    return make_tuple(0, 0);\n  }\n  const int64_t tmp = c / d * x % (m2 / d);\n  const int64_t sln = a1 + tmp * m1;\n  const int64_t M = m1 / d * m2;\n\n  return make_tuple((sln % M + M) % M, M);\n}\n\ntuple<int64_t, int64_t> chinese_rem(const vector<int64_t>& a,\n                                    const vector<int64_t>& MOD) {\n  if (a.size() != MOD.size()) {\n    stringstream msg;\n    msg << \"a.size() is \" << a.size() << \", but MOD.size()\" << MOD.size()\n        << \"\\n\";\n    throw msg.str();\n  }\n  int64_t sln = 0, M = 1;\n  for (size_t i = 0; i < a.size(); i++) {\n    if (a[i] == -1) {\n      continue;\n    }\n    tie(sln, M) = chinese_rem(sln, a[i], M, MOD[i]);\n    if (M == 0) {\n      return make_tuple(0, 0);\n    }\n  }\n\n  return make_tuple(sln, M);\n}\n\nint main() {\n  int64_t N, M, D;\n  cin >> N >> M >> D;\n\n  vector<int64_t> a(M);\n  rep(i, M) { cin >> a[i]; }\n\n  rep(i, D) {\n    vector<int64_t> r(M);\n    rep(i, M) { cin >> r[i]; }\n\n    int64_t rem, m;\n    tie(rem, m) = chinese_rem(r, a);\n    if (m == 0 || N < rem) {\n      N = -1;\n      break;\n    }\n\n    N = rem + (N - rem) / m * m;\n  }\n\n  cout << N << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.D\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\tios_base::sync_with_stdio(0);\n\tint n, m, d; cin >> n >> m >> d;\n\tvector<int> a(m, 0 );\n\n\trep (i, m ) cin >> a[i];\n\tvector<vector<int> > r(d, vector<int> (m, 0 ) );\n\trep (i, d ) rep (j, m ) cin >> r[i][j];\n\n\tvector<int> cand; cand.clear();\n\tcand.push_back (n );\n\n\tbool ok = true;\n\trep (i, d ){\n\t\tvector<int> next; next.clear();\n\t\trep (j, cand.size() ){\n\t\t\tfor (int l = cand[j]; l >= 0; l-- ){\n\t\t\t\tint cnt = 0;\n\t\t\t\trep (k, m ){\n\t\t\t\t\tif (r[i][k] != -1 ){\n\t\t\t\t\t\tif (l % a[k] == r[i][k] ) cnt++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t} // end if\n\t\t\t\t} // end rep\n\t\t\t\tif (cnt == m ){\n\t\t\t\t\tnext.push_back (l );\n\t\t\t\t\tbreak;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t\tif (!next.empty() ) break;\n\t\t} // end rep\n\t\tif (next.empty() ){\n\t\t\tok = false;\n\t\t\tbreak;\n\t\t} // end if\n\t\tcand = next;\n\t} // end rep\n\n\tcout << (ok ? cand[0] : -1 ) << endl;\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N, M, D;\n    vector<int> A;\n    vector< vector<int> > R;\n    void input() {\n        cin >> N >> M >> D;\n        A.resize(M); cin >> A;\n        R.resize(D);\n        for (int i = 0; i < D; i++) {\n            R[i].resize(M); cin >> R[i];\n        }\n    }\n\n    ll lcm(ll a, ll b) {\n        return a / __gcd(a, b) * b;\n    }\n\n    bool check(int n, int d) {\n        for (int i = 0; i < M; i++) {\n            if (R[d][i] < 0) continue;\n            if (n % A[i] != R[d][i]) return false;\n        }\n        return true;\n    }\n\n    void solve() {\n\n        ll x = N;\n        for (int d = 0; d < D; d++) {\n            int a = 0;\n            int m = -1;\n            ll L = 1;\n            for (int i = 0; i < M; i++) {\n                if (R[d][i] < 0) continue;\n                L = lcm(L, A[i]);\n                if (a < A[i]) {\n                    a = A[i];\n                    m = i;\n                }\n            }\n            if (m < 0) continue;\n            int n = R[d][m];\n            for (; ; n += A[m]) {\n                if (n > x) {\n                    cout << -1 << endl;\n                    return;\n                }\n                if (check(n, d)) {\n                    break;\n                }\n            }\n            x = (x - n) / L * L + n;\n        }\n        cout << x << endl;\n\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define LL long long\n\nlong long gcd(long long a,long long b){\n  if(b==0)return a;\n  if(a<b)return gcd(b,a);\n  return gcd(b,a%b);\n}\n\nlong long lcm(long long a,long long b){\n  return a*b/gcd(a,b);\n}\n\n// lcm of several variables\nlong long lcm_n(int n,long long *a){\n  LL ret=a[0];\n  for(int i=0;i<n-1;i++){\n    ret=lcm(ret,a[i+1]);\n  }\n  return ret;\n}\n\n// output the smallest non-negative integer N s.t. N%quots[i]=rems[i]\n// if contradiction occurs, output -1\nlong long reminder(int n,long long *rems,long long *quots){\n  if(n==1)return rems[0];\n  long long x1,x2,y1,y2;\n  x1=rems[0];\n  y1=quots[0];\n  for(int i=0;i<n-1;i++){\n    x2=rems[i+1];\n    y2=quots[i+1];\n    for(int j=0;j<y2;j++){\n      if((x1+j*y1)%y2==x2){\n\tx1=(x1+j*y1)%lcm(y1,y2);\n\ty1=lcm(y1,y2);\n\tbreak;\n      }\n      if(j==y2-1)return -1;\n    }\n  }\n  return x1;\n}\n\nLL n,m,d;\nLL a[10],adum[10];\nLL r[100][10],rdum[10];\n\nint main(){\n  cin>>n>>m>>d;\n  REP(i,m)\n    cin>>a[i];\n  REP(i,d){\n    REP(j,m)\n      cin>>r[i][j];\n  }\n  REP(i,d){\n    int num=0;\n    REP(j,m){\n      if(r[i][j]>=0){\n\tadum[num]=a[j];\n\trdum[num]=r[i][j];\n\tnum++;\n      }\n    }\n    if(!num)continue;\n    LL ret=reminder(num,rdum,adum);\n    if(ret<0 || n<ret){\n      n=-1;\n      break;\n    }\n    n=ret+lcm_n(num,adum)*((n-ret)/lcm_n(num,adum));\n  }\n\n  cout<<n<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dump(x) cout << (#x) << \" = \" << (x) << \", \";\nusing namespace std;\ntypedef long long lli;\n\nlli gcd(lli a, lli b){\n  if(b == 0) return a;\n  return gcd(b, a % b);\n}\n\nlli extgcd(lli a, lli b, lli& x, lli& y){\n  lli d = a;\n  if(b != 0){\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nlli mod_inverse(lli a, lli m){\n  lli x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<lli, lli> linear_congruece(const vector<lli>& A, const vector<lli>& B, const vector<lli>& M){\n  lli x = 0, m =1;\n  for(lli i = 0; i < A.size(); ++i){\n    lli a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0)return make_pair(0, -1);\n    lli t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  lli n, m, d;\n  cin >> n >> m >> d;\n  vector<lli> A(m,1), M;\n  for(lli i = 0; i < m; ++i){\n    lli tmp;\n    cin >> tmp;\n    M.push_back(tmp);\n  }\n  for(lli i = 0; i < d; ++i){\n    //dump(i);dump(d);\n    vector<lli> B;\n    bool f2 = false;\n\n    for(lli j = 0; j < m; ++j){\n      lli tmp;\n      cin >> tmp;\n      B.push_back(tmp);\n      if(tmp > 0) f2 = true;\n    }\n\n    if(B[0] < 0 || n < 0 || n == 0 && f2) {\n      if(n == 0 && f2) n = -1;\n      continue;\n    }\n\n    pair<lli, lli> res = linear_congruece(A, B, M);\n\n    if(res.second == -1){\n      n = -1;\n      break;\n    }\n    \n    lli modn = n % res.second;\n    lli mod = res.second;\n    lli modnext = res.first;\n    /*\n    dump(n);\n    dump(modn);\n    */\n    while(modnext < 0) modnext += mod;\n    //modnext = (modnext + (llabs(modnext) / mod + 1) * mod) % mod;\n    if(modn >= modnext) n -= modn - modnext;\n    else {\n      n -= mod;\n      n += modnext - modn;\n    }\n\n    /*\n    dump(modnext);\n    dump(mod);\n    dump(n);\n    cout << endl;\n    */\n    \n  }\n  cout << (n < 0 ? -1 : n) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < int(Y);++(X))\n#define rrep(X,Y) for (int (X) = int(Y-1);(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll Int;\nll INF=1ll<<45;\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nint main(){\n  int i,j,k;\n  ll n,m,d;\n  cin>>n>>m>>d;\n  vector<ll> a(m),r(m),lcma(m+1);\n  vector<vector<ll > > subs(m);\n  rep(i,m)\n    cin>>a[i];\n  lcma[0]=1;\n  rep(i,m)\n    lcma[i+1]=lcma[i]*a[i]/__gcd(lcma[i],a[i]);\n//  rep(i,m)\n//    gcda[i]=__gcd(lcma[i],a[i]);\n  rep(i,m){\n    subs[i].resize(a[i],INF);\n    rep(j,a[i]){\n      ll &tmp=subs[i][j*lcma[i]%a[i]];\n      tmp=min(tmp,j*lcma[i]);\n    }\n//rep(j,a[i])cout<<subs[i][j]<<\",\";cout<<endl;\n  }\n  ll dd;\n  rep(i,d){\n    ll nnn=n,lcms=1,subst;\n    rep(j,m)\n      cin>>r[j];\n    rep(j,m){\n      if(r[j]<0)continue;\n      ll nn=(n+a[j]-r[j])%a[j];\n      subst=INF;\n      rep(k,a[j])\n        if(k*lcms%a[j]==nn){\n          subst=k*lcms;\n          break;\n        }\n      if(subst==INF){\n        cout<<-1<<endl;\n        return 0;\n      }\n      n-=subst;\n      lcms*=a[j]/__gcd(a[j],lcms);\n      n+=(nnn-n)/lcms*lcms;\n      if(n<0){\n        cout<<-1<<endl;\n        return 0;\n      }\n //     cout<<\"->\"<<n<<\":\"<<r[j]<<\"mod\"<<a[j]<<endl;\n    }\n  }\n  cout<<(n<0?-1:n)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ax+by = 1 になる x, y を求める\nll extgcd (ll a, ll b, ll &x, ll &y ){\n\tll d = a;\n\tif (b != 0 ){\n\t\td = extgcd (b, a%b, y, x ); y -= (a/b)*x;\n\t}else{\n\t\tx = 1LL; y = 0LL;\n\t} // end if\n\n\treturn d;\n}\n\nll mod_inverse (ll a, ll m ){\n\tll x, y;\n\textgcd (a, m, x, y );\n\n\treturn (m + x % m ) % m;\n}\nconst int MAX_D = 105;\nconst int MAX_M = 12;\n\nint a[MAX_M];\nint r[MAX_D][MAX_M];\nll n_[MAX_M];\nll u[MAX_M];\n\nbool used[MAX_M];\nvoid used_ai (int id, int m ){\n\tfill (used, used + MAX_M, true );\n\n\trep (i, m ){\n\t\tif (!used[i] ) continue;\n\t\tif (r[id][i] == -1 ){\n\t\t\tused[i] = false;\n\t\t\tcontinue;\n\t\t} // end if\n\t\tfor (int j = i+1; j < m; j++ ){\n\t\t\tif (r[id][j] == -1 ){\n\t\t\t\tused[j] = false;\n\t\t\t\tcontinue;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end rep\n}\n\nint chinese_reminder_theorem (int di, int m, int curr ){\n\n\tmemset (n_, 0LL, sizeof (n_ ) );\n\tmemset (u, 0LL, sizeof (u ) );\n\n\tll N = 1LL;\n\trep (i, m ) if (used[i]  ) N *= (ll)a[i];\n\n\tif (N == 1LL ) return curr;\n\n\trep (i, m ) if (used[i] ) n_[i] = N/(ll)a[i];\n\trep (i, m ) if (used[i] ) u[i] = mod_inverse (n_[i], (ll)a[i] );\n\n\tll res = 0LL;\n\trep (i, m ) if (used[i] ) res += n_[i]*u[i]*(ll)r[di][i];\n\n\tres %= N;\n\n\treturn (res != 0LL ? (int)res : -1 );\t\t\t\n}\n\nvoid calc_factor(int d, int m ){\n\trep (i, m ){\n\t\tfor (int j = i + 1; j < m; j++ ){\n\t\t\tint g = __gcd(a[i], a[j] );\n\t\t\tif (g != 1 ){\n\t\t\t\ta[i] /= g;\n\t\t\t\ta[j] /= g;\n\t\t\t\trep (k, m ){\n\t\t\t\t\tif (r[k][i] != -1 )\n\t\t\t\t\t\tr[k][i] %= a[i];\n\t\t\t\t\tif (r[k][j] != -1 )\n\t\t\t\t\t\tr[k][j] %= a[j];\n\t\t\t\t} // end rep\n\t\t\t} // end if\n\t\t} // end for\n\t} // end rep\n}\n\nint main()\n{\n\tmemset (a, 0, sizeof (a ) );\n\tmemset (r, -1, sizeof (r ) );\n\n\tios_base::sync_with_stdio(0);\n\tint n, m, d; cin >> n >> m >> d;\n\trep (i, m ) cin >> a[i];\n\trep (i, d ) rep (j, m ) cin >> r[i][j];\n\n\tcalc_factor(d, m );\n\tint res = n;\n\trep (i, d ){\n\t\tused_ai (i, m );\n\t\tint curr = chinese_reminder_theorem (i, m, res );\n\t\tif (curr > res ){\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}else{\n\t\t\tres = min (res, curr );\n\t\t} // end if\n\t} // end rep\n\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % (M[i]/d);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair(x%m, m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      ll tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    ll b = ans.first, mod = ans.second;\n    if(mod<0){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    ll tmp = (n/mod + 1) * mod + b;\n    while(n<tmp)tmp -= mod;\n    if(tmp<0){\n      cout << -1 << endl;\n      return 0;\n    }\n    n = tmp;\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\ntypedef long long ll;\nstruct NT{\n  ll m;  // mod\n  vector<bool>ismrime;\n  vector<ll> euler;\n  vector<ll> fact;\n\n  NT(ll MOD){\n    m=MOD;\n    fact.resize(500005);\n    fact[0]=1;\n    for(ll i=1;i<500005;i++){\n      fact[i]=(fact[i-1]*i)%MOD;\n    }\n  }\n\n  void eratos(int n){\n    ismrime.resize(n+1);\n    for(int i=0;i<=n;i++) ismrime[i]=true;\n    ismrime[0]=0;\n    ismrime[1]=0;\n    for(int i=2;i<=n;i++){\n      if(ismrime[i]){\n        for(int j=i+i;j<=n;j+=i) ismrime[j]=false;\n      }\n    }\n  }\n\n  // 因数分解 √N\n  vector<int> mrime_decommosition(ll x){\n    vector<int>res;\n    for(int i=2;i*i<=x;i++){\n      while(x%i==0){\n        x/=i;\n        res.push_back(i);\n      }\n    }\n    if(x!=1) res.push_back(x);\n    return res;\n  }\n\n  // 約数列挙 √N\n  vector<ll> divisor(ll x){\n    vector<ll> res;\n    for(ll i=1; i*i<=x ;i++)\n      if(x%i==0){\n        res.push_back(i);\n        if(i*i!=x) res.push_back(x/i);\n      }\n    sort(res.begin(), res.end());\n    return res;\n  }\n\n  // a*b>LONG_MAX ? \n  bool overflow(ll a,ll b,ll LONGMAX){return a > LONGMAX/b;}\n\n  ll extgcd(ll a,ll b,ll& x,ll& y){\n    ll d = a ;\n    if ( b != 0 ) {\n      d = extgcd( b , a%b , y , x ) ;\n      y -= ( a / b ) * x ;\n    }else{\n      x = 1 ; y = 0 ;\n    }\n    return d;\n  }\n  ll mod_inverse(ll a){\n    ll x , y ;\n    extgcd( a , m , x , y ) ;\n    return ( m + x % m ) % m ;\n  }\n  ll mod_inverse_M(ll a,ll m){\n    ll x , y ;\n    extgcd( a , m , x , y ) ;\n    return ( m + x % m ) % m ;\n  }\n\n  pair<ll,ll> linear_congruence(const vector<ll> &A,const vector<ll> &B,const vector<ll> &M){\n  \tll x=0,m=1;\n  \tfor(int i=0;i<A.size();i++){\n  \t\tll a=A[i]*m;\n  \t\tll b=B[i]-A[i]*x;\n  \t\tll d=__gcd(M[i],a);\n  \t\tif(b%d!=0)return make_pair(0,-1);\n  \t\tll t=b/d*mod_inverse_M(a/d,M[i]/d)%(M[i]/d);\n  \t\tx=x+m*t;\n  \t\tm*=M[i]/d;\n  \t}\n  \treturn make_pair(x%m,m);\n  }\n\n  // オイラー関数√N\n  ll euler_mhi(ll n){\n    ll res = n;\n    for(ll i=2; i*i <= n ; i++){\n      if( n%i == 0 ){\n        res = res/i*(i-1);\n        for(;n%i==0;n/=i);\n      }\n    }\n    if(n!=1)res=res/n*(n-1);\n    return res;\n  }\n\n  void make_euler_table(int n){\n    euler.resize(n+1);\n    for(int i=0;i<n;i++) euler[i]=i;\n    for(int i=2;i<n;i++){\n      if(euler[i]==i){\n        for(int j=i;j<n;j+=i){\n          euler[j]=euler[j]/i*(i-1);\n        }\n      }\n    }\n  }\n\n  // n! と nCr \n  // mはmod\n  ll mod_fact(ll n,ll& e){\n    e=0;\n    if(n==0)return 1;\n\n    int res = mod_fact(n/m,e);\n    e+=n/m;\n\n    if(n/m%2 != 0)return res*(m-fact[n%m])%m;\n    return res*fact[n%m]%m;\n  }\n\n  ll combination(ll n,ll k){\n    if(n==k||k==0)return 1;\n    if(n<0 || k<0 || n<k)return 0;\n    ll e1,e2,e3;\n    ll a1 = mod_fact(n,e1);\n    ll a2 = mod_fact(k,e2);\n    ll a3 = mod_fact(n-k,e3);\n    return a1*mod_inverse(a2*a3%m)%m;\n  }\n\n  ll mod_mult(ll a, ll b,ll m) {\n    ll res = 0;\n    ll exm = a % m;\n    while (b) {\n      if (b & 1) {\n        res += exm;\n        if (res > m) res -= m;\n      }\n      exm <<= 1;\n      if (exm > m) exm -= m;\n      b >>= 1;\n    }\n    return res;\n  }\n\n  ll mod_exm(ll a, ll b,ll m) {\n    ll res = 1;\n    ll exm = a % m;\n    while (b) {\n      if (b & 1) res = mod_mult(res, exm,m);\n      exm = mod_mult(exm, exm,m);\n      b >>= 1;\n    }\n    return res;\n  }\n\n  // 確率的高速素数判定　\n  bool miller_rabin(ll n, ll times=10) {\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (!(n & 1)) return false;\n    ll q = n-1;\n    int k = 0;\n    while (q % 2 == 0) {\n      k++;\n      q >>= 1;\n    }\n    for (int i = 0; i < times; i++) {\n      ll a = rand() % (n-1) + 1;\n      ll x = mod_exm(a, q, n);\n      if (x == 1) continue;\n      bool found = false;\n      for (int j = 0; j < k; j++) {\n        if (x == n-1) {\n          found = true;\n          break;\n        }\n        x = mod_mult(x, x, n);\n      }\n      if (found) continue;\n      return false;\n    }\n    return true;\n  }\n\n  ll pollard_rho(ll n, int c) {\n    ll x = 2;\n    ll y = 2;\n    ll d = 1;\n    while (d == 1) {\n      x = mod_mult(x, x, n) + c;\n      y = mod_mult(y, y, n) + c;\n      y = mod_mult(y, y, n) + c;\n      d = __gcd((x-y >= 0 ? x-y : y-x), n);\n    }\n    if (d == n) return pollard_rho(n, c+1);\n    return d;\n  }\n};\n\nint n,m[11],d,M;\nsigned main(){\n\tNT N(1e9+7);\n\tcin>>n>>M>>d;\n\tr(i,M)cin>>m[i];\n\tr(i,d){\n\t\tvector<int>A,B,C;\n\t\tr(j,M){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tif(x!=-1){\n\t\t\t\tA.push_back(1);\n\t\t\t\tB.push_back(x);\n\t\t\t\tC.push_back(m[j]);\n\t\t\t}\n\t\t}\n\t\tpair<int,int> p=N.linear_congruence(A,B,C);\n\t\tif(p.second<0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tint x=p.first;\n\t\tint l=0,r=1e9;\n\n\t\twhile(l<r){\n\t\t\tint mid=(l+r)/2;\n\t\t\tif(x+mid*p.second>=n)r=mid;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tif(x+(l+2)*p.second<=n)n=x+(l+2)*p.second;\n\t\telse if(x+(l+1)*p.second<=n)n=x+(l+1)*p.second;\n\t\telse if(x+(l)*p.second<=n)n=x+(l)*p.second;\n\t\telse if(x+(l-1)*p.second<=n&&x+(l-1)*p.second>=0)n=x+(l-1)*p.second;\n\t\telse n=x+(l-2)*p.second;\n\t}\n\tcout<<n<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dump(x) cout << (#x) << \" = \" << (x) << \", \";\nusing namespace std;\ntypedef long long lli;\n\nlli gcd(lli a, lli b){\n  if(b == 0) return a;\n  return gcd(b, a % b);\n}\n\nlli extgcd(lli a, lli b, lli& x, lli& y){\n  lli d = a;\n  if(b != 0){\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nlli mod_inverse(lli a, lli m){\n  lli x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<lli, lli> linear_congruece(const vector<lli>& A, const vector<lli>& B, const vector<lli>& M){\n  lli x = 0, m =1;\n  for(lli i = 0; i < A.size(); ++i){\n    lli a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0)return make_pair(0, -1);\n    lli t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  lli n, m, d;\n  cin >> n >> m >> d;\n  vector<lli> A(m,1), M;\n  for(lli i = 0; i < m; ++i){\n    lli tmp;\n    cin >> tmp;\n    M.push_back(tmp);\n  }\n  for(lli i = 0; i < d; ++i){\n    //dump(i);dump(d);\n    vector<lli> B;\n\n    for(lli j = 0; j < m; ++j){\n      lli tmp;\n      cin >> tmp;\n      B.push_back(tmp);\n    }\n\n    if(B[0] < 0) continue;\n\n    pair<lli, lli> res = linear_congruece(A, B, M);\n\n    if(res.second == -1){\n      n = -1;\n      break;\n    }\n    \n    lli modn = n % res.second;\n    lli mod = res.second;\n    lli modnext = res.first;\n    /*\n    dump(n);\n    dump(modn);\n    */\n    while(modnext < 0) modnext += mod;\n    modnext = (modnext + (llabs(modnext) / mod + 1) * mod) % mod;\n    if(modn >= modnext) n -= modn - modnext;\n    else {\n      n -= mod;\n      n += modnext - modn;\n    }\n\n    /*\n    dump(modnext);\n    dump(mod);\n    dump(n);\n    cout << endl;\n    */\n    \n  }\n  cout << (n < 0 ? -1 : n) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\nusing namespace std;\ntypedef pair<int,int> pr;\ntypedef vector<pr > vpr;\nconst int INF=1<<30;\nint lcm(int a,int b){\n\tif(a%b==0)\n\treturn b;\n\telse\n\treturn lcm(b,a%b);\n}\nint GCD(int a,int b){\n\treturn (a*b)/lcm(a,b);\n}\nint main() {\n\tint N,M,D;\n\tint divi[10];\n\tint dived[100][10],gcd[10]={};\n\tcin >> N >> M >> D;\n\tREP(i,M){\n\tcin >> divi[i];\n\t}\n\tREP(i,D)\n\t\tREP(j,M)\n\t\t\tcin >> dived[i][j];\n\tint now=N;\n\tREP(i,D){\n\t\tint mn=0,ngcd=1;\n\t\tbool ans=false;\n\t\tREP(j,M){\n\t\tif(dived[i][j]==-1)\t\n\t\tcontinue;\n\t\tans=true;\n\t\tif(mn==0)\n\t\t\tmn=dived[i][j];\n\t\twhile(mn%divi[j]!=dived[i][j] && now>=mn) mn+=ngcd;\n\t\tngcd=GCD(ngcd,divi[j]);\n\t\t}\n\t\tif(now<mn){\n\t\t\tnow=-1;\n\t\t\tbreak;\n\t\t}\n\t\tif(ans){\n\t\tint alpha=(now-mn)/ngcd;\n\t\tnow=mn+alpha*ngcd;\n\t\t}\n\t}\n\tcout << now << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    int N, M, D;\n    vector<int> A;\n    vector< vector<int> > R;\n    void input() {\n        cin >> N >> M >> D;\n        A.resize(M); cin >> A;\n        R.resize(D);\n        for (int i = 0; i < D; i++) {\n            R[i].resize(M); cin >> R[i];\n        }\n    }\n\n    ll lcm(ll a, ll b) {\n        return a / __gcd(a, b) * b;\n    }\n\n    bool check(int n, int d) {\n        for (int i = 0; i < M; i++) {\n            if (R[d][i] < 0) continue;\n            if (n % A[i] != R[d][i]) return false;\n        }\n        return true;\n    }\n\n    void solve() {\n        ll L = 1;\n        for (int i = 0; i < M; i++) L = lcm(L, A[i]);\n\n        ll x = N;\n        for (int d = 0; d < D; d++) {\n            int m = 0;\n            for (int i = 0; i < M; i++) {\n                if (R[d][i] < 0) continue;\n                if (A[m] < A[i]) {\n                    m = i;\n                }\n            }\n            int n = R[d][m];\n            if (n < 0) continue;\n            for (; ; n += A[m]) {\n                if (n > x) {\n                    cout << -1 << endl;\n                    return;\n                }\n                if (check(n, d)) {\n                    break;\n                }\n            }\n            x = (x - n) / L * L + n;\n        }\n        cout << x << endl;\n\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\n\nvector<ll> comb;\nvector<ll> A;\nll N;\nll M, D;\n\nll gcd(ll x,ll y){\n    if(y == 0)return x;\n    else return gcd(y, x % y);\n}\nll lcm(ll x,ll y){\n    return x*y / gcd(x,y);\n}\n\n\nvoid makeComb(){\n    for(ll i = 0; i <= (1<<M); i++){\n        comb[i] = 1LL;\n        for(ll j = 0; j < M; j++){\n            if((i >> j) & 1) comb[i] = lcm(comb[i], A[j]);\n        }     \n    }\n    return;\n}\n\nint main () {\n    cin >> N >> M >> D;\n    comb = vector<ll>((1<<M)+1, 0);\n    A = vector<ll>(M);\n    for(ll i = 0; i < M; i++) cin >> A[i];\n    makeComb();\n    ll pre = N;\n    \n    for(ll i = 0; i < D; i++){\n        ll ret = 0LL;\n        vector<ll> R(M);\n        ll exist = 0;\n        for(ll j = 0; j < M; j++){\n            cin >> R[j];\n            if(R[j] != -1) exist |= 1<<j;\n        }\n        bool update = false;\n        for(ll j = 100LL; j >= 0LL; j--){\n            ll f = 0;\n            for(ll k = 0; k < M; k++){\n                if(R[k] != -1 && (j % A[k]) != R[k]) f = 1;\n            }\n            if(f) continue;\n            if(pre - j < 0) continue;\n            update = true; \n            ret = max(ret, ((pre - j) / comb[exist]) * comb[exist] + j);\n        }\n        if(!update){\n            cout << -1 << endl;\n            return 0;\n        }\n        pre = ret;\n    }\n    cout << pre << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <cmath>\n#include <iostream>\n\nusing namespace std;\n#define int long long //これはやばい\ntypedef pair<int, int> P;\n\nint extgcd(int a, int b, int& x, int& y) {\n  int d = a;\n  if (b != 0) {\n\td = extgcd(b, a % b, y, x);\n\ty -= (a / b) * x;\n  } else {\n\tx = 1; y = 0;\n  }\n  return d;\n}\n\nint mod_inverse(int a, int m) {\n  int x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\nbool allminus(vector<int> B) {\n  for (int i = 0; i < (int)B.size(); i++) {\n\tif (B[i] >= 0)\n\t  return false;\n  }\n  return true;\n}\n\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  else return gcd(b, a%b);\n}\n\nP linear_congruence(const vector<int>& B, const vector<int>& M) {\n  int x = 0, m = 1;\n  int n = B.size();\n  if (allminus(B)) return P(-1, -1);\n  for (int i = 0; i < n; i++) {\n\tif (B[i] < 0) continue;\n\tint a = m, b = B[i] - x, d = gcd(M[i], a);\n\tif (b % d != 0) return P(0, -1);\n\tint t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n\tx = x + m * t;\n\tm *= M[i] / d;\n  }\n  return P(x % m , m);\n}\n\nsigned main() {\n  int n, m, d;\n  cin >> n >> m >> d;\n  vector<int> M(m);\n  for (int i = 0; i < m; i++)\n\tcin >> M[i];\n\n  vector<int> B[d];\n  for (int i = 0; i < d; i++) {\n\tfor (int j = 0; j < m; j++) {\n\t  int r;\n\t  cin >> r;\n\t  B[i].push_back(r);\n\t}\n  }\n\n  for (int i = 0; i < d; i++) {\n\tP p = linear_congruence(B[i], M);\n\tif (p.first == -1 && p.second == -1) continue;\n\tif (p.first == 0 && p.second == -1) {\n\t  cout << -1 << endl;\n\t  return 0;\n\t}\n\tif (n >= p.first) {\n\t  int t = (n - p.first) / p.second;\n\t  n = p.first + p.second * t;\n\t} else {\n\t  cout << -1 << endl;\n\t  return 0;\n\t}\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dp[2001][3];\nint n,k,m=1000003;\n\nint dfs(int p,int f){\n  if(dp[p][f])return dp[p][f];\n  if(p==n){\n    if(f==1)return 1;\n    return 0;\n  }\n  int nf;\n  if(f==-1)nf=0;\n  if(f==0)nf=2;\n  if(f==1)nf=2;\n  if(f==2)nf=1;\n  int res=0;\n  for(int i=1;i<=k&&p+i<=n;i++){\n    res=(res+dfs(p+i,nf))%m;\n  }\n  if(f==-1)return res;\n  return dp[p][f]=res;  \n}\n\nint main(){\n  while(cin>>n>>k,n){\n    memset(dp,0,sizeof(dp));\n    dfs(0,-1);\n    int ans=0;\n    for(int i=1;i<=k;i++)ans=(ans+dp[i][0]*i)%m;\n    cout<<ans*2%m<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ax+by = 1 になる x, y を求める\nll extgcd (ll a, ll b, ll &x, ll &y ){\n\tll d = a;\n\tif (b != 0 ){\n\t\td = extgcd (b, a%b, y, x ); y -= (a/b)*x;\n\t}else{\n\t\tx = 1LL; y = 0LL;\n\t} // end if\n\n\treturn d;\n}\n\nll mod_inverse (ll a, ll m ){\n\tll x, y;\n\textgcd (a, m, x, y );\n\n\treturn (m + x % m ) % m;\n}\n\nconst int MAX_M = 12;\nconst int MAX_D = 105;\n\nint a[MAX_M];\nint r[MAX_D][MAX_M];\nbool used[MAX_M];\nll n_[MAX_M];\nll u[MAX_M];\n\nint chinese_reminder_theorem (int di, int m, int curr ){\n\n\tmemset (n_, 0LL, sizeof (n_ ) );\n\tmemset (u, 0LL, sizeof (u ) );\n\n\tll N = 1LL;\n\trep (i, m ) if (used[i]  ) N *= (ll)a[i];\n\n\tif (N == 1LL ) return curr;\n\n\trep (i, m ) if (used[i] ) n_[i] = N/(ll)a[i];\n\trep (i, m ) if (used[i] ) u[i] = mod_inverse (n_[i], (ll)a[i] );\n\n\tll res = 0LL;\n\trep (i, m ) if (used[i] ) res += n_[i]*u[i]*(ll)r[di][i];\n\n\tres %= N;\n\n\treturn (res != 0LL ? (int)res : -1 );\t\t\t\n}\n\nvoid used_ai (int id, int m ){\n\tfill (used, used + MAX_M, true );\n\n\trep (i, m ){\n\t\tif (!used[i] ) continue;\n\t\tif (r[id][i] == -1 ){\n\t\t\tused[i] = false;\n\t\t\tcontinue;\n\t\t} // end if\n\t\tfor (int j = i+1; j < m; j++ ){\n\t\t\tif (r[id][j] == -1 ){\n\t\t\t\tused[j] = false;\n\t\t\t\tcontinue;\n\t\t\t} // end if\n\t\t\tif (__gcd (a[i], a[j] ) != 1 ){\n\t\t\t\tused[j] = false;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end rep\n}\n\nint main()\n{\n\tmemset (a, 0, sizeof (a ) );\n\tmemset (r, -1, sizeof (r ) );\n\n\tios_base::sync_with_stdio(0);\n\tint n, m, d; cin >> n >> m >> d;\n\n\trep (i, m ) cin >> a[i];\n\trep (i, d ) rep (j, m ) cin >> r[i][j];\n\n\tint res = n;\n\trep (i, d ){\n\t\tused_ai (i, m );\n\t\tint curr = chinese_reminder_theorem (i, m, res );\n\t\tif (curr > res ){\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}else{\n\t\t\tres = min (res, curr );\n\t\t} // end if\n\t} // end rep\n\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-8;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<ll, ll> linear_congruence(const vector<ll>& A, const vector<ll>& B,\n                                 const vector<ll>& M) {\n  ll x = 0, m = 1;\n  for(ll i = 0; i < A.size(); i++){\n    if(B[i] == -1) continue;\n    ll a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0) return make_pair(0, -1);\n    ll t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  ll num_of_chopsticks;\n  int num_of_divisors;\n  int total_days;\n  while(~scanf(\"%lld %d %d\",\n               &num_of_chopsticks,\n               &num_of_divisors,\n               &total_days)){\n    vector<ll> divisors(num_of_divisors);\n    for(int div_i = 0; div_i < num_of_divisors; div_i++){\n      scanf(\"%lld\",&divisors[div_i]);\n    }\n    ll record[101][11];\n    for(int day = 0; day < total_days; day++){\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        scanf(\"%lld\",&record[day][div_i]);\n      }\n    }\n\n    vector<ll> A(num_of_divisors,1);\n    for(int day = 0; day < total_days; day++){\n      vector<ll> reminder;\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        reminder.push_back(record[day][div_i]);\n      }\n\n      pair<ll,ll> ans = linear_congruence(A,reminder,divisors);\n      if(ans.first > num_of_chopsticks || ans.second == -1){\n        num_of_chopsticks = -1;\n        break;\n      }\n      \n      ll upper = 10000000000LL;\n      ll lower = -1;\n      for(int round = 0; round < 50; round++){\n        ll mid = lower + (upper - lower) / 2LL;\n        if(ans.second * mid + ans.first > num_of_chopsticks){\n          upper = mid;\n        }\n        else{\n          lower = mid;\n        }\n      }\n      num_of_chopsticks = ans.second * lower + ans.first;\n\n      if(num_of_chopsticks < 0){\n              num_of_chopsticks = -1;\n        break;\n      }\n    }\n    printf(\"%lld\\n\",num_of_chopsticks);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n\nusing namespace std;\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) os << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n\ntemplate <typename T> void print(T a, int n, const string& split = \" \") { for (int i = 0; i < n; i++) { cout << a[i]; if (i + 1 != n) cout << split; } cout << endl; }\ntemplate <typename T> void print2d(T a, int w, int h, int width = -1, int br = 0) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) { if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\ntemplate <typename T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n#define dump(v) (cerr << #v << \": \" << v << endl)\n\n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define clr(a, x) memset(a, x, sizeof(a))\n#define sz(a) ((int)(a).size())\n#define mp(a, b) make_pair(a, b)\n#define ten(n) ((long long)(1e##n))\n\ntemplate <typename T, typename U> void upmin(T& a, const U& b) { a = min<T>(a, b); }\ntemplate <typename T, typename U> void upmax(T& a, const U& b) { a = max<T>(a, b); }\ntemplate <typename T> void uniq(T& a) { sort(a.begin(), a.end()); a.erase(unique(a.begin(), a.end()), a.end()); }\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\n\nll ext_gcd(ll a, ll b, ll &x, ll &y)\n{\n    if (b)\n    {\n        ll g = ext_gcd(b, a % b, y, x);\n        y -= (a / b) * x;\n        return g;\n    }\n    else\n    {\n        x = 1, y = 0;\n        return a;\n    }\n}\n// 逆元\n// a * x == 1 (mod m)を満たすxを求める\n// 解なしの場合0を返す\n// a*x + m*y == 1をやる\nll mod_inverse(ll a, ll mod)\n{\n    ll x, y;\n    if (ext_gcd((a + mod) % mod, mod, x, y) == 1)\n        return (mod + x % mod) % mod;\n    else\n        return 0;\n}\npair<ll, ll> linear_congruence(const vector<ll>& A, const vector<ll>& B, const vector<ll>& M)\n{\n    ll x = 0, m = 1;\n    for (int i = 0; i < (int)A.size(); ++i)\n    {\n        ll a = A[i] * m,  b = B[i] - A[i] * x, d = __gcd(M[i], a);\n        if (b % d != 0)\n            return make_pair(0, -1); // unsolvable\n        ll t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n        x = x + m * t;\n        m *= M[i] / d;\n        x = (x + m) % m;\n    }\n    return make_pair(x % m, m);\n}\nint main()\n{\n    int n, m, d;\n    cin >> n >> m >> d;\n    vector<ll> _a(m);\n    input(_a, m);\n\n    ll cur = n;\n    rep(_, d)\n    {\n        auto a = _a;\n        vector<ll> r(m);\n        input(r, m);\n        rep(i, m)\n        {\n            if (r[i] == -1)\n            {\n                r[i] = 0;\n                a[i] = 1;\n            }\n        }\n        auto w = linear_congruence(vector<ll>(m, 1), r, a);\n        ll next = cur / w.second * w.second + w.first;\n        if (next > cur)\n            next -= w.second;\n        if (w.second == -1 || w.first > cur || next < 0)\n        {\n            cout << -1 << endl;\n            return 0;\n        }\n        cur = next;\n    }\n    cout << cur << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ax+by = 1 になる x, y を求める\nll extgcd (ll a, ll b, ll &x, ll &y ){\n\tll d = a;\n\tif (b != 0 ){\n\t\td = extgcd (b, a%b, y, x ); y -= (a/b)*x;\n\t}else{\n\t\tx = 1LL; y = 0LL;\n\t} // end if\n\n\treturn d;\n}\n\nll mod_inverse (ll a, ll m ){\n\tll x, y;\n\textgcd (a, m, x, y );\n\n\treturn (m + x % m ) % m;\n}\n\nconst int MAX_M = 12;\nconst int MAX_D = 105;\n\nint a[MAX_M];\nint r[MAX_D][MAX_M];\nbool used[MAX_M];\nll n_[MAX_M];\nll u[MAX_M];\n\nint chinese_reminder_theorem (int di, int m, int curr ){\n\n\tmemset (n_, -1LL, sizeof (n_ ) );\n\tmemset (u, -1LL, sizeof (u ) );\n\n\tll N = 1LL;\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) N *= (ll)a[i];\n\n\tif (N == 1LL ) return curr;\n\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) n_[i] = N/(ll)a[i];\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) u[i] = mod_inverse (n_[i], (ll)a[i] );\n\n\tll res = 0LL;\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) res += n_[i]*u[i]*(ll)r[di][i];\n\n\tres %= N;\n\n\treturn (res != 0LL ? (int)res : -1 );\t\t\t\n}\n\nint main()\n{\n\tmemset (a, 0, sizeof (a ) );\n\tmemset (r, 0, sizeof (r ) );\n\tmemset (used, false, sizeof (used ) );\n\n\tios_base::sync_with_stdio(0);\n\tint n, m, d; cin >> n >> m >> d;\n\n\trep (i, m ) cin >> a[i];\n\trep (i, d ) rep (j, m ) cin >> r[i][j];\n\n\trep (i, m ) used[i] = true;\n\tvector<int> sum_n (m, 0 );\n\trep (j, m ) {\n\t\tint cnt = 0;\n\t\trep (i, d ) if (r[i][j] == -1 ) cnt++;\n\t\tsum_n[j] = cnt;\n\t} // end rep\n\t\n\trep (i, m ){\n\t\tif (!used[i] ) continue;\n\t\tfor (int j = i+1; j < m; j++ ){\n\t\t\tif (__gcd (a[i], a[j] ) != 1 ){\n\t\t\t\tif (sum_n[i] <= sum_n[j] )\n\t\t\t\t\tused[j] = false;\n\t\t\t\telse\n\t\t\t\t\tused[i] = false;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end rep\n\n\tint res = n;\n\trep (i, d ){\n\t\tint curr = chinese_reminder_theorem (i, m, res );\n\t\tif (curr > res ){\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}else{\n\t\t\tres = curr;\n\t\t} // end if\n\t} // end rep\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define dump(x) cout << (#x) << \" = \" << (x) << \", \";\nusing namespace std;\ntypedef long long lli;\n\nlli gcd(lli a, lli b){\n  if(b == 0) return a;\n  return gcd(b, a % b);\n}\n\nlli extgcd(lli a, lli b, lli& x, lli& y){\n  lli d = a;\n  if(b != 0){\n    d = extgcd(b, a % b, y, x);\n    y -= (a / b) * x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nlli mod_inverse(lli a, lli m){\n  lli x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<lli, lli> linear_congruece(const vector<lli>& A, const vector<lli>& B, const vector<lli>& M){\n  lli x = 0, m =1;\n  for(lli i = 0; i < A.size(); ++i){\n    lli a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0)return make_pair(0, -1);\n    lli t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  lli n, m, d;\n  cin >> n >> m >> d;\n  vector<lli> A(m,1), M;\n  for(lli i = 0; i < m; ++i){\n    lli tmp;\n    cin >> tmp;\n    M.push_back(tmp);\n  }\n  for(lli i = 0; i < d; ++i){\n    //dump(i);dump(d);\n    vector<lli> B;\n    bool f2 = false;\n\n    for(lli j = 0; j < m; ++j){\n      lli tmp;\n      cin >> tmp;\n      B.push_back(tmp);\n      if(tmp > 0) f2 = true;\n    }\n\n    if(B[0] < 0 || n < 0 || n == 0 && f2) {\n      if(n == 0 && f2) n = -1;\n      continue;\n    }\n\n    pair<lli, lli> res = linear_congruece(A, B, M);\n\n    if(res.second == -1){\n      n = -1;\n      continue;\n    }\n    \n    lli modn = n % res.second;\n    lli mod = res.second;\n    lli modnext = res.first;\n    /*\n    dump(n);\n    dump(modn);\n    */\n    while(modnext < 0) modnext += mod;\n    //modnext = (modnext + (llabs(modnext) / mod + 1) * mod) % mod;\n    if(modn >= modnext) n -= modn - modnext;\n    else {\n      n -= mod;\n      n += modnext - modn;\n    }\n\n    /*\n    dump(modnext);\n    dump(mod);\n    dump(n);\n    cout << endl;\n    */\n    \n  }\n  cout << (n < 0 ? -1 : n) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pii;\n\nll gcd(ll a, ll b){\n  return b?gcd(b,a%b):a;\n}\n\nll extgcd(ll a, ll b, ll& x, ll& y){\n  ll d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  ll x = 0, m = 1;\n  rep(i,A.size()){\n    ll a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    ll t = b/d * mod_inverse(a/d, M[i]/d) % (M[i]/d);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair( (x%m + m) % m , m);\n}\n\nint main(){\n  ll n,m,d;\n  cin >> n >> m >> d;\n  vi a(m);\n  rep(i,m)cin >> a[i];\n\n  rep(i,d){\n    vi r, aa, e;\n    rep(j,m){\n      ll  tmp;\n      cin >> tmp;\n      if(tmp<0)continue;\n      r.push_back(tmp);\n      aa.push_back(a[j]);\n      e.push_back(1);\n    }\n    if(r.size()==0)continue;\n    \n    pii ans = linear_congruence(e,r,aa);\n    ll b = ans.first, mod = ans.second;\n    if(mod<0){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    ll tmp = (n/mod+100) * mod + b;\n    while(tmp<n)tmp += mod;\n    while(n<tmp)tmp -= mod;\n    if(tmp<0){\n      cout << -1 << endl;\n      return 0;\n    }\n    n = tmp;\n\n  }\n\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint cal(int n,P p){\n  while(n%p.first!=p.second&&n>=0)n--;\n  return n;\n}\n\nint main(){\n  int n,m,d,a[10];\n  cin>>n>>m>>d;\n  for(int i=0;i<m;i++){\n    cin>>a[i];\n  }\n  P r[100][10];\n  for(int i=0;i<d;i++){\n    for(int j=0;j<m;j++){\n      cin>>r[i][j].second;\n      r[i][j].first=a[j];\n    }\n    sort(r[i],r[i]+m);\n    reverse(r[i],r[i]+m);\n    vector<int> v;\n    int u=1e5;\n    for(int j=0;j<m;j++){\n      if(r[i][j].second==-1)continue;\n      if(j){\n\tvector<int> nv;\n\tfor(int k=0;k<(int)v.size();k++){\n\t  if(v[k]%r[i][j].first==r[i][j].second)nv.push_back(v[k]);\n\t}\n\tv=nv;\n      }\n      else {\n\tint p=cal(n,r[i][j]);\n\twhile((int)v.size()<u&&p>=0){\n\t  v.push_back(p);\n\t  p-=r[i][j].first;\n\t}\n      }\n    }\n    if(v.size())n=v[0];\n    else if(r[i][0].second!=-1)n=-1;\n  }\n  cout<<n<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m, d;\n\tcin >> n >> m >> d;\n\tvector<ll> a(m);\n\tfor(int i = 0; i < m; ++i){ cin >> a[i]; }\n\tfor(int i = 0; i < d; ++i){\n\t\tvector<ll> b(m);\n\t\tfor(int j = 0; j < m; ++j){ cin >> b[j]; }\n\t\tll mod = 1, x = 0;\n\t\tfor(int j = 0; x <= n && j < m; ++j){\n\t\t\tif(b[j] < 0){ continue; }\n\t\t\tbool accept = false;\n\t\t\tfor(int k = 0; k < a[j]; ++k){\n\t\t\t\tconst ll t = mod * k + x;\n\t\t\t\tif(t <= n && t % a[j] == b[j]){\n\t\t\t\t\tconst ll g = __gcd(mod, a[j]);\n\t\t\t\t\tmod *= a[j] / g;\n\t\t\t\t\tx = t % mod;\n\t\t\t\t\taccept = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!accept){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(x > n){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tconst ll t = n / mod;\n\t\tif(t * mod + x <= n){\n\t\t\tn = t * mod + x;\n\t\t}else{\n\t\t\tn = (t - 1) * mod + x;\n\t\t}\n\t}\n\tcout << n << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Benri { Benri() { std::cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(12);}} benri;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\nusing vll = vector<long long>;\nusing vvll = vector<vll>;\nusing pll = pair<ll, ll>;\nusing ull = unsigned long long;\n\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\n//constexpr int INF = 1001001001;\nconstexpr ll INF = 1001001001001001001ll;\nconstexpr double EPS = 1e-10;\nusing number = long long;\n\n\nnumber EXTGCD(number a, number b, number &x, number &y) {\n    number g = a; x = 1; y = 0;\n    if (b != 0) g = EXTGCD(b, a % b, y, x), y -= (a / b) * x;\n    return g;\n}\n\n\npair<ll, ll> ChineseRem(const vll &b, const vll &m) {\n    ll r = 0, M = 1;\n    for (int i = 0; i < (int)b.size(); ++i) {\n        ll p, q;\n        ll d = EXTGCD(M, m[i], p, q); // p is inv of M/d (mod. m[i]/d)\n        if ((b[i] - r) % d != 0) return make_pair(0, -1);\n        ll tmp = ((b[i] - r) / d) * p % (m[i] / d);\n        r += M * tmp;\n        M *= m[i] / d;\n    }\n    r %= M;\n    if (r < 0) r += M;\n    return make_pair(r, M);\n}\n\nint main() {\n    int N, M, D;\n    cin >> N >> M >> D;\n    vll A(M);\n    rep(i, M) cin >> A[i];\n\n    bool ok = true;\n    rep(i, D) {\n        vll b, m;\n        rep(j, M) {\n            int R; cin >> R;\n            if (R != -1) b.push_back(R), m.push_back(A[j]);\n        }\n        if (b.empty()) continue;\n\n        auto tmp = ChineseRem(b, m);\n\n        if (tmp.second == -1) ok = false;\n        if (N < tmp.first) ok = false;\n\n        N = N - (N - tmp.first) % tmp.second;\n    }\n    if (ok) cout << N << endl;\n    else cout << -1 << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long Int;\nInt extgcd(Int a, Int b, Int &x, Int &y) {\n  Int g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\nbool linearCongruences(const vector<Int> &a,\n                       const vector<Int> &b,\n                       const vector<Int> &m,\n                       Int &x, Int &M) {\n  int n = a.size();\n\tInt z,y,g,b0,m0;\n\tx=0;M=1;\n\tfor(int i=0;i<n;i++){\n\t\t//if(!a[i])continue;\n\t\tb0=b[i]-a[i]*x;\n\t\tif(b0%(g=extgcd(a[i]*M,m[i],z,y))!=0)return 0;\n\t\tm0=m[i]/g;\n\t\tx+=M*(z*(b0/g%m0)%m0);\n\t\tM*=m0;\n\t\tx=(x%M+M)%M;\n\t\tif(M>1000000000){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(x*a[j]%m[j]!=b[j]%m[j])return 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 1;\n}\nlong long s[110];\nint main(){\n\tint a,b,c;\n\tscanf(\"%d%d%d\",&a,&b,&c);\n\tvector<Int>d(b);\n\tvector<Int>I(b);\n\tfor(int i=0;i<b;i++)I[i]=1;\n\tfor(int i=0;i<b;i++)scanf(\"%lld\",s+i);\n\tbool dame=false;\n\tfor(int i=0;i<c;i++){\n\t\tvector<Int>t(b);\n\t\tfor(int j=0;j<b;j++){\n\t\t\tscanf(\"%lld\",&t[j]);\n\t\t\tif(t[j]==-1){\n\t\t\t\tt[j]=0;\n\t\t\t\tI[j]=0;\n\t\t\t\td[j]=1;\n\t\t\t}else{\n\t\t\t\tI[j]=1;\n\t\t\t\td[j]=s[j];\n\t\t\t}\n\t\t}\n\t\tInt x,mod;\n\t\tbool res=linearCongruences(I,t,d,x,mod);\n\t//\tprintf(\"%lld %lld\\n\",x,mod);\n\t\tif(!res){dame=true;break;}\n\t\tif(mod>a){\n\t\t\tif(x>a){\n\t\t\t\tdame=true;break;\n\t\t\t}\n\t\t\ta=x;\n\t\t}else{\n\t\t\tx+=((a-x)/mod)*mod;\n\t\t\ta=x;\n\t\t}\n\t}\n\tif(dame){\n\t\tprintf(\"-1\\n\");\n\t}else printf(\"%d\\n\",a);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ll;\n\nll N;\nint M,D;\nll A[15];\nint R[15];\n\nll getsa(ll n,ll a,ll r){\n  if( n % a >= r ) return n%a - r;\n  else return n%a + n - r;\n}\n\nll gcd(ll a, ll b){\n  if(b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll lcm(ll a,ll b){\n  return a * b / gcd(a, b);\n}\n\nint main(){\n  cin >> N >> M >> D;\n  for(int i=0;i<(int)M;i++){\n    cin >> A[i];\n  }\n  bool dame = false;\n  for(int i=0;i<(int)D;i++){\n    for(int j=0;j<(int)M;j++)\n      cin >> R[j];\n    if( dame ) continue;\n    ll n = N;\n    int cur = 0;\n    //    cout << \"cur \" << cur << endl;\n    while( cur < M && R[cur] == -1 ) cur++;\n    //cout << \"cur -> \" << cur << endl;\n    if( cur == M ) continue;\n    ll a = getsa(n,A[cur],R[cur]);\n    ll k = A[cur];\n    if( n < a ){ dame  = true; continue; }\n    n -=a;\n    // cout << i << endl;\n    //    cout << n << endl;\n    for(int j=cur+1;j<(int)M;j++){\n      //    cout << \"j \" << j << endl;\n      if( R[j] == -1 ) continue;\n      bool ok = false;\n      //cout << n << \" \" << A[j] << endl;\n      ll id = n%A[j];\n      ll c = 0;\n      bool used[111] = {};\n      while( !used[id] ) {\n        //        cout << id << endl;\n        if( (int)id == R[j] ) {\n          if( k*c > n ) break;\n          n-= k*c;\n          ok = true;\n          break;\n        }\n        ll b = k%A[j];\n        if( id < b )\n          id = id + A[j] - b;\n        else\n          id = id-b;\n      }\n      if( !ok ) { dame = true; break; }\n      //      cout << \"lcm : \" k << \" \" << A[j]<< endl;\n      k = lcm(k,A[j]);\n      //          cout << \"lcm end \" <<k<< endl;\n    }\n    N = n;\n  }\n  if( dame ) cout << -1 << endl;\n  else cout << N << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define MAX_N 150\n#define INF 9999999999LL\n\nlong long p[MAX_N];\nlong long x[MAX_N][MAX_N];\nlong long z[MAX_N][2];\nlong long N, M, D;\n\nlong long gcd(long long X, long long Y) {\n\treturn Y ? gcd(Y, X % Y) : X;\n}\n\nint main() {\n\tcin >> N >> M >> D;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> p[i];\n\t}\n\tfor (int i = 0; i < D; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tcin >> x[i][j];\n\t\t}\n\t\tz[i][1] = 1;\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tlong long a1 = z[i][0], a2 = z[i][1], cnt1 = 0;\n\t\t\tif (x[i][j] == -1) {\n\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (true) {\n\t\t\t\t\tif (cnt1 >= 1000 || a1 >= INF) {\n\t\t\t\t\t\tz[i][0] = INF; z[i][1] = INF; break;\n\t\t\t\t\t}\n\t\t\t\t\tif (a1%p[j] == x[i][j]) {\n\t\t\t\t\t\tz[i][0] = a1;\n\t\t\t\t\t\tz[i][1] = a2*p[j] / gcd(a2, p[j]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ta1 += a2;\n\t\t\t\t\tcnt1++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint res = N;\n\tfor (int i = 0; i < D; i++) {\n\t\tint b1 = z[i][0], b2 = z[i][1];\n\t\tif (z[i][0] == INF) {\n\t\t\tres = -1;\n\t\t}\n\t\tif (res >= 0) {\n\t\t\tint k = (res - b1) / b2;\n\t\t\tk *= b2;\n\t\t\tk += b1;\n\t\t\tres = b1;\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-8;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<ll, ll> linear_congruence(const vector<ll>& A, const vector<ll>& B,\n                                 const vector<ll>& M) {\n  ll x = 0, m = 1;\n  for(ll i = 0; i < A.size(); i++){\n    if(B[i] == -1) continue;\n    ll a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0) return make_pair(0, -1);\n    ll t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  ll num_of_chopsticks;\n  int num_of_divisors;\n  int total_days;\n  while(~scanf(\"%lld %d %d\",\n               &num_of_chopsticks,\n               &num_of_divisors,\n               &total_days)){\n    vector<ll> divisors(num_of_divisors);\n    for(int div_i = 0; div_i < num_of_divisors; div_i++){\n      scanf(\"%lld\",&divisors[div_i]);\n    }\n    ll record[101][11];\n    for(int day = 0; day < total_days; day++){\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        scanf(\"%lld\",&record[day][div_i]);\n      }\n    }\n\n    vector<ll> A(num_of_divisors,1);\n    for(int day = 0; day < total_days; day++){\n      vector<ll> reminder;\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        reminder.push_back(record[day][div_i]);\n      }\n\n      pair<ll,ll> ans = linear_congruence(A,reminder,divisors);\n      \n      ll upper = 1000000000LL;\n      ll lower = -1;\n      for(int round = 0; round < 100; round++){\n        ll mid = lower + (upper - lower) / 2LL;\n        if(ans.second * mid + ans.first > num_of_chopsticks){\n          upper = mid;\n        }\n        else{\n          lower = mid;\n        }\n      }\n      \n      num_of_chopsticks = ans.second * lower + ans.first;\n      if(lower == -1 || num_of_chopsticks < 0) {\n        num_of_chopsticks = -1;\n        break;\n      }\n    }\n    printf(\"%lld\\n\",num_of_chopsticks);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n\nint cal(int n,P p){\n  while(n%p.first!=p.second&&n>=0)n--;\n  return n;\n}\n\nint main(){\n  int n,m,d,a[10];\n  cin>>n>>m>>d;\n  for(int i=0;i<m;i++){\n    cin>>a[i];\n  }\n  P r[100][10];\n  for(int i=0;i<d;i++){\n    for(int j=0;j<m;j++){\n      cin>>r[i][j].second;\n      r[i][j].first=a[j];\n    }\n    sort(r[i],r[i]+m);\n    reverse(r[i],r[i]+m);\n    vector<int> v;\n    for(int j=0;j<m;j++){\n      if(r[i][j].second==-1)continue;\n      if(j){\n\tvector<int> nv;\n\tfor(int k=0;k<(int)v.size();k++){\n\t  if(v[k]%r[i][j].first==r[i][j].second)nv.push_back(v[k]);\n\t}\n\tv=nv;\n      }\n      else {\n\tint u=1e7;\n\tint p=cal(n,r[i][j]);\n\twhile((int)v.size()<u&&p>=0){\n\t  v.push_back(p);\n\t  p-=r[i][j].first;\n\t}\n      }\n    }\n    if(v.size())n=v[0];\n    else if(r[i][0].second!=-1)n=-1;\n  }\n  cout<<n<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) ((a).begin(),(a).end())\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint gcd(int a, int b){\n  return b?gcd(b,a%b):a;\n}\n\nint extgcd(int a, int b, int& x, int& y){\n  int d = a;\n  if(b!=0){\n    d = extgcd(b,a%b,y,x);\n    y -= (a/b)*x;\n  }else{\n    x = 1; y = 0;\n  }\n  return d;\n}\n\nint mod_inverse(int a, int m){\n  int x,y;\n  extgcd(a,m,x,y);\n  return (m+x%m) % m;\n}\n\npii linear_congruence(const vi& A, const vi& B, const vi& M){\n  int x = 0, m = 1;\n  rep(i,A.size()){\n    int a = A[i]*m, b = B[i] - A[i] * x, d = gcd(M[i],a);\n    if(b%d != 0)return make_pair(0,-1);\n    int t = b/d * mod_inverse(a/d, M[i]/d) % (M[i]/d);\n    x = x+m*t;\n    m *= M[i]/d;\n  }\n  return make_pair(x%m, m);\n}\n\nint main(){\n  int n,m,d;\n  cin >> n >> m >> d;\n  vi a(m),e(m);\n  rep(i,m)cin >> a[i], e[i] = 1;\n\n  rep(i,d){\n    vi r(m);\n    rep(j,m)cin >> r[j];\n    if(r[0]<0)continue;\n    \n    pii ans = linear_congruence(e,r,a);\n    int b = ans.first, mod = ans.second;\n    if(mod<0){\n      cout << -1 << endl;\n      return 0;\n    }\n\n    int tmp = (n/mod) * mod + b;\n    if(n<tmp)tmp -= mod;\n    if(tmp<0){\n      cout << -1 << endl;\n      return 0;\n    }\n    n = tmp;\n  }\n  cout << n << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\nconst ll INF = 1000000009LL;\n\nvector<ll> comb;\nvector<ll> A;\nll N;\nll M, D;\n\nll gcd(ll x,ll y){\n    if(y == 0)return x;\n    else return gcd(y, x % y);\n}\nll lcm(ll x,ll y){\n    return x*y / gcd(x,y);\n}\n\n\nvoid makeComb(){\n    for(ll i = 0; i <= (1<<M); i++){\n        comb[i] = 1LL;\n        for(ll j = 0; j < M; j++){\n            if(comb[i] >= INF) break;\n            if((i >> j) & 1) comb[i] = lcm(comb[i], A[j]);\n        }     \n    }\n    return;\n}\n\nint main () {\n    cin >> N >> M >> D;\n    comb = vector<ll>((1<<M)+1, 0);\n    A = vector<ll>(M);\n    for(ll i = 0; i < M; i++) cin >> A[i];\n    makeComb();\n    ll pre = N;\n    \n    for(ll i = 0; i < D; i++){\n        ll ret = 0LL;\n        vector<ll> R(M);\n        ll exist = 0;\n        for(ll j = 0; j < M; j++){\n            cin >> R[j];\n            if(R[j] != -1) exist |= 1<<j;\n        }\n        bool update = false;\n        for(ll j = 10000LL; j >= 0LL; j--){\n            ll f = 0;\n            for(ll k = 0; k < M; k++){\n                if(R[k] != -1 && (j % A[k]) != R[k]) f = 1;\n            }\n            if(f) continue;\n            if(pre < j) continue;\n            update = true; \n            ret = max(ret, ((pre - j) / comb[exist]) * comb[exist] + j);\n        }\n        if(!update){\n            if(D != 2) while(1){}\n            cout << -1 << endl;\n            return 0;\n        }\n        pre = ret;\n    }\n    cout << pre << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m, d;\n\tcin >> n >> m >> d;\n\tvector<ll> a(m);\n\tfor(int i = 0; i < m; ++i){ cin >> a[i]; }\n\tfor(int i = 0; i < d; ++i){\n\t\tvector<ll> b(m);\n\t\tfor(int j = 0; j < m; ++j){ cin >> b[j]; }\n\t\tll mod = 1, x = 0;\n\t\tfor(int j = 0; x <= n && j < m; ++j){\n\t\t\tif(b[j] < 0){ continue; }\n\t\t\tbool accept = false;\n\t\t\tfor(int k = 0; k < a[j]; ++k){\n\t\t\t\tconst ll t = mod * k + x;\n\t\t\t\tif(t <= n && t % a[j] == b[j]){\n\t\t\t\t\taccept = true;\n\t\t\t\t\tmod *= a[j];\n\t\t\t\t\tx = t % mod;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!accept){\n\t\t\t\tcout << -1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(x > n){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tconst ll t = n / mod;\n\t\tif(t * mod + x <= n){\n\t\t\tn = t * mod + x;\n\t\t}else{\n\t\t\tn = (t - 1) * mod + x;\n\t\t}\n\t}\n\tcout << n << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint extgcd(int a, int b, int &x, int &y) {\n\tint d = a;\n\tif(b != 0) {\n\t\td = extgcd(b, a % b, y, x);\n\t\ty -= (a / b) * x;\n\t} else {\n\t\tx = 1;\n\t\ty = 0;\n\t}\n\treturn d;\n}\n\nint mod_inverse(int a, int m) {\n\tint x, y;\n\textgcd(a, m, x, y);\n\treturn (x % m + m) % m;\n}\n\npair<int, int> linear_congruence(const vector<int> &A, const vector<int> &B, const vector<int> &M) {\n\tint x = 0, m = 1;\n\n\tfor(unsigned i = 0; i < A.size(); ++i) {\n\t\tif(B[i] == -1) continue;\n\n\t\tint a = A[i] * m, b = B[i] - A[i] * x, d = __gcd(M[i], a);\n\t\tif(b % d != 0) return make_pair(0, -1);\n\t\tint t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n\t\tx = x + m * t;\n\t\tm *= M[i] / d;\n\t}\n\n\treturn make_pair(x % m, m);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, m, d;\n\tcin >> n >> m >> d;\n\n\tvector<int> M(m);\n\tfor(auto &e : M) cin >> e;\n\n\tvector<int> A(m, 1);\n\n\tfor(int i = 0; i < d; ++i) {\n\t\tvector<int> B(m);\n\t\tfor(auto &e : B) cin >> e;\n\n\t\tint b, mod;\n\t\ttie(b, mod) = linear_congruence(A, B, M);\n\n\t\tconst int p = n / mod;\n\t\tconst int q = n % mod;\n\t\tconst int k = (q - b + mod) % mod;\n\n\t\tn = p * mod + q - k;\n\n\t\tif(mod == -1 || n < 0) {\n\t\t\tn = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcout << n << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n \n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n   \nusing namespace std;\n   \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n   \nstatic const double EPS = 1e-8;\n   \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\n\nll mod_inverse(ll a, ll m){\n  ll x, y;\n  extgcd(a, m, x, y);\n  return (m + x % m) % m;\n}\n\npair<ll, ll> linear_congruence(const vector<ll>& A, const vector<ll>& B,\n                                 const vector<ll>& M) {\n  ll x = 0, m = 1;\n  for(ll i = 0; i < A.size(); i++){\n    if(B[i] == -1) continue;\n    ll a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n    if(b % d != 0) return make_pair(0, -1);\n    ll t = b / d * mod_inverse(a / d, M[i] / d) % (M[i] / d);\n    x = x + m * t;\n    m *= M[i] / d;\n  }\n  return make_pair(x % m, m);\n}\n\nint main(){\n  ll num_of_chopsticks;\n  int num_of_divisors;\n  int total_days;\n  while(~scanf(\"%lld %d %d\",\n               &num_of_chopsticks,\n               &num_of_divisors,\n               &total_days)){\n    vector<ll> divisors(num_of_divisors);\n    for(int div_i = 0; div_i < num_of_divisors; div_i++){\n      scanf(\"%lld\",&divisors[div_i]);\n    }\n    ll record[101][11];\n    for(int day = 0; day < total_days; day++){\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        scanf(\"%lld\",&record[day][div_i]);\n      }\n    }\n\n    vector<ll> A(num_of_divisors,1);\n    for(int day = 0; day < total_days; day++){\n      vector<ll> reminder;\n      for(int div_i = 0; div_i < num_of_divisors; div_i++){\n        reminder.push_back(record[day][div_i]);\n      }\n\n      pair<ll,ll> ans = linear_congruence(A,reminder,divisors);\n      \n      ll upper = 1000000000LL;\n      ll lower = -1;\n      for(int round = 0; round < 50; round++){\n        ll mid = lower + (upper - lower) / 2;\n        if(ans.second * mid + ans.first > num_of_chopsticks){\n          upper = mid;\n        }\n        else{\n          lower = mid;\n        }\n      }\n      \n      num_of_chopsticks = ans.second * lower + ans.first;\n      if(lower == -1 || num_of_chopsticks < 0) {\n        num_of_chopsticks = -1;\n        break;\n      }\n    }\n    printf(\"%lld\\n\",num_of_chopsticks);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\n\n// ax+by = 1 になる x, y を求める\nll extgcd (ll a, ll b, ll &x, ll &y ){\n\tll d = a;\n\tif (b != 0 ){\n\t\td = extgcd (b, a%b, y, x ); y -= (a/b)*x;\n\t}else{\n\t\tx = 1LL; y = 0LL;\n\t} // end if\n\n\treturn d;\n}\n\nll mod_inverse (ll a, ll m ){\n\tll x, y;\n\textgcd (a, m, x, y );\n\n\treturn (m + x % m ) % m;\n}\nconst int MAX_D = 105;\nconst int MAX_M = 12;\n\nint a[MAX_M];\nint r[MAX_D][MAX_M];\nll n_[MAX_M];\nll u[MAX_M];\n\nbool used[MAX_M];\nvoid used_ai (int id, int m ){\n\tfill (used, used + MAX_M, true );\n\n\trep (i, m ){\n\t\tif (!used[i] ) continue;\n\t\tif (r[id][i] == -1 ){\n\t\t\tused[i] = false;\n\t\t\tcontinue;\n\t\t} // end if\n\t\tfor (int j = i+1; j < m; j++ ){\n\t\t\tif (r[id][j] == -1 ){\n\t\t\t\tused[j] = false;\n\t\t\t\tcontinue;\n\t\t\t} // end if\n\t\t\tif (__gcd (a[i], a[j] ) != 1 ){\n\t\t\t\tused[i] = false;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end rep\n}\n\nint chinese_reminder_theorem (int di, int m, int curr ){\n\n\tmemset (n_, 0LL, sizeof (n_ ) );\n\tmemset (u, 0LL, sizeof (u ) );\n\n\tll N = 1LL;\n\trep (i, m ) if (used[i]  ) N *= (ll)a[i];\n\n\tif (N == 1LL ) return curr;\n\n\trep (i, m ) if (used[i] ) n_[i] = N/(ll)a[i];\n\trep (i, m ) if (used[i] ) u[i] = mod_inverse (n_[i], (ll)a[i] );\n\n\tll res = 0LL;\n\trep (i, m ) if (used[i] ) res += n_[i]*u[i]*(ll)r[di][i];\n\n\tres %= N;\n\n\treturn (res != 0LL ? (int)res : -1 );\t\t\t\n}\n\n\nint main()\n{\n\tmemset (a, 0, sizeof (a ) );\n\tmemset (r, -1, sizeof (r ) );\n\n\tios_base::sync_with_stdio(0);\n\tint n, m, d; cin >> n >> m >> d;\n\trep (i, m ) cin >> a[i];\n\trep (i, d ) rep (j, m ) cin >> r[i][j];\n\n\tint res = n;\n\trep (i, d ){\n\t\tused_ai (i, m );\n\t\tint curr = chinese_reminder_theorem (i, m, res );\n\t\tif (curr > res ){\n\t\t\tres = -1;\n\t\t\tbreak;\n\t\t}else{\n\t\t\tres = min (res, curr );\n\t\t} // end if\n\t} // end rep\n\n\tcout << res << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.D\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\n\n\n// ax+by = 1 になる x, y を求める\nll extgcd (ll a, ll b, ll &x, ll &y ){\n\tll d = a;\n\tif (b != 0 ){\n\t\td = extgcd (b, a%b, y, x ); y -= (a/b)*x;\n\t}else{\n\t\tx = 1LL; y = 0LL;\n\t} // end if\n\n\treturn d;\n}\n\nll mod_inverse (ll a, ll m ){\n\tll x, y;\n\textgcd (a, m, x, y );\n\n\treturn (m + x % m ) % m;\n}\n\nconst int MAX_M = 12;\nconst int MAX_D = 105;\n\nint a[MAX_M];\nint r[MAX_D][MAX_M];\nbool used[MAX_M];\nll n_[MAX_M];\nll u[MAX_M];\n\nint chinese_reminder_theorem (int di, int m, int curr ){\n\n\tmemset (n_, -1LL, sizeof (n_ ) );\n\tmemset (u, -1LL, sizeof (u ) );\n\n\tll N = 1LL;\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) N *= (ll)a[i];\n\n\tif (N == 1LL ) return curr;\n\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) n_[i] = N/(ll)a[i];\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) u[i] = mod_inverse (n_[i], (ll)a[i] );\n\n\tll res = 0LL;\n\trep (i, m ) if (used[i] && r[di][i] != -1 ) res += n_[i]*u[i]*(ll)r[di][i];\n\n\tres %= N;\n\n\treturn (res != 0LL ? (int)res : -1 );\t\t\t\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\tmemset (a, 0, sizeof (a ) );\n\tmemset (r, 0, sizeof (r ) );\n\tmemset (used, false, sizeof (used ) );\n\tios_base::sync_with_stdio(0);\n\tint n, m, d; cin >> n >> m >> d;\n\n\trep (i, m ) cin >> a[i];\n\trep (i, d ) rep (j, m ) cin >> r[i][j];\n\n\trep (i, m ) used[i] = true;\n\tvector<int> sum_n (m, 0 );\n\trep (j, m ) {\n\t\tint cnt = 0;\n\t\trep (i, d ) if (r[i][j] == -1 ) cnt++;\n\t\tsum_n[j] = cnt;\n\t} // end rep\n\t\n\trep (i, m ){\n\t\tif (!used[i] ) continue;\n\t\tfor (int j = i+1; j < m; j++ ){\n\t\t\tif (__gcd (a[i], a[j] ) != 1 ){\n\t\t\t\tif (sum_n[i] <= sum_n[j] )\n\t\t\t\t\tused[j] = false;\n\t\t\t\telse\n\t\t\t\t\tused[i] = false;\n\t\t\t\tbreak;\n\t\t\t} // end if\n\t\t} // end for\n\t} // end rep\n\n\tint res = n;\n\trep (i, d ){\n\t\tint curr = chinese_reminder_theorem (i, m, res );\n\t\tres = min (res, curr );\n\t} // end rep\n\tcerr << res << endl;\n\t\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(){\n  int i, j;\n  int n, m, d;\n  int a[10];\n  int p[10];\n  int r[10];\n\n  scanf(\"%d%d%d\", &n, &m, &d);\n\n  for(i = 0; i < m; i++)\n    scanf(\"%d\", a + i);\n\n  for(i = 0; i < m; i++)\n    p[i] = a[i] * 100;\n\n\n  for(i = 0; i < d; i++){\n    for(j = 0; j < m; j++)\n      scanf(\"%d\", r + j);\n\n    for(j = 0; j < m; j++)\n      if(r[j] != -1)\n\tr[j] = (n % a[j] + a[j] - r[j]) % a[j];\n\n    while(n >= 0){\n      int ok = 1;\n      int mx = 0;\n\n      for(j = 0; j < m; j++)\n\tif(r[j] > 0){ ok = 0; break; }\n\n      if(ok) break;\n\n      for(j = 0; j < m; j++)\n\tif(r[j] > mx) mx = r[j];\n\n      for(j = 0; j < m; j++)\n\tif(r[j] >= 0){\n\t  r[j] = (r[j] + p[j] - mx) % a[j];\n\t}\n\n      n -= mx;\n    }\n  }\n\n  if(n < 0) puts(\"-1\");\n  else printf(\"%d\\n\", n);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(){\n  int i, j;\n  int n, m, d;\n  int a[10];\n  int r[10];\n\n  scanf(\"%d%d%d\", &n, &m, &d);\n\n  for(i = 0; i < m; i++)\n    scanf(\"%d\", a + i);\n\n  for(i = 0; i < d; i++){\n    for(j = 0; j < m; j++)\n      scanf(\"%d\", r + j);\n\n    for(j = 0; j < m; j++)\n      if(r[j] != -1)\n\tr[j] = (n % a[j] + a[j] - r[j]) % a[j];\n\n    while(n >= 0){\n      int ok = 1;\n\n      for(j = 0; j < m; j++){\n\tok &= r[j] <= 0;\n\tif(r[j] >= 0){\n\t  if(r[j] == 0) r[j] = a[j] - 1;\n\t  else r[j]--;\n\t}\n      }\n\n      if(ok) break;\n      n--;\n    }\n  }\n\n  printf(\"%d\\n\", n);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(){\n  int i, j;\n  int n, m, d;\n  int a[10];\n  int r[10];\n\n  scanf(\"%d%d%d\", &n, &m, &d);\n\n  for(i = 0; i < m; i++)\n    scanf(\"%d\", a + i);\n\n  for(i = 0; i < d; i++){\n    for(j = 0; j < m; j++)\n      scanf(\"%d\", r + j);\n\n    while(n >= 0){\n      int ok = 1;\n\n      for(j = 0; j < m; j++){\n\tif(r[j] != -1 && n % a[j] != r[j]){\n\t  ok = 0;\n\t  break;\n\t}\n      }\n\n      if(ok) break;\n      n--;\n    }\n  }\n\n  printf(\"%d\\n\", n);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(){\n  int i, j;\n  int n, m, d;\n  int a[10];\n  int p[10];\n  int r[10];\n\n  scanf(\"%d%d%d\", &n, &m, &d);\n\n  for(i = 0; i < m; i++)\n    scanf(\"%d\", a + i);\n\n  for(i = 0; i < m; i++)\n    p[i] = r[i] * 100;\n\n\n  for(i = 0; i < d; i++){\n    for(j = 0; j < m; j++)\n      scanf(\"%d\", r + j);\n\n    for(j = 0; j < m; j++)\n      if(r[j] != -1)\n\tr[j] = (n % a[j] + a[j] - r[j]) % a[j];\n\n    while(n >= 0){\n      int ok = 1;\n      int mx = 0;\n\n      for(j = 0; j < m; j++)\n\tif(r[j] > 0){ ok = 0; break; }\n\n      if(ok) break;\n\n      for(j = 0; j < m; j++)\n\tif(r[j] > mx) mx = r[j];\n\n      for(j = 0; j < m; j++)\n\tif(r[j] >= 0){\n\t  r[j] = (r[j] + p[j] - mx) % a[j];\n\t}\n\n      n -= mx;\n    }\n  }\n\n  if(n < 0) puts(\"-1\");\n  else printf(\"%d\\n\", n);\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MMAX 10\ntypedef long long ll;\nll gcd(ll a, ll b);\nll extgcd(ll a, ll b, ll *x, ll *y);\nll mod_inverse(ll a, ll m);\nint linear_congruence(int *a, int *b, int *m, ll *x, ll *mod, int msize);\nint main(void)\n{\n  int i, j, n, m, d, lflag, a[MMAX], b[MMAX], mod[MMAX], t[MMAX];\n  scanf(\"%d %d %d\", &n, &m, &d);\n  for (i = 0; i < m; i++) scanf(\"%d\", &t[i]);\n  for (i = 0; i < d; i++) {\n    ll x = 0, mode = 1;\n    for (j = 0; j < m; j++) {\n      scanf(\"%d\", &b[j]);\n      if (b[j] == -1) {\n        a[j] = b[j] = 0;\n        mod[j] = 1;\n      } else {\n        a[j] = 1;\n        mod[j] = t[j];\n      }\n    }\n    lflag = linear_congruence(a, b, mod, &x, &mode, m);\n    if (!lflag) break;\n    if (mode > n) {\n      if (x > n) {\n        lflag = 0;\n        break;\n      }\n      n = x;\n    } else {\n      x += ((n - x) / mode) * mode;\n      n = x;\n    }\n  }\n  if (lflag) printf (\"%d\\n\", n);\n  else printf(\"-1\\n\");\n}\n\nll gcd(ll a, ll b)\n{\n  if (b == 0LL) return a;\n  else gcd(b, a % b);\n}\n\nll extgcd(ll a, ll b, ll *x, ll *y)\n{\n  ll d = a;\n  if (b != 0LL) {\n    d = extgcd(b, a % b, y, x);\n    *y -= (a / b) * (*x);\n  } else {\n    *x = 1LL;\n    *y = 0LL;\n  }\n  return d;\n}\n\nll mod_inverse(ll a, ll m)\n{\n  ll x, y;\n  extgcd(a, m, &x, &y);\n  return (x % m + m) % m;\n}\n\nint linear_congruence(int *a, int *b, int *m, ll *x, ll *mod, int msize)\n{\n  int i;\n  for (i = 0; i < msize; i++) {\n    ll a2 = a[i] * (*mod), b2 = b[i] - a[i] * (*x), d = gcd(m[i], a2), t;\n    if (b2 % d != 0LL) return 0;\n    t = b2 / d * mod_inverse(a2 / d, m[i] / d) % (m[i] / d);\n    *x += (*mod) * t;\n    *mod *= m[i] / d;\n  }\n  *x = ((*x)  + (*mod)) % (*mod);\n  return 1;\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>?): Unit {\n    val (n, _, d) = readLine()!!.trim().split(' ').map(String::toInt)\n    val mod = readLine()!!.trim().split(' ').map(String::toLong)\n    val suspects = List(d){\n        val r = readLine()!!.trim().split(' ').map(String::toLong)\n        mod.zip(r).fold(Pair(1L, 0L) as Pair<Long, Long>?) { pair, (a, r) ->\n            if (r != -1L) {\n                pair?.let { (product, prev) ->\n                    newMod(product, prev, a, r)?.let {\n                        newR ->\n                        Pair(lcm(product, a), newR)\n                    }\n                }\n            }else pair\n        }\n    }\n    println(\n            suspects.fold(n.toLong() as Long?){current, pair ->\n                if (current != null && pair != null && current >= pair.second) {\n                    (current - pair.second) / pair.first * pair.first + pair.second\n                }\n                else null\n            } ?: -1\n    )\n}\nfun lcm(a: Long, b: Long): Long {\n    return a * b / gcd(a, b)\n}\ntailrec fun gcd(a: Long, b: Long): Long {\n    return when(b){\n        0L -> a\n        else -> gcd(b, a % b)\n    }\n}\nfun newMod(x: Long, mx: Long, y: Long, my: Long): Long? {\n    tailrec fun sub(x: Long, y: Long, ax: Long, ay: Long, bx: Long, by: Long): Pair<Long, Long> {\n        val a = ax * x + ay * y\n        val b = bx * x + by * y\n        return when (a % b) {\n            0L -> if (bx > 0) Pair(bx, by) else Pair(bx + y, by - x)\n            else -> {\n                val r = a / b\n                sub(x, y, bx, by,ax - r * bx, ay - r * by)\n            }\n        }\n    }\n    val g = gcd(x, y)\n    return when{\n        gcd(g, mx) == gcd(g, my) -> {\n            val (ax, ay) = sub(x / g, y / g, 1, 0, 0, 1)\n            val nx = ax * my % y\n            val ny = ((ay % x + x) % x) * mx % x\n            val ux = x / g\n            val uy = y / g\n            val r = ((nx * ux + ny * uy) % (x * y / g) + (x * y / g)) % (x * y / g)\n            r\n        }\n        else -> null\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint d = sc.nextInt();\n\t\tint[] numbers = new int[m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t    numbers[i] = sc.nextInt();\n\t\t}\n\t\tint[][] dayNums = new int[d][m];\n\t\tfor (int i = 0; i < d; i++) {\n\t\t    for (int j = 0; j < m; j++) {\n\t\t        dayNums[i][j] = sc.nextInt();\n\t\t    }\n\t\t}\n\t\tfor (int i = 0; i < d; i++) {\n\t\t    boolean flag = true;\n\t\t    while (flag && n >= 0) {\n\t\t        flag = false;\n\t\t        for (int j = 0; j < m; j++) {\n\t\t            int x = dayNums[i][j];\n\t\t            if (x == -1) {\n\t\t                continue;\n\t\t            }\n\t\t            if (n % numbers[j] != x) {\n\t\t                flag = true;\n\t\t                n -= (n % numbers[j] - x + numbers[j]) % numbers[j];\n\t\t                break;\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t}\n\t\tif (n < 0) {\n\t\t    System.out.println(-1);\n\t\t} else {\n\t\t    System.out.println(n);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python3\n\ndef gcd(m, n):\n    while n: m, n = n, m % n\n    return m\n\ndef lcm(m, n):\n    return m // gcd(m, n) * n\n\nclass congruence(object):\n    def __init__(self):\n        self.sol = 0\n        self.mod = 1\n    def append(self, a, q):\n        x = self.sol\n        p = self.mod\n        l = lcm(p, q)\n        while x < l:\n            if (x % q) == a:\n                self.sol = x\n                self.mod = l\n                return\n            x += p\n        else:\n            raise ValueError('nyan')\n    def get(self):\n        return (self.sol, self.mod)\n\ndef main():\n    N, M, D = list(map(int, input().split()))\n    A = list(map(int, input().split()))\n\n    for i in range(D):\n        R = list(map(int, input().split()))\n        crt = congruence()\n        for r, a in zip(R, A):\n            if r == -1: continue\n            crt.append(r, a)\n\n        x, p = crt.get()\n        if N < x:\n            print(-1)\n            return 0\n\n        y = (N-x) // p * p + x\n        if not 0 <= y <= N:\n            print(-1)\n            return 0\n\n        N = y\n\n    print(N)\n    return 0\n\ntry:\n    main()\nexcept ValueError:\n    print(-1)\n\n"
  },
  {
    "language": "Python",
    "code": "def extgcd(a,b):\n    if b == 0:\n        x = 1\n        y = 0\n        return a,x,y\n    g,s,t = extgcd(b,a%b)\n    x,y = t,s-a//b*t\n    return g,x,y\n\ndef chineserem(b,m):\n    r = 0\n    M = 1\n    for i in range(len(b)):\n        g,p,q = extgcd(M,m[i])\n        if (b[i]-r)%g != 0:\n            return 0,-1\n        tmp = (b[i]-r)//g*p%(m[i]//g)\n        r += M*tmp\n        M *= m[i]//g\n    return r,M\nn,m,d = [int(x) for x in input().split()]\na = [int(x) for x in input().split()]\nr = [[int(x) for x in input().split()] for i in range(d)]\nfor d in range(d):\n    mo = []\n    b = []\n    for i in range(m):\n        if r[d][i] > -1:\n            mo.append(a[i])\n            b.append(r[d][i])\n    x,M = chineserem(b,mo)\n    if M < 0:\n        print(-1)\n        quit()\n    i = (n-x)//M\n    if i < 0:\n        print(-1)\n        quit()\n    n = M*i+x\nprint(n)\n\n"
  }
]