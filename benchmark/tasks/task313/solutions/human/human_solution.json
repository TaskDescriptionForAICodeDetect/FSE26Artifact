[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nconst int INF = 100000;\n\nstruct UF{\n    int par[202],r[202],cnt;\n    void init(){\n        for(int i = 0 ; i < 202 ; i ++){\n            par[i] = i;\n            r[i] = 0;\n        }\n        cnt = 0;\n    }\n    int find(int x){\n        if(par[x] == x)return x;\n        return par[x] = find(par[x]);\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n    void unit(int x,int y){\n        if(same(x,y))return;\n        cnt ++;\n        x = find(x);\n        y = find(y);\n        if(r[x] < r[y]){\n            par[x] = y;\n        }\n        else {\n            par[y] = x;\n            if(r[x] == r[y]){\n                r[x] ++;\n            }\n        }\n    }\n}uf;\n\nint main(){\n    while(1){\n        int n,m,k;\n        scanf(\"%d%d%d\",&n,&m,&k);\n        if(n == 0 && m == 0 && k == 0)return 0;\n        uf.init();\n        vector<pair<int,pair<int,int>>> A,B;\n        for(int i = 0 ; i < m ; i ++){\n            int u,v,w;\n            char l;\n            scanf(\"%d%d%d %c\",&u,&v,&w,&l);\n            if(l == 'A')A.push_back(pair<int,pair<int,int>>(w,pair<int,int>(u,v)));\n            else B.push_back(pair<int,pair<int,int>>(w,pair<int,int>(u,v)));\n            uf.unit(u,v);\n        }\n        if(uf.cnt < n-1){\n            puts(\"-1\");\n            continue;\n        }\n        vector<pair<int,pair<int,int>>> _A,_B;\n        sort(A.begin(),A.end());\n        uf.init();\n        for(int i = 0 ; i < A.size() ; i ++){\n            if(uf.same(A[i].second.first,A[i].second.second)){}\n            else {\n                uf.unit(A[i].second.first,A[i].second.second);\n                _A.push_back(A[i]);\n            }\n        }\n        sort(B.begin(),B.end());\n        uf.init();\n        for(int i = 0 ; i < B.size() ; i ++){\n            if(uf.same(B[i].second.first,B[i].second.second)){}\n            else{\n                uf.unit(B[i].second.first,B[i].second.second);\n                _B.push_back(B[i]);\n            }\n        }\n        if(k+_B.size() < n-1){\n            puts(\"-1\");\n            continue;\n        }\n        \n        /*puts(\"------_A------\");\n        for(int i = 0 ; i < _A.size() ; i ++){\n            printf(\"%d %d %d%c\",_A[i].first,_A[i].second.first,_A[i].second.second,10);\n        }\n        puts(\"------_B------\");\n        for(int i = 0 ; i < _B.size() ; i ++){\n            printf(\"%d %d %d%c\",_B[i].first,_B[i].second.first,_B[i].second.second,10);\n        }*/\n        \n        k -= n-1-_B.size();\n        vector<int> vec;\n        int ret = 0;\n        for(int i = 0 ; i < _A.size() ; i ++)ret += _A[i].first;\n        for(int i = 0 ; i < _B.size() ; i ++)ret += _B[i].first;\n        \n        //cout << ret << endl;\n        \n        for(int i = 0 ; i < _B.size() ; i ++){\n            uf.init();\n            for(int j = 0 ; j < i ; j ++){\n                uf.unit(_B[j].second.first,_B[j].second.second);\n            }\n            for(int j = 0 ; j <= _A.size() ; j ++){\n                if(j == _A.size()){\n                    vec.push_back(INF);\n                    break;\n                }\n                uf.unit(_A[j].second.first,_A[j].second.second);\n                if(uf.same(_B[i].second.first,_B[i].second.second)){\n                    vec.push_back(_A[j].first-_B[i].first);\n                    ret -= _A[j].first;\n                    break;\n                }\n            }\n            //cout << i << \" \" << vec[vec.size()-1] << endl;\n        }\n        sort(vec.begin(),vec.end());\n        for(int i = 0 ; i < k ; i ++){\n            ret += vec[i];\n            if(vec[i] == INF)ret = INF;\n        }\n        if(ret >= INF)ret = -1;\n        printf(\"%d%c\",ret,10);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define whole(xs) xs.begin(),xs.end()\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < int(vs.size()); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    struct Edge {\n        int from, to;\n        int cost;\n        char firm;\n        Edge() {}\n        Edge(int from, int to, int cost, char firm) : from(from), to(to), cost(cost), firm(firm) {}\n    };\n    bool operator<(const Edge& a, const Edge& b) {\n        if (a.cost == b.cost) return a.firm < b.firm;\n        return a.cost < b.cost;\n    }\n    ostream& operator<<(ostream& os, const Edge& e) {\n        return os << \"Edge(\" << e.from << \"->\" << e.to << \" \" << e.cost << \" \" << e.firm << \")\";\n    }\n\n    int N, M, K;\n    vector<Edge> es;\n    bool input() {\n        cin >> N >> M >> K;\n        if (N == 0 && M == 0 && K == 0) return false;\n        es.clear();\n        for (int i = 0; i < M; i++) {\n            int u, v, w; char l;\n            cin >> u >> v >> w >> l;\n            u--; v--;\n            es.emplace_back(u, v, w, l);\n        }\n        return true;\n    }\n\n    struct UnionFind {\n        int N;\n        vector<int> P;\n        UnionFind(int N) : N(N) {\n            P.clear(); P.resize(N, -1);\n        }\n        int root(int x) {\n            if (P[x] == -1) return x;\n            return P[x] = root(P[x]);\n        }\n        int query(int x, int y) {\n            return root(x) == root(y);\n        }\n        void merge(int x, int y) {\n            x = root(x); y = root(y);\n            if (x == y) return;\n            P[x] = y;\n        }\n    };\n\n    const int INF = 1<<20;\n\n    int countA(int k) {\n        vector<Edge> fs = es;\n        for (int i = 0; i < M; i++) {\n            Edge& f = fs[i];\n            if (f.firm == 'A') f.cost += k;\n        }\n        sort(whole(fs));\n        UnionFind uf(N);\n        int count = 0;\n        for (int i = 0; i < M; i++) {\n            const Edge& f = fs[i];\n            if (uf.query(f.from, f.to)) continue;\n            uf.merge(f.from, f.to);\n            if (f.firm == 'A') count++;\n        }\n        return count;\n    }\n\n    int cost(int k) {\n        vector<Edge> fs = es;\n        for (int i = 0; i < M; i++) {\n            Edge& f = fs[i];\n            if (f.firm == 'A') f.cost += k;\n        }\n        int count = 0;\n        sort(whole(fs));\n        UnionFind uf(N);\n        int ret = 0;\n        for (int i = 0; i < M; i++) {\n            const Edge& f = fs[i];\n            if (uf.query(f.from, f.to)) continue;\n            if (f.firm == 'A') {\n                if (count == K) continue;\n                count++;\n            }\n            uf.merge(f.from, f.to);\n            ret += f.cost - (f.firm == 'A' ? k : 0);\n        }\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (not uf.query(i, j)) return -1;\n            }\n        }\n        return ret;\n    }\n\n\n    void solve() {\n        int lb = -INF, ub = INF;\n        int p = countA(lb), q = countA(ub);\n        if ( (p - K) * (q - K) > 0 ) {\n            cout << -1 << endl;\n            return;\n        }\n        while (lb + 1 < ub) {\n            int mid = (lb + ub) / 2;\n            //cerr << mid << \" -> \" << countA(mid) << endl;\n            if (countA(mid) >= K) {\n                lb = mid;\n            } else {\n                ub = mid;\n            }\n        }\n        cout << cost(lb) << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nstruct UnionFind{\n\tint par[210],rank[210];\n\tvoid init(){\n\t\tfor(int i=0;i<210;i++){par[i]=i;rank[i]=0;}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]>rank[y])par[y]=x;\n\t\telse{\n\t\t\tpar[x]=y;\n\t\t\tif(rank[x]==rank[y])rank[y]++;\n\t\t}\n\t\treturn;\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nstruct edge{\n\tint from,to,cost;\n\tedge(){}\n\tedge(int from,int to,int cost):from(from),to(to),cost(cost){}\n\tbool operator < (const edge& a) const{\n\t\treturn cost < a.cost;\n\t}\n};\nint n,m,k;\nvector<edge> A,B;\nint cost,use_a,use;\nint check(int x){\n\tuf.init();\n\tint p = 0,q = 0;\n\tcost = 0;\n\tuse_a = 0;\n\tuse = 0;\n\twhile(p<A.size()&&q<B.size()){\n\t\tedge e;\n\t\tbool flag = false;\n\t\tif(p==A.size())e = B[q++];\n\t\telse if(q==B.size()){\n\t\t\te = A[p++];\n\t\t\tflag = true;\n\t\t}else{\n\t\t\tif(A[p].cost+x<B[q].cost){\n\t\t\t\te = A[p++];\n\t\t\t\tflag = true;\n\t\t\t}else if(A[p].cost+x==B[q].cost){\n\t\t\t\tif(use_a<k){\n\t\t\t\t\te = A[p++];\n\t\t\t\t\tflag = true;\n\t\t\t\t}else e = B[q++];\n\t\t\t}else e = B[q++];\n\t\t}\n\t\tif(!uf.same(e.from,e.to)){\n\t\t\tuf.unite(e.from,e.to);\n\t\t\tcost += e.cost;\n\t\t\tif(flag)use_a++;\n\t\t\tuse++;\n\t\t}\n\t}\n\treturn use_a;\n}\nbool solve(){\n\tcin >> n >> m >> k;\n\tif(n==0&&m==0&&k==0)return false;\n\tA.clear();\n\tB.clear();\n\tfor(int i=0;i<m;i++){\n\t\tint u,v,c;\n\t\tchar l;\n\t\tcin >> u >> v >> c >> l;\n\t\tif(l=='A')A.pb(edge(u,v,c));\n\t\telse B.pb(edge(u,v,c));\n\t}\n\tsort(all(A));\n\tsort(all(B));\n\tint l=-150,r=150;\n\twhile(r-l>1){\n\t\tint mid = (l+r)/2;\n\t\tif(check(mid)>k)l=mid;\n\t\telse r = mid;\n\t}\n\tcheck(r);\n\tif(use<n-1||use_a!=k)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",cost);\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing P = tuple<int, int, int>;\n\nint n, k;\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nusing Elem = tuple<int, int, int, int>;\n\nint kruskal(vector<vector<P>> graph, int diff){\n    vi a_cnt(2);\n    rep(v, n) for(auto & e : graph[v]) if(get<1>(e) == 0) get<0>(e) += diff;\n    int ret = 0;\n    rep(ai, 2){\n        priority_queue<Elem, vector<Elem>, greater<Elem>> q;\n        rep(v, n){\n            for(auto & e : graph[v]){\n                int u, w, l;\n                tie(w, l, u) = e;\n\n                l *= -1;\n                e = P(w, l, u);\n                assert(l == 0 or l == 1 or l == -1);\n\n                if(v < u){\n                    q.push(Elem(w, l, u, v));\n                }\n            }\n        }\n\n        UnionFind uf(n);\n        ret = 0;\n        int cnt = 0;\n        while(q.size()){\n            int w, l, v, u;\n            tie(w, l, v, u) = q.top(); q.pop();\n\n            assert(l == 0 or l == 1 or l == -1);\n\n            if(uf.findSet(v, u)) continue;\n            uf.unionSet(v, u);\n            cnt++;\n\n            ret += w;\n            if(l == 0){\n                a_cnt[ai]++;\n            }\n        }\n        if(cnt != n - 1){\n            return -1;\n        }\n    }\n\n    ret -= diff * k;\n    if(a_cnt[0] > a_cnt[1]) swap(a_cnt[0], a_cnt[1]);\n\n    // cerr << a_cnt << endl;\n    if(not (a_cnt[0] <= k and k <= a_cnt[1])) ret = (a_cnt[1] > k ? -1 : -2);\n\n    return ret;\n}\n\nint offset = 10000;\n\nint main(void){\n    for(int m; cin >> n >> m >> k, n;){\n        vector<vector<P>> graph(n);\n        rep(loop, m){\n            int u, v, w; char l; cin >> u >> v >> w >> l;\n            u--, v--, w += offset;\n            assert(0 <= u and u < n and 0 <= v and v < n);\n\n            graph[u].push_back(P(w, l == 'A' ? 0:1, v));\n            graph[v].push_back(P(w, l == 'A' ? 0:1, u));\n        }\n\n        int lb = -offset, ub = offset;\n        int res = -1;\n        rep(loop, 100){\n            int mid = (lb + ub) / 2;\n\n            int ret = kruskal(graph, mid);\n            if(ret == -2){\n                ub = mid;\n            }\n            else if(ret == -1){\n                lb = mid;\n            }\n            else {\n                res = ret - (offset * (n - 1));\n                break;\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nstruct UnionFind{\n\tint par[210],rank[210];\n\tvoid init(){\n\t\tfor(int i=0;i<210;i++){par[i]=i;rank[i]=0;}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]>rank[y])par[y]=x;\n\t\telse{\n\t\t\tpar[x]=y;\n\t\t\tif(rank[x]==rank[y])rank[y]++;\n\t\t}\n\t\treturn;\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nstruct edge{\n\tint from,to,cost;\n\tedge(){}\n\tedge(int from,int to,int cost):from(from),to(to),cost(cost){}\n\tbool operator < (const edge& a) const{\n\t\treturn cost < a.cost;\n\t}\n};\nint n,m,k;\nvector<edge> A,B;\nint cost,use_a,use;\nvoid check(int x){\n\tuf.init();\n\tint p = 0,q = 0;\n\tcost = 0;\n\tuse_a = 0;\n\tuse = 0;\n\twhile(p<A.size()&&q<B.size()){\n\t\tedge e;\n\t\tbool flag = false;\n\t\tif(p==A.size())e = B[q++];\n\t\telse if(q==B.size()){\n\t\t\te = A[p++];\n\t\t\tflag = true;\n\t\t}else{\n\t\t\tif(A[p].cost+x>=B[q].cost){\n\t\t\t\te = A[p++];\n\t\t\t\tflag = true;\n\t\t\t}else e = B[q++];\n\t\t}\n\t\tif(!uf.same(e.from,e.to)){\n\t\t\tuf.unite(e.from,e.to);\n\t\t\tcost += e.cost;\n\t\t\tif(flag)use_a++;\n\t\t\tuse++;\n\t\t}\n\t}\n\treturn;\n}\nbool solve(){\n\tcin >> n >> m >> k;\n\tif(n==0&&m==0&&k==0)return false;\n\tA.clear();\n\tB.clear();\n\tfor(int i=0;i<m;i++){\n\t\tint u,v,c;\n\t\tchar l;\n\t\tcin >> u >> v >> c >> l;\n\t\tif(l=='A')A.pb(edge(u,v,c));\n\t\telse B.pb(edge(u,v,c));\n\t}\n\tsort(all(A));\n\tsort(all(B));\n\tint ans = INF;\n\tfor(int i=-200;i<=200;i++){\n\t\tcheck(i);\n\t\tif(use_a>=k&&use==n-1)ans = min(ans,cost);\n\t}\n\tif(ans==INF)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int INF = 19191919;\nconst int N = 202;\n\nint dp[N][N];\n\nint main(){\n    int n,m,k;\n    while(scanf(\" %d %d %d\", &n, &m, &k),n){\n        vector<vector<pi>> E(n);\n\n        rep(i,m){\n            int u,v,w;\n            char l;\n            scanf(\" %d %d %d %c\", &u, &v, &w, &l);\n\n            int idx = max(u,v)-1;\n            int isa = (l=='A');\n\n            E[idx].pb({w,isa});\n        }\n\n        fill(dp[0],dp[N],INF);\n        dp[0][0] = 0;\n        for(int i=1; i<n; ++i)rep(j,k+1)if(dp[i-1][j]<INF){\n            for(const auto e:E[i]){\n                int w = e.fi;\n                int nj = j+e.se;\n                if(nj>k) continue;\n\n                dp[i][nj] = min(dp[i][nj], dp[i-1][j]+w);\n            }\n        }\n\n        int ans = dp[n-1][k];\n        if(ans == INF) ans = -1;\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate <int N>\nstruct union_find {\n    int par[N];\n    union_find() { for (int i = 0; i < N; ++i) par[i] = -1; }\n\n    int find(int v) {\n        if (par[v] < 0) return v;\n        return par[v] = find(par[v]);\n    }\n\n    bool unite(int x, int y) {\n        int xx = find(x), yy = find(y);\n        if (xx == yy) return false;\n        if (par[xx] < par[yy]) {\n            par[xx] += par[yy];\n            par[yy] = xx;\n        } else {\n            par[yy] += par[xx];\n            par[xx] = yy;\n        }\n        return true;\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nstruct edge {\n    int u, v, cost;\n    char label;\n    edge() {}\n    edge(int u, int v, int cost, char label): u(u), v(v), cost(cost), label(label) {}\n\n    bool operator < (const edge& o) const {\n        return cost == o.cost ? label < o.label : cost < o.cost;\n    }\n};\n\nint N, M, K;\nvector<edge> edges;\n\npair<int, int> kruskal(vector<edge> es, int add_a) {\n    for (edge& e : es)\n        if (e.label == 'A') e.cost += add_a;\n\n    union_find<200> uf;\n\n    sort(begin(es), end(es));\n\n    int weight_sum = 0, a_count = 0, b_count = 0;\n\n    for (const edge& e : es) {\n        if (uf.same(e.u, e.v)) continue;\n        (e.label == 'A' ? a_count : b_count)++;\n        uf.unite(e.u, e.v);\n        weight_sum += e.cost;\n    }\n\n    if (a_count + b_count < N-1) return make_pair(-1, -1);\n    return make_pair(weight_sum, a_count);\n}\n\nint solve() {\n\n    auto pr = kruskal(edges, 0);\n\n    if (pr.first == -1 && pr.second == -1) return -1;\n\n    int l = -101010, r = 101010;\n    while (l+1 < r) {\n        int a = (l + r) / 2;\n\n        pair<int, int> pr = kruskal(edges, a);\n\n        ((pr.second < K) ? r : l) = a;\n    }\n\n    auto res_l = kruskal(edges, l);\n    auto res_r = kruskal(edges, r);\n\n    return (res_r.second <= K && K <= res_l.second) ? res_l.first - l * K : -1;\n}\n\n\nint main(void) {\n    while (true) {\n        cin >> N >> M >> K;\n        edges.clear();\n        if (N == 0 && M == 0 && K == 0) break;\n        for (int i = 0; i < M; ++i) {\n            int u, v, cost; char label;\n            cin >> u >> v >> cost >> label; --u; --v;\n            edges.emplace_back(u, v, cost, label);\n        }\n\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nusing P = tuple<int, int, int>;\n\nint n, k;\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nusing Elem = tuple<int, int, int, int>;\n\nint kruskal(vector<vector<P>> graph, int diff){\n    vi a_cnt(2);\n    rep(v, n) for(auto & e : graph[v]) if(get<1>(e) == 0) get<0>(e) += diff;\n    int ret = 0;\n    rep(ai, 2){\n        priority_queue<Elem, vector<Elem>, greater<Elem>> q;\n        rep(v, n){\n            for(auto & e : graph[v]){\n                int u, w, l;\n                tie(w, l, u) = e;\n\n                l *= -1;\n                e = P(w, l, u);\n                assert(l == 0 or l == 1 or l == -1);\n\n                if(v < u){\n                    q.push(Elem(w, l, u, v));\n                }\n            }\n        }\n\n        UnionFind uf(n);\n        ret = 0;\n        int cnt = 0;\n        while(q.size()){\n            int w, l, v, u;\n            tie(w, l, v, u) = q.top(); q.pop();\n\n            assert(l == 0 or l == 1 or l == -1);\n\n            if(uf.findSet(v, u)) continue;\n            uf.unionSet(v, u);\n            cnt++;\n\n            ret += w;\n            if(l == 0){\n                a_cnt[ai]++;\n            }\n        }\n        assert(cnt == n - 1);\n    }\n\n    ret -= diff * k;\n    if(a_cnt[0] > a_cnt[1]) swap(a_cnt[0], a_cnt[1]);\n\n    // cerr << a_cnt << endl;\n    if(not (a_cnt[0] <= k and k <= a_cnt[1])) ret = (a_cnt[1] > k ? -1 : -2);\n\n    return ret;\n}\n\nint offset = 10000;\n\nint main(void){\n    for(int m; cin >> n >> m >> k, n;){\n        vector<vector<P>> graph(n);\n        rep(loop, m){\n            int u, v, w; char l; cin >> u >> v >> w >> l;\n            u--, v--, w += offset;\n            assert(0 <= u and u < n and 0 <= v and v < n);\n\n            graph[u].push_back(P(w, l == 'A' ? 0:1, v));\n            graph[v].push_back(P(w, l == 'A' ? 0:1, u));\n        }\n\n        int lb = -offset, ub = offset;\n        int res = -1;\n        rep(loop, 100){\n            int mid = (lb + ub) / 2;\n\n            int ret = kruskal(graph, mid);\n            if(ret == -2){\n                ub = mid;\n            }\n            else if(ret == -1){\n                lb = mid;\n            }\n            else {\n                res = ret - (offset * (n - 1));\n                break;\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define whole(xs) xs.begin(),xs.end()\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < int(vs.size()); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    struct Edge {\n        int from, to;\n        int cost;\n        char firm;\n        Edge() {}\n        Edge(int from, int to, int cost, char firm) : from(from), to(to), cost(cost), firm(firm) {}\n    };\n    bool operator<(const Edge& a, const Edge& b) {\n        if (a.cost == b.cost) return a.firm < b.firm;\n        return a.cost < b.cost;\n    }\n    ostream& operator<<(ostream& os, const Edge& e) {\n        return os << \"Edge(\" << e.from << \"->\" << e.to << \" \" << e.cost << \" \" << e.firm << \")\";\n    }\n\n    int N, M, K;\n    vector<Edge> es;\n    bool input() {\n        cin >> N >> M >> K;\n        if (N == 0 && M == 0 && K == 0) return false;\n        es.clear();\n        for (int i = 0; i < M; i++) {\n            int u, v, w; char l;\n            cin >> u >> v >> w >> l;\n            u--; v--;\n            es.emplace_back(u, v, w, l);\n        }\n        return true;\n    }\n\n    struct UnionFind {\n        int N;\n        vector<int> P;\n        UnionFind(int N) : N(N) {\n            P.clear(); P.resize(N, -1);\n        }\n        int root(int x) {\n            if (P[x] == -1) return x;\n            return P[x] = root(P[x]);\n        }\n        int query(int x, int y) {\n            return root(x) == root(y);\n        }\n        void merge(int x, int y) {\n            x = root(x); y = root(y);\n            if (x == y) return;\n            P[x] = y;\n        }\n    };\n\n    const int INF = 1<<20;\n\n    int countA(int k) {\n        vector<Edge> fs = es;\n        for (int i = 0; i < M; i++) {\n            Edge& f = fs[i];\n            if (f.firm == 'A') f.cost += k;\n        }\n        sort(whole(fs));\n        UnionFind uf(N);\n        int count = 0;\n        for (int i = 0; i < M; i++) {\n            const Edge& f = fs[i];\n            if (uf.query(f.from, f.to)) continue;\n            uf.merge(f.from, f.to);\n            if (f.firm == 'A') count++;\n        }\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (not uf.query(i, j)) throw(-1);\n            }\n        }\n        return count;\n    }\n\n    int cost(int k) {\n        vector<Edge> fs = es;\n        for (int i = 0; i < M; i++) {\n            Edge& f = fs[i];\n            if (f.firm == 'A') f.cost += k;\n        }\n        int count = 0;\n        sort(whole(fs));\n        UnionFind uf(N);\n        int ret = 0;\n        for (int i = 0; i < M; i++) {\n            const Edge& f = fs[i];\n            if (uf.query(f.from, f.to)) continue;\n            if (f.firm == 'A') {\n                if (count == K) continue;\n                count++;\n            }\n            uf.merge(f.from, f.to);\n            ret += f.cost - (f.firm == 'A' ? k : 0);\n        }\n        return ret;\n    }\n\n\n    void solve() {\n        int lb = -INF, ub = INF;\n        int p, q;\n        try {\n            p = countA(lb); q = countA(ub);\n        } catch (int e) {\n            cout << -1 << endl;\n            return;\n        }\n        if ( (p - K) * (q - K) > 0 ) {\n            cout << -1 << endl;\n            return;\n        }\n        while (lb + 1 < ub) {\n            int mid = (lb + ub) / 2;\n            //cerr << mid << \" -> \" << countA(mid) << endl;\n            if (countA(mid) >= K) {\n                lb = mid;\n            } else {\n                ub = mid;\n            }\n        }\n        cout << cost(lb) << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint par[200];\nint rank1[200];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v, cost,col; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nedge cop[600];\nint V, E;\nint k;\nP kruskal() {\n\tsort(cop, cop + E, comp);\n\tinit(V);\n\tint res = 0; int cost = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tedge e = cop[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tcost += e.cost;\n\t\t\tif (e.col == 0) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn { res,cost };\n}\nedge ori[600];\nvoid init2() {\n\trep(i, E) {\n\t\tcop[i] = ori[i];\n\t}\n\treturn;\n}\nbool ooo(int x) {\n\tinit2();\n\trep(i, E) {\n\t\tif (cop[i].col == 0) {\n\t\t\tcop[i].cost += x;\n\t\t}\n\t}\n\tP r = kruskal();\n\tif (r.first < k) {\n\t\treturn false;\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> V >> E >> k, V) {\n\t\tint le = -1000000; int ri = 1000000;\n\t\trep(i, E) {\n\t\t\tint x, y, z;char w;\n\t\t\tcin >> x >> y >> z >> w; x--; y--;\n\t\t\tori[i] = { x,y,z,w - 'A' };\n\t\t}\n\t\twhile (ri - le > 1) {\n\t\t\tint mid = (ri + le) / 2;\n\t\t\tif (ooo(mid)) {\n\t\t\t\tle = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tri = mid;\n\t\t\t}\n\t\t}\n\t\tinit2();\n\t\trep(i, E) {\n\t\t\tif (cop[i].col == 0) {\n\t\t\t\tcop[i].cost += le;\n\t\t\t}\n\t\t}\n\t\tP fin1 = kruskal();\n\t\tinit2();\n\t\trep(i, E) {\n\t\t\tif (cop[i].col == 0) {\n\t\t\t\tcop[i].cost += ri;\n\t\t\t}\n\t\t}\n\t\tP fin2 = kruskal();\n\t\tif (fin1.first < k || k < fin2.first) {\n\t\t\tcout << -1 << endl; continue;\n\t\t}\n\t\tbool f = true;\n\t\trep(i, V) {\n\t\t\trep(j, V) {\n\t\t\t\tif (!same(i, j)) {\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!f) {\n\t\t\tcout << -1 << endl; continue;\n\t\t}\n\t\tcout << fin1.second - k * le << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"<\" << p.first << \",\" << p.second\n       << \">\";\n    return os;\n}\nclass DisjointSets\n{\npublic:\n    DisjointSets(const int v) : parent(v), rank(v, 0), size(v, 1) { iota(parent.begin(), parent.end(), 0); }\n    bool same(const int a, const int b) { return find(a) == find(b); }\n    int find(const int a) { return parent[a] == a ? a : parent[a] = find(parent[a]); }\n    void unite(int a, int b)\n    {\n        a = find(a);\n        b = find(b);\n        if (a == b) {\n            return;\n        }\n        if (rank[a] < rank[b]) {\n            swap(a, b);\n        }\n        rank[a] += rank[b];\n        size[a] += size[b];\n        parent[b] = a;\n    }\n    int getSize(const int i) { return size[find(i)]; }\n\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    vector<int> size;\n};\nstruct Edge {\n    Edge(const int u, const int v, const int w, const char l) : u{u}, v{v}, w{w}, A{(int)(l == 'A')} {}\n    int u;\n    int v;\n    int w;\n    int A;\n    bool operator<(const Edge& e) const\n    {\n        return w != e.w ? w < e.w : A > e.A;\n    }\n};\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        constexpr int MAX = 1000;\n        int N, M, K;\n        cin >> N >> M >> K;\n        if (N == 0 and M == 0 and K == 0) {\n            break;\n        }\n        vector<Edge> e;\n        DisjointSets UF(N);\n        for (int i = 0; i < M; i++) {\n            int u, v, w;\n            char l;\n            cin >> u >> v >> w >> l;\n            u--, v--;\n            e.push_back(Edge(u, v, w, l));\n            UF.unite(u, v);\n        }\n        if (UF.getSize(0) < N) {\n            cout << -1 << endl;\n            continue;\n        }\n        if (K == 0 or K == N - 1) {\n            const int a = K == N - 1;\n            sort(e.begin(), e.end());\n            DisjointSets uf(N);\n            int sum = 0;\n            for (int i = 0; i < M; i++) {\n                if (e[i].A != a) {\n                    continue;\n                }\n                const int u = e[i].u;\n                const int v = e[i].v;\n                if (not uf.same(u, v)) {\n                    uf.unite(u, v);\n                    sum += e[i].w;\n                }\n            }\n            cout << sum << endl;\n        } else {\n            auto check = [&](const int c) {\n                vector<Edge> E = e;\n                for (int i = 0; i < M; i++) {\n                    if (E[i].A == 1) {\n                        E[i].w = e[i].w + c;\n                    }\n                }\n                sort(E.begin(), E.end());\n                DisjointSets uf(N);\n                int sum = 0;\n                int a = 0;\n                for (int i = 0; i < M; i++) {\n                    const int u = E[i].u;\n                    const int v = E[i].v;\n                    if (not uf.same(u, v)) {\n                        sum += E[i].w;\n                        a += E[i].A;\n                        uf.unite(u, v);\n                    }\n                }\n                return a >= K;\n            };\n            int c = -MAX;\n            for (; c <= MAX; c++) {\n                if (not check(c)) {\n                    break;\n                }\n            }\n            c--;\n            for (int i = 0; i < M; i++) {\n                if (e[i].A == 1) {\n                    e[i].w += c;\n                }\n            }\n            sort(e.begin(), e.end());\n            DisjointSets uf(N);\n            int sum = 0;\n            for (int i = 0; i < M; i++) {\n                const int u = e[i].u;\n                const int v = e[i].v;\n                if (not uf.same(u, v)) {\n                    uf.unite(u, v);\n                    sum += e[i].w;\n                }\n            }\n            cout << (c <= -MAX or c >= MAX - 1 ? -1 : sum - K * c) << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint par[200];\nint rank1[200];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v, cost,col; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nedge cop[600];\nint V, E;\nint k;\nP kruskal() {\n\tsort(cop, cop + E, comp);\n\tinit(V);\n\tint res = 0; int cost = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tedge e = cop[i];\n\t\tif (e.col == 0 && res == k)continue;\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tcost += e.cost;\n\t\t\tif (e.col == 0) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn { res,cost };\n}\nedge ori[600];\nvoid init2() {\n\trep(i, E) {\n\t\tcop[i] = ori[i];\n\t}\n\treturn;\n}\nbool ooo(int x) {\n\tinit2();\n\trep(i, E) {\n\t\tif (cop[i].col == 0) {\n\t\t\tcop[i].cost += x;\n\t\t}\n\t}\n\tP r = kruskal();\n\tif (r.first < k) {\n\t\treturn false;\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> V >> E >> k, V) {\n\t\tint le = -1000000; int ri = 1000000;\n\t\trep(i, E) {\n\t\t\tint x, y, z;char w;\n\t\t\tcin >> x >> y >> z >> w; x--; y--;\n\t\t\tori[i] = { x,y,z,w - 'A' };\n\t\t}\n\t\twhile (ri - le > 1) {\n\t\t\tint mid = (ri + le) / 2;\n\t\t\tif (ooo(mid)) {\n\t\t\t\tle = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tri = mid;\n\t\t\t}\n\t\t}\n\t\tinit2();\n\t\trep(i, E) {\n\t\t\tif (cop[i].col == 0) {\n\t\t\t\tcop[i].cost += le;\n\t\t\t}\n\t\t}\n\t\tP fin1 = kruskal();\n\t\tif (fin1.first != k) {\n\t\t\tcout << -1 << endl; continue;\n\t\t}\n\t\tbool f = true;\n\t\trep(i, V) {\n\t\t\trep(j, V) {\n\t\t\t\tif (!same(i, j)) {\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!f) {\n\t\t\tcout << -1 << endl; continue;\n\t\t}\n\t\tcout << fin1.second - k * le << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define whole(xs) xs.begin(),xs.end()\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < int(vs.size()); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    struct Edge {\n        int from, to;\n        int cost;\n        char firm;\n        Edge() {}\n        Edge(int from, int to, int cost, char firm) : from(from), to(to), cost(cost), firm(firm) {}\n    };\n    bool operator<(const Edge& a, const Edge& b) {\n        if (a.cost == b.cost) return a.firm < b.firm;\n        return a.cost < b.cost;\n    }\n    ostream& operator<<(ostream& os, const Edge& e) {\n        return os << \"Edge(\" << e.from << \"->\" << e.to << \" \" << e.cost << \" \" << e.firm << \")\";\n    }\n\n    int N, M, K;\n    vector<Edge> es;\n    bool input() {\n        cin >> N >> M >> K;\n        if (N == 0 && M == 0 && K == 0) return false;\n        es.clear();\n        for (int i = 0; i < M; i++) {\n            int u, v, w; char l;\n            cin >> u >> v >> w >> l;\n            u--; v--;\n            es.emplace_back(u, v, w, l);\n        }\n        return true;\n    }\n\n    struct UnionFind {\n        int N;\n        vector<int> P;\n        UnionFind(int N) : N(N) {\n            P.clear(); P.resize(N, -1);\n        }\n        int root(int x) {\n            if (P[x] == -1) return x;\n            return P[x] = root(P[x]);\n        }\n        int query(int x, int y) {\n            return root(x) == root(y);\n        }\n        void merge(int x, int y) {\n            x = root(x); y = root(y);\n            if (x == y) return;\n            P[x] = y;\n        }\n    };\n\n    const int INF = 1<<20;\n\n    int countA(int k) {\n        vector<Edge> fs = es;\n        for (int i = 0; i < M; i++) {\n            Edge& f = fs[i];\n            if (f.firm == 'A') f.cost += k;\n        }\n        sort(whole(fs));\n        UnionFind uf(N);\n        int count = 0;\n        for (int i = 0; i < M; i++) {\n            const Edge& f = fs[i];\n            if (uf.query(f.from, f.to)) continue;\n            uf.merge(f.from, f.to);\n            if (f.firm == 'A') count++;\n        }\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (not uf.query(i, j)) throw(-1);\n            }\n        }\n        return count;\n    }\n\n    int cost(int k) {\n        vector<Edge> fs = es;\n        for (int i = 0; i < M; i++) {\n            Edge& f = fs[i];\n            if (f.firm == 'A') f.cost += k;\n        }\n        int count = 0;\n        sort(whole(fs));\n        UnionFind uf(N);\n        int ret = 0;\n        for (int i = 0; i < M; i++) {\n            const Edge& f = fs[i];\n            if (uf.query(f.from, f.to)) continue;\n            uf.merge(f.from, f.to);\n            ret += f.cost;\n        }\n        return ret - K * k;\n    }\n\n\n    void solve() {\n        int lb = -INF, ub = INF;\n        int p, q;\n        try {\n            p = countA(lb); q = countA(ub);\n        } catch (int e) {\n            cout << -1 << endl;\n            return;\n        }\n        if ( (p - K) * (q - K) > 0 ) {\n            cout << -1 << endl;\n            return;\n        }\n        while (lb + 1 < ub) {\n            int mid = (lb + ub) / 2;\n            //cerr << mid << \" -> \" << countA(mid) << endl;\n            if (countA(mid) >= K) {\n                lb = mid;\n            } else {\n                ub = mid;\n            }\n        }\n        cout << cost(lb) << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* UnionFind */\n\nstruct UnionFind{\n  vector<int> data, tree_size;\n  UnionFind(int s):data(s,-1),tree_size(s,1) {}\n  \n  int root(int x){\n    //debug(x);\n    if(data[x]==-1) return x;\n    return data[x]=root(data[x]);\n  }\n  \n  bool set(int x,int y){\n    x=root(x);\n    y=root(y);\n    if(x==y) return false;\n    data[y]=x;\n    tree_size[x] += tree_size[y];\n    tree_size[y] = 0;\n    return true;\n  }\n  \n  bool check(int x,int y){\n    x=root(x);\n    y=root(y);\n    return x==y;\n  }\n  \n  int size(int x){\n    return tree_size[root(x)];\n  }\n  \n};\n\n\nint n, m, k;\nint u[SIZE], v[SIZE], w[SIZE], l[SIZE];\n\nint check(int x){\n  vector<pair<int,int> > vec;\n  int sum = 0;\n\n  for(int i=0;i<m;i++){\n    vec.push_back({(w[i] + x * !l[i])*2 + l[i], i});\n  }\n\n  sort(vec.begin(), vec.end());\n\n  int counter = 0, Acounter = 0;\n  UnionFind uf(n);\n  \n  for(int i=0;i<m;i++){\n    if(uf.set(u[vec[i].second], v[vec[i].second])){\n      counter++;\n      Acounter += !l[vec[i].second];\n    }\n  }\n  \n  if(counter == n-1)\n    return Acounter;\n  else\n    return -1;\n}\n\nint make(int x){\n  vector<pair<int,int> > vec;\n  int sum = 0;\n\n  for(int i=0;i<m;i++){\n    vec.push_back({(w[i] + x * !l[i])*2 + l[i], i});\n  }\n\n  sort(vec.begin(), vec.end());\n\n  int counter = 0, Acounter = 0;\n  int limit = k;\n  UnionFind uf(n);\n  \n  for(int i=0;i<m;i++){\n    if(limit <= 0 && !l[vec[i].second]) continue;\n    if(uf.set(u[vec[i].second], v[vec[i].second])){\n      counter++;\n      Acounter += !l[vec[i].second];\n      sum += w[vec[i].second] + x * !l[vec[i].second];\n      //limit -= !l[vec[i].second];\n    }\n  }\n\n  assert(counter == n-1);\n  \n  return sum;\n}\n\nbool solve(){\n  \n  scanf(\"%d%d%d\", &n, &m, &k);\n  if(n == 0) return false;\n  \n  for(int i=0;i<m;i++){\n    char c;\n    scanf(\"%d%d%d %c\", u+i, v+i, w+i, &c);\n    u[i]--; v[i]--;\n    l[i] = c - 'A';\n    //debug(u[i]); debug(v[i]);\n    assert(u[i] < n && v[i] < n);\n  }\n\n  int L = -200, R = 200;\n\n  //cerr << check(L,0) << \"-\" <<  check(R+1,0) << endl;\n  //cerr << check(L,1) << \"-\" <<  check(R+1,1) << endl;\n  \n  if(check(L) == -1 || (k < check(R) || check(L) < k)){\n    puts(\"-1\");\n    return true;\n  }\n  \n  while(L < R){\n    int mid = (L+R+1)/2;\n\n    if(check(mid) < k){\n      R = mid - 1;\n    }else{\n      L = mid;\n    }\n  }\n\n  //debug(L * k);\n  \n  int res = make(L);\n\n  //debug(res);\n  \n  cout << res - L * k<< endl;\n\n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst ll inf =1LL << 62;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\ntypedef tuple<int, int, int> P;\n\nint n, k;\n\nint prim (vector<vector<P>> graph, int diff) {\n    rep(v, n){\n        for(auto & e : graph[v]){\n            int u, w, l;\n            tie(w, l, u) = e;\n\n            if(l == 1) continue;\n            w += diff;\n            e = P(w, l, u);\n        }\n    }\n\n    priority_queue<P, vector<P>, greater<P> > q;\n    for(auto & e : graph[0]) q.push(e);\n\n    vi used(n);\n    used[0] = true;\n\n    int ret = 0, a_cnt = 0;\n    int exa = 0;\n    while(q.size()){\n        int w, v, l;\n        tie(w, l, v) = q.top(); q.pop();\n\n        if(used[v]) continue;\n        used[v] = true;\n\n        ret += w;\n        a_cnt += (l == 0 ? 1 : 0);\n\n        for(auto & e : graph[v]){\n            int nv; tie(ignore, ignore, nv) = e;\n            if(not used[nv]){\n                q.push(e);\n                continue;\n            }\n\n            for(auto & ee : graph[nv]){\n                int ww, vv, ll; tie(ww, ll, vv) = ee;\n                if(vv == v and ll == (l^1) and ww == w){\n                    exa++;\n                    break;\n                }\n            }\n        }\n    }\n\n    // cerr << a_cnt << endl;\n    if(not (a_cnt - exa <= k and k <= a_cnt)) ret = (a_cnt > k ? -1 : -2);\n \n    return ret;\n}\n\nint offset = 10000;\n\nint main(void){\n    for(int m; cin >> n >> m >> k, n;){\n        // cerr << endl;\n        vector<vector<P>> graph(n);\n        rep(loop, m){\n            int u, v, w; char l; cin >> u >> v >> w >> l;\n            u--, v--, w += offset;\n\n            graph[u].push_back(P(w, l == 'A' ? 0:1, v));\n            graph[v].push_back(P(w, l == 'A' ? 0:1, u));\n        }\n\n        int lb = -offset, ub = offset;\n        int res = -1;\n        rep(loop, 100){\n            int mid = (lb + ub) / 2;\n\n            int ret = prim(graph, mid);\n            if(ret == -2){\n                ub = mid;\n            }\n            else if(ret == -1){\n                lb = mid;\n            }\n            else {\n                res = ret - (offset * (n - 1)) - (mid * k);\n                break;\n            }\n        }\n\n        cout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\nstruct Kruskal{\n\n  \n  struct edge{\n    Int from,to,cost,used;\n    char color;\n    edge(){}\n    edge(Int from,Int to,Int cost,char color):\n      from(from),to(to),cost(cost),used(0),color(color){}\n    bool operator<(const edge& e) const{\n      return cost<e.cost;\n    }\n  };\n\n  Int n;\n  vector<edge> edges;\n\n  Kruskal(){}\n  Kruskal(Int sz):n(sz){}\n  \n  void add_edge(Int u,Int v,Int c,char d){\n    edges.emplace_back(u,v,c,d);\n  }\n\n  void input(Int m,Int offset=0){\n    Int a,b,c;\n    char d;\n    for(Int i=0;i<m;i++){\n      cin>>a>>b>>c>>d;\n      add_edge(a+offset,b+offset,c,d);\n    }\n  }\n  \n  Int build(){\n    sort(edges.begin(),edges.end());\n    UnionFind uf(n+1);\n    Int res=0,cnt=0;\n    for(auto &e:edges){\n      if(!uf.same(e.from,e.to)){\n\tres+=e.cost;\n\tuf.unite(e.from,e.to);\n\te.used=1;\n\tcnt++;\n      }\n    }\n    //cout<<cnt<<\" \"<<res<<endl;\n    if(cnt+1!=n) return -1;\n    return res;\n  }\n\n  Int count(char c){\n    Int res=0;\n    for(auto& e:edges)\n      if(e.used&&e.color==c) res++;\n    return res;\n  }\n};\n\n\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    //cout<<n<<\" \"<<m<<\" \"<<k<<endl;\n    Kruskal kr(n);\n    kr.input(m,-1);\n    Int ans=kr.build();\n    if(ans<0){\n      cout<<-1<<endl;\n      continue;\n    }\n    \n    auto es=kr.edges;\n    Int A=kr.count('A');\n    Int B=kr.count('B');\n    \n    auto check=[&](char c,char d,Int i){\n      Int res=-1;\n      UnionFind uf(n);\n      for(Int j=0;j<m;j++)\n\tif(i!=j&&es[j].used)\n\t  uf.unite(es[j].from,es[j].to);\n      \n      for(Int j=0;j<m;j++)\n\tif(es[j].color==d&&!es[j].used)\n\t  if(!uf.same(es[j].from,es[j].to))\n\t    if(res<0||es[j].cost<es[res].cost)\n\t      res=j;\n      \n      return res;\n    };\n\n    //cout<<A<<\" \"<<B<<endl;\n    while(A>k){\n      Int res=-1,idx=-1,idy=-1;\n      for(Int i=0;i<m;i++){\n\tif(es[i].color!='A'||!es[i].used) continue;\n\tInt tmp=check('A','B',i);\n\tif(tmp<0) continue;\n\tif(res<0||es[tmp].cost-es[i].cost<res){\n\t  res=es[tmp].cost;\n\t  idx=i;idy=tmp;\n\t}\n      }\n      if(idx<0) break;\n      es[idx].used=0;ans-=es[idx].cost;\n      es[idy].used=1;ans+=es[idy].cost;\n      A--;B++;\n    }\n    while(A<k){\n      Int res=-1,idx=-1,idy=-1;\n      for(Int i=0;i<m;i++){\n\tif(es[i].color!='B'||!es[i].used) continue;\n\tInt tmp=check('B','A',i);\n\tif(tmp<0) continue;\n\tif(res<0||es[tmp].cost-es[i].cost<res){\n\t  res=es[tmp].cost;\n\t  idx=i;idy=tmp;\n\t}\n      }\n      if(idx<0) break;\n      es[idx].used=0;ans-=es[idx].cost;\n      es[idy].used=1;ans+=es[idy].cost;\n      A++;B--;\n    }\n    if(A!=k) cout<<-1<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <tuple>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\n#define whole(f, x, ...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\n\nstruct disjoint_sets {\n    vector<int> data;\n    disjoint_sets() = default;\n    explicit disjoint_sets(size_t n) : data(n, -1) {}\n    bool is_root(int i) { return data[i] < 0; }\n    int find_root(int i) { return is_root(i) ? i : (data[i] = find_root(data[i])); }\n    int set_size(int i) { return - data[find_root(i)]; }\n    int union_sets(int i, int j) {\n        i = find_root(i); j = find_root(j);\n        if (i != j) {\n            if (set_size(i) < set_size(j)) swap(i,j);\n            data[i] += data[j];\n            data[j] = i;\n        }\n        return i;\n    }\n    bool is_same(int i, int j) { return find_root(i) == find_root(j); }\n};\n\ntemplate <typename UnaryPredicate>\nll binsearch(ll l, ll r, UnaryPredicate p) { // [l, r), p is monotone\n    assert (l < r);\n    -- l;\n    while (r - l > 1) {\n        ll m = (l + r) / 2;\n        (p(m) ? r : l) = m;\n    }\n    return r; // = min { x in [l, r) | p(x) }, or r\n}\n\ntemplate <typename T> struct weighted_edge { int u, v; T cost; bool is_a; };\ntemplate <typename T> bool operator < (weighted_edge<T> const & a, weighted_edge<T> const & b) { return a.cost < b.cost; } // weak ordering\ntuple<int, int, int> minimum_spanning_tree(int n, vector<vector<pair<int, int> > > const & g, vector<vector<pair<int, int> > > const & h, int a, int k) {\n    vector<weighted_edge<int> > edges;\n    repeat (p, 2) {\n        repeat (i, n) {\n            for (auto edge : (p ? g : h)[i]) {\n                int j, cost; tie(j, cost) = edge;\n                if (i < j) edges.push_back((weighted_edge<int>) { i, j, cost + (p ? a : 0), bool(p) });\n            }\n        }\n    }\n    whole(sort, edges);\n    int a_count = 0;\n    int b_count = 0;\n    int total_cost = 0;\n    disjoint_sets sets(n);\n    for (auto e : edges) { // Kruskal's method, O(E \\log E)\n        if (k != -1) {\n            if (e.is_a ? a_count == k : b_count == n - 1 - k) continue;\n        }\n        if (not sets.is_same(e.u, e.v)) {\n            sets.union_sets(e.u, e.v);\n            (e.is_a ? a_count : b_count) += 1;\n            total_cost += e.cost;\n        }\n    }\n    return make_tuple(a_count, b_count, total_cost);\n}\n\nconstexpr int inf = 1e9+7;\nint main() {\n    while (true) {\n        int n, m, k; scanf(\"%d%d%d\", &n, &m, &k);\n        if (n == 0 and m == 0 and k == 0) break;\n        vector<vector<pair<int, int> > > g(n); // of A\n        vector<vector<pair<int, int> > > h(n); // of B\n        repeat (i, m) {\n            int u, v, w; char l; scanf(\"%d%d%d %c\", &u, &v, &w, &l); -- u; -- v;\n            assert (l == 'A' or l == 'B');\n            (l == 'A' ? g : h)[u].emplace_back(v, w);\n            (l == 'A' ? g : h)[v].emplace_back(u, w);\n        }\n        int a = binsearch(- 100, 200, [&](int a) {\n            int a_count, b_count, total_cost;\n            tie(a_count, b_count, total_cost) = minimum_spanning_tree(n, g, h, a, -1);\n            return a_count <= k;\n        });\n        int result = inf;\n        repeat_from (da, -3, +3 + 1) {\n            int a_count, b_count, total_cost;\n            tie(a_count, b_count, total_cost) = minimum_spanning_tree(n, g, h, a + da, k);\n            if (a_count + b_count == n - 1) {\n                setmin(result, total_cost - (a + da) * a_count);\n            }\n        }\n        if (result == inf) result = -1;\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nstruct UnionFind\n{\n\tvector<int> par;\n\tUnionFind(int n) :par(n, -1) {}\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (par[y] < par[x]) swap(x, y);\n\t\tif (par[x] == par[y]) par[x]--;\n\t\tpar[y] = x;\n\t\tif (find(x) != find(y)) par[find(y)] = x;\n\t}\n\tint count()\n\t{\n\t\tint cnt = 0;\n\t\tREP(i, par.size()) if (par[i] < 0) cnt++;\n\t\treturn cnt;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\ntypedef ld Weight;\nstruct Edge\n{\n\tint from, to; Weight cost; char c;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\n\nconst ld INF = 1e9;\nconst ld EPS = 1e-9;\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m, k;\n\twhile (cin >> n >> m >> k, n)\n\t{\n\t\tEdges es;\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; ld c; char d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--; b--;\n\t\t\tes.emplace_back(Edge{ a, b, c, d });\n\t\t}\n\t\tint mn = INF, mx = -1;\n\t\tld lb = -INF, ub = INF;\n\t\tREP(lp, 300)\n\t\t{\n\t\t\tld mid = (ub + lb) / 2;\n\t\t\tEdges tmp;\n\t\t\tfor (auto e : es)\n\t\t\t{\n\t\t\t\tif (e.c == 'A') e.cost += mid;\n\t\t\t\ttmp.push_back(e);\n\t\t\t}\n\t\t\tsort(ALL(tmp));\n\t\t\tUnionFind uf(n);\n\t\t\tint cost = 0;\n\t\t\tint cnta = 0;\n\t\t\tfor (auto e : tmp)\n\t\t\t{\n\t\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\t\tif (e.c == 'A')\n\t\t\t\t{\n\t\t\t\t\tcnta++;\n\t\t\t\t}\n\t\t\t\tcost += e.cost;\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t}\n\n\t\t\tchmax(mx, cnta);\n\t\t\tchmin(mn, cnta);\n\t\t\tif (lp == 299)\n\t\t\t{\n\t\t\t\tif (uf.count() != 1 || (mx < k || mn > k))\n\t\t\t\t{\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse cout << int(cost - k * mid + EPS) << endl;\n\t\t\t}\n\t\t\telse if (cnta > k)\n\t\t\t{\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tub = mid;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n//https://icpc.iisf.or.jp/past-icpc/domestic2015/judge/\n\n#define NUM 605\n\nenum Type{\n\tA,\n\tB,\n};\n\nenum Ret{\n\tMANY,\n\tFEW,\n\tOK,\n};\n\nstruct Edge{\n\tbool operator<(const struct Edge &arg) const{\n\t\tif(weight != arg.weight){\n\t\t\treturn weight < arg.weight;\n\t\t}else{\n\n\t\t\treturn type > arg.type;\n\t\t}\n\t};\n\tint from,to,weight;\n\tType type;\n};\n\n\n\nint V,E,K;\nint parent[205],height[205];\nEdge edge[NUM];\n\nint getParent(int id){\n\tif(parent[id] == id)return id;\n\telse{\n\t\treturn parent[id] = getParent(parent[id]);\n\t}\n}\n\nbool isSame(int a, int b){\n\treturn getParent(a) == getParent(b);\n}\n\nvoid unite(int a,int b){\n\tint a_parent = getParent(a);\n\tint b_parent = getParent(b);\n\n\tif(a_parent == b_parent)return;\n\n\tif(height[a_parent] > height[b_parent]){\n\t\tparent[b_parent] = a_parent;\n\t}else{\n\t\tif(height[a_parent] == height[b_parent])height[b_parent]++;\n\t\tparent[a_parent] = b_parent;\n\t}\n}\n\nvoid init(){\n\n\tfor(int i = 0; i < V; i++){\n\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nRet is_OK(int add_value){\n\n\tint sum = 0,num_A = 0,num_B = 0;\n\n\tinit();\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(edge[i].type == A){\n\t\t\tedge[i].weight += add_value;\n\t\t}\n\t}\n\n\tsort(edge,edge+E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tif(!isSame(edge[i].from,edge[i].to)){\n\n\t\t\tsum += edge[i].weight;\n\t\t\tunite(edge[i].from,edge[i].to);\n\n\t\t\tif(edge[i].type == A){\n\n\t\t\t\tnum_A++;\n\t\t\t}else{\n\n\t\t\t\tnum_B++;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(edge[i].type == A){\n\t\t\tedge[i].weight -= add_value;\n\t\t}\n\t}\n\n\tif(num_A == K && num_B == V-1-K){\n\n\t\treturn OK;\n\t}else if(num_A < K){\n\n\t\treturn FEW;\n\t}else{\n\n\t\treturn MANY;\n\t}\n}\n\nvoid func(){\n\n\tchar buf[2];\n\n\tinit();\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tscanf(\"%d %d %d %s\",&edge[i].from,&edge[i].to,&edge[i].weight,buf);\n\n\t\tedge[i].from--;\n\t\tedge[i].to--;\n\n\t\tunite(edge[i].from,edge[i].to);\n\n\t\tif(buf[0] == 'A'){\n\n\t\t\tedge[i].type = A;\n\t\t}else{\n\n\t\t\tedge[i].type = B;\n\t\t}\n\t}\n\n\tint num_boss = 0;\n\n\tfor(int i = 0; i < V; i++){\n\t\tif(i == getParent(i)){\n\n\t\t\tnum_boss++;\n\t\t}\n\t}\n\n\tif(num_boss > 1){\n\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\n\n\tint L = -1000000,R = 1000000,mid;\n\n\tRet ret;\n\n\twhile(L+2 <= R){\n\n\t\tmid = (L+R)/2;\n\n\t\tret = is_OK(mid);\n\n\t\tif(ret == FEW){\n\n\t\t\tR = mid;\n\t\t}else{\n\n\t\t\tL = mid;\n\t\t}\n\t}\n\n\tinit();\n\n\tint add_1 = L;\n\tint num_1 = 0;\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(edge[i].type == A){\n\t\t\tedge[i].weight += add_1;\n\t\t}\n\t}\n\n\tsort(edge,edge+E);\n\n\tfor(int i = 0; i < E; i++){\n\t\tif(!isSame(edge[i].from,edge[i].to)){\n\t\t\tunite(edge[i].from,edge[i].to);\n\n\t\t\tif(edge[i].type == A){\n\n\t\t\t\tnum_1++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(num_1 < K){\n\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(edge[i].type == A){\n\t\t\tedge[i].weight -= add_1;\n\t\t}\n\t}\n\n\tint add_2 = R;\n\tint num_2 = 0;\n\n\tfor(int i = 0; i < E; i++){\n\n\t\tif(edge[i].type == A){\n\t\t\tedge[i].weight += add_2;\n\t\t}\n\t}\n\n\tsort(edge,edge+E);\n\n\tinit();\n\n\tint sum = 0;\n\n\tfor(int i = 0; i < E; i++){\n\t\tif(!isSame(edge[i].from,edge[i].to)){\n\t\t\tsum += edge[i].weight;\n\t\t\tunite(edge[i].from,edge[i].to);\n\n\t\t\tif(edge[i].type == A){\n\n\t\t\t\tnum_2++;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(num_2 > K){\n\n\t\tprintf(\"-1\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"%d\\n\",sum-R*K);\n}\n\n\nint main(){\n\n\twhile(true){\n\n\t\tscanf(\"%d %d %d\",&V,&E,&K);\n\t\tif(V == 0 && E == 0 && K == 0)break;\n\n\t\tfunc();\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int inf = 1e9;\n\nstruct edge {\n    int u, v, cost, type;\n    bool operator<(const edge& other) const {\n        return cost < other.cost;\n    }\n};\n\nclass union_find {\npublic:\n    union_find(int n) : par(n, -1) {}\n    int root(int x) { return par[x] < 0 ? x : par[x] = root(par[x]); }\n    bool unite(int x, int y) {\n        x = root(x), y = root(y);\n        if(x == y) return false;\n        if(par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n\nprivate:\n    vector<int> par;\n};\n\nint main() {\n    int n, m, k;\n    while(cin >> n >> m >> k, n) {\n        vector<edge> es;\n        for(int i = 0; i < m; ++i) {\n            int u, v, w; char l;\n            cin >> u >> v >> w >> l;\n            es.push_back(edge{u - 1, v - 1, w, l == 'B'});\n        }\n\n        int ans = inf;\n        for(int offset = -100; offset <= 100; ++offset) {\n            auto tes = es;\n            for(auto& e : tes) {\n                if(e.type == 0) {\n                    e.cost += offset;\n                }\n            }\n            sort(begin(tes), end(tes),\n                 [](auto const& e1, auto const& e2) {\n                     return e1.cost < e2.cost || (e1.cost == e2.cost && e1.type < e2.type);\n                 });\n            int cnt1 = 0;\n            int connect = 0;\n            {\n                union_find uf(n);\n                for(auto& e : tes) {\n                    if(uf.unite(e.u, e.v)) {\n                        connect += 1;\n                        cnt1 += e.type == 0;\n                    }\n                }\n            }\n\n            int cost = -offset * k;\n            int cnt2 = 0;\n            sort(begin(tes), end(tes),\n                 [](auto const& e1, auto const& e2) {\n                     return e1.cost < e2.cost || (e1.cost == e2.cost && e1.type > e2.type);\n                 });\n            {\n                union_find uf(n);\n                for(auto& e : tes) {\n                    if(uf.unite(e.u, e.v)) {\n                        cost += e.cost;\n                        cnt2 += e.type == 0;\n                    }\n                }\n            }\n            if(cnt2 <= k && k <= cnt1 && connect == n - 1) {\n                ans = min(ans, cost);\n            }\n        }\n\n        cout << (ans == inf ? -1 : ans) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntemplate <int N>\nstruct union_find {\n    int par[N];\n    union_find() { for (int i = 0; i < N; ++i) par[i] = -1; }\n\n    int find(int v) {\n        if (par[v] < 0) return v;\n        return par[v] = find(par[v]);\n    }\n\n    bool unite(int x, int y) {\n        int xx = find(x), yy = find(y);\n        if (xx == yy) return false;\n        if (par[xx] < par[yy]) {\n            par[xx] += par[yy];\n            par[yy] = xx;\n        } else {\n            par[yy] += par[xx];\n            par[xx] = yy;\n        }\n        return true;\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nstruct edge {\n    int u, v, cost;\n    char label;\n    edge() {}\n    edge(int u, int v, int cost, char label): u(u), v(v), cost(cost), label(label) {}\n\n    bool operator < (const edge& o) const {\n        return cost < o.cost;\n    }\n};\n\nvector<edge> edges, edges_bak;\n\nint N, M, K;\n\nint solve() {\n    edges_bak = edges;\n\n    int ans = 1LL << 28;\n\n    for (int a = -100; a <= 100; ++a) {\n        edges = edges_bak;\n\n        union_find<200> uf;\n\n        for (edge& e : edges)\n            if (e.label == 'A') e.cost += a;\n\n        sort(begin(edges), end(edges));\n\n        int weight_sum = 0, a_count = 0, b_count = 0;\n\n        for (const edge& e : edges) {\n            if (uf.same(e.u, e.v)) continue;\n            if (e.label == 'A' && a_count == K) continue;\n            if (e.label == 'B' && b_count == N-1-K) continue;\n            (e.label == 'A' ? a_count : b_count)++;\n            uf.unite(e.u, e.v);\n            weight_sum += e.cost;\n        }\n\n        if (a_count + b_count < N-1) continue;\n\n        if (a_count == K)\n            ans = min(ans, weight_sum - K * a);\n    }\n\n    return (ans == 1 << 28 ? -1 : ans);\n}\n\n\nint main(void) {\n    while (true) {\n        cin >> N >> M >> K;\n        edges.clear();\n        edges_bak.clear();\n        if (N == 0 && M == 0 && K == 0) break;\n        for (int i = 0; i < M; ++i) {\n            int u, v, cost; char label;\n            cin >> u >> v >> cost >> label; --u; --v;\n            edges.emplace_back(u, v, cost, label);\n        }\n\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#define show(x) cerr << #x << \" = \" << x << endl\nusing namespace std;\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"<\" << p.first << \",\" << p.second\n       << \">\";\n    return os;\n}\nclass DisjointSets\n{\npublic:\n    DisjointSets(const int v) : parent(v), rank(v, 0), size(v, 1) { iota(parent.begin(), parent.end(), 0); }\n    bool same(const int a, const int b) { return find(a) == find(b); }\n    int find(const int a) { return parent[a] == a ? a : parent[a] = find(parent[a]); }\n    void unite(int a, int b)\n    {\n        a = find(a);\n        b = find(b);\n        if (a == b) {\n            return;\n        }\n        if (rank[a] < rank[b]) {\n            swap(a, b);\n        }\n        rank[a] += rank[b];\n        size[a] += size[b];\n        parent[b] = a;\n    }\n    int getSize(const int i) { return size[find(i)]; }\n\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n    vector<int> size;\n};\nstruct Edge {\n    Edge(const int u, const int v, const int w, const char l) : u{u}, v{v}, w{w}, A{(int)(l == 'A')} {}\n    int u;\n    int v;\n    int w;\n    int A;\n    bool operator<(const Edge& e) const\n    {\n        return w != e.w ? w < e.w : A > e.A;\n    }\n};\nint main()\n{\n    while (true) {\n        constexpr int MAX = 10000;\n        int N, M, K;\n        cin >> N >> M >> K;\n        if (N == 0 and M == 0 and K == 0) {\n            break;\n        }\n        vector<Edge> e;\n        DisjointSets UF(N);\n        for (int i = 0; i < M; i++) {\n            int u, v, w;\n            char l;\n            cin >> u >> v >> w >> l;\n            u--, v--;\n            e.push_back(Edge(u, v, w, l));\n            UF.unite(u, v);\n        }\n        if (UF.getSize(0) < N) {\n            cout << -1 << endl;\n            continue;\n        }\n        auto check = [&](const int c) {\n            vector<Edge> E = e;\n            for (int i = 0; i < M; i++) {\n                if (E[i].A == 1) {\n                    E[i].w = e[i].w + c;\n                }\n            }\n            sort(E.begin(), E.end());\n            DisjointSets uf(N);\n            int sum = 0;\n            int a = 0;\n            for (int i = 0; i < M; i++) {\n                const int u = E[i].u;\n                const int v = E[i].v;\n                if (not uf.same(u, v)) {\n                    sum += E[i].w;\n                    a += E[i].A;\n                    uf.unite(u, v);\n                }\n            }\n            return a >= K;\n        };\n        int c = -MAX;\n        for (; c <= MAX; c++) {\n            if (not check(c)) {\n                break;\n            }\n        }\n        c--;\n        for (int i = 0; i < M; i++) {\n            if (e[i].A == 1) {\n                e[i].w += c;\n            }\n        }\n        sort(e.begin(), e.end());\n        DisjointSets uf(N);\n        int sum = 0;\n        for (int i = 0; i < M; i++) {\n            const int u = e[i].u;\n            const int v = e[i].v;\n            if (not uf.same(u, v)) {\n                uf.unite(u, v);\n                sum += e[i].w;\n            }\n        }\n        cout << (c <= -MAX or c >= MAX ? -1 : sum - K * c) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nstruct UnionFind{\n\tint par[210],rank[210];\n\tvoid init(){\n\t\tfor(int i=0;i<210;i++){par[i]=i;rank[i]=0;}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]>rank[y])par[y]=x;\n\t\telse{\n\t\t\tpar[x]=y;\n\t\t\tif(rank[x]==rank[y])rank[y]++;\n\t\t}\n\t\treturn;\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nstruct edge{\n\tint from,to,cost;\n\tedge(){}\n\tedge(int from,int to,int cost):from(from),to(to),cost(cost){}\n\tbool operator < (const edge& a) const{\n\t\treturn cost < a.cost;\n\t}\n};\nint n,m,k;\nvector<edge> A,B;\nint cost,use_a,use;\nvoid check(int x){\n\tuf.init();\n\tint p = 0,q = 0;\n\tcost = 0;\n\tuse_a = 0;\n\tuse = 0;\n\twhile(p<A.size()&&q<B.size()){\n\t\tedge e;\n\t\tbool flag = false;\n\t\tif(p==A.size())e = B[q++];\n\t\telse if(q==B.size()){\n\t\t\te = A[p++];\n\t\t\tflag = true;\n\t\t}else{\n\t\t\tif(A[p].cost+x<B[q].cost){\n\t\t\t\te = A[p++];\n\t\t\t\tflag = true;\n\t\t\t}else if(A[p].cost+x==B[q].cost){\n\t\t\t\tif(use_a<k){\n\t\t\t\t\te = A[p++];\n\t\t\t\t\tflag = true;\n\t\t\t\t}else e = B[q++];\n\t\t\t}else e = B[q++];\n\t\t}\n\t\tif(!uf.same(e.from,e.to)){\n\t\t\tuf.unite(e.from,e.to);\n\t\t\tcost += e.cost;\n\t\t\tif(flag)use_a++;\n\t\t\tuse++;\n\t\t}\n\t}\n\treturn;\n}\nbool solve(){\n\tcin >> n >> m >> k;\n\tif(n==0&&m==0&&k==0)return false;\n\tA.clear();\n\tB.clear();\n\tfor(int i=0;i<m;i++){\n\t\tint u,v,c;\n\t\tchar l;\n\t\tcin >> u >> v >> c >> l;\n\t\tif(l=='A')A.pb(edge(u,v,c));\n\t\telse B.pb(edge(u,v,c));\n\t}\n\tsort(all(A));\n\tsort(all(B));\n\tint ans = INF;\n\tfor(int i=-101;i<=101;i++){\n\t\tcheck(i);\n\t\tif(use_a==k&&use==n-1)ans = min(ans,cost);\n\t}\n\tif(ans==INF)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct Kruskal{\n\n  struct UnionFind{\n    Int n;\n    vector<Int> r,p;\n    UnionFind(){}\n    UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n    Int find(Int x){\n      return (x==p[x]?x:p[x]=find(p[x]));\n    }\n    bool same(Int x,Int y){\n      return find(x)==find(y);\n    }\n    void unite(Int x,Int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      if(r[x]<r[y]) swap(x,y);\n      r[x]+=r[y];\n      p[y]=x;\n    }\n  };\n  \n  struct edge{\n    Int from,to;\n    double cost;\n    Int used;\n    char color;\n    edge(){}\n    edge(Int from,Int to,double cost,char color):\n      from(from),to(to),cost(cost),used(0),color(color){}\n    bool operator<(const edge& e) const{\n      return cost<e.cost;\n    }\n  };\n\n  Int n;\n  vector<edge> edges;\n\n  Kruskal(){}\n  Kruskal(Int sz):n(sz){}\n  \n  Int build(Int k=-1){\n    sort(edges.begin(),edges.end());\n    UnionFind uf(n+1);\n    double res=0;\n    Int cnt=0;\n    for(Int i=0;i<(Int)edges.size();i++){\n      edge &e=edges[i];\n      if(!uf.same(e.from,e.to)){\n\te.used=1;\n\tres+=e.cost;\n\tuf.unite(e.from,e.to);\n\tcnt++;\n      }\n    }\n    if(cnt+1!=n) return -1;\n    return res;\n  }\n};\n\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    Kruskal kr(n);\n    auto edges=kr.edges;\n    for(Int i=0;i<m;i++){\n      Int u,v,w;\n      char c;\n      cin>>u>>v>>w>>c;\n      u--;v--;\n      edges.emplace_back(u,v,w,c);\n    }\n    double ub=1e12,ans;\n    auto check=[&](double x){\n      x-=ub;\n      kr=Kruskal(n);\n      for(auto e:edges){\n\tif(x>0&&e.color=='A') e.cost+=x; \n\tif(x<0&&e.color=='B') e.cost-=x; \n\tkr.edges.emplace_back(e);\n      }\n      \n      ans=kr.build();\n      if(ans<0) return Int(-1);\n      if(x>0) ans-=x*k;\n      if(x<0) ans+=x*(n-1-k);\n      \n      Int res=0;\n      for(auto e:kr.edges)\n\tres+=(e.used&&e.color=='A');\n      return res;\n    };\n    double l=0,r=2*ub;\n    if(check(l)<k||check(r)>k){\n      cout<<-1<<endl;\n      continue;\n    }\n    for(Int i=0;i<2000;i++){\n      double m=(l+r)/2;\n      if(check(m)>=k) l=m;\n      else r=m;\n    }\n    check(l);\n    cout<<(Int)ceil(ans)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\nint par[210],sz[210];\nvoid init(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i] = i; sz[i] = 1;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(ll x, ll y){\n\tx = find(x); y = find(y);\n\tif(x==y) return;\n\tif(sz[x]<sz[y]) swap(x,y);\n\tpar[y] = x; sz[x] += sz[y];\n}\n\nbool same(ll x, ll y){\n\treturn find(x)==find(y);\n}\n\nstruct edge{ll u,v,cost,num;};\nvector<edge> E;\nbool comp1(const edge& e1, const edge& e2){\n\tif(e1.cost!=e2.cost) return e1.cost<e2.cost;\n\telse return e1.num<e2.num;\n}\n\nbool comp2(const edge& e1, const edge& e2){\n\tif(e1.cost!=e2.cost) return e1.cost<e2.cost;\n\telse return e1.num>e2.num;\n}\n\npair<ll,ll> kruscal(int n,ll w,int x){\n\tint i; pair<ll,ll> p = {0,0};\n\tfor(i=0;i<E.size();i++){\n\t\tif(E[i].num==1) E[i].cost += w;\n\t}\n\tif(x==0) sort(E.begin(),E.end(),comp1);\n\tif(x==1) sort(E.begin(),E.end(),comp2);\n\tinit(n);\n\tfor(i=0;i<E.size();i++){\n\t\tedge e = E[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunite(e.u,e.v);\n\t\t\tp.first += e.cost;\n\t\t\tp.second += 1 - e.num;\n\t\t}\n\t}\n\tfor(i=0;i<E.size();i++){\n\t\tif(E[i].num==1) E[i].cost -= w;\n\t}\n\tif(sz[find(0)]<n) p.second = -1;\n\treturn p;\n}\n\nint main(){\n\twhile(true){\n\t\tint i,n,m,k;\n\t\tcin >> n >> m >> k;\n\t\tif(n + m + k==0) break;\n\t\tE.clear();\n\t\tint cnt = 0;\n\t\tfor(i=0;i<m;i++){\n\t\t\tll u,v,w; char c;\n\t\t\tcin >> u >> v >> w >> c;\n\t\t\tu--; v--;\n\t\t\tll l = 0 + (c=='B');\n\t\t\tE.push_back({u,v,w,l});\n\t\t}\n\t\tll inf = 1000000000000;\n\t\tif(kruscal(n,inf,0).second<k || kruscal(n,-inf,0).second>k){\n\t\t\tcout << -1 << endl;\n\t\t}else{\n\t\t\tll r = inf,l = -inf;\n\t\t\twhile(r - l>1){\n\t\t\t\tll mid = (l + r)/2;\n\t\t\t\tif(kruscal(n,mid,0).second<k) l = mid;\n\t\t\t\telse r = mid;\n\t\t\t}\n\t\t\tcout << kruscal(n,r,0).first - r*(n - k - 1) << endl;\n\t\t\tll x = kruscal(n,r - 1,0).second,y = kruscal(n,r,1).second;\n\t\t\tassert(x==y);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=4005,INF=1<<30;\n\nstruct UF{\n    int n;\n    vector<int> par,size;\n    \n    void init(int n_){\n        n=n_;\n        par.assign(n,-1);\n        size.assign(n,1);\n        \n        for(int i=0;i<n;i++){\n            par[i]=i;\n        }\n    }\n    \n    int root(int a){\n        if(par[a]==a) return a;\n        else return par[a]=root(par[a]);\n    }\n    \n    void unite(int a,int b){\n        if(root(a)!=root(b)){\n            size[root(a)]+=size[root(b)];\n            par[root(b)]=root(a);\n        }\n    }\n    \n    bool check(int a,int b){\n        return root(a)==root(b);\n    }\n};\n\nstruct edge{\n    int from;\n    int to;\n    ll cost;\n    int type;\n};\n\npair<ll,ll> check(ll plus,vector<edge> S,int N,int K){\n    int M=si(S);\n    for(int i=0;i<M;i++){\n        if(!S[i].type) S[i].cost+=plus;\n    }\n    \n    sort(all(S),[](auto a,auto b){\n        if(a.cost==b.cost) return a.type<b.type;\n        return a.cost<b.cost;\n    });\n    \n    int cnt=0;\n    ll sum=0;\n    \n    UF uf;\n    uf.init(N);\n    \n    for(int i=0;i<M;i++){\n        int a=uf.root(S[i].from),b=uf.root(S[i].to);\n        if(uf.size[a]==N) break;\n        \n        if(!uf.check(a,b)){\n            uf.unite(a,b);\n            sum+=S[i].cost;\n            if(!S[i].type) cnt++;\n        }\n    }\n    \n    if(K>N){\n        return mp(sum-plus*(K-N),1);\n    }\n    \n    if(uf.size[uf.root(0)]<N) return mp(0,0);\n    \n    if(plus==INF){\n        if(cnt>K) return mp(0,0);\n    }else if(plus==-INF){\n        if(cnt<K) return mp(0,0);\n    }\n    \n    if(cnt==K){\n        return mp(sum-plus*K,1);\n    }else if(cnt>K){\n        return mp(1,0);\n    }else{\n        return mp(-1,0);\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N,M,K;cin>>N>>M>>K;\n        if(N==0) break;\n        \n        vector<edge> S(M);\n        for(int i=0;i<M;i++){\n            int a,b,c;char d;cin>>a>>b>>c>>d;\n            a--;b--;\n            if(d=='A') S[i]={a,b,c,0};\n            else S[i]={a,b,c,1};\n        }\n        if(!check(INF,S,N,K).fi||!check(-INF,S,N,K).fi){\n            cout<<-1<<endl;\n            continue;\n        }\n        \n        ll left=-INF,right=INF,ans=INF;\n        while(right-left>1){\n            ll mid=(left+right)/2;\n            auto x=check(mid,S,N,K);\n            if(x.se){\n                ans=x.fi;\n                break;\n            }\n            if(x.fi==1) left=mid;\n            if(x.fi==-1) right=mid;\n        }\n        \n        if(ans==INF){\n            auto x=check(left,S,N,K+N);\n            ans=x.fi;\n        }\n        cout<<ans<<\"\\n\";\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct Kruskal{\n\n  struct UnionFind{\n    Int n;\n    vector<Int> r,p;\n    UnionFind(){}\n    UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n    Int find(Int x){\n      return (x==p[x]?x:p[x]=find(p[x]));\n    }\n    bool same(Int x,Int y){\n      return find(x)==find(y);\n    }\n    void unite(Int x,Int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      if(r[x]<r[y]) swap(x,y);\n      r[x]+=r[y];\n      p[y]=x;\n    }\n  };\n  \n  struct edge{\n    Int from,to;\n    double cost;\n    Int used;\n    char color;\n    edge(){}\n    edge(Int from,Int to,double cost,char color):\n      from(from),to(to),cost(cost),used(0),color(color){}\n    bool operator<(const edge& e) const{\n      return cost<e.cost;\n    }\n  };\n\n  Int n;\n  vector<edge> edges;\n\n  Kruskal(){}\n  Kruskal(Int sz):n(sz){}\n  \n  Int build(Int k=-1){\n    sort(edges.begin(),edges.end());\n    UnionFind uf(n+1);\n    double res=0;\n    Int cnt=0;\n    for(Int i=0;i<(Int)edges.size();i++){\n      edge &e=edges[i];\n      if(!uf.same(e.from,e.to)){\n\te.used=1;\n\tres+=e.cost;\n\tuf.unite(e.from,e.to);\n\tcnt++;\n      }\n    }\n    if(cnt+1!=n) return -1;\n    return res;\n  }\n};\n\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    Kruskal kr(n);\n    auto edges=kr.edges;\n    for(Int i=0;i<m;i++){\n      Int u,v,w;\n      char c;\n      cin>>u>>v>>w>>c;\n      u--;v--;\n      edges.emplace_back(u,v,w,c);\n    }\n    double ub=1e12,ans;\n    auto check=[&](double x){\n      x-=ub;\n      kr=Kruskal(n);\n      for(auto e:edges){\n\tif(x>0&&e.color=='A') e.cost+=x; \n\tif(x<0&&e.color=='B') e.cost-=x; \n\tkr.edges.emplace_back(e);\n      }\n      \n      ans=kr.build();\n      if(ans<0) return Int(-1);\n      if(x>0) ans-=x*k;\n      if(x<0) ans+=x*(n-1-k);\n      \n      Int res=0;\n      for(auto e:kr.edges)\n\tres+=(e.used&&e.color=='A');\n      return res;\n    };\n    double l=0,r=2*ub;\n    if(check(l)<k||check(r)>k){\n      cout<<-1<<endl;\n      continue;\n    }\n    for(Int i=0;i<1000;i++){\n      double m=(l+r)/2;\n      if(check(m)>=k) l=m;\n      else r=m;\n    }\n    check(l);\n    assert(check(l)==k);\n    cout<<(Int)round(ans)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass union_find {\npublic:\n    union_find(int n)\n        : par_(n, -1)\n    {}\n\n    int root(int x) {\n        return par_[x] < 0 ? x : par_[x] = root(par_[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x == y) {\n            return false;\n        } else {\n            if(par_[x] < par_[y]) {\n                par_[x] += par_[y];\n                par_[y] = x;\n            } else {\n                par_[y] += par_[x];\n                par_[x] = y;\n            }\n            return true;\n        }\n    }\n\n    int size(int x) {\n        return -par_[root(x)];\n    }\n\nprivate:\n    std::vector<int> par_;\n};\n\nstruct edge {\n    int u, v, cost;\n    int kind;\n\n    bool operator<(edge const& e) const {\n        if(cost == e.cost) {\n            return kind > e.kind;\n        }\n        return cost < e.cost;\n    }\n};\n\nusing result = pair<int, int>;\n\nusing edges = vector<edge>;\n\nresult kruskal(edges const& ES, int offset, int V) {\n    auto es = ES;\n    for(auto& e : es) {\n        if(e.kind == 0) {\n            e.cost += offset;\n        }\n    }\n    sort(es.begin(), es.end());\n    result res = make_pair(0, 0);\n    union_find uf(V);\n    for(auto& e : es) {\n        if(uf.unite(e.u, e.v)) {\n            res.second += e.kind == 0;\n            res.first += e.cost;\n        }\n    }\n    return res;\n}\n\n\nint main() {\n    int n, m, k;\n    while(cin >> n >> m >> k, n) {\n        edges es(m);\n        for(int i=0; i<m; ++i) {\n            int u, v, w; char l;\n            cin >> u >> v >> w >> l;\n            u--; v--;\n            es[i] = edge{u, v, w, l - 'A'};\n        }\n        {\n            union_find uf(n);\n            for(int i=0; i<m; ++i) {\n                uf.unite(es[i].u, es[i].v);\n            }\n            if(uf.size(0) != n) {\n                cout << -1 << endl;\n                continue;\n            }\n        }\n        int lb = -100000, ub = 100000;\n        while(ub - lb > 1) {\n            int m = (lb + ub) / 2;\n            auto t = kruskal(es, m, n);\n            if(t.second < k) {\n                ub = m;\n            } else {\n                lb = m;\n            }\n        }\n        auto l = kruskal(es, lb, n);\n        auto r = kruskal(es, ub, n);\n        if(r.second <= k && l.second >= k) {\n            cout << r.first - ub * k << endl;\n        } else {\n            cout << -1 << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int inf = 1e9;\n\nstruct edge {\n    int u, v, cost, type;\n    bool operator<(const edge& other) const {\n        return cost < other.cost;\n    }\n};\n\nclass union_find {\npublic:\n    union_find(int n) : par(n, -1) {}\n    int root(int x) { return par[x] < 0 ? x : par[x] = root(par[x]); }\n    bool unite(int x, int y) {\n        x = root(x), y = root(y);\n        if(x == y) return false;\n        if(par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n\nprivate:\n    vector<int> par;\n};\n\nint main() {\n    int n, m, k;\n    while(cin >> n >> m >> k, n) {\n        vector<edge> es;\n        for(int i = 0; i < m; ++i) {\n            int u, v, w; char l;\n            cin >> u >> v >> w >> l;\n            es.push_back(edge{u - 1, v - 1, w, l == 'B'});\n        }\n\n        int ans = inf;\n        for(int offset = -100; offset <= 100; ++offset) {\n            auto tes = es;\n            for(auto& e : tes) {\n                if(e.type == 0) {\n                    e.cost += offset;\n                }\n            }\n            sort(begin(tes), end(tes),\n                 [](auto const& e1, auto const& e2) {\n                     return e1.cost < e2.cost || (e1.cost == e2.cost && e1.type < e2.type);\n                 });\n            int cnt1 = 0;\n            {\n                union_find uf(n);\n                for(auto& e : tes) {\n                    if(uf.unite(e.u, e.v)) {\n                        cnt1 += e.type == 0;\n                    }\n                }\n            }\n\n            int cost = -offset * k;\n            int cnt2 = 0;\n            sort(begin(tes), end(tes),\n                 [](auto const& e1, auto const& e2) {\n                     return e1.cost < e2.cost || (e1.cost == e2.cost && e1.type > e2.type);\n                 });\n            {\n                union_find uf(n);\n                for(auto& e : tes) {\n                    if(uf.unite(e.u, e.v)) {\n                        cost += e.cost;\n                        cnt2 += e.type == 0;\n                    }\n                }\n            }\n            if(cnt2 <= k && k <= cnt1) {\n                ans = min(ans, cost);\n            }\n        }\n\n        cout << (ans == inf ? -1 : ans) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass union_find {\n\tvector<int> par;\n\tint find(int a) {\n\t\treturn par[a] < 0 ? a : par[a] = find(par[a]);\n\t}\npublic:\n\tunion_find(int n) : par(n, -1) {}\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return;\n\t\tif (par[a] < par[b]) {\n\t\t\tpar[a] += par[b];\n\t\t\tpar[b] = a;\n\t\t}\n\t\telse {\n\t\t\tpar[b] += par[a];\n\t\t\tpar[a] = b;\n\t\t}\n\t}\n\tint size(int a) {\n\t\treturn -par[find(a)];\n\t}\n};\n\nconst int INF = 1e9;\n\nstruct edge {\n\tint u, v, cost;\n\tbool f;\n\tedge(int u_, int v_, int w, bool f_) : u(u_), v(v_), cost(w), f(f_) {}\n\tbool operator<(const edge& that) const {\n\t\treturn cost < that.cost;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, m, k;\n\twhile (cin >> n >> m >> k, n | m | k) {\n\t\tvector<edge> es;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v, w;\n\t\t\tchar l;\n\t\t\tcin >> u >> v >> w >> l; u--, v--;\n\t\t\tes.emplace_back(u, v, w, l == 'A');\n\t\t}\n\t\tsort(es.begin(), es.end());\n\t\tint res = INF;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tunion_find uf(n);\n\t\t\tint c1 = 0, c2 = 0, sum = 0;\n\t\t\tfor (int j = i; j < m; j++) if (es[j].f) {\n\t\t\t\tif (!uf.same(es[j].u, es[j].v)) {\n\t\t\t\t\tuf.unite(es[j].u, es[j].v);\n\t\t\t\t\tsum += es[j].cost;\n\t\t\t\t\tc1++;\n\t\t\t\t\tif (c1 == k) break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < m; j++) if (!es[j].f) {\n\t\t\t\tif (!uf.same(es[j].u, es[j].v)) {\n\t\t\t\t\tuf.unite(es[j].u, es[j].v);\n\t\t\t\t\tsum += es[j].cost;\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c1 == k && c2 == n - 1 - k) {\n\t\t\t\tres = min(res, sum);\n\t\t\t}\n\t\t}\n\t\tcout << (res == INF ? -1 : res) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int from, to, cost, id;\n    char type;\n};\nbool operator <(const Edge& e1, const Edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par;\npublic:\n    UnionFind(int n) : sz(n) {\n        par = vector<int>(n);\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int root(int a) {\n        if (par[a] == a) return a;\n        return par[a] = root(par[a]);\n    }\n    void unite(int a, int b) {\n        par[root(a)] = par[root(b)];\n    }\n    bool isUnited(int a, int b) {\n        return root(a) == root(b);\n    }\n};\n\nconst int inf = 1e9;\n\nvoid add_edge(vector< vector<Edge> >& G, Edge& e) {\n    G[e.from].push_back({e.from, e.to, e.cost, e.id, e.type});\n    G[e.to].push_back({e.to, e.from, e.cost, e.id, e.type});\n}\nvoid remove_edge(vector< vector<Edge> >& G, Edge& e) {\n    int f = 0;\n    for (int i = 0; i < G[e.from].size(); ++i) {\n        if ( G[e.from][i].id == e.id ) {\n            G[e.from].erase(G[e.from].begin()+i, G[e.from].begin()+i+1);\n            ++f;\n            break;\n        }\n    }\n    for (int i = 0; i < G[e.to].size(); ++i) {\n        if ( G[e.to][i].id == e.id ) {\n            G[e.to].erase(G[e.to].begin()+i, G[e.to].begin()+i+1);\n            ++f;\n            break;\n        }\n    }\n    assert(f == 2);\n}\nEdge dfs(vector< vector<Edge> >& G, int v, int t, char type, int prev, vector<bool>& used) {\n    Edge res = {0, 0, inf, -1, 'X'};\n    // if (used[v]) return res;\n    // used[v] = true;\n    if (v == t) {\n        res.cost--;\n        return res;\n    }\n    for (int i = 0; i < G[v].size(); ++i) {\n        Edge& e = G[v][i];\n        if (e.to != prev) {\n            Edge r = dfs(G, e.to, t, type, v, used);\n            if (r.cost != inf) {\n                res = min(res, r);\n                if (e.type == type) {\n                    res = min(res, e);\n                }\n            }\n        }\n    }\n    return res;\n}\nEdge calc(vector< vector<Edge> >& G, Edge& e) {\n    vector<bool> used(G.size(), false);\n    Edge ee = dfs(G, e.from, e.to, (e.type == 'A' ? 'B' : 'A'), -1, used);\n    return ee;\n}\nint main() {\n    int n, m, k;\n    while (cin >> n >> m >> k, n || m || k) {\n        vector<Edge> ae, be, edges;\n        for (int i = 0; i < m; ++i) {\n            int u, v, w; char l; cin >> u >> v >> w >> l; --u, --v;\n            if (l == 'A') {\n                ae.push_back({u, v, w, i, l});\n            }\n            else {\n                be.push_back({u, v, w, i, l});\n            }\n            edges.push_back({u, v, w, i, l});\n        }\n        sort(ae.begin(), ae.end());\n        sort(be.begin(), be.end());\n        sort(edges.begin(), edges.end());\n        vector< vector<Edge> > G(n);\n        UnionFind uf(n);\n        int ans = 0;\n        int cnt = 0, acnt = 0, bcnt = 0;\n        set<int> s;\n        for (int i = 0; i < edges.size(); ++i) {\n            if (cnt >= n-1) break;\n            Edge& e = edges[i];\n            if (uf.isUnited(e.from, e.to)) continue;\n            uf.unite(e.from, e.to);\n            ans += e.cost;\n            add_edge(G, e);\n            ++cnt;\n            s.insert(e.id);\n            if (e.type == 'A') ++acnt;\n            else ++bcnt;\n        }\n        if (cnt < n-1) {\n            cout << -1 << endl;\n            continue;\n        }\n        if (acnt > k) {\n            swap(acnt, bcnt);\n            swap(ae, be);\n            k = n - k - 1;\n        }\n        // remove use edges\n        // int s0 = 0;\n        // for (int i = ea.size()-1; i >= 0; --i) {\n        //     if (s.count(ea.id) > 0) {\n        //         s0 = i+1;\n        //         break;\n        //     }\n        // }\n        vector<bool> used(ae.size(), false);\n        for (int i = 0; i < ae.size(); ++i) {\n            if (s.count(ae[i].id) > 0) {\n                used[i] = true;\n            }\n        }\n        assert(k-acnt >= 0);\n        for (int t = 0; t < k-acnt; ++t) {\n            Edge a = {0, 0, inf-1, -1, 'X'};\n            int b = -1;\n            for (int i = 0; i < ae.size(); ++i) {\n                if (used[i]) continue;\n                // cout << calc(G, ae[i]) << endl;\n                Edge e = calc(G, ae[i]);\n                if (e.cost < inf-1 && (b < 0 || ae[i].cost - e.cost <= ae[b].cost - a.cost)) {\n                    a = e;\n                    b = i;\n                }\n            }\n            if (b < 0) {\n                ans = -1;\n                break;\n            }\n            // if (a.cost >= inf) assert(false);\n            // cout << a.cost << \" \" << b << endl;\n            used[b] = true;\n            remove_edge(G, a);\n            add_edge(G, ae[b]);\n            ans += ae[b].cost;\n            ans -= a.cost;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing Weight=int;\nstruct Edge{\n    int src,dst;\n    Weight weight;\n    int com;\n    Edge(int src,int dst,Weight weight,int com):\n    src(src),dst(dst),weight(weight),com(com){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\ntemplate<typename T>\nstruct UnionFind{\n    vector<T>data;\n    UnionFind(T n):data(n,-1){}\n    bool unite(T x,T y){\n        x=root(x);y=root(y);\n        if(x!=y){\n            if(data[y]<data[x])swap(x,y);\n            data[x]+=data[y];data[y]=x;\n        }\n        return x!=y;\n    }\n    T root(T x){\n        return data[x]<0?x:data[x]=root(data[x]);\n    }\n    bool same(T x,T y){\n        return root(x)==root(y);\n    }\n    T size(T x){\n        return -data[root(x)];\n    }\n};\n\npair<Weight,int>kruskal(const Graph &g,const int h,const int c){\n    int n=g.size();\n    UnionFind<int> uf(n);\n    auto compare = [c](const Edge &a,const Edge &b) {return a.weight != b.weight ? a.weight>b.weight : a.com == c; };\n    priority_queue<Edge,Edges,decltype(compare)>q(compare);\n    for(int i=0;i<n;++i){\n        for(auto e:g[i]){\n            if(i<e.dst){\n                if(e.com==c)q.emplace(e.src,e.dst,e.weight+h,e.com);\n                else q.push(e);\n            }\n        }\n    }\n    int res=0;\n    Weight total=0;\n    Edges forest;\n    while(forest.size()<n-1 && !q.empty()){\n        Edge e=q.top();q.pop();\n        if(uf.unite(e.src,e.dst)){\n            forest.push_back(e);\n            total+=e.weight;\n            if(e.com==c){\n                ++res;\n            }\n        }\n    }\n    //cout<<total<<endl;\n    return pair<Weight, int>(total,res);\n}\n\nint main(){\n    int v,e,k;\n    while (cin >> v >> e >> k, v)\n    {\n        Graph g(v);\n        for (int i = 0; i < e; ++i)\n        {\n            int s, t, w, l;\n            char c;\n            cin >> s >> t >> w >> c;\n            --s;\n            --t;\n            l = c;\n            g[s].emplace_back(s, t, w, l);\n            g[t].emplace_back(t, s, w, l);\n        }\n        int c = 'A';\n        if (kruskal(g, 0, c).second < k){\n            c = 'B';\n        }\n        //cout<<c<<endl;\n        for (int h = 0; h < 200; ++h)\n        {\n            pair<Weight, int> p = kruskal(g, h, c);\n            if (p.second <= k && c == 'A')\n            {\n                cout << p.first-k*h << endl;\n                break;\n            }\n            else if (p.second <= v - k - 1 && c == 'B')\n            {\n                cout << p.first-(v-k-1)*h << endl;\n                break;\n            }\n            if (h == 199){\n                cout << \"-1\" << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct Kruskal{\n\n  struct UnionFind{\n    Int n;\n    vector<Int> r,p;\n    UnionFind(){}\n    UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n    Int find(Int x){\n      return (x==p[x]?x:p[x]=find(p[x]));\n    }\n    bool same(Int x,Int y){\n      return find(x)==find(y);\n    }\n    void unite(Int x,Int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      if(r[x]<r[y]) swap(x,y);\n      r[x]+=r[y];\n      p[y]=x;\n    }\n  };\n  \n  struct edge{\n    Int from,to;\n    double cost;\n    Int used;\n    char color;\n    edge(){}\n    edge(Int from,Int to,double cost,char color):\n      from(from),to(to),cost(cost),used(0),color(color){}\n    bool operator<(const edge& e) const{\n      return cost<e.cost;\n    }\n  };\n\n  Int n;\n  vector<edge> edges;\n\n  Kruskal(){}\n  Kruskal(Int sz):n(sz){}\n  \n  Int build(Int k=-1){\n    sort(edges.begin(),edges.end());\n    UnionFind uf(n+1);\n    double res=0;\n    Int cnt=0;\n    for(Int i=0;i<(Int)edges.size();i++){\n      edge &e=edges[i];\n      if(!uf.same(e.from,e.to)){\n\te.used=1;\n\tres+=e.cost;\n\tuf.unite(e.from,e.to);\n\tcnt++;\n      }\n    }\n    if(cnt+1!=n) return -1;\n    return res;\n  }\n};\n\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    Kruskal kr(n);\n    auto edges=kr.edges;\n    for(Int i=0;i<m;i++){\n      Int u,v,w;\n      char c;\n      cin>>u>>v>>w>>c;\n      u--;v--;\n      edges.emplace_back(u,v,w,c);\n    }\n    double ub=1e12,ans;\n    auto check=[&](double x){\n      x-=ub;\n      kr=Kruskal(n);\n      for(auto e:edges){\n\tif(x>0&&e.color=='A') e.cost+=x; \n\tif(x<0&&e.color=='B') e.cost-=x; \n\tkr.edges.emplace_back(e);\n      }\n      \n      ans=kr.build();\n      if(ans<0) return Int(-1);\n      if(x>0) ans-=x*k;\n      if(x<0) ans+=x*(n-1-k);\n      \n      Int res=0;\n      for(auto e:kr.edges)\n\tres+=(e.used&&e.color=='A');\n      return res;\n    };\n    double l=0,r=2*ub;\n    if(check(l)<k||check(r)>k){\n      cout<<-1<<endl;\n      continue;\n    }\n    for(Int i=0;i<1000;i++){\n      double m=(l+r)/2;\n      if(check(m)>=k) l=m;\n      else r=m;\n    }\n    check(l);\n    assert(check(r)==k);\n    cout<<(Int)round(ans)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct Kruskal{\n\n  struct UnionFind{\n    Int n;\n    vector<Int> r,p;\n    UnionFind(){}\n    UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n    Int find(Int x){\n      return (x==p[x]?x:p[x]=find(p[x]));\n    }\n    bool same(Int x,Int y){\n      return find(x)==find(y);\n    }\n    void unite(Int x,Int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      if(r[x]<r[y]) swap(x,y);\n      r[x]+=r[y];\n      p[y]=x;\n    }\n  };\n  \n  struct edge{\n    Int from,to;\n    double cost;\n    Int used;\n    char color;\n    edge(){}\n    edge(Int from,Int to,double cost,char color):\n      from(from),to(to),cost(cost),used(0),color(color){}\n    bool operator<(const edge& e) const{\n      return cost<e.cost;\n    }\n  };\n\n  Int n;\n  vector<edge> edges;\n\n  Kruskal(){}\n  Kruskal(Int sz):n(sz){}\n  \n  Int build(Int k=-1){\n    sort(edges.begin(),edges.end());\n    UnionFind uf(n+1);\n    double res=0;\n    Int cnt=0;\n    for(Int i=0;i<(Int)edges.size();i++){\n      edge &e=edges[i];\n      if(!uf.same(e.from,e.to)){\n\te.used=1;\n\tres+=e.cost;\n\tuf.unite(e.from,e.to);\n\tcnt++;\n      }\n    }\n    if(cnt+1!=n) return -1;\n    return res;\n  }\n};\n\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    Kruskal kr(n);\n    auto edges=kr.edges;\n    for(Int i=0;i<m;i++){\n      Int u,v,w;\n      char c;\n      cin>>u>>v>>w>>c;\n      u--;v--;\n      edges.emplace_back(u,v,w,c);\n    }\n    double ub=1e12,ans;\n    auto check=[&](double x){\n      x-=ub;\n      kr=Kruskal(n);\n      for(auto e:edges){\n\tif(x>0&&e.color=='A') e.cost+=x; \n\tif(x<0&&e.color=='B') e.cost-=x; \n\tkr.edges.emplace_back(e);\n      }\n      \n      ans=kr.build();\n      if(ans<0) return Int(-1);\n      if(x>0) ans-=x*k;\n      if(x<0) ans+=x*(n-1-k);\n      \n      Int res=0;\n      for(auto e:kr.edges)\n\tres+=(e.used&&e.color=='A');\n      return res;\n    };\n    double l=0,r=2*ub;\n    if(check(l)<k||check(r)>k){\n      cout<<-1<<endl;\n      continue;\n    }\n    for(Int i=0;i<1000;i++){\n      double m=(l+r)/2;\n      if(check(m)>=k) l=m;\n      else r=m;\n    }\n    check(l);\n    assert(check(l)==k);\n    cout<<(Int)round(ans)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);++i)\n#define rep(i,n) REP(i, 0, n)\ntypedef long long int i64;\ntypedef pair<int, int> pint;\n\nstruct UnionFind {\n    vector<int> data; int group;\n    UnionFind(int N) : data(N, -1), group(N) {}\n    void init(int N) {\n        data.assign(N, -1);\n        group = N;\n    }\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n            --group;\n        }\n    }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]);}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\n\nstruct Edge {\n    int from, to, cost;\n    Edge(int f, int t, int c)\n         : from(f), to(t), cost(c) {}\n    bool operator< (const Edge& E) const {\n        return cost < E.cost;\n    }\n};\nint N, M, K;\nint Kruskal(vector<int>& used, UnionFind& uf, const vector<Edge>& edge) {\n    int res = 0;\n    rep(i, edge.size()) {\n        const Edge& e = edge[i];\n        if(uf.same(e.from, e.to)) continue;\n        uf.unite(e.from, e.to);\n        res += e.cost;\n        used.push_back(i);\n    }\n    return res;\n}\n\nint solve(const vector<Edge>& edgea, const vector<Edge>& edgeb) {\n    if(edgea.size() < K || edgeb.size() < (N - K - 1)) return -1;\n    UnionFind uf(N); int res = 0;\n    vector<int> useda, usedb;\n    res += Kruskal(useda, uf, edgea);\n    if(uf.group > 1) {\n        res += Kruskal(usedb, uf, edgeb);\n        if(uf.group > 1) return -1;\n    }\n    vector<int> swap_cost;\n    vector<bool> used_b(edgeb.size(), false);\n    for(int k : usedb) used_b[k] = true;\n    for(int k : useda) {\n        UnionFind temp(N);\n        for(int i : useda) if(i != k)\n          temp.unite(edgea[i].from, edgea[i].to);\n        for(int i : usedb)\n          temp.unite(edgeb[i].from, edgeb[i].to);\n        int kawari = INF;\n        rep(i, edgeb.size()) {\n            if(used_b[i]) continue;\n            const Edge& e = edgeb[i];\n            if(!temp.same(e.from, e.to)) kawari = min(kawari, e.cost);\n        }\n        if(kawari != INF) swap_cost.push_back(edgea[k].cost - kawari);\n    }\n    sort(swap_cost.begin(), swap_cost.end(), greater<int>());\n    int need_to_swap = edgea.size() - K;\n    if(need_to_swap > swap_cost.size() || need_to_swap < 1) return -1;\n    rep(i, need_to_swap) res -= swap_cost[i];\n    return res;\n}\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    while(cin >> N >> M >> K && N) {\n        int u_, v_, w_; char l_;\n        vector<Edge> edge_a, edge_b;\n        rep(_, M) {\n            cin >> u_ >> v_ >> w_ >> l_;\n            --u_; --v_;\n            if(l_ == 'A') edge_a.emplace_back(u_, v_, w_);\n            else edge_b.emplace_back(u_, v_, w_);\n        }\n        sort(edge_a.begin(), edge_a.end());\n        sort(edge_b.begin(), edge_b.end());\n        cout << solve(edge_a, edge_b) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\nstruct edge {\n    ll u, v, w;\n    char l;\n};\n\nbool operator> (const edge &a, const edge &b) {\n    if(a.w != b.w) return a.w > b.w;\n    return a.l > b.l;\n}\n\n\nedge edges[606];\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        ll n, m, k;\n        cin >> n >> m >> k;\n        if(n == 0) break;\n        for(int i = 1; i <= m; i++) {\n            cin >> edges[i].u >> edges[i].v >> edges[i].w >> edges[i].l;\n            edges[i].w *= 2;\n        }\n        UnionFind checker(n + 1);\n        ll NUMA = 0;\n        for(int i = 1; i <= m; i++) {\n            if(edges[i].l == 'A') {\n                if(checker.merge(edges[i].u, edges[i].v)) NUMA++;\n            }\n        }\n        for(int i = 1; i <= m; i++) {\n            if(edges[i].l == 'B') {\n                checker.merge(edges[i].u, edges[i].v);\n            }\n        }\n        if(checker.size(1) < n || NUMA < k) {\n            cout << -1 << endl;\n            continue;\n        }\n        checker.init(n + 1);\n        NUMA = 0;\n        for(int i = 1; i <= m; i++) {\n            if(edges[i].l == 'B') {\n                checker.merge(edges[i].u, edges[i].v);\n            }\n        }\n        for(int i = 1; i <= m; i++) {\n            if(edges[i].l == 'A') {\n                if(checker.merge(edges[i].u, edges[i].v)) NUMA++;\n            }\n        }\n        if(NUMA > k) {\n            cout << -1 << endl;\n            continue;\n        }\n        ll ok = -1e4;\n        ll ng = 1e4;\n        while(ng - ok > 1) {\n            ll mid = (ok + ng) / 2;\n            //cerr << \"mid; \" << mid << endl;\n            priority_queue<edge, vector<edge>, greater<edge>> query;\n            for(int i = 1; i <= m; i++) {\n                edge now = edges[i];\n                if(now.l == 'A') {\n                    now.w += mid;\n                }\n                query.push(now);\n            }\n            UnionFind uni(n + 1);\n            ll numa = 0;\n            while(!query.empty()) {\n                edge now = query.top();\n                query.pop();\n                if(uni.merge(now.u, now.v)) {\n                    if(now.l == 'A') numa++;\n                    //cerr << now.u << \" \" << now.v << \" \" << now.w << \" \" << now.l << endl;\n                }\n            }\n            if(numa >= k) ok = mid;\n            else ng = mid;\n        }\n        //cerr << \"ok: \" << ok << endl;\n        ll ans = -ok * k;\n        priority_queue<edge, vector<edge>, greater<edge>> query;\n        for(int i = 1; i <= m; i++) {\n            edge now = edges[i];\n            if(now.l == 'A') {\n                now.w += ok;\n            }\n            query.push(now);\n        }\n        UnionFind uni(n + 1);\n        ll numa = 0;\n        while(!query.empty()) {\n            edge now = query.top();\n            query.pop();\n            if(uni.merge(now.u, now.v)) {\n                if(now.l == 'A') numa++;\n                ans += now.w;\n                //cerr << now.u << \" \"<< now.v << \" \" << now.w << \" \" << now.l << endl;\n            }\n        }\n        cout << ans / 2 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct Kruskal{\n\n  struct UnionFind{\n    Int n;\n    vector<Int> r,p;\n    UnionFind(){}\n    UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n    Int find(Int x){\n      return (x==p[x]?x:p[x]=find(p[x]));\n    }\n    bool same(Int x,Int y){\n      return find(x)==find(y);\n    }\n    void unite(Int x,Int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      if(r[x]<r[y]) swap(x,y);\n      r[x]+=r[y];\n      p[y]=x;\n    }\n  };\n  \n  struct edge{\n    Int from,to,cost,used;\n    char color;\n    edge(){}\n    edge(Int from,Int to,Int cost,char color):\n      from(from),to(to),cost(cost),used(0),color(color){}\n    bool operator<(const edge& e) const{\n      return cost<e.cost;\n    }\n  };\n\n  Int n;\n  vector<edge> edges;\n\n  Kruskal(){}\n  Kruskal(Int sz):n(sz){}\n  \n  Int build(){\n    sort(edges.begin(),edges.end());\n    UnionFind uf(n+1);\n    Int res=0,cnt=0;\n    for(Int i=0;i<(Int)edges.size();i++){\n      edge &e=edges[i];\n      if(!uf.same(e.from,e.to)){\n\te.used=1;\n\tres+=e.cost;\n\tuf.unite(e.from,e.to);\n\tcnt++;\n      }\n    }\n    if(cnt+1!=n) return -1;\n    return res;\n  }\n};\n\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    Kruskal kr(n);\n    auto edges=kr.edges;\n    for(Int i=0;i<m;i++){\n      Int u,v,w;\n      char c;\n      cin>>u>>v>>w>>c;\n      u--;v--;\n      edges.emplace_back(u,v,w,c);\n    }\n    Int ub=1e12,ans;\n    auto check=[&](Int x){\n      x-=ub;\n      kr=Kruskal(n);\n      for(auto e:edges){\n\tif(x>0&&e.color=='A') e.cost+=x; \n\tif(x<0&&e.color=='B') e.cost-=x; \n\tkr.edges.emplace_back(e);\n      }\n      \n      ans=kr.build();\n      if(ans<0) return ans;\n      if(x>0) ans-=x*k;\n      if(x<0) ans+=x*(n-1-k);\n      \n      Int res=0;\n      for(auto e:kr.edges)\n\tres+=(e.used&&e.color=='A');\n      return res;\n    };\n    Int l=0,r=2*ub;\n    if(check(l)<k||check(r)>k){\n      cout<<-1<<endl;\n      continue;\n    }\n    while(l+1<r){\n      Int m=(l+r)>>1;\n      if(check(m)>=k) l=m;\n      else r=m;\n    }\n    check(l);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++)\nconst ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nint popcnt(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_popcountll(a);\n#else\n\treturn _mm_popcnt_u32(a >> 32) + _mm_popcnt_u32(a);\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n#endif\n}\nint bitscanf(unsigned long a) {\n#ifndef _MSC_VER\n\treturn __builtin_ctz(a);\n#else\n\t_BitScanForward(&a, a);\n\treturn a;\n#endif\n}\ntemplate<class T>\nclass matrix {\npublic:\n\tvector<valarray<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, valarray<T>(e, m == -1 ? n : m)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)ret[i] += obj[i][j] * p.obj[j];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tbool operator==(const matrix&p) {\n\t\tif (s != p.s)return 0;\n\t\trep(i, s.first)rep(j, s.second)if (obj[i][j] != p.obj[i][j])return 0;\n\t\treturn 1;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\tvalarray<T>& operator[](int t) {\n\t\treturn obj[t];\n\t}\n\tvoid gauss() {\n\t\tif (size().first + 1 != size().second)return;\n\t\trep(i, size().first) {\n\t\t\tint p = i;\n\t\t\trepi(j, i, size().first)if (abs(obj[j][i]) > abs(obj[p][i]))p = j;\n\t\t\tswap(obj[i], obj[p]);\n\t\t\tif (abs(obj[i][i]) < 1e-8)return;//contniue;\n\t\t\trepi(j, i + 1, size().second)obj[i][j] /= obj[i][i];\n\t\t\trep(j, size().first) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\trepi(k, i + 1, size().second)obj[j][k] -= obj[j][i] * obj[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned long long exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a=0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned long long exp, ll m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a = 0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\nint main() {\n\tint n, m, k;\n\twhile (cin >> n >> m >> k, n) {\n\t\tvector<tuple<int,int,double,char>> e(m);\n\t\trep(i, m) {\n\t\t\tint u, v, w;\n\t\t\tchar l;\n\t\t\tcin >> u >> v >> w;\n\t\t\tcin >> l;\n\t\t\tu--, v--;\n\t\t\te[i] = tie(u, v, w, l);\n\t\t}\n\t\tint l = -110, u = 110;\n\t\tint cost;\n\t\twhile (l != u) {\n\t\t\tint mi = (l + u)/2;\n\t\t\tauto a = e;\n\t\t\tdouble m1 = mi + 0.0005;\n\t\t\trep(i, m)if (get<3>(a[i]) == 'A')get<2>(a[i]) += m1;\n\t\t\tsort(ALL(a), [](auto a, auto b) {return get<2>(a) < get<2>(b); });\n\t\t\tunionfind uf1(n), uf2(n);\n\t\t\tdouble cost1 = 0, cost2 = 0;\n\t\t\tint k1 = 0, k2 = 0;\n\t\t\trep(i, m)if (!uf1.same(get<0>(a[i]), get<1>(a[i])))uf1.unite(get<0>(a[i]), get<1>(a[i])), cost1 += get<2>(a[i]), k1 += (get<3>(a[i]) == 'A' ? 1 : 0);\n\t\t\trep(i, m)if (get<3>(a[i]) == 'A')get<2>(a[i]) -= 0.001;\n\t\t\tsort(ALL(a), [](auto a, auto b) {return get<2>(a) < get<2>(b); });\n\t\t\trep(i, m)if (!uf2.same(get<0>(a[i]), get<1>(a[i])))uf2.unite(get<0>(a[i]), get<1>(a[i])), cost2 += get<2>(a[i]), k2 += (get<3>(a[i]) == 'A' ? 1 : 0);\n\t\t\tif (k1 <= k&&k <= k2)u = l = mi;\n\t\t\telse if (k < k1)l = mi + 1;\n\t\t\telse u = mi - 1;\n\t\t\tcost = round((cost1 + cost2) / 2) - k*mi;\n\t\t}\n\t\tif (l > 100 || l < -100)cout << -1 << endl;\n\t\telse cout << cost << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int from, to, cost, id;\n    char type;\n};\nbool operator <(const Edge& e1, const Edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par;\npublic:\n    UnionFind(int n) : sz(n) {\n        par = vector<int>(n);\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int root(int a) {\n        if (par[a] == a) return a;\n        return par[a] = root(par[a]);\n    }\n    void unite(int a, int b) {\n        par[root(a)] = par[root(b)];\n    }\n    bool isUnited(int a, int b) {\n        return root(a) == root(b);\n    }\n};\n\nconst int inf = 1e9;\n\nvoid add_edge(vector< vector<Edge> >& G, Edge& e) {\n    G[e.from].push_back({e.from, e.to, e.cost, e.id, e.type});\n    G[e.to].push_back({e.to, e.from, e.cost, e.id, e.type});\n}\nvoid remove_edge(vector< vector<Edge> >& G, Edge& e) {\n    int f = 0;\n    for (int i = 0; i < G[e.from].size(); ++i) {\n        if ( G[e.from][i].id == e.id ) {\n            G[e.from].erase(G[e.from].begin()+i, G[e.from].begin()+i+1);\n            ++f;\n            break;\n        }\n    }\n    for (int i = 0; i < G[e.to].size(); ++i) {\n        if ( G[e.to][i].id == e.id ) {\n            G[e.to].erase(G[e.to].begin()+i, G[e.to].begin()+i+1);\n            ++f;\n            break;\n        }\n    }\n    assert(f == 2);\n}\nEdge dfs(vector< vector<Edge> >& G, int v, int t, char type, int prev, vector<bool>& used) {\n    Edge res = {0, 0, inf, -1, 'X'};\n    if (used[v]) return res;\n    used[v] = true;\n    if (v == t) {\n        res.cost--;\n        return res;\n    }\n    for (int i = 0; i < G[v].size(); ++i) {\n        Edge& e = G[v][i];\n        if (e.to != prev) {\n            Edge r = dfs(G, e.to, t, type, v, used);\n            if (r.cost != inf) {\n                res = min(res, r);\n                if (e.type == type) {\n                    res = min(res, e);\n                }\n            }\n        }\n    }\n    return res;\n}\nEdge calc(vector< vector<Edge> >& G, Edge& e) {\n    vector<bool> used(G.size(), false);\n    Edge ee = dfs(G, e.from, e.to, (e.type == 'A' ? 'B' : 'A'), -1, used);\n    return ee;\n}\nint main() {\n    int n, m, k;\n    while (cin >> n >> m >> k, n || m || k) {\n        vector<Edge> ae, be, edges;\n        for (int i = 0; i < m; ++i) {\n            int u, v, w; char l; cin >> u >> v >> w >> l; --u, --v;\n            if (l == 'A') {\n                ae.push_back({u, v, w, i, l});\n            }\n            else {\n                be.push_back({u, v, w, i, l});\n            }\n            edges.push_back({u, v, w, i, l});\n        }\n        sort(ae.begin(), ae.end());\n        sort(be.begin(), be.end());\n        sort(edges.begin(), edges.end());\n        vector< vector<Edge> > G(n);\n        UnionFind uf(n);\n        int ans = 0;\n        int cnt = 0, acnt = 0, bcnt = 0;\n        set<int> s;\n        for (int i = 0; i < edges.size(); ++i) {\n            if (cnt >= n-1) break;\n            Edge& e = edges[i];\n            if (uf.isUnited(e.from, e.to)) continue;\n            uf.unite(e.from, e.to);\n            ans += e.cost;\n            add_edge(G, e);\n            ++cnt;\n            s.insert(e.id);\n            if (e.type == 'A') ++acnt;\n            else ++bcnt;\n        }\n        if (cnt < n-1) {\n            cout << -1 << endl;\n            continue;\n        }\n        if (acnt > k) {\n            swap(acnt, bcnt);\n            swap(ae, be);\n            k = n - k - 1;\n        }\n        // remove use edges\n        // int s0 = 0;\n        // for (int i = ea.size()-1; i >= 0; --i) {\n        //     if (s.count(ea.id) > 0) {\n        //         s0 = i+1;\n        //         break;\n        //     }\n        // }\n        vector<bool> used(ae.size(), false);\n        for (int i = 0; i < ae.size(); ++i) {\n            if (s.count(ae[i].id) > 0) {\n                used[i] = true;\n            }\n        }\n        assert(k-acnt >= 0);\n        for (int t = 0; t < k-acnt; ++t) {\n            Edge a = {0, 0, inf-1, -1, 'X'};\n            int b = -1;\n            for (int i = 0; i < ae.size(); ++i) {\n                if (used[i]) continue;\n                // cout << calc(G, ae[i]) << endl;\n                Edge e = calc(G, ae[i]);\n                if (e.cost < inf-1 && (b < 0 || ae[i].cost - e.cost <= ae[b].cost - a.cost)) {\n                    a = e;\n                    b = i;\n                }\n            }\n            if (b < 0) {\n                ans = -1;\n                break;\n            }\n            // if (a.cost >= inf) assert(false);\n            // cout << a.cost << \" \" << b << endl;\n            used[b] = true;\n            remove_edge(G, a);\n            add_edge(G, ae[b]);\n            ans += ae[b].cost;\n            ans -= a.cost;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nstruct UnionFind\n{\n\tvector<int> par;\n\tUnionFind(int n) :par(n, -1) {}\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (par[y] < par[x]) swap(x, y);\n\t\tif (par[x] == par[y]) par[x]--;\n\t\tpar[y] = x;\n\t\tif (find(x) != find(y)) par[find(y)] = x;\n\t}\n\tint count()\n\t{\n\t\tint cnt = 0;\n\t\tREP(i, par.size()) if (par[i] < 0) cnt++;\n\t\treturn cnt;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\ntypedef ld Weight;\nstruct Edge\n{\n\tint from, to; Weight cost; char c;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\n\nconst ld INF = 1e9;\nconst ld EPS = 1e-9;\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m, k;\n\twhile (cin >> n >> m >> k, n)\n\t{\n\t\tEdges es;\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; ld c; char d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--; b--;\n\t\t\tes.emplace_back(Edge{ a, b, c, d });\n\t\t}\n\t\tint mn = INF, mx = -1;\n\t\tld lb = -INF, ub = INF;\n\t\tREP(lp, 300)\n\t\t{\n\t\t\tld mid = (ub + lb) / 2;\n\t\t\tEdges tmp;\n\t\t\tfor (auto e : es)\n\t\t\t{\n\t\t\t\tif (e.c == 'A') e.cost += mid;\n\t\t\t\ttmp.push_back(e);\n\t\t\t}\n\t\t\tsort(ALL(tmp));\n\t\t\tUnionFind uf(n);\n\t\t\tld cost = 0;\n\t\t\tint cnta = 0;\n\t\t\tfor (auto e : tmp)\n\t\t\t{\n\t\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\t\tif (e.c == 'A')\n\t\t\t\t{\n\t\t\t\t\tcnta++;\n\t\t\t\t}\n\t\t\t\tcost += e.cost;\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t}\n\n\t\t\tchmax(mx, cnta);\n\t\t\tchmin(mn, cnta);\n\t\t\tif (lp == 299)\n\t\t\t{\n\t\t\t\tif (uf.count() != 1 || (mx < k || mn > k))\n\t\t\t\t{\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcout << ll(cost - k * mid + EPS) << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (cnta > k)\n\t\t\t{\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tub = mid;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int from, to, cost, id;\n    char type;\n};\nbool operator <(const Edge& e1, const Edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par;\npublic:\n    UnionFind(int n) : sz(n) {\n        par = vector<int>(n);\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int root(int a) {\n        if (par[a] == a) return a;\n        return par[a] = root(par[a]);\n    }\n    void unite(int a, int b) {\n        par[root(a)] = par[root(b)];\n    }\n    bool isUnited(int a, int b) {\n        return root(a) == root(b);\n    }\n};\n\nconst int inf = 1e9;\n\nvoid add_edge(vector< vector<Edge> >& G, Edge& e) {\n    G[e.from].push_back({e.from, e.to, e.cost, e.id, e.type});\n    G[e.to].push_back({e.to, e.from, e.cost, e.id, e.type});\n}\nvoid remove_edge(vector< vector<Edge> >& G, Edge& e) {\n    int f = 0;\n    for (int i = 0; i < G[e.from].size(); ++i) {\n        if ( G[e.from][i].id == e.id ) {\n            G[e.from].erase(G[e.from].begin()+i, G[e.from].begin()+i+1);\n            ++f;\n            break;\n        }\n    }\n    for (int i = 0; i < G[e.to].size(); ++i) {\n        if ( G[e.to][i].id == e.id ) {\n            G[e.to].erase(G[e.to].begin()+i, G[e.to].begin()+i+1);\n            ++f;\n            break;\n        }\n    }\n    assert(f == 2);\n}\nEdge dfs(vector< vector<Edge> >& G, int v, int t, char type, int prev, vector<bool>& used) {\n    Edge res = {0, 0, inf, -1, 'X'};\n    if (used[v]) assert(false);\n    used[v] = true;\n    if (v == t) {\n        res.cost--;\n        return res;\n    }\n    for (int i = 0; i < G[v].size(); ++i) {\n        Edge& e = G[v][i];\n        assert(e.from == v);\n        if (e.to != prev) {\n            Edge r = dfs(G, e.to, t, type, v, used);\n            if (r.cost != inf) {\n                res = min(res, r);\n                if (e.type == type) {\n                    res = min(res, e);\n                }\n            }\n        }\n    }\n    return res;\n}\nEdge calc(vector< vector<Edge> >& G, Edge& e) {\n    vector<bool> used(G.size(), false);\n    Edge ee = dfs(G, e.from, e.to, (e.type == 'A' ? 'B' : 'A'), -1, used);\n    return ee;\n}\nint main() {\n    int n, m, k;\n    while (cin >> n >> m >> k, n || m || k) {\n        vector<Edge> ae, be, edges;\n        for (int i = 0; i < m; ++i) {\n            int u, v, w; char l; cin >> u >> v >> w >> l; --u, --v;\n            if (l == 'A') {\n                ae.push_back({u, v, w, i, l});\n            }\n            else {\n                be.push_back({u, v, w, i, l});\n            }\n            edges.push_back({u, v, w, i, l});\n        }\n        sort(ae.begin(), ae.end());\n        sort(be.begin(), be.end());\n        sort(edges.begin(), edges.end());\n        vector< vector<Edge> > G(n);\n        UnionFind uf(n);\n        int ans = 0;\n        int cnt = 0, acnt = 0, bcnt = 0;\n        set<int> s;\n        for (int i = 0; i < edges.size(); ++i) {\n            if (cnt >= n-1) break;\n            Edge& e = edges[i];\n            if (uf.isUnited(e.from, e.to)) continue;\n            uf.unite(e.from, e.to);\n            ans += e.cost;\n            add_edge(G, e);\n            ++cnt;\n            s.insert(e.id);\n            if (e.type == 'A') ++acnt;\n            else ++bcnt;\n        }\n        if (cnt < n-1) {\n            cout << -1 << endl;\n            continue;\n        }\n        if (acnt > k) {\n            swap(acnt, bcnt);\n            swap(ae, be);\n            k = n - k - 1;\n        }\n        // remove use edges\n        // int s0 = 0;\n        // for (int i = ea.size()-1; i >= 0; --i) {\n        //     if (s.count(ea.id) > 0) {\n        //         s0 = i+1;\n        //         break;\n        //     }\n        // }\n        vector<bool> used(ae.size(), false);\n        for (int i = 0; i < ae.size(); ++i) {\n            if (s.count(ae[i].id) > 0) {\n                used[i] = true;\n            }\n        }\n        assert(k-acnt >= 0);\n        for (int t = 0; t < k-acnt; ++t) {\n            Edge a = {0, 0, inf-1, -1, 'X'};\n            int b = -1;\n            for (int i = 0; i < ae.size(); ++i) {\n                if (used[i]) continue;\n                // cout << calc(G, ae[i]) << endl;\n                Edge e = calc(G, ae[i]);\n                if (e.cost < inf-1 && (b < 0 || ae[i].cost - e.cost <= ae[b].cost - a.cost)) {\n                    a = e;\n                    b = i;\n                }\n            }\n            if (b < 0) {\n                ans = -1;\n                break;\n            }\n            // if (a.cost >= inf) assert(false);\n            // cout << a.cost << \" \" << b << endl;\n            used[b] = true;\n            remove_edge(G, a);\n            add_edge(G, ae[b]);\n            ans += ae[b].cost;\n            ans -= a.cost;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\ntypedef vector<int> Vint;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct unionfind{\n\tvector<int> data;\n\tvoid use(int n){ data.assign(n, -1); }\n\tbool unionset(int x, int y){\n\t\tx = root(x); y = root(y);\n\t\tif(x != y){\n\t\t\tif(data[y] < data[x])swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findset(int x, int y){ return root(x) == root(y); }\n\tint root(int x){ return (data[x] < 0) ? x : data[x] = root(data[x]); }\n\tint size(int x){ return -data[root(x)]; }\n};\n\nstruct edge{\n  int to, cost;\n  bool isa;\n};\n\nstruct state{\n  ll cost;\n  int k, nk;\n};\n\nvector<edge> G[200];\nvector< pair<edge, int> > lis;\n\nbool mycom(pair<edge, int> a, pair<edge, int> b){\n  if(a.X.cost != b.X.cost)return a.X.cost < b.X.cost;\n\treturn a.X.isa;\n}\n\nstate kruskal(int v, int e, int a, int k){\n  state res; res.cost = 0; res.k = 0; res.nk = 0;\n  int i, j;\n  unionfind U; U.use(v);\n  rep(i, v)rep(j, G[i].size()){\n    if(G[i][j].isa)G[i][j].cost += a;\n    lis.pb(mp(G[i][j], i));\n    if(G[i][j].isa)G[i][j].cost -= a;\n  }\n  sort(all(lis), mycom);\n  for(i = 0;i < e;i++){\n    pair<edge, int> tmp = lis[i];\n    if(!U.findset(tmp.X.to, tmp.Y)){\n\t\t\tif(res.k == k && tmp.X.isa)continue;\n\t\t\tif(res.nk == v - 1 - k && !tmp.X.isa)continue;\n      res.cost += tmp.X.cost;\n      U.unionset(tmp.X.to, tmp.Y);\n      if(tmp.X.isa)res.k++;\n      else res.nk++;\n    }\n  }\n  lis.clear();\n  return res;\n}\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int3(n, m, k);\n    if(!(n | m | k))break;\n\n    rep(i, m){\n      int3(x, y, z); string AB; cin >> AB;\n      --x; --y;\n      G[x].pb((edge){y, z, (AB == \"A\")});\n    }\n\n    int l = -110, r = 119;\n    state lef = kruskal(n, m, l, k);\n    state rig = kruskal(n, m, r, k);\n\n    if(rig.k <= k && k <= lef.k && lef.k + lef.nk == n - 1){\n\t\t\tll res = 1415926535;\n      for(;l <= r;++l){\n        lef = kruskal(n, m, l, k);\n\t\t\t\tif(lef.k == k){\n\t\t\t\t\tres = min(res, lef.cost - l * k);\n\t\t\t\t}\n      }\n      pri(res);\n    }else pri(-1);\n\n\n//*/\n    rep(i, n)G[i].clear();\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct Kruskal{\n\n  struct UnionFind{\n    Int n;\n    vector<Int> r,p;\n    UnionFind(){}\n    UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n    Int find(Int x){\n      return (x==p[x]?x:p[x]=find(p[x]));\n    }\n    bool same(Int x,Int y){\n      return find(x)==find(y);\n    }\n    void unite(Int x,Int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      if(r[x]<r[y]) swap(x,y);\n      r[x]+=r[y];\n      p[y]=x;\n    }\n  };\n  \n  struct edge{\n    Int from,to,cost,used;\n    char color;\n    edge(){}\n    edge(Int from,Int to,Int cost,char color):\n      from(from),to(to),cost(cost),used(0),color(color){}\n    bool operator<(const edge& e) const{\n      return cost<e.cost;\n    }\n  };\n\n  Int n;\n  vector<edge> edges;\n\n  Kruskal(){}\n  Kruskal(Int sz):n(sz){}\n  \n  void add_edge(Int u,Int v,Int c,char d){\n    edges.emplace_back(u,v,c,d);\n  }\n\n  void input(Int m,Int offset=0){\n    Int a,b,c;\n    char d;\n    for(Int i=0;i<m;i++){\n      cin>>a>>b>>c>>d;\n      add_edge(a+offset,b+offset,c,d);\n    }\n  }\n  \n  Int build(){\n    sort(edges.begin(),edges.end());\n    UnionFind uf(n+1);\n    Int res=0,cnt=0;\n    for(auto &e:edges){\n      if(!uf.same(e.from,e.to)){\n\tres+=e.cost;\n\tuf.unite(e.from,e.to);\n\te.used=1;\n\tcnt++;\n      }\n    }\n    //cout<<cnt<<\" \"<<res<<endl;\n    if(cnt+1!=n) return -1;\n    return res;\n  }\n\n  Int count(char c){\n    Int res=0;\n    for(auto& e:edges)\n      if(e.used&&e.color==c) res++;\n    return res;\n  }\n};\n\n\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    //cout<<n<<\" \"<<m<<\" \"<<k<<endl;\n    Kruskal kr(n);\n    kr.input(m,-1);\n    Int ans=kr.build();\n    if(ans<0){\n      cout<<-1<<endl;\n      continue;\n    }\n    \n    auto es=kr.edges;\n    Int A=kr.count('A');\n    Int B=kr.count('B');\n    Kruskal kr2;\n    auto check=[&](char c,char d,Int i){\n      kr2=Kruskal(n);\n      for(Int j=0;j<m;j++){\n\tif(es[j].color==d)\n\t  kr2.add_edge(es[j].from,es[j].to,es[j].cost,d);\n\telse if(i!=j&&es[j].used)\n\t  kr2.add_edge(es[j].from,es[j].to,es[j].cost,c);\n      }\n      //cout<<\"kr2:\"<<kr2.edges.size()<<endl;\n      return kr2.build();\n    };\n\n    //cout<<A<<\" \"<<B<<endl;\n    while(A>k){\n      Int res=-1,idx=-1;\n      for(Int i=0;i<m;i++){\n\tif(es[i].color!='A'||!es[i].used) continue;\n\tInt tmp=check('A','B',i);\n\tif(tmp<0) continue;\n\tif(res<0||tmp<res) res=tmp,idx=i;\n      }\n      if(idx<0) break;\n      ans=check('A','B',idx);\n      A--;B++;es=kr2.edges;\n    }\n    while(A<k){\n      Int res=-1,idx=-1;\n      for(Int i=0;i<m;i++){\n\tif(es[i].color!='B'||!es[i].used) continue;\n\tInt tmp=check('B','A',i);\n\tif(tmp<0) continue;\n\tif(res<0||tmp<res) res=tmp,idx=i;\n      }\n      if(idx<0) break;\n      ans=check('B','A',idx);\n      A++;B--;es=kr2.edges;\n      //cout<<A<<\" \"<<B<<\":\"<<ans<<endl;\n    }\n    if(A!=k) cout<<-1<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nusing Weight = ll;\nstruct Edge {\n\tint src, dst; Weight weight;\n\tchar id;\n\tEdge() {}\n\tEdge(int s, int d, Weight w, char id) : src(s), dst(d), weight(w), id(id) {}\n};\nusing Edges = vector<Edge>;\n\nstruct UnionFind {\n\tvector<int> par;\n\tint cnt;\n\tUnionFind(int size_) : par(size_, -1), cnt(size_) {}\n\tvoid unite(int x, int y) {\n\t\tif((x = find(x)) != (y = find(y))) {\n\t\t\tif(par[y] < par[x]) swap(x, y);\n\t\t\tpar[x] += par[y]; par[y] = x; cnt--;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tint size(int x) { return -par[find(x)]; }\n\tint size() { return cnt; }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n\tif(e.weight != f.weight) return e.weight < f.weight;\n\treturn e.id > f.id;\n}\npair<Weight, Edges> kruskal(int N, Edges es) {\n\tUnionFind uf(N);\n\tsort(es.begin(), es.end());\n\tWeight total = 0; Edges T;\n\tfor(auto &e : es) if(!uf.same(e.src, e.dst)) {\n\t\tT.push_back(e); total += e.weight; uf.unite(e.src, e.dst);\n\t}\n\treturn make_pair(total, T);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, K;\n\twhile(cin >> N >> M >> K, N) {\n\t\tEdges es;\n\t\tUnionFind uf(N);\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint u, v, w;\n\t\t\tchar l;\n\t\t\tcin >> u >> v >> w >> l;\n\t\t\tu--, v--;\n\t\t\tes.push_back(Edge(u, v, w, l));\n\t\t\tuf.unite(u, v);\n\t\t}\n\n\t\tif(uf.size(0) != N) {\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst ll INF = 1LL << 30;\n\t\tll ng = -INF, ok = INF;\n\t\twhile(abs(ng - ok) > 1) {\n\t\t\tll mid = (ng + ok) / 2;\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tif(es[i].id == 'A') es[i].weight += mid;\n\t\t\t}\n\n\t\t\tauto res = kruskal(N, es);\n\t\t\tint sum = 0;\n\t\t\tfor(auto e : res.second) {\n\t\t\t\tif(e.id == 'A') sum++;\n\t\t\t}\n\t\t\tif(sum <= K) ok = mid;\n\t\t\telse ng = mid;\n\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tif(es[i].id == 'A') es[i].weight -= mid;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tif(es[i].id == 'A') es[i].weight += ok;\n\t\t}\n\t\tauto resR = kruskal(N, es);\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tif(es[i].id == 'A') es[i].weight--;\n\t\t}\n\t\tauto resL = kruskal(N, es);\n\n\t\tint sumR = 0, sumL = 0;\n\t\tfor(auto e : resR.second) {\n\t\t\tif(e.id == 'A') sumR++;\n\t\t}\n\t\tfor(auto e : resL.second) {\n\t\t\tif(e.id == 'A') sumL++;\n\t\t}\n\t\tif(sumR <= K && K <= sumL) {\n\t\t\tcout << resR.first - ok * K << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\n\tint find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\npublic:\n\tunion_find(int n):uf(n, -1) {}\n\n\tbool unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return false;\n\n\t\tif(uf[x] > uf[y]) swap(x, y);\n\t\telse if(uf[x] == uf[y]) --uf[x];\n\n\t\tuf[y] = x;\n\t\treturn true;\n\t}\n\n\tint number_of_sets() {\n\t\treturn count_if(uf.begin(), uf.end(), [](const int &x){return x < 0;});\n\t}\n};\n\ntypedef tuple<int, char, int, int> edge; // cost, color, u, v\n\npair<int, int> kruskal(const int n, vector<edge> &edges, const int offset_a) {\n\tunion_find uf(n);\n\tint num_a = 0;\n\tint res = 0;\n\n\tconst auto calc = [&](const edge &e) { return make_pair(get<0>(e) + (get<1>(e) == 'A' ? offset_a : 0), -get<1>(e)); };\n\tsort(begin(edges), end(edges), [&](const edge &a, const edge &b) { return calc(a) < calc(b); });\n\n\tfor(const auto &e : edges) {\n\t\tif(uf.unite(get<2>(e), get<3>(e))) {\n\t\t\tres += calc(e).first;\n\t\t\tif(get<1>(e) == 'A') ++num_a;\n\t\t}\n\t}\n\n\treturn make_pair(num_a, res);\n}\n\nint solve(const int n, const int m, const int k) {\n\tvector<edge> edges;\n\tedges.reserve(m);\n\n\tunion_find uf(n);\n\tfor(int i = 0; i < m; ++i) {\n\t\tint u, v, w;\n\t\tchar l;\n\t\tcin >> u >> v >> w >> l;\n\t\t--u; --v;\n\n\t\tedges.emplace_back(w, l, u, v);\n\t\tuf.unite(u, v);\n\t}\n\n\tif(uf.number_of_sets() > 1) return -1;\n\n\tconstexpr int INF = (1 << 20);\n\tint L = -INF, R = INF;\n\twhile(L + 1 < R) {\n\t\tconst int M = (L + R) / 2;\n\t\tif(kruskal(n, edges, M).first <= k) {\n\t\t\tR = M;\n\t\t}\n\t\telse {\n\t\t\tL = M;\n\t\t}\n\t}\n\n\tconst auto result_R = kruskal(n, edges, R);\n\tconst auto result_L = kruskal(n, edges, L);\n\n\tif(!(result_R.first <= k && k <= result_L.first)) return -1;\n\treturn result_R.second - R * k;\n}\n\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n, m, k; cin >> n >> m >> k && n;) {\n\t\tcout << solve(n, m, k) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nstruct edge\n{\n    int u,v,cost,kind;\n    bool operator< (const edge& another) const {\n        return cost < another.cost;\n    }\n};\n\nstruct eda\n{\n    int to,cost,kind;\n};\n\nclass UF {\nprivate:\n    int sz; vector<int> par,nrank;\npublic:\n    UF(){}\n    UF(int node_size){ sz = node_size; par.resize(sz),nrank.resize(sz,0); rep(i,sz) par[i] = i; }\n    int find(int x){ if(par[x] == x){ return x; }else{ return par[x] = find(par[x]); } }\n    void unite(int x,int y)\n    { x = find(x),y = find(y); if(x == y) return;\n    \tif(nrank[x] < nrank[y]){ par[x] = y; }else{ par[y] = x; if(nrank[x] == nrank[y]) nrank[x]++; } }\n    bool same(int x,int y){ return find(x) == find(y); }\n};\n\nvoid dfs(int u,int p,int flag,vector<edge>& vec,const set<int>* G,vector<int>& comp)\n{\n    comp[u] = flag;\n    each(v,G[u]){\n        if(v != p){\n            dfs(v,u,flag,vec,G,comp);\n        }\n    }\n}\n\nbool trans(const int n,int ch,int& ans,vector<edge>& vec,set<int>* G,set<int>* use,set<P>* unuse)\n{\n    int diff = INF;\n    int in = -1,out = -1;\n    each(it,use[ch]){\n        vector<int> comp(n,-1);\n        int cri = -vec[it].cost;\n        int id = -1;\n        dfs(vec[it].u,vec[it].v,0,vec,G,comp);\n        dfs(vec[it].v,vec[it].u,1,vec,G,comp);\n        each(it2,unuse[ch^1]){\n            int a = vec[it2.se].u,b = vec[it2.se].v;\n            if(comp[a] != comp[b]){\n                cri += vec[it2.se].cost;\n                id = it2.se;\n                break;\n            }\n        }\n        if(id >= 0 && diff > cri){\n            diff = cri;\n            in = id,out = it;\n        }\n    }\n    G[vec[out].u].erase(vec[out].v),G[vec[out].v].erase(vec[out].u);\n    G[vec[in].u].insert(vec[in].v),G[vec[in].v].insert(vec[in].u);\n    use[ch].erase(out);\n    unuse[ch^1].erase(P(vec[in].cost,in));\n    if(diff == INF){\n        return false;\n    }else{\n        ans += diff;\n        return true;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,m,k;\n        cin >> n >> m >> k;\n        if(n == 0){\n            break;\n        }\n        vector<edge> vec(m);\n        int ans = 0;\n        set<int> G[201];\n        set<int> use[2];\n        set<P> unuse[2];\n        rep(i,m){\n            int a,b,c,d;\n            string hoge;\n            cin >> a >> b >> c >> hoge;\n            if(hoge == \"A\"){\n                d = 0;\n            }else{\n                d = 1;\n            }\n            --a,--b;\n            vec[i] = (edge){a,b,c,d};\n        }\n        int num[2] = {};\n        sort(all(vec));\n        UF uf(n);\n        rep(i,m){\n            int a = vec[i].u,b = vec[i].v;\n            if(!uf.same(a,b)){\n                uf.unite(a,b);\n                G[a].insert(b),G[b].insert(a);\n                ans += vec[i].cost;\n                num[vec[i].kind]++;\n                use[vec[i].kind].insert(i);\n            }else{\n                unuse[vec[i].kind].insert(P(vec[i].cost,i));\n            }\n        }\n        bool flag = false;\n        rep(i,abs(k-num[0])){\n            if(!trans(n,(k > num[0]),ans,vec,G,use,unuse)){\n                cout << \"-1\\n\";\n                flag = true;\n                break;\n            }\n        }\n        if(!flag){\n            cout << ans << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nstruct UnionFind{\n\tint par[210],rank[210];\n\tvoid init(){\n\t\tfor(int i=0;i<210;i++){par[i]=i;rank[i]=0;}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]>rank[y])par[y]=x;\n\t\telse{\n\t\t\tpar[x]=y;\n\t\t\tif(rank[x]==rank[y])rank[y]++;\n\t\t}\n\t\treturn;\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nstruct edge{\n\tint from,to,cost;\n\tedge(){}\n\tedge(int from,int to,int cost):from(from),to(to),cost(cost){}\n\tbool operator < (const edge& a) const{\n\t\treturn cost < a.cost;\n\t}\n};\nint n,m,k;\nvector<edge> A,B;\nint cost,use_a,use;\nvoid check(int x){\n\tuf.init();\n\tint p = 0,q = 0;\n\tcost = 0;\n\tuse_a = 0;\n\tuse = 0;\n\twhile(p<A.size()&&q<B.size()){\n\t\tedge e;\n\t\tbool flag = false;\n\t\tif(p==A.size())e = B[q++];\n\t\telse if(q==B.size()){\n\t\t\te = A[p++];\n\t\t\tflag = true;\n\t\t}else{\n\t\t\tif(A[p].cost+x<B[q].cost){\n\t\t\t\te = A[p++];\n\t\t\t\tflag = true;\n\t\t\t}else if(A[p].cost+x==B[q].cost){\n\t\t\t\tif(use_a<k){\n\t\t\t\t\te = A[p++];\n\t\t\t\t\tflag = true;\n\t\t\t\t}else e = B[q++];\n\t\t\t}else e = B[q++];\n\t\t}\n\t\tif(!uf.same(e.from,e.to)){\n\t\t\tuf.unite(e.from,e.to);\n\t\t\tcost += e.cost;\n\t\t\tif(flag)use_a++;\n\t\t\tuse++;\n\t\t}\n\t}\n\treturn;\n}\nbool solve(){\n\tcin >> n >> m >> k;\n\tif(n==0&&m==0&&k==0)return false;\n\tA.clear();\n\tB.clear();\n\tfor(int i=0;i<m;i++){\n\t\tint u,v,c;\n\t\tchar l;\n\t\tcin >> u >> v >> c >> l;\n\t\tif(l=='A')A.pb(edge(u,v,c));\n\t\telse B.pb(edge(u,v,c));\n\t}\n\tsort(all(A));\n\tsort(all(B));\n\tint ans = INF;\n\tfor(int i=-200;i<=200;i++){\n\t\tcheck(i);\n\t\tif(use_a==k&&use==n-1)ans = min(ans,cost);\n\t}\n\tif(ans==INF)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ans);\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long  ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n,m,k;\nvector<P1>edgea,edgeb;\n\nstruct uf{\n\tint par[205],ran[205];\n\tvoid init(){\n\t\trep(i,205) par[i]=i,ran[i]=0;\n\t}\n\tint find(int x){\n\t\tif(x==par[x]) return x; else return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x); y = find(y);\n\t\tif(x == y) return;\n\t\tif(ran[x] < ran[y]){\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse{\n\t\t\tpar[y] = x;\n\t\t\tif(ran[x] == ran[y]) ran[x]++;\n\t\t}\n\t}\n\tbool same(int x,int y){ return find(x) == find(y); }\n\t\n}kaede;\n\nbool cmp(const pair<P1,int> &a,const pair<P1,int> &b){\n    if(a.fi.fi != b.fi.fi) return a.fi.fi < b.fi.fi;\n    else return a.sc < b.sc;\n}\nint main(){\n\twhile(1){\n\t\tcin >> n >> m >> k;\n\t\tif(n == 0) return 0;\n\t\tedgea.clear(); edgeb.clear();\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint u,v,w; char c; scanf(\"%d%d%d %c\",&u,&v,&w,&c);\n\t\t\tif(c == 'A'){\n\t\t\t\tedgea.pb(mp(w,mp(u,v)));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tedgeb.pb(mp(w,mp(u,v)));\n\t\t\t}\n\t\t}\n\t\tSORT(edgea); SORT(edgeb);\n\t\tint lb = -200, ub = 200;\n\t\tint ans = INF;\n\t\twhile(ub-lb > 1){\n\t\t\tint mid = (lb+ub)/2;\n\t\t\tvector<pair<P1,int> >vec;\n\t\t\tfor(int i=0;i<edgeb.size();i++) vec.pb(mp(edgeb[i],0));\n\t\t\tfor(int i=0;i<edgea.size();i++) vec.pb(mp(mp(edgea[i].fi+mid,edgea[i].sc),1));\n\t\t\tsort(vec.begin(),vec.end(),cmp);\n\t\t\tkaede.init();\n\t\t\tint cnt = 0,ch = 0;\n\t\t\tfor(int i=0;i<vec.size();i++){\n\t\t\t\tint u = vec[i].fi.sc.fi, v = vec[i].fi.sc.sc;\n\t\t\t\tif(kaede.same(u,v) == false){\n\t\t\t\t\tkaede.unite(u,v);\n\t\t\t\t\tif(vec[i].sc == 1) cnt++;\n\t\t\t\t\tch++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ch != n-1){\n\t\t\t\tans = INF;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvector<pair<P1,int> >vecc;\n\t\t\tfor(int i=0;i<edgeb.size();i++) vecc.pb(mp(edgeb[i],2));\n\t\t\tfor(int i=0;i<edgea.size();i++) vecc.pb(mp(mp(edgea[i].fi+mid,edgea[i].sc),1));\n\t\t\tsort(vecc.begin(),vecc.end(),cmp);\n\t\t\tkaede.init();\n\t\t\tint cnt2 = 0, anss = 0;\n\t\t\tfor(int i=0;i<vecc.size();i++){\n\t\t\t\tint u = vecc[i].fi.sc.fi, v = vecc[i].fi.sc.sc;\n\t\t\t\tif(kaede.same(u,v) == false){\n\t\t\t\t\tkaede.unite(u,v);\n\t\t\t\t\tanss += vecc[i].fi.fi;\n\t\t\t\t\tif(vecc[i].sc == 1) cnt2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(cnt <= cnt2);\n\t\t\t//cout << cnt << \" \" << cnt2 << \" \" << mid << endl;\n\t\t\tif(k < cnt){\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t\telse if(k > cnt2){\n\t\t\t\tub = mid;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = min(ans,anss-mid*k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ans == INF) puts(\"-1\");\n\t\telse printf(\"%d\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n/* UnionFind */\n\nstruct UnionFind{\n  vector<int> data, tree_size;\n  UnionFind(int s):data(s,-1),tree_size(s,1) {}\n  \n  int root(int x){\n    if(data[x]==-1) return x;\n    return data[x]=root(data[x]);\n  }\n  \n  bool set(int x,int y){\n    x=root(x);\n    y=root(y);\n    if(x==y) return false;\n    data[y]=x;\n    tree_size[x] += tree_size[y];\n    tree_size[y] = 0;\n    return true;\n  }\n  \n  bool check(int x,int y){\n    x=root(x);\n    y=root(y);\n    return x==y;\n  }\n  \n  int size(int x){\n    return tree_size[root(x)];\n  }\n  \n};\n\n\nint n, m, k;\nint u[SIZE], v[SIZE], w[SIZE], l[SIZE];\n\nint check(int x, int f){\n  vector<pair<int,int> > vec;\n  int sum = 0;\n\n  for(int i=0;i<m;i++){\n    vec.push_back({(w[i] + x * !l[i])*2 + (l[i]^f), i});\n  }\n\n  sort(vec.begin(), vec.end());\n\n  int counter = 0, Acounter = 0;\n  UnionFind uf(n);\n  \n  for(int i=0;i<m;i++){\n    if(uf.set(u[vec[i].second], v[vec[i].second])){\n      counter++;\n      Acounter += !l[vec[i].second];\n      sum += w[vec[i].second];\n    }\n  }\n  \n  if(counter == n-1)\n    return Acounter;\n  else\n    return -1;\n}\n\nint make(int x, int f){\n  vector<pair<int,int> > vec;\n  int sum = 0;\n\n  for(int i=0;i<m;i++){\n    vec.push_back({(w[i] + x * !l[i])*2 + (l[i]^f), i});\n  }\n\n  sort(vec.begin(), vec.end());\n\n  int counter = 0, Acounter = 0;\n  int limit = k;\n  UnionFind uf(n);\n  \n  for(int i=0;i<m;i++){\n    if(limit <= 0 && !l[vec[i].second]) continue;\n    if(uf.set(u[vec[i].second], v[vec[i].second])){\n      counter++;\n      Acounter += !l[vec[i].second];\n      sum += w[vec[i].second];\n      limit -= !l[vec[i].second];\n    }\n  }\n  \n  return sum;\n}\n\nbool solve(){\n  \n  scanf(\"%d%d%d\", &n, &m, &k);\n  if(n == 0) return false;\n  \n  for(int i=0;i<m;i++){\n    char c;\n    scanf(\"%d%d%d %c\", u+i, v+i, w+i, &c);\n    u[i]--; v[i]--;\n    l[i] = c - 'A';\n  }\n\n  int L = -200, R = 200;\n\n  //cerr << check(L,0) << \"-\" <<  check(R+1,0) << endl;\n  //cerr << check(L,1) << \"-\" <<  check(R+1,1) << endl;\n  \n  if(check(L,0) == -1 || (k < check(R+1, 1) || check(L, 0) < k)){\n    puts(\"-1\");\n    return true;\n  }\n  \n  while(L<R){\n    int mid = (L+R+1)/2;\n\n    if(check(mid,0) < k){\n      R = mid-1;\n    }else{\n      L = mid;\n    }\n  }\n\n  //debug(L);\n  \n  int res = make(L,0);\n\n  cout << res << endl;\n\n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nstruct UnionFind{\n\tint par[210],rank[210];\n\tvoid init(){\n\t\tfor(int i=0;i<210;i++){par[i]=i;rank[i]=0;}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]>rank[y])par[y]=x;\n\t\telse{\n\t\t\tpar[x]=y;\n\t\t\tif(rank[x]==rank[y])rank[y]++;\n\t\t}\n\t\treturn;\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nstruct edge{\n\tint from,to,cost;\n\tedge(){}\n\tedge(int from,int to,int cost):from(from),to(to),cost(cost){}\n\tbool operator < (const edge& a) const{\n\t\treturn cost < a.cost;\n\t}\n};\nint n,m,k;\nvector<edge> A,B;\nint cost,use_a_max,use_a_min,use;\nvoid check(int x){\n\tuf.init();\n\tint p = 0,q = 0;\n\tcost = 0;\n\tuse_a_max = 0;\n\tuse = 0;\n\twhile(p<A.size()||q<B.size()){\n\t\tedge e;\n\t\tbool flag = false;\n\t\tif(p==A.size())e = B[q++];\n\t\telse if(q==B.size()){\n\t\t\te = A[p++];\n\t\t\tflag = true;\n\t\t}else{\n\t\t\tif(A[p].cost+x<=B[q].cost){\n\t\t\t\te = A[p++];\n\t\t\t\tflag = true;\n\t\t\t}else e = B[q++];\n\t\t}\n\t\tif(!uf.same(e.from,e.to)){\n\t\t\tuf.unite(e.from,e.to);\n\t\t\tcost += e.cost;\n\t\t\tif(flag)use_a_max++;\n\t\t\tuse++;\n\t\t}\n\t}\n\tuf.init();\n\tp = 0,q = 0;\n\tcost = 0;\n\tuse_a_min = 0;\n\tuse = 0;\n\twhile(p<A.size()||q<B.size()){\n\t\tedge e;\n\t\tbool flag = false;\n\t\tif(p==A.size())e = B[q++];\n\t\telse if(q==B.size()){\n\t\t\te = A[p++];\n\t\t\tflag = true;\n\t\t}else{\n\t\t\tif(A[p].cost+x<B[q].cost){\n\t\t\t\te = A[p++];\n\t\t\t\tflag = true;\n\t\t\t}else e = B[q++];\n\t\t}\n\t\tif(!uf.same(e.from,e.to)){\n\t\t\tuf.unite(e.from,e.to);\n\t\t\tcost += e.cost;\n\t\t\tif(flag)use_a_min++;\n\t\t\tuse++;\n\t\t}\n\t}\n\treturn;\n}\nbool solve(){\n\tcin >> n >> m >> k;\n\tif(n==0&&m==0&&k==0)return false;\n\tA.clear();\n\tB.clear();\n\tfor(int i=0;i<m;i++){\n\t\tint u,v,c;\n\t\tchar l;\n\t\tcin >> u >> v >> c >> l;\n\t\tif(l=='A')A.pb(edge(u,v,c));\n\t\telse B.pb(edge(u,v,c));\n\t}\n\tsort(all(A));\n\tsort(all(B));\n\tfor(int i=-105;i<=105;i++){\n\t\tcheck(i);\n\t\t//cout << i << ' ' << use_a_min << ' ' << use_a_max << ' ' << cost << endl;\n\t\tif(use_a_min<=k&&k<=use_a_max&&use==n-1){\n\t\t\tprintf(\"%d\\n\",cost+i*use_a_min-i*k);\n\t\t\treturn true;\n\t\t}\n\t}\n\tprintf(\"-1\\n\");\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\n#define mp(x, y) make_pair(x, y)\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pipi;\n\nclass UnionFind{\nprivate:\n  vector<int> rank;\n  vector<int> par;\npublic:  \n  UnionFind(int n){\n    rank.resize(n);\n    par.resize(n);\n    for(int i=0;i<n;i++){\n      rank[i] = 0;\n      par[i] = i;\n    }\n  }\n  int find(int x){\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n\n  int same(int x, int y){\n    return find(x) == find(y);\n  }\n\n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }else{\n      par[y] = x;\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n  }\n};\n\nint n, m, k;\nvector<pipi>B;\n\npi kruscal(int a){\n  UnionFind uf(n);\n  int cnt = 0, cost = 0;\n  for(int i=0;i<B.size();i++){\n    if(!uf.same(B[i].second.first, B[i].second.second)){\n      if(B[i].first.second == 'A' && cnt >= k) continue;\n      cost += B[i].first.first;\n      if (B[i].first.second == 'A'){\n\tcnt++;\n\tcost -= a;\n      }\n      uf.unite(B[i].second.first, B[i].second.second);\n    }\n  }\n  return mp(cost, cnt);\n}\n\npi solve(int a){\n  for(int i=0;i<B.size();i++) if(B[i].first.second == 'A') B[i].first.first += a;\n  sort(B.begin(), B.end());\n  pi ret = kruscal(a);\n  for(int i=0;i<B.size();i++) if(B[i].first.second == 'A') B[i].first.first -= a;\n  return ret;\n}\n\nint is_connected(){\n  UnionFind uf(n);\n  //  cout << \"B \" << B.size() << endl;  \n  for(int i=0;i<B.size();i++)\n    if(!uf.same(B[i].second.first, B[i].second.second)){\n      uf.unite(B[i].second.first, B[i].second.second);\n      //      cout << B[i].second.first << \" \" << B[i].second.second << endl;\n    }\n  set<int>s;\n\n  for(int i=0;i<B.size();i++){\n    //    cout << uf.find(i) << endl;\n    s.insert(uf.find(i));\n  }\n  return s.size() == 1;\n}\n\nint main(){\n  while(1){\n    B.clear();\n    cin >> n >> m >> k;\n    if(n == 0 && m == 0 && k == 0) break;\n    int acnt = 0, bcnt = 0;\n    for(int i=0;i<m;i++){\n      int u, v, w;string l;\n      cin >> u >> v >> w >> l; \n      B.push_back(make_pair(make_pair(w, l[0]), make_pair(u-1, v-1)));\n      if(l[0] == 'A') acnt++;\n      else bcnt++;\n    }\n    //    cout << acnt << \" \" << bcnt << \" \" << is_connected() << endl;\n    if(acnt < k || bcnt < n-1-k || !is_connected()){\n      cout << -1 << endl;\n      continue;\n    }\n    int res = 1000000000;\n    int mina = -10000000, maxa = 100000000;\n    int mid = (mina+maxa)/2;\n    for(int i=0;i<100;i++){\n      pi ret = solve(mid);\n      //      cout << maxa << \" \" << mina<< \"  \"<< ret.first << \" \" << ret.second<< endl;\n      if(ret.second < k){\n\tmaxa = mid-1;\n      }else if(ret.second > k){\n\tmina = mid+1;\n      }else{\n\tres = min(res, ret.first);\n\tmina = mid;\n      }\n      mid = (maxa+mina)/2;\n    }\n    if(res == 1000000000)\n      cout << -1 << endl;\n    else\n      cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint par[200];\nint rank1[200];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v, cost,col; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nedge cop[600];\nint V, E;\nint k;\nP kruskal() {\n\tsort(cop, cop + E, comp);\n\tinit(V);\n\tint res = 0; int cost = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tedge e = cop[i];\n\t\tif (e.col == 0 && res == k)continue;\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tcost += e.cost;\n\t\t\tif (e.col == 0) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn { res,cost };\n}\nedge ori[600];\nvoid init2() {\n\trep(i, E) {\n\t\tcop[i] = ori[i];\n\t}\n\treturn;\n}\nbool ooo(int x) {\n\tinit2();\n\trep(i, E) {\n\t\tif (cop[i].col == 0) {\n\t\t\tcop[i].cost += x;\n\t\t}\n\t}\n\tP r = kruskal();\n\tif (r.first < k) {\n\t\treturn false;\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> V >> E >> k, V) {\n\t\tint le = -100000; int ri = 100000;\n\t\trep(i, E) {\n\t\t\tint x, y, z;char w;\n\t\t\tcin >> x >> y >> z >> w; x--; y--;\n\t\t\tori[i] = { x,y,z,w - 'A' };\n\t\t}\n\t\twhile (ri - le > 1) {\n\t\t\tint mid = (ri + le) / 2;\n\t\t\tif (ooo(mid)) {\n\t\t\t\tle = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tri = mid;\n\t\t\t}\n\t\t}\n\t\tinit2();\n\t\trep(i, E) {\n\t\t\tif (cop[i].col == 0) {\n\t\t\t\tcop[i].cost += le;\n\t\t\t}\n\t\t}\n\t\tP fin = kruskal();\n\t\tif (fin.first != k) {\n\t\t\tcout << -1 << endl; continue;\n\t\t}\n\t\tbool f = true;\n\t\trep(i, V) {\n\t\t\trep(j, V) {\n\t\t\t\tif (!same(i, j)) {\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!f) {\n\t\t\tcout << -1 << endl; continue;\n\t\t}\n\t\tcout << fin.second - k * le << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cstdio>\n#include <tuple>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\n#define whole(f, x, ...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void setmin(T & a, T const & b) { a = min(a, b); }\n\nstruct disjoint_sets {\n    vector<int> data;\n    disjoint_sets() = default;\n    explicit disjoint_sets(size_t n) : data(n, -1) {}\n    bool is_root(int i) { return data[i] < 0; }\n    int find_root(int i) { return is_root(i) ? i : (data[i] = find_root(data[i])); }\n    int set_size(int i) { return - data[find_root(i)]; }\n    int union_sets(int i, int j) {\n        i = find_root(i); j = find_root(j);\n        if (i != j) {\n            if (set_size(i) < set_size(j)) swap(i,j);\n            data[i] += data[j];\n            data[j] = i;\n        }\n        return i;\n    }\n    bool is_same(int i, int j) { return find_root(i) == find_root(j); }\n};\n\ntemplate <typename UnaryPredicate>\nll binsearch(ll l, ll r, UnaryPredicate p) { // [l, r), p is monotone\n    assert (l < r);\n    -- l;\n    while (r - l > 1) {\n        ll m = (l + r) / 2;\n        (p(m) ? r : l) = m;\n    }\n    return r; // = min { x in [l, r) | p(x) }, or r\n}\n\ntemplate <typename T> struct weighted_edge { int u, v; T cost; bool is_a; };\ntemplate <typename T> bool operator < (weighted_edge<T> const & a, weighted_edge<T> const & b) { return make_pair(a.cost, a.is_a) < make_pair(b.cost, b.is_a); } // weak ordering\ntuple<int, int, int> minimum_spanning_tree(int n, vector<vector<pair<int, int> > > const & g, vector<vector<pair<int, int> > > const & h, int a) {\n    vector<weighted_edge<int> > edges;\n    repeat (p, 2) {\n        repeat (i, n) {\n            for (auto edge : (p ? g : h)[i]) {\n                int j, cost; tie(j, cost) = edge;\n                if (i < j) edges.push_back((weighted_edge<int>) { i, j, cost + (p ? a : 0), bool(p) });\n            }\n        }\n    }\n    whole(sort, edges);\n    int a_count = 0;\n    int b_count = 0;\n    int total_cost = 0;\n    disjoint_sets sets(n);\n    for (auto e : edges) { // Kruskal's method, O(E \\log E)\n        if (not sets.is_same(e.u, e.v)) {\n            sets.union_sets(e.u, e.v);\n            (e.is_a ? a_count : b_count) += 1;\n            total_cost += e.cost;\n        }\n    }\n    return make_tuple(a_count, b_count, total_cost);\n}\nint count_a_edges(int n, vector<vector<pair<int, int> > > const & g, vector<vector<pair<int, int> > > const & h, int a) {\n    int a_count, b_count;\n    tie(a_count, b_count, ignore) = minimum_spanning_tree(n, g, h, a);\n    if (a_count + b_count != n - 1) return -1;\n    return a_count;\n}\n\nconstexpr int W_MAX = 100;\nint main() {\n    while (true) {\n        int n, m, k; scanf(\"%d%d%d\", &n, &m, &k);\n        if (n == 0 and m == 0 and k == 0) break;\n        vector<vector<pair<int, int> > > g(n); // of A\n        vector<vector<pair<int, int> > > h(n); // of B\n        repeat (i, m) {\n            int u, v, w; char l; scanf(\"%d%d%d %c\", &u, &v, &w, &l); -- u; -- v;\n            assert (l == 'A' or l == 'B');\n            (l == 'A' ? g : h)[u].emplace_back(v, w);\n            (l == 'A' ? g : h)[v].emplace_back(u, w);\n        }\n        constexpr int inf = 10 * W_MAX;\n        int pinf_a = count_a_edges(n, g, h, + inf);\n        int ninf_a = count_a_edges(n, g, h, - inf);\n        int result;\n        if (pinf_a == -1 or ninf_a == -1 or (pinf_a - k) * (ninf_a - k) > 0) {\n            result = -1;\n        } else {\n            int a = binsearch(- 2 * W_MAX, 3 * W_MAX, [&](int a) {\n                int a_count = count_a_edges(n, g, h, a);\n                return a_count <= k;\n            });\n            int a_count, total_cost;\n            tie(a_count, ignore, total_cost) = minimum_spanning_tree(n, g, h, a);\n            assert (a_count <= k);\n            result = total_cost - a * k;\n        }\n        printf(\"%d\\n\", result);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\nusing Pib = pair<int, bool>;\nusing Pibi = pair<pair<int, bool>, int>;\nconst int M = 1000000007;\n\nint main() {\n    while (1) {\n        int n, m, k;\n        cin >> n >> m >> k;\n        if (!n) return 0;\n        vector<vector<Pibi>> edge(n);\n        for (int j = 0; j < m; ++j) {\n            int u, v, w;\n            char c;\n            cin >> u >> v >> w >> c;\n            --u;\n            --v;\n            edge[u].push_back(Pibi(Pib(w, c == 'A'), v));\n            edge[v].push_back(Pibi(Pib(w, c == 'A'), u));\n        }\n        int l = -200, r = 200;\n        int ans = -1;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            priority_queue<Pibi, vector<Pibi>, greater<Pibi>> q;\n            vector<bool> vis(n);\n            q.push(Pibi(Pib(0, false), 0));\n            int sum = 0;\n            int ca = 0;\n            int c = 0;\n            while (!q.empty()) {\n                auto p = q.top();\n                q.pop();\n                if (vis[p.second]) continue;\n\n                vis[p.second] = true;\n                sum += p.first.first;\n                ++c;\n                ca += p.first.second;\n                for (auto a : edge[p.second]) {\n                    if (a.first.second)\n                        q.push(Pibi(Pib(a.first.first + mid, a.first.second), a.second));\n                    else\n                        q.push(a);\n                }\n            }\n            if (c != n) {\n                ans = -1;\n                break;\n            }\n            if (ca <= k)\n                ans = sum - mid * k;\n            if (ca == k) {\n                break;\n            }\n            else if (ca < k) {\n                r = mid - 1;\n            }\n            else {\n                l = mid + 1;\n            }\n        }\n        if (r < -190 || 190 < l)\n            ans = -1;\n\n        cout << ans << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int from, to, cost, id;\n    char type;\n};\nbool operator <(const Edge& e1, const Edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par;\npublic:\n    UnionFind(int n) : sz(n) {\n        par = vector<int>(n);\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int root(int a) {\n        if (par[a] == a) return a;\n        return par[a] = root(par[a]);\n    }\n    void unite(int a, int b) {\n        par[root(a)] = par[root(b)];\n    }\n    bool isUnited(int a, int b) {\n        return root(a) == root(b);\n    }\n};\n\nconst int inf = 1e9;\n\nvoid add_edge(vector< vector<Edge> >& G, Edge& e) {\n    G[e.from].push_back({e.from, e.to, e.cost, e.id, e.type});\n    G[e.to].push_back({e.to, e.from, e.cost, e.id, e.type});\n}\nvoid remove_edge(vector< vector<Edge> >& G, Edge& e) {\n    int f = 0;\n    for (int i = 0; i < G[e.from].size(); ++i) {\n        if ( G[e.from][i].id == e.id ) {\n            G[e.from].erase(G[e.from].begin()+i, G[e.from].begin()+i+1);\n            ++f;\n            break;\n        }\n    }\n    for (int i = 0; i < G[e.to].size(); ++i) {\n        if ( G[e.to][i].id == e.id ) {\n            G[e.to].erase(G[e.to].begin()+i, G[e.to].begin()+i+1);\n            ++f;\n            break;\n        }\n    }\n    assert(f == 2);\n}\nEdge dfs(vector< vector<Edge> >& G, int v, int t, char type, int prev, vector<bool>& used) {\n    Edge res = {0, 0, -1, -1, 'X'};\n    if (used[v]) assert(false);\n    used[v] = true;\n    if (v == t) {\n        res.cost++;\n        return res;\n    }\n    for (int i = 0; i < G[v].size(); ++i) {\n        Edge& e = G[v][i];\n        assert(e.from == v);\n        if (e.to != prev) {\n            Edge r = dfs(G, e.to, t, type, v, used);\n            if (r.cost >= 0) {\n                res = max(res, r);\n                if (e.type == type) {\n                    res = max(res, e);\n                }\n            }\n        }\n    }\n    return res;\n}\nEdge calc(vector< vector<Edge> >& G, Edge& e) {\n    vector<bool> used(G.size(), false);\n    Edge ee = dfs(G, e.from, e.to, (e.type == 'A' ? 'B' : 'A'), -1, used);\n    return ee;\n}\nint main() {\n    int n, m, k;\n    while (cin >> n >> m >> k, n || m || k) {\n        vector<Edge> ae, be, edges;\n        for (int i = 0; i < m; ++i) {\n            int u, v, w; char l; cin >> u >> v >> w >> l; --u, --v;\n            if (l == 'A') {\n                ae.push_back({u, v, w, i, l});\n            }\n            else {\n                be.push_back({u, v, w, i, l});\n            }\n            edges.push_back({u, v, w, i, l});\n        }\n        sort(ae.begin(), ae.end());\n        sort(be.begin(), be.end());\n        sort(edges.begin(), edges.end());\n        vector< vector<Edge> > G(n);\n        UnionFind uf(n);\n        int ans = 0;\n        int cnt = 0, acnt = 0, bcnt = 0;\n        set<int> s;\n        for (int i = 0; i < edges.size(); ++i) {\n            if (cnt >= n-1) break;\n            Edge& e = edges[i];\n            if (uf.isUnited(e.from, e.to)) continue;\n            uf.unite(e.from, e.to);\n            ans += e.cost;\n            add_edge(G, e);\n            ++cnt;\n            s.insert(e.id);\n            if (e.type == 'A') ++acnt;\n            else ++bcnt;\n        }\n        if (cnt < n-1) {\n            cout << -1 << endl;\n            continue;\n        }\n        if (acnt > k) {\n            swap(acnt, bcnt);\n            swap(ae, be);\n            k = n - k - 1;\n        }\n        // remove use edges\n        // int s0 = 0;\n        // for (int i = ea.size()-1; i >= 0; --i) {\n        //     if (s.count(ea.id) > 0) {\n        //         s0 = i+1;\n        //         break;\n        //     }\n        // }\n        vector<bool> used(ae.size(), false);\n        for (int i = 0; i < ae.size(); ++i) {\n            if (s.count(ae[i].id) > 0) {\n                used[i] = true;\n            }\n        }\n        assert(k-acnt >= 0);\n        for (int t = 0; t < k-acnt; ++t) {\n            Edge a = {0, 0, inf-1, -1, 'X'};\n            int b = -1;\n            for (int i = 0; i < ae.size(); ++i) {\n                if (used[i]) continue;\n                // cout << calc(G, ae[i]) << endl;\n                Edge e = calc(G, ae[i]);\n                if (e.cost < inf-1 && (b < 0 || ae[i].cost - e.cost <= ae[b].cost - a.cost)) {\n                    a = e;\n                    b = i;\n                }\n            }\n            if (b < 0) {\n                ans = -1;\n                break;\n            }\n            // if (a.cost >= inf) assert(false);\n            // cout << a.cost << \" \" << b << endl;\n            used[b] = true;\n            remove_edge(G, a);\n            add_edge(G, ae[b]);\n            ans += ae[b].cost;\n            ans -= a.cost;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define whole(xs) xs.begin(),xs.end()\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < int(vs.size()); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    struct Edge {\n        int from, to;\n        int cost;\n        char firm;\n        Edge() {}\n        Edge(int from, int to, int cost, char firm) : from(from), to(to), cost(cost), firm(firm) {}\n    };\n    bool operator<(const Edge& a, const Edge& b) {\n        if (a.cost == b.cost) return a.firm < b.firm;\n        return a.cost < b.cost;\n    }\n    ostream& operator<<(ostream& os, const Edge& e) {\n        return os << \"Edge(\" << e.from << \"->\" << e.to << \" \" << e.cost << \" \" << e.firm << \")\";\n    }\n\n    int N, M, K;\n    vector<Edge> es;\n    bool input() {\n        cin >> N >> M >> K;\n        if (N == 0 && M == 0 && K == 0) return false;\n        es.clear();\n        for (int i = 0; i < M; i++) {\n            int u, v, w; char l;\n            cin >> u >> v >> w >> l;\n            u--; v--;\n            es.emplace_back(u, v, w, l);\n        }\n        return true;\n    }\n\n    struct UnionFind {\n        int N;\n        vector<int> P;\n        UnionFind(int N) : N(N) {\n            P.clear(); P.resize(N, -1);\n        }\n        int root(int x) {\n            if (P[x] == -1) return x;\n            return P[x] = root(P[x]);\n        }\n        int query(int x, int y) {\n            return root(x) == root(y);\n        }\n        void merge(int x, int y) {\n            x = root(x); y = root(y);\n            if (x == y) return;\n            P[x] = y;\n        }\n    };\n\n    const int INF = 1<<20;\n\n    int countA(int k) {\n        vector<Edge> fs = es;\n        for (int i = 0; i < M; i++) {\n            Edge& f = fs[i];\n            if (f.firm == 'A') f.cost += k;\n        }\n        sort(whole(fs));\n        UnionFind uf(N);\n        int count = 0;\n        for (int i = 0; i < M; i++) {\n            const Edge& f = fs[i];\n            if (uf.query(f.from, f.to)) continue;\n            uf.merge(f.from, f.to);\n            if (f.firm == 'A') count++;\n        }\n        return count;\n    }\n\n    int cost(int k) {\n        vector<Edge> fs = es;\n        for (int i = 0; i < M; i++) {\n            Edge& f = fs[i];\n            if (f.firm == 'A') f.cost += k;\n        }\n        int count = 0;\n        sort(whole(fs));\n        UnionFind uf(N);\n        int ret = 0;\n        for (int i = 0; i < M; i++) {\n            const Edge& f = fs[i];\n            if (uf.query(f.from, f.to)) continue;\n            if (f.firm == 'A') {\n                if (count == K) continue;\n                count++;\n            }\n            uf.merge(f.from, f.to);\n            ret += f.cost - (f.firm == 'A' ? k : 0);\n        }\n        return ret;\n    }\n\n\n    void solve() {\n        int lb = -INF, ub = INF;\n        int p = countA(lb), q = countA(ub);\n        if ( (p - K) * (q - K) > 0 ) {\n            cout << -1 << endl;\n            return;\n        }\n        while (lb + 1 < ub) {\n            int mid = (lb + ub) / 2;\n            //cerr << mid << \" -> \" << countA(mid) << endl;\n            if (countA(mid) >= K) {\n                lb = mid;\n            } else {\n                ub = mid;\n            }\n        }\n        cout << cost(lb) << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nstruct UnionFind{\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n  void init(){ for(int i = 0;i < (int)v.size();i++)v[i]=-1; }\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\n\nint N,M,K;\n\nstruct edge{\n  int u,v,cost;\n  int typ;\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(1){\n    cin>>N>>M>>K;\n    if(N==0)break;\n    vector<edge> es[2];\n    rep(i,M){\n      int a,b,c;\n      char t;\n      cin>>a>>b>>c>>t;\n      a--;b--;\n      if(t=='A'){\n        es[0].push_back((edge){a,b,c,-1});\n      }else{\n        es[1].push_back((edge){a,b,c,-1});\n      }\n    }\n    int lb=-10000,ub=10000,res=0,cnta=0;\n    UnionFind uf(N);\n    while(ub-lb>1){\n      int X=(lb+ub)/2;\n      vector<edge> crtes;\n      rep(i,es[0].size())crtes.push_back((edge){es[0][i].u,es[0][i].v,es[0][i].cost+X,1});\n      rep(i,es[1].size())crtes.push_back((edge){es[1][i].u,es[1][i].v,es[1][i].cost,0});\n      sort(all(crtes),[](const edge& a,const edge& b){\n        if(a.cost==b.cost)return a.typ > b.typ;\n        else return a.cost < b.cost;\n      });\n      uf.init();\n      cnta=0;\n      res=0;\n      rep(i,crtes.size()){\n        if(uf.same(crtes[i].u,crtes[i].v))continue;\n        uf.unite(crtes[i].u,crtes[i].v);\n        cnta+=crtes[i].typ;\n        res+=crtes[i].cost;\n      }\n      res-=cnta*X;\n      if(cnta<K)ub=X;\n      else lb=X;\n    }\n    {\n      vector<edge> crtes;\n      rep(i,es[0].size())crtes.push_back((edge){es[0][i].u,es[0][i].v,es[0][i].cost+lb,1});\n      rep(i,es[1].size())crtes.push_back((edge){es[1][i].u,es[1][i].v,es[1][i].cost,0});\n      sort(all(crtes),[](const edge& a,const edge& b){\n        if(a.cost==b.cost)return a.typ > b.typ;\n        else return a.cost < b.cost;\n      });\n      uf.init();\n      cnta=0;\n      res=0;\n      rep(i,crtes.size()){\n        if(uf.same(crtes[i].u,crtes[i].v))continue;\n        uf.unite(crtes[i].u,crtes[i].v);\n        cnta+=crtes[i].typ;\n        res+=crtes[i].cost;\n      }\n    }\n    res-=K*lb;\n\n    if((lb>1000&&cnta!=0)||(lb<-1000&&cnta!=N-1)||uf.size(0)<N)cout<<-1<<endl;\n    else cout<<res<<endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct Kruskal{\n\n  struct UnionFind{\n    Int n;\n    vector<Int> r,p;\n    UnionFind(){}\n    UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n    Int find(Int x){\n      return (x==p[x]?x:p[x]=find(p[x]));\n    }\n    bool same(Int x,Int y){\n      return find(x)==find(y);\n    }\n    void unite(Int x,Int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      if(r[x]<r[y]) swap(x,y);\n      r[x]+=r[y];\n      p[y]=x;\n    }\n  };\n  \n  struct edge{\n    Int from,to;\n    double cost;\n    Int used;\n    char color;\n    edge(){}\n    edge(Int from,Int to,double cost,char color):\n      from(from),to(to),cost(cost),used(0),color(color){}\n    bool operator<(const edge& e) const{\n      return cost<e.cost;\n    }\n  };\n\n  Int n;\n  vector<edge> edges;\n\n  Kruskal(){}\n  Kruskal(Int sz):n(sz){}\n  \n  Int build(Int k=-1){\n    sort(edges.begin(),edges.end());\n    UnionFind uf(n+1);\n    double res=0;\n    Int cnt=0;\n    for(Int i=0;i<(Int)edges.size();i++){\n      edge &e=edges[i];\n      if(!uf.same(e.from,e.to)){\n\te.used=1;\n\tres+=e.cost;\n\tuf.unite(e.from,e.to);\n\tcnt++;\n      }\n    }\n    if(cnt+1!=n) return -1;\n    return res;\n  }\n};\n\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    Kruskal kr(n);\n    auto edges=kr.edges;\n    for(Int i=0;i<m;i++){\n      Int u,v,w;\n      char c;\n      cin>>u>>v>>w>>c;\n      u--;v--;\n      edges.emplace_back(u,v,w,c);\n    }\n    double ub=1e12,ans;\n    auto check=[&](double x){\n      x-=ub;\n      kr=Kruskal(n);\n      for(auto e:edges){\n\tif(x>0&&e.color=='A') e.cost+=x; \n\tif(x<0&&e.color=='B') e.cost-=x; \n\tkr.edges.emplace_back(e);\n      }\n      \n      ans=kr.build();\n      if(ans<0) return Int(-1);\n      if(x>0) ans-=x*k;\n      if(x<0) ans+=x*(n-1-k);\n      \n      Int res=0;\n      for(auto e:kr.edges)\n\tres+=(e.used&&e.color=='A');\n      return res;\n    };\n    double l=0,r=2*ub;\n    if(check(l)<k||check(r)>k){\n      cout<<-1<<endl;\n      continue;\n    }\n    for(Int i=0;i<1000;i++){\n      double m=(l+r)/2;\n      if(check(m)>=k) l=m;\n      else r=m;\n    }\n    check(l);\n    cout<<(Int)round(ans)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int u, v, w, id;\n  edge(){}\n  edge(int u, int v, int w, int id):u(u), v(v), w(w), id(id){}\n  bool operator < (const edge& e) {\n    return w != e.w ? w < e.w : id < e.id;\n  }\n};\n\nstruct UnionFind {\n  vint data;\n  UnionFind(int n):data(n, -1){}\n  int find(int x) {\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n  int size(int x) {\n    return -data[find(x)];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m, k;\n  while(cin >> n >> m >> k, n || m || k) {\n    vint u(m), v(m), w(m);\n    vector<char> id(m);\n    rep(i, m) {\n      cin >> u[i] >> v[i] >> w[i] >> id[i];\n      --u[i], --v[i];\n    }\n    auto check = [&](int mb) -> pair<int, int> {\n      vector<edge> vec;\n      rep(i, m) {\n\tif(id[i] == 'A') vec.emplace_back(u[i], v[i], w[i]+mb, 1);\n\telse vec.emplace_back(u[i], v[i], w[i], 0);\n      }\n      sort(all(vec));\n      UnionFind uf(n);\n      int cnt = 0;\n      int sum = 0;\n      for(edge e : vec) {\n\tif(!uf.same(e.u, e.v)) {\n\t  uf.unite(e.u, e.v);\n\t  cnt += e.id;\n\t  sum += e.w;// - e.id*mb;\n\t}\n      }\n      if(uf.size(0) < n) return make_pair(inf, -inf);\n      return make_pair(sum, cnt);\n    };\n    Pi p = check(-1000), q = check(1000);\n    if(p.second < k || q.second > k) {\n      cout << -1 << endl;\n      continue;\n    }\n    int lb = -1000, ub = 1000;\n    while(lb+1 < ub) {\n      int mb = (lb+ub)/2;\n      if(check(mb).second <= k) ub = mb;\n      else lb = mb;\n    }\n    auto ans = check(ub);\n    //cout<<ub<<endl;\n    //cout<<ans.first<<\" \"<<ans.second << endl;\n    //if(ans.second == k) cout << ans.first << endl;\n    //else cout << -1 << endl;\n    cout << ans.first-k*ub << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconstexpr int MAX = 252;\n\nclass Union_Find {\n  public:\n    int par[MAX], rank[MAX];\n    \n    Union_Find(int N) {\n        for (int i = 0; i < N; i++) {\n            par[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    int find(int x)\n    {\n        if (par[x] == x) {\n            return x;\n        }\n        return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y)\n    {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        \n        if (rank[x] < rank[y]) {\n            par[x] = y;\n        } else {\n            par[y] = x;\n            if (rank[x] == rank[y]) {\n                rank[x]++;\n            }\n        }\n    }\n\n    bool same(int x, int y)\n    {\n        return (find(x) == find(y));\n    }\n};\n\nstruct edge {\n    int u, v, cost, col;\n    edge() {}\n    edge(int u, int v, int cost, int col) :\n        u{u}, v{v}, cost{cost}, col{col} {}\n\n    bool operator < (const edge& e) const {        \n        return cost < e.cost;\n    }\n};\n\nint N, M, K;\n\nvoid add_cost(int x, vector<edge>& es)\n{\n    for (auto& e : es) {\n        if (e.col == 0) {\n            e.cost += x;\n        }\n    }\n}\n\npair<int, int> kruskal(int x, vector<edge> es)\n{\n    add_cost(x, es);\n    sort(es.begin(), es.end());\n    \n    Union_Find uf(N);\n    int res = 0, k = 0, en = 0;\n    for (const auto& e : es) {\n        if (k < K && e.col == 0 && !uf.same(e.u, e.v)) {\n            uf.unite(e.u, e.v);     \n            res += e.cost - x;\n            k++;\n            en++;\n        } else if (e.col == 1 && !uf.same(e.u, e.v)) {\n            uf.unite(e.u, e.v);     \n            res += e.cost;\n            en++;\n        }\n    }\n    if (en != N - 1) return make_pair(-1, -1);\n    return make_pair(res, k);\n}\n\nvoid solve(const vector<edge>& es)\n{\n    int l = 0, r = 252521;\n    while (r - l > 1) {\n        int mid = (l + r) / 2;            \n        auto mst = kruskal(mid, es);\n        if (mst.second < K) {\n            r = mid;\n        } else {\n            l = mid;\n        }\n    }\n\n    auto l1 = kruskal(l, es);\n    auto r1 = kruskal(r, es);\n    if (l1.second == K) {\n        cout << l1.first << endl;\n        return;\n    } else if (r1.second == K) {\n        cout << r1.first << endl;\n        return;\n    }\n    \n    l = -252521, r = 0;\n    while (r - l > 1) {\n        int mid = (l + r) / 2;\n        auto mst = kruskal(mid, es);\n        if (mst.second < K) {\n            r = mid;\n        } else {\n            l = mid;\n        }\n    }\n\n    auto l2 = kruskal(l, es);\n    auto r2 = kruskal(r, es);\n    if (l2.second == K) {\n        cout << l2.first << endl;\n    } else if (r2.second == K) {\n        cout << r2.first << endl;\n    } else {    \n        cout << -1 << endl;\n    }\n}\n\nint main()\n{\n    while (cin >> N >> M >> K, N) {\n        vector<edge> es;\n        for (int i = 0; i < M; i++) {\n            int u, v, w;\n            char l;\n            cin >> u >> v >> w >> l;\n            u--; v--;\n            es.emplace_back(u, v, w, l - 'A');\n        }\n\n        solve(es);       \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint par[200];\nint rank1[200];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v, cost,col; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost < e2.cost;\n}\nedge cop[600];\nint V, E;\nint k;\nP kruskal() {\n\tsort(cop, cop + E, comp);\n\tinit(V);\n\tint res = 0; int cost = 0; int unres = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tedge e = cop[i];\n\t\tif (e.col == 0 && res == k)continue;\n\t\tif (e.col == 1 && unres == V - k - 1)continue;\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tcost += e.cost;\n\t\t\tif (e.col == 0) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn { res,cost };\n}\nedge ori[600];\nvoid init2() {\n\trep(i, E) {\n\t\tcop[i] = ori[i];\n\t}\n\treturn;\n}\nbool ooo(int x) {\n\tinit2();\n\trep(i, E) {\n\t\tif (cop[i].col == 0) {\n\t\t\tcop[i].cost += x;\n\t\t}\n\t}\n\tP r = kruskal();\n\tif (r.first < k) {\n\t\treturn false;\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> V >> E >> k, V) {\n\t\tint le = -1000000; int ri = 1000000;\n\t\trep(i, E) {\n\t\t\tint x, y, z;char w;\n\t\t\tcin >> x >> y >> z >> w; x--; y--;\n\t\t\tori[i] = { x,y,z,w - 'A' };\n\t\t}\n\t\twhile (ri - le > 1) {\n\t\t\tint mid = (ri + le) / 2;\n\t\t\tif (ooo(mid)) {\n\t\t\t\tle = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tri = mid;\n\t\t\t}\n\t\t}\n\t\tinit2();\n\t\trep(i, E) {\n\t\t\tif (cop[i].col == 0) {\n\t\t\t\tcop[i].cost += le;\n\t\t\t}\n\t\t}\n\t\tP fin1 = kruskal();\n\t\tif (fin1.first != k) {\n\t\t\tcout << -1 << endl; continue;\n\t\t}\n\t\tbool f = true;\n\t\trep(i, V) {\n\t\t\trep(j, V) {\n\t\t\t\tif (!same(i, j)) {\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!f) {\n\t\t\tcout << -1 << endl; continue;\n\t\t}\n\t\tcout << fin1.second - k * le << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nstruct UnionFind\n{\n\tvector<int> par;\n\tUnionFind(int n) :par(n, -1) {}\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (par[y] < par[x]) swap(x, y);\n\t\tif (par[x] == par[y]) par[x]--;\n\t\tpar[y] = x;\n\t\tif (find(x) != find(y)) par[find(y)] = x;\n\t}\n\tint count()\n\t{\n\t\tint cnt = 0;\n\t\tREP(i, par.size()) if (par[i] < 0) cnt++;\n\t\treturn cnt;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\ntypedef ld Weight;\nstruct Edge\n{\n\tint from, to; Weight cost; char c;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\n\nconst ld INF = 1e9;\nconst ld EPS = 1e-9;\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m, k;\n\twhile (cin >> n >> m >> k, n)\n\t{\n\t\tEdges es;\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; ld c; char d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--; b--;\n\t\t\tes.emplace_back(Edge{ a, b, c, d });\n\t\t}\n\t\tint mn = INF, mx = -1;\n\t\tld lb = -INF, ub = INF;\n\t\tREP(lp, 300)\n\t\t{\n\t\t\tld mid = (ub + lb) / 2;\n\t\t\tEdges tmp;\n\t\t\tfor (auto e : es)\n\t\t\t{\n\t\t\t\tif (e.c == 'A') e.cost += mid;\n\t\t\t\ttmp.push_back(e);\n\t\t\t}\n\t\t\tsort(ALL(tmp));\n\t\t\tUnionFind uf(n);\n\t\t\tld cost = 0;\n\t\t\tint cnta = 0;\n\t\t\tfor (auto e : tmp)\n\t\t\t{\n\t\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\t\tif (e.c == 'A')\n\t\t\t\t{\n\t\t\t\t\tcnta++;\n\t\t\t\t}\n\t\t\t\tcost += e.cost;\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t}\n\n\t\t\tchmax(mx, cnta);\n\t\t\tchmin(mn, cnta);\n\t\t\tif (lp == 299)\n\t\t\t{\n\t\t\t\tif (uf.count() != 1 || (mx < k || mn > k))\n\t\t\t\t{\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcout << ll(cost - k * mid + EPS) << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (cnta > k)\n\t\t\t{\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tub = mid;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int from, to, cost, id;\n    char type;\n};\nbool operator <(const Edge& e1, const Edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par;\npublic:\n    UnionFind(int n) : sz(n) {\n        par = vector<int>(n);\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int root(int a) {\n        if (par[a] == a) return a;\n        return par[a] = root(par[a]);\n    }\n    void unite(int a, int b) {\n        par[root(a)] = par[root(b)];\n    }\n    bool isUnited(int a, int b) {\n        return root(a) == root(b);\n    }\n};\n\nconst int inf = 1e9;\n\nvoid add_edge(vector< vector<Edge> >& G, Edge& e) {\n    G[e.from].push_back({e.from, e.to, e.cost, e.id, e.type});\n    G[e.to].push_back({e.to, e.from, e.cost, e.id, e.type});\n}\nvoid remove_edge(vector< vector<Edge> >& G, Edge& e) {\n    int f = 0;\n    for (int i = 0; i < G[e.from].size(); ++i) {\n        if ( G[e.from][i].id == e.id ) {\n            G[e.from].erase(G[e.from].begin()+i, G[e.from].begin()+i+1);\n            ++f;\n            break;\n        }\n    }\n    for (int i = 0; i < G[e.to].size(); ++i) {\n        if ( G[e.to][i].id == e.id ) {\n            G[e.to].erase(G[e.to].begin()+i, G[e.to].begin()+i+1);\n            ++f;\n            break;\n        }\n    }\n    assert(f == 2);\n}\nEdge dfs(vector< vector<Edge> >& G, int v, int t, char type, int prev, vector<bool>& used) {\n    Edge res = {0, 0, inf, -1, 'X'};\n    if (used[v]) return res;\n    used[v] = true;\n    if (v == t) {\n        res.cost--;\n        return res;\n    }\n    for (int i = 0; i < G[v].size(); ++i) {\n        Edge& e = G[v][i];\n        if (e.to != prev) {\n            Edge r = dfs(G, e.to, t, type, v, used);\n            if (r.cost != inf) {\n                res = min(res, r);\n                if (e.type == type) {\n                    res = min(res, e);\n                }\n            }\n        }\n    }\n    return res;\n}\nEdge calc(vector< vector<Edge> >& G, Edge& e) {\n    vector<bool> used(G.size(), false);\n    Edge ee = dfs(G, e.from, e.to, (e.type == 'A' ? 'B' : 'A'), -1, used);\n    return ee;\n}\nint main() {\n    int n, m, k;\n    while (cin >> n >> m >> k, n || m || k) {\n        vector<Edge> ae, be, edges;\n        for (int i = 0; i < m; ++i) {\n            int u, v, w; char l; cin >> u >> v >> w >> l; --u, --v;\n            if (l == 'A') {\n                ae.push_back({u, v, w, i, l});\n            }\n            else {\n                be.push_back({u, v, w, i, l});\n            }\n            edges.push_back({u, v, w, i, l});\n        }\n        sort(ae.begin(), ae.end());\n        sort(be.begin(), be.end());\n        sort(edges.begin(), edges.end());\n        vector< vector<Edge> > G(n);\n        UnionFind uf(n);\n        int ans = 0;\n        int cnt = 0, acnt = 0, bcnt = 0;\n        set<int> s;\n        for (int i = 0; i < edges.size(); ++i) {\n            if (cnt >= n-1) break;\n            Edge& e = edges[i];\n            if (uf.isUnited(e.from, e.to)) continue;\n            uf.unite(e.from, e.to);\n            ans += e.cost;\n            add_edge(G, e);\n            ++cnt;\n            s.insert(e.id);\n            if (e.type == 'A') ++acnt;\n            else ++bcnt;\n        }\n        if (cnt < n-1) {\n            cout << -1 << endl;\n            continue;\n        }\n        if (acnt > k) {\n            swap(acnt, bcnt);\n            swap(ae, be);\n            k = n - k - 1;\n        }\n        // remove use edges\n        // int s0 = 0;\n        // for (int i = ea.size()-1; i >= 0; --i) {\n        //     if (s.count(ea.id) > 0) {\n        //         s0 = i+1;\n        //         break;\n        //     }\n        // }\n        vector<bool> used(ae.size(), false);\n        for (int i = 0; i < ae.size(); ++i) {\n            if (s.count(ae[i].id) > 0) {\n                used[i] = true;\n            }\n        }\n        assert(k-acnt >= 0);\n        for (int t = 0; t < k-acnt; ++t) {\n            Edge a = {0, 0, inf-1, -1, 'X'};\n            int b = -1;\n            for (int i = 0; i < ae.size(); ++i) {\n                if (used[i]) continue;\n                // cout << calc(G, ae[i]) << endl;\n                Edge e = calc(G, ae[i]);\n                if (e.cost < inf-1 && (b < 0 || ae[i].cost - e.cost < ae[b].cost - a.cost)) {\n                    a = e;\n                    b = i;\n                }\n            }\n            if (b < 0) {\n                ans = -1;\n                break;\n            }\n            // if (a.cost >= inf) assert(false);\n            // cout << a.cost << \" \" << b << endl;\n            used[b] = true;\n            remove_edge(G, a);\n            add_edge(G, ae[b]);\n            ans += ae[b].cost;\n            ans -= a.cost;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing Weight=int;\nstruct Edge{\n    int src,dst;\n    Weight weight;\n    int com;\n    Edge(int src,int dst,Weight weight,int com):\n    src(src),dst(dst),weight(weight),com(com){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\ntemplate<typename T>\nstruct UnionFind{\n    vector<T>data;\n    UnionFind(T n):data(n,-1){}\n    bool unite(T x,T y){\n        x=root(x);y=root(y);\n        if(x!=y){\n            if(data[y]<data[x])swap(x,y);\n            data[x]+=data[y];data[y]=x;\n        }\n        return x!=y;\n    }\n    T root(T x){\n        return data[x]<0?x:data[x]=root(data[x]);\n    }\n    bool same(T x,T y){\n        return root(x)==root(y);\n    }\n    T size(T x){\n        return -data[root(x)];\n    }\n};\n\npair<Weight,int>kruskal(const Graph &g,const int h,const int c){\n    int n=g.size();\n    UnionFind<int> uf(n);\n    auto compare = [c](const Edge &a,const Edge &b) {return a.weight != b.weight ? a.weight>b.weight : a.com == c; };\n    priority_queue<Edge,Edges,decltype(compare)>q(compare);\n    for(int i=0;i<n;++i){\n        for(auto e:g[i]){\n            if(i<e.dst){\n                if(e.com==c)q.emplace(e.src,e.dst,e.weight+h,e.com);\n                else q.push(e);\n            }\n        }\n    }\n    int res=0,res1=0;\n    Weight total=0;\n    Edges forest;\n    while(forest.size()<n-1 && !q.empty()){\n        Edge e=q.top();q.pop();\n        if(uf.unite(e.src,e.dst)){\n            forest.push_back(e);\n            total+=e.weight;\n            if(e.com==c){\n                ++res;\n            }else{\n                ++res1;\n            }\n        }\n    }\n    if(res+res1 != n-1)total=-1;\n    return pair<Weight, int>(total,res);\n}\n\nint main(){\n    int v,e,k;\n    while (cin >> v >> e >> k, v)\n    {\n        Graph g(v);\n        for (int i = 0; i < e; ++i)\n        {\n            int s, t, w, l;\n            char c;\n            cin >> s >> t >> w >> c;\n            --s;\n            --t;\n            l = c;\n            g[s].emplace_back(s, t, w, l);\n            g[t].emplace_back(t, s, w, l);\n        }\n        int c;\n        if (kruskal(g, 0, 'A').second > k){\n            c = 'A';\n        }else{\n            c = 'B';\n        }\n        //cout<<c<<endl;\n        for (int h = 0; h < 1000; ++h)\n        {\n            pair<Weight, int> p = kruskal(g, h, c);\n            if(p.first == -1){\n                cout<<\"-1\"<<endl;\n                break;\n            }\n            if (p.second <= k && c == 'A')\n            {\n                cout << p.first-k*h << endl;\n                break;\n            }\n            else if (p.second <= v - k - 1 && c == 'B')\n            {\n                cout << p.first-(v-k-1)*h << endl;\n                break;\n            }\n            if (h == 999){\n                cout << \"-1\" << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  void unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] > data[y]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n};\n\nstruct edge\n{\n  int u, v, cost, used;\n  bool company;\n\n  bool operator<(const edge& e)\n  {\n    if(company != e.company) return (company < e.company);\n    return (cost < e.cost);\n  }\n};\n\nint main()\n{\n  int N, M, K;\n  edge e[600];\n\n  while(scanf(\"%d %d %d\", &N, &M, &K), N) {\n    int B = 0;\n    for(int i = 0; i < M; i++) {\n      int u, v, w;\n      char l;\n      scanf(\"%d %d %d %c\", &u, &v, &w, &l);\n      e[i] = (edge) {--u, --v, w, false, l == 'A'};\n      B += l == 'B';\n    }\n    sort(e, e + M);\n\n    UnionFind tree(N);\n    int cost = 0, ac = 0, bc = 0;\n    for(int i = 0; i < M; i++) {\n      if(tree.find(e[i].u) != tree.find(e[i].v)) {\n        tree.unite(e[i].u, e[i].v);\n        cost += e[i].cost;\n        e[i].used = true;\n        i < B ? ++bc : ++ac;\n      }\n    }\n\n    while(ac < K) {\n      tuple< int, int, int > flip(INT_MIN, -1, -1);\n      for(int i = 0; i < B; i++) {\n        if(!e[i].used) continue;\n        UnionFind tree2(N);\n        for(int j = 0; j < M; j++) {\n          if(i != j && e[j].used) tree2.unite(e[j].u, e[j].v);\n        }\n        for(int j = B; j < M; j++) {\n          if(tree2.find(e[j].u) != tree2.find(e[j].v)) {\n            flip = max(flip, make_tuple(e[i].cost - e[j].cost, i, j));\n          }\n        }\n      }\n      int costt, x, y;\n      tie(costt, x, y) = flip;\n      if(costt == INT_MIN) break;\n      swap(e[x].used, e[y].used);\n      cost -= costt;\n      ++ac, --bc;\n    }\n    if(ac + bc != N - 1 || ac != K) puts(\"-1\");\n    else printf(\"%d\\n\", cost);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int from, to, cost, id;\n    char type;\n};\nbool operator <(const Edge& e1, const Edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par;\npublic:\n    UnionFind(int n) : sz(n) {\n        par = vector<int>(n);\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int root(int a) {\n        if (par[a] == a) return a;\n        return par[a] = root(par[a]);\n    }\n    void unite(int a, int b) {\n        par[root(a)] = par[root(b)];\n    }\n    bool isUnited(int a, int b) {\n        return root(a) == root(b);\n    }\n};\n\nconst int inf = 1e9;\n\nvoid add_edge(vector< vector<Edge> >& G, Edge& e) {\n    G[e.from].push_back({e.from, e.to, e.cost, e.id, e.type});\n    G[e.to].push_back({e.to, e.from, e.cost, e.id, e.type});\n}\nvoid remove_edge(vector< vector<Edge> >& G, Edge& e) {\n    int f = 0;\n    for (int i = 0; i < G[e.from].size(); ++i) {\n        if ( G[e.from][i].id == e.id ) {\n            G[e.from].erase(G[e.from].begin()+i, G[e.from].begin()+i+1);\n            ++f;\n            break;\n        }\n    }\n    for (int i = 0; i < G[e.to].size(); ++i) {\n        if ( G[e.to][i].id == e.id ) {\n            G[e.to].erase(G[e.to].begin()+i, G[e.to].begin()+i+1);\n            ++f;\n            break;\n        }\n    }\n    assert(f == 2);\n}\nEdge dfs(vector< vector<Edge> >& G, int v, int t, char type, int prev, vector<bool>& used) {\n    Edge res = {0, 0, inf, -1, 'X'};\n    if (used[v]) assert(false);\n    used[v] = true;\n    if (v == t) {\n        res.cost--;\n        return res;\n    }\n    for (int i = 0; i < G[v].size(); ++i) {\n        Edge& e = G[v][i];\n        if (e.to != prev) {\n            Edge r = dfs(G, e.to, t, type, v, used);\n            if (r.cost != inf) {\n                res = min(res, r);\n                if (e.type == type) {\n                    res = min(res, e);\n                }\n            }\n        }\n    }\n    return res;\n}\nEdge calc(vector< vector<Edge> >& G, Edge& e) {\n    vector<bool> used(G.size(), false);\n    Edge ee = dfs(G, e.from, e.to, (e.type == 'A' ? 'B' : 'A'), -1, used);\n    return ee;\n}\nint main() {\n    int n, m, k;\n    while (cin >> n >> m >> k, n || m || k) {\n        vector<Edge> ae, be, edges;\n        for (int i = 0; i < m; ++i) {\n            int u, v, w; char l; cin >> u >> v >> w >> l; --u, --v;\n            if (l == 'A') {\n                ae.push_back({u, v, w, i, l});\n            }\n            else {\n                be.push_back({u, v, w, i, l});\n            }\n            edges.push_back({u, v, w, i, l});\n        }\n        sort(ae.begin(), ae.end());\n        sort(be.begin(), be.end());\n        sort(edges.begin(), edges.end());\n        vector< vector<Edge> > G(n);\n        UnionFind uf(n);\n        int ans = 0;\n        int cnt = 0, acnt = 0, bcnt = 0;\n        set<int> s;\n        for (int i = 0; i < edges.size(); ++i) {\n            if (cnt >= n-1) break;\n            Edge& e = edges[i];\n            if (uf.isUnited(e.from, e.to)) continue;\n            uf.unite(e.from, e.to);\n            ans += e.cost;\n            add_edge(G, e);\n            ++cnt;\n            s.insert(e.id);\n            if (e.type == 'A') ++acnt;\n            else ++bcnt;\n        }\n        if (cnt < n-1) {\n            cout << -1 << endl;\n            continue;\n        }\n        if (acnt > k) {\n            swap(acnt, bcnt);\n            swap(ae, be);\n            k = n - k - 1;\n        }\n        // remove use edges\n        // int s0 = 0;\n        // for (int i = ea.size()-1; i >= 0; --i) {\n        //     if (s.count(ea.id) > 0) {\n        //         s0 = i+1;\n        //         break;\n        //     }\n        // }\n        vector<bool> used(ae.size(), false);\n        for (int i = 0; i < ae.size(); ++i) {\n            if (s.count(ae[i].id) > 0) {\n                used[i] = true;\n            }\n        }\n        assert(k-acnt >= 0);\n        for (int t = 0; t < k-acnt; ++t) {\n            Edge a = {0, 0, inf-1, -1, 'X'};\n            int b = -1;\n            for (int i = 0; i < ae.size(); ++i) {\n                if (used[i]) continue;\n                // cout << calc(G, ae[i]) << endl;\n                Edge e = calc(G, ae[i]);\n                if (e.cost < inf-1 && (b < 0 || ae[i].cost - e.cost <= ae[b].cost - a.cost)) {\n                    a = e;\n                    b = i;\n                }\n            }\n            if (b < 0) {\n                ans = -1;\n                break;\n            }\n            // if (a.cost >= inf) assert(false);\n            // cout << a.cost << \" \" << b << endl;\n            used[b] = true;\n            remove_edge(G, a);\n            add_edge(G, ae[b]);\n            ans += ae[b].cost;\n            ans -= a.cost;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\n#define mp(x, y) make_pair(x, y)\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pipi;\n\nclass UnionFind{\nprivate:\n  vector<int> rank;\n  vector<int> par;\npublic:  \n  UnionFind(int n){\n    rank.resize(n);\n    par.resize(n);\n    for(int i=0;i<n;i++){\n      rank[i] = 0;\n      par[i] = i;\n    }\n  }\n  int find(int x){\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n\n  int same(int x, int y){\n    return find(x) == find(y);\n  }\n\n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }else{\n      par[y] = x;\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n  }\n};\n\nint n, m, k;\nvector<pipi>B;\n\npi kruscal(int a){\n  UnionFind uf(n);\n  int cnt = 0, cost = 0;\n  for(int i=0;i<B.size();i++){\n    if(!uf.same(B[i].second.first, B[i].second.second)){\n      if(B[i].first.second == 'A' && cnt >= k) continue;\n      cost += B[i].first.first;\n      if (B[i].first.second == 'A'){\n\tcnt++;\n\tcost -= a;\n      }\n      uf.unite(B[i].second.first, B[i].second.second);\n    }\n  }\n  return mp(cost, cnt);\n}\n\npi solve(int a){\n  for(int i=0;i<B.size();i++) if(B[i].first.second == 'A') B[i].first.first += a;\n  sort(B.begin(), B.end());\n  pi ret = kruscal(a);\n  for(int i=0;i<B.size();i++) if(B[i].first.second == 'A') B[i].first.first -= a;\n  return ret;\n}\n\nint is_connected(){\n  UnionFind uf(n);\n  //  cout << \"B \" << B.size() << endl;  \n  for(int i=0;i<B.size();i++)\n    if(!uf.same(B[i].second.first, B[i].second.second)){\n      uf.unite(B[i].second.first, B[i].second.second);\n      //      cout << B[i].second.first << \" \" << B[i].second.second << endl;\n    }\n  set<int>s;\n\n  for(int i=0;i<B.size();i++){\n    //    cout << uf.find(i) << endl;\n    s.insert(uf.find(i));\n  }\n  return s.size() == 1;\n}\n\nint main(){\n  while(1){\n    B.clear();\n    cin >> n >> m >> k;\n    if(n == 0 && m == 0 && k == 0) break;\n    int acnt = 0, bcnt = 0;\n    for(int i=0;i<m;i++){\n      int u, v, w;string l;\n      cin >> u >> v >> w >> l; \n      B.push_back(make_pair(make_pair(w, l[0]), make_pair(u-1, v-1)));\n      if(l[0] == 'A') acnt++;\n      else bcnt++;\n    }\n    //    cout << acnt << \" \" << bcnt << \" \" << is_connected() << endl;\n    if(acnt < k || bcnt < n-1-k || !is_connected()){\n      cout << -1 << endl;\n      continue;\n    }\n    int res = 1000000000;\n    int mina = -1000000, maxa = 10000000;\n    int mid = (mina+maxa)/2;\n    while(mina < maxa){\n      pi ret = solve(mid);\n      //      cout << maxa << \" \" << mina<< \"  \"<< ret.first << \" \" << ret.second<< endl;\n      if(ret.second < k){\n\tmaxa = mid-1;\n      }else if(ret.second > k){\n\tmina = mid+1;\n      }else{\n\tres = min(res, ret.first);\n\tmina = mid;\n      }\n      mid = (maxa+mina)/2;\n    }\n    if(res == 1000000000)\n      cout << -1 << endl;\n    else\n      cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define whole(xs) xs.begin(),xs.end()\n\nusing namespace std;\n\nnamespace {\n\n    typedef double real;\n    typedef long long ll;\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < int(vs.size()); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n    template<class T> istream& operator>>(istream& is, vector<T>& vs) {\n        for (auto it = vs.begin(); it != vs.end(); it++) is >> *it;\n        return is;\n    }\n\n    struct Edge {\n        int from, to;\n        int cost;\n        char firm;\n        Edge() {}\n        Edge(int from, int to, int cost, char firm) : from(from), to(to), cost(cost), firm(firm) {}\n    };\n    bool operator<(const Edge& a, const Edge& b) {\n        if (a.cost == b.cost) return a.firm > b.firm;\n        return a.cost < b.cost;\n    }\n    ostream& operator<<(ostream& os, const Edge& e) {\n        return os << \"Edge(\" << e.from << \"->\" << e.to << \" \" << e.cost << \" \" << e.firm << \")\";\n    }\n\n    int N, M, K;\n    vector<Edge> es;\n    bool input() {\n        cin >> N >> M >> K;\n        if (N == 0 && M == 0 && K == 0) return false;\n        es.clear();\n        for (int i = 0; i < M; i++) {\n            int u, v, w; char l;\n            cin >> u >> v >> w >> l;\n            u--; v--;\n            es.emplace_back(u, v, w, l);\n        }\n        return true;\n    }\n\n    struct UnionFind {\n        int N;\n        vector<int> P;\n        UnionFind(int N) : N(N) {\n            P.clear(); P.resize(N, -1);\n        }\n        int root(int x) {\n            if (P[x] == -1) return x;\n            return P[x] = root(P[x]);\n        }\n        int query(int x, int y) {\n            return root(x) == root(y);\n        }\n        void merge(int x, int y) {\n            x = root(x); y = root(y);\n            if (x == y) return;\n            P[x] = y;\n        }\n    };\n\n    const int INF = 1<<20;\n\n    int countA(int k) {\n        vector<Edge> fs = es;\n        for (int i = 0; i < M; i++) {\n            Edge& f = fs[i];\n            if (f.firm == 'A') f.cost += k;\n        }\n        sort(whole(fs));\n        UnionFind uf(N);\n        int count = 0;\n        for (int i = 0; i < M; i++) {\n            const Edge& f = fs[i];\n            if (uf.query(f.from, f.to)) continue;\n            uf.merge(f.from, f.to);\n            if (f.firm == 'A') count++;\n        }\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                if (not uf.query(i, j)) throw(-1);\n            }\n        }\n        return count;\n    }\n\n    int cost(int k) {\n        vector<Edge> fs = es;\n        for (int i = 0; i < M; i++) {\n            Edge& f = fs[i];\n            if (f.firm == 'A') f.cost += k;\n        }\n        int count = 0;\n        sort(whole(fs));\n        UnionFind uf(N);\n        int ret = 0;\n        for (int i = 0; i < M; i++) {\n            const Edge& f = fs[i];\n            if (uf.query(f.from, f.to)) continue;\n            if (f.firm == 'A') {\n                if (count == K) continue;\n                count++;\n            }\n            uf.merge(f.from, f.to);\n            ret += f.cost - (f.firm == 'A' ? k : 0);\n        }\n        return ret;\n    }\n\n\n    void solve() {\n        int lb = -INF, ub = INF;\n        int p, q;\n        try {\n            p = countA(lb); q = countA(ub);\n        } catch (int e) {\n            cout << -1 << endl;\n            return;\n        }\n        if ( (p - K) * (q - K) > 0 ) {\n            cout << -1 << endl;\n            return;\n        }\n        while (lb + 1 < ub) {\n            int mid = (lb + ub) / 2;\n            //cerr << mid << \" -> \" << countA(mid) << endl;\n            if (countA(mid) >= K) {\n                lb = mid;\n            } else {\n                ub = mid;\n            }\n        }\n        cout << cost(lb) << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconstexpr int MAX = 252;\n\nclass Union_Find {\n  public:\n    int par[MAX], rank[MAX], gnum;\n    \n    Union_Find(int N) {\n        for (int i = 0; i < N; i++) {\n            par[i] = i;\n            rank[i] = 0;\n        }\n        gnum = N;\n    }\n\n    int find(int x)\n    {\n        if (par[x] == x) {\n            return x;\n        }\n        return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y)\n    {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        \n        if (rank[x] < rank[y]) {\n            par[x] = y;\n        } else {\n            par[y] = x;\n            if (rank[x] == rank[y]) {\n                rank[x]++;\n            }\n        }\n        gnum--;\n    }\n\n    bool same(int x, int y)\n    {\n        return (find(x) == find(y));\n    }    \n};\n\nstruct edge {\n    int u, v, cost, col;\n    edge() {}\n    edge(int u, int v, int cost, int col) :\n        u{u}, v{v}, cost{cost}, col{col} {}\n\n    bool operator < (const edge& e) const {        \n        if (cost != e.cost) {\n            return cost < e.cost;\n        }\n        return col > e.col;\n    }\n};\n\nint N, M, K;\n\nvoid add_cost(int x, vector<edge>& es)\n{\n    for (auto& e : es) {\n        if (e.col == 0) {\n            e.cost += x;\n        }\n    }\n}\n\npair<int, int> kruskal(int x, vector<edge> es)\n{\n    add_cost(x, es);\n    sort(es.begin(), es.end());    \n    \n    Union_Find uf(N);\n    int res = 0, k = 0;    \n    for (const auto& e : es) {\n        if (!uf.same(e.u, e.v)) {\n            uf.unite(e.u, e.v);     \n            res += e.cost;\n            k += (e.col == 0);\n        }\n    }\n    return make_pair(res, k);\n}\n\nbool unconnected(const vector<edge>& es)\n{\n    Union_Find uf(N);\n    for (const auto& e : es) {\n        if (!uf.same(e.u, e.v)) {\n            uf.unite(e.u, e.v);\n        }\n    }\n    return (uf.gnum != 1);\n}\n\nvoid solve(const vector<edge>& es)\n{\n    constexpr int INF = 252521;    \n    int l = -INF, r = INF;\n\n    if (unconnected(es)) {\n        cout << -1 << endl;\n        return;\n    }\n    \n    while (r - l > 1) {\n        int mid = (l + r) / 2;            \n        auto mst = kruskal(mid, es);\n\n        if (mst.second < K) {\n            r = mid;\n        } else {\n            l = mid;\n        }\n    }\n\n    auto ll = kruskal(l, es);\n    auto rr = kruskal(r, es);\n\n    if (rr.second <= K && K <= ll.second) {\n        cout << rr.first - r * K << endl;\n    } else {\n        cout << -1 << endl;\n    }\n}\n\nint main()\n{\n    while (cin >> N >> M >> K, N) {\n        vector<edge> es;\n        for (int i = 0; i < M; i++) {\n            int u, v, w;\n            char l;\n            cin >> u >> v >> w >> l;\n            u--; v--;\n            es.emplace_back(u, v, w, l - 'A');\n        }\n        solve(es);       \n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(kbrni,n)cout<<\" \"<<a[kbrni];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(kbrni,v)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nstruct edge\n{\n    int u,v,cost,kind;\n    bool operator< (const edge& another) const {\n        return cost < another.cost;\n    }\n};\n\nstruct eda\n{\n    int to,cost,kind;\n};\n\nclass UF {\nprivate:\n    int sz; vector<int> par,nrank;\npublic:\n    UF(){}\n    UF(int node_size){ sz = node_size; par.resize(sz),nrank.resize(sz,0); rep(i,sz) par[i] = i; }\n    int find(int x){ if(par[x] == x){ return x; }else{ return par[x] = find(par[x]); } }\n    void unite(int x,int y)\n    { x = find(x),y = find(y); if(x == y) return;\n    \tif(nrank[x] < nrank[y]){ par[x] = y; }else{ par[y] = x; if(nrank[x] == nrank[y]) nrank[x]++; } }\n    bool same(int x,int y){ return find(x) == find(y); }\n};\n\nvoid dfs(int u,int p,int flag,vector<edge>& vec,const set<int>* G,vector<int>& comp)\n{\n    comp[u] = flag;\n    each(v,G[u]){\n        if(v != p){\n            dfs(v,u,flag,vec,G,comp);\n        }\n    }\n}\n\nbool trans(const int n,int ch,int& ans,vector<edge>& vec,set<int>* G,set<int>* use,set<P>* unuse)\n{\n    int diff = INF;\n    int in = -1,out = -1;\n    each(it,use[ch]){\n        vector<int> comp(n,-1);\n        int cri = -vec[it].cost;\n        int id = -1;\n        dfs(vec[it].u,vec[it].v,0,vec,G,comp);\n        dfs(vec[it].v,vec[it].u,1,vec,G,comp);\n        each(it2,unuse[ch^1]){\n            int a = vec[it2.se].u,b = vec[it2.se].v;\n            if(comp[a] != comp[b]){\n                cri += vec[it2.se].cost;\n                id = it2.se;\n                break;\n            }\n        }\n        if(id >= 0 && diff > cri){\n            diff = cri;\n            in = id,out = it;\n        }\n    }\n    G[vec[out].u].erase(vec[out].v),G[vec[out].v].erase(vec[out].u);\n    G[vec[in].u].insert(vec[in].v),G[vec[in].v].insert(vec[in].u);\n    use[ch].erase(out);\n    unuse[ch^1].erase(P(vec[in].cost,in));\n    if(diff == INF){\n        return false;\n    }else{\n        ans += diff;\n        return true;\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,m,k;\n        cin >> n >> m >> k;\n        if(n == 0){\n            break;\n        }\n        vector<edge> vec(m);\n        int ans = 0;\n        set<int> G[201];\n        set<int> use[2];\n        set<P> unuse[2];\n        rep(i,m){\n            int a,b,c,d;\n            string hoge;\n            cin >> a >> b >> c >> hoge;\n            if(hoge == \"A\"){\n                d = 0;\n            }else{\n                d = 1;\n            }\n            --a,--b;\n            vec[i] = (edge){a,b,c,d};\n        }\n        int num[2] = {};\n        sort(all(vec));\n        UF uf(n);\n        rep(i,m){\n            int a = vec[i].u,b = vec[i].v;\n            if(!uf.same(a,b)){\n                uf.unite(a,b);\n                G[a].insert(b),G[b].insert(a);\n                ans += vec[i].cost;\n                num[vec[i].kind]++;\n                use[vec[i].kind].insert(i);\n            }else{\n                unuse[vec[i].kind].insert(P(vec[i].cost,i));\n            }\n        }\n        if(num[0] + num[1] < n-1){\n            cout << \"-1\\n\";\n            continue;\n        }\n        bool flag = false;\n        rep(i,abs(k-num[0])){\n            if(!trans(n,(k > num[0]),ans,vec,G,use,unuse)){\n                cout << \"-1\\n\";\n                flag = true;\n                break;\n            }\n        }\n        if(!flag){\n            cout << ans << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct Kruskal{\n\n  struct UnionFind{\n    Int n;\n    vector<Int> r,p;\n    UnionFind(){}\n    UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n    Int find(Int x){\n      return (x==p[x]?x:p[x]=find(p[x]));\n    }\n    bool same(Int x,Int y){\n      return find(x)==find(y);\n    }\n    void unite(Int x,Int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      if(r[x]<r[y]) swap(x,y);\n      r[x]+=r[y];\n      p[y]=x;\n    }\n  };\n  \n  struct edge{\n    Int from,to;\n    double cost;\n    Int used;\n    char color;\n    edge(){}\n    edge(Int from,Int to,double cost,char color):\n      from(from),to(to),cost(cost),used(0),color(color){}\n    bool operator<(const edge& e) const{\n      return cost<e.cost;\n    }\n  };\n\n  Int n;\n  vector<edge> edges;\n\n  Kruskal(){}\n  Kruskal(Int sz):n(sz){}\n  \n  Int build(Int k=-1){\n    sort(edges.begin(),edges.end());\n    UnionFind uf(n+1);\n    double res=0;\n    Int cnt=0;\n    for(Int i=0;i<(Int)edges.size();i++){\n      edge &e=edges[i];\n      if(!uf.same(e.from,e.to)){\n\te.used=1;\n\tres+=e.cost;\n\tuf.unite(e.from,e.to);\n\tcnt++;\n      }\n    }\n    if(cnt+1!=n) return -1;\n    return res;\n  }\n};\n\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    Kruskal kr(n);\n    auto edges=kr.edges;\n    for(Int i=0;i<m;i++){\n      Int u,v,w;\n      char c;\n      cin>>u>>v>>w>>c;\n      u--;v--;\n      edges.emplace_back(u,v,w,c);\n    }\n    double ub=1e12,ans;\n    auto check=[&](double x){\n      x-=ub;\n      kr=Kruskal(n);\n      for(auto e:edges){\n\tif(x>0&&e.color=='A') e.cost+=x; \n\tif(x<0&&e.color=='B') e.cost-=x; \n\tkr.edges.emplace_back(e);\n      }\n      \n      ans=kr.build();\n      if(ans<0) return Int(-1);\n      if(x>0) ans-=x*k;\n      if(x<0) ans+=x*(n-1-k);\n      \n      Int res=0;\n      for(auto e:kr.edges)\n\tres+=(e.used&&e.color=='A');\n      return res;\n    };\n    double l=0,r=2*ub;\n    if(check(l)<k||check(r)>k){\n      cout<<-1<<endl;\n      continue;\n    }\n    for(Int i=0;i<1000;i++){\n      double m=(l+r)/2;\n      if(check(m)>=k) l=m;\n      else r=m;\n    }\n    check(l);\n    cout<<(Int)ceil(ans)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass union_find {\n\tvector<int> par;\n\tint find(int a) {\n\t\treturn par[a] < 0 ? a : par[a] = find(par[a]);\n\t}\npublic:\n\tunion_find(int n) : par(n, -1) {}\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\tvoid unite(int a, int b) {\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b) return;\n\t\tif (par[a] < par[b]) {\n\t\t\tpar[a] += par[b];\n\t\t\tpar[b] = a;\n\t\t}\n\t\telse {\n\t\t\tpar[b] += par[a];\n\t\t\tpar[a] = b;\n\t\t}\n\t}\n\tint size(int a) {\n\t\treturn -par[find(a)];\n\t}\n};\n\nconst int INF = 1e9;\n\nstruct edge {\n\tint u, v, cost;\n\tbool f;\n\tedge(int u_, int v_, int w, bool f_) : u(u_), v(v_), cost(w), f(f_) {}\n\tbool operator<(const edge& that) const {\n\t\treturn cost < that.cost;\n\t}\n};\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n, m, k;\n\twhile (cin >> n >> m >> k, n | m | k) {\n\t\tvector<edge> es;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u, v, w;\n\t\t\tchar l;\n\t\t\tcin >> u >> v >> w >> l; u--, v--;\n\t\t\tes.emplace_back(u, v, w, l == 'A');\n\t\t}\n\t\tsort(es.begin(), es.end());\n\t\tint res = INF;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tunion_find uf(n);\n\t\t\tint c1 = 0, c2 = 0, sum = 0;\n\t\t\tfor (int j = i; j < m; j++) if (es[j].f) {\n\t\t\t\tif (!uf.same(es[j].u, es[j].v)) {\n\t\t\t\t\tuf.unite(es[j].u, es[j].v);\n\t\t\t\t\tsum += es[j].cost;\n\t\t\t\t\tc1++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < m; j++) if (!es[j].f) {\n\t\t\t\tif (!uf.same(es[j].u, es[j].v)) {\n\t\t\t\t\tuf.unite(es[j].u, es[j].v);\n\t\t\t\t\tsum += es[j].cost;\n\t\t\t\t\tc2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (c1 == k && c2 == n - 1 - k) {\n\t\t\t\tres = min(res, sum);\n\t\t\t}\n\t\t}\n\t\tcout << (res == INF ? -1 : res) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) FOR(i,0,b)\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\ntemplate<class T> using V=vector<T>;\ntemplate<class T> using VV=V<V<T>>;\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\trep(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"(\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\")\";\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?1:2);\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconstexpr ll TEN(int n){\n\treturn n==0?1:TEN(n-1)*10;\n}\n\ntemplate<class T>\nvector<T> Uniqued(const vector<T>&vv){\n\tauto v(vv);\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n\treturn v;\n}\ntemplate<class T>\nvoid MakeUniqued(vector<T>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n}\n\n//Matroid\n//size(): returns size\n//Get(): returns pair of\n//1. indices of src(vertices that it is free to add)\n//2. all (x,y) s.t. del x & add y is possible(y is not a src)\ntemplate<class LM,class RM>\nstruct MatroidIntersection{\n\tint n,m,s;\n\tLM& lm;\n\tRM& rm;\n\tstruct Edge{\n\t\tint to,cost,id;\n\t\tfriend ostream& operator<<(ostream&os,const Edge&e){\n\t\t\treturn os<<\"{T:\"<<e.to<<\", C:\"<<e.cost<<\", I:\"<<e.id<<\"}\";\n\t\t}\n\t};\n\tV<tuple<int,int,int>> es;\n\tVV<Edge> g;\n\tMatroidIntersection(LM& llm,RM& rrm):lm(llm),rm(rrm){\n\t\tn=lm.size();\n\t\tm=rm.size();\n\t\ts=n+m;\n\t}\n\tvoid AddEdge(int a,int b,int c){\n\t\tassert(0<=a&&a<n);\n\t\tassert(0<=b&&b<m);\n\t\tassert(0<=c);\n\t\tes.eb(a,b,c);\n\t}\n\tvi h;\n\tV<pi> dist,prev;\n\tvoid FindShortest(const vi&src){\n\t\tdist.assign(s,pi(inf,-1));\n\t\tprev.assign(s,pi(-1,-1));\n\t\t\n\t\tusing Node=tuple<int,int,int>;\n\t\tpriority_queue<Node,V<Node>,greater<Node>> pq;\n\t\tconst auto Reach=[&](int v,int d,int step,int j,int k){\n\t\t\tif(pi(d,step)<dist[v]){\n\t\t\t\tdist[v]=pi(d,step);\n\t\t\t\tprev[v]=pi(j,k);\n\t\t\t\tpq.push(make_tuple(d,step,v));\n\t\t\t}\n\t\t};\n\t\t\t\n\t\tfor(auto i:src)\n\t\t\tReach(i,0,0,-1,-1);\n\t\t\n\t\twhile(!pq.empty()){\n\t\t\tint d,step,v;\n\t\t\ttie(d,step,v)=pq.top();\n\t\t\tpq.pop();\n\t\t\tif(dist[v]!=pi(d,step))\n\t\t\t\tcontinue;\n\t\t\tfor(auto e:g[v]){\n\t\t\t\tassert(e.cost+h[v]-h[e.to]>=0);\n\t\t\t\tReach(e.to,d+e.cost+h[v]-h[e.to],step+1,v,e.id);\n\t\t\t}\n\t\t}\n\t}\n\tint Augment(V<bool>&use){\n\t\tg.assign(s,V<Edge>());\n\t\tvi m1,m2;\n\t\trep(i,es.size()){\n\t\t\tint a,b,c;\n\t\t\ttie(a,b,c)=es[i];\n\t\t\tif(use[i]){\n\t\t\t\tg[n+b].pb(Edge{a,-c,i});\n\t\t\t\tm1.pb(a);\n\t\t\t\tm2.pb(b);\n\t\t\t}else{\n\t\t\t\tg[a].pb(Edge{n+b,c,i});\n\t\t\t}\n\t\t}\n\t\tvi src,dst;\n\t\t{\n\t\t\tauto w=lm.Get(m1);\n\t\t\tsrc=w.first;\n\t\t\tif(src.empty())return -1;\n\t\t\tfor(auto e:w.second)\n\t\t\t\tg[e.first].pb(Edge{e.second,0,-1});\n\t\t}\n\t\t{\n\t\t\tauto w=rm.Get(m2);\n\t\t\tdst=w.first;\n\t\t\tif(dst.empty())return -1;\n\t\t\tfor(auto e:w.second)\n\t\t\t\tg[n+e.second].pb(Edge{n+e.first,0,-1});\n\t\t}\n\t\t\n\t\tFindShortest(src);\n\t\t\n\t\tpair<pi,int> w(pi(inf/2,-1),-1);\n\t\tfor(auto i:dst)\n\t\t\tchmin(w,mp(dist[n+i],n+i));\n\t\tif(w.second==-1)\n\t\t\treturn -1;\n\t\tint x=w.second;\n\t\twhile(prev[x].first!=-1){\n\t\t\tint i=prev[x].second;\n\t\t\tif(i!=-1)\n\t\t\t\tuse[i]=!use[i];\n\t\t\tx=prev[x].first;\n\t\t}\n\t\tint mn=w.first.first;\n\t\trep(i,s){\n\t\t\th[i]+=min(dist[i].first,mn);\n\t\t\tchmin(h[i],inf);\n\t\t}\n\t\treturn h[w.second];\n\t}\n\tpair<int,vi> Solve(){\n\t\th.assign(s,0);\n\t\tV<bool> use(es.size());\n\t\tint c=0,f;\n\t\twhile((f=Augment(use))>=0)\n\t\t\tc+=f;\n\t\tvi sol;\n\t\trep(i,es.size())\n\t\t\tif(use[i])\n\t\t\t\tsol.pb(i);\n\t\treturn mp(c,sol);\n\t}\n};\n\nstruct UnionFind{\n\tvi rank,par;\n\tvoid Init(int n){\n\t\trank.assign(n,0);\n\t\tpar.assign(n,-1);\n\t}\n\tint Find(int i){\n\t\treturn par[i]==-1?i:(par[i]=Find(par[i]));\n\t}\n\tbool Same(int a,int b){\n\t\treturn Find(a)==Find(b);\n\t}\n\tbool Unite(int a,int b){\n\t\ta=Find(a);\n\t\tb=Find(b);\n\t\tif(a==b)\n\t\t\treturn false;\n\t\tif(rank[a]<rank[b])\n\t\t\tswap(a,b);\n\t\tpar[b]=a;\n\t\tif(rank[a]==rank[b])\n\t\t\trank[a]++;\n\t\treturn true;\n\t}\n};\n\nstruct MST{\n\tint n;\n\tvector<pi> es;\n\tMST(int nn){\n\t\tn=nn;\n\t}\n\tvoid AddEdge(int a,int b){\n\t\tassert(0<=a&&a<n);\n\t\tassert(0<=b&&b<n);\n\t\tes.eb(a,b);\n\t}\n\tint size(){\n\t\treturn es.size();\n\t}\n\tUnionFind uf;\n\tpair<vi,V<pi>> Get(const vi&cur){\n\t\tuf.Init(n);\n\t\tvi t(size(),0);\n\t\tfor(auto i:cur){\n\t\t\tuf.Unite(es[i].first,es[i].second);\n\t\t\tt[i]=1;\n\t\t}\n\t\tvi src;\n\t\trep(i,size())if(!t[i]){\n\t\t\tif(!uf.Same(es[i].first,es[i].second)){\n\t\t\t\tsrc.pb(i);\n\t\t\t\tt[i]=2;\n\t\t\t}\n\t\t}\n\t\tV<pi> res;\n\t\trep(i,size())if(t[i]==1){\n\t\t\tuf.Init(n);\n\t\t\trep(j,size())if(t[j]==1&&j!=i)\n\t\t\t\tuf.Unite(es[j].first,es[j].second);\n\t\t\trep(j,size())if(!t[j])\n\t\t\t\tif(!uf.Same(es[j].first,es[j].second))\n\t\t\t\t\tres.eb(i,j);\n\t\t}\n\t\treturn mp(src,res);\n\t}\n};\n\nstruct FreeMatroid{\n\tint n;\n\tFreeMatroid(int nn):n(nn){}\n\tint size(){\n\t\treturn n;\n\t}\n\tpair<vi,V<pi>> Get(const vi&cur){\n\t\tV<bool> used(n);\n\t\tfor(auto i:cur)\n\t\t\tused[i]=true;\n\t\tvi src;\n\t\trep(i,n)if(!used[i])\n\t\t\tsrc.pb(i);\n\t\treturn mp(src,V<pi>());\n\t}\n};\n\nsigned main(){\n\twhile(1){\n\t\tint n=read(),m=read(),k=read();\n\t\tif(n==0)break;\n\t\tMST mst(n);\n\t\tvi cost(m),type(m);\n\t\trep(i,m){\n\t\t\tint u=read()-1,v=read()-1,w=read();\n\t\t\tstring l=readString();\n\t\t\tmst.AddEdge(u,v);\n\t\t\tcost[i]=w;\n\t\t\ttype[i]=l[0]-'A';\n\t\t}\n\t\tFreeMatroid fmat(n-1);\n\t\tMatroidIntersection<FreeMatroid,MST> matint(fmat,mst);\n\t\trep(i,m){\n\t\t\tif(type[i]==0)\n\t\t\t\trep(j,k)\n\t\t\t\t\tmatint.AddEdge(j,i,cost[i]);\n\t\t\telse\n\t\t\t\tFOR(j,k,n-1)\n\t\t\t\t\tmatint.AddEdge(j,i,cost[i]);\n\t\t}\n\t\tauto ans=matint.Solve();\n\t\tif(int(ans.second.size())<n-1)\n\t\t\tprint(-1);\n\t\telse\n\t\t\tprint(ans.first);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\nconst ld eps=1e-8;\nint par[200];\nint rank1[200];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v, cost,col; };\nbool comp(const edge&e1, const edge&e2) {\n\tif (e1.cost != e2.cost) {\n\t\treturn e1.cost < e2.cost;\n\t}\n\treturn e1.col < e2.col;\n}\nedge cop[600];\nint V, E;\nint k;\nP kruskal() {\n\tsort(cop, cop + E, comp);\n\tinit(V);\n\tint res = 0; int cost = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tedge e = cop[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tcost += e.cost;\n\t\t\tif (e.col == 0) {\n\t\t\t\tres++;\n\t\t\t}\n\t\t}\n\t}\n\treturn { res,cost };\n}\nedge ori[600];\nvoid init2() {\n\trep(i, E) {\n\t\tcop[i] = ori[i];\n\t}\n\treturn;\n}\nbool ooo(int x) {\n\tinit2();\n\trep(i, E) {\n\t\tif (cop[i].col == 0) {\n\t\t\tcop[i].cost += x;\n\t\t}\n\t}\n\tP r = kruskal();\n\tif (r.first < k) {\n\t\treturn false;\n\t}\n\treturn true;\n}\nint main() {\n\twhile (cin >> V >> E >> k, V) {\n\t\tint le = -1000000; int ri = 1000000;\n\t\trep(i, E) {\n\t\t\tint x, y, z;char w;\n\t\t\tcin >> x >> y >> z >> w; x--; y--;\n\t\t\tori[i] = { x,y,z,w - 'A' };\n\t\t}\n\t\twhile (ri - le > 1) {\n\t\t\tint mid = (ri + le) / 2;\n\t\t\tif (ooo(mid)) {\n\t\t\t\tle = mid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tri = mid;\n\t\t\t}\n\t\t}\n\t\tinit2();\n\t\trep(i, E) {\n\t\t\tif (cop[i].col == 0) {\n\t\t\t\tcop[i].cost += le;\n\t\t\t}\n\t\t}\n\t\tP fin1 = kruskal();\n\t\tinit2();\n\t\trep(i, E) {\n\t\t\tif (cop[i].col == 0) {\n\t\t\t\tcop[i].cost += ri;\n\t\t\t}\n\t\t}\n\t\tP fin2 = kruskal();\n\t\tif (fin1.first < k || k < fin2.first) {\n\t\t\tcout << -1 << endl; continue;\n\t\t}\n\t\tbool f = true;\n\t\trep(i, V) {\n\t\t\trep(j, V) {\n\t\t\t\tif (!same(i, j)) {\n\t\t\t\t\tf = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!f) {\n\t\t\tcout << -1 << endl; continue;\n\t\t}\n\t\tcout << fin1.second - k * le << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct Kruskal{\n\n  struct UnionFind{\n    Int n;\n    vector<Int> r,p;\n    UnionFind(){}\n    UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n    Int find(Int x){\n      return (x==p[x]?x:p[x]=find(p[x]));\n    }\n    bool same(Int x,Int y){\n      return find(x)==find(y);\n    }\n    void unite(Int x,Int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      if(r[x]<r[y]) swap(x,y);\n      r[x]+=r[y];\n      p[y]=x;\n    }\n  };\n  \n  struct edge{\n    Int from,to,cost,used;\n    char color;\n    edge(){}\n    edge(Int from,Int to,Int cost,char color):\n      from(from),to(to),cost(cost),used(0),color(color){}\n    bool operator<(const edge& e) const{\n      return cost<e.cost;\n    }\n  };\n\n  Int n;\n  vector<edge> edges;\n\n  Kruskal(){}\n  Kruskal(Int sz):n(sz){}\n  \n  Int build(){\n    sort(edges.begin(),edges.end());\n    UnionFind uf(n+1);\n    Int res=0,cnt=0;\n    for(Int i=0;i<(Int)edges.size();i++){\n      edge &e=edges[i];\n      if(!uf.same(e.from,e.to)){\n\te.used=1;\n\tres+=e.cost;\n\tuf.unite(e.from,e.to);\n\tcnt++;\n      }\n    }\n    if(cnt+1!=n) return -1;\n    return res;\n  }\n};\n\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    Kruskal kr(n);\n    auto edges=kr.edges;\n    for(Int i=0;i<m;i++){\n      Int u,v,w;\n      char c;\n      cin>>u>>v>>w>>c;\n      u--;v--;\n      edges.emplace_back(u,v,w,c);\n    }\n    Int ub=1e12,ans;\n    auto check=[&](Int x){\n      x-=ub;\n      kr=Kruskal(n);\n      for(auto e:edges){\n\tif(x>0&&e.color=='A') e.cost+=x; \n\tif(x<0&&e.color=='B') e.cost-=x; \n\tkr.edges.emplace_back(e);\n      }\n      \n      ans=kr.build();\n      if(ans<0) return ans;\n      if(x>0) ans-=x*k;\n      if(x<0) ans+=x*(n-1-k);\n      \n      Int res=0;\n      for(auto e:kr.edges)\n\tres+=(e.used&&e.color=='A');\n      return res;\n    };\n    Int l=0,r=2*ub;\n    if(check(l)<k||check(r)>k){\n      cout<<-1<<endl;\n      continue;\n    }\n    while(l+1<r){\n      Int m=(l+r)>>1;\n      if(check(m)>=k) l=m;\n      else r=m;\n    }\n    check(l);\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nstruct UnionFind\n{\n\tvector<int> par;\n\tUnionFind(int n) :par(n, -1) {}\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (par[y] < par[x]) swap(x, y);\n\t\tif (par[x] == par[y]) par[x]--;\n\t\tpar[y] = x;\n\t\tif (find(x) != find(y)) par[find(y)] = x;\n\t}\n\tint count()\n\t{\n\t\tint cnt = 0;\n\t\tREP(i, par.size()) if (par[i] < 0) cnt++;\n\t\treturn cnt;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\ntypedef ld Weight;\nstruct Edge\n{\n\tint from, to; Weight cost; char c;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\n\nconst ld INF = 1e9;\nconst ld EPS = 1e-9;\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m, k;\n\twhile (cin >> n >> m >> k, n)\n\t{\n\t\tEdges es;\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; ld c; char d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--; b--;\n\t\t\tes.emplace_back(Edge{ a, b, c, d });\n\t\t}\n\t\tint mn = INF, mx = -1;\n\t\tld lb = -INF, ub = INF;\n\t\tREP(lp, 300)\n\t\t{\n\t\t\tld mid = (ub + lb) / 2;\n\t\t\tEdges tmp;\n\t\t\tfor (auto e : es)\n\t\t\t{\n\t\t\t\tif (e.c == 'A') e.cost += mid;\n\t\t\t\ttmp.push_back(e);\n\t\t\t}\n\t\t\tsort(ALL(tmp));\n\t\t\tUnionFind uf(n);\n\t\t\tll cost = 0;\n\t\t\tint cnta = 0;\n\t\t\tfor (auto e : tmp)\n\t\t\t{\n\t\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\t\tif (e.c == 'A')\n\t\t\t\t{\n\t\t\t\t\tcnta++;\n\t\t\t\t}\n\t\t\t\tcost += e.cost;\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t}\n\n\t\t\tchmax(mx, cnta);\n\t\t\tchmin(mn, cnta);\n\t\t\tif (lp == 299)\n\t\t\t{\n\t\t\t\tif (uf.count() != 1 || (mx < k || mn > k))\n\t\t\t\t{\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse cout << ll(cost - k * mid + EPS) << endl;\n\t\t\t}\n\t\t\telse if (cnta > k)\n\t\t\t{\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tub = mid;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nusing Weight = ll;\nstruct Edge {\n\tint src, dst; Weight weight;\n\tchar id;\n\tEdge() {}\n\tEdge(int s, int d, Weight w, char id) : src(s), dst(d), weight(w), id(id) {}\n};\nusing Edges = vector<Edge>;\n\nstruct UnionFind {\n\tvector<int> par;\n\tint cnt;\n\tUnionFind(int size_) : par(size_, -1), cnt(size_) {}\n\tvoid unite(int x, int y) {\n\t\tif((x = find(x)) != (y = find(y))) {\n\t\t\tif(par[y] < par[x]) swap(x, y);\n\t\t\tpar[x] += par[y]; par[y] = x; cnt--;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tint size(int x) { return -par[find(x)]; }\n\tint size() { return cnt; }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n\treturn e.weight < f.weight;\n}\npair<Weight, Edges> kruskal(int N, Edges es) {\n\tUnionFind uf(N);\n\tsort(es.begin(), es.end());\n\tWeight total = 0; Edges T;\n\tfor(auto &e : es) if(!uf.same(e.src, e.dst)) {\n\t\tT.push_back(e); total += e.weight; uf.unite(e.src, e.dst);\n\t}\n\treturn make_pair(total, T);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, K;\n\twhile(cin >> N >> M >> K, N) {\n\t\tEdges es;\n\t\tUnionFind uf(N);\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint u, v, w;\n\t\t\tchar l;\n\t\t\tcin >> u >> v >> w >> l;\n\t\t\tu--, v--;\n\t\t\tes.push_back(Edge(u, v, w, l));\n\t\t\tuf.unite(u, v);\n\t\t}\n\n\t\tif(uf.size(0) != N) {\n\t\t\tcout << -1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst ll INF = 1LL << 30;\n\t\tll ng = -INF, ok = INF;\n\t\twhile(abs(ng - ok) > 1) {\n\t\t\tll mid = (ng + ok) / 2;\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tif(es[i].id == 'A') es[i].weight += mid;\n\t\t\t}\n\n\t\t\tauto res = kruskal(N, es);\n\t\t\tint sum = 0;\n\t\t\tfor(auto e : res.second) {\n\t\t\t\tif(e.id == 'A') sum++;\n\t\t\t}\n\t\t\tif(sum <= K) ok = mid;\n\t\t\telse ng = mid;\n\n\t\t\tfor(int i = 0; i < M; i++) {\n\t\t\t\tif(es[i].id == 'A') es[i].weight -= mid;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tif(es[i].id == 'A') es[i].weight += ok;\n\t\t}\n\t\tauto resR = kruskal(N, es);\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tif(es[i].id == 'A') es[i].weight--;\n\t\t}\n\t\tauto resL = kruskal(N, es);\n\n\t\tint sumR = 0, sumL = 0;\n\t\tfor(auto e : resR.second) {\n\t\t\tif(e.id == 'A') sumR++;\n\t\t}\n\t\tfor(auto e : resL.second) {\n\t\t\tif(e.id == 'A') sumL++;\n\t\t}\n\n\t\tif(sumR <= K && K <= sumL) {\n\t\t\tcout << resR.first - ok * K << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << -1 << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntemplate <int N>\nstruct union_find {\n    int par[N];\n    union_find() { for (int i = 0; i < N; ++i) par[i] = -1; }\n\n    int find(int v) {\n        if (par[v] < 0) return v;\n        return par[v] = find(par[v]);\n    }\n\n    bool unite(int x, int y) {\n        int xx = find(x), yy = find(y);\n        if (xx == yy) return false;\n        if (par[xx] < par[yy]) {\n            par[xx] += par[yy];\n            par[yy] = xx;\n        } else {\n            par[yy] += par[xx];\n            par[xx] = yy;\n        }\n        return true;\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nstruct edge {\n    int u, v, cost;\n    char label;\n    edge() {}\n    edge(int u, int v, int cost, char label): u(u), v(v), cost(cost), label(label) {}\n\n    bool operator < (const edge& o) const {\n        return cost == o.cost ? label < o.label : cost < o.cost;\n    }\n};\n\nint N, M, K;\nvector<edge> edges;\n\npair<int, int> kruskal(vector<edge> es, int add_a) {\n    for (edge& e : es)\n        if (e.label == 'A') e.cost += add_a;\n\n    union_find<200> uf;\n\n    sort(begin(es), end(es));\n\n    int weight_sum = 0, a_count = 0, b_count = 0;\n\n    for (const edge& e : es) {\n        if (uf.same(e.u, e.v)) continue;\n        (e.label == 'A' ? a_count : b_count)++;\n        uf.unite(e.u, e.v);\n        weight_sum += e.cost;\n    }\n\n    if (a_count + b_count < N-1) return make_pair(-1, -1);\n    return make_pair(weight_sum, a_count);\n}\n\nint solve() {\n\n    auto pr = kruskal(edges, 0);\n\n    if (pr.first == -1 && pr.second == -1) return -1;\n\n    int l = -101010, r = 101010;\n    while (l+1 < r) {\n        int a = (l + r) / 2;\n\n        pair<int, int> pr = kruskal(edges, a);\n\n        ((pr.second < K) ? r : l) = a;\n    }\n\n    auto res_l = kruskal(edges, l);\n    auto res_r = kruskal(edges, r);\n\n    return (res_r.second <= K && K <= res_l.second) ? res_l.first - l * K : -1;\n}\n\n\nint main(void) {\n    while (true) {\n        cin >> N >> M >> K;\n        edges.clear();\n        if (N == 0 && M == 0 && K == 0) break;\n        for (int i = 0; i < M; ++i) {\n            int u, v, cost; char label;\n            cin >> u >> v >> cost >> label; --u; --v;\n            edges.emplace_back(u, v, cost, label);\n        }\n\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct Kruskal{\n\n  struct UnionFind{\n    Int n;\n    vector<Int> r,p;\n    UnionFind(){}\n    UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n    Int find(Int x){\n      return (x==p[x]?x:p[x]=find(p[x]));\n    }\n    bool same(Int x,Int y){\n      return find(x)==find(y);\n    }\n    void unite(Int x,Int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      if(r[x]<r[y]) swap(x,y);\n      r[x]+=r[y];\n      p[y]=x;\n    }\n  };\n  \n  struct edge{\n    Int from,to;\n    double cost;\n    Int used;\n    char color;\n    edge(){}\n    edge(Int from,Int to,double cost,char color):\n      from(from),to(to),cost(cost),used(0),color(color){}\n    bool operator<(const edge& e) const{\n      return cost<e.cost;\n    }\n  };\n\n  Int n;\n  vector<edge> edges;\n\n  Kruskal(){}\n  Kruskal(Int sz):n(sz){}\n  \n  Int build(Int k=-1){\n    sort(edges.begin(),edges.end());\n    UnionFind uf(n+1);\n    double res=0;\n    Int cnt=0;\n    for(Int i=0;i<(Int)edges.size();i++){\n      edge &e=edges[i];\n      if(!uf.same(e.from,e.to)){\n\te.used=1;\n\tres+=e.cost;\n\tuf.unite(e.from,e.to);\n\tcnt++;\n      }\n    }\n    if(cnt+1!=n) return -1;\n    return res;\n  }\n};\n\nsigned main(){\n  Int n,m,k;\n  while(cin>>n>>m>>k,n){\n    Kruskal kr(n);\n    auto edges=kr.edges;\n    for(Int i=0;i<m;i++){\n      Int u,v,w;\n      char c;\n      cin>>u>>v>>w>>c;\n      u--;v--;\n      edges.emplace_back(u,v,w,c);\n    }\n    double ub=1e12,ans;\n    auto check=[&](double x){\n      x-=ub;\n      kr=Kruskal(n);\n      for(auto e:edges){\n\tif(x>0&&e.color=='A') e.cost+=x; \n\tif(x<0&&e.color=='B') e.cost-=x; \n\tkr.edges.emplace_back(e);\n      }\n      \n      ans=kr.build();\n      if(ans<0) return Int(-1);\n      if(x>0) ans-=x*k;\n      if(x<0) ans+=x*(n-1-k);\n      \n      Int res=0;\n      for(auto e:kr.edges)\n\tres+=(e.used&&e.color=='A');\n      return res;\n    };\n    double l=0,r=2*ub;\n    if(check(l)<k||check(r)>k){\n      cout<<-1<<endl;\n      continue;\n    }\n    for(Int i=0;i<2000;i++){\n      double m=(l+r)/2;\n      if(check(m)>=k) l=m;\n      else r=m;\n    }\n    check(l);\n    assert(check(l)==k);\n    cout<<(Int)round(ans)<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int u, v, w, id;\n  edge(){}\n  edge(int u, int v, int w, int id):u(u), v(v), w(w), id(id){}\n  bool operator < (const edge& e) {\n    return w < e.w;\n  }\n};\n\nstruct UnionFind {\n  vint data;\n  UnionFind(int n):data(n, -1){}\n  int find(int x) {\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n  int size(int x) {\n    return -data[find(x)];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  void unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n  }\n};\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m, k;\n  while(cin >> n >> m >> k, n || m || k) {\n    vint u(m), v(m), w(m);\n    vector<char> id(m);\n    rep(i, m) {\n      cin >> u[i] >> v[i] >> w[i] >> id[i];\n      --u[i], --v[i];\n    }\n    auto check = [&](int mb) -> pair<int, int> {\n      vector<edge> vec;\n      rep(i, m) {\n\tif(id[i] == 'A') vec.emplace_back(u[i], v[i], w[i]+mb, 1);\n\telse vec.emplace_back(u[i], v[i], w[i], 0);\n      }\n      sort(all(vec));\n      UnionFind uf(n);\n      int cnt = 0;\n      int sum = 0;\n      int tmp = -inf;\n      for(edge e : vec) {\n\tif(cnt >= k && tmp < e.w) break;\n\tif(cnt+e.id <= k && !uf.same(e.u, e.v)) {\n\t  uf.unite(e.u, e.v);\n\t  cnt += e.id;\n\t  sum += e.w - e.id*mb;\n\t  tmp = e.w;\n\t}\n      }\n      for(edge e : vec) {\n\tif(!uf.same(e.u, e.v)) {\n\t  uf.unite(e.u, e.v);\n\t  cnt += e.id;\n\t  sum += e.w - e.id*mb;\n\t}\n      }\n\n      return make_pair(sum, cnt);\n    };\n    int lb = -100000, ub = 100000;\n    while(lb+1 < ub) {\n      int mb = (lb+ub)/2;\n      if(check(mb).second <= k) ub = mb;\n      else lb = mb;\n    }\n    auto ans = check(ub);\n    //cout<<ub<<endl;\n    //cout<<ans.first<<\" \"<<ans.second << endl;\n    if(ans.second == k) cout << ans.first << endl;\n    else cout << -1 << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate <int N>\nstruct union_find {\n    int par[N];\n    union_find() { for (int i = 0; i < N; ++i) par[i] = -1; }\n\n    int find(int v) {\n        if (par[v] < 0) return v;\n        return par[v] = find(par[v]);\n    }\n\n    bool unite(int x, int y) {\n        int xx = find(x), yy = find(y);\n        if (xx == yy) return false;\n        if (par[xx] < par[yy]) {\n            par[xx] += par[yy];\n            par[yy] = xx;\n        } else {\n            par[yy] += par[xx];\n            par[xx] = yy;\n        }\n        return true;\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nstruct edge {\n    int u, v, cost;\n    char label;\n    edge() {}\n    edge(int u, int v, int cost, char label): u(u), v(v), cost(cost), label(label) {}\n\n    bool operator < (const edge& o) const {\n        return cost < o.cost;\n    }\n};\n\nvector<edge> edges, edges_bak;\n\nint N, M, K;\n\nint solve() {\n    edges_bak = edges;\n\n    int ans = 1LL << 28;\n\n    for (int a = -100; a <= 100; ++a) {\n        edges = edges_bak;\n\n        union_find<200> uf;\n\n        for (edge& e : edges)\n            if (e.label == 'A') e.cost += a;\n\n        sort(begin(edges), end(edges));\n\n        int weight_sum = 0, a_count = 0, b_count = 0;\n\n        for (const edge& e : edges) {\n            if (uf.same(e.u, e.v)) continue;\n            if (e.label == 'A' && a_count == K) continue;\n            if (e.label == 'B' && b_count == N-1-K) continue;\n            (e.label == 'A' ? a_count : b_count)++;\n            uf.unite(e.u, e.v);\n            weight_sum += e.cost;\n        }\n\n        if (a_count + b_count < N-1) continue;\n\n        if (a_count == K)\n            ans = min(ans, weight_sum - K * a);\n    }\n\n    return (ans == 1 << 28 ? -1 : ans);\n}\n\n\nint main(void) {\n    while (true) {\n        cin >> N >> M >> K;\n        edges.clear();\n        edges_bak.clear();\n        if (N == 0 && M == 0 && K == 0) break;\n        for (int i = 0; i < M; ++i) {\n            int u, v, cost; char label;\n            cin >> u >> v >> cost >> label; --u; --v;\n            edges.emplace_back(u, v, cost, label);\n        }\n\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 1010\n\n/* Aho Corasick */\n\nstruct ACNode;\n\nACNode *pos[SIZE];\nint pos_size = 0;\n\nstruct ACNode{\n  int val, id;\n  ACNode *next[26], *failure;\n  \n  ACNode():val(0) { memset(next,0,sizeof(next)); }\n  \n  void insert(char *s){\n    if(!*s){ val++; return; }\n    int al = *s-'a';\n    if(next[al]==NULL){\n      next[al] = new ACNode;\n      next[al]->id = pos_size;\n      pos[pos_size++] = next[al];\n    }\n    next[al]->insert(s+1);\n  }\n  \n  ACNode *nextNode(char c){\n    int al = c - 'a';\n    if (next[al]) return next[al];\n    return failure == this ? this : failure->nextNode(c);\n  }\n};\n\nstruct AhoCorasick{\n  ACNode *node;\n  \n  AhoCorasick(){node = new ACNode;}\n  \n  void insert(char *s) {\n    node->insert(s);\n  }\n  \n  void build() {\n    queue<ACNode*> que;\n    que.push(node);\n    node->failure = node;\n    \n    while(que.size()){\n      ACNode *p = que.front();\n      que.pop();\n      \n      for(int i=0;i<26;i++){\n        if(p->next[i]){\n          ACNode *failure = p->failure;\n          while(!failure->next[i] && failure != node){\n            failure = failure->failure;\n          }\n          if (failure->next[i] && failure != p){\n            p->next[i]->failure = failure->next[i];\n            p->next[i]->val += failure->next[i]->val;\n          }else{\n            p->next[i]->failure = node;\n          }\n          que.push(p->next[i]);\n        }\n      }\n    }\n  }\n};\n\n\nstruct DATA{\n  int now;\n  int acpos;\n  bool usessword;\n  \n  const bool operator<(const DATA b) const {\n    if(now != b.now) return now < b.now;\n    if(acpos != b.acpos) return acpos < b.acpos;\n    return usessword < b.usessword;\n  }\n};\n\nint n,m,q;\nstring from[SIZE], to[SIZE], ssword[SIZE];\nint fromid[SIZE], toid[SIZE];\nstring word[SIZE];\n\nbool solve(){\n  map<string, int> dict;\n  vector<int> way[SIZE];\n  \n  scanf(\"%d%d%d\", &n,&m,&q);\n\n  if(n == 0) return false;\n\n  for(int i=0;i<n;i++){\n    cin >> from[i] >> to[i];\n\n    if(dict.find(from[i]) == dict.end()){\n      word[dict.size()] = from[i];\n      dict[from[i]] = dict.size();\n    }\n    if(dict.find(to[i]) == dict.end()){\n      word[dict.size()] = to[i];\n      dict[to[i]] = dict.size();\n    }\n\n    fromid[i] = dict[from[i]];\n    toid[i] = dict[to[i]];\n\n    way[fromid[i]].push_back(toid[i]);\n  }\n\n  AhoCorasick ac;\n  pos[pos_size++] = ac.node;\n  ac.node->id = 0;\n  \n  for(int i=0;i<q;i++){\n    char ssword[50];\n    scanf(\"%s\", ssword);\n    ac.insert(ssword);\n  }\n\n  ac.build();\n\n  for(int i=0;i<dict.size();i++){\n    way[dict.size()].push_back(i);\n  }\n  \n  map<DATA,ll> data[500];\n  DATA initData = {(int)dict.size(), 0, false};\n  data[0][initData] = 1;\n  \n  for(int i=0;i<m;i++){\n    for(auto it: data[i]){\n      auto p = it.first;\n      ll val = it.second;\n\n      for(int j=0;j<way[p.now].size();j++){\n        int l = word[way[p.now][j]].size();\n        if(i + l <= m){\n          auto acpos = pos[p.acpos];\n          int v = 0;\n          for(int k=0;k<l;k++){\n            acpos = acpos->nextNode(word[way[p.now][j]][k]);\n            v += acpos->val;\n          }\n\n          if(v + p.usessword <= 1){\n            DATA newdata = {way[p.now][j], acpos->id, v+p.usessword > 0};\n            data[i+l][newdata] = (data[i+l][newdata] + val)%mod;\n          }\n        }\n      }\n    }\n  }\n\n  ll ans = 0;\n  \n  for(auto it: data[m]){\n    if(it.first.usessword)\n      ans = (it.second + ans)%mod;\n  }\n\n  printf(\"%lld\\n\", ans);\n\n  for(int i=0;i<pos_size;i++){\n    free(pos[i]);\n  }\n  pos_size = 0;\n  \n  return true;\n}\n\nint main(){\n  while(solve());\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\nusing Pib = pair<int, bool>;\nusing Pibi = pair<pair<int, bool>, int>;\nconst int M = 1000000007;\n\nint main() {\n    while (1) {\n        int n, m, k;\n        cin >> n >> m >> k;\n        if (!n) return 0;\n        vector<vector<Pibi>> edge(n);\n        for (int j = 0; j < m; ++j) {\n            int u, v, w;\n            char c;\n            cin >> u >> v >> w >> c;\n            --u;\n            --v;\n            edge[u].push_back(Pibi(Pib(w, c == 'A'), v));\n            edge[v].push_back(Pibi(Pib(w, c == 'A'), u));\n        }\n        int l = -200, r = 200;\n        int ans = -1;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            priority_queue<Pibi, vector<Pibi>, greater<Pibi>> q;\n            vector<bool> vis(n);\n            q.push(Pibi(Pib(0, false), 0));\n            int sum = 0;\n            int ca = 0;\n            int c = 0;\n            while (!q.empty()) {\n                auto p = q.top();\n                q.pop();\n                if (vis[p.second]) continue;\n\n                vis[p.second] = true;\n                sum += p.first.first;\n                ++c;\n                ca += p.first.second;\n                for (auto a : edge[p.second]) {\n                    if (a.first.second)\n                        q.push(Pibi(Pib(a.first.first + mid, a.first.second), a.second));\n                    else\n                        q.push(a);\n                }\n            }\n            if (c != n - 1) {\n                ans = -1;\n                break;\n            }\n            if (ca <= k)\n                ans = sum - mid * k;\n            if (ca == k) {\n                break;\n            }\n            else if (ca < k) {\n                r = mid - 1;\n            }\n            else {\n                l = mid + 1;\n            }\n        }\n        if (r < -190 || 190 < l)\n            ans = -1;\n\n        cout << ans << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nstruct UnionFind{\n\tint par[210],rank[210];\n\tvoid init(){\n\t\tfor(int i=0;i<210;i++){par[i]=i;rank[i]=0;}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]>rank[y])par[y]=x;\n\t\telse{\n\t\t\tpar[x]=y;\n\t\t\tif(rank[x]==rank[y])rank[y]++;\n\t\t}\n\t\treturn;\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nstruct edge{\n\tint from,to,cost;\n\tedge(){}\n\tedge(int from,int to,int cost):from(from),to(to),cost(cost){}\n\tbool operator < (const edge& a) const{\n\t\treturn cost < a.cost;\n\t}\n};\nint n,m,k;\nvector<edge> A,B;\nint cost,use_a_max,use_a_min,use;\nvoid check(int x){\n\tuf.init();\n\tint p = 0,q = 0;\n\tcost = 0;\n\tuse_a_max = 0;\n\tuse = 0;\n\twhile(p<A.size()||q<B.size()){\n\t\tedge e;\n\t\tbool flag = false;\n\t\tif(p==A.size())e = B[q++];\n\t\telse if(q==B.size()){\n\t\t\te = A[p++];\n\t\t\tflag = true;\n\t\t}else{\n\t\t\tif(A[p].cost+x<=B[q].cost){\n\t\t\t\te = A[p++];\n\t\t\t\tflag = true;\n\t\t\t}else e = B[q++];\n\t\t}\n\t\tif(!uf.same(e.from,e.to)){\n\t\t\tuf.unite(e.from,e.to);\n\t\t\tcost += e.cost;\n\t\t\tif(flag)use_a_max++;\n\t\t\tuse++;\n\t\t}\n\t}\n\tuf.init();\n\tp = 0,q = 0;\n\tcost = 0;\n\tuse_a_min = 0;\n\tuse = 0;\n\twhile(p<A.size()||q<B.size()){\n\t\tedge e;\n\t\tbool flag = false;\n\t\tif(p==A.size())e = B[q++];\n\t\telse if(q==B.size()){\n\t\t\te = A[p++];\n\t\t\tflag = true;\n\t\t}else{\n\t\t\tif(A[p].cost+x<B[q].cost){\n\t\t\t\te = A[p++];\n\t\t\t\tflag = true;\n\t\t\t}else e = B[q++];\n\t\t}\n\t\tif(!uf.same(e.from,e.to)){\n\t\t\tuf.unite(e.from,e.to);\n\t\t\tcost += e.cost;\n\t\t\tif(flag)use_a_min++;\n\t\t\tuse++;\n\t\t}\n\t}\n\treturn;\n}\nbool solve(){\n\tcin >> n >> m >> k;\n\tif(n==0&&m==0&&k==0)return false;\n\tA.clear();\n\tB.clear();\n\tfor(int i=0;i<m;i++){\n\t\tint u,v,c;\n\t\tchar l;\n\t\tcin >> u >> v >> c >> l;\n\t\tif(l=='A')A.pb(edge(u,v,c));\n\t\telse B.pb(edge(u,v,c));\n\t}\n\tsort(all(A));\n\tsort(all(B));\n\tfor(int i=-105;i<=105;i++){\n\t\tcheck(i);\n\t\t//cout << i << ' ' << use_a_min << ' ' << use_a_max << ' ' << cost << endl;\n\t\tif(use_a_min<=k&&k<=use_a_max&&use==n-1){\n\t\t\tprintf(\"%d\\n\",cost+i*use_a_min-i*k);\n\t\t\treturn true;\n\t\t}\n\t}\n\tprintf(\"-1\\n\");\n\treturn true;\n}\nint main(){\n\twhile(solve()){}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\ntypedef vector<int> Vint;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct unionfind{\n\tvector<int> data;\n\tvoid use(int n){ data.assign(n, -1); }\n\tbool unionset(int x, int y){\n\t\tx = root(x); y = root(y);\n\t\tif(x != y){\n\t\t\tif(data[y] < data[x])swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findset(int x, int y){ return root(x) == root(y); }\n\tint root(int x){ return (data[x] < 0) ? x : data[x] = root(data[x]); }\n\tint size(int x){ return -data[root(x)]; }\n};\n\nstruct edge{\n  int to, cost;\n  bool isa;\n};\n\nstruct state{\n  int cost, k, nk;\n};\n\nvector<edge> G[200];\nvector< pair<edge, int> > lis;\nunionfind U;\n\nbool mycom(pair<edge, int> a, pair<edge, int> b){\n  if(a.X.cost != b.X.cost)return a.X.cost < b.X.cost;\n\treturn a.X.isa;\n}\n\nstate kruskal(int v, int e, int a, int k){\n  state res; res.cost = 0; res.k = 0; res.nk = 0;\n  int i, j;\n  U.use(v);\n  rep(i, v)rep(j, G[i].size()){\n    if(G[i][j].isa)G[i][j].cost += a;\n    lis.pb(mp(G[i][j], i));\n    if(G[i][j].isa)G[i][j].cost -= a;\n  }\n  sort(all(lis), mycom);\n  for(i = 0;i < e;i++){\n    pair<edge, int> tmp = lis[i];\n    if(!U.findset(tmp.X.to, tmp.Y)){\n\t\t\tif(res.k == k && tmp.X.isa)continue;\n\t\t\tif(res.nk == v - 1 - k && !tmp.X.isa)continue;\n      res.cost += tmp.X.cost;\n      U.unionset(tmp.X.to, tmp.Y);\n      if(tmp.X.isa)res.k++;\n      else res.nk++;\n    }\n  }\n  lis.clear();\n  return res;\n}\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int3(n, m, k);\n    if(!(n | m | k))break;\n\n    rep(i, m){\n      int3(x, y, z); string AB; cin >> AB;\n      --x; --y;\n      G[x].pb((edge){y, z, (AB == \"A\")});\n    }\n\n    int l = -110, r = 119;\n    state lef = kruskal(n, m, l, k);\n    state rig = kruskal(n, m, r, k);\n\n    if(rig.k <= k && k <= lef.k && lef.k + lef.nk == n - 1){\n\t\t\tint res = 31415;\n      for(;l <= r;++l){\n        lef = kruskal(n, m, l, k);\n\t\t\t\tif(lef.k == k){\n\t\t\t\t\tres = min(res, lef.cost - l * k);\n\t\t\t\t}\n      }\n      pri(res);\n    }else pri(-1);\n\n\n//*/\n    rep(i, n)G[i].clear();\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge {\n    int from, to, cost, id;\n    char type;\n};\nbool operator <(const Edge& e1, const Edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par;\npublic:\n    UnionFind(int n) : sz(n) {\n        par = vector<int>(n);\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int root(int a) {\n        if (par[a] == a) return a;\n        return par[a] = root(par[a]);\n    }\n    void unite(int a, int b) {\n        par[root(a)] = par[root(b)];\n    }\n    bool isUnited(int a, int b) {\n        return root(a) == root(b);\n    }\n};\n\nconst int inf = 1e9;\n\nvoid add_edge(vector< vector<Edge> >& G, Edge& e) {\n    G[e.from].push_back({e.from, e.to, e.cost, e.id, e.type});\n    G[e.to].push_back({e.to, e.from, e.cost, e.id, e.type});\n}\nvoid remove_edge(vector< vector<Edge> >& G, Edge& e) {\n    int f = 0;\n    for (int i = 0; i < G[e.from].size(); ++i) {\n        if ( G[e.from][i].id == e.id ) {\n            G[e.from].erase(G[e.from].begin()+i, G[e.from].begin()+i+1);\n            ++f;\n            break;\n        }\n    }\n    for (int i = 0; i < G[e.to].size(); ++i) {\n        if ( G[e.to][i].id == e.id ) {\n            G[e.to].erase(G[e.to].begin()+i, G[e.to].begin()+i+1);\n            ++f;\n            break;\n        }\n    }\n    assert(f == 2);\n}\nEdge dfs(vector< vector<Edge> >& G, int v, int t, char type, int prev, vector<bool>& used) {\n    Edge res = {0, 0, -2, -1, 'X'};\n    if (used[v]) assert(false);\n    used[v] = true;\n    if (v == t) {\n        res.cost++;\n        return res;\n    }\n    for (int i = 0; i < G[v].size(); ++i) {\n        Edge& e = G[v][i];\n        assert(e.from == v);\n        if (e.to != prev) {\n            Edge r = dfs(G, e.to, t, type, v, used);\n            if (r.cost >= -1) {\n                res = max(res, r);\n                if (e.type == type) {\n                    res = max(res, e);\n                }\n            }\n        }\n    }\n    return res;\n}\nEdge calc(vector< vector<Edge> >& G, Edge& e) {\n    vector<bool> used(G.size(), false);\n    Edge ee = dfs(G, e.from, e.to, (e.type == 'A' ? 'B' : 'A'), -1, used);\n    return ee;\n}\nint main() {\n    int n, m, k;\n    while (cin >> n >> m >> k, n || m || k) {\n        vector<Edge> ae, be, edges;\n        for (int i = 0; i < m; ++i) {\n            int u, v, w; char l; cin >> u >> v >> w >> l; --u, --v;\n            if (l == 'A') {\n                ae.push_back({u, v, w, i, l});\n            }\n            else {\n                be.push_back({u, v, w, i, l});\n            }\n            edges.push_back({u, v, w, i, l});\n        }\n        sort(ae.begin(), ae.end());\n        sort(be.begin(), be.end());\n        sort(edges.begin(), edges.end());\n        vector< vector<Edge> > G(n);\n        UnionFind uf(n);\n        int ans = 0;\n        int cnt = 0, acnt = 0, bcnt = 0;\n        set<int> s;\n        for (int i = 0; i < edges.size(); ++i) {\n            if (cnt >= n-1) break;\n            Edge& e = edges[i];\n            if (uf.isUnited(e.from, e.to)) continue;\n            uf.unite(e.from, e.to);\n            ans += e.cost;\n            add_edge(G, e);\n            ++cnt;\n            s.insert(e.id);\n            if (e.type == 'A') ++acnt;\n            else ++bcnt;\n        }\n        if (cnt < n-1) {\n            cout << -1 << endl;\n            continue;\n        }\n        if (acnt > k) {\n            swap(acnt, bcnt);\n            swap(ae, be);\n            k = n - k - 1;\n        }\n        // remove use edges\n        // int s0 = 0;\n        // for (int i = ea.size()-1; i >= 0; --i) {\n        //     if (s.count(ea.id) > 0) {\n        //         s0 = i+1;\n        //         break;\n        //     }\n        // }\n        vector<bool> used(ae.size(), false);\n        for (int i = 0; i < ae.size(); ++i) {\n            if (s.count(ae[i].id) > 0) {\n                used[i] = true;\n            }\n        }\n        assert(k-acnt >= 0);\n        for (int t = 0; t < k-acnt; ++t) {\n            Edge a = {0, 0, -1, -1, 'X'};\n            int b = -1;\n            for (int i = 0; i < ae.size(); ++i) {\n                if (used[i]) continue;\n                // cout << calc(G, ae[i]) << endl;\n                Edge e = calc(G, ae[i]);\n                if (e.cost >= 0 && (b < 0 || ae[i].cost - e.cost <= ae[b].cost - a.cost)) {\n                    a = e;\n                    b = i;\n                }\n            }\n            if (b < 0) {\n                ans = -1;\n                break;\n            }\n            // if (a.cost >= inf) assert(false);\n            // cout << a.cost << \" \" << b << endl;\n            used[b] = true;\n            remove_edge(G, a);\n            add_edge(G, ae[b]);\n            ans += ae[b].cost;\n            ans -= a.cost;\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing Weight=int;\nstruct Edge{\n    int src,dst;\n    Weight weight;\n    int com;\n    Edge(int src,int dst,Weight weight,int com):\n    src(src),dst(dst),weight(weight),com(com){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\ntemplate<typename T>\nstruct UnionFind{\n    vector<T>data;\n    UnionFind(T n):data(n,-1){}\n    bool unite(T x,T y){\n        x=root(x);y=root(y);\n        if(x!=y){\n            if(data[y]<data[x])swap(x,y);\n            data[x]+=data[y];data[y]=x;\n        }\n        return x!=y;\n    }\n    T root(T x){\n        return data[x]<0?x:data[x]=root(data[x]);\n    }\n    bool same(T x,T y){\n        return root(x)==root(y);\n    }\n    T size(T x){\n        return -data[root(x)];\n    }\n};\n\npair<Weight,int>kruskal(const Graph &g,const int h,const int c){\n    int n=g.size();\n    UnionFind<int> uf(n);\n    auto compare = [c](const Edge &a,const Edge &b) {return a.weight != b.weight ? a.weight>b.weight : a.com == c; };\n    priority_queue<Edge,Edges,decltype(compare)>q(compare);\n    for(int i=0;i<n;++i){\n        for(auto e:g[i]){\n            if(i<e.dst){\n                if(e.com==c)q.emplace(e.src,e.dst,e.weight+h,e.com);\n                else q.push(e);\n            }\n        }\n    }\n    int res=0;\n    Weight total=0;\n    Edges forest;\n    while(forest.size()<n-1 && !q.empty()){\n        Edge e=q.top();q.pop();\n        if(uf.unite(e.src,e.dst)){\n            forest.push_back(e);\n            total+=e.weight;\n            if(e.com==c){\n                ++res;\n            }\n        }\n    }\n    //cout<<total<<endl;\n    return pair<Weight, int>(total,res);\n}\n\nint main(){\n    int v,e,k;\n    while (cin >> v >> e >> k, v)\n    {\n        Graph g(v);\n        for (int i = 0; i < e; ++i)\n        {\n            int s, t, w, l;\n            char c;\n            cin >> s >> t >> w >> c;\n            --s;\n            --t;\n            l = c;\n            g[s].emplace_back(s, t, w, l);\n            g[t].emplace_back(t, s, w, l);\n        }\n        int c = 'A';\n        if (kruskal(g, 0, c).second < k){\n            c = 'B';\n        }\n        //cout<<c<<endl;\n        for (int h = 0; h < 1000; ++h)\n        {\n            pair<Weight, int> p = kruskal(g, h, c);\n            if (p.second <= k && c == 'A')\n            {\n                cout << p.first-k*h << endl;\n                break;\n            }\n            else if (p.second <= v - k - 1 && c == 'B')\n            {\n                cout << p.first-(v-k-1)*h << endl;\n                break;\n            }\n            if (h == 999){\n                cout << \"-1\" << endl;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\nusing Pib = pair<int, bool>;\nusing Pibi = pair<pair<int, bool>, int>;\nconst int M = 1000000007;\n\nint main() {\n    while (1) {\n        int n, m, k;\n        cin >> n >> m >> k;\n        if (!n) return 0;\n        vector<vector<Pibi>> edge(n);\n        for (int j = 0; j < m; ++j) {\n            int u, v, w;\n            char c;\n            cin >> u >> v >> w >> c;\n            --u;\n            --v;\n            edge[u].push_back(Pibi(Pib(w, c == 'A'), v));\n            edge[v].push_back(Pibi(Pib(w, c == 'A'), u));\n        }\n        int l = -200, r = 200;\n        int ans = -1;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            priority_queue<Pibi, vector<Pibi>, greater<Pibi>> q;\n            vector<bool> vis(n);\n            q.push(Pibi(Pib(0, false), 0));\n            int sum = 0;\n            int ca = 0;\n            while (!q.empty()) {\n                auto p = q.top();\n                q.pop();\n                if (vis[p.second]) continue;\n\n                vis[p.second] = true;\n                sum += p.first.first;\n                ca += p.first.second;\n                for (auto a : edge[p.second]) {\n                    if (a.first.second)\n                        q.push(Pibi(Pib(a.first.first + mid, a.first.second), a.second));\n                    else\n                        q.push(a);\n                }\n            }\n            if (ca <= k)\n                ans = sum - mid * k;\n            if (ca == k) {\n                break;\n            }\n            else if (ca < k) {\n                r = mid - 1;\n            }\n            else {\n                l = mid + 1;\n            }\n        }\n        if (r < -190 || 190 < l)\n            ans = -1;\n\n        cout << ans << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nstruct UnionFind\n{\n\tvector<int> par;\n\tUnionFind(int n) :par(n, -1) {}\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (par[y] < par[x]) swap(x, y);\n\t\tif (par[x] == par[y]) par[x]--;\n\t\tpar[y] = x;\n\t\tif (find(x) != find(y)) par[find(y)] = x;\n\t}\n\tint count()\n\t{\n\t\tint cnt = 0;\n\t\tREP(i, par.size()) if (par[i] < 0) cnt++;\n\t\treturn cnt;\n\t}\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\ntypedef ld Weight;\nstruct Edge\n{\n\tint from, to; Weight cost; char c;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\n\nconst ld INF = 1e9;\nconst ld EPS = 1e-9;\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m, k;\n\twhile (cin >> n >> m >> k, n)\n\t{\n\t\tEdges es;\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b; ld c; char d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--; b--;\n\t\t\tes.emplace_back(Edge{ a, b, c, d });\n\t\t}\n\t\tint mn = INF, mx = -1;\n\t\tld lb = -INF, ub = INF;\n\t\tREP(lp, 300)\n\t\t{\n\t\t\tld mid = (ub + lb) / 2;\n\t\t\tEdges tmp;\n\t\t\tfor (auto e : es)\n\t\t\t{\n\t\t\t\tif (e.c == 'A') e.cost += mid;\n\t\t\t\ttmp.push_back(e);\n\t\t\t}\n\t\t\tsort(ALL(tmp));\n\t\t\tUnionFind uf(n);\n\t\t\tll cost = 0;\n\t\t\tint cnta = 0;\n\t\t\tfor (auto e : tmp)\n\t\t\t{\n\t\t\t\tif (uf.same(e.from, e.to)) continue;\n\t\t\t\tif (e.c == 'A')\n\t\t\t\t{\n\t\t\t\t\tcnta++;\n\t\t\t\t}\n\t\t\t\tcost += e.cost;\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t}\n\n\t\t\tchmax(mx, cnta);\n\t\t\tchmin(mn, cnta);\n\t\t\tif (lp == 299)\n\t\t\t{\n\t\t\t\tif (uf.count() != 1 || (mx < k || mn > k))\n\t\t\t\t{\n\t\t\t\t\tcout << -1 << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse cout << ll(cost - k * mid + EPS) << endl;\n\t\t\t}\n\t\t\telse if (cnta > k)\n\t\t\t{\n\t\t\t\tlb = mid;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tub = mid;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n, m, k;\n\tstatic int[] u, v;\n\tstatic int[] w;\n\tstatic char[] l;\n\n\tstatic class Edge implements Comparable<Edge> {\n\t\tint src, dst;\n\t\tint cost;\n\t\tchar c;\n\n\t\tpublic Edge(int src, int dst, int cost, char c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.cost = cost;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tpublic int compareTo(Edge o) {\n\t\t\tif (cost != o.cost)\n\t\t\t\treturn Integer.compare(cost, o.cost);\n\t\t\telse {\n\t\t\t\treturn c - o.c;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tk = sc.nextInt();\n\t\t\tif (n == 0 && m == 0 && k == 0)\n\t\t\t\tbreak;\n\t\t\tu = new int[m];\n\t\t\tv = new int[m];\n\t\t\tw = new int[m];\n\t\t\tl = new char[m];\n\t\t\tDJSet ds = new DJSet(n);\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tu[i] = sc.nextInt() - 1;\n\t\t\t\tv[i] = sc.nextInt() - 1;\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\tl[i] = sc.next().toCharArray()[0];\n\t\t\t\tds.setUnion(u[i], v[i]);\n\t\t\t}\n\t\t\tif (ds.upper[0] != -n) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint left = -1 << 20;\n\t\t\tint right = 1 << 20;\n\t\t\twhile (right - left > 1) {\n\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\tint[] ret = kruskal(middle);\n\t\t\t\tif (ret[1] >= k) {\n\t\t\t\t\tleft = middle;\n\t\t\t\t} else {\n\t\t\t\t\tright = middle;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] ret1 = kruskal(right);\n\t\t\tint[] ret2 = kruskal(left);\n\t\t\tif (!(ret1[1] <= k && k <= ret2[1])) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t} else\n\t\t\t\tSystem.out.println(ret2[0]);\n\t\t}\n\t}\n\n\tstatic int[] kruskal(int add) {\n\t\tPriorityQueue<Edge> que = new PriorityQueue<Main.Edge>();\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tEdge e = new Edge(u[i], v[i], w[i], l[i]);\n\t\t\tif (l[i] == 'A')\n\t\t\t\te.cost += add;\n\t\t\tque.add(e);\n\t\t}\n\n\t\tDJSet ds = new DJSet(n);\n\t\tint weight = 0;\n\t\tint cnt = 0;\n\t\twhile (!que.isEmpty()) {\n\t\t\tEdge e = que.poll();\n\t\t\tif (ds.equiv(e.src, e.dst))\n\t\t\t\tcontinue;\n\t\t\tweight += e.cost;\n\t\t\tds.setUnion(e.src, e.dst);\n\t\t\tif (e.c == 'A') {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\treturn new int[] { weight - k * add, cnt };\n\t}\n\n\tstatic class DJSet {\n\t\tint n;\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] > upper[y]) {\n\t\t\t\tint tmp = x;\n\t\t\t\tx = y;\n\t\t\t\ty = tmp;\n\t\t\t}\n\t\t\tupper[x] += upper[y];\n\t\t\tupper[y] = x;\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n, m, k;\n\tstatic int[] u, v;\n\tstatic int[] w;\n\tstatic char[] l;\n\n\tstatic class Edge implements Comparable<Edge> {\n\t\tint src, dst;\n\t\tint cost;\n\t\tchar c;\n\n\t\tpublic Edge(int src, int dst, int cost, char c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.cost = cost;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tpublic int compareTo(Edge o) {\n\t\t\tif (cost != o.cost)\n\t\t\t\treturn Integer.compare(cost, o.cost);\n\t\t\telse {\n\t\t\t\treturn c - o.c;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tk = sc.nextInt();\n\t\t\tif (n == 0 && m == 0 && k == 0)\n\t\t\t\tbreak;\n\t\t\tu = new int[m];\n\t\t\tv = new int[m];\n\t\t\tw = new int[m];\n\t\t\tl = new char[m];\n\t\t\tDJSet ds = new DJSet(n);\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tu[i] = sc.nextInt() - 1;\n\t\t\t\tv[i] = sc.nextInt() - 1;\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\tl[i] = sc.next().toCharArray()[0];\n\t\t\t\tds.setUnion(u[i], v[i]);\n\t\t\t}\n\t\t\tif (ds.upper[ds.root(0)] != -n) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint left = -1 << 20;\n\t\t\tint right = 1 << 20;\n\t\t\twhile (right - left > 1) {\n\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\tint[] ret = kruskal(middle);\n\t\t\t\tif (ret[1] >= k) {\n\t\t\t\t\tleft = middle;\n\t\t\t\t} else {\n\t\t\t\t\tright = middle;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] ret1 = kruskal(right);\n\t\t\tint[] ret2 = kruskal(left);\n\t\t\tif (!(ret1[1] <= k && k <= ret2[1])) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t} else\n\t\t\t\tSystem.out.println(ret2[0]);\n\t\t}\n\t}\n\n\tstatic int[] kruskal(int add) {\n\t\tPriorityQueue<Edge> que = new PriorityQueue<Main.Edge>();\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tEdge e = new Edge(u[i], v[i], w[i], l[i]);\n\t\t\tif (l[i] == 'A')\n\t\t\t\te.cost += add;\n\t\t\tque.add(e);\n\t\t}\n\n\t\tDJSet ds = new DJSet(n);\n\t\tint weight = 0;\n\t\tint cnt = 0;\n\t\twhile (!que.isEmpty()) {\n\t\t\tEdge e = que.poll();\n\t\t\tif (ds.equiv(e.src, e.dst))\n\t\t\t\tcontinue;\n\t\t\tweight += e.cost;\n\t\t\tds.setUnion(e.src, e.dst);\n\t\t\tif (e.c == 'A') {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\treturn new int[] { weight - k * add, cnt };\n\t}\n\n\tstatic class DJSet {\n\t\tint n;\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] > upper[y]) {\n\t\t\t\tint tmp = x;\n\t\t\t\tx = y;\n\t\t\t\ty = tmp;\n\t\t\t}\n\t\t\tupper[x] += upper[y];\n\t\t\tupper[y] = x;\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\nclass UnionFind {\n\tint[] data;\n\tUnionFind(int size) {\n\t\tdata = new int[size];\n\t\tArrays.fill(data, -1);\n\t}\n\tboolean unionSet(int x, int y) {\n\t\tx = root(x); \n\t\ty = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) {\n\t\t\t\tint tmp = x;\n\t\t\t\tx = y;\n\t\t\t\ty = tmp;\n\t\t\t}\n\t\t\tdata[x] += data[y]; \n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tboolean findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n}\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,-1,0,1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic char[] check;\n\tstatic int idx;\n\t\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tif(n == 0 && m == 0 && k == 0) break;\n\t\t\tEdge[] edge = new Edge[m];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt()-1;\n\t\t\t\tint v = sc.nextInt()-1;\n\t\t\t\tint w = sc.nextInt();\n\t\t\t\tint t = sc.next().charAt(0) == 'A'?1:0;\n\t\t\t\tedge[i] = new Edge(w,u,v,t);\n\t\t\t}\n\t\t\tint l = -10000;\n\t\t\tint r = 10000;\n\t\t\tint MAX = INF;\n\t\t\twhile(l <= r) {\n\t\t\t\tint c = (l + r) / 2;\n\t\t\t\tPriorityQueue<Edge> edges = new PriorityQueue<Edge>();\n\t\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\t\tedges.add(new Edge(edge[i].weight + edge[i].type * c,edge[i].from,edge[i].to,edge[i].type));\n\t\t\t\t}\n\t\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\t\tint cost = 0;\n\t\t        int A = 0;\n\t\t\t\tint sum = 1;\n\t\t        while (!edges.isEmpty()) {\n\t\t            Edge e = edges.poll();\n\t\t            if(A == k && e.type == 1) continue;\n\t\t            if (!uf.findSet(e.from, e.to)) {\n\t\t            \tsum++;\n\t\t                cost += e.weight - e.type * c;\n\t\t                A += e.type;\n\t\t                uf.unionSet(e.from, e.to);\n\t\t            }\n\t\t        }\n\t\t        if(A == k && sum == n) {\n\t\t        \tMAX = Math.min(MAX, cost);\n\t\t        \tl++;\n\t\t        }\n\t\t        else if(A < k) {\n\t\t        \tr = c-1;\n\t\t        }\n\t\t        else {\n\t\t        \tl = c+1;\n\t\t        }\n\t\t\t}\n\t\t\tif(MAX == INF) MAX = -1;\n\t\t\tSystem.out.println(MAX);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint weight;\n\t\tint from;\n\t\tint to;\n\t\tint type;\n\t\tEdge(int a, int b, int c,int d) {\n\t\t\tweight = a;\n\t\t\tfrom = b;\n\t\t\tto = c;\n\t\t\ttype = d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\tif(o.weight == this.weight) return this.type - o.type;\n\t\t\treturn this.weight - o.weight;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\n}\n\n\n\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\nclass UnionFind {\n\tint[] data;\n\tUnionFind(int size) {\n\t\tdata = new int[size];\n\t\tArrays.fill(data, -1);\n\t}\n\tboolean unionSet(int x, int y) {\n\t\tx = root(x); \n\t\ty = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) {\n\t\t\t\tint tmp = x;\n\t\t\t\tx = y;\n\t\t\t\ty = tmp;\n\t\t\t}\n\t\t\tdata[x] += data[y]; \n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tboolean findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n}\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,-1,0,1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic char[] check;\n\tstatic int idx;\n\t\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tif(n == 0 && m == 0 && k == 0) break;\n\t\t\tEdge[] edge = new Edge[m];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt()-1;\n\t\t\t\tint v = sc.nextInt()-1;\n\t\t\t\tint w = sc.nextInt();\n\t\t\t\tint t = sc.next().charAt(0) == 'A'?1:0;\n\t\t\t\tedge[i] = new Edge(w,u,v,t);\n\t\t\t}\n\t\t\tint l = -10000;\n\t\t\tint r = 10000;\n\t\t\tint MAX = INF;\n\t\t\twhile(l <= r) {\n\t\t\t\tint c = (l + r) / 2;\n\t\t\t\tPriorityQueue<Edge> edges = new PriorityQueue<Edge>();\n\t\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\t\tedges.add(new Edge(edge[i].weight + edge[i].type * c,edge[i].from,edge[i].to,edge[i].type));\n\t\t\t\t}\n\t\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\t\tint cost = 0;\n\t\t        int A = 0;\n\t\t\t\tint sum = 1;\n\t\t        while (!edges.isEmpty()) {\n\t\t            Edge e = edges.poll();\n\t\t            if(A == k && e.type == 1) continue;\n\t\t            if (!uf.findSet(e.from, e.to)) {\n\t\t            \tsum++;\n\t\t                cost += e.weight - e.type * c;\n\t\t                A += e.type;\n\t\t                uf.unionSet(e.from, e.to);\n\t\t            }\n\t\t        }\n\t\t        if(A == k && sum == n) {\n\t\t        \tMAX = Math.min(MAX, cost);\n\t\t        \tl++;\n\t\t        }\n\t\t        else if(A < k) {\n\t\t        \tr = c-1;\n\t\t        }\n\t\t        else {\n\t\t        \tl = c+1;\n\t\t        }\n\t\t\t}\n\t\t\tif(MAX == INF) MAX = -1;\n\t\t\tSystem.out.println(MAX);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint weight;\n\t\tint from;\n\t\tint to;\n\t\tint type;\n\t\tEdge(int a, int b, int c,int d) {\n\t\t\tweight = a;\n\t\t\tfrom = b;\n\t\t\tto = c;\n\t\t\ttype = d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\tif(o.weight == this.weight) return o.type - this.type;\n\t\t\treturn this.weight - o.weight;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\n}\n\n\n\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\nclass UnionFind {\n\tint[] data;\n\tUnionFind(int size) {\n\t\tdata = new int[size];\n\t\tArrays.fill(data, -1);\n\t}\n\tboolean unionSet(int x, int y) {\n\t\tx = root(x); \n\t\ty = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) {\n\t\t\t\tint tmp = x;\n\t\t\t\tx = y;\n\t\t\t\ty = tmp;\n\t\t\t}\n\t\t\tdata[x] += data[y]; \n\t\t\tdata[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tboolean findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n}\n\npublic class Main {\n\tstatic final int INF = 2 << 28;\n\tstatic final long INF_L = 2L << 60;\n\tstatic final int  MOD = 1000000007;\n\tstatic final long MOD_L = 1000000007L;\n\tstatic final int[] vx_4 = {1,0,-1,0};\n\tstatic final int[] vy_4 = {0,-1,0,1};\n\tstatic final int[] vx_5 = {1,0,-1,0,0};\n\tstatic final int[] vy_5 = {0,1,0,-1,0};\n\tstatic final int[] vx_8 = {1,1,1,0,0,-1,-1,-1};\n\tstatic final int[] vy_8 = {1,0,-1,1,-1,1,0,-1};\n\tstatic final int[] vx_9 = {1,1,1,0,0,0,-1,-1,-1};\n\tstatic final int[] vy_9 = {1,0,-1,1,0,-1,1,0,-1};\n\t\n\tstatic char[] check;\n\tstatic int idx;\n\t\n\tpublic static void main(String[] args) {\t\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint k = sc.nextInt();\n\t\t\tif(n == 0 && m == 0 && k == 0) break;\n\t\t\tEdge[] edge = new Edge[m];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tint u = sc.nextInt()-1;\n\t\t\t\tint v = sc.nextInt()-1;\n\t\t\t\tint w = sc.nextInt();\n\t\t\t\tint t = sc.next().charAt(0) == 'A'?1:0;\n\t\t\t\tedge[i] = new Edge(w,u,v,t);\n\t\t\t}\n\t\t\tint l = -10000;\n\t\t\tint r = 10000;\n\t\t\tint MAX = INF;\n\t\t\twhile(l <= r) {\n\t\t\t\tint c = (l + r) / 2;\n\t\t\t\tPriorityQueue<Edge> edges = new PriorityQueue<Edge>();\n\t\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\t\tedges.add(new Edge(edge[i].weight + edge[i].type * c,edge[i].from,edge[i].to,edge[i].type));\n\t\t\t\t}\n\t\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\t\tint cost = 0;\n\t\t        int A = 0;\n\t\t\t\tint sum = 1;\n\t\t        while (!edges.isEmpty()) {\n\t\t            Edge e = edges.poll();\n\t\t            if(A == k && e.type == 1) continue;\n\t\t            if (!uf.findSet(e.from, e.to)) {\n\t\t            \tsum++;\n\t\t                cost += e.weight - e.type * c;\n\t\t                A += e.type;\n\t\t                uf.unionSet(e.from, e.to);\n\t\t            }\n\t\t        }\n\t\t        if(A == k && sum == n) {\n\t\t        \tMAX = Math.min(MAX, cost);\n\t\t        \tbreak;\n\t\t        }\n\t\t        else if(A < k) {\n\t\t        \tr = c-1;\n\t\t        }\n\t\t        else {\n\t\t        \tl = c+1;\n\t\t        }\n\t\t\t}\n\t\t\tif(MAX == INF) MAX = -1;\n\t\t\tSystem.out.println(MAX);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint weight;\n\t\tint from;\n\t\tint to;\n\t\tint type;\n\t\tEdge(int a, int b, int c,int d) {\n\t\t\tweight = a;\n\t\t\tfrom = b;\n\t\t\tto = c;\n\t\t\ttype = d;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\tif(o.weight == this.weight) return this.type - o.type;\n\t\t\treturn this.weight - o.weight;\n\t\t}\n\t\t\n\t}\n\t\n\t\n\n}\n\n\n\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    public int nextInt() {\n    \tif (!hasNext()) throw new NoSuchElementException();\n        int n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int n, m, k;\n\tstatic int[] u, v;\n\tstatic int[] w;\n\tstatic char[] l;\n\n\tstatic class Edge implements Comparable<Edge> {\n\t\tint src, dst;\n\t\tint cost;\n\t\tchar c;\n\n\t\tpublic Edge(int src, int dst, int cost, char c) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.cost = cost;\n\t\t\tthis.c = c;\n\t\t}\n\n\t\tpublic int compareTo(Edge o) {\n\t\t\tif (cost != o.cost)\n\t\t\t\treturn Integer.compare(cost, o.cost);\n\t\t\telse {\n\t\t\t\treturn c - o.c;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tk = sc.nextInt();\n\t\t\tif (n == 0 && m == 0 && k == 0)\n\t\t\t\tbreak;\n\t\t\tu = new int[m];\n\t\t\tv = new int[m];\n\t\t\tw = new int[m];\n\t\t\tl = new char[m];\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tu[i] = sc.nextInt() - 1;\n\t\t\t\tv[i] = sc.nextInt() - 1;\n\t\t\t\tw[i] = sc.nextInt();\n\t\t\t\tl[i] = sc.next().toCharArray()[0];\n\t\t\t}\n\t\t\tint left = -1 << 20;\n\t\t\tint right = 1 << 20;\n\t\t\twhile (right - left > 1) {\n\t\t\t\tint middle = (right + left) / 2;\n\t\t\t\tint[] ret = kruskal(middle);\n\t\t\t\tif (ret[1] >= k) {\n\t\t\t\t\tleft = middle;\n\t\t\t\t} else {\n\t\t\t\t\tright = middle;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] ret = kruskal(left);\n\t\t\tif (ret[0] > 10000) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t} else\n\t\t\t\tSystem.out.println(ret[0]);\n\t\t}\n\t}\n\n\tstatic int[] kruskal(int add) {\n\t\tPriorityQueue<Edge> que = new PriorityQueue<Main.Edge>();\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tEdge e = new Edge(u[i], v[i], w[i], l[i]);\n\t\t\tif (l[i] == 'A')\n\t\t\t\te.cost += add;\n\t\t\tque.add(e);\n\t\t}\n\n\t\tDJSet ds = new DJSet(n);\n\t\tint weight = 0;\n\t\tint cnt = 0;\n\t\twhile (!que.isEmpty()) {\n\t\t\tEdge e = que.poll();\n\t\t\tif (ds.equiv(e.src, e.dst))\n\t\t\t\tcontinue;\n\t\t\tweight += e.cost;\n\t\t\tds.setUnion(e.src, e.dst);\n\t\t\tif (e.c == 'A') {\n\t\t\t\t++cnt;\n\t\t\t}\n\t\t}\n\t\treturn new int[] { weight - k * add, cnt };\n\t}\n\n\tstatic class DJSet {\n\t\tint n;\n\t\tint[] upper;\n\n\t\tpublic DJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] > upper[y]) {\n\t\t\t\tint tmp = x;\n\t\t\t\tx = y;\n\t\t\t\ty = tmp;\n\t\t\t}\n\t\t\tupper[x] += upper[y];\n\t\t\tupper[y] = x;\n\t\t}\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n//using System.Numerics;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing Number = System.Int64;\nusing KV = System.Collections.Generic.KeyValuePair<int, long>;\nnamespace Program {\n    public class Solver {\n        public void Solve() {\n            for (; ; ) {\n                var n = ri;\n                var m = ri;\n                var k = ri;\n                if (n == 0) return;\n                var f = new int[m];\n                var t = new int[m];\n                var w = new int[m];\n                var c = new int[m];\n                for (int i = 0; i < m; i++) {\n                    f[i] = ri - 1;\n                    t[i] = ri - 1;\n                    w[i] = ri;\n                    c[i] = sc.Char() - 'A';\n                }\n                Func<int, int[]> func = v => {\n                    var cnt = 0;\n                    var sum = 0;\n                    var s = new DisjointSet(n);\n                    foreach (var id in Enumerate(m, x => x).OrderBy(x => c[x] == 0 ? w[x] + v : w[x]).ThenBy(x => c[x])) {\n                        if (s.Unite(f[id], t[id])) {\n                            sum += c[id] == 0 ? w[id] + v : w[id];\n                            cnt += c[id] ^ 1;\n                        }\n                    }\n                    return new int[] { sum, cnt, s.Size(0) };\n                };\n                var l = -300; var r = 300;\n                var ok = true;\n                ok &= func(l)[2] == n;\n                ok &= func(l)[1] >= k;\n                ok &= func(r)[1] <= k;\n                if (!ok) {\n                    Console.WriteLine(-1);\n                    continue;\n                }\n                while (r - l > 1) {\n                    var x = (l + r) / 2;\n                    if (func(x)[1] >= k) l = x;\n                    else r = x;\n                }\n                var ans = func(l)[0] - l * k;\n                Debug.WriteLine(func(l).AsJoinedString());\n                Console.WriteLine(ans);\n\n            }\n        }\n        const long INF = 1L << 60;\n\n        //int[] dx = { -1, 0, 1, 0 };\n        //int[] dy = { 0, 1, 0, -1 };\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n\n        static public void Swap<T>(ref T a, ref T b) {\n            var tmp = a;\n            a = b;\n            b = tmp;\n        }\n    }\n}\n\n#region main\n\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) {\n        return new string(ie.ToArray());\n    }\n\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie.Select(x => x.ToString()).ToArray());\n        //return string.Join(st, ie);\n    }\n\n    static public void Main() {\n        Console.SetOut(new System.IO.StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n\n#endregion\n#region Ex\n\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider {\n            get { return CultureInfo.InvariantCulture; }\n        }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) {\n            str = stream;\n        }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream {\n            get { return isEof; }\n        }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len) {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0) {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n\n        public long Long() {\n            return isEof ? long.MinValue : long.Parse(Scan());\n        }\n\n        public int Integer() {\n            return isEof ? int.MinValue : int.Parse(Scan());\n        }\n\n        public double Double() {\n            return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture);\n        }\n    }\n}\n\n#endregion\n#region DisjointSet\npublic class DisjointSet {\n    int[] par;\n    byte[] rank;\n    public DisjointSet(int n) {\n        par = new int[n];\n        for (int i = 0; i < n; i++)\n            par[i] = -1;\n        rank = new byte[n];\n    }\n    public int this[int id] {\n        get {\n            if ((par[id] < 0)) return id;\n            return par[id] = this[par[id]];\n        }\n    }\n    public bool Unite(int x, int y) {\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (rank[x] < rank[y]) { var z = x; x = y; y = z; }\n        par[x] += par[y];\n        par[y] = x;\n        if (rank[x] == rank[y])\n            rank[x]++;\n        return true;\n    }\n    public int Size(int x) { return -par[this[x]]; }\n    public bool IsUnited(int x, int y) { return this[x] == this[y]; }\n\n}\n#endregion\n"
  },
  {
    "language": "Python",
    "code": "def root(x):\n    if x == parent[x]:\n        return x\n    parent[x] = root(parent[x])\n    return parent[x]\ndef unite(x, y):\n    px = root(x); py = root(y)\n    if px < py:\n        parent[py] = px\n    else:\n        parent[px] = py\nwhile 1:\n    A = []; B = []\n    n, m, k = map(int, raw_input().split())\n    if n == m == k == 0:\n        break\n    parent = range(n)\n    for i in xrange(m):\n        u, v, w, l = raw_input().split()\n        u = int(u)-1; v = int(v)-1; w = int(w)\n        if l is 'A':\n            A.append((w, u, v))\n        else:\n            B.append((w, u, v))\n    A.sort(); B.sort()\n    E = [[] for i in xrange(n)]\n    ans = 0\n    cnt = 0\n    for w, u, v in A:\n        if root(u) != root(v):\n            unite(u, v)\n            ans += w\n            p = [1]\n            E[u].append((v, w, p))\n            E[v].append((u, w, p))\n            cnt += 1\n    if cnt < k:\n        print -1\n        continue\n    used = [0]*len(B)\n    rest = n-k-1\n    for i, (w, u, v) in enumerate(B):\n        if root(u) != root(v):\n            unite(u, v)\n            ans += w\n            used[i] = 1\n            p = [2]\n            E[u].append((v, w, p))\n            E[v].append((u, w, p))\n            rest -= 1\n            cnt += 1\n    if cnt != n-1:\n        print -1\n        continue\n\n    def dfs(v, s, prev):\n        if v == s:\n            return (-1, None)\n        for i, (to, w, can) in enumerate(E[v]):\n            if to == prev or can[0] == 0:\n                continue\n            res = dfs(to, s, v)\n            if res is not None:\n                if can[0] == 1:\n                    return max(res, (w, can))\n                else:\n                    return res\n        return None\n\n    for t in xrange(rest):\n        res = (10**18, None, None)\n        for i, (w, u, v) in enumerate(B):\n            if used[i]:\n                continue\n            rr = dfs(u, v, -1)\n            cost, can = rr\n            if cost != -1:\n                res = min(res, (w - cost, i, can))\n        co, i, can = res\n        if i is None:\n            print -1\n            break\n        ans += co\n        can[0] = 0\n\n        w, u, v = B[i]\n        used[i] = 1\n        p = [2]\n        E[u].append((v, w, p))\n        E[v].append((u, w, p))\n    else:\n        print ans\n        if ans == 272:\n            print A, B"
  },
  {
    "language": "Python",
    "code": "def root(x):\n    if x == parent[x]:\n        return x\n    parent[x] = root(parent[x])\n    return parent[x]\ndef unite(x, y):\n    px = root(x); py = root(y)\n    if px < py:\n        parent[py] = px\n    else:\n        parent[px] = py\nwhile 1:\n    A = []; B = []\n    n, m, k = map(int, raw_input().split())\n    if n == m == k == 0:\n        break\n    parent = range(n)\n    for i in xrange(m):\n        u, v, w, l = raw_input().split()\n        u = int(u)-1; v = int(v)-1; w = int(w)\n        if l is 'A':\n            A.append((w, u, v))\n        else:\n            B.append((w, u, v))\n    A.sort(); B.sort()\n    E = [[] for i in xrange(n)]\n    ans = 0\n    cnt = 0\n    for w, u, v in A:\n        if root(u) != root(v):\n            unite(u, v)\n            ans += w\n            p = [1]\n            E[u].append((v, w, p))\n            E[v].append((u, w, p))\n            cnt += 1\n    if cnt < k:\n        print -1\n        continue\n    used = [0]*len(B)\n    rest = n-k-1\n    for i, (w, u, v) in enumerate(B):\n        if root(u) != root(v):\n            unite(u, v)\n            ans += w\n            used[i] = 1\n            p = [2]\n            E[u].append((v, w, p))\n            E[v].append((u, w, p))\n            rest -= 1\n\n    def dfs(v, s, prev):\n        if v == s:\n            return (-1, None)\n        for i, (to, w, can) in enumerate(E[v]):\n            if to == prev or can[0] == 0:\n                continue\n            res = dfs(to, s, v)\n            if res is not None:\n                if can[0] == 1:\n                    return max(res, (w, can))\n                else:\n                    return res\n        return None\n\n    for t in xrange(rest):\n        res = (10**18, None, None)\n        for i, (w, u, v) in enumerate(B):\n            if used[i]:\n                continue\n            rr = dfs(u, v, -1)\n            cost, can = rr\n            if cost != -1:\n                res = min(res, (w - cost, i, can))\n        co, i, can = res\n        if i is None:\n            print -1\n            break\n        ans += co\n        can[0] = 0\n\n        w, u, v = B[i]\n        used[i] = 1\n        p = [2]\n        E[u].append((v, w, p))\n        E[v].append((u, w, p))\n    else:\n        print ans"
  },
  {
    "language": "Python",
    "code": "def root(x):\n    if x == parent[x]:\n        return x\n    parent[x] = root(parent[x])\n    return parent[x]\ndef unite(x, y):\n    px = root(x); py = root(y)\n    if px < py:\n        parent[py] = px\n    else:\n        parent[px] = py\nwhile 1:\n    A = []; B = []\n    n, m, k = map(int, raw_input().split())\n    if n == m == k == 0:\n        break\n    parent = range(n)\n    for i in xrange(m):\n        u, v, w, l = raw_input().split()\n        u = int(u)-1; v = int(v)-1; w = int(w)\n        if l is 'A':\n            A.append((w, u, v))\n        else:\n            B.append((w, u, v))\n    A.sort(); B.sort()\n    E = [[] for i in xrange(n)]\n    ans = 0\n    cnt = 0\n    for w, u, v in A:\n        if root(u) != root(v):\n            unite(u, v)\n            ans += w\n            p = [1]\n            E[u].append((v, w, p))\n            E[v].append((u, w, p))\n            cnt += 1\n    if cnt < k:\n        print -1\n        continue\n    used = [0]*len(B)\n    for i, (w, u, v) in enumerate(B):\n        if root(u) != root(v):\n            unite(u, v)\n            ans += w\n            used[i] = 1\n            p = [2]\n            E[u].append((v, w, p))\n            E[v].append((u, w, p))\n\n    def dfs(v, s, prev):\n        if v == s:\n            return (-1, None)\n        for i, (to, w, can) in enumerate(E[v]):\n            if to == prev or can[0] == 0:\n                continue\n            res = dfs(to, s, v)\n            if res is not None:\n                if can[0] == 1:\n                    return max(res, (w, can))\n                else:\n                    return res\n        return None\n    for t in xrange(n-k-1):\n        res = (10**18, None, None)\n        for i, (w, u, v) in enumerate(B):\n            if used[i]:\n                continue\n            rr = dfs(u, v, -1)\n            cost, can = rr\n            if cost != -1:\n                res = min(res, (w - cost, i, can))\n        co, i, can = res\n        if i is None:\n            print -1\n            break\n        ans += co\n        can[0] = 0\n\n        w, u, v = B[i]\n        used[i] = 1\n        p = [2]\n        E[u].append((v, w, p))\n        E[v].append((u, w, p))\n    else:\n        print ans"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    N, M, K = map(int, readline().split())\n    if N == 0:\n        return False\n    def root(x):\n        if prt[x] == x:\n            return x\n        prt[x] = y = root(prt[x])\n        return y\n    def unite(x, y):\n        px = root(x); py = root(y)\n        if px == py:\n            return 0\n        if px < py:\n            prt[py] = px\n        else:\n            prt[px] = py\n        return 1\n    E = []\n    for i in range(M):\n        u, v, w, l = readline().strip().split()\n        u = int(u); v = int(v); w = int(w)\n        if l == \"A\":\n            E.append((w, u-1, v-1, 0))\n        else:\n            E.append((w, u-1, v-1, 1))\n    E.sort()\n    U = [0]*M\n    cnt = 0; ec = 0\n    ans = 0\n    *prt, = range(N)\n    for i, (w, u, v, d) in enumerate(E):\n        if unite(u, v):\n            U[i] = 1\n            if d == 0:\n                cnt += 1\n            ec += 1\n            ans += w\n    if ec != N-1:\n        write(\"-1\\n\")\n        return True\n\n\n    if cnt < K:\n        m = 0\n    else:\n        m = 1\n\n    que = deque()\n    used = [0]*N; zeros = [0]*N\n\n    G = [[] for i in range(N)]\n    for i in range(M):\n        if not U[i]:\n            continue\n        w, u, v, d = E[i]\n        if d == m:\n            G[u].append((v, 0, -1))\n            G[v].append((u, 0, -1))\n        else:\n            G[u].append((v, w, i))\n            G[v].append((u, w, i))\n\n    for t in range(abs(K - cnt)):\n        s = 10**18; p = q = -1\n        for i in range(M):\n            if U[i]:\n                continue\n            wi, ui, vi, di = E[i]\n            if di != m:\n                continue\n            que.append((ui, 0, -1))\n            used[:] = zeros\n            used[ui] = 1\n            while que:\n                u, r, j = que.popleft()\n                if u == vi:\n                    wj = r\n                    break\n                for v, w, k in G[u]:\n                    if used[v]:\n                        continue\n                    if k != -1 and r < w:\n                        que.append((v, w, k))\n                    else:\n                        que.append((v, r, j))\n                    used[v] = 1\n            que.clear()\n            if wi - wj < s and j != -1:\n                s = wi - wj\n                p = i; q = j\n        if p == -1:\n            write(\"-1\\n\")\n            return True\n        wq, uq, vq, dq = E[q]\n        g = G[uq]\n        for i in range(len(g)):\n            if g[i][0] == vq:\n                g.pop(i)\n                break\n        g = G[vq]\n        for i in range(len(g)):\n            if g[i][0] == uq:\n                g.pop(i)\n                break\n        wp, up, vp, dp = E[p]\n        G[up].append((vp, 0, -1))\n        G[vp].append((up, 0, -1))\n        U[p] = 1; U[q] = 0\n        ans += s\n    write(\"%d\\n\" % ans)\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Python",
    "code": "def root(x):\n    if x == parent[x]:\n        return x\n    parent[x] = root(parent[x])\n    return parent[x]\ndef unite(x, y):\n    px = root(x); py = root(y)\n    if px < py:\n        parent[py] = px\n    else:\n        parent[px] = py\nwhile 1:\n    n, m, k = map(int, raw_input().split())\n    if n == m == k == 0:\n        break\n    A = []; B = []\n    for i in xrange(m):\n        u, v, w, l = raw_input().split()\n        [B, A][l is 'A'].append((int(w), int(u)-1, int(v)-1))\n    A.sort(); B.sort()\n\n    def check(e):\n        w, u, v = e\n        if root(u) != root(v):\n            unite(u, v)\n            return w\n        return 0\n\n    def solve(mid, la, lb):\n        global parent\n        parent = range(n)\n\n        ia = ib = ca = cb = su = 0\n        while ca < la and cb < lb and ia < len(A) and ib < len(B):\n            if A[ia][0] + mid <= B[ib][0]:\n                res = check(A[ia]); ia += 1\n                if res: ca += 1\n            else:\n                res = check(B[ib]); ib += 1\n                if res: cb += 1\n            su += res\n        while ca < la and ia < len(A):\n            res = check(A[ia]); ia += 1\n            if res: ca += 1\n            su += res\n        while cb < lb and ib < len(B):\n            res = check(B[ib]); ib += 1\n            if res: cb += 1\n            su += res\n        return (-1, ca) if ca + cb < n-1 else (su, ca)\n\n    left = -100; right = 101\n    while left+1 < right:\n        mid = (left + right) / 2\n        su, ca = solve(mid, len(A), len(B))\n\n        if k <= ca:\n            left = mid\n        else:\n            right = mid\n    print solve(mid, k, n-k-1)[0]"
  },
  {
    "language": "Rust",
    "code": "use std::hash::Hash;\nuse std::collections::hash_set::Iter;\nuse std::rc::Rc;\nuse std::ops::DivAssign;\nuse std::ops::MulAssign;\nuse std::ops::SubAssign;\nuse std::collections::BinaryHeap;\nuse std::str::FromStr;\nuse std::collections::HashSet;\nuse std::collections::BTreeMap;\nuse std::fmt::Display;\nuse std::ops::Neg;\nuse std::ops::Div;\nuse std::ops::Mul;\nuse std::ops::Add;\nuse std::ops::{AddAssign, Sub};\nuse std::cmp::max;\nuse std::collections::VecDeque;\nuse std::cmp::min;\nuse std::collections::{HashMap, BTreeSet};\nuse std::cmp::Ordering;\nuse std::fmt::Debug;\n\nfn read_line() -> String {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n    buffer.trim().to_owned()\n}\nfn read_lines<T: std::str::FromStr>(count: usize) -> Vec<T> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(buffer.trim().parse().ok().expect(\"Can't Parse\"));\n        buffer.clear();\n    }\n    vec\n}\nfn read_tabulate<R, T: Fn(&str)->R> (count: usize, transformer: T) -> Vec<R> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(transformer(buffer.trim()));\n        buffer.clear();\n    }\n    vec\n}\nfn read_value<T: std::str::FromStr>() -> T {\n    read_line().trim().parse().ok().unwrap()\n}\nfn read_values<T: std::str::FromStr>() -> Vec<T> {\n    read_line().trim().split_whitespace().map(|x| x.parse().ok().expect(\"Can't Parse\")).collect::<Vec<T>>()\n}\nmacro_rules! freeze {\n    ($($id:ident), *) => {\n        $(let $id = $id;)*\n    };\n}\nmacro_rules! read_map {\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n}\nmacro_rules! read {\n    (mut $ident: ident: String) => {\n        let mut $ident = read_value::<String>();\n    };\n    ($ident: ident: String) => {\n        let $ident = read_value::<String>();\n    };\n    (mut $ident: ident: [$ty:ty]) => {\n        let mut $ident = read_values::<$ty>();\n    };\n    ($ident: ident: [$ty:ty]) => {\n        let $ident = read_values::<$ty>();\n    };\n    (mut $ident: ident: [[$ty:ty]; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    ($ident: ident: [[$ty:ty]; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$ty:ty; $size:expr]) => {\n        let mut $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$ty:ty; $size:expr]) => {\n        let $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    ($($token: tt)*) => {\n        let mut iter = read_values::<String>().into_iter();\n        read_from_iter!(iter; $($token)*);\n    };\n}\nmacro_rules! read_from_iter {\n    ($iter:expr; mut $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; mut $ident:ident:$ty:ty) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter:expr; $ident:ident:$ty:ty) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter: expr; ) => {};\n}\nstruct KeyValue<K, V> {\n    key: K,\n    value: V\n}\nimpl <K: PartialOrd, V> PartialEq for KeyValue<K, V> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key.eq(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Eq for KeyValue<K, V> {}\nimpl <K: PartialOrd, V> PartialOrd for KeyValue<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Ord for KeyValue<K, V> {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.key.partial_cmp(&other.key).ok_or(\"Can't Compare\").unwrap()\n    }\n}\n#[derive(Eq, PartialEq)]\nstruct Rev<T: Ord>(T);\nimpl <T: std::cmp::Ord> PartialOrd for Rev<T> {\n    fn partial_cmp(&self, rhs: &Rev<T>) -> std::option::Option<std::cmp::Ordering> { \n        rhs.0.partial_cmp(&self.0)\n    }\n}\nimpl <T: Ord> Ord for Rev<T> {\n    fn cmp(&self, rhs: &Self) -> std::cmp::Ordering { \n        rhs.0.cmp(&self.0)\n    }\n}\n#[derive(Copy, Clone)]\nstruct Bridge {\n    a: usize, b: usize, cost: i32, provider: usize\n}\nimpl Bridge {\n    fn opposit(&self, side: usize) -> usize {\n        assert_eq!(true, self.a == side || self.b == side);\n        if self.a == side {\n            self.b\n        }else {\n            self.a\n        }\n    }\n}\n#[derive(Clone, Debug)]\nstruct UnionFind {\n    parent: Vec<i32>\n}\nimpl UnionFind {\n    fn new(size: usize) -> UnionFind {\n        UnionFind{parent: vec![-1; size]}\n    }\n    fn find(&mut self, a: usize) -> usize {\n        if self.parent[a] < 0 {\n            a\n        }else {\n            let p = self.parent[a] as usize;\n            let root = self.find(p);\n            self.parent[a] = root as i32;\n            root\n        }\n    }\n    fn same(&mut self, a: usize, b: usize) -> bool {\n        self.find(a) == self.find(b)\n    }\n    fn unite(&mut self, mut a: usize, mut b: usize) -> bool {\n        a = self.find(a);\n        b = self.find(b);\n        if a == b {return false;}\n        if self.parent[a] < self.parent[b] {\n            self.parent[a] += self.parent[b];\n            self.parent[b] = a as i32;\n        }else {\n            self.parent[b] += self.parent[a];\n            self.parent[a] = b as i32;\n        }\n        true\n    }\n}\nfn max_count_of_provider(size: usize, target_provider: usize, edges: &Vec<Bridge>) -> usize {\n    let mut uft = UnionFind::new(size);\n    let mut count = 0;\n    let mut provider_count = 0;\n    for e in edges {\n        if e.provider == target_provider {\n            if uft.unite(e.a, e.b) {\n                count += 1;\n                provider_count += 1;\n            }\n        }\n    }\n    for e in edges {\n        if e.provider != target_provider {\n            if uft.unite(e.a, e.b) {\n                count += 1;\n            }\n        }\n    }\n    if count + 1 == size { provider_count } else {0}\n}\nfn make_min_cost_tree(size: usize, edges: &Vec<Bridge>, bias: i32) -> Option<(usize, i32)> {\n    let mut heap = BinaryHeap::new();\n    let mut uft = UnionFind::new(size);\n    let mut count = 0;\n    let mut provider0_count = 0;\n    let mut sum_cost = 0;\n    for i in 0 .. edges.len(){\n        let e = edges[i];\n        if e.provider == 0 {\n            heap.push(Rev(KeyValue{key: ((e.cost + bias) << 1) + 1, value: i}));\n        }else {\n            heap.push(Rev(KeyValue{key: e.cost << 1, value: i}));\n        }\n    }\n    while let Some(Rev(KeyValue{key: cost, value: i})) = heap.pop() {\n        let e = edges[i];\n        if uft.unite(e.a, e.b) {\n            count += 1;\n            if e.provider == 0 {\n                provider0_count += 1;\n            }\n            sum_cost += cost >> 1;\n        } \n    }\n    if count + 1 == size {\n        Some((provider0_count, sum_cost))\n    }else {\n        None\n    }\n}\nfn calc_min_cost(size: usize, k: usize, edges: Vec<Bridge>) -> Option<i32> {\n    if max_count_of_provider(size, 0, &edges) < k || max_count_of_provider(size, 1, &edges) < size - 1 - k{ return  None; }\n    let mut min = size as i32 * -200;\n    let mut max = size as i32 * 200;\n    while min < max {\n        let mid = (min + max) >> 1;\n        let count = if let Some((count, _)) = make_min_cost_tree(size, &edges, mid) {count} else {return None};\n        if count < k {\n            max = mid;\n        }else {\n            min = mid + 1;\n        }\n    }\n    if let Some((_, cost)) = make_min_cost_tree(size, &edges, max) {\n        Some(cost - max * k as i32)\n    }else {\n        None\n    }\n}\nfn main() {\n    loop {\n        read!(n: usize, m: usize, k: usize);\n        if n == 0 && m == 0 && k == 0 {break;}\n        read_map!(edges: [{\n            read!(u: usize, v: usize, w: i32, l: String);\n            Bridge{a: u - 1, b: v - 1, cost: w, provider: if l == \"A\" {0}else {1}}\n        }; m]);\n        println!(\"{}\", calc_min_cost(n, k, edges).unwrap_or(-1));\n    }\n}\n\n"
  }
]