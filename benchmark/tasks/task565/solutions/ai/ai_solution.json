[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_VERTICES 1000\n\nenum Color { WHITE, GRAY, BLACK };\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nint time;\nint discovery_time[MAX_VERTICES];\nint finish_time[MAX_VERTICES];\nenum Color color[MAX_VERTICES];\nNode* graph[MAX_VERTICES];\n\nNode* create_node(int vertex) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->vertex = vertex;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid add_edge(int src, int dest) {\n    Node* newNode = create_node(dest);\n    newNode->next = graph[src];\n    graph[src] = newNode;\n}\n\nvoid dfs_visit(int u) {\n    color[u] = GRAY;\n    time++;\n    discovery_time[u] = time;\n\n    for (Node* v = graph[u]; v != NULL; v = v->next) {\n        if (color[v->vertex] == WHITE) {\n            dfs_visit(v->vertex);\n        }\n    }\n\n    color[u] = BLACK;\n    time++;\n    finish_time[u] = time;\n}\n\nvoid dfs(int vertices) {\n    for (int i = 0; i < vertices; i++) {\n        color[i] = WHITE;\n        discovery_time[i] = 0;\n        finish_time[i] = 0;\n    }\n\n    time = 0;\n\n    for (int i = 0; i < vertices; i++) {\n        if (color[i] == WHITE) {\n            dfs_visit(i);\n        }\n    }\n}\n\nint main() {\n    int vertices, edges;\n    scanf(\"%d %d\", &vertices, &edges);\n\n    for (int i = 0; i < edges; i++) {\n        int src, dest;\n        scanf(\"%d %d\", &src, &dest);\n        add_edge(src, dest);\n    }\n\n    dfs(vertices);\n\n    for (int i = 0; i < vertices; i++) {\n        printf(\"%d %d %d\\n\", i, discovery_time[i], finish_time[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:09:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nNode* createNode(int v) {\n    Node* newNode = malloc(sizeof(Node));\n    newNode->vertex = v;\n    newNode->next = NULL;\n    return newNode;\n}\n\nvoid addEdge(Node** adjList, int src, int dest) {\n    Node* newNode = createNode(dest);\n    newNode->next = adjList[src];\n    adjList[src] = newNode;\n}\n\nvoid DFSVisit(Node** adjList, int u, int* visited, int* discovery, int* finish, int* time) {\n    visited[u] = 1;\n    discovery[u] = ++(*time);\n\n    Node* temp = adjList[u];\n    while (temp != NULL) {\n        int v = temp->vertex;\n        if (!visited[v]) {\n            DFSVisit(adjList, v, visited, discovery, finish, time);\n        }\n        temp = temp->next;\n    }\n\n    finish[u] = ++(*time);\n}\n\nvoid DFS(Node** adjList, int vertices, int* discovery, int* finish) {\n    int* visited = calloc(vertices, sizeof(int));\n    int time = 0;\n\n    for (int u = 0; u < vertices; u++) {\n        if (!visited[u]) {\n            DFSVisit(adjList, u, visited, discovery, finish, &time);\n        }\n    }\n\n    free(visited);\n}\n\nint main() {\n    int vertices;\n    scanf(\"%d\", &vertices);\n\n    Node** adjList = malloc(vertices * sizeof(Node*));\n    for (int i = 0; i < vertices; i++) {\n        adjList[i] = NULL;\n    }\n\n    for (int i = 0; i < vertices; i++) {\n        int adjCount;\n        scanf(\"%d\", &adjCount);\n        for (int j = 0; j < adjCount; j++) {\n            int dest;\n            scanf(\"%d\", &dest);\n            addEdge(adjList, i, dest);\n        }\n    }\n\n    int* discovery = malloc(vertices * sizeof(int));\n    int* finish = malloc(vertices * sizeof(int));\n\n    DFS(adjList, vertices, discovery, finish);\n\n    for (int i = 0; i < vertices; i++) {\n        printf(\"%d %d %d\\n\", i, discovery[i], finish[i]);\n    }\n\n    for (int i = 0; i < vertices; i++) {\n        Node* temp = adjList[i];\n        while (temp != NULL) {\n            Node* toFree = temp;\n            temp = temp->next;\n            free(toFree);\n        }\n    }\n    free(adjList);\n    free(discovery);\n    free(finish);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:09:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> discovery;\nvector<int> finish;\nvector<bool> visited;\nint time_stamp;\n\nvoid dfs(int u) {\n    discovery[u] = ++time_stamp;\n    visited[u] = true;\n    for (int v : adj[u]) {\n        if (!visited[v]) {\n            dfs(v);\n        }\n    }\n    finish[u] = ++time_stamp;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    adj.resize(n);\n    discovery.resize(n);\n    finish.resize(n);\n    visited.assign(n, false);\n    time_stamp = 0;\n\n    for (int i = 0; i < n; ++i) {\n        int u, k;\n        cin >> u >> k;\n        u--; // assuming input is 1-based\n        vector<int> neighbors(k);\n        for (int j = 0; j < k; ++j) {\n            int v;\n            cin >> v;\n            neighbors[j] = v - 1; // assuming input is 1-based\n        }\n        sort(neighbors.begin(), neighbors.end());\n        adj[u] = neighbors;\n    }\n\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            dfs(i);\n        }\n    }\n\n    for (int i = 0; i < n; ++i) {\n        cout << i + 1 << \" \" << discovery[i] << \" \" << finish[i] << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:09:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DFS {\n    private static int time = 0;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int vertices = scanner.nextInt();\n        scanner.nextLine(); // consume newline\n\n        List<List<Integer>> adjList = new ArrayList<>();\n        for (int i = 0; i < vertices; i++) {\n            String[] parts = scanner.nextLine().split(\" \");\n            List<Integer> neighbors = new ArrayList<>();\n            for (String part : parts) {\n                if (!part.isEmpty()) {\n                    neighbors.add(Integer.parseInt(part));\n                }\n            }\n            adjList.add(neighbors);\n        }\n\n        int[] discovery = new int[vertices];\n        int[] finish = new int[vertices];\n        boolean[] visited = new boolean[vertices];\n\n        for (int i = 0; i < vertices; i++) {\n            if (!visited[i]) {\n                dfs(i, adjList, visited, discovery, finish);\n            }\n        }\n\n        for (int i = 0; i < vertices; i++) {\n            System.out.println((i + 1) + \" \" + discovery[i] + \" \" + finish[i]);\n        }\n    }\n\n    private static void dfs(int vertex, List<List<Integer>> adjList, boolean[] visited, int[] discovery, int[] finish) {\n        time++;\n        discovery[vertex] = time;\n        visited[vertex] = true;\n\n        List<Integer> neighbors = adjList.get(vertex);\n        Collections.sort(neighbors);\n        for (int neighbor : neighbors) {\n            if (!visited[neighbor - 1]) {\n                dfs(neighbor - 1, adjList, visited, discovery, finish);\n            }\n        }\n\n        time++;\n        finish[vertex] = time;\n    }\n}",
    "timestamp": "2025-08-05 22:10:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DFS {\n    private int vertices;\n    private List<List<Integer>> adjacencyList;\n    private boolean[] visited;\n    private int[] discoveryTime;\n    private int[] finishTime;\n    private int time;\n\n    public DFS(int vertices) {\n        this.vertices = vertices;\n        this.adjacencyList = new ArrayList<>(vertices);\n        for (int i = 0; i < vertices; i++) {\n            adjacencyList.add(new ArrayList<>());\n        }\n        this.visited = new boolean[vertices];\n        this.discoveryTime = new int[vertices];\n        this.finishTime = new int[vertices];\n        this.time = 0;\n    }\n\n    public void addEdge(int source, int destination) {\n        adjacencyList.get(source).add(destination);\n    }\n\n    public void performDFS() {\n        for (int i = 0; i < vertices; i++) {\n            if (!visited[i]) {\n                dfsVisit(i);\n            }\n        }\n    }\n\n    private void dfsVisit(int vertex) {\n        visited[vertex] = true;\n        time++;\n        discoveryTime[vertex] = time;\n\n        List<Integer> neighbors = adjacencyList.get(vertex);\n        Collections.sort(neighbors);\n\n        for (int neighbor : neighbors) {\n            if (!visited[neighbor]) {\n                dfsVisit(neighbor);\n            }\n        }\n\n        time++;\n        finishTime[vertex] = time;\n    }\n\n    public void printTimestamps() {\n        for (int i = 0; i < vertices; i++) {\n            System.out.println(i + \" \" + discoveryTime[i] + \" \" + finishTime[i]);\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int vertices = scanner.nextInt();\n        DFS graph = new DFS(vertices);\n\n        for (int i = 0; i < vertices; i++) {\n            int neighbors = scanner.nextInt();\n            for (int j = 0; j < neighbors; j++) {\n                int destination = scanner.nextInt();\n                graph.addEdge(i, destination);\n            }\n        }\n\n        graph.performDFS();\n        graph.printTimestamps();\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:10:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Graph {\nprivate:\n    int V;\n    vector<vector<int>> adj;\n    vector<bool> visited;\n    vector<int> discovery;\n    vector<int> finish;\n    int timestamp;\n\n    void dfs_util(int v) {\n        visited[v] = true;\n        discovery[v] = timestamp++;\n\n        vector<int> unvisited_neighbors;\n        for (int neighbor : adj[v]) {\n            if (!visited[neighbor]) {\n                unvisited_neighbors.push_back(neighbor);\n            }\n        }\n\n        sort(unvisited_neighbors.begin(), unvisited_neighbors.end());\n\n        for (int neighbor : unvisited_neighbors) {\n            dfs_util(neighbor);\n        }\n\n        finish[v] = timestamp++;\n    }\n\npublic:\n    Graph(int vertices) {\n        V = vertices;\n        adj.resize(V);\n        visited.resize(V, false);\n        discovery.resize(V, 0);\n        finish.resize(V, 0);\n        timestamp = 1;\n    }\n\n    void addEdge(int v, int w) {\n        adj[v].push_back(w);\n    }\n\n    void dfs() {\n        for (int i = 0; i < V; i++) {\n            if (!visited[i]) {\n                dfs_util(i);\n            }\n        }\n\n        for (int i = 0; i < V; i++) {\n            cout << i << \" \" << discovery[i] << \" \" << finish[i] << endl;\n        }\n    }\n};\n\nint main() {\n    int V, E;\n    cin >> V >> E;\n\n    Graph g(V);\n\n    for (int i = 0; i < E; i++) {\n        int u, v;\n        cin >> u >> v;\n        g.addEdge(u, v);\n    }\n\n    g.dfs();\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:10:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def dfs_visit(graph, vertex, discovery_time, finishing_time, time, visited):\n    time[0] += 1\n    discovery_time[vertex] = time[0]\n    visited[vertex] = True\n    \n    for neighbor in sorted(graph[vertex]):\n        if not visited[neighbor]:\n            dfs_visit(graph, neighbor, discovery_time, finishing_time, time, visited)\n\n    time[0] += 1\n    finishing_time[vertex] = time[0]\n\ndef depth_first_search(graph, vertices_count):\n    discovery_time = [-1] * vertices_count\n    finishing_time = [-1] * vertices_count\n    visited = [False] * vertices_count\n    time = [0]\n\n    for vertex in range(vertices_count):\n        if not visited[vertex]:\n            dfs_visit(graph, vertex, discovery_time, finishing_time, time, visited)\n    \n    result = [(i, discovery_time[i], finishing_time[i]) for i in range(vertices_count)]\n    result.sort()\n    \n    for vertex_id, discovery, finish in result:\n        print(f\"Vertex {vertex_id}: Discovery Time={discovery}, Finishing Time={finish}\")\n\nif __name__ == \"__main__\":\n    vertices_count = int(input())\n    graph = {i: [] for i in range(vertices_count)}\n\n    for _ in range(vertices_count):\n        data = list(map(int, input().split()))\n        vertex = data[0]\n        graph[vertex] = data[1:]\n    \n    depth_first_search(graph, vertices_count)",
    "timestamp": "2025-08-13 09:14:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class DirectedGraphDFS {\n    private static int time;\n    private static int[] discovery;\n    private static int[] finishing;\n    private static boolean[] visited;\n    private static Map<Integer, List<Integer>> graph;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int vertices = scanner.nextInt();\n        graph = new HashMap<>();\n        \n        for (int i = 0; i < vertices; i++) {\n            graph.put(i, new ArrayList<>());\n        }\n\n        for (int i = 0; i < vertices; i++) {\n            int vertex = scanner.nextInt();\n            int edgesCount = scanner.nextInt();\n            for (int j = 0; j < edgesCount; j++) {\n                int adjacent = scanner.nextInt();\n                graph.get(vertex).add(adjacent);\n            }\n        }\n\n        discovery = new int[vertices];\n        finishing = new int[vertices];\n        visited = new boolean[vertices];\n        time = 0;\n\n        for (int i = 0; i < vertices; i++) {\n            if (!visited[i]) {\n                dfs(i);\n            }\n        }\n\n        List<Integer> sortedVertices = new ArrayList<>(graph.keySet());\n        Collections.sort(sortedVertices);\n        \n        for (int vertex : sortedVertices) {\n            System.out.println(\"Vertex: \" + vertex + \", Discovery Time: \" + discovery[vertex] + \", Finishing Time: \" + finishing[vertex]);\n        }\n    }\n\n    private static void dfs(int vertex) {\n        visited[vertex] = true;\n        discovery[vertex] = ++time;\n\n        List<Integer> neighbors = graph.get(vertex);\n        Collections.sort(neighbors);\n\n        for (int neighbor : neighbors) {\n            if (!visited[neighbor]) {\n                dfs(neighbor);\n            }\n        }\n        \n        finishing[vertex] = ++time;\n    }\n}",
    "timestamp": "2025-08-13 09:14:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_VERTICES 100\n\ntypedef struct {\n    int vertices[MAX_VERTICES];\n    int size;\n} AdjList;\n\ntypedef struct {\n    AdjList adj[MAX_VERTICES];\n    int numVertices;\n} Graph;\n\nint discovery[MAX_VERTICES];\nint finish[MAX_VERTICES];\nint time;\n\nvoid dfs_visit(Graph *g, int v, int *visited) {\n    visited[v] = 1;\n    discovery[v] = ++time;\n    for (int i = 0; i < g->adj[v].size; i++) {\n        int u = g->adj[v].vertices[i];\n        if (!visited[u]) {\n            dfs_visit(g, u, visited);\n        }\n    }\n    finish[v] = ++time;\n}\n\nvoid dfs(Graph *g) {\n    int visited[MAX_VERTICES] = {0};\n    time = 0;\n\n    for (int i = 0; i < g->numVertices; i++) {\n        if (!visited[i]) {\n            dfs_visit(g, i, visited);\n        }\n    }\n}\n\nint main() {\n    Graph graph;\n    int numVertices;\n    \n    scanf(\"%d\", &numVertices);\n    graph.numVertices = numVertices;\n\n    for (int i = 0; i < numVertices; i++) {\n        graph.adj[i].size = 0;\n        int vertex, degree;\n        scanf(\"%d %d\", &vertex, &degree);\n        \n        for (int j = 0; j < degree; j++) {\n            int adjacent;\n            scanf(\"%d\", &adjacent);\n            graph.adj[vertex].vertices[graph.adj[vertex].size++] = adjacent;\n        }\n    }\n\n    dfs(&graph);\n\n    for (int i = 0; i < numVertices; i++) {\n        printf(\"Vertex %d: Discovery = %d, Finish = %d\\n\", i, discovery[i], finish[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 09:14:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Graph:\n    def __init__(self, vertices):\n        self.V = vertices\n        self.graph = {v: [] for v in range(1, vertices + 1)}\n        self.time = 0\n        self.discovery = {}\n        self.finish = {}\n        self.visited = {v: False for v in range(1, vertices + 1)}\n\n    def add_edge(self, u, v):\n        self.graph[u].append(v)\n\n    def dfs(self):\n        self.time = 0\n        for v in sorted(self.graph.keys()):\n            if not self.visited[v]:\n                self.dfs_visit(v)\n\n    def dfs_visit(self, u):\n        self.visited[u] = True\n        self.time += 1\n        self.discovery[u] = self.time\n\n        for v in sorted(self.graph[u]):\n            if not self.visited[v]:\n                self.dfs_visit(v)\n\n        self.time += 1\n        self.finish[u] = self.time\n\ndef main():\n    V = int(input())\n    graph = Graph(V)\n\n    for v in range(1, V + 1):\n        inputs = list(map(int, input().split()))\n        vertex = inputs[0]\n        edges = inputs[1:]\n        for edge in edges:\n            graph.add_edge(vertex, edge)\n\n    graph.dfs()\n\n    for v in sorted(graph.graph.keys()):\n        print(f\"{v} {graph.discovery[v]} {graph.finish[v]}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 09:15:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def dfs(u, adj, visited, discovery, finish, time):\n    time[0] += 1\n    discovery[u] = time[0]\n    visited[u] = True\n    for v in sorted(adj[u]):\n        if not visited[v]:\n            dfs(v, adj, visited, discovery, finish, time)\n    time[0] += 1\n    finish[u] = time[0]\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    n = int(data[idx])\n    idx += 1\n    adj = [[] for _ in range(n)]\n    for u in range(n):\n        parts = list(map(int, data[idx:idx+1+int(data[idx])]))\n        idx += 1 + int(data[idx])\n        adj[u] = parts[1:]\n    \n    visited = [False] * n\n    discovery = [0] * n\n    finish = [0] * n\n    time = [0]\n    \n    for u in range(n):\n        if not visited[u]:\n            dfs(u, adj, visited, discovery, finish, time)\n    \n    for u in range(n):\n        print(u + 1, discovery[u], finish[u])\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 09:15:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nvoid dfs(int v, const map<int, vector<int>>& adjList, vector<int>& visited,\n         vector<int>& discoveryTime, vector<int>& finishTime, int& time) {\n    visited[v] = true;\n    discoveryTime[v] = ++time;\n\n    if (adjList.find(v) != adjList.end()) {\n        for (int u : adjList.at(v)) {\n            if (!visited[u]) {\n                dfs(u, adjList, visited, discoveryTime, finishTime, time);\n            }\n        }\n    }\n\n    finishTime[v] = ++time;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    map<int, vector<int>> adjList;\n    vector<int> vertices;\n\n    for (int i = 0; i < n; ++i) {\n        int u, m;\n        cin >> u >> m;\n        vertices.push_back(u);\n        for (int j = 0; j < m; ++j) {\n            int v;\n            cin >> v;\n            adjList[u].push_back(v);\n        }\n        sort(adjList[u].begin(), adjList[u].end());\n    }\n\n    sort(vertices.begin(), vertices.end());\n\n    vector<int> visited(n + 1, false);\n    vector<int> discoveryTime(n + 1, 0);\n    vector<int> finishTime(n + 1, 0);\n    \n    int time = 0;\n\n    for (int v : vertices) {\n        if (!visited[v]) {\n            dfs(v, adjList, visited, discoveryTime, finishTime, time);\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        cout << \"Vertex \" << i << \": Discovery Time = \" << discoveryTime[i]\n             << \", Finishing Time = \" << finishTime[i] << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:50:23"
  }
]