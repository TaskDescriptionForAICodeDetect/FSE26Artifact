[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 10000\n#define MAX_M 100000\n\ntypedef struct {\n    int u, v, w;\n} Edge;\n\nint parent[MAX_N + 1];\nEdge edges[MAX_M];\n\nint find(int u) {\n    if (parent[u] != u) {\n        parent[u] = find(parent[u]);\n    }\n    return parent[u];\n}\n\nvoid union_set(int u, int v) {\n    int root_u = find(u);\n    int root_v = find(v);\n    if (root_u != root_v) {\n        parent[root_v] = root_u;\n    }\n}\n\nint compare(const void *a, const void *b) {\n    Edge *edgeA = (Edge *)a;\n    Edge *edgeB = (Edge *)b;\n    return edgeA->w - edgeB->w;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &edges[i].u, &edges[i].v, &edges[i].w);\n    }\n\n    for (int i = 1; i <= N; i++) {\n        parent[i] = i;\n    }\n\n    qsort(edges, M, sizeof(Edge), compare);\n\n    int total_cost = 0;\n    for (int i = 0; i < M; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        int w = edges[i].w;\n        if (find(u) != find(v)) {\n            union_set(u, v);\n            total_cost += w;\n        }\n    }\n\n    printf(\"%d\\n\", total_cost);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:17:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nvoid dijkstra(int src, vector<vector<pii>>& adj, vector<int>& dist) {\n    priority_queue<pii, vector<pii>, greater<pii>> pq;\n    dist[src] = 0;\n    pq.push({0, src});\n    \n    while (!pq.empty()) {\n        int u = pq.top().second;\n        int d = pq.top().first;\n        pq.pop();\n        \n        if (d > dist[u]) continue;\n        \n        for (auto& edge : adj[u]) {\n            int v = edge.first;\n            int w = edge.second;\n            if (dist[v] > dist[u] + w) {\n                dist[v] = dist[u] + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<vector<pii>> adj(N + 1);\n    vector<vector<int>> original_edges(N + 1, vector<int>(N + 1, 0));\n    \n    for (int i = 0; i < M; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        adj[u].push_back({v, w});\n        adj[v].push_back({u, w});\n        original_edges[u][v] = original_edges[v][u] = w;\n    }\n    \n    vector<int> dist(N + 1, INT_MAX);\n    dijkstra(1, adj, dist);\n    \n    int total_cost = 0;\n    for (int u = 1; u <= N; ++u) {\n        for (auto& edge : adj[u]) {\n            int v = edge.first;\n            int w = edge.second;\n            if (u < v && dist[u] + w == dist[v]) {\n                total_cost += w;\n            }\n        }\n    }\n    \n    cout << total_cost << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:17:40"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge implements Comparable<Edge> {\n    int to, cost;\n\n    Edge(int to, int cost) {\n        this.to = to;\n        this.cost = cost;\n    }\n\n    @Override\n    public int compareTo(Edge other) {\n        return Integer.compare(this.cost, other.cost);\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        List<List<Edge>> adj = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < M; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int c = sc.nextInt();\n            adj.get(u).add(new Edge(v, c));\n            adj.get(v).add(new Edge(u, c));\n        }\n\n        int[] dist = new int[N];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0] = 0;\n        PriorityQueue<Edge> pq = new PriorityQueue<>();\n        pq.add(new Edge(0, 0));\n\n        while (!pq.isEmpty()) {\n            Edge current = pq.poll();\n            int u = current.to;\n            if (current.cost > dist[u]) continue;\n            for (Edge e : adj.get(u)) {\n                int v = e.to;\n                int newDist = dist[u] + e.cost;\n                if (newDist < dist[v]) {\n                    dist[v] = newDist;\n                    pq.add(new Edge(v, dist[v]));\n                }\n            }\n        }\n\n        int totalCost = 0;\n        for (int u = 0; u < N; u++) {\n            int minEdgeCost = Integer.MAX_VALUE;\n            for (Edge e : adj.get(u)) {\n                int v = e.to;\n                if (dist[u] + e.cost == dist[v]) {\n                    if (e.cost < minEdgeCost) {\n                        minEdgeCost = e.cost;\n                    }\n                }\n            }\n            if (minEdgeCost != Integer.MAX_VALUE) {\n                totalCost += minEdgeCost;\n            }\n        }\n\n        System.out.println(totalCost);\n    }\n}",
    "timestamp": "2025-08-05 21:18:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RoadConstruction {\n    static class Edge implements Comparable<Edge> {\n        int src, dest, weight;\n        \n        Edge(int src, int dest, int weight) {\n            this.src = src;\n            this.dest = dest;\n            this.weight = weight;\n        }\n        \n        public int compareTo(Edge other) {\n            return Integer.compare(this.weight, other.weight);\n        }\n    }\n    \n    static class UnionFind {\n        int[] parent, rank;\n        \n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n        \n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n        \n        boolean union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            \n            if (rootX == rootY) return false;\n            \n            if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else {\n                parent[rootY] = rootX;\n                rank[rootX]++;\n            }\n            return true;\n        }\n    }\n    \n    public static int minimizeRoadCost(int n, int m, int capital, List<Edge> edges) {\n        // Sort edges by weight\n        Collections.sort(edges);\n        \n        // Track distances from capital\n        int[] distances = new int[n];\n        Arrays.fill(distances, Integer.MAX_VALUE);\n        distances[capital] = 0;\n        \n        // Kruskal's algorithm with distance constraints\n        UnionFind uf = new UnionFind(n);\n        int totalCost = 0;\n        \n        for (Edge edge : edges) {\n            int u = edge.src;\n            int v = edge.dest;\n            \n            // Check distance constraints\n            if (distances[u] != Integer.MAX_VALUE && \n                distances[v] != Integer.MAX_VALUE && \n                Math.abs(distances[u] + edge.weight - distances[v]) == 0) {\n                \n                if (uf.union(u, v)) {\n                    totalCost += edge.weight;\n                    \n                    // Update distances\n                    distances[v] = distances[u] + edge.weight;\n                }\n            }\n        }\n        \n        return totalCost;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read input\n        int n = scanner.nextInt(); // Number of cities\n        int m = scanner.nextInt(); // Number of roads\n        int capital = scanner.nextInt(); // Capital city\n        \n        List<Edge> edges = new ArrayList<>();\n        \n        // Read road information\n        for (int i = 0; i < m; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int weight = scanner.nextInt();\n            edges.add(new Edge(u, v, weight));\n        }\n        \n        // Calculate minimum road construction cost\n        int result = minimizeRoadCost(n, m, capital, edges);\n        System.out.println(result);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:18:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_CITIES 1000\n#define MAX_ROADS 10000\n\ntypedef struct {\n    int u, v, weight;\n} Road;\n\nint parent[MAX_CITIES];\nint rank[MAX_CITIES];\nint dist[MAX_CITIES];\n\nint find(int x) {\n    if (parent[x] != x)\n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unionSet(int x, int y) {\n    int rootX = find(x);\n    int rootY = find(y);\n    \n    if (rootX == rootY) return;\n    \n    if (rank[rootX] < rank[rootY]) {\n        parent[rootX] = rootY;\n    } else if (rank[rootX] > rank[rootY]) {\n        parent[rootY] = rootX;\n    } else {\n        parent[rootY] = rootX;\n        rank[rootX]++;\n    }\n}\n\nint cmpRoad(const void* a, const void* b) {\n    Road* roadA = (Road*)a;\n    Road* roadB = (Road*)b;\n    return roadA->weight - roadB->weight;\n}\n\nint main() {\n    int N, M, capital;\n    scanf(\"%d %d %d\", &N, &M, &capital);\n    \n    // Initialize parent and rank\n    for (int i = 1; i <= N; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n    \n    // Read original distances from capital\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &dist[i]);\n    }\n    \n    // Read roads\n    Road roads[MAX_ROADS];\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &roads[i].u, &roads[i].v, &roads[i].weight);\n    }\n    \n    // Sort roads by weight\n    qsort(roads, M, sizeof(Road), cmpRoad);\n    \n    // Kruskal's algorithm with modifications\n    int totalCost = 0;\n    int edgesAdded = 0;\n    \n    for (int i = 0; i < M; i++) {\n        int u = roads[i].u;\n        int v = roads[i].v;\n        \n        // Check if adding this road maintains minimum distance constraints\n        if (find(u) != find(v)) {\n            int uDist = abs(dist[u] - dist[capital]);\n            int vDist = abs(dist[v] - dist[capital]);\n            \n            if (uDist + roads[i].weight == vDist || \n                vDist + roads[i].weight == uDist) {\n                unionSet(u, v);\n                totalCost += roads[i].weight;\n                edgesAdded++;\n            }\n        }\n        \n        // Stop if we have a spanning tree\n        if (edgesAdded == N - 1) break;\n    }\n    \n    // Check if all cities are connected\n    int connectedComponents = 0;\n    for (int i = 1; i <= N; i++) {\n        if (parent[i] == i) connectedComponents++;\n    }\n    \n    if (connectedComponents > 1) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"%d\\n\", totalCost);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:18:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAXN = 1005;\nconst int INF = 0x3f3f3f3f;\n\nstruct Edge {\n    int u, v, w;\n    bool operator<(const Edge& other) const {\n        return w < other.w;\n    }\n};\n\nint parent[MAXN];\nint dist[MAXN];\nvector<Edge> edges;\n\nint find(int x) {\n    if (parent[x] != x) \n        parent[x] = find(parent[x]);\n    return parent[x];\n}\n\nvoid unite(int x, int y) {\n    parent[find(x)] = find(y);\n}\n\nint main() {\n    int n, m, capital;\n    cin >> n >> m >> capital;\n\n    for (int i = 1; i <= n; i++) \n        parent[i] = i;\n\n    memset(dist, 0x3f, sizeof(dist));\n    dist[capital] = 0;\n\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        edges.push_back({u, v, w});\n        \n        int d1 = min(dist[u], dist[v]);\n        int d2 = max(dist[u], dist[v]);\n        \n        if (d2 == INF) {\n            if (u == capital) dist[v] = w;\n            else if (v == capital) dist[u] = w;\n        } else {\n            if (u == capital || v == capital) \n                dist[u == capital ? v : u] = w;\n        }\n    }\n\n    sort(edges.begin(), edges.end());\n    \n    int total_cost = 0;\n    for (auto& edge : edges) {\n        int u = edge.u, v = edge.v, w = edge.w;\n        \n        if (find(u) != find(v)) {\n            int d1 = min(dist[u], dist[v]);\n            int d2 = max(dist[u], dist[v]);\n            \n            if (w >= d2 || u == capital || v == capital) {\n                unite(u, v);\n                total_cost += w;\n            }\n        }\n    }\n\n    cout << total_cost << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:18:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef prim_modified(graph, capital, n):\n    visited = [False] * n\n    min_distance = [float('inf')] * n\n    parent = [-1] * n\n    \n    min_distance[capital] = 0\n    priority_queue = [(0, capital)]\n    \n    while priority_queue:\n        _, u = heapq.heappop(priority_queue)\n        \n        if visited[u]:\n            continue\n        \n        visited[u] = True\n        \n        for weight, v in graph[u]:\n            if not visited[v] and weight < min_distance[v]:\n                min_distance[v] = weight\n                parent[v] = u\n                heapq.heappush(priority_queue, (weight, v))\n    \n    mst_edges = []\n    cost = 0\n    for v in range(n):\n        if v != capital and parent[v] != -1:\n            mst_edges.append((parent[v], v, min_distance[v]))\n            cost += min_distance[v]\n    \n    return cost, mst_edges\n\ndef calculate_minimum_cost_and_plan(n, roads, capital):\n    graph = [[] for _ in range(n)]\n    for u, v, cost in roads:\n        graph[u].append((cost, v))\n        graph[v].append((cost, u))\n    \n    cost, plan = prim_modified(graph, capital, n)\n    return cost, plan\n\n# Example input data\nn = 5\nroads = [\n    (0, 1, 4),\n    (0, 2, 3),\n    (1, 2, 1),\n    (1, 3, 2),\n    (2, 3, 4),\n    (3, 4, 2),\n    (2, 4, 5)\n]\ncapital = 0\n\n# Calculate the minimum cost and the new plan\ncost, plan = calculate_minimum_cost_and_plan(n, roads, capital)\n\n# Output\nprint(\"Minimum construction cost:\", cost)\nprint(\"New construction plan (edges):\", plan)",
    "timestamp": "2025-08-13 05:52:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass RoadConstruction {\n    static class Edge implements Comparable<Edge> {\n        int from, to, cost;\n\n        public Edge(int from, int to, int cost) {\n            this.from = from;\n            this.to = to;\n            this.cost = cost;\n        }\n\n        @Override\n        public int compareTo(Edge other) {\n            return Integer.compare(this.cost, other.cost);\n        }\n    }\n\n    static class UnionFind {\n        int[] parent, rank;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        public int find(int u) {\n            if (parent[u] != u) {\n                parent[u] = find(parent[u]);\n            }\n            return parent[u];\n        }\n\n        public void union(int u, int v) {\n            int rootU = find(u);\n            int rootV = find(v);\n            if (rootU != rootV) {\n                if (rank[rootU] < rank[rootV]) {\n                    parent[rootU] = rootV;\n                } else if (rank[rootU] > rank[rootV]) {\n                    parent[rootV] = rootU;\n                } else {\n                    parent[rootV] = rootU;\n                    rank[rootU]++;\n                }\n            }\n        }\n    }\n\n    static int kruskal(int n, ArrayList<Edge> edges) {\n        Collections.sort(edges);\n        UnionFind uf = new UnionFind(n);\n        int totalCost = 0;\n        for (Edge edge : edges) {\n            if (uf.find(edge.from) != uf.find(edge.to)) {\n                uf.union(edge.from, edge.to);\n                totalCost += edge.cost;\n            }\n        }\n        return totalCost;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt(); // Number of cities\n        int m = scanner.nextInt(); // Number of roads\n\n        ArrayList<Edge> edges = new ArrayList<>();\n        for (int i = 0; i < m; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            int cost = scanner.nextInt();\n            edges.add(new Edge(u, v, cost));\n        }\n\n        int result = kruskal(n, edges);\n        System.out.println(result);\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 05:52:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_CITIES 100\n\nint minDistance(int dist[], int visited[], int n) {\n    int min = INT_MAX, min_index;\n    \n    for (int v = 0; v < n; v++) {\n        if (!visited[v] && dist[v] <= min) {\n            min = dist[v];\n            min_index = v;\n        }\n    }\n    return min_index;\n}\n\nvoid dijkstra(int graph[MAX_CITIES][MAX_CITIES], int n, int src, int dist[]) {\n    int visited[MAX_CITIES];\n    for (int i = 0; i < n; i++) {\n        dist[i] = INT_MAX;\n        visited[i] = 0;\n    }\n    \n    dist[src] = 0;\n    \n    for (int count = 0; count < n - 1; count++) {\n        int u = minDistance(dist, visited, n);\n        visited[u] = 1;\n        \n        for (int v = 0; v < n; v++) {\n            if (!visited[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v]) {\n                dist[v] = dist[u] + graph[u][v];\n            }\n        }\n    }\n}\n\nvoid findMinimumSpanningTree(int graph[MAX_CITIES][MAX_CITIES], int n) {\n    int src = 0;\n    int dist[MAX_CITIES];\n    dijkstra(graph, n, src, dist);\n\n    int minSpanning[MAX_CITIES][MAX_CITIES] = {0};\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == 0 || j == 0 || dist[i] == graph[j][i]) {\n                minSpanning[i][j] = graph[i][j];\n            }\n        }\n    }\n    \n    int minCost = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (minSpanning[i][j]) {\n                minCost += minSpanning[i][j];\n            }\n        }\n    }\n    \n    minCost /= 2; // Because it's an undirected graph\n    \n    printf(\"Minimum Cost: %d\\n\", minCost);\n}\n\nint main() {\n    int n;\n    int graph[MAX_CITIES][MAX_CITIES];\n    \n    printf(\"Enter number of cities: \");\n    scanf(\"%d\", &n);\n\n    printf(\"Enter the adjacency matrix:\\n\");\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &graph[i][j]);\n        }\n    }\n\n    findMinimumSpanningTree(graph, n);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 05:52:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve_road_construction(n, capital, original_roads, distances):\n    # Create adjacency list representation of the graph\n    graph = [[] for _ in range(n)]\n    for u, v, w in original_roads:\n        graph[u-1].append((v-1, w))\n        graph[v-1].append((u-1, w))\n    \n    # Dijkstra's algorithm to find original distances from capital\n    orig_dist = [float('inf')] * n\n    orig_dist[capital-1] = 0\n    pq = [(0, capital-1)]\n    \n    while pq:\n        curr_dist, curr_node = heapq.heappop(pq)\n        \n        if curr_dist > orig_dist[curr_node]:\n            continue\n        \n        for neighbor, weight in graph[curr_node]:\n            dist = curr_dist + weight\n            if dist < orig_dist[neighbor]:\n                orig_dist[neighbor] = dist\n                heapq.heappush(pq, (dist, neighbor))\n    \n    # Kruskal's algorithm for Minimum Spanning Tree\n    def find(parent, x):\n        if parent[x] != x:\n            parent[x] = find(parent, parent[x])\n        return parent[x]\n    \n    def union(parent, rank, x, y):\n        root_x = find(parent, x)\n        root_y = find(parent, y)\n        \n        if root_x == root_y:\n            return False\n        \n        if rank[root_x] < rank[root_y]:\n            parent[root_x] = root_y\n        elif rank[root_x] > rank[root_y]:\n            parent[root_y] = root_x\n        else:\n            parent[root_y] = root_x\n            rank[root_x] += 1\n        \n        return True\n    \n    # Prepare edges for Kruskal's algorithm\n    edges = []\n    for u, v, w in original_roads:\n        edges.append((w, u-1, v-1))\n    edges.sort()\n    \n    # Initialize parent and rank for disjoint set\n    parent = list(range(n))\n    rank = [0] * n\n    \n    # Minimum Spanning Tree construction\n    total_cost = 0\n    for w, u, v in edges:\n        # Check if adding this edge maintains original distances\n        test_dist = [float('inf')] * n\n        test_dist[capital-1] = 0\n        \n        # Run Dijkstra's with new road\n        test_pq = [(0, capital-1)]\n        while test_pq:\n            curr_dist, curr_node = heapq.heappop(test_pq)\n            \n            if curr_dist > test_dist[curr_node]:\n                continue\n            \n            for neighbor, weight in graph[curr_node]:\n                dist = curr_dist + weight\n                if dist < test_dist[neighbor]:\n                    test_dist[neighbor] = dist\n                    heapq.heappush(test_pq, (dist, neighbor))\n        \n        # Check if distances are maintained\n        if test_dist == orig_dist and union(parent, rank, u, v):\n            total_cost += w\n    \n    return total_cost\n\n# Read input\nn, m, capital = map(int, input().split())\noriginal_roads = []\nfor _ in range(m):\n    u, v, w = map(int, input().split())\n    original_roads.append((u, v, w))\n\n# Placeholder for distances (if needed)\ndistances = []\n\n# Solve and print result\nprint(solve_road_construction(n, capital, original_roads, distances))",
    "timestamp": "2025-08-13 05:53:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(N+1)]\n    original_dist = [float('inf')] * (N+1)\n    original_dist[1] = 0\n    \n    for _ in range(M):\n        a = int(data[idx])\n        idx += 1\n        b = int(data[idx])\n        idx += 1\n        c = int(data[idx])\n        idx += 1\n        adj[a].append((b, c))\n        adj[b].append((a, c))\n    \n    # Dijkstra's to find original distances\n    heap = []\n    heapq.heappush(heap, (0, 1))\n    visited = [False] * (N+1)\n    \n    while heap:\n        current_dist, u = heapq.heappop(heap)\n        if visited[u]:\n            continue\n        visited[u] = True\n        for (v, cost) in adj[u]:\n            if original_dist[v] > current_dist + cost:\n                original_dist[v] = current_dist + cost\n                heapq.heappush(heap, (original_dist[v], v))\n    \n    # Now find the minimal cost edges\n    total_cost = 0\n    heap = []\n    heapq.heappush(heap, (0, 1))\n    visited = [False] * (N+1)\n    \n    while heap:\n        current_dist, u = heapq.heappop(heap)\n        if visited[u]:\n            continue\n        visited[u] = True\n        for (v, cost) in adj[u]:\n            if original_dist[v] == original_dist[u] + cost:\n                total_cost += cost\n                heapq.heappush(heap, (original_dist[v], v))\n                break  # Only need one edge per node\n    \n    print(total_cost)\n\nsolve()",
    "timestamp": "2025-08-13 05:53:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Edge {\n    int from, to, cost;\n};\n\nstruct Graph {\n    int vertices;\n    vector<vector<Edge>> adjList;\n\n    Graph(int v) : vertices(v), adjList(v) {}\n\n    void addEdge(int from, int to, int cost) {\n        adjList[from].push_back({from, to, cost});\n        adjList[to].push_back({to, from, cost});\n    }\n};\n\nvector<int> dijkstra(int source, Graph &graph) {\n    vector<int> dist(graph.vertices, numeric_limits<int>::max());\n    dist[source] = 0;\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    pq.push({0, source});\n\n    while (!pq.empty()) {\n        auto [d, u] = pq.top();\n        pq.pop();\n\n        if (d > dist[u]) continue;\n\n        for (auto &edge : graph.adjList[u]) {\n            int v = edge.to;\n            int cost = edge.cost;\n            if (dist[u] + cost < dist[v]) {\n                dist[v] = dist[u] + cost;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n    return dist;\n}\n\nvector<Edge> kruskal(int vertices, vector<Edge> &edges) {\n    sort(edges.begin(), edges.end(), [](Edge &a, Edge &b) {\n        return a.cost < b.cost;\n    });\n\n    vector<int> parent(vertices);\n    for (int i = 0; i < vertices; ++i)\n        parent[i] = i;\n\n    function<int(int)> find = [&](int u) {\n        if (parent[u] != u)\n            parent[u] = find(parent[u]);\n        return parent[u];\n    };\n\n    auto unionSets = [&](int u, int v) {\n        parent[find(u)] = find(v);\n    };\n\n    vector<Edge> mst;\n    for (auto &edge : edges) {\n        if (find(edge.from) != find(edge.to)) {\n            mst.push_back(edge);\n            unionSets(edge.from, edge.to);\n        }\n    }\n    return mst;\n}\n\nint main() {\n    int vertices, edgesCount;\n    cin >> vertices >> edgesCount;\n\n    Graph graph(vertices);\n    vector<Edge> edges;\n    for (int i = 0; i < edgesCount; ++i) {\n        int from, to, cost;\n        cin >> from >> to >> cost;\n        graph.addEdge(from, to, cost);\n        edges.push_back({from, to, cost});\n    }\n\n    int source = 0;\n    vector<int> originalDistances = dijkstra(source, graph);\n\n    vector<Edge> mstEdges = kruskal(vertices, edges);\n\n    Graph mstGraph(vertices);\n    for (auto &edge : mstEdges) {\n        mstGraph.addEdge(edge.from, edge.to, edge.cost);\n    }\n\n    vector<int> mstDistances = dijkstra(source, mstGraph);\n\n    int minimumCost = 0;\n    for (auto &edge : mstEdges) {\n        minimumCost += edge.cost;\n    }\n\n    for (int i = 0; i < vertices; ++i) {\n        if (originalDistances[i] != mstDistances[i]) {\n            cout << \"Impossible\\n\";\n            return 0;\n        }\n    }\n\n    cout << \"Minimum Cost: \" << minimumCost << \"\\n\";\n    return 0;\n}",
    "timestamp": "2025-08-13 11:28:55"
  }
]