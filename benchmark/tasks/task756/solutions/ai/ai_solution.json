[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_N 1000\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    bool dots[MAX_N][MAX_N] = {false};\n    int x, y;\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &x, &y);\n        dots[x][y] = true;\n    }\n    \n    int operations = 0;\n    \n    for (int a = 0; a < MAX_N; a++) {\n        for (int b = 0; b < MAX_N; b++) {\n            for (int c = 0; c < MAX_N; c++) {\n                if (a == c) continue;\n                \n                for (int d = 0; d < MAX_N; d++) {\n                    if (b == d) continue;\n                    \n                    int dotCount = \n                        dots[a][b] + dots[a][d] + \n                        dots[c][b] + dots[c][d];\n                    \n                    if (dotCount == 3) {\n                        int missingX = (dots[a][b] && dots[a][d] && !dots[c][b] && !dots[c][d]) ? c : \n                                       (dots[a][b] && !dots[a][d] && dots[c][b] && !dots[c][d]) ? a : \n                                       (dots[a][b] && !dots[a][d] && !dots[c][b] && dots[c][d]) ? a : \n                                       (!dots[a][b] && dots[a][d] && dots[c][b] && !dots[c][d]) ? c : -1;\n                        \n                        int missingY = (dots[a][b] && dots[a][d] && !dots[c][b] && !dots[c][d]) ? d : \n                                       (dots[a][b] && !dots[a][d] && dots[c][b] && !dots[c][d]) ? b : \n                                       (dots[a][b] && !dots[a][d] && !dots[c][b] && dots[c][d]) ? d : \n                                       (!dots[a][b] && dots[a][d] && dots[c][b] && !dots[c][d]) ? b : -1;\n                        \n                        if (missingX != -1 && missingY != -1 && !dots[missingX][missingY]) {\n                            dots[missingX][missingY] = true;\n                            operations++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", operations);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:47:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct {\n    int x;\n    int y;\n} Point;\n\nint maxOperations(int N, Point* dots) {\n    bool** grid = (bool**)calloc(1001, sizeof(bool*));\n    for (int i = 0; i < 1001; i++) {\n        grid[i] = (bool*)calloc(1001, sizeof(bool));\n    }\n\n    for (int i = 0; i < N; i++) {\n        grid[dots[i].x][dots[i].y] = true;\n    }\n\n    int operations = 0;\n    bool changed;\n\n    do {\n        changed = false;\n        for (int a = 0; a <= 1000; a++) {\n            for (int b = 0; b <= 1000; b++) {\n                if (!grid[a][b]) continue;\n                for (int c = a + 1; c <= 1000; c++) {\n                    if (!grid[c][b]) continue;\n                    for (int d = b + 1; d <= 1000; d++) {\n                        if (grid[a][d] && !grid[c][d]) {\n                            grid[c][d] = true;\n                            operations++;\n                            changed = true;\n                        } else if (!grid[a][d] && grid[c][d]) {\n                            grid[a][d] = true;\n                            operations++;\n                            changed = true;\n                        }\n                    }\n                }\n            }\n        }\n    } while (changed);\n\n    for (int i = 0; i < 1001; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n\n    return operations;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Point* dots = (Point*)malloc(N * sizeof(Point));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &dots[i].x, &dots[i].y);\n    }\n    printf(\"%d\\n\", maxOperations(N, dots));\n    free(dots);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:48:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <map>\n#include <utility>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    set<pair<int, int>> points;\n    map<int, set<int>> xToY, yToX;\n\n    for (int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        points.insert({x, y});\n        xToY[x].insert(y);\n        yToX[y].insert(x);\n    }\n\n    int operations = 0;\n    bool changed;\n    do {\n        changed = false;\n        set<pair<int, int>> newPoints;\n\n        for (auto it = points.begin(); it != points.end(); ++it) {\n            int x1 = it->first, y1 = it->second;\n            for (auto jt = next(it); jt != points.end(); ++jt) {\n                int x2 = jt->first, y2 = jt->second;\n                if (x1 != x2 && y1 != y2) {\n                    bool hasP1 = points.count({x1, y2});\n                    bool hasP2 = points.count({x2, y1});\n                    if (hasP1 && !hasP2) {\n                        if (!points.count({x2, y1})) {\n                            newPoints.insert({x2, y1});\n                        }\n                    } else if (!hasP1 && hasP2) {\n                        if (!points.count({x1, y2})) {\n                            newPoints.insert({x1, y2});\n                        }\n                    }\n                }\n            }\n        }\n\n        if (!newPoints.empty()) {\n            changed = true;\n            operations += newPoints.size();\n            for (auto &p : newPoints) {\n                points.insert(p);\n                xToY[p.first].insert(p.second);\n                yToX[p.second].insert(p.first);\n            }\n        }\n    } while (changed);\n\n    cout << operations << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:49:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n    public static int maxOperations(int[][] dots) {\n        Set<String> set = new HashSet<>();\n        for (int[] dot : dots) {\n            set.add(dot[0] + \",\" + dot[1]);\n        }\n\n        int operations = 0;\n        boolean changed;\n        do {\n            changed = false;\n            Set<String> newDots = new HashSet<>();\n            Set<String> current = new HashSet<>(set);\n            for (String s1 : current) {\n                for (String s2 : current) {\n                    if (s1.equals(s2)) continue;\n                    String[] parts1 = s1.split(\",\");\n                    String[] parts2 = s2.split(\",\");\n                    int a = Integer.parseInt(parts1[0]);\n                    int b = Integer.parseInt(parts1[1]);\n                    int c = Integer.parseInt(parts2[0]);\n                    int d = Integer.parseInt(parts2[1]);\n\n                    if (a != c && b != d) {\n                        String pos1 = a + \",\" + d;\n                        String pos2 = c + \",\" + b;\n                        boolean hasPos1 = current.contains(pos1);\n                        boolean hasPos2 = current.contains(pos2);\n\n                        if (hasPos1 && !hasPos2) {\n                            if (!set.contains(pos2)) {\n                                newDots.add(pos2);\n                                changed = true;\n                            }\n                        } else if (!hasPos1 && hasPos2) {\n                            if (!set.contains(pos1)) {\n                                newDots.add(pos1);\n                                changed = true;\n                            }\n                        }\n                    }\n                }\n            }\n            operations += newDots.size();\n            set.addAll(newDots);\n        } while (changed);\n\n        return operations;\n    }\n}",
    "timestamp": "2025-08-05 22:49:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DotOperation {\n    public static int maxDotOperations(List<int[]> dots) {\n        Set<String> dotSet = new HashSet<>();\n        for (int[] dot : dots) {\n            dotSet.add(dot[0] + \",\" + dot[1]);\n        }\n        \n        int operations = 0;\n        boolean canOperate = true;\n        \n        while (canOperate) {\n            canOperate = false;\n            \n            for (int[] dot1 : dots) {\n                for (int[] dot2 : dots) {\n                    if (dot1[0] == dot2[0] || dot1[1] == dot2[1]) continue;\n                    \n                    int x1 = dot1[0], y1 = dot1[1];\n                    int x2 = dot2[0], y2 = dot2[1];\n                    \n                    int[] possibleDots = {\n                        x1, y2,\n                        x2, y1\n                    };\n                    \n                    int missingDots = 0;\n                    int[] missingDot = new int[2];\n                    \n                    for (int i = 0; i < 4; i += 2) {\n                        String dotKey = possibleDots[i] + \",\" + possibleDots[i+1];\n                        if (!dotSet.contains(dotKey)) {\n                            missingDots++;\n                            missingDot[0] = possibleDots[i];\n                            missingDot[1] = possibleDots[i+1];\n                        }\n                    }\n                    \n                    if (missingDots == 1) {\n                        dotSet.add(missingDot[0] + \",\" + missingDot[1]);\n                        dots.add(missingDot);\n                        operations++;\n                        canOperate = true;\n                        break;\n                    }\n                }\n                if (canOperate) break;\n            }\n        }\n        \n        return operations;\n    }\n    \n    public static void main(String[] args) {\n        // Example usage\n        List<int[]> dots = new ArrayList<>();\n        dots.add(new int[]{0, 0});\n        dots.add(new int[]{0, 1});\n        dots.add(new int[]{1, 0});\n        System.out.println(maxDotOperations(dots));\n    }\n}",
    "timestamp": "2025-08-05 22:49:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    set<pair<int, int>> points;\n    for (int i = 0; i < N; i++) {\n        int x, y;\n        cin >> x >> y;\n        points.insert({x, y});\n    }\n    \n    int operations = 0;\n    while (true) {\n        bool found = false;\n        for (auto p1 : points) {\n            for (auto p2 : points) {\n                if (p1 == p2) continue;\n                \n                int x1 = p1.first, y1 = p1.second;\n                int x2 = p2.first, y2 = p2.second;\n                \n                vector<pair<int, int>> candidates = {\n                    {x1, y2},\n                    {x2, y1}\n                };\n                \n                int existingPoints = 0;\n                pair<int, int> missingPoint;\n                \n                for (auto& p : candidates) {\n                    if (points.count(p)) existingPoints++;\n                    else missingPoint = p;\n                }\n                \n                if (existingPoints == 3) {\n                    points.insert(missingPoint);\n                    operations++;\n                    found = true;\n                    break;\n                }\n            }\n            if (found) break;\n        }\n        \n        if (!found) break;\n    }\n    \n    cout << operations << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:49:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_operations(dots):\n    dot_set = set(dots)\n    max_operations = 0\n    \n    # Generate pairs of x-coordinates and y-coordinates\n    x_coords = sorted({x for x, _ in dot_set})\n    y_coords = sorted({y for _, y in dot_set})\n    \n    for i in range(len(x_coords)):\n        for j in range(i + 1, len(x_coords)):\n            a, c = x_coords[i], x_coords[j]\n            for k in range(len(y_coords)):\n                for l in range(k + 1, len(y_coords)):\n                    b, d = y_coords[k], y_coords[l]\n                    \n                    # Check presence of three dots among the four positions\n                    positions = [(a, b), (a, d), (c, b), (c, d)]\n                    present = sum(1 for p in positions if p in dot_set)\n                    \n                    if present == 3:\n                        missing_dot = next(p for p in positions if p not in dot_set)\n                        dot_set.add(missing_dot)\n                        max_operations += 1\n\n    return max_operations\n\n# Example usage\nN = 4\ndots = [(1, 1), (1, 2), (2, 1), (3, 3)]\nprint(max_operations(dots))",
    "timestamp": "2025-08-13 12:36:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class DotOperations {\n\n    public static int maxOperations(int[][] dots) {\n        Set<String> dotSet = new HashSet<>();\n        for (int[] dot : dots) {\n            dotSet.add(dot[0] + \",\" + dot[1]);\n        }\n\n        int operationCount = 0;\n        for (int[] dot1 : dots) {\n            for (int[] dot2 : dots) {\n                if (dot1[0] != dot2[0] && dot1[1] != dot2[1]) {\n                    String pos1 = dot1[0] + \",\" + dot2[1];\n                    String pos2 = dot2[0] + \",\" + dot1[1];\n\n                    if (dotSet.contains(pos1) && dotSet.contains(pos2)) {\n                        String newDot = dot2[0] + \",\" + dot2[1];\n                        if (!dotSet.contains(newDot)) {\n                            dotSet.add(newDot);\n                            operationCount++;\n                        }\n                    }\n                }\n            }\n        }\n\n        return operationCount;\n    }\n\n    public static void main(String[] args) {\n        int[][] dots = {\n            {0, 0},\n            {0, 1},\n            {1, 0},\n            // Add more dots for testing\n        };\n        System.out.println(maxOperations(dots));\n    }\n}",
    "timestamp": "2025-08-13 12:36:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_COORD 1000\n\nint grid[MAX_COORD + 1][MAX_COORD + 1] = {0};\nint rows[MAX_COORD + 1] = {0};\nint cols[MAX_COORD + 1] = {0};\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n\n    int maxX = 0, maxY = 0;\n\n    for (int i = 0; i < N; ++i) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        grid[x][y] = 1;\n        rows[x]++;\n        cols[y]++;\n        if (x > maxX) maxX = x;\n        if (y > maxY) maxY = y;\n    }\n\n    int operations = 0;\n\n    while (1) {\n        int operation_performed = 0;\n\n        for (int a = 0; a <= maxX; ++a) {\n            if (rows[a] < 2) continue;\n            for (int b = 0; b <= maxY; ++b) {\n                if (grid[a][b] == 0) continue;\n                for (int c = 0; c <= maxX; ++c) {\n                    if (a == c || rows[c] < 2 || grid[c][b] == 1) continue;\n                    for (int d = 0; d <= maxY; ++d) {\n                        if (b == d || cols[d] < 2 || grid[a][d] == 1 || grid[c][d] == 0) continue;\n\n                        grid[a][d] = 1;\n                        rows[a]++;\n                        cols[d]++;\n                        operations++;\n                        operation_performed = 1;\n                        break;\n                    }\n                    if (operation_performed) break;\n                }\n                if (operation_performed) break;\n            }\n            if (operation_performed) break;\n        }\n\n        if (!operation_performed)\n            break;\n    }\n\n    printf(\"%d\\n\", operations);\n    return 0;\n}",
    "timestamp": "2025-08-13 12:36:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxOperations(dots) {\n    const dotSet = new Set(dots.map(dot => `${dot[0]},${dot[1]}`));\n    let operations = 0;\n\n    while (true) {\n        let operationPossible = false;\n\n        for (let [x1, y1] of dotSet) {\n            for (let [x2, y2] of dotSet) {\n                if (x1 === x2 || y1 === y2) continue;\n\n                const positions = [\n                    `${x1},${y2}`,\n                    `${x2},${y1}`\n                ];\n\n                const includedCount = positions.reduce((count, pos) => count + dotSet.has(pos), 0);\n\n                if (includedCount === 1) {\n                    operationPossible = true;\n\n                    const missingPos = positions.find(pos => !dotSet.has(pos));\n                    dotSet.add(missingPos);\n                    operations++;\n\n                    break;\n                }\n            }\n            if (operationPossible) break;\n        }\n        if (!operationPossible) break;\n    }\n\n    return operations;\n}",
    "timestamp": "2025-08-13 12:36:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_dot_additions(coordinates):\n    dots = set(map(tuple, coordinates))\n    operations = 0\n\n    while True:\n        found_operation = False\n        for a, b in dots:\n            for c, d in dots:\n                if a == c or b == d:\n                    continue\n                \n                points = [(a, b), (a, d), (c, b), (c, d)]\n                existing_points = [p for p in points if p in dots]\n                \n                if len(existing_points) == 3:\n                    missing_point = [p for p in points if p not in dots][0]\n                    dots.add(missing_point)\n                    operations += 1\n                    found_operation = True\n                    break\n            \n            if found_operation:\n                break\n        \n        if not found_operation:\n            break\n    \n    return operations\n\n# Example usage\nN = int(input())\ncoordinates = []\nfor _ in range(N):\n    x, y = map(int, input().split())\n    coordinates.append([x, y])\n\nprint(max_dot_additions(coordinates))",
    "timestamp": "2025-08-13 12:36:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(coordinates) {\n    const dots = new Set(coordinates.map(coord => coord.join(',')));\n    let operations = 0;\n\n    while (true) {\n        let performed = false;\n\n        for (let i = 0; i < coordinates.length; i++) {\n            for (let j = i + 1; j < coordinates.length; j++) {\n                const [a, b] = coordinates[i];\n                const [c, d] = coordinates[j];\n\n                if (a === c || b === d) continue;\n\n                const points = [\n                    [a, b],\n                    [a, d],\n                    [c, b],\n                    [c, d]\n                ];\n\n                const existingPoints = points.filter(point => \n                    dots.has(point.join(','))\n                );\n\n                if (existingPoints.length === 3) {\n                    const missingPoint = points.find(point => \n                        !dots.has(point.join(','))\n                    );\n\n                    dots.add(missingPoint.join(','));\n                    coordinates.push(missingPoint);\n                    operations++;\n                    performed = true;\n                    break;\n                }\n            }\n            if (performed) break;\n        }\n\n        if (!performed) break;\n    }\n\n    return operations;\n}",
    "timestamp": "2025-08-13 12:36:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_operations(N, dots):\n    from collections import defaultdict\n\n    x_to_ys = defaultdict(set)\n    y_to_xs = defaultdict(set)\n    points = set()\n\n    for x, y in dots:\n        x_to_ys[x].add(y)\n        y_to_xs[y].add(x)\n        points.add((x, y))\n\n    operations = 0\n    changed = True\n\n    while changed:\n        changed = False\n        new_points = set()\n        # Collect all possible (x1, y1, x2, y2) combinations where three points exist\n        for x1 in list(x_to_ys.keys()):\n            ys = x_to_ys[x1]\n            if len(ys) < 2:\n                continue\n            for y1 in list(ys):\n                for y2 in list(ys):\n                    if y1 >= y2:\n                        continue\n                    # Now check for x2 in y_to_xs[y1] and y_to_xs[y2]\n                    for x2 in list(y_to_xs[y1]):\n                        if x2 == x1:\n                            continue\n                        if (x2, y2) in points:\n                            if (x2, y1) not in points:\n                                new_points.add((x2, y1))\n                                changed = True\n                    for x2 in list(y_to_xs[y2]):\n                        if x2 == x1:\n                            continue\n                        if (x2, y1) in points:\n                            if (x2, y2) not in points:\n                                new_points.add((x2, y2))\n                                changed = True\n        # Add new points\n        for x, y in new_points:\n            if (x, y) not in points:\n                points.add((x, y))\n                x_to_ys[x].add(y)\n                y_to_xs[y].add(x)\n                operations += 1\n    return operations\n\n# Sample usage:\n# N = 4\n# dots = [(0, 0), (0, 1), (1, 0)]\n# print(max_operations(N, dots))  # Output should be 1",
    "timestamp": "2025-08-13 12:36:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxOperations(points) {\n    const pointSet = new Set();\n    for (const [x, y] of points) {\n        pointSet.add(`${x},${y}`);\n    }\n    \n    let operations = 0;\n    let changed = true;\n    \n    while (changed) {\n        changed = false;\n        const newPoints = [];\n        const keys = Array.from(pointSet).map(s => s.split(',').map(Number));\n        \n        for (let i = 0; i < keys.length; i++) {\n            for (let j = i + 1; j < keys.length; j++) {\n                const [x1, y1] = keys[i];\n                const [x2, y2] = keys[j];\n                \n                if (x1 !== x2 && y1 !== y2) {\n                    const p1 = `${x1},${y2}`;\n                    const p2 = `${x2},${y1}`;\n                    \n                    const hasP1 = pointSet.has(p1);\n                    const hasP2 = pointSet.has(p2);\n                    \n                    if (hasP1 && !hasP2) {\n                        newPoints.push([x2, y1]);\n                    } else if (!hasP1 && hasP2) {\n                        newPoints.push([x1, y2]);\n                    }\n                }\n            }\n        }\n        \n        if (newPoints.length > 0) {\n            changed = true;\n            operations += newPoints.length;\n            for (const [x, y] of newPoints) {\n                pointSet.add(`${x},${y}`);\n            }\n        }\n    }\n    \n    return operations;\n}",
    "timestamp": "2025-08-13 12:36:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nstruct Dot {\n    int x, y;\n    bool operator<(const Dot& other) const {\n        if (x == other.x) return y < other.y;\n        return x < other.x;\n    }\n};\n\nint main() {\n    int N;\n    cin >> N;\n    set<Dot> dots;\n\n    for (int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        dots.insert({x, y});\n    }\n\n    int maxOperations = 0;\n\n    for (auto it1 = dots.begin(); it1 != dots.end(); ++it1) {\n        for (auto it2 = next(it1); it2 != dots.end(); ++it2) {\n            if (it1->x == it2->x || it1->y == it2->y)\n                continue;\n\n            Dot third1 = {it1->x, it2->y};\n            Dot third2 = {it2->x, it1->y};\n\n            bool hasThird1 = dots.find(third1) != dots.end();\n            bool hasThird2 = dots.find(third2) != dots.end();\n\n            if (hasThird1 && !hasThird2) {\n                dots.insert(third2);\n                ++maxOperations;\n            } else if (!hasThird1 && hasThird2) {\n                dots.insert(third1);\n                ++maxOperations;\n            }\n        }\n    }\n\n    cout << maxOperations << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:35:30"
  }
]