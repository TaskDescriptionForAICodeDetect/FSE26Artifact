[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PI 3.14159265358979323846264338327950288419\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint n, m;\nint col[200005];\n\nint expo(int a, int b){\n\tint c = 1, d = a;\n\twhile(b){\n\t\tif(b & 1){\n\t\t\tc = 1LL * c * d % mod;\n\t\t}\n\t\td = 1LL * d * d % mod;\n\t\tb >>= 1;\n\t}\n\treturn c;\n}\n\nint inv(int x){\n\treturn expo(x, mod - 2);\n}\n\nint calc(int n){\n\tif(n == 2){\n\t\treturn 2;\n\t}\n\t\n\tint fib[200005];\n\tfib[1] = fib[2] = 1;\n\tfor(int i = 3; i <= n + 1; i++){\n\t\tfib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t}\n\t\n\t// force first one to be 1, last one to be 0: fib[N - 1]\n\t// force first one to be 0: fib[N + 1]\n\treturn (fib[n - 1] + fib[n + 1]) % mod;\n}\n\nint calc2(int n, int ub){\n\tassert(ub & 1);\n\t\n\t// want a bunch of numbers, in [0, ub], to sum to n\n\t\n\tub++;\n\tub = min(ub, n); // coz it can actually be HUGE\n\t\n\tint dp[200005]; // dp[i]: number of possible sums, that sum to i\n\tlong long cumu[200005];\n\t\n\tdp[0] = 1;\n\tcumu[0] = 1;\n\t\n\tfor(int i = 2; i <= n; i += 2){\n\t\t// sum from dp[l_index .. i - 2].. oh, only the even ones!\n\t\tint l_index = i - ub;\n\t//\tprintf(\"%d: sum %d..%d\\n\", i, l_index, r_index);\n\t\tdp[i] = cumu[i - 2];\n\t\tif(l_index > 0){\n\t\t\tdp[i] -= cumu[l_index - 2];\n\t\t}\n\t\t\n\t\tif(dp[i] < 0) dp[i] += mod;\n\t\t\n\t\tcumu[i] = (cumu[i - 2] + dp[i]) % mod;\n\t}\n\t\n\tint ret = 0;\n\t\n\tfor(int space = 0; space < ub; space++){\n\t\t// last 1 is at (n - space), leaving _ space at the end\n\t\t// where can the first 1 be?\n\t\tint left_pos = 1;\n\t\tint right_pos = ub - space;\n\t\tint most_remain = (n - space) - 1;\n\t\tint least_remain = n - ub;\n\t\tif(most_remain & 1) most_remain--;\n\t\t\n\t\tint combin = cumu[most_remain];\n\t\tif(least_remain > 0){\n\t\t\tcombin = (combin - cumu[least_remain - 2] + mod) % mod;\n\t\t}\n\t\tret = (ret + combin) % mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= m; i++){\n\t\tchar c;\n\t\tscanf(\" %c\", &c);\n\t\tcol[i] = (c == 'B');\n\t}\n\tif(col[1] != 0){\n\t\t// WLOG first one is 0\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tcol[i] = 1 - col[i];\n\t\t}\n\t}\n\t\n\tbool monochrome = true;\n\tfor(int i = 2; i <= m; i++){\n\t\tif(col[i]){\n\t\t\tmonochrome = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(monochrome){\n\t\t// ok as long as 1s are not adjacent\n\t\tprintf(\"%d\\n\", calc(n));\n\t\treturn 0;\n\t}else{\n\t\t// 00...010..010..0\n\t\t// each block of 0 is of add length\n\t\t// so, n odd -> definitely no solution\n\t\t// more conditions depending on specifics of col[]\n\t\tif(n % 2 == 1){\n\t\t \tprintf(\"0\\n\");\n\t\t \treturn 0;\n\t\t}\n\t\tint first_run = 0, subseq_run = n;\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tint len = 0;\n\t\t\twhile(i + len <= m && col[i + len] == 0){\n\t\t \t\tlen++;\n\t\t \t}\n\t\t \tif(first_run == 0){\n\t\t \t\tfirst_run = len;\n\t\t \t}else if(len & 1){\n\t\t \t\tsubseq_run = min(subseq_run, len);\n\t\t \t}\n\t\t \ti += len;\n\t\t}\n\t\tint ub = first_run + (first_run % 2 == 0);\n\t\tub = min(ub, subseq_run);\n\t\tprintf(\"%d\\n\", calc2(n, ub));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\ntemplate<typename T>\nstruct SegmentTree{\nprivate:\n    int n;\n    T E;\n    vector<T> node;\n    inline void updatef(T& x,T& y){\n        x = y;\n        //x += y;\n        //x = max(x,y);\n        //x = min(x,y);\n    }\n    inline T queryf(T& x,T& y){\n        //return x*y;\n        return (x+y)%mod;\n        //return max(x,y);\n        //return min(x,y);\n    }\n\npublic:\n    SegmentTree(int sz,T E_):E(E_){\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n    }\n\n    SegmentTree(vector<T>& A,T E_):E(E_){\n        int sz=A.size();\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n        rep(i,sz)node[i+n-1]=A[i];\n        for(int i=n-2;i>=0;--i){\n            node[i]=queryf(node[2*i+1], node[2*i+2]);\n        }\n    }\n    void update(int k,T x){\n        k+=n-1;\n        updatef(node[k],x);\n        while(k>0){\n            k=(k-1)/2;\n            node[k]=queryf(node[2*k+1], node[2*k+2]);\n        }\n    }\n       //[a,b)での和を返す\n    T get(int a,int b,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        if(r<=a||b<=l)return E;\n        if(a<=l&&r<=b)return node[k];\n        T xl=get(a,b,2*k+1,l,(l+r)/2);\n        T xr=get(a,b,2*k+2,(l+r)/2,r);\n        return queryf(xl, xr);\n    }\n};\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n    fact.resize(n+1);\n    inv.resize(n+1);\n    invfact.resize(n+1);\n    fact[0]=inv[0]=invfact[0]=1;\n    inv[1]=1;\n    rep(i,n){\n        fact[i+1]=fact[i]*(i+1)%mod;\n        if(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n        invfact[i+1]=invfact[i]*inv[i+1]%mod;\n    }\n}\nll perm(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n    k%=mod-1;\n    if(k<0)k+=mod-1;\n    ll ret=1;\n    while(k){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\nint main(){\n    int n,m;\n    cin>>n>>m;\n    string s;\n    cin>>s;\n    int len=0;\n    while(len<m&&s[len]==s[0])++len;\n    if(len==m){\n        vector<ll> ans(n+5);\n        ans[0]=2,ans[1]=1;\n        rep(i,n-1)ans[i+2]=(ans[i+1]+ans[i])%mod;\n        cout<<ans[n]<<endl;\n        return 0;\n    }\n    if(n%2){\n        cout<<0<<endl;\n        return 0;\n    }\n    if (len%2==0)++len;\n    int cnt=0;\n    rep(i,m){\n        if(s[i]!=s[0]){\n            if(cnt%2)len=min(len,cnt);\n            cnt=0;\n        }\n        else ++cnt;\n    }\n    n/=2;\n    len = (len+1)/2;\n    SegmentTree<ll> sg(n+5,0);\n    sg.update(0,1);\n    rep(i,n+1){\n        ll ret=sg.get(max(0,i+1-len),i+1);\n        sg.update(i+1,ret);\n    }\n    ll ans=0;\n    rep(i,min(n,len)){\n        ans+=sg.get(max(0,n-len),n-i);\n    }\n    cout<<2*ans%mod<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\n#define MAX_N 200000\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - inv[MOD % i] * (MOD / i);\n        fac[i] = fac[i-1] * i;\n        finv[i] = finv[i-1] * inv[i];\n    }\n}\n\nmod comb(int a, int b)\n{\n    if(a<b) return 0;\n    return fac[a] * finv[b] * finv[a-b];\n}\ntypedef pair<int, int> Pii;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\nll mod_pow(ll a, ll n, ll mod) { ll ret = 1; ll p = a % mod; while (n) { if (n & 1) ret = ret * p % mod; p = p * p % mod; n >>= 1; } return ret; }\n\ntemplate<int mod, int primitive_root>\nclass NTT {\npublic:\n\tint get_mod() const { return mod; }\n\tvoid _ntt(vector<ll>& a, int sign) {\n\t\tconst int n = sz(a);\n\t\tassert((n ^ (n&-n)) == 0); //n = 2^k\n\n\t\tconst int g = 3; //g is primitive root of mod\n\t\tint h = (int)mod_pow(g, (mod - 1) / n, mod); // h^n = 1\n\t\tif (sign == -1) h = (int)mod_inv(h, mod); //h = h^-1 % mod\n\n\t\t//bit reverse\n\t\tint i = 0;\n\t\tfor (int j = 1; j < n - 1; ++j) {\n\t\t\tfor (int k = n >> 1; k >(i ^= k); k >>= 1);\n\t\t\tif (j < i) swap(a[i], a[j]);\n\t\t}\n\n\t\tfor (int m = 1; m < n; m *= 2) {\n\t\t\tconst int m2 = 2 * m;\n\t\t\tconst ll base = mod_pow(h, n / m2, mod);\n\t\t\tll w = 1;\n\t\t\tFOR(x, m) {\n\t\t\t\tfor (int s = x; s < n; s += m2) {\n\t\t\t\t\tll u = a[s];\n\t\t\t\t\tll d = a[s + m] * w % mod;\n\t\t\t\t\ta[s] = u + d;\n\t\t\t\t\tif (a[s] >= mod) a[s] -= mod;\n\t\t\t\t\ta[s + m] = u - d;\n\t\t\t\t\tif (a[s + m] < 0) a[s + m] += mod;\n\t\t\t\t}\n\t\t\t\tw = w * base % mod;\n\t\t\t}\n\t\t}\n\n\t\tfor (auto& x : a) if (x < 0) x += mod;\n\t}\n\tvoid ntt(vector<ll>& input) {\n\t\t_ntt(input, 1);\n\t}\n\tvoid intt(vector<ll>& input) {\n\t\t_ntt(input, -1);\n\t\tconst int n_inv = mod_inv(sz(input), mod);\n\t\tfor (auto& x : input) x = x * n_inv % mod;\n\t}\n\n\t// 畳み込み演算を行う\n\tvector<ll> convolution(const vector<ll>& a, const vector<ll>& b){\n\t\tint ntt_size = 1;\n\t\twhile (ntt_size < sz(a) + sz(b)) ntt_size *= 2;\n\n\t\tvector<ll> _a = a, _b = b;\n\t\t_a.resize(ntt_size); _b.resize(ntt_size);\n\n\t\tntt(_a);\n\t\tntt(_b);\n\n\t\tFOR(i, ntt_size){\n\t\t\t(_a[i] *= _b[i]) %= mod;\n\t\t}\n\n\t\tintt(_a);\n\t\treturn _a;\n\t}\n};\n\nll garner(vector<Pii> mr, int mod){\n\tmr.emplace_back(mod, 0);\n\n\tvector<ll> coffs(sz(mr), 1);\n\tvector<ll> constants(sz(mr), 0);\n\tFOR(i, sz(mr) - 1){\n\t\t// coffs[i] * v + constants[i] == mr[i].second (mod mr[i].first) を解く\n\t\tll v = (mr[i].second - constants[i]) * mod_inv<ll>(coffs[i], mr[i].first) % mr[i].first;\n\t\tif (v < 0) v += mr[i].first;\n\n\t\tfor (int j = i + 1; j < sz(mr); j++) {\n\t\t\t(constants[j] += coffs[j] * v) %= mr[j].first;\n\t\t\t(coffs[j] *= mr[i].first) %= mr[j].first;\n\t\t}\n\t}\n\n\treturn constants[sz(mr) - 1];\n}\n\ntypedef NTT<167772161, 3> NTT_1;\ntypedef NTT<469762049, 3> NTT_2;\ntypedef NTT<1224736769, 3> NTT_3;\n\n//任意のmodで畳み込み演算 O(n log n)\nvector<ll> int32mod_convolution(vector<ll> a, vector<ll> b,int mod){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\tvector<ll> ret(sz(x));\n\tvector<Pii> mr(3);\n\tFOR(i, sz(x)){\n\t\tmr[0].first = ntt1.get_mod(), mr[0].second = (int)x[i];\n\t\tmr[1].first = ntt2.get_mod(), mr[1].second = (int)y[i];\n\t\tmr[2].first = ntt3.get_mod(), mr[2].second = (int)z[i];\n\t\tret[i] = garner(mr, mod);\n\t}\n\n\treturn ret;\n}\n\n// garnerのアルゴリズムを直書きしたversion，速い\nvector<ll> fast_int32mod_convolution(vector<ll> a, vector<ll> b,int mod){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\t\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tassert(ntt1.get_mod() < ntt2.get_mod() && ntt2.get_mod() < ntt3.get_mod());\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\t// garnerのアルゴリズムを極力高速化した\n\tconst ll m1 = ntt1.get_mod(), m2 = ntt2.get_mod(), m3 = ntt3.get_mod();\n\tconst ll m1_inv_m2 = mod_inv<ll>(m1, m2);\n\tconst ll m12_inv_m3 = mod_inv<ll>(m1 * m2, m3);\n\tconst ll m12_mod = m1 * m2 % mod;\n\tvector<ll> ret(sz(x));\n\tFOR(i, sz(x)){\n\t\tll v1 = (y[i] - x[i]) *  m1_inv_m2 % m2;\n\t\tif (v1 < 0) v1 += m2;\n\t\tll v2 = (z[i] - (x[i] + m1 * v1) % m3) * m12_inv_m3 % m3;\n\t\tif (v2 < 0) v2 += m3;\n\t\tll constants3 = (x[i] + m1 * v1 + m12_mod * v2) % mod;\n\t\tif (constants3 < 0) constants3 += mod;\n\t\tret[i] = constants3;\n\t}\n\n\treturn ret;\n}\n\n\nunsigned int add(const unsigned int x, const unsigned int y)\n{\n    return (x + y < MOD) ? x + y : x + y - MOD;\n}\n \nunsigned int sub(const unsigned int x, const unsigned int y)\n{\n    return (x >= y) ? (x - y) : (MOD - y + x);\n}\n \nunsigned int mul(const unsigned int x, const unsigned int y)\n{\n    return (unsigned long long)x * y % MOD;\n}\n \nunsigned int mod_pow(unsigned int x, unsigned int n)\n{\n    unsigned int res = 1;\n    while(n > 0){\n        if(n & 1){ res = mul(res, x); }\n        x = mul(x, x);\n        n >>= 1;\n    }\n    return res;\n}\n \nunsigned int inverse(const unsigned int x)\n{\n    return mod_pow(x, MOD - 2);\n}\n \nvector<ll> polynomial_inverse(const vector<ll>& a, int r)\n{\n    assert(a[0] != 0);\n    vector<ll> h = {(ll)inverse(a[0])};\n    int t = 1;\n    vector<ll> b;\n    int id =  0;\n    for(int i = 0; t < r; ++i){\n    \n        t <<= 1;\n        // vector<ll> tmp = int32mod_convolution(h, h, MOD);\n        while(id<min((int)a.size(),t)){\n            b.push_back(a[id]);\n            id++;\n        }\n        vector<ll> res = int32mod_convolution(b, int32mod_convolution(h, h, MOD), MOD);\n        res.resize(t);\n        for(int j = 0; j < t; ++j){\n            res[j] = sub(0, res[j]);\n            if(j < t / 2) res[j] = add(res[j], mul(2, h[j]));\n        }\n        swap(h, res);\n    }\n    h.resize(r);\n    return h;\n}\n\nmod dp[200010][2][2];\nint main(){\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if(s[0]=='R'){\n        rep(i,m){\n            if(s[i]=='R'){\n                s[i] ='B';\n            }else{\n                s[i] ='R'; \n            }\n        }\n    }\n    int a = inf;\n    int c = 0;\n    rep(i,m){\n        if(s[i]=='B'){\n            c++;\n        }else{\n            chmin(a,c);    \n        }\n    }\n    if(a==inf){\n        dp[0][0][0] = 1;\n        dp[0][1][1] = 1;\n        for(int i=1;i<n;i++){\n            for(int j=0;j<2;j++){\n                if(j==0){\n                    dp[i][j][0] += dp[i-1][1][0];\n                    dp[i][j][1] += dp[i-1][1][1];\n                }else{\n                    dp[i][j][0] += dp[i-1][1][0] + dp[i-1][0][0];\n                    dp[i][j][1] += dp[i-1][1][1] + dp[i-1][0][1];    \n                }\n            }\n        }\n        cout << dp[n-1][1][0] + dp[n-1][1][1] + dp[n-1][1][0] << endl;\n    }else{\n        int len = (a/2)*2+1;\n        //cerr << len << endl;\n        vector<ll> X(n+1),Y(n+1);\n        len++;\n        for(int i=2;i<=len;i+=2){\n            X[i] = i;\n        }\n        Y[0] = 1;\n        for(int i=2;i<=len;i+=2){\n            Y[i] = MOD-1;\n        }\n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        Y =polynomial_inverse(Y,n+1);\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        X = int32mod_convolution(X,Y,MOD);\n        \n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        cout << X[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define Md 1000000007\n#define MN 200005\nint n,m;\nchar c[MN];\nlg Pow(lg x,lg y){\n\tlg res=1;for(;y;y>>=1,x=x*x%Md)if(y&1)res=res*x%Md;return res;\n}\nint Fix(int x){\n\tif(x<0)return x+Md;\n\tif(x>=Md)return x-Md;\n\treturn x;\n}\nint dp[MN],tmp[MN];\nint miu[MN];\nint main(){\n\tread(n);read(m);\n\tscanf(\"%s\",c+1);\n\tmiu[1]=1;\n\tfor(int i=1;i<MN;++i){\n\t\tfor(int j=i+i;j<MN;j+=i){\n\t\t\tmiu[j]-=miu[i];\n\t\t}\n\t}\n\tchar Hd=c[1];\n\tint cnt=0,mx;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse break;\n\t}\n\tif(cnt&1)mx=cnt;else mx=cnt+1;\n\tif((n&1)&&cnt!=m)return puts(\"0\"),0;\n\tif(cnt==m){\n\t\tint res=0;\n\t\ttmp[0]=1;\n\t\tdp[0]=1;\n\t\tif(n>=2)res=n;\n\t\tfor(int i=1;i<n-1;++i){\n\t\t\tdp[i]=(i>=2?tmp[i-2]:0);\n\t\t\ttmp[i]=Fix(tmp[i-1]+dp[i]);\n\t\t\tres=Fix(res+1ll*dp[i]*(n-i)%Md);\n\t\t}\n\t\tprintf(\"%d\",res+1);\n\t\treturn 0;\n\t}\n\tint res=(cnt==m);\n\tcnt=0;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse{\n\t\t\tif(!cnt)continue;\n\t\t\tif(cnt&1)mx=min(mx,cnt);\n\t\t\tcnt=0;\n\t\t}\n\t}\n\t//for(int i=1;i<=5;++i)cerr<<miu[i]<<' ';cerr<<endl;\n\ttmp[0]=tmp[1]=1;\n\tdp[0]=1;\n\tmx+=2;\n\tif(n<mx)res+=n;\n\tfor(int i=2;i<=n;i+=2){\n\t\tdp[i]=Fix(tmp[i-1]-(mx>i?0:tmp[i-mx]));\n\t\ttmp[i]=tmp[i+1]=Fix(tmp[i-1]+dp[i]);\n\t\t//cerr<<dp[i]<<' '<<i<<endl;\n\t\tif((n-i)%2==0&&n-i<mx)res=Fix(res+1ll*dp[i]*(n-i)%Md);\n\t}\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=200005,M=1000000007;\nusing namespace std;\nint n,m,l=1,k=N,ls,f[N],s[N];\nchar S[N],fi;\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,S);\n\tfi=S[0];\n\tfor(int i=1;i<m;i++)\n\tif(S[i]!=S[i-1])\n\tif(S[i]^fi){\n\t\tif(ls==0||i-ls&1)\n\t\tk=min(k,i-ls);\n\t}else ls=i;\n\tif(k<N){\n\t\tif(n&1)return puts(\"0\"),0;\n\t\tk=k+2>>1,n>>=1;\n\t}else l++;\n\tfor(int i=l;i<=n;i++)\n\tf[i]=(s[i-l]+(i>k?-s[i-k-1]:(3ll-l)*i))%M,s[i]=(s[i-1]+f[i])%M;\n\tprintf(\"%d\",(f[n]+l-1+M)%M);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mo 1000000007\n#define N 200010\nusing namespace std;\nint n,m,a[N],b[N],nb;\nll dp[N],s[N],ans;\nint main(){\n\tcin>>n>>m;\n\tfor (int i=1;i<=m;i++){char ch=getchar();while (ch!='R'&&ch!='B')ch=getchar();a[i]=(ch=='R');}\n\tfor (int la=0,i=1;i<=m;i++)if (a[i]!=a[1]){b[++nb]=i-la-1;la=i;}\n\tif (nb==0){\n\t\ts[0]=s[1]=ans=1;\n\t\tfor (int i=2;i<n;i++)s[i]=(s[i-1]+s[i-2])%mo;\n\t\tfor (int j=0;j<n-1;j++)ans=(ans+s[j])%mo;ans=(ans+s[n-2])%mo;\n\t}else{\n\t\tint ma=b[1];\n\t\tfor (int i=2;i<=nb;i++)if (b[i]%2)ma=max(ma,b[i]);\n\t\tif (ma%2==0)ma++;ma++;\n\t\tdp[0]=1;s[0]=1;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tif (i%2)dp[i]=0;\n\t\t\telse{dp[i]=s[i-1];if (i-ma-1>=0)dp[i]=(dp[i]-s[i-ma-1])%mo;}\n\t\t\ts[i]=(s[i-1]+dp[i])%mo;\n\t\t}\n\t\tfor (int j=n-2;j>=0;j-=2)if (n-j<=ma)ans=(ans+dp[j]*(n-j))%mo;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vec>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\nmain(){\n    ios\n    calc();\n    int n=in(),m=in();\n    string s;cin>>s;\n    bool all_same=true;\n    rep(i,m){\n        if(s[i]!=s[0])all_same=false;\n    }\n    if(!all_same and (n&1)) cout<<0<<endl;\n    else if(all_same and (n&1)){\n        mint dp[n+1][2]={};\n        dp[0][0]=1;\n        rep(i,n-1){\n            dp[i+1][1]+=dp[i][0];\n            dp[i+1][0]+=dp[i][0]+dp[i][1];\n        }\n        mint ans=dp[n-1][0]+dp[n-1][1];\n        rep(i,n)dp[i][0]=dp[i][1]=0;\n        dp[0][1]=1;\n        rep(i,n-1){\n            dp[i+1][1]+=dp[i][0];\n            dp[i+1][0]+=dp[i][0]+dp[i][1];\n        }\n        ans+=dp[n-1][0];\n        cout<<ans.a<<endl;\n    }\n    else{\n        char c=s[0];\n        int mi=INT_MAX;\n        rep(i,m){\n            int cnt=0;\n            while(i<m && s[i]==c)cnt++,i++;\n            chmin(mi,cnt);break;\n        }\n        if(mi %2) mi=mi*2-1;\n        else mi=mi+1;\n        rep(i,m){\n            if(s[i]==c){\n                int cnt=0;\n                while(i<m && s[i]==c)cnt++,i++;\n                if(cnt&1)\n                chmin(mi,cnt);\n            }\n        }\n        mint dp[700000]={};\n        mi=(mi+1)/2;\n        rep(i,mi){\n            dp[i]=2;\n        }\n        dp[mi]=-2*mi;\n        rep(i,n/2){\n            dp[i+1]+=dp[i]*2;\n            dp[i+1+mi]-=dp[i];\n        }\n        cout<<dp[n/2-1].a<<endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define SZ(x) (int)(x).size()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i, a, b) for (int i=a;i>=b;--i)\n\nconst int MX_N = 2e5+5;\nconst int MX_M = 2e5+5;\nconst int MOD = 1e9+7;\n\nint N, M;\nstring S;\n\nint dp[MX_N];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> N >> M;\n    cin >> S;\n\n    bool same = true;\n    FOR(i,0,M-1){\n        same &= S[i] == S[0];\n    }\n\n    if (same) {\n        // dp[i]: no of ways to color s.t. no 2 consec is B & i-th is R\n        int ans = 0;\n        dp[1] = 0; dp[2] = 1;   // 1st is B\n        FOR(i,3,N){\n            dp[i] = (dp[i-1] + dp[i-2]) % MOD;\n        }\n        ans = (ans + dp[N]) % MOD;           // Nth is R\n        dp[1] = 1; dp[2] = 1;   // 1st is R\n        FOR(i,3,N){\n            dp[i] = (dp[i-1] + dp[i-2]) % MOD;\n        }\n        ans = (ans + (dp[N] + dp[N-1]) % MOD) % MOD; // Nth is R and B\n        cout << ans;\n        return 0;\n    }\n\n    if (N&1) {\n        cout << 0;\n        return 0;\n    }\n\n    int k = N, kp = N, cur = 0;\n    FOR(i,0,M-1){\n        if (S[i] != S[0]) {\n            if (k == N) {\n                if (cur&1) k = cur;\n                else k = cur+1;\n            } else if (cur&1) kp = min(kp,cur);\n            cur = 0;\n        } else ++cur;\n    }\n\n    int L = min({N-1,k,kp});\n    N /= 2, L /= 2;\n\n    //cout << \"L is \" << L << endl;\n\n    dp[0] = 0; dp[1] = 1;\n    int sum = 0;\n    FOR(i,2,N){\n        if (i-(L+2) >= 1) {\n            sum = (sum - dp[i-(L+2)] + MOD) % MOD;\n        }\n        if (i-1 >= 1) {\n            sum = (sum + dp[i-1]) % MOD;\n        }\n        dp[i] = sum;\n    }\n\n    int ans = 0;\n    FOR(i,0,L){\n        ans = (ans +  1LL * (i+1) * dp[N-i] % MOD) % MOD;\n    }\n    cout << ans * 2 % MOD;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1000000007;\nint n,m,f[200010],sum[200010],la,mi,ans,jc[200010],inv[200010];\nchar s[200010];\nbool bo;\n\nint quickmi(int a,int b)\n{\n\tint t=1;\n\tfor (; b; b>>=1,a=1ll*a*a%mod)\n\t\tif (b&1) t=1ll*t*a%mod;\n\treturn t;\n}\n\nint calc(int n)\n{\n\tint ans=0;\n\tfor (int i=0; n-i-1>=i; i++)\n\t\tans=(ans+1ll*jc[n-i-1]*inv[i]%mod*inv[n-2*i-1])%mod;\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m),scanf(\"%s\",s),bo=1;\n\tif (s[0]=='B') {for (int i=0; i<m; i++) s[i]=(s[i]=='B'?'R':'B');}\n\tfor (int i=0; i<m; i++) if (s[i]=='B') {bo=0; break;}\n\tif (bo)\n\t{\n\t\tjc[0]=1;\n\t\tfor (int i=1; i<=n; i++) jc[i]=1ll*jc[i-1]*i%mod;\n\t\tinv[n]=quickmi(jc[n],mod-2);\n\t\tfor (int i=n; i; i--) inv[i-1]=1ll*inv[i]*i%mod;\n\t\tans=(calc(n)+2ll*calc(n-1))%mod;\n\t\treturn printf(\"%d\\n\",ans),0;\n\t}\n\tla=-1,mi=1000000000,ans=0;\n\tfor (int i=0; i<m; i++)\n\t\tif (s[i]=='B') \n\t\t{\n\t\t\tif ((i-la-1)&1) mi=min(mi,i-la-1);\n\t\t\telse mi=min(mi,i-la);\n\t\t\tla=i;\n\t\t}\n\tf[0]=sum[0]=1,f[1]=sum[1]=0;\n\tfor (int i=2; i<=n; i++) \n\t{\n\t\tf[i]=sum[i-2]-(i-mi-3<0?0:sum[i-mi-3]);\n\t\tif (f[i]<0) f[i]+=mod;\n\t\tsum[i]=(sum[i-2]+f[i]>=mod?sum[i-2]+f[i]-mod:sum[i-2]+f[i]);\n\t}\n\tfor (int i=0,nw1,nw2; i<=mi&&i<n; i++)\n\t{\n\t\tnw1=(n-i-1-((i&1)^1)>=0?sum[n-i-1-((i&1)^1)]:0);\n\t\tnw2=(n-i-3-(mi-i)>=0?sum[n-i-3-(mi-i)]:0);\n\t\tans+=(nw1<nw2?nw1-nw2+mod:nw1-nw2);\n\t\tif (ans>=mod) ans-=mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define pld pair <ld, ld>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n#define cld complex <double>\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 3e5;\nconst ll mod = 1e9 + 7;\n\nll n, m, k, t;\n\nstring s;\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;\n}\n\nll simple() {\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    ll q;\n    for (q = 1; q < n; q++) {\n        D[q] += D[q - 1];\n        if (q >= 2) {\n            D[q] += D[q - 2];\n            D[q] %= mod;\n        }\n    }\n    return (D[n - 2] * 2 + D[n - 1]) % mod;\n    // if (n % 2 == 1) {\n    //     return \n    // }\n    // return step(2, n / 2 + 1);\n}\n\nint main() {\n    pyshnapyshnakaa\n    ll q, w, e, a, b, c;\n    cin >> n >> m;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (q = 0; q < s.length(); q++) {\n            if (s[q] == 'R') {\n                s[q] = 'B';\n            }\n            else {\n                s[q] = 'R';\n            }\n        }\n    }\n    vector <pll> A;\n    A.pb(mp(1, s[0]));\n    for (q = 1; q < s.length(); q++) {\n        if (s[q] == A.back().second) {\n            A.back().first++;\n        }\n        else {\n            A.pb(mp(1, s[q]));\n        }\n    }\n    // cout << \"FALL\" << endl;\n    bool blue = 0, kill = 0;\n    ll mx = maxn;\n    // cout << \"\"\n    for (q = 0; q < A.size(); q++) {\n        if (A[q].second == 'B') {\n            blue = 1;\n            if (A[q].first == 0) {\n                kill = 0;\n            }\n        }\n        else {\n            if (!(A[q].first % 2 == 0 && kill)) {\n                mx = min(mx, A[q].first + 1 - A[q].first % 2);\n            }\n            kill = 0;\n        }\n    }\n    // cout << \"MX \" << mx << endl;\n    // if (fail) {\n    //     cout << 0;\n    //     return 0;\n    // }\n    if (!blue) {\n        cout << simple();\n        return -1;\n    }\n    // ll mx = maxn, cur = 0;\n    // for (q = 0; q < s.length(); q++) {\n    //     if (s[q] == 'B') {\n    //         if (cur % 2 == 1) {\n    //             mx = min(mx, cur);\n    //         }\n    //         else {\n    //             mx = min(mx, cur + 1);\n    //         }\n    //         cur = 0;\n    //     }\n    //     else {\n    //         cur++;\n    //     }\n    // }\n    vector <ll> S(2);\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    S[0] = 1;\n    for (q = 1; q < n; q++) {\n        D[q] = S[q % 2];\n        S[q % 2] = (S[q % 2] + D[q]) % mod;\n        ll deli = q - mx - 1;\n        if (deli >= 0) {\n            // cout << \"DELETING \" << q << endl;\n            S[deli % 2] = (S[deli % 2] - D[deli] + mod) % mod;\n        }\n        // cout << q << \" \" << D[q] << endl;\n    }\n    // cout << \"mx \" << mx << endl;\n    ll ans = 0;\n    for (q = 0; q < n; q++) {\n        ll len = n - q - 1;\n        if (len % 2 == 0 || len > mx) {\n            continue;\n        }\n        ans += D[q] * (len + 1) % mod;\n        ans %= mod;\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline tuple<int, int, int> extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nunsigned ModInt::MOD = 1000000007;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\n\nvector<mint> Fact, InvFact;\nvoid makeFact(int n){\n\tFact = vector<mint>(n+1);\n\tFact[0] = mint(1);\n\trep(i,1,n+1) Fact[i] = mint(i) * Fact[i-1];\n\n\tInvFact = vector<mint>(n+1);\n\tInvFact[n] = mint(1) / Fact[n];\n\trrep(i,n) InvFact[i] = mint(i+1) * InvFact[i+1];\n}\n\nmint Factorial(int n){ return Fact[n];}\nmint InverseFactorial(int n){ return InvFact[n];}\nmint Permutation(int n,int k){ return (n < 0 or k < 0 or n - k < 0) ? ZERO : Fact[n] * InvFact[n - k];}\nmint Combination(int n,int k){ return (n < 0 or k < 0 or n - k < 0) ? ZERO : Fact[n] * InvFact[k] * InvFact[n-k];}\n\n\nconst int limit = 200010;\nmint dp[limit][2][2];\nmint dp2[limit];\nmint csum2[limit];\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\n\tmakeFact(2 * limit);\n\n\tbool same = true;\n\trep(i, m) if(s[0] != s[i]) same = false;\n\n\tif(same){\n\t\tdp[1][0][0] = ONE;\n\t\tdp[1][1][1] = ONE;\n\t\trep(i, 1, n) rep(start, 2) rep(prv, 2){\n\t\t\tdp[i + 1][start][0] += dp[i][start][prv];\n\t\t\tif(prv == 0) dp[i + 1][start][1] += dp[i][start][prv];\n\t\t}\n\t\tmint ans = dp[n][0][0] + dp[n][0][1] + dp[n][1][0];\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\t\t\n\tif(n % 2 == 1){\n\t\tcout << ZERO << endl;\n\t\treturn 0;\n\t}\n\n\tint cmin = m, cons = 0;\n\trep(i, m){\n\t\tif(s[i] == s[0]){\n\t\t\tcons++;\n\t\t} else {\n\t\t\tchmin(cmin, cons);\n\t\t}\n\t}\n\n\tif(cmin % 2 == 0) cmin++;\n\tdp2[1] = csum2[1] = ONE;\n\n\trep(i, 1, n){\n\t\tconst int pos = max(i - cmin - 1, 0);\n\t\tif((i + 1) % 2 == 1) dp2[i + 1] =  csum2[i] - csum2[pos];\n\t\tcsum2[i + 1] = csum2[i] + dp2[i + 1];\n\t}\n\n\tmint ans = ZERO;\n\n\trep(i, n - cmin, n + 1){\n\t\tif(n - i % 2 == 0) continue;\n\t\tconst mint coef = mint(n - i + 1);\n\t\tans += coef * dp2[i];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vec>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\nmain(){\n    ios\n    calc();\n    int n=in(),m=in();\n    string s;cin>>s;\n    bool all_same=true;\n    rep(i,m){\n        if(s[i]!=s[0])all_same=false;\n    }\n    if(!all_same and (n&1)){\n        assert(0);\n    }\n    else if(all_same ){\n        mint dp[n+1][2]={};\n        dp[0][0]=1;\n        rep(i,n-1){\n            dp[i+1][1]+=dp[i][0];\n            dp[i+1][0]+=dp[i][0]+dp[i][1];\n        }\n        mint ans=dp[n-1][0]+dp[n-1][1];\n        rep(i,n)dp[i][0]=dp[i][1]=0;\n        dp[0][1]=1;\n        rep(i,n-1){\n            dp[i+1][1]+=dp[i][0];\n            dp[i+1][0]+=dp[i][0]+dp[i][1];\n        }\n        ans+=dp[n-1][0];\n        cout<<ans.a<<endl;\n    }\n    else{\n        char c=s[0];\n        int mi=INT_MAX;\n        rep(i,m){\n            int cnt=0;\n            while(i<m && s[i]==c)cnt++,i++;\n            chmin(mi,cnt);break;\n        }\n        if(mi %2 ==0)mi++;\n        rep(i,m){\n            if(s[i]==c){\n                int cnt=0;\n                while(i<m && s[i]==c)cnt++,i++;\n                if(cnt&1)\n                chmin(mi,cnt);\n            }\n        }\n        mint dp[700000]={};\n        mi=(mi+1)/2;\n        rep(i,mi){\n            dp[i]=2;\n        }\n        dp[mi]=-2*mi;\n        rep(i,n/2){\n            dp[i+1]+=dp[i]*2;\n            dp[i+1+mi]-=dp[i];\n        }\n        cout<<dp[n/2-1].a<<endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MAX_N 200000\n#define MAX_M 200000\n#define MOD 1000000007\n\n#define INF 1 << 29\n\nint N, M;\nstring S;\n\n// long long dp[MAX_N + 2], rdp[MAX_N + 2];\n\n// int all_color_is_same()\n// {\n//     long long rr = 1, bb = 1, rb = 0, br = 0;\n\n//     for ( int i = 1; i < N; i++ )\n//     {\n//         long long nrr = ( rr + rb ) % MOD;\n//         long long nbb = br;\n//         long long nrb = rr;\n//         long long nbr = ( bb + br ) % MOD;\n\n//         rr = nrr;\n//         bb = nbb;\n//         rb = nrb;\n//         br = nbr;\n//     }\n\n//     return ( rr + rb + br ) % MOD;\n// }\n\n// /**\n\n/* S\nの先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n*/\nint min_freq()\n{\n    // Int l = 0;\n    // while ( S[0] == S[l] ) l++;\n    // if ( l % 2 == 0 ) l++;\n    // Int limit = l;\n    // l = 0;\n    // for ( int i = 0; i < M; i++ )\n    // {\n    //     if ( S[i] == S[0] )\n    //         l++;\n    //     else\n    //     {\n    //         if ( l % 2 == 1 ) limit = min( limit, l );\n    //         l = 0;\n    //     }\n    // }\n    int l = 0;\n    while ( S[0] == S[l] ) l++;\n\n    int ans = ( l & 1 ) ? l : l + 1;\n\n    l = 0;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[0] == S[i] )\n            l++;\n        else\n        {\n            if ( l & 1 ) ans = min( ans, l );\n            l = 0;\n        }\n    }\n    return l ? min( ans, l ) : ans;\n}\n\n// int solve()\n// {\n//     // 一色\n//     if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n//         return all_color_is_same();\n\n//     // N が奇数\n//     if ( N & 1 ) return 0;\n\n//     int L = min_freq();\n\n//     L = ( L + 1 ) >> 1;\n//     N >>= 1;\n\n//     dp[0] = rdp[0] = 1;\n//     for ( int i = 1; i <= N + 1; i++ )\n//     {\n//         dp[i] = rdp[i - 1];\n//         if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n//         if ( dp[i] < 0 ) dp[i] += MOD;\n//         rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n//     }\n\n//     long long res = 0;\n//     for ( int i = 1; i <= L; i++ )\n//         if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n//     return res % MOD;\n// }\n\n// int main( int argc, char **argv )\n// {\n//     cin >> N >> M;\n//     cin >> S;\n\n//     int ans = solve();\n\n//     cout << ans << endl;\n\n//     return 0;\n// }\n// #include <algorithm>\n// #include <iostream>\n// #include <string>\n\n// using namespace std;\n\n// #define MOD 1000000007\n// #define INF ( 1 << 29 )\n// #define LINF ( 1LL << 60 )\n// #define EPS ( 1e-10 )\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt all( Int n )\n{ // no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for ( int i = 1; i < n; i++ )\n    {\n        Int nrr = ( rr + rb ) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = ( bb + br ) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return ( rr + rb + br ) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc( Int n, Int limit )\n{\n    dp[0] = 1;\n    rdp[0] = 1;\n    for ( int i = 1; i <= n + 1; i++ )\n    {\n        dp[i] = ( rdp[i - 1] -\n                  ( ( i - limit - 1 ) >= 0 ? rdp[i - limit - 1] : 0 ) ) %\n                MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n}\n\nInt solve( Int n, Int limit )\n{\n    if ( n % 2 == 1 ) return 0;\n    if ( limit % 2 != 1 ) exit( 1 );\n    limit = ( limit + 1 ) / 2;\n    n /= 2;\n    Int res = 0;\n    calc( n + 10, limit );\n    for ( Int i = 1; i <= limit; i++ )\n    {\n        if ( n - i >= 0 ) res = ( res + dp[n - i] * 2 * i ) % MOD;\n    }\n    if ( res < 0 ) exit( 1 );\n    return res % MOD;\n}\n\nint main()\n{\n    cin >> N >> M;\n    cin >> S;\n\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n    {\n        cout << all( N ) << endl;\n        return 0;\n    }\n\n    int limit = min_freq();\n    cout << solve( N, limit ) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact, _inv;\n\n  Combination(ll sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for(ll i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(ll i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for(ll i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(ll k) const { return _fact[k]; }\n\n  inline T rfact(ll k) const { return _rfact[k]; }\n\n  inline T inv(ll k) const { return _inv[k]; }\n\n  T P(ll n, ll r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n\n  T H(ll n, ll r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\nusing modint = ModInt< MOD1 >;modint pow(ll n, ll x){return modint(n).pow(x);}modint pow(modint n, ll x){return n.pow(x);}\n//using modint=ld;\nusing Comb=Combination<modint>;\n\n\ntemplate<typename T>\nstruct BIT{\n  ll n;\n  ll k=1;\n  vector<T>data;\n  BIT() = default;\n  BIT(ll size):n(size){\n    data.assign(n,0);\n    while(k*2<=n)k*=2;\n  }\n  void add(ll a,T w){\n    for(ll i=a+1;i<=n;i+=i&-i)data[i-1]+=w;\n  }\n  T sum(ll a){\n\tif(a<0)return 0;\n    T ret = 0;\n    for(ll i=a+1;i>0;i-=i&-i)ret+=data[i-1];\n    return ret;\n  }\n  T sum(ll a,ll b){return a>b?0:sum(b)-sum(a-1);}\n  T operator[](ll pos){\n    return sum(pos,pos);\n  }\n  ll lower_bound(ll x){\n    ll ret=0;    \n    for(ll i=k;i>0;i/=2){\n      if(ret+i<=n&&data[ret+i-1]<x){\n        x-=data[ret+i-1];\n        ret+=i;\n      }\n    }\n    return ret;\n  }\n  void print(){\n    for(ll i=0;i<n;i++){\n      if(i!=0)cout<<\" \";\n      cout<<(*this)[i];\n    }\n    cout<<endl;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,m;cin>>n>>m;\n  string s;cin>>s;\n  if(s[0]=='B'){\n    rep(i,0,m){\n      if(s[i]=='R')s[i]='B';\n      else s[i]='R';\n    }\n  }\n  ll mx=INF;\n  {\n    vector<ll>v;\n    ll cnt=0;\n    rep(i,0,m){\n      if(s[i]=='R')cnt++;\n      else{\n        v.PB(cnt);\n        cnt=0;\n      }\n    }\n    if(v.empty()){\n      modint tmp=0;\n      Comb comb(300005);\n      rep(i,0,n+1){\n        tmp+=comb.C(n-i-1,i-1)*2+comb.C(n-i-1,i);\n      }\n      cout<<tmp<<endl;\n      return 0;\n    }\n    rep(i,0,v.size()){\n      if(i==0||v[i]&1)chmin(mx,v[i]);\n    }\n    if(~mx&1)mx++;\n  }\n  if(n&1){\n    cout<<0<<endl;\n    return 0;\n  }\n  vector<modint>v(n+1);\n  BIT<modint>bit(n+1);\n  bit.add(0,1);\n  rep(i,0,n){\n    if(~i&1)continue;\n    bit.add(i+1,bit.sum(max(0LL,i-mx),i));\n  }\n  modint ret=0;\n  rep(i,0,n+1){\n    ret+=bit.sum(max(0LL,n-mx-1),n-i-1);\n    //cout<<n-mx-1 spa n-i spa bit.sum(n-mx-1,n-i)<<endl;\n  }\n  //bit.print();\n  //debug(v,n+1);\n  cout<<ret<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 200100;\nconst int mod = 1e9 + 7;\nconst int oo = 1e9;\nlong long power(long long x, long long k)\n{\n\tlong long ans = 1;\n\twhile(k)\n\t{\n\t\tif(k & 1)\n\t\t\t(ans *= x) %= mod;\n\t\tk >>= 1;\n\t\t(x *= x) %= mod;\n\t}\n\treturn ans;\n}\nint n, m;\nchar s[maxn];\nint l = oo;\nlong long ans = 0;\nlong long dp[maxn][2][2] = {0}, h[maxn][2][2] = {0}, f[maxn];\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(int i = 1; i <= m; i ++)\n\t\tcin >> s[i];\n\twhile(s[m] == s[1] && m >= 1)\n\t\tm --;\n\tif(m != 0)\n\t{\n\t\tint len;\n\t\tfor(len = 1; len <= m && s[len] == s[1]; len ++);\n\t\tlen --;\n\t\tif(len & 1)\n\t\t\tl = min(l, len);\n\t\telse\n\t\t\tl = min(l, len + 1);\n\t\tint now = 0;\n\t\tfor(int i = len + 2; i <= m; i ++)\n\t\t{\n\t\t\tif(s[i] != s[1])\n\t\t\t{\n\t\t\t\tif(now & 1)\n\t\t\t\t\tl = min(l, now);\n\t\t\t\tnow = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tnow ++;\n\t\t}\n\t}\n\tif(m == 0)\n\t{\n\t\tf[0] = 2;\n\t\tf[1] = 1;\n\t\tfor(int i = 2; i <= n; i ++)\n\t\t\tf[i] = (f[i - 1] + f[i - 2]) % mod;\n\t\tcout << f[n] << endl;\n\t\treturn 0;\n\t}\n\tif(n & 1)\n\t{\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tn >>= 1;\n\tl >>= 1;\n\t//cout << n << \" \" << l << endl;\n\tdp[1][0][0] = h[1][0][0] = 1;\n\tdp[1][1][1] = h[1][1][1] = (l > 0);\n\t//dp[0][0][0] = dp[0][1][1] = h[0][0][0] = h[0][1][1] = 1;\n\tfor(int i = 2; i <= n; i ++)\n\t{\n\t\t//cout << i << \" : \" << endl;\n\t\tdp[i][0][0] = (dp[i - 1][0][1] + dp[i - 1][0][0]) % mod;\n\t\tdp[i][0][1] = (h[i - 1][0][0] - h[max(0, i - l - 1)][0][0] + mod) % mod;\n\t\tdp[i][1][0] = (dp[i - 1][1][1] + dp[i - 1][1][0]) % mod;\n\t\tdp[i][1][1] = (h[i - 1][1][0] - h[max(0, i - l - 1)][1][0] + mod) % mod;\n\t\tif(i <= l)\n\t\t\tdp[i][1][1] ++;\n\t\tfor(int asd1 = 0; asd1 < 2; asd1 ++)\n\t\t\tfor(int asd2 = 0; asd2 < 2; asd2 ++)\n\t\t\t\th[i][asd1][asd2] = (h[i - 1][asd1][asd2] + dp[i][asd1][asd2]) % mod;\n\t\t//cout << dp[i][0][0] << \" \" << dp[i][0][1] << \" \" << dp[i][1][0] << \" \" << dp[i][1][1] << endl;\n\t\t//cout << h[i][0][0] << \" \" << h[i][0][1] << \" \" << h[i][1][0] << \" \" << h[i][1][1] << endl;\n\t}\n\tfor(int i = 1; i <= min(l, n); i ++)\n\t\tdp[i][1][1] --;\n\tlong long ans = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\t(ans += (n - i) * dp[i][1][1]) %= mod;\n\t\tif(i <= l && n - i > 1)\n\t\t\t(ans += (n - i)) %= mod;\n\t\tif(n - i <= l && i >= 2)\n\t\t\t(ans += (n - i) * dp[i][0][0]) %= mod;\n\t\t//cout << i << \" \" << ans << endl;\n\t}\n\tans ++;\n\t//cout << ans << endl;\n\tif((l >= n - 1) && n != 1)\n\t\tans += n;\n\tcout << ans * 2 + (m == 0 && n != 1) << endl;\n\treturn 0;\n}\n/*\n1 3\nBBB\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nconst int md = 1e9 + 7;\n\nint dp[N];\n\nsigned main() {\n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n  vector<int> y;\n  for (int i = 0; i < m; i++) {\n    int cnt = 1;\n    while (i + 1 < m && s[i + 1] == s[i]) {\n      ++i;\n      ++cnt;\n    }\n    y.push_back(cnt);\n  }\n  if (y.size() == 1) {\n    vector<int> f(n + 1), g(n + 1);\n    f[1] = 2, f[2] = 3;\n    for (int i = 3; i <= n; i++) {\n      f[i] = (f[i - 1] + f[i - 2]) % md;\n    }\n    g[2] = 3, g[3] = 4;\n    for (int i = 4; i <= n; i++) {\n      g[i] = (f[i - 1] + f[i - 3]) % md;\n    }\n    cout << g[n] << '\\n';\n    return 0;\n  } else if (n % 2 == 1) {\n    cout << 0 << '\\n';\n    return 0;\n  }\n  y.pop_back();\n  if (y.empty()) return cout << \"O\", 0;\n  int C = y[0] + 1;\n  bool is = true;\n  for (int x : y) {\n    if (is && (x % 2 == 1)) {\n      C = min(C, x);\n    }\n    is ^= 1;\n  }\n  dp[0] = dp[2] = 1;\n  for (int i = 4; i < N; i += 2) {\n    dp[i] = 2 * dp[i - 2] % md;\n    if (i - 3 - C >= 0) {\n      (dp[i] += md - dp[i - 3 - C]) %= md;\n    }\n  }\n  int ans = dp[n];\n  for (int l = 1; l <= C; l += 2) {\n    if (n - l - 1 >= 0) {\n      (ans += l * dp[n - l - 1] % md) %= md;\n    }\n  }\n  ((ans %= md) += md) %= md;\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n//#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MaxN = 2e5 + 100;\nconst int Mod = 1e9 + 7;\n\nint dp[MaxN];\nint pref_dp[MaxN];\n\nint small_dp[MaxN][2][2];\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N, M;\n  string s;\n  cin >> N >> M >> s;\n\n  if (count(ALL(s), s[0]) == M) {\n    small_dp[1][1][1] = small_dp[1][0][0] = 1;\n    for (int len = 2; len <= N; ++len) {\n      for (int fst : {0, 1}) {\n        // add gut\n        small_dp[len][fst][0] =\n          (small_dp[len - 1][fst][0] + small_dp[len - 1][fst][1]) % Mod;\n        // add no gut\n        small_dp[len][fst][1] = small_dp[len - 1][fst][0];\n      }\n    }\n\n    int ans = 0;\n    for (int x : {0, 1}) {\n      for (int y : {0, 1}) {\n        if (x + y <= 1) {\n          ans = (ans + small_dp[N][x][y]) % Mod;\n        }\n      }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n  }\n\n  if (s[0] != s[1]) {\n    cout << \"2\\n\";\n    return 0;\n  }\n\n  int min_seg_len = N - 1;\n  int cur_len = 0;\n  for (char ch : s) {\n    if (ch == s[0]) {\n      ++cur_len;\n    } else {\n      if (cur_len) { mini(min_seg_len, cur_len); }\n      cur_len = 0;\n    }\n  }\n  if (cur_len) { mini(min_seg_len, cur_len); }\n\n\n  int answer = 0;\n\n  dp[0] = pref_dp[2] = 1;\n\n  const int min_jump = 2;\n  int max_jump = min_seg_len + 2;\n  // jump must be even as well\n  if (max_jump % 2 == 1) { --max_jump; }\n\n  debug(min_jump, max_jump);\n\n  for (int len = 1; len <= N; ++len) {\n    const int add_from = max(0, len - max_jump);\n    const int add_to = len - min_jump;\n\n    if (add_from <= add_to) {\n      dp[len] = pref_dp[add_to + 2] - pref_dp[add_from];\n      if (dp[len] < 0) { dp[len] += Mod; }\n    }\n\n    debug(len, dp[len]);\n\n    pref_dp[len + 2] = (pref_dp[len] + dp[len]) % Mod;\n  }\n\n  for (int chain_len = 0; chain_len < N; ++chain_len) {\n    const int rem_len = N - chain_len;\n    if (2 <= rem_len && rem_len <= max_jump) {\n      const int coef = dp[chain_len];\n      answer = (answer + (LL)coef * (rem_len )) % Mod;\n    }\n  }\n\n  cout << answer << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n;i++){\n        dp[i-1] = dp[i];\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    return res;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i <= m;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, m;\nlong long Mod = 1000000007, InvF[401000],F[401000], D[401000], S[401000];\nchar p[301000];\nlong long Pow(long long a, long long b) {\n\tlong long r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = r * a%Mod;\n\t\ta = a * a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nlong long Comb(int n, int k) {\n\treturn F[n] * InvF[k] % Mod*InvF[n - k] % Mod;\n}\nlong long Get(int a, int b) {\n\tif (b < 0 || a <= 0)return 0;\n\treturn Comb(a + b - 1, b);\n}\nlong long DD[401000][2][2];\nint main() {\n\tint i, j;\n\tF[0] = 1;\n\tfor (i = 1; i <= 400000; i++)F[i] = F[i - 1] * i%Mod;\n\tInvF[400000] = Pow(F[400000], Mod - 2);\n\tfor (i = 400000; i >= 1; i--)InvF[i - 1] = InvF[i] * i%Mod;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", p);\n\tint ck = 0;\n\tfor (i = 0; p[i]; i++) {\n\t\tif (p[i] == 'R')ck |= 1;\n\t\tif (p[i] == 'B')ck |= 2;\n\t}\n\tif (ck!=3) {\n\t\tDD[1][0][0] = 1;\n\t\tDD[1][1][1] = 1;\n\t\tfor (i = 2; i <= n; i++) {\n\t\t\tDD[i][0][0] = (DD[i - 1][0][0] + DD[i - 1][0][1]) % Mod;\n\t\t\tDD[i][0][1] = (DD[i - 1][0][0]) % Mod;\n\t\t\tDD[i][1][0] = (DD[i - 1][1][0] + DD[i - 1][1][1]) % Mod;\n\t\t\tDD[i][1][1] = (DD[i - 1][1][0]) % Mod;\n\t\t}\n\t\tprintf(\"%lld\\n\", (DD[n][0][0] + DD[n][0][1] + DD[n][1][0]) % Mod);\n\t\treturn 0;\n\t}\n\tif (n % 2 == 1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tif (p[0] == 'B') {\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tp[i] = 'R' + 'B' - p[i];\n\t\t}\n\t}\n\tint c = 0, Mn = 1e9;\n\tck = 0;\n\tfor (i = 0; i < m; i++) {\n\t\tif (p[i] == 'R') {\n\t\t\tc++;\n\t\t\tif (i == m - 1 || p[i + 1] == 'B') {\n\t\t\t\tif (!ck) {\n\t\t\t\t\tif (c % 2 == 0)Mn = min(Mn, c + 1);\n\t\t\t\t\telse Mn = min(Mn, c);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (c % 2 == 1)Mn = min(Mn, c);\n\t\t\t\t}\n\t\t\t\tck = 1;\n\t\t\t}\n\t\t}\n\t\telse c = 0;\n\t}\n\n\tint K = (Mn + 1) / 2;\n\tD[0] = 1;\n\tS[0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tlong long t = S[i - 1];\n\t\tif (i - K - 1 >= 0)t -= S[i - K - 1];\n\t\tD[i] = (t + Mod) % Mod;\n\t\tS[i] = (S[i - 1] + D[i]) % Mod;\n\t}\n\tlong long res = D[n / 2];\n\tfor (i = 1; i <= Mn && i<=n; i+=2) {\n\t\tres = (res + 1ll*i*D[(n - i - 1) / 2])%Mod;\n\t}\n\tprintf(\"%lld\\n\", res);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\nusing namespace std;\nconst int mod=1e9+7;\nint n,m,i,lst,dp[200005],s[200005],f[200005][2],tmp,mi=0x3f3f3f3f,l;\nstring st;\nint main(){\n\tcin>>n>>m;\n\tcin>>st;\n\tst=\" \"+st;\n\ti=1;lst=1;\n\twhile(i<=n){\n\t\tif(st[i]!=st[i-1]){\n\t\t\tif(st[i]!=st[1]){\n\t\t\t\tif(lst==1||((i-lst)&1)){\n\t\t\t\t\tmi=min(mi,i-lst);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlst=i;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tif(mi<0x3f3f3f3f){\n\t\tif(n&1){\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\tmi=mi/2+1;\n\t\tn/=2;\n\t\tl=1;\n/*\t\ts[1]=1;s[mi+1]+=mod-1;\n\t\trep(i,n){\n\t\t\ttmp=(tmp+s[i])%mod;\n\t\t\tdp[i]=tmp;\n\t\t\ts[min(n,i+1)]=(s[min(n,i+1)]+dp[i])%mod;\n\t\t\ts[min(n,i+mi)+1]=(s[min(n,i+mi)+1]+mod-dp[i])%mod;\n\t\t}\n\t\tcout<<dp[n]<<endl;*/\n\t}\n\telse{\n\t\tl=2;\n\t}\n\tfor(i=l;i<=n;i++){\n\t\tdp[i]=(s[i-l]+(i>mi?-s[i-mi-1]:(3ll-l)*i))%mod;\n\t\ts[i]=(s[i-1]+dp[i])%mod;\n\t}\n\tcout<<(dp[n]+l-1+mod)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n 　　　　　／＞　 フ\n 　　　　　| 　_　 _|\n 　 　　　／`ミ _x 彡\n 　　 　 /　　　 　 |\n 　　　 /　  ヽ　　 ?\n 　／￣|　　 |　|　|\n 　| (￣ヽ＿_ヽ_)_)\n 　＼二つ\n  */\n\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MP make_pair\n#define ll long long\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; bool f = 0;\n    char c = getchar();\n    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;\n    for (;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if (f) x=-x;\n}\n\ntemplate<typename F>\ninline void write(F x, char ed = '\\n') {\n    static short st[30];short tp=0;\n    if(x<0) putchar('-'),x=-x;\n    do st[++tp]=x%10,x/=10; while(x);\n    while(tp) putchar('0'|st[tp--]);\n    putchar(ed);\n}\n\ntemplate <typename T>\ninline void Mx(T &x, T y) { x < y && (x = y); }\n\ntemplate <typename T>\ninline void Mn(T &x, T y) { x > y && (x = y); }\n\nconst int P = 1e9 + 7;\nconst int N = 400005;\nchar s[N];\nint sum[N], f[N], a[N], m, n;\nll inv[N], fac[N], ans;\ntemplate <typename T>\ninline void Add(T &x, T y) { x += y, x >= P && (x -= P, 0); }\n\ninline ll C(int n, int m) {\n    if (n < m || n < 0) return 0;\n    return fac[n] * inv[m] % P * inv[n-m] % P;\n}\n\nnamespace subtask {\n    int main(int lim) {\n        if (n & 1) return write(0), 0;\n        int pre = 1;\n        for (int i = 1;i <= m; i++) if (!a[i]) {\n            if ((i - pre) & 1) Mn(lim, i - pre);\n            pre = i + 1;\n        }\n        n >>= 1, lim = (lim + 1) >> 1;\n        f[0] = sum[0] = 1;\n        for (int i = 1;i <= n; i++) {\n            f[i] = sum[i-1] - (i >= lim + 1 ? sum[i - lim - 1] : 0), Add(f[i], P);\n            sum[i] = sum[i-1], Add(sum[i], f[i]);\n        }\n        for (int i = 1;i <= lim; i++)\n            Add(ans, 1ll * f[n-i] * i * 2 % P);\n        write(ans);\n        return 0;\n    }\n}\n\nint main() {\n    read(n), read(m), scanf (\"%s\", s + 1);\n    for (int i = 1;i <= m; i++) a[i] = s[i] == s[1];\n    for (int i = 1;i <= m; i++)\n        if (!a[i]) return subtask::main((i - 1) | 1);\n    if (n == 1) return write(0), 0;\n    inv[0] = inv[1] = fac[0] = fac[1] = 1;\n    for (int i = 2;i <= n + 2; i++) \n        inv[i] = (P - P / i) * inv[P % i] % P;\n    for (int i = 2;i <= n + 2; i++)\n        inv[i] = inv[i-1] * inv[i] % P, fac[i] = fac[i-1] * i % P;\n    for (int i = 0;i + i <= n; i++) \n        ans += C(n - i, i) + C(n - 2 - i, i);\n    write(ans % P);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(long long i=0; i<(long long)(n); i++)\n#define REP(i, k, n) for(long long i=(long long)(k); i<(long long)(n); i++)\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n#define PQ(T) priority_queue<T>\n#define PQS(T) priority_queue<T, vector<T>, greater<T> >\n#define deci cout << fixed << setprecision(15);\ntypedef long long ll;\nconst ll inf = 1020304050607080910;\nconst int mod = 1000000007;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T> bool chmin(T&x,T y){if(x>y){x=y;return true;}return false;}\ntemplate<class T> bool chmax(T&x,T y){if(x<y){x=y;return true;}return false;}\nll gcd(ll x,ll y){if(x>y)swap(x, y);while(x!=0){y%=x;swap(x, y);}return y;}\nll mpow(ll x,ll r){if(r==0)return 1;if(r%2==1){return x*mpow(x,r-1)%mod;}else{ll aa=mpow(x,r/2);return aa*aa%mod;}}\n\nll N, M, ans, cnt, ch, f, mi = 1e9, dp[200010], s1[200010], s2[200010];\nstring S;\nchar c;\n\nconst int MAX = 300002;\n\n// fac[]・・・a! finv[]・・・(a!)^(-1) inv[]・・・a^(-1)\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid pre_comb(void){\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2; i<MAX; i++){\n\t\tfac[i] = fac[i-1] * i % mod;\n\t\tinv[i] = mod - inv[mod%i] * (mod/i) % mod;\n\t\tfinv[i] = finv[i-1] * inv[i] % mod;\n\t}\n}\n\nlong long comb(int n, int k){\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\n\nint main(){\n\tpre_comb();\n\tcin >> N >> M >> S;\n\trep(i, M){\n\t\tif(i==0){\n\t\t\tcnt = 1; c = S[i];\n\t\t}else{\n\t\t\tif(S[i] != S[i-1]){\n\t\t\t\tch = 1;\n\t\t\t\tif(f == 0){\n\t\t\t\t\tif(cnt % 2 == 0) cnt++;\n\t\t\t\t\tchmin(mi, cnt);\n\t\t\t\t\tf = 1;\n\t\t\t\t}else if(S[i-1] == c){\n\t\t\t\t\tif(cnt % 2 == 1) chmin(mi, cnt);\n\t\t\t\t}\n\t\t\t\tcnt = 1;\n\t\t\t}else cnt++;\n\t\t}\n\t}\n\tif(!ch){\n\t\trep(i, N/2+1){\n\t\t\tif(i==0) ans++;\n\t\t\telse{\n\t\t\t\tans = (ans + comb(N-i+1, i))%mod;\n\t\t\t\tif(i >= 2){\n\t\t\t\t\tans = (ans + mod - comb(N-i-1, i-2))%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\tdp[0] = 0, dp[1] = 1, dp[2] = 0;\n\ts1[1] = 1, s1[2] = 0;\n\ts2[1] = 1, s2[2] = 0;\n\tREP(i, 3, N){\n\t\tif(i % 2 == 1){\n\t\t\tif(i <= mi+2){\n\t\t\t\tdp[i] = (i-1)/2;\n\t\t\t}else{\n\t\t\t\tdp[i] = (2*mi-i+3)/2;\n\t\t\t}\n\t\t}\n\t\tif(i <= mi && i % 2 == 1) dp[i]++;\n\t\tif(i > 4){\n\t\t\tif((i-3)/2 <= mi){\n\t\t\t\tdp[i] = (dp[i] + s1[i-4]) % mod;\n\t\t\t}else{\n\t\t\t\tdp[i] = (dp[i] + s1[i-4] + mod - (s1[i-2*mi-4]+mi*s2[s2[i-2*mi-4]])%mod)%mod;\n\t\t\t}\n\t\t}\n\t\ts1[i] = (s1[i-2] + s2[i-2] + dp[i]) % mod;\n\t\ts2[i] = (s2[i-2] + dp[i]) % mod;\n\t}\n\tif(N-1 <= mi) ans = N;\n\tfor(int i=1; i<=mi && i<=N-3; i=i+2){\n\t\tans = (ans + dp[N-i-2]*(i+1)%mod)%mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 1e9 + 7; // change if needed\n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\nconst int MAX_N = 2e5 + 5;\n\nModint dp [MAX_N];\nModint cdp [MAX_N];\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  cin >> n >> m;\n\n  string s;\n  cin >> s;\n\n  if (s[0] == 'B') {\n    for (int i = 0; i < m; i++) {\n      if (s[i] == 'R') s[i] = 'B';\n      else s[i] = 'R';\n    }\n  }\n\n  vector<int> blocks;\n  for (int i = 0; i < m; i++) {\n    if (s[i] == 'R') {\n      if (i == 0 || s[i - 1] == 'B') {\n        blocks.push_back(0);\n      }\n      blocks.back()++;\n    }\n  }\n\n  if (s.back() == 'R') {\n    blocks.pop_back();\n  }\n\n  if (blocks.empty()) {\n    // special case\n    // just count the # of assignments\n    // such that the blue things are singletons\n    Modint ans (1 + n); // the all-red case\n    dp[1] = Modint(1);\n    cdp[1] = Modint(1);\n    for (int i = 2; i < n; i++) {\n      dp[i] = cdp[i - 2];\n      cdp[i] = cdp[i - 1] + dp[i];\n      ans += Modint(n + 1 - i) * dp[i];\n    }\n    cout << ans << endl;\n    return 0;\n  }\n\n  int ub = n;\n  for (int block : blocks) {\n    if (block % 2 == 1) {\n      ub = min(ub, block + 1);\n    }\n  }\n\n  ub = min(ub, blocks[0] + 1);\n  if (ub % 2 == 1) {\n    ub++;\n  }\n\n  // do some DP to count the # of ways\n  // to split a circle into odd-length pieces\n  // separated by singleton pieces\n  // such that each segment has length <= lb\n\n  if (n % 2 != 0) {\n    cout << 0 << endl;\n    return 0;\n  }\n  \n  Modint ans (0);\n  dp[1] = Modint(1);\n  cdp[1] = Modint(1);\n  if (n <= ub) {\n    ans += Modint(n) * dp[1];\n  }\n  \n  for (int i = 3; i <= n; i += 2) {\n    dp[i] = cdp[i - 2] - cdp[max(0, i - ub - 2)];\n    cdp[i] = cdp[i - 2] + dp[i];\n\n    if (n + 1 - i <= ub) {\n      ans += Modint(n + 1 - i) * dp[i];\n    }\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//I forgot you...\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = (int)1e9 + 7;\nconst int MAXN = (int)2e5 + 3;\nconst int infint = (int)1e9 + 3;\nconst ll inf = (ll)1e18;\nint n, m, ans, mika = infint, dp[MAXN], part[MAXN];\nstring s;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif(c >= MOD)\n\t\tc -= MOD;\n\tif(c < 0)\n\t\tc += MOD;\n\treturn c;\n}\nint mul(int a, int b)\n{\n\tint c = 1LL * a * b % MOD;\n\treturn c;\n}\nvoid find_mika()\n{\n\tif(s[0] == 'R')\n\t{\n\t\tint ted = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif(s[i] == 'R')\n\t\t\t\tted++;\n\t\t\telse\n\t\t\tif(s[i] == 'B' && ted > 0)\n\t\t\t{\n\t\t\t\tif(ted % 2)\t\n\t\t\t\t\tmika = min(mika, ted);\n\t\t\t\telse\n\t\t\t\t\tmika = min(mika, ted + 1);\n\t\t\t\tted = 0;\n\t\t\t}\n\t\tif(ted > 0)\n\t\t{\n\t\t\tif(ted % 2)\n\t\t\t\tmika = min(mika, ted);\n\t\t\telse\n\t\t\t\tmika = min(mika, ted + 1);\n\t\t}\n\t}\n\telse\n\t{\n\t\tint ted = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif(s[i] == 'B')\n\t\t\t\tted++;\n\t\t\telse\n\t\t\tif(s[i] == 'R' && ted > 0)\n\t\t\t{\n\t\t\t\tif(ted % 2)\n\t\t\t\t\tmika = min(mika, ted);\n\t\t\t\telse\n\t\t\t\t\tmika = min(mika, ted + 1);\n\t\t\t\tted = 0;\n\t\t\t}\n\t\tif(ted > 0)\n\t\t{\n\t\t\tif(ted % 2)\n\t\t\t\tmika = min(mika, ted);\n\t\t\telse\n\t\t\t\tmika = min(mika, ted + 1);\n\t\t}\n\t}\n}\nint getzarib(int kaman)\n{\n\tint emp = n - kaman;\n\tif(emp == 0)\n\t\treturn 1;\n\telse\n\t\treturn n - emp;\n}\nint main()\n{\n\tios::sync_with_stdio(false); \n\tcin.tie(0); cout.tie(0);\n\tcin >> n >> m >> s;\n\tfind_mika();\n\tbool flg = 1;\n\tfor (int i = 1; i < s.size(); i++)\n\t\tif(s[i] != s[0])\t\n\t\t\tflg = 0;\n\treturn 0;\n\tif(flg)\n\t{\n\t\tdp[1] = 1, dp[2] = 2;\n\t\tfor (int i = 3; i <= n; i++)\n\t\t\tdp[i] = add(dp[i - 1], dp[i - 2]);\n\t\t\n\t\tans = dp[n];\n\t\tif(n >= 3)\n\t\t\tans = add(ans, dp[n - 2]);\n\t\tcout << ans;\n\t\treturn 0;\n\t}\n\tdp[0] = 1;\n\tpart[0] = 1;\n\tfor (int i = 2; i <= n; i += 2)\n\t{\n\t\tdp[i] = part[i - 2];\n\t\tif(i - mika - 3 >= 0)\n\t\t\tdp[i] = add(dp[i], -part[i - mika - 3]);\n\t\tpart[i] = add(part[i - 2], dp[i]);\n\t}\n\tans = add(ans, dp[n]);\n\tfor (int i = 1; i <= mika; i += 2)\n\t\tif(i != n - 2 && i != n)\n\t\t\tans = add(ans, mul(getzarib(i), dp[n - i - 1]));\n\t\telse\n\t\tif(i == n)\n\t\t\tans = add(ans, 1);\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n¼ÙÉèS[1] = R¡£ÄÇÃ´ÏÔÈ»£¬»·ÉÏ²»»á³öÏÖÁ½¸öÁ¬ÐøµÄ±ß¶¼ÊÇB£¬·ñÔòÔÚËüÃÇ½»µã´¦µÚÒ»²½ÍùÁ½±ß×ß¶¼²»ºÏ·¨\nÌØÅÐµôSÖÐÈ«ÊÇRµÄÇé¿ö£¬¿¼ÂÇÒ»°ãÇé¿ö \nÊ×ÏÈ°ÑËùÓÐÊÇBµÄÎ»ÖÃ¶Ï¿ª£¬ÄÇÃ´¾ÍÐÎ³ÉÁËÈô¸É¸öRµÄÁ¬Ðø¶Î¡£¿ÉÒÔ·¢ÏÖÕâÃ´Ò»¸öÐÔÖÊ£ºÃ¿¸öÁ¬Ðø¶ÎµÄ³¤¶È¾ùÎªÆæÊý\nÖ¤Ã÷¿¼ÂÇ·´Ö¤¡£¼ÙÉèÓÐÒ»¸öÅ¼ÊýµÄ¶Î£¬¿¼ÂÇ¶þ·ÖÍ¼¿ÉÒÔ·¢ÏÖ£¬ÄÇÃ´ÓÐµÄµã×ßµ½ÕâÒ»¶ÎµÄ¶Ëµã¾àÀëÓÀÔ¶ÊÇÅ¼Êý¡¢ÓÐµÄµã×ßµ½ÕâÒ»¶ÎµÄ¶Ëµã¾àÀëÓÀÔ¶ÊÇÆæÊý£¬ÒòÎª¶ËµãÍ¬É«\n¶øSµÄµÚÒ»¶ÎÁ¬ÐøR³¤¶ÈÊÇ¹Ì¶¨µÄ£¬²»ÄÜÍ¬Ê±ÎªÅ¼Êý»òÆæÊý£¬Ã¬¶Ü¡£ËùÒÔ¿ÉÒÔµÃµ½½áÂÛ\nÍ¬Ê±£¬SÖÐÃ¿¸öRµÄÁ¬Ðø¶Î¶¼»á¶Ô»·ÉÏÃ¿¸öRµÄÁ¬Ðø¶ÎÓÐ¸öÉÏ½çµÄÏÞÖÆ \n*/\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int Max_NM(200050);\nconst int MOD(1000000000 + 7);\ntypedef long long int LL;\n\nint N, M, L, F[Max_NM], Pre[Max_NM][2], Ans;\nchar S[Max_NM];\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nconstexpr int Sub(int a, int b)\n{\n\treturn a - b < 0 ? a - b + MOD : a - b;\n}\n\nconstexpr int Mult(int a, int b)\n{\n\treturn a * 1LL * b % MOD;\n}\n\ninline void upd(int &a, int b)\n{\n\ta = Add(a, b);\n}\n\nvoid dp(bool have)\n{\n\tF[1] = 1, Pre[1][1 & 1] = 1;\n\tfor (int i = 2, j;i <= N;++i)\n\t{\n\t\tPre[i][0] = Pre[i - 1][0], Pre[i][1] = Pre[i - 1][1];\n\t\tupd(Pre[i][i & 1], F[i - 2]);\n\t\t//jµ½iÊÇR£¬i - j + 1 <= L   =>   j >= i - L + 1\n\t\t//i - j + 1ÊÇÆæÊý£¬i - jÊÇÅ¼Êý£¬iºÍjÆæÅ¼ÐÔÏàµÈ\n\t\tj = max(1, i - L + 1);\n\t\tif (j <= i)\n\t\t{\n\t\t\tF[i] = Sub(Pre[i][i & 1], Pre[j - 1][i & 1]);\n\t\t\tif (have)\n\t\t\t\tupd(F[i], Sub(Pre[i][(i & 1) ^ 1], Pre[j - 1][(i & 1) ^ 1]));\n\t\t}\n\t}\n\t\n}\n\nint main()\n{ \n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tbool haveB = false;\n\tif (S[1] == 'B')\n\t\tfor (int i = 1;i <= M;++i)\n\t\t\tS[i] = 'R' + 'B' - S[i];\n\tfor (int i = 1;i <= M;++i)\n\t\thaveB |= (S[i] == 'B');\n\tL = N;\n\tfor (int i = 1, length = 0, stop = 0;i <= M;++i)\n\t\tif (S[i] == 'B')\n\t\t\tlength = 0, stop = 1;\n\t\telse\n\t\t{\n\t\t\t++length;\n\t\t\tif (i + 1 <= N && S[i + 1] == 'B')\n\t\t\t\tif (stop == 0)\n\t\t\t\t\tif (length & 1)\n\t\t\t\t\t\tL = min(L, length);\n\t\t\t\t\telse\n\t\t\t\t\t\tL = min(L, length + 1);\n\t\t\t\telse\n\t\t\t\t\tif (length & 1)\n\t\t\t\t\t\tL = min(L, length);\n\t\t}\n\tdp(!haveB);\n\tupd(Ans, F[N - 1]);//edge(1, 2) = B\n\tfor (int x = 1, val;x <= L && x < N;++x)//edge(1, 2) = R\n\t{\n\t\tif (haveB && ((x & 1) == 0))\n\t\t\tcontinue;\n\t\tif (x + 1 == N)\n\t\t\tval = 1;\n\t\telse\n\t\t\tval = F[N - x - 2];\n\t\tupd(Ans, Mult(x, val));\n\t}\n\tif (haveB == false)\n\t\tupd(Ans, 1);\n\tprintf(\"%d\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MAX_N 200000\n#define MAX_M 200000\n#define MOD 1000000007\n\n#define INF 1 << 29\n\nint N, M;\nstring S;\n\nlong long dp[MAX_N + 1], rdp[MAX_N + 1];\n\nint all_color_is_same()\n{\n    long long rr = 1, bb = 1, rb = 0, br = 0;\n\n    for ( int i = 1; i < N; i++ )\n    {\n        long long nrr = ( rr + rb ) % MOD;\n        long long nbb = br;\n        long long nrb = rr;\n        long long nbr = ( bb + br ) % MOD;\n\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n\n    return ( rr + rb + br ) % MOD;\n}\n\n/**\n * S の先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n */\nint min_freq()\n{\n    int l = 0;\n    while ( l < M && S[0] == S[l] ) l++;\n\n    int ans = ( l & 1 ) ? l : l + 1;\n\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[0] == S[i] )\n            l++;\n        else if ( l & 1 )\n        {\n            ans = min( ans, l );\n            l = 0;\n        }\n    }\n    return l ? min( ans, l ) : ans;\n}\n\nint solve()\n{\n    // 一色\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n        return all_color_is_same();\n\n    // N が奇数\n    if ( N & 1 ) return 0;\n\n    int L = min_freq();\n\n    L = ( L + 1 ) >> 1;\n    N >>= 1;\n\n    dp[0] = rdp[0] = 1;\n    for ( int i = 1; i <= N + 1; i++ )\n    {\n        dp[i] = rdp[i - 1];\n        if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n\n    long long res = 0;\n    for ( int i = 1; i <= L; i++ )\n        if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n    return res % MOD;\n}\n\nint main( int argc, char **argv )\n{\n    cin >> N >> M;\n    cin >> S;\n\n    int ans = solve();\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 1e9 + 7;\n\nstruct modint {\n    int x;\n    inline modint(int x = 0) : x(x) {}\n    inline modint &operator = (int o) { return x = o, *this; }\n    inline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n    inline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n    inline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n    template <class I>\n    inline modint &operator ^= (I b) {\n        modint a = *this, c;\n        if (!~b) b = P - 2;\n        c.x = 1 % P;\n        while (b) {\n            if (b & 1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return x = c.x, *this;\n    }\n    inline modint &operator /= (modint o) { return *this *= o ^ -1; }\n    inline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n    inline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n    inline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n    inline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n    template <class I>\n    inline friend modint operator + (modint a, I b) { return a += b; }\n    template <class I>\n    inline friend modint operator - (modint a, I b) { return a -= b; }\n    template <class I>\n    inline friend modint operator * (modint a, I b) { return a *= b; }\n    template <class I>\n    inline friend modint operator ^ (modint a, I b) { return a ^= b; }\n    template <class I>\n    inline friend modint operator / (modint a, I b) { return a /= b; }\n    inline friend bool operator == (modint a, int b) { return a.x == b; }\n    inline friend bool operator != (modint a, int b) { return a.x != b; }\n    inline friend bool operator < (modint a, int b) { return a.x < b; }\n    inline friend bool operator <= (modint a, int b) { return a.x <= b; }\n    inline friend bool operator > (modint a, int b) { return a.x > b; }\n    inline friend bool operator >= (modint a, int b) { return a.x >= b; }\n    inline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n    inline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n    inline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n    inline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n    inline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n    inline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n    inline bool operator ! () { return !x; }\n    inline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\n//const int NP = 1e6 + 7;\n//modint p[NP], v[NP], vp[NP];\n//inline void init(int n) {\n//  p[0] = v[0] = 1;\n//  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n//  vp[n] = 1 / p[n];\n//  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n//}\n//inline modint binom(int n, int m) {\n//  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n//}\n\nconst int N = 2e5 + 7;\nint n, m, c[N], k, w;\nchar s[N];\n\nnamespace k1 {\n\tmodint f[N][2][2];\n\tinline void main() {\n\t\tf[1][0][0] = f[1][1][1] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i+1][0][0] = f[i][0][0] + f[i][0][1],\n\t\t\tf[i+1][0][1] = f[i][0][0],\n\t\t\tf[i+1][1][0] = f[i][1][0] + f[i][1][1],\n\t\t\tf[i+1][1][1] = f[i][1][0];\n\t\tprint(f[n][0][0] + f[n][0][1] + f[n][1][0]);\n\t}\n}\n\nmodint f[N], g[N], ans;\n\nint main() {\n\trd(n, m), rds(s, m);\n\tfor (int l = 1, r = 1; l <= m; l = ++r) {\n\t\twhile (r < m && s[r+1] == s[l]) ++r;\n\t\tc[++k] = r - l + 1;\n\t}\n\tif (k == 1) return k1::main(), 0;\n\tif (n & 1) return print(0), 0;\n\tw = c[1] + !(c[1] & 1), k -= k & 1;\n\tfor (int i = 3; i <= k; i += 2)\n\t\tif (c[i] & 1) w = min(w, c[i]);\n\tn >>= 1, w >>= 1;\n\tf[1] = g[1] = 1;\n\tfor (int i = 2; i <= n; i++)\n\t\tg[i] = g[i-1] + (f[i] = g[i-1] - (i - w - 2 >= 0 ? g[i-w-2] : 0));\n\tfor (int i = 0; i <= min(n, w); i++) ans += f[n-i] * (i + 1);\n\tprint(ans + ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass EGoAroundACircle {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, M; cin >> N >> M;\n        string S; cin >> S;\n        char c = S[0];\n        int d = 1, m = 1, so = 2*M;\n        for (int i = 1; i < M; ++i) {\n            if (S[i] == c) {\n                d++;\n\n                m = max(m, d);\n            } else {\n                if (d % 2 == 1) so = min(so, d);\n                d = 0;\n            }\n        }\n\n        if (N % 2 == 1) {\n            if (m == M) {\n                vector2<FieldMod> X(N, 2, 0);\n                X[0][0] = 1;\n                for (int i = 1; i < N; ++i) {\n                    X[i][0] = X[i-1][0] + X[i-1][1];\n                    X[i][1] = X[i-1][0];\n                }\n\n                vector2<FieldMod> Y(N, 2, 0);\n                Y[0][1] = 1;\n                for (int i = 1; i < N; ++i) {\n                    Y[i][0] = Y[i-1][0] + Y[i-1][1];\n                    Y[i][1] = Y[i-1][0];\n                }\n\n                cout << X.back()[0] + X.back()[1] + Y.back()[0] << endl;\n//                cout << X.back() << ' ' << Y.back() << endl;\n//\n//\n//\n//                cout << 1 << endl; // <nope\n            } else {\n                cout << 0 << endl;\n            }\n            return;\n        }\n\n        if (m == M) {\n            cout << FieldMod{2}.pow(N/2) * 2 - 1;\n            return;\n        }\n\n//        cout << m <<  ' ' << so << endl;\n        if (m % 2 == 0) ++m;\n        m = min(m, so);\n        // max size of consecutive Rs => m\n        int b = min(N/2, (m+1)/2);\n\n        vector<FieldMod> H(N/2, 0);\n        FieldMod tot = 1;\n        H[0] = 1;\n        for (int j = 1; j < N/2; ++j) {\n            if (j > b) {  tot -= H[j-b-1]; }\n            H[j] = tot;\n//            cout << \"add \" << j << ' ' << H[j] << endl;\n            tot += H[j];\n        }\n\n//        cout << H;\n        FieldMod ans = 0;\n        for (int i = 1; i <= b; ++i) {\n            ans += i * H[N/2-i];\n        }\n        cout << 2*ans << endl;\n\n\n//        int ans = 0;\n//        for (int i = 0; i < (1<<N); ++i) {\n//            vector<bool> A(N, true);\n//            for (int j = M-1; j >= 0; --j) {\n//                int s = (S[j] == 'R') ? 1 : 0;\n//                vector<bool> B(N, false);\n//                for (int k = 0; k < N; ++k) {\n//                    if (!A[k]) continue;\n//                    int l = k == 0 ? N-1 : k-1;\n//                    int r = k == N-1 ? 0 : k+1;\n//                    if (((i>>l)&1) == s) B[l] = true;\n//                    if (((i>>k)&1) == s) B[r] = true;\n//                }\n//                swap(A,B);\n//            }\n//\n//            if (count(A.begin(),A.end(),true) == N) {\n//                ans++;\n////                for (int j = 0; j < N; ++j) {\n////                    cout << \"BR\"[(i>>j)&1];\n////                }\n////                cout << endl;\n//            }\n//        }\n//        cout << ans << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tEGoAroundACircle solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define mod 1000000007\n#define DIM 200005\nusing namespace std;\nint n, m, i, k, nr, sol;\nchar s[DIM];\nint d[DIM], sum[DIM];\nint main(){\n    cin>> n >> m;\n    cin>> s + 1;\n    k = m;\n    for(i = 1; i <= m; i++){\n        if(s[i] == s[1]){\n            nr++;\n        }\n        else{\n            if(nr == i - 1){\n                if(nr % 2 == 1){\n                    k = min(k, nr);\n                }\n                else{\n                    k = min(k, nr + 1);\n                }\n            }\n            else{\n                if(nr % 2 == 1){\n                    k = min(k, nr);\n                }\n            }\n            nr = 0;\n        }\n    }\n    sum[1] = d[1] = 1;\n    if(k == m){\n        for(i = 3; i < n; i++){\n            d[i] = sum[i - 2];\n            sum[i] = (d[i] + sum[i - 1]) % mod;\n        }\n        sol = 1;\n        for(i = 1; i < n; i++){\n            sol = (sol + d[n - i] * 1LL * (i + 1) ) % mod;\n        }\n        cout<< sol;\n        return 0;\n    }\n    for(i = 3; i < n; i += 2){\n        d[i] = sum[i - 2];\n        if(i - k - 3 > 0){\n            d[i] -= sum[i - k - 3];\n            if(d[i] < 0){\n                d[i] += mod;\n            }\n        }\n        sum[i] = d[i] + sum[i - 2];\n        if(sum[i] >= mod){\n            sum[i] -= mod;\n        }\n    }\n    for(i = 1; i < min(n, k + 2); i += 2){\n        sol = (sol + d[n - i] * 1LL * (i + 1) ) % mod;\n    }\n    cout<< sol;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 233333,mo=1e9+7;\nint n,m,f[N],qz[N];char s[N];\nvoid init(int n, int lim){//<=lim\n\tumin(lim,n);//f[i]=sigma f[i-1..i-lim]\n\tf[0]=1;qz[0]=1;\n\trep(i,1,n){\n\t\tf[i]=(qz[i-1]-(i-lim-1>=0?qz[i-lim-1]:0)+mo)%mo;\n\t\tqz[i]=(qz[i-1]+f[i])%mo;\n\t}\n}\nint main() {\n\tread(n);read(m);scanf(\"%s\",s+1);\n\tint cnt=0;rep(i,1,m)cnt+=s[i]=='R';\n\tif(cnt==0||cnt==m){\n\t\tstatic int f[N];\n\t\tf[0]=1;f[1]=2;rep(i,2,n)f[i]=(f[i-1]+f[i-2])%mo;\n\t\tprintf(\"%d\\n\",(f[n-1]+(n-3>=0?f[n-3]:1))%mo);\n\t\treturn 0;\n\t}\n\tif(n&1){puts(\"0\");return 0;}\n\tint lim=1e9;int j;for(j=1;j<=m;j++)if(s[j]!=s[1])break;j--;\n\tif(j%2==0)lim=j+1;\n\trep(i,1,m)if(s[i]==s[1]){\n\t\tint j;for(j=i;j<=m;j++)if(s[j]!=s[i])break;\n\t\t//[i,j-1]\n\t\tif((j-i)%2&&j-1<m)umin(lim,j-i);\n\t\ti=j-1;\n\t}\n//\tcerr<<lim<<endl;\n\tlim++;init(n/2,lim/2);int res=0;//%2==0\n\tfor(int i=2;i<=min(lim,n);i+=2)res=(res+1LL*i*f[(n-i)/2])%mo;\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <list>\n#include <iterator>\n#include <assert.h>\n#pragma warning(disable:4996) \n\ntypedef long long ll;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF 9223300000000000000\n#define INF 2140000000\nconst long long MOD = 1000000007;\nusing namespace std;\n\nchar str[200005];\n\n// A(Bを数個)A(Bを数個)..A(Bを数個) \n// という列の作り方が何通りあるか、を求める\n// ただし列の長さをn、Bを重ねるのは各箇所について0個以上k個以下とする\n// また両端がつながっているものとする\nll func( int n, int k)\n{\n#ifdef _DEBUG\n    printf(\"%d %d\\n\", n, k);\n#endif\n    vector<ll> dp(n+1);   // dp[i]: func(i,k)と同じ。ただし両端がつながっていないものとする。\n    vector<ll> sdp(n+2);  // dpの累積和\n    dp[0]=1;\n    sdp[0]=0; sdp[1]=1;\n    int i;\n    for(i=1; i<=n; i++) {\n        dp[i]=(sdp[i]-sdp[MAX(0,i-k-1)]+MOD)%MOD;\n        sdp[i+1]=(sdp[i]+dp[i])%MOD;\n    }\n    ll ans = dp[n];\n\n    // dp[n]は、Aから始まるものだけを数えたもの。\n    // 両端がつながっている状況で、Bから始まるものを数える\n    // Bが最初にp個重なった場合を考えて足し合わせればよい\n    int p;\n    for(p=1; p<=k; p++) {\n        // dp[n-p-1],dp[n-p-2],..という(k-p+1)個を足し合わせればよい\n        ans = (ans + sdp[n-p] - sdp[n-k-1])%MOD;\n    }\n\n    return ans;\n}\n\nint main(int argc, char* argv[])\n{\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    scanf(\"%s\", str);\n\n    char c=str[0];\n    int max_odd=0;\n    int cnt_first=-1;\n    int cnt=0;\n    int cnt2=0;\n    int i;\n    for(i=0; i<m; i++) {\n        if(str[i]==c) {\n            cnt++;\n        }\n        else {\n            if(cnt==0) {\n                printf(\"0\\n\"); return 0;\n            }\n            if(cnt_first<0) cnt_first=cnt;\n            if(cnt%2) max_odd = MAX(max_odd, cnt);\n            cnt=0;\n            cnt2++;\n        }        \n    }\n\n    if(cnt2==0) {\n        printf(\"%lld\\n\", func(n, 1));\n    }\n    else {\n        if(n%2==0) {\n            int k = (cnt_first%2==0? cnt_first+1: cnt_first);\n            if(max_odd>0) k = MIN(k, max_odd);\n            printf(\"%lld\\n\", func(n/2, (k-1)/2) *2 %MOD);\n        }\n        else {\n            printf(\"0\\n\");\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define P 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n, m;\n\nchar ch[400010];\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n\tll ans = 1;\n\twhile(y) {\n\t\tif(y & 1) ans = ans * x % p;\n\t\tx = x * x % p;\n\t\ty >>= 1;\n\t}\n\treturn ans;\n}\n\nll F[400010][2][2], G[400010][2][2], H[400010], SH[400010], SG[400010][2][2];\n\n// G1 : ABABABA\n// G2 : BABABAB\n\nvoid cmin(int &x, int y) {if(x > y) x = y;}\n\nvoid add(ll &x, ll y) {x = (x + y) % P;}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", ch + 1);\n\tll ans = 0;\n\t// qingyise\n\tint sub1 = 1;\n\tfor(int i = 2; i <= m; i++) if(ch[i] != ch[1]) sub1 = 0;\n\tif(sub1 == 1) {\n\t\tF[0][0][0] = 1;\n\t\tF[0][1][1] = 1;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\tF[i][j][0] = (F[i - 1][j][0] + F[i - 1][j][1]) % P;\n\t\t\t\tF[i][j][1] = (F[i - 1][j][0]) % P;\n\t\t\t}\n\t\tans = (F[n][0][0] + F[n][1][1]) % P;\n\t\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\t\treturn 0;\n\t}\n\tif(n % 2 == 1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tvector <int> V(1, 1);\n\tfor(int i = 2; i <= m; i++) if(ch[i] == ch[i - 1]) V.back()++; else V.push_back(1);\n\tint l = 0, r = 0, mnA = n + 5, mnB = n + 5, nw = 0;\n\tfor(int i = 1; i < V.size(); i += 2) {\n\t\tif(V[i] % 2 == 1) nw ^= 1;\n\t\tif(i + 2 != V.size() && V[i + 1] % 2 == 1) {\n\t\t\tif(nw == 0) cmin(mnA, V[i + 1]); else cmin(mnB, V[i + 1]);\n\t\t}\n\t}\n\tcmin(mnA, V[0] + !(V[0] % 2));\n\tH[1] = 1, SH[1] = 1;\n\tfor(int i = 3; i <= n + 1; i += 2) {\n\t\tH[i] = SH[i - 2];\n\t\tif(i >= min(mnA, mnB) + 3) {\n\t\t\tadd(H[i], -SH[i - (min(mnA, mnB) + 3)]);\n\t\t}\n\t\t//H[i] = -H[i];\n\t\tSH[i] = (H[i] + SH[i - 2]) % P;\n\t}\n\tfor(int i = 1; i <= n; i += 2) {\n\t\t//if(n - i <= mnA) add(ans, G[i][1][1] * (n - i + 1));\n\t\t//if(n - i <= mnB) add(ans, G[i][0][0] * (n - i + 1));\n\t\tif(n - i <= min(mnA, mnB)) add(ans, H[i] * (n - i + 1));\n\t}\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 200100;\nconst int mod = 1e9 + 7;\nconst int oo = 1e9;\nint n, m;\nchar s[maxn];\nint l = oo;\nlong long ans = 0;\nlong long dp[maxn][2][2] = {0}, h[maxn][2][2] = {0};\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(int i = 1; i <= m; i ++)\n\t\tcin >> s[i];\n\twhile(s[m] == s[1] && m >= 1)\n\t\tm --;\n\tif(m != 0)\n\t{\n\t\tint len;\n\t\tfor(len = 1; len <= m && s[len] == s[1]; len ++);\n\t\tlen --;\n\t\tif(len & 1)\n\t\t\tl = min(l, len);\n\t\telse\n\t\t\tl = min(l, len + 1);\n\t\tint now = 0;\n\t\tfor(int i = len + 2; i <= m; i ++)\n\t\t{\n\t\t\tif(s[i] != s[1])\n\t\t\t{\n\t\t\t\tif(now & 1)\n\t\t\t\t\tl = min(l, now);\n\t\t\t\tnow = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tnow ++;\n\t\t}\n\t}\n\tif(n & 1)\n\t{\n\t\tif(m == 0)\n\t\t\tcout << n + 1 << endl;\n\t\telse\n\t\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tn >>= 1;\n\tl >>= 1;\n\t//cout << n << \" \" << l << endl;\n\tdp[1][0][0] = h[1][0][0] = 1;\n\tdp[1][1][1] = h[1][1][1] = (l > 0);\n\t//dp[0][0][0] = dp[0][1][1] = h[0][0][0] = h[0][1][1] = 1;\n\tfor(int i = 2; i <= n; i ++)\n\t{\n\t\t//cout << i << \" : \" << endl;\n\t\tdp[i][0][0] = (dp[i - 1][0][1] + dp[i - 1][0][0]) % mod;\n\t\tdp[i][0][1] = (h[i - 1][0][0] - h[max(0, i - l - 1)][0][0] + mod) % mod;\n\t\tdp[i][1][0] = (dp[i - 1][1][1] + dp[i - 1][1][0]) % mod;\n\t\tdp[i][1][1] = (h[i - 1][1][0] - h[max(0, i - l - 1)][1][0] + mod) % mod;\n\t\tif(i <= l)\n\t\t\tdp[i][1][1] ++;\n\t\tfor(int asd1 = 0; asd1 < 2; asd1 ++)\n\t\t\tfor(int asd2 = 0; asd2 < 2; asd2 ++)\n\t\t\t\th[i][asd1][asd2] = (h[i - 1][asd1][asd2] + dp[i][asd1][asd2]) % mod;\n\t\t//cout << dp[i][0][0] << \" \" << dp[i][0][1] << \" \" << dp[i][1][0] << \" \" << dp[i][1][1] << endl;\n\t\t//cout << h[i][0][0] << \" \" << h[i][0][1] << \" \" << h[i][1][0] << \" \" << h[i][1][1] << endl;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\t(ans += (n - i) * dp[i][1][1]) %= mod;\n\t\tif(n - i <= l)\n\t\t\t(ans += (n - i) * dp[i][0][0]) %= mod;\n\t}\n\tans ++;\n\t//cout << ans << endl;\n\tif(m == 0 || l >= n - 1)\n\t\tans += n;\n\tcout << ans * 2 + (m == 0) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 1;\n    rdp[0] = 1;\n    for(int i = 1;i <= n+1;i++){\n        dp[i] = (rdp[i-1] - ((i-limit-1)>=0?rdp[i-limit-1]:0)) % MOD;\n        if(dp[i] < 0)dp[i] += MOD;\n        rdp[i] = (rdp[i-1] + dp[i]) % MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n+10, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    bool allsame = true;\n    for(int i = 0;i < m;i++)allsame &= (str[i] == str[0]);\n    if(allsame){\n        cout << all(n) << endl;\n        return 0;\n    }\n    for(int i = 0;i < m;i++)vec.push_back(str[i] == str[0]);\n    vec.push_back(0);\n    Int l = 0;\n    while(vec[l] == 1)l++;\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i < vec.size();i++){\n        if(vec[i] == 1)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2019.5.19 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define eps 1e-10\n#define RG register\ninline int read() {\n    res s=0,ch=getchar();\n    while(ch<'0'||ch>'9')ch=getchar();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return s;\n}\ninline LL Read() {\n    RG LL s=0;\n    res ch=getchar();\n    while(ch<'0'||ch>'9')ch=getchar();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return s;\n}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N=1e5+10;\nconst int kcz=1e9+7;\nnamespace MAIN {\n    int n,m,dp[N],p=1,sum[N],ans;\n    char str[N];\n    inline void add(res &x,const res &y){\n        x+=y,x>=kcz?x-=kcz:1;\n    }\n    inline int Add(const res &x,const res &y){\n        return x+y>=kcz?x+y-kcz:x+y;\n    }\n    inline int mul(const res &x,const res &y){\n        return int(1LL*x*y%kcz);\n    }\n    inline void MAIN(){\n        n=read(),m=read(),scanf(\"%s\",str+1);\n        for(;p<=m;p++)if(str[p]!=str[1])break;\n        p--,dp[0]=sum[0]=1;\n        if(p==m){\n            ans=1;\n            for(res i=0;i<=n;i++){\n                if(i>=2)dp[i]=sum[i-2];\n                sum[i]=Add(sum[i-1],dp[i]);\n                if(n-i>=2)add(ans,mul(dp[i],n-i));\n            }\n            printf(\"%d\\n\",ans);\n            return;\n        }\n        if(n&1){puts(\"0\");return;}\n        if(p%2==0)p++;\n        for(res t=0,i=p/2*2+1;i<=m;i++)\n            if(str[i]==str[1])t++;\n            else {\n                if(t&1)p=min(p,t);\n                t=0;\n            }\n        n>>=1,p=(p+1)>>1;\n        for(res i=0;i<=n;i++){\n            if(i)dp[i]=Add(sum[i-1],kcz-(i-p>0?sum[i-p-1]:0)),sum[i]=Add(sum[i-1],dp[i]);\n            if(n-i<=p)add(ans,mul(n-i,dp[i]<<1));\n        }\n        printf(\"%d\\n\",ans);\n    }\n}\nint main() {\n//    srand((unsigned)time(NULL));\n//    freopen(\"graph.in\",\"r\",stdin);\n//    freopen(\"graph.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n;\nint m;\nstring s;\nint mn = INF;\nll ans ;\nll dp[200005][2][2];\n\nstruct RMQ{\n\t#define ss (1<<19)\n\tll seg[ss];\n\tvoid update(int k,ll a){\n\t\tk+=ss/2-1; seg[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tseg[k]=(seg[k*2+1]+seg[k*2+2])%mod;\n\t\t}\n\t}\n\tll query(int a,int b,int k,int l,int r){\n\t\tif(r<a || b<l) return 0;\n\t\tif(a<=l && r<=b) return seg[k];\n\t\telse{\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2+1,r);\n\t\t\treturn (vl+vr)%mod;\n\t\t}\n\t}\n}rmq[2];\n\nint main(){\n\tcin>>n>>m>>s;\n\tif(s[0] == 'B'){\n\t\trep(i,m){\n\t\t\tif(s[i] == 'B') s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\t\tint cur = 0;\n\t\tchar ch;\n\t\tbool beg = 0;\n\t\tint C = 0;\n\t\trep(i,m){\n\t\t\tif(i == 0){\n\t\t\t\tch = s[i];\n\t\t\t\tcur = 1;\n\t\t\t}\n\t\t\telse if(ch != s[i]){\n\t\t\t\tif(ch == 'R'){\n\t\t\t\t\tif(cur%2 == 1) mn = min(mn,cur);\n\t\t\t\t\telse if(!beg) mn = min(mn,cur+1);\n\t\t\t\t\tbeg = 1; C++;\n\t\t\t\t}\n\t\t\t\t\tch = s[i];\n\t\t\t\t\tcur = 1;\n\t\t\t//\t\tbeg = 1; C++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse cur++;\n\t\t}\n\t\t\t\tif(ch == 'R'){\n\t\t\t\t\tif(cur%2 == 1) mn = min(mn,cur);\n\t\t\t\t\telse if(!beg) mn = min(mn,cur+1);\n\t\t\t\t\tbeg = 1; C++;\n\t\t\t\t}\n\t\t\t\t//cout<<C<<endl;\n\t\t\t\t\t//ch = s[i];\n\t\t\t\t\tcur = 1;\n\t\t\t//\t\tbeg = 1; C++;\n\t\t\t//cout<<C<<\" \"<<mn<<endl;\n\t\tif(C == 1){\n\t\t    //assert(mn == m);\n\t\t\t//BBが存在しなければOK\n\t\t\tdp[0][0][0] = dp[0][1][1] = 1;\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\trep(x,2){\n\t\t\t\t\tdp[i+1][0][x] += dp[i][0][x];\n\t\t\t\t\tdp[i+1][1][x] += dp[i][0][x];\n\t\t\t\t\tdp[i+1][0][x] += dp[i][1][x];\n\t\t\t\t\tdp[i+1][0][x] %= mod;\n\t\t\t\t\tdp[i+1][1][x] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<((dp[n-1][0][0]+dp[n-1][0][1]+dp[n-1][1][0])%mod+mod)%mod<<endl;\n\t\t}\n\t\telse{\n\t\t\tif(n%2 == 1){\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[0][0][0] = 1;\n\t\t\trmq[0].update(0,1);\n\t\t\tfor(int i=2;i<n;i+=2){\n\t\t\t\tdp[i][0][0] = rmq[i%2].query(max(0,i-mn-1),i,0,0,(1<<18)-1);\n\t\t\t\trmq[i%2].update(i,dp[i][0][0]);\n\t\t\t}\n\t\t\tll ans = 0;\n\t\t\tfor(int m=1;m<=n;m++){\n\t\t\t\tif(m-1 > mn) continue;\n\t\t\t\tans += dp[n-m][0][0] * 1LL * m % mod;\n\t\t\t}\n\t\t\tcout << (ans%mod+mod)%mod << endl;\n\t\t\n\t\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n  \n  assert(s[i]=='R');\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  for(Int i=0;i<m;i++)\n    s[i]=\"BR\"[vs[i]];\n  \n  if(vs==vector<Int>(m,1)){    \n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n  assert(vs!=vector<Int>(m,0));\n\n  if(n&1){\n    cout<<0<<endl;\n    return 0;\n  }\n  \n  Int lim=n-1;  \n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    Int j=i;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n\n    if(i==0&&(j-i)%2==0) chmin(lim,j-i+1);\n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }\n  \n  vector<M> dp(n+2,0),sm(n+2,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n+1;i++){\n    sm[i]=sm[i-1]+dp[i-1];\n    if(i&1) dp[i]=sm[i-1]-sm[max<Int>(1,i-1-lim)];\n  }\n  \n  M ans{0};\n  for(Int i=0;i<=lim;i++)\n    ans+=sm[n-i+1]-sm[max<Int>(1,n-lim)];\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nll dp[1 << 18][2][2];\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (s[0] == 'B') {\n\t\trep(i, m) {\n\t\t\tif (s[i] == 'B')s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\tvector<int> v;\n\trep(i, m) {\n\t\tint le = i;\n\t\twhile (i + 1 < m&&s[i + 1] == s[i])i++;\n\t\tv.push_back(i - le + 1);\n\t}\n\tif (v.size() == 1) {\n\t\tdp[0][0][0] = 1;\n\t\tdp[0][1][1] = 1;\n\t\trep(i, n-1) {\n\t\t\trep(j, 2) {\n\t\t\t\t(dp[i + 1][0][j] += dp[i][0][j] + dp[i][1][j])%=mod;\n\t\t\t\tdp[i + 1][1][j] += dp[i][0][j];\n\t\t\t}\n\t\t}\n\t\tll ans = dp[n-1][0][0] + dp[n-1][1][0] + dp[n-1][0][1];\n\t\tcout << ans % mod << endl;\n\t}\n\tif (n % 2) {\n\t\tcout << 0 << endl; return;\n\t}\n\tfor (int i = 0; i < v.size(); i += 2) {\n\t\tif (v[i] % 2) {\n\t\t\tif (n % 2) {\n\t\t\t\tcout << 0 << endl; return;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << 2 << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tint d = n / 2;\n\tint x = v[0] / 2+1;\n\tif (x >= d) {\n\t\tll ans = mod_pow(2, d) - 1;\n\t\tans = ans * 2;\n\t\tans = (ans + mod) % mod;\n\t\tcout << ans << endl;\n\t}\n\telse {\n\t\tll ans = d * mod_pow(2, d -x-1)%mod;\n\t\t\n\t\tans = mod_pow(2, d) - 1 - ans;\n\t\tans = (ans%mod + mod) % mod;\n\t\tcout << ans*2%mod << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\n#include<cassert>\nusing namespace std;\nusing lint = long long;\nusing ld = long double;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(lint i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nint n, m;\nstring s;\n\nvoid allred() {\n\tlint v1 = 0, v2 = 0;\n\tlint ans = 0;\n\tv1 = 1;\n\tREP(i, n - 1) {\n\t\tlint nv1 = (v1 + v2) % MOD;\n\t\tlint nv2 = v1;\n\t\tv1 = nv1;\n\t\tv2 = nv2;\n\t}\n\tans += (v1 + v2) % MOD;\n\tv1 = 0; v2 = 1;\n\tREP(i, n - 1) {\n\t\tlint nv1 = (v1 + v2) % MOD;\n\t\tlint nv2 = v1;\n\t\tv1 = nv1;\n\t\tv2 = nv2;\n\t}\n\tans += v1;\n\tcout << (ans % MOD + MOD) % MOD << endl;\n\treturn;\n}\n\nvoid solve(vector<int> suc_red, int omn) {\n\tint th = omn;\n\tif(suc_red[0] % 2 == 0) th = min(th, suc_red[0] + 1);\n\tlint ans = 0;\n\t/*\n\tif((n - 1) % 2 && (n - 1) <= th) {\n\t\tans += n;\n\t}*/\n\tvector<lint> dpr(n), dpb(n);\n\tdpr[0] = 0;\n\tdpb[0] = 1;\n\tqueue<lint> q0;\n\tqueue<lint> q1;\n\tlint sum0 = 1, sum1 = 0;\n\tq0.push(1);\n\tFOR(i, 1, n) {\n\t\tif(i % 2 == 1) {\n\t\t\twhile(!q0.empty() && (int)q0.size() > (th + 1) / 2) {\n\t\t\t\tsum0 -= q0.front(); sum0 %= MOD;\n\t\t\t\tq0.pop();\n\t\t\t}\n\t\t\tdpr[i] = sum0;\n\t\t} else {\n\t\t\twhile(!q1.empty() && (int)q1.size() > (th + 1) / 2) {\n\t\t\t\tsum1 -= q1.front(); sum1 %= MOD;\n\t\t\t\tq1.pop();\n\t\t\t}\n\t\t\tdpr[i] = sum1;\n\t\t}\n\t\tdpb[i] = dpr[i - 1];\n\t\tif(i % 2 == 0) {\n\t\t\tq0.push(dpb[i]);\n\t\t\tsum0 += dpb[i]; sum0 %= MOD;\n\t\t} else {\n\t\t\tq1.push(dpb[i]);\n\t\t\tsum1 += dpb[i]; sum1 %= MOD;\n\t\t}\n\t}\n\tFOR(i, 1, n) {\n\t\tif(i > th) break;\n\t\tans += dpb[n - 1 - i] * i;\n\t\tans %= MOD;\n\t}\n\tans += dpr[n - 1]; ans %= MOD;\n\tcout << (ans % MOD + MOD) % MOD << endl;\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> m;\n\tcin >> s;\n\tif(s[0] == 'B') {\n\t\tREP(i, m) {\n\t\t\tif(s[i] == 'B') s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\n\tvector<int> suc_red;\n\tint c = 0;\n\tREP(i, m) {\n\t\tif(s[i] == 'R') c++;\n\t\telse {\n\t\t\tif(c != 0) suc_red.pb(c);\n\t\t\tc = 0;\n\t\t}\n\t}\n\tif(c != 0) suc_red.pb(c);\n\n\tif(suc_red[0] == m) {\n\t\tallred();\n\t\treturn 0;\n\t}\n\tint omn = INF;\n\tREP(i, suc_red.size()) {\n\t\tif(suc_red[i] % 2) omn = min(omn, suc_red[i]);\n\t}\n\tsolve(suc_red, omn);\n\treturn 0;\n}\n/* --------------------------------------- */\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = (ll)1e9 + 7;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = 200200;\nchar s[N];\nint n, m;\nll dp[N];\n\nvoid solve1() {\n\tdp[0] = 0;\n\tdp[1] = 1;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tdp[i] = add(dp[i], dp[i - 1]);\n\t\tdp[i + 1] = dp[i - 1];\n\t}\n\tll ans = 1;\n\tfor (int i = 2; i <= n; i++)\n\t\tans = add(ans, mult(i, sub(dp[n - i + 1], dp[n - i])));\n\tprintf(\"%lld\\n\", ans);\n\treturn;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", s);\n\tbool allEq = true;\n\tfor (int i = 1; i < m; i++)\n\t\tallEq &= s[i] == s[0];\n\tif (allEq) {\n\t\tsolve1();\n\t\treturn 0;\n\t}\n\tif (n & 1) {\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tint b = n;\n\tint lst = -1;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (s[i] == s[0]) continue;\n\t\tint x = i - lst - 1;\n\t\tif (x % 2 == 0) {\n\t\t\tif (lst == -1) b = min(b, x + 2);\n\t\t} else {\n\t\t\tb = min(b, x + 1);\n\t\t}\n\t\tlst = i;\n\t}\n\tb /= 2;\n\tn /= 2;\n\n\tdp[0] = 0;\n\tdp[1] = 1;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tdp[i] = add(dp[i], dp[i - 1]);\n\t\tdp[i + 1] = sub(dp[i], dp[max(0, i - b)]);\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= b; i++)\n\t\tans = add(ans, mult(2 * i, sub(dp[n - i + 1], dp[n - i])));\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n\n\ttemplate<typename T> inline int ts(T *s)\n\t{\n\t\tint a=0,c=fetch();\n\t\twhile(c<=32 && c!=EOF)c=fetch();\n\t\twhile(c>32 && c!=EOF)s[a++]=c,c=fetch();\n\t\ts[a]=0;\n\t\treturn a;\n\t}\n}\nusing ae86::ty;\nusing ae86::ts;\n\nconst int _ = 200007 , mo = 1000000007;\n\nint n,m,s[_];\nlint f[_]={0};\n\nint main()\n{\n\tn=ty(),m=ty(),ts(s+1);\n\tfor(int i=m;i>=1;i--)s[i]=s[i]==s[1];\n\n\tlint ans=0;\n\twhile(m>1 && s[m])m--;\n\tif(m<=1)ans=1;\n\t\n\tint lim=m;\n\tfor(int l=1,r=1;l<=m;l=r+1)\n\t{\n\t\twhile(l<=m && !s[l])l++;\n\t\tif(l>m)break;\n\t\tr=l;\n\t\twhile(r<m && s[r+1])r++;\n\t\tint len=r-l+1;\n\t\tif(l==1)lim=min(lim,len+(1-len%2));\n\t\tif(len&1)lim=min(lim,len);\n\t}\n\n\tif(lim>=n)\n\t{\n\t\tf[0]=1;\n\t\tfor(int i=1,x=0;i<=n;i++)f[i]=x,x=(x+f[i-1])%mo;\n\t\tfor(int i=2;i<=n;i++)ans=(ans+f[n-i]*i%mo)%mo;\n\t}\n\telse\n\t{\n\t\tf[0]=1;\n\t\tfor(int i=2,x=f[0];i<=n;i+=2)\n\t\t{\n\t\t\tf[i]=x,x=(x+f[i])%mo;\n\t\t\tif(i>lim)x=(x-f[i-lim-1]+mo)%mo;\t\n\t\t}\n\t\tfor(int i=2;i<=lim+1;i+=2)ans=(ans+f[n-i]*i%mo)%mo;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 200002\n#define p 1000000007\ninline int mod(int x){return x<p?x:x-p;}\nint f[N][2],g[N],i,j,m,n,t,x;char s[N];\nint main()\n{\n    scanf(\"%d%d%s\",&n,&m,s+1),f[0][0]=g[0]=1;\n    if(s[1]=='B')for(i=1;i<=m;i++)s[i]=s[i]=='B'?'R':'B';\n    while(s[m]=='R')s[m--]=0;\n    for(i=0;s[i+1]=='R';i++);\n    for(t=i++|1;s[i];t=(i-j&1)&&t<i-j?i-j:t)\n    {\n        while(s[i]=='B')i++;\n        for(j=i;s[i]=='R';i++);\n    }\n    if(m)for(i=1;i<=n;f[i][i&1]=mod(f[i-1][i&1]+g[i]),f[i][i&1^1]=f[i-1][i&1^1],i++)g[i]=i<t+2?f[i-1][i&1]:mod(p+f[i-1][i&1]-f[i-t-2][i&1]);\n    else for(g[1]=1,i=2;i<=n;i++)g[i]=mod(g[i-2]+g[i-1]);\n    if(m)for(i=n-2;0<=i&&n-i<=t+1;i-=2)x=(x+(long long)g[i]*(n-i))%p;\n    else x=mod(g[n]+g[n-2]);\n    return 0*printf(\"%d\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 201000,mod = 1e9+7;\nchar s[N];\nint a[N],n,m;\nvoid solve1(){\n\tint f[N][2][2];memset(f,0,sizeof(f));\n\tf[1][1][1]=f[1][0][0]=1;\n\tauto upd=[](int&a,int b){a+=b;if(a>=mod)a-=mod;};\n\tfor(int i=2;i<=n;i++){\n\t\tupd(f[i][1][1],f[i-1][1][0]);\n\t\tupd(f[i][1][1],f[i-1][1][1]);\n\t\tupd(f[i][1][0],f[i-1][1][1]);\n\t\tupd(f[i][0][1],f[i-1][0][0]);\n\t\tupd(f[i][0][1],f[i-1][0][1]);\n\t\tupd(f[i][0][0],f[i-1][0][1]);\n\t}\n\tcout<<(0ll+f[n][1][1]+f[n][1][0]+f[n][0][1])%mod<<'\\n';\n}\nvoid solve2(){\n\tint _f[N],*f;memset(_f,0,sizeof(_f));\n\tf=_f+100;\n\tint len=n|1,now=0;\n\tfor(int i=n;i;i--)\n\t\tif(!a[i]){\n\t\t\tif(now&1) len=min(len,now);\n\t\t\tnow=0;\n\t\t}\n\t\telse now++;\n\tlen=min(len,now|1);\n\tf[-1]=f[1]=1;\n\tfor(int i=3;i<=n;i+=2){\n\t\tf[i]=2ll*f[i-2]%mod;\n\t\tif(i>len) f[i]=(f[i]-f[i-len-3]+mod)%mod;\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=len;i+=2) ans=(1ll*(i+1)*f[n-i-2]+ans)%mod;\n\tcout<<ans<<'\\n';\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n>>m>>s+1;\n\tfor(int i=1;i<=m;i++)\n\t\ta[i]=s[i]==s[1];\n\tint flag=1;\n\tfor(int i=1;i<=m;i++)\n\t\tflag&=a[i];\n\tif(flag) solve1();\n\telse solve2();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\ninline void add(int &x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nll bin_pow(ll a, ll p) {\n    ll res = 1;\n    while (p) {\n        if (p & 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return res;\n}\n\nll rev(ll x) {\n    return bin_pow(x, MOD - 2);\n}\n\nll fact[N + 1], rfact[N + 1];\n\nvoid init() {\n    fact[0] = 1;\n    rep(i, 1, N + 1) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    rfact[N] = rev(fact[N]);\n    repb(i, N - 1, -1) {\n        rfact[i] = rfact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nll C(int n, int k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    return fact[n] * rfact[k] % MOD * rfact[n - k] % MOD;\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    init();\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    repb(i, m - 1, -1) {\n        s[i] = char('0' + (s[0] != s[i]));\n    }\n    int c1 = -1;\n    rep(i, 0, m) {\n        if (s[i] == '1') {\n            c1 = i;\n        }\n    }\n    if (c1 == -1) {\n        int ans = 0;\n        for (int i = 0; i * 2 <= n; i++) {\n            add(ans, C(n - i, i));\n            if (i >= 1) {\n                add(ans, C(n - 2 - (i - 1), (i - 1)));\n            }\n        }\n        cout << ans << \"\\n\";\n        return 0;\n    }\n    s = s.substr(0, c1 + 1);\n    m = sz(s);\n    if (n % 2 == 1) {\n        cout << 0 << \"\\n\";\n        return 0;\n    }\n    int k = n - 1, cur = 0;\n    rep(i, 0, m) {\n        if (s[i] == '0') {\n            cur++;\n        }\n        if (s[i] == '0' && (i == m - 1 || s[i + 1] == '1')) {\n            if (cur % 2 == 1) {\n                setmin(k, cur);\n            } else if (cur > 0) {\n                setmin(k, cur + 1);\n            }\n            cur = 0;\n        }\n    }\n    //cout << k << endl;\n    int dp[n + 2], pref1[n + 2];\n    fill(dp, dp + n + 2, 0);\n    fill(pref1, pref1 + n + 2, 0);\n    dp[1] = 1;\n    pref1[1] = 1;\n    for (int i = 3; i <= n + 1; i += 2) {\n        int last_add = max(1, i - (k + 1));\n        dp[i] = pref1[i - 2] - (last_add - 2 >= 0 ? pref1[last_add - 2] : 0);\n        if (dp[i] < 0) {\n            dp[i] += MOD;\n        }\n        pref1[i] = (pref1[i - 2] + dp[i]) % MOD;\n    }\n    /*rep(i, 1, n + 2) {\n        cout << dp[i] << \" \";\n    }\n    cout << \"\\n\";*/\n    int ans = dp[n + 1];\n    //cout << k << endl;\n    for (int c = 1; c <= k; c += 2) {\n        //cout << c << \" \" << dp[n - c] << endl;\n        ans = (ans + 1LL * c * dp[n - c]) % MOD;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint N, M; char S[200200];\n\nconst long long mod = 1000000007;\nlong long D[200200], V[200200];\n\nint main()\n{\n\tscanf (\"%d %d %s\", &N, &M, S);\n\tif (S[0] == 'B'){\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tif (S[i] == 'R') S[i] = 'B';\n\t\t\telse S[i] = 'R';\n\t\t}\n\t}\n\n\tvector<int> len;\n\tfor (int i = 1, l = -1; i < M; i++){\n\t\tif (S[i-1] == 'R' && S[i] == 'B'){\n\t\t\tint u = i - l - 1;\n\t\t\tlen.push_back(u);\n\t\t\tl = i;\n\t\t}\n\t}\n\n\tif (len.empty()){\n\t\tD[0] = 1;\n\t\tD[1] = 1;\n\t\tfor (int i = 2; i <= N; i++) D[i] = (D[i - 1] + D[i - 2]) % mod;\n\t\tprintf (\"%lld\\n\", (D[N - 1] + (N >= 3 ? D[N - 3] : 0) + 1) % mod);\n\t\treturn 0;\n\t}\n\n\tint lim = N + 1;\n\tif (!len.empty()){\n\t\tlim = len[0] + 1;\n\t\tif (lim % 2 == 0) lim--;\n\t}\n\n\tD[0] = V[0] = 1;\n\tfor (int i = 1; i <= N; i++){\n\t\tif (i <= lim + 1) D[i] = i - 1;\n\t\tlong long u = 0, v = 0;\n\t\tif (i >= 2) u = V[i - 2];\n\t\tif (i >= lim + 3) v = V[i - (lim + 3)];\n\t\tD[i] = (D[i] + u + mod - v) % mod;\n\n\t\tV[i] = D[i];\n\t\tif (i >= 2) V[i] = (V[i] + V[i - 2]) % mod;\n\t}\n\tprintf (\"%lld\\n\", D[N]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 2e5 + 10, mod = 1e9 + 7;\n\nll dp[N], pref[N][2];\n\nll solve(int n, int bound, bool parity);\n\nint main() {\n\tfast_cin();\n\tint n, m; string s;\n\tcin >> n >> m >> s;\n\ts += (s[0] ^ 'R' ^ 'B');\n\tvector<int> parts;\n\tint cur = 1;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (s[i] != s[i - 1]) {\n\t\t\tparts.pb(cur);\n\t\t\tcur = 1;\n\t\t} else {\n\t\t\t++cur;\n\t\t}\n\t}\n\tint bound = parts[0] + (1 - (parts[0] & 1));\n\tfor (int i = 2; i < parts.size(); i += 2) {\n\t\tif (parts[i] & 1) {\n\t\t\tbound = min(bound, parts[i]);\n\t\t}\n\t}\n\tif (parts.size() == 1) {\n\t\tcout << (solve(n, n, false) + 1) % mod << '\\n';\n\t} else {\n\t\tcout << solve(n, bound, true) << '\\n';\n\t}\n}\n\nll solve(int n, int bound, bool parity) {\n\tdp[0] = 1;\n\tpref[0][0] = 1;\n\tif (!parity) {\n\t\tpref[0][1] = 1;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint lo = max(0, i - bound - 1), hi = i - 2;\n\t\tif (lo <= hi) {\n\t\t\tdp[i] = pref[hi][hi & 1] - (lo > 0 ? pref[lo - 1][hi & 1] : 0);\n\t\t\tdp[i] += mod;\n\t\t\tdp[i] %= mod; \n\t\t}\n\t\tpref[i][0] = pref[i - 1][0];\n\t\tpref[i][1] = pref[i - 1][1];\n\t\tpref[i][i & 1] += dp[i];\n\t\tpref[i][i & 1] %= mod;\n\t\tif (!parity) {\n\t\t\tpref[i][(i + 1) & 1] = pref[i][i & 1];\n\t\t}\n\t\t// cout << i << ' ' << dp[i] << '\\n';\n\t}\n\tll ans = dp[n];\n\tfor (int i = 1; i < n and i <= bound; ++i) {\n\t\tint lo = max(i, n + (i - 1) - bound) - i, hi = n - i - 1;\n\t\tif (lo <= hi) {\n\t\t\tans += pref[hi][n & 1] - (lo > 0 ? pref[lo - 1][n & 1] : 0);\n\t\t\tans += mod;\n\t\t\tans %= mod;\n\t\t}\n\t}\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PI 3.14159265358979323846264338327950288419\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint n, m;\nint col[200005];\n\nint calc(int n){\n\tint fib[200005];\n\tfib[1] = fib[2] = 1;\n\tfor(int i = 3; i <= n + 1; i++){\n\t\tfib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t}\n\t\n\t// force first one to be 1, last one to be 0: fib[n - 1]\n\t// force first one to be 0: fib[n + 1]\n\treturn (fib[n - 1] + fib[n + 1]) % mod;\n}\n\nint calc2(int n, int ub){\n\tassert(ub & 1);\n\t\n\t// want a bunch of numbers, in [2, ub], to sum to n\n\t\n\tub++;\n\tub = min(ub, n); // coz it can actually be HUGE\n\t\n\tint dp[200005]; // dp[i]: number of possible sums, that sum to i\n\tint cumu[200005];\n\t\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(cumu, 0, sizeof(cumu));\n\tdp[0] = 1;\n\tcumu[0] = 1;\n\t\n\tfor(int i = 2; i <= n; i += 2){\n\t\t// sum dp[l_index .. i - 2].. oh, only the even ones!\n\t\tint l_index = i - ub;\n\t//\tprintf(\"%d: sum %d..%d\\n\", i, l_index, r_index);\n\t\tdp[i] = cumu[i - 2];\n\t\t\n\t\tif(l_index > 0){\n\t\t\tdp[i] -= cumu[l_index - 2];\n\t\t\tif(dp[i] < 0){\n\t\t\t\tdp[i] += mod;\n\t\t\t}\n\t\t}\n//\t\tprintf(\"%d: %d\\n\", i, dp[i]);\n\t\tcumu[i] = (cumu[i - 2] + dp[i]) % mod;\n\t}\n\t\n\tint ret = 0;\n\t\n\tfor(int space = 0; space < ub; space++){\n\t\t// last 1 is at (n - space), leaving _ space at the end\n\t\t// where can the first 1 be?\n\t\tint most_remain = n - (space + 1);\n\t\tint least_remain = n - ub;\n\t\t\n\t\tif(most_remain & 1) most_remain--;\n\t\t\n\t\t// sum up dp[least_remain..most_remain] (even indices only)\n\t\t\n\t\tint combin = cumu[most_remain];\n\t\tif(least_remain > 0){\n\t\t\tcombin = (combin - cumu[least_remain - 2] + mod) % mod;\n\t\t}\n\t\tret = (ret + combin) % mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= m; i++){\n\t\tchar c;\n\t\tscanf(\" %c\", &c);\n\t\tcol[i] = (c == 'B');\n\t}\n\t\n\tif(col[1] != 0){\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tcol[i] = 1 - col[i];\n\t\t}\n\t}\n\t\n\t// WLOG first one is 0\n\tbool monochrome = true;\n\tfor(int i = 2; i <= m; i++){\n\t\tif(col[i]){\n\t\t\tmonochrome = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(monochrome){\n\t\t// ok as long as 1s are not adjacent\n\t\tprintf(\"%d\\n\", calc(n));\n\t\treturn 0;\n\t}else{\n\t\t// 00...010..010..0\n\t\t// each block of 0 is of add length\n\t\t// so, n odd -> definitely no solution\n\t\t// more conditions depending on specifics of col[]\n\t\tif(n % 2 == 1){\n\t\t \tprintf(\"0\\n\");\n\t\t \treturn 0;\n\t\t}\n\t\tint first_run = 0, subseq_run = n - 1;\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tint len = 0;\n\t\t\twhile(i + len <= m && col[i + len] == 0){\n\t\t \t\tlen++;\n\t\t \t}\n\t\t \tif(first_run == 0){\n\t\t \t\tfirst_run = len;\n\t\t \t}else if(len & 1){\n\t\t \t\tsubseq_run = min(subseq_run, len);\n\t\t \t}\n\t\t \ti += len;\n\t\t}\n\t\tint ub = first_run + (first_run % 2 == 0);\n\t\tub = min(ub, subseq_run);\n\t\tassert(ub < n); // see if I get RE for some WA cases...\n\t\tprintf(\"%d\\n\", calc2(n, ub));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MAX_N 200000\n#define MAX_M 200000\n#define MOD 1000000007\n\n#define INF 1 << 29\n\nint N, M;\nstring S;\n\nlong long dp[MAX_N + 2], rdp[MAX_N + 2];\n\nint all_color_is_same()\n{\n    long long rr = 1, bb = 1, rb = 0, br = 0;\n\n    for ( int i = 1; i < N; i++ )\n    {\n        long long nrr = ( rr + rb ) % MOD;\n        long long nbb = br;\n        long long nrb = rr;\n        long long nbr = ( bb + br ) % MOD;\n\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n\n    return ( rr + rb + br ) % MOD;\n}\n\n/* S\nの先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n*/\nint min_freq()\n{\n    int l = 0;\n    while ( S[0] == S[l] ) l++;\n\n    int ans = ( l & 1 ) ? l : l + 1;\n\n    l = 0;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[0] == S[i] )\n            l++;\n        else\n        {\n            if ( l & 1 ) ans = min( ans, l );\n            l = 0;\n        }\n    }\n    return ( l & 1 ) ? min( ans, l ) : ans;\n}\n\nint solve()\n{\n    // 一色\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n        return all_color_is_same();\n\n    // N が奇数\n    if ( N & 1 ) return 0;\n\n    int L = min_freq();\n\n    L = ( L + 1 ) >> 1;\n    N >>= 1;\n\n    dp[0] = rdp[0] = 1;\n    for ( int i = 1; i <= N + 1; i++ )\n    {\n        dp[i] = rdp[i - 1];\n        if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n\n    long long res = 0;\n    for ( int i = 1; i <= L; i++ )\n        if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n    return res % MOD;\n}\n\nint main( int argc, char **argv )\n{\n    cin >> N >> M;\n    cin >> S;\n\n    int ans = solve();\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    constexpr unsigned long MOD = 1000000007;\n    unsigned long N, M;\n    string s;\n    cin >> N >> M >> s;\n\n    if(equal(s.begin(), s.end() - 1, s.begin() + 1)){\n        vector<unsigned long> fib(N + 1);\n        fib[0] = 1;\n        fib[1] = 1;\n        for(unsigned long i = 2; i <= N; ++i){\n            fib[i] = fib[i - 1] + fib[i - 2];\n            fib[i] -= MOD * (fib[i] >= MOD);\n        }\n        cout << fib[N - 2] + fib[N] % MOD << endl;\n    }else{\n        if(N & 1)return 0 & puts(\"0\");\n        auto t = find(s.begin(), s.end(), 'R' ^ 'B' ^ s[0]) - s.begin();\n        auto k = t | 1UL;\n        {\n            unsigned long cnt{0};\n            for(auto &i : s){\n                if(i == s[0])++cnt;\n                else{\n                    if(cnt & 1){\n                        k = min(k, cnt);\n                    }\n                    cnt = 0;\n                }\n            }\n        }\n        vector<unsigned long> dp(N + 1), sum(N + 1);\n        dp[0] = 1;\n        dp[1] = 1;\n        sum[0] = 1;\n        sum[1] = 1;\n        for(unsigned long i = 2; i <= N; ++i){\n            dp[i] = sum[i - 2];\n            if(i > k + 2)dp[i] += MOD - sum[i - k - 3];\n            (sum[i] = sum[i - 2] + (dp[i] %= MOD)) %= MOD;\n        }\n        unsigned long ans{0};\n        for(unsigned long l = 1; l <= k; l += 2)ans += (l + 1) * dp[N - l - 1] % MOD;\n        cout << ans % MOD << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable: 4996)\n\n// 入力\nlong long mod = 1000000007;\nlong long N, M;\nstring S;\n\n// その他\nlong long fib[1 << 19];\nlong long dp[1 << 19], ru[1 << 19];\nlong long ret[1 << 19];\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 32; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nlong long Div(long long p, long long q, long long m) {\n\treturn (p * modpow(q, m - 2, m)) % m;\n}\n\nlong long solve(long long n, long long r) {\n\tfor (int i = 0; i <= N; i++) dp[i] = 0;\n\tfor (int i = 0; i <= N; i++) ru[i] = 0;\n\tfor (int i = 1; i <= r / 2; i++) dp[i] = 1LL * (i * 2);\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tlong long v = ru[i - 1]; if (i - (r / 2) - 1 >= 0) v -= ru[i - (r / 2) - 1];\n\t\tv = (v + mod) % mod;\n\t\tdp[i] += v; dp[i] %= mod;\n\t\tru[i] = (dp[i] + ru[i - 1]) % mod;\n\t}\n\t\n\tlong long val = dp[n / 2];\n\treturn val;\n}\n\nint main() {\n\tcin >> N >> M >> S;\n\n\t// 判定\n\tbool flag = false;\n\tfor (int i = 0; i < S.size() - 1; i++) {\n\t\tif (S[i] != S[i + 1]) flag = true;\n\t}\n\n\t// 特殊\n\tif (flag == false) {\n\t\tfib[0] = 1;\n\t\tfib[1] = 1;\n\t\tfor (int i = 2; i <= N; i++) fib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t\tcout << (fib[N] + fib[N - 2]) % mod << endl;\n\t\treturn 0;\n\t}\n\n\t// 奇数\n\tif (N % 2 == 1) {\n\t\tcout << \"0\" << endl;\n\t\treturn 0;\n\t}\n\n\t// 偶数\n\tif (S[0] == 'B') {\n\t\tfor (int i = 0; i < S.size(); i++) {\n\t\t\tif (S[i] == 'B') S[i] = 'R';\n\t\t\telse S[i] = 'B';\n\t\t}\n\t}\n\tint MaxLength = N, cur = 0, cnt = 0;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] == 'R') cur++;\n\t\telse {\n\t\t\tif (cnt == 0) {\n\t\t\t\tMaxLength = min(MaxLength, cur);\n\t\t\t}\n\t\t\telse if (cur % 2 == 1) {\n\t\t\t\tMaxLength = min(MaxLength, cur);\n\t\t\t}\n\t\t\tcur = 0; cnt++;\n\t\t}\n\t}\n\tMaxLength += 2;\n\n\tvector<long long> E;\n\tfor (int i = 1; i <= N / 2; i++) {\n\t\tif ((N / 2) % i == 0) E.push_back(i);\n\t}\n\tfor (int i = E.size() - 1; i >= 0; i--) {\n\t\tlong long d1 = (N / E[i]);\n\t\tlong long d2 = MaxLength;\n\t\tret[i] = solve(d1, d2);\n\t\tfor (int j = i + 1; j < E.size(); j++) {\n\t\t\tif (E[j] % E[i] == 0) { ret[i] -= ret[j]; ret[i] = (ret[i] + mod) % mod; }\n\t\t}\n\t}\n\n\tlong long FinalAns = 0;\n\tfor (int i = 0; i < E.size(); i++) {\n\t\tFinalAns += 1LL * ret[i];\n\t\tFinalAns %= mod;\n\t}\n\tcout << FinalAns << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200233, mod = 1000000007;\nint n, m, f[N];\nchar s[N];\n\nint main() {\n  scanf(\"%d%d%s\", &n, &m, s + 1);\n  if (*min_element(s + 1, s + 1 + m) == *max_element(s + 1, s + 1 + m)) {\n    int x = 2, y = 1;\n    for (int i = 1; i <= n; i++) {\n      y = (y + x) % mod;\n      x = (mod + y - x) % mod;\n    }\n    printf(\"%d\\n\", x);\n    return 0;\n  }\n  int limit, x = 1;\n  while (x + 1 <= m && s[x + 1] == s[1]) x++;\n  limit = x | 1;\n  for (int i = x + 1, j = 0; i <= m; i++) {\n    if (s[i] != s[1]) {\n      if (j & 1) limit = min(limit, j);\n      j = 0;\n    } else {\n      ++j;\n    }\n  }\n  if (n & 1) {\n    puts(\"0\");\n    return 0;\n  }\n  n >>= 1;\n  limit = min(n, (limit + 1) >> 1);\n  f[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    f[i] = ((long long) mod + f[i - 1] + f[i - 1] - (i > limit ? f[i - limit - 1] : 0)) % mod;\n  }\n  int ans = 0;\n  for (int i = 1; i <= limit; i++) {\n    ans = (ans + (long long) (mod + f[n - i] - (n > i ? f[n - i - 1] : 0)) * i * 2) % mod;\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\ntypedef pair<int, int> P;\nconst long long inf = 1ll << 61;\n\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (n & 1)cout << 0 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint int\nusing namespace std;\n     \ntypedef long long lo;\n     \ntemplate<typename tp> inline void read(tp &x) {\n\tx = 0; char c = getchar(); int f = 0;\n\tfor (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n\tfor (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n\tif (f) x = -x;\n}\nnamespace {\n    const int mo = 1e9 + 7;\n    inline int add(int x, int y) { x += y; return x >= mo ? x - mo : x; }\n    inline int sub(int x, int y) { x -= y; return x < 0 ? x + mo : x; }\n    inline int mul(int x, int y) { return (lo) x * y % mo; }\n    inline int power(int a, int k = mo - 2) {\n\t\tint ans = 1;\n\t\tfor (; k; k >>= 1, a = mul(a, a))\n\t\t\tif (k & 1) ans = mul(ans, a);\n\t\treturn ans;\n    }\n\tinline void U(int &x, int y) { x = add(x, y); } \n}\n\nconst int N = 3e5 + 23;\nint n, m;\nchar str[N];\n\ninline int spj() {\n\tint ans = 0;\n\tfor (int fi = 0; fi < 2; fi++) {\n\t\tvector <vector <int> > dp(n + 1, vector <int> (2, 0));\n\t\tdp[1][fi] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tU(dp[i][0], dp[i - 1][1]);\n\t\t\tU(dp[i][0], dp[i - 1][0]);\n\t\t\tU(dp[i][1], dp[i - 1][0]);\n\t\t\t// cout << dp[i][0] << \" \" << dp[i][1] << \"\\n\";\n\t\t}\n\t\tif (fi == 0) ans = add(ans, add(dp[n][0], dp[n][1]));\n\t\telse ans = add(ans, dp[n][0]);\n\t}\n\treturn ans;\n}\n\ninline int doit(int limit) {\n\t++limit;\n\tvector <int> dp(n + 1, 0);\n\tvector <int> sum(n + 1, 0);\n\tdp[0] = sum[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tauto getsum = [&](int l, int r) {\n\t\t\tif ((l & 1) != (r & 1)) ++l;\n\t\t\tif (l > r || r < 0) return 0;\n\t\t\telse return sub(sum[r], l >= 2 ? sum[l - 2] : 0);\n\t\t};\n\t\t// for (int k = i - 2; k >= 0 && k >= i - limit; k -= 2)\n\t\t// \tU(dp[i], dp[k]);\n\t\tU(dp[i], getsum(max(0, i - limit), i - 2));\n\t\tsum[i] = dp[i];\n\t\tif (i > 1) U(sum[i], sum[i - 2]);\n\t}\n\tint ans = 0;\n\tfor (int pre = 2; pre <= limit; pre += 2) {\n\t\tU(ans, mul(pre, dp[n - pre]));\n\t}\n\treturn ans;\n}\n\nint main(void) {\n\tread(n); read(m);\n\tscanf(\"%s\", str + 1);\n\tint first = 0;\n\tfor (int i = 1; i <= m; i++) \n\t\tif (str[i] != str[1]) { first = i; break; }\n\t--first;\n\t// cout << \"first = \" << first << \"\\n\";\n\tint limit = first & 1 ? first : first + 1;\n\tint con = limit;\n\tfor (int i = first + 1; i <= m; i++) {\n\t\tif (str[i] != str[1]) {\n\t\t\tif (con & 1) limit = min(limit, con);\n\t\t\tcon = 0;\n\t\t} else {\n\t\t\t++con;\n\t\t}\t\t\t   \n\t}\n\tif (con & 1) limit = min(limit, con);\n\t// cerr << \"limit = \" << limit << \"\\n\";\n\tcout << doit(limit) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nconstexpr lint MOD = 1000000007;\n\nlint corner_case(int N)\n{\n    lint a = 1, b = 0; // R始まり\n    lint c = 0, d = 1; // B始まり\n    REP(i, N - 1)\n    {\n        lint bnew = a;\n        lint anew = (a + b) % MOD;\n        a = anew;\n        b = bnew;\n\n        lint dnew = c;\n        lint cnew = (c + d) % MOD;\n        c = cnew;\n        d = dnew;\n    }\n    return (a + b + c) % MOD;\n}\n\nint main()\n{\n    lint N;\n    cin >> N;\n    lint M;\n    cin >> M;\n    string S;\n    cin >> S;\n    if (S[0] == 'B')\n    {\n        for (auto &c : S)\n        {\n            c = 'R' + 'B' - c;\n        }\n    }\n    int n = 0;\n    vector<int> con;\n    for (auto c : S)\n    {\n        if (c == 'R') n++;\n        else con.push_back(n), n = 0;\n    }\n    if (con.size() == 0)\n    {\n        lint ret = corner_case(N);\n        cout << ret << endl;\n        return 0;\n    }\n\n    if (N % 2)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int Lmaxi = (con[0] % 2 ? con[0] : con[0] + 1);\n    FOR(i, 1, con.size())\n    {\n        if (con[i] % 2) mmin(Lmaxi, con[i]); // 奇数だとヤバい\n    }\n\n    int P = (Lmaxi + 1) / 2;\n    int Q = N / 2;\n    // QをP以下で分割\n\n    vector<lint> dp(Q + 1);\n    dp[0] = 1;\n    lint acc = dp[0];\n    REP(i, Q)\n    {\n        dp[i + 1] = acc;\n        (acc += dp[i + 1]) %= MOD;\n        if (i + 1 - P >= 0) (acc += MOD - dp[i + 1 - P]) %= MOD;\n    }\n\n    vector<lint> dp_acc(Q + 2);\n    REP(i, Q + 1) dp_acc[i + 1] = (dp_acc[i] + dp[i]) % MOD;\n\n    lint ret = 0;\n    REP(l, Lmaxi + 1)\n    {\n        int n = l / 2;\n        if (n < P) (ret += (dp_acc[max(Q - n, 0)] - dp_acc[max(Q - P, 0)] + MOD)) %= MOD;\n    }\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\nusing namespace std;\n\ntypedef long long li;\n\nconst int mod = 1e9 + 7;\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (li)x * y % mod; }\n\n// ----------------------------------------\n\nconst int maxn = 2e5;\n\nint n, m, lim;\nchar s[maxn + 1];\nint dp[maxn + 1];\nint sum[maxn + 2];\n\nvoid GetLim(void) {\n  int cnt = 0;\n  for (int i = 0; i < m; ++i) {\n    if (s[i] == 'R') ++cnt; else break;\n  }\n  if (cnt & 1) lim = cnt; else lim = cnt + 1;\n  cnt = 0;\n  for (int i = 0; i < m; ++i) {\n    if (s[i] == 'R') ++cnt; else {\n      if (cnt & 1) lim = min(lim, cnt);\n      cnt = 0;\n    }\n  }\n}\n\nvoid SolveSame(void) {\n  static int dp[maxn + 1][2][2];\n  dp[0][0][0] = dp[0][1][1] = 1;\n  for (int i = 1; i < n; ++i) {\n    for (int x = 0; x <= 1; ++x) {\n      for (int y = 0; y <= 1; ++y) {\n        for (int z = 0; z <= 1; ++z) {\n          if (y != 1 || z != 1) {\n            Add(dp[i][x][z], dp[i - 1][x][y]);\n          }\n        }\n      }\n    }\n  }\n  int ans = Add(Add(dp[n - 1][0][0] + dp[n - 1][0][1]) + dp[n - 1][1][0]);\n  printf(\"%d\\n\", ans);\n}\n\nint main(void) {\n  scanf(\"%d%d%s\", &n, &m, s);\n  if (s[0] == 'B') {\n    for (int i = 0; i < m; ++i) {\n      s[i] ^= 'R' ^ 'B';\n    }\n  }\n  if (count(s, s + m, 'R') == m) {\n    // the same\n    SolveSame();\n    return 0;\n  }\n\n  GetLim();\n  lim = lim + 1 >> 1;\n  if (n & 1) {\n    puts(\"0\");\n    return 0;\n  }\n  n /= 2;\n\n  for (int i = 1; i <= lim; ++i) {\n    Add(dp[i], 2 * i);\n  }\n  for (int i = 1; i <= n; ++i) {\n    // printf(\"this is %d\\n\", i);\n    // calc dp[i]\n    int L = max(1, i - lim), R = i;\n    Add(dp[i], Sub(sum[R] - sum[L]));\n    sum[i + 1] = Add(sum[i] + dp[i]);\n  }\n  printf(\"%d\\n\", dp[n]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=200005;\nconst int mod=1e9+7;\nint n,m,mn,ans;\nchar s[maxn],ch;\nint f[maxn],sum[maxn],g[maxn][2];\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d%d%s\",&n,&m,s);\n\tch=s[0];\n\tint cnt=0;\n\tmn=INF;\n\trep(i,m){\n\t\tif(s[i]!=ch){\n\t\t\tif(!cnt)continue;\n\t\t\tif(cnt%2==0)cnt++;\n\t\t\tmn=min(mn,cnt);\n\t\t\tcnt=0;\t\n\t\t}\n\t\telse cnt++;\n\t}\n\tif(mn==INF){\n\t\tg[1][0]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tg[i][0]=(g[i-1][0]+g[i-1][1])%mod;\n\t\t\tg[i][1]=g[i-1][0];\n\t\t}\n\t\tans=(g[n][0]+g[n][1])%mod;\n\t\tREP(i,n)g[i][0]=g[i][1]=0;\n\t\tg[1][1]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tg[i][0]=(g[i-1][0]+g[i-1][1])%mod;\n\t\t\tg[i][1]=g[i-1][0];\n\t\t}\n\t\tans=(ans+g[n][0])%mod;\n\t}\n\telse{\n\t\tif(n&1)ans=0;\n\t\telse{\n\t\t\tn/=2;\n\t\t\tmn=(mn+1)/2;\n\t\t\tf[0]=1;sum[0]=1;\n\t\t\tREP(i,n){\n\t\t\t\tf[i]=(sum[i-1]-(i-mn-1>=0?sum[i-mn-1]:0)+mod)%mod;\n\t\t\t\tsum[i]=(sum[i-1]+f[i])%mod;\n\t\t\t}\n\t\t\trep(i,n)if(n-i<=mn)ans=(ans+2LL*(n-i)*f[i]%mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MAX_N 200000\n#define MAX_M 200000\n#define MOD 1000000007\n\n#define INF 1 << 29\n\nint N, M;\nstring S;\n\nlong long dp[MAX_N + 1], rdp[MAX_N + 1];\n\nint all_color_is_same()\n{\n    int rr = 1, bb = 1, rb = 0, br = 0;\n\n    for ( int i = 1; i < N; i++ )\n    {\n        int nrr = ( rr + rb ) % MOD;\n        int nbb = br;\n        int nrb = rr;\n        int nbr = ( bb + br ) % MOD;\n\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n\n    return ( rr + rb + br ) % MOD;\n}\n\n/**\n * S の先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n */\nint min_freq()\n{\n    int l = 0;\n    while ( l < M && S[0] == S[l] ) l++;\n\n    int ans = ( l & 1 ) ? l : l + 1;\n\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[0] == S[i] )\n            l++;\n        else if ( l & 1 )\n        {\n            ans = min( ans, l );\n            l = 0;\n        }\n    }\n    return l ? min( ans, l ) : ans;\n}\n\nint solve()\n{\n    // 一色\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n        return all_color_is_same();\n\n    // N が奇数\n    if ( N & 1 ) return 0;\n\n    int L = min_freq();\n\n    L = ( L + 1 ) >> 1;\n    N >>= 1;\n\n    dp[0] = rdp[0] = 1;\n    for ( int i = 1; i <= N + 1; i++ )\n    {\n        dp[i] = rdp[i - 1];\n        if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n\n    int res = 0;\n    for ( int i = 1; i <= L; i++ )\n        if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n    return res % MOD;\n}\n\nint main( int argc, char **argv )\n{\n    cin >> N >> M;\n    cin >> S;\n\n    int ans = solve();\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <list>\n#include <iterator>\n#include <assert.h>\n#pragma warning(disable:4996) \n\ntypedef long long ll;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF 9223300000000000000\n#define INF 2140000000\nconst long long MOD = 1000000007;\nusing namespace std;\n\nchar str[200005];\n\n// A(Bを数個)A(Bを数個)..A(Bを数個) \n// という列の作り方が何通りあるか、を求める\n// ただし列の長さをn、Bを重ねるのは各箇所について0個以上k個以下とする\n// また両端がつながっているものとする\nll func( int n, int k)\n{\n#ifdef _DEBUG\n    printf(\"%d %d\\n\", n, k);\n#endif\n    vector<ll> dp(n+1);   // dp[i]: func(i,k)と同じ。ただし両端がつながっていないものとする。\n    vector<ll> sdp(n+2);  // dpの累積和\n    dp[0]=1;\n    sdp[0]=0; sdp[1]=1;\n    int i;\n    for(i=1; i<=n; i++) {\n        dp[i]=(sdp[i]-sdp[MAX(0,i-k-1)]+MOD)%MOD;\n        sdp[i+1]=(sdp[i]+dp[i])%MOD;\n    }\n    ll ans = dp[n];\n\n    // dp[n]は、Aから始まるものだけを数えたもの。\n    // 両端がつながっている状況で、Bから始まるものを数える\n    // Bが最初にp個重なった場合を考えて足し合わせればよい\n    int p;\n    for(p=1; p<=k; p++) {\n        // dp[n-p-1],dp[n-p-2],..という(k-p+1)個を足し合わせればよい\n        ans = (ans + sdp[n-p] - sdp[n-k-1])%MOD;\n    }\n\n    return ans;\n}\n\nint main(int argc, char* argv[])\n{\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    scanf(\"%s\", str);\n\n    char c=str[0];\n    int max_odd=0;\n    int cnt_first=-1;\n    int cnt=0;\n    int cnt2=0;\n    int i;\n    for(i=0; i<m; i++) {\n        if(str[i]==c) {\n            cnt++;\n        }\n        else {\n            if(cnt==0) {\n                if(n%2==0) printf(\"2\\n\");\n                else       printf(\"0\\n\");\n                return 0;\n            }\n            if(cnt_first<0) cnt_first=cnt;\n            if(cnt%2) max_odd = MAX(max_odd, cnt);\n            cnt=0;\n            cnt2++;\n        }        \n    }\n\n    if(cnt2==0) {\n        printf(\"%lld\\n\", func(n, 1));\n    }\n    else {\n        if(n%2==0) {\n            int k = (cnt_first%2==0? cnt_first+1: cnt_first);\n            if(max_odd>0) k = MIN(k, max_odd);\n            printf(\"%lld\\n\", func(n/2, (k-1)/2) *2 %MOD);\n        }\n        else {\n            printf(\"0\\n\");\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n\treturn powmod(a, MOD-2);\n}\nll f[200001], invf[200001];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n    invf[n]=inv(f[n]);\n    for(ll i=n-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n}\nll comb(int x, int y){\n    if(x<y) return 0;\n    return f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nint main()\n{\n    int n, m; cin>>n>>m;\n    string s; cin>>s;\n    if(s[0]=='B'){\n        for(int i=0; i<m; i++){\n            if(s[i]=='B') s[i]='R';\n            else s[i]='B';\n        }\n    }\n    int j=-1;\n    vector<int> v;\n    bool nuo=1;\n    for(int i=0; i<m; i++){\n        if(s[i]=='B') nuo=0;\n        if(i==m-1 || s[i+1]=='B'){\n            v.push_back(i-j);\n            j=i+1;\n        }\n    }\n    if(nuo){\n        ll dp[2][200002]={};\n        dp[0][0]=1;\n        for(int i=1; i<n; i++){\n            dp[1][i]+=dp[0][i-1];\n            dp[0][i]+=(dp[0][i-1]+dp[1][i-1]);\n            dp[0][i]%=MOD;\n            dp[1][i]%=MOD;\n        }\n        ll ans=dp[0][n-1]+dp[1][n-1];\n        fill(dp[0], dp[0]+n+1, 0);\n        fill(dp[1], dp[1]+n+1, 0);\n        dp[1][0]=1;\n        for(int i=1; i<n; i++){\n            dp[1][i]+=dp[0][i-1];\n            dp[0][i]+=(dp[0][i-1]+dp[1][i-1]);\n            dp[0][i]%=MOD;\n            dp[1][i]%=MOD;\n        }\n        ans+=dp[0][n-1];\n        ans%=MOD;\n        cout<<ans<<endl;\n        return 0;\n    }\n    if(n%2==1){\n        cout<<0<<endl;\n        return 0;\n    }\n    int mx=v[0]+1-v[0]%2;\n    for(int i=1; i<v.size(); i++){\n        if(v[i]&1) mx=min(mx, v[i]);\n    }\n    ll dp[200002]={}, sum[200002];\n    dp[0]=1;\n    sum[0]=1;\n    for(int i=1; i<=n; i++){\n        if(i&1) sum[i]=sum[i-1];\n        else{\n            if(i-mx-3>=0) dp[i]=(sum[i-2]-sum[i-mx-3]+MOD)%MOD;\n            else dp[i]=sum[i-2];\n            sum[i]=(sum[i-1]+dp[i])%MOD;\n        }\n    }\n    ll ans=0;\n    for(int i=1; i<=min(mx, n-1); i+=2){\n        ans+=(ll)(i+1)*dp[n-i-1];\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 1000000007;\n\nconst long long MOD_CONST = 1000000007;\nlong long mul_mod(long long a, long long b, const long long MOD) {\n  return b ? (mul_mod(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow_mod(long long a, long long b, const long long MOD) {\n  return (b ? bpow_mod(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv_mod(long long a, const long long MOD) {\n  return bpow_mod(a, MOD - 2, MOD);\n}\ntemplate <long long param = MOD_CONST, bool fast = false>\nclass mint {\n private:\n  using Z = int;\n  using N = unsigned int;\n  using ZZ = long long;\n  using NN = unsigned long long;\n  struct {\n  } constexpr static exact{};\n  // Using Z deliberately to avoid Z -> N promotion.\n  template <class Ret = ZZ&>\n  static auto modulo() -> std::enable_if_t<(param <= 0), Ret> {\n    static ZZ mod = 0;\n    return mod;\n  }\n  template <class Ret = const ZZ>\n  static auto mod() -> std::enable_if_t<(param <= 0), Ret> {\n    return modulo();\n  }\n  template <class Ret = const ZZ>\n  static constexpr auto mod() -> std::enable_if_t<(param > 0), Ret> {\n    return param;\n  }\n\n public:\n  template <class Arg = ZZ>\n  static void set_modulo(const std::enable_if_t<(param <= 0), Arg> mod) {\n    modulo() = mod;\n  }\n  long long v;\n\n  constexpr mint() : v(0) {}\n\n  constexpr mint(long long v)\n      : v(fast ? (v)\n               : (v < 0 ? (v % mod() + mod()) % mod()\n                        : (v >= mod() ? v % mod() : v))) {}\n  constexpr long long get_mod() { return mod(); }\n  long long get_val() { return v; }\n  void take_mod() { v %= mod(); }\n};\ntemplate <long long param, bool fast>\nostream& operator<<(ostream& os, mint<param, fast>& x) {\n  return os << (x.v % x.get_mod() + x.get_mod()) % x.get_mod();\n}\n\ntemplate <long long param, bool fast, bool fast2>\nbool operator==(mint<param, fast>& a, mint<param, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast>& operator+=(mint<param, fast>& a, mint<param, fast2> b) {\n  return a = a.v + b.v;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, mint<param> b) {\n  return a = a.v - b.v;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, mint<param> b) {\n  return a = a.v * b.v;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, mint<param> b) {\n  return a = a.v * inv_mod(b.v, a.get_mod());\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast> operator+(mint<param, fast> a, mint<param, fast2> b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, mint<param> b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, mint<param> b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, mint<param> b) {\n  return a /= b;\n}\ntemplate <long long param, bool fast>\nmint<param, fast>& operator+=(mint<param, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, long long b) {\n  return a = a.v * inv_mod(b, a.get_mod());\n}\ntemplate <long long param, bool fast>\nmint<param, fast> operator+(mint<param> a, long long b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, long long b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, long long b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, long long b) {\n  return a /= b;\n}\n\nvoid special(int N) {\n  vector<mint<>> vals = {mint<>(1), mint<>(1)};\n  for (int i = 0; i < N; i++) {\n    int sz = vals.size();\n    vals.push_back(vals[sz - 1] + vals[sz - 2]);\n  }\n  mint<> ans = vals[N] + vals[N - 2];\n  cout << ans << endl;\n}\n\nint con(string& S, char t) {\n  int ans = 1000000;\n  int cur = 0;\n  for (auto c : S) {\n    if (c == t)\n      cur++;\n    else {\n      if (cur != 0) ans = min(ans, cur);\n      cur = 0;\n    }\n  }\n  // chmin(ans, cur);\n  return ans;\n}\n\nmint<> calcDP(int N, int conB, int conR) {\n  vector<mint<>> dpR(N + 2, mint<>(0));\n  vector<mint<>> dpB(N + 2, mint<>(0));\n  vector<mint<>> sumR(N + 2, mint<>(0));\n  vector<mint<>> sumB(N + 2, mint<>(0));\n  dpR[1] = 1;\n  sumR[1] = 1;\n  for (int i = 2; i <= N + 1; i++) {\n    if (i % 2 == 1) {\n      dpR[i] = sumB[i - 1] - sumB[max(0, i - conR - 1)];\n      // if (i <= conB) dpR[i] += 1;\n\n    } else\n      dpB[i] = sumR[i - 1] - sumR[max(0, i - conB - 1)];\n    sumB[i] = sumB[i - 1] + dpB[i];\n    sumR[i] = sumR[i - 1] + dpR[i];\n  }\n  mint<> ans = 0;\n  for (int i = 0; i < min(N, conB + 1); i++) {\n    ans += sumR[N - i] - sumR[max(0, N - conB - 1)];\n  }\n  return ans;\n}\n\nvoid solve(long long N, long long M, std::string S) {\n  int cntB = 0;\n\n  int conR = con(S, 'R');\n  int conB = con(S, 'B');\n  for (int i = 0; i < M; i++) {\n    if (S[i] == 'B') cntB++;\n  }\n  if (cntB == M || cntB == 0) {\n    special(N);\n    return;\n  }\n  if (N % 2 == 1) {\n    cout << 0 << endl;\n    return;\n  }\n  if (S[0] == 'R') swap(conR, conB);\n  conR = 1;\n  if (conB % 2 == 0) conB++;\n  // if (conR % 2 == 0) conR--;\n\n  mint<> ans = calcDP(N, conB, conR);\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long M;\n  scanf(\"%lld\", &M);\n  std::string S;\n  std::cin >> S;\n  solve(N, M, S);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-03 17:07:09\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=200010,mod=1000000007;\nint n,m,flag,l,Flag;\ni64 f[N],F[N],ans;\nchar s[N];\nint main()\n{\n\tn=read(); m=read();\n\tscanf(\"%s\",s+1);\n\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\tif(!flag)\n\t{\n\t\tf[1]=1; f[2]=2;\n\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t\treturn 0;\n\t}\n\tl=n-1;\n\tfor(int i=1,j;i<=m;)\n\t\tif(s[i]==s[1])\n\t\t{\n\t\t\tj=i;\n\t\t\twhile(s[j]==s[1]) j++;\n\t\t\tif(j>n) break;\n\t\t\tif(((j-i)&1)||(!Flag)) l=std::min(l,(j-i)+(!((j-i)&1)));\n\t\t\ti=j+1; Flag=1;\n\t\t}\n\t\telse i++;\n\tif(n&1){ printf(\"0\\n\"); return 0; }\n\tn/=2; l=(l+1)/2;\n//\tprintf(\"%d %d\\n\",int(n),int(l));\n\tf[0]=F[0]=1;\n\tfr(i,1,n)\n\t{\n\t\tf[i]=(F[i-1]+mod-(i-l-1>=0?F[i-l-1]:0))%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t}\n\tans=f[n];\n\tfr(i,1,l) ans=(ans+f[n-i]*(2*i-1))%mod;\n\tprintf(\"%d\\n\",int(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,m;\nchar str[200050];\nconst int mod = 1000000007;\nint dp[200050];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str + 1);\n\tbool c1 = 0,c2 = 0;\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tc1 |= str[i] == 'R';\n\t\tc2 |= str[i] == 'B';\n\t}\n\tint p = 1;\n\tint lim;\n\tif(c1 && c2)\n\t{\n\t\tif(n & 1)\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(;str[p + 1] == str[1]; ++ p);\n\t\tlim = p + (p % 2 == 0);\n\t\tint len = 0;\n\t\tfor(int i = p + 1;i <= m; ++ i)\n\t\t{\n\t\t\tif(str[i] != str[1]) lim = min(lim,len % 2 ? len : 10000000),len = 0;\n\t\t\telse len ++;\n\t\t}\n\t\tlim ++;\n\t\tlim /= 2;\n\t\tlim = min(lim,n / 2);\n\t\tint pre = 1;\n\t\tint cur = 0;\n\t\tdp[0] = 1;\n\t\tlong long ans = 0;\n\t\tfor(int i = 0;i <= n / 2; ++ i)\n\t\t{\n\t\t\tif(i)\n\t\t\t{\n\t\t\t\twhile(i - cur > lim) pre -= dp[cur],pre = (pre + mod) % mod,cur ++;\n\t\t\t\tdp[i] = pre;\n\t\t\t\tpre += dp[i];\n\t\t\t\tpre %= mod;\n\t\t\t}\n\t\t\tif(n - i * 2 > 0 && (n - i * 2) / 2 <= lim)\n\t\t\t\tans = ans + 1LL * (n - i * 2) * dp[i] % mod,ans %= mod;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse\n\t{\n\t\tint pre = 0;\n\t\tint cur = 0;\n\t\tdp[0] = 1;\n\t\tlong long ans = 0;\n\t\tfor(int i = 0;i <= n; ++ i)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\tdp[i] = pre;\n\t\t\t\tpre += dp[i - 1];\n\t\t\t\tpre %= mod;\n\t\t\t}\n\t\t\tif(n - i > 1)\n\t\t\t\tans = ans + 1LL * (n - i) * dp[i] % mod,ans %= mod;\n\t\t}\n\t\tprintf(\"%lld\\n\",(ans + 1) % mod);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, m;\nlong long Mod = 1000000007, InvF[401000],F[401000], D[401000], S[401000];\nchar p[301000];\nlong long Pow(long long a, long long b) {\n\tlong long r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = r * a%Mod;\n\t\ta = a * a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nlong long Comb(int n, int k) {\n\treturn F[n] * InvF[k] % Mod*InvF[n - k] % Mod;\n}\nlong long Get(int a, int b) {\n\tif (b < 0 || a <= 0)return 0;\n\treturn Comb(a + b - 1, b);\n}\nlong long DD[101000][2][2];\nint main() {\n\tint i, j;\n\tF[0] = 1;\n\tfor (i = 1; i <= 400000; i++)F[i] = F[i - 1] * i%Mod;\n\tInvF[400000] = Pow(F[400000], Mod - 2);\n\tfor (i = 400000; i >= 1; i--)InvF[i - 1] = InvF[i] * i%Mod;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", p);\n\tint ck = 0;\n\tfor (i = 0; p[i]; i++) {\n\t\tif (p[i] == 'R')ck |= 1;\n\t\tif (p[i] == 'B')ck |= 2;\n\t}\n\tif (ck!=3) {\n\t\tDD[1][0][0] = 1;\n\t\tDD[1][1][1] = 1;\n\t\tfor (i = 2; i <= n; i++) {\n\t\t\tDD[i][0][0] = (DD[i - 1][0][0] + DD[i - 1][0][1]) % Mod;\n\t\t\tDD[i][0][1] = (DD[i - 1][0][0]) % Mod;\n\t\t\tDD[i][1][0] = (DD[i - 1][1][0] + DD[i - 1][1][1]) % Mod;\n\t\t\tDD[i][1][1] = (DD[i - 1][1][0]) % Mod;\n\t\t}\n\t\tprintf(\"%lld\\n\", (DD[n][0][0] + DD[n][0][1] + DD[n][1][0]) % Mod);\n\t\treturn 0;\n\t}\n\tif (n % 2 == 1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tif (p[0] == 'B') {\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tp[i] = 'R' + 'B' - p[i];\n\t\t}\n\t}\n\tint c = 0, Mn = 1e9;\n\tck = 0;\n\tfor (i = 0; i < m; i++) {\n\t\tif (p[i] == 'R') {\n\t\t\tc++;\n\t\t\tif (i == m - 1 || p[i + 1] == 'B') {\n\t\t\t\tif (!ck) {\n\t\t\t\t\tif (c % 2 == 0)Mn = min(Mn, c + 1);\n\t\t\t\t\telse Mn = min(Mn, c);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (c % 2 == 1)Mn = min(Mn, c);\n\t\t\t\t}\n\t\t\t\tck = 1;\n\t\t\t}\n\t\t}\n\t\telse c = 0;\n\t}\n\n\tint K = (Mn + 1) / 2;\n\tD[0] = 1;\n\tS[0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tlong long t = S[i - 1];\n\t\tif (i - K - 1 >= 0)t -= S[i - K - 1];\n\t\tD[i] = (t + Mod) % Mod;\n\t\tS[i] = (S[i - 1] + D[i]) % Mod;\n\t}\n\tlong long res = D[n / 2];\n\tfor (i = 1; i <= Mn && i<=n; i+=2) {\n\t\tres = (res + 1ll*i*D[(n - i - 1) / 2])%Mod;\n\t}\n\tprintf(\"%lld\\n\", res);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 200100\n#define M 1000000007\nusing namespace std;\n\nll n,m,mx,ans,dp[N],qz[N];\nchar str[N];\n\ninline void Add(ll &u,ll v){u=(u+v)%M;}\nint main()\n{\n    ll i,j,t;\n    cin>>n>>m;\n    scanf(\"%s\",str+1);\n    for(i=1;i<=m;i++) if(str[i]!=str[1]) break;\n    mx=i-1;\n    if(mx==m)\n    {\n\tdp[0]=qz[0]=ans=1;\n\tfor(i=0;i<=n;i++)\n\t{\n\t    if(i>=2) dp[i]=qz[i-2];\n\t    qz[i]=(qz[i-1]+dp[i])%M;\n\t    if(n-i>=2) Add(ans,dp[i]*(n-i)%M);\n\t}\n\tcout<<ans;\n\treturn 0;\n    }\n    if(n&1)\n    {\n\tputs(\"0\");\n\treturn 0;\n    }\n    if(mx%2==0) mx++;\n    for(t=0;i<=m;i++)\n    {\n\tif(str[i]==str[1]) t++;\n\telse\n\t{\n\t    if(t&1) mx=min(mx,t);\n\t    t=0;\n\t}\n    }\n    n/=2,mx=(mx+1)/2;\n    dp[0]=qz[0]=1;\n    for(i=1;i<=n;i++)\n    {\n\tdp[i]=(M+qz[i-1]-(i-mx-1>=0?qz[i-mx-1]:0))%M;\n\tqz[i]=(qz[i-1]+dp[i])%M;\n\tif(n-i<=mx) Add(ans,(n-i)*dp[i]*2%M);\n    }\n    cout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // clang-format off\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define in2(s,t)     rep(i,sz(s)){in(s[i] , t[i]);}\n#define in3(s,t,u)   rep(i,sz(s)){in(s[i] , t[i] , u[i]);}\n#define in4(s,t,u,v) rep(i,sz(s)){in(s[i] , t[i] , u[i] , v[i]);}\n#ifdef ONLINE_JUDGE\n  #define rep(i,N) for(int i = 0; i < (int)(N); i++)\n  #define repr(i,N) for(int i = (int)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(int i = 1; i <= (int)(N) ; i++)\n  #define repr1(i,N) for(int i = (N) ; (int)(i) > 0 ; i--)\n#else\n  #define rep(i,N) for(long long i = 0; i < (long long)(N); i++)\n  #define repr(i,N) for(long long i = (long long)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(long long i = 1; i <= (long long)(N) ; i++)\n  #define repr1(i,N) for(long long i = (N) ; (long long)(i) > 0 ; i--)\n#endif\nusing namespace std; void solve();\nusing ll = long long; template<class T = ll> using V = vector<T>;\nusing vi = V<int>; using vl = V<>; using vvi = V< V<int> >;\nusing vd = V<double>; using vs = V<string>; using vvl = V< V<> >;\nconstexpr int inf = 1001001001; constexpr ll infLL = (1LL << 61) - 1;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T,typename U>ll ceil(T a,U b){return (a + b - 1) / b;}\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); for(int i=0;i<s;i++) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);} while(0)\n  #define trcc(v) do { cerr << \"name : \" << #v << \"\\n\"; int cnt = 0; each(x , v){cerr << (cnt++) << \" : \"; trc(x); } } while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  #define trcc(...)\n  int main(){solve();}\n#endif\n\nconstexpr ll TEN(int n){ll ret=1,x=10;while(n){if(n&1)ret*=x;x*=x;n>>=1;}return ret;}\n#define mem(a, val) memset(a, val, sizeof(a))\n\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\nusing P = pair<ll,ll>; using vp = V<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n// clang-format on\n////////////////////////////////////////////////////\n\n\nvector<pair<char,int>> RunLengthEncoding(string& S){\n  vector<pair<char,int>> ret;\n  char c = -1;\n  int n = 0;\n  for(char x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate<typename T>\nvector<pair<T,int>> RunLengthEncoding(vector<T>& S){\n  vector<pair<T,int>> ret;\n  T c = -1;\n  int n = 0;\n  for(T& x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\nusing mint = modint;\n\nnamespace FastFourierTransform {\n  using real = double;\n\n  struct C {\n    real x, y;\n\n    C() : x(0), y(0) {}\n\n    C(real x, real y) : x(x), y(y) {}\n\n    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }\n\n    inline C conj() const { return C(x, -y); }\n  };\n\n  const real PI = acosl(-1);\n  int base = 1;\n  vector< C > rts = { {0, 0},\n                     {1, 0} };\n  vector< int > rev = {0, 1};\n\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    while(base < nbase) {\n      real angle = PI * 2.0 / (1 << (base + 1));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        real angle_i = angle * (2 * i + 1 - (1 << base));\n        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n      }\n      ++base;\n    }\n  }\n\n  void fft(vector< C > &a, int n) {\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          C z = a[i + j + k] * rts[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n  }\n\n  vector< int64_t > multiply(const vector< int > &a, const vector< int > &b) {\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = C(x, y);\n    }\n    fft(fa, sz);\n    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n      fa[i] = z;\n    }\n    for(int i = 0; i < (sz >> 1); i++) {\n      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n      fa[i] = A0 + A1 * s;\n    }\n    fft(fa, sz >> 1);\n    vector< int64_t > ret(need);\n    for(int i = 0; i < need; i++) {\n      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n    }\n    return ret;\n  }\n};\n\ntemplate< typename T >\nstruct ArbitraryModConvolution {\n  using real = FastFourierTransform::real;\n  using C = FastFourierTransform::C;\n\n  ArbitraryModConvolution() = default;\n\n  vector< T > multiply(const vector< T > &a, const vector< T > &b, int need = -1) {\n    if(need == -1) need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while((1 << nbase) < need) nbase++;\n    FastFourierTransform::ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < (int)a.size(); i++) {\n      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);\n    }\n    fft(fa, sz);\n    vector< C > fb(sz);\n    if(a == b) {\n      fb = fa;\n    } else {\n      for(int i = 0; i < (int)b.size(); i++) {\n        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);\n      }\n      fft(fb, sz);\n    }\n    real ratio = 0.25 / sz;\n    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C a1 = (fa[i] + fa[j].conj());\n      C a2 = (fa[i] - fa[j].conj()) * r2;\n      C b1 = (fb[i] + fb[j].conj()) * r3;\n      C b2 = (fb[i] - fb[j].conj()) * r4;\n      if(i != j) {\n        C c1 = (fa[j] + fa[i].conj());\n        C c2 = (fa[j] - fa[i].conj()) * r2;\n        C d1 = (fb[j] + fb[i].conj()) * r3;\n        C d2 = (fb[j] - fb[i].conj()) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector< T > ret(need);\n    for(int i = 0; i < need; i++) {\n      int64_t aa = llround(fa[i].x);\n      int64_t bb = llround(fb[i].x);\n      int64_t cc = llround(fa[i].y);\n      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;\n      ret[i] = aa + (bb << 15) + (cc << 30);\n    }\n    return ret;\n  }\n};\n\ntemplate< int mod >\nstruct NumberTheoreticTransform {\n\n  int base, max_base, root;\n  vector< int > rev, rts;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while(tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while(n > 0) {\n      if(n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) {\n    return mod_pow(x, mod - 2);\n  }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long) mod;\n  }\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while(base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n\n  void ntt(vector< int > &a) {\n    const int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n\n  vector< int > multiply(vector< int > a, vector< int > b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for(int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n\n  vector<modint> multiply_for_fps(const vector<modint> &a,const vector<modint> &b){\n    vector<int> A(a.size()) , B(b.size());\n    for(int i = 0;i < (int)a.size(); i++) A[i] = a[i].x;\n    for(int i = 0;i < (int)b.size(); i++) B[i] = b[i].x;\n    auto C = multiply( A , B );\n    vector<modint> ret(C.size());\n    for(int i = 0; i < (int)C.size() ;i++) ret[i].x = C[i];\n    return ret;\n  }\n};\n\n\ntemplate< typename T >\nstruct FormalPowerSeries : vector< T > {\n  using vector< T >::vector;\n  using P = FormalPowerSeries;\n\n  using MULT = function< P(P, P) >;\n\n  static MULT &get_mult() {\n    static MULT mult = nullptr;\n    return mult;\n  }\n\n  static void set_fft(MULT f) {\n    get_mult() = f;\n  }\n\n  void shrink() {\n    while(this->size() && this->back() == T(0)) this->pop_back();\n  }\n\n  P operator+(const P &r) const { return P(*this) += r; }\n\n  P operator+(const T &v) const { return P(*this) += v; }\n\n  P operator-(const P &r) const { return P(*this) -= r; }\n\n  P operator-(const T &v) const { return P(*this) -= v; }\n\n  P operator*(const P &r) const { return P(*this) *= r; }\n\n  P operator*(const T &v) const { return P(*this) *= v; }\n\n  P operator/(const P &r) const { return P(*this) /= r; }\n\n  P operator%(const P &r) const { return P(*this) %= r; }\n\n  P &operator+=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] += r[i];\n    return *this;\n  }\n\n  P &operator+=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] += r;\n    return *this;\n  }\n\n  P &operator-=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] -= r[i];\n    shrink();\n    return *this;\n  }\n\n  P &operator-=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] -= r;\n    shrink();\n    return *this;\n  }\n\n  P &operator*=(const T &v) {\n    const int n = (int) this->size();\n    for(int k = 0; k < n; k++) (*this)[k] *= v;\n    return *this;\n  }\n\n  P &operator*=(const P &r) {\n    if(this->empty() || r.empty()) {\n      this->clear();\n      return *this;\n    }\n    assert(get_mult() != nullptr);\n    return *this = get_mult()(*this, r);\n  }\n\n  P &operator%=(const P &r) {\n    return *this -= *this / r * r;\n  }\n\n  P operator-() const {\n    P ret(this->size());\n    for(int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];\n    return ret;\n  }\n\n  P &operator/=(const P &r) {\n    if(this->size() < r.size()) {\n      this->clear();\n      return *this;\n    }\n    int n = this->size() - r.size() + 1;\n    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);\n  }\n\n  P pre(int sz) const {\n    return P(begin(*this), begin(*this) + min((int) this->size(), sz));\n  }\n\n  P operator>>(int sz) const {\n    if(this->size() <= sz) return {};\n    P ret(*this);\n    ret.erase(ret.begin(), ret.begin() + sz);\n    return ret;\n  }\n\n  P operator<<(int sz) const {\n    P ret(*this);\n    ret.insert(ret.begin(), sz, T(0));\n    return ret;\n  }\n\n  P rev(int deg = -1) const {\n    P ret(*this);\n    if(deg != -1) ret.resize(deg, T(0));\n    reverse(begin(ret), end(ret));\n    return ret;\n  }\n\n  P diff() const {\n    const int n = (int) this->size();\n    P ret(max(0, n - 1));\n    for(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);\n    return ret;\n  }\n\n  P integral() const {\n    const int n = (int) this->size();\n    P ret(n + 1);\n    ret[0] = T(0);\n    for(int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);\n    return ret;\n  }\n\n  // F(0) must not be 0\n  P inv(int deg = -1) const {\n    assert(((*this)[0]) != T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1) / (*this)[0]});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 1\n  P log(int deg = -1) const {\n    assert((*this)[0] == 1);\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();\n  }\n\n  P sqrt(int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n\n    if((*this)[0] == T(0)) {\n      for(int i = 1; i < n; i++) {\n        if((*this)[i] != T(0)) {\n          if(i & 1) return {};\n          if(deg - i / 2 <= 0) break;\n          auto ret = (*this >> i).sqrt(deg - i / 2) << (i / 2);\n          if(ret.size() < deg) ret.resize(deg, T(0));\n          return ret;\n        }\n      }\n      return P(deg, 0);\n    }\n\n    P ret({T(1)});\n    T inv2 = T(1) / T(2);\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 0\n  P exp(int deg = -1) const {\n    assert((*this)[0] == T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1)});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  P pow(int64_t k, int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    for(int i = 0; i < n; i++) {\n      if((*this)[i] != T(0)) {\n        T rev = T(1) / (*this)[i];\n        P C(*this * rev);\n        P D(n - i);\n        for(int j = i; j < n; j++) D[j - i] = C[j];\n        D = (D.log() * k).exp() * (*this)[i].pow(k);\n        P E(deg);\n        if(i * k > deg) return E;\n        auto S = i * k;\n        for(int j = 0; j + S < deg && j < D.size(); j++) E[j + S] = D[j];\n        return E;\n      }\n    }\n    return *this;\n  }\n\n  T eval(T x) const {\n    T r = 0, w = 1;\n    for(auto &v : *this) {\n      r += w * v;\n      w *= x;\n    }\n    return r;\n  }\n};\n\nusing FPS = FormalPowerSeries< modint >;\n\n// fにa * x^n + bを掛ける\nvoid mul_simple(FPS &f,modint a ,int n, modint b){\n  for(int i = (int)f.size() - 1 ; i >= 0 ; i--){\n    f[i] *= b;\n    if(i >= n) f[i] += f[i - n] * a; \n  }\n}\n\n// fからa * x^n + bを割る\nvoid div_simple(FPS &f,modint a,int n,modint b){\n  for(int i = 0 ; i < (int)f.size() ; i++){\n    f[i] /= b;\n    if(i + n < (int)f.size() ) f[n + i] -= f[i] * a; \n  }\n}\n\n// f / gをdeg(f)次まで求める\nFPS div_(FPS &f , FPS g){\n  int n = f.size();\n  return (f * g.inv(n)).pre(n);\n}\n\n\n// solve関数内で\n//\n// FPS::set_fft(mul);\n//\n// とすること。\n\n/**\nNumberTheoreticTransform<MOD> ntt;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret =ntt.multiply_for_fps(a , b);\n  return FPS::P(ret.begin(), ret.end());\n};\n/*///\nArbitraryModConvolution< modint > fft;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret = fft.multiply(a, b);\n  return FPS::P(ret.begin(), ret.end());\n};\n//*/\n\n// 下記のリンクを実装(kitamasa法のモンゴメリ乗算を使わない版)\n// http://q.c.titech.ac.jp/docs/progs/polynomial_division.html\n// k項間漸化式のa_Nを求める O(k log k log N)\n// N ... 求めたい項　(0-indexed)\n// Q ... 漸化式 (1 - \\sum_i c_i x^i)の形\n// a ... 初期解 (a_0 , a_1 , ... , a_k-1)\n// x^N を fでわった剰余を求め、aと内積を取る\nmodint kitamasa(ll N, FPS &Q, FPS &a){\n  int k = Q.size() - 1;\n  assert( (int)a.size() == k );\n  FPS P = a * Q; P.resize(k);\n  while(N){\n    auto Q2 = Q;\n    for(int i = 1; i < (int)Q2.size(); i += 2) Q2[i].x = MOD - Q2[i].x;\n    auto S = P * Q2;\n    auto T = Q * Q2;\n    if(N & 1){\n      for(int i = 1 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    else{\n      for(int i = 0 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    N >>= 1;\n  }\n  return P[0];\n}\n\nvoid solve(){\n  ini(N , M);\n  ins(S);\n  auto run = RunLengthEncoding(S);\n  if(run.size() == 1){\n    // DP\n    V<mint> dp(N),ep(N),fp(N),gp(N);\n    // [0]がR\n    // -> [1],[-1]はどちらでもよい\n    dp[0] = gp[0] = 1;\n    rep1(i , N - 1){\n      dp[i] = dp[i - 1] + ep[i - 1];\n      ep[i] = dp[i - 1];\n      fp[i] = fp[i - 1] + gp[i - 1];\n      gp[i] = fp[i - 1];\n    }\n    out(dp[N-1] + ep[N-1] + fp[N-1]);\n    return;\n  }\n  if(N % 2 == 1){\n    out(0);\n    return;\n  }\n\n  FPS::set_fft(mul);\n  // rの最小値\n  int r = N-1 , b = N-1;\n  auto trans = [](int n){\n    return (n % 2 == 1) ? n : (n + 1);\n  };\n  rep(i , sz(run)){\n    if(i==0)continue;\n    auto p = run[i];\n    if(p.first == 'R' && p.second % 2 == 1) amin(r , trans(p.second));\n    if(p.first == 'B' && p.second % 2 == 1) amin(b , trans(p.second));\n  }\n\n  // 初手の制約\n  amin( (run[0].first == 'R' ? r : b) , trans(run[0].second) );\n  // 初手とは異なる方が1である必要あり\n  (run[0].first == 'R' ? b : r) = 1;\n  trc(r , b);\n  if(r < b) swap(r , b);  \n  auto nyaan = [&](ll n,int flg = false) -> FPS{\n    FPS ret(n + 1);\n    for(int i = 1 ; i <= n ; i += 2) ret[i] = (flg ? i + 1 : 1);\n    return ret;\n  };\n  FPS f({0 , 1});\n  f *= nyaan(r);\n  f *= -1; f[0] = 1;\n  if((int)f.size() <= N) f.resize(N * 2 + 100);\n  trc(f);\n  f = f.inv();\n  trc(f);\n  // やる\n  mint ans = 0;\n  for(int i = 2 ; i <= r + 1 ; i += 2){\n    ans += f[N - i] * i;\n  }\n  out(ans);\n  \n  \n  /*\n  //trc(f);\n  // 倍数包除\n  for(int i = 2 ; i <= N ; i++){\n    // i番目は？\n    //引こう！\n    for(int j = 2 ; i * j <= N ; j++){\n      f[i * j] -= f[i];\n    }\n  }\n  trc(f);\n  */\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\nll dp[200010] = {},mod = 1000000007;\nstring s;\nvector<pair<char,int>> v;\nint main(){\n\tll i,j,n,m;\n\tcin >> n >> m >> s;\n\tif(s[0]=='B'){\n\t\tfor(i=0;i<m;i++){\n\t\t\tif(s[i]=='R') s[i] = 'B';\n\t\t\telse s[i] = 'R';\n\t\t}\n\t}\n\tfor(i=0;i<m;i++){\n\t\tif(i==0 || v.back().first!=s[i]){\n\t\t\tv.push_back({s[i],1});\n\t\t}else{\n\t\t\tv.back().second++;\n\t\t}\n\t}\n\tif(v.size()==1){\n\t\tcout << n + 1 << endl;\n\t\treturn 0;\n\t}\n\tif(n&1){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint mn = -1;\n\tfor(i=0;i<v.size();i++){\n\t\tif(i==0){\n\t\t\tmn = v[i].second + 1 - (v[i].second&1);\n\t\t}\n\t\tif(v[i].first=='R' && (v[i].second&1)){\n\t\t\tmn = min(mn,v[i].second);\n\t\t}\n\t}\n\tmn++;\n\tdp[0] = 1;dp[2] = 1;\n\tll sum = 2;\n\tfor(i=4;i<=n;i+=2){\n\t\t(dp[i] += sum) %= mod;\n\t\t(sum += dp[i]) %= mod;\n\t\tif(i>=mn) sum -= dp[i - mn];\n\t\tif(sum<0) sum += mod;\n\t}\n\tll ans = 0;\n\tfor(i=2;i<=mn;i++){\n\t\t(ans += i*dp[n - i]) %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : E.cpp\n * Author  : Kazune Takahashi\n * Created : 2/12/2020, 4:45:12 PM\n * Powered by Visual Studio Code\n */\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/multiprecision/cpp_int.hpp>\n// ----- using directives and manipulations -----\nusing namespace std;\nusing boost::rational;\nusing boost::multiprecision::cpp_int;\nusing ll = long long;\ntemplate <typename T>\nusing max_heap = priority_queue<T>;\ntemplate <typename T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\n// ----- constexpr for Mint and Combination -----\nconstexpr ll MOD{1000000007LL};\n// constexpr ll MOD{998244353LL}; // be careful\nconstexpr ll MAX_SIZE{3000010LL};\n// constexpr ll MAX_SIZE{30000010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{(x % MOD + MOD) % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator++() { return *this += 1; }\n  Mint &operator++(int)\n  {\n    Mint tmp{*this};\n    ++*this;\n    return tmp;\n  }\n  Mint &operator--() { return *this -= 1; }\n  Mint &operator--(int)\n  {\n    Mint tmp{*this};\n    --*this;\n    return tmp;\n  }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\ntemplate <typename T>\nT gcd(T x, T y) { return y ? gcd(y, x % y) : x; }\ntemplate <typename T>\nT lcm(T x, T y) { return x / gcd(x, y) * y; }\n// ----- for C++17 -----\ntemplate <typename T>\nint popcount(T x) // C++20\n{\n  int ans{0};\n  while (x != 0)\n  {\n    ans += x & 1;\n    x >>= 1;\n  }\n  return ans;\n}\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\n// constexpr ll infty{1000000000000000LL}; // or\n// constexpr int infty{1'000'000'010};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n// ----- main() -----\n\nclass Solve\n{\n  bool all_red;\n  int N, M;\n  string S;\n  int X;\n\npublic:\n  Solve(int N, int M, string S) : all_red{false}, N{N}, M{M}, S{S}, X{max_length()} {}\n\n  void flush()\n  {\n#if DEBUG == 1\n    cerr << \"X = \" << X << endl;\n#endif\n    if (all_red)\n    {\n      cout << solve_all_red() << endl;\n    }\n    else\n    {\n      cout << solve_normal() << endl;\n    }\n  };\n\nprivate:\n  mint solve_all_red()\n  {\n    vector<vector<mint>> dp(N + 1, vector<mint>(2, 0));\n    dp[0][0] = 1;\n    for (auto i = 1; i <= N; ++i)\n    {\n      dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n      dp[i][1] = dp[i - 1][0];\n    }\n    return 3 * dp[N - 2][0] + dp[N - 2][1];\n  }\n\n  mint solve_normal()\n  {\n    if (N % 2 == 1)\n    {\n      return 0;\n    }\n    int N{Solve::N / 2}, X{Solve::X / 2};\n    vector<mint> DP(N + 1, 0);\n    DP[0] = 1;\n    for (auto i = 1; i <= N; ++i)\n    {\n      DP[i] = 2 * DP[i - 1];\n      if (i - 1 - X == 0)\n      {\n        DP[i] -= 1;\n      }\n      else if (i - 1 - X > 0)\n      {\n        DP[i] -= DP[i - 2 - X];\n      }\n    }\n#if DEBUG == 1\n    for (auto i = 0; i <= N; ++i)\n    {\n      cerr << \"DP[\" << i << \"] = \" << DP[i] << endl;\n    }\n#endif\n    mint ans{0};\n    for (auto K = 0; K <= X; ++K)\n    {\n      if (N - K - 2 >= 0)\n      {\n        ans += (K + 1) * DP[N - K - 2];\n      }\n    }\n    return ans * 2;\n  }\n\n  int max_length()\n  {\n    if (S[0] == 'B')\n    {\n      for (auto &x : S)\n      {\n        if (x == 'R')\n        {\n          x = 'B';\n        }\n        else\n        {\n          x = 'R';\n        }\n      }\n    }\n    vector<int> V;\n    int now{0};\n    for (auto i = 0; i < M; ++i)\n    {\n      if (S[i] == 'R')\n      {\n        ++now;\n      }\n      else if (now > 0)\n      {\n        V.push_back(now);\n        now = 0;\n      }\n    }\n    if (V.empty())\n    {\n      all_red = true;\n      return N;\n    }\n    if (V[0] % 2 == 0)\n    {\n      ++V[0];\n    }\n    for (auto it = V.begin() + 1; it != V.end(); ++it)\n    {\n      if (*it % 2 == 0)\n      {\n        *it = N;\n      }\n    }\n    return *min_element(V.begin(), V.end());\n  }\n};\n\nint main()\n{\n  int N, M;\n  string S;\n  cin >> N >> M >> S;\n  Solve solve(N, M, S);\n  solve.flush();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll dp[202020][2][2];\nll mo=1000000007;\n\nll dp2[202020];\nll dps[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\tif(S[0]=='B') {\n\t\tFORR(c,S) c='R'+'B'-c;\n\t}\n\tif(count(ALL(S),'B')==0) {\n\t\tdp[0][0][0]=dp[0][1][1]=1;\n\t\tfor(i=1;i<N;i++) {\n\t\t\t(dp[i][0][0]=dp[i-1][0][0]+dp[i-1][0][1])%=mo;\n\t\t\t(dp[i][0][1]=dp[i-1][0][0])%=mo;\n\t\t\t(dp[i][1][0]=dp[i-1][1][0]+dp[i-1][1][1])%=mo;\n\t\t\t(dp[i][1][1]=dp[i-1][1][0])%=mo;\n\t\t}\n\t\tcout<<(dp[N-1][0][0]+dp[N-1][0][1]+dp[N-1][1][0])%mo<<endl;\n\t\treturn;\n\t}\n\t\n\tint L=0;\n\twhile(S[L]=='R') L++;\n\t\n\tif(L%2==0) L++;\n\t\n\tdp2[0]=dps[0]=1;\n\tfor(i=2;i<=N;i+=2) {\n\t\tdp2[i]=dps[i-2];\n\t\tif(i-(L+1)>0) dp2[i]+=mo-dps[i-(L+1)-1];\n\t\tdps[i]=(dps[i-2]+dp2[i])%mo;\n\t\t//cout<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=min(L,N-1);i+=2) {\n\t\t//cout<<i<<\" \"<<(i+1)<<\"*\"<<dp2[N-(i+1)]<<endl;\n\t\t(ret+=(i+1)*dp2[N-(i+1)])%=mo;\n\t}\n\tcout<<ret%mo<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline tuple<int, int, int> extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nunsigned ModInt::MOD = 1000000007;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\n\n\nconst int limit = 200010;\nmint dp[limit];\nmint csum[limit];\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\n\tint cmin = n, cons = 0;\n\n\trep(i, m){\n\t\tif(s[i] == s[0]){\n\t\t\tcons++;\n\t\t} else {\n\t\t\tchmin(cmin, cons);\n\t\t\tcons = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trep(i, m){\n\t\tif(s[i] == s[0]){\n\t\t\tcons++;\n\t\t} else {\n\t\t\tif(cons % 2 == 1) chmin(cmin, cons);\n\t\t\tcons = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(cmin % 2 == 0) cmin++;\n\tdp[1] = csum[1] = ONE;\n\n\trep(i, 1, n){\n\t\tconst int pos = max(i - cmin - 1, 0);\n\t\tif((i + 1) % 2 == 1) dp[i + 1] =  csum[i] - csum[pos];\n\t\tcsum[i + 1] = csum[i] + dp[i + 1];\n\t}\n\n\tmint ans = ZERO;\n\n\trep(i, max(0, n - cmin), n + 1){\n\t\tconst mint coef = mint(n - i + 1);\n\t\tans += coef * dp[i];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nchar str[200005];\nint arr[200005];\nlong long MOD=1000000007;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",str);\n\tfor(int i=0;i<m;i++)if(str[i]=='R')arr[i]=0;else arr[i]=1;\n\tbool all[2];all[0]=all[1]=1;\n\tfor(int i=0;i<m;i++)all[arr[i]^1]=0;\n\tif(all[0]||all[1]){\n\t\tlong long dp[2][n];memset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;dp[1][0]=0; //start with red (or blue if everything is blue)\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tlong long ans=(dp[0][n-1]+dp[1][n-1])%MOD;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=0;dp[1][0]=1; //start with blue\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tans+=dp[0][n-1];\n\t\tprintf(\"%lld\",ans);\n\t\treturn 0;\n\t}\n\tif(n%2!=0){printf(\"0\");return 0;}\n\tint cur=0;vector<int> v;\n\tfor(int i=0;i<n;i++){\n\t\tif(arr[i]==arr[0])cur++;\n\t\telse{if(cur!=0)v.push_back(cur);cur=0;}\n\t}\n\tif(cur!=0)v.push_back(cur);\n\tint mxl=(v[0]%2==0?v[0]+1:v[0]);\n\tfor(int i=1;i<(int)v.size();i++){\n\t\tif(v[i]%2==1)mxl=min(mxl,v[i]);\n\t}\n\t//comments: wlog red is first\n\tn/=2; mxl=mxl/2; //remove the ones that are different parity from blue\n\tlong long dp[100005],pref[100005];\n\tmemset(dp,0,sizeof(dp));memset(pref,0,sizeof(pref));\n\t//i segments on a line, first and last are blue, max mxl consecutive reds\n\t//blues may be consecutive because the reds in between were removed\n\tdp[1]=pref[1]=1;dp[2]=1;pref[2]=2;\n\tfor(int i=3;i<=n;i++){\n\t\tdp[i]=pref[i-1]-pref[max(0,i-(mxl+2))];\n\t\tdp[i]%=MOD;dp[i]+=MOD;dp[i]%=MOD;\n\t\tpref[i]=dp[i]+pref[i-1];\n\t\tpref[i]%=MOD;pref[i]+=MOD;pref[i]%=MOD;\n\t}\n\tlong long ans=0;\n\tfor(long long i=2;i<=min(n,mxl+2);i++){\n\t\tans+=2LL*(i-1LL)*dp[n-i+2];\n\t\tans%=MOD;\n\t}\n\tprintf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << (a) << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int MOD = 1e9 + 7;\n\nvi split(string s) {\n    vi ans;\n    char last = 'X'; \n    s += 'X';\n    int streak = 0;\n    for (char c : s) {\n        if (c != last) {\n            if (streak) ans.pb(streak);\n            streak = 0;\n            last = c;\n        }\n        streak++;\n    }\n    return ans;\n}\n\nvoid add(int &x, int y) {\n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n\nvi go(int n, int lim, int start) {\n    vi dp(n+1);\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = 0;\n        if (i >= start) add(dp[i], dp[i-start]);\n        if (i >= lim+1) add(dp[i], MOD-dp[i-lim-1]);\n        add(dp[i], dp[i-1]);\n    }\n    for (int i = n; i >= 1; i--) add(dp[i], MOD-dp[i-1]);\n    return dp;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    int n,l;\n    string s;\n    while (cin >> n >> l >> s) {\n        auto p = split(s);\n        if (si(p) == 1) {\n            //cout << \"TODO\" << endl;\n            auto dp = go(n,n,2);\n            int ans = 0;\n            for (int dif = 1; dif <= n; dif++) {\n                if (dif == 1 || dif == n-1) continue;\n                add(ans, ll(dif) * dp[n-dif] % MOD);\n            }\n            cout << (ans+1)%MOD << endl;\n        }\n        else {\n            if (n%2 == 1) {\n                assert(0);\n                cout << 0 << endl;\n                continue;\n            }\n            int lim = n+l;\n            forn(i,si(p)) if (i == 0 || (i%2 == 0 && p[i]%2 == 1)) {\n                lim = min(lim, p[i]/2+1);\n            }\n            n /= 2;\n            auto dp = go(n, lim, 1);\n            int ans = 0;\n            for (int dif = 1; dif <= lim; dif++)\n                add(ans, ll(dif) * dp[n-dif] % MOD);\n            cout << 2*ans%MOD << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int p = 1e9 + 7;\nint main() {\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n, m;\n  cin >> n >> m;\n  string str;\n  cin >> str;\n  if (str[0] == 'B') {\n    for (int i = 0; i < m; i++) {\n      if (str[i] == 'R') {\n        str[i] = 'B';\n      } else {\n        str[i] = 'R';\n      }\n    }\n  }\n  while (!str.empty() && str.back() == 'R') {\n    str.pop_back();\n  }\n  if (str.empty()) {\n    vector<int> dp(n);\n    int sum = 0;\n    for (int i = 1; i < n; i++) {\n      dp[i] = (i + 1 + sum) % p;\n      if (i) {\n        sum = (sum + dp[i - 1]) % p;\n      }\n    }\n    cout << (dp[n - 1] + 1) % p << endl;\n  } else {\n    int limit = INT_MAX, last = -1;\n    for (int i = 0; i < str.size(); i++) {\n      if (str[i] == 'B') {\n        int len = i - last - 1;\n        if (len & 1) {\n          limit = min(limit, len);\n        } else if (-1 == last) {\n          limit = min(limit, len + 1);\n        }\n        last = i;\n      }\n    }\n    vector<int> dp(n);\n    int sum_0 = 0, sum_1 = 0;\n    for (int i = 1; i < n; i++) {\n      if (i <= limit) {\n        dp[i] = i + 1;\n      }\n      if (i & 1) {\n        dp[i] = (dp[i] + sum_1) % p;\n        sum_0 = (sum_0 + dp[i - 1]) % p;\n      } else {\n        dp[i] = (dp[i] + sum_0) % p;\n        sum_1 = (sum_1 + dp[i - 1]) % p;\n      }\n      if (i > limit - 1) {\n        if (i - limit - 1 & 1) {\n          sum_1 = (sum_1 - dp[i - limit - 1] + p) % p;\n        } else {\n          sum_0 = (sum_0 - dp[i - limit - 1] + p) % p;\n        }\n      }\n    }\n    int answer = dp[n - 1];\n    if (n & 1) {\n      answer = (answer + 1) % p;\n    }\n    cout << answer << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n//#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int M = 1e9 + 7;\n\nvoid solve_fib(int n) {\n    vi f(n + 1);\n    f[0] = f[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        f[i] = (f[i - 1] + f[i - 2]) % M;\n    }\n    cout << (f[n] + f[n - 2]) % M;\n}\nconst int oo = 1e9 + 10;\n\nint kek(int cnt, bool & first, bool last = false) {\n    if (last) {\n        return oo;\n    }\n    if (first) {\n        first = false;\n        if (cnt & 1)\n            return cnt;\n        return oo;\n        return cnt + 1;\n    }\n    if (cnt & 1)\n        return cnt;\n    return oo;\n}\n\nvoid insum(int &a, int b) {\n    a = (a + b) % M;\n}\n\nvoid smain() {\n\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    m = s.size();\n    if (count(ALL(s), 'R') == 0 || count(ALL(s), 'B') == 0) {\n        solve_fib(n);\n        return;\n    }\n\n    vi a(m);\n    fori (i, m) {\n        a[i] = s[i] == 'R';\n    }\n\n    vi min_sz(2, oo);\n    int cur = -1;\n    int cnt = 0;\n    bool first = true;\n    for (auto c : a) {\n        if (c != cur) {\n            if (cur != -1) {\n                inmin(min_sz[cur], kek(cnt, first));\n            }\n            cur = c;\n            cnt = 1;\n        } else {\n            cnt++;\n        }\n    }\n    inmin(min_sz[cur], kek(cnt, first, true));\n    vvi f(2);\n    fori (z, 2) {\n        vvi dp(2, vi(n, 0));\n        vvi p(2, vi(n, 0));\n        p[!z][0] = dp[!z][0] = 1;\n        for (int i = 1; i < n; ++i) {\n            fori (zz, 2) {\n                int j = i - min_sz[zz];\n                if (j < i) {\n                    dp[zz][i] = (p[!zz][i - 1] - (j - 2 >= 0 ? p[!zz][j - 2] : 0) + M) % M;\n                }\n            }\n            fori (zz, 2) {\n                p[zz][i] = (dp[zz][i] + (i - 2 >= 0 ? p[zz][i - 2] : 0)) % M;\n            }\n        }\n        f[z] = dp[z];\n    }\n    int ans = 0;\n    fori (z, 2) {\n        for (int sz = 1; sz <= min_sz[z]; sz += 2) if (sz < n) {\n            insum(ans, (ll)f[!z][n - sz] * sz % M);\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=200005,mod=1e9+7;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nint n,m;\nchar s[N];\nint dp[N],pre[N];\nint main(){\n\tn=read(),m=read();\n\tcin>>(s+1);\n\tint p=1;\n\twhile (p<=m&&s[p]==s[1])\n\t\tp++;\n\tp--;\n\tif (p==m){\n\t\tFor(i,2,n)\n\t\t\tdp[i]=i;\n\t\tFor(i,1,n){\n\t\t\tAdd(dp[i],pre[i-2]);\n\t\t\tpre[i]=Add(pre[i-1]+dp[i]);\n\t\t}\n\t\tcout<<Add(dp[n]+1)<<endl;\n\t\treturn 0;\n\t}\n\tif (n&1)\n\t\treturn puts(\"0\"),0;\n\tint maxlen=p+(~p&1);\n\tint las=p+1;\n\tFor(i,p+2,m)\n\t\tif (s[i]!=s[1]){\n\t\t\tif ((i-las-1)&1)\n\t\t\t\tmaxlen=min(maxlen,i-las-1);\n\t\t\tlas=i;\n\t\t}\n\tn/=2,maxlen=(maxlen+1)/2;\n\tFor(i,1,maxlen)\n\t\tdp[i]=i*2;\n\tFor(i,1,n){\n\t\tAdd(dp[i],Del(pre[i-1]-pre[max(0,i-maxlen-1)]));\n\t\tpre[i]=Add(pre[i-1]+dp[i]);\n\t}\n\tcout<<dp[n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int N = 2e5;\nconst int P = 1e9+7;\nchar a[N+3];\nllong f[N+3],sf[N+3];\nint n,m; llong ans;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m); scanf(\"%s\",a+1);\n\tfor(int i=1; i<=m; i++) a[i] = a[i]=='R'?0:1;\n\tif(a[1]) {for(int i=1; i<=m; i++) a[i] ^= 1;}\n\tint lim = m,cur = 0;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tif(a[i]==a[1]) {cur++;}\n\t\telse\n\t\t{\n\t\t\tif(cur==i-1) {lim = cur&1?cur:cur+1;}\n\t\t\telse {if(cur&1) lim = min(lim,cur);}\n\t\t\tcur = 0;\n\t\t}\n\t}\n\tif(cur==m)\n\t{\n\t\tf[1] = 1ll; for(int i=2; i<=n; i++) f[i] = (f[i-1]+f[i-2])%P;\n\t\tans = (f[n]+f[n-1]+f[n-1])%P;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse\n\t{\n\t\tif(n&1) {puts(\"0\"); return 0;}\n//\t\tprintf(\"lim=%d\\n\",lim);\n\t\tlim>>=1,n>>=1; f[1] = sf[1] = 1ll;\n\t\tfor(int i=2; i<=n; i++)\n\t\t{\n\t\t\tf[i] = (sf[i-1]-sf[max(0,i-lim-2)]+P)%P; sf[i] = (sf[i-1]+f[i])%P;\n\t\t}\n\t\tfor(int i=1; i<=n; i++) if(n-i<=lim)\n\t\t{\n\t\t\tans = (ans+f[i]*(n-i+1ll))%P;\n\t\t}\n\t\tprintf(\"%lld\\n\",(ans+ans)%P);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\ninline void add(int &x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nll bin_pow(ll a, ll p) {\n    ll res = 1;\n    while (p) {\n        if (p & 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return res;\n}\n\nll rev(ll x) {\n    return bin_pow(x, MOD - 2);\n}\n\nll fact[N + 1], rfact[N + 1];\n\nvoid init() {\n    fact[0] = 1;\n    rep(i, 1, N + 1) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    rfact[N] = rev(fact[N]);\n    repb(i, N - 1, -1) {\n        rfact[i] = rfact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nll C(int n, int k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    return fact[n] * rfact[k] % MOD * rfact[n - k] % MOD;\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    init();\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    repb(i, m - 1, -1) {\n        s[i] = char('0' + (s[0] != s[i]));\n    }\n    int c1 = 0;\n    rep(i, 0, m) {\n        if (s[i] == '1') {\n            c1++;\n        }\n    }\n    if (c1 == 0) {\n        //assert(false);\n        int ans = 0;\n        for (int i = 0; i * 2 <= n; i++) {\n            //cout << i << \" \" << n - i << \" \" << C(n - i, i) << \"\\n\";\n            add(ans, C(n - i, i));\n            if (i >= 1) {\n                add(ans, C(n - 2 - (i - 1), (i - 1)));\n            }\n        }\n        cout << ans << \"\\n\";\n        return 0;\n    }\n  assert(false);\n    int k = (n % 2 == 1 ? n : n - 1), cur = 0;\n    rep(i, 0, m) {\n        if (s[i] == '0') {\n            cur++;\n        }\n        if (i == m - 1 || s[i + 1] == '1') {\n            if (cur % 2 == 1) {\n                setmin(k, cur);\n            } else if (cur > 0) {\n                setmin(k, cur * 2 - 3);\n            }\n            cur = 0;\n        }\n    }\n    //cout << k << endl;\n    int dp[n + 2], pref0[n + 2], pref1[n + 2];\n    fill(dp, dp + n + 1, 0);\n    fill(pref0, pref0 + n + 2, 0);\n    fill(pref1, pref1 + n + 2, 0);\n    dp[1] = 1;\n    pref1[1] = 1;\n    rep(i, 2, n + 2) {\n        int last_add = max(2 - i % 2, i - (k + 1));\n        if (i % 2 == 0) {\n            dp[i] = pref0[i - 2] - (last_add - 2 >= 0 ? pref0[last_add - 2] : 0);\n            if (dp[i] < 0) {\n                dp[i] += MOD;\n            }\n        } else {\n            dp[i] = pref1[i - 2] - (last_add - 2 >= 0 ? pref1[last_add - 2] : 0);\n        }\n        if (i % 2 == 0) {\n            pref0[i] = (pref0[i - 2] + dp[i]) % MOD;\n        } else {\n            pref1[i] = (pref1[i - 2] + dp[i]) % MOD;\n        }\n    }\n    /*rep(i, 1, n + 2) {\n        cout << dp[i] << \" \";\n    }\n    cout << \"\\n\";*/\n    if (n % 2 == 1) {\n        cout << 0 << \"\\n\";\n        return 0;\n    }\n    int ans = dp[n + 1];\n    //cout << k << endl;\n    for (int c = 1; c <= k; c += 2) {\n        //cout << c << \" \" << dp[n - c] << endl;\n        ans = (ans + 1LL * c * dp[n - c]) % MOD;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//{{{\n#include <bits/stdc++.h>\nusing namespace std;\n#define repX(a,b,c,x,...) x\n#define repN(a) repX a\n#define rep(...) repN((__VA_ARGS__,rep3,rep2,loop))(__VA_ARGS__)\n#define rrep(...) repN((__VA_ARGS__,rrep3,rrep2))(__VA_ARGS__)\n#define loop(n) rep2(i_,n)\n#define rep2(i,n) rep3(i,0,n)\n#define rep3(i,begin,end) for(int i=(int)(begin),i##_end=(int)(end);i<i##_end;++i)\n#define rrep2(i,n) rrep3(i,n,0)\n#define rrep3(i,begin,end) for(int i=(int)(begin-1),i##_end=(int)(end);i>=i##_end;--i)\n#define foreach(x,a) for(auto&x:a)\nusing ll=long long;\nconst ll mod=(ll)1e9+7;\n//}}}\n\ntypedef vector< vector<int> > Graph;\n\nint getFar(const Graph& g, int start){\n  const int kInf = 1234567;\n  int n = g.size();\n  vector<int> dist(n, kInf);\n  dist[start] = 0;\n  queue<int> qu;\n  qu.push(start);\n  int res = start;\n  while(!qu.empty()){\n    int p = qu.front();\n    qu.pop();\n    res = p;\n    rep(i, g[p].size()){\n      int next = g[p][i];\n      if(dist[next] < dist[p]+1) continue;\n      dist[next] = dist[p]+1;\n      qu.push(next);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int N;\n  cin >> N;\n  Graph g(N);\n  rep(i, N - 1){\n    int a, b;\n    cin >> a >> b;\n    a--;\n    b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  int s = getFar(g, 0);\n\n  queue<int> qu;\n  qu.push(s);\n  int dis = 0;\n\n  vector<int> dp(N, 0);\n  dp[s] = 1;\n  while(!qu.empty()){\n    int p = qu.front();\n    qu.pop();\n    rep(i, g[p].size()){\n      int next = g[p][i];\n      if(dp[next] != 0) continue;\n      dp[next] = dp[p] + 1;\n      qu.push(next);\n    }\n  }\n  rep(i, N){\n    dis = max(dis, dp[i]);\n  }\n\n  int ans = ((dis % 3) == 0);\n  puts(ans ? \"First\" : \"Second\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-03 17:07:09\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=200010,mod=1000000007;\nint n,m,flag,l,Flag;\ni64 f[N],F[N],ans;\nchar s[N];\nint main()\n{\n\tn=read(); m=read();\n\tscanf(\"%s\",s+1);\n\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\tif(!flag)\n\t{\n\t\tf[0]=1; f[1]=1; f[2]=2;\n\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t\treturn 0;\n\t}\n\tl=n-1;\n\tfor(int i=1,j;i<=m;)\n\t\tif(s[i]==s[1])\n\t\t{\n\t\t\tj=i;\n\t\t\twhile(s[j]==s[1]) j++;\n\t\t\tif(j>n) break;\n\t\t\tif(((j-i)&1)||(!Flag)) l=std::min(l,(j-i)+((j-i)%2==0));\n\t\t\ti=j+1; Flag=1;\n\t\t}\n\t\telse i++;\n\tif(n&1){ printf(\"0\\n\"); return 0; }\n\tn/=2; l=(l+1)/2;\n//\tprintf(\"%d %d\\n\",int(n),int(l));\n\tf[0]=F[0]=1;\n\tfr(i,1,n)\n\t{\n\t\tf[i]=(F[i-1]+mod-(i-l-1>0?F[i-l-1]:0))%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t}\n\tfr(i,1,l) ans=(ans+f[n-i]*2*i)%mod;\n\tprintf(\"%d\\n\",int(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+10;\nconst int mod=1e9+7;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nvoid inc(int &a,int b) {\n\ta=a+b>=mod?a+b-mod:a+b;\n}\n\nint n,m,f[N];\nchar s[N];\n\nint main() {\n\tcin>>n>>m;\n\tscanf(\"%s\",s+1);\n\tint p=n+1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(s[1]!=s[i]) { p=i;break; }\n\tif(p==n+1) {\n\t\tf[0]=1;\n\t\tfor(int i=2,s=1;i<=n;i++) {\n\t\t\tinc(s,f[i-1]);f[i]=s;\n\t\t}\n\t\tint ans=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t\tans=(ans+1ll*i*f[n-i])%mod;\n\t\tcout<<ans;\n\t}\n\telse {\n\t\t--p;int mx=p+!(p&1),len=0;\n\t\tfor(int i=p+1;i<=n;i++) {\n\t\t\tif(s[i]==s[1]) ++len;\n\t\t\telse {\n\t\t\t\tif(len&1) mx=min(mx,len);\n\t\t\t\tlen=0;\n\t\t\t}\n\t\t}\n\t\t++mx;f[0]=1;\n\t\tfor(int i=2,s=1;i<=n;i+=2) {\n\t\t\tf[i]=s;\n\t\t\tif(i>=mx) inc(s,mod-f[i-mx]);\n\t\t\tinc(s,f[i]);\n\t\t\t//cerr<<i<<' '<<f[i]<<endl;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=2;i<=mx;i+=2)\n\t\t\tans=(ans+1ll*i*f[n-i])%mod;\n\t\tcout<<ans;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#define N 201000\ntypedef long long ll;\ntemplate <typename T> inline void read(T &x) {\n\tx = 0; char c = getchar(); bool flag = false;\n\twhile (!isdigit(c)) { if (c == '-')\tflag = true; c = getchar(); }\n\twhile (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }\n\tif (flag)\tx = -x;\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nconst int inf = 987654321;\ninline void MIN(int &a, int b) {\n\tif (b < a)\ta = b;\n}\nint n, m;\nchar s[N];\nnamespace jzp1 {\n\tll jie[N], jieni[N];\n\tinline ll get_c(int n, int m) {\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\tif (n < 0 || m < 0 || n - m < 0)\treturn 0;\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\treturn jie[n] * jieni[m] % P * jieni[n - m] % P;\n\t}\n\tinline ll quickpow(ll x, int k) {\n\t\tll res = 1;\n\t\twhile (k) {\n\t\t\tif (k & 1)\tres = res * x % P;\n\t\t\tx = x * x % P;\n\t\t\tk >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline void sol() {\n//\t\twhile(1);\n\t\tif (n == 1) { puts(\"1\"); return ; }\n\t\tjie[0] = jieni[0] = 1;\n\t\tint up = n + 1;\n\t\tfor (int i = 1; i <= up; ++i)\tjie[i] = jie[i - 1] * i % P;\n\t\tjieni[up] = quickpow(jie[up], P - 2);\n\t\tfor (int i = up - 1; i; --i)\tjieni[i] = jieni[i + 1] * (i + 1) % P;\n\t\tll res = 0;\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tres = (res + get_c(n - i + 1, i) - get_c(n - i - 1, i - 2)) % P;\n//\t\t\tprintf(\"res = %lld\\n\", res);\n\t\t}\n\t\tprintf(\"%lld\\n\", (res % P + P) % P);\n\t}\n}\nll f[N];\nll sum[N];\nint main() {\n\tread(n), read(m);\n\tscanf(\"%s\", s + 1);\n\tbool flag = false;\n\tfor (int i = 1; i <= m; ++i)\tif (s[i] != s[1]) { flag = true; break; }\n\tif (!flag) { jzp1::sol(); return 0; }\n\tif (n & 1) { puts(\"0\"); return 0; }\n\tint lst = 1, mn = inf;\n\tfor (int i = 2; i <= m + 1; ++i) {\n\t\tif (s[i] != s[1]) {\n\t\t\tif (lst & 1)\tMIN(mn, lst);\n\t\t\tlst = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == s[i - 1])\t++lst;\n\t\telse {\n\t\t\tif (lst & 1) MIN(mn, lst);\n\t\t\tlst = 1;\n\t\t}\n\t}\n\tif (mn == inf) {\n//\t\twhile (1);\n\t\tint memo = 1;\n\t\tfor (int i = 1; s[i] == s[1]; ++i) memo = i;\n\t\tmn = memo + 1;\n\t}\n\tn >>= 1;\n\tint k = (mn + 1) >> 1;\n\tMIN(k, n);\n\tf[0] = 1; sum[0] = 1;\n//\tprintf(\"n = %d, k = %d\\n\", n, k);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (i <= k)\tf[i] = sum[i - 1];\n\t\telse f[i] = (sum[i - 1] - sum[i - k - 1]) % P;\n\t\tsum[i] = (sum[i - 1] + f[i]) % P;\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tans += (f[n - i] * i) % P;\n\t}\n\tans = (ans << 1) % P;\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n\n/*\n3 3\nBBB\n//4\n\n1 1\nB\n//1\n\n12 10\nRRRRBRRRRB\n//78\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define mod 1000000007\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nchar S[200010];\nint f[200010],sf[200010];\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),m=gi(),all=0;\n\tscanf(\"%s\",S+1);\n\tint L=1145141;\n\tfor(int l=1,r;l<=m;l=r+1){\n\t\tr=l;if(S[l]!=S[1])continue;\n\t\twhile(r<m&&S[r+1]==S[r])++r;\n\t\tif(l==1&&r==m)all=1;\n\t\tif(((r-l+1&1)||l==1)&&r<m)cnk(L,r-l+2);\n\t}\n\tif(all){\n\t\tstatic int f[200010][2];\n\t\tint ans=0;\n\t\tfor(int fir=0;fir<2;++fir){\n\t\t\tmemset(f,0,sizeof f);\n\t\t\tf[1][fir]=1;\n\t\t\tfor(int i=1;i<=n;++i){\n\t\t\t\tinc(f[i+1][0],f[i][1]);\n\t\t\t\tinc(f[i+1][1],f[i][0]);\n\t\t\t\tinc(f[i+1][1],f[i][1]);\n\t\t\t}\n\t\t\tif(fir)inc(ans,f[n][0]);\n\t\t\tinc(ans,f[n][1]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(L&1)++L;\n\tf[1]=sf[1]=1;\n\tfor(int i=2;i<=n;++i)f[i]=(sf[i-2]-(i-L-2<0?0:sf[i-L-2])+mod)%mod,sf[i]=(f[i]+sf[i-2])%mod;\n\tint ans=0;\n\tfor(int i=n-1;n-i<L&&i>=0;i-=2)\n\t\tinc(ans,1ll*(n-i+1)*f[i]%mod);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int Q=1<<19;\nchar s[Q];\nint n,m;\nconst int MOD=1e9+7;\ninline int add(int a,int b)\n{a+=b;return a>=MOD?a-MOD:a;}\ninline int sub(int a,int b)\n{a-=b;return a<0?a+MOD:a;}\ninline int mul(int a,int b)\n{return 1LL*a*b%MOD;}\nint dp[Q];\nvoid DP(int n,int lim)\n{\n\tdp[0]=1;\n\tint sm=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i>lim)sm=sub(sm,dp[i-lim-1]);\n\t\tdp[i]=sm;\n\t\tsm=add(sm,dp[i]);\n\t}\n}\nvoid s1()\n{\n\tdp[0]=1;\n\tint sm=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i>=2)sm=add(sm,dp[i-2]);\n\t\tdp[i]=sm;\n\t}\n\tint als=1;\n\tfor(int i=2;i<=n;i++){\n\t\tals=add(als,mul(i,dp[n-i]));\n\t}\n\tprintf(\"%d\\n\",als);\n}\nvoid s2(int fir)\n{\n\tif(n&1){\n\t\tputs(\"0\");\n\t\treturn;\n\t}\n\tint mus=fir+(fir%2==0);\n\tfor(int len=0,i=fir+2;i<=m;i++){\n\t\tif(s[i]==s[1])++len;\n\t\telse{\n\t\t\tif(len&1)mus=min(mus,len);\n\t\t\tlen=0;\n\t\t}\n\t}\n\tn/=2,mus=(mus+1)/2;\n\t// printf(\"%d %d WCNM\\n\",n,mus);\n\t\n\tDP(n,mus);\n\t// for(int i=0;i<=n;i++)\n\t\t// printf(\"%d ????\\n\",dp[i]);\n\tint als=0;\n\tfor(int i=1;i<=n&&i<=mus;i++){\n\t\tals=add(als,mul(2*i,dp[n-i]));\n\t}\n\tprintf(\"%d\",als);\n}\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tfor(int i=2;i<=m;i++)\n\t\tif(s[i]!=s[1]){\n\t\t\ts2(i-1);\n\t\t\treturn 0;\n\t\t}\n\ts1();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\nconst int N=200200,P=1e9+7;\nint n,m,ans,lim,all,mxo;\nint b[N],f[N],s[N];\nchar S[N];\nvoid work(int w){\n\tf[0]=s[0]=1;//cout<<w<<' '<<lim<<'\\n';\n\tif(w==1){\n\t\tf[1]=0;s[1]=1;\n\t\tFOR(i,2,n){\n\t\t\tf[i]=s[i-2];\n\t\t\ts[i]=(s[i-1]+f[i])%P;\n\t\t\t//cout<<f[i]<<' ';\n\t\t}\n\t}\n\telse{\n\t\tFOR(i,1,n){\n\t\t\tf[i]=(s[i-1]-(i-lim-1<0?0:s[i-lim-1])+P)%P;\n\t\t\ts[i]=(s[i-1]+f[i])%P;\n\t\t\t//cout<<f[i]<<'\\n';\n\t\t}\n\t}\n\tFOR(i,1+(w==1),min(lim,n)) (ans+=1ll*i*f[n-i]%P)%=P;\n\tcout<<w*ans%P<<'\\n';\n}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d%d%s\",&n,&m,S+1);\n\tROF(i,m,1) b[i]=S[i]=='R'^S[1]=='B';\n\tall=1;\n\tFOR(i,1,m) all&=b[i];\n\tif(all) return lim=n,ans=1,work(1),0;\n\tFOR(i,1,m)if(!b[i]){lim=i-!(i%2);break;}\n\tfor(int l=1,r=1;l<=m;l=r){\n\t\twhile(r<=m && b[r]==b[l]) r++;\n\t\tif(b[l]==0) continue;\n\t\tif((r-l&1) && l!=1 && r<=m) lim=min(lim,r-l);\n\t}\n\tlim=lim+1>>1;\n\tif(n&1) return puts(\"0\"),0;\n\tn/=2;work(2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/01/29] 12:36:49\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nvoid outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\n\n\ntemplate<typename T> T gcd(const T& a, const T& b) { return a < 0 ? gcd(-a, b) : b < 0 ? gcd(a, -b) : (a > b ? gcd(b, a) : a == 0 ? b : gcd(b % a, a)); }\ntemplate<typename T> T lcm(const T& a, const T& b) { return a / gcd(a, b) * b; }\ntemplate<typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto g = gcd(a, b), da = std::abs(b) / g;\n    const auto p = extgcd(b, a % b);\n    const auto x = (da + p.second % da) % da, y = (g - a * x) / b;\n    return {x, y};\n}\ntemplate<typename T>\nconstexpr T inverse(const T a, const T mod) { return extgcd(a, mod).first; }\ntemplate<uint mod_value, bool dynamic = false>\nclass modint_base\n{\npublic:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, const UInt> mod() { return mod_ref(); }\n    template<typename UInt = uint>\n    static constexpr std::enable_if_t<not dynamic, const UInt> mod() { return mod_value; }\n    template<typename UInt = uint>\n    static void set_mod(const std::enable_if_t<dynamic, const UInt> mod) { mod_ref() = mod, inv_ref() = {1, 1}; }\n    modint_base() : v{0} {}\n    modint_base(const ll val) : v{norm(static_cast<uint>(val % static_cast<ll>(mod()) + static_cast<ll>(mod())))} {}\n    modint_base(const modint_base& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    modint_base& operator=(const modint_base& m) { return v = m(), (*this); }\n    modint_base& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod()) + static_cast<ll>(mod()))), (*this); }\n    friend modint_base operator+(const modint_base& m) { return m; }\n    friend modint_base operator-(const modint_base& m) { return make(norm(mod() - m.v)); }\n    friend modint_base operator+(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + m2.v)); }\n    friend modint_base operator-(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + mod() - m2.v)); }\n    friend modint_base operator*(const modint_base& m1, const modint_base& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod()))); }\n    friend modint_base operator/(const modint_base& m1, const modint_base& m2) { return m1 * inv(m2.v); }\n    friend modint_base operator+(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) - val}; }\n    friend modint_base operator*(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * inv(val)}; }\n    friend modint_base operator+(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const ll val, const modint_base& m) { return modint_base{-static_cast<ll>(m.v) + val}; }\n    friend modint_base operator*(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const ll val, const modint_base& m) { return modint_base{val * inv(static_cast<ll>(m.v))}; }\n    friend modint_base& operator+=(modint_base& m1, const modint_base& m2) { return m1 = m1 + m2; }\n    friend modint_base& operator-=(modint_base& m1, const modint_base& m2) { return m1 = m1 - m2; }\n    friend modint_base& operator*=(modint_base& m1, const modint_base& m2) { return m1 = m1 * m2; }\n    friend modint_base& operator/=(modint_base& m1, const modint_base& m2) { return m1 = m1 / m2; }\n    friend modint_base& operator+=(modint_base& m, const ll val) { return m = m + val; }\n    friend modint_base& operator-=(modint_base& m, const ll val) { return m = m - val; }\n    friend modint_base& operator*=(modint_base& m, const ll val) { return m = m * val; }\n    friend modint_base& operator/=(modint_base& m, const ll val) { return m = m / val; }\n    friend modint_base operator^(const modint_base& m, const ll n) { return power(m.v, n); }\n    friend modint_base& operator^=(modint_base& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const modint_base& m1, const modint_base& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const modint_base& m1, const modint_base& m2) { return not(m1 == m2); }\n    friend bool operator==(const modint_base& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const modint_base& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const modint_base& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const ll val, const modint_base& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, modint_base& m)\n    {\n        ll v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const modint_base& m) { return os << m(); }\n    uint operator()() const { return v; }\n    static modint_base small_inv(const usize n)\n    {\n        auto& in = inv_ref();\n        if (n < in.size()) { return in[n]; }\n        for (usize i = in.size(); i <= n; i++) { in.push_back(-in[modint_base::mod() % i] * (modint_base::mod() / i)); }\n        return in.back();\n    }\n    std::pair<ll, ll> quad() const\n    {\n        const auto ans = quad_r(v, mod());\n        ll x = std::get<0>(ans), y = std::get<1>(ans);\n        if (y < 0) { x = -x, y = -y; }\n        return {x, y};\n    }\n\nprivate:\n    static std::tuple<ll, ll, ll> quad_r(const ll r, const ll p)  // r = x/y (mod p), (x,y,z) s.t. x=yr+pz\n    {\n        if (std::abs(r) <= 1000) { return {r, 1, 0}; }\n        ll nr = p % r, q = p / r;\n        if (nr * 2LL >= r) { nr -= r, q++; }\n        if (nr * 2LL <= -r) { nr += r, q--; }\n        const auto sub = quad_r(nr, r);\n        const ll x = std::get<0>(sub), z = std::get<1>(sub), y = std::get<2>(sub);\n        return {x, y - q * z, z};\n    }\n\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, UInt&> mod_ref()\n    {\n        static UInt mod = 0;\n        return mod;\n    }\n    static uint norm(const uint x) { return x < mod() ? x : x - mod(); }\n    static modint_base make(const uint x)\n    {\n        modint_base m;\n        return m.v = x, m;\n    }\n    static modint_base power(modint_base x, ull n)\n    {\n        modint_base ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static modint_base inv(const ll v) { return v <= 2000000 ? small_inv(static_cast<usize>(v)) : modint_base{inverse(v, static_cast<ll>(mod()))}; }\n    static std::vector<modint_base>& inv_ref()\n    {\n        static std::vector<modint_base> in{1, 1};\n        return in;\n    }\n    uint v;\n};\ntemplate<uint mod>\nusing modint = modint_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modint = modint_base<id, true>;\nint main()\n{\n    using mint   = modint<mod>;\n    const auto N = in<int>(), M = in<int>();\n    auto S = in<std::string>();\n    if (S[0] == 'B') {\n        for (auto& c : S) { c = (c == 'R' ? 'B' : 'R'); }\n    }\n    if (S == std::string(M, 'R')) {\n        mint ans = 0;\n        mint r = 1, b = 0;\n        for (int i = 0; i < N - 2; i++) {\n            mint r_ = r, b_ = b;\n            r = r_ + b_, b = r_;\n        }\n        ans += r;\n        r = 1, b = 1;\n        for (int i = 0; i < N - 2; i++) {\n            mint r_ = r, b_ = b;\n            r = r_ + b_, b = r_;\n        }\n        ans += r + b;\n        return outln(ans);\n    }\n    if (N % 2 == 1) { return outln(0); }\n    S.push_back('$');\n    std::vector<int> ls;\n    char p = 'R';\n    int l  = 0;\n    for (int i = 0; i <= M; i++) {\n        if (S[i] != p) {\n            p = S[i];\n            ls.push_back(l);\n            l = 1;\n        } else {\n            l++;\n        }\n    }\n    SHOW(ls);\n    int m = inf_v<int>;\n    for (int i = 0; i < ls.size(); i += 2) {\n        if (i == 0) {\n            chmin(m, ls[i] / 2 + 1);\n        } else if (ls[i] % 2 == 1) {\n            chmin(m, (ls[i] + 1) / 2);\n        }\n    }\n    SHOW(m);\n    const int n = N / 2;\n    // x1+x2+...+xk = n (円環)\n    // xi <= m\n    std::vector<mint> dp(n + 1, 0);\n    std::vector<mint> sm(n + 1, 0);\n    dp[0] = sm[0] = 1;\n    auto sum      = [&](int i, int j) { return sm[j - 1] - (i == 0 ? mint(0) : sm[i - 1]); };\n    for (int i = 1; i <= n; i++) {\n        dp[i] = sum(std::max(0, i - m), i);\n        sm[i] = sm[i - 1] + dp[i];\n    }\n    mint ans = 0;\n    for (int r1 = 1; r1 <= std::min(n, m); r1++) { ans += dp[n - r1] * 2 * r1; }\n    outln(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=200010, LOG=20;\n\nint n, m, k, u, v, x, y, t, a, b, ans;\nint A[MAXN];\nint dp[MAXN];\nstring S;\n\ninline void fix(int &x){\n\tif (x>=mod) x-=mod;\n\tif (x<0) x+=mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n>>m>>S;\n\tfor (int i=0; i<m; i++) if (S[i]=='R') S[i]='A'; // :(\n\tif (S[0]=='B'){\n\t\tfor (int i=0; i<m; i++) S[i]='A'+'B'-S[i];\n\t}\n\twhile (S.size()>1 && S.back()=='A') S.pop_back();\n\tm=S.size();\n//\tdebug(S)\n\tif (m==1){\n\t\tdp[1]=1;\n\t\tfor (int i=3; i<=n; i++){\n\t\t\tfix(dp[i]=dp[i-1]+dp[i-2]);\n\t\t}\n\t\tans=n+1;\n\t\tfor (int i=3; i<n; i++) ans=(ans + (n-i+1ll)*dp[i])%mod;\n\t\tfix(ans);\n\t\tcout<<ans<<\"\\n\";\n\t\t\n\t\treturn 0;\n\t}\n\tif (n&1) kill(0)\n\tfor (int i=0, j=0; i<m; i=j){\n\t\tif (S[i]=='B') j++;\n\t\telse{\n\t\t\twhile (S[j]=='A' && j<m) j++;\n\t\t\tif (i==0 || (j-i)%2==1) k=max(k, j-i);\n\t\t}\n\t}\n\tk>>=1;\n\tn>>=1;\n//\tdebug2(n, k)\n\tdp[0]=1;\n\tdp[1]=1+(k>=1);\n\tfor (int i=2; i<=n; i++){\n\t\tfix(dp[i]=2*dp[i-1]-(k>=i-1)+(k>=i));\n\t\tif (i>=k+2) fix(dp[i]-=dp[i-k-2]);\n\t}\n//\tdebug(dp[1])\n//\tdebug(dp[2])\n//\tdebug(dp[3])\n\t\n\tfor (int i=0; i+2<=n; i++) if (n-i-2<=k) ans=(ans + (n-i-1ll)*dp[i])%mod;\n\tif (n-1<=k) fix(ans+=n);\n\tfix(ans*=2);\n\tfix(ans);\n\tcout<<ans<<\"\\n\";\n\t\n\treturn 0;\n}\n/*\n12 5\nAAAAB\n\n6 5\nRRRRB\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\ninline void add(int &x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nll bin_pow(ll a, ll p) {\n    ll res = 1;\n    while (p) {\n        if (p & 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return res;\n}\n\nll rev(ll x) {\n    return bin_pow(x, MOD - 2);\n}\n\nll fact[N + 1], rfact[N + 1];\n\nvoid init() {\n    fact[0] = 1;\n    rep(i, 1, N + 1) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    rfact[N] = rev(fact[N]);\n    repb(i, N - 1, -1) {\n        rfact[i] = rfact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nll C(int n, int k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    return fact[n] * rfact[k] % MOD * rfact[n - k] % MOD;\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    init();\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    repb(i, m - 1, -1) {\n        s[i] = char('0' + (s[0] != s[i]));\n    }\n    int c1 = 0;\n    rep(i, 0, m) {\n        if (s[i] == '1') {\n            c1++;\n        }\n    }\n    if (c1 == 0) {\n        int ans = 0;\n        for (int i = 0; i * 2 <= n; i++) {\n            //cout << i << \" \" << n - i << \" \" << C(n - i, i) << \"\\n\";\n            add(ans, C(n - i, i));\n            if (i >= 1) {\n                add(ans, C(n - 2 - (i - 1), (i - 1)));\n            }\n        }\n        cout << ans << \"\\n\";\n        return 0;\n    }\n    int k = (n % 2 == 1 ? n : n - 1), cur = 0;\n    rep(i, 0, m) {\n        if (s[i] == '0') {\n            cur++;\n        }\n        if (i == m - 1 || s[i + 1] == '1') {\n            if (cur % 2 == 1) {\n                setmin(k, cur);\n            } else if (cur > 0) {\n                setmin(k, cur * 2 - 3);\n            }\n            cur = 0;\n        }\n    }\n    //cout << k << endl;\n    int dp[n + 2], pref0[n + 2], pref1[n + 2];\n    fill(dp, dp + n + 1, 0);\n    fill(pref0, pref0 + n + 2, 0);\n    fill(pref1, pref1 + n + 2, 0);\n    dp[1] = 1;\n    pref1[1] = 1;\n    rep(i, 2, n + 2) {\n        int last_add = max(2 - i % 2, i - (k + 1));\n        if (i % 2 == 0) {\n            dp[i] = pref0[i - 2] - (last_add - 2 >= 0 ? pref0[last_add - 2] : 0);\n            if (dp[i] < 0) {\n                dp[i] += MOD;\n            }\n        } else {\n            dp[i] = pref1[i - 2] - (last_add - 2 >= 0 ? pref1[last_add - 2] : 0);\n        }\n        if (i % 2 == 0) {\n            pref0[i] = (pref0[i - 2] + dp[i]) % MOD;\n        } else {\n            pref1[i] = (pref1[i - 2] + dp[i]) % MOD;\n        }\n    }\n    /*rep(i, 1, n + 2) {\n        cout << dp[i] << \" \";\n    }\n    cout << \"\\n\";*/\n    if (n % 2 == 1) {\n        cout << 0 << \"\\n\";\n        return 0;\n    }\n    int ans = dp[n + 1];\n    //cout << k << endl;\n    for (int c = 1; c <= k; c += 2) {\n        //cout << c << \" \" << dp[n - c] << endl;\n        ans = (ans + 1LL * c * dp[n - c]) % MOD;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // clang-format off\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define in2(s,t)     rep(i,sz(s)){in(s[i] , t[i]);}\n#define in3(s,t,u)   rep(i,sz(s)){in(s[i] , t[i] , u[i]);}\n#define in4(s,t,u,v) rep(i,sz(s)){in(s[i] , t[i] , u[i] , v[i]);}\n#ifdef ONLINE_JUDGE\n  #define rep(i,N) for(int i = 0; i < (int)(N); i++)\n  #define repr(i,N) for(int i = (int)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(int i = 1; i <= (int)(N) ; i++)\n  #define repr1(i,N) for(int i = (N) ; (int)(i) > 0 ; i--)\n#else\n  #define rep(i,N) for(long long i = 0; i < (long long)(N); i++)\n  #define repr(i,N) for(long long i = (long long)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(long long i = 1; i <= (long long)(N) ; i++)\n  #define repr1(i,N) for(long long i = (N) ; (long long)(i) > 0 ; i--)\n#endif\nusing namespace std; void solve();\nusing ll = long long; template<class T = ll> using V = vector<T>;\nusing vi = V<int>; using vl = V<>; using vvi = V< V<int> >;\nusing vd = V<double>; using vs = V<string>; using vvl = V< V<> >;\nconstexpr int inf = 1001001001; constexpr ll infLL = (1LL << 61) - 1;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T,typename U>ll ceil(T a,U b){return (a + b - 1) / b;}\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); for(int i=0;i<s;i++) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);} while(0)\n  #define trcc(v) do { cerr << \"name : \" << #v << \"\\n\"; int cnt = 0; each(x , v){cerr << (cnt++) << \" : \"; trc(x); } } while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  #define trcc(...)\n  int main(){solve();}\n#endif\n\nconstexpr ll TEN(int n){ll ret=1,x=10;while(n){if(n&1)ret*=x;x*=x;n>>=1;}return ret;}\n#define mem(a, val) memset(a, val, sizeof(a))\n\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\nusing P = pair<ll,ll>; using vp = V<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n// clang-format on\n////////////////////////////////////////////////////\n\n\nvector<pair<char,int>> RunLengthEncoding(string& S){\n  vector<pair<char,int>> ret;\n  char c = -1;\n  int n = 0;\n  for(char x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate<typename T>\nvector<pair<T,int>> RunLengthEncoding(vector<T>& S){\n  vector<pair<T,int>> ret;\n  T c = -1;\n  int n = 0;\n  for(T& x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\nusing mint = modint;\n\nnamespace FastFourierTransform {\n  using real = double;\n\n  struct C {\n    real x, y;\n\n    C() : x(0), y(0) {}\n\n    C(real x, real y) : x(x), y(y) {}\n\n    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }\n\n    inline C conj() const { return C(x, -y); }\n  };\n\n  const real PI = acosl(-1);\n  int base = 1;\n  vector< C > rts = { {0, 0},\n                     {1, 0} };\n  vector< int > rev = {0, 1};\n\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    while(base < nbase) {\n      real angle = PI * 2.0 / (1 << (base + 1));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        real angle_i = angle * (2 * i + 1 - (1 << base));\n        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n      }\n      ++base;\n    }\n  }\n\n  void fft(vector< C > &a, int n) {\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          C z = a[i + j + k] * rts[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n  }\n\n  vector< int64_t > multiply(const vector< int > &a, const vector< int > &b) {\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = C(x, y);\n    }\n    fft(fa, sz);\n    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n      fa[i] = z;\n    }\n    for(int i = 0; i < (sz >> 1); i++) {\n      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n      fa[i] = A0 + A1 * s;\n    }\n    fft(fa, sz >> 1);\n    vector< int64_t > ret(need);\n    for(int i = 0; i < need; i++) {\n      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n    }\n    return ret;\n  }\n};\n\ntemplate< typename T >\nstruct ArbitraryModConvolution {\n  using real = FastFourierTransform::real;\n  using C = FastFourierTransform::C;\n\n  ArbitraryModConvolution() = default;\n\n  vector< T > multiply(const vector< T > &a, const vector< T > &b, int need = -1) {\n    if(need == -1) need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while((1 << nbase) < need) nbase++;\n    FastFourierTransform::ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < (int)a.size(); i++) {\n      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);\n    }\n    fft(fa, sz);\n    vector< C > fb(sz);\n    if(a == b) {\n      fb = fa;\n    } else {\n      for(int i = 0; i < (int)b.size(); i++) {\n        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);\n      }\n      fft(fb, sz);\n    }\n    real ratio = 0.25 / sz;\n    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C a1 = (fa[i] + fa[j].conj());\n      C a2 = (fa[i] - fa[j].conj()) * r2;\n      C b1 = (fb[i] + fb[j].conj()) * r3;\n      C b2 = (fb[i] - fb[j].conj()) * r4;\n      if(i != j) {\n        C c1 = (fa[j] + fa[i].conj());\n        C c2 = (fa[j] - fa[i].conj()) * r2;\n        C d1 = (fb[j] + fb[i].conj()) * r3;\n        C d2 = (fb[j] - fb[i].conj()) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector< T > ret(need);\n    for(int i = 0; i < need; i++) {\n      int64_t aa = llround(fa[i].x);\n      int64_t bb = llround(fb[i].x);\n      int64_t cc = llround(fa[i].y);\n      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;\n      ret[i] = aa + (bb << 15) + (cc << 30);\n    }\n    return ret;\n  }\n};\n\ntemplate< int mod >\nstruct NumberTheoreticTransform {\n\n  int base, max_base, root;\n  vector< int > rev, rts;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while(tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while(n > 0) {\n      if(n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) {\n    return mod_pow(x, mod - 2);\n  }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long) mod;\n  }\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while(base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n\n  void ntt(vector< int > &a) {\n    const int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n\n  vector< int > multiply(vector< int > a, vector< int > b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for(int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n\n  vector<modint> multiply_for_fps(const vector<modint> &a,const vector<modint> &b){\n    vector<int> A(a.size()) , B(b.size());\n    for(int i = 0;i < (int)a.size(); i++) A[i] = a[i].x;\n    for(int i = 0;i < (int)b.size(); i++) B[i] = b[i].x;\n    auto C = multiply( A , B );\n    vector<modint> ret(C.size());\n    for(int i = 0; i < (int)C.size() ;i++) ret[i].x = C[i];\n    return ret;\n  }\n};\n\n\ntemplate< typename T >\nstruct FormalPowerSeries : vector< T > {\n  using vector< T >::vector;\n  using P = FormalPowerSeries;\n\n  using MULT = function< P(P, P) >;\n\n  static MULT &get_mult() {\n    static MULT mult = nullptr;\n    return mult;\n  }\n\n  static void set_fft(MULT f) {\n    get_mult() = f;\n  }\n\n  void shrink() {\n    while(this->size() && this->back() == T(0)) this->pop_back();\n  }\n\n  P operator+(const P &r) const { return P(*this) += r; }\n\n  P operator+(const T &v) const { return P(*this) += v; }\n\n  P operator-(const P &r) const { return P(*this) -= r; }\n\n  P operator-(const T &v) const { return P(*this) -= v; }\n\n  P operator*(const P &r) const { return P(*this) *= r; }\n\n  P operator*(const T &v) const { return P(*this) *= v; }\n\n  P operator/(const P &r) const { return P(*this) /= r; }\n\n  P operator%(const P &r) const { return P(*this) %= r; }\n\n  P &operator+=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] += r[i];\n    return *this;\n  }\n\n  P &operator+=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] += r;\n    return *this;\n  }\n\n  P &operator-=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] -= r[i];\n    shrink();\n    return *this;\n  }\n\n  P &operator-=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] -= r;\n    shrink();\n    return *this;\n  }\n\n  P &operator*=(const T &v) {\n    const int n = (int) this->size();\n    for(int k = 0; k < n; k++) (*this)[k] *= v;\n    return *this;\n  }\n\n  P &operator*=(const P &r) {\n    if(this->empty() || r.empty()) {\n      this->clear();\n      return *this;\n    }\n    assert(get_mult() != nullptr);\n    return *this = get_mult()(*this, r);\n  }\n\n  P &operator%=(const P &r) {\n    return *this -= *this / r * r;\n  }\n\n  P operator-() const {\n    P ret(this->size());\n    for(int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];\n    return ret;\n  }\n\n  P &operator/=(const P &r) {\n    if(this->size() < r.size()) {\n      this->clear();\n      return *this;\n    }\n    int n = this->size() - r.size() + 1;\n    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);\n  }\n\n  P pre(int sz) const {\n    return P(begin(*this), begin(*this) + min((int) this->size(), sz));\n  }\n\n  P operator>>(int sz) const {\n    if(this->size() <= sz) return {};\n    P ret(*this);\n    ret.erase(ret.begin(), ret.begin() + sz);\n    return ret;\n  }\n\n  P operator<<(int sz) const {\n    P ret(*this);\n    ret.insert(ret.begin(), sz, T(0));\n    return ret;\n  }\n\n  P rev(int deg = -1) const {\n    P ret(*this);\n    if(deg != -1) ret.resize(deg, T(0));\n    reverse(begin(ret), end(ret));\n    return ret;\n  }\n\n  P diff() const {\n    const int n = (int) this->size();\n    P ret(max(0, n - 1));\n    for(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);\n    return ret;\n  }\n\n  P integral() const {\n    const int n = (int) this->size();\n    P ret(n + 1);\n    ret[0] = T(0);\n    for(int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);\n    return ret;\n  }\n\n  // F(0) must not be 0\n  P inv(int deg = -1) const {\n    assert(((*this)[0]) != T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1) / (*this)[0]});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 1\n  P log(int deg = -1) const {\n    assert((*this)[0] == 1);\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();\n  }\n\n  P sqrt(int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n\n    if((*this)[0] == T(0)) {\n      for(int i = 1; i < n; i++) {\n        if((*this)[i] != T(0)) {\n          if(i & 1) return {};\n          if(deg - i / 2 <= 0) break;\n          auto ret = (*this >> i).sqrt(deg - i / 2) << (i / 2);\n          if(ret.size() < deg) ret.resize(deg, T(0));\n          return ret;\n        }\n      }\n      return P(deg, 0);\n    }\n\n    P ret({T(1)});\n    T inv2 = T(1) / T(2);\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 0\n  P exp(int deg = -1) const {\n    assert((*this)[0] == T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1)});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  P pow(int64_t k, int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    for(int i = 0; i < n; i++) {\n      if((*this)[i] != T(0)) {\n        T rev = T(1) / (*this)[i];\n        P C(*this * rev);\n        P D(n - i);\n        for(int j = i; j < n; j++) D[j - i] = C[j];\n        D = (D.log() * k).exp() * (*this)[i].pow(k);\n        P E(deg);\n        if(i * k > deg) return E;\n        auto S = i * k;\n        for(int j = 0; j + S < deg && j < D.size(); j++) E[j + S] = D[j];\n        return E;\n      }\n    }\n    return *this;\n  }\n\n  T eval(T x) const {\n    T r = 0, w = 1;\n    for(auto &v : *this) {\n      r += w * v;\n      w *= x;\n    }\n    return r;\n  }\n};\n\nusing FPS = FormalPowerSeries< modint >;\n\n// fにa * x^n + bを掛ける\nvoid mul_simple(FPS &f,modint a ,int n, modint b){\n  for(int i = (int)f.size() - 1 ; i >= 0 ; i--){\n    f[i] *= b;\n    if(i >= n) f[i] += f[i - n] * a; \n  }\n}\n\n// fからa * x^n + bを割る\nvoid div_simple(FPS &f,modint a,int n,modint b){\n  for(int i = 0 ; i < (int)f.size() ; i++){\n    f[i] /= b;\n    if(i + n < (int)f.size() ) f[n + i] -= f[i] * a; \n  }\n}\n\n// f / gをdeg(f)次まで求める\nFPS div_(FPS &f , FPS g){\n  int n = f.size();\n  return (f * g.inv(n)).pre(n);\n}\n\n\n// solve関数内で\n//\n// FPS::set_fft(mul);\n//\n// とすること。\n\n/**\nNumberTheoreticTransform<MOD> ntt;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret =ntt.multiply_for_fps(a , b);\n  return FPS::P(ret.begin(), ret.end());\n};\n/*///\nArbitraryModConvolution< modint > fft;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret = fft.multiply(a, b);\n  return FPS::P(ret.begin(), ret.end());\n};\n//*/\n\n// 下記のリンクを実装(kitamasa法のモンゴメリ乗算を使わない版)\n// http://q.c.titech.ac.jp/docs/progs/polynomial_division.html\n// k項間漸化式のa_Nを求める O(k log k log N)\n// N ... 求めたい項　(0-indexed)\n// Q ... 漸化式 (1 - \\sum_i c_i x^i)の形\n// a ... 初期解 (a_0 , a_1 , ... , a_k-1)\n// x^N を fでわった剰余を求め、aと内積を取る\nmodint kitamasa(ll N, FPS &Q, FPS &a){\n  int k = Q.size() - 1;\n  assert( (int)a.size() == k );\n  FPS P = a * Q; P.resize(k);\n  while(N){\n    auto Q2 = Q;\n    for(int i = 1; i < (int)Q2.size(); i += 2) Q2[i].x = MOD - Q2[i].x;\n    auto S = P * Q2;\n    auto T = Q * Q2;\n    if(N & 1){\n      for(int i = 1 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    else{\n      for(int i = 0 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    N >>= 1;\n  }\n  return P[0];\n}\n\nvoid solve(){\n  ini(N , M);\n  ins(S);\n  auto run = RunLengthEncoding(S);\n  if(run.size() == 1){\n    // DP\n    V<mint> dp(N),ep(N),fp(N),gp(N);\n    // [0]がR\n    // -> [1],[-1]はどちらでもよい\n    dp[0] = gp[0] = 1;\n    rep1(i , N - 1){\n      dp[i] = dp[i - 1] + ep[i - 1];\n      ep[i] = dp[i - 1];\n      fp[i] = fp[i - 1] + gp[i - 1];\n      gp[i] = fp[i - 1];\n    }\n    out(dp[N-1] + ep[N-1] + fp[N-1]);\n    return;\n  }\n  if(N % 2 == 1){\n    out(0);\n    return;\n  }\n\n  FPS::set_fft(mul);\n  // rの最小値\n  int r = N-1 , b = N-1;\n  // 偶数は無視していい\n  rep(i , sz(run)){\n    if(i==0)continue;\n    auto p = run[i];\n    if(p.first == 'R' && p.second % 2 == 1) amin(r , p.second);\n    if(p.first == 'B' && p.second % 2 == 1) amin(b , p.second);\n  }\n  // 初手の制約\n  amin( (run[0].first == 'R' ? r : b) , run[0].second + (run[0].second % 2 == 0) );\n  // 初手とは異なる方が1である必要あり\n  (run[0].first == 'R' ? b : r) = 1;\n  trc(r , b);\n  if(r < b) swap(r , b);\n  auto nyaan = [&](ll n,int flg = false) -> FPS{\n    FPS ret(n + 1);\n    for(int i = 1 ; i <= n ; i += 2) ret[i] = (flg ? i : 1);\n    return ret;\n  };\n  FPS f({0 , 1});\n  f *= nyaan(r);\n  trc(f);\n  f = FPS({1}) - f;\n  if((int)f.size() <= N) f.resize(N + 2);\n  f = f.inv();\n  f *= nyaan(r,1) * FPS({0,1}) + FPS({0,1}) * nyaan(r); \n  trc(f);\n  out(f[N]);\n  \n  \n  /*\n  //trc(f);\n  // 倍数包除\n  for(int i = 2 ; i <= N ; i++){\n    // i番目は？\n    //引こう！\n    for(int j = 2 ; i * j <= N ; j++){\n      f[i * j] -= f[i];\n    }\n  }\n  trc(f);\n  */\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nconst int mod=1e9+7;\n\nvoid U(int &x,int y){\n    x=(x+y)%mod;\n}\n\nint n, m, a[202000];\nchar s[202000];\n\nint main(){\n    cin>>n>>m>>s+1;\n    for (int i=1;i<=m;++i)\n        a[i]= s[i]==s[1];\n    if (*min_element(a+1,a+m+1)==1){\n        static int f[202000][2][2];\n        f[1][0][0]=f[1][1][1]=1;\n        for (int i=1;i<n;++i){\n            for (int s=0;s<=1;++s)\n                for (int t=0;t<=1;++t)\n                    for (int tt=0;tt<=1;++tt){\n                        if (t==0&&tt==0) continue;\n                        U(f[i+1][s][tt],f[i][s][t]);\n                    }\n        }\n        int ans=(1ll*f[n][0][1]+f[n][1][0]+f[n][1][1])%mod;\n        cout<<ans<<endl;\n        return 0;\n    }\n    int las=0, mx=1e9; vector<int>vec;\n    for (int i=1;i<=m;++i)\n        if (a[i]){\n            ++las;\n        }else{\n            vec.push_back(las);\n            las=0;\n        }\n    {\n        int t=vec.front(); vec.erase(vec.begin());\n        mx=min(mx,(t&1? t: t+1));\n    }\n    for (auto t:vec){\n        if (t&1) mx=min(mx,t);\n    }\n\n\n    static int ans=0, f[202000], sum[202000];\n    f[1]=sum[1]=1;\n    for (int i=1;i<=n;++i){\n        if (i!=1){\n            f[i]=(sum[i-2]-sum[max(0,i-mx-3)]+mod)%mod;\n            sum[i]=(sum[i-2]+f[i])%mod;\n        }\n        if ((n-i&1)&&n-i<=mx){\n            ans=(ans+(ll)f[i]*(n-i+1))%mod;\n        }\n    }\n    cout<<ans-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-03 17:07:09\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=200010,mod=1000000007;\nint n,m,flag,l,Flag;\ni64 f[N],F[N],ans;\nchar s[N];\nint main()\n{\n\tn=read(); m=read();\n\tscanf(\"%s\",s+1);\n\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\tif(!flag)\n\t{\n\t\tf[0]=1; f[1]=1; f[2]=2;\n\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t\treturn 0;\n\t}\n\tl=n-1;\n\tfor(int i=1,j;i<=m;)\n\t\tif(s[i]==s[1])\n\t\t{\n\t\t\tj=i;\n\t\t\twhile(s[j]==s[1]) j++;\n\t\t\tif(j>n) break;\n\t\t\tif(((j-i)&1)||(!Flag)) l=std::min(l,(j-i)+((j-i)%2==0));\n\t\t\ti=j+1; Flag=1;\n\t\t}\n\t\telse i++;\n\tif(n&1){ printf(\"0\\n\"); return 0; }\n\tn/=2; l=(l+1)/2;\n//\tprintf(\"%d %d\\n\",int(n),int(l));\n\tf[0]=F[0]=1;\n\tfr(i,1,n)\n\t{\n\t\tf[i]=(F[i-1]+mod-(i-l-1>=0?F[i-l-1]:0))%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t}\n\tans=f[n];\n\tfr(i,1,std::min(l,n-1)) ans=(ans+f[n-i]*(2*i-1))%mod;\n\tprintf(\"%d\\n\",int(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inv(x) power(x,Mod-2)\n#define NO() {puts(\"0\");return 0;}\nusing namespace std;\ntypedef long long ll;\nconst int Mod=1e9+7;\nint add(int a,const int b){a+=b;if(a>=Mod)a-=Mod;return a;}\nint sub(int a,const int b){a-=b;if(a<0)a+=Mod;return a;}\nint mul(const int a,const int b){return (ll)a*b%Mod;}\nint power(int x,int cs)\n{\n\tint ras=1;\n\twhile(cs)\n\t{\n\t\tif(cs&1) ras=mul(ras,x);\n\t\tx=mul(x,x);cs>>=1;\n\t}\n\treturn ras;\n}\nconst int N=2e5+50;\nint n,m,tag=0,mx,ans=0;\nchar s[N];\nint val[N],dp[N],sum[N];\nint q(int l,int r)\n{\n\tif(l>r) return 0;\n\tint ras=sum[r];\n\tif(l!=0) ras=sub(ras,sum[l-1]);\n\treturn ras;\n}\nint main()\n{\n\t\n\tint i,x,pos;\n\tscanf(\"%d%d\",&n,&m);\t\n\t\n\tscanf(\"%s\",s+1);\n\tif(s[1]=='B') tag=1;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tif(s[i]=='R') val[i]=(1^tag);\n\t\telse val[i]=(0^tag);\n\t}\n\tfor(x=1;x<=m&&val[x]==1;x++);\n\tx--;\n\tif(x==m)\n\t{\n\t\tmx=n;ans=1;\n\t\tdp[0]=1;sum[0]=1;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tdp[i]=q(max(i-mx,0),i-2);\n\t\t\tsum[i]=add(sum[i-1],dp[i]);\n\t\t}\n\t\t//printf(\"%d %d\\n\",dp[1],dp[2]);\n\t\tfor(i=2;i<=mx;i++)\n\t\t{\n\t\t\tans=add(ans,mul(i,dp[n-i]));\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(n&1) NO();\n\t\tif(x&1) mx=x;\n\t\telse mx=x+1;\n\t\tfor(i=x+1;i<=m;)\n\t\t{\n\t\t\tif(val[i]==0) \n\t\t\t{\n\t\t\t\ti++;continue;\n\t\t\t}\n\t\t\tpos=i;\n\t\t\twhile(val[pos]==1) pos++;\n\t\t\tpos--;\n\t\t\tif((pos-i+1)&1) mx=min(mx,pos-i+1);\n\t\t\ti=pos+1;\n\t\t}\n\t\tn=(n+1)/2;mx=(mx+1)/2;\n\t\tdp[0]=1;sum[0]=1;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tdp[i]=q(max(i-mx,0),i-1);\n\t\t\tsum[i]=add(sum[i-1],dp[i]);\n\t\t}\n\t\tfor(i=1;i<=mx;i++)\n\t\t{\n\t\t\tans=add(ans,mul(i<<1,dp[n-i]));\n\t\t}\n\t}\n\t//printf(\"n%d mx%d\\n\",n,mx);\n\t\n\t\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-03 17:07:09\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=2000010,mod=1000000007;\ni64 n,m,flag,l,Flag;\ni64 f[N],F[N],ans;\nchar s[N];\nnamespace std\n{\n\tint main()\n\t{\n\t\ti64 i,j,t;\n\t\tfor(i=1;i<=m;i++) if(s[i]!=s[1]) break;\n\t\tl=i-1;\n\t\tif(l%2==0) l++;\n\t\tfor(t=0;i<=m;i++)\n\t\t{\n\t\t\tif(s[i]==s[1]) t++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(t&1) l=min(l,t);\n\t\t\t\tt=0;\n\t\t\t}\n\t\t}\n\t\tn/=2,l=(l+1)/2;\n\t\treturn 0;\n\t}\n}\nint main()\n{\n\tn=read(); m=read();\n\tscanf(\"%s\",s+1);\n\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\tif(!flag)\n\t{\n\t\tf[0]=1; f[1]=1; f[2]=2;\n\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t\treturn 0;\n\t}\n\tfor(int i=1,j;i<=m;)\n\t\tif(s[i]==s[1])\n\t\t{\n\t\t\tj=i;\n\t\t\twhile(s[j]==s[1]) j++;\n\t\t\tif(j>n) break;\n\t\t\tif(!Flag) l=j-i+((j-i)%2==0);\n\t\t\telse if((j-i)&1) l=std::min(l,(i64)(j-i));\n\t\t\ti=j+1; Flag=1;\n\t\t}\n\t\telse i++;\n\tif(n&1){ printf(\"0\\n\"); return 0; }\n\tstd::main();\n//\tprintf(\"%d %d\\n\",int(n),int(l));\n\tf[0]=F[0]=1;\n\tfr(i,1,n)\n\t{\n\t\tf[i]=(F[i-1]+mod-(i-l-1>=0?F[i-l-1]:0))%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t}\n\tans=f[n];\n\tfr(i,1,l) ans=(ans+f[n-i]*(2*i-1))%mod;\n\tprintf(\"%d\\n\",int(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MOD = 1e9 + 7;\n\nvoid update(int& x, int a)\n{\n  x += a;\n  if (x >= MOD) {\n    x -= MOD;\n  }\n}\n\nint solve(int n, int m, const std::string& s)\n{\n  bool has_b = false;\n  int max_len = n;\n  for (int i = 0, len = 0; i < m; ++ i) {\n    if (i && s[i - 1] != s[i]) {\n      if (s[i - 1] == s[0]) {\n        max_len = std::min(max_len, len + 1);\n      }\n      len = 0;\n    }\n    has_b |= s[i] != s[0];\n    len ++;\n  }\n  std::vector<int> dp(n);\n  dp[0] = 1;\n  if (has_b) {\n    // <=> has A + has B + no consecutive B + len <= max_len\n    for (int i = 2, j = 0, sum = 0; i < n; i += 2) {\n      update(sum, dp[i - 2]);\n      if (i - j > max_len + 1) {\n        update(sum, MOD - dp[j]);\n        j += 2;\n      }\n      dp[i] = sum;\n    }\n    int result = 0;\n    for (int len = 2; len <= n && len - 1 <= max_len; len += 2) {\n      update(result, 1LL * len * dp[n - len] % MOD);\n    }\n    return result;\n  } else {\n    // AA...A <=> has A + no consecutive B\n    for (int i = 1, sum = 0; i < n; ++ i) {\n      if (i >= 2) {\n        update(sum, dp[i - 2]);\n      }\n      dp[i] = sum;\n    }\n    int result = 1; // no B\n    for (int len = 2; len <= n; ++ len) {\n      update(result, 1LL * len * dp[n - len] % MOD);\n    }\n    return result;\n  }\n}\n\nint main()\n{\n  int n, m;\n  while (std::cin >> n >> m) {\n    std::string s;\n    std::cin >> s;\n    std::cout << solve(n, m, s) << std::endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MAX_N 200000\n#define MAX_M 200000\n#define MOD 1000000007\n\n#define INF 1 << 29\n\nint N, M;\nstring S;\n\nlong long dp[MAX_N + 2], rdp[MAX_N + 2];\n\nint all_color_is_same()\n{\n    long long rr = 1, bb = 1, rb = 0, br = 0;\n\n    for ( int i = 1; i < N; i++ )\n    {\n        long long nrr = ( rr + rb ) % MOD;\n        long long nbb = br;\n        long long nrb = rr;\n        long long nbr = ( bb + br ) % MOD;\n\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n\n    return ( rr + rb + br ) % MOD;\n}\n\n/* S\nの先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n*/\nint min_freq()\n{\n    int l = 0;\n    while ( l < M && S[0] == S[l] ) l++;\n\n    int ans = ( l & 1 ) ? l : l + 1;\n\n    l = 0;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[0] == S[i] )\n            l++;\n        else\n        {\n            if ( l & 1 ) ans = min( ans, l );\n            l = 0;\n        }\n    }\n    return ans;\n    // int l = 0;\n    // while ( S[0] == S[l] ) l++;\n    // if ( l % 2 == 0 ) l++;\n    // int limit = l;\n    // l = 0;\n    // for ( int i = 0; i < M; i++ )\n    // {\n    //     if ( S[i] == S[0] )\n    //         l++;\n    //     else\n    //     {\n    //         if ( l % 2 == 1 ) limit = min( limit, l );\n    //         l = 0;\n    //     }\n    // }\n    // return limit;\n}\n\nint solve()\n{\n    // 一色\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n        return all_color_is_same();\n\n    // N が奇数\n    if ( N & 1 ) return 0;\n\n    int L = min_freq();\n\n    L = ( L + 1 ) >> 1;\n    N >>= 1;\n\n    dp[0] = rdp[0] = 1;\n    for ( int i = 1; i <= N + 1; i++ )\n    {\n        dp[i] = rdp[i - 1];\n        if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n\n    long long res = 0;\n    for ( int i = 1; i <= L; i++ )\n        if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n    return res % MOD;\n}\n\nint main( int argc, char **argv )\n{\n    cin >> N >> M;\n    cin >> S;\n\n    int ans = solve();\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\nusing namespace std;\n#define SIZE 262144\ntypedef long long ll;\nll mod = 1000000007;\nclass BIT\n{\npublic:\n\tll bit[SIZE + 1];\n\tvoid add(int a, ll b)\n\t{\n\t\ta+=120000;\n\t\tfor (;;)\n\t\t{\n\t\t\tbit[a] += b;\n\t\t\tbit[a] %= mod;\n\t\t\ta += a&-a;\n\t\t\tif (a > SIZE)return;\n\t\t}\n\t}\n\tll get(int a)\n\t{\n\t\ta+=120000;\n\t\tll ret = 0;\n\t\tfor (;;)\n\t\t{\n\t\t\tret += bit[a];\n\t\t\ta -= a&-a;\n\t\t\tif (a == 0)return ret%mod;\n\t\t}\n\t}\n};\nBIT bi;\nll dp[202020];\nll sub[2][202020][2];\nint main()\n{\n\tint num, len;\n\tscanf(\"%d%d\", &num, &len);\n\tstring s;\n\tcin >> s;\n\tif (s[0] == 'B')\n\t{\n\t\tfor (int i = 0; i < s.size(); i++)s[i] = 'R' + 'B' - s[i];\n\t}\n\tint mini = 1000000000, cnt = 0;\n\tbool ff = false;\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tif (s[i] == 'R')cnt++;\n\t\telse\n\t\t{\n\t\t\tif (!ff)\n\t\t\t{\n\t\t\t\tif (cnt % 2 == 0)mini = min(mini, cnt + 1);\n\t\t\t\telse mini = min(mini, cnt);\n\t\t\t\tff = true;\n\t\t\t}\n\t\t\telse if (cnt % 2 == 1)mini = min(mini, cnt);\n\t\t}\n\t}\n\tif (!ff)\n\t{\n\t\tsub[0][0][0] = sub[1][0][1] = 1;\n\t\tfor (int i = 0; i < 2; i++)\n\t\t{\n\t\t\tfor (int j = 1; j < num; j++)\n\t\t\t{\n\t\t\t\tsub[i][j][0] = (sub[i][j - 1][0] + sub[i][j - 1][1]) % mod;\n\t\t\t\tsub[i][j][1] = sub[i][j - 1][0];\n\t\t\t}\n\t\t}\n\t\tll r = sub[0][num - 1][0] + sub[0][num - 1][1] + sub[1][num - 1][0];\n\t\tprintf(\"%lld\\n\", r%mod);\n\t\tabort();\n\t\treturn 0;\n\t}\n\tif (num % 2 == 1)\n\t{\n\t\tprintf(\"0\\n\");\n\t\tfor (;;) { printf(\"a\\n\"); }\n\t\treturn 0;\n\t}\n\tmini = (mini + 1) / 2;\n\tnum /= 2;\n\tmini = min(mini, num);\n\tdp[0] = 1;\n\tbi.add(0, 1);\n\tfor (int i = 1; i <= num; i++)\n\t{\n\t\tdp[i] = (bi.get(i - 1) - bi.get(i - mini - 1) + mod) % mod;\n\t\tbi.add(i, dp[i]);\n\t\t//printf(\"%d %lld\\n\", i, dp[i]);\n\t}\n\tll r = 0;\n\tfor (int i = 1; i <= mini; i++)r = (r + dp[num - i] * i * 2) % mod;\n\tprintf(\"%lld\\n\", r);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 200100\n#define M 1000000007\nusing namespace std;\n\nll n,m,mx,ans,dp[N],qz[N];\nchar str[N];\n\ninline void Add(ll &u,ll v){u=(u+v)%M;}\nint main()\n{\n\tll i,j,t;\n\tcin>>n>>m;\n\tscanf(\"%s\",str+1);\n\tfor(i=1;i<=m;i++) if(str[i]!=str[1]) break;\n\tmx=i-1;\n\tif(mx==m)\n\t{\n\t\tdp[0]=qz[0]=ans=1;\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tif(i>=2) dp[i]=qz[i-2];\n\t\t\tqz[i]=(qz[i-1]+dp[i])%M;\n\t\t\tif(n-i>=2) Add(ans,dp[i]*(n-i)%M);\n\t\t}\n\t\tcout<<ans;\n\t\treturn 0;\n\t}\n\tif(n&1)\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tif(mx%2==0) mx++;\n\tfor(t=0;i<=m;i++)\n\t{\n\t\tif(str[i]==str[1]) t++;\n\t\telse\n\t\t{\n\t\t\tif(t&1) mx=min(mx,t);\n\t\t\tt=0;\n\t\t}\n\t}\n\tn/=2,mx=(mx+1)/2;\n\tdp[0]=qz[0]=1;\n\tfor(i=0;i<=n;i++)\n\t{\n\t\tif(i)\n\t\t{\n\t\t\tdp[i]=(M+qz[i-1]-(i-mx-1>=0?qz[i-mx-1]:0))%M;\n\t\t\tqz[i]=(qz[i-1]+dp[i])%M;\n\t\t}\n\t\tif(n-i<=mx) Add(ans,(n-i)*dp[i]*2%M);\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\n#define MAX_N 200000\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - inv[MOD % i] * (MOD / i);\n        fac[i] = fac[i-1] * i;\n        finv[i] = finv[i-1] * inv[i];\n    }\n}\n\nmod comb(int a, int b)\n{\n    if(a<b) return 0;\n    return fac[a] * finv[b] * finv[a-b];\n}\ntypedef pair<int, int> Pii;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\nll mod_pow(ll a, ll n, ll mod) { ll ret = 1; ll p = a % mod; while (n) { if (n & 1) ret = ret * p % mod; p = p * p % mod; n >>= 1; } return ret; }\n\ntemplate<int mod, int primitive_root>\nclass NTT {\npublic:\n\tint get_mod() const { return mod; }\n\tvoid _ntt(vector<ll>& a, int sign) {\n\t\tconst int n = sz(a);\n\t\tassert((n ^ (n&-n)) == 0); //n = 2^k\n\n\t\tconst int g = 3; //g is primitive root of mod\n\t\tint h = (int)mod_pow(g, (mod - 1) / n, mod); // h^n = 1\n\t\tif (sign == -1) h = (int)mod_inv(h, mod); //h = h^-1 % mod\n\n\t\t//bit reverse\n\t\tint i = 0;\n\t\tfor (int j = 1; j < n - 1; ++j) {\n\t\t\tfor (int k = n >> 1; k >(i ^= k); k >>= 1);\n\t\t\tif (j < i) swap(a[i], a[j]);\n\t\t}\n\n\t\tfor (int m = 1; m < n; m *= 2) {\n\t\t\tconst int m2 = 2 * m;\n\t\t\tconst ll base = mod_pow(h, n / m2, mod);\n\t\t\tll w = 1;\n\t\t\tFOR(x, m) {\n\t\t\t\tfor (int s = x; s < n; s += m2) {\n\t\t\t\t\tll u = a[s];\n\t\t\t\t\tll d = a[s + m] * w % mod;\n\t\t\t\t\ta[s] = u + d;\n\t\t\t\t\tif (a[s] >= mod) a[s] -= mod;\n\t\t\t\t\ta[s + m] = u - d;\n\t\t\t\t\tif (a[s + m] < 0) a[s + m] += mod;\n\t\t\t\t}\n\t\t\t\tw = w * base % mod;\n\t\t\t}\n\t\t}\n\n\t\tfor (auto& x : a) if (x < 0) x += mod;\n\t}\n\tvoid ntt(vector<ll>& input) {\n\t\t_ntt(input, 1);\n\t}\n\tvoid intt(vector<ll>& input) {\n\t\t_ntt(input, -1);\n\t\tconst int n_inv = mod_inv(sz(input), mod);\n\t\tfor (auto& x : input) x = x * n_inv % mod;\n\t}\n\n\t// 畳み込み演算を行う\n\tvector<ll> convolution(const vector<ll>& a, const vector<ll>& b){\n\t\tint ntt_size = 1;\n\t\twhile (ntt_size < sz(a) + sz(b)) ntt_size *= 2;\n\n\t\tvector<ll> _a = a, _b = b;\n\t\t_a.resize(ntt_size); _b.resize(ntt_size);\n\n\t\tntt(_a);\n\t\tntt(_b);\n\n\t\tFOR(i, ntt_size){\n\t\t\t(_a[i] *= _b[i]) %= mod;\n\t\t}\n\n\t\tintt(_a);\n\t\treturn _a;\n\t}\n};\n\nll garner(vector<Pii> mr, int mod){\n\tmr.emplace_back(mod, 0);\n\n\tvector<ll> coffs(sz(mr), 1);\n\tvector<ll> constants(sz(mr), 0);\n\tFOR(i, sz(mr) - 1){\n\t\t// coffs[i] * v + constants[i] == mr[i].second (mod mr[i].first) を解く\n\t\tll v = (mr[i].second - constants[i]) * mod_inv<ll>(coffs[i], mr[i].first) % mr[i].first;\n\t\tif (v < 0) v += mr[i].first;\n\n\t\tfor (int j = i + 1; j < sz(mr); j++) {\n\t\t\t(constants[j] += coffs[j] * v) %= mr[j].first;\n\t\t\t(coffs[j] *= mr[i].first) %= mr[j].first;\n\t\t}\n\t}\n\n\treturn constants[sz(mr) - 1];\n}\n\ntypedef NTT<167772161, 3> NTT_1;\ntypedef NTT<469762049, 3> NTT_2;\ntypedef NTT<1224736769, 3> NTT_3;\n\n//任意のmodで畳み込み演算 O(n log n)\nvector<ll> int32mod_convolution(vector<ll> a, vector<ll> b,int mod){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\tvector<ll> ret(sz(x));\n\tvector<Pii> mr(3);\n\tFOR(i, sz(x)){\n\t\tmr[0].first = ntt1.get_mod(), mr[0].second = (int)x[i];\n\t\tmr[1].first = ntt2.get_mod(), mr[1].second = (int)y[i];\n\t\tmr[2].first = ntt3.get_mod(), mr[2].second = (int)z[i];\n\t\tret[i] = garner(mr, mod);\n\t}\n\n\treturn ret;\n}\n\n// garnerのアルゴリズムを直書きしたversion，速い\nvector<ll> fast_int32mod_convolution(vector<ll> a, vector<ll> b,int mod){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\t\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tassert(ntt1.get_mod() < ntt2.get_mod() && ntt2.get_mod() < ntt3.get_mod());\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\t// garnerのアルゴリズムを極力高速化した\n\tconst ll m1 = ntt1.get_mod(), m2 = ntt2.get_mod(), m3 = ntt3.get_mod();\n\tconst ll m1_inv_m2 = mod_inv<ll>(m1, m2);\n\tconst ll m12_inv_m3 = mod_inv<ll>(m1 * m2, m3);\n\tconst ll m12_mod = m1 * m2 % mod;\n\tvector<ll> ret(sz(x));\n\tFOR(i, sz(x)){\n\t\tll v1 = (y[i] - x[i]) *  m1_inv_m2 % m2;\n\t\tif (v1 < 0) v1 += m2;\n\t\tll v2 = (z[i] - (x[i] + m1 * v1) % m3) * m12_inv_m3 % m3;\n\t\tif (v2 < 0) v2 += m3;\n\t\tll constants3 = (x[i] + m1 * v1 + m12_mod * v2) % mod;\n\t\tif (constants3 < 0) constants3 += mod;\n\t\tret[i] = constants3;\n\t}\n\n\treturn ret;\n}\n\n\nunsigned int add(const unsigned int x, const unsigned int y)\n{\n    return (x + y < MOD) ? x + y : x + y - MOD;\n}\n \nunsigned int sub(const unsigned int x, const unsigned int y)\n{\n    return (x >= y) ? (x - y) : (MOD - y + x);\n}\n \nunsigned int mul(const unsigned int x, const unsigned int y)\n{\n    return (unsigned long long)x * y % MOD;\n}\n \nunsigned int mod_pow(unsigned int x, unsigned int n)\n{\n    unsigned int res = 1;\n    while(n > 0){\n        if(n & 1){ res = mul(res, x); }\n        x = mul(x, x);\n        n >>= 1;\n    }\n    return res;\n}\n \nunsigned int inverse(const unsigned int x)\n{\n    return mod_pow(x, MOD - 2);\n}\n \nvector<ll> polynomial_inverse(const vector<ll>& a, int r)\n{\n    assert(a[0] != 0);\n    vector<ll> h = {(ll)inverse(a[0])};\n    int t = 1;\n    vector<ll> b;\n    int id =  0;\n    for(int i = 0; t < r; ++i){\n    \n        t <<= 1;\n        // vector<ll> tmp = int32mod_convolution(h, h, MOD);\n        while(id<min((int)a.size(),t)){\n            b.push_back(a[id]);\n            id++;\n        }\n        vector<ll> res = fast_int32mod_convolution(b, fast_int32mod_convolution(h, h, MOD), MOD);\n        res.resize(t);\n        for(int j = 0; j < t; ++j){\n            res[j] = sub(0, res[j]);\n            if(j < t / 2) res[j] = add(res[j], mul(2, h[j]));\n        }\n        swap(h, res);\n    }\n    h.resize(r);\n    return h;\n}\n\nmod dp[200010][2][2];\nint main(){\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if(s[0]=='R'){\n        rep(i,m){\n            if(s[i]=='R'){\n                s[i] ='B';\n            }else{\n                s[i] ='R'; \n            }\n        }\n    }\n    int a = inf;\n    int c = 0;\n    rep(i,m){\n        if(s[i]=='B'){\n            c++;\n        }else{\n            chmin(a,c);    \n        }\n    }\n    if(a==inf){\n        dp[0][0][0] = 1;\n        dp[0][1][1] = 1;\n        for(int i=1;i<n;i++){\n            for(int j=0;j<2;j++){\n                if(j==0){\n                    dp[i][j][0] += dp[i-1][1][0];\n                    dp[i][j][1] += dp[i-1][1][1];\n                }else{\n                    dp[i][j][0] += dp[i-1][1][0] + dp[i-1][0][0];\n                    dp[i][j][1] += dp[i-1][1][1] + dp[i-1][0][1];    \n                }\n            }\n        }\n        cout << dp[n-1][1][0] + dp[n-1][1][1] + dp[n-1][1][0] << endl;\n    }else{\n        int len = (a/2)*2+1;\n        //cerr << len << endl;\n        vector<ll> X(n+1),Y(n+1);\n        len++;\n        for(int i=2;i<=len;i+=2){\n            X[i] = i;\n        }\n        Y[0] = 1;\n        for(int i=2;i<=len;i+=2){\n            Y[i] = MOD-1;\n        }\n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        Y =polynomial_inverse(Y,n+1);\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        X = fast_int32mod_convolution(X,Y,MOD);\n        \n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        cout << X[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nconst int mo=1000000007;\nconst int N=200005;\nint n,m;\nchar s[N];\nint f[N][2][2];\nvoid solve1(){\n\tf[1][0][0]=f[1][1][1]=1;\n\tFor(i,2,n) For(j,0,1) For(k,0,1) For(l,0,1)\n\t\tif (k|l) f[i][j][l]=(f[i][j][l]+f[i-1][j][k])%mo;\n\tint ans=0;\n\tFor(i,0,1) For(j,0,1)\n\t\tif (i|j) ans=(ans+f[n][i][j])%mo;\n\tprintf(\"%d\\n\",ans);\n}\nint pre[N];\nint g[N],h[N];\nvoid solve2(){\n\tpre[1]=1;\n\tint mnv=(1<<30);\n\tFor(i,2,m)\n\t\tpre[i]=(s[i]==s[i-1]?pre[i-1]:0)+1;\n\tFor(i,2,m+1) if (s[i-1]=='R'&&s[i]!='R')\n\t\tif (pre[i-1]%2==0) mnv=min(mnv,pre[i-1]+1);\n\t\telse mnv=min(mnv,pre[i-1]);\n\tg[0]=h[0]=1;\n\tFor(i,1,n){\n\t\tg[i]=((i>=2?h[i-2]:0)+mo-(i>=mnv+3?h[i-mnv-3]:0))%mo;\n\t\th[i]=(g[i]+(i>=2?h[i-2]:0))%mo;\n\t}\n\tint ans=0;\n\tfor (int i=2;i<=min(mnv+1,n);i++)\n\t\tans=(ans+1ll*i*g[n-i])%mo;\n\tprintf(\"%d\\n\",ans);\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tif (s[1]=='B'){\n\t\tFor(i,1,m)\n\t\t\tif (s[i]=='R') s[i]='B';\n\t\t\telse s[i]='R';\n\t}\n\tbool flag=0;\n\tFor(i,1,m) if (s[i]!=s[1]) flag=1;\n\tif (!flag) return solve1(),0;\n\tsolve2();\n}\n/*\n偶数个R||B回到该端点 \n奇数个R||B到达另一端点\n\nRBRBRBRBRB\n\n一段长度为奇数的开头字母 \n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#pragma warning (disable: 4996)\n\n// 入力\nlong long mod = 1000000007;\nlong long N, M;\nstring S;\n\n// その他\nlong long fib[1 << 19];\nlong long dp[1 << 19], ru[1 << 19];\nlong long ret[1 << 19];\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 32; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nlong long Div(long long p, long long q, long long m) {\n\treturn (p * modpow(q, m - 2, m)) % m;\n}\n\nlong long solve(long long n, long long r) {\n\tfor (int i = 0; i <= N; i++) dp[i] = 0;\n\tfor (int i = 0; i <= N; i++) ru[i] = 0;\n\tfor (int i = 1; i <= r / 2; i++) dp[i] = 1LL * (i * 2);\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tlong long v = ru[i - 1]; if (i - (r / 2) - 1 >= 0) v -= ru[i - (r / 2) - 1];\n\t\tv = (v + mod) % mod;\n\t\tdp[i] += v; dp[i] %= mod;\n\t\tru[i] = (dp[i] + ru[i - 1]) % mod;\n\t}\n\t\n\tlong long val = dp[n / 2];\n\treturn val;\n}\n\nint main() {\n\tcin >> N >> M >> S;\n\n\t// 判定\n\tbool flag = false;\n\tfor (int i = 0; i < S.size() - 1; i++) {\n\t\tif (S[i] != S[i + 1]) flag = true;\n\t}\n\n\t// 特殊\n\tif (flag == false) {\n\t\tfib[0] = 1;\n\t\tfib[1] = 1;\n\t\tfor (int i = 2; i <= N; i++) fib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t\tcout << (fib[N] + fib[N - 2]) % mod << endl;\n\t\treturn 0;\n\t}\n\n\t// 奇数\n\tif (N % 2 == 1) {\n\t\tcout << \"0\" << endl;\n\t\treturn 0;\n\t}\n\n\t// 偶数\n\tif (S[0] == 'B') {\n\t\tfor (int i = 0; i < S.size(); i++) {\n\t\t\tif (S[i] == 'B') S[i] = 'R';\n\t\t\telse S[i] = 'B';\n\t\t}\n\t}\n\tint MaxLength = N, cur = 0, cnt = 0;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] == 'R') cur++;\n\t\telse {\n\t\t\tif (cnt == 0) {\n\t\t\t\tMaxLength = min(MaxLength, cur);\n\t\t\t}\n\t\t\telse if (MaxLength % 2 == 1) {\n\t\t\t\tMaxLength = min(MaxLength, cur);\n\t\t\t}\n\t\t\tcur = 0; cnt++;\n\t\t}\n\t}\n\tMaxLength += 2;\n\n\tvector<long long> E;\n\tfor (int i = 1; i <= N / 2; i++) {\n\t\tif ((N / 2) % i == 0) E.push_back(i);\n\t}\n\tfor (int i = E.size() - 1; i >= 0; i--) {\n\t\tlong long d1 = (N / E[i]);\n\t\tlong long d2 = MaxLength;\n\t\tret[i] = solve(d1, d2);\n\t\tfor (int j = i + 1; j < E.size(); j++) {\n\t\t\tif (E[j] % E[i] == 0) { ret[i] -= ret[j]; ret[i] = (ret[i] + mod) % mod; }\n\t\t}\n\t}\n\n\tlong long FinalAns = 0;\n\tfor (int i = 0; i < E.size(); i++) {\n\t\tFinalAns += 1LL * ret[i];\n\t\tFinalAns %= mod;\n\t}\n\tcout << FinalAns << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\n#include<cassert>\nusing namespace std;\nusing lint = long long;\nusing ld = long double;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(lint i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nint n, m;\nstring s;\n\nvoid allred() {\n\tlint v1 = 0, v2 = 0;\n\tlint ans = 0;\n\tv1 = 1;\n\tREP(i, n - 1) {\n\t\tlint nv1 = (v1 + v2) % MOD;\n\t\tlint nv2 = v1;\n\t\tv1 = nv1;\n\t\tv2 = nv2;\n\t}\n\tans += (v1 + v2) % MOD;\n\tv1 = 0; v2 = 1;\n\tREP(i, n - 1) {\n\t\tlint nv1 = (v1 + v2) % MOD;\n\t\tlint nv2 = v1;\n\t\tv1 = nv1;\n\t\tv2 = nv2;\n\t}\n\tans += v1;\n\tcout << (ans % MOD + MOD) % MOD << endl;\n\treturn;\n}\n\nvoid solve(vector<int> suc_red, int omn) {\n\tint th = omn;\n\tif(suc_red[0] % 2 == 0) th = min(th, suc_red[0] + 1);\n\tlint ans = 0;\n\t/*\n\tif((n - 1) % 2 && (n - 1) <= th) {\n\t\tans += n;\n\t}*/\n\tvector<lint> dpr(n), dpb(n);\n\tdpr[0] = 0;\n\tdpb[0] = 1;\n\tqueue<lint> q0;\n\tqueue<lint> q1;\n\tlint sum0 = 1, sum1 = 0;\n\tq0.push(1);\n\tFOR(i, 1, n) {\n\t\tif(i % 2 == 1) {\n\t\t\twhile(!q0.empty() && (int)q0.size() > (th + 1) / 2) {\n\t\t\t\tsum0 -= q0.front(); sum0 %= MOD;\n\t\t\t\tq0.pop();\n\t\t\t}\n\t\t\tdpr[i] = sum0;\n\t\t} else {\n\t\t\twhile(!q1.empty() && (int)q1.size() > (th + 1) / 2) {\n\t\t\t\tsum1 -= q1.front(); sum1 %= MOD;\n\t\t\t\tq1.pop();\n\t\t\t}\n\t\t\tdpr[i] = sum1;\n\t\t}\n\t\tdpb[i] = dpr[i - 1];\n\t\tif(i % 2 == 0) {\n\t\t\tq0.push(dpb[i]);\n\t\t\tsum0 += dpb[i]; sum0 %= MOD;\n\t\t} else {\n\t\t\tq1.push(dpb[i]);\n\t\t\tsum1 += dpb[i]; sum1 %= MOD;\n\t\t}\n\t}\n\tFOR(i, 1, n) {\n\t\tif(i > th) break;\n\t\tans += dpb[n - 1 - i] * i;\n\t\tans %= MOD;\n\t}\n\tans += dpr[n - 1]; ans %= MOD;\n\tcout << (ans % MOD + MOD) % MOD << endl;\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> m;\n\tcin >> s;\n\tif(s[0] == 'B') {\n\t\tREP(i, m) {\n\t\t\tif(s[i] == 'B') s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\n\tvector<int> suc_red;\n\tint c = 0;\n\tREP(i, m) {\n\t\tif(s[i] == 'R') c++;\n\t\telse {\n\t\t\tif(c != 0) suc_red.pb(c);\n\t\t\tc = 0;\n\t\t}\n\t}\n\tif(c != 0) suc_red.pb(c);\n\n\tif(suc_red[0] == m) {\n\t\tallred();\n\t\treturn 0;\n\t}\n\n\tint omn = INF;\n\tint roopmx = (int)suc_red.size();\n\tif(s[m - 1] == 'R') roopmx--;\n\tREP(i, roopmx) {\n\t\tif(suc_red[i] % 2) omn = min(omn, suc_red[i]);\n\t}\n\tsolve(suc_red, omn);\n\treturn 0;\n}\n/* --------------------------------------- */\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MAX_N 200000\n#define MAX_M 200000\n#define MOD 1000000007\n\n#define INF 0x3f3f3f3f\n\nint N, M;\nstring S;\n\nlong dp[MAX_N + 1], rdp[MAX_N + 1];\n\nint all_color_is_same()\n{\n    int rr = 1, bb = 1, rb = 0, br = 0;\n\n    for ( int i = 1; i < N; i++ )\n    {\n        int nrr = ( rr + rb ) % MOD;\n        int nbb = br;\n        int nrb = rr;\n        int nbr = ( bb + br ) % MOD;\n\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n\n    return ( rr + rb + br ) % MOD;\n}\n\n/**\n * S の先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n */\nint min_freq()\n{\n    int l = 0;\n    while ( l < M && S[0] == S[l] ) l++;\n\n    int ans = ( l & 1 ) ? l : l + 1;\n\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[0] == S[i] )\n            l++;\n        else if ( l & 1 )\n        {\n            ans = min( ans, l );\n            l = 0;\n        }\n    }\n    return l ? min( ans, l ) : ans;\n}\n\nint solve()\n{\n    // 一色\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n        return all_color_is_same();\n\n    // N が奇数\n    if ( N & 1 ) return 0;\n\n    int L = min_freq();\n\n    L = ( L + 1 ) >> 1;\n    N >>= 1;\n\n    dp[0] = rdp[0] = 1;\n    for ( int i = 1; i <= N + 1; i++ )\n    {\n        dp[i] = rdp[i - 1];\n        if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n\n    int res = 0;\n    for ( int i = 1; i <= L; i++ )\n        if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n    return res % MOD;\n}\n\nint main( int argc, char **argv )\n{\n    cin >> N >> M;\n    cin >> S;\n\n    int ans = solve();\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nll dp[1 << 18][2][2];\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (s[0] == 'B') {\n\t\trep(i, m) {\n\t\t\tif (s[i] == 'B')s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\tvector<int> v;\n\trep(i, m) {\n\t\tint le = i;\n\t\twhile (i + 1 < m&&s[i + 1] == s[i])i++;\n\t\tv.push_back(i - le + 1);\n\t}\n\tif (v.size() == 1) {\n\t\tdp[0][0][0] = 1;\n\t\tdp[0][1][1] = 1;\n\t\trep(i, n-1) {\n\t\t\trep(j, 2) {\n\t\t\t\t(dp[i + 1][0][j] += dp[i][0][j] + dp[i][1][j])%=mod;\n\t\t\t\tdp[i + 1][1][j] += dp[i][0][j];\n\t\t\t}\n\t\t}\n\t\tll ans = dp[n-1][0][0] + dp[n-1][1][0] + dp[n-1][0][1];\n\t\tcout << ans % mod << endl; return;\n\t}\n\tif (n % 2) {\n\t\tcout << 0 << endl; return;\n\t}\n\tfor (int i = 0; i < v.size(); i += 2) {\n\t\tif (v[i] % 2) {\n\t\t\tif (n % 2) {\n\t\t\t\tcout << 0 << endl; return;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << 2 << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tint d = n / 2;\n\tint x = v[0] / 2+1;\n\tif (x >= d) {\n\t\tll ans = mod_pow(2, d) - 1;\n\t\tans = ans * 2;\n\t\tans = (ans + mod) % mod;\n\t\tcout << ans << endl;\n\t}\n\telse {\n\t\tll ans = d * mod_pow(2, d -x-1)%mod;\n\t\t\n\t\tans = mod_pow(2, d) - 1 - ans;\n\t\tans = (ans%mod + mod) % mod;\n\t\tcout << ans*2%mod << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXCYCLEN=200000;\nconst int MAXSLEN=200000;\nconst int MOD=1000000007;\nvoid inc(int &a,int b) { if((a+=b)>=MOD) a-=MOD; }\n\nint cyclen,slen;\nchar s[MAXSLEN+1];\n\nint dp[MAXCYCLEN+1];\nint dpsum[MAXCYCLEN+1];\n\nint calcunlim() {\n\tmemset(dp,0,sizeof(dp));\n\tdp[0]=dpsum[0]=1;\n\tFORE(i,1,cyclen) {\n\t\tif(i>=2) inc(dp[i],dpsum[i-2]);\n\t\tdpsum[i]=dp[i]; if(i-1>=0) inc(dpsum[i],dpsum[i-1]);\n\t}\n\tint ret=1;\n\tinc(ret,dp[cyclen]);\n\tfor(int j=1;j+1<=cyclen;++j) inc(ret,(ll)j*dp[cyclen-(j+1)]%MOD);\n\treturn ret;\n}\n\nint calclim(int lim) {\n\t//printf(\"lim=%d\\n\",lim);\n\tmemset(dp,0,sizeof(dp));\n\tdp[0]=dpsum[0]=1;\n\tFORE(i,1,cyclen) {\n\t\tif(i%2==0) {\n\t\t\t// dp[i]+=dp[i-2]+dp[i-4]...+dp[i-(lim+1)]\n\t\t\tinc(dp[i],dpsum[i-2]);\n\t\t\tif(i-(lim+1)-2>=0) inc(dp[i],MOD-dpsum[i-(lim+1)-2]);\n\t\t\t//for(int j=1;j<=lim;j+=2) if(j+1<=i) inc(dp[i],dp[i-(j+1)]);\n\t\t}\n\t\tdpsum[i]=dp[i]; if(i-2>=0) inc(dpsum[i],dpsum[i-2]);\n\t}\n\t//printf(\"dp:\"); REPE(i,cyclen) printf(\" %d\",dp[i]); puts(\"\");\n\tint ret=dp[cyclen];\n\n\tfor(int j=1;j<=lim&&j+1<=cyclen;j+=2) inc(ret,(ll)j*dp[cyclen-(j+1)]%MOD);\n\t//FORE(k,1,lim) FORE(j,k,lim) if(j+1<=cyclen&&j%2==1) inc(ret,dp[cyclen-(j+1)]);\n\treturn ret;\n}\n\nint solve() {\n\tif(s[0]=='B') REP(i,slen) s[i]=s[i]=='B'?'R':'B';\n\tvector<int> seglen;\n\tfor(int l=0,r=l;l<slen;l=r) {\n\t\twhile(r<slen&&s[r]==s[l]) ++r;\n\t\tif(s[l]=='R'&&r<slen) seglen.PB(r-l);\n\t}\n\t//printf(\"seglen:\"); REPSZ(i,seglen) printf(\" %d\",seglen[i]); puts(\"\");\n\tif(SZ(seglen)==0) return calcunlim();\n\tint lim=INT_MAX;\n\tif(seglen[0]%2==0) lim=min(lim,seglen[0]+1); else lim=min(lim,seglen[0]);\n\tFORSZ(i,1,seglen) if(seglen[i]%2==1) lim=min(lim,seglen[i]);\n\treturn calclim(lim);\n}\n\nvoid run() {\n\tscanf(\"%d%d\",&cyclen,&slen);\n\tscanf(\"%s\",s);\n\tprintf(\"%d\\n\",solve());\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // clang-format off\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define in2(s,t)     rep(i,sz(s)){in(s[i] , t[i]);}\n#define in3(s,t,u)   rep(i,sz(s)){in(s[i] , t[i] , u[i]);}\n#define in4(s,t,u,v) rep(i,sz(s)){in(s[i] , t[i] , u[i] , v[i]);}\n#ifdef ONLINE_JUDGE\n  #define rep(i,N) for(int i = 0; i < (int)(N); i++)\n  #define repr(i,N) for(int i = (int)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(int i = 1; i <= (int)(N) ; i++)\n  #define repr1(i,N) for(int i = (N) ; (int)(i) > 0 ; i--)\n#else\n  #define rep(i,N) for(long long i = 0; i < (long long)(N); i++)\n  #define repr(i,N) for(long long i = (long long)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(long long i = 1; i <= (long long)(N) ; i++)\n  #define repr1(i,N) for(long long i = (N) ; (long long)(i) > 0 ; i--)\n#endif\nusing namespace std; void solve();\nusing ll = long long; template<class T = ll> using V = vector<T>;\nusing vi = V<int>; using vl = V<>; using vvi = V< V<int> >;\nusing vd = V<double>; using vs = V<string>; using vvl = V< V<> >;\nconstexpr int inf = 1001001001; constexpr ll infLL = (1LL << 61) - 1;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T,typename U>ll ceil(T a,U b){return (a + b - 1) / b;}\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); for(int i=0;i<s;i++) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);} while(0)\n  #define trcc(v) do { cerr << \"name : \" << #v << \"\\n\"; int cnt = 0; each(x , v){cerr << (cnt++) << \" : \"; trc(x); } } while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  #define trcc(...)\n  int main(){solve();}\n#endif\n\nconstexpr ll TEN(int n){ll ret=1,x=10;while(n){if(n&1)ret*=x;x*=x;n>>=1;}return ret;}\n#define mem(a, val) memset(a, val, sizeof(a))\n\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\nusing P = pair<ll,ll>; using vp = V<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n// clang-format on\n////////////////////////////////////////////////////\n\n\nvector<pair<char,int>> RunLengthEncoding(string& S){\n  vector<pair<char,int>> ret;\n  char c = -1;\n  int n = 0;\n  for(char x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate<typename T>\nvector<pair<T,int>> RunLengthEncoding(vector<T>& S){\n  vector<pair<T,int>> ret;\n  T c = -1;\n  int n = 0;\n  for(T& x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\nusing mint = modint;\n\nnamespace FastFourierTransform {\n  using real = double;\n\n  struct C {\n    real x, y;\n\n    C() : x(0), y(0) {}\n\n    C(real x, real y) : x(x), y(y) {}\n\n    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }\n\n    inline C conj() const { return C(x, -y); }\n  };\n\n  const real PI = acosl(-1);\n  int base = 1;\n  vector< C > rts = { {0, 0},\n                     {1, 0} };\n  vector< int > rev = {0, 1};\n\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    while(base < nbase) {\n      real angle = PI * 2.0 / (1 << (base + 1));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        real angle_i = angle * (2 * i + 1 - (1 << base));\n        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n      }\n      ++base;\n    }\n  }\n\n  void fft(vector< C > &a, int n) {\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          C z = a[i + j + k] * rts[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n  }\n\n  vector< int64_t > multiply(const vector< int > &a, const vector< int > &b) {\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = C(x, y);\n    }\n    fft(fa, sz);\n    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n      fa[i] = z;\n    }\n    for(int i = 0; i < (sz >> 1); i++) {\n      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n      fa[i] = A0 + A1 * s;\n    }\n    fft(fa, sz >> 1);\n    vector< int64_t > ret(need);\n    for(int i = 0; i < need; i++) {\n      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n    }\n    return ret;\n  }\n};\n\ntemplate< typename T >\nstruct ArbitraryModConvolution {\n  using real = FastFourierTransform::real;\n  using C = FastFourierTransform::C;\n\n  ArbitraryModConvolution() = default;\n\n  vector< T > multiply(const vector< T > &a, const vector< T > &b, int need = -1) {\n    if(need == -1) need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while((1 << nbase) < need) nbase++;\n    FastFourierTransform::ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < (int)a.size(); i++) {\n      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);\n    }\n    fft(fa, sz);\n    vector< C > fb(sz);\n    if(a == b) {\n      fb = fa;\n    } else {\n      for(int i = 0; i < (int)b.size(); i++) {\n        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);\n      }\n      fft(fb, sz);\n    }\n    real ratio = 0.25 / sz;\n    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C a1 = (fa[i] + fa[j].conj());\n      C a2 = (fa[i] - fa[j].conj()) * r2;\n      C b1 = (fb[i] + fb[j].conj()) * r3;\n      C b2 = (fb[i] - fb[j].conj()) * r4;\n      if(i != j) {\n        C c1 = (fa[j] + fa[i].conj());\n        C c2 = (fa[j] - fa[i].conj()) * r2;\n        C d1 = (fb[j] + fb[i].conj()) * r3;\n        C d2 = (fb[j] - fb[i].conj()) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector< T > ret(need);\n    for(int i = 0; i < need; i++) {\n      int64_t aa = llround(fa[i].x);\n      int64_t bb = llround(fb[i].x);\n      int64_t cc = llround(fa[i].y);\n      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;\n      ret[i] = aa + (bb << 15) + (cc << 30);\n    }\n    return ret;\n  }\n};\n\ntemplate< int mod >\nstruct NumberTheoreticTransform {\n\n  int base, max_base, root;\n  vector< int > rev, rts;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while(tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while(n > 0) {\n      if(n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) {\n    return mod_pow(x, mod - 2);\n  }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long) mod;\n  }\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while(base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n\n  void ntt(vector< int > &a) {\n    const int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n\n  vector< int > multiply(vector< int > a, vector< int > b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for(int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n\n  vector<modint> multiply_for_fps(const vector<modint> &a,const vector<modint> &b){\n    vector<int> A(a.size()) , B(b.size());\n    for(int i = 0;i < (int)a.size(); i++) A[i] = a[i].x;\n    for(int i = 0;i < (int)b.size(); i++) B[i] = b[i].x;\n    auto C = multiply( A , B );\n    vector<modint> ret(C.size());\n    for(int i = 0; i < (int)C.size() ;i++) ret[i].x = C[i];\n    return ret;\n  }\n};\n\n\ntemplate< typename T >\nstruct FormalPowerSeries : vector< T > {\n  using vector< T >::vector;\n  using P = FormalPowerSeries;\n\n  using MULT = function< P(P, P) >;\n\n  static MULT &get_mult() {\n    static MULT mult = nullptr;\n    return mult;\n  }\n\n  static void set_fft(MULT f) {\n    get_mult() = f;\n  }\n\n  void shrink() {\n    while(this->size() && this->back() == T(0)) this->pop_back();\n  }\n\n  P operator+(const P &r) const { return P(*this) += r; }\n\n  P operator+(const T &v) const { return P(*this) += v; }\n\n  P operator-(const P &r) const { return P(*this) -= r; }\n\n  P operator-(const T &v) const { return P(*this) -= v; }\n\n  P operator*(const P &r) const { return P(*this) *= r; }\n\n  P operator*(const T &v) const { return P(*this) *= v; }\n\n  P operator/(const P &r) const { return P(*this) /= r; }\n\n  P operator%(const P &r) const { return P(*this) %= r; }\n\n  P &operator+=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] += r[i];\n    return *this;\n  }\n\n  P &operator+=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] += r;\n    return *this;\n  }\n\n  P &operator-=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] -= r[i];\n    shrink();\n    return *this;\n  }\n\n  P &operator-=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] -= r;\n    shrink();\n    return *this;\n  }\n\n  P &operator*=(const T &v) {\n    const int n = (int) this->size();\n    for(int k = 0; k < n; k++) (*this)[k] *= v;\n    return *this;\n  }\n\n  P &operator*=(const P &r) {\n    if(this->empty() || r.empty()) {\n      this->clear();\n      return *this;\n    }\n    assert(get_mult() != nullptr);\n    return *this = get_mult()(*this, r);\n  }\n\n  P &operator%=(const P &r) {\n    return *this -= *this / r * r;\n  }\n\n  P operator-() const {\n    P ret(this->size());\n    for(int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];\n    return ret;\n  }\n\n  P &operator/=(const P &r) {\n    if(this->size() < r.size()) {\n      this->clear();\n      return *this;\n    }\n    int n = this->size() - r.size() + 1;\n    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);\n  }\n\n  P pre(int sz) const {\n    return P(begin(*this), begin(*this) + min((int) this->size(), sz));\n  }\n\n  P operator>>(int sz) const {\n    if(this->size() <= sz) return {};\n    P ret(*this);\n    ret.erase(ret.begin(), ret.begin() + sz);\n    return ret;\n  }\n\n  P operator<<(int sz) const {\n    P ret(*this);\n    ret.insert(ret.begin(), sz, T(0));\n    return ret;\n  }\n\n  P rev(int deg = -1) const {\n    P ret(*this);\n    if(deg != -1) ret.resize(deg, T(0));\n    reverse(begin(ret), end(ret));\n    return ret;\n  }\n\n  P diff() const {\n    const int n = (int) this->size();\n    P ret(max(0, n - 1));\n    for(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);\n    return ret;\n  }\n\n  P integral() const {\n    const int n = (int) this->size();\n    P ret(n + 1);\n    ret[0] = T(0);\n    for(int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);\n    return ret;\n  }\n\n  // F(0) must not be 0\n  P inv(int deg = -1) const {\n    assert(((*this)[0]) != T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1) / (*this)[0]});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 1\n  P log(int deg = -1) const {\n    assert((*this)[0] == 1);\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();\n  }\n\n  P sqrt(int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n\n    if((*this)[0] == T(0)) {\n      for(int i = 1; i < n; i++) {\n        if((*this)[i] != T(0)) {\n          if(i & 1) return {};\n          if(deg - i / 2 <= 0) break;\n          auto ret = (*this >> i).sqrt(deg - i / 2) << (i / 2);\n          if(ret.size() < deg) ret.resize(deg, T(0));\n          return ret;\n        }\n      }\n      return P(deg, 0);\n    }\n\n    P ret({T(1)});\n    T inv2 = T(1) / T(2);\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 0\n  P exp(int deg = -1) const {\n    assert((*this)[0] == T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1)});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  P pow(int64_t k, int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    for(int i = 0; i < n; i++) {\n      if((*this)[i] != T(0)) {\n        T rev = T(1) / (*this)[i];\n        P C(*this * rev);\n        P D(n - i);\n        for(int j = i; j < n; j++) D[j - i] = C[j];\n        D = (D.log() * k).exp() * (*this)[i].pow(k);\n        P E(deg);\n        if(i * k > deg) return E;\n        auto S = i * k;\n        for(int j = 0; j + S < deg && j < D.size(); j++) E[j + S] = D[j];\n        return E;\n      }\n    }\n    return *this;\n  }\n\n  T eval(T x) const {\n    T r = 0, w = 1;\n    for(auto &v : *this) {\n      r += w * v;\n      w *= x;\n    }\n    return r;\n  }\n};\n\nusing FPS = FormalPowerSeries< modint >;\n\n// fにa * x^n + bを掛ける\nvoid mul_simple(FPS &f,modint a ,int n, modint b){\n  for(int i = (int)f.size() - 1 ; i >= 0 ; i--){\n    f[i] *= b;\n    if(i >= n) f[i] += f[i - n] * a; \n  }\n}\n\n// fからa * x^n + bを割る\nvoid div_simple(FPS &f,modint a,int n,modint b){\n  for(int i = 0 ; i < (int)f.size() ; i++){\n    f[i] /= b;\n    if(i + n < (int)f.size() ) f[n + i] -= f[i] * a; \n  }\n}\n\n// f / gをdeg(f)次まで求める\nFPS div_(FPS &f , FPS g){\n  int n = f.size();\n  return (f * g.inv(n)).pre(n);\n}\n\n\n// solve関数内で\n//\n// FPS::set_fft(mul);\n//\n// とすること。\n\n/**\nNumberTheoreticTransform<MOD> ntt;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret =ntt.multiply_for_fps(a , b);\n  return FPS::P(ret.begin(), ret.end());\n};\n/*///\nArbitraryModConvolution< modint > fft;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret = fft.multiply(a, b);\n  return FPS::P(ret.begin(), ret.end());\n};\n//*/\n\n// 下記のリンクを実装(kitamasa法のモンゴメリ乗算を使わない版)\n// http://q.c.titech.ac.jp/docs/progs/polynomial_division.html\n// k項間漸化式のa_Nを求める O(k log k log N)\n// N ... 求めたい項　(0-indexed)\n// Q ... 漸化式 (1 - \\sum_i c_i x^i)の形\n// a ... 初期解 (a_0 , a_1 , ... , a_k-1)\n// x^N を fでわった剰余を求め、aと内積を取る\nmodint kitamasa(ll N, FPS &Q, FPS &a){\n  int k = Q.size() - 1;\n  assert( (int)a.size() == k );\n  FPS P = a * Q; P.resize(k);\n  while(N){\n    auto Q2 = Q;\n    for(int i = 1; i < (int)Q2.size(); i += 2) Q2[i].x = MOD - Q2[i].x;\n    auto S = P * Q2;\n    auto T = Q * Q2;\n    if(N & 1){\n      for(int i = 1 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    else{\n      for(int i = 0 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    N >>= 1;\n  }\n  return P[0];\n}\n\nvoid solve(){\n  ini(N , M);\n  ins(S);\n  auto run = RunLengthEncoding(S);\n  if(run.size() == 1){\n    // DP\n    V<mint> dp(N),ep(N),fp(N),gp(N);\n    // [0]がR\n    // -> [1],[-1]はどちらでもよい\n    dp[0] = gp[0] = 1;\n    rep1(i , N - 1){\n      dp[i] = dp[i - 1] + ep[i - 1];\n      ep[i] = dp[i - 1];\n      fp[i] = fp[i - 1] + gp[i - 1];\n      gp[i] = fp[i - 1];\n    }\n    out(dp[N-1] + ep[N-1] + fp[N-1]);\n    return;\n  }\n  if(N % 2 == 1){\n    out(0);\n    return;\n  }\n\n  FPS::set_fft(mul);\n  // rの最小値\n  int r = N-1 , b = N-1;\n  auto trans = [](int n){\n    return (n % 2 == 1) ? n : (n + 1);\n  };\n  rep(i , sz(run)){\n    if(i==0)continue;\n    if(i == sz(run) - 1) continue;\n    auto p = run[i];\n    if(p.first == 'R' && p.second % 2 == 1) amin(r , trans(p.second));\n    if(p.first == 'B' && p.second % 2 == 1) amin(b , trans(p.second));\n  }\n\n  // 初手の制約\n  amin( (run[0].first == 'R' ? r : b) , trans(run[0].second) );\n  // 初手とは異なる方が1である必要あり\n  (run[0].first == 'R' ? b : r) = 1;\n  trc(r , b);\n  if(r < b) swap(r , b);  \n  auto nyaan = [&](ll n) -> FPS{\n    FPS ret(n + 1 , 0);\n    for(int i = 1 ; i <= n ; i += 2) ret[i] = 1;\n    return ret;\n  };\n  FPS f({0 , 1});\n  f *= nyaan(r);\n  f *= -1; f[0] = 1;\n  if((int)f.size() <= N) f.resize(N + 1);\n  f = f.inv();\n  trc(f);\n  // やる\n  mint ans = 0;\n  for(int i = 2 ; i <= r + 1 ; i += 2){\n    ans += f[N - i] * i;\n  }\n  out(ans);\n  \n  \n  /*\n  //trc(f);\n  // 倍数包除\n  for(int i = 2 ; i <= N ; i++){\n    // i番目は？\n    //引こう！\n    for(int j = 2 ; i * j <= N ; j++){\n      f[i * j] -= f[i];\n    }\n  }\n  trc(f);\n  */\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n\treturn powmod(a, MOD-2);\n}\nll f[200001], invf[200001];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n    invf[n]=inv(f[n]);\n    for(ll i=n-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n}\nll comb(int x, int y){\n    if(x<y) return 0;\n    return f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nint main()\n{\n    int n, m; cin>>n>>m;\n    string s; cin>>s;\n    if(s[0]=='B'){\n        for(int i=0; i<m; i++){\n            if(s[i]=='B') s[i]='R';\n            else s[i]='B';\n        }\n    }\n    int j=-1;\n    vector<int> v;\n    bool nuo=1;\n    for(int i=0; i<n; i++){\n        if(s[i]=='B') nuo=0;\n        if(i==n-1 || s[i+1]=='B'){\n            v.push_back(i-j);\n            j=i+1;\n        }\n    }\n    if(nuo){\n        ll dp[2][200002]={};\n        dp[0][0]=1;\n        for(int i=1; i<n; i++){\n            dp[1][i]+=dp[0][i-1];\n            dp[0][i]+=(dp[0][i-1]+dp[1][i-1]);\n            dp[0][i]%=MOD;\n            dp[1][i]%=MOD;\n        }\n        ll ans=dp[0][n-1]+dp[1][n-1];\n        fill(dp[0], dp[0]+n+1, 0);\n        fill(dp[1], dp[1]+n+1, 0);\n        dp[1][0]=1;\n        for(int i=1; i<n; i++){\n            dp[1][i]+=dp[0][i-1];\n            dp[0][i]+=(dp[0][i-1]+dp[1][i-1]);\n            dp[0][i]%=MOD;\n            dp[1][i]%=MOD;\n        }\n        ans+=dp[0][n-1];\n        ans%=MOD;\n        cout<<ans<<endl;\n        return 0;\n    }\n    if(n%2==1){\n        cout<<0<<endl;\n        return 0;\n    }\n    int mx=v[0]+1-v[0]%2;\n    for(int i=1; i<v.size(); i++){\n        if(v[i]&1) mx=min(mx, v[i]);\n    }\n    ll dp[200002]={}, sum[200002];\n    dp[0]=1;\n    sum[0]=1;\n    for(int i=1; i<=n; i++){\n        if(i&1) sum[i]=sum[i-1];\n        else{\n            if(i-mx-3>=0) dp[i]=(sum[i-2]-sum[i-mx-3]+MOD)%MOD;\n            else dp[i]=sum[i-2];\n            sum[i]=(sum[i-1]+dp[i])%MOD;\n        }\n    }\n    ll ans=0;\n    for(int i=1; i<=min(mx, n-1); i+=2){\n        ans+=(ll)(i+1)*dp[n-i-1];\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc()) \n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int MOD = (int)(1e9 + 7);\ninline void Add(int& x,int y) {\n  x = x + y >= MOD ? x + y - MOD : x + y;\n}\ninline void Sub(int& x,int y) {\n  x = x - y < 0 ? x - y + MOD : x - y;\n}\nint power(int a,int b) {\n  int ret = 1;\n  while (b) {\n    if (b&1) ret = 1ll * ret * a % MOD;\n    a = 1ll * a * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\n\nconst int N = 200010;\nint n, m, arr[N], acnt;\nchar str[N];\nint dp[N];\nvoid doit(int lim) {\n  if (n%2) {\n    puts(\"0\");\n    return;\n  }\n  lim = (lim + 1) / 2;\n  rep (i, 1, n/2) {\n    Add(dp[i], dp[i-1]);\n    if (i-lim-1 >= 1)\n      Sub(dp[i], dp[i-lim-1]);\n    if (i <= lim) Add(dp[i], 2 * i);\n    Add(dp[i], dp[i-1]);\n  }\n  int ans = dp[n/2];\n  Sub(ans, dp[n/2-1]);\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  read(n), read(m);\n  scanf(\"%s\", str+1);\n  if (str[1] == 'R') {\n    rep (i, 1, n) {\n      if (str[i] == 'R') str[i] = 'B';\n      else str[i] = 'R';\n    }\n  }\n  int key = 1;\n  rep (i, 2, n) if (str[i] == 'R') key = 0;\n  if (key) {\n    dp[0] = 1, dp[1] = 2;\n    rep (i, 2, n) dp[i] = (dp[i-1] + dp[i-2]) % MOD;\n    int ans = dp[n];\n    Sub(ans, dp[max(0, n - 4)]);\n    printf(\"%d\\n\", ans);\n    return 0;\n  }\n  for (int i = 1, j = 0; i <= n; ++ i) {\n    if (str[i] == 'B') {\n      ++ j;\n      if (str[i+1] == 'R' && i <= n)\n\tarr[++ acnt] = j;\n    }\n    else j = 0;\n  }\n  int lim = n;\n  rep (i, 2, acnt) {\n    if (arr[i] % 2 != 0)\n      lim = min(lim, arr[i]); \n  }\n  lim = min(lim, arr[1] + 1);\n  doit(lim);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 200005\n#define mo 1000000007\n#define ll long long\nint n,m,L;\nchar s[M];\nll ans,f[M],g[M];\nll dp[M][2];\nvoid work() {\n    while(s[m]==s[1]) m--;\n    L=1e9;\n    char ch=s[1];\n    for(int i=2,l=1,tp=1;i<=m;i++)\n\t{\n\t    if(s[i]==ch) l++;\n\t    else\n\t\t{\n\t\t    if(l&1) L=min(L,l);\n\t\t    else if(tp) L=min(L,l+1);\n\t\t    l=tp=0;\n\t\t}\n\t}\n    if(L==1e9)\n\t{\n\t    dp[1][0]=1;\n\t    for(int i=2;i<=n;i++)\n\t\t{\n\t\t    dp[i][0]=(dp[i-1][0]+dp[i-1][1])%mo;\n\t\t    dp[i][1]=dp[i-1][0];\n\t\t}\n\t    ans=(dp[n][1]+dp[n][0])%mo;\n\t    memset(dp,0,sizeof(dp));\n\t    dp[1][1]=1;\n\t    for(int i=2;i<=n;i++)\n\t\t{\n\t\t    dp[i][0]=(dp[i-1][0]+dp[i-1][1])%mo;\n\t\t    dp[i][1]=dp[i-1][0];\n\t\t}\n\t    ans=(ans+dp[n][0])%mo;\n\t    cout<<ans<<'\\n';\n\t}\n    else\n\t{\n\t    f[1]=g[1]=1;\n\t    for(int i=2;i<=n;i++)\n\t\t{\n\t\t    if(i<=L&&(i&1)) f[i]=1;\n\t\t    //for(int j=i-2;j>=max(i-L-1,0);j-=2) f[i]=(f[i]+f[j])%mo;\n\t\t    f[i]=(f[i]+g[i-2]-(i-L-3>=0?g[i-L-3]:0)+mo)%mo;\n\t\t    g[i]=(g[i-2]+f[i])%mo;\n\t\t}\n\t    for(int i=3;i<=L+2&&i<=n;i+=2) ans=(ans+f[n-i]*(i-1)%mo)%mo;\n\t    if(n-1<=L&&((n-1)&1)) ans=(ans+n)%mo;\n\t    cout<<ans<<'\\n';\n\t}\n}\nint main()\n{\n    cin>>n>>m;\n    scanf(\"%s\",s+1);\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nusing Int = long long;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T>\nstruct FormalPowerSeries{\n  using Poly = vector<T>;\n  using Conv = function<Poly(Poly, Poly)>;\n  Conv conv;\n  FormalPowerSeries(Conv conv):conv(conv){}\n\n  Poly pre(const Poly &as,int deg){\n    return Poly(as.begin(),as.begin()+min((int)as.size(),deg));\n  }\n\n  Poly add(Poly as,Poly bs){\n    int sz=max(as.size(),bs.size());\n    Poly cs(sz,T(0));\n    for(int i=0;i<(int)as.size();i++) cs[i]+=as[i];\n    for(int i=0;i<(int)bs.size();i++) cs[i]+=bs[i];\n    return cs;\n  }\n\n  Poly sub(Poly as,Poly bs){\n    int sz=max(as.size(),bs.size());\n    Poly cs(sz,T(0));\n    for(int i=0;i<(int)as.size();i++) cs[i]+=as[i];\n    for(int i=0;i<(int)bs.size();i++) cs[i]-=bs[i];\n    return cs;\n  }\n\n  Poly mul(Poly as,Poly bs){\n    return conv(as,bs);\n  }\n\n  Poly mul(Poly as,T k){\n    for(auto &a:as) a*=k;\n    return as;\n  }\n\n  // F(0) must not be 0\n  Poly inv(Poly as,int deg){\n    assert(as[0]!=T(0));\n    Poly rs({T(1)/as[0]});\n    for(int i=1;i<deg;i<<=1)\n      rs=pre(sub(add(rs,rs),mul(mul(rs,rs),pre(as,i<<1))),i<<1);\n    return rs;\n  }\n\n  // not zero\n  Poly div(Poly as,Poly bs){\n    while(as.back()==T(0)) as.pop_back();\n    while(bs.back()==T(0)) bs.pop_back();\n    if(bs.size()>as.size()) return Poly();\n    reverse(as.begin(),as.end());\n    reverse(bs.begin(),bs.end());\n    int need=as.size()-bs.size()+1;\n    Poly ds=pre(mul(as,inv(bs,need)),need);\n    reverse(ds.begin(),ds.end());\n    return ds;\n  }\n\n  // F(0) must be 1\n  Poly sqrt(Poly as,int deg){\n    assert(as[0]==T(1));\n    T inv2=T(1)/T(2);\n    Poly ss({T(1)});\n    for(int i=1;i<deg;i<<=1){\n      ss=pre(add(ss,mul(pre(as,i<<1),inv(ss,i<<1))),i<<1);\n      for(T &x:ss) x*=inv2;\n    }\n    return ss;\n  }\n\n  Poly diff(Poly as){\n    int n=as.size();\n    Poly res(n-1);\n    for(int i=1;i<n;i++) res[i-1]=as[i]*T(i);\n    return res;\n  }\n\n  Poly integral(Poly as){\n    int n=as.size();\n    Poly res(n+1);\n    res[0]=T(0);\n    for(int i=0;i<n;i++) res[i+1]=as[i]/T(i+1);\n    return res;\n  }\n\n  // F(0) must be 1\n  Poly log(Poly as,int deg){\n    return pre(integral(mul(diff(as),inv(as,deg))),deg);\n  }\n\n  // F(0) must be 0\n  Poly exp(Poly as,int deg){\n    Poly f({T(1)});\n    as[0]+=T(1);\n    for(int i=1;i<deg;i<<=1)\n      f=pre(mul(f,sub(pre(as,i<<1),log(f,i<<1))),i<<1);\n    return f;\n  }\n\n  Poly partition(int n){\n    Poly rs(n+1);\n    rs[0]=T(1);\n    for(int k=1;k<=n;k++){\n      if(1LL*k*(3*k+1)/2<=n) rs[k*(3*k+1)/2]+=T(k%2?-1LL:1LL);\n      if(1LL*k*(3*k-1)/2<=n) rs[k*(3*k-1)/2]+=T(k%2?-1LL:1LL);\n    }\n    return inv(rs,n+1);\n  }\n};\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\nconstexpr int bmds(int x){\n  const int v[] = {1012924417, 924844033, 998244353,\n                   897581057, 645922817};\n  return v[x];\n}\nconstexpr int brts(int x){\n  const int v[] = {5, 5, 3, 3, 3};\n  return v[x];\n}\n\ntemplate<int X>\nstruct NTT{\n  static constexpr int md = bmds(X);\n  static constexpr int rt = brts(X);\n  using M = Mint<int, md>;\n  vector< vector<M> > rts,rrts;\n\n  void ensure_base(int n){\n    if((int)rts.size()>=n) return;\n    rts.resize(n);rrts.resize(n);\n    for(int i=1;i<n;i<<=1){\n      if(!rts[i].empty()) continue;\n      M w=M(rt).pow((md-1)/(i<<1));\n      M rw=w.inv();\n      rts[i].resize(i);rrts[i].resize(i);\n      rts[i][0]=M(1);rrts[i][0]=M(1);\n      for(int k=1;k<i;k++){\n        rts[i][k]=rts[i][k-1]*w;\n        rrts[i][k]=rrts[i][k-1]*rw;\n      }\n    }\n  }\n\n  void ntt(vector<M> &as,bool f,int n=-1){\n    if(n==-1) n=as.size();\n    assert((n&(n-1))==0);\n    ensure_base(n);\n\n    for(int i=0,j=1;j+1<n;j++){\n      for(int k=n>>1;k>(i^=k);k>>=1);\n      if(i>j) swap(as[i],as[j]);\n    }\n\n    for(int i=1;i<n;i<<=1){\n      for(int j=0;j<n;j+=i*2){\n        for(int k=0;k<i;k++){\n          M z=as[i+j+k]*(f?rrts[i][k]:rts[i][k]);\n          as[i+j+k]=as[j+k]-z;\n          as[j+k]+=z;\n        }\n      }\n    }\n\n    if(f){\n      M tmp=M(n).inv();\n      for(int i=0;i<n;i++) as[i]*=tmp;\n    }\n  }\n\n  vector<M> multiply(vector<M> as,vector<M> bs){\n    int need=as.size()+bs.size()-1;\n    int sz=1;\n    while(sz<need) sz<<=1;\n    as.resize(sz,M(0));\n    bs.resize(sz,M(0));\n\n    ntt(as,0);ntt(bs,0);\n    for(int i=0;i<sz;i++) as[i]*=bs[i];\n    ntt(as,1);\n\n    as.resize(need);\n    return as;\n  }\n\n  vector<int> multiply(vector<int> as,vector<int> bs){\n    vector<M> am(as.size()),bm(bs.size());\n    for(int i=0;i<(int)am.size();i++) am[i]=M(as[i]);\n    for(int i=0;i<(int)bm.size();i++) bm[i]=M(bs[i]);\n    vector<M> cm=multiply(am,bm);\n    vector<int> cs(cm.size());\n    for(int i=0;i<(int)cs.size();i++) cs[i]=cm[i].v;\n    return cs;\n  }\n};\ntemplate<int X> constexpr int NTT<X>::md;\ntemplate<int X> constexpr int NTT<X>::rt;\n\n\nnamespace FFT{\n  using dbl = double;\n\n  struct num{\n    dbl x,y;\n    num(){x=y=0;}\n    num(dbl x,dbl y):x(x),y(y){}\n  };\n\n  inline num operator+(num a,num b){\n    return num(a.x+b.x,a.y+b.y);\n  }\n  inline num operator-(num a,num b){\n    return num(a.x-b.x,a.y-b.y);\n  }\n  inline num operator*(num a,num b){\n    return num(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n  }\n  inline num conj(num a){\n    return num(a.x,-a.y);\n  }\n\n  int base=1;\n  vector<num> rts={{0,0},{1,0}};\n  vector<int> rev={0,1};\n\n  const dbl PI=acosl(-1.0);\n\n  void ensure_base(int nbase){\n    if(nbase<=base) return;\n\n    rev.resize(1<<nbase);\n    for(int i=0;i<(1<<nbase);i++)\n      rev[i]=(rev[i>>1]>>1)+((i&1)<<(nbase-1));\n\n    rts.resize(1<<nbase);\n    while(base<nbase){\n      dbl angle=2*PI/(1<<(base+1));\n      for(int i=1<<(base-1);i<(1<<base);i++){\n        rts[i<<1]=rts[i];\n        dbl angle_i=angle*(2*i+1-(1<<base));\n        rts[(i<<1)+1]=num(cos(angle_i),sin(angle_i));\n      }\n      base++;\n    }\n  }\n\n  void fft(vector<num> &a,int n=-1){\n    if(n==-1) n=a.size();\n    assert((n&(n-1))==0);\n\n    int zeros=__builtin_ctz(n);\n    ensure_base(zeros);\n    int shift=base-zeros;\n    for(int i=0;i<n;i++)\n      if(i<(rev[i]>>shift))\n        swap(a[i],a[rev[i]>>shift]);\n\n    for(int k=1;k<n;k<<=1){\n      for(int i=0;i<n;i+=2*k){\n        for(int j=0;j<k;j++){\n          num z=a[i+j+k]*rts[j+k];\n          a[i+j+k]=a[i+j]-z;\n          a[i+j]=a[i+j]+z;\n        }\n      }\n    }\n  }\n\n  vector<num> fa;\n\n  vector<Int> multiply(vector<int> &a,vector<int> &b){\n    int need=a.size()+b.size()-1;\n    int nbase=0;\n    while((1<<nbase)<need) nbase++;\n    ensure_base(nbase);\n\n    int sz=1<<nbase;\n    if(sz>(int)fa.size()) fa.resize(sz);\n    for(int i=0;i<sz;i++){\n      int x=(i<(int)a.size()?a[i]:0);\n      int y=(i<(int)b.size()?b[i]:0);\n      fa[i]=num(x,y);\n    }\n    fft(fa,sz);\n\n    num r(0,-0.25/sz);\n    for(int i=0;i<=(sz>>1);i++){\n      int j=(sz-i)&(sz-1);\n      num z=(fa[j]*fa[j]-conj(fa[i]*fa[i]))*r;\n      if(i!=j)\n        fa[j]=(fa[i]*fa[i]-conj(fa[j]*fa[j]))*r;\n      fa[i]=z;\n    }\n    fft(fa,sz);\n\n    vector<Int> res(need);\n    for(int i=0;i<need;i++)\n      res[i]=fa[i].x+0.5;\n\n    return res;\n  }\n\n};\n\n\ntemplate<typename T>\nstruct ArbitraryModConvolution{\n  using dbl=FFT::dbl;\n  using num=FFT::num;\n\n  vector<T> multiply(vector<T> as,vector<T> bs){\n    int need=as.size()+bs.size()-1;\n    int sz=1;\n    while(sz<need) sz<<=1;\n    vector<num> fa(sz),fb(sz);\n    for(int i=0;i<(int)as.size();i++)\n      fa[i]=num(as[i].v&((1<<15)-1),as[i].v>>15);\n    for(int i=0;i<(int)bs.size();i++)\n      fb[i]=num(bs[i].v&((1<<15)-1),bs[i].v>>15);\n\n    fft(fa,sz);fft(fb,sz);\n\n    dbl ratio=0.25/sz;\n    num r2(0,-1),r3(ratio,0),r4(0,-ratio),r5(0,1);\n    for(int i=0;i<=(sz>>1);i++){\n      int j=(sz-i)&(sz-1);\n      num a1=(fa[i]+conj(fa[j]));\n      num a2=(fa[i]-conj(fa[j]))*r2;\n      num b1=(fb[i]+conj(fb[j]))*r3;\n      num b2=(fb[i]-conj(fb[j]))*r4;\n      if(i!=j){\n        num c1=(fa[j]+conj(fa[i]));\n        num c2=(fa[j]-conj(fa[i]))*r2;\n        num d1=(fb[j]+conj(fb[i]))*r3;\n        num d2=(fb[j]-conj(fb[i]))*r4;\n        fa[i]=c1*d1+c2*d2*r5;\n        fb[i]=c1*d2+c2*d1;\n      }\n      fa[j]=a1*b1+a2*b2*r5;\n      fb[j]=a1*b2+a2*b1;\n    }\n    fft(fa,sz);fft(fb,sz);\n\n    vector<T> cs(need);\n    using ll = long long;\n    for(int i=0;i<need;i++){\n      ll aa=T(llround(fa[i].x)).v;\n      ll bb=T(llround(fb[i].x)).v;\n      ll cc=T(llround(fa[i].y)).v;\n      cs[i]=T(aa+(bb<<15)+(cc<<30));\n    }\n    return cs;\n  }\n};\n\n//INSERT ABOVE HERE\n\nsigned HAPPYQUERY_E(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n,m,q;\n  cin>>n>>m>>q;\n  vector<int> ls(q),rs(q);\n  for(int i=0;i<q;i++) cin>>ls[i]>>rs[i],ls[i]--;\n\n  vector<int> as(n);\n  for(int i=0;i<n;i++) cin>>as[i];\n\n  if(as==vector<int>(n,0)){\n    for(int i=0;i<m;i++){\n      if(i) cout<<\" \";\n      cout<<0;\n    }\n    cout<<endl;\n    return 0;\n  }\n\n  vector<int> cs(n-m+1,0);\n  for(int l:ls) cs[l]++;\n\n  NTT<0> ntt;\n  using M = NTT<0>::M;\n  auto conv=[&](auto as,auto bs){return ntt.multiply(as,bs);};\n  FormalPowerSeries<M> FPS(conv);\n\n  vector<M> ps(as.size()),qs(cs.size());\n  for(int i=0;i<(int)ps.size();i++) ps[i]=M(as[i]);\n  for(int i=0;i<(int)qs.size();i++) qs[i]=M(cs[i]);\n\n  auto bs=FPS.div(ps,qs);\n  for(int i=0;i<m;i++){\n    if(i) cout<<\" \";\n    cout<<bs[i];\n  }\n  cout<<endl;\n  return 0;\n}\n/*\n  verified on 2019/09/17\n  https://www.hackerrank.com/contests/happy-query-contest/challenges/array-restoring\n*/\n\nsigned CFR250_E(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n,m;\n  cin>>n>>m;\n  vector<int> cs(n);\n  for(int i=0;i<n;i++) cin>>cs[i];\n\n  NTT<2> ntt;\n  using M = NTT<2>::M;\n  auto conv=[&](auto as,auto bs){return ntt.multiply(as,bs);};\n  FormalPowerSeries<M> FPS(conv);\n\n  const int deg=1<<18;\n  vector<M> as(deg,0);\n  as[0]=M(1);\n  for(int c:cs) as[c]-=M(4);\n\n  auto bs=FPS.sqrt(as,deg);\n  bs[0]+=M(1);\n\n  vector<M> vs({2});\n\n  auto ans=FPS.mul(vs,FPS.inv(bs,deg));\n  for(int i=1;i<=m;i++) cout<<ans[i]<<\"\\n\";\n  cout<<flush;\n\n  return 0;\n}\n/*\n  verified on 2019/09/17\n  https://codeforces.com/contest/438/problem/E\n*/\n\nsigned YUKI_3046(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int k,n;\n  cin>>k>>n;\n  vector<int> xs(n);\n  for(int i=0;i<n;i++) cin>>xs[i];\n\n  using M = Mint<int>;\n  ArbitraryModConvolution<M> arb;\n  auto conv=[&](auto as,auto bs){return arb.multiply(as,bs);};\n  FormalPowerSeries<M> FPS(conv);\n\n  const int sz=1<<17;\n  vector<M> bs(sz,M(0));\n  bs[0]=1;\n  for(int x:xs) bs[x]-=M(1);\n  cout<<FPS.inv(bs,k+1)[k]<<endl;\n  return 0;\n}\n/*\n  verified on 2019/09/17\n  https://yukicoder.me/problems/no/3046\n*/\n\nconst int md = 998244353;\ninline int add(int a,int b){\n  a+=b;\n  if(a>=md) a-=md;\n  return a;\n}\n\ninline int mul(int a,int b){\n  return 1LL*a*b%md;\n}\n\ninline int pow(int a,int b){\n  int res=1;\n  while(b){\n    if(b&1) res=mul(res,a);\n    a=mul(a,a);\n    b>>=1;\n  }\n  return res;\n}\n\ninline int sqrt(int a){\n  if(a==0) return 0;\n  if(pow(a,(md-1)/2)!=1) return -1;\n  int q=md-1,m=0;\n  while(~q&1) q>>=1,m++;\n  mt19937 mt;\n  int z=mt()%md;\n  while(pow(z,(md-1)/2)!=md-1) z=mt()%md;\n  int c=pow(z,q),t=pow(a,q),r=pow(a,(q+1)/2);\n  while(m>1){\n    if(pow(t,1<<(m-2))!=1)\n      r=mul(r,c),t=mul(t,mul(c,c));\n    c=mul(c,c);\n    m--;\n  }\n  return min(r,md-r);\n}\n\nsigned LOJ_150(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  NTT<2> ntt;\n  using M = NTT<2>::M;\n  auto conv=[&](auto as,auto bs){return ntt.multiply(as,bs);};\n  FormalPowerSeries<M> FPS(conv);\n\n  int n,k;\n  cin>>n>>k;\n\n  vector<M> F(n+1);\n  for(int i=0;i<=n;i++) cin>>F[i].v;\n\n  const int deg = 1<<17;\n  auto as=FPS.log(FPS.mul(F,F[0].inv()),deg);\n  auto bs=FPS.exp(FPS.mul(as,M((md-1)/2)),deg);\n  M s(sqrt(F[0].v));\n  auto cs=FPS.integral(FPS.mul(bs,s.inv()));\n  auto ds=FPS.exp(cs,deg);\n  auto es=FPS.sub(F,ds);\n  es[0]+=M(2);\n  es[0]-=F[0];\n  auto fs=FPS.log(es,deg);\n  fs[0]+=M(1);\n  auto gs=FPS.log(fs,deg);\n  auto hs=FPS.mul(gs,M(k));\n  auto is=FPS.exp(hs,deg);\n  auto G=FPS.diff(is);\n\n  for(int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<G[i];\n  }\n  cout<<endl;\n  return 0;\n}\n#define mod 1000000007\n\nMint<int> dp[200010][2][2];\nint main(){\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if(s[0]=='R'){\n        rep(i,m){\n            if(s[i]=='R'){\n                s[i] ='B';\n            }else{\n                s[i] ='R'; \n            }\n        }\n    }\n    int a = inf;\n    int c = 0;\n    rep(i,m){\n        if(s[i]=='B'){\n            c++;\n        }else{\n            chmin(a,c);    \n        }\n    }\n    if(a==inf){\n        dp[0][0][0] = 1;\n        dp[0][1][1] = 1;\n        for(int i=1;i<n;i++){\n            for(int j=0;j<2;j++){\n                if(j==0){\n                    dp[i][j][0] += dp[i-1][1][0];\n                    dp[i][j][1] += dp[i-1][1][1];\n                }else{\n                    dp[i][j][0] += dp[i-1][1][0] + dp[i-1][0][0];\n                    dp[i][j][1] += dp[i-1][1][1] + dp[i-1][0][1];    \n                }\n            }\n        }\n        cout << dp[n-1][1][0] + dp[n-1][1][1] + dp[n-1][0][1] << endl;\n    }else{\n        int len = (a/2)*2+1;\n        cerr << len << endl;\n        vector<Mint<int> > X(n+1),Y(n+1);\n        len++;\n        for(int i=2;i<=len;i+=2){\n            X[i] = i;\n        }\n        Y[0] = 1;\n        for(int i=2;i<=len;i+=2){\n            Y[i] = mod-1;\n        }\n        ArbitraryModConvolution<Mint<int,mod> > arb;\n        auto conv=[&](auto as,auto bs){return arb.multiply(as,bs);};\n        FormalPowerSeries<Mint<int> > FPS(conv);\n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        auto cs = FPS.inv(Y,n+1);\n        \n        // rep(i,n+1){\n        //     cerr << cs[i] << \" \";\n        // }\n        auto res = FPS.mul(X,cs);\n        cerr << endl;\n        cout << res[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define rng(a) a.begin(),a.end()\n#define rrng(a) a.rbegin(),a.rend()\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define limit(x,l,r) max(l,min(x,r))\n#define lims(x,l,r) (x = max(l,min(x,r)))\n#define isin(x,l,r) ((l) <= (x) && (x) < (r))\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcountll\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,v(T),greater<T> >\n#define bn(x) ((1<<x)-1)\n#define dup(x,y) (((x)+(y)-1)/(y))\n#define newline puts(\"\")\n#define v(T) vector<T>\n#define vv(T) v(v(T))\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ntemplate<typename T>inline istream& operator>>(istream&i,v(T)&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(const v(T)&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>inline ostream& operator<<(ostream&o,const v(T)&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>inline istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>inline ostream& operator<<(ostream&o,const pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\ntemplate<typename T>inline ll suma(const v(T)& a) { ll res(0); for (auto&& x : a) res += x; return res;}\nconst double eps = 1e-10;\nconst ll LINF = 1001002003004005006ll;\nconst int INF = 1001001001;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"YES\");}else{puts(\"NO\");}\nconst int MX = 200005;\n\n// Mod int\nconst int mod = 1000000007;\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  // mint(ll x):x(x){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\nistream& operator>>(istream&i,mint&a){i>>a.x;return i;}\nostream& operator<<(ostream&o,const mint&a){o<<a.x;return o;}\ntypedef vector<mint> vm;\ntypedef vector<vm> vvm;\n//\n\nvoid one(int n) {\n  mint ans = 0;\n  rep(si,2) {\n    vm dp(2);\n    dp[si] = 1;\n    rep(i,n-1) {\n      vm p(2); swap(dp,p);\n      dp[0] = p[0]+p[1];\n      dp[1] = p[0];\n    }\n    ans += dp[0];\n    if (!si) ans += dp[1];\n  }\n  cout<<ans<<endl;\n}\n\nmint two(int n, vi x) {\n  vvm dp(2,vm(n+1));\n  vvm ds(2,vm(n+1));\n  dp[0][0] = 1;\n  rep(i,n) {\n    if (i) {\n      rep(j,2) ds[j][i+1] = ds[j][i-1]+dp[j][i];\n    } else {\n      rep(j,2) ds[j][i+1] = dp[j][i];\n    }\n    rep(j,2) {\n      int l = max(0,i-x[j]);\n      dp[j][i+1] = ds[j^1][i+1]-ds[j^1][l];\n    }\n  }\n  // rep(i,2) cerr<<dp[i]<<endl;\n  mint res = 0;\n  rep(i,n) {\n    if (i%2 == 0) continue;\n    if (i > x[0]) break;\n    res += dp[1][n-i]*i;\n  }\n  // cerr<<x<<\" \"<<res<<endl;\n  return res;\n}\n\nint main() {\n  int n,m;\n  scanf(\"%d%d\",&n,&m);\n  string s;\n  cin>>s;\n  vi a(1);\n  char pre = s[0];\n  rep(i,m) {\n    if (pre != s[i]) a.pb(0);\n    a.back()++;\n    pre = s[i];\n  }\n  if (sz(a) == 1) {\n    one(n);\n    return 0;\n  }\n  vi x(2,INF);\n  x[1] = 1;\n  rep(i,sz(a)-1) {\n    int now = 0;\n    if (!i) {\n      now = a[i]/2*2+1;\n    } else {\n      if (a[i]%2 == 0) continue;\n      now = a[i];\n    }\n    mins(x[i&1],now);\n  }\n  mint ans;\n  rep(ri,2) {\n    ans += two(n,x);\n    reverse(rng(x));\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1000000007;\nint n, m, dp[200005], sum[2][200005];\nchar s[200005];\n\nint main() {\n\tscanf(\"%d%d%s\", &n, &m, s + 1);\n\tif (s[1] == 'B')\n\t\tfor (int i = 1; i <= m; ++i)\n\t\t\ts[i] = 'R' + 'B' - s[i];\n\tif (count(s + 1, s + 1 + m, 'R') == m) {\n\t\tif (n == 1) return puts(\"1\"), 0;\n\t\tint ans = 0;\n\t\tfor (int c = 0; c < 2; ++c) {\n\t\t\tint dp[2] = {1, 0};\n\t\t\tfor (int i = 1; i < n; ++i) {\n\t\t\t\tint t = dp[1];\n\t\t\t\tdp[1] = dp[0];\n\t\t\t\tdp[0] = (dp[0] + t) % P;\n\t\t\t}\n\t\t\tans += dp[0];\n\t\t}\n\t\tprintf(\"%d\\n\", ans % P);\n\t\treturn 0;\n\t}\n\tint lim = n - 1;\n\tfor (int i = 1, j; i <= m; i = j) {\n\t\tfor (j = i; j <= m && s[j] == s[i]; ++j);\n\t\tif (s[i] == 'B') continue;\n\t\tif (j - i & 1)\n\t\t\tlim = min(lim, j - i);\n\t\telse if (i == 1)\n\t\t\tlim = min(lim, j - i + 1);\n\t}\n\tdp[0] = 1;\n\tsum[0][0] = sum[0][1] = 1;\n\tsum[1][0] = sum[1][1] = 0;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tint d = max(0, i - lim - 1);\n\t\tdp[i] = (sum[i & 1][i - 2] - (d == 0 ? 0 : sum[i & 1][d - 1])) % P;\n\t\tsum[0][i] = sum[0][i - 1];\n\t\tsum[1][i] = sum[1][i - 1];\n\t\tsum[i & 1][i] = (sum[i & 1][i] + dp[i]) % P;\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i <= lim; ++i)\n\t\t\tans += sum[n & 1][n - (i + 1)] - (n == lim + 1 ? 0 : sum[n & 1][n - (lim + 1) - 1]);\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+10;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    lim = min(lim,n-1);\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    ans = dp[n+1];\n    for(ll i = 1;i<=lim;i+=2)\n    {\n        ans += (i*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    int mn = 1e9;\n    if (vc[0]%2==0)\n        mn = vc[0]+1;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MAX_N 200000\n#define MAX_M 200000\n#define MOD 1000000007\n\n#define INF 1 << 29\n\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nint N, M;\nstring S;\n\n// long long dp[MAX_N + 2], rdp[MAX_N + 2];\n\n// int all_color_is_same()\n// {\n//     long long rr = 1, bb = 1, rb = 0, br = 0;\n\n//     for ( int i = 1; i < N; i++ )\n//     {\n//         long long nrr = ( rr + rb ) % MOD;\n//         long long nbb = br;\n//         long long nrb = rr;\n//         long long nbr = ( bb + br ) % MOD;\n\n//         rr = nrr;\n//         bb = nbb;\n//         rb = nrb;\n//         br = nbr;\n//     }\n\n//     return ( rr + rb + br ) % MOD;\n// }\n\n// /**\n\n/* S\nの先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n*/\nint min_freq()\n{\n    // int l = 0;\n    // while ( l < M && S[0] == S[l] ) l++;\n\n    // int ans = ( l & 1 ) ? l : l + 1;\n\n    // l = 0;\n    // for ( int i = 0; i < M; i++ )\n    // {\n    //     if ( S[0] == S[i] )\n    //         l++;\n    //     else\n    //     {\n    //         if ( l & 1 ) ans = min( ans, l );\n    //         l = 0;\n    //     }\n    // }\n    // return ( l & 1 ) ? min( ans, l ) : ans;\n    Int l = 0;\n    while ( S[0] == S[l] ) l++;\n    if ( l % 2 == 0 ) l++;\n    Int limit = l;\n    l = 0;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[i] == S[0] )\n            l++;\n        else\n        {\n            if ( l % 2 == 1 ) limit = min( limit, l );\n            l = 0;\n        }\n    }\n    return l;\n}\n\n// int solve()\n// {\n//     // 一色\n//     if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n//         return all_color_is_same();\n\n//     // N が奇数\n//     if ( N & 1 ) return 0;\n\n//     int L = min_freq();\n\n//     L = ( L + 1 ) >> 1;\n//     N >>= 1;\n\n//     dp[0] = rdp[0] = 1;\n//     for ( int i = 1; i <= N + 1; i++ )\n//     {\n//         dp[i] = rdp[i - 1];\n//         if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n//         if ( dp[i] < 0 ) dp[i] += MOD;\n//         rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n//     }\n\n//     long long res = 0;\n//     for ( int i = 1; i <= L; i++ )\n//         if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n//     return res % MOD;\n// }\n\n// int main( int argc, char **argv )\n// {\n//     cin >> N >> M;\n//     cin >> S;\n\n//     int ans = solve();\n\n//     cout << ans << endl;\n\n//     return 0;\n// }\n\nInt all( Int n )\n{ // no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for ( int i = 1; i < n; i++ )\n    {\n        Int nrr = ( rr + rb ) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = ( bb + br ) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return ( rr + rb + br ) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc( Int n, Int limit )\n{\n    dp[0] = 1;\n    rdp[0] = 1;\n    for ( int i = 1; i <= n + 1; i++ )\n    {\n        dp[i] = ( rdp[i - 1] -\n                  ( ( i - limit - 1 ) >= 0 ? rdp[i - limit - 1] : 0 ) ) %\n                MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n}\n\nInt solve( Int n, Int limit )\n{\n    if ( n % 2 == 1 ) return 0;\n    if ( limit % 2 != 1 ) exit( 1 );\n    limit = ( limit + 1 ) / 2;\n    n /= 2;\n    Int res = 0;\n    calc( n + 10, limit );\n    for ( Int i = 1; i <= limit; i++ )\n    {\n        if ( n - i >= 0 ) res = ( res + dp[n - i] * 2 * i ) % MOD;\n    }\n    if ( res < 0 ) exit( 1 );\n    return res % MOD;\n}\n\nint main()\n{\n    cin >> N >> M;\n    cin >> S;\n\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n    {\n        cout << all( N ) << endl;\n        return 0;\n    }\n\n    int limit = min_freq();\n    cout << solve( N, limit ) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\nll dp[200010] = {},mod = 1000000007;\nstring s;\nvector<pair<char,int>> v;\nint main(){\n\tll i,j,n,m;\n\tcin >> n >> m >> s;\n\tif(s[0]=='B'){\n\t\tfor(i=0;i<m;i++){\n\t\t\tif(s[i]=='R') s[i] = 'B';\n\t\t\telse s[i] = 'R';\n\t\t}\n\t}\n\tfor(i=0;i<m;i++){\n\t\tif(i==0 || v.back().first!=s[i]){\n\t\t\tv.push_back({s[i],1});\n\t\t}else{\n\t\t\tv.back().second++;\n\t\t}\n\t}\n\tif(v.size()==1){\n\t\tcout << n + 1 << endl;\n\t\treturn 0;\n\t}\n\tif(n&1){\n\t\tassert(false);\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint mn = -1;\n\tfor(i=0;i<v.size();i++){\n\t\tif(i==0){\n\t\t\tmn = v[i].second + 1 - (v[i].second&1);\n\t\t}\n\t\tif(v[i].first=='R' && (v[i].second&1)){\n\t\t\tmn = min(mn,v[i].second);\n\t\t}\n\t}\n\tmn++;\n\tdp[0] = 1;dp[2] = 1;\n\tll sum = 2;\n\tfor(i=4;i<=n;i+=2){\n\t\t(dp[i] += sum) %= mod;\n\t\t(sum += dp[i]) %= mod;\n\t\tif(i>=mn) sum -= dp[i - mn];\n\t\tif(sum<0) sum += mod;\n\t}\n\tll ans = 0;\n\tfor(i=2;i<=mn;i++){\n\t\t(ans += i*dp[n - i]) %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+10;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nint a[MAX_N];\nint dp[MAX_N];\nint sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = sum[i-2]+dp[i];\n    }\n    ll ans = 0;\n    ans = dp[n+1];\n    for(int i = 1;i<=lim;i+=2)\n    {\n        ans += (i*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[0] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = sum[i-2]+dp[i];\n        }\n        ll ans = dp[n+1];\n        for(int i = 1;i<=n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    int mn = 1e9;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nint n, m, k;\nstring s;\nllint dp[200005], dif[200005];\nllint dp2[200005][2];\n\nllint calc()\n{\n\tint N = (n-1)/2;\n\tk = min(k, N);\n\t\n\tdif[0] = 1, dif[1] = mod-1;\n\tllint sum = 0;\n\tfor(int i = 0; i <= N; i++){\n\t\tsum += dif[i], sum %= mod;\n\t\tdp[i] = sum;\n\t\tdif[i+1] += dp[i], dif[i+1] %= mod;\n\t\tdif[i+k+2] += mod - dp[i], dif[i+k+2] %= mod;\n\t}\n\t\n\tllint ret = 0;\n\tfor(int i = 0; i <= k; i++){\n\t\tret += (i+1)*2 * dp[N-i] % mod;\n\t\tret %= mod;\n\t}\n\treturn ret;\n}\n\nllint calc2()\n{\n\tllint ret = 0;\n\t\n\tdp2[1][0] = 1;\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\tif(j == 1 && k == 1) continue;\n\t\t\t\tdp2[i+1][k] += dp2[i][j], dp2[i+1][k] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tret += dp2[n][0] + dp2[n][1], ret %= mod;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tdp2[i][j] = 0;\n\t\t}\n\t}\n\tdp2[1][1] = 1;\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\tif(j == 1 && k == 1) continue;\n\t\t\t\tdp2[i+1][k] += dp2[i][j], dp2[i+1][k] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tret += dp2[n][0], ret %= mod;\n\t\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> m;\n\tcin >> s;\n\t\n\tif(s[0] == 'B'){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(s[i] == 'R') s[i] = 'B';\n\t\t\telse s[i] = 'R';\n\t\t}\n\t}\n\t\n\tbool diff = false;\n\tfor(int i = 1; i < m; i++){\n\t\tif(s[i] != s[i-1]) diff = true;\n\t}\n\tif(!diff){\n\t\tcout << calc2() << endl;\n\t\treturn 0;\n\t}\n\tif(n % 2){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tk = n+1;\n\tint cnt = 0; bool flag = true;\n\tfor(int i = 0; i < m; i++){\n\t\tif(s[i] == 'R') cnt++;\n\t\telse{\n\t\t\tif(cnt % 2) k = min(k, cnt);\n\t\t\tif(flag) k = min(k, cnt+1), flag = false;\n\t\t\tcnt = 0;\n\t\t}\n\t}\n\tk = (k-1)/2;\n\t\n\tcout << calc() << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=200005;\nconst int mod=1e9+7;\nint n,m,mn,ans;\nchar s[maxn],ch;\nint f[maxn],sum[maxn],g[maxn][2];\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d%d%s\",&n,&m,s);\n\tch=s[0];\n\tint cnt=0;\n\tmn=INF;\n\trep(i,m){\n\t\tif(s[i]!=ch){\n\t\t\tif(cnt%2==0)cnt++;\n\t\t\tmn=min(mn,cnt);\n\t\t\tcnt=0;\t\n\t\t}\n\t\telse cnt++;\n\t}\n\tif(mn==INF){\n\t\tg[1][0]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tg[i][0]=(g[i-1][0]+g[i-1][1])%mod;\n\t\t\tg[i][1]=g[i-1][0];\n\t\t}\n\t\tans=(g[n][0]+g[n][1])%mod;\n\t\tREP(i,n)g[i][0]=g[i][1]=0;\n\t\tg[1][1]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tg[i][0]=(g[i-1][0]+g[i-1][1])%mod;\n\t\t\tg[i][1]=g[i-1][0];\n\t\t}\n\t\tans=(ans+g[n][0])%mod;\n\t}\n\telse{\n\t\tif(n&1)ans=0;\n\t\telse{\n\t\t\tn/=2;\n\t\t\tmn=(mn+1)/2;\n\t\t\tf[0]=1;sum[0]=1;\n\t\t\tREP(i,n){\n\t\t\t\tf[i]=(sum[i-1]-(i-mn-1>=0?sum[i-mn-1]:0)+mod)%mod;\n\t\t\t\tsum[i]=(sum[i-1]+f[i])%mod;\n\t\t\t}\n\t\t\trep(i,n)if(n-i<=mn)ans=(ans+2LL*(n-i)*f[i]%mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n//#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int M = 1e9 + 7;\n\nvoid solve_fib(int n) {\n    vi f(n + 1);\n    f[0] = f[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        f[i] = (f[i - 1] + f[i - 2]) % M;\n    }\n    cout << (f[n] + f[n - 2]) % M;\n}\nconst int oo = 1e9 + 10;\n\nint kek(int cnt, bool & first) {\n    if (first) {\n        first = false;\n        if (cnt & 1)\n            return cnt;\n        return cnt + 1;\n    }\n    if (cnt & 1)\n        return cnt;\n    return oo;\n}\n\nvoid insum(int &a, int b) {\n    a = (a + b) % M;\n}\n\nvoid smain() {\n\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    m = s.size();\n    if (count(ALL(s), 'R') == 0 || count(ALL(s), 'B') == 0) {\n        solve_fib(n);\n        return;\n    }\n\n    vi a(m);\n    fori (i, m) {\n        a[i] = s[i] == 'R';\n    }\n\n    vi min_sz(2, oo);\n    int cur = -1;\n    int cnt = 0;\n    bool first = true;\n    for (auto c : a) {\n        if (c != cur) {\n            if (cur != -1) {\n                inmin(min_sz[cur], kek(cnt, first));\n            }\n            cur = c;\n            cnt = 1;\n        } else {\n            cnt++;\n        }\n    }\n    min_sz[!a[0]] = 1;\n    vvi f(2);\n    fori (z, 2) {\n        vvi dp(2, vi(n, 0));\n        vvi p(2, vi(n, 0));\n        p[!z][0] = dp[!z][0] = 1;\n        for (int i = 1; i < n; ++i) {\n            fori (zz, 2) {\n                if (min_sz[zz] == oo) {\n                    dp[zz][i] = (p[!zz][i - 1] + (i - 2 >= 0 ? p[!zz][i - 2] : 0));\n                } else {\n                    int j = i - min_sz[zz];\n                    dp[zz][i] = (p[!zz][i - 1] - (j - 2 >= 0 ? p[!zz][j - 2] : 0) + M) % M;\n                }\n            }\n            fori (zz, 2) {\n                p[zz][i] = (dp[zz][i] + (i - 2 >= 0 ? p[zz][i - 2] : 0)) % M;\n            }\n        }\n        f[z] = dp[z];\n    }\n    int ans = 0;\n    fori (z, 2) {\n        for (int sz = 1; sz <= min(n - 1, min_sz[z]); sz += 1 + (min_sz[z] != oo)) {\n            insum(ans, (ll)f[!z][n - sz] * sz % M);\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    string s;\n    cin>>s;\n    if(s[0]=='B'){\n        for(int i=0;i<m;i++){\n            if(s[i]=='B'){s[i]='R';}\n            else{s[i]='B';}\n        }\n    }\n    ll l=0;\n    while(l<m && s[l]=='R'){l++;}\n    if(n&1){cout<<(l==m?1:0)<<endl; return 0;}\n    ll mi=E;\n    if(l&1){mi=l;}\n    else{mi=l+1;}\n    for(ll i=l;i<m;i++){\n        if(s[i]=='R'){\n            ll w=i;\n            while(i<m && s[i]=='R'){i++;}\n            if(i!=m){\n                ll L=i-w;\n                if(L&1){mi=min(mi,L);}\n            }\n        }\n    }\n    vector<ll> dp(n,0);\n    vector<ll> sum(n,0);\n    dp[0]=sum[0]=1;\n    for(int i=2;i<n;i+=2){\n        ll r=sum[i-2];\n        ll l=(i-mi-3>=0?sum[i-mi-3]:0LL);\n        dp[i]=r-l;\n        dp[i]%=MOD;\n        sum[i]=sum[i-2]+dp[i];\n        sum[i]%=MOD;\n        //cout<<dp[i]<<\" \"<<sum[i]<<endl;\n    }\n    ll ans=0;\n    for(ll i=2;i<=mi+1 && n-i>=0;i++){\n        ans+=dp[n-i]*i%MOD;\n    }\n    if(l==m){ans++;}\n    ans%=MOD;\n    if(ans<0){ans+=MOD;}\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <string>\n#define SIZE 200005\n#define MOD 1000000007\n\nusing namespace std;\ntypedef long long int ll;\n\nchar str[SIZE];\nll dp[SIZE],rdp[SIZE];\n\nll solve(int n,int L)\n{\n\tdp[1]=1;\n\trdp[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tdp[i]=rdp[i-1]-(i-L-2<=0?0:rdp[i-L-2]);\n\t\tif(dp[i]<0) dp[i]+=MOD;\n\t\trdp[i]=rdp[i-1]+dp[i];\n\t\tif(rdp[i]>=MOD) rdp[i]-=MOD;\n\t}\n\tll ret=0;\n\tfor(int i=0;i<=min(n-1,L);i++)\n\t{\n\t\tret+=(ll) (i+1)*dp[n-i]%MOD;\n\t\tif(ret>=MOD) ret-=MOD;\n\t}\n\treturn ret;\n}\nll solve2(int n)\n{\n\tdp[1]=1;\n\trdp[1]=1;\n\tdp[2]=0;\n\trdp[2]=1;\n\tfor(int i=3;i<=n;i++)\n\t{\n\t\tdp[i]=rdp[i-2];\n\t\trdp[i]=rdp[i-1]+dp[i];\n\t\tif(rdp[i]>=MOD) rdp[i]-=MOD;\n\t}\n\tll ret=0;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tret+=(ll) (i+1)*dp[n-i]%MOD;\n\t\tif(ret>=MOD) ret-=MOD;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tscanf(\"%s\",&str);\n\tbool R=false,B=false;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(str[i]=='R') R=true;\n\t\telse B=true;\n\t}\n\tif(!B||!R) printf(\"%lld\\n\",(solve2(n)+1)%MOD);\n\telse\n\t{\n\t\tif(n%2==1) puts(\"0\");\n\t\telse\n\t\t{\n\t\t\tint mn=n;\n\t\t\tfor(int i=0;i<m;)\n\t\t\t{\n\t\t\t\tif(str[i]!=str[0])\n\t\t\t\t{\n\t\t\t\t\ti++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint f=i;\n\t\t\t\tfor(;i<m&&str[i]==str[f];i++);\n\t\t\t\tint len=i-f;\n\t\t\t\t//printf(\"%d\\n\",len);\n\t\t\t\tif(f==0)\n\t\t\t\t{\n\t\t\t\t\tif(len%2==0) len++;\n\t\t\t\t\tmn=min(mn,len);\n\t\t\t\t}\n\t\t\t\telse if(i<m&&len%2==1) mn=min(mn,len);\n\t\t\t}\n\t\t\t//printf(\"%d\\n\",mn);\n\t\t\tprintf(\"%lld\\n\",solve(n/2,mn/2)*2LL%MOD);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___CLASS_MODINT\n#define ___CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::uint64_t n_) : n(n_ % mod) {};\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tstd::uint32_t get() const { return n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint binpow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tmodint inv() { return (*this).binpow(mod - 2); }\n};\n\n#endif // ___CLASS_MODINT\n\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nusing modulo = modint<1000000007>;\nconst int inf = 1012345678;\nint solve(int N, int M, string S) {\n\tif (S[0] == 'B') {\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (S[i] == 'B') S[i] = 'R';\n\t\t\telse S[i] = 'B';\n\t\t}\n\t}\n\tint pre = 0, mn = inf;\n\tfor (int i = 1; i < M; ++i) {\n\t\tif (pre != -1 && S[i] == 'B') {\n\t\t\tif (pre == 0 || (i - pre) % 2 == 1) mn = min(mn, i - pre + 1);\n\t\t}\n\t\telse if (i != M && pre == -1 && S[i] == 'R') pre = i;\n\t}\n\tif (mn == inf) {\n\t\tvector<modulo> fib(N + 3);\n\t\tfib[1] = 1;\n\t\tfor (int i = 2; i <= N + 2; ++i) {\n\t\t\tfib[i] = fib[i - 1] + fib[i - 2];\n\t\t}\n\t\tmodulo ans = fib[N + 2] - fib[N - 2];\n\t\treturn ans.get();\n\t}\n\telse {\n\t\tvector<modulo> dp(N + 1);\n\t\tdp[1] = 1;\n\t\tint lim = mn / 2 * 2;\n\t\tmodulo sum = 1;\n\t\tfor (int i = 3; i <= N; i += 2) {\n\t\t\tif (i - lim - 2 >= 0) sum -= dp[i - lim - 2];\n\t\t\tdp[i] = sum;\n\t\t\tsum += dp[i];\n\t\t}\n\t\tmodulo ans = 0;\n\t\tfor (int i = 1; i <= mn && i <= N; i += 2) {\n\t\t\tans += dp[N - i] * (i + 1);\n\t\t}\n\t\treturn ans.get();\n\t}\n\treturn -1;\n}\nint main() {\n\tint N, M; string S;\n\tcin >> N >> M >> S;\n\tcout << solve(N, M, S) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\ninline void add(int &x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nll bin_pow(ll a, ll p) {\n    ll res = 1;\n    while (p) {\n        if (p & 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return res;\n}\n\nll rev(ll x) {\n    return bin_pow(x, MOD - 2);\n}\n\nll fact[N + 1], rfact[N + 1];\n\nvoid init() {\n    fact[0] = 1;\n    rep(i, 1, N + 1) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    rfact[N] = rev(fact[N]);\n    repb(i, N - 1, -1) {\n        rfact[i] = rfact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nll C(int n, int k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    return fact[n] * rfact[k] % MOD * rfact[n - k] % MOD;\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    init();\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    repb(i, m - 1, -1) {\n        s[i] = char('0' + (s[0] != s[i]));\n    }\n    int c1 = -1;\n    rep(i, 0, m) {\n        if (s[i] == '1') {\n            c1 = i;\n        }\n    }\n    if (c1 == 0) {\n        int ans = 0;\n        for (int i = 0; i * 2 <= n; i++) {\n            add(ans, C(n - i, i));\n            if (i >= 1) {\n                add(ans, C(n - 2 - (i - 1), (i - 1)));\n            }\n        }\n        cout << ans << \"\\n\";\n        return 0;\n    }\n    s = s.substr(0, c1 + 1);\n    m = sz(s);\n    if (n % 2 == 1) {\n        cout << 0 << \"\\n\";\n        return 0;\n    }\n    int k = n - 1, cur = 0;\n    rep(i, 0, m) {\n        if (s[i] == '0') {\n            cur++;\n        }\n        if (s[i] == '0' && (i == m - 1 || s[i + 1] == '1')) {\n            if (cur % 2 == 1) {\n                setmin(k, cur);\n            } else if (cur > 0) {\n                setmin(k, cur + 1);\n            }\n            cur = 0;\n        }\n    }\n    //cout << k << endl;\n    int dp[n + 2], pref1[n + 2];\n    fill(dp, dp + n + 2, 0);\n    fill(pref1, pref1 + n + 2, 0);\n    dp[1] = 1;\n    pref1[1] = 1;\n    for (int i = 3; i <= n + 1; i += 2) {\n        int last_add = max(1, i - (k + 1));\n        dp[i] = pref1[i - 2] - (last_add - 2 >= 0 ? pref1[last_add - 2] : 0);\n        if (dp[i] < 0) {\n            dp[i] += MOD;\n        }\n        pref1[i] = (pref1[i - 2] + dp[i]) % MOD;\n    }\n    /*rep(i, 1, n + 2) {\n        cout << dp[i] << \" \";\n    }\n    cout << \"\\n\";*/\n    int ans = dp[n + 1];\n    //cout << k << endl;\n    for (int c = 1; c <= k; c += 2) {\n        //cout << c << \" \" << dp[n - c] << endl;\n        ans = (ans + 1LL * c * dp[n - c]) % MOD;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// input a string\n\tinline void read (char *s){\n\t\tfor(c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tfor(; c >= 'A' && c <= 'Z'; c = gc()) *++s = c;\n\t\t*++s = '\\0';\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: read;\nusing io :: putc;\nusing io :: print;\nconst int N=2e5+5,mod=1e9+7,inf=2e9; \nchar s[N];\nint n,f[N]; \ninline int solve0(ri n){\n\t// f[i] 表示 col_i = R 1 ~ i 的染色方案\n\tf[1]=1; // 强制钦定 col_1 = R \n\tfor(ri i=2;i<=n;++i) f[i]=(f[i-1]+f[i-2])%mod;\n\t// BR...R f[n-1]\n\t// R...RB f[n-1]\n\t// R....R f[n]\n\treturn ((ll)f[n-1]+f[n-1]+f[n])%mod;\n}\nint pre[N]; \ninline int solve1(ri r){\n\t// f[i] 表示 col_i = B 1 ~ i的染色方案 \n\tri i,ans;\n\tfor(i=1;i<=n/2;++i){\n\t\tif(i<=r/2) f[i]=1;\n\t\tf[i]=((ll)f[i]+pre[i-1]-pre[max(0,i-r/2-1)]+mod)%mod;\n\t\tpre[i]=(pre[i-1]+f[i])%mod;\n\t}\n\t// 首先考虑只有一个 B 的情况\n\tif(n<=r)\n\t\tans=n;\n\telse\n\t\tans=0;\n\tfor(i=0;i+1<=n&&i+1<=r;++i) // 枚举 1 ~ i 都为 R \n\t\tans=((ll)ans+pre[max(0,(n-i-1)/2)]-pre[max(0,(n-r)/2-1)]+mod)%mod; \n\treturn ans;\n}\nint main(){\n\tri m,i,j,flag,r;\n\tgi(n);gi(m);\n\tread(s);\n\tif(s[1]=='B'){\n\t\tfor(i=1;i<=m;++i)\n\t\t\ts[i]=s[i]=='B'?'R':'B';\n\t}\n\tflag=1;\n\tfor(i=1;i<=m;++i)\n\t\tif(s[i]!='R'){\n\t\t\tflag=0;\n\t\t\tbreak;\n\t\t}\n\tif(flag)\n\t\treturn printf(\"%d\\n\",solve0(n)),0;\n\tif(n&1) return puts(\"0\"),0;\n\tr=inf;\n\tfor(i=1;i<=m;++i){\n\t\tif(s[i]!='R') continue;\n\t\tfor(j=i;j+1<=m&&s[j+1]=='R';++j);\n\t\tif(i==1) r=min(r,j-i+1+1);\n\t\telse if(j==m){\n\t\t\ti=j;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(j-i+1&1) r=min(r,j-i+1);\n\t\ti=j;\n\t}\n\tif(~r&1) --r;\n\tprintf(\"%d\\n\",solve1(r+1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nchar S[210000];\nlong long bit[210000];\nlong long sum(int a,int b){\n\tif(a)return (sum(0,b)-sum(0,a-1)+mod)%mod;\n\tlong long ret=0;\n\tfor(;b>=0;b=(b&(b+1))-1)ret+=bit[b];\n\treturn ret%mod;\n}\nvoid add(int a,long long b){\n\tfor(;a<210000;a|=a+1)bit[a]=(bit[a]+b)%mod;\n}\nlong long dp[210000][2][2];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tscanf(\"%s\",S);\n\tif(S[0]=='B'){\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(S[i]=='B')S[i]='R';\n\t\t\telse S[i]='B';\n\t\t}\n\t}\n\tlong long ret=0;\n\tint chk=0;\n\tfor(int i=0;i<b;i++){\n\t\tif(S[i]=='B')chk=1;\n\t}\n\tif(chk==0){\n\t\tdp[1][0][0]=1;\n\t\tdp[1][1][1]=1;\n\t\tfor(int i=1;i<a;i++){\n\t\t\tdp[i+1][0][0]=(dp[i+1][0][0]+dp[i][0][0]+dp[i][1][0])%mod;\n\t\t\tdp[i+1][1][0]=(dp[i+1][1][0]+dp[i][0][0])%mod;\n\t\t\tdp[i+1][0][1]=(dp[i+1][0][1]+dp[i][0][1]+dp[i][1][1])%mod;\n\t\t\tdp[i+1][1][1]=(dp[i+1][1][1]+dp[i][0][1])%mod;\n\t\t\t\n\t\t}\n\t\tret=(dp[a][0][0]+dp[a][0][1]+dp[a][1][0])%mod;\n\t\tprintf(\"%lld\\n\",ret);\n\t\treturn 0;\n\t}\n\tif(a%2){\n\t\tprintf(\"0\\n\");return 0;\n\t}\n\tbool wolf=true;\n\tint fi=0;\n\tint tmp=0;\n\tfor(int i=0;i<b;i++){\n\t\tif(S[i]=='B'){\n\t\t\tif(wolf){\n\t\t\t\tfi=tmp;tmp=0;\n\t\t\t\twolf=false;\n\t\t\t}else{\n\t\t\t\tif(tmp%2){\n\t\t\t\t\tprintf(\"2\\n\");return 0;\n\t\t\t\t}\n\t\t\t\ttmp=0;\n\t\t\t}\n\t\t}else{\n\t\t\ttmp++;\n\t\t}\n\t}\n\ta/=2;\n\tadd(1,1);\n\tif(fi%2)return 0;\n\tfor(int i=2;i<=a;i++){\n\t\tint L;\n\t\tL=max(1,i-1-fi/2);\n\t\tlong long tmp=sum(L,i-1);\n\t\tadd(i,tmp);\n\t}\n\tfor(int i=1;i<=a;i++){\n\t//\tif(a-i>fi)continue;\n\t\tif(a-i>fi/2)continue;\n\t//\tprintf(\"%d: %lld\\n\",i,sum(i,i));\n\t\tret=(ret+(a+1-i)*sum(i,i))%mod;\n\t}\n\tret=ret*2%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#else\n#define LLFORMAT \"ll\"\n#endif\n\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tstatic constexpr int mod = 1e9 + 7;\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\tif(s[0] == 'R') for (auto &c: s) c = 'R' + 'B' - c;\n\tbool flag_R = false;\n\tfor (auto c: s) if(c == 'R') { flag_R = true; break; }\n\tif(flag_R) {\n\t\tint limit, i = 0, cnt = 0;\n\t\twhile(i < m && s[i] == 'B') {\n\t\t\t++cnt;\n\t\t\t++i;\n\t\t}\n\t\tif(cnt & 1) limit = cnt;\n\t\telse limit = cnt + 1;\n\t\twhile(i < m && s[i] == 'R') ++i;\n\t\tfor(;;) {\n\t\t\tcnt = 0;\n\t\t\twhile(i < m && s[i] == 'B') {\n\t\t\t\t++cnt;\n\t\t\t\t++i;\n\t\t\t}\n\t\t\tif(i == m) break;\n\t\t\tif(cnt & 1) limit = min(limit, cnt);\n\t\t\twhile(i < m && s[i] == 'R') ++i;\n\t\t}\n\t\tvector<int> dp(n + 1, 0);\n\t\tdp[1] = 1;\n\t\tint sum = 1;\n\t\tfor (int i = 3; i <= n; i += 2) {\n\t\t\tif(i - (limit + 2 + 1) > 0) sum = (sum - dp[i - (limit + 2 + 1)]) % mod;\n\t\t\tdp[i] = sum;\n\t\t\tsum = (sum + dp[i]) % mod;\n\t\t}\n\t\tif(n & 1) { cout << \"0\\n\"; return 0; }\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; i += 2) {\n\t\t\tint j = n - i;\n\t\t\tif(j && j <= limit) ans = ((long long) dp[i] * (j + 1) + ans) % mod;\n\t\t}\n\t\tcout << (ans + mod) % mod << endl;\n\t}\n\telse {\n\t\tvector<int> dp[2][2];\n\t\tfor (int a = 0; a < 2; ++a) for (int b = 0; b < 2; ++b) dp[a][b].resize(n, 0);\n\t\tdp[0][0][0] = dp[1][1][0] = 1;\n\t\tint t;\n\t\tfor (int i = 0; i < n - 1; ++i) for (int a = 0; a < 2; ++a) for (int b = 0; b < 2; ++b) if(t = dp[a][b][i]) {\n\t\t\tdp[a][0][i + 1] = (dp[a][0][i + 1] + t) % mod;\n\t\t\tif(!b) dp[a][1][i + 1] = (dp[a][1][i + 1] + t) % mod;\n\t\t}\n\t\tcout << (((dp[0][0][n - 1] + dp[0][1][n - 1]) % mod + dp[1][0][n - 1]) % mod + mod) % mod << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//I forgot you...\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = (int)1e9 + 7;\nconst int MAXN = (int)2e5 + 3;\nconst int infint = (int)1e9 + 3;\nconst ll inf = (ll)1e18;\nint n, m, ans, mika = infint, dp[MAXN], part[MAXN];\nstring s;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif(c >= MOD)\n\t\tc -= MOD;\n\tif(c < 0)\n\t\tc += MOD;\n\treturn c;\n}\nint mul(int a, int b)\n{\n\tint c = 1LL * a * b % MOD;\n\treturn c;\n}\nvoid find_mika()\n{\n\tif(s[0] == 'R')\n\t{\n\t\tint ted = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif(s[i] == 'R')\n\t\t\t\tted++;\n\t\t\telse\n\t\t\tif(s[i] == 'B' && ted > 0)\n\t\t\t{\n\t\t\t\tif(ted % 2)\t\n\t\t\t\t\tmika = min(mika, ted);\n\t\t\t\telse\n\t\t\t\t\tmika = min(mika, ted + 1);\n\t\t\t\tted = 0;\n\t\t\t}\n\t\tif(ted > 0)\n\t\t{\n\t\t\tif(ted % 2)\n\t\t\t\tmika = min(mika, ted);\n\t\t\telse\n\t\t\t\tmika = min(mika, ted + 1);\n\t\t}\n\t}\n\telse\n\t{\n\t\tint ted = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif(s[i] == 'B')\n\t\t\t\tted++;\n\t\t\telse\n\t\t\tif(s[i] == 'R' && ted > 0)\n\t\t\t{\n\t\t\t\tif(ted % 2)\n\t\t\t\t\tmika = min(mika, ted);\n\t\t\t\telse\n\t\t\t\t\tmika = min(mika, ted + 1);\n\t\t\t\tted = 0;\n\t\t\t}\n\t\tif(ted > 0)\n\t\t{\n\t\t\tif(ted % 2)\n\t\t\t\tmika = min(mika, ted);\n\t\t\telse\n\t\t\t\tmika = min(mika, ted + 1);\n\t\t}\n\t}\n}\nint getzarib(int kaman)\n{\n\tint emp = n - kaman;\n\tif(emp == 0)\n\t\treturn 1;\n\telse\n\t\treturn n - emp;\n}\nint main()\n{\n\tios::sync_with_stdio(false); \n\tcin.tie(0); cout.tie(0);\n\tcin >> n >> m >> s;\n\tfind_mika();\n\tbool flg = 1;\n\tfor (int i = 1; i < s.size(); i++)\n\t\tif(s[i] != s[0])\t\n\t\t\tflg = 0;\n\tif(flg)\n\t{\n\t\tdp[1] = 1, dp[2] = 2;\n\t\tfor (int i = 3; i <= n; i++)\n\t\t\tdp[i] = add(dp[i - 1], dp[i - 2]);\n\t\t\n\t\tans = dp[n];\n\t\tif(n >= 3)\n\t\t\tans = add(ans, dp[n - 2]);\n\t\tcout << ans;\n\t\treturn 0;\n\t}\n\tdp[0] = 1;\n\tpart[0] = 1;\n\tfor (int i = 2; i <= n; i += 2)\n\t{\n\t\tdp[i] = part[i - 2];\n\t\tif(i - mika - 3 >= 0)\n\t\t\tdp[i] = add(dp[i], -part[i - mika - 3]);\n\t\tpart[i] = add(part[i - 2], dp[i]);\n\t}\n\tans = add(ans, dp[n]);\n\tfor (int i = 1; i <= mika; i += 2)\n\t\tif(i != n - 2 && i != n)\n\t\t\tans = add(ans, mul(getzarib(i), dp[n - i - 1]));\n\t\telse\n\t\tif(i == n)\n\t\t\tans = add(ans, 1);\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nchar S[210000];\nlong long bit[210000];\nlong long sum(int a,int b){\n\tif(a)return (sum(0,b)-sum(0,a-1)+mod)%mod;\n\tlong long ret=0;\n\tfor(;b>=0;b=(b&(b+1))-1)ret+=bit[b];\n\treturn ret%mod;\n}\nvoid add(int a,long long b){\n\tfor(;a<210000;a|=a+1)bit[a]=(bit[a]+b)%mod;\n}\nlong long dp[210000][2][2];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tscanf(\"%s\",S);\n\tif(S[0]=='B'){\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(S[i]=='B')S[i]='R';\n\t\t\telse S[i]='B';\n\t\t}\n\t}\n\tlong long ret=0;\n\tint chk=0;\n\tfor(int i=0;i<b;i++){\n\t\tif(S[i]=='B')chk=1;\n\t}\n\tif(chk==0){\n\t\tdp[1][0][0]=1;\n\t\tdp[1][1][1]=1;\n\t\tfor(int i=1;i<a;i++){\n\t\t\tdp[i+1][0][0]=(dp[i+1][0][0]+dp[i][0][0]+dp[i][1][0])%mod;\n\t\t\tdp[i+1][1][0]=(dp[i+1][1][0]+dp[i][0][0])%mod;\n\t\t\tdp[i+1][0][1]=(dp[i+1][0][1]+dp[i][0][1]+dp[i][1][1])%mod;\n\t\t\tdp[i+1][1][1]=(dp[i+1][1][1]+dp[i][0][1])%mod;\n\t\t\t\n\t\t}\n\t\tret=(dp[a][0][0]+dp[a][0][1]+dp[a][1][0])%mod;\n\t\tprintf(\"%lld\\n\",ret);\n\t\treturn 0;\n\t}\n\tif(a%2){\n\t\tprintf(\"0\\n\");return 0;\n\t}\n\tbool wolf=true;\n\tint fi=0;\n\tint tmp=0;\n\tfor(int i=0;i<b;i++){\n\t\tif(S[i]=='B'){\n\t\t\tif(wolf){\n\t\t\t\tfi=tmp;tmp=0;\n\t\t\t\twolf=false;\n\t\t\t}else{\n\t\t\t\tif(tmp%2){\n\t\t\t\t\tprintf(\"2\\n\");return 0;\n\t\t\t\t}\n\t\t\t\ttmp=0;\n\t\t\t}\n\t\t}else{\n\t\t\ttmp++;\n\t\t}\n\t}\n\ta/=2;\n\tadd(1,1);\n\tfor(int i=2;i<=a;i++){\n\t\tint L;\n\t\tif(fi%2==0)L=max(1,i-1-fi/2);\n\t\telse L=max(1,i-1-fi/2);\n\t\tlong long tmp=sum(L,i-1);\n\t\tadd(i,tmp);\n\t}\n\tfor(int i=1;i<=a;i++){\n\t//\tif(a-i>fi)continue;\n\t\tif(a-i>fi/2)continue;\n\t//\tprintf(\"%d: %lld\\n\",i,sum(i,i));\n\t\tret=(ret+(a+1-i)*sum(i,i))%mod;\n\t}\n\tret=ret*2%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1, typename T2>\ninline bool chmax (T1& a, T2 b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\nconstexpr int md = 1e9 + 7;\ninline void mad(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\ninline void msb(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\ninline int mul(int a, int b) {\n  return (int)((long long)a * b % md);\n}\ninline int mow(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n      b--;\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\ntemplate<typename T>\nclass run_length_encoding {\n  vector<pair<int, T>> rle;\n  public:\n    run_length_encoding(\n        vector<T> input\n      ) :\n      rle(0)\n      {\n        int cnt = 0;\n        for (auto it = input.begin(); it != input.end(); it++) {\n          auto jt = next(it); cnt++;\n          if (jt == input.end() || *it != *jt) {\n            rle.emplace_back(cnt, *it);\n            cnt = 0;\n          }\n        }\n      }\n    auto const& code () const {return rle;}\n};\nint main() {\n  int n, m; string s;\n  cin >> n >> m >> s;\n  vector<int> a(m);\n  for (int i = 0; i < m; i++) a[i] = s[0] == s[i];\n  auto rle = run_length_encoding<int>(a).code();\n  if (rle.size()  == 1) {\n    vector<int> dp(n + 1, 0);\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n      mad(dp[i], dp[i - 1]);\n      mad(dp[i], dp[i - 2]);\n    }\n    for (int i = n; i >= 1; i--) msb(dp[i], dp[i - 1]);\n    int ret = 0;\n    for (int i = 0; i < n; i++) {\n      mad(ret, mul(i + 1, dp[n - i]));\n    }\n    cout << ret << endl;\n    return 0;\n  }\n  if (n & 1) {\n    cout << 0 << endl;\n    return 0;\n  }\n  n >>= 1;\n  int k = 1;\n  for (auto it = rle.begin(); it < rle.end() - 1; it += 2) {\n    int m = it->first;\n    if (m & 1) chmax(k, (m + 1) >> 1);\n    else if (it == rle.begin()) chmax(k, (m + 2) >> 1);\n  }\n  vector<int> dp(n + 1, 0);\n  dp[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    mad(dp[i], dp[i - 1]);\n    mad(dp[i], dp[i - 1]);\n    if (i - k - 1 >= 0) msb(dp[i], dp[i - k - 1]);\n  }\n  for (int i = n; i >= 1; i--) msb(dp[i], dp[i - 1]);\n  int ret = 0;\n  for (int i = 0; i < k; i++) {\n    mad(ret, mul(i + 1, dp[n - i]));\n  }\n  mad(ret, ret);\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nchar str[200005];\nint arr[200005];\nlong long MOD=1000000007;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",str);\n\tfor(int i=0;i<m;i++)if(str[i]=='R')arr[i]=0;else arr[i]=1;\n\tbool all[2];all[0]=all[1]=1;\n\tfor(int i=0;i<m;i++)all[arr[i]^1]=0;\n\tif(all[0]||all[1]){\n\t\tlong long dp[2][n];memset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;dp[1][0]=0; //start with red (or blue if everything is blue)\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tlong long ans=(dp[0][n-1]+dp[1][n-1])%MOD;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=0;dp[1][0]=1; //start with blue\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tans+=dp[0][n-1];ans%=MOD;ans+=MOD;ans%=MOD;\n\t\tprintf(\"%lld\",ans);\n\t\treturn 0;\n\t}\n\tif(n%2!=0){printf(\"0\");return 0;}\n\tint cur=0;bool b=0;\n\tint mxl=n-1;\n\tfor(int i=0;i<m;i++){\n\t\tif(arr[i]==arr[0])cur++;\n\t\telse{\n\t\t\tif(!b){\n\t\t\t\tb=1;mxl=min(mxl,cur^1);\n\t\t\t}else if(cur%2==1)mxl=min(mxl,cur);\n\t\t\tcur=0;\n\t\t}\n\t}\n\t//can ignore last segment of arr[0]\n\t//comments: wlog red is first\n\tn/=2; mxl/=2; //remove the ones that are different parity from blue\n\tlong long dp[100005],pref[100005];\n\tmemset(dp,0,sizeof(dp));memset(pref,0,sizeof(pref));\n\t//i segments on a line, first and last are blue, max mxl consecutive reds\n\t//blues may be consecutive because the reds in between were removed\n\tdp[1]=pref[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tdp[i]=pref[i-1]-pref[max(0,i-(mxl+2))];\n\t\tdp[i]%=MOD;dp[i]+=MOD;dp[i]%=MOD;\n\t\tpref[i]=dp[i]+pref[i-1];\n\t\tpref[i]%=MOD;pref[i]+=MOD;pref[i]%=MOD;\n\t}\n\tlong long ans=0;\n\tfor(long long i=2;i<=min(n,mxl+2);i++){\n\t\tans+=(i-1LL)*dp[n-i+2];\n\t\tans%=MOD;\n\t}\n\tans+=MOD;ans%=MOD;\n\tprintf(\"%lld\",(ans*2)%MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ii pair<int,int>\n#define ll long long\n\nint n;\nint arr[200005];\nint brr[200005];\npriority_queue<ii> pq;\n\nvoid rage(){\n\tprintf(\"-1\\n\");\n\texit(0);\n}\n\nint main(){\n\tcin>>n;\n\tfor (int x=0;x<n;x++) cin>>arr[x];\n\tfor (int x=0;x<n;x++) cin>>brr[x];\n\t\n\tfor (int x=0;x<n;x++){\n\t\tif (arr[x]>brr[x]) rage();\n\t\telse if (arr[x]<brr[x]) pq.push(ii(brr[x],x));\n\t}\n\t\n\tint pos,temp;\n\tll ans=0;\n\twhile (!pq.empty()){\n\t\t//printf(\"%d %d\\n\",pq.top().first,pq.top().second);\n\t\tpos=pq.top().second,pq.pop();\n\t\t\n\t\ttemp=brr[(pos+1)%n]+brr[(pos-1+n)%n];\n\t\t\n\t\tif (brr[pos]<=temp) rage();\n\t\tans+=brr[pos]/temp;\n\t\tbrr[pos]%=temp;\n\t\tif (brr[pos]==0) brr[pos]=temp,ans--;\n\t\t\n\t\tif (arr[pos]>brr[pos]) rage();\n\t\telse if (arr[pos]<brr[pos]){\n\t\t\tpq.push(ii(brr[pos],pos));\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint N, M; char S[200200];\n\nconst long long mod = 1000000007;\nlong long D[200200], V[200200];\n\nint main()\n{\n\tscanf (\"%d %d %s\", &N, &M, S);\n\tif (S[0] == 'B'){\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tif (S[i] == 'R') S[i] = 'B';\n\t\t\telse S[i] = 'R';\n\t\t}\n\t}\n\n\tvector<int> len;\n\tfor (int i = 1, l = -1; i < M; i++){\n\t\tif (S[i-1] == 'R' && S[i] == 'B'){\n\t\t\tint u = i - l - 1;\n\t\t\tlen.push_back(u);\n\t\t}\n\t\tif (S[i] == 'B') l = i;\n\t}\n\n\tif (M == 1){\n\t\tlong long ans = 1;\n\t\tfor (int i = 0; i < N; i++) ans = ans * 2 % mod;\n\t\tans = (ans + mod - 1) % mod;\n\t\tprintf (\"%lld\\n\", ans);\n\t\treturn 0;\n\t}\n\tif (len.empty()){\n\t\tif (N == 2){\n\t\t\tprintf (\"3\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tD[0] = 1;\n\t\tD[1] = 2;\n\t\tfor (int i = 2; i <= N; i++) D[i] = (D[i - 1] + D[i - 2]) % mod;\n\t\tprintf (\"%lld\\n\", (D[N - 1] + D[N - 3]) % mod);\n\t\treturn 0;\n\t}\n\n\tint lim = len[0];\n\tif (lim % 2 == 0) lim++;\n\tfor (int i = 1; i < len.size(); i++){\n\t\tif (len[i] % 2){\n\t\t\tif (lim > len[i])\n\t\t\t\tlim = len[i];\n\t\t}\n\t}\n\n\tD[0] = V[0] = 1;\n\tfor (int i = 1; i <= N; i++){\n\t\tif (i <= lim + 1) D[i] = i - 1;\n\t\tlong long u = 0, v = 0;\n\t\tif (i >= 2) u = V[i - 2];\n\t\tif (i >= lim + 3) v = V[i - (lim + 3)];\n\t\tD[i] = (D[i] + u + mod - v) % mod;\n\n\t\tV[i] = D[i];\n\t\tif (i >= 2) V[i] = (V[i] + V[i - 2]) % mod;\n\t}\n\tprintf (\"%lld\\n\", D[N]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n;\nint m;\nstring s;\nint mn = INF;\nll ans ;\nll dp[200005][2][2];\n\nstruct RMQ{\n\t#define ss (1<<19)\n\tll seg[ss];\n\tvoid update(int k,ll a){\n\t\tk+=ss/2-1; seg[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tseg[k]=(seg[k*2+1]+seg[k*2+2])%mod;\n\t\t}\n\t}\n\tll query(int a,int b,int k,int l,int r){\n\t\tif(r<a || b<l) return 0;\n\t\tif(a<=l && r<=b) return seg[k];\n\t\telse{\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2+1,r);\n\t\t\treturn (vl+vr)%mod;\n\t\t}\n\t}\n}rmq[2];\n\nint main(){\n\tcin>>n>>m>>s;\n\tif(s[0] == 'B'){\n\t\trep(i,m){\n\t\t\tif(s[i] == 'B') s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\t\tint cur = 0;\n\t\tchar ch;\n\t\tbool beg = 0;\n\t\tint C = 0;\n\t\trep(i,m){\n\t\t\tif(i == 0){\n\t\t\t\tch = s[i];\n\t\t\t\tcur = 1;\n\t\t\t}\n\t\t\telse if(ch != s[i]){\n\t\t\t\tif(ch == 'R'){\n\t\t\t\t\tif(cur%2 == 1) mn = min(mn,cur);\n\t\t\t\t\telse if(!beg) mn = min(mn,cur+1);\n\t\t\t\t\tbeg = 1; C++;\n\t\t\t\t}\n\t\t\t\t\tch = s[i];\n\t\t\t\t\tcur = 1;\n\t\t\t//\t\tbeg = 1; C++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse cur++;\n\t\t}\n\t\t\t\tif(ch == 'R'){\n\t\t\t\t\tif(cur%2 == 1) mn = min(mn,cur);\n\t\t\t\t\telse if(!beg) mn = min(mn,cur+1);\n\t\t\t\t\tbeg = 1; C++;\n\t\t\t\t}\n\t\t\t\t//cout<<C<<endl;\n\t\t\t\t\t//ch = s[i];\n\t\t\t\t\tcur = 1;\n\t\t\t//\t\tbeg = 1; C++;\n\t\t\t//cout<<C<<\" \"<<mn<<endl;\n\t\tif(C == 1){\n\t\t    //assert(mn == m);\n\t\t\t//BBが存在しなければOK\n\t\t\tdp[0][0][0] = dp[0][1][1] = 1;\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\trep(x,2){\n\t\t\t\t\tdp[i+1][0][x] += dp[i][0][x];\n\t\t\t\t\tdp[i+1][1][x] += dp[i][0][x];\n\t\t\t\t\tdp[i+1][0][x] += dp[i][1][x];\n\t\t\t\t\tdp[i+1][0][x] %= mod;\n\t\t\t\t\tdp[i+1][1][x] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<((dp[n-1][0][0]+dp[n-1][0][1]+dp[n-1][1][0])%mod+mod)%mod<<endl;\n\t\t\tassert(0);\n\t\t}\n\t\telse{\n\t\t\tif(n%2 == 1){\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[0][0][0] = 1;\n\t\t\trmq[0].update(0,1);\n\t\t\tfor(int i=2;i<n;i+=2){\n\t\t\t\tdp[i][0][0] = rmq[i%2].query(max(0,i-mn-1),i,0,0,(1<<18)-1);\n\t\t\t\trmq[i%2].update(i,dp[i][0][0]);\n\t\t\t}\n\t\t\tll ans = 0;\n\t\t\tfor(int m=1;m<=n;m++){\n\t\t\t\tif(m-1 > mn) continue;\n\t\t\t\tans += dp[n-m][0][0] * 1LL * m % mod;\n\t\t\t}\n\t\t\tcout << (ans%mod+mod)%mod << endl;\n\t\t\n\t\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200010;\nconst int mod = 1e9 + 7;\n\ntypedef long long LL;\n\nchar s[N];\n\nint f[N], g[N], dp[2][2][N];\n\nint main() {\n    int n, m; scanf(\"%d%d%s\", &n, &m, s + 1);\n    bool flag = false;\n    for (int i = 1; i <= m; i++) if (s[i] != s[1]) {\n        flag = true; break;\n    } \n    if (flag) {\n        if (n & 1) return puts(\"0\"), 0;\n        int fir = 0;\n        for (int i = 1; i <= m; i++) if (s[i] != s[1]) {\n            fir = i - 1; break;\n        }\n        int lim = fir | 1;\n        for (int i = fir + 1; i <= m; i++) if (s[i] != s[1]) {\n            int j = i + 1;\n            while (j <= m && s[j] == s[1]) j++;\n            if (j <= m && (j - i - 1) % 2 == 1) lim = min(lim, j - i - 1); \n        } \n        n /= 2, lim = (lim + 1) / 2;\n        for (int i = 1; i <= lim; i++) f[i] = i * 2;\n        for (int i = 1, diff = 0; i <= n; i++) {\n            diff = (diff + g[i]) % mod, f[i] = (f[i] + diff) % mod;\n            if (i + 1 <= n) g[i + 1] = (g[i + 1] + f[i]) % mod;\n            if (i + lim + 1 <= n) g[i + lim + 1] = (g[i + lim + 1] - f[i] + mod) % mod;\n        }\n        printf(\"%d\\n\", f[n]);\n    } else {\n        dp[1][1][1] = dp[0][0][1] = 1;\n        for (int i = 2; i <= n; i++) \n            for (int t = 0; t <= 1; t++) {\n                dp[t][0][i] = (dp[t][1][i - 1] + dp[t][0][i - 1]) % mod;\n                dp[t][1][i] = dp[t][0][i - 1];\n            }\n        printf(\"%d\\n\", ((LL)dp[1][0][n] + dp[0][0][n] + dp[0][1][n]) % mod);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define P 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n, m;\n\nchar ch[400010];\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n\tll ans = 1;\n\twhile(y) {\n\t\tif(y & 1) ans = ans * x % p;\n\t\tx = x * x % p;\n\t\ty >>= 1;\n\t}\n\treturn ans;\n}\n\nll F[400010][2][2], G[400010][2][2], H[400010], SH[400010], SG[400010][2][2];\n\n// G1 : ABABABA\n// G2 : BABABAB\n\nvoid cmin(int &x, int y) {if(x > y) x = y;}\n\nvoid add(ll &x, ll y) {x = (x + y) % P;}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", ch + 1);\n\tll ans = 0;\n\t// qingyise\n\tint sub1 = 1;\n\tfor(int i = 2; i <= m; i++) if(ch[i] != ch[1]) sub1 = 0;\n\tif(sub1 == 1) {\n\t\tF[0][0][0] = 1;\n\t\tF[0][1][1] = 1;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\tF[i][j][0] = (F[i - 1][j][0] + F[i - 1][j][1]) % P;\n\t\t\t\tF[i][j][1] = (F[i - 1][j][0]) % P;\n\t\t\t}\n\t\tans = (F[n][0][0] + F[n][1][1]) % P;\n\t\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\t\treturn 0;\n\t}\n\tif(n % 2 == 1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tvector <int> V(1, 1);\n\tfor(int i = 2; i <= m; i++) if(ch[i] == ch[i - 1]) V.back()++; else V.push_back(1);\n\tint l = 0, r = 0, mnA = n + 5, mnB = n + 5, nw = 0;\n\tfor(int i = 1; i < V.size(); i += 2) {\n\t\tif(V[i] % 2 == 1) nw ^= 1;\n\t\tif(V[i + 1] % 2 == 1) {\n\t\t\tif(nw == 0) cmin(mnA, V[i + 1]); else cmin(mnB, V[i + 1]);\n\t\t}\n\t}\n\tcmin(mnA, V[0] + !(V[0] % 2));\n\tH[1] = 1, SH[1] = 1;\n\tfor(int i = 3; i <= n + 1; i += 2) {\n\t\tH[i] = SH[i - 2];\n\t\tif(i >= min(mnA, mnB) + 3) {\n\t\t\tadd(H[i], -SH[i - (min(mnA, mnB) + 3)]);\n\t\t}\n\t\t//H[i] = -H[i];\n\t\tSH[i] = (H[i] + SH[i - 2]) % P;\n\t}\n\tfor(int i = 1; i <= n; i += 2) {\n\t\t//if(n - i <= mnA) add(ans, G[i][1][1] * (n - i + 1));\n\t\t//if(n - i <= mnB) add(ans, G[i][0][0] * (n - i + 1));\n\t\tif(n - i <= min(mnA, mnB)) add(ans, H[i] * (n - i + 1));\n\t}\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int Q=1<<19;\nchar s[Q];\nint n,m;\nconst int MOD=1e9+7;\ninline int add(int a,int b)\n{a+=b;return a>=MOD?a-MOD:a;}\ninline int sub(int a,int b)\n{a-=b;return a<0?a+MOD:a;}\ninline int mul(int a,int b)\n{return 1LL*a*b%MOD;}\nint dp[Q];\nvoid DP(int n,int lim)\n{\n\tdp[0]=1;\n\tint sm=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i>lim)sm=sub(sm,dp[i-lim-1]);\n\t\tdp[i]=sm;\n\t\tsm=add(sm,dp[i]);\n\t}\n}\nvoid s1()\n{\n\texit(-1);\n\tdp[0]=1;\n\tint sm=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(i>=2)sm=add(sm,dp[i-2]);\n\t\tdp[i]=sm;\n\t}\n\tint als=1;\n\tfor(int i=2;i<=n;i++){\n\t\tals=add(als,mul(i,dp[n-i]));\n\t}\n\tprintf(\"%d\\n\",als);\n}\nvoid s2(int fir)\n{\n\tif(n&1){\n\t\tputs(\"0\");\n\t\treturn;\n\t}\n\tint mus=fir+(fir%2==0);\n\tfor(int len=0,i=fir+2;i<=m;i++){\n\t\tif(s[i]==s[1])++len;\n\t\telse{\n\t\t\tif(len&1)mus=min(mus,len);\n\t\t\tlen=0;\n\t\t}\n\t}\n\tn/=2,mus=(mus+1)/2;\n\t// printf(\"%d %d WCNM\\n\",n,mus);\n\t\n\tDP(n,mus);\n\t// for(int i=0;i<=n;i++)\n\t\t// printf(\"%d ????\\n\",dp[i]);\n\tint als=0;\n\tfor(int i=1;i<=n&&i<=mus;i++){\n\t\tals=add(als,mul(2*i,dp[n-i]));\n\t}\n\tprintf(\"%d\",als);\n}\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tfor(int i=2;i<=m;i++)\n\t\tif(s[i]!=s[1]){\n\t\t\ts2(i-1);\n\t\t\treturn 0;\n\t\t}\n\ts1();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=a*b%mod\n\nll n,m;\nstring s;\nint main(){\n    cin>>n>>m>>s;\n    if(s[0]=='R'){\n\tfor(int i=0;i<n;i++){\n\t    if(s[i]=='R')s[i]='B';\n\t    else s[i]='R';\n\t}\n    }\n    bool th=0;\n    ll cnt=0,mi=1e17;\n    bool fi=1; ll lead;\n    for(int i=0;i<n;i++){\n\tif(s[i]=='R'){\n\t    if(fi)lead=cnt; fi=0;\n\t    th=1;\n\t    if(cnt%2==1)chmin(mi,cnt);\n\t    cnt=0;\n\t}\n\telse cnt++;\n    }\n    if(th==0){\n\tll f[100010];\n\tf[0]=f[1]=1;\n\tfor(int i=2;i<n;i++){\n\t    f[i]=f[i-1]+f[i-2];\n\t}\n\tll ans=(f[n-2]*2+f[n-1])%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n    }\n    if(n%2==1){\n\tcout<<0<<endl;\n\treturn 0;\n    }\n    if(lead%2==0)lead++;\n    chmin(mi,lead);\n    mi=(mi+1)/2;\n    chmin(mi,n/2);\n    ll f[100010],rui[100010];\n    f[0]=rui[0]=0;\n    for(ll i=1;i<=mi;i++){\n\tf[i]=i;\n\trui[i]=(rui[i-1]+i)%mod;\n    }\n    for(int i=1;i<n/2;i++){\n\tmad(f[i],rui[i-1]);\n\tif(i-mi-1>=0)mad(f[i],-rui[i-mi-1]);\n\trui[i]=(rui[i-1]+f[i])%mod;\n    }\n    ll ans=0;\n    for(int i=1;i<=mi;i++)mad(ans,f[n/2-i]);\n    //cout<<mi<<endl;\n    //for(int i=0;i<n/2;i++)cout<<i<<\":\"<<f[i]<<endl;\n    ans=ans*2%mod;\n    if(ans<0)ans+=mod;\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define mod 1000000007\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nchar S[200010];\nint f[200010],sf[200010];\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),m=gi(),all=0;\n\tscanf(\"%s\",S+1);\n\tint L=1145141;\n\tfor(int l=1,r;l<=m;l=r+1){\n\t\tr=l;if(S[l]!=S[1])continue;\n\t\twhile(r<m&&S[r+1]==S[r])++r;\n\t\tif(r-l&1)\n\t\t\tif(r<m)cnk(L,r-l+2);\n\t\t\telse if(l==1)all=1;\n\t}\n\tif(all){\n\t\tstatic int f[200010][2];\n\t\tint ans=0;\n\t\tfor(int fir=0;fir<2;++fir){\n\t\t\tmemset(f,0,sizeof f);\n\t\t\tf[1][fir]=1;\n\t\t\tfor(int i=1;i<=n;++i){\n\t\t\t\tinc(f[i+1][0],f[i][1]);\n\t\t\t\tinc(f[i+1][1],f[i][0]);\n\t\t\t\tinc(f[i+1][1],f[i][1]);\n\t\t\t}\n\t\t\tif(fir)inc(ans,f[n][0]);\n\t\t\tinc(ans,f[n][1]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(L&1)++L;\n\tf[1]=sf[1]=1;\n\tfor(int i=2;i<=n;++i)f[i]=(sf[i-2]-(i-L-2<0?0:sf[i-L-2])+mod)%mod,sf[i]=(f[i]+sf[i-2])%mod;\n\tint ans=0;\n\tfor(int i=n-1;n-i<L&&i>=0;i-=2)\n\t\tinc(ans,1ll*(n-i+1)*f[i]%mod);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// 入力\nlong long mod = 1000000007;\nlong long N, M;\nstring S;\n\n// その他\nlong long fib[1 << 19];\nlong long dp[1 << 19], ru[1 << 19];\nlong long ret[1 << 19];\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 32; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nlong long Div(long long p, long long q, long long m) {\n\treturn (p * modpow(q, m - 2, m)) % m;\n}\n\nlong long solve(long long n, long long r) {\n\tfor (int i = 0; i <= n / 2; i++) dp[i] = 0;\n\tfor (int i = 1; i <= r / 2; i++) dp[i] = 1LL * (i * 2);\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tlong long v = ru[i - 1]; if (i - (r / 2) - 1 >= 0) v -= ru[i - (r / 2) - 1];\n\t\tv = (v + mod) % mod;\n\t\tdp[i] += v; dp[i] %= mod;\n\t\tru[i] = (dp[i] + ru[i - 1]) % mod;\n\t}\n\t\n\tlong long val = dp[n / 2];\n\treturn val;\n}\n\nint main() {\n\tcin >> N >> M >> S;\n\n\t// 判定\n\tbool flag = false;\n\tfor (int i = 0; i < S.size() - 1; i++) {\n\t\tif (S[i] != S[i + 1]) flag = true;\n\t}\n\n\t// 特殊\n\tif (flag == false) {\n\t\tfib[0] = 1;\n\t\tfib[1] = 1;\n\t\tfor (int i = 2; i <= N; i++) fib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t\tcout << (fib[N] + fib[N - 2]) % mod << endl;\n\t\treturn 0;\n\t}\n\n\t// 奇数\n\tif (N % 2 == 1) {\n\t\tcout << \"0\" << endl;\n\t\treturn 0;\n\t}\n\n\t// 偶数\n\tif (S[0] == 'B') {\n\t\tfor (int i = 0; i < S.size(); i++) {\n\t\t\tif (S[i] == 'B') S[i] = 'R';\n\t\t\telse S[i] = 'B';\n\t\t}\n\t}\n\tint MaxLength = N, cur = 0;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] == 'R') cur++;\n\t\telse {\n\t\t\tMaxLength = min(MaxLength, cur);\n\t\t\tcur = 0;\n\t\t}\n\t}\n\tMaxLength += 2;\n\n\tvector<long long> E;\n\tfor (int i = 1; i <= N / 2; i++) {\n\t\tif ((N / 2) % i == 0) E.push_back(i);\n\t}\n\tfor (int i = E.size() - 1; i >= 0; i--) {\n\t\tlong long d1 = (N / E[i]);\n\t\tlong long d2 = MaxLength;\n\t\tret[i] = solve(d1, d2);\n\t\tfor (int j = i + 1; j < E.size(); j++) {\n\t\t\tif (E[j] % E[i] == 0) { ret[i] -= ret[j]; ret[i] = (ret[i] + mod) % mod; }\n\t\t}\n\t}\n\n\tlong long FinalAns = 0;\n\tfor (int i = 0; i < E.size(); i++) {\n\t\tFinalAns += 1LL * ret[i];\n\t\tFinalAns %= mod;\n\t}\n\tcout << FinalAns << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 1e9 + 7;\n\nint n, m;\nchar S[200005];\nvector<int> sizs;\nint dp[200005];\n\nint solve(int tot)\n{\n\tint ret = 0;\n\trep1(i, min(8, tot)) if(i % 2 == 0) {\n\t\tif(tot == i) ret += i;\n\t\telse ret += solve(tot - i);\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d%d%s\", &n, &m, S);\n\t\n\tint ccnt = 1;\n\tfor(int i = 1; i < m; i ++)\n\tif(S[i] != S[i - 1]) {\n\t\tsizs.push_back(ccnt);\n\t\tccnt = 1;\n\t} else ccnt ++;\n\tsizs.push_back(ccnt);\n\t\n\tif(sizs.size() == 1) {\n\t\tdp[1] = 2;\n\t\tdp[2] = MOD - 1;\n\t\trep(i, n) {\n\t\t\tif(i >= 1) dp[i] = (dp[i] + dp[i - 1]) % MOD;\n\t\t}\n\t\trep(i, n) {\n\t\t\tif(i >= 1) dp[i] = (dp[i] + dp[i - 1]) % MOD;\n\t\t\tif(i >= 2) dp[i] = (dp[i] + dp[i - 2]) % MOD;\n\t\t}\n\t\tprintf(\"%d\\n\", dp[n - 1] + 1);\n\t} else {\n\t\tint maxl = min(n, sizs[0] + 2);\n\t\trep(i, sizs.size()) if(!(i & 1) && sizs[i] & 1)\n\t\tmaxl = min(maxl, sizs[i] + 1);\n\t\t\n\t\tdp[1] = 2;\n\t\tdp[1 + maxl] = MOD - 2 - maxl;\n\t\tdp[3 + maxl] = maxl;\n\t\t\n\t\trep(i, n) {\n\t\t\tif(i >= 2) dp[i] = (dp[i] + dp[i - 2]) % MOD;\n\t\t}\n\t\trep(i, n) {\n\t\t\tif(i >= 2) dp[i] = (dp[i] + 2LL * dp[i - 2]) % MOD;\n\t\t\tif(i >= 2 + maxl) dp[i] = (dp[i] + (MOD - 1LL) * dp[i - 2 - maxl]) % MOD;\n\t\t}\n\t\tprintf(\"%d\\n\", dp[n - 1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 2e5 + 10, mod = 1e9 + 7;\n\nll dp[N], pref[N][2];\n\nll solve(int n, int bound, bool parity);\n\nint main() {\n\tfast_cin();\n\tint n, m; string s;\n\tcin >> n >> m >> s;\n\ts += (s.back() ^ 'R' ^ 'B');\n\tvector<int> parts;\n\tint cur = 1;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (s[i] != s[i - 1]) {\n\t\t\tparts.pb(cur);\n\t\t\tcur = 1;\n\t\t} else {\n\t\t\t++cur;\n\t\t}\n\t}\n\tint bound = parts[0] + (1 - (parts[0] & 1));\n\tfor (int i = 2; i + 1 < parts.size(); i += 2) {\n\t\tif (parts[i] & 1) {\n\t\t\tbound = min(bound, parts[i]);\n\t\t}\n\t}\n\tif (parts.size() == 1) {\n\t\tcout << (solve(n, n, false) + 1) % mod << '\\n';\n\t} else {\n\t\tcout << solve(n, bound, true) << '\\n';\n\t}\n}\n\nll solve(int n, int bound, bool parity) {\n\tdp[0] = 1;\n\tpref[0][0] = 1;\n\tif (!parity) {\n\t\tpref[0][1] = 1;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint lo = max(0, i - bound - 1), hi = i - 2;\n\t\tif (lo <= hi) {\n\t\t\tdp[i] = pref[hi][hi & 1] - (lo > 0 ? pref[lo - 1][hi & 1] : 0);\n\t\t\tdp[i] += mod;\n\t\t\tdp[i] %= mod; \n\t\t}\n\t\tpref[i][0] = pref[i - 1][0];\n\t\tpref[i][1] = pref[i - 1][1];\n\t\tpref[i][i & 1] += dp[i];\n\t\tpref[i][i & 1] %= mod;\n\t\tif (!parity) {\n\t\t\tpref[i][(i + 1) & 1] = pref[i][i & 1];\n\t\t}\n\t\t// cout << i << ' ' << dp[i] << '\\n';\n\t}\n\tll ans = dp[n];\n\tfor (int i = 1; i < n and i <= bound; ++i) {\n\t\tint lo = max(i, n + (i - 1) - bound) - i, hi = n - i - 1;\n\t\tif (lo <= hi) {\n\t\t\tans += pref[hi][n & 1] - (lo > 0 ? pref[lo - 1][n & 1] : 0);\n\t\t\tans += mod;\n\t\t\tans %= mod;\n\t\t}\n\t}\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\ninline void add(int &x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nll bin_pow(ll a, ll p) {\n    ll res = 1;\n    while (p) {\n        if (p & 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return res;\n}\n\nll rev(ll x) {\n    return bin_pow(x, MOD - 2);\n}\n\nll fact[N + 1], rfact[N + 1];\n\nvoid init() {\n    fact[0] = 1;\n    rep(i, 1, N + 1) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    rfact[N] = rev(fact[N]);\n    repb(i, N - 1, -1) {\n        rfact[i] = rfact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nll C(int n, int k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    return fact[n] * rfact[k] % MOD * rfact[n - k] % MOD;\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    init();\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    repb(i, m - 1, -1) {\n        s[i] = char('0' + (s[0] != s[i]));\n    }\n    int c1 = 0;\n    rep(i, 0, m) {\n        if (s[i] == '1') {\n            c1++;\n        }\n    }\n    if (c1 == 0) {\n        int ans = 0;\n        for (int i = 0; i * 2 <= n; i++) {\n            add(ans, C(n - i, i));\n            if (i >= 1) {\n                add(ans, C(n - 2 - (i - 1), (i - 1)));\n            }\n        }\n        cout << ans << \"\\n\";\n        return 0;\n    }\n    if (n % 2 == 1) {\n        cout << 0 << \"\\n\";\n        return 0;\n    }\n    assert(false);\n    int k = (n % 2 == 1 ? n : n - 1), cur = 0;\n    rep(i, 0, m) {\n        if (s[i] == '0') {\n            cur++;\n        }\n        if (i == m - 1 || s[i + 1] == '1') {\n            if (cur % 2 == 1) {\n                setmin(k, cur);\n            } else if (cur > 0) {\n                setmin(k, cur * 2 - 3);\n            }\n            cur = 0;\n        }\n    }\n    //cout << k << endl;\n    int dp[n + 2], pref0[n + 2], pref1[n + 2];\n    fill(dp, dp + n + 1, 0);\n    fill(pref0, pref0 + n + 2, 0);\n    fill(pref1, pref1 + n + 2, 0);\n    dp[1] = 1;\n    pref1[1] = 1;\n    rep(i, 2, n + 2) {\n        int last_add = max(2 - i % 2, i - (k + 1));\n        if (i % 2 == 0) {\n            dp[i] = pref0[i - 2] - (last_add - 2 >= 0 ? pref0[last_add - 2] : 0);\n            if (dp[i] < 0) {\n                dp[i] += MOD;\n            }\n        } else {\n            dp[i] = pref1[i - 2] - (last_add - 2 >= 0 ? pref1[last_add - 2] : 0);\n        }\n        if (i % 2 == 0) {\n            pref0[i] = (pref0[i - 2] + dp[i]) % MOD;\n        } else {\n            pref1[i] = (pref1[i - 2] + dp[i]) % MOD;\n        }\n    }\n    /*rep(i, 1, n + 2) {\n        cout << dp[i] << \" \";\n    }\n    cout << \"\\n\";*/\n    if (n % 2 == 1) {\n        cout << 0 << \"\\n\";\n        return 0;\n    }\n    int ans = dp[n + 1];\n    //cout << k << endl;\n    for (int c = 1; c <= k; c += 2) {\n        //cout << c << \" \" << dp[n - c] << endl;\n        ans = (ans + 1LL * c * dp[n - c]) % MOD;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define pld pair <ld, ld>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n#define cld complex <double>\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 3e5;\nconst ll mod = 1e9 + 7;\n\nll n, m, k, t;\n\nstring s;\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;\n}\n\nll simple() {\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    ll q;\n    for (q = 1; q < n; q++) {\n        D[q] += D[q - 1];\n        if (q >= 2) {\n            D[q] += D[q - 2];\n            D[q] %= mod;\n        }\n    }\n    return (D[n - 2] * 2 + D[n - 1]) % mod;\n    // if (n % 2 == 1) {\n    //     return \n    // }\n    // return step(2, n / 2 + 1);\n}\n\nint main() {\n    pyshnapyshnakaa\n    ll q, w, e, a, b, c;\n    cin >> n >> m;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (q = 0; q < s.length(); q++) {\n            if (s[q] == 'R') {\n                s[q] = 'B';\n            }\n            else {\n                s[q] = 'R';\n            }\n        }\n    }\n    vector <pll> A;\n    A.pb(mp(1, s[0]));\n    for (q = 1; q < s.length(); q++) {\n        if (s[q] == A.back().second) {\n            A.back().first++;\n        }\n        else {\n            A.pb(mp(1, s[q]));\n        }\n    }\n    // cout << \"FALL\" << endl;\n    bool blue = 0, kill = 0;\n    ll mx = maxn;\n    // cout << \"\"\n    for (q = 0; q < A.size(); q++) {\n        if (A[q].second == 'B') {\n            blue = 1;\n            if (A[q].first == 0) {\n                kill = 0;\n            }\n        }\n        else {\n            if (q == 0 || A[q].first % 2 == 1) {\n                mx = min(mx, A[q].first + 1 - A[q].first % 2);\n            }\n            kill = 0;\n        }\n    }\n    // cout << \"MX \" << mx << endl;\n    // if (fail) {\n    //     cout << 0;\n    //     return 0;\n    // }\n    if (!blue) {\n        cout << simple();\n        return 0;\n    }\n    // ll mx = maxn, cur = 0;\n    // for (q = 0; q < s.length(); q++) {\n    //     if (s[q] == 'B') {\n    //         if (cur % 2 == 1) {\n    //             mx = min(mx, cur);\n    //         }\n    //         else {\n    //             mx = min(mx, cur + 1);\n    //         }\n    //         cur = 0;\n    //     }\n    //     else {\n    //         cur++;\n    //     }\n    // }\n    vector <ll> S(2);\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    S[0] = 1;\n    for (q = 1; q < n; q++) {\n        D[q] = S[q % 2];\n        S[q % 2] = (S[q % 2] + D[q]) % mod;\n        ll deli = q - mx - 1;\n        if (deli >= 0) {\n            // cout << \"DELETING \" << q << endl;\n            S[deli % 2] = (S[deli % 2] - D[deli] + mod) % mod;\n        }\n        // cout << q << \" \" << D[q] << endl;\n    }\n    // cout << \"mx \" << mx << endl;\n    ll ans = 0;\n    for (q = 0; q < n; q++) {\n        ll len = n - q - 1;\n        if (len % 2 == 0 || len > mx) {\n            continue;\n        }\n        ans += D[q] * (len + 1) % mod;\n        ans %= mod;\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n//#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int M = 1e9 + 7;\n\nvoid solve_fib(int n) {\n    vi f(n + 1);\n    f[0] = f[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        f[i] = (f[i - 1] + f[i - 2]) % M;\n    }\n    cout << (f[n] + f[n - 2]) % M;\n}\n\nint kek(int cnt) {\n    if (cnt & 1)\n        return cnt;\n    return cnt + 1;\n}\n\nvoid insum(int &a, int b) {\n    a = (a + b) % M;\n}\n\nvoid smain() {\n\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    m = s.size();\n    if (count(ALL(s), 'R') == 0 || count(ALL(s), 'B') == 0) {\n        solve_fib(n);\n        return;\n    }\n\n    vi a(m);\n    fori (i, m) {\n        a[i] = s[i] == 'R';\n    }\n\n    vi min_sz(2, m + 100);\n    int cur = -1;\n    int cnt = 0;\n    for (auto c : a) {\n        if (c != cur) {\n            if (cur != -1) {\n                inmin(min_sz[cur], kek(cnt));\n            }\n            cur = c;\n            cnt = 1;\n        } else {\n            cnt++;\n        }\n    }\n    inmin(min_sz[cur], kek(cnt));\n    vvi f(2);\n    fori (z, 2) {\n        vvi dp(2, vi(n, 0));\n        vvi p(2, vi(n, 0));\n        p[!z][0] = dp[!z][0] = 1;\n        for (int i = 1; i < n; ++i) {\n            fori (zz, 2) {\n                int j = i - min_sz[zz];\n                if (j < i) {\n                    dp[zz][i] = (p[!zz][i - 1] - (j - 2 >= 0 ? p[!zz][j - 2] : 0) + M) % M;\n                }\n            }\n            fori (zz, 2) {\n                p[zz][i] = (dp[zz][i] + (i - 2 >= 0 ? p[zz][i - 2] : 0)) % M;\n            }\n        }\n        f[z] = dp[z];\n    }\n    int ans = 0;\n    fori (z, 2) {\n        for (int sz = 1; sz <= min_sz[z]; sz += 2) if (sz < n) {\n            insum(ans, (ll)f[!z][n - sz] * sz % M);\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 1000000007;\n\nconst long long MOD_CONST = 1000000007;\nlong long mul_mod(long long a, long long b, const long long MOD) {\n  return b ? (mul_mod(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow_mod(long long a, long long b, const long long MOD) {\n  return (b ? bpow_mod(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv_mod(long long a, const long long MOD) {\n  return bpow_mod(a, MOD - 2, MOD);\n}\ntemplate <long long param = MOD_CONST, bool fast = false>\nclass mint {\n private:\n  using Z = int;\n  using N = unsigned int;\n  using ZZ = long long;\n  using NN = unsigned long long;\n  struct {\n  } constexpr static exact{};\n  // Using Z deliberately to avoid Z -> N promotion.\n  template <class Ret = ZZ&>\n  static auto modulo() -> std::enable_if_t<(param <= 0), Ret> {\n    static ZZ mod = 0;\n    return mod;\n  }\n  template <class Ret = const ZZ>\n  static auto mod() -> std::enable_if_t<(param <= 0), Ret> {\n    return modulo();\n  }\n  template <class Ret = const ZZ>\n  static constexpr auto mod() -> std::enable_if_t<(param > 0), Ret> {\n    return param;\n  }\n\n public:\n  template <class Arg = ZZ>\n  static void set_modulo(const std::enable_if_t<(param <= 0), Arg> mod) {\n    modulo() = mod;\n  }\n  long long v;\n\n  constexpr mint() : v(0) {}\n\n  constexpr mint(long long v)\n      : v(fast ? (v)\n               : (v < 0 ? (v % mod() + mod()) % mod()\n                        : (v >= mod() ? v % mod() : v))) {}\n  constexpr long long get_mod() { return mod(); }\n  long long get_val() { return v; }\n  void take_mod() { v %= mod(); }\n};\ntemplate <long long param, bool fast>\nostream& operator<<(ostream& os, mint<param, fast>& x) {\n  return os << (x.v % x.get_mod() + x.get_mod()) % x.get_mod();\n}\n\ntemplate <long long param, bool fast, bool fast2>\nbool operator==(mint<param, fast>& a, mint<param, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast>& operator+=(mint<param, fast>& a, mint<param, fast2> b) {\n  return a = a.v + b.v;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, mint<param> b) {\n  return a = a.v - b.v;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, mint<param> b) {\n  return a = a.v * b.v;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, mint<param> b) {\n  return a = a.v * inv_mod(b.v, a.get_mod());\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast> operator+(mint<param, fast> a, mint<param, fast2> b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, mint<param> b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, mint<param> b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, mint<param> b) {\n  return a /= b;\n}\ntemplate <long long param, bool fast>\nmint<param, fast>& operator+=(mint<param, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, long long b) {\n  return a = a.v * inv_mod(b, a.get_mod());\n}\ntemplate <long long param, bool fast>\nmint<param, fast> operator+(mint<param> a, long long b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, long long b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, long long b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, long long b) {\n  return a /= b;\n}\n\nvoid special(int N) {\n  vector<mint<>> vals = {mint<>(1), mint<>(1)};\n  for (int i = 0; i < N; i++) {\n    int sz = vals.size();\n    vals.push_back(vals[sz - 1] + vals[sz - 2]);\n  }\n  mint<> ans = vals[N] + vals[N - 2];\n  cout << ans << endl;\n}\n\nint con(string& S, char t) {\n  int ans = 1000000;\n  int cur = 0;\n  for (auto c : S) {\n    if (c == t)\n      cur++;\n    else {\n      if (cur != 0) ans = min(ans, cur);\n      cur = 0;\n    }\n  }\n  chmin(ans, cur);\n  return ans;\n}\n\nmint<> calcDP(int N, int conB, int conR) {\n  vector<mint<>> dpR(N + 2, mint<>(0));\n  vector<mint<>> dpB(N + 2, mint<>(0));\n  vector<mint<>> sumR(N + 2, mint<>(0));\n  vector<mint<>> sumB(N + 2, mint<>(0));\n  dpR[1] = 1;\n  sumR[1] = 1;\n  for (int i = 2; i <= N + 1; i++) {\n    if (i % 2 == 1) {\n      dpR[i] = sumB[i - 1] - sumB[max(0, i - conB - 1)];\n      // if (i <= conB) dpR[i] += 1;\n\n    } else\n      dpB[i] = sumR[i - 1] - sumR[max(0, i - conR - 1)];\n    sumB[i] = sumB[i - 1] + dpB[i];\n    sumR[i] = sumR[i - 1] + dpR[i];\n  }\n  mint<> ans = 0;\n  for (int i = 0; i < min(N, conB + 1); i++) {\n    ans += sumR[N - i] - sumR[max(0, N - conB - 1)];\n  }\n  return ans;\n}\n\nvoid solve(long long N, long long M, std::string S) {\n  int cntB = 0;\n\n  int conR = con(S, 'R');\n  int conB = con(S, 'B');\n  for (int i = 0; i < M; i++) {\n    if (S[i] == 'B') cntB++;\n  }\n  if (cntB == M || cntB == 0) {\n    special(N);\n    return;\n  }\n  if (N % 2 == 1) {\n    cout << 0 << endl;\n    return;\n  }\n  if (S[0] == 'R') swap(conR, conB);\n  conR = 1;\n  if (conB % 2 == 0) conB++;\n  // if (conR % 2 == 0) conR--;\n\n  mint<> ans = calcDP(N, conB, conR);\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long M;\n  scanf(\"%lld\", &M);\n  std::string S;\n  std::cin >> S;\n  solve(N, M, S);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int maxn=200111;\nconst int mod=1e9+7;\n\nint n,m,dp[maxn],pre[maxn];\nchar s[maxn];\n\nint main()\n{\n\tget2(n,m);\n\tscanf(\"%s\",s+1);\n\t\n\twhile(m>1&&s[m]==s[m-1])m--;\n\tif(m==1)\n\t{\n\t\tdp[0]=2;dp[1]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tdp[i]=dp[i-1]+dp[i-2];\n\t\t\tif(dp[i]>=mod)dp[i]-=mod;\n\t\t}\n\t\tprintf(\"%d\\n\",dp[n]);\n\t\treturn 0;\n\t}\n\t\n\tif(n%2==1)\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\t\n\tif(s[m]==s[1])m--;\n\tint bound=inf;\n\tfor(int i=1;i<=m;i++)if(s[i]==s[1]&&s[i]!=s[i-1])\n\t{\n\t\tint len=0;\n\t\twhile(s[i+len]==s[i])len++;\n\t\tif(len%2==1)bound=min(bound,len);\n\t\telse if(i==1)bound=min(bound,len+1);\n\t}\n\tbound=min(bound,n-1);\n\t\n\tn/=2;bound=(bound+1)/2;\n\tdp[0]=1;pre[0]=1;\n\tint sum=0;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tif(i)\n\t\t{\n\t\t\tif(i<=bound)dp[i]=pre[i-1];\n\t\t\telse dp[i]=(pre[i-1]-pre[i-bound-1]+mod)%mod;\n\t\t\tpre[i]=(pre[i-1]+dp[i])%mod;\n\t\t}\n\t\tif(i>=n-bound)\n\t\t{\n\t\t\tint coef=((n-i)*2-1);\n\t\t\tif(i==n)coef=1;\n\t\t\tsum=(sum+(LL)dp[i]*coef)%mod;\n\t\t}\n\t}\n\tprintendl(sum);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n//#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int M = 1e9 + 7;\n\nvoid solve_fib(int n) {\n    vi f(n + 1);\n    f[0] = f[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        f[i] = (f[i - 1] + f[i - 2]) % M;\n    }\n    cout << (f[n] + f[n - 2]) % M;\n}\n\nint kek(int cnt) {\n    if (cnt & 1)\n        return cnt;\n    return cnt + 1;\n}\n\nvoid insum(int &a, int b) {\n    a = (a + b) % M;\n}\n\nvoid smain() {\n\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    m = s.size();\n    if (count(ALL(s), 'R') == 0 || count(ALL(s), 'B') == 0) {\n        solve_fib(n);\n        assert(0);\n        return;\n    }\n\n    vi a(m);\n    fori (i, m) {\n        a[i] = s[i] == 'R';\n    }\n\n    vi min_sz(2, m);\n    int cur = -1;\n    int cnt = 0;\n    for (auto c : a) {\n        if (c != cur) {\n            if (cur != -1) {\n                inmin(min_sz[cur], kek(cnt));\n            }\n            cur = c;\n            cnt = 1;\n        } else {\n            cnt++;\n        }\n    }\n    inmin(min_sz[cur], kek(cnt));\n    vvi f(2);\n    fori (z, 2) {\n        vvi dp(2, vi(n, 0));\n        vvi p(2, vi(n, 0));\n        p[!z][0] = dp[!z][0] = 1;\n        for (int i = 1; i < n; ++i) {\n            fori (zz, 2) {\n                int j = i - min_sz[zz];\n                if (j < i) {\n                    dp[zz][i] = (p[!zz][i - 1] - (j - 2 >= 0 ? p[!zz][j - 2] : 0) + M) % M;\n                }\n            }\n            fori (zz, 2) {\n                p[zz][i] = (dp[zz][i] + (i - 2 >= 0 ? p[zz][i - 2] : 0)) % M;\n            }\n        }\n        f[z] = dp[z];\n    }\n    int ans = 0;\n    fori (z, 2) {\n        for (int sz = 1; sz <= min_sz[z]; sz += 2) if (sz < n){\n            insum(ans, (ll)f[!z][n - sz] * sz % M);\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n+10, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    if(str.size() != m)return 1;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i < vec.size();i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\nchar s[N];\nint n,m;\n\nll dp[N],sdp[N],ans;\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s);\n\tbool mono=1;\n\trep(i,0,m) mono&=s[i]==s[0];\n\tif (mono) {\n\t\tint a=2,b=1;\n\t\trep(i,1,n) {\n\t\t\ta=(a+b)%mod;\n\t\t\tswap(a,b);\n\t\t}\n\t\tprintf(\"%d\\n\",b);\n\t\treturn 0;\n\t}\n\tint sR=2*n+1,sB=2*n+1;\n\tif (s[0]=='B') {\n\t\trep(i,0,m) if (s[i]=='R') s[i]='B'; else s[i]='R';\n\t}\n\trep(l,0,n) {\n\t\tint r=l;\n\t\twhile (r<n&&s[r]==s[l]) r++;\n\t\tint len=r-l;\n\t\tif (len%2==0) len=len+1;\n\t\tif (r==n) continue;\n\t\tif (s[l]=='R') sR=min(sR,len);\n\t\telse sB=min(sB,len);\n\t\tl=r-1;\n\t}\n\tif (n%2==1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tauto solve=[&](int sR,int sB) {\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(sdp,0,sizeof(sdp));\n\t\tdp[0]=1;\n\t\tsdp[2]=1;\n\t\trep(i,1,n+1) {\n\t\t\tif (i%2==1) {\n\t\t\t\tdp[i]=(sdp[i+1]-sdp[max(0,i-sR)])%mod;\n//\t\t\t\tfor (int j=1;j<=sR&&j<=i;j+=2) {\n//\t\t\t\t\tdp[i]+=dp[i-j];\n//\t\t\t\t}\n//\t\t\t\tprintf(\"%d %lld\\n\",i,dp[i]);\n\t\t\t} else {\n\t\t\t\tif (i!=n) {\n//\t\t\t\t\tfor (int j=1;j<=sB&&j<=i;j+=2) {\n//\t\t\t\t\t\tdp[i]+=dp[i-j];\n//\t\t\t\t\t}\n\t\t\t\t\tdp[i]=(sdp[i+1]-sdp[max(1,i-sB)])%mod;\n//\t\t\t\t\tprintf(\"%d %lld\\n\",i,dp[i]);\n\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j=1;j<=sB&&j<=i;j+=2) {\n\t\t\t\t\t\tdp[i]=(dp[i]+dp[i-j]*j)%mod;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsdp[i+2]=(sdp[i]+dp[i])%mod;\n\t\t}\n\t\tans+=dp[n];\n//\t\tprintf(\"%lld\\n\",dp[n]);\n\t};\n\tsolve(sR,sB);\n\tsolve(sB,sR);\n\tans%=mod;\n\tif (ans<0) ans+=mod;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=401000;\nchar s[N];\nint n,m;\n\nll dp[N],sdp[N],ans;\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s);\n\tbool mono=1;\n\trep(i,0,m) mono&=s[i]==s[0];\n\tif (mono) {\n\t\tint a=2,b=1;\n\t\trep(i,1,n) {\n\t\t\ta=(a+b)%mod;\n\t\t\tswap(a,b);\n\t\t}\n\t\tprintf(\"%d\\n\",b);\n\t\treturn 0;\n\t}\n\tint sR=2*n+1,sB=1;\n\tif (s[0]=='B') {\n\t\trep(i,0,m) if (s[i]=='R') s[i]='B'; else s[i]='R';\n\t}\n\trep(l,0,m) {\n\t\tint r=l;\n\t\twhile (r<m&&s[r]==s[l]) r++;\n\t\tint len=r-l;\n\t\tif (len%2==0) len=len+1;\n\t\tif (r==m) break;\n\t\tif (s[l]=='R') sR=min(sR,len);\n\t\telse sB=min(sB,len);\n\t\tl=r-1;\n\t}\n\tif (n%2==1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n//\tprintf(\"%d %d\\n\",sR,sB);\n\tauto solve=[&](int sR,int sB) {\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(sdp,0,sizeof(sdp));\n\t\tdp[0]=1;\n\t\tsdp[2]=1;\n\t\trep(i,1,n+1) {\n\t\t\tif (i%2==1) {\n\t\t\t\tdp[i]=(sdp[i+1]-sdp[max(0,i-sR)])%mod;\n\t\t\t} else {\n\t\t\t\tif (i!=n) {\n\t\t\t\t\tdp[i]=(sdp[i+1]-sdp[max(1,i-sB)])%mod;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j=1;j<=sB&&j<=i;j+=2) {\n\t\t\t\t\t\tdp[i]=(dp[i]+dp[i-j]*j)%mod;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsdp[i+2]=(sdp[i]+dp[i])%mod;\n\t\t}\n\t\tans+=dp[n];\n\t};\n\tsolve(sR,sB);\n\tsolve(sB,sR);\n\tans%=mod;\n\tif (ans<0) ans+=mod;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\nusing dd = double;\nusing vdd = std::vector<dd>;\nusing vvdd = std::vector<vdd>;\nusing vvvdd = std::vector<vvdd>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, N-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, N-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S, ll E){ T s=v[S]; REPS(i, S+1, E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = (ll)(1e9 + 7);// 998244353LL;//(ll)(1e9 + 7);\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\n\nll N, M;\nstring S;\n\nvoid solveB(){\n\tmll ans = 0;\n\n\t//先頭がRの時\n\t{\n\t\tvvmll dp(N, vmll(2));\n\t\tdp[0][0] = 1;\n\t\tdp[0][1] = 0;\n\n\t\tREPS(i, 1, N-1){\n\t\t\tdp[i][0] = dp[i-1][0] + dp[i-1][1];\n\t\t\tdp[i][1] = dp[i-1][0];\n\t\t}\n\t\tans += dp[N-1][0] + dp[N-1][1];\n\t}\n\n\t//先頭がBの時\n\t{\n\t\tvvmll dp(N, vmll(2));\n\t\tdp[0][0] = 0;\n\t\tdp[0][1] = 1;\n\n\t\tREPS(i, 1, N-2){\n\t\t\tdp[i][0] = dp[i-1][0] + dp[i-1][1];\n\t\t\tdp[i][1] = dp[i-1][0];\n\t\t}\n\t\tans += dp[N-2][0] + dp[N-2][1];\n\t}\n\tcout << ans << '\\n';\n}\n\n\nvoid solve()\n{\n\tcin >> N >> M >> S;\n\n\tif (S[0] == 'B'){\n\t\tEACH(c, S){\n\t\t\tif (c == 'B') c = 'R';\n\t\t\telse          c = 'B';\n\t\t}\n\t}\n\n\tll renzoku = 0;\n\tll minRenzoku = INF;\n\tEACH(c, S){\n\t\tif (c == 'R') renzoku++;\n\t\telse{\n\t\t\tchmin(minRenzoku, renzoku);\n\t\t\trenzoku=0;\n\t\t}\n\t}\n\n\tif (minRenzoku == INF){\n\t\tsolveB();\n\t\treturn;\n\t}\n\n\t/////\n\n\tif (N%2 == 1){bye(0);}\n\n\tll n = minRenzoku/2;\n\tif (n == 0){ bye(2); }\n\n\tvmll dp(N/2+1);\n\tvmll sum(N/2+1);\n\n\tdp[1] = 2;\n\tsum[1] = 2;\n\n\tREPS(i, 2, N/2){\n\t\t//dpの計算\n\t\tdp[i] = sum[i-1];\n\t\tif (i <= n+1){ dp[i] += 2*i; }\n\n\t\t//sumの計算\n\t\tif (i <= n+1){sum[i] = sum[i-1] + dp[i];}\n\t\telse         {sum[i] = sum[i-1] + dp[i] - dp[i-n-1];}\n\n\t}\n\tcout << dp[N/2] << '\\n';\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\nclass comb{\nprivate:\n    ll mod;\n    ll mx;\n    vector<ll> F;\n    vector<ll> FR;\n    \npublic:\n    comb(ll mod=1000000007,ll mx=1000000):mod(mod),mx(mx),F(mx+1,1),FR(mx+1,1){\n        mk_F();\n    }\n    \n    ll mod_pow(ll a,ll x){\n        a%=mod;\n        ll ans=1;\n        while(x>0){\n            if(x&1){ans*=a; ans%=mod;}\n            a*=a;\n            a%=mod;\n            x>>=1;\n        }\n        return ans;\n    }\n    \n    pll Ex_gcd(ll a,ll b){\n        if(b==0){return {1,0};}\n        pll ret=Ex_gcd(b,a%b);\n        ret.F-=a/b*ret.S;\n        return {ret.S,ret.F};\n    }\n    \n    ll prime_R(ll a){\n        return mod_pow(a,mod-2);\n    }\n    \n    ll R(ll a){\n        ll ret=Ex_gcd(a,mod).F;\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    void mk_F(){\n        for(ll i=1;i<=mx;i++){F[i]=F[i-1]*i%mod; FR[i]=R(F[i]);}\n    }\n    \n    ll c(ll n,ll k){\n        if(n<k){return 0;}\n        if(n==k || k==0){return 1;}\n        return F[n]*FR[n-k]%mod*FR[k]%mod;\n    }\n    \n    //mod must be prime\n    ll Lucas_C(ll n,ll m){\n        ll ret=1;\n        while(n>0 || m>0){\n            ret*=c(n%mod,m%mod);\n            ret%=mod;\n            n/=mod; m/=mod;\n        }\n        return ret;\n    }\n    \n    ll Stirling(ll n,ll k){\n        ll ret=0;\n        for(ll i=1;i<=k;i++){\n            if((k-i)%2){ret-=c(k,i)*mod_pow(i,n)%mod;}\n            else{ret+=c(k,i)*mod_pow(i,n)%mod;}\n            ret%=mod;\n        }\n        ret*=R(F[k]);\n        ret%=mod;\n        if(ret<0){ret+=mod;}\n        return ret;\n    }\n    \n    ll Bell(ll n,ll k){\n        ll ret=0;\n        for(ll i=1;i<=k;i++){ret+=Stirling(n,i); ret%=mod;}\n        return ret;\n    }\n};\n\ncomb C;\n\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    string s;\n    cin>>s;\n    if(s[0]=='B'){\n        for(int i=0;i<m;i++){\n            if(s[i]=='B'){s[i]='R';}\n            else{s[i]='B';}\n        }\n    }\n    ll l=0;\n    while(l<m && s[l]=='R'){l++;}\n    if(l==m){\n        ll ans=1;\n        vector<ll> dp(n,0);\n        vector<ll> sum(n,0);\n        dp[0]=sum[0]=1;\n        for(int i=2;i<n;i++){\n            dp[i]=sum[i-2];\n            sum[i]=dp[i]+sum[i-1];\n            sum[i]%=MOD;\n        }\n        for(ll i=2;i<=n;i++){\n            ans+=sum[n-i]*i%MOD;\n        }\n        ans%=MOD;\n        cout<<ans<<endl;\n    }\n    if(n&1){cout<<(l==m?1:0)<<endl; return 0;}\n    ll mi=E;\n    if(l&1){mi=l;}\n    else{mi=l+1;}\n    for(ll i=l;i<m;i++){\n        if(s[i]=='R'){\n            ll w=i;\n            while(i<m && s[i]=='R'){i++;}\n            if(i!=m){\n                ll L=i-w;\n                if(L&1){mi=min(mi,L);}\n            }\n        }\n    }\n    vector<ll> dp(n,0);\n    vector<ll> sum(n,0);\n    dp[0]=sum[0]=1;\n    for(int i=2;i<n;i+=2){\n        ll r=sum[i-2];\n        ll l=(i-mi-3>=0?sum[i-mi-3]:0LL);\n        dp[i]=r-l;\n        dp[i]%=MOD;\n        sum[i]=sum[i-2]+dp[i];\n        sum[i]%=MOD;\n        //cout<<dp[i]<<\" \"<<sum[i]<<endl;\n    }\n    ll ans=0;\n    for(ll i=2;i<=mi+1 && n-i>=0;i++){\n        ans+=dp[n-i]*i%MOD;\n        ans%=MOD;\n    }\n    if(l==m){ans++;}\n    ans%=MOD;\n    if(ans<0){ans+=MOD;}\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nint Mn(int a,int b){return a<b?a:b;}\nconst int N=2e5+5,mod=1e9+7;\nint upt(int x){while(x>=mod)x-=mod;while(x<0)x+=mod;return x;}\n\nint n,m,lm,dp[N],sm[N],ans,g[N];\nchar s[N];\nvoid solve()\n{\n  g[0]=sm[0]=1;\n  for(int i=1;i<=n;i++)\n    {\n      if(i>=2)g[i]=sm[i-2];\n      sm[i]=upt(sm[i-1]+g[i]);\n    }\n  int ans=1;//ans=1 for all one color\n  for(int i=2;i<=n;i++)\n    ans=(ans+(ll)i*g[n-i])%mod;\n  printf(\"%d\\n\",ans);\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&m);\n  scanf(\"%s\",s+1); bool fg=0;\n  for(int i=1;i<=m;i++)\n    if(s[i]!=s[1]){fg=1;break;}\n  if(!fg){solve();return 0;}\n  if(n&1){puts(\"0\");return 0;}\n  lm=n+1; int lst;\n  for(int i=m;i;i--)if(s[i]==s[1]){lst=i;break;}\n  for(int i=1;i<=m;i++)\n    if(s[i]==s[1])//== not !=\n      {\n\tint j=i;\n\twhile(j+1<=m&&s[j+1]==s[j])j++;\n\tswap(i,j); j=i-j+1;\n\tif(i-j==0) lm=Mn(lm,j+((j&1)==0));\n\telse if((j&1)&&i!=m)lm=Mn(lm,j);//i!=m\n\t//else if((j&1)&&i!=lst)lm=Mn(lm,j);\n      }\n  n>>=1; lm=(lm+1)>>1; dp[0]=sm[0]=1;\n  for(int i=1;i<=n;i++)\n    {\n      dp[i]=sm[i-1]; if(i>lm)dp[i]=upt(dp[i]-sm[i-lm-1]);\n      sm[i]=upt(sm[i-1]+dp[i]);\n    }\n  int ans=0;\n  for(int i=1;i<=lm;i++)//lm not n\n    ans=(ans+(ll)i*2*dp[n-i])%mod;\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact, _inv;\n\n  Combination(ll sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for(ll i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(ll i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for(ll i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(ll k) const { return _fact[k]; }\n\n  inline T rfact(ll k) const { return _rfact[k]; }\n\n  inline T inv(ll k) const { return _inv[k]; }\n\n  T P(ll n, ll r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n\n  T H(ll n, ll r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\nusing modint = ModInt< MOD1 >;modint pow(ll n, ll x){return modint(n).pow(x);}modint pow(modint n, ll x){return n.pow(x);}\n//using modint=ld;\nusing Comb=Combination<modint>;\n\n\ntemplate<typename T>\nstruct BIT{\n  ll n;\n  ll k=1;\n  vector<T>data;\n  BIT() = default;\n  BIT(ll size):n(size){\n    data.assign(n,0);\n    while(k*2<=n)k*=2;\n  }\n  void add(ll a,T w){\n    for(ll i=a+1;i<=n;i+=i&-i)data[i-1]+=w;\n  }\n  T sum(ll a){\n\tif(a<0)return 0;\n    T ret = 0;\n    for(ll i=a+1;i>0;i-=i&-i)ret+=data[i-1];\n    return ret;\n  }\n  T sum(ll a,ll b){return a>b?0:sum(b)-sum(a-1);}\n  T operator[](ll pos){\n    return sum(pos,pos);\n  }\n  ll lower_bound(ll x){\n    ll ret=0;    \n    for(ll i=k;i>0;i/=2){\n      if(ret+i<=n&&data[ret+i-1]<x){\n        x-=data[ret+i-1];\n        ret+=i;\n      }\n    }\n    return ret;\n  }\n  void print(){\n    for(ll i=0;i<n;i++){\n      if(i!=0)cout<<\" \";\n      cout<<(*this)[i];\n    }\n    cout<<endl;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,m;cin>>n>>m;\n  string s;cin>>s;\n  if(s[0]=='B'){\n    rep(i,0,m){\n      if(s[i]=='R')s[i]='B';\n      else s[i]='R';\n    }\n  }\n  ll mx=n-1;\n  {\n    vector<ll>v;\n    ll cnt=0;\n    rep(i,0,m){\n      if(s[i]=='R')cnt++;\n      else{\n        v.PB(cnt);\n        cnt=0;\n      }\n    }\n    if(v.empty()){\n      modint tmp=0;\n      Comb comb(300005);\n      rep(i,0,n+1){\n        tmp+=comb.C(n-i-1,i-1)*2+comb.C(n-i-1,i);\n      }\n      cout<<tmp<<endl;\n      return 0;\n    }\n    rep(i,0,v.size()){\n      if(i==0||v[i]&1)chmin(mx,v[i]);\n    }\n    if(~mx&1)mx++;\n  }\n  vector<modint>v(n+1);\n  BIT<modint>bit(n+1);\n  bit.add(0,1);\n  rep(i,0,n){\n    if(~i&1)continue;\n    bit.add(i+1,bit.sum(max(0LL,i-mx),i));\n  }\n  modint ret=0;\n  rep(i,0,n+1){\n    ret+=bit.sum(n-mx-1,n-i-1);\n    //cout<<n-mx-1 spa n-i spa bit.sum(n-mx-1,n-i)<<endl;\n  }\n  //bit.print();\n  //debug(v,n+1);\n  cout<<ret<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << (a) << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int MOD = 1e9 + 7;\n\nvi split(string s) {\n    vi ans;\n    char last = 'X'; \n    s += 'X';\n    int streak = 0;\n    for (char c : s) {\n        if (c != last) {\n            if (streak) ans.pb(streak);\n            streak = 0;\n            last = c;\n        }\n        streak++;\n    }\n    return ans;\n}\n\nvoid add(int &x, int y) {\n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n\nvi go(int n, int lim, int start) {\n    vi dp(n+1);\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = 0;\n        if (i >= start) add(dp[i], dp[i-start]);\n        if (i >= lim+1) add(dp[i], MOD-dp[i-lim-1]);\n        add(dp[i], dp[i-1]);\n    }\n    for (int i = n; i >= 1; i--) add(dp[i], MOD-dp[i-1]);\n    return dp;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    int n,l;\n    string s;\n    while (cin >> n >> l >> s) {\n        auto p = split(s);\n        if (si(p) == 1) {\n            //cout << \"TODO\" << endl;\n            auto dp = go(n,n,2);\n            int ans = 0;\n            for (int dif = 1; dif <= n; dif++) {\n                if (dif == 1 || dif == n-1) continue;\n                add(ans, ll(dif) * dp[n-dif] % MOD);\n            }\n            cout << (ans+1)%MOD << endl;\n        }\n        else {\n            if (n%2 == 1) {\n                cout << 0 << endl;\n                continue;\n            }\n            int lim = n+l;\n            forn(i,si(p)) if (i == 0 || (i%2 == 0 && p[i]%2 == 1)) {\n                lim = min(lim, p[i]/2+1);\n            }\n            n /= 2;\n            auto dp = go(n, lim, 1);\n            int ans = 0;\n            for (int dif = 1; dif <= lim; dif++)\n                add(ans, ll(dif) * dp[n-dif] % MOD);\n            cout << 2*ans%MOD << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll dp[202020][2][2];\nll mo=1000000007;\n\nll dp2[202020];\nll dps[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\tif(S[0]=='B') {\n\t\tFORR(c,S) c='R'+'B'-c;\n\t}\n\tif(count(ALL(S),'B')==0) {\n\t\tdp[0][0][0]=dp[0][1][1]=1;\n\t\tfor(i=1;i<N;i++) {\n\t\t\t(dp[i][0][0]=dp[i-1][0][0]+dp[i-1][0][1])%=mo;\n\t\t\t(dp[i][0][1]=dp[i-1][0][0])%=mo;\n\t\t\t(dp[i][1][0]=dp[i-1][1][0]+dp[i-1][1][1])%=mo;\n\t\t\t(dp[i][1][1]=dp[i-1][1][0])%=mo;\n\t\t}\n\t\tcout<<(dp[N-1][0][0]+dp[N-1][0][1]+dp[N-1][1][0])%mo<<endl;\n\t\treturn;\n\t}\n\t\n\tvector<int> V;\n\tV.push_back(0);\n\tFORR(c,S) {\n\t\tif(c=='R') V.back()++;\n\t\telse V.push_back(0);\n\t}\n\t\n\tint L=1<<20;\n\tFOR(i,V.size()) {\n\t\tif(i==0) {\n\t\t\tif(V[0]%2==0) V[0]++;\n\t\t\tL=min(L,V[0]);\n\t\t}\n\t\telse if(V[i]%2==1) {\n\t\t\tL=min(L,V[i]);\n\t\t}\n\t}\n\t\n\t\n\tdp2[0]=dps[0]=1;\n\tfor(i=2;i<=N;i+=2) {\n\t\tdp2[i]=dps[i-2];\n\t\tif(i-(L+1)>0) (dp2[i]+=mo-dps[i-(L+1)-2])%=mo;\n\t\tdps[i]=(dps[i-2]+dp2[i])%mo;\n\t\t//cout<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=min(L,N-1);i+=2) {\n\t\t//cout<<i<<\" \"<<(i+1)<<\"*\"<<dp2[N-(i+1)]<<endl;\n\t\t(ret+=(i+1)*dp2[N-(i+1)])%=mo;\n\t}\n\tcout<<ret%mo<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n¼ÙÉèS[1] = R¡£ÄÇÃ´ÏÔÈ»£¬»·ÉÏ²»»á³öÏÖÁ½¸öÁ¬ÐøµÄ±ß¶¼ÊÇB£¬·ñÔòÔÚËüÃÇ½»µã´¦µÚÒ»²½ÍùÁ½±ß×ß¶¼²»ºÏ·¨\nÌØÅÐµôSÖÐÈ«ÊÇRµÄÇé¿ö£¬¿¼ÂÇÒ»°ãÇé¿ö \nÊ×ÏÈ°ÑËùÓÐÊÇBµÄÎ»ÖÃ¶Ï¿ª£¬ÄÇÃ´¾ÍÐÎ³ÉÁËÈô¸É¸öRµÄÁ¬Ðø¶Î¡£¿ÉÒÔ·¢ÏÖÕâÃ´Ò»¸öÐÔÖÊ£ºÃ¿¸öÁ¬Ðø¶ÎµÄ³¤¶È¾ùÎªÆæÊý\nÖ¤Ã÷¿¼ÂÇ·´Ö¤¡£¼ÙÉèÓÐÒ»¸öÅ¼ÊýµÄ¶Î£¬¿¼ÂÇ¶þ·ÖÍ¼¿ÉÒÔ·¢ÏÖ£¬ÄÇÃ´ÓÐµÄµã×ßµ½ÕâÒ»¶ÎµÄ¶Ëµã¾àÀëÓÀÔ¶ÊÇÅ¼Êý¡¢ÓÐµÄµã×ßµ½ÕâÒ»¶ÎµÄ¶Ëµã¾àÀëÓÀÔ¶ÊÇÆæÊý£¬ÒòÎª¶ËµãÍ¬É«\n¶øSµÄµÚÒ»¶ÎÁ¬ÐøR³¤¶ÈÊÇ¹Ì¶¨µÄ£¬²»ÄÜÍ¬Ê±ÎªÅ¼Êý»òÆæÊý£¬Ã¬¶Ü¡£ËùÒÔ¿ÉÒÔµÃµ½½áÂÛ\nÍ¬Ê±£¬SÖÐÃ¿¸öRµÄÁ¬Ðø¶Î¶¼»á¶Ô»·ÉÏÃ¿¸öRµÄÁ¬Ðø¶ÎÓÐ¸öÉÏ½çµÄÏÞÖÆ \n*/\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int Max_NM(200050);\nconst int MOD(1000000000 + 7);\ntypedef long long int LL;\n\nint N, M, L, F[Max_NM], Pre[Max_NM][2], Ans;\nchar S[Max_NM];\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nconstexpr int Sub(int a, int b)\n{\n\treturn a - b < 0 ? a - b + MOD : a - b;\n}\n\nconstexpr int Mult(int a, int b)\n{\n\treturn a * 1LL * b % MOD;\n}\n\ninline void upd(int &a, int b)\n{\n\ta = Add(a, b);\n}\n\nvoid dp(bool have)\n{\n\tF[1] = 1, Pre[1][1 & 1] = 1;\n\tfor (int i = 2, j;i <= N;++i)\n\t{\n\t\tPre[i][0] = Pre[i - 1][0], Pre[i][1] = Pre[i - 1][1];\n\t\tupd(Pre[i][i & 1], F[i - 2]);\n\t\t//jµ½iÊÇR£¬i - j + 1 <= L   =>   j >= i - L + 1\n\t\t//i - j + 1ÊÇÆæÊý£¬i - jÊÇÅ¼Êý£¬iºÍjÆæÅ¼ÐÔÏàµÈ\n\t\tj = max(1, i - L + 1);\n\t\tif (j <= i)\n\t\t{\n\t\t\tF[i] = Sub(Pre[i][i & 1], Pre[j - 1][i & 1]);\n\t\t\tif (have)\n\t\t\t\tupd(F[i], Sub(Pre[i][(i & 1) ^ 1], Pre[j - 1][(i & 1) ^ 1]));\n\t\t}\n\t}\n\t\n}\n\nint main()\n{ \n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tbool haveB = false;\n\tif (S[1] == 'B')\n\t\tfor (int i = 1;i <= M;++i)\n\t\t\tS[i] = 'R' + 'B' - S[i];\n\tfor (int i = 1;i <= M;++i)\n\t\thaveB |= (S[i] == 'B');\n\tL = N;\n\tfor (int i = 1, length = 0, stop = 0;i <= M;++i)\n\t\tif (S[i] == 'B')\n\t\t\tlength = 0, stop = 1;\n\t\telse\n\t\t{\n\t\t\t++length;\n\t\t\tif (i + 1 <= N && S[i + 1] == 'B')\n\t\t\t\tif (stop == 0)\n\t\t\t\t\tif (length & 1)\n\t\t\t\t\t\tL = min(L, length);\n\t\t\t\t\telse\n\t\t\t\t\t\tL = min(L, length + 1);\n\t\t\t\telse\n\t\t\t\t\tif (length & 1)\n\t\t\t\t\t\tL = min(L, length);\n\t\t}\n\tdp(!haveB);\n\tupd(Ans, F[N - 1]);//edge(1, 2) = B\n\tfor (int x = 1, val;x <= L && x < L;x += 2)//edge(1, 2) = R\n\t{\n\t\tif (x == N)\n\t\t\tval = 1;\n\t\telse\n\t\t\tif (x + 1 == N)\n\t\t\t\tval = 1;\n\t\t\telse\n\t\t\t\tval = F[N - x - 2];\n\t\tupd(Ans, Mult(x, val));\n\t}\n\tif ((L & 1) && L == N)\n\t\tupd(Ans, 1);\n\tprintf(\"%d\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+10;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    ans = dp[n+1];\n    for(ll i = 1;i<=lim;i+=2)\n    {\n        ans += (i*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        exit(1);\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-1];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    int mn = 1e9;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll md = 1e9+7;\n\nvector<ll> calc(int n, int k){\n\tvector<ll> todo(n);\n\ttodo[0] = -1;\n\tif(n > 1) todo[1] = 1;\n\trep(i,0,n){\n\t\tif(i+1 < n) todo[i+1] = (todo[i+1] + 2*todo[i]) % md;\n\t\tif(i + k+1 < n) todo[i+k+1] = (todo[i+k+1] - todo[i]) % md;\n\t\ttodo[i] *= -1;\n\t}\n\treturn todo;\n}\n\nvector<ll> calc1(int n){\n\tvector<ll> todo(n);\n\ttodo[0] = -1;\n\tif(n > 1) todo[1] = 1;\n\tvector<ll> ans(n);\n\trep(i,0,n){\n\t\tif(i+1 < n) todo[i+1] = (todo[i+1] + todo[i]) % md;\n\t\tif(i+2 < n) todo[i+2] = (todo[i+2] + todo[i]) % md;\n\t\ttodo[i] *= -1;\n\t}\n\treturn todo;\n}\n\nll solve(){\n\tint n, m;\n\tstring s;\n\tcin >> n >> m >> s;\n\tif(s[0]=='B') trav(c, s) c = 'B'+'R'-c;\n\tif(count(all(s), 'R') == m){\n\t\tll ans = 1;\n\t\tauto dp = calc1(n-1);\n\t\tfor(int l = 1; l < n; ++l)\n\t\t\tans += (l+1) * dp[n-l-1] % md;\n\t\treturn ans;\n\t} else {\n\t\tif(n%2) return 0;\n\t\tint mx = n-1;\n\t\trep(i,0,m) if(s[i]=='B' && s[i-1]=='R'){\n\t\t\tint j = i;\n\t\t\twhile(j && s[j-1] =='R') --j;\n\t\t\tif(j == 0) mx = min(mx, 2*i-1);\n\t\t\telse if((i-j)%2) mx = min(mx, i-j);\n\t\t}\n\t\tauto dp = calc(n/2, (mx+1)/2);\n\t\tll ans = 0;\n\t\tfor(int l = 1; l <= mx; l += 2)\n\t\t\tans += (l+1) * dp[(n-l-1)/2] % md;\n\t\treturn ans;\n\t}\n}\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\n\tll res = solve();\n\tres %= md;\n\tif(res < 0) res += md;\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/01/29] 12:36:49\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nvoid outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\n\n\ntemplate<typename T> T gcd(const T& a, const T& b) { return a < 0 ? gcd(-a, b) : b < 0 ? gcd(a, -b) : (a > b ? gcd(b, a) : a == 0 ? b : gcd(b % a, a)); }\ntemplate<typename T> T lcm(const T& a, const T& b) { return a / gcd(a, b) * b; }\ntemplate<typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto g = gcd(a, b), da = std::abs(b) / g;\n    const auto p = extgcd(b, a % b);\n    const auto x = (da + p.second % da) % da, y = (g - a * x) / b;\n    return {x, y};\n}\ntemplate<typename T>\nconstexpr T inverse(const T a, const T mod) { return extgcd(a, mod).first; }\ntemplate<uint mod_value, bool dynamic = false>\nclass modint_base\n{\npublic:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, const UInt> mod() { return mod_ref(); }\n    template<typename UInt = uint>\n    static constexpr std::enable_if_t<not dynamic, const UInt> mod() { return mod_value; }\n    template<typename UInt = uint>\n    static void set_mod(const std::enable_if_t<dynamic, const UInt> mod) { mod_ref() = mod, inv_ref() = {1, 1}; }\n    modint_base() : v{0} {}\n    modint_base(const ll val) : v{norm(static_cast<uint>(val % static_cast<ll>(mod()) + static_cast<ll>(mod())))} {}\n    modint_base(const modint_base& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    modint_base& operator=(const modint_base& m) { return v = m(), (*this); }\n    modint_base& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod()) + static_cast<ll>(mod()))), (*this); }\n    friend modint_base operator+(const modint_base& m) { return m; }\n    friend modint_base operator-(const modint_base& m) { return make(norm(mod() - m.v)); }\n    friend modint_base operator+(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + m2.v)); }\n    friend modint_base operator-(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + mod() - m2.v)); }\n    friend modint_base operator*(const modint_base& m1, const modint_base& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod()))); }\n    friend modint_base operator/(const modint_base& m1, const modint_base& m2) { return m1 * inv(m2.v); }\n    friend modint_base operator+(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) - val}; }\n    friend modint_base operator*(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * inv(val)}; }\n    friend modint_base operator+(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const ll val, const modint_base& m) { return modint_base{-static_cast<ll>(m.v) + val}; }\n    friend modint_base operator*(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const ll val, const modint_base& m) { return modint_base{val * inv(static_cast<ll>(m.v))}; }\n    friend modint_base& operator+=(modint_base& m1, const modint_base& m2) { return m1 = m1 + m2; }\n    friend modint_base& operator-=(modint_base& m1, const modint_base& m2) { return m1 = m1 - m2; }\n    friend modint_base& operator*=(modint_base& m1, const modint_base& m2) { return m1 = m1 * m2; }\n    friend modint_base& operator/=(modint_base& m1, const modint_base& m2) { return m1 = m1 / m2; }\n    friend modint_base& operator+=(modint_base& m, const ll val) { return m = m + val; }\n    friend modint_base& operator-=(modint_base& m, const ll val) { return m = m - val; }\n    friend modint_base& operator*=(modint_base& m, const ll val) { return m = m * val; }\n    friend modint_base& operator/=(modint_base& m, const ll val) { return m = m / val; }\n    friend modint_base operator^(const modint_base& m, const ll n) { return power(m.v, n); }\n    friend modint_base& operator^=(modint_base& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const modint_base& m1, const modint_base& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const modint_base& m1, const modint_base& m2) { return not(m1 == m2); }\n    friend bool operator==(const modint_base& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const modint_base& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const modint_base& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const ll val, const modint_base& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, modint_base& m)\n    {\n        ll v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const modint_base& m) { return os << m(); }\n    uint operator()() const { return v; }\n    static modint_base small_inv(const usize n)\n    {\n        auto& in = inv_ref();\n        if (n < in.size()) { return in[n]; }\n        for (usize i = in.size(); i <= n; i++) { in.push_back(-in[modint_base::mod() % i] * (modint_base::mod() / i)); }\n        return in.back();\n    }\n    std::pair<ll, ll> quad() const\n    {\n        const auto ans = quad_r(v, mod());\n        ll x = std::get<0>(ans), y = std::get<1>(ans);\n        if (y < 0) { x = -x, y = -y; }\n        return {x, y};\n    }\n\nprivate:\n    static std::tuple<ll, ll, ll> quad_r(const ll r, const ll p)  // r = x/y (mod p), (x,y,z) s.t. x=yr+pz\n    {\n        if (std::abs(r) <= 1000) { return {r, 1, 0}; }\n        ll nr = p % r, q = p / r;\n        if (nr * 2LL >= r) { nr -= r, q++; }\n        if (nr * 2LL <= -r) { nr += r, q--; }\n        const auto sub = quad_r(nr, r);\n        const ll x = std::get<0>(sub), z = std::get<1>(sub), y = std::get<2>(sub);\n        return {x, y - q * z, z};\n    }\n\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, UInt&> mod_ref()\n    {\n        static UInt mod = 0;\n        return mod;\n    }\n    static uint norm(const uint x) { return x < mod() ? x : x - mod(); }\n    static modint_base make(const uint x)\n    {\n        modint_base m;\n        return m.v = x, m;\n    }\n    static modint_base power(modint_base x, ull n)\n    {\n        modint_base ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static modint_base inv(const ll v) { return v <= 2000000 ? small_inv(static_cast<usize>(v)) : modint_base{inverse(v, static_cast<ll>(mod()))}; }\n    static std::vector<modint_base>& inv_ref()\n    {\n        static std::vector<modint_base> in{1, 1};\n        return in;\n    }\n    uint v;\n};\ntemplate<uint mod>\nusing modint = modint_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modint = modint_base<id, true>;\n\n\ntemplate<typename Real>\nstruct complex\n{\n    using value_type = Real;\n    complex() : real{Real{0}}, imag{Real{0}} {}\n    complex(const complex&) = default;\n    complex(const Real& theta) : real(std::cos(theta)), imag(std::sin(theta)) {}\n    complex(const Real& r, const Real& i) : real{r}, imag{i} {}\n    ~complex() = default;\n    friend complex operator+(const complex& c) { return c; }\n    friend complex operator-(const complex& c) { return complex{-c.real, -c.imag}; }\n    friend complex operator+(const complex& c1, const complex& c2) { return complex{c1.real + c2.real, c1.imag + c2.imag}; }\n    friend complex operator-(const complex& c1, const complex& c2) { return complex{c1.real - c2.real, c1.imag - c2.imag}; }\n    friend complex operator*(const complex& c1, const complex& c2) { return complex{c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real}; }\n    friend complex operator*(const complex& c, const Real& r) { return complex{c.real * r, c.imag * r}; }\n    friend complex operator/(complex& c1, complex& c2) { c1* c2.conj() / c2.norm(); }\n    friend bool operator==(const complex& c1, const complex& c2) { return c1.real == c2.real and c1.imag == c2.imag; }\n    friend bool operator!=(const complex& c1, const complex& c2) { return not(c1 == c2); }\n    friend complex& operator+=(complex& c1, const complex& c2) { return c1.real += c2.real, c1.imag += c2.imag, c1; }\n    friend complex& operator-=(complex& c1, const complex& c2) { return c1.real += c2.real, c1.imag += c2.imag, c1; }\n    friend complex& operator*=(complex& c1, const complex& c2) { return c1 = c1 * c2; }\n    friend complex& operator*=(complex& c, const Real& r) { return c = c * r; }\n    friend complex& operator/=(complex& c1, const complex& c2) { return c1 = c1 / c2; }\n    complex conj() const { return complex{real, -imag}; }\n    Real norm() const { return real * real + imag * imag; }\n    Real abs() const { return std::sqrt(norm()); }\n    Real arg() const { return std::atan2(imag, real); }\n    friend std::ostream& operator<<(std::ostream& os, const complex& c) { return os << c.real << \"+\" << c.imag << \"i\"; }\n    Real real, imag;\n};\ntemplate<typename Real = double>\nclass fft\n{\nprivate:\n    static constexpr usize depth = 30;\n    static constexpr Real pi     = pi_v<Real>;\n    static void transform(std::vector<complex<Real>>& a, const usize lg, const bool rev)\n    {\n        static std::vector<complex<Real>> root[depth];\n        const usize sz = a.size();\n        assert((1UL << lg) == sz);\n        if (root[lg].empty()) {\n            root[lg].reserve(sz), root[lg].resize(sz);\n            for (usize i = 0; i < sz; i++) { root[lg][i] = complex<Real>(pi * Real(2 * i) / Real(sz)); }\n        }\n        std::vector<complex<Real>> tmp(sz);\n        for (usize w = (sz >> 1); w > 0; w >>= 1) {\n            for (usize y = 0; y < (sz >> 1); y += w) {\n                const complex<Real> r = rev ? root[lg][y].conj() : root[lg][y];\n                for (usize x = 0; x < w; x++) {\n                    const auto u = a[y << 1 | x], v = a[y << 1 | x | w] * r;\n                    tmp[y | x] = u + v, tmp[y | x | (sz >> 1)] = u - v;\n                }\n            }\n            std::swap(tmp, a);\n        }\n    }\n\npublic:\n    using value_type = Real;\n    fft()            = delete;\n    template<typename T = ll, typename I = int>\n    static std::vector<T> simple_convolute(const std::vector<I>& a, const std::vector<I>& b)\n    {\n        const usize need = a.size() + b.size() - 1, lg = clog(need), sz = 1UL << lg;\n        std::vector<complex<Real>> x(sz), y(sz);\n        for (usize i = 0; i < a.size(); i++) { x[i] = {(Real)a[i], (Real)0}; }\n        for (usize i = 0; i < b.size(); i++) { y[i] = {(Real)b[i], (Real)0}; }\n        transform(x, lg, false), transform(y, lg, false);\n        for (usize i = 0; i < sz; i++) { x[i] *= y[i]; }\n        transform(x, lg, true);\n        std::vector<T> ans(need);\n        for (usize i = 0; i < need; i++) { ans[i] = (T)std::round(x[i].real / (Real)sz); }\n        return ans;\n    }\n    template<typename T = ll, usize division = 2, typename I = int>\n    static std::vector<T> convolute(const std::vector<I>& a, const std::vector<I>& b)\n    {\n        constexpr usize bitnum = (depth + division - 1) / division;\n        const usize need = a.size() + b.size() - 1, lg = clog(need), sz = 1UL << lg;\n        std::vector<complex<value_type>> x[division], y[division], tmp(sz);\n        for (usize i = 0; i < division; i++) {\n            x[i].reserve(sz), x[i].resize(sz), y[i].reserve(sz), y[i].resize(sz);\n            std::fill(tmp.begin() + std::min(a.size(), b.size()), tmp.end(), complex<value_type>{});\n            for (usize j = 0; j < a.size(); j++) { tmp[j].real = value_type((a[j] >> (bitnum * i)) & ((1 << bitnum) - 1)); }\n            for (usize j = 0; j < b.size(); j++) { tmp[j].imag = value_type((b[j] >> (bitnum * i)) & ((1 << bitnum) - 1)); }\n            transform(tmp, lg, false);\n            for (usize j = 0; j < sz; j++) { tmp[j] *= value_type(0.5); }\n            for (usize j = 0; j < sz; j++) {\n                const usize k = j == 0 ? 0UL : sz - j;\n                x[i][j] = complex<value_type>{tmp[j].real + tmp[k].real, tmp[j].imag - tmp[k].imag}, y[i][j] = complex<value_type>{tmp[j].imag + tmp[k].imag, -tmp[j].real + tmp[k].real};\n            }\n        }\n        std::vector<complex<value_type>> z[division];\n        for (usize i = 0; i < division; i++) { z[i].reserve(sz), z[i].resize(sz); }\n        for (usize a = 0; a < division; a++) {\n            for (usize b = 0; b < division; b++) {\n                for (usize i = 0; i < sz; i++) {\n                    if (a + b < division) {\n                        z[a + b][i] += x[a][i] * y[b][i];\n                    } else {\n                        z[a + b - division][i] += x[a][i] * y[b][i] * complex<value_type>(0, 1);\n                    }\n                }\n            }\n        }\n        for (usize i = 0; i < division; i++) { transform(z[i], lg, true); }\n        std::vector<T> ans(need);\n        T base = 1;\n        for (usize k = 0; k < 2 * division - 1; k++, base *= (1LL << bitnum)) {\n            for (usize i = 0; i < need; i++) {\n                if (k < division) {\n                    ans[i] += base * T(std::round(z[k][i].real / value_type(sz)));\n                } else {\n                    ans[i] += base * T(std::round(z[k - division][i].imag / value_type(sz)));\n                }\n            }\n        }\n        return ans;\n    }\n    template<uint mod, bool dynamic = false, usize division = 2>\n    static std::vector<modint_base<mod, dynamic>> convolute(const std::vector<modint_base<mod, dynamic>>& a, const std::vector<modint_base<mod, dynamic>>& b)\n    {\n        using mint             = modint_base<mod, dynamic>;\n        constexpr usize bitnum = (depth + division - 1) / division;\n        const usize need = a.size() + b.size() - 1, lg = clog(need), sz = 1UL << lg;\n        std::vector<complex<value_type>> x[division], y[division], tmp(sz);\n        for (usize i = 0; i < division; i++) {\n            x[i].reserve(sz), x[i].resize(sz), y[i].reserve(sz), y[i].resize(sz);\n            std::fill(tmp.begin() + std::min(a.size(), b.size()), tmp.end(), complex<value_type>{});\n            for (usize j = 0; j < a.size(); j++) { tmp[j].real = value_type((a[j]() >> (bitnum * i)) & ((1 << bitnum) - 1)); }\n            for (usize j = 0; j < b.size(); j++) { tmp[j].imag = value_type((b[j]() >> (bitnum * i)) & ((1 << bitnum) - 1)); }\n            transform(tmp, lg, false);\n            for (usize j = 0; j < sz; j++) { tmp[j] *= value_type(0.5); }\n            for (usize j = 0; j < sz; j++) {\n                const usize k = j == 0 ? 0UL : sz - j;\n                x[i][j] = complex<value_type>{tmp[j].real + tmp[k].real, tmp[j].imag - tmp[k].imag}, y[i][j] = complex<value_type>{tmp[j].imag + tmp[k].imag, -tmp[j].real + tmp[k].real};\n            }\n        }\n        std::vector<complex<value_type>> z[division];\n        for (usize i = 0; i < division; i++) { z[i].reserve(sz), z[i].resize(sz); }\n        for (usize a = 0; a < division; a++) {\n            for (usize b = 0; b < division; b++) {\n                for (usize i = 0; i < sz; i++) {\n                    if (a + b < division) {\n                        z[a + b][i] += x[a][i] * y[b][i];\n                    } else {\n                        z[a + b - division][i] += x[a][i] * y[b][i] * complex<value_type>(0, 1);\n                    }\n                }\n            }\n        }\n        for (usize i = 0; i < division; i++) { transform(z[i], lg, true); }\n        std::vector<mint> ans(need);\n        mint base = 1;\n        for (usize k = 0; k < 2 * division - 1; k++, base *= (1LL << bitnum)) {\n            for (usize i = 0; i < need; i++) {\n                if (k < division) {\n                    ans[i] += int((base * ll(std::round(z[k][i].real / value_type(sz))))());\n                } else {\n                    ans[i] += int((base * ll(std::round(z[k - division][i].imag / value_type(sz))))());\n                }\n            }\n        }\n        return ans;\n    }\n};\n\ntemplate<uint mod = 924844033, uint root = 5>\nclass ntt\n{\nprivate:\n    using value_type             = modint<mod>;\n    static constexpr usize depth = 30;\n    static void transform(std::vector<value_type>& a, const usize lg, const bool rev)\n    {\n        const usize N = a.size();\n        assert(1UL << lg == N);\n        static std::vector<value_type> R[depth];\n        if (R[lg].empty()) {\n            R[lg].reserve(N), R[lg].resize(N, value_type(1));\n            const value_type r = value_type(root) ^ ((mod - 1) / N);\n            for (usize i = 1; i < N; i++) { R[lg][i] = R[lg][i - 1] * r; }\n        }\n        std::vector<value_type> tmp(N);\n        for (usize w = (N >> 1); w > 0; w >>= 1) {\n            for (usize y = 0; y < (N >> 1); y += w) {\n                const value_type r = rev ? R[lg][y == 0 ? 0 : N - y] : R[lg][y];\n                for (usize x = 0; x < w; x++) {\n                    const auto u = a[y << 1 | x], v = a[y << 1 | x | w]() * r;\n                    tmp[y | x] = u + v, tmp[y | x | (N >> 1)] = u - v;\n                }\n            }\n            std::swap(tmp, a);\n        }\n        if (rev) {\n            for (usize i = 0; i < N; i++) { a[i] /= value_type(N); }\n        }\n    }\n\npublic:\n    ntt() = delete;\n    static std::vector<value_type> convolute(const std::vector<value_type>& a, const std::vector<value_type>& b)\n    {\n        const usize need = a.size() + b.size() - 1, lg = clog(need), sz = 1UL << lg;\n        std::vector<value_type> A(sz, 0), B(sz, 0);\n        for (usize i = 0; i < a.size(); i++) { A[i] = a[i](); }\n        for (usize i = 0; i < b.size(); i++) { B[i] = b[i](); }\n        transform(A, lg, false), transform(B, lg, false);\n        for (usize i = 0; i < sz; i++) { A[i] *= B[i]; }\n        transform(A, lg, true);\n        std::vector<value_type> ans(need);\n        for (usize i = 0; i < need; i++) { ans[i] = int(A[i]()); }\n        return ans;\n    }\n};\ntemplate<uint mod, uint root, bool dynamic, uint fft_division>\nclass poly_base\n{\npublic:\n    using value_type = modint_base<mod, dynamic>;\n    poly_base() : v(0) {}\n    poly_base(const value_type& r) : v{r} { shrink(); }\n    poly_base(const std::vector<value_type>& v) : v{v} { shrink(); }\n    poly_base(const std::initializer_list<value_type>&& list) : v{list} { shrink(); }\n    std::vector<value_type> operator()() const { return v; }\n    value_type& operator[](const usize i) { return v[i]; }\n    const value_type& operator[](const usize i) const { return v[i]; }\n    value_type at(const usize i) const { return i < size() ? v[i] : value_type(0); }\n    friend poly_base operator+(const poly_base& p) { return p; }\n    friend poly_base operator-(const poly_base& p)\n    {\n        std::vector<value_type> ans = p.v;\n        for (auto& e : ans) { e = -e; }\n        return poly_base(ans);\n    }\n    friend poly_base operator+(const poly_base& p, const poly_base& q)\n    {\n        const usize sz = std::max(p.size(), q.size());\n        std::vector<value_type> ans(sz);\n        for (usize i = 0; i < sz; i++) { ans[i] = p.at(i) + q.at(i); }\n        return poly_base(ans);\n    }\n    friend poly_base operator-(const poly_base& p, const poly_base& q)\n    {\n        const usize sz = std::max(p.size(), q.size());\n        std::vector<value_type> ans(sz);\n        for (usize i = 0; i < sz; i++) { ans[i] = p.at(i) - q.at(i); }\n        return poly_base(ans);\n    }\n    friend poly_base operator*(const poly_base& p, const poly_base& q) { return p.size() <= 300 or q.size() <= 300 ? naive_multiply(p, q) : fft_multiply(p, q); }\n    friend poly_base operator*(const poly_base& p, const value_type& r)\n    {\n        std::vector<value_type> ans = p.v;\n        for (auto& e : ans) { e *= r; }\n        return poly_base(ans);\n    }\n    friend poly_base operator/(const poly_base& p, const value_type& r)\n    {\n        std::vector<value_type> ans = p.v;\n        for (auto& e : ans) { e /= r; }\n        return poly_base(ans);\n    }\n    friend poly_base operator>>(const poly_base& p, const usize s) { return p.divide_by_power(s); }\n    friend poly_base operator<<(const poly_base& p, const usize s) { return p.multiply_power(s); }\n    friend poly_base operator/(const poly_base& p, const poly_base& q) { return p.div(q); }\n    friend poly_base operator%(const poly_base& p, const poly_base& q) { return p.rem(q); }\n    friend poly_base& operator+=(poly_base& p, const poly_base& q) { return p = p + q; }\n    friend poly_base& operator-=(poly_base& p, const poly_base& q) { return p = p - q; }\n    friend poly_base& operator*=(poly_base& p, const poly_base& q) { return p = p * q; }\n    friend poly_base& operator*=(poly_base& p, const value_type& r) { return p = p * r; }\n    friend poly_base& operator/=(poly_base& p, const value_type& r) { return p = p / r; }\n    friend poly_base& operator>>=(poly_base& p, const usize s) { return p = (p >> s); }\n    friend poly_base& operator<<=(poly_base& p, const usize s) { return p = (p << s); }\n    friend poly_base& operator/=(poly_base& p, const poly_base& q) { return p = p / q; }\n    friend poly_base& operator%=(poly_base& p, const poly_base& q) { return p = p % q; }\n    poly_base multiply_power(const usize s) const\n    {\n        const usize sz = size();\n        if (sz == 0) { return poly_base(); }\n        std::vector<value_type> ans(sz + s, 0);\n        for (usize i = 0; i < sz; i++) { ans[i + s] = v[i]; }\n        return poly_base(ans);\n    }\n    poly_base divide_by_power(const usize s) const\n    {\n        const usize N = size();\n        if (N <= s) { return poly_base(); }\n        std::vector<value_type> ans(N - s);\n        for (usize i = 0; i < N - s; i++) { ans[i] = v[i + s]; }\n        return poly_base(ans);\n    }\n    poly_base rem_by_power(const usize k) const { return size() <= k ? *this : poly_base(std::vector<value_type>(v.begin(), v.begin() + k)); }\n    poly_base inverse(const usize k) const\n    {\n        poly_base q{value_type(1) / v[0]};\n        const auto T = poly_base{2};\n        for (usize i = 1, j = 0; j < k; j++, i *= 2) { q = (q * (T - rem_by_power(2 * i) * q)).rem_by_power(2 * i); }\n        return q;\n    }\n    template<typename Int>\n    poly_base power_and_rem(const Int k, const usize s)\n    {\n        if (k == 0) { return poly_base(1); }\n        if (k % 2 == 1) {\n            return (power_and_rem(k - 1, s) * (*this)).rem_by_power(s);\n        } else {\n            const auto q = power_and_rem(k / 2, s);\n            return (q * q).rem_by_power(s);\n        }\n    }\n    template<typename Int>\n    static poly_base rem_of_power(const Int k, const poly_base& p)\n    {\n        const usize B = p.size() * 2 - 1;\n        const auto q  = p.pseudo_inv(B);\n        poly_base ans{1};\n        const usize D = log2p1<usize>(k);\n        for (usize i = 0; i < D; i++) {\n            if (k & (static_cast<Int>(1) << (D - i - 1))) { ans = (ans.multiply_power(1)).rem(p, q, B); }\n            if (D - i - 1) { ans = (ans * ans).rem(p, q, B); }\n        }\n        return ans;\n    }\n    usize size() const { return v.size(); }\n    friend std::ostream& operator<<(std::ostream& os, const poly_base& p)\n    {\n        if (p.size() == 0) { return os << \"0\"; }\n        for (usize i = 0; i < p.size(); i++) { os << (i != 0 ? \"+\" : \"\") << p[i] << (i != 0 ? i == 1 ? \"X\" : \"X^\" + std::to_string(i) : \"\"); }\n        return os;\n    }\n\nprivate:\n    static std::vector<value_type> naive_convolute(const std::vector<value_type>& a, const std::vector<value_type>& b)\n    {\n        std::vector<value_type> ans(a.size() + b.size() - 1, 0);\n        for (usize i = 0; i < a.size(); i++) {\n            for (usize j = 0; j < b.size(); j++) { ans[i + j] += a[i] * b[j]; }\n        }\n        return ans;\n    }\n    static poly_base naive_multiply(const poly_base& p, const poly_base& q) { return p.size() == 0 or q.size() == 0 ? poly_base{} : poly_base{naive_convolute(p(), q())}; }\n    template<typename Poly = poly_base>\n    static std::enable_if_t<root == 0, Poly> fft_multiply(const poly_base& p, const poly_base& q) { return p.size() == 0 or q.size() == 0 ? poly_base() : poly_base{fft<double>::convolute<mod, dynamic, fft_division>(p(), q())}; }\n    template<typename Poly = poly_base>\n    static std::enable_if_t<root != 0, Poly> fft_multiply(const poly_base& p, const poly_base& q) { return p.size() == 0 or q.size() == 0 ? poly_base() : poly_base{ntt<mod, root>::convolute(p(), q())}; }\n    poly_base rev(const usize l) const\n    {\n        std::vector<value_type> ans = v;\n        ans.resize(l), std::reverse(ans.begin(), ans.end());\n        return poly_base(ans);\n    }\n    poly_base div(const poly_base& q) const\n    {\n        assert(q.size() > 0);\n        if (size() < q.size()) { return poly_base(); }\n        const usize N = size();\n        const auto iq = q.pseudoInv(N);\n        return (*this * iq).divide_by_power(N - 1);\n    }\n    poly_base rem(const poly_base& q) const { return *this - div(q) * q; }\n    poly_base rem(const poly_base& q, const poly_base& iq, const usize B) { return *this - q * ((*this * iq).divide_by_power(B - 1)); }\n    void shrink()\n    {\n        for (; not v.empty() and v.back() == 0; v.pop_back()) {}\n    }\n    poly_base pseudo_inv(const usize B) const\n    {\n        const usize N = size();\n        return rev(N).inverse(B + 2 > N ? clog(B - N + 2) : 0).rev(B + 1 - N);\n    }\n    std::vector<value_type> v;\n};\ntemplate<uint mod, uint fft_division = 2>\nusing poly = poly_base<mod, 0, false, fft_division>;\ntemplate<uint mod, uint fft_division = 2>\nusing dynamic_poly = poly_base<mod, 0, true, fft_division>;\ntemplate<uint mod = 924844033, uint root = 5>\nusing ntt_poly = poly_base<mod, root, false, 0>;\nint main()\n{\n    using mint   = modint<mod>;\n    using P      = poly<mod>;\n    const auto N = in<int>(), M = in<int>();\n    auto S = in<std::string>();\n    if (S[0] == 'B') {\n        for (auto& c : S) { c = (c == 'R' ? 'B' : 'R'); }\n    }\n    if (S == std::string(M, 'R')) {\n        mint ans = 0;\n        mint r = 1, b = 0;\n        for (int i = 0; i < N - 2; i++) {\n            mint r_ = r, b_ = b;\n            r = r_ + b_, b = r_;\n        }\n        ans += r;\n        r = 1, b = 1;\n        for (int i = 0; i < N - 2; i++) {\n            mint r_ = r, b_ = b;\n            r = r_ + b_, b = r_;\n        }\n        ans += r + b;\n        return outln(ans);\n    }\n    if (N % 2 == 1) { return outln(0); }\n    S.push_back('$');\n    std::vector<int> ls;\n    char p = 'R';\n    int l  = 0;\n    for (int i = 0; i <= M; i++) {\n        if (S[i] != p) {\n            p = S[i];\n            ls.push_back(l);\n            l = 1;\n        } else {\n            l++;\n        }\n    }\n    SHOW(ls);\n    int m = inf_v<int>;\n    for (int i = 0; i < ls.size(); i += 2) {\n        if (i == 0) {\n            chmin(m, ls[i] / 2 + 1);\n        } else if (ls[i] % 2 == 1) {\n            chmin(m, (ls[i] + 1) / 2);\n        }\n    }\n    SHOW(m);\n    const int n = N / 2;\n    // x1+x2+...+xk = n\n    // xi <= max\n    std::vector<mint> c(m + 1, 1);\n    for (int i = 1; i <= m; i++) { c[i] = -1; }\n    P f{c};\n    const auto g = f.inverse(clog(2 * n + 1));\n    mint ans     = 0;\n    for (int r1 = 1; r1 <= std::min(n, m); r1++) { ans += g.at(n - r1) * 2 * r1; }\n    outln(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//2019.5.19 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define eps 1e-10\n#define RG register\ninline int read() {\n    res s=0,ch=getchar();\n    while(ch<'0'||ch>'9')ch=getchar();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return s;\n}\ninline LL Read() {\n    RG LL s=0;\n    res ch=getchar();\n    while(ch<'0'||ch>'9')ch=getchar();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return s;\n}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N=2e5+10;\nconst int kcz=1e9+7;\nnamespace MAIN {\n    int n,m,dp[N],p=1,sum[N],ans;\n    char str[N];\n    inline void add(res &x,const res &y){\n        x+=y,x>=kcz?x-=kcz:(x<0?x+=kcz:1);\n    }\n    inline int Add(const res &x,const res &y){\n        return x+y>=kcz?x+y-kcz:(x+y<0?x+y+kcz:x+y);\n    }\n    inline int mul(const res &x,const res &y){\n        return int(1LL*x*y%kcz);\n    }\n    inline void MAIN(){\n        n=read(),m=read(),scanf(\"%s\",str+1);\n        for(;p<=m;p++)if(str[p]!=str[1])break;\n        p--,dp[0]=sum[0]=1;\n        if(p==m){\n            ans=1;\n            for(res i=0;i<=n;i++){\n                if(i>=2)dp[i]=sum[i-2];\n                sum[i]=Add(sum[i-1],dp[i]);\n                if(n-i>=2)add(ans,mul(dp[i],n-i));\n            }\n            printf(\"%d\\n\",ans);\n            return;\n        }\n        if(n&1){puts(\"0\");return;}\n        if(p%2==0)p++;\n        for(res t=0,i=p/2*2+1;i<=m;i++)\n            if(str[i]==str[1])t++;\n            else {\n                if(t&1)p=min(p,t);\n                t=0;\n            }\n        n>>=1,p=(p+1)>>1;\n        for(res i=0;i<=n;i++){\n            if(i)dp[i]=Add(sum[i-1],kcz-(i-p>0?sum[i-p-1]:0)),sum[i]=Add(sum[i-1],dp[i]);\n            if(n-i<=p)add(ans,mul(n-i,dp[i]<<1));\n        }\n        printf(\"%d\\n\",ans);\n    }\n}\nint main() {\n//    srand((unsigned)time(NULL));\n//    freopen(\"graph.in\",\"r\",stdin);\n//    freopen(\"graph.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long word;\ntypedef pair<int, int> pi;\nconst int MAXN = 200005;\nconst int mod = 1e9 + 7;\n\nint n, m;\nint f[MAXN];\nchar s[MAXN];\nint sum[MAXN];\n\nint main(){\n\tscanf(\"%d %d %s\",&n,&m,s);\n\tfor(int i=0; i<m; i++) if(s[i] == 'R') s[i] = 'A';\n\tif(s[0] == 'B'){\n\t\tfor(int i=0; i<m; i++) s[i] = 'A' + 'B' - s[i];\n\t}\n\tif(count(s, s + m, 'B') == 0){\n\t\tf[0] = 1; f[1] = 2;\n\t\tfor(int i=2; i<=n; i++){\n\t\t\tf[i] = f[i-1] + f[i-2];\n\t\t\tf[i] %= mod;\n\t\t}\n\t\tlint ret = f[n];\n\t\tif(n == 3) ret += mod - 1;\n\t\telse if(n >= 4) ret += mod - f[n - 4];\n\t\tret %= mod;\n\t\tcout << ret << endl;\n\t\treturn 0;\n\t}\n\tint alt = 1e9;\n\tint pref = 0;\n\twhile(s[pref] == 'A') pref++;\n\tif(n % 2 == 1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint x = min(alt, pref + 1 - pref % 2);\n\tf[0] = 1;\n\tsum[0] = 1;\n\tfor(int i=1; i<=n/2; i++){\n\t\tf[i] = sum[i - 1];\n\t\tif(i >= (x + 3) / 2) f[i] += mod - sum[i - (x + 3) / 2];\n\t\tf[i] %= mod;\n\t\tsum[i] = (sum[i-1] + f[i]) % mod;\n\t}\n\tlint ret = 0;\n\tfor(int i=0; i<n;i++){\n\t\tint len = n - 1 - x;\n\t\tif(n - 1 - x > n - 1 - i) continue;\n\t\tret += sum[(n - 1 - i) / 2];\n\t\tif(len >= 1){\n\t\t\tret += mod - sum[(len - 1) / 2];\n\t\t}\n\t}\n\n\tcout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\ntemplate <long long Mod = MOD>\nclass Modint {\n public:\n  long long v;\n\n  Modint(const Modint &x) { v = x.v; }\n  explicit Modint(int x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(long long x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    if (x < 0) x += Mod;\n    v = x;\n  }\n  explicit Modint(unsigned x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  explicit Modint(unsigned long long x) {\n    if (Mod <= x) x %= Mod;\n    v = x;\n  }\n  template <typename T>\n  explicit Modint(T x) {\n    if (x < 0 or Mod <= x) x %= Mod;\n    v = x;\n  }\n  Modint() : v(0) {}\n  long long get() const { return v; }\n  Modint mpow(Modint &n) const { return mpow(n.v); }\n  Modint mpow(long long n) const {\n    long long i = 1, p = v;\n    Modint ret(1);\n    while (i <= n) {\n      if (i & n) ret *= p;\n      i = (i << 1);\n      p = (p * p) % Mod;\n    }\n    return ret;\n  }\n  Modint operator-() const { return (v ? Modint(Mod - v) : Modint(0)); }\n  explicit operator int() const { return v; }\n  explicit operator long long() const { return v; }\n  Modint &operator+=(const Modint &a) {\n    v = (v + a.v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  Modint &operator-=(const Modint &a) {\n    v = (v - a.v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  Modint &operator*=(const Modint &a) {\n    v = (v * a.v) % Mod;\n    return *this;\n  }\n  Modint &operator/=(const Modint &a) {\n    v = (v * a.mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator+=(const T &a) {\n    v = (v + Modint(a).v);\n    if (v >= Mod) v -= Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator-=(const T &a) {\n    v = (v - Modint(a).v);\n    if (v < 0) v += Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator*=(const T &a) {\n    v = (v * Modint(a).v) % Mod;\n    return *this;\n  }\n  template <class T>\n  Modint &operator/=(const T &a) {\n    v = (v * Modint(a).mpow(Mod - 2).v) % Mod;\n    return *this;\n  }\n  friend Modint operator+(const Modint &a, const Modint &b) {\n    return Modint(a) += b;\n  }\n  friend Modint operator-(const Modint &a, const Modint &b) {\n    return Modint(a) -= b;\n  }\n  friend Modint operator*(const Modint &a, const Modint &b) {\n    return Modint(a) *= b;\n  }\n  friend Modint operator/(const Modint &a, const Modint &b) {\n    return Modint(a) /= b;\n  }\n  template <class T, class U>\n  friend Modint operator+(const T &a, const U &b) {\n    return Modint(a) += Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator-(const T &a, const U &b) {\n    return Modint(a) -= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator*(const T &a, const U &b) {\n    return Modint(a) *= Modint(b);\n  }\n  template <class T, class U>\n  friend Modint operator/(const T &a, const U &b) {\n    return Modint(a) /= Modint(b);\n  }\n};\n\ntemplate <long long M>\nostream &operator<<(ostream &os, const Modint<M> m) {\n  return os << m.v;\n}\n\ntemplate <long long Mod = MOD>\nclass Factorial {\n private:\n  int n;\n\n public:\n  vector<long long> fac, inv;\n\n public:\n  Factorial(long long n) : n(n), fac(n + 1), inv(n + 1) {\n    fac[0] = 1;\n    for (int i = 0; i < n; ++i) fac[i + 1] = fac[i] * (i + 1) % Mod;\n    inv[n] = modpow(fac[n], Mod - 2);\n    for (int i = n - 1; i >= 0; --i) inv[i] = inv[i + 1] * (i + 1) % Mod;\n  };\n  long long modpow(long long a, long long n, long long mod = Mod) {\n    long long i = 1, ret = 1, p = a;\n    while (i <= n) {\n      if (i & n) {\n        ret = (ret * p) % mod;\n      }\n      i = (i << 1);\n      p = (p * p) % mod;\n    }\n    return ret;\n  }\n  long long C(int a, int b) {\n    return (fac[a] * inv[b] % Mod) * inv[a - b] % Mod;\n  }\n  long long P(int a, int b) {\n    return (fac[a]) * inv[a - b] % Mod;\n  }\n  long long H(int a, int b) {  //The number of multisets of length b on a symbols\n    return C(a + b - 1, b);\n  }\n};\n\nclass Solver2 {\n public:\n  LL n, m;\n  string s;\n  Solver2(LL n, LL m) : n(n), m(m){};\n\n  void solve() {\n    cin >> s;\n\n    if (s[0] == 'B') {\n      for (int i = 0; i < m; ++i) {\n        if (s[i] == 'B') {\n          s[i] = 'R';\n        } else {\n          s[i] = 'B';\n        }\n      }\n    }\n    DBG(s)\n    //R~~~\n    int pp = -1;\n    for (int i = 0; i < m; ++i) {\n      if (s[i] == 'B') {\n        pp = i;\n        break;\n      }\n    }\n    DBG(pp)\n    if (pp == -1) {\n      deque<Modint<>> dpr(2), dpb(2);\n      dpr[0] = dpb[1] = Modint<>(1);\n      Modint<> sum(1);\n      for (int i = 1; i < n; ++i) {\n        dpr.push_front(sum);\n        sum += sum;\n        if (dpr.size() > 2) {\n          sum -= dpr[2];\n          dpr.pop_back();\n        }\n        DBG(dpr, sum)\n      }\n      sum = Modint<>(1);\n      for (int i = 1; i < n; ++i) {\n        dpb.push_front(sum);\n        sum += sum;\n        if (dpb.size() > 2) {\n          sum -= dpb[2];\n          dpb.pop_back();\n        }\n        DBG(dpb, sum)\n      }\n      cout << dpr[0] + dpr[1] + dpb[0] << endl;\n      return;\n    }\n    if (n % 2) {\n      cout << 0 << endl;\n      return;\n    }\n    int M;\n    if (pp == 1)\n      M = 1;\n    else {\n      if (pp % 2 == 0) pp++;\n      M = (pp + 1) / 2;\n    }\n    deque<Modint<>> dp;\n    dp.push_back(Modint<>(1));\n    dp.push_back(Modint<>(1));\n    Modint<> sum(2);\n\n    for (int i = 1; i < n / 2; ++i) {\n      dp.push_front(sum);\n      sum += sum;\n      if (dp.size() > M) {\n        sum -= dp[M];\n        dp.pop_back();\n      }\n      DBG(dp)\n    }\n\n    cout << sum * 2 << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  // std::cout << std::fixed << std::setprecision(12);\n  long long n = 0, m;\n  std::cin >> n >> m;\n\n  Problem::Solver2 sol(n, m);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass finite_field {\n\tconst int md;\n\tconst int sz;\n\tvector<int> fct, fnv;\n\tpublic :\n\t\tfinite_field(\n\t\t\t\tconst int md,\n\t\t\t\tconst int init_factorial_size = 0\n\t\t\t) :\n\t\t\tmd(md), sz(init_factorial_size),\n\t\t\tfct(sz), fnv(sz)\n\t\t\t{\n\t\t\t\tif (sz) {\n\t\t\t\t\tfct[0] = 1;\n\t\t\t\t\tfor (int i = 1; i < sz; i++) fct[i] = prod(fct[i - 1], i);\n\t\t\t\t\tfnv[sz - 1] = inv(fct[sz - 1]);\n\t\t\t\t\tfor (int i = sz - 1; i >= 1; i--) fnv[i - 1] = prod(fnv[i], i);\n\t\t\t\t}\n\t\t\t}\n\t\tinline void add (int& a, const int b) const {\n\t\t\ta += b;\n\t\t\tif (a >= md) a -= md;\n\t\t}\n\t\tinline void sub (int& a, const int b) const {\n\t\t\ta -= b;\n\t\t\tif (a < 0) a += md;\n\t\t}\n\t\ttemplate<class... A> int sum (A... args) const {\n\t\t\tint ret = 0;\n\t\t\tfor (int a : initializer_list<int>{args...}) {\n\t\t\t\tadd(ret, a);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\ttemplate<class... A> int prod (A... args) const {\n\t\t\tlong long ret = 1;\n\t\t\tfor (int a : initializer_list<int>{args...}) {\n\t\t\t\tret *= a;\n\t\t\t\tret %= md;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\t\tvoid mul (int& a, int b) const {\n\t\t\ta = prod(a, b);\n\t\t}\n\t\tinline int inv (int a) const {\n\t\t\ta %= md; if (a < 0) a += md;\n\t\t\tint b = md, u = 0, v = 1;\n\t\t\twhile (a) {\n\t\t\t\tint t = b / a;\n\t\t\t\tb -= a * t; swap(a, b);\n\t\t\t\tu -= v * t; swap(u, v);\n\t\t\t}\n\t\t\tassert(b == 1);\n\t\t\tif(u < 0) u += md;\n\t\t\treturn u;\n\t\t}\n\t\tinline int quat (int a, int b) const {\n\t\t\treturn prod(a, inv(b));\n\t\t}\n\t\tvoid div (int& a, int b) const {\n\t\t\ta = quat(a, b);\n\t\t}\n\t\tinline int binom (int n, int k) const {\n\t\t\tassert(0 <= n && n < sz);\n\t\t\tif (k < 0 || n < k) return 0;\n\t\t\treturn prod(fct[n], fnv[k], fnv[n - k]);\n\t\t}\n};\nint main() {\n\tcin.tie(0); cin.sync_with_stdio(false);\n\tint n, m; string s;\n\tcin >> n >> m >> s;\n\tfinite_field fld(1e9 + 7);\n\tif (s == string(m, s[0])) {\n\t\tint ans = 0;\n\t\tfor (int first = 0; first < 2; first++) {\n\t\t\tvector<int> dp(2, 0);\n\t\t\tdp[first] = 1;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tvector<int> new_dp(2, 0);\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tfor (int x = 0; x < 2; x++) {\n\t\t\t\t\t\tif (j + x < 2) {\n\t\t\t\t\t\t\tfld.add(new_dp[j], dp[x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tswap(dp, new_dp);\n\t\t\t}\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tif (j + first < 2) {\n\t\t\t\t\tfld.add(ans, dp[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\tif (n & 1) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tvector<int> seqs;\n\tint t = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (s[i] == s[0]) {\n\t\t\t++t;\n\t\t} else {\n\t\t\tseqs.push_back(t);\n\t\t\tt = 0;\n\t\t}\n\t}\n\tint bound = seqs[0];\n\tif (!(bound & 1)) {\n\t\t++bound;\n\t}\n\tfor (int it = 1; it < (int) seqs.size(); it++) {\n\t\tif (seqs[it] % 2 == 1) {\n\t\t\tbound = min(bound, seqs[it]);\n\t\t}\n\t}\n\tn /= 2;\n\tbound /= 2;\n\tint ans = 0;\n\tif (bound == 0) {\n\t\tans = 1;\n\t} else {\n\t\tvector<int> dp(n);\n\t\tvector<int> pref(n + 1);\n\t\tdp[0] = 1;\n\t\tpref[1] = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdp[i] = pref[i];\n\t\t\tif (i - bound - 1 >= 0) {\n\t\t\t\tfld.sub(dp[i], pref[i - bound - 1]);\n\t\t\t}\n\t\t\tpref[i + 1] = fld.sum(pref[i], dp[i]);\n\t\t}\n\t\tfor (int i = n - 1 - bound; i < n; i++) {\n\t\t\tfld.add(ans, fld.prod(dp[i], n - i));\n\t\t}\n\t}\n\tcout << fld.prod(2, ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf 1010000000\n#define infll 1010000000000000000ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define mpr make_pair\n#define fi first\n#define se second\n#define vi vector<int>\n#define pb push_back\n#define mod 1000000007\n#define ad(x,y) (x=(x+(y))%mod)\n#define up(x,y) (x<(y)?x=(y):0)\n#define dn(x,y) (x>(y)?x=(y):0)\n#define N 200009\nusing namespace std;\n\nint n,m,dp[N][2][2],f[N]; char ch[N]; vi e;\nvoid solve0(){\n\tint i,j,k,l; dp[1][0][0]=dp[1][1][1]=1;\n\tfor (i=2; i<=n; i++)\n\t\tfor (j=0; j<2; j++)\n\t\t\tfor (k=0; k<2; k++)\n\t\t\t\tfor (l=0; k+l<2; l++)\n\t\t\t\t\tad(dp[i][j][l],dp[i-1][j][k]);\n\tprintf(\"%d\\n\",((dp[n][0][0]+dp[n][0][1])%mod+dp[n][1][0])%mod);\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,ch+1);\n\tint i;\n\tif (ch[1]=='B')\n\t\tfor (i=1; i<=n; i++)  ch[i]=(ch[i]=='R'?'B':'R');\n\tfor (i=2; i<=n; i++) if (ch[i]=='B') break;\n\tif (i>n){\n\t\tsolve0(); return 0;\t\t\t\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tfor (i=n; i; i--) if (ch[i]=='B') break;\n\tint lim=n,now=0;\n\tfor (; i>=0; i--){\n\t\tif (!i || ch[i]=='B'){\n\t\t\tif (now) e.pb(now);\n\t\t\tnow=0;\n\t\t} else now++;\n\t}\n\treverse(e.begin(),e.end());\n\tfor (i=0; i<e.size(); i++){\n\t\tif (i==0 && !(e[i]&1)) dn(lim,e[i]+2);\n\t\tif (e[i]&1) dn(lim,e[i]+1);\t\n\t}\n\tf[0]=f[2]=1;\n\tfor (i=3; i<=n; i++)\n\t\tf[i]=((ll)f[i-2]-(i-2-lim>=0?f[i-2-lim]:0)+f[i-2]+mod)%mod;\n\tint ans=0;\n\tfor (i=2; i<=lim; i+=2) ad(ans,(ll)f[n-i]*i);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\n\nint n, m, k;\nstring s;\nllint dp[200005], dif[200005];\nllint dp2[200005][2];\n\nllint calc()\n{\n\tint N = (n-1)/2;\n\tk = min(k, N);\n\t\n\tdif[0] = 1, dif[1] = mod-1;\n\tllint sum = 0;\n\tfor(int i = 0; i <= N; i++){\n\t\tsum += dif[i], sum %= mod;\n\t\tdp[i] = sum;\n\t\tdif[i+1] += dp[i], dif[i+1] %= mod;\n\t\tdif[i+k+2] += mod - dp[i], dif[i+k+2] %= mod;\n\t}\n\t\n\tllint ret = 0;\n\tfor(int i = 0; i <= k; i++){\n\t\tret += (i+1)*2 * dp[N-i] % mod;\n\t\tret %= mod;\n\t}\n\treturn ret;\n}\n\nllint calc2()\n{\n\tllint ret = 0;\n\t\n\tdp2[1][0] = 1;\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\tif(j == 1 && k == 1) continue;\n\t\t\t\tdp2[i+1][k] += dp2[i][j], dp2[i+1][k] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tret += dp2[n][0] + dp2[n][1], ret %= mod;\n\t\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tdp2[i][j] = 0;\n\t\t}\n\t}\n\tdp2[1][1] = 1;\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int j = 0; j < 2; j++){\n\t\t\tfor(int k = 0; k < 2; k++){\n\t\t\t\tif(j == 1 && k == 1) continue;\n\t\t\t\tdp2[i+1][k] += dp2[i][j], dp2[i+1][k] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tret += dp2[n][0], ret %= mod;\n\t\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> m;\n\tcin >> s;\n\t\n\tif(s[0] == 'B'){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tif(s[i] == 'R') s[i] = 'B';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\t\n\tbool diff = false;\n\tfor(int i = 1; i < m; i++){\n\t\tif(s[i] != s[i-1]) diff = true;\n\t}\n\tif(!diff){\n\t\tcout << calc2() << endl;\n\t\treturn 0;\n\t}\n\tif(n % 2){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\t\n\tk = n+1;\n\tint cnt = 0; bool flag = true;\n\tfor(int i = 0; i < m; i++){\n\t\tif(s[i] == 'R') cnt++;\n\t\telse{\n\t\t\tif(cnt % 2) k = min(k, cnt);\n\t\t\tif(flag) k = min(k, cnt+1), flag = false;\n\t\t\tcnt = 0;\n\t\t}\n\t}\n\tk = (k-1)/2;\n\t\n\tcout << calc() << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\n#include<cassert>\nusing namespace std;\nusing lint = long long;\nusing ld = long double;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(lint i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nint n, m;\nstring s;\n\nvoid allred() {\n\tlint v1 = 0, v2 = 0;\n\tlint ans = 0;\n\tv1 = 1;\n\tREP(i, n - 1) {\n\t\tlint nv1 = (v1 + v2) % MOD;\n\t\tlint nv2 = v1;\n\t\tv1 = nv1;\n\t\tv2 = nv2;\n\t}\n\tans += (v1 + v2) % MOD;\n\tv1 = 0; v2 = 1;\n\tREP(i, n - 1) {\n\t\tlint nv1 = (v1 + v2) % MOD;\n\t\tlint nv2 = v1;\n\t\tv1 = nv1;\n\t\tv2 = nv2;\n\t}\n\tans += v1;\n\tcout << (ans % MOD + MOD) % MOD << endl;\n\treturn;\n}\n\nvoid solve(vector<int> suc_red, int omn) {\n\tint th = omn;\n\tif(suc_red[0] % 2 == 0) th = min(th, suc_red[0] + 1);\n\tlint ans = 0;\n\t/*\n\tif((n - 1) % 2 && (n - 1) <= th) {\n\t\tans += n;\n\t}*/\n\tvector<lint> dpr(n), dpb(n);\n\tdpr[0] = 0;\n\tdpb[0] = 1;\n\tqueue<lint> q0;\n\tqueue<lint> q1;\n\tlint sum0 = 1, sum1 = 0;\n\tq0.push(1);\n\tFOR(i, 1, n) {\n\t\tif(i % 2 == 1) {\n\t\t\twhile(!q0.empty() && (int)q0.size() > (th + 1) / 2) {\n\t\t\t\tsum0 -= q0.front(); sum0 %= MOD;\n\t\t\t\tq0.pop();\n\t\t\t}\n\t\t\tdpr[i] = sum0;\n\t\t} else {\n\t\t\twhile(!q1.empty() && (int)q1.size() > (th + 1) / 2) {\n\t\t\t\tsum1 -= q1.front(); sum1 %= MOD;\n\t\t\t\tq1.pop();\n\t\t\t}\n\t\t\tdpr[i] = sum1;\n\t\t}\n\t\tdpb[i] = dpr[i - 1];\n\t\tif(i % 2 == 0) {\n\t\t\tq0.push(dpb[i]);\n\t\t\tsum0 += dpb[i]; sum0 %= MOD;\n\t\t} else {\n\t\t\tq1.push(dpb[i]);\n\t\t\tsum1 += dpb[i]; sum1 %= MOD;\n\t\t}\n\t}\n\tFOR(i, 1, n) {\n\t\tif(i > th) break;\n\t\tans += dpb[n - 1 - i] * i;\n\t\tans %= MOD;\n\t}\n\tans += dpr[n - 1]; ans %= MOD;\n\tcout << (ans % MOD + MOD) % MOD << endl;\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> m;\n\tcin >> s;\n\tif(s[0] == 'B') {\n\t\tREP(i, m) {\n\t\t\tif(s[i] == 'B') s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\n\tvector<int> suc_red;\n\tint c = 0;\n\tREP(i, m) {\n\t\tif(s[i] == 'R') c++;\n\t\telse {\n\t\t\tif(c != 0) suc_red.pb(c);\n\t\t\tc = 0;\n\t\t}\n\t}\n\tif(c != 0) suc_red.pb(c);\n\n\tif(suc_red[0] == m) {\n\t\tallred();\n\t\treturn 0;\n\t}\n\n\tint omn = INF;\n\tREP(i, (int)suc_red.size() - 1) {\n\t\tif(suc_red[i] % 2) omn = min(omn, suc_red[i]);\n\t}\n\tsolve(suc_red, omn);\n\treturn 0;\n}\n/* --------------------------------------- */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nstruct SegmentTree\n{\n    using T = mint;\n\n    int N;\n    vector<T> dat;\n\n    T id = 0;\n    T F(T &a, T &b) { return a + b; }\n    \n    SegmentTree(int n){\n        N = 1;\n        while(n > N) N = N << 1;\n        dat = vector<T>(2 * N - 1, id);\n    }\n\n    SegmentTree(int n, vector<T> &v){\n        N = 1;\n        while(n > N) N = N << 1;\n        dat = vector<T>(2 * N - 1, id);\n        for(int i = 0; i < n; i++) dat[i + N - 1] = v[i];\n        for(int i = N - 2; i >= 0; i--) dat[i] = F(dat[i * 2 + 1], dat[i * 2 + 2]); \n    }\n\n\n    void update(int k, T a){\n        k += N - 1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k - 1) / 2;\n            dat[k] = F(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n\n    void reset() { fill(dat.begin(), dat.end(), id); }\n\n    T get(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l) return id;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            T vl = get(a, b, k * 2 + 1, l, (l + r) / 2);\n            T vr = get(a, b, k * 2 + 2, (l + r) / 2, r);\n            return F(vl, vr);\n        }\n    }\n    T get(int a, int b) { return get(a, b, 0, 0, N); }\n\n    T val(int k){ return dat[k + N - 1]; }\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n\n    if(S[0] == 'B'){\n        REP(i, N){\n            if(S[i] == 'B') S[i] = 'R';\n            else S[i] = 'B';\n        }\n    }\n\n    int f = -1, s = INF, t = 0;\n    REP(i, M){\n        if(S[i] == 'R') t++;\n        else{\n            if(f == -1) f = t;\n            else if(t % 2) Min(s, t);\n            t = 0;\n        } \n    }\n\n    mint ans = 0;\n    if(f == -1){\n        mmat dp(N, mvec(2, 0));\n        dp[0][0] = 1;\n        REP(i, N - 1){\n            dp[i + 1][0] += dp[i][0] + dp[i][1];\n            dp[i + 1][1] += dp[i][0];\n        }\n        ans = dp[N - 1][0] + dp[N - 1][1] + dp[N - 2][0];\n    }else if(N % 2 == 0){\n        int d;\n        if(f % 2) d = min(f, s);\n        else d = min(f + 1, s);\n        //debug(d);\n        N /= 2;\n        d /= 2;\n\n        mvec dp(N, 0);\n        dp[0] = 1;\n        SegmentTree ST(N, dp);\n        FOR(i, 1, N){\n            dp[i] = ST.get(i - d - 1, i);\n            ST.update(i, dp[i]);\n        }\n        REP(i, d + 1) if(N - 1 - i >= 0) ans += dp[N - 1 - i] * 2 * (i + 1);\n        //vdebug(dp);\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int mo=1e9+7,N=2e5+5;\nint vf[N],fac[N],inv[N];\ninline int C(int n,int m){return 1ll*vf[m]*vf[n-m]%mo*fac[n]%mo;}\nint n,m,i,j,ans,lm=N,f[N],s[N];\nchar c[N];\nint main(){\n\tfor(int i=*vf=*fac=1;i<N;++i)\n\t\tinv[i]=i==1?1:1ll*(mo-mo/i)*inv[mo%i]%mo,\n\t\tvf[i]=1ll*vf[i-1]*inv[i]%mo,\n\t\tfac[i]=1ll*fac[i-1]*i%mo;\n\tscanf(\"%d%d%s\",&n,&m,c+1);\n\tfor(i=1;c[i]==c[1];++i);\n\tif(i>m){\n\t\tstatic int f[N][2];\n\t\tf[0][0]=1;\n\t\tfor(i=1;i<=n;++i)f[i][0]=(f[i-1][0]+f[i-1][1])%mo,f[i][1]=f[i-1][0];\n\t\tans=f[n][0];\n\t\tmemset(f,0,sizeof f);\n\t\tf[0][1]=1;\n\t\tfor(i=1;i<=n;++i)f[i][0]=(f[i-1][0]+f[i-1][1])%mo,f[i][1]=f[i-1][0];\n\t\tans=(ans+f[n][1])%mo;\n\t}else{\n\t\tlm=i&1?i:i-1;\n\t\tfor(;i<=m;i=j){\n\t\t\tif(c[i+1]==c[i]){puts(\"0\");return 0;}\n\t\t\tfor(j=i+1;c[j]==c[1];++j);\n\t\t\tif(j<=m && (j-i-1)%2==1)lm=std::min(lm,j-i-1);\n\t\t}\n\t\tif(n&1){puts(\"0\");return 0;}\n\t\tlm-=lm%2==0;lm=lm+1>>1;\n\t\ts[0]=f[0]=1;\n\t\tfor(i=1;i<=n;++i)f[i]=(s[i-1]+mo-(i>lm?s[i-lm-1]:0))%mo,s[i]=(s[i-1]+f[i])%mo;\n\t\tfor(i=1;i<=lm*2-1 && i+1<=n;i+=2)ans=(ans+1ll*(i+1)*f[n-i-1>>1])%mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst ll N=2e5+10,mo=1e9+7;\nll f[N],n,m,lim,q[N];\nchar s[N];\nvoid move(ll &a,ll b){a=(a+b)%mo;}\nint main(){\n\tcin>>n>>m;\n\tscanf(\"%s\",s+1);\n\tif (s[1]=='B'){\n\t\tfor (ll i=1;i<=m;i++)s[i]='B'+'R'-s[i];\n\t}\n\tll cnt=0;\n\tfor (ll i=1;i<=m;i++){\n\t\tif (s[i]=='R')cnt++;\n\t\telse {\n\t\t\tif (!lim)lim=cnt|1;\n\t\t\telse if (cnt&1)lim=min(lim,cnt);\n\t\t\tcnt=0;\n\t\t}\n\t}\n\tif (!lim){\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tmove(f[i],s[i-2]+i-(i==1));\n\t\t\ts[i]=(s[i-1]+f[i])%mo;\n\t\t}\n\t\tcout<<f[n]+1<<endl;\n\t\treturn 0;\n\t}\n\tlim++;\n\tfor (ll i=1;i<=n;i++){\n\t\tf[i]=q[i-2];\n\t\tif (i<=lim&&(i%2==0))move(f[i],i);\n\t\tq[i]=((ll)q[i-2]+f[i]-(i>lim?f[i-lim]:0)+mo)%mo;\n\t}\n\tcout<<f[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-03 17:07:09\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=200010,mod=1000000007;\nint n,m,flag,l,Flag;\ni64 f[N],F[N],ans;\nchar s[N];\nint main()\n{\n\tn=read(); m=read();\n\tscanf(\"%s\",s+1);\n\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\tif(!flag)\n\t{\n\t\tf[0]=1; f[1]=1; f[2]=2;\n\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t\treturn 0;\n\t}\n\tl=n-1;\n\tfor(int i=1,j;i<=m;)\n\t\tif(s[i]==s[1])\n\t\t{\n\t\t\tj=i;\n\t\t\twhile(s[j]==s[1]) j++;\n\t\t\tif(j>n) break;\n\t\t\tif(((j-i)&1)||(!Flag)) l=std::min(l,(j-i)+((j-i)%2==0));\n\t\t\ti=j+1; Flag=1;\n\t\t}\n\t\telse i++;\n\tif(n&1){ printf(\"0\\n\"); return 0; }\n\tn/=2; l=(l+1)/2;\n//\tprintf(\"%d %d\\n\",int(n),int(l));\n\tf[0]=F[0]=1;\n\tfr(i,1,n)\n\t{\n\t\tf[i]=(F[i-1]+mod-(i-l-1>=0?F[i-l-1]:0))%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t}\n\tfr(i,1,l) ans=(ans+f[n-i]*2*i)%mod;\n\tprintf(\"%d\\n\",int(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // clang-format off\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define in2(s,t)     rep(i,sz(s)){in(s[i] , t[i]);}\n#define in3(s,t,u)   rep(i,sz(s)){in(s[i] , t[i] , u[i]);}\n#define in4(s,t,u,v) rep(i,sz(s)){in(s[i] , t[i] , u[i] , v[i]);}\n#ifdef ONLINE_JUDGE\n  #define rep(i,N) for(int i = 0; i < (int)(N); i++)\n  #define repr(i,N) for(int i = (int)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(int i = 1; i <= (int)(N) ; i++)\n  #define repr1(i,N) for(int i = (N) ; (int)(i) > 0 ; i--)\n#else\n  #define rep(i,N) for(long long i = 0; i < (long long)(N); i++)\n  #define repr(i,N) for(long long i = (long long)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(long long i = 1; i <= (long long)(N) ; i++)\n  #define repr1(i,N) for(long long i = (N) ; (long long)(i) > 0 ; i--)\n#endif\nusing namespace std; void solve();\nusing ll = long long; template<class T = ll> using V = vector<T>;\nusing vi = V<int>; using vl = V<>; using vvi = V< V<int> >;\nusing vd = V<double>; using vs = V<string>; using vvl = V< V<> >;\nconstexpr int inf = 1001001001; constexpr ll infLL = (1LL << 61) - 1;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T,typename U>ll ceil(T a,U b){return (a + b - 1) / b;}\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); for(int i=0;i<s;i++) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);} while(0)\n  #define trcc(v) do { cerr << \"name : \" << #v << \"\\n\"; int cnt = 0; each(x , v){cerr << (cnt++) << \" : \"; trc(x); } } while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  #define trcc(...)\n  int main(){solve();}\n#endif\n\nconstexpr ll TEN(int n){ll ret=1,x=10;while(n){if(n&1)ret*=x;x*=x;n>>=1;}return ret;}\n#define mem(a, val) memset(a, val, sizeof(a))\n\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\nusing P = pair<ll,ll>; using vp = V<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n// clang-format on\n////////////////////////////////////////////////////\n\n\nvector<pair<char,int>> RunLengthEncoding(string& S){\n  vector<pair<char,int>> ret;\n  char c = -1;\n  int n = 0;\n  for(char x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate<typename T>\nvector<pair<T,int>> RunLengthEncoding(vector<T>& S){\n  vector<pair<T,int>> ret;\n  T c = -1;\n  int n = 0;\n  for(T& x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\nusing mint = modint;\n\nnamespace FastFourierTransform {\n  using real = double;\n\n  struct C {\n    real x, y;\n\n    C() : x(0), y(0) {}\n\n    C(real x, real y) : x(x), y(y) {}\n\n    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }\n\n    inline C conj() const { return C(x, -y); }\n  };\n\n  const real PI = acosl(-1);\n  int base = 1;\n  vector< C > rts = { {0, 0},\n                     {1, 0} };\n  vector< int > rev = {0, 1};\n\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    while(base < nbase) {\n      real angle = PI * 2.0 / (1 << (base + 1));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        real angle_i = angle * (2 * i + 1 - (1 << base));\n        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n      }\n      ++base;\n    }\n  }\n\n  void fft(vector< C > &a, int n) {\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          C z = a[i + j + k] * rts[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n  }\n\n  vector< int64_t > multiply(const vector< int > &a, const vector< int > &b) {\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = C(x, y);\n    }\n    fft(fa, sz);\n    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n      fa[i] = z;\n    }\n    for(int i = 0; i < (sz >> 1); i++) {\n      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n      fa[i] = A0 + A1 * s;\n    }\n    fft(fa, sz >> 1);\n    vector< int64_t > ret(need);\n    for(int i = 0; i < need; i++) {\n      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n    }\n    return ret;\n  }\n};\n\ntemplate< typename T >\nstruct ArbitraryModConvolution {\n  using real = FastFourierTransform::real;\n  using C = FastFourierTransform::C;\n\n  ArbitraryModConvolution() = default;\n\n  vector< T > multiply(const vector< T > &a, const vector< T > &b, int need = -1) {\n    if(need == -1) need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while((1 << nbase) < need) nbase++;\n    FastFourierTransform::ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < (int)a.size(); i++) {\n      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);\n    }\n    fft(fa, sz);\n    vector< C > fb(sz);\n    if(a == b) {\n      fb = fa;\n    } else {\n      for(int i = 0; i < (int)b.size(); i++) {\n        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);\n      }\n      fft(fb, sz);\n    }\n    real ratio = 0.25 / sz;\n    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C a1 = (fa[i] + fa[j].conj());\n      C a2 = (fa[i] - fa[j].conj()) * r2;\n      C b1 = (fb[i] + fb[j].conj()) * r3;\n      C b2 = (fb[i] - fb[j].conj()) * r4;\n      if(i != j) {\n        C c1 = (fa[j] + fa[i].conj());\n        C c2 = (fa[j] - fa[i].conj()) * r2;\n        C d1 = (fb[j] + fb[i].conj()) * r3;\n        C d2 = (fb[j] - fb[i].conj()) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector< T > ret(need);\n    for(int i = 0; i < need; i++) {\n      int64_t aa = llround(fa[i].x);\n      int64_t bb = llround(fb[i].x);\n      int64_t cc = llround(fa[i].y);\n      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;\n      ret[i] = aa + (bb << 15) + (cc << 30);\n    }\n    return ret;\n  }\n};\n\ntemplate< int mod >\nstruct NumberTheoreticTransform {\n\n  int base, max_base, root;\n  vector< int > rev, rts;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while(tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while(n > 0) {\n      if(n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) {\n    return mod_pow(x, mod - 2);\n  }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long) mod;\n  }\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while(base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n\n  void ntt(vector< int > &a) {\n    const int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n\n  vector< int > multiply(vector< int > a, vector< int > b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for(int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n\n  vector<modint> multiply_for_fps(const vector<modint> &a,const vector<modint> &b){\n    vector<int> A(a.size()) , B(b.size());\n    for(int i = 0;i < (int)a.size(); i++) A[i] = a[i].x;\n    for(int i = 0;i < (int)b.size(); i++) B[i] = b[i].x;\n    auto C = multiply( A , B );\n    vector<modint> ret(C.size());\n    for(int i = 0; i < (int)C.size() ;i++) ret[i].x = C[i];\n    return ret;\n  }\n};\n\n\ntemplate< typename T >\nstruct FormalPowerSeries : vector< T > {\n  using vector< T >::vector;\n  using P = FormalPowerSeries;\n\n  using MULT = function< P(P, P) >;\n\n  static MULT &get_mult() {\n    static MULT mult = nullptr;\n    return mult;\n  }\n\n  static void set_fft(MULT f) {\n    get_mult() = f;\n  }\n\n  void shrink() {\n    while(this->size() && this->back() == T(0)) this->pop_back();\n  }\n\n  P operator+(const P &r) const { return P(*this) += r; }\n\n  P operator+(const T &v) const { return P(*this) += v; }\n\n  P operator-(const P &r) const { return P(*this) -= r; }\n\n  P operator-(const T &v) const { return P(*this) -= v; }\n\n  P operator*(const P &r) const { return P(*this) *= r; }\n\n  P operator*(const T &v) const { return P(*this) *= v; }\n\n  P operator/(const P &r) const { return P(*this) /= r; }\n\n  P operator%(const P &r) const { return P(*this) %= r; }\n\n  P &operator+=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] += r[i];\n    return *this;\n  }\n\n  P &operator+=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] += r;\n    return *this;\n  }\n\n  P &operator-=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] -= r[i];\n    shrink();\n    return *this;\n  }\n\n  P &operator-=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] -= r;\n    shrink();\n    return *this;\n  }\n\n  P &operator*=(const T &v) {\n    const int n = (int) this->size();\n    for(int k = 0; k < n; k++) (*this)[k] *= v;\n    return *this;\n  }\n\n  P &operator*=(const P &r) {\n    if(this->empty() || r.empty()) {\n      this->clear();\n      return *this;\n    }\n    assert(get_mult() != nullptr);\n    return *this = get_mult()(*this, r);\n  }\n\n  P &operator%=(const P &r) {\n    return *this -= *this / r * r;\n  }\n\n  P operator-() const {\n    P ret(this->size());\n    for(int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];\n    return ret;\n  }\n\n  P &operator/=(const P &r) {\n    if(this->size() < r.size()) {\n      this->clear();\n      return *this;\n    }\n    int n = this->size() - r.size() + 1;\n    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);\n  }\n\n  P pre(int sz) const {\n    return P(begin(*this), begin(*this) + min((int) this->size(), sz));\n  }\n\n  P operator>>(int sz) const {\n    if(this->size() <= sz) return {};\n    P ret(*this);\n    ret.erase(ret.begin(), ret.begin() + sz);\n    return ret;\n  }\n\n  P operator<<(int sz) const {\n    P ret(*this);\n    ret.insert(ret.begin(), sz, T(0));\n    return ret;\n  }\n\n  P rev(int deg = -1) const {\n    P ret(*this);\n    if(deg != -1) ret.resize(deg, T(0));\n    reverse(begin(ret), end(ret));\n    return ret;\n  }\n\n  P diff() const {\n    const int n = (int) this->size();\n    P ret(max(0, n - 1));\n    for(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);\n    return ret;\n  }\n\n  P integral() const {\n    const int n = (int) this->size();\n    P ret(n + 1);\n    ret[0] = T(0);\n    for(int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);\n    return ret;\n  }\n\n  // F(0) must not be 0\n  P inv(int deg = -1) const {\n    assert(((*this)[0]) != T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1) / (*this)[0]});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 1\n  P log(int deg = -1) const {\n    assert((*this)[0] == 1);\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();\n  }\n\n  P sqrt(int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n\n    if((*this)[0] == T(0)) {\n      for(int i = 1; i < n; i++) {\n        if((*this)[i] != T(0)) {\n          if(i & 1) return {};\n          if(deg - i / 2 <= 0) break;\n          auto ret = (*this >> i).sqrt(deg - i / 2) << (i / 2);\n          if(ret.size() < deg) ret.resize(deg, T(0));\n          return ret;\n        }\n      }\n      return P(deg, 0);\n    }\n\n    P ret({T(1)});\n    T inv2 = T(1) / T(2);\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 0\n  P exp(int deg = -1) const {\n    assert((*this)[0] == T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1)});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  P pow(int64_t k, int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    for(int i = 0; i < n; i++) {\n      if((*this)[i] != T(0)) {\n        T rev = T(1) / (*this)[i];\n        P C(*this * rev);\n        P D(n - i);\n        for(int j = i; j < n; j++) D[j - i] = C[j];\n        D = (D.log() * k).exp() * (*this)[i].pow(k);\n        P E(deg);\n        if(i * k > deg) return E;\n        auto S = i * k;\n        for(int j = 0; j + S < deg && j < D.size(); j++) E[j + S] = D[j];\n        return E;\n      }\n    }\n    return *this;\n  }\n\n  T eval(T x) const {\n    T r = 0, w = 1;\n    for(auto &v : *this) {\n      r += w * v;\n      w *= x;\n    }\n    return r;\n  }\n};\n\nusing FPS = FormalPowerSeries< modint >;\n\n// fにa * x^n + bを掛ける\nvoid mul_simple(FPS &f,modint a ,int n, modint b){\n  for(int i = (int)f.size() - 1 ; i >= 0 ; i--){\n    f[i] *= b;\n    if(i >= n) f[i] += f[i - n] * a; \n  }\n}\n\n// fからa * x^n + bを割る\nvoid div_simple(FPS &f,modint a,int n,modint b){\n  for(int i = 0 ; i < (int)f.size() ; i++){\n    f[i] /= b;\n    if(i + n < (int)f.size() ) f[n + i] -= f[i] * a; \n  }\n}\n\n// f / gをdeg(f)次まで求める\nFPS div_(FPS &f , FPS g){\n  int n = f.size();\n  return (f * g.inv(n)).pre(n);\n}\n\n\n// solve関数内で\n//\n// FPS::set_fft(mul);\n//\n// とすること。\n\n/**\nNumberTheoreticTransform<MOD> ntt;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret =ntt.multiply_for_fps(a , b);\n  return FPS::P(ret.begin(), ret.end());\n};\n/*///\nArbitraryModConvolution< modint > fft;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret = fft.multiply(a, b);\n  return FPS::P(ret.begin(), ret.end());\n};\n//*/\n\n// 下記のリンクを実装(kitamasa法のモンゴメリ乗算を使わない版)\n// http://q.c.titech.ac.jp/docs/progs/polynomial_division.html\n// k項間漸化式のa_Nを求める O(k log k log N)\n// N ... 求めたい項　(0-indexed)\n// Q ... 漸化式 (1 - \\sum_i c_i x^i)の形\n// a ... 初期解 (a_0 , a_1 , ... , a_k-1)\n// x^N を fでわった剰余を求め、aと内積を取る\nmodint kitamasa(ll N, FPS &Q, FPS &a){\n  int k = Q.size() - 1;\n  assert( (int)a.size() == k );\n  FPS P = a * Q; P.resize(k);\n  while(N){\n    auto Q2 = Q;\n    for(int i = 1; i < (int)Q2.size(); i += 2) Q2[i].x = MOD - Q2[i].x;\n    auto S = P * Q2;\n    auto T = Q * Q2;\n    if(N & 1){\n      for(int i = 1 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    else{\n      for(int i = 0 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    N >>= 1;\n  }\n  return P[0];\n}\n\nvoid solve(){\n  ini(N , M);\n  ins(S);\n  auto run = RunLengthEncoding(S);\n  if(run.size() == 1){\n    // DP\n    V<mint> dp(N),ep(N),fp(N),gp(N);\n    // [0]がR\n    // -> [1],[-1]はどちらでもよい\n    dp[0] = gp[0] = 1;\n    rep1(i , N - 1){\n      dp[i] = dp[i - 1] + ep[i - 1];\n      ep[i] = dp[i - 1];\n      fp[i] = fp[i - 1] + gp[i - 1];\n      gp[i] = fp[i - 1];\n    }\n    out(dp[N-1] + ep[N-1] + fp[N-1]);\n    return;\n  }\n  if(N % 2 == 1){\n    out(0);\n    return;\n  }\n\n  FPS::set_fft(mul);\n  // rの最小値\n  int r = N - 1 , b = N - 1;\n  // 偶数は無視していい\n  rep(i , sz(run)){\n    if(i==0)continue;\n    auto p = run[i];\n    if(p.first == 'R' && p.second % 2 == 1) amin(r , p.second);\n    if(p.first == 'B' && p.second % 2 == 1) amin(b , p.second);\n  }\n  // 初手の制約\n  amin( (run[0].first == 'R' ? r : b) , run[0].second + (run[0].second % 2 == 0) );\n  // 初手とは異なる方が1である必要あり\n  (run[0].first == 'R' ? b : r) = 1;\n  trc(r , b);\n\n  FPS f({1});\n  auto nyaan = [&](ll n,int flg = false) -> FPS{\n    FPS ret(n + 1);\n    for(int i = 1 ; i <= n ; i += 2) ret[i] = (flg ? i : 1);\n    return ret;\n  };\n  trc(f);\n  f *= nyaan(r);\n  f *= nyaan(b);\n  trc(f);\n  f = FPS({1}) - f;\n  if((int)f.size() <= N) f.resize(N + 2);\n  f = f.inv();\n  f *= nyaan(r,1) * nyaan(b) + nyaan(b,1) * nyaan(r); \n  trc(f);\n  out(f[N]);\n  \n  \n  /*\n  //trc(f);\n  // 倍数包除\n  for(int i = 2 ; i <= N ; i++){\n    // i番目は？\n    //引こう！\n    for(int j = 2 ; i * j <= N ; j++){\n      f[i * j] -= f[i];\n    }\n  }\n  trc(f);\n  */\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nint const N = 200000, md = 1e9 + 7;\nchar s[N + 1];\nint dp[N + 1], n, m;\n\ninline void ad(int &x, int y) { if ((x += y) >= md)x -= md; }\ninline void sb(int &x, int y) { if ((x -= y) <  0 )x += md; }\ninline void out(int an) { printf(\"%d\\n\", an); exit(0); }\n\nvoid sad(){\n\tdp[0] = 1;\n\tdp[1] = 1;\n\tf(i, 2, n + 1)ad(dp[i] = dp[i - 1], dp[i - 2]);\n\tint an = dp[n];\n\tad(an, dp[n - 2]);\n\tout(an);\n}\n\nint main(){\n\tscanf(\"%d%d%s\", &n, &m, s);\n\tint mx = md;\n\tbool im = false;\n\tf(i, 0, m){\n\t\tint j = i;\n\t\twhile (j + 1 < m && s[j + 1] == s[i])++j;\n\t\tif (i == 0 && j + 1 == m)sad();\n\t\tim = !im;\n\t\tif (im && j + 1 != m){\n\t\t\tint ln = j - i + 1;\n\t\t\tif (ln & 1)mx = min(mx, ln);\n\t\t\telse if (i == 0)mx = min(mx, ln | 1);\n\t\t}\n\t\ti = j;\n\t}\n\tif (n & 1)out(0);\n\tn >>= 1;\n\tmx = mx + 1 >> 1;\n\tint l = 1, s = 0;\n\tf(i, 1, n + 1){\n\t\tif (i - l > mx)sb(s, dp[l++]);\n\t\tdp[i] = s;\n\t\tif (i <= mx)ad(dp[i], i << 1);\n\t\tad(s, dp[i]);\n\t}\n\tout(dp[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=a*b%mod\n\nll n,m;\nstring s;\nint main(){\n    cin>>n>>m>>s;\n    if(s[0]=='R'){\n\tfor(int i=0;i<n;i++){\n\t    if(s[i]=='R')s[i]='B';\n\t    else s[i]='R';\n\t}\n    }\n    bool th=0;\n    ll cnt=0,mi=1e17;\n    bool fi=1; ll lead;\n    for(int i=0;i<n;i++){\n\tif(s[i]=='R'){\n\t    if(fi)lead=cnt; fi=0;\n\t    th=1;\n\t    if(cnt%2==1)chmin(mi,cnt);\n\t    cnt=0;\n\t}\n\telse cnt++;\n    }\n    if(th==0){\n\tll f[200010];\n\tf[0]=f[1]=1;\n\tfor(int i=2;i<n;i++){\n\t    f[i]=f[i-1]+f[i-2];\n\t}\n\tll ans=(f[n-2]*2+f[n-1])%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n    }\n    if(n%2==1){\n\tcout<<0<<endl;\n\treturn 0;\n    }\n    if(lead%2==0)lead++;\n    chmin(mi,lead);\n    mi=(mi+1)/2;\n    chmin(mi,n/2);\n    ll f[200010],rui[200010];\n    f[0]=rui[0]=0;\n    for(ll i=1;i<=mi;i++){\n\tf[i]=i;\n\trui[i]=(rui[i-1]+i)%mod;\n    }\n    for(int i=1;i<n/2;i++){\n\tmad(f[i],rui[i-1]);\n\tif(i-mi-1>=0)mad(f[i],-rui[i-mi-1]);\n\trui[i]=(rui[i-1]+f[i])%mod;\n    }\n    ll ans=0;\n    for(int i=1;i<=mi;i++)mad(ans,f[n/2-i]);\n    //cout<<mi<<endl;\n    //for(int i=0;i<n/2;i++)cout<<i<<\":\"<<f[i]<<endl;\n    ans=ans*2%mod;\n    if(ans<0)ans+=mod;\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nint gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);}\n\n#define ll long long\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=2e5+500;\nconst ll mod=1e9+7;\nconst ll inf=1e9+9;\n\nll dp[maxn];\nll par[maxn];\nvoid update(ll a){\n\tif(a<2)par[a]=dp[a];\n\tpar[a]=(par[a-2]+dp[a])%mod;\t\n}\nll find_sum(ll l,ll r){\n\tif(!(l<=r))return 0;\n\tl=max(l,0LL);\n\tif(l%2!=r%2){\n\t\treturn find_sum(l+1,r);\n\t}\n\tif(l<2)return par[r];\n\treturn (par[r]-par[l-2]+mod)%mod;\n}\n\n\nll find_ans(ll n,ll s){\n\tif(s%2==0)s--;\n\tmemset(dp,0,sizeof dp);\n\tmemset(par,0,sizeof par);\n\n\tdp[0]=1;\n\tdp[1]=0;\n\tupdate(1);\n\tupdate(0);\n\tfor(ll i=2;i<=n;i++){\n\t\tdp[i]=find_sum(i-s-1,i-2);\n\t\tupdate(i);\n\t}\n\tll ans=0;\n\tfor(ll i=2;i<=n && i-1<=s;i++){\n\t\tll lp=0;\n\t\tif((i-1)%2==0)lp=1;\n\t\tll rp=s-i+1;\n\t\t\n\t\tll lw=n-i-rp;\n\t\tll rw=n-i-lp;\n\n\t\tans+=find_sum(lw,rw);\n\t}\n\tans+=dp[n];\n\treturn ans%mod;\n}\nstring ok(string s,ll m){\n\tif(s[0]=='B'){\n\t\tfor(ll i=0;i<m;i++){\n\t\t\tif(s[i]=='B'){\n\t\t\t\ts[i]='R';\n\t\t\t}else{\n\t\t\t\ts[i]='B';\n\t\t\t}\n\t\t}\n\t}\n\treturn s;\n}\nint main(){\n\tll n,m;\n\tstring s;\n\tcin>>n>>m>>s;\n\ts=ok(s,m);\n\tvector<ll> vec;\n\tll res=0;\n\tfor(ll i=0;i<m;i++){\n\t\tif(s[i]=='R'){\n\t\t\tres++;\n\t\t}\n\t\tif(res!=0 && (i==m-1 || s[i]=='B')){\n\t\t\tvec.pb(res);\n\t\t\tres=0;\n\t\t}\n\t}\n\tll si=inf;\n\tif(vec[0]==m){\n\t\tdp[2]=1;\n\t\tdp[1]=1;\n\t\tfor(ll i=3;i<=n;i++){\n\t\t\tdp[i]=(dp[i-2]+dp[i-1])%mod;\n\t\t}\n\t\tll ans=1;\n\t\tfor(ll i=2;i<=n;i++){\n\t\t\tans+=dp[n-i+1];\n\t\t}\n\t\tans+=dp[n-1];\n\t\tcout<<ans%mod;\n\t\treturn 0;\n\t}\n\tfor(auto v:vec){\n\t\tif(v%2==1)si=min(si,v);\n\t}\n\tsi=min(si,vec[0]+1);\n\tcout<<find_ans(n,si)<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define set0(x) memset(x,0,sizeof(x))\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> void read(T &x){\n\tx = 0;char ch = getchar();int f = 1;\n\twhile(!isdigit(ch)){if(ch == '-')f*=-1;ch=getchar();}\n\twhile(isdigit(ch)){x = x*10+ch-48;ch=getchar();}x*=f;\n}\nint mod = 1000000007;\ninline int mul(int x,int y){return 1ll*x*y%mod;}\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint sub(int x,int y){return x-y<0?x-y+mod:x-y;}\nint sq(int x){return 1ll*x*x%mod;}\nint pow(int a,int b){return b == 0 ? 1 : ( b&1 ? mul(a,sq(pow(a,b/2))) : sq(pow(a,b/2)));}\nconst int N = 200020;\nint n,m,dp[N] = {0},sudp[N] = {0};\nchar ch[N];\nint ans = 0;\nint main() {\n\tread(n);read(m);\n\tscanf(\"%s\",ch);\n\tint ftt = 0,clen = 0;\n\tfor(int i=1;i<m;i++){\n\t\tif(ch[i]!=ch[0]){\n\t\t\tftt = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(ftt){\n\t\tclen = (ftt%2)?(ftt):(ftt+1);\n\t\tint la = ftt;\n\t\t//cout<<clen<<endl;\n\t\tfor(int i=ftt+1;i<=n;i++){\n\t\t\tif(ch[i]==ch[0] && ch[i+1]!=ch[0]){\n\t\t\t\t//cout<<\"OC \"<<i<<' '<<la<<endl;\n\t\t\t\tif((i-la)%2) clen = min(clen,i-la);\n\t\t\t}\n\t\t\tif(ch[i]!=ch[0])la = i;\n\t\t}\n\t}else{\n\t\tans = 1;\n\t\tclen = n;\n\t}\n\t\n\tint clim = (clen+1)/2;\n\t//cout<<ftt<<' '<<clen<<' '<<clim<<endl;\n\tdp[0] = sudp[0] = 1;\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = sudp[i-1];\n\t\tif(i-clim-1>=0)dp[i] = sub(dp[i],sudp[i-clim-1]);\n\t\tsudp[i] = add(sudp[i-1],dp[i]);\n\t\t//cout<<i<<' '<<dp[i]<<endl;\n\t}\n\tif(ans!=0 || n%2 == 0){\n\t\tfor(int i=1;i<=min(clen+1,n);i++){\n\t\t\tint cl = (n-clen-1)/2,cr = (n-i)/2;\n\t\t\tif(i == 1 && i*cr+2 == n)cr-=1;\n\t\t\t//cout<<i<<' '<<i+cl*2<<' '<<i+cr*2<<' '<<sub(sudp[cr],sudp[cl-1])<<endl;\n\t\t\tans = add(ans,sudp[cr]);\n\t\t\tif(cl) ans = sub(ans,sudp[cl-1]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#define N 201000\ntypedef long long ll;\ntemplate <typename T> inline void read(T &x) {\n\tx = 0; char c = getchar(); bool flag = false;\n\twhile (!isdigit(c)) { if (c == '-')\tflag = true; c = getchar(); }\n\twhile (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }\n\tif (flag)\tx = -x;\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nconst int inf = 987654321;\ninline void MIN(int &a, int b) {\n\tif (b < a)\ta = b;\n}\nint n, m;\nchar s[N];\nnamespace jzp1 {\n\tll jie[N], jieni[N];\n\tinline ll get_c(int n, int m) {\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\tif (n < 0 || m < 0 || n - m < 0)\treturn 0;\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\treturn jie[n] * jieni[m] % P * jieni[n - m] % P;\n\t}\n\tinline ll quickpow(ll x, int k) {\n\t\tll res = 1;\n\t\twhile (k) {\n\t\t\tif (k & 1)\tres = res * x % P;\n\t\t\tx = x * x % P;\n\t\t\tk >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline void sol() {\n//\t\twhile(1);\n\t\tif (n == 1) { puts(\"1\"); return ; }\n\t\tjie[0] = jieni[0] = 1;\n\t\tint up = n + 1;\n\t\tfor (int i = 1; i <= up; ++i)\tjie[i] = jie[i - 1] * i % P;\n\t\tjieni[up] = quickpow(jie[up], P - 2);\n\t\tfor (int i = up - 1; i; --i)\tjieni[i] = jieni[i + 1] * (i + 1) % P;\n\t\tll res = 0;\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tres = (res + get_c(n - i + 1, i) - get_c(n - i - 1, i - 2)) % P;\n//\t\t\tprintf(\"res = %lld\\n\", res);\n\t\t}\n\t\tprintf(\"%lld\\n\", (res % P + P) % P);\n\t}\n}\nll f[N];\nll sum[N];\nint main() {\n\tread(n), read(m);\n\tscanf(\"%s\", s + 1);\n\tbool flag = false;\n\tfor (int i = 1; i <= m; ++i)\tif (s[i] != s[1]) { flag = true; break; }\n\tif (!flag) { jzp1::sol(); return 0; }\n\tif (n & 1) { puts(\"0\"); return 0; }\n\tint lst = 1, mn = inf;\n\tfor (int i = 2; i <= m + 1; ++i) {\n\t\tif (s[i] != s[1]) {\n\t\t\tif (lst & 1)\tMIN(mn, lst);\n\t\t\tlst = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == s[i - 1])\t++lst;\n\t\telse {\n\t\t\tif (lst & 1) MIN(mn, lst);\n\t\t\tlst = 1;\n\t\t}\n\t}\n\tif (mn == inf) {\n//\t\twhile (1);\n\t\tint memo = 1;\n\t\tfor (int i = 1; s[i] == s[1]; ++i) memo = i;\n\t\tmn = memo + 1;\n\t}\n\tn >>= 1;\n\tint k = (mn + 1) >> 1;\n\tMIN(k, n);\n\tf[0] = 1; sum[0] = 1;\n//\tprintf(\"n = %d, k = %d\\n\", n, k);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (i <= k)\tf[i] = sum[i - 1];\n\t\telse f[i] = (sum[i - 1] - sum[i - k - 1]) % P;\n\t\tsum[i] = (sum[i - 1] + f[i]) % P;\n\t}\n\tll ans = 0, mx = k;\n\tconst int mod = 1e9 + 7;\n\t\tfor(int i = 0 ; i <= n ; ++i)\n\t\tif(n - i <= mx) (ans += (ll)f[i] * (n - i) % mod * 2 % mod) %= mod;\n//\tll ans = 0;\n//\tfor (int i = 1; i <= k; ++i) {\n//\t\tans = (ans + f[n - i] * i) % P;\n//\t}\n//\tans = (ans << 1) % P;\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n\n/*\n3 3\nBBB\n//4\n\n1 1\nB\n//1\n\n12 10\nRRRRBRRRRB\n//78\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define pii pair<int, int>\n#define p3i pair<pii, int>\n#define pll pair<ll, ll>\n#define p3l pair<pll, ll>\n#define vi vector<int>\n#define vpii vector<pii>\n#define vp3i vector<p3i>\n#define vpll vector<pll>\n#define vp3l vector<p3l>\n#define lseg L, (L+R)/2, N*2+1\n#define rseg (L+R)/2+1, R, N*2+2\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define MN 1000000007\n#define fox(k, x) for (int k=0; k<x; ++k)\n#define fox1(k, x) for (int k=1; k<=x; ++k)\n#define foxr(k, x) for (int k=x-1; k>=0; --k)\n#define fox1r(k, x) for (int k=x; k>0; --k)\n#define ms multiset\n#define flood(x) memset(x, 0x3f3f3f3f, sizeof x)\n#define drain(x) memset(x, 0, sizeof x)\n#define rng() ((rand() << 14)+rand())\n#define scan(X) do{while((X=getchar())<'0'); for(X-='0'; '0'<=(_=getchar()); X=(X<<3)+(X<<1)+_-'0');}while(0)\nchar _;\n#define pi 3.14159265358979323846\n\nint n, m, dp[200005], psa[200005];\nint sum, ans=0;\nstring s;\nint get(int N, int L){\n  int hi = N;\n  int lo = hi - L - 1;\n  //cout << N << ' ' << L << ' ' <<lo << ' ' << hi << endl;\n  int res = psa[hi];\n  if (lo >= 0) res -= psa[lo];\n  return res;\n}\nint32_t main(){\n  cin >> n >> m >> s;\n  int pref = 0, lim, c = 0;\n  fox(l, m){\n    if (s[l] != s[0]) break;\n    pref++;\n  }\n  if (pref % 2 == 1)\n    lim = pref;\n  else\n    lim = pref + 1;\n  if (pref == m){\n    dp[0] = 1;\n    dp[1] = 1;\n    for(int l = 2; l <= n; ++l){\n      dp[l] = (dp[l-1]+dp[l-2])%MN;\n    }\n    cout << dp[n-2] + dp[n];\n    return 0;\n  }\n  if (n%2 == 1){\n    if (pref != m){\n      printf(\"0\\n\");\n      return 0;\n    }\n  }\n  fox(l, m){\n    if (s[l]!=s[0]){\n      if (c%2 == 1){\n        lim = min(lim, c);\n      }\n      c=0;\n    } else {\n      c++;\n    }\n  }\n  if (c%2 == 1){\n    lim = min(lim, c);\n  }\n  n/=2;\n  lim /= 2;\n  dp[0]= 1;\n  int p=0;\n  sum = 1;\n  psa[0] = 1;\n  fox1(l, n){\n    while(l-p-1 > lim){\n      sum = (sum - dp[p]) % MN;\n      ++p;\n    }\n    dp[l] = sum;\n    psa[l] = (psa[l-1] + dp[l]) % MN;\n    sum = (sum + dp[l]) % MN;\n    //cout << dp[l] << ' ';\n  }\n  fox(l, lim+1){\n    //starting component\n    ans = (ans + get(n-1-l, lim-l));\n  }\n  cout << ans*2;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___CLASS_MODINT\n#define ___CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::uint64_t n_) : n(n_ % mod) {};\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tstd::uint32_t get() const { return n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint binpow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tmodint inv() { return (*this).binpow(mod - 2); }\n};\n\n#endif // ___CLASS_MODINT\n\n#include <string>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nusing modulo = modint<1000000007>;\nconst int inf = 1012345678;\nint solve(int N, int M, string S) {\n\tif (S[0] == 'B') {\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (S[i] == 'B') S[i] = 'R';\n\t\t\telse S[i] = 'B';\n\t\t}\n\t}\n\tint pre = 0, mn = inf; bool bluemove = true;\n\tfor (int i = 1; i < M; ++i) {\n\t\tif (S[i - 1] != S[i]) {\n\t\t\tif (S[i - 1] == 'R' && (pre == 0 || (i - pre) % 2 == 1)) {\n\t\t\t\tmn = min(mn, i - pre + 1);\n\t\t\t}\n\t\t\tif (S[i - 1] == 'B' && (i - pre) % 2 == 1) {\n\t\t\t\tbluemove = false;\n\t\t\t}\n\t\t\tpre = i;\n\t\t}\n\t}\n\tif (mn == inf) {\n\t\tvector<modulo> fib(N + 3);\n\t\tfib[1] = 1;\n\t\tfor (int i = 2; i <= N + 2; ++i) {\n\t\t\tfib[i] = fib[i - 1] + fib[i - 2];\n\t\t}\n\t\tmodulo ans = fib[N + 2] - fib[N - 2];\n\t\treturn ans.get();\n\t}\n\telse if (bluemove) {\n\t\tvector<modulo> dp1(N + 1), dp2(N + 1);\n\t\tdp2[0] = 1;\n\t\tint lim = (mn + 1) / 2 * 2;\n\t\tmodulo oddsum = 0, evensum = 0;\n\t\tfor (int i = 1; i <= N; ++i) {\n\t\t\tif (i - lim - 1 >= 0) {\n\t\t\t\tif (i % 2 == 1) evensum -= dp1[i - lim - 1];\n\t\t\t\telse oddsum -= dp1[i - lim - 1];\n\t\t\t}\n\t\t\tdp1[i] = dp2[i - 1] + dp1[i - 1];\n\t\t\tdp2[i] = (i % 2 == 1 ? evensum : oddsum);\n\t\t\tif (i % 2 == 1) oddsum += dp1[i];\n\t\t\telse evensum += dp1[i];\n\t\t}\n\t\tmodulo ans = dp1[N];\n\t\tfor (int i = 1; i <= mn && i <= N; i += 2) {\n\t\t\tans += dp1[N - i] * (i + 1);\n\t\t}\n\t\treturn ans.get();\n\t}\n\telse {\n\t\tvector<modulo> dp(N + 1);\n\t\tdp[1] = 1;\n\t\tint lim = (mn + 1) / 2 * 2;\n\t\tmodulo sum = 1;\n\t\tfor (int i = 3; i <= N; i += 2) {\n\t\t\tif (i - lim - 2 >= 0) sum -= dp[i - lim - 2];\n\t\t\tdp[i] = sum;\n\t\t\tsum += dp[i];\n\t\t}\n\t\tmodulo ans = 0;\n\t\tfor (int i = 1; i <= mn && i <= N; i += 2) {\n\t\t\tans += dp[N - i] * (i + 1);\n\t\t}\n\t\treturn ans.get();\n\t}\n\treturn -1;\n}\nint main() {\n\tint N, M; string S;\n\tcin >> N >> M >> S;\n\tcout << solve(N, M, S) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\nunsigned int mod_pow(unsigned int a, unsigned int n, unsigned int _mod){\n    unsigned int ret = 1;\n\twhile(n){\n\t\tif(n & 1) ret = (unsigned long long)ret * a % _mod;\n\t\ta = (unsigned long long)a * a % _mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\ntemplate<unsigned int _mod>\nclass NTT {\npublic:\n\tunsigned int get_mod() const { return _mod; }\n\tvoid _ntt(vector<int>& a, int sign){\n\t\tconst unsigned int n = (int)a.size();\n\t\tconst unsigned int g = 3;\n\t\tunsigned int h = mod_pow(g, (_mod - 1) / n, _mod);\n\t\tif(sign == -1) h = mod_pow(h, _mod-2, _mod);\n        unsigned int s, x, m, j, k;\n        unsigned int i = 0;\n\t\tfor(j = 1; j < n - 1; ++j){\n\t\t\tfor(k = n >> 1; k > (i ^= k); k >>= 1);\n\t\t\tif (j < i) swap(a[i], a[j]);\n\t\t}\n\t\tfor(m = 1; m < n; m *= 2){\n\t\t\tconst unsigned int m2 = 2 * m;\n\t\t\tconst unsigned int base = mod_pow(h, n / m2, _mod);\n\t\t\tunsigned int w = 1;\n\t\t\tfor(x = 0; x < m; x++){\n\t\t\t\tfor(s = x; s < n; s += m2){\n\t\t\t\t\tunsigned int u = a[s];\n\t\t\t\t\tunsigned int d = (unsigned long long)a[s + m] * w % _mod;\n\t\t\t\t\ta[s] = (u + d) % _mod;\n\t\t\t\t\ta[s + m] = (u + _mod - d) % _mod;\n\t\t\t\t}\n\t\t\t\tw = (unsigned long long)w * base % _mod;\n\t\t\t}\n\t\t}\n\t}\n\tvoid ntt(vector<int>& input){\n\t\t_ntt(input, 1);\n\t}\n\tvoid intt(vector<int>& input){\n\t\t_ntt(input, -1);\n\t\tconst unsigned int n_inv = mod_pow(input.size(), _mod-2, _mod);\n\t\tfor(auto& x : input) x = (unsigned long long)x * n_inv % _mod;\n\t}\n\tvoid convolution(const vector<int>& a, const vector<int>& b, vector<int>& _a, vector<int>& _b,\n        unsigned int asize, unsigned int bsize, unsigned int _size){\n\t\tunsigned int ntt_size = 1;\n\t\twhile(ntt_size < asize + bsize) ntt_size *= 2;\n        _a.assign(ntt_size, 0), _b.assign(ntt_size, 0);\n        for(unsigned int i = 0; i < asize; ++i){ _a[i] = a[i]; }\n        for(unsigned int i = 0; i < bsize; ++i){ _b[i] = b[i]; }\n\t\tntt(_a), ntt(_b);\n\t\tfor(unsigned int i = 0; i < ntt_size; ++i){\n\t\t\t_a[i] = (unsigned long long)_a[i] * _b[i] % _mod;\n\t\t}\n\t\tintt(_a);\n        _a.resize(_size);\n\t}\n};\n\ntypedef NTT<167772161> NTT_1;\ntypedef NTT<469762049> NTT_2;\ntypedef NTT<1224736769> NTT_3;\n\nvector<int> convolute(const vector<int>& a, const vector<int>& b, int asize, int bsize, int _size){\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n    vector<int> x, _x, y, _y, z, _z;\n\tntt1.convolution(a, b, x, _x, asize, bsize, _size);\n    ntt2.convolution(a, b, y, _y, asize, bsize, _size);\n    ntt3.convolution(a, b, z, _z, asize, bsize, _size);\n\tconst unsigned int m1 = ntt1.get_mod(), m2 = ntt2.get_mod(), m3 = ntt3.get_mod();\n\tconst unsigned int m1_inv_m2 = mod_pow(m1, m2-2, m2);\n\tconst unsigned int m12_inv_m3 = mod_pow((unsigned long long)m1 * m2 % m3, m3-2, m3);\n\tconst unsigned int m12_mod = (unsigned long long)m1 * m2 % MOD;\n\tvector<int> res(_size);\n\tfor(unsigned int i = 0; i < x.size(); ++i){\n\t    unsigned int v1 = ((unsigned long long )y[i] + m2 - x[i]) *  m1_inv_m2 % m2;\n\t    unsigned int v2 = ((unsigned long long)z[i] + m3 - (x[i] + (unsigned long long)m1 * v1) % m3) * m12_inv_m3 % m3;\n\t    res[i] = (x[i] + (unsigned long long)m1 * v1 + (unsigned long long)m12_mod * v2) % MOD;\n\t}\n    return res;\n}\n\nunsigned int add(const unsigned int x, const unsigned int y)\n{\n    return (x + y < MOD) ? x + y : x + y - MOD;\n}\n \nunsigned int sub(const unsigned int x, const unsigned int y)\n{\n    return (x >= y) ? (x - y) : (MOD - y + x);\n}\n \nunsigned int mul(const unsigned int x, const unsigned int y)\n{\n    return (unsigned long long)x * y % MOD;\n}\n \nunsigned int mod_pow(unsigned int x, unsigned int n)\n{\n    unsigned int res = 1;\n    while(n > 0){\n        if(n & 1){ res = mul(res, x); }\n        x = mul(x, x);\n        n >>= 1;\n    }\n    return res;\n}\n \nunsigned int inverse(const unsigned int x)\n{\n    return mod_pow(x, MOD - 2);\n}\n \nvector<int> polynomial_inverse(const vector<int>& a, int r)\n{\n    assert(a[0] != 0);\n    vector<int> h = {(int)inverse(a[0])};\n    int t = 1;\n    for(int i = 0; t < r; ++i){\n        t <<= 1;\n        vector<int> res = convolute(a, convolute(h, h, t / 2, t / 2, t), min((int)a.size(), t), t, t);\n        for(int j = 0; j < t; ++j){\n            res[j] = sub(0, res[j]);\n            if(j < t / 2) res[j] = add(res[j], mul(2, h[j]));\n        }\n        swap(h, res);\n    }\n    h.resize(r);\n    return h;\n}\n\nmod dp[200010][2][2];\nint main(){\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if(s[0]=='R'){\n        rep(i,m){\n            if(s[i]=='R'){\n                s[i] ='B';\n            }else{\n                s[i] ='R'; \n            }\n        }\n    }\n    int a = inf;\n    int c = 0;\n    bool flag = 1;\n    rep(i,m){\n        if(s[i]=='B'){\n            c++;\n        }else{\n            if(flag){\n                flag = 0;\n                chmin(a,c);\n            }else if(c%2==1){\n                chmin(a,c); \n            }\n            c = 0;   \n        }\n    }\n    if(a==inf){\n        dp[0][0][0] = 1;\n        dp[0][1][1] = 1;\n        for(int i=1;i<n;i++){\n            for(int j=0;j<2;j++){\n                if(j==0){\n                    dp[i][j][0] += dp[i-1][1][0];\n                    dp[i][j][1] += dp[i-1][1][1];\n                }else{\n                    dp[i][j][0] += dp[i-1][1][0] + dp[i-1][0][0];\n                    dp[i][j][1] += dp[i-1][1][1] + dp[i-1][0][1];    \n                }\n            }\n        }\n        cout << dp[n-1][1][0] + dp[n-1][1][1] + dp[n-1][0][1] << endl;\n    }else{\n        int len = (a/2)*2+1;\n        //cerr << len << endl;\n        vector<int> X(n+1),Y(n+1);\n        len++;\n        len = min(n,len);\n        for(int i=2;i<=len;i+=2){\n            X[i] = i;\n        }\n        Y[0] = 1;\n        for(int i=2;i<=len;i+=2){\n            Y[i] = MOD-1;\n        }\n        rep(i,n+1){\n            cerr << X[i] << \" \";\n        }\n        cerr << endl;\n        \n        rep(i,n+1){\n            cerr << Y[i] << \" \";\n        }\n        cerr << endl;\n        Y =polynomial_inverse(Y,n+1);\n        \n        rep(i,n+1){\n            cerr << Y[i] << \" \";\n        }\n        cerr << endl;\n        X = convolute(X,Y,(int)X.size(),(int)Y.size(),n+1);\n        \n        rep(i,n+1){\n            cerr << X[i] << \" \";\n        }\n        cerr << endl;\n        cout << X[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define set0(x) memset(x,0,sizeof(x))\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> void read(T &x){\n\tx = 0;char ch = getchar();int f = 1;\n\twhile(!isdigit(ch)){if(ch == '-')f*=-1;ch=getchar();}\n\twhile(isdigit(ch)){x = x*10+ch-48;ch=getchar();}x*=f;\n}\nint mod = 1000000007;\ninline int mul(int x,int y){return 1ll*x*y%mod;}\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint sub(int x,int y){return x-y<0?x-y+mod:x-y;}\nint sq(int x){return 1ll*x*x%mod;}\nint pow(int a,int b){return b == 0 ? 1 : ( b&1 ? mul(a,sq(pow(a,b/2))) : sq(pow(a,b/2)));}\nconst int N = 200020;\nint n,m,dp[N] = {0},sudp[N] = {0};\nchar ch[N];\nint ans = 0;\nint main() {\n\tread(n);read(m);\n\tscanf(\"%s\",ch);\n\tint ftt = 0,clen = 0;\n\tfor(int i=1;i<m;i++){\n\t\tif(ch[i]!=ch[0]){\n\t\t\tftt = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(ftt){\n\t\tclen = (ftt%2)?(ftt):(ftt+1);\n\t\tint la = ftt;\n\t\t//cout<<clen<<endl;\n\t\tfor(int i=ftt+1;i<=n;i++){\n\t\t\tif(ch[i]==ch[0] && ch[i+1]!=ch[0]){\n\t\t\t\t//cout<<\"OC \"<<i<<' '<<la<<endl;\n\t\t\t\tif((i-la)%2) clen = min(clen,i-la);\n\t\t\t}\n\t\t\tif(ch[i]!=ch[0])la = i;\n\t\t}\n\t}else{\n\t\tans = 1;\n\t\tclen = n;\n\t}\n\t\n\tint clim = (clen+1)/2;\n\t//cout<<ftt<<' '<<clen<<' '<<clim<<endl;\n\tdp[0] = sudp[0] = 1;\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = sudp[i-1];\n\t\tif(i-clim-1>=0)dp[i] = sub(dp[i],sudp[i-clim-1]);\n\t\tsudp[i] = add(sudp[i-1],dp[i]);\n\t\t//cout<<i<<' '<<dp[i]<<endl;\n\t}\n\tif(ans!=0 || n%2 == 0){\n\t\tfor(int i=1;i<=min(clen+1,n);i++){\n\t\t\tint cl = (n-clen-1)/2,cr = (n-i)/2;\n\t\t\tif(n-2*cl-1>clen)cl+=1;\n\t\t\tif(i == 1 && i*cr+2 == n)cr-=1;\n\t\t\tif(cr<cl)continue;\n\t\t\tans = add(ans,sudp[cr]);\n\t\t\tif(cl) ans = sub(ans,sudp[cl-1]);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//I forgot you...\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = (int)1e9 + 7;\nconst int MAXN = (int)2e5 + 3;\nconst int infint = (int)1e9 + 3;\nconst ll inf = (ll)1e18;\nint n, m, ans, mika = infint, dp[MAXN], part[MAXN];\nstring s;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif(c >= MOD)\n\t\tc -= MOD;\n\tif(c < 0)\n\t\tc += MOD;\n\treturn c;\n}\nint mul(int a, int b)\n{\n\tint c = 1LL * a * b % MOD;\n\treturn c;\n}\nvoid find_mika()\n{\n\tif(s[0] == 'R')\n\t{\n\t\tint ted = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif(s[i] == 'R')\n\t\t\t\tted++;\n\t\t\telse\n\t\t\tif(s[i] == 'B' && ted > 0)\n\t\t\t{\n\t\t\t\tif(ted % 2)\t\n\t\t\t\t\tmika = min(mika, ted);\n\t\t\t\telse\n\t\t\t\t\tmika = min(mika, ted + 1);\n\t\t\t\tted = 0;\n\t\t\t}\n\t\tif(ted > 0)\n\t\t{\n\t\t\tif(ted % 2)\n\t\t\t\tmika = min(mika, ted);\n\t\t\telse\n\t\t\t\tmika = min(mika, ted + 1);\n\t\t}\n\t}\n\telse\n\t{\n\t\tint ted = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tif(s[i] == 'B')\n\t\t\t\tted++;\n\t\t\telse\n\t\t\tif(s[i] == 'R' && ted > 0)\n\t\t\t{\n\t\t\t\tif(ted % 2)\n\t\t\t\t\tmika = min(mika, ted);\n\t\t\t\telse\n\t\t\t\t\tmika = min(mika, ted + 1);\n\t\t\t\tted = 0;\n\t\t\t}\n\t\tif(ted > 0)\n\t\t{\n\t\t\tif(ted % 2)\n\t\t\t\tmika = min(mika, ted);\n\t\t\telse\n\t\t\t\tmika = min(mika, ted + 1);\n\t\t}\n\t}\n}\nint getzarib(int kaman)\n{\n\tint emp = n - kaman;\n\tif(emp == 0)\n\t\treturn 1;\n\telse\n\t\treturn n - emp;\n}\nint main()\n{\n\tios::sync_with_stdio(false); \n\tcin.tie(0); cout.tie(0);\n\tcin >> n >> m >> s;\n\tfind_mika();\n\tbool flg = 1;\n\tfor (int i = 1; i < s.size(); i++)\n\t\tif(s[i] != s[0])\t\n\t\t\tflg = 0;\n\tif(flg)\n\t{\n\t\tdp[1] = 1, dp[2] = 2;\n\t\tfor (int i = 3; i <= n; i++)\n\t\t\tdp[i] = add(dp[i - 1], dp[i - 2]);\n\t\t\n\t\tans = dp[n];\n\t\tif(n >= 3)\n\t\t\tans = add(ans, dp[n - 2]);\n\t\tcout << ans;\n\t\treturn 0;\n\t}\n\treturn 0;\n\tdp[0] = 1;\n\tpart[0] = 1;\n\tfor (int i = 2; i <= n; i += 2)\n\t{\n\t\tdp[i] = part[i - 2];\n\t\tif(i - mika - 3 >= 0)\n\t\t\tdp[i] = add(dp[i], -part[i - mika - 3]);\n\t\tpart[i] = add(part[i - 2], dp[i]);\n\t}\n\tans = add(ans, dp[n]);\n\tfor (int i = 1; i <= mika; i += 2)\n\t\tif(i != n - 2 && i != n)\n\t\t\tans = add(ans, mul(getzarib(i), dp[n - i - 1]));\n\t\telse\n\t\tif(i == n)\n\t\t\tans = add(ans, 1);\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long word;\ntypedef pair<int, int> pi;\nconst int MAXN = 200005;\nconst int mod = 1e9 + 7;\n\nint n, m;\nint f[MAXN];\nchar s[MAXN];\nint sum[MAXN];\n\nint main(){\n\tscanf(\"%d %d %s\",&n,&m,s);\n\tfor(int i=0; i<m; i++) if(s[i] == 'R') s[i] = 'A';\n\tif(s[0] == 'B'){\n\t\tfor(int i=0; i<m; i++) s[i] = 'A' + 'B' - s[i];\n\t}\n\tif(count(s, s + m, 'B') == 0){\n\t\tf[0] = 1; f[1] = 2;\n\t\tfor(int i=2; i<=n; i++){\n\t\t\tf[i] = f[i-1] + f[i-2];\n\t\t\tf[i] %= mod;\n\t\t}\n\t\tlint ret = f[n];\n\t\tif(n == 3) ret += mod - 1;\n\t\telse if(n >= 4) ret += mod - f[n - 4];\n\t\tret %= mod;\n\t\tcout << ret << endl;\n\t\treturn 0;\n\t}\n\tint alt = 1e9;\n\tint pref = 0;\n\twhile(s[pref] == 'A') pref++;\n\tfor(int i=0; i<m; i++){\n\t\tif(s[i] == 'B'){\n\t\t\tint e = i + 1;\n\t\t\twhile(s[e] == 'A') e++;\n\t\t\tif(e > i + 1 && e % 2 == i % 2){\n\t\t\t\talt = min(alt, e - i - 1);\n\t\t\t}\n\t\t\ti = e - 1;\n\t\t}\n\t}\n\tif(n % 2 == 1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint x = min(alt, pref + 1);\n\tf[0] = 1;\n\tsum[0] = 1;\n\tfor(int i=1; i<=n/2; i++){\n\t\tf[i] = sum[i - 1];\n\t\tif(i >= (x + 3) / 2) f[i] += mod - sum[i - (x + 3) / 2];\n\t\tf[i] %= mod;\n\t\tsum[i] = (sum[i-1] + f[i]) % mod;\n\t}\n\tlint ret = 0;\n\tfor(int i=0; i<n;i++){\n\t\tint len = n - 1 - x;\n\t\tif(n - 1 - x > n - 1 - i) continue;\n\t\tret += sum[(n - 1 - i) / 2];\n\t\tif(len >= 1){\n\t\t\tret += mod - sum[(len - 1) / 2];\n\t\t}\n\t}\n\n\tcout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define Md 1000000007\n#define MN 200005\nint n,m;\nchar c[MN];\nlg Pow(lg x,lg y){\n\tlg res=1;for(;y;y>>=1,x=x*x%Md)if(y&1)res=res*x%Md;return res;\n}\nint Fix(int x){\n\tif(x<0)return x+Md;\n\tif(x>=Md)return x-Md;\n\treturn x;\n}\nint dp[MN],tmp[MN];\nint miu[MN];\nint main(){\n\tread(n);read(m);\n\tscanf(\"%s\",c+1);\n\tmiu[1]=1;\n\tfor(int i=1;i<MN;++i){\n\t\tfor(int j=i+i;j<MN;j+=i){\n\t\t\tmiu[j]-=miu[i];\n\t\t}\n\t}\n\tchar Hd=c[1];\n\tint cnt=0,mx;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse break;\n\t}\n\tif(cnt&1)mx=cnt;else mx=cnt+1;\n\tif((n&1)&&cnt!=m)return puts(\"0\"),0;\n\tif(cnt==m){\n\t\tint res=0;\n\t\ttmp[0]=tmp[1]=1;\n\t\tdp[0]=1;\n\t\tif(n>2)res=n;\n\t\tfor(int i=1;i<n-1;++i){\n\t\t\tdp[i]=(i>=2?tmp[i-2]:0);\n\t\t\ttmp[i]=Fix(tmp[i-1]+dp[i]);\n\t\t\tres=Fix(res+1ll*dp[i]*(n-i)%Md);\n\t\t}\n\t\tprintf(\"%d\",res+1);\n\t\treturn 0;\n\t}\n\tint res=(cnt==m);\n\tcnt=0;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse{\n\t\t\tif(!cnt)continue;\n\t\t\tif(cnt&1)mx=min(mx,cnt);\n\t\t\tcnt=0;\n\t\t}\n\t}\n\t//for(int i=1;i<=5;++i)cerr<<miu[i]<<' ';cerr<<endl;\n\ttmp[0]=tmp[1]=1;\n\tdp[0]=1;\n\tmx+=2;\n\tif(n<mx)res+=n;\n\tfor(int i=2;i<=n;i+=2){\n\t\tdp[i]=Fix(tmp[i-1]-(mx>i?0:tmp[i-mx]));\n\t\ttmp[i]=tmp[i+1]=Fix(tmp[i-1]+dp[i]);\n\t\t//cerr<<dp[i]<<' '<<i<<endl;\n\t\tif((n-i)%2==0&&n-i<mx)res=Fix(res+1ll*dp[i]*(n-i)%Md);\n\t}\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int P = 1e9 + 7;\nconst int inf = 1e9;\nint mul(int a,int b){\n  return a * b % P;\n}\nvoid add(int &a, int b){\n  a += b;\n  if(a >= P)\n    a -= P;\n}\n\nvoid sub(int &a, int b){\n  a -= b;\n  if(a < 0)\n    a += P;\n}\n\nint licz(int n,int lim){\n  debug(n,lim);\n  vector<int> dp(n + 1);\n  dp[0] = 1;\n  dp[1] = 1;\n  for(int i = 1;i < n;i++){\n    add(dp[i + 1], dp[i]);\n    add(dp[i + 1], dp[i]);\n    if(i > lim){\n      sub(dp[i + 1], dp[i - lim - 1]);\n    }\n  }\n  debug(dp);\n  int res = 0;\n  R(i, lim + 1){\n    add(res, mul(dp[n - 1 - i], i + 1));\n  }\n  return res;\n}\nint n,m;\nstring s;\nvoid nope(){\n  cout << \"0\\n\";\n  exit(0);\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n >> m >> s;\n  if(s[0] == 'B'){\n    for(char& el:s)\n      el = 'R' + 'B' - el;\n  }\n  int naj = inf;\n  int ak = 0;\n  bool czB = 0;\n  R(i,m)if(s[i] == 'R'){\n    ak++;\n  }else{\n    if(!czB || ak&1){\n      mini(naj, ak);\n    }\n    czB = 1;\n    ak = 0;\n  }\n  if(!czB){\n    cout << licz(n, 1) << \"\\n\";\n  }else{\n    if(n&1)nope();\n    cout << mul(2, licz(n / 2, naj / 2)) << \"\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\ntemplate <typename T> void chmin(T &x,const T &y)\n{\n\tif(x>y)x=y;\n}\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\ntypedef long long s64;\nconst int N=2e5+5,D=1e9+7;\nchar s[N];\ns64 dp[N],sum[N];\n\nint main()\n{\n#ifdef kcz\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tint n,m;\n\tcin>>n>>m;\n\tscanf(\"%s\",s+1);\n\tif(s[1]=='B')\n\trep(i,1,m)s[i]=\"RB\"[s[i]=='R'];\n\tint mn[2]={N,N},now=0;\n\trep(i,1,m+1)\n\tif(s[i]=='R')++now;\n\telse \n\t{\n\t\tif(now)chmin(mn[now%2],now);\n\t\tnow=0;\n\t}\n\tif(mn[m%2]==m)\n\t{\n\t\tdp[0]=1;\n\t\trep(i,2,n+2)dp[i]=(dp[i-1]+dp[i-2])%D;\n\t\tcout<<(dp[n]+dp[n+2])%D;\n\t}\n\telse\n\t{\n\t\tint fir=1;\n\t\twhile(s[fir]=='R')++fir;\n\t\tif(fir%2)chmin(mn[1],fir);\n\t\tif(n%2){puts(\"0\");exit(0);}\n\t\tdp[0]=sum[0]=1;\n\t\trep(i,2,n)\n\t\t{\n\t\t\tdp[i]=sum[i-2];\n\t\t\tint j=i-mn[1]-1-2;\n\t\t\tif(j>=0)dp[i]-=sum[j];\n\t\t\tdp[i]%=D;\n\t\t\tsum[i]=(sum[i-2]+dp[i])%D;\n\t\t}\n\t\ts64 ans=0;\n\t\trep(x,0,min(n/2-1,mn[1]/2))\n\t\t{\n\t\t\tans+=sum[n-2*x-2];\n\t\t\tif(mn[1]+3<=n)ans-=sum[n-mn[1]-1-2];\n\t\t}\n\t\tcout<<(ans*2%D+D)%D;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)2e6];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(__int128 x) {\n\tif (x == 0) { fast_print('0'); return; }\n\tif (x < 0) {\n\t\tfast_print('-');\n\t\tx = -x;\n\t}\n\t__int128 p = 1;\n\twhile (x / (p * 10)) p *= 10;\n\twhile (p) {\n\t\t__int128 symb = x / p;\n\t\tfast_print((int)symb);\n\t\tx -= p * symb;\n\t\tp /= 10;\n\t}\n};\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n, m;\nstring s;\n\nconst ll MOD = 1e9 + 7;\ntemplate<ll MOD>\nstruct Ring {\n\tll value = 0;\n\tRing() {}\n\tRing(int _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing(ll _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing pow(ll p) const {\n\t\tif (p == 0) return 1;\t\n\t\tif (p & 1) {\n\t\t\treturn Ring(value).pow(p - 1) * value;\n\t\t} else {\n\t\t\tRing sub = Ring(value).pow(p / 2);\n\t\t\treturn sub * sub;\n\t\t}\n\t}\n\tRing inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tvoid operator*=(const Ring<MOD> &b) {\n\t\tvalue *= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator*(Ring<MOD> a, const Ring<MOD> &b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\tvoid operator+=(const Ring<MOD> &b) {\n\t\tvalue += b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator+(Ring a, const Ring &b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\tvoid operator-=(const Ring<MOD> &b) {\n\t\tvalue -= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator-(Ring a, const Ring &b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\tvoid operator/=(const Ring<MOD> &b) {\n\t\t(*this) *= b.inv();\t\n\t}\n\tfriend Ring operator/(Ring a, const Ring &b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\tbool operator==(const Ring<MOD> &b) {\n\t\treturn value == b.value;\n\t}\n\tbool operator!=(const Ring<MOD> &b) {\n\t\treturn value != b.value;\n\t}\n\tfriend void fast_print(const Ring<MOD> &b) {\n\t\tfast_print(b.value);\n\t}\n};\n\ntypedef Ring<MOD> num;\n\nsigned main(signed argc, char *argv[]) {\n\tscan n, m;\n\tscan s;\n\tif (count(s.begin(), s.end(), s[0]) == len(s)) {\n\t\tvector<num> dp(n + 1);\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) \n\t\t\tfor (int j = 2; j <= i; j++)\n\t\t\t\tdp[i] += dp[i - j];\n\t\tnum final = 0;\n\t\tfor (int a = 0; a <= n; a++) \n\t\t\tfor (int b = 0; a + b + 1 <= n; b++)\n\t\t\t\tfinal += dp[n - a - b - 1];\n\t\tprint final;\n\t\treturn 123;\n\t}\n\tif (n & 1) {\n\t\tprint 0;\n\t\treturn 123;\n\t}\n\tif (s[0] == 'B') {\n\t\tfor (char &c : s) \n\t\t\tc = (c == 'R') ? 'B' : 'R';\n\t}\n\tint _max = 1e9;\n\tchar pref = '!';\n\tint _size = 0;\n\tfor (int i = 0; i <= len(s); i++) {\n\t\tif (s[i] != pref) {\n\t\t\tif ((_size & 1) && pref == 'R')\n\t\t\t\t_max = min(_max, _size);\n\t\t\tif (_max == 1e9 && pref != '!') {\n\t\t\t\t_max = min(_max, _size | 1);\n\t\t\t}\n\t\t\t_size = 1;\n\t\t} else {\n\t\t\t_size++;\n\t\t}\n\t\tpref = s[i];\n\t}\n\tvector<num> dp(n + 1);\n\tdp[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 2; j <= min(i, _max + 1); j += 2)\n\t\t\tdp[i] += dp[i - j];\n\tnum final = 0;\n\tfor (int a = 0; a <= n; a++)\n\t\tfor (int b = 0; a + b <= min(_max, n); b++)\n\t\t\tif ((a + b) & 1)\n\t\t\t\tif (n - a - b - 1 >= 0) {\n\t\t\t\t\t// print a, b, n - a - b - 1, dp[n - a - b - 1];\n\t\t\t\t\tfinal += dp[n - a - b - 1];\n\t\t\t\t}\n\tprint final;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nusing Int = long long;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T>\nstruct FormalPowerSeries{\n  using Poly = vector<T>;\n  using Conv = function<Poly(Poly, Poly)>;\n  Conv conv;\n  FormalPowerSeries(Conv conv):conv(conv){}\n\n  Poly pre(const Poly &as,int deg){\n    return Poly(as.begin(),as.begin()+min((int)as.size(),deg));\n  }\n\n  Poly add(Poly as,Poly bs){\n    int sz=max(as.size(),bs.size());\n    Poly cs(sz,T(0));\n    for(int i=0;i<(int)as.size();i++) cs[i]+=as[i];\n    for(int i=0;i<(int)bs.size();i++) cs[i]+=bs[i];\n    return cs;\n  }\n\n  Poly sub(Poly as,Poly bs){\n    int sz=max(as.size(),bs.size());\n    Poly cs(sz,T(0));\n    for(int i=0;i<(int)as.size();i++) cs[i]+=as[i];\n    for(int i=0;i<(int)bs.size();i++) cs[i]-=bs[i];\n    return cs;\n  }\n\n  Poly mul(Poly as,Poly bs){\n    return conv(as,bs);\n  }\n\n  Poly mul(Poly as,T k){\n    for(auto &a:as) a*=k;\n    return as;\n  }\n\n  // F(0) must not be 0\n  Poly inv(Poly as,int deg){\n    assert(as[0]!=T(0));\n    Poly rs({T(1)/as[0]});\n    for(int i=1;i<deg;i<<=1)\n      rs=pre(sub(add(rs,rs),mul(mul(rs,rs),pre(as,i<<1))),i<<1);\n    return rs;\n  }\n\n  // not zero\n  Poly div(Poly as,Poly bs){\n    while(as.back()==T(0)) as.pop_back();\n    while(bs.back()==T(0)) bs.pop_back();\n    if(bs.size()>as.size()) return Poly();\n    reverse(as.begin(),as.end());\n    reverse(bs.begin(),bs.end());\n    int need=as.size()-bs.size()+1;\n    Poly ds=pre(mul(as,inv(bs,need)),need);\n    reverse(ds.begin(),ds.end());\n    return ds;\n  }\n\n  // F(0) must be 1\n  Poly sqrt(Poly as,int deg){\n    assert(as[0]==T(1));\n    T inv2=T(1)/T(2);\n    Poly ss({T(1)});\n    for(int i=1;i<deg;i<<=1){\n      ss=pre(add(ss,mul(pre(as,i<<1),inv(ss,i<<1))),i<<1);\n      for(T &x:ss) x*=inv2;\n    }\n    return ss;\n  }\n\n  Poly diff(Poly as){\n    int n=as.size();\n    Poly res(n-1);\n    for(int i=1;i<n;i++) res[i-1]=as[i]*T(i);\n    return res;\n  }\n\n  Poly integral(Poly as){\n    int n=as.size();\n    Poly res(n+1);\n    res[0]=T(0);\n    for(int i=0;i<n;i++) res[i+1]=as[i]/T(i+1);\n    return res;\n  }\n\n  // F(0) must be 1\n  Poly log(Poly as,int deg){\n    return pre(integral(mul(diff(as),inv(as,deg))),deg);\n  }\n\n  // F(0) must be 0\n  Poly exp(Poly as,int deg){\n    Poly f({T(1)});\n    as[0]+=T(1);\n    for(int i=1;i<deg;i<<=1)\n      f=pre(mul(f,sub(pre(as,i<<1),log(f,i<<1))),i<<1);\n    return f;\n  }\n\n  Poly partition(int n){\n    Poly rs(n+1);\n    rs[0]=T(1);\n    for(int k=1;k<=n;k++){\n      if(1LL*k*(3*k+1)/2<=n) rs[k*(3*k+1)/2]+=T(k%2?-1LL:1LL);\n      if(1LL*k*(3*k-1)/2<=n) rs[k*(3*k-1)/2]+=T(k%2?-1LL:1LL);\n    }\n    return inv(rs,n+1);\n  }\n};\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\nconstexpr int bmds(int x){\n  const int v[] = {1012924417, 924844033, 998244353,\n                   897581057, 645922817};\n  return v[x];\n}\nconstexpr int brts(int x){\n  const int v[] = {5, 5, 3, 3, 3};\n  return v[x];\n}\n\ntemplate<int X>\nstruct NTT{\n  static constexpr int md = bmds(X);\n  static constexpr int rt = brts(X);\n  using M = Mint<int, md>;\n  vector< vector<M> > rts,rrts;\n\n  void ensure_base(int n){\n    if((int)rts.size()>=n) return;\n    rts.resize(n);rrts.resize(n);\n    for(int i=1;i<n;i<<=1){\n      if(!rts[i].empty()) continue;\n      M w=M(rt).pow((md-1)/(i<<1));\n      M rw=w.inv();\n      rts[i].resize(i);rrts[i].resize(i);\n      rts[i][0]=M(1);rrts[i][0]=M(1);\n      for(int k=1;k<i;k++){\n        rts[i][k]=rts[i][k-1]*w;\n        rrts[i][k]=rrts[i][k-1]*rw;\n      }\n    }\n  }\n\n  void ntt(vector<M> &as,bool f,int n=-1){\n    if(n==-1) n=as.size();\n    assert((n&(n-1))==0);\n    ensure_base(n);\n\n    for(int i=0,j=1;j+1<n;j++){\n      for(int k=n>>1;k>(i^=k);k>>=1);\n      if(i>j) swap(as[i],as[j]);\n    }\n\n    for(int i=1;i<n;i<<=1){\n      for(int j=0;j<n;j+=i*2){\n        for(int k=0;k<i;k++){\n          M z=as[i+j+k]*(f?rrts[i][k]:rts[i][k]);\n          as[i+j+k]=as[j+k]-z;\n          as[j+k]+=z;\n        }\n      }\n    }\n\n    if(f){\n      M tmp=M(n).inv();\n      for(int i=0;i<n;i++) as[i]*=tmp;\n    }\n  }\n\n  vector<M> multiply(vector<M> as,vector<M> bs){\n    int need=as.size()+bs.size()-1;\n    int sz=1;\n    while(sz<need) sz<<=1;\n    as.resize(sz,M(0));\n    bs.resize(sz,M(0));\n\n    ntt(as,0);ntt(bs,0);\n    for(int i=0;i<sz;i++) as[i]*=bs[i];\n    ntt(as,1);\n\n    as.resize(need);\n    return as;\n  }\n\n  vector<int> multiply(vector<int> as,vector<int> bs){\n    vector<M> am(as.size()),bm(bs.size());\n    for(int i=0;i<(int)am.size();i++) am[i]=M(as[i]);\n    for(int i=0;i<(int)bm.size();i++) bm[i]=M(bs[i]);\n    vector<M> cm=multiply(am,bm);\n    vector<int> cs(cm.size());\n    for(int i=0;i<(int)cs.size();i++) cs[i]=cm[i].v;\n    return cs;\n  }\n};\ntemplate<int X> constexpr int NTT<X>::md;\ntemplate<int X> constexpr int NTT<X>::rt;\n\n\nnamespace FFT{\n  using dbl = double;\n\n  struct num{\n    dbl x,y;\n    num(){x=y=0;}\n    num(dbl x,dbl y):x(x),y(y){}\n  };\n\n  inline num operator+(num a,num b){\n    return num(a.x+b.x,a.y+b.y);\n  }\n  inline num operator-(num a,num b){\n    return num(a.x-b.x,a.y-b.y);\n  }\n  inline num operator*(num a,num b){\n    return num(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n  }\n  inline num conj(num a){\n    return num(a.x,-a.y);\n  }\n\n  int base=1;\n  vector<num> rts={{0,0},{1,0}};\n  vector<int> rev={0,1};\n\n  const dbl PI=acosl(-1.0);\n\n  void ensure_base(int nbase){\n    if(nbase<=base) return;\n\n    rev.resize(1<<nbase);\n    for(int i=0;i<(1<<nbase);i++)\n      rev[i]=(rev[i>>1]>>1)+((i&1)<<(nbase-1));\n\n    rts.resize(1<<nbase);\n    while(base<nbase){\n      dbl angle=2*PI/(1<<(base+1));\n      for(int i=1<<(base-1);i<(1<<base);i++){\n        rts[i<<1]=rts[i];\n        dbl angle_i=angle*(2*i+1-(1<<base));\n        rts[(i<<1)+1]=num(cos(angle_i),sin(angle_i));\n      }\n      base++;\n    }\n  }\n\n  void fft(vector<num> &a,int n=-1){\n    if(n==-1) n=a.size();\n    assert((n&(n-1))==0);\n\n    int zeros=__builtin_ctz(n);\n    ensure_base(zeros);\n    int shift=base-zeros;\n    for(int i=0;i<n;i++)\n      if(i<(rev[i]>>shift))\n        swap(a[i],a[rev[i]>>shift]);\n\n    for(int k=1;k<n;k<<=1){\n      for(int i=0;i<n;i+=2*k){\n        for(int j=0;j<k;j++){\n          num z=a[i+j+k]*rts[j+k];\n          a[i+j+k]=a[i+j]-z;\n          a[i+j]=a[i+j]+z;\n        }\n      }\n    }\n  }\n\n  vector<num> fa;\n\n  vector<Int> multiply(vector<int> &a,vector<int> &b){\n    int need=a.size()+b.size()-1;\n    int nbase=0;\n    while((1<<nbase)<need) nbase++;\n    ensure_base(nbase);\n\n    int sz=1<<nbase;\n    if(sz>(int)fa.size()) fa.resize(sz);\n    for(int i=0;i<sz;i++){\n      int x=(i<(int)a.size()?a[i]:0);\n      int y=(i<(int)b.size()?b[i]:0);\n      fa[i]=num(x,y);\n    }\n    fft(fa,sz);\n\n    num r(0,-0.25/sz);\n    for(int i=0;i<=(sz>>1);i++){\n      int j=(sz-i)&(sz-1);\n      num z=(fa[j]*fa[j]-conj(fa[i]*fa[i]))*r;\n      if(i!=j)\n        fa[j]=(fa[i]*fa[i]-conj(fa[j]*fa[j]))*r;\n      fa[i]=z;\n    }\n    fft(fa,sz);\n\n    vector<Int> res(need);\n    for(int i=0;i<need;i++)\n      res[i]=fa[i].x+0.5;\n\n    return res;\n  }\n\n};\n\n\ntemplate<typename T>\nstruct ArbitraryModConvolution{\n  using dbl=FFT::dbl;\n  using num=FFT::num;\n\n  vector<T> multiply(vector<T> as,vector<T> bs){\n    int need=as.size()+bs.size()-1;\n    int sz=1;\n    while(sz<need) sz<<=1;\n    vector<num> fa(sz),fb(sz);\n    for(int i=0;i<(int)as.size();i++)\n      fa[i]=num(as[i].v&((1<<15)-1),as[i].v>>15);\n    for(int i=0;i<(int)bs.size();i++)\n      fb[i]=num(bs[i].v&((1<<15)-1),bs[i].v>>15);\n\n    fft(fa,sz);fft(fb,sz);\n\n    dbl ratio=0.25/sz;\n    num r2(0,-1),r3(ratio,0),r4(0,-ratio),r5(0,1);\n    for(int i=0;i<=(sz>>1);i++){\n      int j=(sz-i)&(sz-1);\n      num a1=(fa[i]+conj(fa[j]));\n      num a2=(fa[i]-conj(fa[j]))*r2;\n      num b1=(fb[i]+conj(fb[j]))*r3;\n      num b2=(fb[i]-conj(fb[j]))*r4;\n      if(i!=j){\n        num c1=(fa[j]+conj(fa[i]));\n        num c2=(fa[j]-conj(fa[i]))*r2;\n        num d1=(fb[j]+conj(fb[i]))*r3;\n        num d2=(fb[j]-conj(fb[i]))*r4;\n        fa[i]=c1*d1+c2*d2*r5;\n        fb[i]=c1*d2+c2*d1;\n      }\n      fa[j]=a1*b1+a2*b2*r5;\n      fb[j]=a1*b2+a2*b1;\n    }\n    fft(fa,sz);fft(fb,sz);\n\n    vector<T> cs(need);\n    using ll = long long;\n    for(int i=0;i<need;i++){\n      ll aa=T(llround(fa[i].x)).v;\n      ll bb=T(llround(fb[i].x)).v;\n      ll cc=T(llround(fa[i].y)).v;\n      cs[i]=T(aa+(bb<<15)+(cc<<30));\n    }\n    return cs;\n  }\n};\n\n//INSERT ABOVE HERE\n\nsigned HAPPYQUERY_E(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n,m,q;\n  cin>>n>>m>>q;\n  vector<int> ls(q),rs(q);\n  for(int i=0;i<q;i++) cin>>ls[i]>>rs[i],ls[i]--;\n\n  vector<int> as(n);\n  for(int i=0;i<n;i++) cin>>as[i];\n\n  if(as==vector<int>(n,0)){\n    for(int i=0;i<m;i++){\n      if(i) cout<<\" \";\n      cout<<0;\n    }\n    cout<<endl;\n    return 0;\n  }\n\n  vector<int> cs(n-m+1,0);\n  for(int l:ls) cs[l]++;\n\n  NTT<0> ntt;\n  using M = NTT<0>::M;\n  auto conv=[&](auto as,auto bs){return ntt.multiply(as,bs);};\n  FormalPowerSeries<M> FPS(conv);\n\n  vector<M> ps(as.size()),qs(cs.size());\n  for(int i=0;i<(int)ps.size();i++) ps[i]=M(as[i]);\n  for(int i=0;i<(int)qs.size();i++) qs[i]=M(cs[i]);\n\n  auto bs=FPS.div(ps,qs);\n  for(int i=0;i<m;i++){\n    if(i) cout<<\" \";\n    cout<<bs[i];\n  }\n  cout<<endl;\n  return 0;\n}\n/*\n  verified on 2019/09/17\n  https://www.hackerrank.com/contests/happy-query-contest/challenges/array-restoring\n*/\n\nsigned CFR250_E(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n,m;\n  cin>>n>>m;\n  vector<int> cs(n);\n  for(int i=0;i<n;i++) cin>>cs[i];\n\n  NTT<2> ntt;\n  using M = NTT<2>::M;\n  auto conv=[&](auto as,auto bs){return ntt.multiply(as,bs);};\n  FormalPowerSeries<M> FPS(conv);\n\n  const int deg=1<<18;\n  vector<M> as(deg,0);\n  as[0]=M(1);\n  for(int c:cs) as[c]-=M(4);\n\n  auto bs=FPS.sqrt(as,deg);\n  bs[0]+=M(1);\n\n  vector<M> vs({2});\n\n  auto ans=FPS.mul(vs,FPS.inv(bs,deg));\n  for(int i=1;i<=m;i++) cout<<ans[i]<<\"\\n\";\n  cout<<flush;\n\n  return 0;\n}\n/*\n  verified on 2019/09/17\n  https://codeforces.com/contest/438/problem/E\n*/\n\nsigned YUKI_3046(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int k,n;\n  cin>>k>>n;\n  vector<int> xs(n);\n  for(int i=0;i<n;i++) cin>>xs[i];\n\n  using M = Mint<int>;\n  ArbitraryModConvolution<M> arb;\n  auto conv=[&](auto as,auto bs){return arb.multiply(as,bs);};\n  FormalPowerSeries<M> FPS(conv);\n\n  const int sz=1<<17;\n  vector<M> bs(sz,M(0));\n  bs[0]=1;\n  for(int x:xs) bs[x]-=M(1);\n  cout<<FPS.inv(bs,k+1)[k]<<endl;\n  return 0;\n}\n/*\n  verified on 2019/09/17\n  https://yukicoder.me/problems/no/3046\n*/\n\nconst int md = 998244353;\ninline int add(int a,int b){\n  a+=b;\n  if(a>=md) a-=md;\n  return a;\n}\n\ninline int mul(int a,int b){\n  return 1LL*a*b%md;\n}\n\ninline int pow(int a,int b){\n  int res=1;\n  while(b){\n    if(b&1) res=mul(res,a);\n    a=mul(a,a);\n    b>>=1;\n  }\n  return res;\n}\n\ninline int sqrt(int a){\n  if(a==0) return 0;\n  if(pow(a,(md-1)/2)!=1) return -1;\n  int q=md-1,m=0;\n  while(~q&1) q>>=1,m++;\n  mt19937 mt;\n  int z=mt()%md;\n  while(pow(z,(md-1)/2)!=md-1) z=mt()%md;\n  int c=pow(z,q),t=pow(a,q),r=pow(a,(q+1)/2);\n  while(m>1){\n    if(pow(t,1<<(m-2))!=1)\n      r=mul(r,c),t=mul(t,mul(c,c));\n    c=mul(c,c);\n    m--;\n  }\n  return min(r,md-r);\n}\n\nsigned LOJ_150(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  NTT<2> ntt;\n  using M = NTT<2>::M;\n  auto conv=[&](auto as,auto bs){return ntt.multiply(as,bs);};\n  FormalPowerSeries<M> FPS(conv);\n\n  int n,k;\n  cin>>n>>k;\n\n  vector<M> F(n+1);\n  for(int i=0;i<=n;i++) cin>>F[i].v;\n\n  const int deg = 1<<17;\n  auto as=FPS.log(FPS.mul(F,F[0].inv()),deg);\n  auto bs=FPS.exp(FPS.mul(as,M((md-1)/2)),deg);\n  M s(sqrt(F[0].v));\n  auto cs=FPS.integral(FPS.mul(bs,s.inv()));\n  auto ds=FPS.exp(cs,deg);\n  auto es=FPS.sub(F,ds);\n  es[0]+=M(2);\n  es[0]-=F[0];\n  auto fs=FPS.log(es,deg);\n  fs[0]+=M(1);\n  auto gs=FPS.log(fs,deg);\n  auto hs=FPS.mul(gs,M(k));\n  auto is=FPS.exp(hs,deg);\n  auto G=FPS.diff(is);\n\n  for(int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<G[i];\n  }\n  cout<<endl;\n  return 0;\n}\n#define mod 1000000007\n\nMint<int,mod> dp[400010][2][2];\nint main(){\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if(s[0]=='R'){\n        rep(i,m){\n            if(s[i]=='R'){\n                s[i] ='B';\n            }else{\n                s[i] ='R'; \n            }\n        }\n    }\n    int a = inf;\n    int c = 0;\n    rep(i,m){\n        if(s[i]=='B'){\n            c++;\n        }else{\n            chmin(a,c);    \n        }\n    }\n    if(a==inf){\n        dp[0][0][0] = 1;\n        dp[0][1][1] = 1;\n        for(int i=1;i<n;i++){\n            for(int j=0;j<2;j++){\n                if(j==0){\n                    dp[i][j][0] += dp[i-1][1][0];\n                    dp[i][j][1] += dp[i-1][1][1];\n                }else{\n                    dp[i][j][0] += dp[i-1][1][0] + dp[i-1][0][0];\n                    dp[i][j][1] += dp[i-1][1][1] + dp[i-1][0][1];    \n                }\n            }\n        }\n        cout << dp[n-1][1][0] + dp[n-1][1][1] + dp[n-1][0][1] << endl;\n    }else{\n        int len = (a/2)*2+1;\n        cerr << len << endl;\n        vector<Mint<int> > X(n+1),Y(n+1);\n        len++;\n        len = min(len,n);\n        for(int i=2;i<=len;i+=2){\n            X[i] = i;\n        }\n        Y[0] = 1;\n        for(int i=2;i<=len;i+=2){\n            Y[i] = mod-1;\n        }\n        ArbitraryModConvolution<Mint<int,mod> > arb;\n        auto conv=[&](auto as,auto bs){return arb.multiply(as,bs);};\n        FormalPowerSeries<Mint<int> > FPS(conv);\n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        auto cs = FPS.inv(Y,n+1);\n        \n        // rep(i,n+1){\n        //     cerr << cs[i] << \" \";\n        // }\n        auto res = FPS.mul(X,cs);\n        cout << res[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e5+10,inf=0x3f3f3f3f,mod=1e9+7;\nchar s[maxn];\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\ty>>=1;\n\t\tx=(ll)x*x%mod;\n\t}\n\treturn res;\n}\nint dp[maxn],sum[maxn];\nint main(){\n\tint n=read(),m=read();\n\tscanf(\"%s\",s+1);\n\tint Min=inf;\n\tfor(int i=1,j;i<=m;i++) if(s[i]==s[1]){\n\t\tj=i;\n\t\twhile(j<m && s[j+1]==s[1]) ++j;\n\t\tif((j-i+1)%2==1) chkmin(Min,j-i+1);\n\t\telse if(i==1) chkmin(Min,j-i+2);\n\t\ti=j;\n\t}\n\tint flag=1;\n\tREP(i,2,m) flag&=(s[i]==s[1]);\n\tdp[1]=sum[1]=1;\n\tREP(i,2,n+1){\n\t\tif(flag){\n\t\t\tdp[i]=sum[i-2];\n\t\t\tsum[i]=(sum[i-1]+dp[i])%mod;\n\t\t}\n\t\telse{\n\t\t\tdp[i]=(sum[i-2]-sum[max(i-Min-3,0)]+mod)%mod;\n\t\t\tsum[i]=(sum[i-2]+dp[i])%mod;\n\t\t}\n\t}\n\tint ans=(dp[n+1]*2+flag)%mod;\n\tREP(i,1,n-2) if(((n-i)%2==1 && n-i<=Min) || flag) ans=(ans+(ll)dp[i]*(n-i-1))%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nchar str[200005];\nint arr[200005];\nlong long MOD=1000000007;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",str);\n\tfor(int i=0;i<m;i++){\n\t\tif(str[i]=='R')arr[i]=0;\n\t\telse arr[i]=1;\n\t}\n\tbool all[2];all[0]=all[1]=1;\n\tfor(int i=0;i<m;i++)all[arr[i]^1]=0;\n\tif(all[0]||all[1]){\n\t\tlong long dp[2][n];memset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;dp[1][0]=0; //start with red (or blue if everything is blue)\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tlong long ans=(dp[0][n-1]+dp[1][n-1])%MOD; //end with red or blue\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=0;dp[1][0]=1; //start with blue\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tans+=dp[0][n-1];ans%=MOD;ans+=MOD;ans%=MOD; //only end with red\n\t\tprintf(\"%lld\",ans);\n\t\treturn 0;\n\t}\n\tif(n%2!=0){printf(\"0\");return 0;}\n\tint s=0,l=n-1;\n\tfor(int i=0;i<m;i++){\n\t\tint cur=0;\n\t\twhile(i+cur<m&&arr[i+cur]==arr[0])cur++;\n\t\tif(s==0)s=(cur%2==0?cur+1:cur);\n\t\telse if(i+cur<m&&cur%2!=0)l=min(l,cur);\n\t\ti+=cur;\n\t}\n\tint mxl=min((s==0?(int)MOD:s),l);\n\t//comments: wlog red is first\n\t//can ignore last segment of red\n\tn/=2; mxl/=2; //remove the ones that are different parity from blue\n\tlong long dp[100005],pref[100005];\n\tmemset(dp,0,sizeof(dp));memset(pref,0,sizeof(pref));\n\t//i segments on a line, first and last are blue, max mxl consecutive reds\n\t//blues may be consecutive because the reds in between were removed\n\tdp[1]=pref[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tdp[i]=pref[i-1]-pref[max(0,i-(mxl+2))];\n\t\tdp[i]%=MOD;dp[i]+=MOD;dp[i]%=MOD;\n\t\tpref[i]=dp[i]+pref[i-1];\n\t\tpref[i]%=MOD;pref[i]+=MOD;pref[i]%=MOD;\n\t}\n\tlong long ans=0;\n\tfor(long long i=2;i<=min(n,mxl+2);i++){\n\t\tans+=(i-1LL)*dp[n-i+2];\n\t\tans%=MOD;\n\t}\n\tans+=MOD;ans%=MOD;\n\tprintf(\"%lld\",(ans*2)%MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=a*b%mod\n\nll n,m;\nstring s;\nll f[200010],rui[200010];\n\nint main(){\n    cin>>n>>m>>s;\n    if(s[0]=='R'){\n\tfor(int i=0;i<m;i++){\n\t    if(s[i]=='R')s[i]='B';\n\t    else s[i]='R';\n\t}\n    }\n    bool th=0;\n    ll cnt=0,mi=1e17;\n    bool fi=1; ll lead;\n    for(int i=0;i<m;i++){\n\tif(s[i]=='R'){\n\t    if(fi)lead=cnt; fi=0;\n\t    th=1;\n\t    if(cnt%2==1)chmin(mi,cnt);\n\t    cnt=0;\n\t}\n\telse cnt++;\n    }\n    if(th==0){\n\tf[0]=f[1]=1;\n\tfor(int i=2;i<n;i++){\n\t    f[i]=(f[i-1]+f[i-2])%mod;\n\t}\n\tll ans=(f[n-2]*2+f[n-1])%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n    }\n    if(n%2==1){\n\tcout<<0<<endl;\n\treturn 0;\n    }cout<<1/0<<endl;\n    \n    if(lead%2==0)lead++;\n    chmin(mi,lead);\n    mi=(mi+1)/2;\n    chmin(mi,n/2);\n    f[0]=rui[0]=0;\n    for(ll i=1;i<=mi;i++){\n\tf[i]=i;\n\trui[i]=(rui[i-1]+i)%mod;\n    }\n    for(int i=1;i<n/2;i++){\n\tmad(f[i],rui[i-1]);\n\tif(i-mi-1>=0)mad(f[i],-rui[i-mi-1]);\n\trui[i]=(rui[i-1]+f[i])%mod;\n    }\n    ll ans=0;\n    for(int i=1;i<=mi;i++)mad(ans,f[n/2-i]);\n    //cout<<mi<<endl;\n    //for(int i=0;i<n/2;i++)cout<<i<<\":\"<<f[i]<<endl;\n    ans=ans*2%mod;\n    if(ans<0)ans+=mod;\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,inline\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#include<bits/stdc++.h>\n#define ll long long\n//#define int ll\nusing namespace std;\nconst ll md=1000000007;\nconst int mxn=200005;\nint n,m,mx,ans,dp[mxn],f[mxn];\nchar s[mxn];\ninline void add(int&x,int y){\n\tx+=y;\n\tif(x>=md)x-=md;\n}\nsigned main(){\n\tint i,j,t;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(i=1;i<=m;++i)if(s[i]!=s[1])break;mx=i-1;\n\tif(mx==m){\n\t\tdp[0]=f[i]=ans=1;\n\t\tfor(int i=0;i<=n;++i){\n\t\t\tif(i>=2)dp[i]=f[i-2];\n\t\t\tf[i]=(f[i-1]+dp[i])%md;\n\t\t\tif(n-i>1)add(ans,dp[i]*(n-i)%md);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(n&1)return 0*puts(\"0\");\n\tif(!(mx&1))++mx;\n\tfor(t=0;i<=m;++i){\n\t\tif(s[i]==s[1])++t;\n\t\telse{\n\t\t\tif(t&1)mx=min(mx,t);\n\t\t\tt=0;\n\t\t}\n\t}\n\tn>>=1,mx=mx+1>>1;\n\tdp[0]=f[0]=1;\n\tfor(i=0;i<=n;++i){\n\t\tif(i){\n\t\t\tdp[i]=(md+f[i-1]-(i-mx-1>=0?f[i-mx-1]:0))%md;\n\t\t\tf[i]=(f[i-1]+dp[i])%md;\n\t\t}\n\t\tif(n-i<=mx) add(ans,(n-i)*dp[i]*2ll%md);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 1;\n    rdp[0] = 1;\n    for(int i = 1;i <= n+1;i++){\n        dp[i] = (rdp[i-1] - ((i-limit-1)>=0?rdp[i-limit-1]:0)) % MOD;\n        if(dp[i] < 0)dp[i] += MOD;\n        rdp[i] = (rdp[i-1] + dp[i]) % MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    if(limit % 2 != 1)exit(1);\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n+10, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    bool allsame = true;\n    for(int i = 0;i < m;i++)allsame &= (str[i] == str[0]);\n    if(allsame){\n        cout << all(n) << endl;\n        return 0;\n    }\n    for(int i = 0;i < m;i++)vec.push_back(str[i] == str[0]);\n    vec.push_back(0);\n    Int l = 0;\n    while(vec[l] == 1)l++;\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i < vec.size();i++){\n        if(vec[i] == 1)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing std::min;\n\nconst int MOD=1000000007;\n\nconst int MAXN=200011, MAXM=200011;\n\ninline int sum(const int &a, const int &b){\n\treturn (a+b>=MOD)?(a+b-MOD):(a+b);\n}\n\ninline int mul(const int &a, const int &b){\n\treturn (int)((1LL*a*b)%(long long)(MOD));\n}\n\ninline void add(int &f, const int &v){\n\tf+=v;if(f>=MOD)\tf-=MOD;\n}\n\nint N, M;\nint A[MAXM];\nchar input[MAXM];\nint F[MAXN];\n\ninline bool AllZero(){\n\tint Cnt=0;\n\tfor(int i=1;i<=M;++i)\tCnt+=!A[i];\n\treturn Cnt==M;\n}\n\nint main(){\n\t\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", input);\n\tfor(int i=1;i<=M;++i)\tA[i]=input[i-1]!=input[0];\n\t\n\tif(AllZero()){\n\t\tint F[2][2], T[2][2];\n\t\tF[0][0]=F[1][1]=1;\n\t\tF[0][1]=F[1][0]=0;\n\t\tfor(int i=2;i<=N;++i){\n\t\t\tfor(int s=0;s<2;++s)\n\t\t\t\tfor(int n=0;n<2;++n)\n\t\t\t\t\tT[s][n]=0;\n\t\t\tfor(int s=0;s<2;++s)\n\t\t\t\tfor(int n=0;n<2;++n)\n\t\t\t\t\tfor(int c=0;c<2;++c)\n\t\t\t\t\t\tif(n+c<2)\tT[s][c]+=F[s][n];\n\t\t\tfor(int s=0;s<2;++s)\n\t\t\t\tfor(int n=0;n<2;++n)\n\t\t\t\t\tF[s][n]=T[s][n];\n\t\t}\n\t\tint Ans=0;\n\t\tfor(int s=0;s<2;++s)\n\t\t\tfor(int n=0;n<2;++n)\n\t\t\t\tif(s+n<2)\tadd(Ans, F[s][n]);\n\t\tprintf(\"%d\\n\", Ans);\n\t}\n\telse{\n\t\tint Lim=N;\n\t\tfor(int i=1, c=0, p=0;i<=M;++i){\n\t\t\tif(A[i]){\n\t\t\t\tif(c&1)\tLim=min(Lim, c+1);\n\t\t\t\telse if(!p)\tLim=min(Lim, c+2);\n\t\t\t\tc=0;p=i;\n\t\t\t}\n\t\t\telse\t++c;\n\t\t}\n\t\tF[0]=F[2]=1;\n\t\tfor(int i=4;i<=N;i+=2){\n\t\t\tF[i]=sum(F[i-2], F[i-2]);\n\t\t\tif(i>=Lim+2){\n\t\t\t\tadd(F[i], MOD-F[i-(Lim+2)]);\n\t\t\t}\n\t\t}\n\t\tint Ans=0;\n\t\tfor(int i=2;i<=Lim;i+=2){\n\t\t\tadd(Ans, mul(F[N-i], i));\n\t\t}\n\t\tprintf(\"%d\\n\", Ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#define N 201000\ntypedef long long ll;\ntemplate <typename T> inline void read(T &x) {\n\tx = 0; char c = getchar(); bool flag = false;\n\twhile (!isdigit(c)) { if (c == '-')\tflag = true; c = getchar(); }\n\twhile (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }\n\tif (flag)\tx = -x;\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nconst int inf = 987654321;\ninline void MIN(int &a, int b) {\n\tif (b < a)\ta = b;\n}\nint n, m;\nchar s[N];\nnamespace jzp1 {\n\tll jie[N], jieni[N];\n\tinline ll get_c(int n, int m) {\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\tif (n < 0 || m < 0 || n - m < 0)\treturn 0;\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\treturn jie[n] * jieni[m] % P * jieni[n - m] % P;\n\t}\n\tinline ll quickpow(ll x, int k) {\n\t\tll res = 1;\n\t\twhile (k) {\n\t\t\tif (k & 1)\tres = res * x % P;\n\t\t\tx = x * x % P;\n\t\t\tk >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline void sol() {\n//\t\twhile(1);\n\t\tif (n == 1) { puts(\"1\"); return ; }\n\t\tjie[0] = jieni[0] = 1;\n\t\tint up = n + 1;\n\t\tfor (int i = 1; i <= up; ++i)\tjie[i] = jie[i - 1] * i % P;\n\t\tjieni[up] = quickpow(jie[up], P - 2);\n\t\tfor (int i = up - 1; i; --i)\tjieni[i] = jieni[i + 1] * (i + 1) % P;\n\t\tll res = 0;\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tres = (res + get_c(n - i + 1, i) - get_c(n - i - 1, i - 2)) % P;\n//\t\t\tprintf(\"res = %lld\\n\", res);\n\t\t}\n\t\tprintf(\"%lld\\n\", (res % P + P) % P);\n\t}\n}\nll f[N];\nll sum[N];\nint main() {\n\tread(n), read(m);\n\tif (n < m)\texit(-1);\n\tscanf(\"%s\", s + 1);\n\tbool flag = false;\n\tfor (int i = 1; i <= m; ++i)\tif (s[i] != s[1]) { flag = true; break; }\n\tif (!flag) { jzp1::sol(); return 0; }\n\tif (n & 1) { puts(\"0\"); return 0; }\n\tint lst = 1, mn = inf;\n\tfor (int i = 2; i <= m + 1; ++i) {\n\t\tif (s[i] != s[1]) {\n\t\t\tif (lst & 1)\tMIN(mn, lst);\n\t\t\tlst = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == s[i - 1])\t++lst;\n\t\telse {\n\t\t\tif (lst & 1) MIN(mn, lst);\n\t\t\tlst = 1;\n\t\t}\n\t}\n\tif (mn == inf) {\n//\t\twhile (1);\n\t\tint memo = 1;\n\t\tfor (int i = 1; s[i] == s[1]; ++i) memo = i;\n\t\tmn = memo + 1;\n\t}\n\tn >>= 1;\n\tint k = (mn + 1) >> 1;\n\tMIN(k, n);\n\tf[0] = 1; sum[0] = 1;\n//\tprintf(\"n = %d, k = %d\\n\", n, k);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (i <= k)\tf[i] = sum[i - 1];\n\t\telse f[i] = (sum[i - 1] - sum[i - k - 1]) % P;\n\t\tsum[i] = (sum[i - 1] + f[i]) % P;\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tans = (ans + f[n - i] * i) % P;\n\t}\n\tans = (ans << 1) % P;\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n\n/*\n3 3\nBBB\n//4\n\n1 1\nB\n//1\n\n12 10\nRRRRBRRRRB\n//78\n*/"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nllint solve(llint n,llint K){\n\tllint i;\n\tif(K>n){\n\t\tllint ans=1;\n\t\twhile(n--){ans*=2;ans%=mod;}\n\t\treturn ans;\n\t}\n\t//円環上にAマークとBマーク\n\t//BマークがKこ連続してはいけない\n\tvector<llint>dp(n+1);//最後のAマーク\n\tllint gen=1;//くぎりてん\n\tdp[0]=1;//最後のBマーク\n\tfor(i=1;i<n;i++){\n\t\tdp[i]=gen;\n\t\tgen*=2;\n\t\tif(i-K>=0){gen-=dp[i-K];}\n\t\tgen+=mod;gen%=mod;\n\t}\n\tllint ans=0;\n\tfor(i=1;i<=K;i++){\n\t\tans+=i*dp[n-i];\n\t\tans%=mod;\n\t}\n\treturn ans;\n}\nint main(void){\n\tint i,n,m;cin>>n>>m;\n\tstring S;cin>>S;\n\tvector<int>suu;\n\tchar now=S[0];\n\tint ban=0;\n\tfor(i=0;i<n;i++){\n\t\tif(S[i]==now){ban++;}\n\t\telse{suu.pub(ban);ban=1;}\n\t\tnow=S[i];\n\t}\n\tsuu.pub(ban);\n\t//for(auto it:suu){cerr<<it<<endl;}\n\tif(suu.size()==1){\n\t\tcout<<solve(n,2)<<endl;\n\t\treturn 0;\n\t}\n\tif(n%2==1){cout<<0<<endl;return 0;}\n\tint sei=suu[0];\n\tif(suu[0]%2==0){sei=suu[0]+1;}\n\tfor(i=2;i<suu.size();i+=2){\n\t\tif(suu[i]%2==1){mineq(sei,suu[i]);}\n\t}\n\tsei++;\n\t//cerr<<sei<<endl;\n\tcout<<(2*solve(n/2,sei/2))%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef HOME\n#pragma GCC optimize \"-O3\"\n#endif\n\n#include <bits/stdc++.h>\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing namespace std;\n\nconst int MOD = 1000 * 1000 * 1000 + 7;\nconst int MX = 200 * 1000 + 7;\n\nint pw[MX];\nint f[MX][2][2];\n\nvector<int> dv[MX];\n\nint main() {\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    for (int i = 1; i < MX; i++) {\n        for (int j = i; j < MX; j += i) {\n            dv[j].push_back(i);\n        }\n    }\n    pw[0] = 1;\n    for (int i = 1; i < MX; i++) {\n        pw[i] = (pw[i - 1] + pw[i - 1]) % MOD;\n    }\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (char& c : s) {\n            c = c ^ 'R' ^ 'B';\n        }\n    }\n\n    while (!s.empty() && s.back() == 'R') {\n        s.pop_back();\n    }\n    {\n        bool fl = false;\n        for (char c : s) {\n            if (c != 'R') {\n                fl = true;\n            }\n        }\n        if (!fl) {\n            f[1][0][0] = 1;\n            f[1][1][1] = 1;\n            for (int i = 2; i <= n; i++) {\n                for (int x = 0; x < 2; x++) {\n                    for (int y = 0; y < 2; y++) {\n                        for (int z = 0; z < 2; z++) {\n                            if (y == 0 && z == 0) {\n                                continue;\n                            }\n                            f[i][x][y] = (f[i][x][y] + f[i - 1][x][z]) % MOD;\n                        }\n                    }\n                }\n            }\n            int ans = 0;\n            for (int i = 0; i < 2; i++) {\n                for (int j = 0; j < 2; j++) {\n                    if (i == 0 && j == 0) {\n                        continue;\n                    }\n                    ans = (ans + f[n][i][j]) % MOD;\n                }\n            }\n            cout << ans << \"\\n\";\n            return 0;\n        }\n    }\n    {\n        int len1 = 0, len2 = 0;\n        int ptr = 0;\n        while (ptr < m) {\n            if (s[ptr] == 'R') {\n                int go = ptr;\n                while (go < m && s[go] == 'R') {\n                    go++;\n                }\n                int len = go - ptr;\n                if (len % 2 == 1) {\n                    len1 = max(len1, len);\n                }\n                ptr = go;\n            } else {\n                vector<char> st;\n                int mst = 0;\n                int go = ptr;\n                do {\n                    if (s[go] == 'R' && (go + 1 == m || s[go + 1] == 'R')) {\n                        break;\n                    }\n                    if (!st.empty() && st.back() == s[go]) {\n                        st.pop_back();\n                    } else {\n                        st.push_back(s[go]);\n                    }\n                    go++;\n                    mst = max(mst, (int)st.size());\n                } while (!st.empty() && go < m);\n                if (mst % 2 == 0) {\n                    mst--;\n                }\n                ptr = go;\n                len2 = max(len2, mst);\n            }\n        }\n\n        int ans = 0;\n        if (len2 > n) {\n            if (n % 2 == 1) {\n                cout << 0 << \"\\n\";\n            } else {\n                cout << 2 << \"\\n\";\n            }\n            return 0;\n        }\n\n        if (n % 2 == 0) {\n            ans = 2;\n        }\n\n        for (int pers = 1; pers <= n; pers++) {\n            if (n % pers) {\n                continue;\n            }\n            int len = n / pers;\n            if (len % 2 != 0) {\n                continue;\n            }\n            int more = len - len1 - len2;\n            if (more < 0) {\n                continue;\n            }\n            ans = (ans + 1ll * (more / 2) * len) % MOD;\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nchar s[200005];\nint f[200005];\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tif(s[1]=='B')\n\t\tfor(int i=1;i<=m;i++)s[i]=(s[i]=='R'?'B':'R');\n\tint lst=0,k=n;\n\tfor(int i=1;i<=m;i++){\n\t\tif(s[i]=='B'){\n\t\t\tif(lst==i-1)lst=i;\n\t\t\telse{\n\t\t\t\tif(!lst)k=min(k,i-lst);\n\t\t\t\tif((i-lst-1)&1)k=min(k,i-lst-1);\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"%d\\n\",k);\n\tif(k==n){\n\t\tint ans=1;\n\t\tf[1]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tf[i]=(f[i-1]+f[i-2])%mod;\n\t\t\tans+=f[i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(k&1)k++;\n\tf[1]=f[3]=1;\n\tfor(int i=5;i<=n;i+=2)f[i]=(2ll*f[i-2]+(i>k?mod-f[i-k-2]:0))%mod;\t\n\tint ans=0;\n\tfor(int i=1;i<=k;i++)if(i&1)ans=(ans+1ll*f[n-i]*(i+1))%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n/*\n0-index\nfunctionの中を書いて使う\n宣言の時に単位元を書く\n*/\ntemplate<typename T>\nstruct segtree{\n\tint n;\n\tvector<T> dat;\n\tT ZERO;\n\tfunction<T(T,T)> func;\n\tsegtree(int n_, function<T(T,T)> func_, T zero):func(func_), ZERO(zero){\n\t  n = 1;\n\t  while(n < n_)n*=2;\n\t  dat.resize(2*n);\n\t  for(int i = 0;i < 2*n;i++)dat[i] = ZERO;\n\t}\n\tvoid update(int k, T a){\n\t  k += n - 1;dat[k] = a;\n\t  while(k > 0){\n\t\tk = (k-1)/2;\n\t\tdat[k] = func(dat[k*2+1],dat[k*2+2]);\n\t  }\n\t}\n\n\tvoid set(int k, T a) {\n\t\tk += n - 1;dat[k] = a;\n\t}\n\n\tvoid build(){\n\t\tfor(int i = n - 2;i >= 0;i--){\n\t\t\tdat[i] = func(dat[2 * i + 1], dat[2 * i + 2]);\n\t\t}\n\t}\n\n\tT get(int k){return dat[k+n-1];}\n\n\tT que(int a,int b){\n\t\tT L = ZERO,R = ZERO;\n\t\tint A = a + n - 1;\n\t\tint B = b + n - 1;\n\t\twhile(A < B){\n\t\t\tif((A & 1) == 0)L = func(L,dat[A++]);\n            if((B & 1) == 0)R = func(dat[--B],R);\n            A = A >> 1;\n            B = B >> 1;\n\t\t}\n\t\treturn func(L,R);\n\t}\n};\n\n\nint getmin(string str){\n\tchar c = str[0];\n\tbool isFirst = true;\n\tint cou = 0;\n\tint ret = INF;\n\tREP(i, str.size()){\n\t\tif(str[i] == c)cou++;\n\t\telse {\n\t\t\tif(isFirst && cou % 2 == 0)cou++;\n\t\t\tif(cou % 2)ret = min(ret, cou);\n\t\t\tisFirst = false;\n\t\t\tcou = 0;\n\t\t}\n\t}\n\n\tif(isFirst && cou % 2 == 0)cou++;\n\tif(cou % 2)ret = min(ret, cou);\n\treturn ret;\n}\n\nbool oneKind(string str){\n\tREP(i, str.size())if(str[0] != str[i])return false;\n\treturn true;\n}\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\tll n, m;cin >> n >> m;\n\tstring str;cin >> str;\n\n\tint k = getmin(str);\n\tsegtree<ll> seg(n, [](ll a, ll b){return (a + b) % MOD;}, 0);\n\n\tseg.update(0, 1);\n\tfor(ll i = 2;i < n;i++){\n\t\tif(i % 2)continue;\n\t\tll l = max(0LL, i - k - 1);\n\t\tll r = i - 1;\n\t\tseg.update(i, seg.que(l, r));\n\t}\n\n\t//REP(i, n)cout << seg.get(i) << \" \";cout << endl;\n\n\tll ans = 0;\n\tbool flag = oneKind(str);\n\tREP(i, n-1){\n\t\tif(n - (i + 1) <= k && ((n - (i + 1)) % 2 || flag)){\n\t\t\t//cout << \"pass \" << seg.get(i) * (n - i) % MOD << endl;\n\t\t\tans = (ans + seg.get(i) * (n - i) % MOD) % MOD;\n\t\t}\n\t}\n\tif(flag)ans = (ans + 1) % MOD;\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod=1000000007;\nint n,m,f[200010],sum[200010],la,mi,ans,jc[200010],inv[200010];\nchar s[200010];\nbool bo;\n\nint quickmi(int a,int b)\n{\n\tint t=1;\n\tfor (; b; b>>=1,a=1ll*a*a%mod)\n\t\tif (b&1) t=1ll*t*a%mod;\n\treturn t;\n}\n\nint calc(int n)\n{\n\tint ans=0;\n\tfor (int i=0; n-i-1>=i; i++)\n\t\tans=(ans+1ll*jc[n-i-1]*inv[i]%mod*inv[n-2*i-1])%mod;\n\treturn ans;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m),scanf(\"%s\",s),bo=1;\n\tif (s[0]=='B') {for (int i=0; i<m; i++) s[i]=(s[i]=='B'?'R':'B');}\n\tfor (int i=0; i<m; i++) if (s[i]=='B') {bo=0; break;}\n\tif (bo)\n\t{\n\t\tjc[0]=1;\n\t\tfor (int i=1; i<=n; i++) jc[i]=1ll*jc[i-1]*i%mod;\n\t\tinv[n]=quickmi(jc[n],mod-2);\n\t\tfor (int i=n; i; i--) inv[i-1]=1ll*inv[i]*i%mod;\n\t\tans=(calc(n)+2ll*calc(n-1))%mod;\n\t\treturn printf(\"%d\\n\",ans),0;\n\t}\n\tla=-1,mi=1000000000,ans=0;\n\tfor (int i=0; i<m; i++)\n\t\tif (s[i]=='B') \n\t\t{\n\t\t\tif ((i-la-1)&1) mi=min(mi,i-la-1);\n\t\t\telse if (la==-1) mi=min(mi,i-la);\n\t\t\tla=i;\n\t\t}\n\tf[0]=sum[0]=1,f[1]=sum[1]=0;\n\tfor (int i=2; i<=n; i++) \n\t{\n\t\tf[i]=sum[i-2]-(i-mi-3<0?0:sum[i-mi-3]);\n\t\tif (f[i]<0) f[i]+=mod;\n\t\tsum[i]=(sum[i-2]+f[i]>=mod?sum[i-2]+f[i]-mod:sum[i-2]+f[i]);\n\t}\n\tfor (int i=0,nw1,nw2; i<=mi&&i<n; i++)\n\t{\n\t\tnw1=(n-i-1-((i&1)^1)>=0?sum[n-i-1-((i&1)^1)]:0);\n\t\tnw2=(n-i-3-(mi-i)>=0?sum[n-i-3-(mi-i)]:0);\n\t\tans+=(nw1<nw2?nw1-nw2+mod:nw1-nw2);\n\t\tif (ans>=mod) ans-=mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5+5;\nconst int mod = 1e9+7;\ninline int add(int a,int b){a+=b;return a>=mod?a-mod:a;}\nchar s[N];\nint n,m,mx;\nint f[N],f2[N],ans;\n\nint main()\n{\n\tcin >> n >> m;\n\tscanf(\"%s\",s+1);\n\tint p;\n\tfor(p=1;p<=m;p++){\n\t\tif(s[p]!=s[1])break;\n\t}\n\tmx=p-1;\n\tif(mx==m){\n\t\tf[0] = f2[0] = ans = 1;\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tif(i>=2)f[i] = f2[i-2];\n\t\t\tf2[i] = add((i-1>=0?f2[i-1]:0),f[i]);\n\t\t\tif(n-i>=2)ans = add(ans, 1ll*f[i]*(n-i)%mod);\n\t\t}\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\tif(n&1)puts(\"0\");\n\tif(mx%2==0)++mx;\n\tfor(int t=0;p<=m;p++){\n\t\tif(s[p]==s[1])++t;\n\t\telse{\n\t\t\tif(t&1)mx = min(mx, t);\n\t\t\tt=0;\n\t\t}\n\t}\n\tn/=2,mx=(mx+1)/2;\n\tf[0]=f2[0]=1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tif(i)\n\t\t{\n\t\t\tf[i]=(mod+f2[i-1]-(i-mx-1>=0?f2[i-mx-1]:0))%mod;\n\t\t\tf2[i]=(f2[i-1]+f[i])%mod;\n\t\t}\n\t\tif(n-i<=mx) ans = add(ans,1ll*(n-i)*f[i]*2%mod);\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)2e6];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(__int128 x) {\n\tif (x == 0) { fast_print('0'); return; }\n\tif (x < 0) {\n\t\tfast_print('-');\n\t\tx = -x;\n\t}\n\t__int128 p = 1;\n\twhile (x / (p * 10)) p *= 10;\n\twhile (p) {\n\t\t__int128 symb = x / p;\n\t\tfast_print((int)symb);\n\t\tx -= p * symb;\n\t\tp /= 10;\n\t}\n};\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n, m;\nstring s;\n\nconst ll MOD = 1e9 + 7;\ntemplate<ll MOD>\nstruct Ring {\n\tll value = 0;\n\tRing() {}\n\tRing(int _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing(ll _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing pow(ll p) const {\n\t\tif (p == 0) return 1;\t\n\t\tif (p & 1) {\n\t\t\treturn Ring(value).pow(p - 1) * value;\n\t\t} else {\n\t\t\tRing sub = Ring(value).pow(p / 2);\n\t\t\treturn sub * sub;\n\t\t}\n\t}\n\tRing inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tvoid operator*=(const Ring<MOD> &b) {\n\t\tvalue *= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator*(Ring<MOD> a, const Ring<MOD> &b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\tvoid operator+=(const Ring<MOD> &b) {\n\t\tvalue += b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator+(Ring a, const Ring &b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\tvoid operator-=(const Ring<MOD> &b) {\n\t\tvalue -= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator-(Ring a, const Ring &b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\tvoid operator/=(const Ring<MOD> &b) {\n\t\t(*this) *= b.inv();\t\n\t}\n\tfriend Ring operator/(Ring a, const Ring &b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\tbool operator==(const Ring<MOD> &b) {\n\t\treturn value == b.value;\n\t}\n\tbool operator!=(const Ring<MOD> &b) {\n\t\treturn value != b.value;\n\t}\n\tfriend void fast_print(const Ring<MOD> &b) {\n\t\tfast_print(b.value);\n\t}\n};\n\ntypedef Ring<MOD> num;\n\nsigned main(signed argc, char *argv[]) {\n\tscan n, m;\n\tscan s;\n\tif (count(s.begin(), s.end(), s[0]) == len(s)) {\n\t\tvector<num> dp(n + 1);\n\t\tvector<num> dpR(n + 1);\n\t\tdp[0] = 1;\n\t\tdpR[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdp[i] = (i >= 2 ? (dpR[i - 2]) : 0);\n\t\t\t// for (int j = 2; j <= i; j++) {\n\t\t\t// \tdp[i] += dp[i - j];\n\t\t\t// }\n\n\t\t\tdpR[i] = dp[i] + dpR[i - 1];\n\t\t}\n\t\tnum final = 0;\n\t\t// for (int a = 0; a <= n; a++) \n\t\t// \tfor (int b = 0; a + b + 1 <= n; b++) \n\t\t// \t\tif (a || b) {\n\t\t// \t\t\tfinal += dp[n - a - b - 1];\n\t\t// \t\t}\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tint sum = n - 1 - i;\n\t\t\tif (sum > 0) {\n\t\t\t\tfinal += dp[i] * (sum + 1);\n\t\t\t}\n\t\t}\n\t\tprint final + 1;\n\t\treturn 0;\n\t}\n\tif (n & 1) {\n\t\tprint 0;\n\t\treturn 0;\n\t}\n\tif (s[0] == 'B') {\n\t\tfor (char &c : s) \n\t\t\tc = (c == 'R') ? 'B' : 'R';\n\t}\n\tint _max = 1e9;\n\tchar pref = '!';\n\tint _size = 0;\n\tfor (int i = 0; i < len(s); i++) {\n\t\tif (s[i] != pref) {\n\t\t\tif ((_size & 1) && pref == 'R')\n\t\t\t\t_max = min(_max, _size);\n\t\t\tif (_max == 1e9 && pref != '!') {\n\t\t\t\t_max = min(_max, _size | 1);\n\t\t\t}\n\t\t\t_size = 1;\n\t\t} else {\n\t\t\t_size++;\n\t\t}\n\t\tpref = s[i];\n\t}\n\tvector<num> dp(n + 1);\n\tvector<num> dpR(n + 1);\n\tdp[0] = 1;\n\tdpR[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint sub = (((i - min(i, _max + 1)) | 1) ^ 1) - 2;\n\t\tdp[i] = dpR[i - 2] - (sub >= 0 ? (dpR[sub]) : 0);\n\t\t// for (int j = 2; j <= min(i, _max + 1); j += 2)\n\t\t\t// dp[i] += dp[i - j];\n\t\tdpR[i] = dp[i] + dpR[i - 2];\n\t}\n\tnum final = 0;\n\t// for (int a = 0; a <= n; a++)\n\t// \tfor (int b = 0; a + b <= min(_max, n); b++)\n\t// \t\tif ((a + b) & 1)\n\t// \t\t\tif (n - a - b - 1 >= 0) {\n\t// \t\t\t\tfinal += dp[n - a - b - 1];\n\t// \t\t\t}\n\tfor (int i = 0; i <= n; i++) {\n\t\tint sum = n - 1 - i;\n\t\tif ((sum & 1) && sum >= 0 && sum <= min(_max, n)) {\n\t\t\tfinal += dp[i] * (sum + 1);\n\t\t}\n\t}\n\tprint final;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nvector<int64_t> fact, seq_inv, fact_inv;\n\nvoid create_fact_mod(int num){\n    fact[0] = 1;\n    fact[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact[i] = fact[i-1] * i % MOD;\n    }\n}\n\nvoid create_seq_inv_mod(int num){\n    seq_inv[0] = 1;\n    seq_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        seq_inv[i] = (MOD - MOD/i) * seq_inv[MOD%i] % MOD;\n    }\n}\n\nvoid create_fact_inv_mod(int num){\n    fact_inv[0] = 1;\n    fact_inv[1] = 1;\n    for(int i=2; i<=num; i++){\n        fact_inv[i] = fact_inv[i-1] * seq_inv[i] % MOD;\n    }\n}\n\nvoid create_mod_tables(int num){\n    fact.resize(num+1);\n    seq_inv.resize(num+1);\n    fact_inv.resize(num+1);\n    create_fact_mod(num);\n    create_seq_inv_mod(num);\n    create_fact_inv_mod(num);\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y){\n    int64_t d = a;\n    if(b != 0){\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nint64_t inv_mod(int64_t a){\n    int64_t x, y;\n    extgcd(a, MOD, x, y);\n    return (MOD + x%MOD) % MOD;\n}\n\ntemplate<typename T>\nstruct BIT {\n    int n;\n    vector<T> dat;\n\n    BIT(int n=0){\n        initialize(n);\n    }\n\n    void initialize(int nin){\n        n = nin;\n        dat.resize(n);\n        for(int i = 0; i<n; i++) dat[i] = 0;\n    }\n\n    T sum(int i){\n        T s = 0;\n        while(i >= 0){\n            add(s, dat[i]);\n            i = (i & (i+1)) - 1;\n        }\n        return s;\n    }\n\n    T sum_between(int i, int j){\n        int64_t res = sum(j);\n        if(i>0) add(res, MOD - sum(i-1));\n        return res;\n    }\n\n    void plus(int i, T x){\n        while(i < n){\n            add(dat[i], x);\n            i |= i+1;\n        }\n    }\n\n    // a[0]+...+a[ret] >= x\n    int lower_bound(T x){\n        int ret = -1;\n        int k = 1;\n        while(2*k <= n) k <<= 1;\n        for( ;k>0; k>>=1){\n            if(ret+k < n && dat[ret+k] < x){\n                x -= dat[ret+k];\n                ret += k;\n            }\n        }\n        return ret + 1;\n    }\n};\n\nvoid solve1(int N){\n    static int64_t dp[200001][2][2] = {0};\n    dp[0][0][0] = dp[0][1][1] = 1;\n    for(int i=0; i<N-1; i++){\n        for(int j=0; j<2; j++){\n            add(dp[i+1][0][j], dp[i][0][j] + dp[i][1][j]);\n            add(dp[i+1][1][j], dp[i][0][j]);\n        }\n    }\n    int64_t ans = (dp[N-1][0][0] + dp[N-1][1][0] + dp[N-1][0][1]) % MOD;\n    cout << ans << endl;\n    exit(0);\n}\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    if(S[0] == 'B'){\n        for(int i=0; i<M; i++) S[i] = (S[i] == 'B' ? 'R' : 'B');\n    }\n    create_mod_tables(200000);\n\n    int len = 0, mn = M;\n    for(int i=0; i<M; i++){\n        if(S[i] == 'R'){\n            len++;\n        }else{\n            if(len > 0) mn = min(mn, len);\n            len = 0;\n        }\n    }\n    if(mn == M){\n        solve1(N);\n    }\n    if(N%2){\n        cout << 0 << endl;\n        return 0;\n    }\n\n    N /= 2;\n    int lim = mn/2+1;\n    BIT<int64_t> bit(N+1);\n    bit.plus(0, 1);\n    for(int i=1; i<=N; i++){\n        int l = max(0, i-lim);\n        int64_t res = bit.sum_between(l, i);\n        bit.plus(i, res);\n    }\n\n    int64_t ans = 0;\n    for(int i=1; i<=min(N, lim); i++){\n        add(ans, i * bit.sum_between(N-i, N-i) % MOD);\n    }\n    mul(ans, 2);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MAX_N 200000\n#define MAX_M 200000\n#define MOD 1000000007\n\n#define INF 1 << 29\n\nint N, M;\nstring S;\n\n// long long dp[MAX_N + 2], rdp[MAX_N + 2];\n\n// int all_color_is_same()\n// {\n//     long long rr = 1, bb = 1, rb = 0, br = 0;\n\n//     for ( int i = 1; i < N; i++ )\n//     {\n//         long long nrr = ( rr + rb ) % MOD;\n//         long long nbb = br;\n//         long long nrb = rr;\n//         long long nbr = ( bb + br ) % MOD;\n\n//         rr = nrr;\n//         bb = nbb;\n//         rb = nrb;\n//         br = nbr;\n//     }\n\n//     return ( rr + rb + br ) % MOD;\n// }\n\n// /**\n\n/* S\nの先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n*/\nint min_freq()\n{\n    int l = 0;\n    while ( l < M && S[0] == S[l] ) l++;\n\n    int ans = ( l & 1 ) ? l : l + 1;\n\n    l = 0;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[0] == S[i] )\n            l++;\n        else\n        {\n            if ( l & 1 ) ans = min( ans, l );\n            l = 0;\n        }\n    }\n    return ( l & 1 ) ? min( ans, l ) : ans;\n}\n\n// int solve()\n// {\n//     // 一色\n//     if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n//         return all_color_is_same();\n\n//     // N が奇数\n//     if ( N & 1 ) return 0;\n\n//     int L = min_freq();\n\n//     L = ( L + 1 ) >> 1;\n//     N >>= 1;\n\n//     dp[0] = rdp[0] = 1;\n//     for ( int i = 1; i <= N + 1; i++ )\n//     {\n//         dp[i] = rdp[i - 1];\n//         if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n//         if ( dp[i] < 0 ) dp[i] += MOD;\n//         rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n//     }\n\n//     long long res = 0;\n//     for ( int i = 1; i <= L; i++ )\n//         if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n//     return res % MOD;\n// }\n\n// int main( int argc, char **argv )\n// {\n//     cin >> N >> M;\n//     cin >> S;\n\n//     int ans = solve();\n\n//     cout << ans << endl;\n\n//     return 0;\n// }\n// #include <algorithm>\n// #include <iostream>\n// #include <string>\n\n// using namespace std;\n\n// #define MOD 1000000007\n// #define INF ( 1 << 29 )\n// #define LINF ( 1LL << 60 )\n// #define EPS ( 1e-10 )\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt all( Int n )\n{ // no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for ( int i = 1; i < n; i++ )\n    {\n        Int nrr = ( rr + rb ) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = ( bb + br ) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return ( rr + rb + br ) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc( Int n, Int limit )\n{\n    dp[0] = 1;\n    rdp[0] = 1;\n    for ( int i = 1; i <= n + 1; i++ )\n    {\n        dp[i] = ( rdp[i - 1] -\n                  ( ( i - limit - 1 ) >= 0 ? rdp[i - limit - 1] : 0 ) ) %\n                MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n}\n\nInt solve( Int n, Int limit )\n{\n    if ( n % 2 == 1 ) return 0;\n    if ( limit % 2 != 1 ) exit( 1 );\n    limit = ( limit + 1 ) / 2;\n    n /= 2;\n    Int res = 0;\n    calc( n + 10, limit );\n    for ( Int i = 1; i <= limit; i++ )\n    {\n        if ( n - i >= 0 ) res = ( res + dp[n - i] * 2 * i ) % MOD;\n    }\n    if ( res < 0 ) exit( 1 );\n    return res % MOD;\n}\n\nint main()\n{\n    cin >> N >> M;\n    cin >> S;\n\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n    {\n        cout << all( N ) << endl;\n        return 0;\n    }\n\n    // Int l = 0;\n    // while ( S[0] == S[l] ) l++;\n    // if ( l % 2 == 0 ) l++;\n    // Int limit = l;\n    // l = 0;\n    // for ( int i = 0; i < M; i++ )\n    // {\n    //     if ( S[i] == S[0] )\n    //         l++;\n    //     else\n    //     {\n    //         if ( l % 2 == 1 ) limit = min( limit, l );\n    //         l = 0;\n    //     }\n    // }\n    int limit = min_freq();\n    cout << solve( N, limit ) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n//#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int M = 1e9 + 7;\n\nvoid solve_fib(int n) {\n    vi f(n + 1);\n    f[0] = f[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        f[i] = (f[i - 1] + f[i - 2]) % M;\n    }\n    cout << (f[n] + f[n - 2]) % M;\n}\nconst int oo = 1e9 + 10;\n\nint kek(int cnt, bool & first) {\n    if (first) {\n        first = false;\n        if (cnt & 1)\n            return cnt;\n        return cnt + 1;\n    }\n    if (cnt & 1)\n        return cnt;\n    return oo;\n}\n\nvoid insum(int &a, int b) {\n    a = (a + b) % M;\n}\n\nvoid smain() {\n\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    m = s.size();\n    if (count(ALL(s), 'R') == 0 || count(ALL(s), 'B') == 0) {\n        solve_fib(n);\n        return;\n    }\n\n    vi a(m);\n    fori (i, m) {\n        a[i] = s[i] == 'R';\n    }\n\n    vi min_sz(2, oo);\n    int cur = -1;\n    int cnt = 0;\n    bool first = true;\n    for (auto c : a) {\n        if (c != cur) {\n            if (cur != -1) {\n                inmin(min_sz[cur], kek(cnt, first));\n            }\n            cur = c;\n            cnt = 1;\n        } else {\n            cnt++;\n        }\n    }\n    vvi f(2);\n    fori (z, 2) {\n        vvi dp(2, vi(n, 0));\n        vvi p(2, vi(n, 0));\n        p[!z][0] = dp[!z][0] = 1;\n        for (int i = 1; i < n; ++i) {\n            fori (zz, 2) {\n                int j = i - min_sz[zz];\n                if (j < i) {\n                    dp[zz][i] = (p[!zz][i - 1] - (j - 2 >= 0 ? p[!zz][j - 2] : 0) + M) % M;\n                }\n            }\n            fori (zz, 2) {\n                p[zz][i] = (dp[zz][i] + (i - 2 >= 0 ? p[zz][i - 2] : 0)) % M;\n            }\n        }\n        f[z] = dp[z];\n    }\n    int ans = 0;\n    fori (z, 2) {\n        for (int sz = 1; sz <= min_sz[z]; sz += 2) if (sz < n) {\n            insum(ans, (ll)f[!z][n - sz] * sz % M);\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: E.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nchar s[200005];\nint f[200005];\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint n,m;\n\tread(n,m);\n\tread(s+1);\n\tchar fir=s[1];\n\tint mn=inf;\n\tfor(int i=1,j=1;i<=m;i=j){\n\t\twhile(s[i]==s[j])++j;\n\t\tif(s[i]==fir){\n\t\t\tif(i==1)chkmin(mn,j-i+(!((j-i)&1)));\n\t\t\telse if((j-i)&1)chkmin(mn,j-i);\n//\t\t\tchkmin(mn,j-i);\n\n\t\t}\n\n\t}\n\tif(mn==m){\n\t\tf[0]=1;\n\t\tint s=0;\n\t\tfor(int i=2;i<=n;++i){\n\t\t\tf[i]=s+i-f[i-1];\n\t\t\ts+=f[i];\n\t\t}\n\t\twrite(f[n]+1,'\\n');\n\t}\n\telse{\n\t\tif(n&1)return write(\"0\\n\");\n\t\tf[0]=1;\n\t\t++mn;\n\t\tfor(int i=2;i<=n;i+=2){\n\t\t\tfor(int j=2;j<=mn && j<i;j+=2)f[i]+=f[i-j];\n\t\t\tif(i<=mn)f[i]+=i;\n\t\t}\n\t\twrite(f[n],'\\n');\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=2e5+20;\nconst int mod=1e9+7;\n\nint n,m;\nchar str[maxn];\nint lim;\nint f[maxn];\n\ninline void CHECK1()\n{\n\tREP(i,1,n)if(str[i]=='B')return;\n\tf[0]=1;f[1]=1;\n\tREP(i,2,n)f[i]=(f[i-1]+f[i-2])%mod;\n\tprintf(\"%d\\n\",(f[n-2]+f[n])%mod);\n\texit(0);\n}\n\ninline void init()\n{\n\tn=read();m=read();\n\tscanf(\"%s\",str+1);\n\tif(str[1]=='B')\n\t{\n\t\tREP(i,1,m)str[i]=str[i]=='B'?'R':'B';\n\t}\n\tCHECK1();\n\tlim=n;\n\tint lstb=0;\n\tREP(i,1,n)\n\t{\n\t\tif(str[i]=='B')\n\t\t{\n\t\t\tint num=i-lstb-1;\n\t\t\tif(lstb==0)chkmin(lim,num+(num+1&1));\n\t\t\telse if(num&1)chkmin(lim,num);\n\t\t\tlstb=i;\n\t\t}\n\t}\n\tlim=lim+1>>1;\n}\n\ninline void doing()\n{\n\tif(n&1)puts(\"0\"),exit(0);\n\tn>>=1;\n\tf[0]=1;int s=1;\n\tREP(i,1,n)\n\t{\n\t\tf[i]=s;\n\t\ts=(s+f[i])%mod;\n\t\tif(i-lim>=0)s=(s-f[i-lim]+mod)%mod;\n\t}\n\t//int ans=f[n>>1];\n\tint ans=0;\n\tREP(i,1,lim)ans=(ans+(ll)i*f[n-i])%mod;\n\tans=(ll)ans*2%mod;\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n¼ÙÉèS[1] = R¡£ÄÇÃ´ÏÔÈ»£¬»·ÉÏ²»»á³öÏÖÁ½¸öÁ¬ÐøµÄ±ß¶¼ÊÇB£¬·ñÔòÔÚËüÃÇ½»µã´¦µÚÒ»²½ÍùÁ½±ß×ß¶¼²»ºÏ·¨\nÌØÅÐµôSÖÐÈ«ÊÇRµÄÇé¿ö£¬¿¼ÂÇÒ»°ãÇé¿ö \nÊ×ÏÈ°ÑËùÓÐÊÇBµÄÎ»ÖÃ¶Ï¿ª£¬ÄÇÃ´¾ÍÐÎ³ÉÁËÈô¸É¸öRµÄÁ¬Ðø¶Î¡£¿ÉÒÔ·¢ÏÖÕâÃ´Ò»¸öÐÔÖÊ£ºÃ¿¸öÁ¬Ðø¶ÎµÄ³¤¶È¾ùÎªÆæÊý\nÖ¤Ã÷¿¼ÂÇ·´Ö¤¡£¼ÙÉèÓÐÒ»¸öÅ¼ÊýµÄ¶Î£¬¿¼ÂÇ¶þ·ÖÍ¼¿ÉÒÔ·¢ÏÖ£¬ÄÇÃ´ÓÐµÄµã×ßµ½ÕâÒ»¶ÎµÄ¶Ëµã¾àÀëÓÀÔ¶ÊÇÅ¼Êý¡¢ÓÐµÄµã×ßµ½ÕâÒ»¶ÎµÄ¶Ëµã¾àÀëÓÀÔ¶ÊÇÆæÊý£¬ÒòÎª¶ËµãÍ¬É«\n¶øSµÄµÚÒ»¶ÎÁ¬ÐøR³¤¶ÈÊÇ¹Ì¶¨µÄ£¬²»ÄÜÍ¬Ê±ÎªÅ¼Êý»òÆæÊý£¬Ã¬¶Ü¡£ËùÒÔ¿ÉÒÔµÃµ½½áÂÛ\nÍ¬Ê±£¬SÖÐÃ¿¸öRµÄÁ¬Ðø¶Î¶¼»á¶Ô»·ÉÏÃ¿¸öRµÄÁ¬Ðø¶ÎÓÐ¸öÉÏ½çµÄÏÞÖÆ \n*/\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int Max_NM(200050);\nconst int MOD(1000000000 + 7);\ntypedef long long int LL;\n\nint N, M, L, F[Max_NM], Pre[Max_NM][2], Ans;\nchar S[Max_NM];\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nconstexpr int Sub(int a, int b)\n{\n\treturn a - b < 0 ? a - b + MOD : a - b;\n}\n\nconstexpr int Mult(int a, int b)\n{\n\treturn a * 1LL * b % MOD;\n}\n\ninline void upd(int &a, int b)\n{\n\ta = Add(a, b);\n}\n\nvoid dp(bool have)\n{\n\tF[1] = 1, Pre[1][1 & 1] = 1;\n\tfor (int i = 2, j;i <= N;++i)\n\t{\n\t\tPre[i][0] = Pre[i - 1][0], Pre[i][1] = Pre[i - 1][1];\n\t\tupd(Pre[i][i & 1], F[i - 2]);\n\t\t//jµ½iÊÇR£¬i - j + 1 <= L   =>   j >= i - L + 1\n\t\t//i - j + 1ÊÇÆæÊý£¬i - jÊÇÅ¼Êý£¬iºÍjÆæÅ¼ÐÔÏàµÈ\n\t\tj = max(1, i - L + 1);\n\t\tif (j <= i)\n\t\t{\n\t\t\tF[i] = Sub(Pre[i][i & 1], Pre[j - 1][i & 1]);\n\t\t\tif (have)\n\t\t\t\tupd(F[i], Sub(Pre[i][(i & 1) ^ 1], Pre[j - 1][(i & 1) ^ 1]));\n\t\t}\n\t}\n\t\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tbool haveB = false;\n\tif (S[1] == 'B')\n\t\tfor (int i = 1;i <= M;++i)\n\t\t\tS[i] = 'R' + 'B' - S[i];\n\tfor (int i = 1;i <= M;++i)\n\t\thaveB |= (S[i] == 'B');\n\tL = N;\n\tfor (int i = 1, length = 0, stop = 0;i <= M;++i)\n\t\tif (S[i] == 'B')\n\t\t\tlength = 0, stop = 1;\n\t\telse\n\t\t{\n\t\t\t++length;\n\t\t\tif (i + 1 <= M && S[i + 1] == 'B')\n\t\t\t\tif (stop == 0)\n\t\t\t\t\tif (length & 1)\n\t\t\t\t\t\tL = min(L, length);\n\t\t\t\t\telse\n\t\t\t\t\t\tL = min(L, length + 1);\n\t\t\t\telse\n\t\t\t\t\tif (length & 1)\n\t\t\t\t\t\tL = min(L, length);\n\t\t}\n\tdp(!haveB);\n\tupd(Ans, F[N - 1]);//edge(1, 2) = B\n\tfor (int x = 1, val;x <= L && x < N;++x)//edge(1, 2) = R\n\t{\n\t\tif (haveB && ((x & 1) == 0))\n\t\t\tcontinue;\n\t\tif (x + 1 == N)\n\t\t\tval = 1;\n\t\telse\n\t\t\tval = F[N - x - 2];\n\t\tupd(Ans, Mult(x, val));\n\t}\n\tif (haveB == false)\n\t\tupd(Ans, 1);\n\tprintf(\"%d\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\ninline void add(int &x,int y){(x+=y)>=mod?x-=mod:0;}\ninline int kpow(int a,int b)\n{\n\tint s=1;\n\tfor(;b;b>>=1,a=1ll*a*a%mod)\n\t\tif(b&1)s=1ll*s*a%mod;\n\treturn s;\n}\nint n,m,jc[200020],jcv[200020],ans,dp[200020];\nchar s[200020];\nvoid init()\n{\n\tjc[0]=1;\n\tfor(int i=1;i<=200000;++i)jc[i]=1ll*jc[i-1]*i%mod;\n\tjcv[200000]=kpow(jc[200000],mod-2);\n\tfor(int i=200000;i;--i)jcv[i-1]=1ll*jcv[i]*i%mod;\n}\ninline int C(int a,int b)\n{\n\tif(a<b)return 0;\n\treturn 1ll*jc[a]*jcv[b]%mod*jcv[a-b]%mod;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d %d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tchar r=s[1];\n\tfor(int i=1;i<=m;++i)s[i]=s[i]==r?0:1;\n\tint last=0,mi=0x3f3f3f3f;\n\tfor(int i=1;i<=m;++i)\n\t\tif(s[i]==1)\n\t\t{\n\t\t\tif(!last)\n\t\t\t{\n\t\t\t\tif(i&1)mi=min(mi,i);\n\t\t\t\telse mi=min(mi,i-1);\n\t\t\t}\n\t\t\telse if((i-last-1)&1)mi=min(mi,i-last-1);\n\t\t\tlast=i;\n\t\t}\n\tif(!last)\n\t{\n\t\tfor(int k=0;k<=n-2-k;++k)add(ans,C(n-2-k,k));\n\t\tadd(ans,ans);\n\t\tfor(int k=0;k<=n-1-k;++k)add(ans,C(n-1-k,k));\n\t\tprintf(\"%d\",ans);\n\t\treturn 0;\n\t}\n\tif(n&1)return printf(\"0\"),0;\n\tn>>=1;mi=mi+1>>1;\n\tint tmp=1;dp[0]=1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tif(i-mi-1>=0)add(tmp,mod-dp[i-mi-1]);\n\t\tdp[i]=tmp;\n\t\tadd(tmp,dp[i]);\n\t}\n\tfor(int i=1;i<=mi;++i)ans=(ans+1ll*dp[n-i]*i)%mod;\n\tadd(ans,ans);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\ntemplate<typename T>\nstruct SegmentTree{\nprivate:\n    int n;\n    T E;\n    vector<T> node;\n    inline void updatef(T& x,T& y){\n        x = y;\n        //x += y;\n        //x = max(x,y);\n        //x = min(x,y);\n    }\n    inline T queryf(T& x,T& y){\n        //return x*y;\n        return (x+y)%mod;\n        //return max(x,y);\n        //return min(x,y);\n    }\n\npublic:\n    SegmentTree(int sz,T E_):E(E_){\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n    }\n\n    SegmentTree(vector<T>& A,T E_):E(E_){\n        int sz=A.size();\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n        rep(i,sz)node[i+n-1]=A[i];\n        for(int i=n-2;i>=0;--i){\n            node[i]=queryf(node[2*i+1], node[2*i+2]);\n        }\n    }\n    void update(int k,T x){\n        k+=n-1;\n        updatef(node[k],x);\n        while(k>0){\n            k=(k-1)/2;\n            node[k]=queryf(node[2*k+1], node[2*k+2]);\n        }\n    }\n       //[a,b)での和を返す\n    T get(int a,int b,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        if(r<=a||b<=l)return E;\n        if(a<=l&&r<=b)return node[k];\n        T xl=get(a,b,2*k+1,l,(l+r)/2);\n        T xr=get(a,b,2*k+2,(l+r)/2,r);\n        return queryf(xl, xr);\n    }\n};\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n    fact.resize(n+1);\n    inv.resize(n+1);\n    invfact.resize(n+1);\n    fact[0]=inv[0]=invfact[0]=1;\n    inv[1]=1;\n    rep(i,n){\n        fact[i+1]=fact[i]*(i+1)%mod;\n        if(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n        invfact[i+1]=invfact[i]*inv[i+1]%mod;\n    }\n}\nll perm(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n    k%=mod-1;\n    if(k<0)k+=mod-1;\n    ll ret=1;\n    while(k){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\nint main(){\n    int n,m;\n    cin>>n>>m;\n    string s;\n    cin>>s;\n    int len=0;\n    while(len<m&&s[len]==s[0])++len;\n    if(len==m){\n        vector<ll> ans(n+1);\n        ans[0]=2,ans[1]=1;\n        rep(i,n-1)ans[i+2]=(ans[i+1]+ans[i])%mod;\n        cout<<ans[n]<<endl;\n        return 0;\n    }\n    if(n%2){\n        cout<<0<<endl;\n        return 0;\n    }\n    if (len%2==0)++len;\n    int cnt=0;\n    rep(i,m){\n        if(s[i]!=s[0]){\n            if(cnt%2)len=min(len,cnt);\n            cnt=0;\n        }\n        else ++cnt;\n    }\n    n/=2;\n    len = (len+1)/2;\n    SegmentTree<ll> sg(n+5,0);\n    sg.update(0,1);\n    rep(i,n+1){\n        ll ret=sg.get(max(0,i+1-len),i+1);\n        sg.update(i+1,ret);\n    }\n    ll ans=0;\n    rep(i,min(n,len)){\n        ans+=sg.get(max(0,n-len),n-i);\n    }\n    cout<<2*ans%mod<<endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=a*b%mod\n\nll n,m;\nstring s;\nll f[200010],rui[200010];\n\nint main(){\n    cin>>n>>m>>s;\n    if(s[0]=='R'){\n\tfor(int i=0;i<m;i++){\n\t    if(s[i]=='R')s[i]='B';\n\t    else s[i]='R';\n\t}\n    }\n    bool th=0;\n    ll cnt=0,mi=1e17;\n    bool fi=1; ll lead;\n    for(int i=0;i<m;i++){\n\tif(s[i]=='R'){\n\t    if(fi)lead=cnt; fi=0;\n\t    th=1;\n\t    if(cnt%2==1)chmin(mi,cnt);\n\t    cnt=0;\n\t}\n\telse cnt++;\n    }\n    if(th==0){\n\tf[0]=f[1]=1;\n\tfor(int i=2;i<n;i++){\n\t    f[i]=(f[i-1]+f[i-2])%mod;\n\t}\n\tll ans=(f[n-2]*2+f[n-1])%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n    }\n    if(n%2==1){\n\tcout<<0<<endl;\n\treturn 0;\n    }\n    \n    if(lead%2==0)lead++;\n    chmin(mi,lead);\n    mi=(mi+1)/2;\n    chmin(mi,n/2);\n    f[0]=rui[0]=0;\n    for(ll i=1;i<=mi;i++){\n\tf[i]=i;\n\trui[i]=(rui[i-1]+i)%mod;\n    }\n    for(int i=1;i<n/2;i++){\n\tmad(f[i],rui[i-1]);\n\tif(i-mi-1>=0)mad(f[i],-rui[i-mi-1]);\n\trui[i]=(rui[i-1]+f[i])%mod;\n    }\n    ll ans=0;\n    for(int i=1;i<=mi;i++)mad(ans,f[n/2-i]);\n    //cout<<mi<<endl;\n    //for(int i=0;i<n/2;i++)cout<<i<<\":\"<<f[i]<<endl;\n    ans=ans*2%mod;\n    if(ans<0)ans+=mod;\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=2e5+10,mod=1e9+7;\ninline void Dec(int &x,int y) { x-=y; if(x<0) x+=mod; }\ninline void Add(int &x,int y) { x+=y; if(x>=mod) x-=mod; }\nchar S[N];\nint n,m,f[N];\nint main() {\n\trd(n),rd(m);\n\tscanf(\"%s\",S+1);\n\tchar c=S[1];\n\tint p=1,r=1,L=m;\n\t\n\twhile(r<=m&&S[r]==c) r++;\n\tif(r==m+1) {\n\t\tif(n==2) { printf(\"3\\n\"); return 0; }\n\t\tf[0]=1,f[1]=2;\n\t\tfor(int i=2;i<=n;++i) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",(f[n-3]+f[n-1])%mod);\n\t\treturn 0;\n\t}\n\t\n\tL=min(L,(r-p)|1);\t\n\tp=r;\n\twhile(p<=m&&S[p]!=c) p++;\n\t\n\tdo {\n\t\tr=p;\n\t\twhile(r<=m&&S[r]==c) r++;\n\t\tif((r-p)&1) L=min(L,r-p);\n\t\tp=r;\n\t\twhile(p<=m&&S[p]!=c) p++;\n\t} while(p<=m);\n\t\n\tint sum[2]={0,0};\n\tf[1]=1,sum[1]=1;\n\tfor(int i=2;i<=n;++i) {\n\t\tf[i]=sum[i&1];\n\t\tif(i-L-1>=1) Dec(sum[i&1],f[i-L-1]);\n\t\tAdd(sum[i&1],f[i]);\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i) {\n\t\tif(n-i>L||!((n-i)&1)) continue;\n\t\tAdd(ans,f[i]*(ll)(n-i+1)%mod);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tstring s;\n\tcin >> s;\n\tset<char>st;\n\tfor (auto i : s)st.insert(i);\n\tif (st.size() == 1) {\n\t\tvector<long long int>dp(N + 1);\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1];\n\t\t\tif (i > 1)dp[i] += dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tlong long int ans = dp.back();\n\t\tdp[0] = 1;\n\t\tdp[1] = 0;\n\t\tfor (int i = 2; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tans += dp.back();\n\t\tans %= MOD;\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\ts.push_back(s[0] + 1);\n\tvector<int>num(s.size() + 1);\n\tfor (int i = 0; i <= s.size(); i++) {\n\t\tnum[i] = s[i] == s[0];\n\t\tif (i)num[i] = num[i] * (num[i - 1] + 1);\n\t}\n\tint fst = 0;\n\tint m = MOD;\n\tbool even = true;\n\tfor (int i = 1; i <= s.size(); i++) {\n\t\tif (!num[i] && num[i - 1]) {\n\t\t\tif (num[i - 1] & 1) {\n\t\t\t\teven = false;\n\t\t\t\tm = min(m, num[i - 1]);\n\t\t\t}\n\t\t\tif (fst == 0) {\n\t\t\t\tfst = num[i - 1];\n\t\t\t\tif (fst % 2 == 0)m = MOD;\n\t\t\t}\n\t\t}\n\t}\n\tif (even) {\n\t\tm = fst + 2;\n\t}\n\telse if (fst % 2 == 0) {\n\t\tm = min(m, fst+2);\n\t}\n\tif (m & 1)m++;\n\tvector<long long int>dp(N + 2);\n\tvector<long long int>sum(N + 2);\n\tfor (int i = 2; i <= m; i += 2)dp[i] = i;\n\tfor (int i = 2; i <= N; i++) {\n\t\tdp[i] += sum[i - 2] + MOD;\n\t\tif (i - m - 2 >= 0)dp[i] -= sum[i - m - 2];\n\t\tdp[i] %= MOD;\n\t\tif (i == N) {\n\t\t\tcout << dp[i] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsum[i] = sum[i - 2] + dp[i];\n\t\tsum[i] %= MOD;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MOD = 1e9 + 7; // change if needed\n\nstruct Modint {\n  ll val;\n  \n  Modint (ll _val = 0)\n    : val(_val % MOD) {}\n\n  Modint operator+ (Modint other) const {\n    return Modint(val + other.val);\n  }\n\n  void operator+= (Modint other) {\n    val += other.val;\n    val %= MOD;\n  }\n\n  Modint operator- () const {\n    return Modint(MOD - val);\n  }\n\n  Modint operator- (Modint other) const {\n    return Modint(val + MOD - other.val);\n  }\n\n  void operator-= (Modint other) {\n    val += MOD - other.val;\n    val %= MOD;\n  }\n\n  Modint operator* (Modint other) const {\n    return Modint(val * other.val);\n  }\n\n  void operator*= (Modint other) {\n    val *= other.val;\n    val %= MOD;\n  }\n\n  bool operator== (Modint other) const {\n    return val == other.val;\n  }\n\n  bool operator!= (Modint other) const {\n    return val != other.val;\n  }\n};\n\nModint exp (Modint a, int k) {\n  if (k == 0) {\n    return Modint(1);\n  } else if (k % 2 == 0) {\n    Modint half = exp(a, k / 2);\n    return half * half;\n  } else {\n    return a * exp(a, k - 1);\n  }\n}\n\nModint inv (Modint a) {\n  return exp(a, MOD - 2);\n}\n\nostream& operator<< (ostream& out, Modint p) {\n  out << p.val;\n  return out;\n}\n\nconst int MAX_N = 2e5 + 5;\n\nModint dp [MAX_N];\nModint cdp [MAX_N];\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  cin >> n >> m;\n\n  string s;\n  cin >> s;\n\n  if (s[0] == 'B') {\n    for (int i = 0; i < m; i++) {\n      if (s[i] == 'R') s[i] = 'B';\n      else s[i] = 'R';\n    }\n  }\n\n  vector<int> blocks;\n  for (int i = 0; i < m; i++) {\n    if (s[i] == 'R') {\n      if (i == 0 || s[i - 1] == 'B') {\n        blocks.push_back(0);\n      }\n      blocks.back()++;\n    }\n  }\n\n  blocks.pop_back();\n\n  if (blocks.empty()) {\n    // special case\n    // just count the # of assignments\n    // such that the blue things are singletons\n    Modint ans (1 + n); // the all-red case\n    dp[1] = Modint(1);\n    cdp[1] = Modint(1);\n    for (int i = 2; i < n; i++) {\n      dp[i] = cdp[i - 2];\n      cdp[i] = cdp[i - 1] + dp[i];\n      ans += Modint(n + 1 - i) * dp[i];\n    }\n    cout << ans << endl;\n    return 0;\n  }\n\n  int ub = n;\n  for (int block : blocks) {\n    if (block % 2 == 1) {\n      ub = min(ub, block + 1);\n    }\n  }\n\n  ub = min(ub, blocks[0] + 1);\n  if (ub % 2 == 1) {\n    ub++;\n  }\n\n  // do some DP to count the # of ways\n  // to split a circle into odd-length pieces\n  // separated by singleton pieces\n  // such that each segment has length <= lb\n\n  if (n % 2 != 0) {\n    cout << 0 << endl;\n    return 0;\n  }\n  \n  Modint ans (0);\n  dp[1] = Modint(1);\n  cdp[1] = Modint(1);\n  if (n <= ub) {\n    ans += Modint(n) * dp[1];\n  }\n  \n  for (int i = 3; i <= n; i += 2) {\n    dp[i] = cdp[i - 2] - cdp[max(0, i - ub - 2)];\n    cdp[i] = cdp[i - 2] + dp[i];\n\n    if (n + 1 - i <= ub) {\n      ans += Modint(n + 1 - i) * dp[i];\n    }\n  }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ΔAGC033E\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 222222;\nconst int MO = 1e9+7;\nchar ch[N];\nint n,m,ans,f[N],s[N];\nint main()\n{\n\tint i,x,y,o;\n\tscanf(\"%d%d%s\",&n,&m,ch+1);\n\tfor(i=1;i<=n;i=i+1)\n\t\tif(ch[i]!=ch[1])\n\t\t\tbreak;\n\to=n;\n\tif(i<=n){\n\t\to=i-1;\n\t\tif(o%2==0)\n\t\t\to++;\n\t\tx=1,y=0;\n\t\tfor(i=i+1;i<=n;i=i+1){\n\t\t\tif(ch[i]==ch[i-1])\n\t\t\t\tx++;\n\t\t\telse{\n\t\t\t\tif(y&&x%2==1)\n\t\t\t\t\to=min(o,x);\n\t\t\t\ty^=1;\n\t\t\t\tx=1;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tf[1]=1;\n\t\ts[1]=1;\n\t\tfor(i=2;i<=n;i=i+1){\n\t\t\tf[i]=s[i-2];\n\t\t\ts[i]=(s[i-1]+f[i])%MO;\n\t\t}\n\t\tx=0;\n\t\tfor(i=1;i<n;i=i+1)\n\t\t\tx+=(LL)f[i]*(n-i+1)%MO,x%=MO;\n\t\tcout<<x;\n\t\treturn 0;\n\t}\n\tif(n&1){\n\t\tcout<<0;\n\t\treturn 0;\n\t}\n\to++;\n\to/=2;\n\tn/=2;\n\tf[1]=1;\n\ts[1]=1;\n\tfor(i=2;i<=n;i=i+1){\n\t\tx=i-o-1;\n\t\tif(x<0)\n\t\t\ty=0;\n\t\telse\n\t\t\ty=s[x];\n\t\tf[i]=(s[i-1]-y+MO)%MO;\n\t\ts[i]=(s[i-1]+f[i]%MO);\n\t}\n\tx=0;\n\tfor(i=n-o+1;i<=n;i=i+1)\n\t\tx+=(LL)f[i]*((n-i+1)*2)%MO,x%=MO;\n\tcout<<x;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+10;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    ans = dp[n+1];\n    for(ll i = 1;i<=lim;i+=2)\n    {\n        ans += (i*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    int mn = 1e9;\n    if (vc[0]%2==0)\n        mn = vc[0]+1;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#define N 201000\ntypedef long long ll;\ntemplate <typename T> inline void read(T &x) {\n\tx = 0; char c = getchar(); bool flag = false;\n\twhile (!isdigit(c)) { if (c == '-')\tflag = true; c = getchar(); }\n\twhile (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }\n\tif (flag)\tx = -x;\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nconst int inf = 987654321;\ninline void MIN(int &a, int b) {\n\tif (b < a)\ta = b;\n}\nint n, m;\nchar s[N];\nnamespace jzp1 {\n\tll jie[N], jieni[N];\n\tinline ll get_c(int n, int m) {\n\t\tif (n < 0 || m < 0 || n - m < 0)\treturn 0;\n\t\treturn jie[n] * jieni[m] % P * jieni[n - m] % P;\n\t}\n\tinline ll quickpow(ll x, int k) {\n\t\tll res = 1;\n\t\twhile (k) {\n\t\t\tif (k & 1)\tres = res * x % P;\n\t\t\tx = x * x % P;\n\t\t\tk >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline void sol() {\n\t\tif (n == 1) { puts(\"1\"); return ; }\n\t\tjie[0] = jieni[0] = 1;\n\t\tint up = n + 1;\n\t\tfor (int i = 1; i <= up; ++i)\tjie[i] = jie[i - 1] * i % P;\n\t\tjieni[up] = quickpow(jie[up], P - 2);\n\t\tfor (int i = up - 1; i; --i)\tjieni[i] = jieni[i + 1] * (i + 1) % P;\n\t\tll res = 0;\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tres = (res + get_c(n - i + 1, i) - get_c(n - i - 1, i - 2)) % P;\n\t\t}\n\t\tprintf(\"%lld\\n\", (res % P + P) % P);\n\t}\n}\nll f[N];\nll sum[N];\nint main() {\n\tread(n), read(m);\n\tscanf(\"%s\", s + 1);\n\tbool flag = false;\n\tint tmp = 0;\n\tfor (int i = 1; i <= m; ++i)\tif (s[i] != s[1]) { flag = true; tmp = i - 1; break; }\n\tif (!flag) { jzp1::sol(); return 0; }\n\tif (n & 1) { puts(\"0\"); return 0; }\n\tint lst = 1, mn = tmp | 1;\n\tfor (int i = 2; i <= m; ++i) {\n\t\tif (s[i] != s[1]) {\n\t\t\tif (lst & 1)\tMIN(mn, lst);\n\t\t\tlst = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == s[i - 1])\t++lst;\n\t\telse {\n\t\t\tif (lst & 1) MIN(mn, lst);\n\t\t\tlst = 1;\n\t\t}\n\t}\n\tn >>= 1;\n\tint k = (mn + 1) >> 1;\n\tMIN(k, n);\n\tf[0] = 1; sum[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (i <= k)\tf[i] = sum[i - 1];\n\t\telse f[i] = (sum[i - 1] - sum[i - k - 1]) % P;\n\t\tsum[i] = (sum[i - 1] + f[i]) % P;\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tans = (ans + f[n - i] * i) % P;\n\t}\n\tans = (ans << 1) % P;\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n\n/*\n3 3\nBBB\n//4\n\n1 1\nB\n//1\n\n12 10\nRRRRBRRRRB\n//78\n\n6 5\nRRBBR\n//8\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint n, m;\nchar s[MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nint main() {\n\tread(n), read(m);\n\tscanf(\"%s\", s + 1);\n\tbool same = true;\n\tfor (int i = 1; i <= m; i++)\n\t\tif (s[i] != s[1]) same = false;\n\tif (same) {\n\t\tstatic int dp[MAXN], sum[MAXN];\n\t\tdp[1] = sum[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tdp[i] = sum[i - 2];\n\t\t\tsum[i] = (sum[i - 1] + dp[i]) % P;\n\t\t}\n\t\tint ans = (sum[n - 1] + 1) % P;\n\t\tfor (int i = 2, j = n - 1; i <= n; i++, j--)\n\t\t\tupdate(ans, sum[j]);\n\t\tprintf(\"%d\\n\", ans);\n\t\treturn 0;\n\t}\n\tint Min = n - (n - 1) % 2;\n\tint last = 0;\n\tfor (int i = 1; i <= m; i++)\n\t\tif (s[i] != s[1]) {\n\t\t\tint len = i - last - 1;\n\t\t\tif (last == 0) chkmin(Min, 2 * len + 1);\n\t\t\tif (len % 2 == 1) chkmin(Min, len);\n\t\t\tlast = i;\n\t\t}\n\tstatic int dp[MAXN], sum[MAXN];\n\tdp[1] = sum[1] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (i % 2 == 1) {\n\t\t\tdp[i] = sum[i - 2];\n\t\t\tupdate(dp[i], P - sum[max(i - Min - 3, 0)]);\n\t\t}\n\t\tsum[i] = (sum[i - 1] + dp[i]) % P;\n\t}\n\tint ans = (sum[n - 1] - sum[max(n - Min - 2, 0)] + P) % P;\n\tfor (int i = 2, j = n - 1; i <= n && j >= n - Min - 2; i++, j--)\n\t\tupdate(ans, (sum[j] - sum[max(n - Min - 2, 0)] + P) % P);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#define N 201000\ntypedef long long ll;\ntemplate <typename T> inline void read(T &x) {\n\tx = 0; char c = getchar(); bool flag = false;\n\twhile (!isdigit(c)) { if (c == '-')\tflag = true; c = getchar(); }\n\twhile (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }\n\tif (flag)\tx = -x;\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nconst int inf = 987654321;\ninline void MIN(int &a, int b) {\n\tif (b < a)\ta = b;\n}\nint n, m;\nchar s[N];\nnamespace jzp1 {\n\tll jie[N], jieni[N];\n\tinline ll get_c(int n, int m) {\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\tif (n < 0 || m < 0 || n - m < 0)\treturn 0;\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\treturn jie[n] * jieni[m] % P * jieni[n - m] % P;\n\t}\n\tinline ll quickpow(ll x, int k) {\n\t\tll res = 1;\n\t\twhile (k) {\n\t\t\tif (k & 1)\tres = res * x % P;\n\t\t\tx = x * x % P;\n\t\t\tk >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline void sol() {\n//\t\twhile(1);\n\t\tif (n == 1) { puts(\"1\"); return ; }\n\t\tjie[0] = jieni[0] = 1;\n\t\tint up = n + 1;\n\t\tfor (int i = 1; i <= up; ++i)\tjie[i] = jie[i - 1] * i % P;\n\t\tjieni[up] = quickpow(jie[up], P - 2);\n\t\tfor (int i = up - 1; i; --i)\tjieni[i] = jieni[i + 1] * (i + 1) % P;\n\t\tll res = 0;\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tres = (res + get_c(n - i + 1, i) - get_c(n - i - 1, i - 2)) % P;\n//\t\t\tprintf(\"res = %lld\\n\", res);\n\t\t}\n\t\tprintf(\"%lld\\n\", (res % P + P) % P);\n\t}\n}\nll f[N];\nll sum[N];\nint main() {\n\tread(n), read(m);\n\tscanf(\"%s\", s + 1);\n\tbool flag = false;\n\tint tmp = 0;\n\tfor (int i = 1; i <= m; ++i)\tif (s[i] != s[1]) { flag = true; tmp = i - 1; break; }\n\tif (!flag) { jzp1::sol(); return 0; }\n\tif (n & 1) { puts(\"0\"); return 0; }\n\tint lst = 1, mn = tmp | 1;\n\tfor (int i = 2; i <= m; ++i) {\n//\t\tprintf(\"i = %d, mn = %d\\n\", i, mn);\n\t\tif (s[i] != s[1]) {\n\t\t\tif (lst & 1)\tMIN(mn, lst);\n\t\t\tlst = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == s[i - 1])\t++lst;\n\t\telse {\n\t\t\tif (lst & 1) MIN(mn, lst);\n\t\t\tlst = 1;\n\t\t}\n\t}\n\tif (mn == inf) {\n//\t\twhile (1);\n\t\tint memo = 1;\n\t\tfor (int i = 1; s[i] == s[1]; ++i) memo = i;\n\t\tmn = memo + 1;\n\t\tprintf(\"memo = %d\\n\", memo);\n\t}\n\tn >>= 1;\n\tint k = (mn + 1) >> 1;\n\tMIN(k, n);\n\tf[0] = 1; sum[0] = 1;\n//\tprintf(\"n = %d, k = %d\\n\", n, k);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (i <= k)\tf[i] = sum[i - 1];\n\t\telse f[i] = (sum[i - 1] - sum[i - k - 1]) % P;\n\t\tsum[i] = (sum[i - 1] + f[i]) % P;\n\t}\n\tll ans = 0, mx = k;\n\tconst int mod = 1e9 + 7;\n\t\tfor(int i = 0 ; i <= n ; ++i)\n\t\tif(n - i <= mx) (ans += (ll)f[i] * (n - i) % mod * 2 % mod) %= mod;\n//\tll ans = 0;\n//\tfor (int i = 1; i <= k; ++i) {\n//\t\tans = (ans + f[n - i] * i) % P;\n//\t}\n//\tans = (ans << 1) % P;\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n\n/*\n3 3\nBBB\n//4\n\n1 1\nB\n//1\n\n12 10\nRRRRBRRRRB\n//78\n\n6 5\nRRBBR\n//8\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll dp[202020][2][2];\nll mo=1000000007;\n\nll dp2[202020];\nll dps[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\tif(S[0]=='B') {\n\t\tFORR(c,S) c='R'+'B'-c;\n\t}\n\tif(count(ALL(S),'B')==0) {\n\t\tdp[0][0][0]=dp[0][1][1]=1;\n\t\tfor(i=1;i<N;i++) {\n\t\t\t(dp[i][0][0]=dp[i-1][0][0]+dp[i-1][0][1])%=mo;\n\t\t\t(dp[i][0][1]=dp[i-1][0][0])%=mo;\n\t\t\t(dp[i][1][0]=dp[i-1][1][0]+dp[i-1][1][1])%=mo;\n\t\t\t(dp[i][1][1]=dp[i-1][1][0])%=mo;\n\t\t}\n\t\tassert(0);\n\t\tcout<<(dp[N-1][0][0]+dp[N-1][0][1]+dp[N-1][1][0])%mo<<endl;\n\t\treturn;\n\t}\n\tint L=0;\n\twhile(S[L]=='R') L++;\n\t\n\tif(L%2==0) L++;\n\t\n\tdp2[0]=dps[0]=dps[1]=1;\n\tfor(i=2;i<=N;i++) {\n\t\tif(i%2==0) {\n\t\t\tdp2[i]=dps[i-2];\n\t\t\tif(i-(L+1)>0) dp2[i]+=mo-dps[i-(L+1)-1];\n\t\t\tdp2[i]%=mo;\n\t\t}\n\t\t(dps[i]=dps[i-1]+dp2[i])%=mo;\n\t\tcout<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=min(L,N-1);i++) {\n\t\tcout<<i<<\" \"<<(i+1)<<\"*\"<<dp2[N-(i+1)]<<endl;\n\t\t(ret+=(i+1)*dp2[N-(i+1)])%=mo;\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nint (*rd)()=read<int>;\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\nconst u32 P=1e9+7;\nu32 &inc(u32 &a, u32 b) {return (a+=b)<P?a:(a-=P);}\nu32 &dec(u32 &a, u32 b) {return (a-=b)&0x80000000?(a+=P):a;}\nu32 sum(u32 a, u32 b) {return inc(a, b);}\nu32 dif(u32 a, u32 b) {return dec(a, b);}\n\nconst int N=2e5+5;\nint n, m;\nu32 f[N];\nchar s[N];\nint main() {\n\tassert(scanf(\"%d%d%s\", &n, &m, s)==3);\n\tif(s[0]=='B') for(int i=0; i<m; ++i) s[i]^='B'^'R';\n\tif(std::count(s, s+m, 'B')==0) {\n\t\tf[0]=f[1]=1;\n\t\tfor(int i=2; i<=n; ++i) f[i]=sum(f[i-1], f[i-2]);\n\t\tprintf(\"%u\\n\", sum(f[n], f[n-2]));\n\t\treturn 0;\n\t}\n\tif(n%2==1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint ml=n;\n\tfor(int l=0, r; l<n; l=r+1) {\n\t\tfor(r=l; r<n&&s[r]=='R'; ++r);\n\t\tif(r==n) break;\n\t\tif(l==0) cmin(ml, r+1); else if((r-l)%2==1) cmin(ml, r-l);\n\t}\n\tml=(ml+1)/2;\n\tn/=2;\n\tu32 s=0;\n\tfor(int i=1; i<=n; ++i) {\n\t\tf[i]=s;\n\t\tif(i<=ml) inc(f[i], 2*i);\n\t\tinc(s, f[i]);\n\t\tif(i>=ml) dec(s, f[i-ml]);\n\t}\n\tprintf(\"%u\\n\", f[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define int long long\nusing namespace std;\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nconst int N = 2e5 + 1000,mod = 1e9 + 7;\nint n,m,k,isfirst = 1,len;\nchar s[N];\nint A[N],B[N],ans;\nsigned main()\n{\n\tk = 0x3f3f3f3f; n = read(); m = read(); scanf(\"%s\",s + 1);\n\tfor(int i = 1;i <= m;i ++)\n\t{\n\t\tif(s[i] != s[1]) {if(isfirst || len & 1) k = min(k,len / 2 + 1); isfirst = len = 0;}\n\t\telse len ++;\n\t}\n\tif(isfirst)\n\t{\n\t\tint x1 = 1,x2 = 0;\n\t\tfor(int i = 1;i <= n;i ++)\n\t\t{\n\t\t\tx2 = (x1 + x2) % mod;\n\t\t\tx1 = (x2 - x1 + mod) % mod;\n\t\t}\n\t\tcout << (2ll * x1 + x2 ) % mod << \"\\n\"; return 0;\n\t}\n\tif(n & 1) {puts(\"0\"); return 0;}\n\tn /= 2; k = min(k,n);\n\tA[0] = B[0] = 1;\n\tfor(int i = 1;i <= n;i ++)\n\t{\n\t\tA[i] = B[i - 1];\n\t\tif(i > k) A[i] = (A[i] - B[i - k - 1] + mod) % mod;\n\t\tB[i] = (B[i - 1] + A[i]) % mod; \n\t}\n\tfor(int i = 1;i <= k;i ++) ans = (ans + 2ll * i * A[n - i]) % mod;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (200010)\n#define P (1000000007)\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c){\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,m,f[N]; char s[N];\nvoid spj(){\n\tint f[N][2];\n\tfor(int i=1;i<=m;i++)if(s[i]=='R')return;\n\tint ans=0; f[1][0]=0,f[1][1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tf[i][0]=f[i-1][1];\n\t\tf[i][1]=(f[i-1][0]+f[i-1][1])%P;\n\t}\n\t(ans+=(f[n][0]+f[n][1])%P)%=P;\n\tf[1][0]=1,f[1][1]=0,f[2][0]=0,f[2][1]=1;\n\tfor(int i=3;i<=n;i++){\n\t\tf[i][0]=f[i-1][1];\n\t\tf[i][1]=(f[i-1][0]+f[i-1][1])%P;\n\t}\n\t(ans+=f[n][1])%=P;\n\tprintf(\"%d\\n\",ans);\n\texit(0);\n}\nint main(){\n\tread(n),read(m);\n\tfor(int i=1;i<=m;i++)readc(s[i]);\n\tif(s[1]=='R'){for(int i=1;i<=m;i++)s[i]^='R'^'B';}\n\tspj(); int lst=m,lim=n,cnt=0; while(s[lst]=='B')lst--;\n\tfor(int i=lst;~i;i--)\n\tif(!i||s[i]=='R'){\n\t\tif(cnt&1)lim=min(lim,cnt+1);\n\t\telse if((!i)&&cnt)lim=min(lim,cnt+2);\n\t\tcnt=0;\n\t}\n\telse cnt++;\n//\tcout<<lim<<endl; \n\tf[0]=f[2]=1;\n\tfor(int i=4;i<=n;i+=2){\n\t\tf[i]=1ll*f[i-2]*2%P;\n\t\tif(i-2>=lim)f[i]=(f[i]-f[i-lim-2]+P)%P;\n\t}\n\tint ans=0;\n\tfor(int i=2;i<=lim;i+=2)\n\t(ans+=1ll*f[n-i]*i%P)%=P;\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n;\nint m;\nstring s;\nint mn = INF;\nll ans ;\nll dp[200005][2][2];\nstruct RMQ{\n\t#define ss (1<<19)\n\tll seg[ss];\n\tvoid update(int k,ll a){\n\t\tk+=ss/2-1; seg[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tseg[k]=(seg[k*2+1]+seg[k*2+2])%mod;\n\t\t}\n\t}\n\tll query(int a,int b,int k,int l,int r){\n\t\tif(r<a || b<l) return 0;\n\t\tif(a<=l && r<=b) return seg[k];\n\t\telse{\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2+1,r);\n\t\t\treturn (vl+vr)%mod;\n\t\t}\n\t}\n}rmq[2];\n\nint main(){\n\tcin>>n>>m>>s;\n\tif(s[0] == 'B'){\n\t\trep(i,m){\n\t\t\tif(s[i] == 'B') s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\t\tint cur = 0;\n\t\tchar ch;\n\t\tbool beg = 0;\n\t\tint C = 0;\n\t\trep(i,m){\n\t\t\tif(i == 0){\n\t\t\t\tch = s[i];\n\t\t\t\tcur = 1;\n\t\t\t}\n\t\t\telse if(ch != s[i]){\n\t\t\t\tif(ch == 'R'){\n\t\t\t\t\tif(cur%2 == 1) mn = min(mn,cur);\n\t\t\t\t\telse if(!beg) mn = min(mn,cur+1);\n\t\t\t\t\tbeg = 1; C++;\n\t\t\t\t}\n\t\t\t\t\tch = s[i];\n\t\t\t\t\tcur = 1;\n\t\t\t//\t\tbeg = 1; C++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse cur++;\n\t\t}\n\t\t\t\tif(ch == 'R'){\n\t\t\t\t\tif(cur%2 == 1) mn = min(mn,cur);\n\t\t\t\t\telse if(!beg) mn = min(mn,cur+1);\n\t\t\t\t\tbeg = 1; C++;\n\t\t\t\t}\n\t\t\t\t//cout<<C<<endl;\n\t\t\t\t\t//ch = s[i];\n\t\t\t\t\tcur = 1;\n\t\t\t//\t\tbeg = 1; C++;\n\t\tif(C == 1){\n\t\t\t//BBが存在しなければOK\n\t\t\tdp[0][0][0] = dp[0][1][1] = 1;\n\t\t\t//cout<<n<<endl;\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\trep(x,2){\n\t\t\t\t\tdp[i+1][0][x] += dp[i][0][x];\n\t\t\t\t\tdp[i+1][1][x] += dp[i][0][x];\n\t\t\t\t\tdp[i+1][0][x] += dp[i][1][x];\n\t\t\t\t\tdp[i+1][0][x] %= mod;\n\t\t\t\t\tdp[i+1][1][x] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<(dp[n-1][0][0]+dp[n-1][0][1]+dp[n-1][1][0])%mod<<endl;\n\t\t}\n\t\telse{\n\t\t\tif(n%2 == 1){\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[0][0][0] = 1;\n\t\t\trmq[0].update(0,1);\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tdp[i][0][0] = rmq[i%2].query(max(0,i-mn-1),i,0,0,(1<<18)-1);\n\t\t\t\trmq[i%2].update(i,dp[i][0][0]);\n\t\t\t}\n\t\t\tll ans = 0;\n\t\t\tfor(int m=1;m<=n;m++){\n\t\t\t\tif(m-1 > mn) continue;\n\t\t\t\tans += dp[n-m][0][0] * 1LL * m % mod;\n\t\t\t}\n\t\t\tcout << (ans%mod+mod)%mod << endl;\n\t\t\n\t\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass finite_field {\n\tconst int md;\n\tconst int sz;\n\tvector<int> fct, fnv;\n\tpublic :\n\t\tfinite_field(\n\t\t\t\tconst int md,\n\t\t\t\tconst int init_factorial_size = 0\n\t\t\t) :\n\t\t\tmd(md), sz(init_factorial_size),\n\t\t\tfct(sz), fnv(sz)\n\t\t\t{\n\t\t\t\tif (sz) {\n\t\t\t\t\tfct[0] = 1;\n\t\t\t\t\tfor (int i = 1; i < sz; i++) fct[i] = prod(fct[i - 1], i);\n\t\t\t\t\tfnv[sz - 1] = inv(fct[sz - 1]);\n\t\t\t\t\tfor (int i = sz - 1; i >= 1; i--) fnv[i - 1] = prod(fnv[i], i);\n\t\t\t\t}\n\t\t\t}\n\t\tinline void add (int& a, const int b) const {\n\t\t\ta += b;\n\t\t\tif (a >= md) a -= md;\n\t\t}\n\t\tinline void sub (int& a, const int b) const {\n\t\t\ta -= b;\n\t\t\tif (a < 0) a += md;\n\t\t}\n\t\ttemplate<class... A> int sum (A... args) const {\n\t\t\tint ret = 0;\n\t\t\tfor (int a : initializer_list<int>{args...}) {\n\t\t\t\tadd(ret, a);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\ttemplate<class... A> int prod (A... args) const {\n\t\t\tlong long ret = 1;\n\t\t\tfor (int a : initializer_list<int>{args...}) {\n\t\t\t\tret *= a;\n\t\t\t\tret %= md;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\t\tvoid mul (int& a, int b) const {\n\t\t\ta = prod(a, b);\n\t\t}\n\t\tinline int inv (int a) const {\n\t\t\ta %= md; if (a < 0) a += md;\n\t\t\tint b = md, u = 0, v = 1;\n\t\t\twhile (a) {\n\t\t\t\tint t = b / a;\n\t\t\t\tb -= a * t; swap(a, b);\n\t\t\t\tu -= v * t; swap(u, v);\n\t\t\t}\n\t\t\tassert(b == 1);\n\t\t\tif(u < 0) u += md;\n\t\t\treturn u;\n\t\t}\n\t\tinline int quat (int a, int b) const {\n\t\t\treturn prod(a, inv(b));\n\t\t}\n\t\tvoid div (int& a, int b) const {\n\t\t\ta = quat(a, b);\n\t\t}\n\t\tinline int binom (int n, int k) const {\n\t\t\tassert(0 <= n && n < sz);\n\t\t\tif (k < 0 || n < k) return 0;\n\t\t\treturn prod(fct[n], fnv[k], fnv[n - k]);\n\t\t}\n};\nint main() {\n\tcin.tie(0); cin.sync_with_stdio(false);\n\tint n, m; string s;\n\tcin >> n >> m >> s;\n\tfinite_field fld(1e9 + 7);\n\tif (s == string(m, s[0])) {\n\t\tint ans = 0;\n\t\tfor (int first = 0; first < 2; first++) {\n\t\t\tvector<int> dp(2, 0);\n\t\t\tdp[first] = 1;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tvector<int> new_dp(2, 0);\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tfor (int x = 0; x < 2; x++) {\n\t\t\t\t\t\tif (j + x < 2) {\n\t\t\t\t\t\t\tfld.add(new_dp[j], dp[x]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tswap(dp, new_dp);\n\t\t\t}\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tif (j + first < 2) {\n\t\t\t\t\tfld.add(ans, dp[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\tif (n & 1) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tvector<int> seqs;\n\tint t = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (s[i] == s[0]) {\n\t\t\t++t;\n\t\t} else {\n\t\t\tseqs.push_back(t);\n\t\t\tt = 0;\n\t\t}\n\t}\n\tint bound = seqs[0];\n\tif (!(bound & 1)) {\n\t\t++bound;\n\t}\n\tfor (int it = 1; it < (int) seqs.size(); it++) {\n\t\tif (seqs[it] % 2 == 1) {\n\t\t\tbound = min(bound, seqs[it]);\n\t\t}\n\t}\n\tn /= 2;\n\tbound /= 2;\n\tint ans = 0;\n\tif (bound == 0) {\n\t\tans = 1;\n\t} else {\n\t\tvector<int> dp(n);\n\t\tvector<int> pref(n + 1);\n\t\tdp[0] = 1;\n\t\tpref[1] = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdp[i] = pref[i];\n\t\t\tif (i - bound - 1 >= 0) {\n\t\t\t\tfld.sub(dp[i], pref[i - bound - 1]);\n\t\t\t}\n\t\t\tpref[i + 1] = fld.sum(pref[i], dp[i]);\n\t\t}\n\t\tfor (int i = n - 1 - bound; i < n; i++) {\n\t\t\tfld.add(ans, fld.prod(dp[i], n - i));\n\t\t}\n\t}\n\tcout << 2 * ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define SZ(x) (int)(x).size()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i, a, b) for (int i=a;i>=b;--i)\n\nconst int MX_N = 2e5+5;\nconst int MX_M = 2e5+5;\nconst int MOD = 1e9+7;\n\nint N, M;\nstring S;\n\nint dp[MX_N];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> N >> M;\n    cin >> S;\n\n    bool same = true;\n    FOR(i,0,M-1){\n        same &= S[i] == S[0];\n    }\n\n    if (same) {\n        // dp[i]: no of ways to color s.t. no 2 consec is B & i-th is R\n        int ans = 0;\n        dp[1] = 0; dp[2] = 1;   // 1st is B\n        FOR(i,3,N){\n            dp[i] = (dp[i-1] + dp[i-2]) % MOD;\n        }\n        ans = (ans + dp[N]) % MOD;           // Nth is R\n        dp[1] = 1; dp[2] = 1;   // 1st is R\n        FOR(i,3,N){\n            dp[i] = (dp[i-1] + dp[i-2]) % MOD;\n        }\n        ans = (ans + (dp[N] + dp[N-1]) % MOD) % MOD; // Nth is R and B\n        cout << ans;\n        return 0;\n    }\n\n    if (N&1) {\n        cout << 0;\n        return 0;\n    }\n\n    int k = -1, kp = -1, cur = 0;\n    FOR(i,0,M-1){\n        if (S[i] != S[0]) {\n            if (k == -1) {\n                if (cur&1) k = cur;\n                else k = cur+1;\n            } else if (cur&1) kp = max(kp,cur);\n            cur = 0;\n        } else ++cur;\n    }\n\n    int L = min(N-1,max(k,kp));\n    N /= 2, L /= 2;\n\n    //cout << \"L is \" << L << endl;\n\n    dp[1] = 1;\n    int sum = 0;\n    FOR(i,2,N){\n        if (i-(L+2) >= 1) {\n            sum = (sum - dp[i-(L+2)] + MOD) % MOD;\n        }\n        if (i-1 >= 1) {\n            sum = (sum + dp[i-1]) % MOD;\n        }\n        dp[i] = sum;\n    }\n\n    int ans = 0;\n    FOR(i,0,L){\n        ans = (ans +  1LL * (i+1) * dp[N-i] % MOD) % MOD;\n    }\n    cout << ans * 2 % MOD;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n;i++){\n        dp[i-1] = dp[i];\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)\n            tmp[i] = dp[n-i];\n    }\n    for(int i = limit-1;i >= 0;i--){\n        tmp[i] += tmp[i+1];\n        tmp[i] %= MOD;\n    }\n    for(int i = 1;i <= limit;i++){\n        res = (res + tmp[i] * 2) % MOD;\n    }\n    return res;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    bool ok = true;\n    for(auto elem:vec)ok &= elem == 0;\n    if(ok){\n        cout << all(n) << endl;\n        return 0;\n    }\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    vec.push_back(1);\n    for(int i = 0;i <= n;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define pld pair <ld, ld>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n#define cld complex <double>\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 3e5;\nconst ll mod = 1e9 + 7;\n\nll n, m, k, t;\n\nstring s;\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;\n}\n\nll simple() {\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    ll q;\n    for (q = 1; q < n; q++) {\n        D[q] += D[q - 1];\n        if (q >= 2) {\n            D[q] += D[q - 2];\n            D[q] %= mod;\n        }\n    }\n    return (D[n - 2] * 2 + D[n - 1]) % mod;\n    // if (n % 2 == 1) {\n    //     return \n    // }\n    // return step(2, n / 2 + 1);\n}\n\nint main() {\n    pyshnapyshnakaa\n    ll q, w, e, a, b, c;\n    cin >> n >> m;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (q = 0; q < s.length(); q++) {\n            if (s[q] == 'R') {\n                s[q] = 'B';\n            }\n            else {\n                s[q] = 'R';\n            }\n        }\n    }\n    bool fail = 0, blue = 0;\n    for (q = 0; q < s.length(); q++) {\n        if (s[q] == 'B') {\n            blue = 1;\n        }\n        if (q >= 1) {\n            if (s[q - 1] == s[q] && s[q] == 'B') {\n                fail = 1;\n            }\n        }\n    }\n    if (fail) {\n        cout << 0;\n        return 0;\n    }\n    if (!blue) {\n        cout << simple();\n        return -1;\n    }\n    ll mx = maxn, cur = 0;\n    for (q = 0; q < s.length(); q++) {\n        if (s[q] == 'B') {\n            if (cur % 2 == 1) {\n                mx = min(mx, cur);\n            }\n            else {\n                mx = min(mx, cur + 1);\n            }\n            cur = 0;\n        }\n        else {\n            cur++;\n        }\n    }\n    vector <ll> S(2);\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    S[0] = 1;\n    for (q = 1; q < n; q++) {\n        D[q] = S[q % 2];\n        S[q % 2] = (S[q % 2] + D[q]) % mod;\n        ll deli = q - mx - 1;\n        if (deli >= 0) {\n            // cout << \"DELETING \" << q << endl;\n            S[deli % 2] = (S[deli % 2] - D[deli] + mod) % mod;\n        }\n        // cout << q << \" \" << D[q] << endl;\n    }\n    // cout << \"mx \" << mx << endl;\n    ll ans = 0;\n    for (q = 0; q < n; q++) {\n        ll len = n - q - 1;\n        if (len % 2 == 0 || len > mx) {\n            continue;\n        }\n        ans += D[q] * (len + 1) % mod;\n        ans %= mod;\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define SZ(x) (int)(x).size()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i, a, b) for (int i=a;i>=b;--i)\n\nconst int MX_N = 2e5+5;\nconst int MX_M = 2e5+5;\nconst int MOD = 1e9+7;\n\nint N, M;\nstring S;\n\nint dp[MX_N];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> N >> M;\n    cin >> S;\n\n    bool same = true;\n    FOR(i,0,M-1){\n        same &= S[i] == S[0];\n    }\n\n    if (same) {\n        // dp[i]: no of ways to color s.t. no 2 consec is B & i-th is R\n        int ans = 0;\n        dp[1] = 0; dp[2] = 1;   // 1st is B\n        FOR(i,3,N){\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        ans += dp[N];           // Nth is R\n        if (ans >= MOD) ans -= MOD;\n        dp[1] = 1; dp[2] = 1;   // 1st is R\n        FOR(i,3,N){\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        ans += dp[N];           // Nth is R\n        if (ans >= MOD) ans -= MOD;\n        ans += dp[N-1];         // Nth is B\n        if (ans >= MOD) ans -= MOD;\n        cout << ans;\n        return 0;\n    }\n\n    int k = -1, kp = -1, cur = 0;\n    bool inv = (S[0] == 'B');\n    FOR(i,0,M-1){\n        if (inv) S[i] = (S[i] == 'R' ? 'B' : 'R');\n        if (S[i] == 'B') {\n            if (k == -1) {\n                if (cur&1) k = cur;\n                else k = cur+1;\n            } else if (cur&1) kp = max(kp,cur);\n            cur = 0;\n        } else ++cur;\n    }\n\n    if (N&1) {\n        cout << 0;\n        return 0;\n    }\n\n    int L = max(k,kp);\n    assert(L&1);\n\n    N /= 2, L /= 2;\n\n    //cout << \"L is \" << L << endl;\n\n    dp[1] = 1;\n    int sum = 0;\n    FOR(i,2,N){\n        if (i-(L+2) >= 1) {\n            sum -= dp[i-(L+2)];\n            if (sum < 0) sum += MOD;\n        }\n        if (i-1 >= 1) {\n            sum += dp[i-1];\n            if (sum >= MOD) sum -= MOD;\n        }\n        dp[i] = sum;\n    }\n\n    int ans = 0;\n    FOR(i,0,L){\n        ans += 1LL * (i+1) * dp[N-i] % MOD;\n        if (ans >= MOD) ans -= MOD;\n    }\n    cout << ans * 2 % MOD;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long prime = 1000000007;\n\nbool all_chars_equal(string s) {\n    for (char c : s) {\n        if (c != s[0]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> get_runs(string s) {\n    vector<int> runs;\n    int current_run = 0;\n    for (char c : s) {\n        if (c == s[0]) {\n            ++current_run;\n        } else if (current_run > 0) {\n            runs.push_back(current_run);\n            current_run = 0;\n        }\n    }\n    return runs;\n}\n    \nlong long f(int n, int k) {\n    vector<long long> pow_2(2 * k + 4);\n    pow_2[0] = 1LL;\n    for (int i = 1; i < 2 * k + 4; ++i) {\n        pow_2[i] = pow_2[i - 1] * 2 % prime;\n    }\n\n    vector<long long> f1(max(n + 1, 2 * k + 4), 0);\n    for (int i = 1; i <= k; ++i) {\n        f1[i] = pow_2[i];\n    }\n    f1[k + 1] = (pow_2[k+1] - 1 + prime) % prime;\n    for (int n1 = k + 2; n1 <= 2 * k + 3; ++n1) {\n        f1[n1] = ((pow_2[n1] - 1 - n1 * pow_2[n1 - k - 2]) % prime + prime) % prime;\n    }\n    for (int n1 = 2 * k + 4; n1 <= n; ++n1) {\n        f1[n1] = ((2 * f1[n1 - 1] - f1[n1 - k - 2]) % prime + prime) % prime;\n    }\n    return f1[n];\n}\n\n/*\nf(n, k) = antal cirkler af længde n med højst k røde i streg (ingen andre begrænsninger)\n\nf(n, k) = 2^n for n <= k\nf(n, k) = 2^n - 1 for n = k+1\nf(n, k) = 2^n - 1 - n * 2^{n-k-2} for k+2 <= n <= 2k+3\nf(n, k) = 2f(n-1, k) - f(n-k-2, k) for n >= 2k + 4\n\n*/\n\nlong long different_case(int n, int k) {\n    return f(n / 2, (k - 1) / 2) * 2LL % prime;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    string s;\n    cin >> n >> m;\n    cin >> s;\n    auto t0 = clock();\n    if (all_chars_equal(s)) {\n        cout << f(n, 1) << endl;  // OK since n >= 2\n        cerr << \"Time used: \" << clock() - t0 << \" ms\" << endl;\n        return 0;\n    }\n    if (n % 2 != 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n    vector<int> runs = get_runs(s);\n    int bound = runs[0] / 2 * 2 + 1;\n    bound = min(bound, n - 1);\n    for (int run : runs) {\n        if (run % 2 == 1) {\n            bound = min(bound, run);\n        }\n    }\n    cout << different_case(n, bound) << endl;\n\n    cerr << \"Time used: \" << clock() - t0 << \" ms\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 1000000007;\n\nconst long long MOD_CONST = 1000000007;\nlong long mul_mod(long long a, long long b, const long long MOD) {\n  return b ? (mul_mod(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow_mod(long long a, long long b, const long long MOD) {\n  return (b ? bpow_mod(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv_mod(long long a, const long long MOD) {\n  return bpow_mod(a, MOD - 2, MOD);\n}\ntemplate <long long param = MOD_CONST, bool fast = false>\nclass mint {\n private:\n  using Z = int;\n  using N = unsigned int;\n  using ZZ = long long;\n  using NN = unsigned long long;\n  struct {\n  } constexpr static exact{};\n  // Using Z deliberately to avoid Z -> N promotion.\n  template <class Ret = ZZ&>\n  static auto modulo() -> std::enable_if_t<(param <= 0), Ret> {\n    static ZZ mod = 0;\n    return mod;\n  }\n  template <class Ret = const ZZ>\n  static auto mod() -> std::enable_if_t<(param <= 0), Ret> {\n    return modulo();\n  }\n  template <class Ret = const ZZ>\n  static constexpr auto mod() -> std::enable_if_t<(param > 0), Ret> {\n    return param;\n  }\n\n public:\n  template <class Arg = ZZ>\n  static void set_modulo(const std::enable_if_t<(param <= 0), Arg> mod) {\n    modulo() = mod;\n  }\n  long long v;\n\n  constexpr mint() : v(0) {}\n\n  constexpr mint(long long v)\n      : v(fast ? (v)\n               : (v < 0 ? (v % mod() + mod()) % mod()\n                        : (v >= mod() ? v % mod() : v))) {}\n  constexpr long long get_mod() { return mod(); }\n  long long get_val() { return v; }\n  void take_mod() { v %= mod(); }\n};\ntemplate <long long param, bool fast>\nostream& operator<<(ostream& os, mint<param, fast>& x) {\n  return os << (x.v % x.get_mod() + x.get_mod()) % x.get_mod();\n}\n\ntemplate <long long param, bool fast, bool fast2>\nbool operator==(mint<param, fast>& a, mint<param, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast>& operator+=(mint<param, fast>& a, mint<param, fast2> b) {\n  return a = a.v + b.v;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, mint<param> b) {\n  return a = a.v - b.v;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, mint<param> b) {\n  return a = a.v * b.v;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, mint<param> b) {\n  return a = a.v * inv_mod(b.v, a.get_mod());\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast> operator+(mint<param, fast> a, mint<param, fast2> b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, mint<param> b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, mint<param> b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, mint<param> b) {\n  return a /= b;\n}\ntemplate <long long param, bool fast>\nmint<param, fast>& operator+=(mint<param, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, long long b) {\n  return a = a.v * inv_mod(b, a.get_mod());\n}\ntemplate <long long param, bool fast>\nmint<param, fast> operator+(mint<param> a, long long b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, long long b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, long long b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, long long b) {\n  return a /= b;\n}\n\nvoid special(int N) {\n  vector<mint<>> vals = {mint<>(1), mint<>(1)};\n  for (int i = 0; i < N; i++) {\n    int sz = vals.size();\n    vals.push_back(vals[sz - 1] + vals[sz - 2]);\n  }\n  mint<> ans = vals[N] + vals[N - 2];\n  cout << ans << endl;\n}\n\nint con(string& S, char t) {\n  int ans = 1000000;\n  int cur = 0;\n  for (auto c : S) {\n    if (c == t)\n      cur++;\n    else {\n      if (cur != 0) ans = min(ans, cur);\n      cur = 0;\n    }\n  }\n  // chmin(ans, cur);\n  return ans;\n}\n\nmint<> calcDP(int N, int conB, int conR) {\n  vector<mint<>> dpR(N + 2, mint<>(0));\n  vector<mint<>> dpB(N + 2, mint<>(0));\n  vector<mint<>> sumR(N + 2, mint<>(0));\n  vector<mint<>> sumB(N + 2, mint<>(0));\n  dpR[1] = 1;\n  sumR[1] = 1;\n  for (int i = 2; i <= N + 1; i++) {\n    if (i % 2 == 1) {\n      dpR[i] = sumB[i - 1] - sumB[max(0, i - conR - 1)];\n      // if (i <= conB) dpR[i] += 1;\n\n    } else\n      dpB[i] = sumR[i - 1] - sumR[max(0, i - conB - 1)];\n    sumB[i] = sumB[i - 1] + dpB[i];\n    sumR[i] = sumR[i - 1] + dpR[i];\n  }\n  mint<> ans = 0;\n  for (int i = 0; i < min(N, conB + 1); i++) {\n    ans += sumR[N - i] - sumR[max(0, N - conB - 2)];\n  }\n  return ans;\n}\n\nvoid solve(long long N, long long M, std::string S) {\n  int cntB = 0;\n\n  int conR = con(S, 'R');\n  int conB = con(S, 'B');\n  for (int i = 0; i < M; i++) {\n    if (S[i] == 'B') cntB++;\n  }\n  if (cntB == M || cntB == 0) {\n    special(N);\n    return;\n  }\n  if (N % 2 == 1) {\n    cout << 0 << endl;\n    return;\n  }\n  if (S[0] == 'R') swap(conR, conB);\n  conR = 1;\n  if (conB % 2 == 0) conB++;\n  // if (conR % 2 == 0) conR--;\n\n  mint<> ans = calcDP(N, conB, conR);\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long M;\n  scanf(\"%lld\", &M);\n  std::string S;\n  std::cin >> S;\n  solve(N, M, S);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nint gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);}\n\n#define ll long long\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=2e5+500;\nconst ll mod=1e9+7;\nconst ll inf=1e9+9;\n\nll dp[maxn];\nll par[maxn];\nvoid update(ll a){\n\tif(a<2)par[a]=dp[a];\n\tpar[a]=(par[a-2]+dp[a])%mod;\t\n}\nll find_sum(ll l,ll r){\n\tif(!(l<=r))return 0;\n\tl=max(l,0LL);\n\tif(l%2!=r%2){\n\t\treturn find_sum(l+1,r);\n\t}\n\tif(l<2)return par[r];\n\treturn (par[r]-par[l-2]+mod)%mod;\n}\n\n\nll find_ans(ll n,ll s){\n\tif(s%2==0)s--;\n\tmemset(dp,0,sizeof dp);\n\tmemset(par,0,sizeof par);\n\n\tdp[0]=1;\n\tdp[1]=0;\n\tupdate(1);\n\tupdate(0);\n\tfor(ll i=2;i<=n;i++){\n\t\tdp[i]=find_sum(i-s-1,i-2);\n\t\tupdate(i);\n\t}\n\tll ans=0;\n\tfor(ll i=2;i<=n && i-1<=s;i++){\n\t\tll lp=0;\n\t\tif((i-1)%2==0)lp=1;\n\t\tll rp=s-i+1;\n\t\t\n\t\tll lw=n-i-rp;\n\t\tll rw=n-i-lp;\n\n\t\tans+=find_sum(lw,rw);\n\t}\n\tans+=dp[n];\n\treturn ans%mod;\n}\nstring ok(string s,ll m){\n\tif(s[0]=='B'){\n\t\tfor(ll i=0;i<m;i++){\n\t\t\tif(s[i]=='B'){\n\t\t\t\ts[i]='R';\n\t\t\t}else{\n\t\t\t\ts[i]='B';\n\t\t\t}\n\t\t}\n\t}\n\treturn s;\n}\nint main(){\n\tll n,m;\n\tstring s;\n\tcin>>n>>m>>s;\n\ts=ok(s,m);\n\tvector<ll> vec;\n\tll res=0;\n\tfor(ll i=0;i<m;i++){\n\t\tif(s[i]=='R'){\n\t\t\tres++;\n\t\t}\n\t\tif(res!=0 && (i==m-1 || s[i]=='B')){\n\t\t\tvec.pb(res);\n\t\t\tres=0;\n\t\t}\n\t}\n\tll si=inf;\n\tif(vec[0]==m){\n\t\texit(1);\n\t\tdp[2]=1;\n\t\tdp[1]=1;\n\t\tfor(ll i=3;i<=n;i++){\n\t\t\tdp[i]=(dp[i-2]+dp[i-1])%mod;\n\t\t}\n\t\tll ans=1;\n\t\tfor(ll i=2;i<=n;i++){\n\t\t\tans+=dp[n-i+1];\n\t\t}\n\t\tans+=dp[n-1];\n\t\tcout<<ans%mod;\n\t\treturn 0;\n\t}\n\tfor(auto v:vec){\n\t\tif(v%2==1)si=min(si,v);\n\t}\n\tsi=min(si,vec[0]+1);\n\tcout<<find_ans(n,si)<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<bits/stdc++.h>\n#define uc unsigned char\nusing namespace std;\nunordered_map<uc,int>ma[190][190][190];\nint H,W;\nint sm[190][190];\nint lg[190];\nchar ss[190][190];\n\nbool query(uc x,uc y,uc l,uc r) {\n\tint orz = sm[y][r]+sm[x-1][l-1]-sm[x-1][r]-sm[y][l-1];\n\tif(orz==0||orz==(y-x+1)*(r-l+1)) return 1;\n\treturn 0;\n}\n\nuc dfs(uc x,uc y,uc l,uc r) {\n\tif(ma[x][y][l].count(r)) return ma[x][y][l][r];\n\tif(query(x,y,l,r)) return ma[x][y][l][r] = 0;\n\tuc ans = lg[y-x+1] + lg[r-l+1];\n\tint L = x; int R = y+1;\n\twhile(L+1<R) {\n\t\tint mid = (L+R)>>1;\n\t\tuc a = dfs(x,mid-1,l,r);\n\t\tuc b = dfs(mid,r,l,r);\n\t\tif(min(a,b)+1>=ans) break;\n\t\tans = min((uc)ans,(uc)(max(a,b)+1) );\n\t\tif(a>=b) R = mid-1;\n\t\telse L = mid+1;\n\t}\n\tL = l; R = r+1;\n\twhile(L+1<R) {\n\t\tint mid = (L+R)>>1;\n\t\tuc a = dfs(x,y,l,mid-1);\n\t\tuc b = dfs(x,y,mid,r);\n\t\tif(min(a,b)+1>=ans) break;\n\t\tans = min(ans,(uc)(max(a,b)+1) );\n\t\tif(a>=b) R = mid-1;\n\t\telse L = mid+1;\n\t}\n\treturn ma[x][y][l][r] = ans;\n}   \n\nint main() {\n\tscanf(\"%d%d\",&H,&W);\n\tfor(int i=0;i<=185;i++) while((1<<lg[i])<i) lg[i]++;\n\tfor(int i=1;i<=H;i++) {\n\t\tscanf(\"%s\",&ss[i][1]);\n\t\tfor(int j=1;j<=W;j++) {\n\t\t\tsm[i][j] = sm[i-1][j] + sm[i][j-1] - sm[i-1][j-1] + (ss[i][j]=='#' ?1:0 );\n\t\t}\n\t}\n\tprintf(\"%d\",(int)dfs(1,H,1,W) );\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[2160000];\nInt rdp[2160000];\nInt dp[2160000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n+10, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    if(str.size() != m)return 1;\n    bool allsame = true;\n    for(int i = 0;i < m;i++)allsame &= (str[i] == str[0]);\n    if(allsame){\n        cout << all(n) << endl;\n        return 0;\n    }\n    for(int i = 0;i < m;i++)vec.push_back(str[i] == str[0]);\n    vec.push_back(0);\n    Int l = 0;\n    while(vec[l] == 1)l++;\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i < vec.size();i++){\n        if(vec[i] == 1)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst ll N=2e5+10,mo=1e9+7;\nll f[N],n,m,lim,q[N];\nchar s[N];\nvoid move(ll &a,ll b){a=(a+b)%mo;}\nint main(){\n\tcin>>n>>m;\n\tscanf(\"%s\",s+1);\n\tif (s[1]=='B'){\n\t\tfor (ll i=1;i<=m;i++)s[i]='B'+'R'-s[i];\n\t}\n\tll cnt=0;\n\tfor (ll i=1;i<=m;i++){\n\t\tif (s[i]=='R')cnt++;\n\t\telse {\n\t\t\tif (!lim)lim=cnt|1;\n\t\t\telse if (cnt&1)lim=min(lim,cnt);\n\t\t\tcnt=0;\n\t\t}\n\t}\n\tif (!lim){\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tmove(f[i],q[i-2]+i-(i==1));\n\t\t\tq[i]=(q[i-1]+f[i])%mo;\n\t\t}\n\t\tcout<<f[n]+1<<endl;\n\t\treturn 0;\n\t}\n\tlim++;\n\tfor (ll i=1;i<=n;i++){\n\t\tf[i]=q[i-2];\n\t\tif (i<=lim&&(i%2==0))move(f[i],i);\n\t\tq[i]=((ll)q[i-2]+f[i]-(i>lim?f[i-lim]:0)+mo)%mo;\n\t}\n\tcout<<f[n]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n        if(dp[i-1] < 0)dp[i-1] %= MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    return res;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        return 0;\n        cout << all(n) << endl;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i <= m;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // clang-format off\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define in2(s,t)     rep(i,sz(s)){in(s[i] , t[i]);}\n#define in3(s,t,u)   rep(i,sz(s)){in(s[i] , t[i] , u[i]);}\n#define in4(s,t,u,v) rep(i,sz(s)){in(s[i] , t[i] , u[i] , v[i]);}\n#ifdef ONLINE_JUDGE\n  #define rep(i,N) for(int i = 0; i < (int)(N); i++)\n  #define repr(i,N) for(int i = (int)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(int i = 1; i <= (int)(N) ; i++)\n  #define repr1(i,N) for(int i = (N) ; (int)(i) > 0 ; i--)\n#else\n  #define rep(i,N) for(long long i = 0; i < (long long)(N); i++)\n  #define repr(i,N) for(long long i = (long long)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(long long i = 1; i <= (long long)(N) ; i++)\n  #define repr1(i,N) for(long long i = (N) ; (long long)(i) > 0 ; i--)\n#endif\nusing namespace std; void solve();\nusing ll = long long; template<class T = ll> using V = vector<T>;\nusing vi = V<int>; using vl = V<>; using vvi = V< V<int> >;\nusing vd = V<double>; using vs = V<string>; using vvl = V< V<> >;\nconstexpr int inf = 1001001001; constexpr ll infLL = (1LL << 61) - 1;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T,typename U>ll ceil(T a,U b){return (a + b - 1) / b;}\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); for(int i=0;i<s;i++) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);} while(0)\n  #define trcc(v) do { cerr << \"name : \" << #v << \"\\n\"; int cnt = 0; each(x , v){cerr << (cnt++) << \" : \"; trc(x); } } while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  #define trcc(...)\n  int main(){solve();}\n#endif\n\nconstexpr ll TEN(int n){ll ret=1,x=10;while(n){if(n&1)ret*=x;x*=x;n>>=1;}return ret;}\n#define mem(a, val) memset(a, val, sizeof(a))\n\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\nusing P = pair<ll,ll>; using vp = V<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n// clang-format on\n////////////////////////////////////////////////////\n\n\nvector<pair<char,int>> RunLengthEncoding(string& S){\n  vector<pair<char,int>> ret;\n  char c = -1;\n  int n = 0;\n  for(char x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate<typename T>\nvector<pair<T,int>> RunLengthEncoding(vector<T>& S){\n  vector<pair<T,int>> ret;\n  T c = -1;\n  int n = 0;\n  for(T& x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\nusing mint = modint;\n\nnamespace FastFourierTransform {\n  using real = double;\n\n  struct C {\n    real x, y;\n\n    C() : x(0), y(0) {}\n\n    C(real x, real y) : x(x), y(y) {}\n\n    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }\n\n    inline C conj() const { return C(x, -y); }\n  };\n\n  const real PI = acosl(-1);\n  int base = 1;\n  vector< C > rts = { {0, 0},\n                     {1, 0} };\n  vector< int > rev = {0, 1};\n\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    while(base < nbase) {\n      real angle = PI * 2.0 / (1 << (base + 1));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        real angle_i = angle * (2 * i + 1 - (1 << base));\n        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n      }\n      ++base;\n    }\n  }\n\n  void fft(vector< C > &a, int n) {\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          C z = a[i + j + k] * rts[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n  }\n\n  vector< int64_t > multiply(const vector< int > &a, const vector< int > &b) {\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = C(x, y);\n    }\n    fft(fa, sz);\n    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n      fa[i] = z;\n    }\n    for(int i = 0; i < (sz >> 1); i++) {\n      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n      fa[i] = A0 + A1 * s;\n    }\n    fft(fa, sz >> 1);\n    vector< int64_t > ret(need);\n    for(int i = 0; i < need; i++) {\n      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n    }\n    return ret;\n  }\n};\n\ntemplate< typename T >\nstruct ArbitraryModConvolution {\n  using real = FastFourierTransform::real;\n  using C = FastFourierTransform::C;\n\n  ArbitraryModConvolution() = default;\n\n  vector< T > multiply(const vector< T > &a, const vector< T > &b, int need = -1) {\n    if(need == -1) need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while((1 << nbase) < need) nbase++;\n    FastFourierTransform::ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < (int)a.size(); i++) {\n      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);\n    }\n    fft(fa, sz);\n    vector< C > fb(sz);\n    if(a == b) {\n      fb = fa;\n    } else {\n      for(int i = 0; i < (int)b.size(); i++) {\n        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);\n      }\n      fft(fb, sz);\n    }\n    real ratio = 0.25 / sz;\n    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C a1 = (fa[i] + fa[j].conj());\n      C a2 = (fa[i] - fa[j].conj()) * r2;\n      C b1 = (fb[i] + fb[j].conj()) * r3;\n      C b2 = (fb[i] - fb[j].conj()) * r4;\n      if(i != j) {\n        C c1 = (fa[j] + fa[i].conj());\n        C c2 = (fa[j] - fa[i].conj()) * r2;\n        C d1 = (fb[j] + fb[i].conj()) * r3;\n        C d2 = (fb[j] - fb[i].conj()) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector< T > ret(need);\n    for(int i = 0; i < need; i++) {\n      int64_t aa = llround(fa[i].x);\n      int64_t bb = llround(fb[i].x);\n      int64_t cc = llround(fa[i].y);\n      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;\n      ret[i] = aa + (bb << 15) + (cc << 30);\n    }\n    return ret;\n  }\n};\n\ntemplate< int mod >\nstruct NumberTheoreticTransform {\n\n  int base, max_base, root;\n  vector< int > rev, rts;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while(tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while(n > 0) {\n      if(n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) {\n    return mod_pow(x, mod - 2);\n  }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long) mod;\n  }\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while(base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n\n  void ntt(vector< int > &a) {\n    const int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n\n  vector< int > multiply(vector< int > a, vector< int > b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for(int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n\n  vector<modint> multiply_for_fps(const vector<modint> &a,const vector<modint> &b){\n    vector<int> A(a.size()) , B(b.size());\n    for(int i = 0;i < (int)a.size(); i++) A[i] = a[i].x;\n    for(int i = 0;i < (int)b.size(); i++) B[i] = b[i].x;\n    auto C = multiply( A , B );\n    vector<modint> ret(C.size());\n    for(int i = 0; i < (int)C.size() ;i++) ret[i].x = C[i];\n    return ret;\n  }\n};\n\n\ntemplate< typename T >\nstruct FormalPowerSeries : vector< T > {\n  using vector< T >::vector;\n  using P = FormalPowerSeries;\n\n  using MULT = function< P(P, P) >;\n\n  static MULT &get_mult() {\n    static MULT mult = nullptr;\n    return mult;\n  }\n\n  static void set_fft(MULT f) {\n    get_mult() = f;\n  }\n\n  void shrink() {\n    while(this->size() && this->back() == T(0)) this->pop_back();\n  }\n\n  P operator+(const P &r) const { return P(*this) += r; }\n\n  P operator+(const T &v) const { return P(*this) += v; }\n\n  P operator-(const P &r) const { return P(*this) -= r; }\n\n  P operator-(const T &v) const { return P(*this) -= v; }\n\n  P operator*(const P &r) const { return P(*this) *= r; }\n\n  P operator*(const T &v) const { return P(*this) *= v; }\n\n  P operator/(const P &r) const { return P(*this) /= r; }\n\n  P operator%(const P &r) const { return P(*this) %= r; }\n\n  P &operator+=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] += r[i];\n    return *this;\n  }\n\n  P &operator+=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] += r;\n    return *this;\n  }\n\n  P &operator-=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] -= r[i];\n    shrink();\n    return *this;\n  }\n\n  P &operator-=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] -= r;\n    shrink();\n    return *this;\n  }\n\n  P &operator*=(const T &v) {\n    const int n = (int) this->size();\n    for(int k = 0; k < n; k++) (*this)[k] *= v;\n    return *this;\n  }\n\n  P &operator*=(const P &r) {\n    if(this->empty() || r.empty()) {\n      this->clear();\n      return *this;\n    }\n    assert(get_mult() != nullptr);\n    return *this = get_mult()(*this, r);\n  }\n\n  P &operator%=(const P &r) {\n    return *this -= *this / r * r;\n  }\n\n  P operator-() const {\n    P ret(this->size());\n    for(int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];\n    return ret;\n  }\n\n  P &operator/=(const P &r) {\n    if(this->size() < r.size()) {\n      this->clear();\n      return *this;\n    }\n    int n = this->size() - r.size() + 1;\n    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);\n  }\n\n  P pre(int sz) const {\n    return P(begin(*this), begin(*this) + min((int) this->size(), sz));\n  }\n\n  P operator>>(int sz) const {\n    if(this->size() <= sz) return {};\n    P ret(*this);\n    ret.erase(ret.begin(), ret.begin() + sz);\n    return ret;\n  }\n\n  P operator<<(int sz) const {\n    P ret(*this);\n    ret.insert(ret.begin(), sz, T(0));\n    return ret;\n  }\n\n  P rev(int deg = -1) const {\n    P ret(*this);\n    if(deg != -1) ret.resize(deg, T(0));\n    reverse(begin(ret), end(ret));\n    return ret;\n  }\n\n  P diff() const {\n    const int n = (int) this->size();\n    P ret(max(0, n - 1));\n    for(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);\n    return ret;\n  }\n\n  P integral() const {\n    const int n = (int) this->size();\n    P ret(n + 1);\n    ret[0] = T(0);\n    for(int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);\n    return ret;\n  }\n\n  // F(0) must not be 0\n  P inv(int deg = -1) const {\n    assert(((*this)[0]) != T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1) / (*this)[0]});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 1\n  P log(int deg = -1) const {\n    assert((*this)[0] == 1);\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();\n  }\n\n  P sqrt(int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n\n    if((*this)[0] == T(0)) {\n      for(int i = 1; i < n; i++) {\n        if((*this)[i] != T(0)) {\n          if(i & 1) return {};\n          if(deg - i / 2 <= 0) break;\n          auto ret = (*this >> i).sqrt(deg - i / 2) << (i / 2);\n          if(ret.size() < deg) ret.resize(deg, T(0));\n          return ret;\n        }\n      }\n      return P(deg, 0);\n    }\n\n    P ret({T(1)});\n    T inv2 = T(1) / T(2);\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 0\n  P exp(int deg = -1) const {\n    assert((*this)[0] == T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1)});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  P pow(int64_t k, int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    for(int i = 0; i < n; i++) {\n      if((*this)[i] != T(0)) {\n        T rev = T(1) / (*this)[i];\n        P C(*this * rev);\n        P D(n - i);\n        for(int j = i; j < n; j++) D[j - i] = C[j];\n        D = (D.log() * k).exp() * (*this)[i].pow(k);\n        P E(deg);\n        if(i * k > deg) return E;\n        auto S = i * k;\n        for(int j = 0; j + S < deg && j < D.size(); j++) E[j + S] = D[j];\n        return E;\n      }\n    }\n    return *this;\n  }\n\n  T eval(T x) const {\n    T r = 0, w = 1;\n    for(auto &v : *this) {\n      r += w * v;\n      w *= x;\n    }\n    return r;\n  }\n};\n\nusing FPS = FormalPowerSeries< modint >;\n\n// fにa * x^n + bを掛ける\nvoid mul_simple(FPS &f,modint a ,int n, modint b){\n  for(int i = (int)f.size() - 1 ; i >= 0 ; i--){\n    f[i] *= b;\n    if(i >= n) f[i] += f[i - n] * a; \n  }\n}\n\n// fからa * x^n + bを割る\nvoid div_simple(FPS &f,modint a,int n,modint b){\n  for(int i = 0 ; i < (int)f.size() ; i++){\n    f[i] /= b;\n    if(i + n < (int)f.size() ) f[n + i] -= f[i] * a; \n  }\n}\n\n// f / gをdeg(f)次まで求める\nFPS div_(FPS &f , FPS g){\n  int n = f.size();\n  return (f * g.inv(n)).pre(n);\n}\n\n\n// solve関数内で\n//\n// FPS::set_fft(mul);\n//\n// とすること。\n\n/**\nNumberTheoreticTransform<MOD> ntt;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret =ntt.multiply_for_fps(a , b);\n  return FPS::P(ret.begin(), ret.end());\n};\n/*///\nArbitraryModConvolution< modint > fft;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret = fft.multiply(a, b);\n  return FPS::P(ret.begin(), ret.end());\n};\n//*/\n\n// 下記のリンクを実装(kitamasa法のモンゴメリ乗算を使わない版)\n// http://q.c.titech.ac.jp/docs/progs/polynomial_division.html\n// k項間漸化式のa_Nを求める O(k log k log N)\n// N ... 求めたい項　(0-indexed)\n// Q ... 漸化式 (1 - \\sum_i c_i x^i)の形\n// a ... 初期解 (a_0 , a_1 , ... , a_k-1)\n// x^N を fでわった剰余を求め、aと内積を取る\nmodint kitamasa(ll N, FPS &Q, FPS &a){\n  int k = Q.size() - 1;\n  assert( (int)a.size() == k );\n  FPS P = a * Q; P.resize(k);\n  while(N){\n    auto Q2 = Q;\n    for(int i = 1; i < (int)Q2.size(); i += 2) Q2[i].x = MOD - Q2[i].x;\n    auto S = P * Q2;\n    auto T = Q * Q2;\n    if(N & 1){\n      for(int i = 1 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    else{\n      for(int i = 0 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    N >>= 1;\n  }\n  return P[0];\n}\n\nvoid solve(){\n  ini(N , M);\n  ins(S);\n  auto run = RunLengthEncoding(S);\n  if(run.size() == 1){\n    // DP\n    V<mint> dp(N),ep(N),fp(N),gp(N);\n    // [0]がR\n    // -> [1],[-1]はどちらでもよい\n    dp[0] = gp[0] = 1;\n    rep1(i , N - 1){\n      dp[i] = dp[i - 1] + ep[i - 1];\n      ep[i] = dp[i - 1];\n      fp[i] = fp[i - 1] + gp[i - 1];\n      gp[i] = fp[i - 1];\n    }\n    out(dp[N-1] + ep[N-1] + fp[N-1]);\n    return;\n  }\n  if(N % 2 == 1){\n    out(0);\n    return;\n  }\n\n  FPS::set_fft(mul);\n  // rの最小値\n  int r = N-1 , b = N-1;\n  // 偶数は無視していい\n  // \n  auto trans = [](int n){\n    return (n % 2 == 1) ? n : (n + 1);\n  };\n  rep(i , sz(run)){\n    if(i==0)continue;\n    auto p = run[i];\n    if(p.first == 'R' && p.second % 2 == 1) amin(r , trans(p.second));\n    if(p.first == 'B' && p.second % 2 == 1) amin(b , trans(p.second));\n  }\n  // 初手の制約\n  amin( (run[0].first == 'R' ? r : b) , trans(run[0].second) );\n  // 初手とは異なる方が1である必要あり\n  (run[0].first == 'R' ? b : r) = 1;\n  trc(r , b);\n  if(r < b) swap(r , b);  \n  auto nyaan = [&](ll n,int flg = false) -> FPS{\n    FPS ret(n + 1);\n    for(int i = 1 ; i <= n ; i += 2) ret[i] = (flg ? i + 1 : 1);\n    return ret;\n  };\n  FPS f({0 , 1});\n  f *= nyaan(r);\n  f *= -1; f[0] = 1;\n  if((int)f.size() <= N) f.resize(N + 2);\n  trc(f);\n  f = f.inv();\n  trc(f);\n  // [0]の置き方\n  f *= nyaan(r,1);\n  trc(f);\n  out(f[N-1]);\n  \n  \n  /*\n  //trc(f);\n  // 倍数包除\n  for(int i = 2 ; i <= N ; i++){\n    // i番目は？\n    //引こう！\n    for(int j = 2 ; i * j <= N ; j++){\n      f[i * j] -= f[i];\n    }\n  }\n  trc(f);\n  */\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register\nchar ss[1001000];\nconst int mod=1e9+7;\nint f[1001000],ff[1001000][2][2],x[2];\nint main()\n{\n\tre int n,m,ans=1,xx=0,mmx=1<<30;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",ss+1);\n\tfor(re int i=1;i<=m;i++)\n\t{\n\t\tif(ss[i]!=ss[1])\n\t\t{\n\t\t\tif(ans)mmx=xx+2-(xx&1);\n\t\t\telse if((xx&1)&&mmx>xx+1)mmx=xx+1;\n\t\t\txx=0;ans=0;\n\t\t}else xx++;\n\t}\n\tif(ans==1)\n\t{\n\t\tff[1][0][0]=ff[1][1][1]=1;\n\t\tfor(re int i=2;i<=n;i++)\n\t\t{\n\t\t\tfor(re int j=0;j<=1;j++)\n\t\t\t{\n\t\t\t\tff[i][j][0]=(ff[i-1][j][0]+ff[i-1][j][1])%mod;\n\t\t\t\tff[i][j][1]=ff[i-1][j][0];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",((long long)ff[n][0][0]+ff[n][0][1]+ff[n][1][0])%mod);\n\t\treturn 0;\n\t}\n\tf[0]=f[2]=1;\n\tfor(re int i=4;i<=n;i++)\n\t{\n\t\tf[i]=(2ll*f[i-2]+(i-mmx-2>=0?mod-f[i-mmx-2]:0))%mod;\n\t\t//printf(\"**%d %d %d\\n\",i,f[i],mmx);\n\t}\n\tfor(re int i=2;i<=mmx&&i<=n;i+=2)ans=(ans+(long long)i*f[n-i])%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//I forgot you...\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = (int)1e9 + 7;\nconst int MAXN = (int)2e5 + 3;\nconst int infint = (int)1e9 + 3;\nconst ll inf = (ll)1e18;\nint n, m, ans, mika = infint, dp[MAXN], part[MAXN];\nstring s;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif(c >= MOD)\n\t\tc -= MOD;\n\tif(c < 0)\n\t\tc += MOD;\n\treturn c;\n}\nint mul(int a, int b)\n{\n\tint c = 1LL * a * b % MOD;\n\treturn c;\n}\nvoid find_mika()\n{\n\tmika = n - 1;\n\tif(n % 2 == 1)\n\t\tmika--;\n\tif(s[0] == 'R')\n\t{\n\t\tint ted = 0;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tif(s[i] == 'R')\n\t\t\t\tted++;\n\t\t\telse\n\t\t\tif(s[i] == 'B' && ted > 0)\n\t\t\t{\n\t\t\t\tif(ted % 2)\t\n\t\t\t\t\tmika = min(mika, ted);\n\t\t\t\telse\n\t\t\t\t\tmika = min(mika, ted + 1);\n\t\t\t\tted = 0;\n\t\t\t}\n\t}\n\telse\n\t{\n\t\tint ted = 0;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tif(s[i] == 'B')\n\t\t\t\tted++;\n\t\t\telse\n\t\t\tif(s[i] == 'R' && ted > 0)\n\t\t\t{\n\t\t\t\tif(ted % 2)\n\t\t\t\t\tmika = min(mika, ted);\n\t\t\t\telse\n\t\t\t\t\tmika = min(mika, ted + 1);\n\t\t\t\tted = 0;\n\t\t\t}\n\t}\n}\nint getzarib(int kaman)\n{\n\tint emp = n - kaman;\n\tif(emp == 0)\n\t\treturn 1;\n\telse\n\t\treturn n - emp;\n}\nint main()\n{\n\tios::sync_with_stdio(false); \n\tcin.tie(0); cout.tie(0);\n\tcin >> n >> m >> s;\n\tbool flg = 1;\n\tfor (int i = 1; i < m; i++)\n\t\tif(s[i] != s[0])\t\n\t\t\tflg = 0;\n\tif(flg)\n\t{\n\t\tdp[0] = 1, dp[1] = 1, dp[2] = 2;\n\t\tfor (int i = 3; i <= n; i++)\n\t\t\tdp[i] = add(dp[i - 1], dp[i - 2]);\n\t\t\n\t\tans = dp[n];\n\t\tif(n >= 2)\n\t\t\tans = add(ans, dp[n - 2]);\n\t\tcout << ans;\n\t\treturn 0;\n\t}\n\tfind_mika();\n\tdp[0] = 1;\n\tpart[0] = 1;\n\tfor (int i = 2; i <= n; i += 2)\n\t{\n\t\tdp[i] = part[i - 2];\n\t\tif(i - mika - 3 >= 0)\n\t\t\tdp[i] = add(dp[i], -part[i - mika - 3]);\n\t\tpart[i] = add(part[i - 2], dp[i]);\n\t}\n\tans = add(ans, dp[n]);\n\tfor (int i = 1; i <= mika; i += 2)\n\t\tif(i != n - 2 && i != n)\n\t\t\tans = add(ans, mul(getzarib(i), dp[n - i - 1]));\n\t\telse\n\t\tif(i == n)\n\t\t\tans = add(ans, 1);\n\tcout << ans;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\n#define debug(x)//  cerr << #x << \" = \" << x << endl\ntypedef long long ll;\nconst ll MAX_N = 2e5+100;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nint n,m;\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    int mn = 1e9;\n    if (vc[0]%2==0)\n        mn = vc[0]+1;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    int lim = mn;\n    dp[1] = 1;\n    dp[3] = 1;\n    for(int i = 5;i<=n;i+=2)\n    {\n        dp[i] = (dp[i-2]*2ll)%MOD;\n        if (i>=lim+3)\n            dp[i] = (dp[i]-dp[i-lim-3]+MOD+MOD)%MOD;\n    }\n    ll ans = 0;\n    for(ll i = 1;i<=min(n-1,lim);i+=2)\n    {\n        ans += ((i+1ll)*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define mod 1000000007\n#define N 200050\nint n,m,dp[N][2][2],fg,mx,fg2,dp2[N],su[N],as;\nchar s[N];\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tfor(int i=2;i<=m;i++)if(s[i]!=s[i-1])fg=1;\n\tif(!fg)\n\t{\n\t\tdp[1][1][1]=dp[1][0][0]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\tdp[i][0][0]=(dp[i-1][0][0]+dp[i-1][1][0])%mod,\n\t\tdp[i][0][1]=(dp[i-1][0][1]+dp[i-1][1][1])%mod,\n\t\tdp[i][1][0]=dp[i-1][0][0],\n\t\tdp[i][1][1]=dp[i-1][0][1];\n\t\tprintf(\"%lld\\n\",(1ll*dp[n][0][0]+dp[n][0][1]+dp[n][1][0])%mod);\n\t\treturn 0;\n\t}\n\tint su1=0;\n\tfor(int i=1;i<=m;i++)\n\tif(s[i]==s[1])su1++;\n\telse\n\t{\n\t\tif((su1&1)&&mx>su1)mx=su1;\n\t\tif(!fg2)mx=su1+1;\n\t\tfg2=1;su1=0;\n\t}\n\tif(mx>n)mx=n;\n\tif(~mx&1)mx--;\n\tdp2[1]=1;su[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(i-mx>3)dp2[i]=(su[i-2]-su[i-mx-3]+mod)%mod;\n\t\telse dp2[i]=su[i-2];\n\t\tsu[i]=(su[i-2]+dp2[i])%mod;\n\t}\n\tfor(int i=1;i<=mx;i+=2)as=(as+1ll*dp2[n-i]*(i+1))%mod;\n\tprintf(\"%d\\n\",as);\n}//"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,inline\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#include<bits/stdc++.h>\n#define ll long long\n//#define int ll\nusing namespace std;\nconst int md=1000000007;\nconst int mxn=200005;\nint n,m,mx,ans,dp[mxn],f[mxn];\nchar s[mxn];\ninline void add(int&x,int y){\n\tx+=y;\n\tif(x>=md)x-=md;\n}\nsigned main(){\n\tint i,j,t;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(i=1;i<=m;++i)if(s[i]!=s[1])break;mx=i-1;\n\tif(mx==m){\n\t\tdp[0]=f[i]=ans=1;\n\t\tfor(int i=0;i<=n;++i){\n\t\t\tif(i>=2)dp[i]=f[i-2];\n\t\t\tf[i]=(f[i-1]+dp[i])%md;\n\t\t\tif(n-i>1)add(ans,(ll)dp[i]*(n-i)%md);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(n&1)return 0*puts(\"0\");\n\tif(!(mx&1))++mx;\n\tfor(t=0;i<=m;++i){\n\t\tif(s[i]==s[1])++t;\n\t\telse{\n\t\t\tif(t&1)mx=min(mx,t);\n\t\t\tt=0;\n\t\t}\n\t}\n\tn>>=1,mx=mx+1>>1;\n\tdp[0]=f[0]=1;\n\tfor(i=0;i<=n;++i){\n\t\tif(i){\n\t\t\tdp[i]=(md+f[i-1]-(i-mx-1>=0?f[i-mx-1]:0))%md;\n\t\t\tf[i]=(f[i-1]+dp[i])%md;\n\t\t}\n\t\tif(n-i<=mx) add(ans,(ll)(n-i)*dp[i]*2ll%md);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 233333,mo=1e9+7;\nint n,m,f[N],qz[N];char s[N];\nvoid init(int n, int lim){//<=lim\n\tumin(lim,n);//f[i]=sigma f[i-1..i-lim]\n\tf[0]=1;qz[0]=1;\n\trep(i,1,n){\n\t\tf[i]=(qz[i-1]-(i-lim-1>=0?qz[i-lim-1]:0)+mo)%mo;\n\t\tqz[i]=(qz[i-1]+f[i])%mo;\n\t}\n}\nint main() {\n\tread(n);read(m);scanf(\"%s\",s+1);\n\tint cnt=0;rep(i,1,m)cnt+=s[i]=='R';\n\tif(cnt==0||cnt==m){\n\t\tstatic int f[N];\n\t\tf[0]=1;f[1]=2;rep(i,2,n)f[i]=(f[i-1]+f[i-2])%mo;\n\t\tprintf(\"%d\\n\",(f[n-1]+(n-3>=0?f[n-3]:1))%mo);\n\t\treturn 0;\n\t}\n\tint lim=1e9;int j;for(j=1;j<=m;j++)if(s[j]!=s[1])break;j--;\n\tif(j%2==0)lim=j+1;\n\trep(i,1,m)if(s[i]==s[1]){\n\t\tint j;for(j=i;j<=m;j++)if(s[j]!=s[i])break;\n\t\t//[i,j-1]\n\t\tif((j-i)%2)umin(lim,j-i);\n\t\ti=j-1;\n\t}\n\tlim++;init(n/2,lim/2);int res=0;//%2==0\n\tfor(int i=2;i<=min(lim,n);i+=2)res=(res+1LL*i*f[(n-i)/2])%mo;\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\ntemplate<typename T>\nclass RangeAddQuery {\npublic:\n    explicit RangeAddQuery(int n) : N(calcN_(n)) {\n        mVal.assign(2*N+1, 0);\n    }\n    void update(int l, int r, T value){\n        l = max(0, l);\n        r = min(N, r);\n        int offset = N;\n        while(offset > 0){\n            if(l >= r) break;\n            if(l&1){ update_(mVal[offset+l-1], value); l++; }\n            if(r&1){ update_(mVal[offset+r-2], value); }\n            l /= 2;\n            r /= 2;\n            offset /= 2;\n        }\n    }\n    T get(int idx){\n        int i = N + idx - 1;\n        auto res = mVal[i];\n        while(i > 0){\n            i = (i-1)/2;\n            update_(res, mVal[i]);\n        }\n        return res;\n    }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    inline void update_(T& data, T val) { data = (data + val) % MOD; }\n    const int N;\n    vector<T> mVal;\n};\n\nint maxSegment(const string& S){\n    char c = S[0];\n    bool first = true;\n    int cnt = 0;\n    int res = MOD;\n    for(auto& s : S){\n        if(c == s) ++cnt;\n        else {\n            if(first || cnt%2 == 1){\n                res = min(res, cnt/2+1);\n                cnt = 0;\n                first = false;\n            }\n        }\n    }\n    return res < MOD ? res : -1;\n}\n\nint solve(const string& S, int N){\n    int seg = maxSegment(S);\n    if(seg != -1 && N%2 == 1) return 0;\n    long long res = 0;\n    if(seg == -1){\n        RangeAddQuery<long long> raq(N);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N;i++){\n            auto a = raq.get(i);\n            raq.update(i+2, N, a);\n        }\n        res = 1;\n        for(int i=N-2;i>=0;i--){\n            res = (res + raq.get(i) * (N-i)) % MOD;\n        }\n    } else {\n        seg = min(seg, N/2);\n        vector<long long> dp(N/2, 0);\n        vector<long long> sum(N/2, 0);\n        dp[0] = sum[0] = 1;\n        for(int i=1;i<N/2;i++){\n            dp[i] = sum[i-1];\n            if(i-1-seg >= 0) dp[i] = (dp[i] + MOD - sum[i-1-seg]) % MOD;\n            sum[i] = (dp[i] + sum[i-1]) % MOD;\n        }\n        for(int i=N/2-1;i>=N/2-seg;i--){\n            res = (res + dp[i] * 2 * (N/2-i)) % MOD;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    cout << solve(S, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define mod 1000000007\n#define DIM 200005\nusing namespace std;\nint n, m, i, k, nr, sol;\nchar s[DIM];\nint d[DIM], sum[DIM];\nint main(){\n    cin>> n >> m;\n    cin>> s + 1;\n    k = m;\n    for(i = 1; i <= n; i++){\n        if(s[i] == s[1]){\n            nr++;\n        }\n        else{\n            if(nr == i - 1){\n                if(nr % 2 == 1){\n                    k = min(k, nr);\n                }\n                else{\n                    k = min(k, nr + 1);\n                }\n            }\n            else{\n                if(nr % 2 == 1){\n                    k = min(k, nr);\n                }\n            }\n        }\n    }\n    sum[1] = d[1] = 1;\n    if(k == m){\n        for(i = 3; i < n; i++){\n            d[i] = sum[i - 2];\n            sum[i] = (d[i] + sum[i - 1]) % mod;\n        }\n        sol = 1;\n        for(i = 1; i < n; i++){\n            sol = (sol + d[n - i] * 1LL * (i + 1) ) % mod;\n        }\n        cout<< sol;\n        return 0;\n    }\n    for(i = 3; i < n; i += 2){\n        d[i] = sum[i - 2];\n        if(i - k - 3 > 0){\n            d[i] -= sum[i - k - 3];\n            if(d[i] < 0){\n                d[i] += mod;\n            }\n        }\n        sum[i] = d[i] + sum[i - 2];\n        if(sum[i] >= mod){\n            sum[i] -= mod;\n        }\n    }\n    for(i = 1; i < min(n, k + 2); i += 2){\n        sol = (sol + d[n - i] * 1LL * (i + 1) ) % mod;\n    }\n    cout<< sol;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long prime = 1000000007;\n\nbool all_chars_equal(string s) {\n    for (char c : s) {\n        if (c != s[0]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> get_runs(string s) {\n    vector<int> runs;\n    int current_run = 0;\n    for (char c : s) {\n        if (c == s[0]) {\n            ++current_run;\n        } else if (current_run > 0) {\n            runs.push_back(current_run);\n            current_run = 0;\n        }\n    }\n    // We intentionally don't add the last run\n    return runs;\n}\n\nlong long mod(long long x) {\n    return (x % prime + prime) % prime;\n}\n\nlong long f(int n, int k) {\n    vector<long long> pow_2(2 * k + 4);\n    pow_2[0] = 1LL;\n    for (int i = 1; i < 2 * k + 4; ++i) {\n        pow_2[i] = pow_2[i - 1] * 2 % prime;\n    }\n\n    vector<long long> f1(max(n + 1, 2 * k + 4), 0);\n    for (int i = 1; i <= k; ++i) {\n        f1[i] = pow_2[i];\n    }\n    f1[k + 1] = mod(pow_2[k+1] - 1);\n    for (int n1 = k + 2; n1 <= 2 * k + 3; ++n1) {\n        f1[n1] = mod(pow_2[n1] - 1 - n1 * pow_2[n1 - k - 2]);\n    }\n    for (int n1 = 2 * k + 4; n1 <= n; ++n1) {\n        f1[n1] = mod(2 * f1[n1 - 1] - f1[n1 - k - 2]);\n    }\n    return f1[n];\n}\n\n/*\nf(n, k) = antal cirkler af længde n med højst k røde i streg (ingen andre begrænsninger)\n\nf(n, k) = 2^n for n <= k\nf(n, k) = 2^n - 1 for n = k+1\nf(n, k) = 2^n - 1 - n * 2^{n-k-2} for k+2 <= n <= 2k+3\nf(n, k) = 2f(n-1, k) - f(n-k-2, k) for n >= 2k + 4\n\n*/\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    string s;\n    cin >> n >> m;\n    cin >> s;\n    if (all_chars_equal(s)) {\n        cout << f(n, 1) << endl;  // OK since n >= 2\n        return 0;\n    }\n    if (n % 2 != 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n    vector<int> runs = get_runs(s);\n    int bound = runs[0] % 2 == 1 ? runs[0] : runs[0] + 1;\n    bound = min(bound, n - 1);\n    for (int run : runs) {\n        if (run % 2 == 1 && run < bound) {\n            bound = run;\n        }\n    }\n    cout << mod(f(n / 2, (bound - 1) / 2) * 2) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << (a) << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int MOD = 1e9 + 7;\n\nvi split(string s) {\n    vi ans;\n    char last = 'X'; \n    s += 'X';\n    int streak = 0;\n    for (char c : s) {\n        if (c != last) {\n            if (streak) ans.pb(streak);\n            streak = 0;\n            last = c;\n        }\n        streak++;\n    }\n    return ans;\n}\n\nvoid add(int &x, int y) {\n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n\nvi go(int n, int lim, int start) {\n    vi dp(n+1);\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = 0;\n        if (i >= start) add(dp[i], dp[i-start]);\n        if (i >= lim+1) add(dp[i], MOD-dp[i-lim-1]);\n        add(dp[i], dp[i-1]);\n    }\n    for (int i = n; i >= 1; i--) add(dp[i], MOD-dp[i-1]);\n    return dp;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    int n,l;\n    string s;\n    while (cin >> n >> l >> s) {\n        auto p = split(s);\n        if (si(p) == 1) {\n            auto dp = go(n,n,2);\n            int ans = 0;\n            for (int dif = 1; dif <= n; dif++) {\n                if (dif == 1 || dif == n-1) continue;\n                add(ans, ll(dif) * dp[n-dif] % MOD);\n            }\n            cout << (ans+1)%MOD << endl;\n        }\n        else {\n            if (n%2 == 1) {\n                cout << 0 << endl;\n                continue;\n            }\n            else {\n                int lim = p[0]/2+1;\n                forn(i,si(p)) if (i%2 == 0 && p[i]%2 == 1) \n                    lim = min(lim, p[i]/2+1);\n                n /= 2;\n                auto dp = go(n, lim, 1);\n                int ans = 0;\n                for (int dif = 1; dif <= lim; dif++)\n                    add(ans, ll(dif) * dp[n-dif] % MOD);\n                cout << 2LL*ans%MOD << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register\nchar ss[1001000];\nconst int mod=1e9+7;\nint f[1001000],ff[1001000][2][2],x[2];\nint main()\n{\n\tre int n,m,ans=1,xx=1,mmx=1<<30;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",ss+1);\n\tfor(re int i=1;i<=m;i++)\n\t{\n\t\tif(ss[i]!=ss[1])\n\t\t{\n\t\t\tif(xx<mmx)mmx=xx;\n\t\t\txx=0;ans=0;\n\t\t}else xx++;\n\t}\n\tif(ans==1)\n\t{\n\t\tff[1][0][0]=ff[1][1][1]=1;\n\t\tfor(re int i=2;i<=n;i++)\n\t\t{\n\t\t\tfor(re int j=0;j<=1;j++)\n\t\t\t{\n\t\t\t\tff[i][j][0]=(ff[i-1][j][0]+ff[i-1][j][1])%mod;\n\t\t\t\tff[i][j][1]=ff[i-1][j][0];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",((long long)ff[n][0][0]+ff[n][0][1]+ff[n][1][0])%mod);\n\t\treturn 0;\n\t}\n\tmmx+=2;\n\tif(mmx&1)mmx--;\n\tf[0]=f[2]=1;\n\tfor(re int i=4;i<=n;i++)\n\t{\n\t\tf[i]=(2ll*f[i-2]+(i-mmx-2>=0?mod-f[i-mmx-2]:0))%mod;\n\t//\tprintf(\"**%d %d\\n\",i,f[i]);\n\t}\n\tfor(re int i=2;i<=mmx&&i<=n;i+=2)ans=(ans+(long long)i*f[n-i])%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nchar str[200005];\nint arr[200005];\nlong long MOD=1000000007;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",str);\n\tfor(int i=0;i<m;i++)if(str[i]=='R')arr[i]=0;else arr[i]=1;\n\tbool all=1;for(int i=1;i<m&&all;i++)if(arr[i]!=arr[0])all=0;\n\tif(all){\n\t\tlong long dp[2][n];memset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;dp[1][0]=0; //start with red (or blue if everything is blue)\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tlong long ans=(dp[0][n-1]+dp[1][n-1])%MOD; //end with red or blue\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=0;dp[1][0]=1; //start with blue\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tans+=dp[0][n-1];ans%=MOD;ans+=MOD;ans%=MOD; //only end with red\n\t\tprintf(\"%lld\",ans);\n\t\treturn 0;\n\t}\n\tif(n%2!=0){printf(\"0\");return 0;}\n\tint mxl=(int)MOD; //large number\n\tint st=1,cur=0;\n\tfor(int i=1;i<m;i++){\n\t\tif(arr[i]==arr[0]){\n\t\t\tif(st!=-1)st++;\n\t\t\telse cur++;\n\t\t}else{\n\t\t\tif(st!=-1){\n\t\t\t\tmxl=st|1; //+1 if even\n\t\t\t\tst=-1;\n\t\t\t}else{\n\t\t\t\tif(cur%2!=0)mxl=min(mxl,cur);\n\t\t\t\tcur=0;\n\t\t\t}\n\t\t}\n\t}\n\t//comments: wlog red is first\n\t//can ignore last segment of red\n\tn/=2; mxl/=2; //remove the ones that are different parity from blue\n\tlong long dp[100005],pref[100005];\n\tmemset(dp,0,sizeof(dp));memset(pref,0,sizeof(pref));\n\t//i segments on a line, first and last are blue, max mxl consecutive reds\n\t//blues may be consecutive because the reds in between were removed\n\tdp[1]=pref[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tdp[i]=pref[i-1]-pref[max(0,i-(mxl+2))];\n\t\tdp[i]%=MOD;dp[i]+=MOD;dp[i]%=MOD;\n\t\tpref[i]=dp[i]+pref[i-1];\n\t\tpref[i]%=MOD;pref[i]+=MOD;pref[i]%=MOD;\n\t}\n\tlong long ans=0;\n\tfor(long long i=2;i<=min(n,mxl+2);i++){\n\t\tans+=(i-1LL)*dp[n-i+2];\n\t\tans%=MOD;\n\t}\n\tans+=MOD;ans%=MOD;\n\tprintf(\"%lld\",(ans*2)%MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,INF=0X3F3F3F3F,P=1e9+7;\nint n,m,f[N];\nchar s[N];\nvoid sol1(){\n\tf[1]=1;\n\trep(i,2,n+1)f[i]=(f[i-1]+f[i-2])%P;\n\tprintf(\"%d\\n\",(f[n-1]+f[n+1])%P);\n}\nvoid sol2(int n,int lim){\n\tD(\"n=%d lim=%d\\n\",n,lim);\n\tint cur=0;\n\tfor(int i=1;i<=n;++i){\n\t\tif(i>lim+1)cur=(cur-f[i-lim-1]+P)%P;\n\t\tf[i]=(cur+(i<=lim?i:0))%P;\n\t\tcur=(cur+f[i])%P;\n\t}\n\tprintf(\"%lld\\n\",2LL*f[n]%P);\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,s);\n\tif(s[0]=='B'){\n\t\trep(i,0,m-1)s[i]=(s[i]=='R'?'B':'R');\n\t}\n\tif(count(s,s+m,s[0])==m){\n\t\tsol1();\n\t\treturn 0;\n\t}\n\tif(n&1)puts(\"0\"),exit(0);\n\tbool fir=1;\n\tint mn=INF;\n\tfor(int i=0,j;i<m;i=j){\n\t\tj=i+1;\n\t\twhile(j<m&&s[j]==s[i])++j;\n\t\tif(s[i]=='R'&&(fir||(j-i!=1&&(j-i)%2)))mn=min(mn,j-i),fir=0;\n\t}\n\tsol2(n/2,mn/2+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\n#define debug(x)//  cerr << #x << \" = \" << x << endl\ntypedef long long ll;\nconst ll MAX_N = 2e5+100;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nint main()\n{\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    int mn = 1e9;\n    if (vc[0]%2==0)\n        mn = vc[0]+1;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    int lim = mn;\n    dp[1] = 1;\n    dp[3] = 1;\n    for(int i = 5;i<=n;i+=2)\n    {\n        dp[i] = (dp[i-2]*2ll)%MOD;\n        if (i>=lim+3)\n            dp[i] = (dp[i]-dp[i-lim-3]+MOD+MOD)%MOD;\n    }\n    ll ans = 0;\n    for(ll i = 1;i<=min(n-1,lim);i+=2)\n    {\n        ans += ((i+1ll)*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst ll N=2e5+10,mo=1e9+7;\nll f[N],n,m,lim,q[N];\nchar s[N];\nvoid move(ll &a,ll b){a=(a+b)%mo;}\nint main(){\n\tcin>>n>>m;\n\tscanf(\"%s\",s+1);\n\tif (s[1]=='B'){\n\t\tfor (ll i=1;i<=m;i++)s[i]='B'+'R'-s[i];\n\t}\n\tll cnt=0;\n\tfor (ll i=1;i<=m;i++){\n\t\tif (s[i]=='R')cnt++;\n\t\telse {\n\t\t\tif (!lim)lim=cnt|1;\n\t\t\telse if (cnt&1)lim=min(lim,cnt);\n\t\t\tcnt=0;\n\t\t}\n\t}\n\tif (!lim)lim=n+1;\n\tlim++;\n\tfor (ll i=1;i<=n;i++){\n\t\tf[i]=q[i-2];\n\t\tif (i<=lim&&(i%2==0))move(f[i],i);\n\t\tq[i]=((ll)q[i-2]+f[i]-(i>lim?f[i-lim]:0)+mo)%mo;\n\t}\n\tcout<<f[n]+(lim==n+2)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-03 17:07:09\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=200010,mod=1000000007;\nint n,m,flag,l,Flag;\ni64 f[N],F[N],ans;\nchar s[N];\nint main()\n{\n\tn=read(); m=read();\n\tscanf(\"%s\",s+1);\n\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\tif(!flag)\n\t{\n\t\tf[0]=1; f[1]=1; f[2]=2;\n\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t\treturn 0;\n\t}\n\tl=n-1;\n\tfor(int i=1,j;i<=m;)\n\t\tif(s[i]==s[1])\n\t\t{\n\t\t\tj=i;\n\t\t\twhile(s[j]==s[1]) j++;\n\t\t\tif(j>n) break;\n\t\t\tif(((j-i)&1)||(!Flag)) l=std::min(l,(j-i)+(!((j-i)&1)));\n\t\t\ti=j+1; Flag=1;\n\t\t}\n\t\telse i++;\n\tif(n&1){ printf(\"0\\n\"); return 0; }\n\tn/=2; l=(l+1)/2;\n//\tprintf(\"%d %d\\n\",int(n),int(l));\n\tf[0]=F[0]=1;\n\tfr(i,1,n)\n\t{\n\t\tf[i]=(F[i-1]+mod-(i-l-1>=0?F[i-l-1]:0))%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t}\n\tans=f[n];\n\tfr(i,1,l) ans=(ans+f[n-i]*(2*i-1))%mod;\n\tprintf(\"%d\\n\",int(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tstring s;\n\tcin >> s;\n\tset<char>st;\n\tfor (auto i : s)st.insert(i);\n\tif (st.size() == 1) {\n\t\tvector<long long int>dp(N + 1);\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1];\n\t\t\tif (i > 1)dp[i] += dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tlong long int ans = dp.back();\n\t\tdp[0] = 1;\n\t\tdp[1] = 0;\n\t\tfor (int i = 2; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tans += dp.back();\n\t\tans %= MOD;\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\ts.push_back(s[0] + 1);\n\tvector<int>num(s.size() + 1);\n\tfor (int i = 0; i <= s.size(); i++) {\n\t\tnum[i] = s[i] == s[0];\n\t\tif (i)num[i] = num[i] * (num[i - 1] + 1);\n\t}\n\tint fst = 0;\n\tint m = MOD;\n\tbool even = true;\n\tfor (int i = 1; i <= s.size(); i++) {\n\t\tif (!num[i] && num[i - 1]) {\n\t\t\tif (num[i - 1] & 1) {\n\t\t\t\teven = false;\n\t\t\t\tm = min(m, num[i - 1]);\n\t\t\t}\n\t\t\tif (fst == 0) {\n\t\t\t\tfst = num[i - 1];\n\t\t\t\tif (fst % 2 == 0)m = MOD;\n\t\t\t}\n\t\t}\n\t}\n\tassert(even);\n\tif (even) {\n\t\tm = fst + 2;\n\t}\n\telse if (fst % 2 == 0) {\n\t\tm = min(m, fst + 1);\n\t}\n\tif (m & 1)m++;\n\tvector<long long int>dp(N + 2);\n\tvector<long long int>sum(N + 2);\n\tfor (int i = 2; i <= m; i += 2)dp[i] = i;\n\tfor (int i = 2; i <= N; i++) {\n\t\tdp[i] += sum[i - 2] + MOD;\n\t\tif (i - m - 2 >= 0)dp[i] -= sum[i - m - 2];\n\t\tdp[i] %= MOD;\n\t\tif (i == N) {\n\t\t\tcout << dp[i] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsum[i] = sum[i - 2] + dp[i];\n\t\tsum[i] %= MOD;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//*\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <numeric>\n#include <functional>\n#define MOD 1000000007\n#define MAX 0x3f3f3f3f\n#define MAX2 0x3f3f3f3f3f3f3f3fll\n#define ERR 1e-10\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#pragma warning(disable:4996)\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n\nint n, m;\nchar s[300000];\n\nll d[300000][2];\n\nll u[300000], v[300000];\n\nint main()\n{\n    int i, j, k, l;\n    ll ans=0;\n    cin>>n>>m;\n    scanf(\"%s\", s);\n    m=strlen(s);\n    if(s[0] == 'B')\n    {\n        for(i=0;i<m;i++) s[i]=s[i]=='R'?'B':'R';\n    }\n    for(i=0;i<m;i++)\n    {\n        if(s[i] == 'R') s[i]='o';\n        else s[i]='x';\n    }\n    if(count(s, s+m, 'o') == m)\n    {\n        for(k=0;k<2;k++)\n        {\n            d[0][k]=1;\n            d[0][!k]=0;\n            for(i=1;i<n;i++)\n            {\n                d[i][0]=d[i-1][0]+d[i-1][1];\n                d[i][1]=d[i-1][0];\n                d[i][0]%=MOD, d[i][1]%=MOD;\n            }\n            if(k == 0)\n            {\n                ans+=d[n-1][0]+d[n-1][1];\n            }\n            else\n            {\n                ans+=d[n-1][0];\n            }\n        }\n        ans%=MOD;\n    }\n    else\n    {\n        if(n%2 == 1)\n        {\n            return !printf(\"0\\n\");\n        }\n        n/=2;\n        int mi=MAX;\n        int cur=0;\n        int flag=0;\n        for(i=0;i<m;i++)\n        {\n            if(s[i] == 'o') cur++;\n            else\n            {\n                if(cur)\n                {\n                    if(flag == 0)\n                    {\n                        if(cur%2 == 0) cur++;\n                    }\n                    else\n                    {\n                        if(cur%2 == 0)\n                        {\n                            cur=0;\n                            continue;\n                        }\n                    }\n                    mi=min(mi, cur);\n                    flag=1;\n                }\n                cur=0;\n            }\n        }\n        mi/=2;\n        if(mi >= n-1)\n        {\n            ans=1;\n            for(i=0;i<n;i++) ans*=2, ans%=MOD;\n            ans--;\n            ans+=MOD;\n            ans%=MOD;\n        }\n        else\n        {\n            u[0]=v[0]=1;\n            u[1]=1, v[1]=2;\n            for(i=2;i<n;i++)\n            {\n                int idx=max(-1, i-mi-2);\n                u[i]=(v[i-1]-(idx==-1?0:v[idx]))%MOD;\n                u[i]+=MOD;\n                u[i]%=MOD;\n                v[i]=v[i-1]+u[i];\n                v[i]%=MOD;\n            }\n            for(i=n-1;i>=n-1-mi;i--)\n            {\n                ans+=u[i]*(n-i);\n                ans%=MOD;\n            }\n        }\n        ans*=2;\n        ans%=MOD;\n    }\n    ans+=MOD;\n    ans%=MOD;\n    cout<<ans<<endl;\n    return 0;\n}\n//*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 200100\n#define M 1000000007\nusing namespace std;\n\nll n,m,mx,ans,dp[N],qz[N];\nchar str[N];\n\ninline void Add(ll &u,ll v){u=(u+v)%M;}\nint main()\n{\n    ll i,j,t;\n    cin>>n>>m;\n    scanf(\"%s\",str+1);\n    for(i=1;i<=m;i++) if(str[i]!=str[1]) break;\n    mx=i-1;\n    if(mx==m)\n    {\n\tdp[0]=qz[0]=ans=1;\n\tfor(i=0;i<=n;i++)\n\t{\n\t    if(i>=2) dp[i]=qz[i-2];\n\t    if(n-i>=2) Add(ans,dp[i]*(n-i)%M);\n\t}\n\tcout<<ans;\n\treturn 0;\n    }\n    if(n&1)\n    {\n\tputs(\"0\");\n\treturn 0;\n    }\n    if(mx%2==0) mx++;\n    for(t=0;i<=m;i++)\n    {\n\tif(str[i]==str[1]) t++;\n\telse\n\t{\n\t    if(t&1) mx=min(mx,t);\n\t    t=0;\n\t}\n    }\n    n/=2,mx=(mx+1)/2;\n    dp[0]=qz[0]=1;\n    for(i=1;i<=n;i++)\n    {\n\tdp[i]=(M+qz[i-1]-(i-mx-1>=0?qz[i-mx-1]:0))%M;\n\tqz[i]=(qz[i-1]+dp[i])%M;\n\tif(n-i<=mx) Add(ans,(n-i)*dp[i]*2%M);\n    }\n    cout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MP make_pair\n#define ll long long\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate <typename T>\nvoid read(T &x) {\n    x = 0; bool f = 0;\n    char c = getchar();\n    for (;!isdigit(c);c=getchar()) if (c=='-') f=1;\n    for (;isdigit(c);c=getchar()) x=x*10+(c^48);\n    if (f) x=-x;\n}\n\ntemplate<typename F>\ninline void write(F x, char ed = '\\n') {\n    static short st[30];short tp=0;\n    if(x<0) putchar('-'),x=-x;\n    do st[++tp]=x%10,x/=10; while(x);\n    while(tp) putchar('0'|st[tp--]);\n    putchar(ed);\n}\n\ntemplate <typename T>\ninline void Mx(T &x, T y) { x < y && (x = y); }\n\ntemplate <typename T>\ninline void Mn(T &x, T y) { x > y && (x = y); }\n\nconst int P = 1e9 + 7;\nconst int N = 400005;\nchar s[N];\nint sum[N], f[N], a[N], m, n;\nll inv[N], fac[N], ans;\ntemplate <typename T>\ninline void Add(T &x, T y) { x += y, x >= P && (x -= P, 0); }\n\ninline ll C(int n, int m) {\n    if (n < m || n < 0) return 0;\n    return fac[n] * inv[m] % P * inv[n-m] % P;\n}\n\nnamespace subtask {\n    int main(int lim) {\n        if (n & 1) return write(0), 0;\n        int pre = 1;\n        for (int i = 1;i <= m; i++) if (!a[i]) {\n            if ((i - pre) & 1) Mn(lim, i - pre);\n            pre = i + 1;\n        }\n        n >>= 1, lim = (lim + 1) >> 1;\n        f[0] = sum[0] = 1;\n        for (int i = 1;i <= n; i++) {\n            f[i] = sum[i-1] - (i >= lim + 1 ? sum[i - lim - 1] : 0), Add(f[i], P);\n            sum[i] = sum[i-1], Add(sum[i], f[i]);\n        }\n        for (int i = 1;i <= lim; i++)\n            Add(ans, 1ll * f[n-i] * i * 2 % P);\n        write(ans);\n        return 0;\n    }\n}\n\nint main() {\n    read(n), read(m), scanf (\"%s\", s + 1);\n    for (int i = 1;i <= m; i++) a[i] = s[i] == s[1];\n    for (int i = 1;i <= m; i++)\n        if (!a[i]) return subtask::main((i - 1) | 1);\n    if (n == 1) return write(0), 0;\n    inv[0] = inv[1] = fac[0] = fac[1] = 1;\n    for (int i = 2;i <= n + 2; i++) \n        inv[i] = (P - P / i) * inv[P % i] % P;\n    for (int i = 2;i <= n + 2; i++)\n        inv[i] = inv[i-1] * inv[i] % P, fac[i] = fac[i-1] * i % P;\n    for (int i = 0;i + i <= n; i++) \n        ans += C(n - i, i) + C(n - 2 - i, i);\n    write(ans % P);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\nusing namespace std;\nconst int mod=1e9+7;\nint n,m,i,lst,dp[200005],s[200005],f[200005][2],tmp,mi=0x3f3f3f3f,l;\nstring st;\nint main(){\n\tcin>>n>>m;\n\tcin>>st;\n\tst=\" \"+st;\n\ti=1;lst=1;\n\twhile(i<=m){\n\t\tif(st[i]!=st[i-1]){\n\t\t\tif(st[i]!=st[1]){\n\t\t\t\tif(lst==1||((i-lst)&1)){\n\t\t\t\t\tmi=min(mi,i-lst);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlst=i;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tif(mi<0x3f3f3f3f){\n\t\tif(n&1){\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\tmi=mi/2+1;\n\t\tn/=2;\n\t\tl=1;\n/*\t\ts[1]=1;s[mi+1]+=mod-1;\n\t\trep(i,n){\n\t\t\ttmp=(tmp+s[i])%mod;\n\t\t\tdp[i]=tmp;\n\t\t\ts[min(n,i+1)]=(s[min(n,i+1)]+dp[i])%mod;\n\t\t\ts[min(n,i+mi)+1]=(s[min(n,i+mi)+1]+mod-dp[i])%mod;\n\t\t}\n\t\tcout<<dp[n]<<endl;*/\n\t}\n\telse{\n\t\tl=2;\n\t}\n\tfor(i=l;i<=n;i++){\n\t\tdp[i]=(s[i-l]+(i>mi?-s[i-mi-1]:(3ll-l)*i))%mod;\n\t\ts[i]=(s[i-1]+dp[i])%mod;\n\t}\n\tcout<<(dp[n]+l-1+mod)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\ntemplate<typename T>\nstruct BIT {\n    int n;\n    vector<T> dat;\n\n    BIT(int n=0){\n        initialize(n);\n    }\n\n    void initialize(int nin){\n        n = nin;\n        dat.resize(n);\n        for(int i = 0; i<n; i++) dat[i] = 0;\n    }\n\n    T sum(int i){\n        T s = 0;\n        while(i >= 0){\n            add(s, dat[i]);\n            i = (i & (i+1)) - 1;\n        }\n        return s;\n    }\n\n    T sum_between(int i, int j){\n        int64_t res = sum(j);\n        if(i>0) add(res, MOD - sum(i-1));\n        return res;\n    }\n\n    void plus(int i, T x){\n        while(i < n){\n            add(dat[i], x);\n            i |= i+1;\n        }\n    }\n\n    // a[0]+...+a[ret] >= x\n    int lower_bound(T x){\n        int ret = -1;\n        int k = 1;\n        while(2*k <= n) k <<= 1;\n        for( ;k>0; k>>=1){\n            if(ret+k < n && dat[ret+k] < x){\n                x -= dat[ret+k];\n                ret += k;\n            }\n        }\n        return ret + 1;\n    }\n};\n\nvoid solve1(int N){\n    static int64_t dp[200001][2][2] = {0};\n    dp[0][0][0] = dp[0][1][1] = 1;\n    for(int i=0; i<N-1; i++){\n        for(int j=0; j<2; j++){\n            add(dp[i+1][0][j], dp[i][0][j] + dp[i][1][j]);\n            add(dp[i+1][1][j], dp[i][0][j]);\n        }\n    }\n    int64_t ans = (dp[N-1][0][0] + dp[N-1][1][0] + dp[N-1][0][1]) % MOD;\n    cout << ans << endl;\n    exit(0);\n}\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    if(S[0] == 'B'){\n        for(int i=0; i<M; i++) S[i] = (S[i] == 'B' ? 'R' : 'B');\n    }\n\n    int len = 0, mn = M;\n    for(int i=0; i<M; i++){\n        if(S[i] == 'R'){\n            len++;\n        }else{\n            if(len > 0) mn = min(mn, len);\n            len = 0;\n        }\n    }\n    if(mn == M){\n        solve1(N);\n    }\n    if(N%2){\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int lim = (mn/2+1)*2;\n    BIT<int64_t> bit(N+1);\n    bit.plus(0, 1);\n    for(int i=2; i<=N; i+=2){\n        int l = max(0, i-lim);\n        int64_t res = bit.sum_between(l, i-1);\n        bit.plus(i, res);\n    }\n\n    int64_t ans = 0;\n    for(int i=1; i<=min(N-1, lim-1); i+=2){\n        add(ans, (i+1) * bit.sum_between(N-i-1, N-i-1) % MOD);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define set0(x) memset(x,0,sizeof(x))\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> void read(T &x){\n\tx = 0;char ch = getchar();int f = 1;\n\twhile(!isdigit(ch)){if(ch == '-')f*=-1;ch=getchar();}\n\twhile(isdigit(ch)){x = x*10+ch-48;ch=getchar();}x*=f;\n}\nint mod = 1000000007;\ninline int mul(int x,int y){return 1ll*x*y%mod;}\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint sub(int x,int y){return x-y<0?x-y+mod:x-y;}\nint sq(int x){return 1ll*x*x%mod;}\nint pow(int a,int b){return b == 0 ? 1 : ( b&1 ? mul(a,sq(pow(a,b/2))) : sq(pow(a,b/2)));}\nconst int N = 200020;\nint n,m,dp[N] = {0},sudp[N] = {0};\nchar ch[N];\nint ans = 0;\nint main() {\n\tread(n);read(m);\n\tscanf(\"%s\",ch);\n\tint ftt = 0,clen = 0;\n\tfor(int i=1;i<m;i++){\n\t\tif(ch[i]!=ch[0]){\n\t\t\tftt = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(ftt){\n\t\tclen = (ftt%2)?(ftt):(ftt-1);\n\t\tint la = ftt;\n\t\t//cout<<clen<<endl;\n\t\tfor(int i=ftt+1;i<n;i++){\n\t\t\tif(ch[i]==ch[0] && ch[i+1]!=ch[0]){\n\t\t\t\t//cout<<\"OC \"<<i<<' '<<la<<endl;\n\t\t\t\tif((i-la)%2) clen = min(clen,i-la);\n\t\t\t}\n\t\t\tif(ch[i]!=ch[0])la = i;\n\t\t}\n\t}\n\tint clim = (clen+1)/2;\n\t//cout<<ftt<<' '<<clen<<' '<<clim<<endl;\n\tdp[0] = sudp[0] = 1;\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = sudp[i-1];\n\t\tif(i-clim-1>=0)dp[i] = sub(dp[i],sudp[i-clim-1]);\n\t\tsudp[i] = add(sudp[i-1],dp[i]);\n\t}\n\tif(ftt == 0){\n\t\tans = 0;\n\t\tdp[1] = sudp[1] = 1;\n\t\tdp[2] = sudp[2] = 1;\n\t\tans = n+1;\n\t\tfor(int i=3;i<n;i++){\n\t\t\tdp[i] = sudp[i-2];\n\t\t\tsudp[i] = add(sudp[i-1],dp[i]);\n\t\t\tans = add(ans,mul(dp[i],n-i+1));\n\t\t}\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\tif(n%2){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=min(clen+1,n);i++){\n\t\tint cl = (n-clen-1)/2,cr = (n-i)/2;\n\t\tif(n-2*cl-1>clen)cl+=1;\n\t\tif(i == 1 && i+cr*2 == n)cr-=1;\n\t\tif(cr<cl)continue;\n\t\t//cout<<i<<' '<<i+cl*2<<' '<<i+cr*2<<' '<<ans<<endl;\n\t\tans = add(ans,sudp[cr]);\n\t\tif(cl>0) ans = sub(ans,sudp[cl-1]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline tuple<int, int, int> extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nunsigned ModInt::MOD = 1000000007;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\n\n\nconst int limit = 200010;\nmint dp[limit];\nmint csum[limit];\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\n\n\tint cmin = n, cons = 0;\n\trep(i, m){\n\t\tif(s[i] == s[0]){\n\t\t\tcons++;\n\t\t} else {\n\t\t\tchmin(cmin, cons);\n\t\t}\n\t}\n\n\tif(cmin % 2 == 0) cmin++;\n\tdp[1] = csum[1] = ONE;\n\n\trep(i, 1, n){\n\t\tconst int pos = max(i - cmin - 1, 0);\n\t\tif((i + 1) % 2 == 1) dp[i + 1] =  csum[i] - csum[pos];\n\t\tcsum[i + 1] = csum[i] + dp[i + 1];\n\t}\n\n\tmint ans = ZERO;\n\n\trep(i, n - cmin, n + 1){\n\t\tconst mint coef = mint(n - i + 1);\n\t\tans += coef * dp[i];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nint Mn(int a,int b){return a<b?a:b;}\nconst int N=2e5+5,mod=1e9+7;\nint upt(int x){while(x>=mod)x-=mod;while(x<0)x+=mod;return x;}\n\nint n,m,lm,dp[N],sm[N],ans,f[N][3];\nchar s[N];\nvoid solve()\n{\n  f[1][0]=1;\n  for(int i=2;i<=n;i++)\n    {\n      f[i][0]=f[i-1][0];\n      f[i][1]=(f[i-1][1]+f[i-1][2]);\n      f[i][2]=upt(f[i-1][0]+f[i-1][1]);\n    }\n  int ans=(f[n][0]+upt(f[n][1]+f[n][2]));\n  f[1][2]=1; f[1][0]=f[1][1]=0;\n  for(int i=2;i<=n;i++)\n    {\n      f[i][1]=(f[i-1][1]+f[i-1][2]);\n      f[i][2]=f[i-1][1];\n    }\n  ans=upt(ans+f[n][1]); printf(\"%d\\n\",ans);\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&m);\n  scanf(\"%s\",s+1); bool fg=0;\n  for(int i=1;i<=m;i++)\n    if(s[i]!=s[1]){fg=1;break;}\n  if(!fg){solve();return 0;}\n  if(n&1){puts(\"0\");return 0;}\n  lm=n+1; int lst;\n  for(int i=m;i;i--)if(s[i]==s[1]){lst=i;break;}\n  for(int i=1;i<=m;i++)\n    if(s[i]==s[1])//== not !=\n      {\n\tint j=i;\n\twhile(j+1<=m&&s[j+1]==s[j])j++;\n\tswap(i,j); j=i-j+1;\n\tif(i-j==0) lm=Mn(lm,j+((j&1)==0));\n\telse if((j&1)&&i!=lst)lm=Mn(lm,j);//i!=lst!!!\n      }\n  n>>=1; lm=(lm+1)>>1; dp[0]=sm[0]=1;\n  for(int i=1;i<=n;i++)\n    {\n      dp[i]=sm[i-1]; if(i>lm)dp[i]=upt(dp[i]-sm[i-lm-1]);\n      sm[i]=upt(sm[i-1]+dp[i]);\n    }\n  int ans=0;\n  for(int i=1;i<=lm;i++)//lm not n\n    ans=(ans+(ll)i*2*dp[n-i])%mod;\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=200005,mod=1e9+7;\nint n,m,c[N],k,lst,f[N],pfx[N],ans; char s[N];\ninline int sum(CI x,CI y)\n{\n\tint t=x+y; return t>=mod?t-mod:t;\n}\nnamespace SP //one char solver\n{\n\tint f[N][2][2];\n\tinline int solve(void)\n\t{\n\t\tf[1][0][0]=f[1][1][1]=1; for (RI i=2;i<=n;++i)\n\t\tf[i][0][0]=sum(f[i-1][0][0],f[i-1][0][1]),f[i][0][1]=f[i-1][0][0],\n\t\tf[i][1][0]=sum(f[i-1][1][0],f[i-1][1][1]),f[i][1][1]=f[i-1][1][0];\n\t\treturn sum(f[n][0][0],sum(f[n][0][1],f[n][1][0]));\n\t}\n};\nint main()\n{\n\tRI i; for (scanf(\"%d%d%s\",&n,&m,s+1),lst=1,i=2;i<=n;++i)\n\tif (s[i]!=s[i-1]) c[++k]=i-lst,lst=i; c[++k]=n-lst+1;\n\tif (k==1) return printf(\"%d\",SP::solve()),0;\n\tif (k&1) --k; int lim=c[1]+1; for (i=3;i<=k;i+=2) if (c[i]&1) lim=min(lim,c[i]);\n\tfor (n>>=1,lim=lim+1>>1,f[0]=pfx[0]=i=1;i<=n;++i)\n\tf[i]=sum(pfx[i-1],mod-(i-1-lim>=0?pfx[i-1-lim]:0)),\n\tpfx[i]=sum(pfx[i-1],f[i]); for (i=1;i<=min(n,lim);++i)\n\tans=sum(ans,2LL*f[n-i]*i%mod); return printf(\"%d\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inv(x) power(x,Mod-2)\n#define NO() {puts(\"0\");return 0;}\nusing namespace std;\ntypedef long long ll;\nconst int Mod=998244353;\nint add(int a,const int b){a+=b;if(a>=Mod)a-=Mod;return a;}\nint sub(int a,const int b){a-=b;if(a<0)a+=Mod;return a;}\nint mul(const int a,const int b){return (ll)a*b%Mod;}\nint power(int x,int cs)\n{\n\tint ras=1;\n\twhile(cs)\n\t{\n\t\tif(cs&1) ras=mul(ras,x);\n\t\tx=mul(x,x);cs>>=1;\n\t}\n\treturn ras;\n}\nconst int N=2e5+50;\nint n,m,tag=0,mx,ans=0;\nchar s[N];\nint val[N],dp[N],sum[N];\nint q(int l,int r)\n{\n\tif(l>r) return 0;\n\tint ras=sum[r];\n\tif(l!=0) ras=sub(ras,sum[l-1]);\n\treturn ras;\n}\nint main()\n{\n\t\n\tint i,x,pos;\n\tscanf(\"%d%d\",&n,&m);\t\n\t\n\tscanf(\"%s\",s+1);\n\tif(s[1]=='B') tag=1;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tif(s[i]=='R') val[i]=(1^tag);\n\t\telse val[i]=(0^tag);\n\t}\n\tfor(x=1;x<=m&&val[x]==1;x++);\n\tx--;\n\tif(x==m)\n\t{\n\t\tmx=n;ans=1;\n\t\tdp[0]=1;sum[0]=1;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tdp[i]=q(max(i-mx,0),i-2);\n\t\t\tsum[i]=add(sum[i-1],dp[i]);\n\t\t}\n\t\t//printf(\"%d %d\\n\",dp[1],dp[2]);\n\t\tfor(i=2;i<=mx;i++)\n\t\t{\n\t\t\tans=add(ans,mul(i,dp[n-i]));\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(n&1) NO();\n\t\tif(x&1) mx=x;\n\t\telse mx=x+1;\n\t\tfor(i=x+1;i<=m;)\n\t\t{\n\t\t\tif(val[i]==0) \n\t\t\t{\n\t\t\t\ti++;continue;\n\t\t\t}\n\t\t\tpos=i;\n\t\t\twhile(val[pos]==1) pos++;\n\t\t\tpos--;\n\t\t\tif((pos-i+1)&1) mx=min(mx,pos-i+1);\n\t\t\ti=pos+1;\n\t\t}\n\t\tn=(n+1)/2;mx=(mx+1)/2;\n\t\tdp[0]=1;sum[0]=1;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tdp[i]=q(max(i-mx,0),i-1);\n\t\t\tsum[i]=add(sum[i-1],dp[i]);\n\t\t}\n\t\tfor(i=1;i<=mx;i++)\n\t\t{\n\t\t\tans=add(ans,mul(i<<1,dp[n-i]));\n\t\t}\n\t}\n\t//printf(\"n%d mx%d\\n\",n,mx);\n\t\n\t\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define Md 1000000007\n#define MN 200005\nint n,m;\nchar c[MN];\nlg Pow(lg x,lg y){\n\tlg res=1;for(;y;y>>=1,x=x*x%Md)if(y&1)res=res*x%Md;return res;\n}\nint Fix(int x){\n\tif(x<0)return x+Md;\n\tif(x>=Md)return x-Md;\n\treturn x;\n}\nint dp[MN],tmp[MN];\nint miu[MN];\nint main(){\n\tread(n);read(m);\n\tscanf(\"%s\",c+1);\n\tmiu[1]=1;\n\tfor(int i=1;i<MN;++i){\n\t\tfor(int j=i+i;j<MN;j+=i){\n\t\t\tmiu[j]-=miu[i];\n\t\t}\n\t}\n\tchar Hd=c[1];\n\tint cnt=0,mx;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse break;\n\t}\n\tif(cnt&1)mx=cnt;else mx=cnt+1;\n\tif(cnt==m){\n\t\tif(n&1)return puts(\"0\"),0;\n\t\tint res=0;\n\t\ttmp[0]=tmp[1]=1;\n\t\tdp[0]=1;\n\t\tif(n>2)res=n;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tdp[i]=(i>=2?tmp[i-2]:0);\n\t\t\ttmp[i]=Fix(tmp[i-1]+dp[i]);\n\t\t\tif(i<n-1)res=Fix(res+1ll*dp[i]*(n-i)%Md);\n\t\t}\n\t\tprintf(\"%d\",res+1);\n\t\treturn 0;\n\t}\n\tint res=(cnt==m);\n\tcnt=0;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse{\n\t\t\tif(!cnt)continue;\n\t\t\tif(cnt&1)mx=min(mx,cnt);\n\t\t\tcnt=0;\n\t\t}\n\t}\n\t//for(int i=1;i<=5;++i)cerr<<miu[i]<<' ';cerr<<endl;\n\ttmp[0]=tmp[1]=1;\n\tdp[0]=1;\n\tmx+=2;\n\tif(n<mx)res+=n;\n\tfor(int i=2;i<=n;i+=2){\n\t\tdp[i]=Fix(tmp[i-1]-(mx>i?0:tmp[i-mx]));\n\t\ttmp[i]=tmp[i+1]=Fix(tmp[i-1]+dp[i]);\n\t\t//cerr<<dp[i]<<' '<<i<<endl;\n\t\tif((n-i)%2==0&&n-i<mx)res=Fix(res+1ll*dp[i]*(n-i)%Md);\n\t}\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nchar str[200005];\nint arr[200005];\nlong long MOD=1000000007;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",str);\n\tfor(int i=0;i<m;i++)if(str[i]=='R')arr[i]=0;else arr[i]=1;\n\tbool all[2];all[0]=all[1]=1;\n\tfor(int i=0;i<m;i++)all[arr[i]^1]=0;\n\tif(all[0]||all[1]){\n\t\tlong long dp[2][n];memset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;dp[1][0]=0; //start with red (or blue if everything is blue)\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tlong long ans=(dp[0][n-1]+dp[1][n-1])%MOD;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=0;dp[1][0]=1; //start with blue\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tans+=dp[0][n-1];ans%=MOD;ans+=MOD;ans%=MOD;\n\t\tprintf(\"%lld\",ans);\n\t\treturn 0;\n\t}\n\tif(n%2!=0){printf(\"0\");return 0;}\n\tint cur=0;bool b=0;\n\tint mxl=n-1;\n\tfor(int i=0;i<m;i++){\n\t\tif(arr[i]==arr[0])cur++;\n\t\telse{\n\t\t\tif(!b){\n\t\t\t\tb=1;mxl=min(mxl,cur|1);\n\t\t\t}else if(cur%2==1)mxl=min(mxl,cur);\n\t\t\tcur=0;\n\t\t}\n\t}\n\t//can ignore last segment of arr[0]\n\t//comments: wlog red is first\n\tn/=2; mxl/=2; //remove the ones that are different parity from blue\n\tlong long dp[100005],pref[100005];\n\tmemset(dp,0,sizeof(dp));memset(pref,0,sizeof(pref));\n\t//i segments on a line, first and last are blue, max mxl consecutive reds\n\t//blues may be consecutive because the reds in between were removed\n\tdp[1]=pref[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tdp[i]=pref[i-1]-pref[max(0,i-(mxl+2))];\n\t\tdp[i]%=MOD;dp[i]+=MOD;dp[i]%=MOD;\n\t\tpref[i]=dp[i]+pref[i-1];\n\t\tpref[i]%=MOD;pref[i]+=MOD;pref[i]%=MOD;\n\t}\n\tlong long ans=0;\n\tfor(long long i=2;i<=min(n,mxl+2);i++){\n\t\tans+=(i-1LL)*dp[n-i+2];\n\t\tans%=MOD;\n\t}\n\tans+=MOD;ans%=MOD;\n\tprintf(\"%lld\",(ans*2)%MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nchar s[200005];\nint f[200005];\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tif(s[1]=='B')\n\t\tfor(int i=1;i<=m;i++)s[i]=(s[i]=='R'?'B':'R');\n\tint lst=0,k=n;\n\tfor(int i=1;i<=m;i++){\n\t\tif(s[i]=='B'){\n\t\t\tif(lst==i-1)lst=i;\n\t\t\telse{\n\t\t\t\tif(!lst)k=min(k,i-lst);\n\t\t\t\tif((i-lst-1)&1)k=min(k,i-lst-1);\n\t\t\t}\n\t\t}\n\t}\n\t//printf(\"%d\\n\",k);\n\tif(k==n){\n\t\tint ans=2;\n\t\tf[1]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tf[i]=(f[i-1]+f[i-2])%mod;\n\t\t\tif(i!=n)ans=(ans+f[i])%mod;\n\t\t\telse ans=(ans+f[i-1])%mod;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(k&1)k++;\n\tf[1]=f[3]=1;\n\tfor(int i=5;i<=n;i+=2)f[i]=(2ll*f[i-2]+(i>k?mod-f[i-k-2]:0))%mod;\t\n\tint ans=0;\n\tfor(int i=1;i<=k;i++)if(i&1)ans=(ans+1ll*f[n-i]*(i+1))%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define int long long\nusing namespace std;\nconst int N = 2e5 + 5;\nconst int mod = 1e9 + 7;\nint n, m, k = 2e9, a[N], b[N], ans, f[N];\nchar s[N];\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nsigned main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read(); m = read(); scanf(\"%s\", s + 1);\n\tint tag = 1;\n\tfor(int i = 1, len = 0; i <= m; i ++)\n\t{\n\t\tif(s[i] != s[1])\n\t\t{\n\t\t\tif(tag || len & 1) k = min(k, len / 2 + 1);\n\t\t\ttag = len = 0;\n\t\t}\n\t\telse len ++;\n\t}\n\tif(tag)\n\t{\n\t\tf[0] = 0; f[1] = 1;\n\t\tfor(int i = 2; i <= n; i ++) f[i] = (f[i - 1] + f[i - 2]) % mod;\n\t\tprintf(\"%lld\\n\", (2 * f[n - 1] + f[n]) % mod);\n\t\treturn 0;\n\t}\n\tif(n & 1) {puts(\"0\"); return 0;}\n\tn /= 2; a[0] = b[0] = 1;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\ta[i] = b[i - 1];\n\t\tif(i > k) a[i] = (b[i - 1] - b[i - k - 1] + mod) % mod;\n\t\tb[i] = (b[i - 1] + a[i]) % mod;\n\t}\n\tfor(int i = 1; i <= k; i ++) ans = (ans + 2 * i * a[n - i]) % mod;\n\tprintf(\"%lld\\n\", ans);\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef double db;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pct __builtin_popcount\n\n#define P 1000000007\n\n#define N 200010\nint f[N], g[N];\n\nint n, m;\nstring s;\n\nint main() {\n\tcin >> n >> m >> s;\n\tif (s[0] == 'B') {\n\t\tfor (int i = 0; i < m; i ++)\n\t\t\ts[i] = 'R' + 'B' - s[i];\n\t}\n\tif (s == string(m, 'R')) {\n\t\tint fbb = 1, fbr = 0, frb = 0, frr = 1;\n\t\tfor (int i = 1; i < n; i ++) {\n\t\t\tint gbb = fbr;\n\t\t\tint gbr = (fbb + fbr)%P;\n\t\t\tint grb = frr;\n\t\t\tint grr = (frr + frb)%P;\n\t\t\tfbb = gbb;\n\t\t\tfbr = gbr;\n\t\t\tfrb = grb;\n\t\t\tfrr = grr;\n\t\t}\n\t\tint S = ((ll)frr + fbr + frb)%P;\n\t\tcout << S << endl;\n\t\treturn 0;\n\t}\n\tif (n%2 == 1) {\n\t\tputs (\"0\");\n\t\treturn 0;\n\t}\n\n\tint l = n;\n\tfor (int i = 0; i < m; ) {\n\t\tint j = i;\n\t\twhile (j < m && s[j] == s[i]) j++;\n\t\tif (j == m) break;\n\t\tif ((j-i)%2 == 1) {\n\t\t\tif (s[i] == 'R') l = min(l, j-i);\n\t\t} else {\n\t\t\tif (i == 0) l = min(l, j+1);\n\t\t}\n\t\ti = j;\n\t}\n\n\tl = (l+1)/2;\n\tn /= 2;\n\n\tf[0] = 1;\n\tg[1] = 1;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tif (i <= l) f[i] = g[i]; else {\n\t\t\tf[i] = (g[i] - g[i-l]+P)%P;\n\t\t}\n\t\tg[i+1] = (g[i] + f[i])%P;\n\t}\n\n\tint S = 0;\n\tfor (int i = 0; i < min(l, n); i ++) {\n\t\tint T = (g[n-i] - g[n-l]+P)%P;\n\t\t// f[n-i-1] + .. + f[n-l];\n\t\t(S += T) %= P;\n\t}\n\n\tS = (ll)S*2%P;\n\tcout << S << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct SegT {\nprivate:\n\tint sz; vector<ll> node;\n\tconst ll init_c = 0;\npublic:\n\tSegT(int n) {\n\t\tsz = 1;\n\t\twhile (sz < n)sz *= 2;\n\t\tnode.resize(2 * sz - 1, init_c);\n\t}\n\tll f(ll a, ll b) {\n\t\treturn (a + b)%mod;\n\t}\n\tvoid update(int k, ll a) {\n\t\tk += sz - 1;\n\t\tnode[k] = a;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\tll query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = sz;\n\t\tif (r <= a || b <= l)return init_c;\n\t\telse if (a <= l && r <= b)return node[k];\n\t\telse {\n\t\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn f(vl, vr);\n\t\t}\n\t}\n};\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nll dp[1 << 18][2][2];\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (s[0] == 'B') {\n\t\trep(i, m) {\n\t\t\tif (s[i] == 'B')s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\tvector<int> v;\n\trep(i, m) {\n\t\tint le = i;\n\t\twhile (i + 1 < m&&s[i + 1] == s[i])i++;\n\t\tv.push_back(i - le + 1);\n\t}\n\tif (v.size() == 1) {\n\t\tdp[0][0][0] = 1;\n\t\tdp[0][1][1] = 1;\n\t\trep(i, n - 1) {\n\t\t\trep(j, 2) {\n\t\t\t\t(dp[i + 1][0][j] += dp[i][0][j] + dp[i][1][j]) %= mod;\n\t\t\t\tdp[i + 1][1][j] += dp[i][0][j];\n\t\t\t}\n\t\t}\n\t\tll ans = dp[n - 1][0][0] + dp[n - 1][1][0] + dp[n - 1][0][1];\n\t\tcout << ans % mod << endl; return;\n\t}\n\tif (n % 2) {\n\t\tcout << 0 << endl; return;\n\t}\n\tint d = n / 2;\n\tint x = v[0] / 2 + 1;\n\tfor (int i = 0; i < v.size(); i += 2) {\n\t\tif (v[i] % 2) {\n\t\t\tx = max(x, v[i] / 2 + 1);\n\t\t}\n\t}\n\tif (x >= d) {\n\t\tll ans = mod_pow(2, d) - 1;\n\t\tans = ans * 2;\n\t\tans = (ans + mod) % mod;\n\t\tcout << ans << endl;\n\t}\n\telse {\n\t\tSegT dp(d + 1);\n\t\tdp.update(0, 1);\n\t\trep1(i, d - 1) {\n\t\t\tint le = i - x;\n\t\t\tle = max(le, 0);\n\t\t\tll nex = dp.query(le, i);\n\t\t\tdp.update(i, nex);\n\t\t}\n\t\tll ans = 0;\n\t\trep(i, x) {\n\t\t\tll z = dp.query(d - x, d - i); ans += z;\n\t\t\tif (ans >= mod)ans -= mod;\n\t\t}\n\t\tans = ans * 2 % mod;\n\t\tcout << ans << endl;\n\t}\n\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\n\n/// --- Modulo Integer {{{ ///\n#include <ostream>\ntemplate < long long mod = static_cast< long long >(1e9 + 7) >\nstruct ModuloInteger {\n  static_assert(mod > 0, \"mod must be positive\");\n  static_assert(mod <= 3037000499, \"mod is too big\");\n  using integer = long long;\n  static ModuloInteger unused;\n  // math {{{\n  static inline integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  static inline integer modpow(integer a, long long b) {\n    if(b < 0) b = -b, a = modinv(a);\n    integer r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  integer val;\n  constexpr ModuloInteger() : val(0) {}\n  constexpr ModuloInteger(integer t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\nprivate:\n  // strict constructor\n  constexpr ModuloInteger(integer t, int) : val(t) {}\n\npublic:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // operator bool() { return bool(val); }\n  // ModuloInteger <arithmetic-operator>[=] ModuloInteger {{{\n  ModuloInteger operator+(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModuloInteger operator-(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModuloInteger operator*(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModuloInteger operator/(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModuloInteger &operator+=(ModuloInteger const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModuloInteger &operator-=(ModuloInteger const &rhs) { return *this += -rhs; }\n  ModuloInteger &operator*=(ModuloInteger const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModuloInteger &operator/=(ModuloInteger const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModuloInteger operator++(int) {\n    ModuloInteger tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModuloInteger operator--(int) {\n    ModuloInteger tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModuloInteger &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModuloInteger &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModuloInteger operator-() const { return ModuloInteger(val == 0 ? 0 : mod - val, 0); }\n  // ModuloInteger <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModuloInteger operator+(T const &rhs) const {\n      return ModuloInteger(val + rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator-(T const &rhs) const {\n      return ModuloInteger(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator*(T const &rhs) const {\n      return ModuloInteger(val * (rhs % mod));\n    }\n  template < typename T >\n    ModuloInteger operator/(T const &rhs) const {\n      return ModuloInteger(val * modinv(rhs));\n    }\n  template < typename T >\n    ModuloInteger &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator/=(T const &rhs) {\n      val = val * modinv(rhs) % mod;\n      return *this;\n    }\n  // }}}\n  ModuloInteger inv() const { return ModuloInteger(modinv(val), 0); }\n  ModuloInteger operator~() const { return inv(); }\n  friend std::ostream &operator<<(std::ostream &os, ModuloInteger const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // equality operator {{{\n  ModuloInteger operator==(const ModuloInteger &a) const { return val == a.val; }\n  ModuloInteger operator!=(const ModuloInteger &a) const { return val != a.val; }\n  ModuloInteger operator==(const integer &a) const { return val == ModuloInteger(a); }\n  ModuloInteger operator!=(const integer &a) const { return val != ModuloInteger(a); }\n  // }}}\n  // T <arithmetic-operator> ModuloInteger {{{\n  friend constexpr ModuloInteger operator+(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod + mv.val);\n  }\n  friend constexpr ModuloInteger operator-(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod - mv.val);\n  }\n  friend constexpr ModuloInteger operator*(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModuloInteger operator/(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModuloInteger operator^(integer x) const { return pow(*this, x); }\n  ModuloInteger &operator^=(integer x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModuloInteger pow(ModuloInteger x, integer y) {\n    return ModuloInteger(modpow(x.val, y), 0);\n  }\n  // }}}\n};\ntemplate < long long mod >\nModuloInteger< mod > ModuloInteger< mod >::unused(mod, 0);\n/// }}}--- ///\n\nusing modint = ModuloInteger<>;\n\n\n// LazySegmentTree( size [, initial] )\n// LazySegmentTree( <data> )\n/// --- LazySegmentTree {{{ ///\n#include <cassert>\n#include <initializer_list>\n#include <iostream>\n#include <vector>\ntemplate < class M_act >\nstruct LazySegmentTree {\npublic:\n  using Monoid = typename M_act::Monoid;\n  using X = typename Monoid::T;\n  using M = typename M_act::M;\n\nprivate:\n  size_t n;\n  int h;\n  vector< X > data;\n  vector< M > lazy;\n  vector< size_t > nodeLength;\n  // call before use data[i]\n  void eval(size_t i) {\n    if(lazy[i] == M_act::identity()) return;\n    data[i] = M_act::actInto(lazy[i], nodeLength[i], data[i]);\n    if(i < n) {\n      lazy[i * 2] = M_act::op(lazy[i], lazy[i * 2]);\n      lazy[i * 2 + 1] = M_act::op(lazy[i], lazy[i * 2 + 1]);\n    }\n    lazy[i] = M_act::identity();\n  }\n  // call before use seg[i] = data[i + n]\n  void evalDown(size_t i) {\n    i += n;\n    for(int j = h - 1; j >= 0; j--) eval(i >> j);\n  }\n  // call after touch seg[i] = data[i + n]\n  void propUp(size_t i) {\n    i += n;\n    while(i >>= 1)\n      eval(i * 2), eval(i * 2 + 1), data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n  }\n\npublic:\n  LazySegmentTree() : n(0) {}\n  LazySegmentTree(size_t n, X initial = Monoid::identity()) : n(n) {\n    if(n > 0) {\n      h = 1;\n      while(1u << h < n) h++;\n      data.resize(2 * n, initial);\n      lazy.resize(2 * n, M_act::identity());\n      nodeLength.resize(2 * n, 1);\n      for(size_t i = n - 1; i > 0; i--) // fill from deep\n        data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]),\n          nodeLength[i] = nodeLength[i * 2] + nodeLength[i * 2 + 1];\n    }\n  }\n  template < class InputIter, class = typename iterator_traits< InputIter >::value_type >\n    LazySegmentTree(InputIter first, InputIter last)\n    : LazySegmentTree(distance(first, last)) {\n      if(n > 0) {\n        copy(first, last, begin(data) + n);\n        for(size_t i = n - 1; i > 0; i--) // fill from deep\n          data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n      }\n    }\n  LazySegmentTree(vector< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  LazySegmentTree(initializer_list< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  void act(int l, int r, const M &m) {\n    if(l < 0) l = 0;\n    if(l >= r) return;\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    int tl = l, tr = r;\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), lazy[l] = m, eval(l), l++;\n      if(r & 1) --r, eval(r), lazy[r] = m, eval(r);\n    }\n    propUp(tl);\n    propUp(tr - 1);\n  }\n  void set(size_t i, const X &x) {\n    assert(i < n);\n    evalDown(i);\n    data[i + n] = x;\n    propUp(i);\n  }\n  X get(size_t i) {\n    assert(i < n);\n    evalDown(i);\n    return data[i + n];\n  }\n  X fold(int l, int r) {\n    if(l < 0) l = 0;\n    if(l >= r) return Monoid::identity();\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    X tmpL = Monoid::identity(), tmpR = Monoid::identity();\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), tmpL = Monoid::op(tmpL, data[l]), l++;\n      if(r & 1) --r, eval(r), tmpR = Monoid::op(data[r], tmpR);\n    }\n    return Monoid::op(tmpL, tmpR);\n  }\n  int size() { return n; }\n  inline void dum(int r = -1) {\n#ifdef DEBUG\n    if(r < 0) r = n;\n    DEBUG_OUT << \"{\";\n    for(int i = 0; i < min(r, (int) n); i++) DEBUG_OUT << (i ? \", \" : \"\") << get(i);\n    DEBUG_OUT << \"}\" << endl;\n#endif\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid examples {{{ ///\nconstexpr long long inf_monoid = 1e18 + 100;\n#include <algorithm>\nstruct Nothing {\n  using T = char;\n  using Monoid = Nothing;\n  using M = T;\n  static constexpr T op(const T &, const T &) { return T(); }\n  static constexpr T identity() { return T(); }\n  template < class X >\n    static constexpr X actInto(const M &, long long, const X &x) {\n      return x;\n    }\n};\n\ntemplate < class U = long long >\nstruct RangeMin {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::min< T >(a, b); }\n  static constexpr T identity() { return T(inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeMax {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::max< T >(a, b); }\n  static constexpr T identity() { return T(-inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeSum {\n  using T = U;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return T(0); }\n};\n\ntemplate < class U >\nstruct RangeProd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a * b; }\n  static constexpr T identity() { return T(1); }\n};\n\ntemplate < class U = long long >\nstruct RangeOr {\n  using T = U;\n  static T op(const T &a, const T &b) { return a | b; }\n  static constexpr T identity() { return T(0); }\n};\n\n#include <bitset>\n\ntemplate < class U = long long >\nstruct RangeAnd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return T(-1); }\n};\n\ntemplate < size_t N >\nstruct RangeAnd< std::bitset< N > > {\n  using T = std::bitset< N >;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return std::bitset< N >().set(); }\n};\n\n/// }}}--- ///\n\n/// --- M_act examples {{{ ///\ntemplate < class U = long long, class V = U >\nstruct RangeMinAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMin< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMax< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMinSet {\n  using M = U;\n  using Monoid = RangeMin< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxSet {\n  using M = U;\n  using Monoid = RangeMax< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long n, const X &x) { return m * n + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long n, const X &x) {\n    return m == identity() ? x : m * n;\n  }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdMul {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M mpow(M a, long long b) {\n    X r(1);\n    while(b) {\n      if(b & 1) r = r * a;\n      a = a * a;\n      b >>= 1;\n    }\n    return r;\n  }\n  static M op(const M &a, const M &b) { return a * b; }\n  static constexpr M identity() { return M(1); }\n  static X actInto(const M &m, long long n, const X &x) { return x * mpow(m, n); }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return V::unused; }\n  static X actInto(const M &m, long long n, const X &) {\n    if(m == identity()) return;\n    return RangeProdMul< U, V >::mpow(m, n);\n  }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeOr2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeOr< U >;\n  static M op(const M &a, const M &b) { return a | b; }\n  static constexpr M identity() { return M(0); }\n  static X actInto(const M &m, long long, const X &x) { return m | x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeAnd2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return M(-1); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n\ntemplate < class U, size_t N >\nstruct RangeAnd2< U, std::bitset< N > > {\n  using X = U;\n  using M = std::bitset< N >;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return std::bitset< N >().set(); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n/// }}}--- ///\n\nusing Seg = LazySegmentTree< RangeSumAdd<modint> >;\n\n\n// NOTE : use H with larger N\n/// --- Modulo Factorial {{{ ///\n#include <cassert>\n#include <cstddef>\ntemplate < std::size_t N, int mod = static_cast< int >(1e9 + 7) >\nstruct Factorial {\n  using integer = long long;\n  constexpr integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d = 0;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  constexpr integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  int arr[N + 1], inv[N + 1];\n  integer operator[](int i) const { return arr[i]; }\n  Factorial() : arr(), inv() {\n    arr[0] = 1;\n    for(std::size_t i = 1; i <= N; i++) {\n      arr[i] = (integer) i * arr[i - 1] % mod;\n    }\n    inv[N] = modinv(arr[N]);\n    for(int i = N - 1; i >= 0; i--) {\n      inv[i] = (integer)(i + 1) * inv[i + 1] % mod;\n    }\n  }\n  integer C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    assert(n <= N);\n    return (integer) arr[n] * inv[r] % mod * inv[n - r] % mod;\n  }\n  integer H(int n, int r) const { return C(n + r - 1, r); }\n};\n/// }}}--- ///\n\nconstexpr int mod = 1e9 + 7;\nconst int N = 2e5 + 10;\nFactorial< N * 2, mod > fact;\n\n\n\nint n, m;\nint r, b;\nint rmax;\nstring s;\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n >> m;\n  cin >> s;\n  if(s[0] == 'B') for(auto &e : s) e = e == 'R' ? 'B' : 'R';\n  bool allR = 1;\n  for(auto e : s) allR &= e == 'R';\n\n  if(allR) {\n    dump(\"allR\");\n    modint ans;\n    for(int B = 0; B <= n; B++) {\n      int R = n - B - B;\n      ans += modint(fact.C(R + B, R));\n      ans += modint(fact.C(R + B - 1, R));\n    }\n    cout << ans << endl;\n    return 0;\n  }\n\n  if(n % 2 == 1) {\n    cout << 0 << endl;\n    dump(\"odd\");\n    return 0;\n  }\n\n  int c = 0;\n  bool first = 1;\n  for(int i = 0; i <= m; i++) {\n    if(i == n || s[i] == 'B') {\n      if(c % 2 == 0 && first) rmax = max(rmax, c + 1);\n      if(c % 2 == 1) rmax = max(rmax, c);\n      c = 0;\n      first = 0;\n    } else c++;\n  }\n\n  dump(rmax);\n\n  // RB\n\n  // vector<modint> dp(n + 1);\n  Seg dp(n + 1);\n  dp.set(0, 1);\n\n  modint ans;\n\n  for(int i = 0; i <= n - 1; i+=2) {\n    dp.act(i + 2, min<int>(n - 1, i + 1 + rmax) + 1, dp.get(i));\n    if(i + 1 + rmax >= n) {\n      int f = n - i - 1;\n      if (f >= 1) {\n        dump(i, dp.get(i), f);\n        ans += dp.get(i) * (f + 1);\n      }\n    }\n  }\n  cout << ans << endl;\n  dp.dum();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define mod 1000000007\n#define N 200050\nint n,m,dp[N][2][2],fg,mx,fg2,dp2[N],su[N],as;\nchar s[N];\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tfor(int i=2;i<=m;i++)if(s[i]!=s[i-1])fg=1;\n\tif(!fg)\n\t{\n\t\tdp[1][1][1]=dp[1][0][0]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\tdp[i][0][0]=(dp[i-1][0][0]+dp[i-1][1][0])%mod,\n\t\tdp[i][0][1]=(dp[i-1][0][1]+dp[i-1][1][1])%mod,\n\t\tdp[i][1][0]=dp[i-1][0][0],\n\t\tdp[i][1][1]=dp[i-1][0][1];\n\t\tprintf(\"%lld\\n\",(1ll*dp[n][0][0]+dp[n][0][1]+dp[n][1][0])%mod);\n\t\treturn 0;\n\t}\n\tint su1=0;\n\tfor(int i=1;i<=n;i++)\n\tif(s[i]==s[1])su1++;\n\telse\n\t{\n\t\tif((su1&1)&&mx>su1)mx=su1;\n\t\tif(!fg2)mx=su1+1;\n\t\tfg2=1;\n\t}\n\tif(~mx&1)mx--;\n\tdp2[1]=1;su[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(i-mx>3)dp2[i]=su[i-2]-su[i-mx-3];\n\t\telse dp2[i]=su[i-2];\n\t\tsu[i]=su[i-2]+dp2[i];\n\t}\n\tfor(int i=1;i<=mx;i+=2)as=(as+1ll*dp2[n-i]*(i+1))%mod;\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\tconst int N=2e5+9,mod=1e9+7;\n\tinline int add(int x,int y){return x+y>=mod?x-mod+y:x+y;}\n\tinline int sub(int x,int y){return x>=y?x-y:x+mod-y;}\n\tinline int qpow(int x,int y){\n\t\tint ret=1;\n\t\twhile(y){\n\t\t\tif(y&1) ret=1LL*x*ret%mod;\n\t\t\tx=1LL*x*x%mod,y>>=1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint n,m,f[N],sum[N];char s[N];\n\tint main(){\n\t\tn=read<int>(),m=read<int>(),scanf(\"%s\",s+1);\n\t\t\n\t\tint peg=1;\n\t\tfor(int i=2;i<=m;i++) if(s[1]!=s[i]) peg=0;\n\t\tif(peg){\n\t\t\tf[0]=1,f[1]=0,sum[0]=sum[1]=1;\n\t\t\tfor(int i=2;i<=n;i++)\n\t\t\t\tf[i]=sum[i-2],sum[i]=add(sum[i-1],f[i]);\n\t\t//\tfor(int i=1;i<=n;i++) cout<<f[i]<<\" \";cout<<endl;\n\t\t\tint ans=0;\n\t\t\tfor(int i=2;i<=n;i++) ans=add(ans,1LL*f[n-i]*i%mod);\n\t\t\tprintf(\"%d\\n\",add(ans,1));\n\t\t\treturn 0;\n\t\t}\n\t\tint mx=0,i,t;\n\t\tfor(i=1;i<=m;i++)\n\t\t\tif(s[i]!=s[1]){mx=i-1+(~(i-1)&1);break;}\n\t\tfor(t=0;i<=m;i++)\n\t\t\tif(s[i]!=s[1]){\n\t\t\t\tif(t&1) mx=min(mx,t);\n\t\t\t\tt=0;\n\t\t\t}else t++;\n\t\tif(t&1) mx=max(mx,t);\n\n\t\tf[0]=1,f[1]=0,sum[0]=sum[1]=1;\n\t\tfor(i=2;i<=n;i++){\n\t\t\tf[i]=sub(sum[i-2],i-mx-2>=0?sum[i-mx-2]:0),sum[i]=sum[i-1];\n\t\t\tif(~i&1) sum[i]=add(sum[i],f[i]);\n\t\t}\n\t//\tfor(int i=1;i<=n;i++) cout<<f[i]<<\" \";cout<<endl;\n\t\tint ans=0;\n\t\tfor(int i=2;i<=mx+1;i++) if(~i&1) ans=add(ans,1LL*f[n-i]*i%mod);\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "/*\n¼ÙÉèS[1] = R¡£ÄÇÃ´ÏÔÈ»£¬»·ÉÏ²»»á³öÏÖÁ½¸öÁ¬ÐøµÄ±ß¶¼ÊÇB£¬·ñÔòÔÚËüÃÇ½»µã´¦µÚÒ»²½ÍùÁ½±ß×ß¶¼²»ºÏ·¨\nÌØÅÐµôSÖÐÈ«ÊÇRµÄÇé¿ö£¬¿¼ÂÇÒ»°ãÇé¿ö \nÊ×ÏÈ°ÑËùÓÐÊÇBµÄÎ»ÖÃ¶Ï¿ª£¬ÄÇÃ´¾ÍÐÎ³ÉÁËÈô¸É¸öRµÄÁ¬Ðø¶Î¡£¿ÉÒÔ·¢ÏÖÕâÃ´Ò»¸öÐÔÖÊ£ºÃ¿¸öÁ¬Ðø¶ÎµÄ³¤¶È¾ùÎªÆæÊý\nÖ¤Ã÷¿¼ÂÇ·´Ö¤¡£¼ÙÉèÓÐÒ»¸öÅ¼ÊýµÄ¶Î£¬¿¼ÂÇ¶þ·ÖÍ¼¿ÉÒÔ·¢ÏÖ£¬ÄÇÃ´ÓÐµÄµã×ßµ½ÕâÒ»¶ÎµÄ¶Ëµã¾àÀëÓÀÔ¶ÊÇÅ¼Êý¡¢ÓÐµÄµã×ßµ½ÕâÒ»¶ÎµÄ¶Ëµã¾àÀëÓÀÔ¶ÊÇÆæÊý£¬ÒòÎª¶ËµãÍ¬É«\n¶øSµÄµÚÒ»¶ÎÁ¬ÐøR³¤¶ÈÊÇ¹Ì¶¨µÄ£¬²»ÄÜÍ¬Ê±ÎªÅ¼Êý»òÆæÊý£¬Ã¬¶Ü¡£ËùÒÔ¿ÉÒÔµÃµ½½áÂÛ\nÍ¬Ê±£¬SÖÐÃ¿¸öRµÄÁ¬Ðø¶Î¶¼»á¶Ô»·ÉÏÃ¿¸öRµÄÁ¬Ðø¶ÎÓÐ¸öÉÏ½çµÄÏÞÖÆ \n*/\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int Max_NM(200050);\nconst int MOD(1000000000 + 7);\ntypedef long long int LL;\n\nint N, M, L, F[Max_NM], Pre[Max_NM][2], Ans;\nchar S[Max_NM];\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nconstexpr int Sub(int a, int b)\n{\n\treturn a - b < 0 ? a - b + MOD : a - b;\n}\n\nconstexpr int Mult(int a, int b)\n{\n\treturn a * 1LL * b % MOD;\n}\n\ninline void upd(int &a, int b)\n{\n\ta = Add(a, b);\n}\n\nvoid dp(bool have)\n{\n\tF[1] = 1, Pre[1][1 & 1] = 1;\n\tfor (int i = 2, j;i <= N;++i)\n\t{\n\t\tPre[i][0] = Pre[i - 1][0], Pre[i][1] = Pre[i - 1][1];\n\t\tupd(Pre[i][i & 1], F[i - 2]);\n\t\t//jµ½iÊÇR£¬i - j + 1 <= L   =>   j >= i - L + 1\n\t\t//i - j + 1ÊÇÆæÊý£¬i - jÊÇÅ¼Êý£¬iºÍjÆæÅ¼ÐÔÏàµÈ\n\t\tj = max(1, i - L + 1);\n\t\tif (j <= i)\n\t\t{\n\t\t\tF[i] = Sub(Pre[i][i & 1], Pre[j - 1][i & 1]);\n\t\t\tif (have)\n\t\t\t\tupd(F[i], Sub(Pre[i][(i & 1) ^ 1], Pre[j - 1][(i & 1) ^ 1]));\n\t\t}\n\t}\n\t\n}\n\nint main()\n{ \n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tbool haveB = false;\n\tif (S[1] == 'B')\n\t\tfor (int i = 1;i <= M;++i)\n\t\t\tS[i] = 'R' + 'B' - S[i];\n\tfor (int i = 1;i <= M;++i)\n\t\thaveB |= (S[i] == 'B');\n\tL = N;\n\tfor (int i = 1, length = 0, stop = 0;i <= M;++i)\n\t\tif (S[i] == 'B')\n\t\t\tlength = 0, stop = 1;\n\t\telse\n\t\t{\n\t\t\t++length;\n\t\t\tif (i + 1 <= N && S[i + 1] == 'B')\n\t\t\t\tif (stop == 0)\n\t\t\t\t\tif (length & 1)\n\t\t\t\t\t\tL = min(L, length);\n\t\t\t\t\telse\n\t\t\t\t\t\tL = min(L, length + 1);\n\t\t\t\telse\n\t\t\t\t\tif (length & 1)\n\t\t\t\t\t\tL = min(L, length);\n\t\t}\n\tdp(!haveB);\n\tupd(Ans, F[N - 1]);//edge(1, 2) = B\n\tfor (int x = 1, val;x <= L && x < N;++x)//edge(1, 2) = R\n\t{\n\t\tif (haveB && ((x & 1) == 0))\n\t\t\tcontinue;\n\t\tif (x + 1 == N)\n\t\t\tval = 1;\n\t\telse\n\t\t\tval = F[N - x - 2];\n\t\tupd(Ans, Mult(x, val));\n\t}\n\tif ((haveB == false || (L & 1)) && L == N)\n\t\tupd(Ans, 1);\n\tprintf(\"%d\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll dp[202020][2][2];\nll mo=1000000007;\n\nll dp2[202020];\nll dps[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\tif(S[0]=='B') {\n\t\tFORR(c,S) c='R'+'B'-c;\n\t}\n\tif(count(ALL(S),'B')==0) {\n\t\tdp[0][0][0]=dp[0][1][1]=1;\n\t\tfor(i=1;i<N;i++) {\n\t\t\t(dp[i][0][0]=dp[i-1][0][0]+dp[i-1][0][1])%=mo;\n\t\t\t(dp[i][0][1]=dp[i-1][0][0])%=mo;\n\t\t\t(dp[i][1][0]=dp[i-1][1][0]+dp[i-1][1][1])%=mo;\n\t\t\t(dp[i][1][1]=dp[i-1][1][0])%=mo;\n\t\t}\n\t\tcout<<(dp[N-1][0][0]+dp[N-1][0][1]+dp[N-1][1][0])%mo<<endl;\n\t\treturn;\n\t}\n\tassert(0);\n\tint L=0;\n\twhile(S[L]=='R') L++;\n\t\n\tif(L%2==0) L++;\n\t\n\tdp2[0]=dps[0]=dps[1]=1;\n\tfor(i=2;i<=N;i++) {\n\t\tif(i%2==0) {\n\t\t\tdp2[i]=dps[i-2];\n\t\t\tif(i-(L+1)>0) dp2[i]+=mo-dps[i-(L+1)-1];\n\t\t\tdp2[i]%=mo;\n\t\t}\n\t\t(dps[i]=dps[i-1]+dp2[i])%=mo;\n\t\t//cout<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=min(L,N-1);i++) {\n\t\t//cout<<i<<\" \"<<(i+1)<<\"*\"<<dp2[N-(i+1)]<<endl;\n\t\t(ret+=(i+1)*dp2[N-(i+1)])%=mo;\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: E.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define int long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nchar s[200005];\nint f[200005],g[200005];\nconst int p=1000000007;\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint n,m;\n\tread(n,m);\n\tread(s+1);\n\tchar fir=s[1];\n\tint mn=inf;\n\tfor(int i=1,j=1;i<=m;i=j){\n\t\twhile(s[i]==s[j])++j;\n\t\tif(s[i]==fir){\n\t\t\tif(i==1)chkmin(mn,j-i+(!((j-i)&1)));\n\t\t\telse if((j-i)&1)chkmin(mn,j-i);\n//\t\t\tchkmin(mn,j-i);\n\n\t\t}\n\n\t}\n\tif(mn>=m){\n\t\tf[0]=1;\n\t\tint s=0;\n\t\tfor(int i=2;i<=n;++i){\n\t\t\tf[i]=(s+i-f[i-1]+p)%p;\n\t\t\t(s+=f[i])%=p;\n\t\t}\n\t\twrite((f[n]+1)%p,'\\n');\n\t}\n\telse{\n\t\tif(n&1)return write(\"0\\n\");\n\t\tf[0]=1;\n\t\t++mn;\n\t\tg[0]=1;\n\t\tfor(int i=2;i<=n;i+=2){\n\t\t\tf[i]=(g[i-2]-g[i-min(i,mn+2)]+p)%p;\n//\t\t\tfor(int j=2;j<=mn && j<i;j+=2)f[i]+=f[i-j];\n\t\t\tif(i<=mn)(f[i]+=i)%=p;\n\t\t\tg[i]=(f[i]+g[i-2])%p;\n\t\t}\n\t\twrite(f[n],'\\n');\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PI 3.14159265358979323846264338327950288419\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint n, m;\nint col[200005];\n\nint expo(int a, int b){\n\tint c = 1, d = a;\n\twhile(b){\n\t\tif(b & 1){\n\t\t\tc = 1LL * c * d % mod;\n\t\t}\n\t\td = 1LL * d * d % mod;\n\t\tb >>= 1;\n\t}\n\treturn c;\n}\n\nint inv(int x){\n\treturn expo(x, mod - 2);\n}\n\nint calc(int n){\n\tint fib[200005];\n\tfib[1] = fib[2] = 1;\n\tfor(int i = 3; i <= n + 1; i++){\n\t\tfib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t}\n\t\n\t// force first one to be 1, last one to be 0: fib[n - 1]\n\t// force first one to be 0: fib[n + 1]\n\treturn (fib[n - 1] + fib[n + 1]) % mod;\n}\n\nint calc2(int n, int ub){\n\tassert(ub & 1);\n\t\n\t// want a bunch of numbers, in [2, ub], to sum to n\n\t\n\tub++;\n\tub = min(ub, n); // coz it can actually be HUGE\n\t\n\tint dp[200005]; // dp[i]: number of possible sums, that sum to i\n\tint cumu[200005];\n\t\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(cumu, 0, sizeof(cumu));\n\tdp[0] = 1;\n\tcumu[0] = 1;\n\t\n\tfor(int i = 2; i <= n; i += 2){\n\t\t// sum dp[l_index .. i - 2].. oh, only the even ones!\n\t\tint l_index = i - ub;\n\t//\tprintf(\"%d: sum %d..%d\\n\", i, l_index, r_index);\n\t\tdp[i] = cumu[i - 2];\n\t\t\n\t\tif(l_index > 0){\n\t\t\tdp[i] -= cumu[l_index - 2];\n\t\t\tif(dp[i] < 0){\n\t\t\t\tdp[i] += mod;\n\t\t\t}\n\t\t}\n//\t\tprintf(\"%d: %d\\n\", i, dp[i]);\n\t\tcumu[i] = (cumu[i - 2] + dp[i]) % mod;\n\t}\n\t\n\tint ret = 0;\n\t\n\tfor(int space = 0; space < ub; space++){\n\t\t// last 1 is at (n - space), leaving _ space at the end\n\t\t// where can the first 1 be?\n\t\tint left_pos = 1;\n\t\tint right_pos = ub - space;\n\t\t\n\t\tint most_remain = (n - space) - 1;\n\t\tint least_remain = n - ub;\n\t\t\n\t\tif(most_remain & 1) most_remain--;\n\t\t\n\t\tint combin = cumu[most_remain];\n\t\tif(least_remain > 0){\n\t\t\tcombin = (combin - cumu[least_remain - 2] + mod) % mod;\n\t\t}\n\t\tret = (ret + combin) % mod;\n\t}\n\tassert(ret >= 0);\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= m; i++){\n\t\tchar c;\n\t\tscanf(\" %c\", &c);\n\t\tcol[i] = (c == 'B');\n\t}\n\t\n\tif(col[1] != 0){\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tcol[i] = 1 - col[i];\n\t\t}\n\t}\n\t\n\t// WLOG first one is 0\n\tbool monochrome = true;\n\tfor(int i = 2; i <= m; i++){\n\t\tif(col[i]){\n\t\t\tmonochrome = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(monochrome){\n\t\t// ok as long as 1s are not adjacent\n\t\tprintf(\"%d\\n\", calc(n));\n\t\treturn 0;\n\t}else{\n\t\t// 00...010..010..0\n\t\t// each block of 0 is of add length\n\t\t// so, n odd -> definitely no solution\n\t\t// more conditions depending on specifics of col[]\n\t\tif(n % 2 == 1){\n\t\t \tprintf(\"0\\n\");\n\t\t \treturn 0;\n\t\t}\n\t\tint first_run = 0, subseq_run = n - 1;\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tint len = 0;\n\t\t\twhile(i + len <= m && col[i + len] == 0){\n\t\t \t\tlen++;\n\t\t \t}\n\t\t \tif(first_run == 0){\n\t\t \t\tfirst_run = len;\n\t\t \t}else if(len & 1){\n\t\t \t\tsubseq_run = min(subseq_run, len);\n\t\t \t}\n\t\t \ti += len;\n\t\t}\n\t\tint ub = first_run + (first_run % 2 == 0);\n\t\tub = min(ub, subseq_run);\n\t\tprintf(\"%d\\n\", calc2(n, ub));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long word;\ntypedef pair<int, int> pi;\nconst int MAXN = 200005;\nconst int mod = 1e9 + 7;\n\nint n, m;\nint f[MAXN];\nchar s[MAXN];\nint sum[MAXN];\n\nint main(){\n\tscanf(\"%d %d %s\",&n,&m,s);\n\tfor(int i=0; i<m; i++) if(s[i] == 'R') s[i] = 'A';\n\tif(s[0] == 'B'){\n\t\tfor(int i=0; i<m; i++) s[i] = 'A' + 'B' - s[i];\n\t}\n\tif(count(s, s + m, 'B') == 0){\n\t\tf[0] = 1; f[1] = 2;\n\t\tfor(int i=2; i<=n; i++){\n\t\t\tf[i] = f[i-1] + f[i-2];\n\t\t\tf[i] %= mod;\n\t\t}\n\t\tlint ret = f[n];\n\t\tif(n == 3) ret += mod - 1;\n\t\telse if(n >= 4) ret += mod - f[n - 4];\n\t\tret %= mod;\n\t\tcout << ret << endl;\n\t\treturn 0;\n\t}\n\tint alt = 1e9;\n\tint pref = 0;\n\twhile(s[pref] == 'A') pref++;\n\tfor(int i=0; i<m; i++){\n\t\tif(s[i] == 'B'){\n\t\t\tint e = i + 1;\n\t\t\twhile(s[e] == 'A') e++;\n\t\t\tif(e > i + 1 && e % 2 == i % 2){\n\t\t\t\talt = min(alt, e - i - 1);\n\t\t\t}\n\t\t\ti = e - 1;\n\t\t}\n\t}\n\tif(n % 2 == 1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint x = min(alt, pref + 1);\n\tf[0] = 1;\n\tsum[0] = 1;\n\tfor(int i=1; i<=n/2; i++){\n\t\tf[i] = sum[i - 1];\n\t\tif(i >= (x + 3) / 2) f[i] += mod - sum[i - (x + 3) / 2];\n\t\tf[i] %= mod;\n\t\tsum[i] = (sum[i-1] + f[i]) % mod;\n\t}\n\tlint ret = 0;\n\tfor(int i=0; i<n;i++){\n\t\tfor(int j=i; j<n; j+=2){\n\t\t\tint len = n - (j - i + 1);\n\t\t\tif(len <= x) ret += f[(j - i) / 2];\n\t\t\tret %= mod;\n\t\t}\n\t}\n\n\tcout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define prev azaza\n#define MP make_pair\n#define PB push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int max_n = 200111, inf = 1000111222;\nconst ll mod = 1000000007;\n\nint n, m;\nstring s;\n\nll dp[max_n];\nll pr[max_n];\nll dp2[max_n];\n\nll solve_allr() {\n    ll ans = 1;\n    dp[1] = 1;\n    dp[2] = 0;\n    ll sum = dp[1];\n    for (int i = 3; i < max_n; ++i) {\n        dp[i] = sum;\n        sum += dp[i - 1];\n        sum %= mod;\n    }\n    for (int len = 1; len < n; ++len) {\n        ans += dp[n - len] * (len + 1);\n        ans %= mod;\n    }\n    return ans;\n}\n\nll solve(int L) {\n    int L1 = L / 2;\n    pr[0] = 0;\n    pr[1] = 1;\n    dp2[1] = 1;\n    for (int i = 2; i < max_n; ++i) {\n        dp2[i] = (pr[i - 1] - pr[max(1, i - L1 - 1) - 1] + 2 * mod) % mod;\n        pr[i] = pr[i - 1] + dp2[i];\n        pr[i] %= mod;\n    }\n    dp[1] = 1;\n    for (int i = 3; i < max_n; i += 2) {\n        dp[i] = dp2[i / 2 + 1];\n    }\n    ll ans = 0;\n    for (int len = 1; len <= L; len += 2) {\n        ans += dp[n - len] * (len + 1);\n        ans %= mod;\n    }\n    return ans;\n}\n\nint main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> m;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (int i = 0; i < s.size(); ++i) {\n            s[i] = (s[i] == 'B' ? 'R' : 'B');\n        }\n    }\n    bool allr = 1;\n    for (char c : s) {\n        if (c == 'B') {\n            allr = 0;\n            break;\n        }\n    }\n    if (allr) {\n        cout << solve_allr() << endl;\n        return 0;\n    }\n    if (n % 2 == 1) {\n        cout << 0 << endl;\n        return 0;\n    }\n    while (s.back() == 'R') {\n        s.pop_back();\n    }\n    int L = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] == 'B') {\n            break;\n        } else {\n            ++L;\n        }\n    }\n    if (L % 2 == 0) {\n        ++L;\n    }\n    int len = 1;\n    for (int i = L; i < s.size(); ++i) {\n        if (s[i] == s[i - 1]) {\n            ++len;\n        } else {\n            if (s[i] == 'B' && len % 2 == 1) {\n                L = min(L, len);\n            }\n            len = 1;\n        }\n    }\n    cout << solve(L) << endl;\n    return 0;\n}\n\n// think 2:06\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\n\nint main() {\n\tll N, M;\n\tcin >> N >> M;\n\tstring S;\n\tcin >> S;\n\n\tll c = S[0];\n\n\tll K = -1;\n\trep(i, M) {\n\t\tif (S[i] != c) { K = i; }\n\t}\n\t\n\tif (K == -1) {\n\t\tif (N == 1) { cout << 1 << endl; return 0; }\n\t\tif (N == 2) { cout << 3 << endl; return 0; }\n\t\tvmint dp(N + 1, 0);\n\t\tdp[0] = 1;\n\t\tdp[1] = 2;\n\n\t\tfor (ll i = 2; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 2] + dp[i - 1];\n\t\t}\n\n\t\tmint ans = dp[N - 1];\n\t\tans += dp[N - 3];\n\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\tif (N % 2 != 0) { cout << 0 << endl; return 0; }\n\n\tvll ren(K + 1, 0);\n\trep(i, K + 1) {\n\t\tif (S[i] != c) { ren[i] = 0; }\n\t\telse if (i == 0) { ren[i] = 1; }\n\t\telse { ren[i] = ren[i - 1] + 1; }\n\t}\n\n\tll mn = INF;\n\trep(i, K) {\n\t\tif (ren[i + 1] == 0) {\n\t\t\tif (ren[i] % 2 == 1) { mn = min(ren[i], mn); }\n\t\t\tif (ren[i] == i + 1) { mn = min(ren[i]+ 1, mn); }\n\t\t\t}\n\t}\n\n\t//cout << mn << endl;\n\n\tN /= 2;\n\tmn = (mn - 1) / 2;\n\n\tvmint dp(N + 1, 0), rdp(N + 1, 0);\n\tdp[0] = 1;\n\trdp[0] = 1;\n\n\trepn(i, N) {\n\t\tif (i <= mn + 1)dp[i] = rdp[i - 1];\n\t\telse dp[i] = rdp[i - 1] - rdp[i - mn - 2];\n\n\t\trdp[i] = rdp[i - 1] + dp[i];\n\n\t\t//cout << i << dp[i] << rdp[i] << endl;\n\t}\n\n\tmint ans = 0;\n\tif (mn >= N) { ans = pw(2, N); }\n\telse if (mn == N - 1) { ans = pw(2, N) - 1; }\n\telse {\n\t\trep(i, mn + 1) {\n\t\t\tans += rdp[N - i - 1] - rdp[N - mn - 2];\n\t\t}\n\t}\n\tans *= 2;\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define set0(x) memset(x,0,sizeof(x))\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntemplate<typename T> void read(T &x){\n\tx = 0;char ch = getchar();int f = 1;\n\twhile(!isdigit(ch)){if(ch == '-')f*=-1;ch=getchar();}\n\twhile(isdigit(ch)){x = x*10+ch-48;ch=getchar();}x*=f;\n}\nint mod = 1000000007;\ninline int mul(int x,int y){return 1ll*x*y%mod;}\nint add(int x,int y){return x+y>=mod?x+y-mod:x+y;}\nint sub(int x,int y){return x-y<0?x-y+mod:x-y;}\nint sq(int x){return 1ll*x*x%mod;}\nint pow(int a,int b){return b == 0 ? 1 : ( b&1 ? mul(a,sq(pow(a,b/2))) : sq(pow(a,b/2)));}\nconst int N = 200020;\nint n,m,dp[N] = {0},sudp[N] = {0};\nchar ch[N];\nint ans = 0;\nint main() {\n\tread(n);read(m);\n\tscanf(\"%s\",ch);\n\tint ftt = 0,clen = 0;\n\tfor(int i=1;i<m;i++){\n\t\tif(ch[i]!=ch[0]){\n\t\t\tftt = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(ftt){\n\t\n\t\tclen = (ftt%2)?(ftt):(ftt+1);\n\t\tint la = ftt;\n\t\t//cout<<clen<<endl;\n\t\tfor(int i=ftt+1;i<m-1;i++){\n\t\t\tif(ch[i]==ch[0] && ch[i+1]!=ch[0]){\n\t\t\t\t//cout<<\"OC \"<<i<<' '<<la<<endl;\n\t\t\t\tif((i-la)%2) clen = min(clen,i-la);\n\t\t\t}\n\t\t\tif(ch[i]!=ch[0])la = i;\n\t\t}\n\t\t\n\t}\n\tint clim = (clen+1)/2;\n\t//cout<<ftt<<' '<<clen<<' '<<clim<<endl;\n\tdp[0] = sudp[0] = 1;\n\tfor(int i=1;i<=n;i++){\n\t\tdp[i] = sudp[i-1];\n\t\tif(i-clim-1>=0)dp[i] = sub(dp[i],sudp[i-clim-1]);\n\t\tsudp[i] = add(sudp[i-1],dp[i]);\n\t}\n\tif(ftt == 0){\n\t\tans = 0;\n\t\tdp[1] = sudp[1] = 1;\n\t\tdp[2] = sudp[2] = 1;\n\t\tans = n+1;\n\t\tfor(int i=3;i<n;i++){\n\t\t\tdp[i] = sudp[i-2];\n\t\t\tsudp[i] = add(sudp[i-1],dp[i]);\n\t\t\tans = add(ans,mul(dp[i],n-i+1));\n\t\t}\n\t\tif(n == 1)ans = 1;\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\tif(n%2){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=min(clen+1,n);i++){\n\t\tint cl = (n-clen-1)/2,cr = (n-i)/2;\n\t\tif(n-2*cl-1>clen)cl+=1;\n\t\tif(i == 1 && i+cr*2 == n)cr-=1;\n\t\tif(cr<cl)continue;\n\t\t//cout<<i<<' '<<i+cl*2<<' '<<i+cr*2<<' '<<ans<<endl;\n\t\tans = add(ans,sudp[cr]);\n\t\tif(cl>0) ans = sub(ans,sudp[cl-1]);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass EGoAroundACircle {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, M; cin >> N >> M;\n        string S; cin >> S;\n        char c = S[0];\n        int d = 1, m = 1, so = 1e9;\n        for (int i = 1; i < M; ++i) {\n            if (S[i] == c) {\n                d++;\n\n                m = max(m, d);\n            } else {\n                if (d % 2 == 1) so = min(so, d);\n                d = 0;\n            }\n        }\n\n        if (N % 2 == 1) {\n            if (m == M) {\n                vector2<FieldMod> X(N, 2, 0);\n                X[0][0] = 1;\n                for (int i = 1; i < N; ++i) {\n                    X[i][0] = X[i-1][0] + X[i-1][1];\n                    X[i][1] = X[i-1][0];\n                }\n\n                vector2<FieldMod> Y(N, 2, 0);\n                Y[0][1] = 1;\n                for (int i = 1; i < N; ++i) {\n                    Y[i][0] = Y[i-1][0] + Y[i-1][1];\n                    Y[i][1] = Y[i-1][0];\n                }\n\n\n                cout << X.back()[0] + X.back()[1] + Y.back()[0] << endl;\n            } else {\n                cout << 0 << endl;\n            }\n            return;\n        }\n\n        if (m == M) {\n            cout << FieldMod{2}.pow(N/2) * 2 - 1;\n            return;\n        }\n\n        if (m % 2 == 0) ++m;\n        m = min(m, so);\n        // max size of consecutive Rs => m\n        int b = min(N/2, (m+1)/2);\n\n        vector<FieldMod> H(N/2, 0);\n        FieldMod tot = 1;\n        H[0] = 1;\n        for (int j = 1; j < N/2; ++j) {\n            if (j > b) {  tot -= H[j-b-1]; }\n            H[j] = tot;\n//            cout << \"add \" << j << ' ' << H[j] << endl;\n            tot += H[j];\n        }\n\n//        cout << H;\n        FieldMod ans = 0;\n        for (int i = 1; i <= b; ++i) {\n            ans += i * H[N/2-i];\n        }\n        cout << 2*ans << endl;\n\n\n//        int ans = 0;\n//        for (int i = 0; i < (1<<N); ++i) {\n//            vector<bool> A(N, true);\n//            for (int j = M-1; j >= 0; --j) {\n//                int s = (S[j] == 'R') ? 1 : 0;\n//                vector<bool> B(N, false);\n//                for (int k = 0; k < N; ++k) {\n//                    if (!A[k]) continue;\n//                    int l = k == 0 ? N-1 : k-1;\n//                    int r = k == N-1 ? 0 : k+1;\n//                    if (((i>>l)&1) == s) B[l] = true;\n//                    if (((i>>k)&1) == s) B[r] = true;\n//                }\n//                swap(A,B);\n//            }\n//\n//            if (count(A.begin(),A.end(),true) == N) {\n//                ans++;\n////                for (int j = 0; j < N; ++j) {\n////                    cout << \"BR\"[(i>>j)&1];\n////                }\n////                cout << endl;\n//            }\n//        }\n//        cout << ans << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tEGoAroundACircle solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=200010, LOG=20;\n\nint n, m, k=inf, u, v, x, y, t, a, b, ans;\nint A[MAXN];\nint dp[MAXN];\nstring S;\n\ninline void fix(int &x){\n\tif (x>=mod) x-=mod;\n\tif (x<0) x+=mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n//\tfreopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n>>m>>S;\n\tfor (int i=0; i<m; i++) if (S[i]=='R') S[i]='A'; // :(\n\tif (S[0]=='B'){\n\t\tfor (int i=0; i<m; i++) S[i]='A'+'B'-S[i];\n\t}\n\twhile (S.size()>1 && S.back()=='A') S.pop_back();\n\tm=S.size();\n//\tdebug(S)\n\tif (m==1){\n\t\tdp[1]=1;\n\t\tfor (int i=3; i<=n; i++){\n\t\t\tfix(dp[i]=dp[i-1]+dp[i-2]);\n\t\t}\n\t\tans=n+1;\n\t\tfor (int i=3; i<n; i++) ans=(ans + (n-i+1ll)*dp[i])%mod;\n\t\tfix(ans);\n\t\tcout<<ans<<\"\\n\";\n\t\t\n\t\treturn 0;\n\t}\n\tif (n&1) kill(0)\n\tfor (int i=0, j=0; i<m; i=j){\n\t\tif (S[i]=='B') j++;\n\t\telse{\n\t\t\twhile (S[j]=='A' && j<m) j++;\n\t\t\tif (i==0 || (j-i)%2==1) k=min(k, j-i);\n\t\t}\n\t}\n//\tdebug(k)\n\tk>>=1;\n\tn>>=1;\n//\tdebug2(n, k)\n\tdp[0]=1;\n\tdp[1]=1+(k>=1);\n\tfor (int i=2; i<=n; i++){\n\t\tfix(dp[i]=2*dp[i-1]-(k>=i-1)+(k>=i));\n\t\tif (i>=k+2) fix(dp[i]-=dp[i-k-2]);\n\t}\n//\tdebug(dp[1])\n//\tdebug(dp[2])\n//\tdebug(dp[3])\n\t\n\tfor (int i=0; i+2<=n; i++) if (n-i-2<=k) ans=(ans + (n-i-1ll)*dp[i])%mod;\n\tif (n-1<=k) fix(ans+=n);\n\tfix(ans*=2);\n\tfix(ans);\n\tcout<<ans<<\"\\n\";\n\t\n\treturn 0;\n}\n/*\n12 5\nAAAAB\n\n6 5\nRRRRB\n\n6 5\nRRBRB\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 2e5+5;\nconst int mod = 1e9+7;\ninline int add(int a,int b){a+=b;return a>=mod?a-mod:a;}\nchar s[N];\nint n,m,mx;\nint f[N],f2[N],ans;\n\nint main()\n{\n\tcin >> n >> m;\n\tscanf(\"%s\",s+1);\n\tint p;\n\tfor(p=1;p<=m;p++){\n\t\tif(s[p]!=s[1])break;\n\t}\n\tmx=p-1;\n\tif(mx==m){\n\t\tf[0] = f2[0] = ans = 1;\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tif(i>=2)f[i] = f2[i-2];\n\t\t\tf2[i] = add((i-1>=0?f2[i-1]:0),f[i]);\n\t\t\tif(n-i>=2)ans = add(ans, 1ll*f[i]*(n-i)%mod);\n\t\t}\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\tif(n&1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tif(mx%2==0)++mx;\n\tfor(int t=0;p<=m;p++){\n\t\tif(s[p]==s[1])++t;\n\t\telse{\n\t\t\tif(t&1)mx = min(mx, t);\n\t\t\tt=0;\n\t\t}\n\t}\n\tn/=2,mx=(mx+1)/2;\n\tf[0]=f2[0]=1;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tif(i)\n\t\t{\n\t\t\tf[i]=(mod+f2[i-1]-(i-mx-1>=0?f2[i-mx-1]:0))%mod;\n\t\t\tf2[i]=(f2[i-1]+f[i])%mod;\n\t\t}\n\t\tif(n-i<=mx) ans = add(ans,(mod+1ll*(n-i)*f[i]*2%mod)%mod);\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vec>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\nmain(){\n    ios\n    calc();\n    int n=in(),m=in();\n    string s;cin>>s;\n    bool all_same=true;\n    rep(i,m){\n        if(s[i]!=s[0])all_same=false;\n    }\n    if(!all_same and (n&1)){\n        cout<<0<<endl;\n    }\n    else if(all_same){\n        assert(0);\n        mint dp[n+1][2]={};\n        dp[0][0]=1;\n        rep(i,n-1){\n            dp[i+1][1]+=dp[i][0];\n            dp[i+1][0]+=dp[i][0]+dp[i][1];\n        }\n        mint ans=dp[n-1][0]+dp[n-1][1];\n        rep(i,n)dp[i][0]=dp[i][1]=0;\n        dp[0][1]=1;\n        rep(i,n-1){\n            dp[i+1][1]+=dp[i][0];\n            dp[i+1][0]+=dp[i][0]+dp[i][1];\n        }\n        ans+=dp[n-1][0];\n        cout<<ans.a<<endl;\n    }\n    else{\n        char c=s[0];\n        int mi=INT_MAX;\n        rep(i,m){\n            int cnt=0;\n            while(i<m && s[i]==c)cnt++,i++;\n            chmin(mi,cnt);break;\n        }\n        if(mi %2 ==0)mi++;\n        rep(i,m){\n            if(s[i]==c){\n                int cnt=0;\n                while(i<m && s[i]==c)cnt++,i++;\n                if(cnt&1)\n                chmin(mi,cnt);\n            }\n        }\n        mint dp[700000]={};\n        mi=(mi+1)/2;\n        rep(i,mi){\n            dp[i]=2;\n        }\n        dp[mi]=-2*mi;\n        rep(i,n/2){\n            dp[i+1]+=dp[i]*2;\n            dp[i+1+mi]-=dp[i];\n        }\n        cout<<dp[n/2-1].a<<endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\tconst int N=2e5+9,mod=1e9+7;\n\tinline int add(int x,int y){return x+y>=mod?x-mod+y:x+y;}\n\tinline int sub(int x,int y){return x>=y?x-y:x+mod-y;}\n\tinline int qpow(int x,int y){\n\t\tint ret=1;\n\t\twhile(y){\n\t\t\tif(y&1) ret=1LL*x*ret%mod;\n\t\t\tx=1LL*x*x%mod,y>>=1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint n,m,f[N],sum[N];char s[N];\n\tint main(){\n\t\tn=read<int>(),m=read<int>(),scanf(\"%s\",s+1);\n\t\t\n\t\tint peg=1;\n\t\tfor(int i=2;i<=m;i++) if(s[1]!=s[i]) peg=0;\n\t\tif(peg){\n\t\t\tf[0]=1,f[1]=0,sum[0]=sum[1]=1;\n\t\t\tfor(int i=2;i<=n;i++)\n\t\t\t\tf[i]=sum[i-2],sum[i]=add(sum[i-1],f[i]);\n\t\t//\tfor(int i=1;i<=n;i++) cout<<f[i]<<\" \";cout<<endl;\n\t\t\tint ans=0;\n\t\t\tfor(int i=2;i<=n;i++) ans=add(ans,1LL*f[n-i]*i%mod);\n\t\t\tprintf(\"%d\\n\",add(ans,1));\n\t\t\treturn 0;\n\t\t}\n\t\tint mx=0,i,t;\n\t\tfor(i=1;i<=m;i++)\n\t\t\tif(s[i]!=s[1]){mx=i-1+(~(i-1)&1);break;}\n\t\tfor(t=0;i<=m;i++)\n\t\t\tif(s[i]!=s[1]){\n\t\t\t\tif(t&1) mx=min(mx,t);\n\t\t\t\tt=0;\n\t\t\t}else t++;\n\t\tif(t&1) mx=min(mx,t);\n\n\t\tf[0]=1,f[1]=0,sum[0]=sum[1]=1;\n\t\tfor(i=2;i<=n;i++){\n\t\t\tf[i]=sub(sum[i-2],i-mx-2>=0?sum[i-mx-2]:0),sum[i]=sum[i-1];\n\t\t\tif(~i&1) sum[i]=add(sum[i],f[i]);\n\t\t}\n\t//\tfor(int i=1;i<=n;i++) cout<<f[i]<<\" \";cout<<endl;\n\t\tint ans=0;\n\t\tfor(int i=2;i<=mx+1;i++) if(~i&1) ans=add(ans,1LL*f[n-i]*i%mod);\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int Mod = 1000000007;\nconst int MN = 200005, MM = 200005;\n\nint N, M, K;\nchar S[MM];\nint A[MN], B[MN], Ans;\n\nint main() {\n\tscanf(\"%d%d%s\", &N, &M, S + 1);\n\tK = 0x3f3f3f3f;\n\tint isfirst = 1, len = 0;\n\tfor (int i = 1; i <= M; ++i) {\n\t\tif (S[i] != S[1]) {\n\t\t\tif (isfirst || len & 1) K = std::min(K, len / 2 + 1);\n\t\t\tisfirst = len = 0;\n\t\t} else ++len;\n\t}\n\tif (isfirst) {\n\t\tint X1 = 1, X2 = 0;\n\t\tfor (int i = 1; i <= N; ++i) {\n\t\t\tX2 -= (X2 = X1 + X2) >= Mod ? Mod : 0;\n\t\t\tX1 += (X1 = X2 - X1) < 0 ? Mod : 0;\n\t\t}\n\t\tprintf(\"%lld\\n\", (2ll * X1 + X2) % Mod);\n\t\treturn 0;\n\t}\n\tif (N & 1) return puts(\"0\"), 0;\n\tN /= 2;\n\tK = std::min(K, N);\n\tA[0] = B[0] = 1;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tA[i] = B[i - 1];\n\t\tif (i > K) A[i] += (A[i] -= B[i - K - 1]) < 0 ? Mod : 0;\n\t\tB[i] -= (B[i] = B[i - 1] + A[i]) >= Mod ? Mod : 0;\n\t}\n\tfor (int i = 1; i <= K; ++i)\n\t\tAns = (Ans + 2ll * i * A[N - i]) % Mod;\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n        if(dp[i-1] < 0)dp[i-1] += MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i <= m;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=2e5+20;\nconst int mod=1e9+7;\n\nint n,m;\nchar str[maxn];\nint lim;\nint f[maxn];\n\ninline void CHECK1()\n{\n\tREP(i,1,n)if(str[i]=='B')return;\n\tf[0]=1;f[1]=1;\n\tREP(i,2,n)f[i]=(f[i-1]+f[i-2])%mod;\n\tprintf(\"%d\\n\",(f[n-2]+f[n])%mod);\n\texit(0);\n}\n\ninline void init()\n{\n\tn=read();m=read();\n\tscanf(\"%s\",str+1);\n\tif(str[1]=='B')\n\t{\n\t\tREP(i,1,n)str[i]=str[i]=='B'?'R':'B';\n\t}\n\tCHECK1();\n\tlim=n;\n\tint lstb=0;\n\tREP(i,1,n)\n\t{\n\t\tif(str[i]=='B')\n\t\t{\n\t\t\tint num=i-lstb-1;\n\t\t\tif(lstb==0)chkmin(lim,num+(num+1&1));\n\t\t\telse if(num&1)chkmin(lim,num);\n\t\t}\n\t}\n\tlim=lim+1>>1;\n}\n\ninline void doing()\n{\n\tif(n&1)puts(\"0\"),exit(0);\n\tn>>=1;\n\tf[0]=1;int s=1;\n\tREP(i,1,n)\n\t{\n\t\tf[i]=s;\n\t\ts=(s+f[i])%mod;\n\t\tif(i-lim>=0)s=(s-f[i-lim]+mod)%mod;\n\t}\n\t//int ans=f[n>>1];\n\tint ans=0;\n\tREP(i,1,lim)ans=(ans+(ll)i*f[n-i])%mod;\n\tans=(ll)ans*2%mod;\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)//  cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ld PI = 3.14159265359;\n\nconst ll MOD = (ll) 1e9 + 7;\nconst ll MAXN = (ll) 2e5 + 10;\nconst ll INF = (ll) 2242545357980376863;\nconst ld EPS = (ld) 1e-8;\n\nvector<ll> A;\nll dp[MAXN], sm[MAXN];\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll n, m;\n\tcin >> n >> m;\n\tstr s;\n\tcin >> s;\n\t\n\tif(s[0] == 'B'){\n\t\tfor(int i = 0; i < m;i++){\n\t\t\tif(s[i] == 'R') s[i] = 'B';\n\t\t\telse s[i] = 'R';\n\t\t}\n\t}\n\tll cnt = 1;\n\tfor(int i = 1; i< m; i++){\n\t\tif(s[i] == s[i - 1]) cnt ++;\n\t\telse {\n\t\t\tA.pb(cnt);\n\t\t\tcnt = 1;\n\t\t}\n\t}\n\tA.pb(cnt);\n\tif(A.size() == 1){\n\t\t//debug(\"S\");\n\t\tdp[1] = 1;\n\t\tdp[2] = 0;\n\t\tsm[1] = 1;\n\t\tsm[2] = 1;\n\t\tfor(int i = 3; i <= n; i++){\n\t\t\tdp[i] = sm[i - 2];\n\t\t\tsm[i] = (dp[i] + sm[i - 1]) % MOD;\n\t\t}\n\t\tll ans = 1;\n\t\tfor(int len = 1; len <= n - 1; len ++){\n\t\t\tans += (len + 1ll) * dp[n - len];\n\t\t\tans %= MOD;\n\t\t}\n\t\tcout << ans;\n\t\treturn 0;\n\t\t/////\n\t}\n\t\n\tll mx;\n\t\n\tif(A[0] % 2 == 0 ) mx = A[0] + 1;\n\telse mx = A[0];\n\tfor(int i = 2; i < A.size(); i += 2){\n\t\tif(A[i] % 2 == 1) mx = max(mx, A[i]);\n\t}\n\tdebug(mx);\n\tdp[0] = 0;\n\tdp[1] = 1;\n\tdp[3] = 1;\n\tfor(int i = 5; i <= n; i++){\n\t\tdp[i] = dp[i - 2] + dp[i - 2];\n\t\tif(i >= mx + 3) dp[i] -= dp[i - mx - 3];\n\t\tdp[i] %= MOD;\n\t}\n\t//debug(dp[1]);\n\t//debug(dp[3]);\n\tll ans = 0;\n\tfor(int len = 1; len <= min(n, mx); len ++){\n\t\tans += (len + 1ll) * dp[n - len];\n\t\tans %= MOD;\n\t}\n\tcout << ((ans % MOD) + MOD)%MOD;\n\t\n\treturn 0;\n}\n\n\n/*\n\n                                 ____              ,----..               ,----..\n   ,---,                       ,'  , `.           /   /   \\             /   /   \\\n  '  .' \\                   ,-+-,.' _ |          /   .     :           /   .     :\n /  ;    '.              ,-+-. ;   , ||         .   /   ;.  \\         .   /   ;.  \\\n:  :       \\            ,--.'|'   |  ;|        .   ;   /  ` ;        .   ;   /  ` ;\n:  |   /\\   \\          |   |  ,', |  ':        ;   |  ; \\ ; |        ;   |  ; \\ ; |\n|  :  ' ;.   :         |   | /  | |  ||        |   :  | ; | '        |   :  | ; | '\n|  |  ;/  \\   \\        '   | :  | :  |,        .   |  ' ' ' :        .   |  ' ' ' :\n'  :  | \\  \\ ,'        ;   . |  ; |--'         '   ;  \\; /  |        '   ;  \\; /  |\n|  |  '  '--'          |   : |  | ,             \\   \\  ',  /          \\   \\  ',  /\n|  :  :                |   : '  |/               ;   :    /            ;   :    /\n|  | ,'                ;   | |`-'                 \\   \\ .'              \\   \\ .'\n`--''                  |   ;/                      `---`                 `---`\n                       '---'\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=200005,mod=1e9+7;\nint n,m,lim=N;\nchar s[N];\n\nvoid special(int n){\n\tstatic int f[N],s[N];\n\ts[1]=s[0]=f[0]=1;\n\trep(i,2,n){\n\t\tf[i]=s[i-2];\n\t\ts[i]=(s[i-1]+f[i])%mod;\n\t}\n\tint ans=1;\n\trep(i,2,n)\n\t\tans=(ans+(ll)i*f[n-i])%mod;\n\tcout<<ans<<endl;\n}\n\nvoid solve(int n,int k){\n\tstatic int f[N],s[N];\n\ts[0]=f[0]=1;\n\tfor(int i=2;i<=n;i+=2){\n\t\tf[i]=(s[i-2]+mod-s[i-k-3])%mod;\n\t\ts[i]=(s[i-2]+f[i])%mod;\n\t}\n\tint ans=0;\n\tfor(int i=2;i<=k+1;i+=2)\n\t\tans=(ans+(ll)i*f[n-i])%mod;\n\tcout<<ans<<endl;\n}\n\nint main(){\n\tread(n),read(m);\n\tscanf(\"%s\",s+1);\n\tfor(int l=1,r;l<=m;l++)\n\t\tif(s[l]==s[1]){\n\t\t\tr=l;\n\t\t\twhile(r<m&&s[r+1]==s[l])\n\t\t\t\tr++;\n\t\t\tif(l==1&&r==m){\n\t\t\t\tspecial(n);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(l==1){\n\t\t\t\tif(r%2==0) lim=min(lim,r+1);\n\t\t\t\telse lim=min(lim,r);\n\t\t\t}\n\t\t\telse if(r!=m&&(r-l)%2==0){\n\t\t\t\tlim=min(lim,r-l+1);\n\t\t\t}\n\t\t\tl=r;\n\t\t}\n\tsolve(n,lim);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // clang-format off\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define in2(s,t)     rep(i,sz(s)){in(s[i] , t[i]);}\n#define in3(s,t,u)   rep(i,sz(s)){in(s[i] , t[i] , u[i]);}\n#define in4(s,t,u,v) rep(i,sz(s)){in(s[i] , t[i] , u[i] , v[i]);}\n#ifdef ONLINE_JUDGE\n  #define rep(i,N) for(int i = 0; i < (int)(N); i++)\n  #define repr(i,N) for(int i = (int)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(int i = 1; i <= (int)(N) ; i++)\n  #define repr1(i,N) for(int i = (N) ; (int)(i) > 0 ; i--)\n#else\n  #define rep(i,N) for(long long i = 0; i < (long long)(N); i++)\n  #define repr(i,N) for(long long i = (long long)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(long long i = 1; i <= (long long)(N) ; i++)\n  #define repr1(i,N) for(long long i = (N) ; (long long)(i) > 0 ; i--)\n#endif\nusing namespace std; void solve();\nusing ll = long long; template<class T = ll> using V = vector<T>;\nusing vi = V<int>; using vl = V<>; using vvi = V< V<int> >;\nusing vd = V<double>; using vs = V<string>; using vvl = V< V<> >;\nconstexpr int inf = 1001001001; constexpr ll infLL = (1LL << 61) - 1;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T,typename U>ll ceil(T a,U b){return (a + b - 1) / b;}\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); for(int i=0;i<s;i++) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);} while(0)\n  #define trcc(v) do { cerr << \"name : \" << #v << \"\\n\"; int cnt = 0; each(x , v){cerr << (cnt++) << \" : \"; trc(x); } } while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  #define trcc(...)\n  int main(){solve();}\n#endif\n\nconstexpr ll TEN(int n){ll ret=1,x=10;while(n){if(n&1)ret*=x;x*=x;n>>=1;}return ret;}\n#define mem(a, val) memset(a, val, sizeof(a))\n\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\nusing P = pair<ll,ll>; using vp = V<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n// clang-format on\n////////////////////////////////////////////////////\n\n\nvector<pair<char,int>> RunLengthEncoding(string& S){\n  vector<pair<char,int>> ret;\n  char c = -1;\n  int n = 0;\n  for(char x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate<typename T>\nvector<pair<T,int>> RunLengthEncoding(vector<T>& S){\n  vector<pair<T,int>> ret;\n  T c = -1;\n  int n = 0;\n  for(T& x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\nusing mint = modint;\n\nnamespace FastFourierTransform {\n  using real = double;\n\n  struct C {\n    real x, y;\n\n    C() : x(0), y(0) {}\n\n    C(real x, real y) : x(x), y(y) {}\n\n    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }\n\n    inline C conj() const { return C(x, -y); }\n  };\n\n  const real PI = acosl(-1);\n  int base = 1;\n  vector< C > rts = { {0, 0},\n                     {1, 0} };\n  vector< int > rev = {0, 1};\n\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    while(base < nbase) {\n      real angle = PI * 2.0 / (1 << (base + 1));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        real angle_i = angle * (2 * i + 1 - (1 << base));\n        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n      }\n      ++base;\n    }\n  }\n\n  void fft(vector< C > &a, int n) {\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          C z = a[i + j + k] * rts[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n  }\n\n  vector< int64_t > multiply(const vector< int > &a, const vector< int > &b) {\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = C(x, y);\n    }\n    fft(fa, sz);\n    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n      fa[i] = z;\n    }\n    for(int i = 0; i < (sz >> 1); i++) {\n      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n      fa[i] = A0 + A1 * s;\n    }\n    fft(fa, sz >> 1);\n    vector< int64_t > ret(need);\n    for(int i = 0; i < need; i++) {\n      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n    }\n    return ret;\n  }\n};\n\ntemplate< typename T >\nstruct ArbitraryModConvolution {\n  using real = FastFourierTransform::real;\n  using C = FastFourierTransform::C;\n\n  ArbitraryModConvolution() = default;\n\n  vector< T > multiply(const vector< T > &a, const vector< T > &b, int need = -1) {\n    if(need == -1) need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while((1 << nbase) < need) nbase++;\n    FastFourierTransform::ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < (int)a.size(); i++) {\n      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);\n    }\n    fft(fa, sz);\n    vector< C > fb(sz);\n    if(a == b) {\n      fb = fa;\n    } else {\n      for(int i = 0; i < (int)b.size(); i++) {\n        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);\n      }\n      fft(fb, sz);\n    }\n    real ratio = 0.25 / sz;\n    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C a1 = (fa[i] + fa[j].conj());\n      C a2 = (fa[i] - fa[j].conj()) * r2;\n      C b1 = (fb[i] + fb[j].conj()) * r3;\n      C b2 = (fb[i] - fb[j].conj()) * r4;\n      if(i != j) {\n        C c1 = (fa[j] + fa[i].conj());\n        C c2 = (fa[j] - fa[i].conj()) * r2;\n        C d1 = (fb[j] + fb[i].conj()) * r3;\n        C d2 = (fb[j] - fb[i].conj()) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector< T > ret(need);\n    for(int i = 0; i < need; i++) {\n      int64_t aa = llround(fa[i].x);\n      int64_t bb = llround(fb[i].x);\n      int64_t cc = llround(fa[i].y);\n      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;\n      ret[i] = aa + (bb << 15) + (cc << 30);\n    }\n    return ret;\n  }\n};\n\ntemplate< int mod >\nstruct NumberTheoreticTransform {\n\n  int base, max_base, root;\n  vector< int > rev, rts;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while(tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while(n > 0) {\n      if(n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) {\n    return mod_pow(x, mod - 2);\n  }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long) mod;\n  }\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while(base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n\n  void ntt(vector< int > &a) {\n    const int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n\n  vector< int > multiply(vector< int > a, vector< int > b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for(int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n\n  vector<modint> multiply_for_fps(const vector<modint> &a,const vector<modint> &b){\n    vector<int> A(a.size()) , B(b.size());\n    for(int i = 0;i < (int)a.size(); i++) A[i] = a[i].x;\n    for(int i = 0;i < (int)b.size(); i++) B[i] = b[i].x;\n    auto C = multiply( A , B );\n    vector<modint> ret(C.size());\n    for(int i = 0; i < (int)C.size() ;i++) ret[i].x = C[i];\n    return ret;\n  }\n};\n\n\ntemplate< typename T >\nstruct FormalPowerSeries : vector< T > {\n  using vector< T >::vector;\n  using P = FormalPowerSeries;\n\n  using MULT = function< P(P, P) >;\n\n  static MULT &get_mult() {\n    static MULT mult = nullptr;\n    return mult;\n  }\n\n  static void set_fft(MULT f) {\n    get_mult() = f;\n  }\n\n  void shrink() {\n    while(this->size() && this->back() == T(0)) this->pop_back();\n  }\n\n  P operator+(const P &r) const { return P(*this) += r; }\n\n  P operator+(const T &v) const { return P(*this) += v; }\n\n  P operator-(const P &r) const { return P(*this) -= r; }\n\n  P operator-(const T &v) const { return P(*this) -= v; }\n\n  P operator*(const P &r) const { return P(*this) *= r; }\n\n  P operator*(const T &v) const { return P(*this) *= v; }\n\n  P operator/(const P &r) const { return P(*this) /= r; }\n\n  P operator%(const P &r) const { return P(*this) %= r; }\n\n  P &operator+=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] += r[i];\n    return *this;\n  }\n\n  P &operator+=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] += r;\n    return *this;\n  }\n\n  P &operator-=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] -= r[i];\n    shrink();\n    return *this;\n  }\n\n  P &operator-=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] -= r;\n    shrink();\n    return *this;\n  }\n\n  P &operator*=(const T &v) {\n    const int n = (int) this->size();\n    for(int k = 0; k < n; k++) (*this)[k] *= v;\n    return *this;\n  }\n\n  P &operator*=(const P &r) {\n    if(this->empty() || r.empty()) {\n      this->clear();\n      return *this;\n    }\n    assert(get_mult() != nullptr);\n    return *this = get_mult()(*this, r);\n  }\n\n  P &operator%=(const P &r) {\n    return *this -= *this / r * r;\n  }\n\n  P operator-() const {\n    P ret(this->size());\n    for(int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];\n    return ret;\n  }\n\n  P &operator/=(const P &r) {\n    if(this->size() < r.size()) {\n      this->clear();\n      return *this;\n    }\n    int n = this->size() - r.size() + 1;\n    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);\n  }\n\n  P pre(int sz) const {\n    return P(begin(*this), begin(*this) + min((int) this->size(), sz));\n  }\n\n  P operator>>(int sz) const {\n    if(this->size() <= sz) return {};\n    P ret(*this);\n    ret.erase(ret.begin(), ret.begin() + sz);\n    return ret;\n  }\n\n  P operator<<(int sz) const {\n    P ret(*this);\n    ret.insert(ret.begin(), sz, T(0));\n    return ret;\n  }\n\n  P rev(int deg = -1) const {\n    P ret(*this);\n    if(deg != -1) ret.resize(deg, T(0));\n    reverse(begin(ret), end(ret));\n    return ret;\n  }\n\n  P diff() const {\n    const int n = (int) this->size();\n    P ret(max(0, n - 1));\n    for(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);\n    return ret;\n  }\n\n  P integral() const {\n    const int n = (int) this->size();\n    P ret(n + 1);\n    ret[0] = T(0);\n    for(int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);\n    return ret;\n  }\n\n  // F(0) must not be 0\n  P inv(int deg = -1) const {\n    assert(((*this)[0]) != T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1) / (*this)[0]});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 1\n  P log(int deg = -1) const {\n    assert((*this)[0] == 1);\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();\n  }\n\n  P sqrt(int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n\n    if((*this)[0] == T(0)) {\n      for(int i = 1; i < n; i++) {\n        if((*this)[i] != T(0)) {\n          if(i & 1) return {};\n          if(deg - i / 2 <= 0) break;\n          auto ret = (*this >> i).sqrt(deg - i / 2) << (i / 2);\n          if(ret.size() < deg) ret.resize(deg, T(0));\n          return ret;\n        }\n      }\n      return P(deg, 0);\n    }\n\n    P ret({T(1)});\n    T inv2 = T(1) / T(2);\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 0\n  P exp(int deg = -1) const {\n    assert((*this)[0] == T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1)});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  P pow(int64_t k, int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    for(int i = 0; i < n; i++) {\n      if((*this)[i] != T(0)) {\n        T rev = T(1) / (*this)[i];\n        P C(*this * rev);\n        P D(n - i);\n        for(int j = i; j < n; j++) D[j - i] = C[j];\n        D = (D.log() * k).exp() * (*this)[i].pow(k);\n        P E(deg);\n        if(i * k > deg) return E;\n        auto S = i * k;\n        for(int j = 0; j + S < deg && j < D.size(); j++) E[j + S] = D[j];\n        return E;\n      }\n    }\n    return *this;\n  }\n\n  T eval(T x) const {\n    T r = 0, w = 1;\n    for(auto &v : *this) {\n      r += w * v;\n      w *= x;\n    }\n    return r;\n  }\n};\n\nusing FPS = FormalPowerSeries< modint >;\n\n// fにa * x^n + bを掛ける\nvoid mul_simple(FPS &f,modint a ,int n, modint b){\n  for(int i = (int)f.size() - 1 ; i >= 0 ; i--){\n    f[i] *= b;\n    if(i >= n) f[i] += f[i - n] * a; \n  }\n}\n\n// fからa * x^n + bを割る\nvoid div_simple(FPS &f,modint a,int n,modint b){\n  for(int i = 0 ; i < (int)f.size() ; i++){\n    f[i] /= b;\n    if(i + n < (int)f.size() ) f[n + i] -= f[i] * a; \n  }\n}\n\n// f / gをdeg(f)次まで求める\nFPS div_(FPS &f , FPS g){\n  int n = f.size();\n  return (f * g.inv(n)).pre(n);\n}\n\n\n// solve関数内で\n//\n// FPS::set_fft(mul);\n//\n// とすること。\n\n/**\nNumberTheoreticTransform<MOD> ntt;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret =ntt.multiply_for_fps(a , b);\n  return FPS::P(ret.begin(), ret.end());\n};\n/*///\nArbitraryModConvolution< modint > fft;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret = fft.multiply(a, b);\n  return FPS::P(ret.begin(), ret.end());\n};\n//*/\n\n// 下記のリンクを実装(kitamasa法のモンゴメリ乗算を使わない版)\n// http://q.c.titech.ac.jp/docs/progs/polynomial_division.html\n// k項間漸化式のa_Nを求める O(k log k log N)\n// N ... 求めたい項　(0-indexed)\n// Q ... 漸化式 (1 - \\sum_i c_i x^i)の形\n// a ... 初期解 (a_0 , a_1 , ... , a_k-1)\n// x^N を fでわった剰余を求め、aと内積を取る\nmodint kitamasa(ll N, FPS &Q, FPS &a){\n  int k = Q.size() - 1;\n  assert( (int)a.size() == k );\n  FPS P = a * Q; P.resize(k);\n  while(N){\n    auto Q2 = Q;\n    for(int i = 1; i < (int)Q2.size(); i += 2) Q2[i].x = MOD - Q2[i].x;\n    auto S = P * Q2;\n    auto T = Q * Q2;\n    if(N & 1){\n      for(int i = 1 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    else{\n      for(int i = 0 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    N >>= 1;\n  }\n  return P[0];\n}\n\nvoid solve(){\n  ini(N , M);\n  ins(S);\n  auto run = RunLengthEncoding(S);\n  if(N % 2 == 1 || run.size() == 1) exit(1);\n\n  FPS::set_fft(mul);\n  // rの最小値\n  int r = inf , b = inf;\n  each(p , run){\n    if(p.first == 'R') amin(r , (p.second%2==0 ? p.second+1:p.second));\n    if(p.first == 'B') amin(b , (p.second%2==0 ? p.second+1:p.second));\n  }\n\n  FPS f({1});\n  auto nyaan = [&](ll n,int flg = false) -> FPS{\n    FPS ret(n + 1);\n    for(int i = 1 ; i <= n ; i += 2) ret[i] = (flg ? i : 1);\n    return ret;\n  };\n  trc(f);\n  f *= nyaan(r);\n  f *= nyaan(b);\n  trc(f);\n  f = FPS({1}) - f;\n  f.resize(N + 1);\n  f = f.inv();\n  f *= nyaan(r,1) * nyaan(b) + nyaan(b,1) * nyaan(r); \n  trc(f);\n  out(f[N]);\n  \n  /*\n  //trc(f);\n  // 倍数包除\n  for(int i = 2 ; i <= N ; i++){\n    // i番目は？\n    //引こう！\n    for(int j = 2 ; i * j <= N ; j++){\n      f[i * j] -= f[i];\n    }\n  }\n  trc(f);\n  */\n\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___CLASS_MODINT\n#define ___CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::uint64_t n_) : n(n_ % mod) {};\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tstd::uint32_t get() const { return n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint binpow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tmodint inv() { return (*this).binpow(mod - 2); }\n};\n\n#endif // ___CLASS_MODINT\n\n#include <string>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nusing modulo = modint<1000000007>;\nconst int inf = 1012345678;\nint solve(int N, int M, string S) {\n\tif (S[0] == 'B') {\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (S[i] == 'B') S[i] = 'R';\n\t\t\telse S[i] = 'B';\n\t\t}\n\t}\n\tint pre = 0, mn = inf;\n\tfor (int i = 1; i < M; ++i) {\n\t\tif (pre != -1 && S[i] == 'B') {\n\t\t\tif (pre == 0 || (i - pre) % 2 == 1) mn = min(mn, i - pre + 1);\n\t\t}\n\t\telse if (i != M && pre == -1 && S[i] == 'R') pre = i;\n\t}\n\tif (mn == inf) {\n\t\tassert(false);\n\t\tvector<modulo> fib(N + 3);\n\t\tfib[1] = 1;\n\t\tfor (int i = 2; i <= N + 2; ++i) {\n\t\t\tfib[i] = fib[i - 1] + fib[i - 2];\n\t\t}\n\t\tmodulo ans = fib[N + 2] - fib[N - 2];\n\t\treturn ans.get();\n\t}\n\telse {\n\t\tvector<modulo> dp(N + 1);\n\t\tdp[1] = 1;\n\t\tint lim = (mn + 1) / 2 * 2;\n\t\tmodulo sum = 1;\n\t\tfor (int i = 3; i <= N; i += 2) {\n\t\t\tif (i - lim - 2 >= 0) sum -= dp[i - lim - 2];\n\t\t\tdp[i] = sum;\n\t\t\tsum += dp[i];\n\t\t}\n\t\tmodulo ans = 0;\n\t\tfor (int i = 1; i <= mn && i <= N; i += 2) {\n\t\t\tans += dp[N - i] * (i + 1);\n\t\t}\n\t\treturn ans.get();\n\t}\n\treturn -1;\n}\nint solve_easy(int N, int M, string S) {\n\tif (S[0] == 'B') {\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (S[i] == 'B') S[i] = 'R';\n\t\t\telse S[i] = 'B';\n\t\t}\n\t}\n\tint pre = 0, mn = inf;\n\tfor (int i = 1; i < M; ++i) {\n\t\tif (pre != -1 && S[i] == 'B') {\n\t\t\tif (pre == 0 || (i - pre) % 2 == 1) mn = min(mn, i - pre + 1);\n\t\t}\n\t\telse if (i != M && pre == -1 && S[i] == 'R') pre = i;\n\t}\n\tint ans = 0;\n\tfor (int i = (mn == inf ? 0 : 1); i < 1 << N; ++i) {\n\t\tstring T;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif ((i >> j) & 1) T += 'B';\n\t\t\telse T += 'R';\n\t\t}\n\t\tT += T;\n\t\tint pre = 0; bool valid = true;\n\t\tfor (int j = 1; j <= 2 * N; ++j) {\n\t\t\tif (j == 2 * N || T[j] != T[j - 1]) {\n\t\t\t\tif (T[j - 1] == 'B' && j - pre >= 2) valid = false;\n\t\t\t\tif (T[j - 1] == 'R' && ((mn != inf && pre != 0 && j != 2 * N && (j - pre) % 2 == 0) || j - pre > mn)) valid = false;\n\t\t\t\tpre = j;\n\t\t\t}\n\t\t}\n\t\tif (valid) ++ans;\n\t}\n\treturn ans;\n}\nint main() {\n\tint N, M; string S;\n\tcin >> N >> M >> S;\n\tcout << solve(N, M, S) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MAX_N 200000\n#define MAX_M 200000\n#define MOD 1000000007\n\n#define INF 1 << 29\n\nint N, M;\nstring S;\n\nlong long dp[MAX_N + 2], rdp[MAX_N + 2];\n\nint all_color_is_same()\n{\n    long long rr = 1, bb = 1, rb = 0, br = 0;\n\n    for ( int i = 1; i < N; i++ )\n    {\n        long long nrr = ( rr + rb ) % MOD;\n        long long nbb = br;\n        long long nrb = rr;\n        long long nbr = ( bb + br ) % MOD;\n\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n\n    return ( rr + rb + br ) % MOD;\n}\n\n/* S\nの先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n*/\nint min_freq()\n{\n    int l = 0;\n    while ( l < M && S[0] == S[l] ) l++;\n\n    int ans = ( l & 1 ) ? l : l + 1;\n\n    l = 0;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[0] == S[i] )\n            l++;\n        else\n        {\n            if ( l & 1 ) ans = min( ans, l );\n            l = 0;\n        }\n    }\n    return ans;\n}\n\nint solve()\n{\n    // 一色\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n        return all_color_is_same();\n\n    // N が奇数\n    if ( N & 1 ) return 0;\n\n    int L = min_freq();\n\n    L = ( L + 1 ) >> 1;\n    N >>= 1;\n\n    dp[0] = rdp[0] = 1;\n    for ( int i = 1; i <= N + 1; i++ )\n    {\n        dp[i] = rdp[i - 1];\n        if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n\n    long long res = 0;\n    for ( int i = 1; i <= L; i++ )\n        if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n    return res % MOD;\n}\n\nint main( int argc, char **argv )\n{\n    cin >> N >> M;\n    cin >> S;\n\n    int ans = solve();\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MAX_N 200000\n#define MAX_M 200000\n#define MOD 1000000007\n\n#define INF 1 << 29\n\nint N, M;\nstring S;\n\nlong long dp[MAX_N + 2], rdp[MAX_N + 2];\n\nint all_color_is_same()\n{\n    long long rr = 1, bb = 1, rb = 0, br = 0;\n\n    for ( int i = 1; i < N; i++ )\n    {\n        long long nrr = ( rr + rb ) % MOD;\n        long long nbb = br;\n        long long nrb = rr;\n        long long nbr = ( bb + br ) % MOD;\n\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n\n    return ( rr + rb + br ) % MOD;\n}\n\n/**\n * S の先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n */\nint min_freq()\n{\n    int l = 0;\n    while ( l < M && S[0] == S[l] ) l++;\n\n    int ans = ( l & 1 ) ? l : l + 1;\n\n    l = 0;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[0] == S[i] )\n            l++;\n        else if ( l & 1 )\n        {\n            ans = min( ans, l );\n            l = 0;\n        }\n    }\n    return l ? min( ans, l ) : ans;\n}\n\nint solve()\n{\n    // 一色\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n        return all_color_is_same();\n\n    // N が奇数\n    if ( N & 1 ) return 0;\n\n    int L = min_freq();\n\n    L = ( L + 1 ) >> 1;\n    N >>= 1;\n\n    dp[0] = rdp[0] = 1;\n    for ( int i = 1; i <= N + 1; i++ )\n    {\n        dp[i] = rdp[i - 1];\n        if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n\n    long long res = 0;\n    for ( int i = 1; i <= L; i++ )\n        if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n    return res % MOD;\n}\n\nint main( int argc, char **argv )\n{\n    cin >> N >> M;\n    cin >> S;\n\n    int ans = solve();\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 201000,mod = 1e9+7;\nchar s[N];\nint a[N],n,m;\nvoid solve1(){\n\tint f[N][2][2];memset(f,0,sizeof(f));\n\tf[1][1][1]=f[1][0][0]=1;\n\tauto upd=[](int&a,int b){a+=b;if(a>=mod)a-=mod;};\n\tfor(int i=2;i<=n;i++){\n\t\tupd(f[i][1][1],f[i-1][1][0]);\n\t\tupd(f[i][1][1],f[i-1][1][1]);\n\t\tupd(f[i][1][0],f[i-1][1][1]);\n\t\tupd(f[i][0][1],f[i-1][0][0]);\n\t\tupd(f[i][0][1],f[i-1][0][1]);\n\t\tupd(f[i][0][0],f[i-1][0][1]);\n\t}\n\tcout<<(0ll+f[n][1][1]+f[n][1][0]+f[n][0][1])%mod<<'\\n';\n}\nvoid solve2(){\n\tint _f[N],*f;memset(_f,0,sizeof(_f));\n\tf=_f+100;\n\tint len=n|1,now=0,pos=n;\n\twhile(a[pos]) pos--;\n\tfor(int i=pos;i;i--)\n\t\tif(!a[i]){\n\t\t\tif(now&1) len=min(len,now);\n\t\t\tnow=0;\n\t\t}\n\t\telse now++;\n\tlen=min(len,now|1);\n\tf[-1]=f[1]=1;\n\tfor(int i=3;i<=n;i+=2){\n\t\tf[i]=2ll*f[i-2]%mod;\n\t\tif(i>len) f[i]=(f[i]-f[i-len-3]+mod)%mod;\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=len;i+=2) ans=(1ll*(i+1)*f[n-i-2]+ans)%mod;\n\tcout<<ans<<'\\n';\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n>>m>>s+1;\n\tfor(int i=1;i<=m;i++)\n\t\ta[i]=s[i]==s[1];\n\tint flag=1;\n\tfor(int i=1;i<=m;i++)\n\t\tflag&=a[i];\n\tif(flag) solve1();\n\telse solve2();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=200005,mod=1000000007;\nll ksm(ll a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ans;\n}\nll fac[N],f[N],ni[N];\nchar ch[N];\nint q[N];\nll c(int a,int b){\n\treturn a>=b&&b>=0?fac[a]*ni[b]%mod*ni[a-b]%mod:0;\n}\nint main(){\n\t//freopen(\"std.in\",\"r\",stdin); freopen(\"my.out\",\"w\",stdout);\n\tFor(i,fac[0]=1,N-1)fac[i]=fac[i-1]*i%mod; ni[N-1]=ksm(fac[N-1],mod-2);\n\tRep(i,N-1,1)ni[i-1]=ni[i]*i%mod;\n\tint n=read(),m=read();\n\tscanf(\"%s\",ch+1);\n\tif(ch[1]=='B')For(i,1,m)ch[i]='R'+'B'-ch[i];\n\tint fr=1;\n\tFor(i,2,m)if(ch[i]!=ch[i-1])fr=0;\n\tif(fr){\n\t\tll ans=0;\n\t\tFor(i,1,n)ans=(ans+c(i-1,n-i)+2*c(i-1,n-i-1))%mod;\n\t\twriteln(ans);\n\t\treturn 0;\n\t}\n\tint cnt=0,mx=1e9,fff=1;\n\tFor(i,1,m){\n\t\tif(ch[i]=='B'){\n\t\t\tif(cnt&1)mx=min(mx,cnt); else if(fff)mx=min(mx,cnt+1);\n\t\t\tcnt=0; fff=0;\n\t\t}else cnt++;\n\t}\n\tif(n&1){\n\t\tputs(\"0\"); return 0;\n\t}\n\tint t=mx; \n\tmx/=2; mx+=2;  //cout<<mx<<endl;\n\tstatic ll ans[N];\n\tans[0]=1;\n\tFor(i,1,n){\n\t\tif(i==1)ans[i]=-1; else ans[i]=0;\n\t\tans[i]=(ans[i]+(ll)ans[i-1]*2)%mod;\n\t\tif(i>=mx)ans[i]=(ans[i]-ans[i-mx])%mod;\n\t}\n\t//For(i,0,n)cout<<ans[i]<<\" \";puts(\"\");\n\tll sum=0;\n\tfor(int i=1;i<=t&&i<n;i+=2){\n\t\tsum=(sum+(i+1)*ans[(n-i-1)/2])%mod;// cout<<(i+1)<<\" \"<<ans[(n-i-1)/2]<<endl;\n\t}\n\tcout<<(sum+mod)%mod<<endl;\n}\n/*\n200000 8\nRRBRRRRB\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=200005,mod=1e9+7;\nint n,m,c[N],k,lst,f[N],pfx[N],ans; char s[N];\ninline int sum(CI x,CI y)\n{\n\tint t=x+y; return t>=mod?t-mod:t;\n}\nnamespace SP //one char solver\n{\n\tint f[N][2][2];\n\tinline int solve(void)\n\t{\n\t\tf[1][0][0]=f[1][1][1]=1; for (RI i=2;i<=n;++i)\n\t\tf[i][0][0]=sum(f[i-1][0][0],f[i-1][0][1]),f[i][0][1]=f[i-1][0][0],\n\t\tf[i][1][0]=sum(f[i-1][1][0],f[i-1][1][1]),f[i][1][1]=f[i-1][1][0];\n\t\treturn sum(f[n][0][0],sum(f[n][0][1],f[n][1][0]));\n\t}\n};\nint main()\n{\n\tRI i; for (scanf(\"%d%d%s\",&n,&m,s+1),lst=1,i=2;i<=n;++i)\n\tif (s[i]!=s[i-1]) c[++k]=i-lst,lst=i; c[++k]=n-lst+1;\n\tif (k==1) return printf(\"%d\",SP::solve()),0; if (n&1) return puts(\"0\"),0;\n\tif (k&1) --k; int lim=c[1]+!(c[1]&1); for (i=3;i<=k;i+=2) if (c[i]&1) lim=min(lim,c[i]);\n\tfor (n>>=1,lim=lim+1>>1,f[0]=pfx[0]=i=1;i<=n;++i)\n\tf[i]=sum(pfx[i-1],mod-(i-1-lim>=0?pfx[i-1-lim]:0)),\n\tpfx[i]=sum(pfx[i-1],f[i]); for (i=1;i<=min(n,lim);++i)\n\tans=sum(ans,2LL*f[n-i]*i%mod); return printf(\"%d\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#define N 201000\ntypedef long long ll;\ntemplate <typename T> inline void read(T &x) {\n\tx = 0; char c = getchar(); bool flag = false;\n\twhile (!isdigit(c)) { if (c == '-')\tflag = true; c = getchar(); }\n\twhile (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }\n\tif (flag)\tx = -x;\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nconst int inf = 987654321;\ninline void MIN(int &a, int b) {\n\tif (b < a)\ta = b;\n}\nint n, m;\nchar s[N];\nnamespace jzp1 {\n\tll jie[N], jieni[N];\n\tinline ll get_c(int n, int m) {\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\tif (n < 0 || m < 0 || n - m < 0)\treturn 0;\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\treturn jie[n] * jieni[m] % P * jieni[n - m] % P;\n\t}\n\tinline ll quickpow(ll x, int k) {\n\t\tll res = 1;\n\t\twhile (k) {\n\t\t\tif (k & 1)\tres = res * x % P;\n\t\t\tx = x * x % P;\n\t\t\tk >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline void sol() {\n\t\twhile(1);\n\t\tif (n == 1) { puts(\"1\"); return ; }\n\t\tjie[0] = jieni[0] = 1;\n\t\tint up = n + 1;\n\t\tfor (int i = 1; i <= up; ++i)\tjie[i] = jie[i - 1] * i % P;\n\t\tjieni[up] = quickpow(jie[up], P - 2);\n\t\tfor (int i = up - 1; i; --i)\tjieni[i] = jieni[i + 1] * (i + 1) % P;\n\t\tll res = 0;\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tres = (res + get_c(n - i + 1, i) - get_c(n - i - 1, i - 2)) % P;\n//\t\t\tprintf(\"res = %lld\\n\", res);\n\t\t}\n\t\tprintf(\"%lld\\n\", (res % P + P) % P);\n\t}\n}\nll f[N];\nll sum[N];\nint main() {\n\tread(n), read(m);\n\tscanf(\"%s\", s + 1);\n\tbool flag = false;\n\tfor (int i = 1; i <= m; ++i)\tif (s[i] != s[1]) { flag = true; break; }\n\tif (!flag) { jzp1::sol(); return 0; }\n\tif (n & 1) { puts(\"0\"); return 0; }\n\tint lst = 1, mn = inf;\n\tfor (int i = 2; i <= m + 1; ++i) {\n\t\tif (s[i] != s[1]) {\n\t\t\tif (lst & 1)\tMIN(mn, lst);\n\t\t\tlst = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == s[i - 1])\t++lst;\n\t\telse {\n\t\t\tif (lst & 1) MIN(mn, lst);\n\t\t\tlst = 1;\n\t\t}\n\t}\n\tif (mn == inf) {\n//\t\twhile (1);\n\t\tint memo = 1;\n\t\tfor (int i = 1; s[i] == s[1]; ++i) memo = i;\n\t\tmn = memo + 1;\n\t}\n\tn >>= 1;\n\tint k = (mn + 1) >> 1;\n\tf[0] = 1; sum[0] = 1;\n//\tprintf(\"n = %d, k = %d\\n\", n, k);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (i <= k)\tf[i] = sum[i - 1];\n\t\telse f[i] = (sum[i - 1] - sum[i - k - 1]) % P;\n\t\tsum[i] = (sum[i - 1] + f[i]) % P;\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tans += (f[n - i] * i) % P;\n\t}\n\tans = (ans << 1) % P;\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n\n/*\n3 3\nBBB\n//4\n\n1 1\nB\n//1\n\n12 10\nRRRRBRRRRB\n//78\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\n#include<cassert>\nusing namespace std;\nusing lint = long long;\nusing ld = long double;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(lint i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nint n, m;\nstring s;\n\nvoid allred() {\n\tlint v1 = 0, v2 = 0;\n\tlint ans = 0;\n\tv1 = 1;\n\tREP(i, n - 1) {\n\t\tlint nv1 = (v1 + v2) % MOD;\n\t\tlint nv2 = v1;\n\t\tv1 = nv1;\n\t\tv2 = nv2;\n\t}\n\tans += (v1 + v2) % MOD;\n\tv1 = 0; v2 = 1;\n\tREP(i, n - 1) {\n\t\tlint nv1 = (v1 + v2) % MOD;\n\t\tlint nv2 = v1;\n\t\tv1 = nv1;\n\t\tv2 = nv2;\n\t}\n\tans += v1;\n\tcout << (ans % MOD + MOD) % MOD << endl;\n\treturn;\n}\n\nvoid solve(vector<int> suc_red, int omn) {\n\tint th = omn;\n\tif(suc_red[0] % 2 == 0) th = min(th, suc_red[0] + 1);\n\tlint ans = 0;\n\t/*\n\tif((n - 1) % 2 && (n - 1) <= th) {\n\t\tans += n;\n\t}*/\n\tvector<lint> dpr(n), dpb(n);\n\tdpr[0] = 0;\n\tdpb[0] = 1;\n\tqueue<lint> q0;\n\tqueue<lint> q1;\n\tlint sum0 = 1, sum1 = 0;\n\tq0.push(1);\n\tFOR(i, 1, n) {\n\t\tif(i % 2 == 1) {\n\t\t\twhile(!q0.empty() && (int)q0.size() > (th + 1) / 2) {\n\t\t\t\tsum0 -= q0.front(); sum0 %= MOD;\n\t\t\t\tq0.pop();\n\t\t\t}\n\t\t\tdpr[i] = sum0;\n\t\t} else {\n\t\t\twhile(!q1.empty() && (int)q1.size() > (th + 1) / 2) {\n\t\t\t\tsum1 -= q1.front(); sum1 %= MOD;\n\t\t\t\tq1.pop();\n\t\t\t}\n\t\t\tdpr[i] = sum1;\n\t\t}\n\t\tdpb[i] = dpr[i - 1];\n\t\tif(i % 2 == 0) {\n\t\t\tq0.push(dpb[i]);\n\t\t\tsum0 += dpb[i]; sum0 %= MOD;\n\t\t} else {\n\t\t\tq1.push(dpb[i]);\n\t\t\tsum1 += dpb[i]; sum1 %= MOD;\n\t\t}\n\t}\n\tFOR(i, 1, n) {\n\t\tif(i > th) break;\n\t\tans += dpb[n - 1 - i] * i;\n\t\tans %= MOD;\n\t}\n\tans += dpr[n - 1]; ans %= MOD;\n\tcout << (ans % MOD + MOD) % MOD << endl;\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> m;\n\tcin >> s;\n\tif(s[0] == 'B') {\n\t\tREP(i, m) {\n\t\t\tif(s[i] == 'B') s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\n\tvector<int> suc_red;\n\tint c = 0;\n\tREP(i, n) {\n\t\tif(s[i] == 'R') c++;\n\t\telse {\n\t\t\tif(c != 0) suc_red.pb(c);\n\t\t\tc = 0;\n\t\t}\n\t}\n\tif(c != 0) suc_red.pb(c);\n\n\tif(suc_red[0] == m) {\n\t\tallred();\n\t\treturn 0;\n\t}\n\n\tassert(false);\n\n\tint omn = INF;\n\tREP(i, suc_red.size()) {\n\t\tif(suc_red[i] % 2) omn = min(omn, suc_red[i]);\n\t}\n\tsolve(suc_red, omn);\n\treturn 0;\n}\n/* --------------------------------------- */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll dp[202020][2][2];\nll mo=1000000007;\n\nll dp2[202020];\nll dps[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\tif(S[0]=='B') {\n\t\tFORR(c,S) c='R'+'B'-c;\n\t}\n\tif(count(ALL(S),'B')==0) {\n\t\tdp[0][0][0]=dp[0][1][1]=1;\n\t\tfor(i=1;i<N;i++) {\n\t\t\t(dp[i][0][0]=dp[i-1][0][0]+dp[i-1][0][1])%=mo;\n\t\t\t(dp[i][0][1]=dp[i-1][0][0])%=mo;\n\t\t\t(dp[i][1][0]=dp[i-1][1][0]+dp[i-1][1][1])%=mo;\n\t\t\t(dp[i][1][1]=dp[i-1][1][0])%=mo;\n\t\t}\n\t\tcout<<(dp[N-1][0][0]+dp[N-1][0][1]+dp[N-1][1][0])%mo<<endl;\n\t\treturn;\n\t}\n\t\n\tassert(N%2);\n\tint L=0;\n\twhile(S[L]=='R') L++;\n\t\n\tif(L%2==0) L++;\n\t\n\tdp2[0]=dps[0]=dps[1]=1;\n\tfor(i=2;i<=N;i++) {\n\t\tif(i%2==0) {\n\t\t\tdp2[i]=dps[i-2];\n\t\t\tif(i-(L+1)>0) dp2[i]+=mo-dps[i-(L+1)-1];\n\t\t\tdp2[i]%=mo;\n\t\t}\n\t\t(dps[i]=dps[i-1]+dp2[i])%=mo;\n\t\t//cout<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=min(L,N-1);i+=2) {\n\t\t//cout<<i<<\" \"<<(i+1)<<\"*\"<<dp2[N-(i+1)]<<endl;\n\t\t(ret+=(i+1)*dp2[N-(i+1)])%=mo;\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // clang-format off\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define in2(s,t)     rep(i,sz(s)){in(s[i] , t[i]);}\n#define in3(s,t,u)   rep(i,sz(s)){in(s[i] , t[i] , u[i]);}\n#define in4(s,t,u,v) rep(i,sz(s)){in(s[i] , t[i] , u[i] , v[i]);}\n#ifdef ONLINE_JUDGE\n  #define rep(i,N) for(int i = 0; i < (int)(N); i++)\n  #define repr(i,N) for(int i = (int)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(int i = 1; i <= (int)(N) ; i++)\n  #define repr1(i,N) for(int i = (N) ; (int)(i) > 0 ; i--)\n#else\n  #define rep(i,N) for(long long i = 0; i < (long long)(N); i++)\n  #define repr(i,N) for(long long i = (long long)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(long long i = 1; i <= (long long)(N) ; i++)\n  #define repr1(i,N) for(long long i = (N) ; (long long)(i) > 0 ; i--)\n#endif\nusing namespace std; void solve();\nusing ll = long long; template<class T = ll> using V = vector<T>;\nusing vi = V<int>; using vl = V<>; using vvi = V< V<int> >;\nusing vd = V<double>; using vs = V<string>; using vvl = V< V<> >;\nconstexpr int inf = 1001001001; constexpr ll infLL = (1LL << 61) - 1;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T,typename U>ll ceil(T a,U b){return (a + b - 1) / b;}\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); for(int i=0;i<s;i++) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);} while(0)\n  #define trcc(v) do { cerr << \"name : \" << #v << \"\\n\"; int cnt = 0; each(x , v){cerr << (cnt++) << \" : \"; trc(x); } } while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  #define trcc(...)\n  int main(){solve();}\n#endif\n\nconstexpr ll TEN(int n){ll ret=1,x=10;while(n){if(n&1)ret*=x;x*=x;n>>=1;}return ret;}\n#define mem(a, val) memset(a, val, sizeof(a))\n\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\nusing P = pair<ll,ll>; using vp = V<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n// clang-format on\n////////////////////////////////////////////////////\n\n\nvector<pair<char,int>> RunLengthEncoding(string& S){\n  vector<pair<char,int>> ret;\n  char c = -1;\n  int n = 0;\n  for(char x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate<typename T>\nvector<pair<T,int>> RunLengthEncoding(vector<T>& S){\n  vector<pair<T,int>> ret;\n  T c = -1;\n  int n = 0;\n  for(T& x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\nusing mint = modint;\n\nnamespace FastFourierTransform {\n  using real = double;\n\n  struct C {\n    real x, y;\n\n    C() : x(0), y(0) {}\n\n    C(real x, real y) : x(x), y(y) {}\n\n    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }\n\n    inline C conj() const { return C(x, -y); }\n  };\n\n  const real PI = acosl(-1);\n  int base = 1;\n  vector< C > rts = { {0, 0},\n                     {1, 0} };\n  vector< int > rev = {0, 1};\n\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    while(base < nbase) {\n      real angle = PI * 2.0 / (1 << (base + 1));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        real angle_i = angle * (2 * i + 1 - (1 << base));\n        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n      }\n      ++base;\n    }\n  }\n\n  void fft(vector< C > &a, int n) {\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          C z = a[i + j + k] * rts[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n  }\n\n  vector< int64_t > multiply(const vector< int > &a, const vector< int > &b) {\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = C(x, y);\n    }\n    fft(fa, sz);\n    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n      fa[i] = z;\n    }\n    for(int i = 0; i < (sz >> 1); i++) {\n      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n      fa[i] = A0 + A1 * s;\n    }\n    fft(fa, sz >> 1);\n    vector< int64_t > ret(need);\n    for(int i = 0; i < need; i++) {\n      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n    }\n    return ret;\n  }\n};\n\ntemplate< typename T >\nstruct ArbitraryModConvolution {\n  using real = FastFourierTransform::real;\n  using C = FastFourierTransform::C;\n\n  ArbitraryModConvolution() = default;\n\n  vector< T > multiply(const vector< T > &a, const vector< T > &b, int need = -1) {\n    if(need == -1) need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while((1 << nbase) < need) nbase++;\n    FastFourierTransform::ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < (int)a.size(); i++) {\n      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);\n    }\n    fft(fa, sz);\n    vector< C > fb(sz);\n    if(a == b) {\n      fb = fa;\n    } else {\n      for(int i = 0; i < (int)b.size(); i++) {\n        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);\n      }\n      fft(fb, sz);\n    }\n    real ratio = 0.25 / sz;\n    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C a1 = (fa[i] + fa[j].conj());\n      C a2 = (fa[i] - fa[j].conj()) * r2;\n      C b1 = (fb[i] + fb[j].conj()) * r3;\n      C b2 = (fb[i] - fb[j].conj()) * r4;\n      if(i != j) {\n        C c1 = (fa[j] + fa[i].conj());\n        C c2 = (fa[j] - fa[i].conj()) * r2;\n        C d1 = (fb[j] + fb[i].conj()) * r3;\n        C d2 = (fb[j] - fb[i].conj()) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector< T > ret(need);\n    for(int i = 0; i < need; i++) {\n      int64_t aa = llround(fa[i].x);\n      int64_t bb = llround(fb[i].x);\n      int64_t cc = llround(fa[i].y);\n      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;\n      ret[i] = aa + (bb << 15) + (cc << 30);\n    }\n    return ret;\n  }\n};\n\ntemplate< int mod >\nstruct NumberTheoreticTransform {\n\n  int base, max_base, root;\n  vector< int > rev, rts;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while(tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while(n > 0) {\n      if(n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) {\n    return mod_pow(x, mod - 2);\n  }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long) mod;\n  }\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while(base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n\n  void ntt(vector< int > &a) {\n    const int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n\n  vector< int > multiply(vector< int > a, vector< int > b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for(int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n\n  vector<modint> multiply_for_fps(const vector<modint> &a,const vector<modint> &b){\n    vector<int> A(a.size()) , B(b.size());\n    for(int i = 0;i < (int)a.size(); i++) A[i] = a[i].x;\n    for(int i = 0;i < (int)b.size(); i++) B[i] = b[i].x;\n    auto C = multiply( A , B );\n    vector<modint> ret(C.size());\n    for(int i = 0; i < (int)C.size() ;i++) ret[i].x = C[i];\n    return ret;\n  }\n};\n\n\ntemplate< typename T >\nstruct FormalPowerSeries : vector< T > {\n  using vector< T >::vector;\n  using P = FormalPowerSeries;\n\n  using MULT = function< P(P, P) >;\n\n  static MULT &get_mult() {\n    static MULT mult = nullptr;\n    return mult;\n  }\n\n  static void set_fft(MULT f) {\n    get_mult() = f;\n  }\n\n  void shrink() {\n    while(this->size() && this->back() == T(0)) this->pop_back();\n  }\n\n  P operator+(const P &r) const { return P(*this) += r; }\n\n  P operator+(const T &v) const { return P(*this) += v; }\n\n  P operator-(const P &r) const { return P(*this) -= r; }\n\n  P operator-(const T &v) const { return P(*this) -= v; }\n\n  P operator*(const P &r) const { return P(*this) *= r; }\n\n  P operator*(const T &v) const { return P(*this) *= v; }\n\n  P operator/(const P &r) const { return P(*this) /= r; }\n\n  P operator%(const P &r) const { return P(*this) %= r; }\n\n  P &operator+=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] += r[i];\n    return *this;\n  }\n\n  P &operator+=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] += r;\n    return *this;\n  }\n\n  P &operator-=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] -= r[i];\n    shrink();\n    return *this;\n  }\n\n  P &operator-=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] -= r;\n    shrink();\n    return *this;\n  }\n\n  P &operator*=(const T &v) {\n    const int n = (int) this->size();\n    for(int k = 0; k < n; k++) (*this)[k] *= v;\n    return *this;\n  }\n\n  P &operator*=(const P &r) {\n    if(this->empty() || r.empty()) {\n      this->clear();\n      return *this;\n    }\n    assert(get_mult() != nullptr);\n    return *this = get_mult()(*this, r);\n  }\n\n  P &operator%=(const P &r) {\n    return *this -= *this / r * r;\n  }\n\n  P operator-() const {\n    P ret(this->size());\n    for(int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];\n    return ret;\n  }\n\n  P &operator/=(const P &r) {\n    if(this->size() < r.size()) {\n      this->clear();\n      return *this;\n    }\n    int n = this->size() - r.size() + 1;\n    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);\n  }\n\n  P pre(int sz) const {\n    return P(begin(*this), begin(*this) + min((int) this->size(), sz));\n  }\n\n  P operator>>(int sz) const {\n    if(this->size() <= sz) return {};\n    P ret(*this);\n    ret.erase(ret.begin(), ret.begin() + sz);\n    return ret;\n  }\n\n  P operator<<(int sz) const {\n    P ret(*this);\n    ret.insert(ret.begin(), sz, T(0));\n    return ret;\n  }\n\n  P rev(int deg = -1) const {\n    P ret(*this);\n    if(deg != -1) ret.resize(deg, T(0));\n    reverse(begin(ret), end(ret));\n    return ret;\n  }\n\n  P diff() const {\n    const int n = (int) this->size();\n    P ret(max(0, n - 1));\n    for(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);\n    return ret;\n  }\n\n  P integral() const {\n    const int n = (int) this->size();\n    P ret(n + 1);\n    ret[0] = T(0);\n    for(int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);\n    return ret;\n  }\n\n  // F(0) must not be 0\n  P inv(int deg = -1) const {\n    assert(((*this)[0]) != T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1) / (*this)[0]});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 1\n  P log(int deg = -1) const {\n    assert((*this)[0] == 1);\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();\n  }\n\n  P sqrt(int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n\n    if((*this)[0] == T(0)) {\n      for(int i = 1; i < n; i++) {\n        if((*this)[i] != T(0)) {\n          if(i & 1) return {};\n          if(deg - i / 2 <= 0) break;\n          auto ret = (*this >> i).sqrt(deg - i / 2) << (i / 2);\n          if(ret.size() < deg) ret.resize(deg, T(0));\n          return ret;\n        }\n      }\n      return P(deg, 0);\n    }\n\n    P ret({T(1)});\n    T inv2 = T(1) / T(2);\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 0\n  P exp(int deg = -1) const {\n    assert((*this)[0] == T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1)});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  P pow(int64_t k, int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    for(int i = 0; i < n; i++) {\n      if((*this)[i] != T(0)) {\n        T rev = T(1) / (*this)[i];\n        P C(*this * rev);\n        P D(n - i);\n        for(int j = i; j < n; j++) D[j - i] = C[j];\n        D = (D.log() * k).exp() * (*this)[i].pow(k);\n        P E(deg);\n        if(i * k > deg) return E;\n        auto S = i * k;\n        for(int j = 0; j + S < deg && j < D.size(); j++) E[j + S] = D[j];\n        return E;\n      }\n    }\n    return *this;\n  }\n\n  T eval(T x) const {\n    T r = 0, w = 1;\n    for(auto &v : *this) {\n      r += w * v;\n      w *= x;\n    }\n    return r;\n  }\n};\n\nusing FPS = FormalPowerSeries< modint >;\n\n// fにa * x^n + bを掛ける\nvoid mul_simple(FPS &f,modint a ,int n, modint b){\n  for(int i = (int)f.size() - 1 ; i >= 0 ; i--){\n    f[i] *= b;\n    if(i >= n) f[i] += f[i - n] * a; \n  }\n}\n\n// fからa * x^n + bを割る\nvoid div_simple(FPS &f,modint a,int n,modint b){\n  for(int i = 0 ; i < (int)f.size() ; i++){\n    f[i] /= b;\n    if(i + n < (int)f.size() ) f[n + i] -= f[i] * a; \n  }\n}\n\n// f / gをdeg(f)次まで求める\nFPS div_(FPS &f , FPS g){\n  int n = f.size();\n  return (f * g.inv(n)).pre(n);\n}\n\n\n// solve関数内で\n//\n// FPS::set_fft(mul);\n//\n// とすること。\n\n/**\nNumberTheoreticTransform<MOD> ntt;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret =ntt.multiply_for_fps(a , b);\n  return FPS::P(ret.begin(), ret.end());\n};\n/*///\nArbitraryModConvolution< modint > fft;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret = fft.multiply(a, b);\n  return FPS::P(ret.begin(), ret.end());\n};\n//*/\n\n// 下記のリンクを実装(kitamasa法のモンゴメリ乗算を使わない版)\n// http://q.c.titech.ac.jp/docs/progs/polynomial_division.html\n// k項間漸化式のa_Nを求める O(k log k log N)\n// N ... 求めたい項　(0-indexed)\n// Q ... 漸化式 (1 - \\sum_i c_i x^i)の形\n// a ... 初期解 (a_0 , a_1 , ... , a_k-1)\n// x^N を fでわった剰余を求め、aと内積を取る\nmodint kitamasa(ll N, FPS &Q, FPS &a){\n  int k = Q.size() - 1;\n  assert( (int)a.size() == k );\n  FPS P = a * Q; P.resize(k);\n  while(N){\n    auto Q2 = Q;\n    for(int i = 1; i < (int)Q2.size(); i += 2) Q2[i].x = MOD - Q2[i].x;\n    auto S = P * Q2;\n    auto T = Q * Q2;\n    if(N & 1){\n      for(int i = 1 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    else{\n      for(int i = 0 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    N >>= 1;\n  }\n  return P[0];\n}\n\nvoid solve(){\n  ini(N , M);\n  ins(S);\n  auto run = RunLengthEncoding(S);\n  if(run.size() == 1){\n    // DP\n    V<mint> dp(N),ep(N),fp(N),gp(N);\n    // [0]がR\n    // -> [1],[-1]はどちらでもよい\n    dp[0] = gp[0] = 1;\n    rep1(i , N - 1){\n      dp[i] = dp[i - 1] + ep[i - 1];\n      ep[i] = dp[i - 1];\n      fp[i] = fp[i - 1] + gp[i - 1];\n      gp[i] = fp[i - 1];\n    }\n    out(dp[N-1] + ep[N-1] + fp[N-1]);\n    return;\n  }\n  if(N % 2 == 1){\n    out(0);\n    return;\n  }\n\n  FPS::set_fft(mul);\n  // rの最小値\n  int r = N-1 , b = N-1;\n  auto trans = [](int n){\n    return (n % 2 == 1) ? n : (n + 1);\n  };\n  rep(i , sz(run)){\n    if(i==0)continue;\n    auto p = run[i];\n    if(p.first == 'R' && p.second % 2 == 1) amin(r , trans(p.second));\n    if(p.first == 'B' && p.second % 2 == 1) amin(b , trans(p.second));\n  }\n\n  // 初手の制約\n  amin( (run[0].first == 'R' ? r : b) , trans(run[0].second) );\n  // 初手とは異なる方が1である必要あり\n  (run[0].first == 'R' ? b : r) = 1;\n  trc(r , b);\n  if(r < b) swap(r , b);  \n  auto nyaan = [&](ll n,int flg = false) -> FPS{\n    FPS ret(n + 1);\n    for(int i = 1 ; i <= n ; i += 2) ret[i] = (flg ? i + 1 : 1);\n    return ret;\n  };\n  FPS f({0 , 1});\n  f *= nyaan(r);\n  f *= -1; f[0] = 1;\n  if((int)f.size() <= N) f.resize(N * 2 + 100);\n  trc(f);\n  f = f.inv();\n  trc(f);\n  // [0]の置き方\n  f *= nyaan(r,1);\n  trc(f);\n  out(f[N-1]);\n  \n  \n  /*\n  //trc(f);\n  // 倍数包除\n  for(int i = 2 ; i <= N ; i++){\n    // i番目は？\n    //引こう！\n    for(int j = 2 ; i * j <= N ; j++){\n      f[i * j] -= f[i];\n    }\n  }\n  trc(f);\n  */\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\nunsigned int mod_pow(unsigned int a, unsigned int n, unsigned int _mod){\n    unsigned int ret = 1;\n\twhile(n){\n\t\tif(n & 1) ret = (unsigned long long)ret * a % _mod;\n\t\ta = (unsigned long long)a * a % _mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\n\ntemplate<unsigned int _mod>\nclass NTT {\npublic:\n\tunsigned int get_mod() const { return _mod; }\n    void ntt(vector<int>& a, const bool rev = false){\n        unsigned int i, j, k, l, p, q, r, s;\n        const unsigned int size = a.size();\n    \tif(size == 1) return;\n    \tvector<int> b(size);\n    \tr = rev ? (_mod - 1 - (_mod - 1) / size) : (_mod - 1) / size;\n    \ts = mod_pow(3, r, _mod);\n    \tvector<unsigned int> kp(size / 2 + 1, 1);\n    \tfor(i = 0; i < size / 2; ++i) kp[i + 1] = (unsigned long long)kp[i] * s % _mod;\n    \tfor(i = 1, l = size / 2; i < size; i <<= 1, l >>= 1){\n    \t\tfor(j = 0, r = 0; j < l; ++j, r += i){\n    \t\t\tfor(k = 0, s = kp[i * j]; k < i; ++k){\n    \t\t\t\tp = a[k + r], q = a[k + r + size / 2];\n    \t\t\t\tb[k + 2 * r] = ((p + q < _mod) ? (p + q) : (p + q - _mod));\n    \t\t\t\tb[k + 2 * r + i] = (unsigned long long)((p >= q) ? (p - q) : (_mod - q + p)) * s % _mod;\n    \t\t\t}\n    \t\t}\n    \t\tswap(a, b);\n    \t}\n        if(rev){\n            s = mod_pow(size, _mod - 2, _mod);\n            for(i = 0; i < size; ++i){ a[i] = (unsigned long long)a[i] * s % _mod; }\n        }\n    }\n\tvoid convolution(const vector<int>& a, const vector<int>& b, vector<int>& _a, vector<int>& _b,\n        unsigned int asize, unsigned int bsize, unsigned int _size){\n\t\tunsigned int ntt_size = 1;\n\t\twhile(ntt_size < asize + bsize) ntt_size *= 2;\n        _a.assign(ntt_size, 0), _b.assign(ntt_size, 0);\n        for(unsigned int i = 0; i < asize; ++i){ _a[i] = ((a[i] < (int)_mod) ? a[i] : (a[i] % _mod)); }\n        for(unsigned int i = 0; i < bsize; ++i){ _b[i] = ((b[i] < (int)_mod) ? b[i] : (b[i] % _mod)); }\n\t\tntt(_a), ntt(_b);\n\t\tfor(unsigned int i = 0; i < ntt_size; ++i){\n\t\t\t_a[i] = (unsigned long long)_a[i] * _b[i] % _mod;\n\t\t}\n        ntt(_a, true);\n        _a.resize(_size);\n\t}\n};\n\ntypedef NTT<167772161> NTT_1;\ntypedef NTT<469762049> NTT_2;\ntypedef NTT<1224736769> NTT_3;\n\nvector<int> convolute(const vector<int>& a, const vector<int>& b, int asize, int bsize, int _size){\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n    vector<int> x, _x, y, _y, z, _z;\n\tntt1.convolution(a, b, x, _x, asize, bsize, _size);\n    ntt2.convolution(a, b, y, _y, asize, bsize, _size);\n    ntt3.convolution(a, b, z, _z, asize, bsize, _size);\n\tconst unsigned int m1 = ntt1.get_mod(), m2 = ntt2.get_mod(), m3 = ntt3.get_mod();\n\tconst unsigned int m1_inv_m2 = mod_pow(m1, m2-2, m2);\n\tconst unsigned int m12_inv_m3 = mod_pow((unsigned long long)m1 * m2 % m3, m3-2, m3);\n\tconst unsigned int m12_mod = (unsigned long long)m1 * m2 % MOD;\n\tvector<int> res(_size);\n\tfor(unsigned int i = 0; i < x.size(); ++i){\n\t    unsigned int v1 = ((unsigned long long )y[i] + m2 - x[i]) *  m1_inv_m2 % m2;\n\t    unsigned int v2 = ((unsigned long long)z[i] + m3 - (x[i] + (unsigned long long)m1 * v1) % m3) * m12_inv_m3 % m3;\n\t    res[i] = (x[i] + (unsigned long long)m1 * v1 + (unsigned long long)m12_mod * v2) % MOD;\n\t}\n    return res;\n}\n\nunsigned int add(const unsigned int x, const unsigned int y)\n{\n    return (x + y < MOD) ? x + y : x + y - MOD;\n}\n \nunsigned int sub(const unsigned int x, const unsigned int y)\n{\n    return (x >= y) ? (x - y) : (MOD - y + x);\n}\n \nunsigned int mul(const unsigned int x, const unsigned int y)\n{\n    return (unsigned long long)x * y % MOD;\n}\n \nunsigned int mod_pow(unsigned int x, unsigned int n)\n{\n    unsigned int res = 1;\n    while(n > 0){\n        if(n & 1){ res = mul(res, x); }\n        x = mul(x, x);\n        n >>= 1;\n    }\n    return res;\n}\n \nunsigned int inverse(const unsigned int x)\n{\n    return mod_pow(x, MOD - 2);\n}\n \nvector<int> polynomial_inverse(const vector<int>& a, int r)\n{\n    assert(a[0] != 0);\n    vector<int> h = {(int)inverse(a[0])};\n    int t = 1;\n    for(int i = 0; t < r; ++i){\n        t <<= 1;\n        vector<int> res = convolute(a, convolute(h, h, t / 2, t / 2, t), min((int)a.size(), t), t, t);\n        for(int j = 0; j < t; ++j){\n            res[j] = sub(0, res[j]);\n            if(j < t / 2) res[j] = add(res[j], mul(2, h[j]));\n        }\n        swap(h, res);\n    }\n    h.resize(r);\n    return h;\n}\n\nmod dp[200010][2][2];\nint main(){\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if(s[0]=='R'){\n        rep(i,m){\n            if(s[i]=='R'){\n                s[i] ='B';\n            }else{\n                s[i] ='R'; \n            }\n        }\n    }\n    int a = inf;\n    int c = 0;\n    bool flag = 1;\n    rep(i,m){\n        if(s[i]=='B'){\n            c++;\n        }else{\n            if(flag){\n                flag = 0;\n                chmin(a,c);\n            }else if(c%2==1){\n                chmin(a,c); \n            }\n            c = 0;   \n        }\n    }\n    if(a==inf){\n        dp[0][0][0] = 1;\n        dp[0][1][1] = 1;\n        for(int i=1;i<n;i++){\n            for(int j=0;j<2;j++){\n                if(j==0){\n                    dp[i][j][0] += dp[i-1][1][0];\n                    dp[i][j][1] += dp[i-1][1][1];\n                }else{\n                    dp[i][j][0] += dp[i-1][1][0] + dp[i-1][0][0];\n                    dp[i][j][1] += dp[i-1][1][1] + dp[i-1][0][1];    \n                }\n            }\n        }\n        cout << dp[n-1][1][0] + dp[n-1][1][1] + dp[n-1][0][1] << endl;\n    }else{\n        int len = (a/2)*2+1;\n        vector<int> X(n+1),Y(n+1);\n        len++;\n        len = min(n,len);\n        for(int i=2;i<=len;i+=2){\n            X[i] = i;\n        }\n        Y[0] = 1;\n        for(int i=2;i<=len;i+=2){\n            Y[i] = MOD-1;\n        }\n        Y =polynomial_inverse(Y,n+1);\n        X = convolute(X,Y,(int)X.size(),(int)Y.size(),n+1);\n        cout << X[n] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___CLASS_MODINT\n#define ___CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::uint64_t n_) : n(n_ % mod) {};\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tstd::uint32_t get() const { return n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint binpow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tmodint inv() { return (*this).binpow(mod - 2); }\n};\n\n#endif // ___CLASS_MODINT\n\n#include <string>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nusing modulo = modint<1000000007>;\nconst int inf = 1012345678;\nint solve(int N, int M, string S) {\n\tif (S[0] == 'B') {\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (S[i] == 'B') S[i] = 'R';\n\t\t\telse S[i] = 'B';\n\t\t}\n\t}\n\tint pre = 0, mn = inf; bool bluemove = true;\n\tfor (int i = 1; i < M; ++i) {\n\t\tif (S[i - 1] != S[i]) {\n\t\t\tif (S[i - 1] == 'R' && (pre == 0 || (i - pre) % 2 == 1)) {\n\t\t\t\tmn = min(mn, i - pre + 1);\n\t\t\t}\n\t\t\tif (S[i - 1] == 'B' && (i - pre) % 2 == 1) {\n\t\t\t\tbluemove = false;\n\t\t\t}\n\t\t\tpre = i;\n\t\t}\n\t}\n\tif (mn == inf) {\n\t\tvector<modulo> fib(N + 3);\n\t\tfib[1] = 1;\n\t\tfor (int i = 2; i <= N + 2; ++i) {\n\t\t\tfib[i] = fib[i - 1] + fib[i - 2];\n\t\t}\n\t\tmodulo ans = fib[N + 2] - fib[N - 2];\n\t\treturn ans.get();\n\t}\n\telse if (bluemove) {\n\t\tvector<modulo> dp1(N + 1), dp2(N + 1);\n\t\tdp2[0] = 1;\n\t\tfor (int i = 1; i <= N; ++i) {\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tdp1[i] += dp2[j];\n\t\t\t\tif ((i - j) % 2 == 1 && i - j <= mn) {\n\t\t\t\t\tdp2[i] += dp1[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmodulo ans = dp1[N];\n\t\tfor (int i = 1; i <= mn && i <= N; i += 2) {\n\t\t\tans += dp1[N - i] * (i + 1);\n\t\t}\n\t\treturn ans.get();\n\t}\n\telse {\n\t\tvector<modulo> dp(N + 1);\n\t\tdp[1] = 1;\n\t\tint lim = (mn + 1) / 2 * 2;\n\t\tmodulo sum = 1;\n\t\tfor (int i = 3; i <= N; i += 2) {\n\t\t\tif (i - lim - 2 >= 0) sum -= dp[i - lim - 2];\n\t\t\tdp[i] = sum;\n\t\t\tsum += dp[i];\n\t\t}\n\t\tmodulo ans = 0;\n\t\tfor (int i = 1; i <= mn && i <= N; i += 2) {\n\t\t\tans += dp[N - i] * (i + 1);\n\t\t}\n\t\treturn ans.get();\n\t}\n\treturn -1;\n}\nint main() {\n\tint N, M; string S;\n\tcin >> N >> M >> S;\n\tcout << solve(N, M, S) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int p = 1e9 + 7;\nint main() {\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n, m;\n  cin >> n >> m;\n  string str;\n  cin >> str;\n  if (str[0] == 'B') {\n    for (int i = 0; i < m; i++) {\n      if (str[i] == 'R') {\n        str[i] = 'B';\n      } else {\n        str[i] = 'R';\n      }\n    }\n  }\n  while (!str.empty() && str.back() == 'R') {\n    str.pop_back();\n  }\n  if (str.empty()) {\n    vector<int> dp(n);\n    int sum = 0;\n    for (int i = 1; i < n; i++) {\n      dp[i] = (i + 1 + sum) % p;\n      if (i) {\n        sum = (sum + dp[i - 1]) % p;\n      }\n    }\n    cout << (dp[n - 1] + 1) % p << endl;\n  } else {\n    int limit = INT_MAX, last = -1;\n    for (int i = 0; i < str.size(); i++) {\n      if (str[i] == 'B') {\n        int len = i - last - 1;\n        if (len & 1) {\n          limit = min(limit, len);\n        } else if (-1 == last) {\n          limit = min(limit, len + 1);\n        }\n        last = i;\n      }\n    }\n    vector<int> dp(n);\n    int sum_0 = 0, sum_1 = 0;\n    for (int i = 1; i < n; i++) {\n      if (i <= limit) {\n        dp[i] = i + 1;\n      }\n      if (i & 1) {\n        dp[i] = (dp[i] + sum_1) % p;\n        sum_0 = (sum_0 + dp[i - 1]) % p;\n      } else {\n        dp[i] = (dp[i] + sum_0) % p;\n        sum_1 = (sum_1 + dp[i - 1]) % p;\n      }\n      if (i - limit - 1 > 0) {\n        if (i - limit - 1 & 1) {\n          sum_1 = (sum_1 - dp[i - limit - 1] + p) % p;\n        } else {\n          sum_0 = (sum_0 - dp[i - limit - 1] + p) % p;\n        }\n      }\n    }\n    int answer = dp[n - 1];\n    if (n & 1) {\n      answer = (answer + 1) % p;\n    }\n    cout << answer << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n/*\n0-index\nfunctionの中を書いて使う\n宣言の時に単位元を書く\n*/\ntemplate<typename T>\nstruct segtree{\n\tint n;\n\tvector<T> dat;\n\tT ZERO;\n\tfunction<T(T,T)> func;\n\tsegtree(int n_, function<T(T,T)> func_, T zero):func(func_), ZERO(zero){\n\t  n = 1;\n\t  while(n < n_)n*=2;\n\t  dat.resize(2*n);\n\t  for(int i = 0;i < 2*n;i++)dat[i] = ZERO;\n\t}\n\tvoid update(int k, T a){\n\t  k += n - 1;dat[k] = a;\n\t  while(k > 0){\n\t\tk = (k-1)/2;\n\t\tdat[k] = func(dat[k*2+1],dat[k*2+2]);\n\t  }\n\t}\n\n\tvoid set(int k, T a) {\n\t\tk += n - 1;dat[k] = a;\n\t}\n\n\tvoid build(){\n\t\tfor(int i = n - 2;i >= 0;i--){\n\t\t\tdat[i] = func(dat[2 * i + 1], dat[2 * i + 2]);\n\t\t}\n\t}\n\n\tT get(int k){return dat[k+n-1];}\n\n\tT que(int a,int b){\n\t\tT L = ZERO,R = ZERO;\n\t\tint A = a + n - 1;\n\t\tint B = b + n - 1;\n\t\twhile(A < B){\n\t\t\tif((A & 1) == 0)L = func(L,dat[A++]);\n            if((B & 1) == 0)R = func(dat[--B],R);\n            A = A >> 1;\n            B = B >> 1;\n\t\t}\n\t\treturn func(L,R);\n\t}\n};\n\n\nint getmin(string str){\n\tchar c = str[0];\n\tbool isFirst = true;\n\tint cou = 0;\n\tint ret = INF;\n\tREP(i, str.size()){\n\t\tif(str[i] == c)cou++;\n\t\telse {\n\t\t\tif(isFirst && cou % 2 == 0)cou++;\n\t\t\tif(cou % 2)ret = min(ret, cou);\n\t\t\tisFirst = false;\n\t\t\tcou = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nbool oneKind(string str){\n\tREP(i, str.size())if(str[0] != str[i])return false;\n\treturn true;\n}\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\tll n, m;cin >> n >> m;\n\tstring str;cin >> str;\n\tll ans = 0;\n\n\tint k = getmin(str);\n\tsegtree<ll> seg(n, [](ll a, ll b){return (a + b) % MOD;}, 0);\n\n\tseg.update(0, 1);\n\n\tif(oneKind(str)){\n\t\tfor(ll i = 2;i < n;i++){\n\t\t\tll l = max(0LL, i - k - 1);\n\t\t\tll r = i - 1;\n\t\t\tseg.update(i, seg.que(l, r));\n\t\t}\n\t\tREP(i, n-1){\n\t\t\tif(n - (i + 1) <= k){\n\t\t\t\t//cout << \"pass \" << seg.get(i) * (n - i) % MOD << endl;\n\t\t\t\tans = (ans + seg.get(i) * (n - i) % MOD) % MOD;\n\t\t\t}\n\t\t}\n\t\tans = (ans + 1) % MOD;\n\t}\n\telse {\n\t\tfor(ll i = 2;i < n;i++){\n\t\t\tif(i % 2)continue;\n\t\t\tll l = max(0LL, i - k - 1);\n\t\t\tll r = i - 1;\n\t\t\tseg.update(i, seg.que(l, r));\n\t\t}\n\n\t\t//REP(i, n)cout << seg.get(i) << \" \";cout << endl;\n\t\tREP(i, n-1){\n\t\t\tif(n - (i + 1) <= k && ((n - (i + 1)) % 2)){\n\t\t\t\t//cout << \"pass \" << seg.get(i) * (n - i) % MOD << endl;\n\t\t\t\tans = (ans + seg.get(i) * (n - i) % MOD) % MOD;\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nconst int MOD = (1e9 + 7);\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(a<b) return 0;\n\tif(b==0) return 1;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tpow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\n\nint dp[2][2][333333]; //# of sols to a_1+b_1+...+a_n=K in restricted range\nint S[2][2][2][333333];\nconst int INF = int(1e9);\n\nint ss(int parity, int id, int lascolor, int pos)\n{\n\twhile(pos>=0&&((pos+parity)%2!=0)) pos--;\n\tif(pos<0) return 0;\n\treturn S[parity][id][lascolor][pos];\n}\n\n\nint sum(int id, int lascolor, int parity, int l, int r)\n{\n\treturn add(ss(parity,id,lascolor,r),MOD-ss(parity,id,lascolor,l-1));\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tinit(234567);\n\tint n,m; cin>>n>>m;\n\tstring s; cin>>s;\n\tint mx[2] = {INF,INF};\n\tint pr[2] = {1,1};\n\tvector<int> runs;\n\tint currun=1;\n\tfor(int i=1;i<m;i++)\n\t{\n\t\tif(s[i]==s[i-1]) currun++;\n\t\telse\n\t\t{\n\t\t\truns.pb(currun); currun=1;\n\t\t}\n\t}\n\truns.pb(currun);\n\tfor(int i=0;i+1<runs.size();i++)\n\t{\n\t\tmx[i%2]=min(mx[i%2],runs[i]+1); pr[i%2]=0;\n\t}\n\t//cerr<<mx[0]<<' '<<mx[1]<<' '<<pr[0]<<' '<<pr[1]<<'\\n';\n\t//mono color\n\tint ans=0;\n\tif(mx[0]==INF&&mx[1]==INF){ans++;}\n\tmx[1]=1;\n\t//exist at least 2 colors\n\t/*\n\t{\n\t\tint cnt=0;\n\t\tfor(int i=1;i+1<(1<<n);i++)\n\t\t{\n\t\t\tint M[2]={0,0};\n\t\t\tint exeven[2]={0,0};\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint cur=j;\n\t\t\t\tint vv=0;\n\t\t\t\tif(i&(1<<j)) vv=1;\n\t\t\t\tint r=1;\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\tif(r>=n){break;}\n\t\t\t\t\tcur++;\n\t\t\t\t\tcur%=n;\n\t\t\t\t\tint v=0;\n\t\t\t\t\tif(i&(1<<cur)) v=1;\n\t\t\t\t\tif(vv==v) r++;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tM[vv]=max(M[vv],r);\n\t\t\t\tbool isrun=false;\n\t\t\t\tint tmp = (j+n-1)%n;\n\t\t\t\tint xx=0;\n\t\t\t\tif(i&(1<<tmp)) xx=1;\n\t\t\t\tif(xx!=vv){isrun=1;}\n\t\t\t\tif(r%2==0&&isrun) exeven[vv]=1;\n\t\t\t}\n\t\t\tif(M[0]>mx[0]||M[1]>mx[1]) continue;\n\t\t\tif(exeven[0])\n\t\t\t{\n\t\t\t\tif(!pr[0]) continue;\n\t\t\t}\n\t\t\tif(exeven[1])\n\t\t\t{\n\t\t\t\tif(!pr[1]) continue;\n\t\t\t}\n\t\t\t//cerr<<M[0]<<' '<<M[1]<<' '<<exeven[0]<<' '<<exeven[1]<<'\\n';\n\t\t\tcnt++;\n\t\t}\n\t\t//cerr<<\"CNT : \"<<cnt<<'\\n';\n\t}\n\t*/\n\tfor(int i=0;i<2;i++)\n\t{\n\t\t//start with color i\n\t\tfor(int j=1;j<=min(n,mx[i]);j++)\n\t\t{\n\t\t\tif(j%2==0)\n\t\t\t{\n\t\t\t\tif(!pr[i]) continue;\n\t\t\t}\n\t\t\tdp[i][i][j]=1;\n\t\t}\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\t//push dp\n\t\t\tfor(int k=0;k<2;k++)\n\t\t\t{\n\t\t\t\tdp[i][k][j] = add(dp[i][k][j], sum(i,k^1,(j+1)&1,j-mx[k],j-1));\n\t\t\t\tif(pr[k]) dp[i][k][j] = add(dp[i][k][j], sum(i,k^1,j&1,j-mx[k],j-1));\n\t\t\t\t//cerr<<i<<' '<<k<<' '<<j<<' '<<dp[i][k][j]<<'\\n';\n\t\t\t}\n\t\t\tfor(int k=0;k<2;k++)\n\t\t\t{\n\t\t\t\tS[j%2][i][k][j]=dp[i][k][j];\n\t\t\t\tif(j-2>=0) S[j%2][i][k][j]=add(S[j%2][i][k][j],S[j%2][i][k][j-2]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int c=0;c<2;c++)\n\t{\n\t\tfor(int run=1;run<=min(n,mx[c]);run++)\n\t\t{\n\t\t\tif(run%2==0)\n\t\t\t{\n\t\t\t\tif(!pr[c]) continue;\n\t\t\t}\n\t\t\tint val = dp[c^1][c^1][n-run];\n\t\t\t//cerr<<c<<' '<<run<<' '<<val<<'\\n';\n\t\t\tans=add(ans,mult(run,val));\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200010\n#define ll long long\n#define mod 1000000007\nusing namespace std;\nchar s[maxn];\nint f[maxn], pre[maxn];\nint main()\n{\n\tint n, m, mx = 0, flag = 1;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", s + 1);\n\tfor (int i = 2; i <= m; i++)\n\t\tif (s[i] != s[1]) flag = 0;\n\tif (flag == 0)\n\t{\n\t\tint st;\n\t\tfor (int i = 1; i <= m; i++)\n\t\t\tif (s[i] != s[1])\n\t\t\t{\n\t\t\t\tst = i;\n\t\t\t\tmx = i - 1;\n\t\t\t\tif (mx % 2 == 0) mx++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\twhile (st <= m)\n\t\t{\n\t\t\tint cur = st;\n\t\t\twhile (cur <= m && s[cur] == s[st]) cur++;\n\t\t\tif (s[st] == s[1] && (st - cur) % 2) mx = min(mx, cur - st);\n\t\t\tst = cur;\n\t\t}\n\t\tif (n % 2) {puts(\"0\"); return 0;}\n\t\tn /= 2;\n\t\tmx = (mx + 1) / 2;\n\t}\n\telse mx = n;\n\tf[0] = pre[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tf[i] = pre[i - 1];\n\t\tif (i - mx - 1 >= 0) f[i] = (f[i] - pre[i - mx - 1] + mod) % mod;\n\t\tif (flag) f[i] = (f[i] - f[i - 1] + mod) % mod;\n\t\tpre[i] = (pre[i - 1] + f[i]) % mod;\n\t}\n\tint res = flag;\n\tfor (int i = flag + 1; i <= mx; i++)\n\t\tres = (res + (ll)i * f[n - i] % mod) % mod;\n\tif (flag == 0) res = (ll)res * 2 % mod;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\n#define MAX_N 200000\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - inv[MOD % i] * (MOD / i);\n        fac[i] = fac[i-1] * i;\n        finv[i] = finv[i-1] * inv[i];\n    }\n}\n\nmod comb(int a, int b)\n{\n    if(a<b) return 0;\n    return fac[a] * finv[b] * finv[a-b];\n}\ntypedef pair<int, int> Pii;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\nll mod_pow(ll a, ll n, ll mod) { ll ret = 1; ll p = a % mod; while (n) { if (n & 1) ret = ret * p % mod; p = p * p % mod; n >>= 1; } return ret; }\n\ntemplate<int mod, int primitive_root>\nclass NTT {\npublic:\n\tint get_mod() const { return mod; }\n\tvoid _ntt(vector<ll>& a, int sign) {\n\t\tconst int n = sz(a);\n\t\tassert((n ^ (n&-n)) == 0); //n = 2^k\n\n\t\tconst int g = 3; //g is primitive root of mod\n\t\tint h = (int)mod_pow(g, (mod - 1) / n, mod); // h^n = 1\n\t\tif (sign == -1) h = (int)mod_inv(h, mod); //h = h^-1 % mod\n\n\t\t//bit reverse\n\t\tint i = 0;\n\t\tfor (int j = 1; j < n - 1; ++j) {\n\t\t\tfor (int k = n >> 1; k >(i ^= k); k >>= 1);\n\t\t\tif (j < i) swap(a[i], a[j]);\n\t\t}\n\n\t\tfor (int m = 1; m < n; m *= 2) {\n\t\t\tconst int m2 = 2 * m;\n\t\t\tconst ll base = mod_pow(h, n / m2, mod);\n\t\t\tll w = 1;\n\t\t\tFOR(x, m) {\n\t\t\t\tfor (int s = x; s < n; s += m2) {\n\t\t\t\t\tll u = a[s];\n\t\t\t\t\tll d = a[s + m] * w % mod;\n\t\t\t\t\ta[s] = u + d;\n\t\t\t\t\tif (a[s] >= mod) a[s] -= mod;\n\t\t\t\t\ta[s + m] = u - d;\n\t\t\t\t\tif (a[s + m] < 0) a[s + m] += mod;\n\t\t\t\t}\n\t\t\t\tw = w * base % mod;\n\t\t\t}\n\t\t}\n\n\t\tfor (auto& x : a) if (x < 0) x += mod;\n\t}\n\tvoid ntt(vector<ll>& input) {\n\t\t_ntt(input, 1);\n\t}\n\tvoid intt(vector<ll>& input) {\n\t\t_ntt(input, -1);\n\t\tconst int n_inv = mod_inv(sz(input), mod);\n\t\tfor (auto& x : input) x = x * n_inv % mod;\n\t}\n\n\t// 畳み込み演算を行う\n\tvector<ll> convolution(const vector<ll>& a, const vector<ll>& b){\n\t\tint ntt_size = 1;\n\t\twhile (ntt_size < sz(a) + sz(b)) ntt_size *= 2;\n\n\t\tvector<ll> _a = a, _b = b;\n\t\t_a.resize(ntt_size); _b.resize(ntt_size);\n\n\t\tntt(_a);\n\t\tntt(_b);\n\n\t\tFOR(i, ntt_size){\n\t\t\t(_a[i] *= _b[i]) %= mod;\n\t\t}\n\n\t\tintt(_a);\n\t\treturn _a;\n\t}\n};\n\nll garner(vector<Pii> mr, int mod){\n\tmr.emplace_back(mod, 0);\n\n\tvector<ll> coffs(sz(mr), 1);\n\tvector<ll> constants(sz(mr), 0);\n\tFOR(i, sz(mr) - 1){\n\t\t// coffs[i] * v + constants[i] == mr[i].second (mod mr[i].first) を解く\n\t\tll v = (mr[i].second - constants[i]) * mod_inv<ll>(coffs[i], mr[i].first) % mr[i].first;\n\t\tif (v < 0) v += mr[i].first;\n\n\t\tfor (int j = i + 1; j < sz(mr); j++) {\n\t\t\t(constants[j] += coffs[j] * v) %= mr[j].first;\n\t\t\t(coffs[j] *= mr[i].first) %= mr[j].first;\n\t\t}\n\t}\n\n\treturn constants[sz(mr) - 1];\n}\n\ntypedef NTT<167772161, 3> NTT_1;\ntypedef NTT<469762049, 3> NTT_2;\ntypedef NTT<1224736769, 3> NTT_3;\n\n//任意のmodで畳み込み演算 O(n log n)\nvector<ll> int32mod_convolution(vector<ll> a, vector<ll> b,int mod){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\tvector<ll> ret(sz(x));\n\tvector<Pii> mr(3);\n\tFOR(i, sz(x)){\n\t\tmr[0].first = ntt1.get_mod(), mr[0].second = (int)x[i];\n\t\tmr[1].first = ntt2.get_mod(), mr[1].second = (int)y[i];\n\t\tmr[2].first = ntt3.get_mod(), mr[2].second = (int)z[i];\n\t\tret[i] = garner(mr, mod);\n\t}\n\n\treturn ret;\n}\n\n// garnerのアルゴリズムを直書きしたversion，速い\nvector<ll> fast_int32mod_convolution(vector<ll> a, vector<ll> b,int mod,int len){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\t\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tassert(ntt1.get_mod() < ntt2.get_mod() && ntt2.get_mod() < ntt3.get_mod());\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\t// garnerのアルゴリズムを極力高速化した\n\tconst ll m1 = ntt1.get_mod(), m2 = ntt2.get_mod(), m3 = ntt3.get_mod();\n\tconst ll m1_inv_m2 = mod_inv<ll>(m1, m2);\n\tconst ll m12_inv_m3 = mod_inv<ll>(m1 * m2, m3);\n\tconst ll m12_mod = m1 * m2 % mod;\n\tint L = min(len,sz(x));\n    vector<ll> ret(L);\n\tFOR(i, L){\n\t\tll v1 = (y[i] - x[i]) *  m1_inv_m2 % m2;\n\t\tif (v1 < 0) v1 += m2;\n\t\tll v2 = (z[i] - (x[i] + m1 * v1) % m3) * m12_inv_m3 % m3;\n\t\tif (v2 < 0) v2 += m3;\n\t\tll constants3 = (x[i] + m1 * v1 + m12_mod * v2) % mod;\n\t\tif (constants3 < 0) constants3 += mod;\n\t\tret[i] = constants3;\n\t}\n\n\treturn ret;\n}\n\n\nunsigned int add(const unsigned int x, const unsigned int y)\n{\n    return (x + y < MOD) ? x + y : x + y - MOD;\n}\n \nunsigned int sub(const unsigned int x, const unsigned int y)\n{\n    return (x >= y) ? (x - y) : (MOD - y + x);\n}\n \nunsigned int mul(const unsigned int x, const unsigned int y)\n{\n    return (unsigned long long)x * y % MOD;\n}\n \nunsigned int mod_pow(unsigned int x, unsigned int n)\n{\n    unsigned int res = 1;\n    while(n > 0){\n        if(n & 1){ res = mul(res, x); }\n        x = mul(x, x);\n        n >>= 1;\n    }\n    return res;\n}\n \nunsigned int inverse(const unsigned int x)\n{\n    return mod_pow(x, MOD - 2);\n}\n \nvector<ll> polynomial_inverse(const vector<ll>& a, int r)\n{\n    assert(a[0] != 0);\n    vector<ll> h = {(ll)inverse(a[0])};\n    int t = 1;\n    vector<ll> b;\n    int id =  0;\n    for(int i = 0; t < r; ++i){\n    \n        t <<= 1;\n        // vector<ll> tmp = int32mod_convolution(h, h, MOD);\n        while(id<min((int)a.size(),t)){\n            b.push_back(a[id]);\n            id++;\n        }\n        vector<ll> res = fast_int32mod_convolution(b, fast_int32mod_convolution(h, h, MOD,t), MOD,t);\n        res.resize(t);\n        for(int j = 0; j < t; ++j){\n            res[j] = sub(0, res[j]);\n            if(j < t / 2) res[j] = add(res[j], mul(2, h[j]));\n        }\n        swap(h, res);\n    }\n    h.resize(r);\n    return h;\n}\n\nmod dp[200010][2][2];\nint main(){\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if(s[0]=='R'){\n        rep(i,m){\n            if(s[i]=='R'){\n                s[i] ='B';\n            }else{\n                s[i] ='R'; \n            }\n        }\n    }\n    int a = inf;\n    int c = 0;\n    rep(i,m){\n        if(s[i]=='B'){\n            c++;\n        }else{\n            chmin(a,c);    \n        }\n    }\n    if(a==inf){\n        dp[0][0][0] = 1;\n        dp[0][1][1] = 1;\n        for(int i=1;i<n;i++){\n            for(int j=0;j<2;j++){\n                if(j==0){\n                    dp[i][j][0] += dp[i-1][1][0];\n                    dp[i][j][1] += dp[i-1][1][1];\n                }else{\n                    dp[i][j][0] += dp[i-1][1][0] + dp[i-1][0][0];\n                    dp[i][j][1] += dp[i-1][1][1] + dp[i-1][0][1];    \n                }\n            }\n        }\n        cout << dp[n-1][1][0] + dp[n-1][1][1] + dp[n-1][1][0] << endl;\n    }else{\n        int len = (a/2)*2+1;\n        //cerr << len << endl;\n        vector<ll> X(n+1),Y(n+1);\n        len++;\n        for(int i=2;i<=len;i+=2){\n            X[i] = i;\n        }\n        Y[0] = 1;\n        for(int i=2;i<=len;i+=2){\n            Y[i] = MOD-1;\n        }\n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        Y =polynomial_inverse(Y,n+1);\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        X = fast_int32mod_convolution(X,Y,MOD,n+1);\n        \n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        cout << X[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\ntypedef long long LL;\nconst int Mod = 1000000007;\nconst int MN = 200005, MM = 200005;\n\nint N, M, K;\nchar S[MM];\nint A[MN], B[MN], Ans;\n\nint main() {\n\tscanf(\"%d%d%s\", &N, &M, S + 1);\n\tK = 0x3f3f3f3f;\n\tint isfirst = 1, len = 0;\n\tfor (int i = 1; i <= M; ++i) {\n\t\tif (S[i] != S[1]) {\n\t\t\tif (isfirst || len & 1) K = std::min(K, len / 2 + 1);\n\t\t\tisfirst = len = 0;\n\t\t} else ++len;\n\t}\n\tif (isfirst) {\n\t\tint X1 = 1, X2 = 0;\n\t\tfor (int i = 1; i <= N; ++i) {\n\t\t\tX2 -= (X2 = X1 + X2) >= Mod ? Mod : 0;\n\t\t\tX1 += (X1 = X2 - X1) < 0 ? Mod : 0;\n\t\t}\n\t\tprintf(\"%lld\\n\", (2ll * X1 + X2) % Mod);\n\t\treturn 0;\n\t}\n\tif (N & 1) return puts(\"0\"), 0;\n\tN /= 2;\n\tK = std::min(K, N);\n\tA[0] = B[0] = 1;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tA[i] = B[i - 1];\n\t\tif (i > K) A[i] += (A[i] -= B[i - K - 1]) < 0 ? Mod : 0;\n\t\tB[i] -= (B[i] = B[i - 1] + A[i]) >= Mod ? Mod : 0;\n\t}\n\tfor (int i = 1; i <= K; ++i)\n\t\tAns = (Ans + 2ll * i * A[N - i]) % Mod;\n\tprintf(\"%d\\n\", Ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int Mod=1000000007;\nint a[200010];\nchar s[200010];\nint f[200010],g[200010];\nint main()\n{\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(int i=1;i<=m;i++)\n\t\ta[i]=s[i]=='B';\n\tif(a[1]){\n\t\tfor(int i=1;i<=m;i++)\n\t\t\ta[i]^=1;\n\t}\n\tbool flag=true;\n\tfor(int i=1;i<=m;i++)\n\t\tif(a[i])flag=false;\n\tif(flag){\n\t\tf[0]=1;\n\t\tg[0]=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(i>1)f[i]=g[i-2];\n\t\t\tg[i]=(g[i-1]+f[i])%Mod;\n\t\t}\n\t\tint ans=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t\tans=(ans+1ll*f[n-i]*i)%Mod;\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(n&1){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tint lim=n;\n\tint lst=0;\n\tfor(int i=1;i<=m;i++)\n\t\tif(a[i]){\n\t\t\tif(!lst)lim=min(lim,i-lst+1);\n\t\t\telse if((i-lst)%2==0)lim=min(lim,i-lst);\n\t\t\tlst=i;\n\t\t}\n\tlim/=2;\n\tf[0]=1;\n\tg[0]=1;\n\tfor(int i=1;i<=n/2;i++)\n\t{\n\t\tf[i]=g[i-1];\n\t\tif(i-lim>0)f[i]=(f[i]-g[i-lim-1]+Mod)%Mod;\n\t\tg[i]=(g[i-1]+f[i])%Mod;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=lim;i++)\n\t\tans=(ans+1ll*i*2*f[n/2-i])%Mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,INF=0X3F3F3F3F,P=1e9+7;\nint n,m,f[N];\nchar s[N];\nvoid sol1(){\n\tf[1]=1;\n\trep(i,2,n+1)f[i]=(f[i-1]+f[i-2])%P;\n\tprintf(\"%d\\n\",(f[n-1]+f[n+1])%P);\n}\nvoid sol2(int n,int lim){\n\tD(\"n=%d lim=%d\\n\",n,lim);\n\tint cur=0;\n\tfor(int i=1;i<=n;++i){\n\t\tif(i>lim+1)cur=(cur-f[i-lim-1]+P)%P;\n\t\tf[i]=(cur+(i<=lim?i:0))%P;\n\t\tcur=(cur+f[i])%P;\n\t}\n\tprintf(\"%lld\\n\",2LL*f[n]%P);\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,s);\n\tif(s[0]=='B'){\n\t\trep(i,0,m-1)s[i]=(s[i]=='R'?'B':'R');\n\t}\n\tif(count(s,s+m,s[0])==m){\n\t\tsol1();\n\t\treturn 0;\n\t}\n\tif(n&1)puts(\"0\"),exit(0);\n\tbool fir=1;\n\tint mn=INF;\n\tfor(int i=0,j;i<m;i=j){\n\t\tj=i+1;\n\t\twhile(j<m&&s[j]==s[i])++j;\n\t\tif(j>=m)break;\n\t\tif(s[i]=='R'&&(fir||(j-i)%2))mn=min(mn,j-i),fir=0;\n\t}\n\tsol2(n/2,mn/2+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll modminus(ll x, ll y) {\n    return (x - y + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll modpower(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y == 1) {\n        return x % mod;\n    } else if (y % 2 == 0) {\n        ll p = modpower(x, y / 2);\n        return p * p % mod;\n    } else {\n        ll p = modpower (x, y / 2);\n        return (p * p) % mod * (x % mod) % mod;\n    }\n}\n\nll divide(ll x, ll y) {\n    return multiply(x, modpower(y, mod - 2));\n}\n\nll frac[1000000];\nll invfrac[1000000];\n\nvoid fracinvfrac(ll n) {\n    frac[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        frac[i] = multiply(frac[i - 1], i);\n    }\n    invfrac[n] = divide(1, frac[n]);\n    for (int i = n - 1; i >= 0; i--) {\n        invfrac[i] = multiply(invfrac[i + 1], i + 1);\n    }\n}\n\nll modcombi(ll x, ll y) {\n    if (x < y || y < 0) {\n        return 0;\n    } else if (y == 0) {\n        return 1;\n    } else {\n        return multiply(multiply(frac[x], invfrac[x - y]), invfrac[y]);\n    }\n}\n\nll N, M;\nll dp[200010][2];\n\nll solve(ll num) {\n    dp[0][0] = 1;\n    REP(i, 0, num) {\n        dp[i + 1][0] = modadd(dp[i + 1][0], dp[i][0]);\n        dp[i + 1][0] = modadd(dp[i + 1][0], dp[i][1]);\n        dp[i + 1][1] = modadd(dp[i + 1][1], dp[i][0]);\n    }\n    return (dp[num - 1][0] + dp[num - 1][1] + dp[num - 2][0]) % mod;\n}\n\nll dpb[200010][2];\n\nll solveb(ll num, ll len) {\n    ll p = num / 2;\n    ll q = len / 2;\n    dpb[0][0] = 1;\n    ll sum = 1;\n    REP(i, 0, p) {\n        dpb[i + 1][0] = modadd(dpb[i + 1][0], sum);\n        // dpb[i + 1][0] = modadd(dpb[i + 1][0], dpb[i][1]);\n        dpb[i + 1][1] = modadd(dpb[i + 1][1], dpb[i][0]);\n        sum = modadd(sum, dpb[i + 1][1]);\n        if (i >= q - 1) {\n            sum = modminus(sum, dpb[i - q + 1][1]);\n        }\n        // if (i == 0) {\n        //     sum--;\n        // }\n    }\n    // dpb[0][0] = 1;\n    // dpb[0][1] = 1;\n    // REP(i, 0, num) {\n    //     dpb[i + 1][0] = modadd(dpb[i + 1][0], dpb[i][0]);\n    //     dpb[i + 1][0] = modadd(dpb[i + 1][0], dpb[i][1]);\n    //     dpb[i + 1][1] = modadd(dpb[i + 1][1], dpb[i][0]);\n    // }\n    // dp[0][0] = 1;\n    // REP(i, 0, num) {\n    //     dp[i + 1][0] = modadd(dp[i + 1][0], dp[i][0]);\n    //     dp[i + 1][0] = modadd(dp[i + 1][0], dp[i][1]);\n    //     dp[i + 1][1] = modadd(dp[i + 1][1], dp[i][0]);\n    // }\n    return multiply(modadd(dpb[p][0], dpb[p][1]), 2);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    if (N & 1) {\n        bool ok = true;\n        char c = S[0];\n        REP(i, 0, M) {\n            if (S[i] != c) {\n                ok = false;\n            }\n        }\n        if (ok) {\n            cout << solve(N) << endl;\n        } else {\n            cout << 0 << endl;\n        }\n        return 0;\n    } else {\n        ll len = 0;\n        char c = S[0];\n        ll num = 0;\n        while (num < M && S[num] == c) {\n            num++;\n        }\n        len = num;\n        if (len == M) {\n            cout << solve(N) << endl;\n            return 0;\n        }\n        if (!(len & 1)) {\n            len++;\n        }\n        ll tmp = 0;\n        num++;\n        while (num < M) {\n            if (num == c) {\n                tmp++;\n            } else {\n                if (tmp & 1) {\n                    len = min(len, tmp);\n                }\n                tmp = 0;\n            }\n            num++;\n        }\n        cout << len << endl;\n        cout << solveb(N, len) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nconst int mo=1000000007;\nconst int N=200005;\nint n,m;\nchar s[N];\nint f[N][2][2];\nvoid solve1(){\n\tf[1][0][0]=f[1][1][1]=1;\n\tFor(i,2,n) For(j,0,1) For(k,0,1) For(l,0,1)\n\t\tif (k|l) f[i][j][l]=(f[i][j][l]+f[i-1][j][k])%mo;\n\tint ans=0;\n\tFor(i,0,1) For(j,0,1)\n\t\tif (i|j) ans=(ans+f[n][i][j])%mo;\n\tprintf(\"%d\\n\",ans);\n}\nint pre[N];\nint g[N],h[N];\nvoid solve2(){\n\tpre[1]=1;\n\tint mnv=(1<<30);\n\tFor(i,2,m)\n\t\tpre[i]=(s[i]==s[i-1]?pre[i-1]:0)+1;\n\tFor(i,2,m+1) if (s[i-1]=='R'&&s[i]!='R')\n\t\tif (pre[i-1]%2==0) mnv=min(mnv,pre[i-1]+1);\n\t\telse mnv=min(mnv,pre[i]);\n\tg[0]=h[0]=1;\n\tFor(i,1,n){\n\t\tg[i]=((i>=2?h[i-2]:0)+mo-(i>=mnv+3?h[i-mnv-3]:0))%mo;\n\t\th[i]=(g[i]+(i>=2?h[i-2]:0))%mo;\n\t}\n\tint ans=0;\n\tfor (int i=2;i<=min(mnv+1,n);i++)\n\t\tans=(ans+1ll*i*g[n-i])%mo;\n\tprintf(\"%d\\n\",ans);\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tif (s[1]=='B'){\n\t\tFor(i,1,m)\n\t\t\tif (s[i]=='R') s[i]='B';\n\t\t\telse s[i]='R';\n\t}\n\tbool flag=0;\n\tFor(i,1,m) if (s[i]!=s[1]) flag=1;\n\tif (!flag) return solve1(),0;\n\tsolve2();\n}\n/*\n偶数个R||B回到该端点 \n奇数个R||B到达另一端点\n\nRBRBRBRBRB\n\n一段长度为奇数的开头字母 \n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 233333,mo=1e9+7;\nint n,m,f[N],qz[N];char s[N];\nvoid init(int n, int lim){//<=lim\n\tumin(lim,n);//f[i]=sigma f[i-1..i-lim]\n\tf[0]=1;qz[0]=1;\n\trep(i,1,n){\n\t\tf[i]=(qz[i-1]-(i-lim-1>=0?qz[i-lim-1]:0)+mo)%mo;\n\t\tqz[i]=(qz[i-1]+f[i])%mo;\n\t}\n}\nint main() {\n\tread(n);read(m);scanf(\"%s\",s+1);\n\tint cnt=0;rep(i,1,m)cnt+=s[i]=='R';\n\tif(cnt==0||cnt==m){\n\t\tstatic int f[N];\n\t\tf[0]=1;f[1]=2;rep(i,2,n)f[i]=(f[i-1]+f[i-2])%mo;\n\t\tprintf(\"%d\\n\",(f[n-1]+(n-3>=0?f[n-3]:1))%mo);\n\t\treturn 0;\n\t}\n\tif(n&1){puts(\"0\");return 0;}\n\tint lim=1e9;int j;for(j=1;j<=m;j++)if(s[j]!=s[1])break;j--;\n\tif(j%2==0)lim=j+1;\n\trep(i,1,m)if(s[i]==s[1]){\n\t\tint j;for(j=i;j<=m;j++)if(s[j]!=s[i])break;\n\t\t//[i,j-1]\n\t\tif((j-i)%2)umin(lim,j-i);\n\t\ti=j-1;\n\t}\n\tlim++;init(n/2,lim/2);int res=0;//%2==0\n\tfor(int i=2;i<=min(lim,n);i+=2)res=(res+1LL*i*f[(n-i)/2])%mo;\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/01/29] 12:36:49\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nvoid outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\n\n\ntemplate<typename T> T gcd(const T& a, const T& b) { return a < 0 ? gcd(-a, b) : b < 0 ? gcd(a, -b) : (a > b ? gcd(b, a) : a == 0 ? b : gcd(b % a, a)); }\ntemplate<typename T> T lcm(const T& a, const T& b) { return a / gcd(a, b) * b; }\ntemplate<typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto g = gcd(a, b), da = std::abs(b) / g;\n    const auto p = extgcd(b, a % b);\n    const auto x = (da + p.second % da) % da, y = (g - a * x) / b;\n    return {x, y};\n}\ntemplate<typename T>\nconstexpr T inverse(const T a, const T mod) { return extgcd(a, mod).first; }\ntemplate<uint mod_value, bool dynamic = false>\nclass modint_base\n{\npublic:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, const UInt> mod() { return mod_ref(); }\n    template<typename UInt = uint>\n    static constexpr std::enable_if_t<not dynamic, const UInt> mod() { return mod_value; }\n    template<typename UInt = uint>\n    static void set_mod(const std::enable_if_t<dynamic, const UInt> mod) { mod_ref() = mod, inv_ref() = {1, 1}; }\n    modint_base() : v{0} {}\n    modint_base(const ll val) : v{norm(static_cast<uint>(val % static_cast<ll>(mod()) + static_cast<ll>(mod())))} {}\n    modint_base(const modint_base& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    modint_base& operator=(const modint_base& m) { return v = m(), (*this); }\n    modint_base& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod()) + static_cast<ll>(mod()))), (*this); }\n    friend modint_base operator+(const modint_base& m) { return m; }\n    friend modint_base operator-(const modint_base& m) { return make(norm(mod() - m.v)); }\n    friend modint_base operator+(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + m2.v)); }\n    friend modint_base operator-(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + mod() - m2.v)); }\n    friend modint_base operator*(const modint_base& m1, const modint_base& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod()))); }\n    friend modint_base operator/(const modint_base& m1, const modint_base& m2) { return m1 * inv(m2.v); }\n    friend modint_base operator+(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) - val}; }\n    friend modint_base operator*(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * inv(val)}; }\n    friend modint_base operator+(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const ll val, const modint_base& m) { return modint_base{-static_cast<ll>(m.v) + val}; }\n    friend modint_base operator*(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const ll val, const modint_base& m) { return modint_base{val * inv(static_cast<ll>(m.v))}; }\n    friend modint_base& operator+=(modint_base& m1, const modint_base& m2) { return m1 = m1 + m2; }\n    friend modint_base& operator-=(modint_base& m1, const modint_base& m2) { return m1 = m1 - m2; }\n    friend modint_base& operator*=(modint_base& m1, const modint_base& m2) { return m1 = m1 * m2; }\n    friend modint_base& operator/=(modint_base& m1, const modint_base& m2) { return m1 = m1 / m2; }\n    friend modint_base& operator+=(modint_base& m, const ll val) { return m = m + val; }\n    friend modint_base& operator-=(modint_base& m, const ll val) { return m = m - val; }\n    friend modint_base& operator*=(modint_base& m, const ll val) { return m = m * val; }\n    friend modint_base& operator/=(modint_base& m, const ll val) { return m = m / val; }\n    friend modint_base operator^(const modint_base& m, const ll n) { return power(m.v, n); }\n    friend modint_base& operator^=(modint_base& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const modint_base& m1, const modint_base& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const modint_base& m1, const modint_base& m2) { return not(m1 == m2); }\n    friend bool operator==(const modint_base& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const modint_base& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const modint_base& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const ll val, const modint_base& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, modint_base& m)\n    {\n        ll v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const modint_base& m) { return os << m(); }\n    uint operator()() const { return v; }\n    static modint_base small_inv(const usize n)\n    {\n        auto& in = inv_ref();\n        if (n < in.size()) { return in[n]; }\n        for (usize i = in.size(); i <= n; i++) { in.push_back(-in[modint_base::mod() % i] * (modint_base::mod() / i)); }\n        return in.back();\n    }\n    std::pair<ll, ll> quad() const\n    {\n        const auto ans = quad_r(v, mod());\n        ll x = std::get<0>(ans), y = std::get<1>(ans);\n        if (y < 0) { x = -x, y = -y; }\n        return {x, y};\n    }\n\nprivate:\n    static std::tuple<ll, ll, ll> quad_r(const ll r, const ll p)  // r = x/y (mod p), (x,y,z) s.t. x=yr+pz\n    {\n        if (std::abs(r) <= 1000) { return {r, 1, 0}; }\n        ll nr = p % r, q = p / r;\n        if (nr * 2LL >= r) { nr -= r, q++; }\n        if (nr * 2LL <= -r) { nr += r, q--; }\n        const auto sub = quad_r(nr, r);\n        const ll x = std::get<0>(sub), z = std::get<1>(sub), y = std::get<2>(sub);\n        return {x, y - q * z, z};\n    }\n\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, UInt&> mod_ref()\n    {\n        static UInt mod = 0;\n        return mod;\n    }\n    static uint norm(const uint x) { return x < mod() ? x : x - mod(); }\n    static modint_base make(const uint x)\n    {\n        modint_base m;\n        return m.v = x, m;\n    }\n    static modint_base power(modint_base x, ull n)\n    {\n        modint_base ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static modint_base inv(const ll v) { return v <= 2000000 ? small_inv(static_cast<usize>(v)) : modint_base{inverse(v, static_cast<ll>(mod()))}; }\n    static std::vector<modint_base>& inv_ref()\n    {\n        static std::vector<modint_base> in{1, 1};\n        return in;\n    }\n    uint v;\n};\ntemplate<uint mod>\nusing modint = modint_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modint = modint_base<id, true>;\n\n\ntemplate<typename Real>\nstruct complex\n{\n    using value_type = Real;\n    complex() : real{Real{0}}, imag{Real{0}} {}\n    complex(const complex&) = default;\n    complex(const Real& theta) : real(std::cos(theta)), imag(std::sin(theta)) {}\n    complex(const Real& r, const Real& i) : real{r}, imag{i} {}\n    ~complex() = default;\n    friend complex operator+(const complex& c) { return c; }\n    friend complex operator-(const complex& c) { return complex{-c.real, -c.imag}; }\n    friend complex operator+(const complex& c1, const complex& c2) { return complex{c1.real + c2.real, c1.imag + c2.imag}; }\n    friend complex operator-(const complex& c1, const complex& c2) { return complex{c1.real - c2.real, c1.imag - c2.imag}; }\n    friend complex operator*(const complex& c1, const complex& c2) { return complex{c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real}; }\n    friend complex operator*(const complex& c, const Real& r) { return complex{c.real * r, c.imag * r}; }\n    friend complex operator/(complex& c1, complex& c2) { c1* c2.conj() / c2.norm(); }\n    friend bool operator==(const complex& c1, const complex& c2) { return c1.real == c2.real and c1.imag == c2.imag; }\n    friend bool operator!=(const complex& c1, const complex& c2) { return not(c1 == c2); }\n    friend complex& operator+=(complex& c1, const complex& c2) { return c1.real += c2.real, c1.imag += c2.imag, c1; }\n    friend complex& operator-=(complex& c1, const complex& c2) { return c1.real += c2.real, c1.imag += c2.imag, c1; }\n    friend complex& operator*=(complex& c1, const complex& c2) { return c1 = c1 * c2; }\n    friend complex& operator*=(complex& c, const Real& r) { return c = c * r; }\n    friend complex& operator/=(complex& c1, const complex& c2) { return c1 = c1 / c2; }\n    complex conj() const { return complex{real, -imag}; }\n    Real norm() const { return real * real + imag * imag; }\n    Real abs() const { return std::sqrt(norm()); }\n    Real arg() const { return std::atan2(imag, real); }\n    friend std::ostream& operator<<(std::ostream& os, const complex& c) { return os << c.real << \"+\" << c.imag << \"i\"; }\n    Real real, imag;\n};\ntemplate<typename Real = double>\nclass fft\n{\nprivate:\n    static constexpr usize depth = 30;\n    static constexpr Real pi     = pi_v<Real>;\n    static void transform(std::vector<complex<Real>>& a, const usize lg, const bool rev)\n    {\n        static std::vector<complex<Real>> root[depth];\n        const usize sz = a.size();\n        assert((1UL << lg) == sz);\n        if (root[lg].empty()) {\n            root[lg].reserve(sz), root[lg].resize(sz);\n            for (usize i = 0; i < sz; i++) { root[lg][i] = complex<Real>(pi * Real(2 * i) / Real(sz)); }\n        }\n        std::vector<complex<Real>> tmp(sz);\n        for (usize w = (sz >> 1); w > 0; w >>= 1) {\n            for (usize y = 0; y < (sz >> 1); y += w) {\n                const complex<Real> r = rev ? root[lg][y].conj() : root[lg][y];\n                for (usize x = 0; x < w; x++) {\n                    const auto u = a[y << 1 | x], v = a[y << 1 | x | w] * r;\n                    tmp[y | x] = u + v, tmp[y | x | (sz >> 1)] = u - v;\n                }\n            }\n            std::swap(tmp, a);\n        }\n    }\n\npublic:\n    using value_type = Real;\n    fft()            = delete;\n    template<typename T = ll, typename I = int>\n    static std::vector<T> simple_convolute(const std::vector<I>& a, const std::vector<I>& b)\n    {\n        const usize need = a.size() + b.size() - 1, lg = clog(need), sz = 1UL << lg;\n        std::vector<complex<Real>> x(sz), y(sz);\n        for (usize i = 0; i < a.size(); i++) { x[i] = {(Real)a[i], (Real)0}; }\n        for (usize i = 0; i < b.size(); i++) { y[i] = {(Real)b[i], (Real)0}; }\n        transform(x, lg, false), transform(y, lg, false);\n        for (usize i = 0; i < sz; i++) { x[i] *= y[i]; }\n        transform(x, lg, true);\n        std::vector<T> ans(need);\n        for (usize i = 0; i < need; i++) { ans[i] = (T)std::round(x[i].real / (Real)sz); }\n        return ans;\n    }\n    template<typename T = ll, usize division = 2, typename I = int>\n    static std::vector<T> convolute(const std::vector<I>& a, const std::vector<I>& b)\n    {\n        constexpr usize bitnum = (depth + division - 1) / division;\n        const usize need = a.size() + b.size() - 1, lg = clog(need), sz = 1UL << lg;\n        std::vector<complex<value_type>> x[division], y[division], tmp(sz);\n        for (usize i = 0; i < division; i++) {\n            x[i].reserve(sz), x[i].resize(sz), y[i].reserve(sz), y[i].resize(sz);\n            std::fill(tmp.begin() + std::min(a.size(), b.size()), tmp.end(), complex<value_type>{});\n            for (usize j = 0; j < a.size(); j++) { tmp[j].real = value_type((a[j] >> (bitnum * i)) & ((1 << bitnum) - 1)); }\n            for (usize j = 0; j < b.size(); j++) { tmp[j].imag = value_type((b[j] >> (bitnum * i)) & ((1 << bitnum) - 1)); }\n            transform(tmp, lg, false);\n            for (usize j = 0; j < sz; j++) { tmp[j] *= value_type(0.5); }\n            for (usize j = 0; j < sz; j++) {\n                const usize k = j == 0 ? 0UL : sz - j;\n                x[i][j] = complex<value_type>{tmp[j].real + tmp[k].real, tmp[j].imag - tmp[k].imag}, y[i][j] = complex<value_type>{tmp[j].imag + tmp[k].imag, -tmp[j].real + tmp[k].real};\n            }\n        }\n        std::vector<complex<value_type>> z[division];\n        for (usize i = 0; i < division; i++) { z[i].reserve(sz), z[i].resize(sz); }\n        for (usize a = 0; a < division; a++) {\n            for (usize b = 0; b < division; b++) {\n                for (usize i = 0; i < sz; i++) {\n                    if (a + b < division) {\n                        z[a + b][i] += x[a][i] * y[b][i];\n                    } else {\n                        z[a + b - division][i] += x[a][i] * y[b][i] * complex<value_type>(0, 1);\n                    }\n                }\n            }\n        }\n        for (usize i = 0; i < division; i++) { transform(z[i], lg, true); }\n        std::vector<T> ans(need);\n        T base = 1;\n        for (usize k = 0; k < 2 * division - 1; k++, base *= (1LL << bitnum)) {\n            for (usize i = 0; i < need; i++) {\n                if (k < division) {\n                    ans[i] += base * T(std::round(z[k][i].real / value_type(sz)));\n                } else {\n                    ans[i] += base * T(std::round(z[k - division][i].imag / value_type(sz)));\n                }\n            }\n        }\n        return ans;\n    }\n    template<uint mod, bool dynamic = false, usize division = 2>\n    static std::vector<modint_base<mod, dynamic>> convolute(const std::vector<modint_base<mod, dynamic>>& a, const std::vector<modint_base<mod, dynamic>>& b)\n    {\n        using mint             = modint_base<mod, dynamic>;\n        constexpr usize bitnum = (depth + division - 1) / division;\n        const usize need = a.size() + b.size() - 1, lg = clog(need), sz = 1UL << lg;\n        std::vector<complex<value_type>> x[division], y[division], tmp(sz);\n        for (usize i = 0; i < division; i++) {\n            x[i].reserve(sz), x[i].resize(sz), y[i].reserve(sz), y[i].resize(sz);\n            std::fill(tmp.begin() + std::min(a.size(), b.size()), tmp.end(), complex<value_type>{});\n            for (usize j = 0; j < a.size(); j++) { tmp[j].real = value_type((a[j]() >> (bitnum * i)) & ((1 << bitnum) - 1)); }\n            for (usize j = 0; j < b.size(); j++) { tmp[j].imag = value_type((b[j]() >> (bitnum * i)) & ((1 << bitnum) - 1)); }\n            transform(tmp, lg, false);\n            for (usize j = 0; j < sz; j++) { tmp[j] *= value_type(0.5); }\n            for (usize j = 0; j < sz; j++) {\n                const usize k = j == 0 ? 0UL : sz - j;\n                x[i][j] = complex<value_type>{tmp[j].real + tmp[k].real, tmp[j].imag - tmp[k].imag}, y[i][j] = complex<value_type>{tmp[j].imag + tmp[k].imag, -tmp[j].real + tmp[k].real};\n            }\n        }\n        std::vector<complex<value_type>> z[division];\n        for (usize i = 0; i < division; i++) { z[i].reserve(sz), z[i].resize(sz); }\n        for (usize a = 0; a < division; a++) {\n            for (usize b = 0; b < division; b++) {\n                for (usize i = 0; i < sz; i++) {\n                    if (a + b < division) {\n                        z[a + b][i] += x[a][i] * y[b][i];\n                    } else {\n                        z[a + b - division][i] += x[a][i] * y[b][i] * complex<value_type>(0, 1);\n                    }\n                }\n            }\n        }\n        for (usize i = 0; i < division; i++) { transform(z[i], lg, true); }\n        std::vector<mint> ans(need);\n        mint base = 1;\n        for (usize k = 0; k < 2 * division - 1; k++, base *= (1LL << bitnum)) {\n            for (usize i = 0; i < need; i++) {\n                if (k < division) {\n                    ans[i] += int((base * ll(std::round(z[k][i].real / value_type(sz))))());\n                } else {\n                    ans[i] += int((base * ll(std::round(z[k - division][i].imag / value_type(sz))))());\n                }\n            }\n        }\n        return ans;\n    }\n};\n\ntemplate<uint mod = 924844033, uint root = 5>\nclass ntt\n{\nprivate:\n    using value_type             = modint<mod>;\n    static constexpr usize depth = 30;\n    static void transform(std::vector<value_type>& a, const usize lg, const bool rev)\n    {\n        const usize N = a.size();\n        assert(1UL << lg == N);\n        static std::vector<value_type> R[depth];\n        if (R[lg].empty()) {\n            R[lg].reserve(N), R[lg].resize(N, value_type(1));\n            const value_type r = value_type(root) ^ ((mod - 1) / N);\n            for (usize i = 1; i < N; i++) { R[lg][i] = R[lg][i - 1] * r; }\n        }\n        std::vector<value_type> tmp(N);\n        for (usize w = (N >> 1); w > 0; w >>= 1) {\n            for (usize y = 0; y < (N >> 1); y += w) {\n                const value_type r = rev ? R[lg][y == 0 ? 0 : N - y] : R[lg][y];\n                for (usize x = 0; x < w; x++) {\n                    const auto u = a[y << 1 | x], v = a[y << 1 | x | w]() * r;\n                    tmp[y | x] = u + v, tmp[y | x | (N >> 1)] = u - v;\n                }\n            }\n            std::swap(tmp, a);\n        }\n        if (rev) {\n            for (usize i = 0; i < N; i++) { a[i] /= value_type(N); }\n        }\n    }\n\npublic:\n    ntt() = delete;\n    static std::vector<value_type> convolute(const std::vector<value_type>& a, const std::vector<value_type>& b)\n    {\n        const usize need = a.size() + b.size() - 1, lg = clog(need), sz = 1UL << lg;\n        std::vector<value_type> A(sz, 0), B(sz, 0);\n        for (usize i = 0; i < a.size(); i++) { A[i] = a[i](); }\n        for (usize i = 0; i < b.size(); i++) { B[i] = b[i](); }\n        transform(A, lg, false), transform(B, lg, false);\n        for (usize i = 0; i < sz; i++) { A[i] *= B[i]; }\n        transform(A, lg, true);\n        std::vector<value_type> ans(need);\n        for (usize i = 0; i < need; i++) { ans[i] = int(A[i]()); }\n        return ans;\n    }\n};\ntemplate<uint mod, uint root, bool dynamic, uint fft_division>\nclass poly_base\n{\npublic:\n    using value_type = modint_base<mod, dynamic>;\n    poly_base() : v(0) {}\n    poly_base(const value_type& r) : v{r} { shrink(); }\n    poly_base(const std::vector<value_type>& v) : v{v} { shrink(); }\n    poly_base(const std::initializer_list<value_type>&& list) : v{list} { shrink(); }\n    std::vector<value_type> operator()() const { return v; }\n    value_type& operator[](const usize i) { return v[i]; }\n    const value_type& operator[](const usize i) const { return v[i]; }\n    value_type at(const usize i) const { return i < size() ? v[i] : value_type(0); }\n    friend poly_base operator+(const poly_base& p) { return p; }\n    friend poly_base operator-(const poly_base& p)\n    {\n        std::vector<value_type> ans = p.v;\n        for (auto& e : ans) { e = -e; }\n        return poly_base(ans);\n    }\n    friend poly_base operator+(const poly_base& p, const poly_base& q)\n    {\n        const usize sz = std::max(p.size(), q.size());\n        std::vector<value_type> ans(sz);\n        for (usize i = 0; i < sz; i++) { ans[i] = p.at(i) + q.at(i); }\n        return poly_base(ans);\n    }\n    friend poly_base operator-(const poly_base& p, const poly_base& q)\n    {\n        const usize sz = std::max(p.size(), q.size());\n        std::vector<value_type> ans(sz);\n        for (usize i = 0; i < sz; i++) { ans[i] = p.at(i) - q.at(i); }\n        return poly_base(ans);\n    }\n    friend poly_base operator*(const poly_base& p, const poly_base& q) { return p.size() <= 300 or q.size() <= 300 ? naive_multiply(p, q) : fft_multiply(p, q); }\n    friend poly_base operator*(const poly_base& p, const value_type& r)\n    {\n        std::vector<value_type> ans = p.v;\n        for (auto& e : ans) { e *= r; }\n        return poly_base(ans);\n    }\n    friend poly_base operator/(const poly_base& p, const value_type& r)\n    {\n        std::vector<value_type> ans = p.v;\n        for (auto& e : ans) { e /= r; }\n        return poly_base(ans);\n    }\n    friend poly_base operator>>(const poly_base& p, const usize s) { return p.divide_by_power(s); }\n    friend poly_base operator<<(const poly_base& p, const usize s) { return p.multiply_power(s); }\n    friend poly_base operator/(const poly_base& p, const poly_base& q) { return p.div(q); }\n    friend poly_base operator%(const poly_base& p, const poly_base& q) { return p.rem(q); }\n    friend poly_base& operator+=(poly_base& p, const poly_base& q) { return p = p + q; }\n    friend poly_base& operator-=(poly_base& p, const poly_base& q) { return p = p - q; }\n    friend poly_base& operator*=(poly_base& p, const poly_base& q) { return p = p * q; }\n    friend poly_base& operator*=(poly_base& p, const value_type& r) { return p = p * r; }\n    friend poly_base& operator/=(poly_base& p, const value_type& r) { return p = p / r; }\n    friend poly_base& operator>>=(poly_base& p, const usize s) { return p = (p >> s); }\n    friend poly_base& operator<<=(poly_base& p, const usize s) { return p = (p << s); }\n    friend poly_base& operator/=(poly_base& p, const poly_base& q) { return p = p / q; }\n    friend poly_base& operator%=(poly_base& p, const poly_base& q) { return p = p % q; }\n    poly_base multiply_power(const usize s) const\n    {\n        const usize sz = size();\n        if (sz == 0) { return poly_base(); }\n        std::vector<value_type> ans(sz + s, 0);\n        for (usize i = 0; i < sz; i++) { ans[i + s] = v[i]; }\n        return poly_base(ans);\n    }\n    poly_base divide_by_power(const usize s) const\n    {\n        const usize N = size();\n        if (N <= s) { return poly_base(); }\n        std::vector<value_type> ans(N - s);\n        for (usize i = 0; i < N - s; i++) { ans[i] = v[i + s]; }\n        return poly_base(ans);\n    }\n    poly_base rem_by_power(const usize k) const { return size() <= k ? *this : poly_base(std::vector<value_type>(v.begin(), v.begin() + k)); }\n    poly_base inverse(const usize k) const\n    {\n        poly_base q{value_type(1) / v[0]};\n        const auto T = poly_base{2};\n        for (usize i = 1, j = 0; j < k; j++, i *= 2) { q = (q * (T - rem_by_power(2 * i) * q)).rem_by_power(2 * i); }\n        return q;\n    }\n    template<typename Int>\n    poly_base power_and_rem(const Int k, const usize s)\n    {\n        if (k == 0) { return poly_base(1); }\n        if (k % 2 == 1) {\n            return (power_and_rem(k - 1, s) * (*this)).rem_by_power(s);\n        } else {\n            const auto q = power_and_rem(k / 2, s);\n            return (q * q).rem_by_power(s);\n        }\n    }\n    template<typename Int>\n    static poly_base rem_of_power(const Int k, const poly_base& p)\n    {\n        const usize B = p.size() * 2 - 1;\n        const auto q  = p.pseudo_inv(B);\n        poly_base ans{1};\n        const usize D = log2p1<usize>(k);\n        for (usize i = 0; i < D; i++) {\n            if (k & (static_cast<Int>(1) << (D - i - 1))) { ans = (ans.multiply_power(1)).rem(p, q, B); }\n            if (D - i - 1) { ans = (ans * ans).rem(p, q, B); }\n        }\n        return ans;\n    }\n    usize size() const { return v.size(); }\n    friend std::ostream& operator<<(std::ostream& os, const poly_base& p)\n    {\n        if (p.size() == 0) { return os << \"0\"; }\n        for (usize i = 0; i < p.size(); i++) { os << (i != 0 ? \"+\" : \"\") << p[i] << (i != 0 ? i == 1 ? \"X\" : \"X^\" + std::to_string(i) : \"\"); }\n        return os;\n    }\n\nprivate:\n    static std::vector<value_type> naive_convolute(const std::vector<value_type>& a, const std::vector<value_type>& b)\n    {\n        std::vector<value_type> ans(a.size() + b.size() - 1, 0);\n        for (usize i = 0; i < a.size(); i++) {\n            for (usize j = 0; j < b.size(); j++) { ans[i + j] += a[i] * b[j]; }\n        }\n        return ans;\n    }\n    static poly_base naive_multiply(const poly_base& p, const poly_base& q) { return p.size() == 0 or q.size() == 0 ? poly_base{} : poly_base{naive_convolute(p(), q())}; }\n    template<typename Poly = poly_base>\n    static std::enable_if_t<root == 0, Poly> fft_multiply(const poly_base& p, const poly_base& q) { return p.size() == 0 or q.size() == 0 ? poly_base() : poly_base{fft<double>::convolute<mod, dynamic, fft_division>(p(), q())}; }\n    template<typename Poly = poly_base>\n    static std::enable_if_t<root != 0, Poly> fft_multiply(const poly_base& p, const poly_base& q) { return p.size() == 0 or q.size() == 0 ? poly_base() : poly_base{ntt<mod, root>::convolute(p(), q())}; }\n    poly_base rev(const usize l) const\n    {\n        std::vector<value_type> ans = v;\n        ans.resize(l), std::reverse(ans.begin(), ans.end());\n        return poly_base(ans);\n    }\n    poly_base div(const poly_base& q) const\n    {\n        assert(q.size() > 0);\n        if (size() < q.size()) { return poly_base(); }\n        const usize N = size();\n        const auto iq = q.pseudoInv(N);\n        return (*this * iq).divide_by_power(N - 1);\n    }\n    poly_base rem(const poly_base& q) const { return *this - div(q) * q; }\n    poly_base rem(const poly_base& q, const poly_base& iq, const usize B) { return *this - q * ((*this * iq).divide_by_power(B - 1)); }\n    void shrink()\n    {\n        for (; not v.empty() and v.back() == 0; v.pop_back()) {}\n    }\n    poly_base pseudo_inv(const usize B) const\n    {\n        const usize N = size();\n        return rev(N).inverse(B + 2 > N ? clog(B - N + 2) : 0).rev(B + 1 - N);\n    }\n    std::vector<value_type> v;\n};\ntemplate<uint mod, uint fft_division = 2>\nusing poly = poly_base<mod, 0, false, fft_division>;\ntemplate<uint mod, uint fft_division = 2>\nusing dynamic_poly = poly_base<mod, 0, true, fft_division>;\ntemplate<uint mod = 924844033, uint root = 5>\nusing ntt_poly = poly_base<mod, root, false, 0>;\nint main()\n{\n    using mint   = modint<mod>;\n    using P      = poly<mod>;\n    const auto N = in<int>(), M = in<int>();\n    auto S = in<std::string>();\n    if (S[0] == 'B') {\n        for (auto& c : S) { c = (c == 'R' ? 'B' : 'R'); }\n    }\n    if (S == std::string(M, 'R')) {\n        mint ans = 0;\n        mint r = 1, b = 0;\n        for (int i = 0; i < N - 2; i++) {\n            mint r_ = r, b_ = b;\n            r = r_ + b_, b = r_;\n        }\n        ans += r;\n        r = 1, b = 1;\n        for (int i = 0; i < N - 2; i++) {\n            mint r_ = r, b_ = b;\n            r = r_ + b_, b = r_;\n        }\n        ans += r + b;\n        return outln(ans);\n    }\n    if (N % 2 == 1) { return outln(0); }\n    S.push_back('$');\n    std::vector<int> ls;\n    char p = 'R';\n    int l  = 0;\n    for (int i = 0; i <= M; i++) {\n        if (S[i] != p) {\n            p = S[i];\n            ls.push_back(l);\n            l = 1;\n        } else {\n            l++;\n        }\n    }\n    SHOW(ls);\n    int m = inf_v<int>;\n    for (int i = 0; i < ls.size(); i += 2) {\n        if (i == 0) {\n            chmin(m, ls[i] / 2 + 1);\n        } else if (ls[i] % 2 == 1) {\n            chmin(m, (ls[i] + 1) / 2);\n        }\n    }\n    SHOW(m);\n    const int n = N / 2;\n    // x1+x2+...+xk = n\n    // xi <= max\n    std::vector<mint> c(m + 1, 1);\n    for (int i = 1; i <= m; i++) { c[i] = -1; }\n    P f{c};\n    const auto g = f.inverse(clog(n + 1));\n    mint ans     = 0;\n    for (int r1 = 1; r1 <= std::min(n, m); r1++) { ans += g.at(n - r1) * 2 * r1; }\n    outln(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    string s;\n    cin>>s;\n    if(s[0]=='B'){\n        for(int i=0;i<m;i++){\n            if(s[i]=='B'){s[i]='R';}\n            else{s[i]='B';}\n        }\n    }\n    ll l=0;\n    while(l<m && s[l]=='R'){l++;}\n    if(l==m){\n        ll ans=1;\n        vector<ll> dp(n,0);\n        vector<ll> sum(n,0);\n        dp[0]=sum[0]=1;\n        sum[1]=1;\n        for(int i=2;i<n;i++){\n            dp[i]=sum[i-1];\n            sum[i]=sum[i-1]+dp[i];\n            sum[i]%=MOD;\n        }\n        ans+=sum[n-2];\n        ans%=MOD;\n        if(ans<0){ans+=MOD;}\n        cout<<ans<<endl;\n    }\n    if(n&1){cout<<0<<endl; return 0;}\n    ll mi=E;\n    if(l&1){mi=l;}\n    else{mi=l+1;}\n    for(ll i=l;i<m;i++){\n        if(s[i]=='R'){\n            ll w=i;\n            while(i<m && s[i]=='R'){i++;}\n            if(i!=m){\n                ll L=i-w;\n                if(L&1){mi=min(mi,L);}\n            }\n        }\n    }\n    vector<ll> dp(n,0);\n    vector<ll> sum(n,0);\n    dp[0]=sum[0]=1;\n    for(int i=2;i<n;i+=2){\n        ll r=sum[i-2];\n        ll l=(i-mi-3>=0?sum[i-mi-3]:0LL);\n        dp[i]=r-l;\n        dp[i]%=MOD;\n        sum[i]=sum[i-2]+dp[i];\n        sum[i]%=MOD;\n        //cout<<dp[i]<<\" \"<<sum[i]<<endl;\n    }\n    ll ans=0;\n    for(ll i=2;i<=mi+1 && n-i>=0;i++){\n        ans+=dp[n-i]*i%MOD;\n        ans%=MOD;\n    }\n    ans%=MOD;\n    if(ans<0){ans+=MOD;}\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nint const N = 400000, md = 1e9 + 7;\nchar s[N + 1];\nint dp[N + 1], n, m;\n\ninline void ad(int &x, int y) { if ((x += y) >= md)x -= md; }\ninline void sb(int &x, int y) { if ((x -= y) <  0 )x += md; }\ninline void out(int an) { printf(\"%d\\n\", an); exit(0); }\n\nvoid sad(){\n\tdp[0] = 1;\n\tdp[1] = 1;\n\tf(i, 2, n + 1)ad(dp[i] = dp[i - 1], dp[i - 2]);\n\tint an = dp[n];\n\tad(an, dp[n - 2]);\n\tout(an);\n}\n\nint main(){\n\tscanf(\"%d%d%s\", &n, &m, s);\n\tassert(n <= N && m <= N);\n\tint mx = md;\n\tbool im = false;\n\tf(i, 0, m){\n\t\tint j = i;\n\t\twhile (j + 1 < m && s[j + 1] == s[i])++j;\n\t\tif (i == 0 && j + 1 == m)sad();\n\t\tim = !im;\n\t\tif (im){\n\t\t\tint ln = j - i + 1;\n\t\t\tif (ln & 1)mx = min(mx, ln);\n\t\t\telse if (i == 0)mx = min(mx, ln | 1);\n\t\t}\n\t\ti = j;\n\t}\n\tif (n & 1)out(0);\n\tn >>= 1;\n\tmx = mx + 1 >> 1;\n\tint l = 1, s = 0;\n\tf(i, 1, n + 1){\n\t\tif (i - l > mx)sb(s, dp[l++]);\n\t\tdp[i] = s;\n\t\tif (i <= mx)ad(dp[i], i << 1);\n\t\tad(s, dp[i]);\n\t}\n\tout(dp[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nconst int md = 1e9 + 7;\n\nint dp[N];\n\nsigned main() {\n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n  vector<int> y;\n  for (int i = 0; i < m; i++) {\n    int cnt = 1;\n    while (i + 1 < m && s[i + 1] == s[i]) {\n      ++i;\n      ++cnt;\n    }\n    y.push_back(cnt);\n  }\n  if (y.size() == 1) {\n    vector<int> f(n + 1), g(n + 1);\n    f[1] = 2, f[2] = 3;\n    for (int i = 3; i <= n; i++) {\n      f[i] = (f[i - 1] + f[i - 2]) % md;\n    }\n    g[0] = 1, g[1] = 2, g[2] = 3, g[3] = 4;\n    for (int i = 4; i <= n; i++) {\n      g[i] = ((long long) g[i - 1] + g[i - 2] + md - f[n - 4]) % md;\n    }\n    cout << g[n] << '\\n';\n    return 0;\n  } else if (n % 2 == 1) {\n    cout << 0 << '\\n';\n    return 0;\n  }\n  y.pop_back();\n  int C = y[0] + 1;\n  bool is = true;\n  for (int x : y) {\n    if (is && (x % 2 == 1)) {\n      C = min(C, x);\n    }\n    is ^= 1;\n  }\n  dp[0] = dp[2] = 1;\n  for (int i = 4; i < N; i += 2) {\n    dp[i] = 2 * dp[i - 2] % md;\n    if (i - 3 - C >= 0) {\n      (dp[i] += md - dp[i - 3 - C]) %= md;\n    }\n  }\n  int ans = dp[n];\n  for (int l = 1; l <= C; l += 2) {\n    if (n - l - 1 >= 0) {\n      (ans += (long long) l * dp[n - l - 1] % md) %= md;\n    }\n  }\n  assert(0 <= ans && ans < md);\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 1000000007;\n\nconst long long MOD_CONST = 1000000007;\nlong long mul_mod(long long a, long long b, const long long MOD) {\n  return b ? (mul_mod(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow_mod(long long a, long long b, const long long MOD) {\n  return (b ? bpow_mod(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv_mod(long long a, const long long MOD) {\n  return bpow_mod(a, MOD - 2, MOD);\n}\ntemplate <long long param = MOD_CONST, bool fast = false>\nclass mint {\n private:\n  using Z = int;\n  using N = unsigned int;\n  using ZZ = long long;\n  using NN = unsigned long long;\n  struct {\n  } constexpr static exact{};\n  // Using Z deliberately to avoid Z -> N promotion.\n  template <class Ret = ZZ&>\n  static auto modulo() -> std::enable_if_t<(param <= 0), Ret> {\n    static ZZ mod = 0;\n    return mod;\n  }\n  template <class Ret = const ZZ>\n  static auto mod() -> std::enable_if_t<(param <= 0), Ret> {\n    return modulo();\n  }\n  template <class Ret = const ZZ>\n  static constexpr auto mod() -> std::enable_if_t<(param > 0), Ret> {\n    return param;\n  }\n\n public:\n  template <class Arg = ZZ>\n  static void set_modulo(const std::enable_if_t<(param <= 0), Arg> mod) {\n    modulo() = mod;\n  }\n  long long v;\n\n  constexpr mint() : v(0) {}\n\n  constexpr mint(long long v)\n      : v(fast ? (v)\n               : (v < 0 ? (v % mod() + mod()) % mod()\n                        : (v >= mod() ? v % mod() : v))) {}\n  constexpr long long get_mod() { return mod(); }\n  long long get_val() { return v; }\n  void take_mod() { v %= mod(); }\n};\ntemplate <long long param, bool fast>\nostream& operator<<(ostream& os, mint<param, fast>& x) {\n  return os << (x.v % x.get_mod() + x.get_mod()) % x.get_mod();\n}\n\ntemplate <long long param, bool fast, bool fast2>\nbool operator==(mint<param, fast>& a, mint<param, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast>& operator+=(mint<param, fast>& a, mint<param, fast2> b) {\n  return a = a.v + b.v;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, mint<param> b) {\n  return a = a.v - b.v;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, mint<param> b) {\n  return a = a.v * b.v;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, mint<param> b) {\n  return a = a.v * inv_mod(b.v, a.get_mod());\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast> operator+(mint<param, fast> a, mint<param, fast2> b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, mint<param> b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, mint<param> b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, mint<param> b) {\n  return a /= b;\n}\ntemplate <long long param, bool fast>\nmint<param, fast>& operator+=(mint<param, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, long long b) {\n  return a = a.v * inv_mod(b, a.get_mod());\n}\ntemplate <long long param, bool fast>\nmint<param, fast> operator+(mint<param> a, long long b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, long long b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, long long b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, long long b) {\n  return a /= b;\n}\n\nvoid special(int N) {\n  vector<mint<>> vals = {mint<>(1), mint<>(1)};\n  for (int i = 0; i < N; i++) {\n    int sz = vals.size();\n    vals.push_back(vals[sz - 1] + vals[sz - 2]);\n  }\n  mint<> ans = vals[N] + vals[N - 2];\n  cout << ans << endl;\n}\n\nint con(string& S, char t) {\n  int ans = 1000000;\n  int cur = 0;\n  for (auto c : S) {\n    if (c == t)\n      cur++;\n    else {\n      if (cur != 0) ans = min(ans, cur);\n      cur = 0;\n    }\n  }\n  return ans;\n}\n\nmint<> calcDP(int N, int conB, int conR) {\n  vector<mint<>> dpR(N + 2, mint<>(0));\n  vector<mint<>> dpB(N + 2, mint<>(0));\n  vector<mint<>> sumR(N + 2, mint<>(0));\n  vector<mint<>> sumB(N + 2, mint<>(0));\n  dpR[1] = 1;\n  sumR[1] = 1;\n  for (int i = 2; i <= N + 1; i++) {\n    if (i % 2 == 1) {\n      dpR[i] = sumB[i - 1] - sumB[max(0, i - conB - 1)];\n      // if (i <= conB) dpR[i] += 1;\n\n    } else\n      dpB[i] = sumR[i - 1] - sumR[max(0, i - conR - 1)];\n    sumB[i] = sumB[i - 1] + dpB[i];\n    sumR[i] = sumR[i - 1] + dpR[i];\n  }\n  mint<> ans = 0;\n  for (int i = 0; i < min(N, conB + 1); i++) {\n    ans += sumR[N - i] - sumR[max(0, N - conB - 1)];\n  }\n  return ans;\n}\n\nvoid solve(long long N, long long M, std::string S) {\n  int cntB = 0;\n\n  int conR = con(S, 'R');\n  int conB = con(S, 'B');\n  for (int i = 0; i < N; i++) {\n    if (S[i] == 'B') cntB++;\n  }\n  if (cntB == N || cntB == 0) {\n    special(N);\n    return;\n  }\n  if (N % 2 == 1) {\n    cout << 0 << endl;\n    return;\n  }\n  if (S[0] == 'R') swap(conR, conB);\n  conR = 1;\n  if (conB % 2 == 0) conB++;\n  // if (conR % 2 == 0) conR--;\n\n  mint<> ans = calcDP(N, conB, conR);\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long M;\n  scanf(\"%lld\", &M);\n  std::string S;\n  std::cin >> S;\n  solve(N, M, S);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline tuple<int, int, int> extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nunsigned ModInt::MOD = 1000000007;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\n\n\nconst int limit = 200010;\nmint dp[limit];\nmint csum[limit];\nmint dp2[limit][2][2];\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\n\tbool same = true;\n\trep(i, m) if(s[0] != s[i]) same = false;\n \n\tif(same){\n\t\tdp2[1][0][0] = ONE;\n\t\tdp2[1][1][1] = ONE;\n\t\trep(i, 1, n) rep(start, 2) rep(prv, 2){\n\t\t\tdp2[i + 1][start][0] += dp2[i][start][prv];\n\t\t\tif(prv == 0) dp2[i + 1][start][1] += dp2[i][start][prv];\n\t\t}\n\t\tmint ans = dp2[n][0][0] + dp2[n][0][1] + dp2[n][1][0];\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\n\tint cmin = n, cons = 0;\n\n\trep(i, m){\n\t\tif(s[i] == s[0]){\n\t\t\tcons++;\n\t\t} else {\n\t\t\tchmin(cmin, cons);\n\t\t\tcons = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trep(i, m){\n\t\tif(s[i] == s[0]){\n\t\t\tcons++;\n\t\t} else {\n\t\t\tif(cons % 2 == 1) chmin(cmin, cons);\n\t\t\tcons = 0;\n\t\t}\n\t}\n\n\tif(cmin % 2 == 0) cmin++;\n\tdp[1] = csum[1] = ONE;\n\n\trep(i, 1, n){\n\t\tconst int pos = max(i - cmin - 1, 0);\n\t\tif((i + 1) % 2 == 1) dp[i + 1] =  csum[i] - csum[pos];\n\t\tcsum[i + 1] = csum[i] + dp[i + 1];\n\t}\n\n\tmint ans = ZERO;\n\n\trep(i, max(0, n - cmin), n + 1){\n\t\tif((n - i) % 2 == 0) continue;\n\t\tconst mint coef = mint(n - i + 1);\n\t\tans += coef * dp[i];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1, typename T2>\ninline bool cmn (T1& a, T2 b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate<typename T1, typename T2>\ninline bool cmx (T1& a, T2 b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\nconstexpr int md = 1e9 + 7;\ninline void mad(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\ninline void msb(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\ninline int mul(int a, int b) {\n  return (int)((long long)a * b % md);\n}\ntemplate<typename T>\nclass run_length_encoding {\n  vector<pair<int, T>> rle;\n  public:\n    run_length_encoding(\n        vector<T> input\n      ) :\n      rle()\n      {\n        int cnt = 0;\n        for (auto it = input.begin(); it != input.end(); it++) {\n          auto jt = next(it); cnt++;\n          if (jt == input.end() || *it != *jt) {\n            rle.emplace_back(cnt, *it);\n            cnt = 0;\n          }\n        }\n      }\n    auto const& code () const {return rle;}\n};\nint main() {\n  int n, m; string s;\n  cin >> n >> m >> s;\n  vector<int> a(m);\n  for (int i = 0; i < m; i++) a[i] = s[0] == s[i];\n  auto rle = run_length_encoding<int>(a).code();\n  if (rle.size()  == 1) {\n    vector<int> dp(n + 1, 0);\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n      mad(dp[i], dp[i - 1]);\n      mad(dp[i], dp[i - 2]);\n    }\n    for (int i = n; i >= 1; i--) msb(dp[i], dp[i - 1]);\n    int ret = 0;\n    for (int i = 0; i < n; i++) {\n      mad(ret, mul(i + 1, dp[n - i]));\n    }\n    cout << ret << endl;\n    return 0;\n  }\n  if (n & 1) {\n    cout << 0 << endl;\n    return 0;\n  }\n  n >>= 1;\n  int k = n;\n  for (auto it = rle.begin(); it < rle.end() - 1; it += 2) {\n    int m = it->first;\n    if (m & 1) cmn(k, (m + 1) >> 1);\n    else if (it == rle.begin()) cmn(k, (m + 2) >> 1);\n  }\n  vector<int> dp(n + 1, 0);\n  dp[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    mad(dp[i], dp[i - 1]);\n    mad(dp[i], dp[i - 1]);\n    if (i - k - 1 >= 0) msb(dp[i], dp[i - k - 1]);\n  }\n  for (int i = n; i >= 1; i--) msb(dp[i], dp[i - 1]);\n  int ret = 0;\n  for (int i = 0; i < k; i++) {\n    mad(ret, mul(i + 1, dp[n - i]));\n  }\n  mad(ret, ret);\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define Pr(f,...) printf(f,##__VA_ARGS__),fflush(stdout)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define lop(i,s,t) for(int i=s;i<(t);++i)\nusing namespace std; \n\nconst int N=200050,P=1e9+7; \n\nint n,m,limit,f[N],sum[N]; \nchar s[N]; \n\nint main(int argc,char *argv[]){\n\tfreopen(\"d.in.cpp\",\"r\",stdin); \n    scanf(\"%d%d%s\",&n,&m,s); \n    if(s[0]=='B')lop(i,0,m)s[i]=s[i]=='R'?'B':'R';\n\t//Pr(\"%d,%d,%s\\n\",n,m,s);  \n    while(m&&s[m-1]=='R')--m;\n    if(m==0){\n    \tf[0]=2,f[1]=1;\n\t\trep(i,2,n)f[i]=(f[i-1]+f[i-2])%P;\n\t\tprintf(\"%d\\n\",f[n]); \n\t\treturn 0; \t\n    }\n    if(n%2!=0){\n        puts(\"0\"); \n        return 0; \n    }\n    limit=n-1; \n    for(int p=0,prv=0;p<m;++p){\n        while(p<m&&s[p]=='R')++p;\n\t\tif(prv==0){\n            if(p-prv%2==1)limit=p-prv;\n            else limit=p-prv+1;\n        }\n        if(p-prv%2==1)limit=min(limit,p-prv);\n        prv=p;\n    }          \n\tf[1]=sum[1]=0,f[2]=sum[2]=2;\n\tfor(int i=4;i<=n;i+=2){\n\t\tsum[i-1]=(sum[i-2]+f[i-1])%P;\n\t\tif(i<=limit+1)(f[i]+=i)%=P;\n\t\t(f[i]+=(sum[i-1]-sum[i-limit-2]+P)%P)%=P;\n\t\tsum[i]=(sum[i-1]+f[i])%P;\n\t}\n\tprintf(\"%d\\n\",f[n]); \n    return 0; \n}    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n  \n  assert(s[0]=='R');\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  for(Int i=0;i<m;i++)\n    s[i]=\"BR\"[vs[i]];\n  \n  if(vs==vector<Int>(m,1)){    \n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n  assert(vs!=vector<Int>(m,0));\n\n  if(n&1){\n    cout<<0<<endl;\n    return 0;\n  }\n  \n  Int lim=n-1;  \n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    Int j=i;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n\n    if(i==0&&(j-i)%2==0) chmin(lim,j-i+1);\n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }\n  \n  vector<M> dp(n+2,0),sm(n+2,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n+1;i++){\n    sm[i]=sm[i-1]+dp[i-1];\n    if(i&1) dp[i]=sm[i-1]-sm[max<Int>(1,i-1-lim)];\n  }\n  \n  M ans{0};\n  for(Int i=0;i<=lim;i++)\n    ans+=sm[n-i+1]-sm[max<Int>(1,n-lim)];\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  for(Int i=0;i<m;i++)\n    s[i]=\"BR\"[vs[i]];\n  \n  if(vs==vector<Int>(m,1)){    \n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n  assert(vs!=vector<Int>(m,0));\n\n  if(n&1){\n    cout<<0<<endl;\n    return 0;\n  }\n  \n  Int lim=n-1;  \n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    Int j=i;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n\n    if(i==0&&(j-i)%2==0) chmin(lim,j-i+1);\n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }\n  \n  vector<M> dp(n+2,0),sm(n+2,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n+1;i++){\n    sm[i]=sm[i-1]+dp[i-1];\n    if(i&1) dp[i]=sm[i-1]-sm[max<Int>(1,i-1-lim)];\n  }\n  \n  M ans{0};\n  for(Int i=0;i<=lim;i++)\n    ans+=sm[n-i+1]-sm[max<Int>(1,n-lim)];\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nchar str[200005];\nint arr[200005];\nlong long MOD=1000000007;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",str);\n\tfor(int i=0;i<m;i++)if(str[i]=='R')arr[i]=0;else arr[i]=1;\n\tbool all[2];all[0]=all[1]=1;\n\tfor(int i=0;i<m;i++)all[arr[i]^1]=0;\n\tif(all[0]||all[1]){\n\t\tlong long dp[2][n];memset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;dp[1][0]=0; //start with red (or blue if everything is blue)\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tlong long ans=(dp[0][n-1]+dp[1][n-1])%MOD;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=0;dp[1][0]=1; //start with blue\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tans+=dp[0][n-1];ans%=MOD;ans+=MOD;ans%=MOD;\n\t\tprintf(\"%lld\",ans);\n\t\treturn 0;\n\t}\n\tif(n%2!=0){printf(\"0\");return 0;}\n\tint cur=0,mxl=n;\n\tfor(int i=0;i<m;i++){\n\t\tif(arr[i]==arr[0])cur++;\n\t\telse{\n\t\t\tif(mxl==n)mxl=cur|1;\n\t\t\telse if(cur%2==1)mxl=min(mxl,cur);\n\t\t\tcur=0;\n\t\t}\n\t}\n\tmxl=min(mxl,n-1);\n\t//comments: wlog red is first\n\t//can ignore last segment of red\n\tn/=2; mxl/=2; //remove the ones that are different parity from blue\n\tlong long dp[100005],pref[100005];\n\tmemset(dp,0,sizeof(dp));memset(pref,0,sizeof(pref));\n\t//i segments on a line, first and last are blue, max mxl consecutive reds\n\t//blues may be consecutive because the reds in between were removed\n\tdp[1]=pref[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tdp[i]=pref[i-1]-pref[max(0,i-(mxl+2))];\n\t\tdp[i]%=MOD;dp[i]+=MOD;dp[i]%=MOD;\n\t\tpref[i]=dp[i]+pref[i-1];\n\t\tpref[i]%=MOD;pref[i]+=MOD;pref[i]%=MOD;\n\t}\n\tlong long ans=0;\n\tfor(long long i=2;i<=min(n,mxl+2);i++){\n\t\tans+=(i-1LL)*dp[n-i+2];\n\t\tans%=MOD;\n\t}\n\tans+=MOD;ans%=MOD;\n\tprintf(\"%lld\",(ans*2)%MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\n\n/// --- Modulo Integer {{{ ///\n#include <ostream>\ntemplate < long long mod = static_cast< long long >(1e9 + 7) >\nstruct ModuloInteger {\n  static_assert(mod > 0, \"mod must be positive\");\n  static_assert(mod <= 3037000499, \"mod is too big\");\n  using integer = long long;\n  static ModuloInteger unused;\n  // math {{{\n  static inline integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  static inline integer modpow(integer a, long long b) {\n    if(b < 0) b = -b, a = modinv(a);\n    integer r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  integer val;\n  constexpr ModuloInteger() : val(0) {}\n  constexpr ModuloInteger(integer t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\nprivate:\n  // strict constructor\n  constexpr ModuloInteger(integer t, int) : val(t) {}\n\npublic:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // operator bool() { return bool(val); }\n  // ModuloInteger <arithmetic-operator>[=] ModuloInteger {{{\n  ModuloInteger operator+(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModuloInteger operator-(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModuloInteger operator*(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModuloInteger operator/(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModuloInteger &operator+=(ModuloInteger const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModuloInteger &operator-=(ModuloInteger const &rhs) { return *this += -rhs; }\n  ModuloInteger &operator*=(ModuloInteger const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModuloInteger &operator/=(ModuloInteger const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModuloInteger operator++(int) {\n    ModuloInteger tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModuloInteger operator--(int) {\n    ModuloInteger tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModuloInteger &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModuloInteger &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModuloInteger operator-() const { return ModuloInteger(val == 0 ? 0 : mod - val, 0); }\n  // ModuloInteger <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModuloInteger operator+(T const &rhs) const {\n      return ModuloInteger(val + rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator-(T const &rhs) const {\n      return ModuloInteger(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator*(T const &rhs) const {\n      return ModuloInteger(val * (rhs % mod));\n    }\n  template < typename T >\n    ModuloInteger operator/(T const &rhs) const {\n      return ModuloInteger(val * modinv(rhs));\n    }\n  template < typename T >\n    ModuloInteger &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator/=(T const &rhs) {\n      val = val * modinv(rhs) % mod;\n      return *this;\n    }\n  // }}}\n  ModuloInteger inv() const { return ModuloInteger(modinv(val), 0); }\n  ModuloInteger operator~() const { return inv(); }\n  friend std::ostream &operator<<(std::ostream &os, ModuloInteger const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // equality operator {{{\n  ModuloInteger operator==(const ModuloInteger &a) const { return val == a.val; }\n  ModuloInteger operator!=(const ModuloInteger &a) const { return val != a.val; }\n  ModuloInteger operator==(const integer &a) const { return val == ModuloInteger(a); }\n  ModuloInteger operator!=(const integer &a) const { return val != ModuloInteger(a); }\n  // }}}\n  // T <arithmetic-operator> ModuloInteger {{{\n  friend constexpr ModuloInteger operator+(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod + mv.val);\n  }\n  friend constexpr ModuloInteger operator-(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod - mv.val);\n  }\n  friend constexpr ModuloInteger operator*(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModuloInteger operator/(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModuloInteger operator^(integer x) const { return pow(*this, x); }\n  ModuloInteger &operator^=(integer x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModuloInteger pow(ModuloInteger x, integer y) {\n    return ModuloInteger(modpow(x.val, y), 0);\n  }\n  // }}}\n};\ntemplate < long long mod >\nModuloInteger< mod > ModuloInteger< mod >::unused(mod, 0);\n/// }}}--- ///\n\nusing modint = ModuloInteger<>;\n\n\n// LazySegmentTree( size [, initial] )\n// LazySegmentTree( <data> )\n/// --- LazySegmentTree {{{ ///\n#include <cassert>\n#include <initializer_list>\n#include <iostream>\n#include <vector>\ntemplate < class M_act >\nstruct LazySegmentTree {\npublic:\n  using Monoid = typename M_act::Monoid;\n  using X = typename Monoid::T;\n  using M = typename M_act::M;\n\nprivate:\n  size_t n;\n  int h;\n  vector< X > data;\n  vector< M > lazy;\n  vector< size_t > nodeLength;\n  // call before use data[i]\n  void eval(size_t i) {\n    if(lazy[i] == M_act::identity()) return;\n    data[i] = M_act::actInto(lazy[i], nodeLength[i], data[i]);\n    if(i < n) {\n      lazy[i * 2] = M_act::op(lazy[i], lazy[i * 2]);\n      lazy[i * 2 + 1] = M_act::op(lazy[i], lazy[i * 2 + 1]);\n    }\n    lazy[i] = M_act::identity();\n  }\n  // call before use seg[i] = data[i + n]\n  void evalDown(size_t i) {\n    i += n;\n    for(int j = h - 1; j >= 0; j--) eval(i >> j);\n  }\n  // call after touch seg[i] = data[i + n]\n  void propUp(size_t i) {\n    i += n;\n    while(i >>= 1)\n      eval(i * 2), eval(i * 2 + 1), data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n  }\n\npublic:\n  LazySegmentTree() : n(0) {}\n  LazySegmentTree(size_t n, X initial = Monoid::identity()) : n(n) {\n    if(n > 0) {\n      h = 1;\n      while(1u << h < n) h++;\n      data.resize(2 * n, initial);\n      lazy.resize(2 * n, M_act::identity());\n      nodeLength.resize(2 * n, 1);\n      for(size_t i = n - 1; i > 0; i--) // fill from deep\n        data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]),\n          nodeLength[i] = nodeLength[i * 2] + nodeLength[i * 2 + 1];\n    }\n  }\n  template < class InputIter, class = typename iterator_traits< InputIter >::value_type >\n    LazySegmentTree(InputIter first, InputIter last)\n    : LazySegmentTree(distance(first, last)) {\n      if(n > 0) {\n        copy(first, last, begin(data) + n);\n        for(size_t i = n - 1; i > 0; i--) // fill from deep\n          data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n      }\n    }\n  LazySegmentTree(vector< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  LazySegmentTree(initializer_list< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  void act(int l, int r, const M &m) {\n    if(l < 0) l = 0;\n    if(l >= r) return;\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    int tl = l, tr = r;\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), lazy[l] = m, eval(l), l++;\n      if(r & 1) --r, eval(r), lazy[r] = m, eval(r);\n    }\n    propUp(tl);\n    propUp(tr - 1);\n  }\n  void set(size_t i, const X &x) {\n    assert(i < n);\n    evalDown(i);\n    data[i + n] = x;\n    propUp(i);\n  }\n  X get(size_t i) {\n    assert(i < n);\n    evalDown(i);\n    return data[i + n];\n  }\n  X fold(int l, int r) {\n    if(l < 0) l = 0;\n    if(l >= r) return Monoid::identity();\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    X tmpL = Monoid::identity(), tmpR = Monoid::identity();\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), tmpL = Monoid::op(tmpL, data[l]), l++;\n      if(r & 1) --r, eval(r), tmpR = Monoid::op(data[r], tmpR);\n    }\n    return Monoid::op(tmpL, tmpR);\n  }\n  int size() { return n; }\n  inline void dum(int r = -1) {\n#ifdef DEBUG\n    if(r < 0) r = n;\n    DEBUG_OUT << \"{\";\n    for(int i = 0; i < min(r, (int) n); i++) DEBUG_OUT << (i ? \", \" : \"\") << get(i);\n    DEBUG_OUT << \"}\" << endl;\n#endif\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid examples {{{ ///\nconstexpr long long inf_monoid = 1e18 + 100;\n#include <algorithm>\nstruct Nothing {\n  using T = char;\n  using Monoid = Nothing;\n  using M = T;\n  static constexpr T op(const T &, const T &) { return T(); }\n  static constexpr T identity() { return T(); }\n  template < class X >\n    static constexpr X actInto(const M &, long long, const X &x) {\n      return x;\n    }\n};\n\ntemplate < class U = long long >\nstruct RangeMin {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::min< T >(a, b); }\n  static constexpr T identity() { return T(inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeMax {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::max< T >(a, b); }\n  static constexpr T identity() { return T(-inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeSum {\n  using T = U;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return T(0); }\n};\n\ntemplate < class U >\nstruct RangeProd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a * b; }\n  static constexpr T identity() { return T(1); }\n};\n\ntemplate < class U = long long >\nstruct RangeOr {\n  using T = U;\n  static T op(const T &a, const T &b) { return a | b; }\n  static constexpr T identity() { return T(0); }\n};\n\n#include <bitset>\n\ntemplate < class U = long long >\nstruct RangeAnd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return T(-1); }\n};\n\ntemplate < size_t N >\nstruct RangeAnd< std::bitset< N > > {\n  using T = std::bitset< N >;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return std::bitset< N >().set(); }\n};\n\n/// }}}--- ///\n\n/// --- M_act examples {{{ ///\ntemplate < class U = long long, class V = U >\nstruct RangeMinAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMin< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMax< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMinSet {\n  using M = U;\n  using Monoid = RangeMin< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxSet {\n  using M = U;\n  using Monoid = RangeMax< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long n, const X &x) { return m * n + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long n, const X &x) {\n    return m == identity() ? x : m * n;\n  }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdMul {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M mpow(M a, long long b) {\n    X r(1);\n    while(b) {\n      if(b & 1) r = r * a;\n      a = a * a;\n      b >>= 1;\n    }\n    return r;\n  }\n  static M op(const M &a, const M &b) { return a * b; }\n  static constexpr M identity() { return M(1); }\n  static X actInto(const M &m, long long n, const X &x) { return x * mpow(m, n); }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return V::unused; }\n  static X actInto(const M &m, long long n, const X &) {\n    if(m == identity()) return;\n    return RangeProdMul< U, V >::mpow(m, n);\n  }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeOr2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeOr< U >;\n  static M op(const M &a, const M &b) { return a | b; }\n  static constexpr M identity() { return M(0); }\n  static X actInto(const M &m, long long, const X &x) { return m | x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeAnd2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return M(-1); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n\ntemplate < class U, size_t N >\nstruct RangeAnd2< U, std::bitset< N > > {\n  using X = U;\n  using M = std::bitset< N >;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return std::bitset< N >().set(); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n/// }}}--- ///\n\nusing Seg = LazySegmentTree< RangeSumAdd<modint> >;\n\n\n// NOTE : use H with larger N\n/// --- Modulo Factorial {{{ ///\n#include <cassert>\n#include <cstddef>\ntemplate < std::size_t N, int mod = static_cast< int >(1e9 + 7) >\nstruct Factorial {\n  using integer = long long;\n  constexpr integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d = 0;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  constexpr integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  int arr[N + 1], inv[N + 1];\n  integer operator[](int i) const { return arr[i]; }\n  Factorial() : arr(), inv() {\n    arr[0] = 1;\n    for(std::size_t i = 1; i <= N; i++) {\n      arr[i] = (integer) i * arr[i - 1] % mod;\n    }\n    inv[N] = modinv(arr[N]);\n    for(int i = N - 1; i >= 0; i--) {\n      inv[i] = (integer)(i + 1) * inv[i + 1] % mod;\n    }\n  }\n  integer C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    assert(n <= N);\n    return (integer) arr[n] * inv[r] % mod * inv[n - r] % mod;\n  }\n  integer H(int n, int r) const { return C(n + r - 1, r); }\n};\n/// }}}--- ///\n\nconstexpr int mod = 1e9 + 7;\nconst int N = 2e5 + 10;\nFactorial< N * 2, mod > fact;\n\n\n\nint n, m;\nint r, b;\nint rmax;\nstring s;\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n >> m;\n  cin >> s;\n  if(s[0] == 'B') for(auto &e : s) e = e == 'R' ? 'B' : 'R';\n  bool allR = 1;\n  for(auto e : s) allR &= e == 'R';\n\n  if(allR) {\n    dump(\"allR\");\n    modint ans;\n    for(int B = 0; B <= n; B++) {\n      int R = n - B - B;\n      ans += modint(fact.C(R + B, R));\n      ans += modint(fact.C(R + B - 1, R));\n    }\n    cout << ans << endl;\n    return 0;\n  }\n\n  if(n % 2 == 1) {\n    cout << 0 << endl;\n    dump(\"odd\");\n    return 0;\n  }\n\n  int c = m;\n  bool first = 1;\n  for(int i = 0; i <= m; i++) {\n    if(i == n || s[i] == 'B') {\n      if(c) {\n        if(c % 2 == 0 && first) rmax = min(rmax, c + 1);\n        if(c % 2 == 1) rmax = min(rmax, c);\n      }\n      c = 0;\n      first = 0;\n    } else c++;\n  }\n\n  dump(rmax);\n\n  // RB\n\n  // vector<modint> dp(n + 1);\n  Seg dp(n + 1);\n  dp.set(0, 1);\n\n  modint ans;\n\n  for(int i = 0; i <= n - 1; i+=2) {\n    dp.act(i + 2, min<int>(n - 1, i + 1 + rmax) + 1, dp.get(i));\n    if(i + 1 + rmax >= n) {\n      int f = n - i - 1;\n      if (f >= 1) {\n        dump(i, dp.get(i), f);\n        ans += dp.get(i) * (f + 1);\n      }\n    }\n  }\n  cout << ans << endl;\n  dp.dum();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef double db;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pct __builtin_popcount\n\n#define P 1000000007\n\n#define N 200010\nint f[N], g[N];\n\nint n, m;\nstring s;\n\nint main() {\n\tcin >> n >> m >> s;\n\tif (s[0] == 'B') {\n\t\tfor (int i = 0; i < m; i ++)\n\t\t\ts[i] = 'R' + 'B' - s[i];\n\t}\n\tif (s == string(m, 'R')) {\n\t\tint fbb = 1, fbr = 0, frb = 0, frr = 1;\n\t\tfor (int i = 1; i < n; i ++) {\n\t\t\tint gbb = fbr;\n\t\t\tint gbr = (fbb + fbr)%P;\n\t\t\tint grb = frr;\n\t\t\tint grr = (frr + frb)%P;\n\t\t\tfbb = gbb;\n\t\t\tfbr = gbr;\n\t\t\tfrb = grb;\n\t\t\tfrr = grr;\n\t\t}\n\t\tint S = ((ll)frr + fbr + frb)%P;\n\t\tcout << S << endl;\n\t\treturn 0;\n\t}\n\tif (n%2 == 1) {\n\t\tputs (\"0\");\n\t\treturn 0;\n\t}\n\n\tbool F = true;\n\tint l = n;\n\tfor (int i = 0; i < n; ) {\n\t\tint j = i;\n\t\twhile (j < n && s[j] == s[i]) j++;\n\t\tif (j == n) break;\n\t\tif ((j-i)%2 == 1) {\n\t\t\tif (s[i] == 'R') l = min(l, j-i);\n\t\t} else {\n\t\t\tif (i == 0) l = min(l, j+1);\n\t\t}\n\t\ti = j;\n\t}\n\tif (!F) {\n\t\tputs (\"0\");\n\t\treturn 0;\n\t}\n\n\tl = (l+1)/2;\n\tn /= 2;\n\n\tf[0] = 1;\n\tg[1] = 1;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tif (i <= l) f[i] = g[i]; else {\n\t\t\tf[i] = (g[i] - g[i-l]+P)%P;\n\t\t}\n\t\tg[i+1] = (g[i] + f[i])%P;\n\t}\n\n\tint S = 0;\n\tfor (int i = 0; i < min(l, n); i ++) {\n\t\tint T = (g[n-i] - g[n-l]+P)%P;\n\t\t// f[n-i-1] + .. + f[n-l];\n\t\t(S += T) %= P;\n\t}\n\n\tS = (ll)S*2%P;\n\tcout << S << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+10;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    ans = dp[n+1];\n    for(ll i = 1;i<=lim;i+=2)\n    {\n        ans += (i*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-1];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    int mn = 1e9;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 200010\n#define int long long\n#define mod 1000000007\n#define debug cerr<<__LINE__<<\" \"<<__FUNCTION__<<\"\\n\"\n\ninline int read(){\n    int x=0,y=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n    return x*y;\n}\nvoid put(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>=10) put(x/10);\n    putchar((x%10)+48);\n}\nint n,m,A[N],B[N];\nstring s;\nsigned main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tn=read();m=read();\n\tcin>>s;\n\tif(s[0]=='B'){\n\t\tfor(int i=0;i<m;i++) s[i]=(s[i]=='B'?'R':'B');\n\t}\n\tint pos=s.find('B');\n\tif(pos==string::npos){\n\t\tA[1]=A[2]=1;\n\t\tfor(int i=3;i<=n;i++) A[i]=(A[i-1]+A[i-2])%mod;\n\t\tcout<<(A[n]+2*A[n-1]%mod)%mod<<\"\\n\";\n\t\treturn 0;\n\t}\n\tif(n&1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint l=m,res=0,flag=1;\n\tfor(int i=0;i<m;i++){\n\t\tif(s[i]=='B'){\n\t\t\tif(flag||(res&1==0)) l=min(l,res+(res&1));\n\t\t\tflag=0;\n\t\t\tres=0;\n\t\t}\n\t\tres++;\n\t}\n//\tcout<<l<<\"\\n\";\n\tl/=2;n/=2;\n\tA[0]=B[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tA[i]=B[i-1];\n\t\tif(i>l) A[i]=(A[i]-B[i-l-1]+mod)%mod;\n\t\tB[i]=(B[i-1]+A[i])%mod;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=l;i++){\n\t\tans=(ans+2*i%mod*A[n-i]%mod)%mod;\n\t}\n\tcout<<ans<<\"\\n\";\n//\tfclose(stdin);\n//\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // clang-format off\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define in2(s,t)     rep(i,sz(s)){in(s[i] , t[i]);}\n#define in3(s,t,u)   rep(i,sz(s)){in(s[i] , t[i] , u[i]);}\n#define in4(s,t,u,v) rep(i,sz(s)){in(s[i] , t[i] , u[i] , v[i]);}\n#ifdef ONLINE_JUDGE\n  #define rep(i,N) for(int i = 0; i < (int)(N); i++)\n  #define repr(i,N) for(int i = (int)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(int i = 1; i <= (int)(N) ; i++)\n  #define repr1(i,N) for(int i = (N) ; (int)(i) > 0 ; i--)\n#else\n  #define rep(i,N) for(long long i = 0; i < (long long)(N); i++)\n  #define repr(i,N) for(long long i = (long long)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(long long i = 1; i <= (long long)(N) ; i++)\n  #define repr1(i,N) for(long long i = (N) ; (long long)(i) > 0 ; i--)\n#endif\nusing namespace std; void solve();\nusing ll = long long; template<class T = ll> using V = vector<T>;\nusing vi = V<int>; using vl = V<>; using vvi = V< V<int> >;\nusing vd = V<double>; using vs = V<string>; using vvl = V< V<> >;\nconstexpr int inf = 1001001001; constexpr ll infLL = (1LL << 61) - 1;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T,typename U>ll ceil(T a,U b){return (a + b - 1) / b;}\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); for(int i=0;i<s;i++) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);} while(0)\n  #define trcc(v) do { cerr << \"name : \" << #v << \"\\n\"; int cnt = 0; each(x , v){cerr << (cnt++) << \" : \"; trc(x); } } while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  #define trcc(...)\n  int main(){solve();}\n#endif\n\nconstexpr ll TEN(int n){ll ret=1,x=10;while(n){if(n&1)ret*=x;x*=x;n>>=1;}return ret;}\n#define mem(a, val) memset(a, val, sizeof(a))\n\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\nusing P = pair<ll,ll>; using vp = V<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n// clang-format on\n////////////////////////////////////////////////////\n\n\nvector<pair<char,int>> RunLengthEncoding(string& S){\n  vector<pair<char,int>> ret;\n  char c = -1;\n  int n = 0;\n  for(char x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate<typename T>\nvector<pair<T,int>> RunLengthEncoding(vector<T>& S){\n  vector<pair<T,int>> ret;\n  T c = -1;\n  int n = 0;\n  for(T& x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\nusing mint = modint;\n\nnamespace FastFourierTransform {\n  using real = double;\n\n  struct C {\n    real x, y;\n\n    C() : x(0), y(0) {}\n\n    C(real x, real y) : x(x), y(y) {}\n\n    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }\n\n    inline C conj() const { return C(x, -y); }\n  };\n\n  const real PI = acosl(-1);\n  int base = 1;\n  vector< C > rts = { {0, 0},\n                     {1, 0} };\n  vector< int > rev = {0, 1};\n\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    while(base < nbase) {\n      real angle = PI * 2.0 / (1 << (base + 1));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        real angle_i = angle * (2 * i + 1 - (1 << base));\n        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n      }\n      ++base;\n    }\n  }\n\n  void fft(vector< C > &a, int n) {\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          C z = a[i + j + k] * rts[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n  }\n\n  vector< int64_t > multiply(const vector< int > &a, const vector< int > &b) {\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = C(x, y);\n    }\n    fft(fa, sz);\n    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n      fa[i] = z;\n    }\n    for(int i = 0; i < (sz >> 1); i++) {\n      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n      fa[i] = A0 + A1 * s;\n    }\n    fft(fa, sz >> 1);\n    vector< int64_t > ret(need);\n    for(int i = 0; i < need; i++) {\n      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n    }\n    return ret;\n  }\n};\n\ntemplate< typename T >\nstruct ArbitraryModConvolution {\n  using real = FastFourierTransform::real;\n  using C = FastFourierTransform::C;\n\n  ArbitraryModConvolution() = default;\n\n  vector< T > multiply(const vector< T > &a, const vector< T > &b, int need = -1) {\n    if(need == -1) need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while((1 << nbase) < need) nbase++;\n    FastFourierTransform::ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < (int)a.size(); i++) {\n      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);\n    }\n    fft(fa, sz);\n    vector< C > fb(sz);\n    if(a == b) {\n      fb = fa;\n    } else {\n      for(int i = 0; i < (int)b.size(); i++) {\n        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);\n      }\n      fft(fb, sz);\n    }\n    real ratio = 0.25 / sz;\n    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C a1 = (fa[i] + fa[j].conj());\n      C a2 = (fa[i] - fa[j].conj()) * r2;\n      C b1 = (fb[i] + fb[j].conj()) * r3;\n      C b2 = (fb[i] - fb[j].conj()) * r4;\n      if(i != j) {\n        C c1 = (fa[j] + fa[i].conj());\n        C c2 = (fa[j] - fa[i].conj()) * r2;\n        C d1 = (fb[j] + fb[i].conj()) * r3;\n        C d2 = (fb[j] - fb[i].conj()) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector< T > ret(need);\n    for(int i = 0; i < need; i++) {\n      int64_t aa = llround(fa[i].x);\n      int64_t bb = llround(fb[i].x);\n      int64_t cc = llround(fa[i].y);\n      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;\n      ret[i] = aa + (bb << 15) + (cc << 30);\n    }\n    return ret;\n  }\n};\n\ntemplate< int mod >\nstruct NumberTheoreticTransform {\n\n  int base, max_base, root;\n  vector< int > rev, rts;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while(tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while(n > 0) {\n      if(n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) {\n    return mod_pow(x, mod - 2);\n  }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long) mod;\n  }\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while(base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n\n  void ntt(vector< int > &a) {\n    const int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n\n  vector< int > multiply(vector< int > a, vector< int > b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for(int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n\n  vector<modint> multiply_for_fps(const vector<modint> &a,const vector<modint> &b){\n    vector<int> A(a.size()) , B(b.size());\n    for(int i = 0;i < (int)a.size(); i++) A[i] = a[i].x;\n    for(int i = 0;i < (int)b.size(); i++) B[i] = b[i].x;\n    auto C = multiply( A , B );\n    vector<modint> ret(C.size());\n    for(int i = 0; i < (int)C.size() ;i++) ret[i].x = C[i];\n    return ret;\n  }\n};\n\n\ntemplate< typename T >\nstruct FormalPowerSeries : vector< T > {\n  using vector< T >::vector;\n  using P = FormalPowerSeries;\n\n  using MULT = function< P(P, P) >;\n\n  static MULT &get_mult() {\n    static MULT mult = nullptr;\n    return mult;\n  }\n\n  static void set_fft(MULT f) {\n    get_mult() = f;\n  }\n\n  void shrink() {\n    while(this->size() && this->back() == T(0)) this->pop_back();\n  }\n\n  P operator+(const P &r) const { return P(*this) += r; }\n\n  P operator+(const T &v) const { return P(*this) += v; }\n\n  P operator-(const P &r) const { return P(*this) -= r; }\n\n  P operator-(const T &v) const { return P(*this) -= v; }\n\n  P operator*(const P &r) const { return P(*this) *= r; }\n\n  P operator*(const T &v) const { return P(*this) *= v; }\n\n  P operator/(const P &r) const { return P(*this) /= r; }\n\n  P operator%(const P &r) const { return P(*this) %= r; }\n\n  P &operator+=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] += r[i];\n    return *this;\n  }\n\n  P &operator+=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] += r;\n    return *this;\n  }\n\n  P &operator-=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] -= r[i];\n    shrink();\n    return *this;\n  }\n\n  P &operator-=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] -= r;\n    shrink();\n    return *this;\n  }\n\n  P &operator*=(const T &v) {\n    const int n = (int) this->size();\n    for(int k = 0; k < n; k++) (*this)[k] *= v;\n    return *this;\n  }\n\n  P &operator*=(const P &r) {\n    if(this->empty() || r.empty()) {\n      this->clear();\n      return *this;\n    }\n    assert(get_mult() != nullptr);\n    return *this = get_mult()(*this, r);\n  }\n\n  P &operator%=(const P &r) {\n    return *this -= *this / r * r;\n  }\n\n  P operator-() const {\n    P ret(this->size());\n    for(int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];\n    return ret;\n  }\n\n  P &operator/=(const P &r) {\n    if(this->size() < r.size()) {\n      this->clear();\n      return *this;\n    }\n    int n = this->size() - r.size() + 1;\n    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);\n  }\n\n  P pre(int sz) const {\n    return P(begin(*this), begin(*this) + min((int) this->size(), sz));\n  }\n\n  P operator>>(int sz) const {\n    if(this->size() <= sz) return {};\n    P ret(*this);\n    ret.erase(ret.begin(), ret.begin() + sz);\n    return ret;\n  }\n\n  P operator<<(int sz) const {\n    P ret(*this);\n    ret.insert(ret.begin(), sz, T(0));\n    return ret;\n  }\n\n  P rev(int deg = -1) const {\n    P ret(*this);\n    if(deg != -1) ret.resize(deg, T(0));\n    reverse(begin(ret), end(ret));\n    return ret;\n  }\n\n  P diff() const {\n    const int n = (int) this->size();\n    P ret(max(0, n - 1));\n    for(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);\n    return ret;\n  }\n\n  P integral() const {\n    const int n = (int) this->size();\n    P ret(n + 1);\n    ret[0] = T(0);\n    for(int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);\n    return ret;\n  }\n\n  // F(0) must not be 0\n  P inv(int deg = -1) const {\n    assert(((*this)[0]) != T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1) / (*this)[0]});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 1\n  P log(int deg = -1) const {\n    assert((*this)[0] == 1);\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();\n  }\n\n  P sqrt(int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n\n    if((*this)[0] == T(0)) {\n      for(int i = 1; i < n; i++) {\n        if((*this)[i] != T(0)) {\n          if(i & 1) return {};\n          if(deg - i / 2 <= 0) break;\n          auto ret = (*this >> i).sqrt(deg - i / 2) << (i / 2);\n          if(ret.size() < deg) ret.resize(deg, T(0));\n          return ret;\n        }\n      }\n      return P(deg, 0);\n    }\n\n    P ret({T(1)});\n    T inv2 = T(1) / T(2);\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 0\n  P exp(int deg = -1) const {\n    assert((*this)[0] == T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1)});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  P pow(int64_t k, int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    for(int i = 0; i < n; i++) {\n      if((*this)[i] != T(0)) {\n        T rev = T(1) / (*this)[i];\n        P C(*this * rev);\n        P D(n - i);\n        for(int j = i; j < n; j++) D[j - i] = C[j];\n        D = (D.log() * k).exp() * (*this)[i].pow(k);\n        P E(deg);\n        if(i * k > deg) return E;\n        auto S = i * k;\n        for(int j = 0; j + S < deg && j < D.size(); j++) E[j + S] = D[j];\n        return E;\n      }\n    }\n    return *this;\n  }\n\n  T eval(T x) const {\n    T r = 0, w = 1;\n    for(auto &v : *this) {\n      r += w * v;\n      w *= x;\n    }\n    return r;\n  }\n};\n\nusing FPS = FormalPowerSeries< modint >;\n\n// fにa * x^n + bを掛ける\nvoid mul_simple(FPS &f,modint a ,int n, modint b){\n  for(int i = (int)f.size() - 1 ; i >= 0 ; i--){\n    f[i] *= b;\n    if(i >= n) f[i] += f[i - n] * a; \n  }\n}\n\n// fからa * x^n + bを割る\nvoid div_simple(FPS &f,modint a,int n,modint b){\n  for(int i = 0 ; i < (int)f.size() ; i++){\n    f[i] /= b;\n    if(i + n < (int)f.size() ) f[n + i] -= f[i] * a; \n  }\n}\n\n// f / gをdeg(f)次まで求める\nFPS div_(FPS &f , FPS g){\n  int n = f.size();\n  return (f * g.inv(n)).pre(n);\n}\n\n\n// solve関数内で\n//\n// FPS::set_fft(mul);\n//\n// とすること。\n\n/**\nNumberTheoreticTransform<MOD> ntt;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret =ntt.multiply_for_fps(a , b);\n  return FPS::P(ret.begin(), ret.end());\n};\n/*///\nArbitraryModConvolution< modint > fft;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret = fft.multiply(a, b);\n  return FPS::P(ret.begin(), ret.end());\n};\n//*/\n\n// 下記のリンクを実装(kitamasa法のモンゴメリ乗算を使わない版)\n// http://q.c.titech.ac.jp/docs/progs/polynomial_division.html\n// k項間漸化式のa_Nを求める O(k log k log N)\n// N ... 求めたい項　(0-indexed)\n// Q ... 漸化式 (1 - \\sum_i c_i x^i)の形\n// a ... 初期解 (a_0 , a_1 , ... , a_k-1)\n// x^N を fでわった剰余を求め、aと内積を取る\nmodint kitamasa(ll N, FPS &Q, FPS &a){\n  int k = Q.size() - 1;\n  assert( (int)a.size() == k );\n  FPS P = a * Q; P.resize(k);\n  while(N){\n    auto Q2 = Q;\n    for(int i = 1; i < (int)Q2.size(); i += 2) Q2[i].x = MOD - Q2[i].x;\n    auto S = P * Q2;\n    auto T = Q * Q2;\n    if(N & 1){\n      for(int i = 1 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    else{\n      for(int i = 0 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    N >>= 1;\n  }\n  return P[0];\n}\n\nvoid solve(){\n  ini(N , M);\n  ins(S);\n  auto run = RunLengthEncoding(S);\n  if(run.size() == 1){\n    // DP\n    V<mint> dp(N),ep(N),fp(N),gp(N);\n    // [0]がR\n    // -> [1],[-1]はどちらでもよい\n    dp[0] = gp[0] = 1;\n    rep1(i , N - 1){\n      dp[i] = dp[i - 1] + ep[i - 1];\n      ep[i] = dp[i - 1];\n      fp[i] = fp[i - 1] + gp[i - 1];\n      gp[i] = fp[i - 1];\n    }\n    out(dp[N-1] + ep[N-1] + fp[N-1]);\n    return;\n  }\n  if(N % 2 == 1){\n    out(0);\n    return;\n  }\n  FPS::set_fft(mul);\n  // rの最小値\n  int r = inf , b = inf;\n  each(p , run){\n    if(p.first == 'R') amin(r , (p.second%2==0 ? p.second+1:p.second));\n    if(p.first == 'B') amin(b , (p.second%2==0 ? p.second+1:p.second));\n  }\n  trc(r , b);\n\n  FPS f({1});\n  auto nyaan = [&](ll n,int flg = false) -> FPS{\n    FPS ret(n + 1);\n    for(int i = 1 ; i <= n ; i += 2) ret[i] = (flg ? i : 1);\n    return ret;\n  };\n  trc(f);\n  f *= nyaan(r);\n  f *= nyaan(b);\n  trc(f);\n  f = FPS({1}) - f;\n  if((int)f.size() <= N) f.resize(N + 2);\n  f = f.inv();\n  f *= nyaan(r,1) * nyaan(b) + nyaan(b,1) * nyaan(r); \n  trc(f);\n  out(f[N]);\n  \n  /*\n  //trc(f);\n  // 倍数包除\n  for(int i = 2 ; i <= N ; i++){\n    // i番目は？\n    //引こう！\n    for(int j = 2 ; i * j <= N ; j++){\n      f[i * j] -= f[i];\n    }\n  }\n  trc(f);\n  */\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=200005,mod=1e9+7;\nint n,m,c[N],k,lst,f[N],pfx[N],ans; char s[N];\ninline int sum(CI x,CI y)\n{\n\tint t=x+y; return t>=mod?t-mod:t;\n}\nnamespace SP //one char solver\n{\n\tint f[N][2][2];\n\tinline int solve(void)\n\t{\n\t\tf[1][0][0]=f[1][1][1]=1; for (RI i=2;i<=n;++i)\n\t\tf[i][0][0]=sum(f[i-1][0][0],f[i-1][0][1]),f[i][0][1]=f[i-1][0][0],\n\t\tf[i][1][0]=sum(f[i-1][1][0],f[i-1][1][1]),f[i][1][1]=f[i-1][1][0];\n\t\treturn sum(f[n][0][0],sum(f[n][0][1],f[n][1][0]));\n\t}\n};\nint main()\n{\n\tRI i; for (scanf(\"%d%d%s\",&n,&m,s+1),lst=1,i=2;i<=n;++i)\n\tif (s[i]!=s[i-1]) c[++k]=i-lst,lst=i; c[++k]=n-lst+1;\n\tif (k==1) return printf(\"%d\",SP::solve()),0; if (n&1) return puts(\"0\"),0;\n\tif (k&1) --k; int lim=c[1]+1; for (i=3;i<=k;i+=2) if (c[i]&1) lim=min(lim,c[i]);\n\tfor (n>>=1,lim=lim+1>>1,f[0]=pfx[0]=i=1;i<=n;++i)\n\tf[i]=sum(pfx[i-1],mod-(i-1-lim>=0?pfx[i-1-lim]:0)),\n\tpfx[i]=sum(pfx[i-1],f[i]); for (i=1;i<=min(n,lim);++i)\n\tans=sum(ans,2LL*f[n-i]*i%mod); return printf(\"%d\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nchar str[200005];\nint arr[200005];\nlong long MOD=1000000007;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",str);\n\tfor(int i=0;i<m;i++)if(str[i]=='R')arr[i]=0;else arr[i]=1;\n\tbool all[2];all[0]=all[1]=1;\n\tfor(int i=0;i<m;i++)all[arr[i]^1]=0;\n\tif(all[0]||all[1]){\n\t\tlong long dp[2][n];memset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;dp[1][0]=0; //start with red (or blue if everything is blue)\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tlong long ans=(dp[0][n-1]+dp[1][n-1])%MOD; //end with red or blue\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=0;dp[1][0]=1; //start with blue\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tans+=dp[0][n-1];ans%=MOD;ans+=MOD;ans%=MOD; //only end with red\n\t\tprintf(\"%lld\",ans);\n\t\treturn 0;\n\t}\n\tif(n%2!=0){printf(\"0\");return 0;}\n\tint mxl=(int)MOD; //large number\n\tint st=1,cur=0;\n\tfor(int i=1;i<m;i++){\n\t\tif(arr[i]==arr[0]){\n\t\t\tif(st!=-1)st++;\n\t\t\telse cur++;\n\t\t}else{\n\t\t\tif(st!=-1){\n\t\t\t\tmxl=st|1; //+1 if even\n\t\t\t\tst=-1;\n\t\t\t}else{\n\t\t\t\tif(cur%2!=0)mxl=min(mxl,cur);\n\t\t\t\tcur=0;\n\t\t\t}\n\t\t}\n\t}\n\tmxl=min(mxl,n-1);\n\t//comments: wlog red is first\n\t//can ignore last segment of red\n\tn/=2; mxl/=2; //remove the ones that are different parity from blue\n\tlong long dp[100005],pref[100005];\n\tmemset(dp,0,sizeof(dp));memset(pref,0,sizeof(pref));\n\t//i segments on a line, first and last are blue, max mxl consecutive reds\n\t//blues may be consecutive because the reds in between were removed\n\tdp[1]=pref[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tdp[i]=pref[i-1]-pref[max(0,i-(mxl+2))];\n\t\tdp[i]%=MOD;dp[i]+=MOD;dp[i]%=MOD;\n\t\tpref[i]=dp[i]+pref[i-1];\n\t\tpref[i]%=MOD;pref[i]+=MOD;pref[i]%=MOD;\n\t}\n\tlong long ans=0;\n\tfor(long long i=2;i<=min(n,mxl+2);i++){\n\t\tans+=(i-1LL)*dp[n-i+2];\n\t\tans%=MOD;\n\t}\n\tans+=MOD;ans%=MOD;\n\tprintf(\"%lld\",(ans*2)%MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) FOR(i,0,b)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n#define fs first\n#define sc second\n\ntemplate<class T> using V=vector<T>;\ntemplate<class T> using VV=V<V<T>>;\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\trep(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"(\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\")\";\n}\n\nll read(){\n\tll i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconstexpr ll TEN(int n){\n\treturn n==0?1:TEN(n-1)*10;\n}\n\ntemplate<class T>\nvector<T> Uniqued(const vector<T>&vv){\n\tauto v(vv);\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n\treturn v;\n}\ntemplate<class T>\nvoid MakeUniqued(vector<T>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tstatic constexpr int base=mod;\n\tint v;\n\tModInt():v(0){}\n\tModInt(ll vv){\n\t\tv=vv%mod;\n\t\tif(v<0)v+=mod;\n\t}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n\texplicit operator int()const{\n\t\treturn v;\n\t}\n\tbool operator==(const ModInt&rhs)const{\n\t\treturn v==rhs.v;\n\t}\n\tbool operator!=(const ModInt&rhs)const{\n\t\treturn v!=rhs.v;\n\t}\n\tModInt operator-()const{\n\t\treturn ModInt(0)-*this;\n\t}\n\tModInt& operator+=(const ModInt&rhs){\n\t\tv+=rhs.v;\n\t\tif(v>=mod)v-=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator-=(const ModInt&rhs){\n\t\tv-=rhs.v;\n\t\tif(v<0)v+=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator*=(const ModInt&rhs){\n\t\tv=ll(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tModInt&operator/=(const ModInt&rhs){\n\t\toperator*=(rhs.inv());\n\t\treturn *this;\n\t}\n\tModInt operator+(const ModInt&rhs)const{\n\t\treturn ModInt(*this)+=rhs;\n\t}\n\tModInt operator-(const ModInt&rhs)const{\n\t\treturn ModInt(*this)-=rhs;\n\t}\n\tModInt operator*(const ModInt&rhs)const{\n\t\treturn ModInt(*this)*=rhs;\n\t}\n\tModInt operator/(const ModInt&rhs)const{\n\t\treturn ModInt(*this)/=rhs;\n\t}\n\tfriend ModInt operator+(int x,const ModInt&y){\n\t\treturn ModInt(x)+y;\n\t}\n\tfriend ModInt operator-(int x,const ModInt&y){\n\t\treturn ModInt(x)-y;\n\t}\n\tfriend ModInt operator*(int x,const ModInt&y){\n\t\treturn ModInt(x)*y;\n\t}\n\tfriend ModInt operator/(int x,const ModInt&y){\n\t\treturn ModInt(x)/y;\n\t}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tModInt inv()const{\n\t\treturn pow(mod-2);\n\t}\n};\n\ntemplate<int mod>\nostream& operator<<(ostream&os,const ModInt<mod>&m){\n\treturn os<<m.v;\n}\ntemplate<int mod>\nvoid print(const ModInt<mod>&m,int suc=1){\n\tprint(m.v,suc);\n}\n\nusing mint=ModInt<1000000007>;\n//using mint=ModInt<998244353>;\n\nconst int Vmax=min<int>(2000010,mint::base);\nmint fact[Vmax],factInv[Vmax],invs[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfactInv[Vmax-1]=fact[Vmax-1].inv();\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1]*(i+1);\n\t}\n\tfor(int i=Vmax-1;i>=1;i--){\n\t\tinvs[i]=factInv[i]*fact[i-1];\n\t}\n}\nstruct InitFactDummy{\n\tInitFactDummy(){\n\t\tInitFact();\n\t}\n} initFactDummy;\nmint Choose(int n,int k){\n\treturn fact[n]*factInv[n-k]*factInv[k];\n}\nmint Binom(int a,int b){\n\treturn fact[a+b]*factInv[a]*factInv[b];\n}\nmint Catalan(int n){\n\treturn Binom(n,n)-(n-1>=0?Binom(n-1,n+1):0);\n}\n\nV<mint> getDP(int m,int a,int b){\n\tV<mint> dp(m+1),sum(m+1);\n\tdp[0]=sum[0]=1;\n\tFOR(i,1,m+1){\n\t\tmint w;\n\t\tif(i-a>=0)w+=sum[i-a];\n\t\tif(i-b-1>=0)w-=sum[i-b-1];\n\t\tdp[i]=w;\n\t\tsum[i]=sum[i-1]+dp[i];\n\t}\n\treturn dp;\n}\n\nsigned main(){\n\tint n=read(),m=read();\n\tstring s=readString();\n\tif(s[0]!='R'){\n\t\tfor(auto&c:s){\n\t\t\tc='R'+'B'-c;\n\t\t}\n\t}\n\tif(s==string(n,'R')){\n\t\tauto dp=getDP(n,2,inf);\n\t\tmint ans=1;\n\t\tfor(int k=1;k<=n-1;k++){\n\t\t\tint rem=n-k-1;\n\t\t\tans+=dp[rem]*(k+1);\n\t\t}\n\t\tprint(ans);\n\t\treturn 0;\n\t}\n\tint lim=n-1;\n\tif(lim%2==0)lim--;\n\tfor(int i=0;i<m;){\n\t\tif(s[i]=='R'){\n\t\t\tint len=0;\n\t\t\twhile(i+len<m&&s[i+len]=='R')\n\t\t\t\tlen++;\n\t\t\ti+=len;\n\t\t\tif(i<m&&len%2)\n\t\t\t\tchmin(lim,len);\n\t\t\tif(i==len&&len%2==0)\n\t\t\t\tchmin(lim,len+1);\n\t\t}else{\n\t\t\ti++;\n\t\t}\n\t}\n\tconst int L=(lim+1)/2;\n\tauto dp=getDP(n,1,L);\n\tcerr<<L<<endl;\n\tcerr<<dp<<endl;\n\tmint ans;\n\tfor(int k=1;k<=lim;k+=2){\n\t\tint rem=(n-k-1);\n\t\tcerr<<rem<<endl;\n\t\tif(rem%2)continue;\n\t\tmint w=dp[rem/2];\n\t\tans+=w*(k+1);\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PI 3.14159265358979323846264338327950288419\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint n, m;\nint col[200005];\n\nint expo(int a, int b){\n\tint c = 1, d = a;\n\twhile(b){\n\t\tif(b & 1){\n\t\t\tc = 1LL * c * d % mod;\n\t\t}\n\t\td = 1LL * d * d % mod;\n\t\tb >>= 1;\n\t}\n\treturn c;\n}\n\nint inv(int x){\n\treturn expo(x, mod - 2);\n}\n\nint calc(int n){\n\t\n\tint fib[200005];\n\tfib[1] = fib[2] = 1;\n\tfor(int i = 3; i <= n + 1; i++){\n\t\tfib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t}\n\t\n\t// force first one to be 1, last one to be 0: fib[n - 1]\n\t// force first one to be 0: fib[n + 1]\n\treturn (fib[n - 1] + fib[n + 1]) % mod;\n}\n\nint calc2(int n, int ub){\n\tassert(ub & 1);\n\t\n\t// want a bunch of numbers, in [2, ub], to sum to n\n\t\n\tub++;\n\tub = min(ub, n); // coz it can actually be HUGE\n\t\n\tint dp[200005]; // dp[i]: number of possible sums, that sum to i\n\tint cumu[200005];\n\t\n\tdp[0] = 1;\n\tcumu[0] = 1;\n\t\n\tfor(int i = 2; i <= n; i += 2){\n\t\t// sum from dp[l_index .. i - 2].. oh, only the even ones!\n\t\tint l_index = i - ub;\n\t//\tprintf(\"%d: sum %d..%d\\n\", i, l_index, r_index);\n\t\tdp[i] = cumu[i - 2];\n\t\t\n\t\tif(l_index > 0){\n\t\t\tdp[i] -= cumu[l_index - 2];\n\t\t\tif(dp[i] < 0){\n\t\t\t\tdp[i] += mod;\n\t\t\t}\n\t\t}\n//\t\tprintf(\"%d: %d\\n\", i, dp[i]);\n\t\tcumu[i] = (cumu[i - 2] + dp[i]) % mod;\n\t}\n\t\n\tint ret = 0;\n\t\n\tfor(int space = 0; space < ub; space++){\n\t\t// last 1 is at (n - space), leaving _ space at the end\n\t\t// where can the first 1 be?\n\t\tint left_pos = 1;\n\t\tint right_pos = ub - space;\n\t\t\n\t\tint most_remain = (n - space) - 1;\n\t\tint least_remain = n - ub;\n\t\t\n\t\tif(most_remain & 1) most_remain--;\n\t\t\n\t\tint combin = cumu[most_remain];\n\t\tif(least_remain > 0){\n\t\t\tcombin = (combin - cumu[least_remain - 2] + mod) % mod;\n\t\t}\n\t\tret = (ret + combin) % mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= m; i++){\n\t\tchar c;\n\t\tscanf(\" %c\", &c);\n\t\tcol[i] = (c == 'B');\n\t}\n\t\n\tif(col[1] != 0){\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tcol[i] = 1 - col[i];\n\t\t}\n\t}\n\t\n\t// WLOG first one is 0\n\tbool monochrome = true;\n\tfor(int i = 2; i <= m; i++){\n\t\tif(col[i]){\n\t\t\tmonochrome = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(monochrome){\n\t\t// ok as long as 1s are not adjacent\n\t\tprintf(\"%d\\n\", calc(n));\n\t\treturn 0;\n\t}else{\n\t\t// 00...010..010..0\n\t\t// each block of 0 is of add length\n\t\t// so, n odd -> definitely no solution\n\t\t// more conditions depending on specifics of col[]\n\t\tif(n % 2 == 1){\n\t\t \tprintf(\"0\\n\");\n\t\t \treturn 0;\n\t\t}\n\t\tint first_run = 0, subseq_run = n - 1;\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tint len = 0;\n\t\t\twhile(i + len <= m && col[i + len] == 0){\n\t\t \t\tlen++;\n\t\t \t}\n\t\t \tif(first_run == 0){\n\t\t \t\tfirst_run = len;\n\t\t \t}else if(len & 1){\n\t\t \t\tsubseq_run = min(subseq_run, len);\n\t\t \t}\n\t\t \ti += len;\n\t\t}\n\t\tint ub = first_run + (first_run % 2 == 0);\n\t\tub = min(ub, subseq_run);\n\t\tprintf(\"%d\\n\", calc2(n, ub));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200010;\nconst int mod = 1e9 + 7;\n\ntypedef long long LL;\n\nchar s[N];\n\nint f[N], g[N], dp[2][2][N];\n\nint main() {\n    int n, m; scanf(\"%d%d%s\", &n, &m, s + 1);\n    bool flag = false;\n    for (int i = 1; i <= m; i++) if (s[i] != s[1]) {\n        flag = true; break;\n    } \n    if (flag) {\n        if (n & 1) return puts(\"0\"), 0;\n        int fir = 0;\n        for (int i = 1; i <= n; i++) if (s[i] != s[1]) {\n            fir = i - 1; break;\n        }\n        int lim = fir | 1;\n        for (int i = fir + 1; i <= n; i++) if (s[i] != s[1]) {\n            int j = i + 1;\n            while (j <= n && s[j] == s[1]) j++;\n            if (j <= n && (j - i - 1) % 2 == 1) lim = min(lim, j - i - 1); \n        } \n        n /= 2, lim = (lim + 1) / 2;\n        for (int i = 1; i <= lim; i++) f[i] = i * 2;\n        for (int i = 1, diff = 0; i <= n; i++) {\n            diff = (diff + g[i]) % mod, f[i] = (f[i] + diff) % mod;\n            if (i + 1 <= n) g[i + 1] = (g[i + 1] + f[i]) % mod;\n            if (i + lim + 1 <= n) g[i + lim + 1] = (g[i + lim + 1] - f[i] + mod) % mod;\n        }\n        printf(\"%d\\n\", f[n]);\n    } else {\n        dp[1][1][1] = dp[0][0][1] = 1;\n        for (int i = 2; i <= n; i++) \n            for (int t = 0; t <= 1; t++) {\n                dp[t][0][i] = (dp[t][1][i - 1] + dp[t][0][i - 1]) % mod;\n                dp[t][1][i] = dp[t][0][i - 1];\n            }\n        printf(\"%d\\n\", ((LL)dp[1][0][n] + dp[0][0][n] + dp[0][1][n]) % mod);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Dmitry _kun_ Sayutin (2019)\n\n#include <bits/stdc++.h>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::tuple;\nusing std::make_tuple;\nusing std::get;\n\nusing std::min;\nusing std::abs;\nusing std::max;\nusing std::swap;\n\nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n\n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n\ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n\ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n\n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n\nconst int mod = 1000 * 1000 * 1000 + 7;\nint add(int a, int b) {\n    return (a + b >= mod ? a + b - mod : a + b);\n}\n\nint sub(int a, int b) {\n    return (a >= b ? a - b : mod + a - b);\n}\n\nint mult(int a, int b) {\n    return (int64_t(a) * b) % mod;\n}\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    // code here\n    int n = input<int>();\n    int m = input<int>();\n    \n    string s = input<string>();\n\n    if (s[0] == 'B')\n        for (int i = 0; i != m; ++i)\n            s[i] = ('R' + 'B' - s[i]);\n\n    if (std::find(ALL(s), 'B') == s.end()) {\n        int ans = 0;\n        \n        for (int fst = 0; fst != 2; ++fst) {\n            pair<int, int> cur_dp = {0, 0};\n\n            if (fst == 0)\n                cur_dp.first += 1;\n            else\n                cur_dp.second += 1;\n\n            for (int i = 0; i != n - 1; ++i) {\n                pair<int, int> newdp = {0, 0};\n                newdp.first = cur_dp.second;\n                newdp.second = add(cur_dp.first, cur_dp.second);\n\n                cur_dp = newdp;\n            }\n\n            if (fst == 1)\n                ans = add(ans, add(cur_dp.first, cur_dp.second));\n            else\n                ans = add(ans, cur_dp.second);\n        }\n\n        cout << ans << \"\\n\";\n        return 0;\n    } else {\n        vector<int> lens = {1};\n        assert(s[0] == 'R');\n\n        for (int i = 1; i != m; ++i)\n            if (s[i] == 'R' and s[i - 1] == 'R')\n                lens.back() += 1;\n            else if (s[i] == 'R')\n                lens.push_back(1);\n\n        int limit = 1000 * 1000 * 1000 + 1;\n        \n        for (int len: lens)\n            if (len % 2 == 0)\n                limit = min(limit, len + 1);\n            else\n                limit = min(limit, len);\n\n        // dp[k]: start with 0, end with zero, length k.\n        vector<int> dp(n + 5);\n        vector<int> dp_sum(n + 5);\n\n        dp[0] = 0;\n        dp[1] = 1;\n\n        dp_sum[0] = 0;\n        dp_sum[1] = 1;\n        for (int p = 2; p < SZ(dp); ++p) {\n            // for (int last = 1; last <= limit and last + 1 <= p; last += 2)\n            //     dp[p] = add(dp[p], dp[p - 1 - last]);\n\n            int upto = min(limit, p - 1);\n            if (upto % 2 == 0)\n                --upto;\n\n            dp[p] = dp_sum[p - 2];\n\n            if (p - upto - 3 >= 0)\n                dp[p] = sub(dp[p], dp_sum[p - upto - 3]);\n\n            dp_sum[p] = add(dp_sum[p - 2], dp[p]);\n        }\n\n        int ans = 0;\n        for (int beg = 1; beg <= n - 1 and beg <= limit; beg += 2)\n            ans = add(ans, mult(beg + 1, dp[n - beg]));\n\n        cout << ans << \"\\n\";\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst int maxn = 210000;\nconst i64 P = 1000000000 + 7;\ni64 dp[2][2][maxn];\n\nvoid add(i64 &x, i64 y) {\n    x += y;\n    x %= P;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int n, l;\n    string s;\n    cin >> n >> l >> s;\n    char c0 = s[0], c1 = c0 ^ 'R' ^ 'B';\n    if (s == string(n, c0)) {\n        forn(i, 2) dp[i][i][1] = 1;\n        for1(i, n - 1) forn(f, 2) forn(j, 2) forn(k, 2) {\n            if (j && k) continue;\n            add(dp[f][k][i + 1], dp[f][j][i]);\n        }\n        i64 ans = 0;\n        forn(f, 2) forn(j, 2) {\n            if (f && j) continue;\n            add(ans, dp[f][j][n]);\n        }\n        cout << ans << '\\n';\n        return 0;\n    }\n\n    if (n % 2) {\n        cout << 0 << '\\n';\n        return 0;\n    }\n\n    vector<pair<int, char> > cl;\n    pii p = {1, c0};\n    for1(i, n - 1) {\n        if (s[i] == p.se) ++p.fi;\n        else cl.pb(p), p = {1, s[i]};\n    }\n\n    int ub = n / 2;\n    if (cl[0].fi % 2 == 0) ub = cl[0].fi + 1;\n    for (auto w: cl) if (w.se == c0 && w.fi % 2) uin(ub, w.fi);\n    ub /= 2;\n\n    vi64 vals(n / 2 + 1), svals(n / 2 + 2);\n    vals[0] = 1;\n    svals[1] = 1;\n//    cerr << ub << '\\n';\n    for1(i, n / 2) {\n        vals[i] = svals[i] - svals[max(i - ub - 1, 0)];\n        vals[i] %= P;\n//        cerr << i << ' ' << vals[i] << '\\n';\n        svals[i + 1] = (svals[i] + vals[i]) % P;\n    }\n\n    i64 ans = vals[n / 2];\n    for1(i, ub) if (i + 1 <= n / 2) add(ans, vals[n / 2 - i - 1] * i);\n    ans *= 2;\n    ans %= P;\n    if (ans < 0) ans += P;\n    cout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+10;\nconst int mod=1e9+7;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nvoid inc(int &a,int b) {\n\ta=a+b>=mod?a+b-mod:a+b;\n}\n\nint n,m,f[N];\nchar s[N];\n\nint main() {\n\tcin>>n>>m;\n\tscanf(\"%s\",s+1);\n\tint p=m+1;\n\tfor(int i=2;i<=m;i++)\n\t\tif(s[1]!=s[i]) { p=i;break; }\n\tif(p==m+1) {\n\t\tf[0]=1;\n\t\tfor(int i=2,s=1;i<=n;i++) {\n\t\t\tf[i]=s;inc(s,f[i-1]);\n\t\t}\n\t\tint ans=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t\tans=(ans+1ll*i*f[n-i])%mod;\n\t\tcout<<ans;\n\t}\n\telse {\n\t\t--p;int mx=p+!(p&1),len=0;\n\t\tfor(int i=p+1;i<=m;i++) {\n\t\t\tif(s[i]==s[1]) ++len;\n\t\t\telse {\n\t\t\t\tif(len&1) mx=min(mx,len);\n\t\t\t\tlen=0;\n\t\t\t}\n\t\t}\n\t\t++mx;f[0]=1;\n\t\tfor(int i=2,s=1;i<=n;i+=2) {\n\t\t\tf[i]=s;\n\t\t\tif(i>=mx) inc(s,mod-f[i-mx]);\n\t\t\tinc(s,f[i]);\n\t\t\t//cerr<<i<<' '<<f[i]<<endl;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=2;i<=mx;i+=2)\n\t\t\tans=(ans+1ll*i*f[n-i])%mod;\n\t\tcout<<ans;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,a,b) for (int i=(int)(a); i<(int)(b); ++i)\n#define repeq(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define rrep(i,a,b) for (int i=(int)(a)-1; i>=(int)(b); --i)\n#define rrepeq(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\ntemplate<> struct is_plural<string> : true_type{};\n\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n\nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\ntemplate<uint_fast64_t Modulus = MOD>\nstruct Modint {\n  using u64 = uint_fast64_t;\n  u64 a;\n\n  constexpr Modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n\n  constexpr Modint operator+(const Modint rhs) const noexcept {\n    return Modint(*this) += rhs;\n  }\n  constexpr Modint operator-(const Modint rhs) const noexcept {\n    return Modint(*this) -= rhs;\n  }\n  constexpr Modint operator*(const Modint rhs) const noexcept {\n    return Modint(*this) *= rhs;\n  }\n  constexpr Modint operator/(const Modint rhs) const noexcept {\n    return Modint(*this) /= rhs;\n  }\n\n  constexpr Modint &operator+=(const Modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) a -= Modulus;\n    return *this;\n  }\n  constexpr Modint &operator-=(const Modint rhs) noexcept {\n    if (a < rhs.a) a += Modulus;\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr Modint &operator*=(const Modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr Modint &operator/=(Modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp & 1) *this *= rhs;\n      rhs *= rhs;\n      exp >>= 1;\n    }\n    return *this;\n  }\n\n  Modint pow(u64 t) const {\n    if (!t) return 1;\n    Modint x = pow(t>>1);\n    x *= x;\n    if (t&1) x *= *this;\n    return x;\n  }\n\n  explicit operator bool() const {\n    return a;\n  }\n\n  friend ostream &operator<<(ostream &os, const Modint &m) {\n    return os << m.a;\n  }\n};\n\nusing mint = Modint<>;\n\ntemplate<typename T>\nvector<pair<T, int>> prime_factor(T num) {\n  vector<pair<T, int>> ret;\n  for (T i=2; i*i<=num; ++i) {\n    int cnt = 0;\n    while (num%i == 0) {\n      num /= i;\n      ++cnt;\n    }\n    if (cnt != 0) ret.emplace_back(i, cnt);\n  }\n  if (num != 1) ret.emplace_back(num, 1);\n  return ret;\n}\n\n// if (srt > 0), sorted by ascending order. else if (srt < 0), sorted by descending order.\ntemplate<typename T>\nvector<T> divisor(const vector<pair<T, int>> &pf, int srt = 0) {\n  vector<T> ret;\n  ret.emplace_back(1);\n  for (auto &p : pf) {\n    int sz = ret.size();\n    T x; int y;\n    tie(x,y) = p;\n    T d = 1;\n    for (int i=0; i<y; ++i) {\n      d *= x;\n      for (int j=0; j<sz; ++j) {\n        ret.emplace_back(d * ret[j]);\n      }\n    }\n  }\n  if (srt > 0) sort(ret.begin(), ret.end());\n  else if (srt < 0) sort(ret.rbegin(), ret.rend());\n  return ret;\n}\n\ntemplate<typename T>\nvector<T> divisor(const T &num, int srt = 0) {\n  auto pf = prime_factor(num);\n  return divisor(pf, srt);\n}\n\nvoid solve() {\n  int n, m; cin >> n >> m;\n  string s; cin >> s;\n\n  int MAX = m;\n  int now = 0;\n  rep(i,0,m) {\n    if (s[i] == s[0]) {\n      ++now;\n    } else {\n      if (MAX == m) {\n        MAX = now | 1;\n      } else if (now & 1) {\n        chmin(MAX, now);\n      }\n      now = 0;\n    }\n  }\n\n  if (MAX == m) {\n    Graph<mint> dp(n, vector<mint>(2, 0));\n    dp[0][1] = 1;\n\n    rep(i,1,n) {\n      dp[i][0] = dp[i-1][0] + dp[i-1][1];\n      dp[i][1] = dp[i-1][0];\n    }\n\n    mint ans = dp[n-1][0];\n\n    dp.assign(n, vector<mint>(2, 0));\n    dp[0][0] = 1;\n\n    rep(i,1,n) {\n      dp[i][0] = dp[i-1][0] + dp[i-1][1];\n      dp[i][1] = dp[i-1][0];\n    }\n\n    ans += dp[n-1][0] + dp[n-1][1];\n\n    cout << ans << endl;\n    return;\n  }\n\n  if (n & 1) {\n    cout << 0 << endl;\n    return;\n  }\n\n  n /= 2;\n  (MAX /= 2) += 1;\n\n  auto div = divisor(n, 1);\n  vector<pair<int, mint>> memo;\n\n  for (auto &d : div) {\n    vector<mint> dp(d+1, 0);\n    dp[0] = 1;\n    mint now = 1;\n\n    repeq(i,1,d) {\n      now += dp[i] = now;\n      if (i >= MAX) now -= dp[i - MAX];\n    }\n\n    vector<mint> sum(d+2, 0);\n    rep(i,1,d+2) sum[i] = sum[i-1] + dp[i-1];\n\n    mint tmp = dp[d];\n    int MIN = min(MAX, d);\n    rep(i,1,MIN) {\n      tmp += sum[d-i] - sum[d-MIN];\n    }\n\n    memo.emplace_back(d, tmp);\n  }\n\n  int sz = memo.size();\n\n  rep(i,0,sz) {\n    rep(j,i+1,sz) {\n      if (memo[j].first % memo[i].first == 0) {\n        memo[j].second -= memo[i].second;\n      }\n    }\n  }\n\n  mint ans = 0;\n  for (auto &p : memo) {\n    ans += p.second;\n  }\n  cout << ans * 2 << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nLL dp[SIZE][2][2];\nvoid solve_same(int N){\n    dp[1][0][0]=1;\n    dp[1][1][1]=1;\n    REPP(i,1,N){\n        REP(j,2){\n            ADD(dp[i+1][j][0],dp[i][j][1]);\n            ADD(dp[i+1][j][1],dp[i][j][0]);\n            ADD(dp[i+1][j][1],dp[i][j][1]);\n        }\n    }\n    LL an=0;\n    ADD(an,dp[N][0][1]);\n    ADD(an,dp[N][1][1]);\n    ADD(an,dp[N][1][0]);\n    W(an);\n}\nLL mypow(LL x,LL y){\n    x%=MOD;\n    LL res=1%MOD;\n    while(y){\n        if(y&1)res=res*x%MOD;\n        y>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nLL dp2[SIZE],dp2_sum[SIZE];\nvoid solve(int ma,int N){\n    LL an=0;\n    if(ma+1>=N){\n        ADD(an,(mypow(2,N/2)-1)*2);\n    }\n    else{\n        ma=(ma+1)/2;\n        dp2[0]=dp2_sum[0]=1;\n        FOR(i,1,N/2){\n            dp2_sum[i]=dp2_sum[i-1];\n            dp2[i]=dp2_sum[i-1];\n            if(i>ma)ADD(dp2[i],-dp2_sum[i-ma-1]);\n            ADD(dp2_sum[i],dp2[i]);\n        }\n        ADD(an,dp2[N/2]);\n        FOR(i,2,ma){\n            ADD(an,(i-1)*dp2[N/2-i]);\n        }\n        ADD(an,an);\n    }\n    W(an);\n}\nint main(){\n    int N,M; R(N,M);\n    string s; R(s);\n    bool same=1;\n    REPP(i,1,M){\n        if(s[i]!=s[i-1])same=0;\n    }\n    if(same)solve_same(N);\n    else{\n        if(N%2){\n            W(0);\n            return 0;\n        }\n        VI AA;\n        for(int i=0,j;i<M;i=j){\n            for(j=i+1;j<M&&s[j]==s[i];j++);\n            if(s[i]==s[0])AA.PB(j-i);\n        }\n        int ma=-1;\n        if(AA[0]%2)ma=AA[0];\n        else ma=AA[0]+1;\n        REPP(i,1,SZ(AA)){\n            if(AA[i]%2==1)ma=min(ma,AA[i]);\n        }\n        solve(ma,N);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n;i++){\n        dp[i-1] = dp[i];\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        tmp[i] = dp[n-i];\n    }\n    for(int i = limit-1;i >= 0;i--){\n        tmp[i] += tmp[i+1];\n        tmp[i] %= MOD;\n    }\n    for(int i = 1;i <= limit;i++){\n        res = (res + tmp[i] * 2) % MOD;\n    }\n    return res;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    bool ok = true;\n    for(auto elem:vec)ok &= elem == 0;\n    if(ok){\n        cout << all(n) << endl;\n        return 0;\n    }\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    vec.push_back(1);\n    for(int i = 0;i <= n;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=401000;\nchar s[N];\nint n,m;\n\nll dp[N],sdp[N],ans;\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s);\n\tbool mono=1;\n\trep(i,0,m) mono&=s[i]==s[0];\n\tif (mono) {\n\t\tint a=2,b=1;\n\t\trep(i,1,n) {\n\t\t\ta=(a+b)%mod;\n\t\t\tswap(a,b);\n\t\t}\n\t\tprintf(\"%d\\n\",b);\n\t\treturn 0;\n\t}\n\tint sR=2*n+1,sB=1;\n\tif (s[0]=='B') {\n\t\trep(i,0,m) if (s[i]=='R') s[i]='B'; else s[i]='R';\n\t}\n\trep(l,0,m) {\n\t\tint r=l;\n\t\twhile (r<m&&s[r]==s[l]) r++;\n\t\tint len=r-l;\n\t\tif (len%2==0) {\n\t\t\tif (l==0) len=len+1;\n\t\t\telse len=2*n+1;\n\t\t}\n\t\tif (r==m) break;\n\t\tif (s[l]=='R') sR=min(sR,len);\n\t\telse sB=min(sB,len);\n\t\tl=r-1;\n\t}\n\tif (n%2==1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n//\tprintf(\"%d %d\\n\",sR,sB);\n\tauto solve=[&](int sR,int sB) {\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(sdp,0,sizeof(sdp));\n\t\tdp[0]=1;\n\t\tsdp[2]=1;\n\t\trep(i,1,n+1) {\n\t\t\tif (i%2==1) {\n\t\t\t\tdp[i]=(sdp[i+1]-sdp[max(0,i-sR)])%mod;\n\t\t\t} else {\n\t\t\t\tif (i!=n) {\n\t\t\t\t\tdp[i]=(sdp[i+1]-sdp[max(1,i-sB)])%mod;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j=1;j<=sB&&j<=i;j+=2) {\n\t\t\t\t\t\tdp[i]=(dp[i]+dp[i-j]*j)%mod;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsdp[i+2]=(sdp[i]+dp[i])%mod;\n\t\t}\n\t\tans+=dp[n];\n\t};\n\tsolve(sR,sB);\n\tsolve(sB,sR);\n\tans%=mod;\n\tif (ans<0) ans+=mod;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200010\n#define ll long long\n#define mod 1000000007\nusing namespace std;\nchar s[maxn];\nint f[maxn], pre[maxn];\nint main()\n{\n\tint n, m, mx = 0, flag = 1;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", s + 1);\n\tfor (int i = 2; i <= m; i++)\n\t\tif (s[i] != s[1]) flag = 0;\n\tif (flag == 0)\n\t{\n\t\tint st;\n\t\tfor (int i = 1; i <= m; i++)\n\t\t\tif (s[i] != s[1])\n\t\t\t{\n\t\t\t\tst = i;\n\t\t\t\tmx = i - 1;\n\t\t\t\tif (mx % 2 == 0) mx++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\twhile (st <= m)\n\t\t{\n\t\t\tint cur = st;\n\t\t\twhile (cur <= m && s[cur] == s[st]) cur++;\n\t\t\tif (cur != m + 1 && s[st] == s[1] && (cur - st) % 2) mx = min(mx, cur - st);\n\t\t\tst = cur;\n\t\t}\n\t\tif (n % 2) {puts(\"0\"); return 0;}\n\t\tn /= 2;\n\t\tmx = (mx + 1) / 2;\n\t}\n\telse mx = n;\n\tf[0] = pre[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tf[i] = pre[i - 1];\n\t\tif (i - mx - 1 >= 0) f[i] = (f[i] - pre[i - mx - 1] + mod) % mod;\n\t\tif (flag) f[i] = (f[i] - f[i - 1] + mod) % mod;\n\t\tpre[i] = (pre[i - 1] + f[i]) % mod;\n\t}\n\tint res = flag;\n\tfor (int i = flag + 1; i <= mx; i++)\n\t\tres = (res + (ll)i * f[n - i] % mod) % mod;\n\tif (flag == 0) res = (ll)res * 2 % mod;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define pld pair <ld, ld>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n#define cld complex <double>\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 3e5;\nconst ll mod = 1e9 + 7;\n\nll n, m, k, t;\n\nstring s;\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;\n}\n\nll simple() {\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    ll q;\n    for (q = 1; q < n; q++) {\n        D[q] += D[q - 1];\n        if (q >= 2) {\n            D[q] += D[q - 2];\n            D[q] %= mod;\n        }\n    }\n    return (D[n - 2] * 2 + D[n - 1]) % mod;\n    // if (n % 2 == 1) {\n    //     return \n    // }\n    // return step(2, n / 2 + 1);\n}\n\nint main() {\n    pyshnapyshnakaa\n    ll q, w, e, a, b, c;\n    cin >> n >> m;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (q = 0; q < s.length(); q++) {\n            if (s[q] == 'R') {\n                s[q] = 'B';\n            }\n            else {\n                s[q] = 'R';\n            }\n        }\n    }\n    vector <pll> A;\n    A.pb(mp(1, s[0]));\n    for (q = 1; q < s.length(); q++) {\n        if (s[q] == A.back().second) {\n            A.back().first++;\n        }\n        else {\n            A.pb(mp(1, s[q]));\n        }\n    }\n    // cout << \"FALL\" << endl;\n    bool blue = 0; /*kill = 0;*/\n    ll mx = maxn;\n    // cout << \"\"\n    for (q = 0; q < A.size(); q++) {\n        if (A[q].second == 'B') {\n            blue = 1;\n            if (A[q].first >= 2) {\n                cout << 0;\n                return 0;\n            }\n        }\n        else {\n            if (q == 0 || A[q].first % 2 == 1) {\n                // cout << q << endl;\n                mx = min(mx, A[q].first + 1 - A[q].first % 2);\n            }\n        }\n    }\n    // cout << \"MX \" << mx << endl;\n    // if (fail) {\n    //     cout << 0;\n    //     return 0;\n    // }\n    if (!blue) {\n        cout << simple();\n        return 0;\n    }\n    // ll mx = maxn, cur = 0;\n    // for (q = 0; q < s.length(); q++) {\n    //     if (s[q] == 'B') {\n    //         if (cur % 2 == 1) {\n    //             mx = min(mx, cur);\n    //         }\n    //         else {\n    //             mx = min(mx, cur + 1);\n    //         }\n    //         cur = 0;\n    //     }\n    //     else {\n    //         cur++;\n    //     }\n    // }\n    vector <ll> S(2);\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    S[0] = 1;\n    for (q = 1; q < n; q++) {\n        D[q] = S[q % 2];\n        S[q % 2] = (S[q % 2] + D[q]) % mod;\n        ll deli = q - mx - 1;\n        if (deli >= 0) {\n            // cout << \"DELETING \" << q << endl;\n            S[deli % 2] = (S[deli % 2] - D[deli] + mod) % mod;\n        }\n        // cout << q << \" \" << D[q] << endl;\n    }\n    // cout << \"mx \" << mx << endl;\n    ll ans = 0;\n    for (q = 0; q < n; q++) {\n        ll len = n - q - 1;\n        if (len % 2 == 0 || len > mx) {\n            continue;\n        }\n        ans += D[q] * (len + 1) % mod;\n        ans %= mod;\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 500008\n#define mod 1000000007\nchar str[nn];int n,m;\nint dp[nn];int sum[nn];\n#define err return 0*puts(\"0\");\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str+1);\n\t\n\tint cnt=0;\n\tif(str[1]=='B') for(int i=1;i<=m;i++) if(str[i]=='R') str[i]='B';else str[i]='R';\n\tfor(int i=1;i<=m;i++) if(str[i]=='B') cnt++;\n\tint mx=n;int flg=0;\n\tif(cnt)\n\t{\n\t\tcnt=0;\n\t\tif(n%2) err;int j=1;\n\t\tfor(int i=m;i>=1;i--)\n\t\t\tif(str[i]=='B')  {for(int j=i;j<=m;j++) str[j]='B';break;}\n\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(str[i]=='B') break;\n\t\t\tcnt++;j=i;\n\t\t}\n\t\tmx=min(mx,cnt/2+1);\n\t\t\n\t\tj++;\n\t\tcnt=0;str[m+1]='B';\n\t\tfor(;j<=m+1;j++)\n\t\t{\n\t\t\tif(str[j]=='B')\n\t\t\t{\n\t\t\t\tif(cnt%2) mx=min(mx,(cnt)/2);\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t\telse cnt++;\n\t\t}\n\t\tflg=1;\n\t\tn/=2;\n\t}\n\t\n//\tcout<<n<<\" \"<<mx<<\"\\n\";\n\t\n\tdp[0]=sum[0]=1;\n\tint ls=0;if(!flg) ls=1,sum[1]=1;\n\tfor(int i=ls+1;i<=n;i++) \n\t{\n\t\tif(i-mx-1>=0) dp[i]=(sum[i-1-ls]-sum[i-mx-1]+mod)%mod;\n\t\telse dp[i]=sum[i-1-ls];\n\t\tsum[i]=(sum[i-1]+dp[i])%mod;\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=n and i<=mx;i++)\n\t{\n\t\tans+=1ll*dp[n-i]*(i)%mod;\n\t\tif(flg) ans+=1ll*dp[n-i]*i%mod;\n\t\tans%=mod;\n\t}\n\t\n\tprintf(\"%lld\\n\",ans);\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 200000\n#define X 1000000007\nusing namespace std;\nint n,m,t,a[N+5],f[N+5],g[N+5];char s[N+5];\nint w[N+5][2];I void Work()\n{\n\t#define DP() for(RI i=2;i<=n;++i) w[i][0]=w[i-1][1],w[i][1]=(w[i-1][0]+w[i-1][1])%X;\n\tw[1][1]=1;DP();RI t=(w[n][0]+w[n][1])%X;\n\tw[1][0]=1,w[1][1]=0;DP();printf(\"%d\\n\",(t+w[n][1])%X);\n}\nint main()\n{\n\tRI i;for(scanf(\"%d%d%s\",&n,&m,s+1),i=1;i<=m;++i) s[i]^s[i-1]&&++t,++a[t];\n\tif(t&1&&--t,!t) return Work(),0;if(n&1) return puts(\"0\");\n\tRI p=a[1]+(a[1]&1^1);for(i=3;i<=t;i+=2) a[i]&1&&(p=min(p,a[i]));\n\tfor(f[0]=g[0]=1,i=2;i<=n;++i) f[i]=(g[i-2]+(i-p-3>=0?X-g[i-p-3]:0))%X,g[i]=(g[i-2]+f[i])%X;\n\tRI res=0;for(i=2;i<=p+1&&i<=n;++i) res=(1LL*i*f[n-i]+res)%X;return printf(\"%d\\n\",res),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int mod = 1000000007;\nchar s[200001];\nlong long dp[200001][2];\nlong long dp2[200001][2];\n\nint main() {\n    int n, m, c, i, j;\n    long long ans = 0;\n    vector <int> v, w;\n    \n    scanf(\"%d %d\", &n, &m);\n    scanf(\"%s\", s);\n    \n    for (i = 0; i < m; ) {\n        for (j = i; j < m; j++) {\n            if (s[i] != s[j]) break;\n        }\n        \n        v.push_back(j - i);\n        i = j;\n    }\n    v.back() = 1e9;\n    \n    c = v[0] + 1;\n    for (i = 0; i < v.size(); i += 2) {\n        if (v[i] % 2 == 1) c = min(c, v[i]);\n    }\n    \n    dp[0][1] = 1;\n    dp[1][1] = mod - 1;\n    dp2[0][1] = 1;\n    dp2[1][1] = mod - 1;\n    \n    for (i = 0; i <= n; i++) {\n        if (i > 0) {\n            for (j = 0; j < 2; j++) {\n                dp[i][j] += dp[i - 1][j];\n                if (dp[i][j] >= mod) dp[i][j] -= mod;\n                \n                dp2[i][j] += dp2[i - 1][j];\n                if (dp2[i][j] >= mod) dp2[i][j] -= mod;\n            }\n        }\n        \n        if (i == 0) {\n            dp[1][0] = 2;\n            for (j = 2; j <= c && j <= n; j++) dp[j][0] = 1;\n            if (c + 1 <= n) dp[c + 1][0] = mod - (c + 1);\n        } else if (i % 2 == 1) {\n            if (i + 1 <= n) {\n                dp[i + 1][1] += dp[i][0];\n                if (dp[i + 1][1] >= mod) dp[i + 1][1] -= mod;\n            }\n            \n            if (i + 2 <= n) {\n                dp[i + 2][1] -= dp[i][0];\n                if (dp[i + 2][1] < 0) dp[i + 2][1] += mod;\n            }\n        } else {\n            if (i + 1 <= n) {\n                dp[i + 1][0] += dp[i][1];\n                if (dp[i + 1][0] >= mod) dp[i + 1][0] -= mod;\n            }\n            \n            if (i + c + 1 <= n) {\n                dp[i + c + 1][0] -= dp[i][1];\n                if (dp[i + c + 1][0] < 0) dp[i + c + 1][0] += mod;\n            }\n        }\n        \n        if (i == 0) {\n            dp2[1][0] = 2;\n            for (j = 2; j <= c && j <= n; j++) dp2[j][0] = 1;\n            if (c + 1 <= n) dp2[c + 1][0] = mod - (c + 1);\n        } else {\n            if (i + 1 <= n) {\n                dp2[i + 1][1] += dp2[i][0];\n                if (dp2[i + 1][1] >= mod) dp2[i + 1][1] -= mod;\n            }\n            \n            if (i + 2 <= n) {\n                dp2[i + 2][1] -= dp2[i][0];\n                if (dp2[i + 2][1] < 0) dp2[i + 2][1] += mod;\n            }\n            \n            if (i + 1 <= n) {\n                dp2[i + 1][0] += dp2[i][1];\n                if (dp2[i + 1][0] >= mod) dp2[i + 1][0] -= mod;\n            }\n            \n            if (i + c + 1 <= n) {\n                dp2[i + c + 1][0] -= dp2[i][1];\n                if (dp2[i + c + 1][0] < 0) dp2[i + c + 1][0] += mod;\n            }\n        }\n    }\n        \n    if (n % 2 == 0) ans = dp[n][1];\n    if (v.size() == 1) ans = (dp2[n][1] + 1) % mod;\n    \n    printf(\"%lld\\n\", ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = (int) 1e9 + 7;\n\ninline void add(int &x, int y) {\n  x += y;\n  if (x >= md) {\n    x -= md;\n  }\n}\n\ninline void sub(int &x, int y) {\n  x -= y;\n  if (x < 0) {\n    x += md;\n  }\n}\n\ninline int mul(int x, int y) {\n  return (int) ((long long) x * y % md);\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  string s;\n  cin >> n >> m >> s;\n  if (s[0] == 'B') {\n    for (auto &c : s) {\n      c ^= 'R' ^ 'B';\n    }\n  }\n  int first = m;\n  for (int i = 0; i < m; ++i) {\n    if (s[i] == 'B') {\n      first = i;\n      break;\n    }\n  }\n  if (first == m) {\n    vector<int> dp(4);\n    dp[0] = dp[3] = 1;\n    for (int i = 1; i < n; ++i) {\n      vector<int> new_dp(4);\n      for (int a = 0; a < 2; ++a) {\n        for (int b = 0; b < 2; ++b) {\n          for (int c = 0; c < 2; ++c) {\n            if (!b || !c) {\n              add(new_dp[a * 2 + b], dp[a * 2 + c]);\n            }\n          }\n        }\n      }\n      swap(dp, new_dp);\n    }\n    int ans = 0;\n    for (int i = 0; i < 3; ++i) {\n      add(ans, dp[i]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n  }\n  int last = m - 1;\n  while (s[last] == 'R') {\n    --last;\n  }\n  int limit = n, cur = 0;\n  for (int i = last; i >= -1; --i) {\n    if (i == -1 || s[i] == 'B') {\n      if (cur) {\n        if (cur & 1) {\n          limit = min(limit, cur + 1);\n        } else if (i == -1) {\n          limit = min(limit, cur + 2);\n        }\n        cur = 0;\n      }\n    } else {\n      ++cur;\n    }\n  }\n  vector<int> dp(n + 1);\n  dp[0] = dp[2] = 1;\n  for (int i = 3; i <= n; ++i) {\n    dp[i] = mul(dp[i - 2], 2);\n    if (i >= limit + 2) {\n      sub(dp[i], dp[i - (limit + 2)]);\n    }\n  }\n  int ans = 0;\n  for (int i = 2; i <= limit; ++i) {\n    add(ans, mul(dp[n - i], i));\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define int long long\nusing namespace std;\nconst int N=2e5+2;\nconst int mod=1e9+7;\nint dp[N],sum[N];\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,max1,ans=0,m;\n\tstring s;\n\tcin>>n>>m>>s;\n\tif(s[0]=='B'){\n\t\tfor(i=0;i<m;i++){\n\t\t\tif(s[i]=='B'){\n\t\t\t\ts[i]='R';\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts[i]='B';\n\t\t\t}\n\t\t}\n//\t\tcout<<s<<endl;\n\t}\n\tbool cac=true;\n\tfor(i=1;i<m;i++){\n\t\tif(s[i]!=s[i-1]){\n\t\t\tcac=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(cac){\n//\t\tcout<<0<<endl;\n\t\tdp[0]=1;\n\t\tsum[0]=1;\n\t\tans=1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(i!=1){\n\t\t\t\tdp[i]=sum[i-2];\n\t\t\t}\n\t\t\tsum[i]=sum[i-1]+dp[i];\n\t\t\tif(sum[i]>=mod){\n\t\t\t\tsum[i]-mod;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n-1;i++){\n\t\t\tans+=(i+1)*dp[n-i-1];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout<<ans;\n\t}\n\telse{\n\t\tif(n&1){\n\t\t\tcout<<0;\n\t\t\treturn 0;\n\t\t}\n\t\tmax1=n-1;\n\t\tcac=true;\n\t\tj=1;\n\t\tfor(i=m-2;i>-1;i--){\n\t\t\tif(s[i]==s[i+1]){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(s[i]=='B'){\n\t\t\t\t\tif(cac){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(j&1){\n\t\t\t\t\t\t\tmax1=min(max1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj=1;\n\t\t\t}\n\t\t}\n\t\tif(j&1){\n\t\t\tmax1=min(max1,j);\n\t\t}\n\t\telse{\n\t\t\tmax1=min(max1,j+1);\n\t\t}\n\t\tdp[0]=1;\n\t\tsum[0]=1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tsum[i]=sum[i-1];\n\t\t\tif(i&1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i]=sum[i-2];\n\t\t\tif(i-max1-2>=0){\n\t\t\t\tdp[i]-=sum[i-max1-2];\n\t\t\t\tif(dp[i]<0){\n\t\t\t\t\tdp[i]+=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum[i]+=dp[i];\n\t\t\tif(sum[i]>=mod){\n\t\t\t\tsum[i]-=mod;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=max1;i+=2){\t\n\t\t\tans+=(i+1)*dp[n-i-1];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout<<ans;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vec>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\nmain(){\n    ios\n    calc();\n    int n=in(),m=in();\n    string s;cin>>s;\n    bool all_same=true;\n    rep(i,m){\n        if(s[i]!=s[0])all_same=false;\n    }\n    if(!all_same and (n&1)) cout<<0<<endl;\n    else if(all_same and (n&1)){\n        mint dp[n+1][2]={};\n        dp[0][0]=1;\n        rep(i,n-1){\n            dp[i+1][1]+=dp[i][0];\n            dp[i+1][0]+=dp[i][0]+dp[i][1];\n        }\n        mint ans=dp[n-1][0]+dp[n-1][1];\n        rep(i,n)dp[i][0]=dp[i][1]=0;\n        dp[0][1]=1;\n        rep(i,n-1){\n            dp[i+1][1]+=dp[i][0];\n            dp[i+1][0]+=dp[i][0]+dp[i][1];\n        }\n        ans+=dp[n-1][0];\n        cout<<ans.a<<endl;\n    }\n    else{\n        char c=s[0];\n        int mi=INT_MAX;\n        rep(i,m){\n            int cnt=0;\n            while(i<m && s[i]==c)cnt++,i++;\n            chmin(mi,cnt);break;\n        }\n        if(mi %2) mi=mi*2-1;\n        else mi=mi+1;\n        rep(i,m){\n            if(s[i]==c){\n                int cnt=0;\n                while(i<m && s[i]==c)cnt++,i++;\n                if(cnt&1)\n                chmin(mi,cnt);\n            }\n        }\n        mint dp[700000]={};\n        mi=(mi+1)/2;\n        rep(i,mi){\n            dp[i]=2;\n        }\n        dp[mi]=-2*mi;\n        rep(i,n/2){\n            dp[i+1]+=dp[i]*2;\n            dp[i+1+mi]-=dp[i];\n        }\n        if(all_same)dp[n/2-1]+=1;\n        cout<<dp[n/2-1].a<<endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, m;\nlong long Mod = 1000000007, InvF[401000],F[401000], D[401000], S[401000];\nchar p[301000];\nlong long Pow(long long a, long long b) {\n\tlong long r = 1;\n\twhile (b) {\n\t\tif (b & 1)r = r * a%Mod;\n\t\ta = a * a%Mod; b >>= 1;\n\t}\n\treturn r;\n}\nlong long Comb(int n, int k) {\n\treturn F[n] * InvF[k] % Mod*InvF[n - k] % Mod;\n}\nlong long Get(int a, int b) {\n\tif (b < 0 || a <= 0)return 0;\n\treturn Comb(a + b - 1, b);\n}\nint main() {\n\tint i, j;\n\tF[0] = 1;\n\tfor (i = 1; i <= 400000; i++)F[i] = F[i - 1] * i%Mod;\n\tInvF[400000] = Pow(F[400000], Mod - 2);\n\tfor (i = 400000; i >= 1; i--)InvF[i - 1] = InvF[i] * i%Mod;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", p);\n\tint ck = 0;\n\tfor (i = 0; p[i]; i++) {\n\t\tif (p[i] == 'R')ck |= 1;\n\t\tif (p[i] == 'B')ck |= 2;\n\t}\n\tif (ck!=3) {\n\t\tprintf(\"%d\\n\", (n + 1) % Mod);\n\t\treturn 0;\n\t}\n\tif (n % 2 == 1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tif (p[0] == 'B') {\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tp[i] = 'R' + 'B' - p[i];\n\t\t}\n\t}\n\tint c = 0, Mn = 1e9;\n\tck = 0;\n\tfor (i = 0; i < m; i++) {\n\t\tif (p[i] == 'R') {\n\t\t\tc++;\n\t\t\tif (i == m - 1 || p[i + 1] == 'B') {\n\t\t\t\tif (!ck) {\n\t\t\t\t\tif (c % 2 == 0)Mn = min(Mn, c + 1);\n\t\t\t\t\telse Mn = min(Mn, c);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (c % 2 == 1)Mn = min(Mn, c);\n\t\t\t\t}\n\t\t\t\tck = 1;\n\t\t\t}\n\t\t}\n\t\telse c = 0;\n\t}\n\n\tint K = (Mn + 1) / 2;\n\tD[0] = 1;\n\tS[0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tlong long t = S[i - 1];\n\t\tif (i - K - 1 >= 0)t -= S[i - K - 1];\n\t\tD[i] = (t + Mod) % Mod;\n\t\tS[i] = (S[i - 1] + D[i]) % Mod;\n\t}\n\tlong long res = D[n / 2];\n\tfor (i = 1; i <= Mn && i<=n; i+=2) {\n\t\tres = (res + 1ll*i*D[(n - i - 1) / 2])%Mod;\n\t}\n\tprintf(\"%lld\\n\", res);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\ntemplate <typename T> void chmin(T &x,const T &y)\n{\n\tif(x>y)x=y;\n}\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\ntypedef long long s64;\nconst int N=2e5+5,D=1e9+7;\nchar s[N];\ns64 dp[N],sum[N];\n\nint main()\n{\n#ifdef kcz\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tint n,m;\n\tcin>>n>>m;\n\tscanf(\"%s\",s+1);\n\tif(s[1]=='B')\n\trep(i,1,m)s[i]=\"RB\"[s[i]=='R'];\n\tint mn[2]={N,N},now=0;\n\trep(i,1,m+1)\n\tif(s[i]=='R')++now;\n\telse \n\t{\n\t\tif(now)chmin(mn[now%2],now);\n\t\tnow=0;\n\t}\n\tif(mn[m%2]==m)\n\t{\n\t\tdp[0]=1;\n\t\trep(i,2,n+2)dp[i]=(dp[i-1]+dp[i-2])%D;\n\t\tcout<<(dp[n]+dp[n+2])%D;\n\t}\n\telse\n\t{\n\t\tchmin(mn[1],mn[0]+1);\n\t\tif(n%2){puts(\"0\");exit(0);}\n\t\tdp[0]=sum[0]=1;\n\t\trep(i,2,n)\n\t\t{\n\t\t\tdp[i]=sum[i-2];\n\t\t\tint j=i-mn[1]-1-2;\n\t\t\tif(j>=0)dp[i]-=sum[j];\n\t\t\tdp[i]%=D;\n\t\t\tsum[i]=(sum[i-2]+dp[i])%D;\n\t\t}\n\t\ts64 ans=0;\n\t\trep(x,0,min(n/2-1,mn[1]/2))\n\t\t{\n\t\t\tans+=sum[n-2*x-2];\n\t\t\tif(mn[1]+3<=n)ans-=sum[n-mn[1]-1-2];\n\t\t}\n\t\tcout<<(ans*2%D+D)%D;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 300000\n\nconst LL mod=1000000007;\nLL n,m,p,ans,f[N];\nchar s[N];\n\nvoid upd(LL &x,LL y){x=(x+y)%mod;}\n\nint main(){\n\tscanf(\"%lld%lld%s\",&n,&m,s+1);\n\tif (s[1]=='B') for (LL i=1;i<=m;++i) s[i]=s[i]=='B'?'R':'B';\n\tp=n;\n\tans=1;\n\tfor (LL i=1,j=0,fst=0;i<=m;++i){\n\t\tif (s[i]=='R') ++j;\n\t\telse{\n\t\t\tans=0;\n\t\t\tif (!fst) p=min(p,j&1?j:j+1);\n\t\t\tfst=1;\n\t\t\tif (j&1) p=min(p,j);\n\t\t\tj=0;\n\t\t}\n\t}\n\tif (!ans&&(n&1)){printf(\"%lld\\n\",ans); return 0;}\n\tif (n&1){\n\t\tans=0;\n\t\tf[1]=1;\n\t\tfor (LL i=2;i<=n;++i) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tupd(ans,f[n]+f[n-1]*2);\n\t}\n\telse{\n\t\tp=(p+1)/2;\n\t\tf[0]=1;\n\t\tfor (LL i=1,j=0,k=0;i<=n/2;++i){\n\t\t\tupd(k,f[i-1]);\n\t\t\tif (j<i-p){upd(k,-f[j]); ++j;}\n\t\t\tupd(f[i],k);\n\t\t}\n\t\tfor (LL i=2;i<=n&&i<=p*2;i+=2) upd(ans,i*f[(n-i)/2]);\n\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(),(x).end()\n#define SP <<\" \"<<\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  int n,m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n  vector<int> ss(n);\n  ss[0]=1;\n  for(int i=0;i<n;i++){\n    if(s[i]==s[0]) ss[i]=1;\n    else ss[i]=0;\n  }\n  int count=0;\n  int l=0;\n  for(int i=0;i<n;i++){\n    if(ss[i]){\n      count++;\n    }else{\n      if(l==0){\n        l=2*count+1;\n      }else{\n        if(count%2){\n          l=min(l,count);\n        }\n      }\n      count=0;\n    }\n  }\n  if(l==0){ // all R/B\n    LL ans=0;\n    LL ok=1,ng=0;\n    for(int i=1;i<n;i++){\n      LL nok=ng+ok;\n      LL nng=ok;\n      ok=nok,ng=nng;\n    }\n    ans=(ok+ng)%MOD;\n    ok=0,ng=1;\n    for(int i=1;i<n;i++){\n      LL nok=ng+ok;\n      LL nng=ok;\n      ok=nok,ng=nng;\n    }\n    ans=(ans+ok)%MOD;\n    cout << ans << endl;\n  }else{ // 1,...,l から選んで総和がn/2\n    if(n%2){\n      cout << 0 << endl;\n      return 0;\n    }\n\t//??????????\n    vector<LL> c(n+1);\n    LL total=1;\n    c[0]=1;\n    cout << c[n]*2%MOD << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tstring S;\n\tcin >> N >> M >> S;\n\tcat mod = 1000000007;\n\tvector<int> L;\n\tfor(int i = 0; i < M; i++) if(i == 0 || S[i] != S[i-1]) {\n\t\tint l = 0;\n\t\twhile(i+l < M && S[i+l] == S[i]) l++;\n\t\tL.push_back(l);\n\t}\n\tM = L.size();\n\n\tif(M == 1) {\n\t\tvector<cat> cnt(N+1, 0);\n\t\tcnt[1] = 1;\n\t\tcat pref = 1;\n\t\tfor(int i = 2; i <= N; i++) {\n\t\t\tcnt[i] = (pref - cnt[i-1]) % mod;\n\t\t\tpref = (pref + cnt[i]) % mod;\n\t\t}\n\t\tcat ans = 1;\n\t\tfor(int i = 1; i < N; i++)\n\t\t\tans = (ans + (i+1) * cnt[N-i]) % mod;\n\t\tcout << ans << \"\\n\";\n\t\treturn 0;\n\t}\n \n\tint max_first = N-1;\n\tif(L[0]%2 == 0) max_first = min(max_first, L[0]+1);\n\tfor(int i = 0; i < M-1; i += 2)\n\t\tif(L[i]%2 != 0) max_first = min(max_first, L[i]);\n\tif(max_first%2 == 0) max_first--;\n\n\tvector<cat> cnt(N+1, 0), pref(N+2, 0);\n\tcnt[1] = pref[2] = 1;\n\tfor(int i = 3; i <= N; i += 2) {\n\t\tcnt[i] = (pref[i-1] - pref[max(0, i-max_first-2)]) % mod;\n\t\tpref[i+1] = (cnt[i] + pref[i-1]) % mod;\n\t}\n\n\tcat ans = 0;\n\tfor(int i = 1; i <= max_first; i += 2)\n\t\tans = (ans + (i+1) * cnt[N-i]) % mod;\n\tans %= mod;\n\tif(ans < 0) ans += mod;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nchar S[210000];\nlong long bit[210000];\nlong long sum(int a,int b){\n\tif(a)return (sum(0,b)-sum(0,a-1)+mod)%mod;\n\tlong long ret=0;\n\tfor(;b>=0;b=(b&(b+1))-1)ret+=bit[b];\n\treturn ret%mod;\n}\nvoid add(int a,long long b){\n\tfor(;a<210000;a|=a+1)bit[a]=(bit[a]+b)%mod;\n}\nlong long dp[210000][2][2];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tscanf(\"%s\",S);\n\tif(S[0]=='B'){\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(S[i]=='B')S[i]='R';\n\t\t\telse S[i]='B';\n\t\t}\n\t}\n\tlong long ret=0;\n\tint chk=0;\n\tfor(int i=0;i<b;i++){\n\t\tif(S[i]=='B')chk=1;\n\t}\n\tif(chk==0){\n\t\tdp[1][0][0]=1;\n\t\tdp[1][1][1]=1;\n\t\tfor(int i=1;i<a;i++){\n\t\t\tdp[i+1][0][0]=(dp[i+1][0][0]+dp[i][0][0]+dp[i][1][0])%mod;\n\t\t\tdp[i+1][1][0]=(dp[i+1][1][0]+dp[i][0][0])%mod;\n\t\t\tdp[i+1][0][1]=(dp[i+1][0][1]+dp[i][0][1]+dp[i][1][1])%mod;\n\t\t\tdp[i+1][1][1]=(dp[i+1][1][1]+dp[i][0][1])%mod;\n\t\t\t\n\t\t}\n\t\tret=(dp[a][0][0]+dp[a][0][1]+dp[a][1][0])%mod;\n\t\tprintf(\"%lld\\n\",ret);\n\t\treturn 0;\n\t}\n\tif(a%2){\n\t\tprintf(\"0\\n\");return 0;\n\t}\n\tbool wolf=true;\n\tint fi=0;\n\tint tmp=0;\n\tfor(int i=0;i<b;i++){\n\t\tif(S[i]=='B'){\n\t\t\tif(wolf){\n\t\t\t\tfi=tmp;tmp=0;\n\t\t\t\twolf=false;\n\t\t\t}else{\n\t\t\t\tif(tmp%2){\n\t\t\t\t\tprintf(\"2\\n\");return 0;\n\t\t\t\t}\n\t\t\t\ttmp=0;\n\t\t\t}\n\t\t}else{\n\t\t\ttmp++;\n\t\t}\n\t}\n\ta/=2;\n\tadd(1,1);\n\tif(fi%2)return 1;\n\tfor(int i=2;i<=a;i++){\n\t\tint L;\n\t\tL=max(1,i-1-fi/2);\n\t\tlong long tmp=sum(L,i-1);\n\t\tadd(i,tmp);\n\t}\n\tfor(int i=1;i<=a;i++){\n\t//\tif(a-i>fi)continue;\n\t\tif(a-i>fi/2)continue;\n\t//\tprintf(\"%d: %lld\\n\",i,sum(i,i));\n\t\tret=(ret+(a+1-i)*sum(i,i))%mod;\n\t}\n\tret=ret*2%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long LL;\nconst int N = 2e5+10 , mod = 1e9+7;\ninline int read()\n{\n\tregister int x = 0 , f = 0; register char c = getchar();\n\twhile(c < '0' || c > '9') f |= c == '-' , c = getchar();\n\twhile(c >= '0' && c <= '9') x = (x << 3) + (x << 1) + c - '0' , c = getchar();\n\treturn f ? -x : x;\n}\nint n , m;\nchar s[N];\nint sum[N] , f[N];\nint main()\n{\n\tn = read(); m = read(); scanf(\"%s\" , s+1);\n\tint i , mx , ans = 0;\n\tfor(i = 1 ; i <= m ; ++i) if(s[i] != s[1]) break;\n\tmx = i - 1;\n\tif(mx == m)\n\t{\n\t\tsum[0] = f[0] = ans = 1;\n\t\tfor(int i = 1 ; i <= n ; ++i)\n\t\t{\n\t\t\tif(i >= 2) f[i] = sum[i-2];\n\t\t\tsum[i] = (sum[i-1] + f[i]) % mod;\n\t\t}\n\t\tfor(int i = 0 ; n - i >= 2 ; ++i) (ans += (LL)f[i] * (n - i) % mod) %= mod;\n\t\tcout << ans << '\\n'; return 0;\n\t}\n\tif(n & 1) return puts(\"0\") , 0;\n\tif(mx % 2 == 0) mx++;\n\tfor(int tmp = 0 ; i <= m ; ++i)\n\t{\n\t\tif(s[i] == s[1]) tmp++;\n\t\telse\n\t\t{\n\t\t\tif(tmp & 1) mx = min(mx , tmp);\n\t\t\ttmp = 0;\n\t\t}\n\t}\n\tmx = (mx + 1) >> 1; n >>= 1; f[0] = sum[0] = 1;\n\tfor(int i = 1 ; i <= n ; ++i)\n\t{\n\t\tf[i] = (sum[i-1] - (i - mx - 1 >= 0 ? sum[i - mx - 1] : 0) + mod) % mod;\n\t\tsum[i] = (sum[i-1] + f[i]) % mod;\n\t}\n\tfor(int i = 0 ; i <= n ; ++i) if(n - i <= mx) (ans += (LL)f[i] * (n - i) % mod * 2 % mod) %= mod;\n\tcout << ans << '\\n'; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline tuple<int, int, int> extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nunsigned ModInt::MOD = 1000000007;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\n\n\nconst int limit = 200010;\nmint dp[limit];\nmint csum[limit];\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\n\tint cmin = m, cons = 0;\n\trep(i, m){\n\t\tif(s[i] == s[0]){\n\t\t\tcons++;\n\t\t} else {\n\t\t\tchmin(cmin, cons);\n\t\t}\n\t}\n\n\tif(cmin % 2 == 0) cmin++;\n\tdp[1] = csum[1] = ONE;\n\n\trep(i, 1, n){\n\t\tconst int pos = max(i - cmin - 1, 0);\n\t\tif((i + 1) % 2 == 1) dp[i + 1] =  csum[i] - csum[pos];\n\t\tcsum[i + 1] = csum[i] + dp[i + 1];\n\t}\n\n\tmint ans = ZERO;\n\n\trep(i, n - cmin, n + 1){\n\t\tconst mint coef = mint(n - i + 1);\n\t\tans += coef * dp[i];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\ntemplate <unsigned int MOD>\nstruct ModInt {\n    using uint = unsigned int;\n    using ull = unsigned long long;\n    using M = ModInt;\n\n    uint v;\n\n    ModInt(ll _v = 0) { set_norm(_v % MOD + MOD); }\n    M& set_norm(uint _v) {  //[0, MOD * 2)->[0, MOD)\n        v = (_v < MOD) ? _v : _v - MOD;\n        return *this;\n    }\n\n    explicit operator bool() const { return v != 0; }\n    M operator+(const M& a) const { return M().set_norm(v + a.v); }\n    M operator-(const M& a) const { return M().set_norm(v + MOD - a.v); }\n    M operator*(const M& a) const { return M().set_norm(ull(v) * a.v % MOD); }\n    M operator/(const M& a) const { return *this * a.inv(); }\n    M& operator+=(const M& a) { return *this = *this + a; }\n    M& operator-=(const M& a) { return *this = *this - a; }\n    M& operator*=(const M& a) { return *this = *this * a; }\n    M& operator/=(const M& a) { return *this = *this / a; }\n    M operator-() const { return M() - *this; }\n    M& operator++(int) { return *this = *this + 1; }\n    M& operator--(int) { return *this = *this - 1; }\n\n    M pow(ll n) const {\n        if (n < 0) return inv().pow(-n);\n        M x = *this, res = 1;\n        while (n) {\n            if (n & 1) res *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    M inv() const {\n        ll a = v, b = MOD, p = 1, q = 0, t;\n        while (b != 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(p -= t * q, q);\n        }\n        return M(p);\n    }\n\n    bool operator==(const M& a) const { return v == a.v; }\n    bool operator!=(const M& a) const { return v != a.v; }\n    friend ostream& operator<<(ostream& os, const M& a) { return os << a.v; }\n    static uint get_mod() { return MOD; }\n};\n\nusing Mint = ModInt<1000000007>;\n\nconst int maxn = 200010;\n\nMint dp[maxn];\n\nMint uni(int n) {\n    dp[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        for (int j = 1; j < i - 1; ++j) {\n            dp[i] += dp[j];\n        }\n    }\n    Mint res(1);\n    for (int l = 1; l <= n; l++) {\n        res += dp[n - l] * (l + 1);\n    }\n    return res;\n}\n\nMint solve(int n, int ml) {\n    dp[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        for (int j = max(1, i - ml - 1); j < i - 1; ++j) {\n            if ((i - j - 1) % 2 == 1) {\n                dp[i] += dp[j];\n            }\n        }\n    }\n    Mint res;\n    for (int l = 1; l <= min(n, ml); l += 2) {\n        res += dp[n - l] * (l + 1);\n    }\n    return res;\n}\n\nint main() {\n    int N, M;\n    string S;\n    cin >> N >> M >> S;\n    V<pii> vec;\n\n    rep(i, M) {\n        if (vec.size() > 0 && vec.back().fi == S[i]) {\n            vec.back().se++;\n        } else {\n            vec.eb(S[i], 1);\n        }\n    }\n\n    if (vec.size() == 1) {\n        cout << uni(N) << endl;\n        return 0;\n    }\n\n    if (N % 2) {\n        puts(\"0\");\n        return 0;\n    }\n\n    if (vec.back().fi == vec[0].fi) {\n        vec.pop_back();\n    }\n\n    debug(vec);\n\n    int ml = vec[0].se;\n    if (ml % 2 == 0) ml++;\n\n    int sc = vec[0].fi;\n    for (auto p : vec) {\n        if (p.fi == sc && p.se % 2) {\n            chmin(ml, p.se);\n        }\n    }\n    debug(ml);\n\n    cout << solve(N, ml) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\nint f[200005];\n\nint solve(int n,int up) {\n  int s=0;\n  for(int i=1;i<=n;i++) {\n  \tif (i>up+1) s=(s-f[i-up-1]+MOD)%MOD;\n  \tf[i]=(s+((i<=up)?i:0))%MOD;\n  \ts=(s+f[i])%MOD;\n  }\n  return f[n];\n}\n\nint solve2(int n) {\n  f[1]=1;\n  for(int i=2;i<=n+1;i++) f[i]=(f[i-1]+f[i-2])%MOD;\n  return (f[n+1]+f[n-1])%MOD;\n}\n\nchar str[200005];\n\nint main() {\n  int n,m;\n  scanf(\"%d%d%s\",&n,&m,str+1);\n  if (str[1]=='B') {\n  \tfor(int i=1;i<=m;i++) str[i]=((str[i]=='R')?'B':'R');\n  }\n  bool v=0;\n  for(int i=1;i<=m;i++)\n    if (str[i]=='B') {\n    \tv=1;\n    \tbreak;\n\t}\n  if (!v) {\n  \tprintf(\"%d\\n\",solve2(n));\n  \treturn 0;\n  }\n  if (n&1) {\n  \tputs(\"0\");\n  \treturn 0;\n  }\n  int minn=n,s=0;\n  for(int i=1;i<=m;i++)\n    if (str[i]=='R') s++;\n    else {\n    \tif (s) minn=min(minn,s);\n    \ts=0;\n\t}\n  printf(\"%d\\n\",2*solve(n>>1,(minn>>1)+1)%MOD);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N=2e5+5,Mo=1e9+7;\n\nint n,m,k,f[N],s[N];\nchar st[N];\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",st+1);\n\tk=1;for(;k<m&&st[k+1]==st[1];k++);\n\tif (k==m) {\n\t\tf[0]=s[0]=1;\n\t\tfo(i,1,n) {\n\t\t\tif (i>=2) f[i]=s[i-2];\n\t\t\ts[i]=(s[i-1]+f[i])%Mo;\n\t\t}\n\t\tint ans=1;\n\t\tfo(i,2,n) (ans+=(ll)i*f[n-i]%Mo)%=Mo;\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif (n&1) {puts(\"0\");return 0;}\n\tint lim=k+1,now=0;\n\tfor(k++;k<=m;k++) {\n\t\tif (st[k]==st[1]) now++;\n\t\telse {\n\t\t\tif (now&1) lim=min(lim,now);\n\t\t\tnow=0;\n\t\t}\n\t}\n\tn>>=1;lim=(lim+1)>>1;\n\tf[0]=s[0]=1;\n\tfo(i,1,n) {\n\t\tf[i]=s[i-1];\n\t\tif (i-lim-1>=0) (f[i]+=Mo-s[i-lim-1])%=Mo;\n\t\ts[i]=(s[i-1]+f[i])%Mo;\n\t}\n\tint ans=0;\n\tfo(i,1,lim) (ans+=(ll)(i<<1)*f[n-i]%Mo)%=Mo;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 1000000007;\n\nconst long long MOD_CONST = 1000000007;\nlong long mul_mod(long long a, long long b, const long long MOD) {\n  return b ? (mul_mod(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow_mod(long long a, long long b, const long long MOD) {\n  return (b ? bpow_mod(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv_mod(long long a, const long long MOD) {\n  return bpow_mod(a, MOD - 2, MOD);\n}\ntemplate <long long param = MOD_CONST, bool fast = false>\nclass mint {\n private:\n  using Z = int;\n  using N = unsigned int;\n  using ZZ = long long;\n  using NN = unsigned long long;\n  struct {\n  } constexpr static exact{};\n  // Using Z deliberately to avoid Z -> N promotion.\n  template <class Ret = ZZ&>\n  static auto modulo() -> std::enable_if_t<(param <= 0), Ret> {\n    static ZZ mod = 0;\n    return mod;\n  }\n  template <class Ret = const ZZ>\n  static auto mod() -> std::enable_if_t<(param <= 0), Ret> {\n    return modulo();\n  }\n  template <class Ret = const ZZ>\n  static constexpr auto mod() -> std::enable_if_t<(param > 0), Ret> {\n    return param;\n  }\n\n public:\n  template <class Arg = ZZ>\n  static void set_modulo(const std::enable_if_t<(param <= 0), Arg> mod) {\n    modulo() = mod;\n  }\n  long long v;\n\n  constexpr mint() : v(0) {}\n\n  constexpr mint(long long v)\n      : v(fast ? (v)\n               : (v < 0 ? (v % mod() + mod()) % mod()\n                        : (v >= mod() ? v % mod() : v))) {}\n  constexpr long long get_mod() { return mod(); }\n  long long get_val() { return v; }\n  void take_mod() { v %= mod(); }\n};\ntemplate <long long param, bool fast>\nostream& operator<<(ostream& os, mint<param, fast>& x) {\n  return os << (x.v % x.get_mod() + x.get_mod()) % x.get_mod();\n}\n\ntemplate <long long param, bool fast, bool fast2>\nbool operator==(mint<param, fast>& a, mint<param, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast>& operator+=(mint<param, fast>& a, mint<param, fast2> b) {\n  return a = a.v + b.v;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, mint<param> b) {\n  return a = a.v - b.v;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, mint<param> b) {\n  return a = a.v * b.v;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, mint<param> b) {\n  return a = a.v * inv_mod(b.v, a.get_mod());\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast> operator+(mint<param, fast> a, mint<param, fast2> b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, mint<param> b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, mint<param> b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, mint<param> b) {\n  return a /= b;\n}\ntemplate <long long param, bool fast>\nmint<param, fast>& operator+=(mint<param, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, long long b) {\n  return a = a.v * inv_mod(b, a.get_mod());\n}\ntemplate <long long param, bool fast>\nmint<param, fast> operator+(mint<param> a, long long b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, long long b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, long long b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, long long b) {\n  return a /= b;\n}\n\nvoid special(int N) {\n  vector<mint<>> vals = {mint<>(1), mint<>(1)};\n  for (int i = 0; i < N; i++) {\n    int sz = vals.size();\n    vals.push_back(vals[sz - 1] + vals[sz - 2]);\n  }\n  mint<> ans = vals[N] + vals[N - 2];\n  cout << ans << endl;\n}\n\nint con(string& S, char t) {\n  int ans = 1000000;\n  int cur = 0;\n  int first = 0;\n  if (S[0] != t) first++;\n  for (auto c : S) {\n    if (c == t)\n      cur++;\n    else {\n      if (first == 0) {\n        first++;\n        ans = cur;\n      }\n\n      if (cur % 2 == 1) ans = min(ans, cur);\n      cur = 0;\n    }\n  }\n  // chmin(ans, cur);\n  return ans;\n}\n\nmint<> calcDP(int N, int conB, int conR) {\n  vector<mint<>> dpR(N + 2, mint<>(0));\n  vector<mint<>> dpB(N + 2, mint<>(0));\n  vector<mint<>> sumR(N + 2, mint<>(0));\n  vector<mint<>> sumB(N + 2, mint<>(0));\n  dpR[1] = 1;\n  sumR[1] = 1;\n  for (int i = 2; i <= N + 1; i++) {\n    if (i % 2 == 1) {\n      dpR[i] = sumB[i - 1] - sumB[max(0, i - conR - 1)];\n\n    } else\n      dpB[i] = sumR[i - 1] - sumR[max(0, i - conB - 1)];\n    sumB[i] = sumB[i - 1] + dpB[i];\n    sumR[i] = sumR[i - 1] + dpR[i];\n  }\n  mint<> ans = 0;\n  for (int i = 0; i < min(N, conB + 1); i++) {\n    ans += sumR[N - i] - sumR[max(0, N - conB - 2)];\n  }\n  return ans;\n}\n\nvoid solve(long long N, long long M, std::string S) {\n  int cntB = 0;\n\n  int conR = con(S, 'R');\n  int conB = con(S, 'B');\n  for (int i = 0; i < M; i++) {\n    if (S[i] == 'B') cntB++;\n  }\n  if (cntB == M || cntB == 0) {\n    special(N);\n    return;\n  }\n  if (N % 2 == 1) {\n    cout << 0 << endl;\n    return;\n  }\n  if (S[0] == 'R') swap(conR, conB);\n  conR = 1;\n  if (conB % 2 == 0) conB++;\n  // if (conR % 2 == 0) conR--;\n\n  mint<> ans = calcDP(N, conB, conR);\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long M;\n  scanf(\"%lld\", &M);\n  std::string S;\n  std::cin >> S;\n  solve(N, M, S);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nconst int P = 1e9 + 7;\n\nstruct modint {\n    int x;\n    inline modint(int x = 0) : x(x) {}\n    inline modint &operator = (int o) { return x = o, *this; }\n    inline modint &operator += (modint o) { return (x += o.x) >= P && (x -= P), *this; }\n    inline modint &operator -= (modint o) { return (x -= o.x) < 0 && (x += P), *this; }\n    inline modint &operator *= (modint o) { return x = 1ll * x * o.x % P, *this; }\n    template <class I>\n    inline modint &operator ^= (I b) {\n        modint a = *this, c;\n        if (!~b) b = P - 2;\n        c.x = 1 % P;\n        while (b) {\n            if (b & 1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return x = c.x, *this;\n    }\n    inline modint &operator /= (modint o) { return *this *= o ^ -1; }\n    inline modint &operator += (int o) { return (x += o) >= P && (x -= P), *this; }\n    inline modint &operator -= (int o) { return (x -= o) < 0 && (x += P), *this; }\n    inline modint &operator *= (int o) { return x = 1ll * x * o % P, *this; }\n    inline modint &operator /= (int o) { return *this *= (modint)o ^ -1; }\n    template <class I>\n    inline friend modint operator + (modint a, I b) { return a += b; }\n    template <class I>\n    inline friend modint operator - (modint a, I b) { return a -= b; }\n    template <class I>\n    inline friend modint operator * (modint a, I b) { return a *= b; }\n    template <class I>\n    inline friend modint operator ^ (modint a, I b) { return a ^= b; }\n    template <class I>\n    inline friend modint operator / (modint a, I b) { return a /= b; }\n    inline friend bool operator == (modint a, int b) { return a.x == b; }\n    inline friend bool operator != (modint a, int b) { return a.x != b; }\n    inline friend bool operator < (modint a, int b) { return a.x < b; }\n    inline friend bool operator <= (modint a, int b) { return a.x <= b; }\n    inline friend bool operator > (modint a, int b) { return a.x > b; }\n    inline friend bool operator >= (modint a, int b) { return a.x >= b; }\n    inline friend bool operator == (modint a, modint b) { return a.x == b.x; }\n    inline friend bool operator != (modint a, modint b) { return a.x != b.x; }\n    inline friend bool operator < (modint a, modint b) { return a.x < b.x; }\n    inline friend bool operator <= (modint a, modint b) { return a.x <= b.x; }\n    inline friend bool operator > (modint a, modint b) { return a.x > b.x; }\n    inline friend bool operator >= (modint a, modint b) { return a.x >= b.x; }\n    inline bool operator ! () { return !x; }\n    inline modint operator - () { return x ? P - x : 0; }\n};\ninline void rd(modint &x) { rd(x.x); }\ninline void print(modint x, char k = '\\n') { print(x.x, k); }\n\n//const int NP = 1e6 + 7;\n//modint p[NP], v[NP], vp[NP];\n//inline void init(int n) {\n//  p[0] = v[0] = 1;\n//  for (int i = 1; i <= n; i++) p[i] = p[i-1] * i;\n//  vp[n] = 1 / p[n];\n//  for (int i = n; i; i--) v[i] = vp[i] * p[i-1], vp[i-1] = vp[i] * i;\n//}\n//inline modint binom(int n, int m) {\n//  return (m < 0 || n < m) ? 0 : p[n] * vp[m] * vp[n-m];\n//}\n\nconst int N = 2e5 + 7;\nint n, m, c[N], k, w;\nchar s[N];\n\nnamespace k1 {\n\tmodint f[N][2][2];\n\tinline void main() {\n\t\tf[1][0][0] = f[1][1][1] = 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tf[i+1][0][0] = f[i][0][0] + f[i][0][1],\n\t\t\tf[i+1][0][1] = f[i][0][0],\n\t\t\tf[i+1][1][0] = f[i][1][0] + f[i][1][1],\n\t\t\tf[i+1][1][1] = f[i][1][0];\n\t\tprint(f[n][0][0] + f[n][0][1] + f[n][1][0]);\n\t}\n}\n\nmodint f[N], g[N], ans;\n\nint main() {\n\trd(n, m), rds(s, m);\n\tfor (int l = 1, r = 1; l <= m; l = ++r) {\n\t\twhile (r < n && s[r+1] == s[l]) ++r;\n\t\tc[++k] = r - l + 1;\n\t}\n\tif (k == 1) return k1::main(), 0;\n\tif (n & 1) return print(0), 0;\n\tw = c[1] + !(c[1] & 1), k -= k & 1;\n\tfor (int i = 3; i <= k; i += 2)\n\t\tif (c[i] & 1) w = min(w, c[i]);\n\tn >>= 1, w >>= 1;\n\tf[1] = g[1] = 1;\n\tfor (int i = 2; i <= n; i++)\n\t\tg[i] = g[i-1] + (f[i] = g[i-1] - (i - w - 2 >= 0 ? g[i-w-2] : 0));\n\tfor (int i = 0; i <= min(n, w); i++) ans += f[n-i] * (i + 1);\n\tprint(ans + ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n//#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MaxN = 2e5 + 100;\nconst int Mod = 1e9 + 7;\n\nint dp[MaxN];\nint pref_dp[MaxN];\n\nint small_dp[MaxN][2][2];\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N, M;\n  string s;\n  cin >> N >> M >> s;\n\n  if (count(ALL(s), s[0]) == M) {\n    small_dp[1][1][1] = small_dp[1][0][0] = 1;\n    for (int len = 2; len <= N; ++len) {\n      for (int fst : {0, 1}) {\n        // add gut\n        small_dp[len][fst][0] =\n          (small_dp[len - 1][fst][0] + small_dp[len - 1][fst][1]) % Mod;\n        // add no gut\n        small_dp[len][fst][1] = small_dp[len - 1][fst][0];\n      }\n    }\n\n    int ans = 0;\n    for (int x : {0, 1}) {\n      for (int y : {0, 1}) {\n        if (x + y <= 1) {\n          ans = (ans + small_dp[N][x][y]) % Mod;\n        }\n      }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n  }\n\n  if (s[0] != s[1]) {\n    if (N % 2 == 0) {\n      cout << \"2\\n\";\n    } else {\n      cout << \"0\\n\";\n    }\n    return 0;\n  }\n\n  int min_seg_len = N - 1;\n  int cur_len = 0;\n  for (char ch : s) {\n    if (ch == s[0]) {\n      ++cur_len;\n    } else {\n      if (cur_len) { mini(min_seg_len, cur_len); }\n      cur_len = 0;\n    }\n  }\n  if (cur_len) { mini(min_seg_len, cur_len); }\n\n\n  int answer = 0;\n\n  dp[0] = pref_dp[2] = 1;\n\n  const int min_jump = 2;\n  int max_jump = min_seg_len + 2;\n  // jump must be even as well\n  if (max_jump % 2 == 1) { --max_jump; }\n\n  debug(min_jump, max_jump);\n\n  for (int len = 1; len <= N; ++len) {\n    const int add_from = max(0, len - max_jump);\n    const int add_to = len - min_jump;\n\n    if (add_from <= add_to) {\n      dp[len] = pref_dp[add_to + 2] - pref_dp[add_from];\n      if (dp[len] < 0) { dp[len] += Mod; }\n    }\n\n    debug(len, dp[len]);\n\n    pref_dp[len + 2] = (pref_dp[len] + dp[len]) % Mod;\n  }\n\n  for (int chain_len = 0; chain_len < N; ++chain_len) {\n    const int rem_len = N - chain_len;\n    if (2 <= rem_len && rem_len <= max_jump && rem_len % 2 == 0) {\n      const int coef = dp[chain_len];\n      answer = (answer + (LL)coef * (rem_len )) % Mod;\n    }\n  }\n\n  cout << answer << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tstring s;\n\tcin >> s;\n\tset<char>st;\n\tfor (auto i : s)st.insert(i);\n\tif (st.size() == 1) {\n\t\tvector<long long int>dp(N + 1);\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1];\n\t\t\tif (i > 1)dp[i] += dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tlong long int ans = dp.back();\n\t\tdp[0] = 1;\n\t\tdp[1] = 0;\n\t\tfor (int i = 2; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tans += dp.back();\n\t\tans %= MOD;\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\ts.push_back(s[0] + 1);\n\tvector<int>num(s.size() + 1);\n\tfor (int i = 0; i <= s.size(); i++) {\n\t\tnum[i] = s[i] == s[0];\n\t\tif (i)num[i] = num[i] * (num[i - 1] + 1);\n\t}\n\tint fst = 0;\n\tint m = MOD;\n\tbool even = true;\n\tfor (int i = 1; i <= s.size(); i++) {\n\t\tif (!num[i] && num[i - 1]) {\n\t\t\tif (num[i - 1] & 1) {\n\t\t\t\teven = false;\n\t\t\t\tm = min(m, num[i - 1]);\n\t\t\t}\n\t\t\tif (fst == 0) {\n\t\t\t\tfst = num[i - 1];\n\t\t\t\tif (fst % 2 == 0)m = MOD;\n\t\t\t}\n\t\t}\n\t}\n\tif (even) {\n\t\tm = fst + 2;\n\t}\n\telse if (fst % 2 == 0) {\n\t\tassert(0);\n\t\tm = min(m, fst + 1);\n\t}\n\tif (m & 1)m++;\n\tvector<long long int>dp(N + 2);\n\tvector<long long int>sum(N + 2);\n\tfor (int i = 2; i <= m; i += 2)dp[i] = i;\n\tfor (int i = 2; i <= N; i++) {\n\t\tdp[i] += sum[i - 2] + MOD;\n\t\tif (i - m - 2 >= 0)dp[i] -= sum[i - m - 2];\n\t\tdp[i] %= MOD;\n\t\tif (i == N) {\n\t\t\tcout << dp[i] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsum[i] = sum[i - 2] + dp[i];\n\t\tsum[i] %= MOD;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\nconst int MAXN = 200005;\nconst int mod = 1e9 + 7;\n\nint n, m;\nint f[MAXN];\nchar s[MAXN];\nint sum[MAXN];\n\nint main(){\n\tscanf(\"%d %d %s\",&n,&m,s);\n\tfor(int i=0; i<m; i++) if(s[i] == 'R') s[i] = 'A';\n\tif(s[0] == 'B'){\n\t\tfor(int i=0; i<m; i++) s[i] = 'A' + 'B' - s[i];\n\t}\n\tif(count(s, s + m, 'B') == 0){\n\t\tf[0] = 1; f[1] = 2;\n\t\tfor(int i=2; i<=n; i++){\n\t\t\tf[i] = f[i-1] + f[i-2];\n\t\t\tf[i] %= mod;\n\t\t}\n\t\tlint ret = f[n];\n\t\tif(n == 3) ret += mod - 1;\n\t\telse if(n >= 4) ret += mod - f[n - 4];\n\t\tret %= mod;\n\t\tcout << ret << endl;\n\t\treturn 0;\n\t}\n\tint alt = 1e9;\n\tint pref = 0;\n\twhile(s[pref] == 'A') pref++;\n\tfor(int i=0; i<m; i++){\n\t\tif(s[i] == 'B'){\n\t\t\tint e = i + 1;\n\t\t\twhile(s[e] == 'A') e++;\n\t\t\tif(e == n) break;\n\t\t\tif(e > i + 1 && e % 2 == i % 2){\n\t\t\t\talt = min(alt, e - i - 1);\n\t\t\t}\n\t\t\ti = e - 1;\n\t\t}\n\t}\n\tif(n % 2 == 1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint x = min(alt, pref + 1);\n\tf[0] = 1;\n\tsum[0] = 1;\n\tfor(int i=1; i<=n/2; i++){\n\t\tf[i] = sum[i - 1];\n\t\tif(i >= (x + 3) / 2) f[i] += mod - sum[i - (x + 3) / 2];\n\t\tf[i] %= mod;\n\t\tsum[i] = (sum[i-1] + f[i]) % mod;\n\t}\n\tlint ret = 0;\n\tfor(int i=0; i<n;i++){\n\t\tint len = n - 1 - x;\n\t\tif(n - 1 - x > n - 1 - i) continue;\n\t\tret += sum[(n - 1 - i) / 2];\n\t\tif(len >= 1){\n\t\t\tret += mod - sum[(len - 1) / 2];\n\t\t}\n\t}\n\n\tcout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1, typename T2>\ninline bool cmn (T1& a, T2 b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate<typename T1, typename T2>\ninline bool cmx (T1& a, T2 b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\nconstexpr int md = 1e9 + 7;\ninline void mad(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\ninline void msb(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\ninline int mul(int a, int b) {\n  return (int)((long long)a * b % md);\n}\ninline int mow(int a, long long b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n      b--;\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\ntemplate<typename T>\nclass run_length_encoding {\n  vector<pair<int, T>> rle;\n  public:\n    run_length_encoding(\n        vector<T> input\n      ) :\n      rle()\n      {\n        int cnt = 0;\n        for (auto it = input.begin(); it != input.end(); it++) {\n          auto jt = next(it); cnt++;\n          if (jt == input.end() || *it != *jt) {\n            rle.emplace_back(cnt, *it);\n            cnt = 0;\n          }\n        }\n      }\n    auto const& code () const {return rle;}\n};\nint main() {\n  int n, m; string s;\n  cin >> n >> m >> s;\n  vector<int> a(m);\n  for (int i = 0; i < m; i++) a[i] = s[0] == s[i];\n  auto rle = run_length_encoding<int>(a).code();\n  if (rle.size()  == 1) {\n    vector<int> dp(n + 1, 0);\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n      mad(dp[i], dp[i - 1]);\n      mad(dp[i], dp[i - 2]);\n    }\n    for (int i = n; i >= 1; i--) msb(dp[i], dp[i - 1]);\n    int ret = 0;\n    for (int i = 0; i < n; i++) {\n      mad(ret, mul(i + 1, dp[n - i]));\n    }\n    cout << ret << endl;\n    return 0;\n  }\n  if (n & 1) {\n    cout << 0 << endl;\n    return 0;\n  }\n  n >>= 1;\n  int k = 1;\n  for (auto it = rle.begin(); it < rle.end() - 1; it += 2) {\n    int m = it->first;\n    if (m & 1) cmx(k, (m + 1) >> 1);\n    else if (it == rle.begin()) cmx(k, (m + 2) >> 1);\n  }\n  cmn(k, n);\n  vector<int> dp(n + 1, 0);\n  dp[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    mad(dp[i], dp[i - 1]);\n    mad(dp[i], dp[i - 1]);\n    if (i - k - 1 >= 0) msb(dp[i], dp[i - k - 1]);\n  }\n  for (int i = n; i >= 1; i--) msb(dp[i], dp[i - 1]);\n  int ret = 0;\n  for (int i = 0; i < k; i++) {\n    mad(ret, mul(i + 1, dp[n - i]));\n  }\n  mad(ret, ret);\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define mod 1000000007\n#define N 200050\nint n,m,dp[N][2][2],fg,mx,fg2,dp2[N],su[N],as;\nchar s[N];\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tfor(int i=2;i<=m;i++)if(s[i]!=s[i-1])fg=1;\n\tif(!fg)\n\t{\n\t\tdp[1][1][1]=dp[1][0][0]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\tdp[i][0][0]=(dp[i-1][0][0]+dp[i-1][1][0])%mod,\n\t\tdp[i][0][1]=(dp[i-1][0][1]+dp[i-1][1][1])%mod,\n\t\tdp[i][1][0]=dp[i-1][0][0],\n\t\tdp[i][1][1]=dp[i-1][0][1];\n\t\tprintf(\"%lld\\n\",(1ll*dp[n][0][0]+dp[n][0][1]+dp[n][1][0])%mod);\n\t\treturn 0;\n\t}\n\tint su1=0;\n\tfor(int i=1;i<=m;i++)\n\tif(s[i]==s[1])su1++;\n\telse\n\t{\n\t\tif((su1&1)&&mx>su1)mx=su1;\n\t\tif(!fg2)mx=su1+1;\n\t\tfg2=1;\n\t}\n\tif(mx>n)mx=n;\n\tif(~mx&1)mx--;\n\tdp2[1]=1;su[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(i-mx>3)dp2[i]=(su[i-2]-su[i-mx-3]+mod)%mod;\n\t\telse dp2[i]=su[i-2];\n\t\tsu[i]=(su[i-2]+dp2[i])%mod;\n\t}\n\tfor(int i=1;i<=mx;i+=2)as=(as+1ll*dp2[n-i]*(i+1))%mod;\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "//第8回シンデレラガール総選挙は是非本田未央ちゃんに投票をお願いします！\n//ファンのことも他のアイドルの子たちのことも本当に大事にしてて、今まで周りに色んなものを与えてくれました。\n//今度は私たちが未央ちゃんにお返しをする番です。みんなでガラスの靴を履かせてあげましょう！\n// #本田未央を一番星に #本田未央を令和のシンデレラガールに #第8回シンデレラガール総選挙\n#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nlint mo=1000000007;\ntemplate <class typ> struct BIT{\n\tvector<typ> x;\n\tBIT(int n):x(n,0){}\n\ttyp sum(int a,int b){\n\t\tif(a>b) return 0;\n\t\tif(a==0){\n\t\t\ttyp s=0;\n\t\t\tfor(int i=b;i>=0;i=(i&(i+1))-1){\n\t\t\t\ts+=x[i];s%=mo;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\telse return (sum(0,b)-sum(0,a-1)+mo)%mo;\n\t}\n\tvoid add(int ind,typ f){\n\t\tfor(int i=ind;i<x.size();i|=i+1){\n\t\t\tx[i]+=f;x[i]%=mo;\n\t\t}\n\t}\n};\nvector<int> le;\nlint dp[200100][2][2];\nint main()\n{\n\tint n,m,now=0;string s;\n\tcin>>n>>m;\n\tcin>>s;s+='X';\n\trep(i,m){\n\t\tnow++;\n\t\tif(s[i]!=s[i+1]){\n\t\t\tle.pb(now);now=0;\n\t\t}\n\t}\n\tif(le.size()==1){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[1][0][0]=dp[1][1][1]=1;\n\t\tREP(i,1,n) rep(j,2){\n\t\t\tdp[i+1][0][j]+=dp[i][0][j]+dp[i][1][j];\n\t\t\tdp[i+1][1][j]+=dp[i][0][j];\n\t\t\tdp[i+1][0][j]%=mo;\n\t\t\tdp[i+1][1][j]%=mo;\n\t\t}\n\t\tcout<<(dp[n][0][0]+dp[n][0][1]+dp[n][1][0])%mo<<endl;\n\t\treturn 0;\n\t}\n\tif(n%2>0){\n\t\tcout<<0<<endl;return 0;\n\t}\n\tint ma=le[0]/2+1;\n\tfor(int i=0;i<(int)le.size()-1;i+=2){\n\t\tif(le[i]%2>0) ma=min(ma,le[i]/2+1);\n\t}\n\t//cout<<ma<<endl;\n\tBIT<lint> bit(n/2+10);\n\tbit.add(0,1);\n\tREP(i,1,n/2){\n\t\t//cout<<i<<' '<<bit.sum(max(0,i-ma),i-1)<<endl;\n\t\tbit.add(i,bit.sum(max(0,i-ma),i-1));\n\t}\n\tlint out=0;\n\tREP(i,1,min(n/2,ma)+1){\n\t\t//cout<<i<<endl;\n\t\tout+=bit.sum(n/2-i,n/2-i)*i*2;out%=mo;\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\ntypedef double db;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define pct __builtin_popcount\n\n#define P 1000000007\n\n#define N 200010\nint f[N], g[N];\n\nint n, m;\nstring s;\n\nint main() {\n\tcin >> n >> m >> s;\n\tif (s[0] == 'B') {\n\t\tfor (int i = 0; i < m; i ++)\n\t\t\ts[i] = 'R' + 'B' - s[i];\n\t}\n\tif (s == string(m, 'R')) {\n\t\tint fbb = 1, fbr = 0, frb = 0, frr = 1;\n\t\tfor (int i = 1; i < n; i ++) {\n\t\t\tint gbb = fbr;\n\t\t\tint gbr = (fbb + fbr)%P;\n\t\t\tint grb = frr;\n\t\t\tint grr = (frr + frb)%P;\n\t\t\tfbb = gbb;\n\t\t\tfbr = gbr;\n\t\t\tfrb = grb;\n\t\t\tfrr = grr;\n\t\t}\n\t\tint S = ((ll)frr + fbr + frb)%P;\n\t\tcout << S << endl;\n\t\treturn 0;\n\t}\n\tif (n%2 == 1) {\n\t\tputs (\"0\");\n\t\treturn 0;\n\t}\n\n\tbool F = true;\n\tint l = n;\n\tfor (int i = 0; i < n; ) {\n\t\tint j = i;\n\t\twhile (j < n && s[j] == s[i]) j++;\n\t\tif (j == n) break;\n\t\tif ((j-i)%2 == 1) {\n\t\t\tif (s[i] == 'R') l = min(l, j-i);\n\t\t} else {\n\t\t\tif (i == 0) l = min(l, j+1);\n\t\t}\n\t\ti = j;\n\t}\n\tif (!F) {\n\t\tputs (\"0\");\n\t\treturn 0;\n\t}\n\n\tl = (l+1)/2;\n\tn /= 2;\n\tl = min(n, l);\n\n\tf[0] = 1;\n\tg[1] = 1;\n\tfor (int i = 1; i <= n; i ++) {\n\t\tif (i <= l) f[i] = g[i]; else {\n\t\t\tf[i] = (g[i] - g[i-l]+P)%P;\n\t\t}\n\t\tg[i+1] = (g[i] + f[i])%P;\n\t}\n\n\tint S = 0;\n\tfor (int i = 0; i < min(l, n); i ++) {\n\t\tint T = (g[n-i] - g[n-l]+P)%P;\n\t\t// f[n-i-1] + .. + f[n-l];\n\t\t(S += T) %= P;\n\t}\n\n\tS = (ll)S*2%P;\n\tcout << S << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n \nusing namespace std;\n \nconst int MOD = 1000000007;\n \ntemplate<typename T>\nclass RangeAddQuery {\npublic:\n    explicit RangeAddQuery(int n) : N(calcN_(n)) {\n        mVal.assign(2*N+1, 0);\n    }\n    void update(int l, int r, T value){\n        l = max(0, l);\n        r = min(N, r);\n        int offset = N;\n        while(offset > 0){\n            if(l >= r) break;\n            if(l&1){ update_(mVal[offset+l-1], value); l++; }\n            if(r&1){ update_(mVal[offset+r-2], value); }\n            l /= 2;\n            r /= 2;\n            offset /= 2;\n        }\n    }\n    T get(int idx){\n        int i = N + idx - 1;\n        auto res = mVal[i];\n        while(i > 0){\n            i = (i-1)/2;\n            update_(res, mVal[i]);\n        }\n        return res;\n    }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    inline void update_(T& data, T val) { data = (data + val) % MOD; }\n    const int N;\n    vector<T> mVal;\n};\n \nint maxSegment(const string& S){\n    char c = S[0];\n    bool first = true;\n    int cnt = 0;\n    int res = MOD;\n    for(auto& s : S){\n        if(c == s) ++cnt;\n        else {\n            if(first || cnt%2 == 1){\n                res = min(res, cnt/2+1);\n                cnt = 0;\n                first = false;\n            }\n        }\n    }\n    return res < MOD ? res : -1;\n}\n \nint solve(const string& S, int N){\n    int seg = maxSegment(S);\n    if(seg != -1 && N%2 == 1) return 0;\n    long long res = 0;\n    if(seg == -1){\n        assert(false);\n        RangeAddQuery<long long> raq(N);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N;i++){\n            auto a = raq.get(i);\n            raq.update(i+2, N, a);\n        }\n        res = 1;\n        for(int i=N-2;i>=0;i--){\n            res = (res + raq.get(i) * (N-i)) % MOD;\n        }\n    } else {\n        seg = min(seg, N/2);\n        RangeAddQuery<long long> raq(N/2);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N/2;i++){\n            auto a = raq.get(i);\n            raq.update(i+1, i+1+seg, a);\n        }\n        for(int i=N/2-1;i>=N/2-seg;i--){\n            res = (res + raq.get(i) * 2LL * (N/2-i)) % MOD;\n        }\n    }\n    return res;\n}\n \nint main(){\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    cout << solve(S, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-03 17:07:09\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=200010,mod=1000000007;\nint n,m,flag,l,Flag;\ni64 f[N],F[N],ans;\nchar s[N];\nint main()\n{\n\tn=read(); m=read();\n\tscanf(\"%s\",s+1);\n\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\tif(!flag)\n\t{\n\t\tf[0]=1; f[1]=1; f[2]=2;\n\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t\treturn 0;\n\t}\n\tl=n-1;\n\tfor(int i=1,j;i<=m;)\n\t\tif(s[i]==s[1])\n\t\t{\n\t\t\tj=i;\n\t\t\twhile(s[j]==s[1]) j++;\n\t\t\tif(j>n) break;\n\t\t\tif(((j-i)&1)||(!Flag)) l=std::min(l,(j-i)+((j-i)%2==0));\n\t\t\ti=j+1; Flag=1;\n\t\t}\n\t\telse i++;\n\tif(n&1){ printf(\"0\\n\"); return 0; }\n\tn/=2; l=(l+1)/2;\n//\tprintf(\"%d %d\\n\",int(n),int(l));\n\tf[0]=F[0]=1;\n\tfr(i,1,n)\n\t{\n\t\tf[i]=(F[i-1]+mod-(i-l-1>0?F[i-l-1]:0))%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t}\n\tans=f[n];\n\tfr(i,1,l) ans=(ans+f[n-i]*(2*i-1))%mod;\n\tprintf(\"%d\\n\",int(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PI 3.14159265358979323846264338327950288419\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint n, m;\nint col[200005];\n\nint expo(int a, int b){\n\tint c = 1, d = a;\n\twhile(b){\n\t\tif(b & 1){\n\t\t\tc = 1LL * c * d % mod;\n\t\t}\n\t\td = 1LL * d * d % mod;\n\t\tb >>= 1;\n\t}\n\treturn c;\n}\n\nint inv(int x){\n\treturn expo(x, mod - 2);\n}\n\nint calc(int n){\n\tif(n == 2){\n\t\treturn 2;\n\t}\n\t\n\tint fib[200005];\n\tfib[1] = fib[2] = 1;\n\tfor(int i = 3; i <= n + 1; i++){\n\t\tfib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t}\n\t\n\t// force first one to be 1, last one to be 0: fib[N - 1]\n\t// force first one to be 0: fib[N + 1]\n\treturn (fib[n - 1] + fib[n + 1]) % mod;\n}\n\nint calc2(int n, int ub){\n\tassert(ub & 1);\n\t\n\t// want a bunch of numbers, in [2, ub], to sum to n\n\t\n\tub++;\n\tub = min(ub, n); // coz it can actually be HUGE\n\t\n\tint dp[200005]; // dp[i]: number of possible sums, that sum to i\n\tint cumu[200005];\n\t\n\tdp[0] = 1;\n\tcumu[0] = 1;\n\t\n\tfor(int i = 2; i <= n; i += 2){\n\t\t// sum from dp[l_index .. i - 2].. oh, only the even ones!\n\t\tint l_index = i - ub;\n\t//\tprintf(\"%d: sum %d..%d\\n\", i, l_index, r_index);\n\t\tdp[i] = cumu[i - 2];\n\t\t\n\t\tif(l_index > 0){\n\t\t\tdp[i] -= cumu[l_index - 2];\n\t\t\tif(dp[i] < 0){\n\t\t\t\tdp[i] += mod;\n\t\t\t}\n\t\t}\n//\t\tprintf(\"%d: %d\\n\", i, dp[i]);\n\t\tcumu[i] = (cumu[i - 2] + dp[i]) % mod;\n\t}\n\t\n\tint ret = 0;\n\t\n\tfor(int space = 0; space < ub; space++){\n\t\t// last 1 is at (n - space), leaving _ space at the end\n\t\t// where can the first 1 be?\n\t\tint left_pos = 1;\n\t\tint right_pos = ub - space;\n\t\t\n\t\tint most_remain = (n - space) - 1;\n\t\tint least_remain = n - ub;\n\t\t\n\t\tif(most_remain & 1) most_remain--;\n\t\t\n\t\tint combin = cumu[most_remain];\n\t\tif(least_remain > 0){\n\t\t\tcombin = (combin - cumu[least_remain - 2] + mod) % mod;\n\t\t}\n\t\tret = (ret + combin) % mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= m; i++){\n\t\tchar c;\n\t\tscanf(\" %c\", &c);\n\t\tcol[i] = (c == 'B');\n\t}\n\tif(col[1] != 0){\n\t\t// WLOG first one is 0\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tcol[i] = 1 - col[i];\n\t\t}\n\t}\n\t\n\tbool monochrome = true;\n\tfor(int i = 2; i <= m; i++){\n\t\tif(col[i]){\n\t\t\tmonochrome = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(monochrome){\n\t\t// ok as long as 1s are not adjacent\n\t\tprintf(\"%d\\n\", calc(n));\n\t\treturn 0;\n\t}else{\n\t\t// 00...010..010..0\n\t\t// each block of 0 is of add length\n\t\t// so, n odd -> definitely no solution\n\t\t// more conditions depending on specifics of col[]\n\t\tif(n % 2 == 1){\n\t\t \tprintf(\"0\\n\");\n\t\t \treturn 0;\n\t\t}\n\t\tint first_run = 0, subseq_run = n - 1;\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tint len = 0;\n\t\t\twhile(i + len <= m && col[i + len] == 0){\n\t\t \t\tlen++;\n\t\t \t}\n\t\t \tif(first_run == 0){\n\t\t \t\tfirst_run = len;\n\t\t \t}else if(len & 1){\n\t\t \t\tsubseq_run = min(subseq_run, len);\n\t\t \t}\n\t\t \ti += len;\n\t\t}\n\t\tint ub = first_run + (first_run % 2 == 0);\n\t\tub = min(ub, subseq_run);\n\t\tprintf(\"%d\\n\", calc2(n, ub));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define lld long double\nusing namespace std;\nconst int N = 101000;\nchar c[N];\nint main(){\n\tsprintf(c,\"p=int(1e9+7)\\ndef calc(n,l,r):\\n\\tf=[0]* (n+1)\\n\\tf[0]=1\\n\\tsum=0\\n\\tfor i in range (1,n+1):\\n\\t\\tif i>=l:\\n\\t\\t\\tsum+=f[i-l]\\n\\t\\tf[i]=sum%%p\\n\\t\\tif (i>=r):\\n\\t\\t\\tsum-=f[i-r]\\n\\tans=0\\n\\tfor i in range (l,r+1):\\n\\t\\tans=(ans+f[n-i]*i)%%p\\n\\treturn ans\\nn,m=input().split()\\nn=int(n)\\nm=int(m)\\ns=input()\\na=s.split(chr(ord('R')+ord('B')-ord(s[0])))\\nif len(a)==1:\\n\\tprint((calc(n,2,n)+1)%%p)\\nelif n%%2==1:\\n\\tprint(0)\\nelse:\\n\\tr=len(a[0])+1-len(a[0])%%2\\n\\tfor i in range(1,len(a)-1):\\n\\t\\tif len(a[i])%%2==1 :\\n\\t\\t\\tr=min(r,len(a[i]));\\n\\tn=n//2\\n\\tr=(r+1)//2\\n\\tprint(calc(n,1,r)*2%%p)\\n\");\n\tstring out;\n\tout=\"python3 -c \\\"\";\n\tint len=strlen(c);\n\tfor(int i=0;i<len;i++)\n\t\tout+=c[i];\n\tout+=\"\\\"\";\n\tsystem(out.data());\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll md = 1e9+7;\n\nvector<ll> calc(int n, int k){\n\tvector<ll> todo(n);\n\ttodo[0] = -1;\n\tif(n > 1) todo[1] = 1;\n\tvector<ll> ans(n);\n\trep(i,0,n){\n\t\tans[i] = -todo[i];\n\t\tif(i+1 < n) todo[i+1] = (todo[i+1] + 2*todo[i]) % md;\n\t\tif(i + k+1 < n) todo[i+k+1] = (todo[i+k+1] - todo[i]) % md;\n\t}\n\treturn ans;\n}\n\nvector<ll> calc1(int n, int k){\n\tvector<ll> todo(n);\n\ttodo[0] = -1;\n\tif(n > 1) todo[1] = 1;\n\tvector<ll> ans(n);\n\trep(i,0,n){\n\t\tans[i] = -todo[i];\n\t\tif(i+1 < n) todo[i+1] = (todo[i+1] + todo[i]) % md;\n\t\tif(i+2 < n) todo[i+2] = (todo[i+2] + todo[i]) % md;\n\t\tif(i + k+1 < n) todo[i+k+1] = (todo[i+k+1] - todo[i]) % md;\n\t}\n\treturn ans;\n}\n\nll solve(){\n\tint n, m;\n\tstring s;\n\tcin >> n >> m >> s;\n\tif(s[0]=='B') trav(c, s) c = 'B'+'R'-c;\n\tif(count(all(s), 'R') == m){\n\t\tll ans = 1;\n\t\tauto dp = calc1(n, n);\n\t\tfor(int l = 1; l < n; ++l)\n\t\t\tans += (l+1) * dp[n-l-1] % md;\n\t\treturn ans;\n\t} else {\n\t\tif(n%2) return 0;\n\t\tint mx = n-1;\n\t\trep(i,0,m) if(s[i]=='B' && s[i-1]=='R'){\n\t\t\tint j = i-1;\n\t\t\twhile(j >= 0 && s[j] =='R') --j;\n\t\t\tif(j == -1) mx = min(mx, 2*i-1);\n\t\t\telse if((i-j)%2) mx = min(mx, i-j);\n\t\t}\n\t\tauto dp = calc(n/2, (mx+1)/2);\n\t\tll ans = 0;\n\t\tfor(int l = 1; l <= mx; l += 2)\n\t\t\tans += (l+1) * dp[(n-l-1)/2] % md;\n\t\tans %= md;\n\t\treturn ans;\n\t}\n}\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\n\tll res = solve();\n\tres %= md;\n\tif(res < 0) res += md;\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3e5 + 5, mod = 1e9 + 7;\nint dp[N], sum[N];\n\nchar s[N];\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  scanf(\"%s\", s);\n  bool same = 1;\n  for (int i = 0; i < m; ++i)\n    if (s[i] != s[0])\n      same = 0;\n  if (same) {\n    dp[0] = 1;\n    for (int i = 1; i <= n; ++i) {\n      dp[i] = dp[i-1];\n      if (i > 1)\n        dp[i] = (dp[i] + dp[i-2]) % mod;\n    }\n    int ans = (dp[n] + dp[n-2]) % mod;\n    printf(\"%d\\n\", ans);\n    return 0;\n  }\n  int cnt = 0;\n  while (s[cnt] == s[0]) ++cnt;\n  if ((cnt & 1) == 0)\n    ++cnt;\n  int cur = 0;\n  for (int i = 0; i < m; ++i) {\n    if (s[i] != s[0]) {\n      if (cur & 1) {\n        cnt = min(cnt, cur);\n      }\n      cur = 0;\n    }\n    else {\n      ++cur;\n    }\n  }\n  dp[0] = 1;\n  sum[0] = 1;\n  for (int i = 2; i <= n; i += 2) {\n    dp[i] = sum[i-2] - (i - (cnt+3) >= 0 ? sum[i - (cnt+3)] : 0);\n    dp[i] %= mod;\n    if (dp[i] < 0)\n      dp[i] += mod;\n    sum[i] = (dp[i] + sum[i-2]) % mod;\n  }\n  int ans = dp[n];\n  for (int i = 2; i <= n && i <= cnt+1; i += 2) {\n    ans = (ans + 1LL * dp[n-i] * (i-1)) % mod;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  if(vs==vector<Int>(m,1)){\n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n\n  if(n&1){\n    cout<<0<<endl;\n    return 0;\n  }\n  \n  Int lim=n-1;  \n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    Int j=i;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n    \n    if(i==0) chmin(lim,(j-i)+(~(j-i)&1));    \n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }  \n  \n  vector<M> dp(n+2,0),sm(n+2,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n+1;i++){\n    sm[i]=sm[i-1]+dp[i-1];\n    if(i&1) dp[i]=sm[i-1]-sm[max<Int>(1,i-1-lim)];\n  }\n  \n  M ans{0};\n  for(Int i=0;i<n;i++)\n    if(n-i+1>=max<Int>(1,n-lim))\n      ans+=sm[n-i+1]-sm[max<Int>(1,n-lim)];\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200010;\nconst int mod = 1e9 + 7;\n\ntypedef long long LL;\n\nchar s[N];\n\nint f[N], g[N], dp[2][2][N];\n\nint main() {\n    int n, m; scanf(\"%d%d%s\", &n, &m, s + 1);\n    bool flag = false;\n    for (int i = 1; i <= m; i++) if (s[i] != s[1]) {\n        flag = true; break;\n    } \n    if (flag) {\n        if (n & 1) return puts(\"0\"), 0;\n        int fir = 0;\n        for (int i = 1; i <= m; i++) if (s[i] != s[1]) {\n            fir = i - 1; break;\n        }\n        int lim = fir | 1;\n        for (int i = fir + 1; i <= m; i++) if (s[i] != s[1]) {\n            int j = i + 1;\n            while (j <= m && s[j] == s[1]) j++;\n            if (j <= m && (j - i - 1) % 2 == 1) lim = min(lim, j - i - 1); \n        } \n        n /= 2, lim = (lim + 1) / 2;\n        for (int i = 1; i <= lim; i++) f[i] = i * 2;\n        for (int i = 1, diff = 0; i <= n; i++) {\n            diff = (diff + g[i]) % mod, f[i] = (f[i] + diff) % mod;\n            if (i + 1 <= n) g[i + 1] = (g[i + 1] + f[i]) % mod;\n            if (i + lim + 1 <= n) g[i + lim + 1] = (g[i + lim + 1] - f[i] + mod) % mod;\n        }\n        printf(\"%d\\n\", f[n]);\n    } else {\n        dp[1][1][1] = dp[0][0][1] = 1;\n        for (int i = 2; i <= n; i++) \n            for (int t = 0; t <= 1; t++) {\n                dp[t][0][i] = (dp[t][1][i - 1] + dp[t][0][i - 1]) % mod;\n                dp[t][1][i] = dp[t][0][i - 1];\n            }\n        printf(\"%d\\n\", ((LL)dp[1][0][n] + dp[0][0][n] + dp[0][1][n]) % mod);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 100010\n#define int long long\n#define mod 1000000007\n#define debug cerr<<__LINE__<<\" \"<<__FUNCTION__<<\"\\n\"\n\ninline int read(){\n    int x=0,y=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n    return x*y;\n}\nvoid put(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>=10) put(x/10);\n    putchar((x%10)+48);\n}\nint n,m,A[N],B[N];\nstring s;\nsigned main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tn=read();m=read();\n\tcin>>s;\n\tif(s[0]=='B'){\n\t\tfor(int i=0;i<m;i++) s[i]=(s[i]=='B'?'R':'B');\n\t}\n\tint pos=s.find('B');\n\tif(pos==string::npos){\n\t\tA[1]=A[2]=1;\n\t\tfor(int i=3;i<=n;i++) A[i]=(A[i-1]+A[i-2])%mod;\n\t\tcout<<(A[n]+2*A[n-1]%mod)%mod<<\"\\n\";\n\t\treturn 0;\n\t}\n\tif(n&1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint l=n,res=0,flag=0;\n\tfor(int i=0;i<m;i++){\n\t\tif(s[i]=='B'){\n\t\t\tif(flag) l=min(l,res+(res&1));\n\t\t\tflag=1;\n\t\t\tres=0;\n\t\t}\n\t\tres++;\n\t}\n//\tcout<<l<<\"\\n\";\n\tl/=2;n/=2;\n\tA[0]=B[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tA[i]=B[i-1];\n\t\tif(i>l) A[i]=(A[i]-B[i-l-1]+mod)%mod;\n\t\tB[i]=(B[i-1]+A[i])%mod;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=l;i++){\n\t\tans=(ans+2*i%mod*A[n-i]%mod)%mod;\n\t}\n\tcout<<ans<<\"\\n\";\n//\tfclose(stdin);\n//\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (200010)\n#define P (1000000007)\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c){\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,m,f[N]; char s[N];\nvoid spj(){\n\tint f[N][2];\n\tfor(int i=1;i<=n;i++)if(s[i]=='R')return;\n\tint ans=0; f[1][0]=0,f[1][1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tf[i][0]=f[i-1][1];\n\t\tf[i][1]=(f[i-1][0]+f[i-1][1])%P;\n\t}\n\t(ans+=(f[n][0]+f[n][1])%P)%=P;\n\tf[1][0]=1,f[1][1]=0,f[2][0]=0,f[2][1]=1;\n\tfor(int i=3;i<=n;i++){\n\t\tf[i][0]=f[i-1][1];\n\t\tf[i][1]=(f[i-1][0]+f[i-1][1])%P;\n\t}\n\t(ans+=f[n][1])%=P;\n\tprintf(\"%d\\n\",ans);\n\texit(0);\n}\nint main(){\n\tread(n),read(m);\n\tfor(int i=1;i<=m;i++)readc(s[i]);\n\tif(s[0]=='R'){for(int i=1;i<=m;i++)s[i]^='R'^'B';}\n\tspj(); int lst=m,lim=n,cnt=0; while(s[lst]=='B')lst--;\n\tfor(int i=lst;~i;i--)\n\tif(!i||s[i]=='B'){\n\t\tif(cnt&1)lim=min(lim,cnt+1);\n\t\telse if((!i)&&cnt)lim=min(lim,cnt+2);\n\t\tcnt=0;\n\t}\n\telse cnt++;\n\tf[0]=f[2]=1;\n\tfor(int i=4;i<=n;i++){\n\t\tf[i]=1ll*f[i-2]*2%P;\n\t\tif(i-2>=lim)f[i]=(f[i]-f[i-lim-2]+P)%P;\n\t}\n\tint ans=0;\n\tfor(int i=2;i<=lim;i+=2)\n\t(ans+=1ll*f[n-i]*i%P)%=P;\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nllint solve(llint n,llint K){\n\tllint i;\n\tif(K>n){\n\t\tllint ans=1;\n\t\twhile(n--){ans*=2;ans%=mod;}\n\t\treturn ans;\n\t}\n\t//円環上にAマークとBマーク\n\t//BマークがKこ連続してはいけない\n\tvector<llint>dp(n+1);//最後のAマーク\n\tllint gen=1;//くぎりてん\n\tdp[0]=1;//最後のBマーク\n\tfor(i=1;i<n;i++){\n\t\tdp[i]=gen;\n\t\tgen*=2;\n\t\tif(i-K>=0){gen-=dp[i-K];}\n\t\tgen+=mod;gen%=mod;\n\t}\n\tllint ans=0;\n\tfor(i=1;i<=K;i++){\n\t\tans+=i*dp[n-i];\n\t\tans%=mod;\n\t}\n\treturn ans;\n}\nint main(void){\n\tint i,n,m;cin>>n>>m;\n\tstring S;cin>>S;\n\tvector<int>suu;\n\tchar now=S[0];\n\tint ban=0;\n\tfor(i=0;i<m;i++){\n\t\tif(S[i]==now){ban++;}\n\t\telse{suu.pub(ban);ban=1;}\n\t\tnow=S[i];\n\t}\n\tsuu.pub(ban);\n\t//for(auto it:suu){cerr<<it<<endl;}\n\tif(suu.size()==1){\n\t\tcout<<solve(n,2)<<endl;\n\t\treturn 0;\n\t}\n\tif(n%2==1){cout<<0<<endl;return 0;}\n\tint sei=suu[0];\n\tif(suu[0]%2==0){sei=suu[0]+1;}\n\tfor(i=2;i+1<suu.size();i+=2){\n\t\tif(suu[i]%2==1){mineq(sei,suu[i]);}\n\t}\n\tsei++;\n\t//cerr<<sei<<endl;\n\tcout<<(2*solve(n/2,sei/2))%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing std::min;\n\nconst int MOD=1000000007;\n\nconst int MAXN=200011, MAXM=200011;\n\ninline int sum(const int &a, const int &b){\n\treturn (a+b>=MOD)?(a+b-MOD):(a+b);\n}\n\ninline int mul(const int &a, const int &b){\n\treturn (int)((1LL*a*b)%(long long)(MOD));\n}\n\ninline void add(int &f, const int &v){\n\tf+=v;if(f>=MOD)\tf-=MOD;\n}\n\nint N, M;\nint A[MAXM];\nchar input[MAXM];\nint F[MAXN];\n\ninline bool AllZero(){\n\tint Cnt=0;\n\tfor(int i=1;i<=M;++i)\tCnt+=!A[i];\n\treturn Cnt==M;\n}\n\nint main(){\n\t\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", input);\n\tfor(int i=1;i<=M;++i)\tA[i]=input[i-1]!=input[0];\n\t\n\tif(AllZero()){\n\t\tint F[2][2], T[2][2];\n\t\tF[0][0]=F[1][1]=1;\n\t\tF[0][1]=F[1][0]=0;\n\t\tfor(int i=2;i<=N;++i){\n\t\t\tfor(int s=0;s<2;++s)\n\t\t\t\tfor(int n=0;n<2;++n)\n\t\t\t\t\tT[s][n]=0;\n\t\t\tfor(int s=0;s<2;++s)\n\t\t\t\tfor(int n=0;n<2;++n)\n\t\t\t\t\tfor(int c=0;c<2;++c)\n\t\t\t\t\t\tif(n+c<2)\tT[s][c]+=F[s][n];\n\t\t\tfor(int s=0;s<2;++s)\n\t\t\t\tfor(int n=0;n<2;++n)\n\t\t\t\t\tF[s][n]=T[s][n];\n\t\t}\n\t\tint Ans=0;\n\t\tfor(int s=0;s<2;++s)\n\t\t\tfor(int n=0;n<2;++n)\n\t\t\t\tif(s+n<2)\tadd(Ans, F[s][n]);\n\t\tprintf(\"%d\\n\", Ans);\n\t}\n\telse{\n\t\tint Lim=N;\n\t\tfor(int i=1, c=0, p=0;i<=N;++i){\n\t\t\tif(A[i]){\n\t\t\t\tif(c&1)\tLim=min(Lim, c+1);\n\t\t\t\telse if(!p)\tLim=min(Lim, c+2);\n\t\t\t\tc=0;p=i;\n\t\t\t}\n\t\t\telse\t++c;\n\t\t}\n\t\tF[0]=F[2]=1;\n\t\tfor(int i=4;i<=N;i+=2){\n\t\t\tF[i]=sum(F[i-2], F[i-2]);\n\t\t\tif(i>=Lim+2){\n\t\t\t\tadd(F[i], MOD-F[i-(Lim+2)]);\n\t\t\t}\n\t\t}\n\t\tint Ans=0;\n\t\tfor(int i=2;i<=Lim;i+=2){\n\t\t\tadd(Ans, mul(F[N-i], i));\n\t\t}\n\t\tprintf(\"%d\\n\", Ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register\nchar ss[1001000];\nconst int mod=1e9+7;\nint f[1001000],ff[1001000][2][2],x[2];\nint main()\n{\n\tre int n,m,ans=1,xx=0,mmx=1<<30;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",ss+1);\n\tfor(re int i=1;i<=m;i++)\n\t{\n\t\tif(ss[i]!=ss[1])\n\t\t{\n\t\t\tif(xx<mmx)mmx=xx;\n\t\t\txx=0;ans=0;\n\t\t}else xx++;\n\t}\n\tif(ans==1)\n\t{\n\t\tff[1][0][0]=ff[1][1][1]=1;\n\t\tfor(re int i=2;i<=n;i++)\n\t\t{\n\t\t\tfor(re int j=0;j<=1;j++)\n\t\t\t{\n\t\t\t\tff[i][j][0]=(ff[i-1][j][0]+ff[i-1][j][1])%mod;\n\t\t\t\tff[i][j][1]=ff[i-1][j][0];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",((long long)ff[n][0][0]+ff[n][0][1]+ff[n][1][0])%mod);\n\t\treturn 0;\n\t}\n\tmmx+=2;\n\tif(mmx&1)mmx--;\n\tf[0]=f[2]=1;\n\tfor(re int i=4;i<=n;i++)\n\t{\n\t\tf[i]=(2ll*f[i-2]+(i-mmx-2>=0?mod-f[i-mmx-2]:0))%mod;\n\t\t//printf(\"**%d %d %d\\n\",i,f[i],mmx);\n\t}\n\tfor(re int i=2;i<=mmx&&i<=n;i+=2)ans=(ans+(long long)i*f[n-i])%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass EGoAroundACircle {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, M; cin >> N >> M;\n        string S; cin >> S;\n\n        char c = S[0];\n        int d = 1, m = -1, so = 1e9;\n        for (int i = 1; i < M; ++i) {\n            if (S[i] == c) {\n                d++;\n            } else {\n                if (m == -1) m = d;\n                if (d % 2 == 1) so = min(so, d);\n                d = 0;\n            }\n        }\n\n        if (m == -1) {\n            vector2<FieldMod> X(N, 2, 0);\n            X[0][0] = 1;\n            for (int i = 1; i < N; ++i) {\n                X[i][0] = X[i - 1][0] + X[i - 1][1];\n                X[i][1] = X[i - 1][0];\n            }\n\n            vector2<FieldMod> Y(N, 2, 0);\n            Y[0][1] = 1;\n            for (int i = 1; i < N; ++i) {\n                Y[i][0] = Y[i - 1][0] + Y[i - 1][1];\n                Y[i][1] = Y[i - 1][0];\n            }\n\n\n            cout << X.back()[0] + X.back()[1] + Y.back()[0] << endl;\n            return;\n        }\n\n        if (N % 2 == 1) {\n            cout << 0 << endl;\n            return;\n        }\n\n        m = min(m, so);\n        // max size of consecutive Rs => m\n        int b = min(N/2, m/2 + 1);\n\n        vector<FieldMod> H(N/2, 0);\n        FieldMod tot = 1;\n        H[0] = 1;\n        for (int j = 1; j < N/2; ++j) {\n            if (j > b)  tot -= H[j-b-1];\n            H[j] = tot;\n            tot += H[j];\n        }\n\n        FieldMod ans = 0;\n        for (int i = 1; i <= b; ++i) {\n            ans += i * H[N/2-i];\n        }\n        cout << 2*ans << endl;\n\n\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tEGoAroundACircle solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e5+10,inf=0x3f3f3f3f,mod=1e9+7;\nchar s[maxn];\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\ty>>=1;\n\t\tx=(ll)x*x%mod;\n\t}\n\treturn res;\n}\nint dp[maxn],sum[maxn];\nint main(){\n\tint n=read(),m=read();\n\tscanf(\"%s\",s+1);\n\tint Min=inf;\n\tfor(int i=1,j;i<=m;i++) if(s[i]==s[1]){\n\t\tj=i;\n\t\twhile(j<m && s[j+1]==s[1]) ++j;\n\t\tif(j-i+1%2==1) chkmin(Min,j-i+1);\n\t\telse if(i==1) chkmin(Min,j-i+2);\n\t\ti=j;\n\t}\n\tint flag=1;\n\tREP(i,2,n) flag&=(s[i]==s[1]);\n\tdp[1]=sum[1]=1;\n\tREP(i,2,n+1){\n\t\tif(flag){\n\t\t\tdp[i]=sum[i-2];\n\t\t\tsum[i]=(sum[i-1]+dp[i])%mod;\n\t\t}\n\t\telse{\n\t\t\tdp[i]=(sum[i-2]-sum[max(i-Min-3,0)]+mod)%mod;\n\t\t\tsum[i]=(sum[i-2]+dp[i])%mod;\n\t\t}\n\t}\n\tint ans=(dp[n+1]*2+flag)%mod;\n\tREP(i,1,n-2) if(((n-i)%2==1 || flag) && n-i<=Min) ans=(ans+(ll)dp[i]*(n-i-1))%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nchar str[200005];\nint arr[200005];\nlong long MOD=1000000007;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",str);\n\tfor(int i=0;i<m;i++)if(str[i]=='R')arr[i]=0;else arr[i]=1;\n\tbool all[2];all[0]=all[1]=1;\n\tfor(int i=0;i<m;i++)all[arr[i]^1]=0;\n\tif(all[0]||all[1]){\n\t\tlong long dp[2][n];memset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;dp[1][0]=0; //start with red (or blue if everything is blue)\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tlong long ans=(dp[0][n-1]+dp[1][n-1])%MOD; //end with red or blue\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=0;dp[1][0]=1; //start with blue\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tans+=dp[0][n-1];ans%=MOD;ans+=MOD;ans%=MOD; //only end with red\n\t\tprintf(\"%lld\",ans);\n\t\treturn 0;\n\t}\n\tif(n%2!=0){printf(\"0\");return 0;}\n\tint s=0,l=n-1;\n\tfor(int i=0;i<m;i++){\n\t\tint cur=0;\n\t\twhile(i+cur<m&&arr[i+cur]==arr[0]){\n\t\t\tcur++;\n\t\t}\n\t\tif(s==0)s=cur|1;\n\t\telse if(i+cur<m&&cur%2!=0)l=min(l,cur);\n\t\ti+=cur;\n\t}\n\tint mxl=min(s,l);\n\t//comments: wlog red is first\n\t//can ignore last segment of red\n\tn/=2; mxl/=2; //remove the ones that are different parity from blue\n\tlong long dp[100005],pref[100005];\n\tmemset(dp,0,sizeof(dp));memset(pref,0,sizeof(pref));\n\t//i segments on a line, first and last are blue, max mxl consecutive reds\n\t//blues may be consecutive because the reds in between were removed\n\tdp[1]=pref[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tdp[i]=pref[i-1]-pref[max(0,i-(mxl+2))];\n\t\tdp[i]%=MOD;dp[i]+=MOD;dp[i]%=MOD;\n\t\tpref[i]=dp[i]+pref[i-1];\n\t\tpref[i]%=MOD;pref[i]+=MOD;pref[i]%=MOD;\n\t}\n\tlong long ans=0;\n\tfor(long long i=2;i<=min(n,mxl+2);i++){\n\t\tans+=(i-1LL)*dp[n-i+2];\n\t\tans%=MOD;\n\t}\n\tans+=MOD;ans%=MOD;\n\tprintf(\"%lld\",(ans*2)%MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass EGoAroundACircle {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, M; cin >> N >> M;\n        string S; cin >> S;\n        char c = S[0];\n        int d = 1, m = -1, so = 1e9;\n        for (int i = 1; i < M; ++i) {\n            if (S[i] == c) {\n                d++;\n            } else {\n                if (m == -1) m = d;\n                if (d % 2 == 1) so = min(so, d);\n                d = 0;\n            }\n        }\n\n        if (N % 2 == 1) {\n            if (m == -1) {\n                vector2<FieldMod> X(N, 2, 0);\n                X[0][0] = 1;\n                for (int i = 1; i < N; ++i) {\n                    X[i][0] = X[i-1][0] + X[i-1][1];\n                    X[i][1] = X[i-1][0];\n                }\n\n                vector2<FieldMod> Y(N, 2, 0);\n                Y[0][1] = 1;\n                for (int i = 1; i < N; ++i) {\n                    Y[i][0] = Y[i-1][0] + Y[i-1][1];\n                    Y[i][1] = Y[i-1][0];\n                }\n\n\n                cout << X.back()[0] + X.back()[1] + Y.back()[0] << endl;\n            } else {\n                cout << 0 << endl;\n            }\n            return;\n        }\n\n        if (m == -1) {\n            cout << FieldMod{2}.pow(N/2) * 2 - 1;\n            return;\n        }\n\n        if (m % 2 == 0) ++m;\n        m = min(m, so);\n        // max size of consecutive Rs => m\n        int b = min(N/2, (m+1)/2);\n\n        vector<FieldMod> H(N/2, 0);\n        FieldMod tot = 1;\n        H[0] = 1;\n        for (int j = 1; j < N/2; ++j) {\n            if (j > b)  tot -= H[j-b-1];\n            H[j] = tot;\n            tot += H[j];\n        }\n\n//        cout << H;\n        FieldMod ans = 0;\n        for (int i = 1; i <= b; ++i) {\n            ans += i * H[N/2-i];\n        }\n        cout << 2*ans << endl;\n\n\n//        int ans = 0;\n//        for (int i = 0; i < (1<<N); ++i) {\n//            vector<bool> A(N, true);\n//            for (int j = M-1; j >= 0; --j) {\n//                int s = (S[j] == 'R') ? 1 : 0;\n//                vector<bool> B(N, false);\n//                for (int k = 0; k < N; ++k) {\n//                    if (!A[k]) continue;\n//                    int l = k == 0 ? N-1 : k-1;\n//                    int r = k == N-1 ? 0 : k+1;\n//                    if (((i>>l)&1) == s) B[l] = true;\n//                    if (((i>>k)&1) == s) B[r] = true;\n//                }\n//                swap(A,B);\n//            }\n//\n//            if (count(A.begin(),A.end(),true) == N) {\n//                ans++;\n////                for (int j = 0; j < N; ++j) {\n////                    cout << \"BR\"[(i>>j)&1];\n////                }\n////                cout << endl;\n//            }\n//        }\n//        cout << ans << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tEGoAroundACircle solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 2e5 + 10,mod = 1e9 + 7;\n\nchar str[N];\nint dp[N];\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Add(int &x,int y) { if((x += y) >= mod) x -= mod; }\ninline int chk(int v) { return v < 0 ? 0 : dp[v]; }\ninline int val(int v) { return v & 1 ? v - 1 : v; }\n\nint main() {\n\n\tint n = read(),m = read(),flag = true;\n\tscanf(\"%s\",str + 1);\n\tFor(i,1,m - 1) if(str[i] != str[i + 1]) flag = false;\n\tif(flag) {\n\t\tint v00 = 1,v11 = 1,v01 = 0,v10 = 0;\n\t\tFor(i,2,n) {\n\t\t\tint c00 = v00,c10 = v10;\n\t\t\tAdd(v00,v10),Add(v10,v11);\n\t\t\tv01 = c00,v11 = c10;\n\t\t}\n\t\tprintf(\"%lld\\n\",(1ll * v00 + v10 + v01) % mod);\n\t\treturn 0;\n\t}\n\tif(n & 1) return puts(\"0\"),0;\n\tint v = INF,tot = 0;\n\tFor(i,1,m) {\n\t\tif(str[i] == str[1]) tot++;\n\t\telse {\n\t\t\tif(tot == i - 1) chkmin(v,tot + (tot % 2 == 0));\n\t\t\tif(tot & 1) chkmin(v,tot);\n\t\t\ttot = 0;\n\t\t}\n\t}\n\tv++, dp[0] = 1;\n\tfor(int i = 2;i <= n;i += 2) dp[i] = (2ll * dp[i - 2] - chk(i - 2 - v)) % mod;\n\tint ans = dp[n] - dp[n - 2];\n\tFor(i,1,v - 1) ans = (ans + dp[val(n - i - 1)] - dp[n - v - 2]) % mod;\n\tprintf(\"%d\\n\",(ans + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define Md 1000000007\n#define MN 200005\nint n,m;\nchar c[MN];\nlg Pow(lg x,lg y){\n\tlg res=1;for(;y;y>>=1,x=x*x%Md)if(y&1)res=res*x%Md;return res;\n}\nint Fix(int x){\n\tif(x<0)return x+Md;\n\tif(x>=Md)return x-Md;\n\treturn x;\n}\nint dp[MN],tmp[MN];\nint miu[MN];\nint main(){\n\tread(n);read(m);\n\tscanf(\"%s\",c+1);\n\tmiu[1]=1;\n\tfor(int i=1;i<MN;++i){\n\t\tfor(int j=i+i;j<MN;j+=i){\n\t\t\tmiu[j]-=miu[i];\n\t\t}\n\t}\n\tchar Hd=c[1];\n\tint cnt=0,mx;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse break;\n\t}\n\tif(cnt&1)mx=cnt;else mx=cnt+1;\n\tif((n&1)||cnt==m){\n\t\tif(cnt!=m)return puts(\"0\"),0;\n\t\tint res=0;\n\t\ttmp[0]=tmp[1]=1;\n\t\tdp[0]=1;\n\t\tif(n>2)res=n;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tdp[i]=(i>=2?tmp[i-2]:0);\n\t\t\ttmp[i]=Fix(tmp[i-1]+dp[i]);\n\t\t\tif(i<n-1)res=Fix(res+1ll*dp[i]*(n-i)%Md);\n\t\t\t//cerr<<res<<\"????\"<<i<<endl;\n\t\t}\n\t\tprintf(\"%d\",res+1);\n\t\treturn 0;\n\t}\n\tint res=(cnt==m);\n\tcnt=0;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse{\n\t\t\tif(!cnt)continue;\n\t\t\tif(cnt&1)mx=min(mx,cnt);\n\t\t\tcnt=0;\n\t\t}\n\t}\n\t//for(int i=1;i<=5;++i)cerr<<miu[i]<<' ';cerr<<endl;\n\ttmp[0]=tmp[1]=1;\n\tdp[0]=1;\n\tmx+=2;\n\tif(n<mx)res+=n;\n\tfor(int i=2;i<=n;i+=2){\n\t\tdp[i]=Fix(tmp[i-1]-(mx>i?0:tmp[i-mx]));\n\t\ttmp[i]=tmp[i+1]=Fix(tmp[i-1]+dp[i]);\n\t\t//cerr<<dp[i]<<' '<<i<<endl;\n\t\tif((n-i)%2==0&&n-i<mx)res=Fix(res+1ll*dp[i]*(n-i)%Md);\n\t}\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MAX_N 200000\n#define MAX_M 200000\n#define MOD 1000000007\n\n#define INF 1 << 29\n\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nint N, M;\nstring S;\n\n// long long dp[MAX_N + 2], rdp[MAX_N + 2];\n\n// int all_color_is_same()\n// {\n//     long long rr = 1, bb = 1, rb = 0, br = 0;\n\n//     for ( int i = 1; i < N; i++ )\n//     {\n//         long long nrr = ( rr + rb ) % MOD;\n//         long long nbb = br;\n//         long long nrb = rr;\n//         long long nbr = ( bb + br ) % MOD;\n\n//         rr = nrr;\n//         bb = nbb;\n//         rb = nrb;\n//         br = nbr;\n//     }\n\n//     return ( rr + rb + br ) % MOD;\n// }\n\n// /**\n\n/* S\nの先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n*/\nint min_freq()\n{\n    // int l = 0;\n    // while ( l < M && S[0] == S[l] ) l++;\n\n    // int ans = ( l & 1 ) ? l : l + 1;\n\n    // l = 0;\n    // for ( int i = 0; i < M; i++ )\n    // {\n    //     if ( S[0] == S[i] )\n    //         l++;\n    //     else\n    //     {\n    //         if ( l & 1 ) ans = min( ans, l );\n    //         l = 0;\n    //     }\n    // }\n    // return ( l & 1 ) ? min( ans, l ) : ans;\n    Int l = 0;\n    while ( S[0] == S[l] ) l++;\n    if ( l % 2 == 0 ) l++;\n    Int limit = l;\n    l = 0;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[i] == S[0] )\n            l++;\n        else\n        {\n            if ( l % 2 == 1 ) limit = min( limit, l );\n            l = 0;\n        }\n    }\n    return limit;\n}\n\n// int solve()\n// {\n//     // 一色\n//     if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n//         return all_color_is_same();\n\n//     // N が奇数\n//     if ( N & 1 ) return 0;\n\n//     int L = min_freq();\n\n//     L = ( L + 1 ) >> 1;\n//     N >>= 1;\n\n//     dp[0] = rdp[0] = 1;\n//     for ( int i = 1; i <= N + 1; i++ )\n//     {\n//         dp[i] = rdp[i - 1];\n//         if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n//         if ( dp[i] < 0 ) dp[i] += MOD;\n//         rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n//     }\n\n//     long long res = 0;\n//     for ( int i = 1; i <= L; i++ )\n//         if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n//     return res % MOD;\n// }\n\n// int main( int argc, char **argv )\n// {\n//     cin >> N >> M;\n//     cin >> S;\n\n//     int ans = solve();\n\n//     cout << ans << endl;\n\n//     return 0;\n// }\n\nInt all( Int n )\n{ // no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for ( int i = 1; i < n; i++ )\n    {\n        Int nrr = ( rr + rb ) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = ( bb + br ) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return ( rr + rb + br ) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc( Int n, Int limit )\n{\n    dp[0] = 1;\n    rdp[0] = 1;\n    for ( int i = 1; i <= n + 1; i++ )\n    {\n        dp[i] = ( rdp[i - 1] -\n                  ( ( i - limit - 1 ) >= 0 ? rdp[i - limit - 1] : 0 ) ) %\n                MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n}\n\nInt solve( Int n, Int limit )\n{\n    if ( n % 2 == 1 ) return 0;\n    if ( limit % 2 != 1 ) exit( 1 );\n    limit = ( limit + 1 ) / 2;\n    n /= 2;\n    Int res = 0;\n    calc( n + 10, limit );\n    for ( Int i = 1; i <= limit; i++ )\n    {\n        if ( n - i >= 0 ) res = ( res + dp[n - i] * 2 * i ) % MOD;\n    }\n    if ( res < 0 ) exit( 1 );\n    return res % MOD;\n}\n\nint main()\n{\n    cin >> N >> M;\n    cin >> S;\n\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n    {\n        cout << all( N ) << endl;\n        return 0;\n    }\n\n    int limit = min_freq();\n    // cout << limit << endl;\n    cout << solve( N, limit ) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=200005,M=1e9+7;\nint n,m,f[N],g[N],ans;\nchar s[N];\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tif (s[1]=='R'){\n\t\tfor (int i=1;i<=m;i++){\n\t\t\tif (s[i]=='R')s[i]='B';\n\t\t\telse s[i]='R';\n\t\t}\n\t}\n\tint l=0,mi=0;\n\tfor (int i=1;i<=m;i++)\n\t\tif (s[i]=='R'){\n\t\t\tl=i-1;\n\t\t\tbreak;\n\t\t}\n\tif (!l){\n\t\tf[0]=g[0]=1;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tf[i]=g[i-2];\n\t\t\tg[i]=(g[i-1]+f[i])%M;\n\t\t}\n\t\tfor (int i=2;i<=n;i++)(ans+=i*f[n-i])%=M;\n\t\tprintf(\"%lld\\n\",ans+1);\n\t\treturn 0;\n\t}\n\tmi=l+!(l%2);\n\tfor (int i=1,j=1;i<=m;i=j){\n\t\twhile (j<=m&&s[j]=='B')j++;\n\t\tif ((j-i)&1)mi=min(mi,j-i);\n\t\twhile (j<=m&&s[j]=='R')j++;\n\t}\n\tif (n%2==1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tmi=(mi+1)/2;\n\tn/=2;\n\tf[0]=g[0]=1;\n\tfor (int i=1;i<=n;i++){\n\t\tf[i]=(g[i-1]-(i-mi-1<0?0:g[i-mi-1])+M)%M;\n\t\tg[i]=(g[i-1]+f[i])%M;\n\t}\n\tfor (int i=1;i<=mi;i++)(ans+=i*2*f[n-i])%=M;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\nconst ll mod = 1000000007;\nll N, M;\nstring S;\n\nll beki(ll a, ll b) {\n    if(b == 0) return 1;\n    ll ans = beki(a, b / 2);\n    ans = ans * ans % mod;\n    if(b % 2 == 1) ans = ans * a % mod;\n    return ans;\n}\n\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<ll> node;\n \npublic:\n    SegmentTree() {\n        int sz = 200050;\n        n = 1; while(n < sz) n *= 2;\n        node.resize(2*n-1, 0);\n        for(int i=0; i<sz; i++) node[i+n-1] = 0;\n        for(int i=n-2; i>=0; i--) node[i] = min(node[2*i+1], node[2*i+2]);\n    }\n \n    void update(int x, ll val) {\n        x += (n - 1);\n        node[x] = val;\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node[x] = (node[2*x+1] + node[2*x+2]) % mod;\n        }\n    }\n    // hannkaikukann \n    ll getsum(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return 0;\n        if(a <= l && r <= b) return node[k];\n \n        ll vl = getsum(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getsum(a, b, 2*k+2, (l+r)/2, r);\n        return (vl + vr) % mod;\n    }\n};\n\nint main() {\n    //cout.precision(10);\n    cin >> N >> M;\n    cin >> S;\n    if(S[0] == 'B') {\n        for(int i = 0; i < M; i++) {\n            if(S[i] == 'B') S[i] = 'R';\n            else S[i] = 'B';\n        }\n    }\n    bool all = true;\n    for(int i = 0; i < M; i++) {\n        if(S[i] == 'B') all = false;\n    }\n    ll Rlen = 0;\n    for(int i = 0; i < S.size(); i++) {\n        if(S[i] == 'R') Rlen++;\n        else break;\n    }\n    //Rlen = Rlen * 2 + 1;\n    if(Rlen % 2 == 0) {\n        Rlen = Rlen  + 1;\n    } else {\n        Rlen = Rlen;\n    }\n    ll Rnow = -INF;\n    for(int i = 0; i < S.size(); i++) {\n        //cerr << Rnow << endl;\n        if(S[i] == 'R') {\n            Rnow++;\n            continue;\n        }\n        if(Rnow < 0) {\n            Rnow = 0;\n            continue;\n        }\n        if(Rnow % 2 == 0) {\n            Rnow = 0;\n            continue;\n        }\n        Rlen = min(Rlen, Rnow);\n        Rnow = 0;\n    }\n    if(all) {\n        SegmentTree seg;\n        seg.update(1, 1);\n        for(int i = 2; i <= N + 1; i++) {\n            ll val = seg.getsum(1, i - 1);\n            seg.update(i, val);\n        }\n        ll ans = 0;\n        for(ll now = 1; now <= N - 1; now++) {\n            ans += now * seg.getsum(N - now, N - now + 1);\n            ans %= mod;\n        }\n        ans += seg.getsum(N+1, N+2);\n        ans += 1;\n        ans %= mod;\n        cout << ans << endl;\n        return 0;\n    }\n    SegmentTree seg;\n    seg.update(1, 1);\n    cerr << Rlen << endl;\n    //Rlen = 5;\n    for(int i = 3; i <= N + 2; i += 2) {\n        ll val = seg.getsum(max((ll)0, i - 1 - Rlen), i);\n        seg.update(i, val);\n        //cerr << i << \" \" << val << endl;\n    }\n    ll ans = 0;\n    if(N % 2 == 1) {\n        cout << 0 << endl;\n        return 0;\n    }\n    for(ll now = 1; now <= min(N, Rlen); now += 2) {\n        ans += now * seg.getsum(N - now, N - now + 1);\n        ans %= mod;\n    }\n    ans += seg.getsum(N + 1, N + 2);\n    ans %= mod;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline tuple<int, int, int> extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nunsigned ModInt::MOD = 1000000007;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\n\n\nconst int limit = 200010;\nmint dp[limit];\nmint csum[limit];\nmint dp2[limit][2][2];\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\n\tbool same = true;\n\trep(i, m) if(s[0] != s[i]) same = false;\n \n\tif(same){\n\t\tdp2[1][0][0] = ONE;\n\t\tdp2[1][1][1] = ONE;\n\t\trep(i, 1, n) rep(start, 2) rep(prv, 2){\n\t\t\tdp2[i + 1][start][0] += dp2[i][start][prv];\n\t\t\tif(prv == 0) dp2[i + 1][start][1] += dp2[i][start][prv];\n\t\t}\n\t\tmint ans = dp2[n][0][0] + dp2[n][0][1] + dp2[n][1][0];\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\n\tint cmin = n, cons = 0;\n\n\trep(i, m){\n\t\tif(s[i] == s[0]){\n\t\t\tcons++;\n\t\t} else {\n\t\t\tchmin(cmin, cons);\n\t\t\tcons = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trep(i, m){\n\t\tif(s[i] == s[0]){\n\t\t\tcons++;\n\t\t} else {\n\t\t\tif(cons % 2 == 1) chmin(cmin, cons);\n\t\t\tcons = 0;\n\t\t}\n\t}\n\n\tif(cmin % 2 == 0) cmin++;\n\tdp[1] = csum[1] = ONE;\n\n\trep(i, 1, n){\n\t\tconst int pos = max(i - cmin - 1, 0);\n\t\tif((i + 1) % 2 == 1) dp[i + 1] =  csum[i] - csum[pos];\n\t\tcsum[i + 1] = csum[i] + dp[i + 1];\n\t}\n\n\tmint ans = ZERO;\n\n\trep(i, max(0, n - cmin), n + 1){\n\t\tconst mint coef = mint(n - i + 1);\n\t\tans += coef * dp[i];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll md = 1e9+7;\n\nvector<ll> calc(int n, int k){\n\tvector<ll> todo(n);\n\ttodo[0] = -1;\n\tif(n > 1) todo[1] = 1;\n\trep(i,0,n){\n\t\tif(i+1 < n) todo[i+1] = (todo[i+1] + 2*todo[i]) % md;\n\t\tif(i + k+1 < n) todo[i+k+1] = (todo[i+k+1] - todo[i]) % md;\n\t\ttodo[i] *= -1;\n\t}\n\treturn todo;\n}\n\nvector<ll> calc1(int n){\n\tvector<ll> todo(n);\n\ttodo[0] = -1;\n\tif(n > 1) todo[1] = 1;\n\tvector<ll> ans(n);\n\trep(i,0,n){\n\t\tif(i+1 < n) todo[i+1] = (todo[i+1] + todo[i]) % md;\n\t\tif(i+2 < n) todo[i+2] = (todo[i+2] + todo[i]) % md;\n\t\ttodo[i] *= -1;\n\t}\n\treturn todo;\n}\n\nll solve(){\n\tint n, m;\n\tstring s;\n\tcin >> n >> m >> s;\n\tif(s[0]=='B') trav(c, s) c = 'B'+'R'-c;\n\tif(count(all(s), 'R') == m){\n\t\tll ans = 1;\n\t\tauto dp = calc1(n-1);\n\t\tfor(int l = 1; l < n; ++l)\n\t\t\tans += (l+1) * dp[n-l-1] % md;\n\t\treturn ans;\n\t} else {\n\t\tif(n%2) return 0;\n\t\tint mx = n-1;\n\t\trep(i,0,m) if(s[i]=='B' && s[i-1]=='R'){\n\t\t\tint j = i-1;\n\t\t\twhile(j >= 0 && s[j] =='R') --j;\n\t\t\tif(j == -1) mx = min(mx, 2*i-1);\n\t\t\telse if((i-j)%2) mx = min(mx, i-j);\n\t\t}\n\t\tauto dp = calc(n/2, (mx+1)/2);\n\t\tll ans = 0;\n\t\tfor(int l = 1; l <= mx; l += 2)\n\t\t\tans += (l+1) * dp[(n-l-1)/2] % md;\n\t\treturn ans;\n\t}\n}\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\n\tll res = solve();\n\tres %= md;\n\tif(res < 0) res += md;\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n\t*\tAuthor: huhao\n\t*\tEmail: 826538400@qq.com\n\t*\tCreate time: 2020-02-03 17:07:09\n\t****************************************************************/\n\t#include<stdio.h>\n\t#include<string.h>\n\t#include<math.h>\n\t#include<algorithm>\n\t#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n\t#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\n\tint read()\n\t{\n\t\tint r=0,t=1,c=getchar();\n\t\twhile(c<'0'||c>'9')\n\t\t{\n\t\t\tt=c=='-'?-1:1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\t\tc=getchar();\n\t\t}\n\t\treturn r*t;\n\t}\n\t#define i64 long long\n\tconst int N=2000010,mod=1000000007;\n\ti64 n,m,flag,l,Flag;\n\ti64 f[N],F[N],ans;\n\tchar s[N];\n\tnamespace std\n\t{\n\t\tint main()\n\t\t{\n\t\t\ti64 i,j,t;\n\t\t\tfor(i=1;i<=m;i++) if(s[i]!=s[1]) break;\n\t\t\tif(i-1+((i-1)%2==0)!=l) exit(1);\n\t\t\tl=i-1;\n\t\t\tif(l%2==0) l++;\n\t\t\tfor(t=0;i<=m;i++)\n\t\t\t{\n\t\t\t\tif(s[i]==s[1]) t++;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(t&1) l=min(l,t);\n\t\t\t\t\tt=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tn/=2,l=(l+1)/2;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint main()\n\t{\n\t\tn=read(); m=read();\n\t\tscanf(\"%s\",s+1);\n\t\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\t\tif(!flag)\n\t\t{\n\t\t\tf[0]=1; f[1]=1; f[2]=2;\n\t\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t\t\treturn 0;\n\t\t}\n\t\tfor(int i=1,j;i<=m;)\n\t\t\tif(s[i]==s[1])\n\t\t\t{\n\t\t\t\tj=i;\n\t\t\t\twhile(s[j]==s[1]) j++;\n\t\t\t\tif(j>n) break;\n\t\t\t\tif(!Flag) l=j-i+((j-i)%2==0);\n\t//\t\t\telse if((j-i)&1) l=std::min(l,(i64)(j-i));\n\t\t\t\ti=j+1; Flag=1;\n\t\t\t}\n\t\t\telse i++;\n\t\tif(n&1){ printf(\"0\\n\"); return 0; }\n\t\tstd::main();\n\t//\tprintf(\"%d %d\\n\",int(n),int(l));\n\t\tf[0]=F[0]=1;\n\t\tfr(i,1,n)\n\t\t{\n\t\t\tf[i]=(F[i-1]+mod-(i-l-1>=0?F[i-l-1]:0))%mod;\n\t\t\tF[i]=(F[i-1]+f[i])%mod;\n\t//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t\t}\n\t\tans=f[n];\n\t\tfr(i,1,l) ans=(ans+f[n-i]*(2*i-1))%mod;\n\t\tprintf(\"%d\\n\",int(ans));\n\t\treturn 0;\n\t}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact, _inv;\n\n  Combination(ll sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for(ll i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(ll i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for(ll i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(ll k) const { return _fact[k]; }\n\n  inline T rfact(ll k) const { return _rfact[k]; }\n\n  inline T inv(ll k) const { return _inv[k]; }\n\n  T P(ll n, ll r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n\n  T H(ll n, ll r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\nusing modint = ModInt< MOD1 >;modint pow(ll n, ll x){return modint(n).pow(x);}modint pow(modint n, ll x){return n.pow(x);}\n//using modint=ld;\nusing Comb=Combination<modint>;\n\n\ntemplate<typename T>\nstruct BIT{\n  ll n;\n  ll k=1;\n  vector<T>data;\n  BIT() = default;\n  BIT(ll size):n(size){\n    data.assign(n,0);\n    while(k*2<=n)k*=2;\n  }\n  void add(ll a,T w){\n    for(ll i=a+1;i<=n;i+=i&-i)data[i-1]+=w;\n  }\n  T sum(ll a){\n\tif(a<0)return 0;\n    T ret = 0;\n    for(ll i=a+1;i>0;i-=i&-i)ret+=data[i-1];\n    return ret;\n  }\n  T sum(ll a,ll b){return a>b?0:sum(b)-sum(a-1);}\n  T operator[](ll pos){\n    return sum(pos,pos);\n  }\n  ll lower_bound(ll x){\n    ll ret=0;    \n    for(ll i=k;i>0;i/=2){\n      if(ret+i<=n&&data[ret+i-1]<x){\n        x-=data[ret+i-1];\n        ret+=i;\n      }\n    }\n    return ret;\n  }\n  void print(){\n    for(ll i=0;i<n;i++){\n      if(i!=0)cout<<\" \";\n      cout<<(*this)[i];\n    }\n    cout<<endl;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,m;cin>>n>>m;\n  string s;cin>>s;\n  if(s[0]=='B'){\n    rep(i,0,m){\n      if(s[i]=='R')s[i]='B';\n      else s[i]='R';\n    }\n  }\n  ll mx=INF;\n  {\n    vector<ll>v;\n    ll cnt=0;\n    rep(i,0,m){\n      if(s[i]=='R')cnt++;\n      else{\n        v.PB(cnt);\n        cnt=0;\n      }\n    }\n    if(v.empty()){\n        assert(0);\n      modint tmp=0;\n      Comb comb(300005);\n      rep(i,0,n+1){\n        tmp+=comb.C(n-i-1,i-1)*2+comb.C(n-i-1,i);\n      }\n      cout<<tmp<<endl;\n      return 0;\n    }\n    rep(i,0,v.size()){\n      if(i==0||v[i]&1)chmin(mx,v[i]);\n    }\n    if(~mx&1)mx++;\n  }\n  vector<modint>v(n+1);\n  BIT<modint>bit(n+1);\n  bit.add(0,1);\n  rep(i,0,n){\n    if(~i&1)continue;\n    bit.add(i+1,bit.sum(max(0LL,i-mx),i));\n  }\n  modint ret=0;\n  rep(i,0,n+1){\n    ret+=bit.sum(max(0LL,n-mx-1),n-i-1);\n    //cout<<n-mx-1 spa n-i spa bit.sum(n-mx-1,n-i)<<endl;\n  }\n  //bit.print();\n  //debug(v,n+1);\n  cout<<ret<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int md=1000000007;\nconst int mxn=200005;\nint n,m,mx,ans,dp[mxn],f[mxn];\nchar s[mxn];\ninline void add(int&x,int y){\n\tx+=y;\n\tif(x>=md)x-=md;\n}\nsigned main(){\n\tint i,j,t;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(i=1;i<=m;++i)if(s[i]!=s[1])break;mx=i-1;\n\tif(mx==m){\n\t\tdp[0]=f[i]=ans=1;\n\t\tfor(int i=0;i<=n;++i){\n\t\t\tif(i>=2)dp[i]=f[i-2];\n\t\t\tf[i]=(f[i-1]+dp[i])%md;\n\t\t\tif(n-i>1)add(ans,(ll)dp[i]*(n-i)%md);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(n&1)return 0*puts(\"0\");\n\tif(!(mx&1))++mx;\n\tfor(t=0;i<=m;++i){\n\t\tif(s[i]==s[1])++t;\n\t\telse{\n\t\t\tif(t&1)mx=min(mx,t);\n\t\t\tt=0;\n\t\t}\n\t}\n\tn>>=1,mx=mx+1>>1;\n\tdp[0]=f[0]=1;\n\tfor(i=0;i<=n;++i){\n\t\tif(i)dp[i]=(md+f[i-1]-(i-mx-1>=0?f[i-mx-1]:0))%md,f[i]=(f[i-1]+dp[i])%md;\n\t\tif(n-i<=mx) add(ans,(ll)(n-i)*dp[i]*2ll%md);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nusing std::min;\n\nconst int MOD=1000000007;\n\nconst int MAXN=200011, MAXM=200011;\n\ninline int sum(const int &a, const int &b){\n\treturn (a+b>=MOD)?(a+b-MOD):(a+b);\n}\n\ninline int mul(const int &a, const int &b){\n\treturn (int)((1LL*a*b)%(long long)(MOD));\n}\n\ninline void add(int &f, const int &v){\n\tf+=v;if(f>=MOD)\tf-=MOD;\n}\n\nint N, M;\nint A[MAXM];\nchar input[MAXM];\nint F[MAXN];\n\ninline bool AllZero(){\n\tint Cnt=0;\n\tfor(int i=1;i<=M;++i)\tCnt+=!A[i];\n\treturn Cnt==M;\n}\n\nint main(){\n\t\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", input);\n\tfor(int i=1;i<=M;++i)\tA[i]=input[i-1]!=input[0];\n\t\n\tif(AllZero()){\n\t\tint F[2][2], T[2][2];\n\t\tF[0][0]=F[1][1]=1;\n\t\tF[0][1]=F[1][0]=0;\n\t\tfor(int i=2;i<=N;++i){\n\t\t\tfor(int s=0;s<2;++s)\n\t\t\t\tfor(int n=0;n<2;++n)\n\t\t\t\t\tT[s][n]=0;\n\t\t\tfor(int s=0;s<2;++s)\n\t\t\t\tfor(int n=0;n<2;++n)\n\t\t\t\t\tfor(int c=0;c<2;++c)\n\t\t\t\t\t\tif(n+c<2)\tadd(T[s][c], F[s][n]);\n\t\t\tfor(int s=0;s<2;++s)\n\t\t\t\tfor(int n=0;n<2;++n)\n\t\t\t\t\tF[s][n]=T[s][n];\n\t\t}\n\t\tint Ans=0;\n\t\tfor(int s=0;s<2;++s)\n\t\t\tfor(int n=0;n<2;++n)\n\t\t\t\tif(s+n<2)\tadd(Ans, F[s][n]);\n\t\tprintf(\"%d\\n\", Ans);\n\t}\n\telse{\n\t\tint Lim=N;\n\t\tfor(int i=1, c=0, p=0;i<=M;++i){\n\t\t\tif(A[i]){\n\t\t\t\tif(c&1)\tLim=min(Lim, c+1);\n\t\t\t\telse if(!p)\tLim=min(Lim, c+2);\n\t\t\t\tc=0;p=i;\n\t\t\t}\n\t\t\telse\t++c;\n\t\t}\n\t\tF[0]=F[2]=1;\n\t\tfor(int i=4;i<=N;i+=2){\n\t\t\tF[i]=sum(F[i-2], F[i-2]);\n\t\t\tif(i>=Lim+2){\n\t\t\t\tadd(F[i], MOD-F[i-(Lim+2)]);\n\t\t\t}\n\t\t}\n\t\tint Ans=0;\n\t\tfor(int i=2;i<=Lim;i+=2){\n\t\t\tadd(Ans, mul(F[N-i], i));\n\t\t}\n\t\tprintf(\"%d\\n\", Ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\tconst int N=2e5+9,mod=1e9+7;\n\tinline int add(int x,int y){return x+y>=mod?x-mod+y:x+y;}\n\tinline int sub(int x,int y){return x>=y?x-y:x+mod-y;}\n\tinline int qpow(int x,int y){\n\t\tint ret=1;\n\t\twhile(y){\n\t\t\tif(y&1) ret=1LL*x*ret%mod;\n\t\t\tx=1LL*x*x%mod,y>>=1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint n,m,f[N],sum[N];char s[N];\n\tint main(){\n\t\tn=read<int>(),m=read<int>(),scanf(\"%s\",s+1);\n\t\t\n\t\tint peg=1;\n\t\tfor(int i=2;i<=m;i++) if(s[1]!=s[i]) peg=0;\n\t\tif(peg){\n\t\t\tf[0]=1,f[1]=0,sum[0]=sum[1]=1;\n\t\t\tfor(int i=2;i<=n;i++)\n\t\t\t\tf[i]=sum[i-2],sum[i]=add(sum[i-1],f[i]);\n\t\t//\tfor(int i=1;i<=n;i++) cout<<f[i]<<\" \";cout<<endl;\n\t\t\tint ans=0;\n\t\t\tfor(int i=2;i<=n;i++) ans=add(ans,1LL*f[n-i]*i%mod);\n\t\t\tprintf(\"%d\\n\",add(ans,1));\n\t\t\treturn 0;\n\t\t}\n\t\tint mx=0,i,t;\n\t\tfor(i=1;i<=m;i++)\n\t\t\tif(s[i]!=s[1]){mx=i-1+(~(i-1)&1);break;}\n\t\tfor(t=0;i<=m;i++)\n\t\t\tif(s[i]!=s[1]){\n\t\t\t\tif(t&1) mx=min(mx,t);\n\t\t\t\tt=0;\n\t\t\t}else t++;\n\n\t\tf[0]=1,f[1]=0,sum[0]=sum[1]=1;\n\t\tfor(i=2;i<=n;i++){\n\t\t\tf[i]=sub(sum[i-2],i-mx-2>=0?sum[i-mx-2]:0),sum[i]=sum[i-1];\n\t\t\tif(~i&1) sum[i]=add(sum[i],f[i]);\n\t\t}\n\t//\tfor(int i=1;i<=n;i++) cout<<f[i]<<\" \";cout<<endl;\n\t\tint ans=0;\n\t\tfor(int i=2;i<=mx+1;i++) if(~i&1) ans=add(ans,1LL*f[n-i]*i%mod);\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define Pr(f,...) printf(f,##__VA_ARGS__),fflush(stdout)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define lop(i,s,t) for(int i=s;i<(t);++i)\nusing namespace std; \n\nconst int N=200050,P=1e9+7; \n\nint n,m,limit,f[N],sum[N]; \nchar s[N]; \n\nint main(int argc,char *argv[]){\n//\tfreopen(\"d.in.cpp\",\"r\",stdin); \n    scanf(\"%d%d%s\",&n,&m,s); \n    if(s[0]=='B')lop(i,0,m)s[i]=s[i]=='R'?'B':'R';\n\t//Pr(\"%d,%d,%s\\n\",n,m,s);  \n    while(m&&s[m-1]=='R')--m;\n    if(m==0){\n    \tf[0]=2,f[1]=1;\n\t\trep(i,2,n)f[i]=(f[i-1]+f[i-2])%P;\n\t\tprintf(\"%d\\n\",f[n]); \n\t\treturn 0; \t\n    }\n    if(n%2!=0){\n        puts(\"0\"); \n        return 0; \n    }\n    limit=n-1; \n    for(int p=0,prv=0;p<m;++p){\n        while(p<m&&s[p]=='R')++p;\n\t\tif(prv==0){\n            if(p-prv%2==1)limit=p-prv;\n            else limit=p-prv+1;\n        }\n        if((p-prv)%2==1)limit=min(limit,p-prv);\n        //printf(\"%d\\n\",p-prv); \n        prv=p+1;\n    }          \n    //Pr(\"limit=%d\\n\",limit); \n\tf[1]=sum[1]=0,f[2]=sum[2]=2;\n\tfor(int i=4;i<=n;i+=2){\n\t\tsum[i-1]=(sum[i-2]+f[i-1])%P;\n\t\tif(i<=limit+1)(f[i]+=i)%=P;\n\t\t(f[i]+=(sum[i-1]-sum[max(1,i-limit-2)]+P)%P)%=P;\n\t\tsum[i]=(sum[i-1]+f[i])%P;\n\t}\n\tprintf(\"%d\\n\",f[n]); \n    return 0; \n}    "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint N, M; char S[200200];\n\nconst long long mod = 1000000007;\nlong long D[200200], V[200200];\n\nint main()\n{\n\tscanf (\"%d %d %s\", &N, &M, S);\n\tif (S[0] == 'B'){\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tif (S[i] == 'R') S[i] = 'B';\n\t\t\telse S[i] = 'R';\n\t\t}\n\t}\n\n\tvector<int> len;\n\tfor (int i = 1, l = -1; i < M; i++){\n\t\tif (S[i-1] == 'R' && S[i] == 'B'){\n\t\t\tint u = i - l - 1;\n\t\t\tlen.push_back(u);\n\t\t\tl = i;\n\t\t}\n\t}\n\n\tif (len.empty()){\n\t\tif (N == 2){\n\t\t\tprintf (\"3\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tD[0] = 1;\n\t\tD[1] = 1;\n\t\tfor (int i = 2; i <= N; i++) D[i] = (D[i - 1] + D[i - 2]) % mod;\n\t\tprintf (\"%lld\\n\", (D[N - 1] + D[N - 3] + 1) % mod);\n\t\treturn 0;\n\t}\n\n\tint lim = len[0] * 2 - 1;\n\tfor (int i = 1; i < len.size(); i++){\n\t\tif (len[i] % 2){\n\t\t\tif (lim > len[i])\n\t\t\t\tlim = len[i];\n\t\t}\n\t}\n\n\tD[0] = V[0] = 1;\n\tfor (int i = 1; i <= N; i++){\n\t\tif (i <= lim + 1) D[i] = i - 1;\n\t\tlong long u = 0, v = 0;\n\t\tif (i >= 2) u = V[i - 2];\n\t\tif (i >= lim + 3) v = V[i - (lim + 3)];\n\t\tD[i] = (D[i] + u + mod - v) % mod;\n\n\t\tV[i] = D[i];\n\t\tif (i >= 2) V[i] = (V[i] + V[i - 2]) % mod;\n\t}\n\tprintf (\"%lld\\n\", D[N]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\ntemplate<typename T>\nstruct SegmentTree{\nprivate:\n    int n;\n    T E;\n    vector<T> node;\n    inline void updatef(T& x,T& y){\n        x = y;\n        //x += y;\n        //x = max(x,y);\n        //x = min(x,y);\n    }\n    inline T queryf(T& x,T& y){\n        //return x*y;\n        return (x+y)%mod;\n        //return max(x,y);\n        //return min(x,y);\n    }\n\npublic:\n    SegmentTree(int sz,T E_):E(E_){\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n    }\n\n    SegmentTree(vector<T>& A,T E_):E(E_){\n        int sz=A.size();\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n        rep(i,sz)node[i+n-1]=A[i];\n        for(int i=n-2;i>=0;--i){\n            node[i]=queryf(node[2*i+1], node[2*i+2]);\n        }\n    }\n    void update(int k,T x){\n        k+=n-1;\n        updatef(node[k],x);\n        while(k>0){\n            k=(k-1)/2;\n            node[k]=queryf(node[2*k+1], node[2*k+2]);\n        }\n    }\n       //[a,b)での和を返す\n    T get(int a,int b,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        if(r<=a||b<=l)return E;\n        if(a<=l&&r<=b)return node[k];\n        T xl=get(a,b,2*k+1,l,(l+r)/2);\n        T xr=get(a,b,2*k+2,(l+r)/2,r);\n        return queryf(xl, xr);\n    }\n};\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n    fact.resize(n+1);\n    inv.resize(n+1);\n    invfact.resize(n+1);\n    fact[0]=inv[0]=invfact[0]=1;\n    inv[1]=1;\n    rep(i,n){\n        fact[i+1]=fact[i]*(i+1)%mod;\n        if(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n        invfact[i+1]=invfact[i]*inv[i+1]%mod;\n    }\n}\nll perm(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n    k%=mod-1;\n    if(k<0)k+=mod-1;\n    ll ret=1;\n    while(k){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\nint main(){\n    int n,m;\n    cin>>n>>m;\n    string s;\n    cin>>s;\n    int len=0;\n    while(len<m&&s[len]==s[0])++len;\n    if(len==m){\n        vector<ll> ans(n+5);\n        ans[0]=2,ans[1]=1;\n        rep(i,n-1)ans[i+2]=(ans[i+1]+ans[i])%mod;\n        cout<<ans[n]<<endl;\n        return 0;\n    }\n    if(n%2){\n        cout<<0<<endl;\n        return 0;\n    }\n    if (len%2==0)++len;\n    int cnt=0;\n    rep(i,n){\n        if(s[i]!=s[0]){\n            if(cnt%2)len=min(len,cnt);\n            cnt=0;\n        }\n        else ++cnt;\n    }\n    n/=2;\n    len = (len+1)/2;\n    SegmentTree<ll> sg(n+5,0);\n    sg.update(0,1);\n    rep(i,n+1){\n        ll ret=sg.get(max(0,i+1-len),i+1);\n        sg.update(i+1,ret);\n    }\n    ll ans=0;\n    rep(i,min(n,len)){\n        ans+=sg.get(max(0,n-len),n-i);\n    }\n    cout<<2*ans%mod<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n;\nint m;\nstring s;\nint mn = INF;\nll ans ;\nll dp[200005][2][2];\n\nstruct RMQ{\n\t#define ss (1<<19)\n\tll seg[ss];\n\tvoid update(int k,ll a){\n\t\tk+=ss/2-1; seg[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tseg[k]=(seg[k*2+1]+seg[k*2+2])%mod;\n\t\t}\n\t}\n\tll query(int a,int b,int k,int l,int r){\n\t\tif(r<a || b<l) return 0;\n\t\tif(a<=l && r<=b) return seg[k];\n\t\telse{\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2+1,r);\n\t\t\treturn (vl+vr)%mod;\n\t\t}\n\t}\n}rmq[2];\n\nint main(){\n\tcin>>n>>m>>s;\n\tif(s[0] == 'B'){\n\t\trep(i,m){\n\t\t\tif(s[i] == 'B') s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\t\tint cur = 0;\n\t\tchar ch;\n\t\tbool beg = 0;\n\t\tint C = 0;\n\t\trep(i,m){\n\t\t\tif(i == 0){\n\t\t\t\tch = s[i];\n\t\t\t\tcur = 1;\n\t\t\t}\n\t\t\telse if(ch != s[i]){\n\t\t\t\tif(ch == 'R'){\n\t\t\t\t\tif(cur%2 == 1) mn = min(mn,cur);\n\t\t\t\t\telse if(!beg) mn = min(mn,cur+1);\n\t\t\t\t\tbeg = 1; C++;\n\t\t\t\t}\n\t\t\t\t\tch = s[i];\n\t\t\t\t\tcur = 1;\n\t\t\t//\t\tbeg = 1; C++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse cur++;\n\t\t}\n\t\t\t\tif(ch == 'R'){\n\t\t\t\t\tif(cur%2 == 1) mn = min(mn,cur);\n\t\t\t\t\telse if(!beg) mn = min(mn,cur+1);\n\t\t\t\t\tbeg = 1; C++;\n\t\t\t\t}\n\t\t\t\t//cout<<C<<endl;\n\t\t\t\t\t//ch = s[i];\n\t\t\t\t\tcur = 1;\n\t\t\t//\t\tbeg = 1; C++;\n\t\t\t//cout<<C<<\" \"<<mn<<endl;\n\t\tif(C == 1){\n\t\t    //assert(mn == m);\n\t\t\t//BBが存在しなければOK\n\t\t\tdp[0][0][0] = dp[0][1][1] = 1;\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\trep(x,2){\n\t\t\t\t\tdp[i+1][0][x] += dp[i][0][x];\n\t\t\t\t\tdp[i+1][1][x] += dp[i][0][x];\n\t\t\t\t\tdp[i+1][0][x] += dp[i][1][x];\n\t\t\t\t\tdp[i+1][0][x] %= mod;\n\t\t\t\t\tdp[i+1][1][x] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<((dp[n-1][0][0]+dp[n-1][0][1]+dp[n-1][1][0])%mod+mod)%mod<<endl;\n\t\t\t//assert(0);\n\t\t}\n\t\telse{\n\t\t\tif(n%2 == 1){\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[0][0][0] = 1;\n\t\t\trmq[0].update(0,1);\n\t\t\tfor(int i=2;i<n;i+=2){\n\t\t\t\tdp[i][0][0] = rmq[i%2].query(max(0,i-mn-1),i,0,0,(1<<18)-1);\n\t\t\t\trmq[i%2].update(i,dp[i][0][0]);\n\t\t\t}\n\t\t\tll ans = 0;\n\t\t\tfor(int m=1;m<=n;m++){\n\t\t\t\tif(m-1 > mn) continue;\n\t\t\t\tif((m-1)%2 == 0) continue;\n\t\t\t\tans += dp[n-m][0][0] * 1LL * m % mod;\n\t\t\t}\n\t\t\tcout << (ans%mod+mod)%mod << endl;\n\t\t\n\t\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll dp[202020][2][2];\nll mo=1000000007;\n\nll dp2[202020];\nll dps[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\tif(S[0]=='B') {\n\t\tFORR(c,S) c='R'+'B'-c;\n\t}\n\tif(count(ALL(S),'B')==0) {\n\t\tdp[0][0][0]=dp[0][1][1]=1;\n\t\tfor(i=1;i<N;i++) {\n\t\t\t(dp[i][0][0]=dp[i-1][0][0]+dp[i-1][0][1])%=mo;\n\t\t\t(dp[i][0][1]=dp[i-1][0][0])%=mo;\n\t\t\t(dp[i][1][0]=dp[i-1][1][0]+dp[i-1][1][1])%=mo;\n\t\t\t(dp[i][1][1]=dp[i-1][1][0])%=mo;\n\t\t}\n\t\tcout<<(dp[N-1][0][0]+dp[N-1][0][1]+dp[N-1][1][0])%mo<<endl;\n\t\treturn;\n\t}\n\t\n\tint L=0;\n\twhile(S[L]=='R') L++;\n\t\n\tif(L%2==0) L++;\n\t\n\tdp2[0]=dps[0]=dps[1]=1;\n\tfor(i=2;i<=N;i++) {\n\t\tif(i%2==0) {\n\t\t\tdp2[i]=dps[i-2];\n\t\t\tif(i-(L+1)>0) dp2[i]+=mo-dps[i-(L+1)-1];\n\t\t\tdp2[i]%=mo;\n\t\t}\n\t\t(dps[i]=dps[i-1]+dp2[i])%=mo;\n\t\t//cout<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=min(L,N-1);i+=2) {\n\t\t//cout<<i<<\" \"<<(i+1)<<\"*\"<<dp2[N-(i+1)]<<endl;\n\t\t(ret+=(i+1)*dp2[N-(i+1)])%=mo;\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+10;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    ans = dp[n+1];\n    for(ll i = 1;i<=lim;i+=2)\n    {\n        ans += (i*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[0] = 1;\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-2]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    int mn = 1e9;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1<<18, mod = 1e9 + 7;\nint n, m, pr = 0, dp[maxn], p[maxn][2];\nstring s;\nint corner() {\n\tdp[0] = 2, dp[1] = 1;\n\tfor(int i = 2; i <= n; i++) dp[i] = (dp[i-1] + dp[i-2])%mod;\n\treturn dp[n];\n}\nvoid add(int &a, int b) {\n\ta += b;\n\tif(a >= mod) a -= mod;\n}\nint normal() {\n\tint ans = 0;\n\tfor(int i = 0; i <= n; i++) {\n\t\tif(i) {\n\t\t\tadd(p[i][0], p[i-1][0]);\n\t\t\tadd(p[i][1], p[i-1][1]);\n\t\t}\n\t\tdp[i] = p[i][i&1];\n\t\tif(i == 1) {\n\t\t\tdp[i] = 1;\n\t\t}\n\t\tadd(p[i+2][i&1], dp[i]);\n\t\tadd(p[i+pr+2][i&1], mod - dp[i]);\n\t}\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(i + pr < n || ((i+pr)&1) != (n&1)) continue;\n\t\tans = (ans + (n-i+1)*1ll*dp[i]);\n\t}\n\treturn ans;\n}\nbool check(int msk, int f = 0) {\n\tif((msk&1) && ((msk>>(n-1))&1)) return 0;\n\tif(msk == 0) return 0;\n\tint prev = -1, streak = 0, i = 0;\n\tif(f) while(!(msk&1)) {\n\t\tmsk = (msk/2);}\n\tfor(; i < n; i++) {\n\t\tint cur = (msk>>i)&1;\n\t\tif(prev == cur) streak++;\n\t\telse {\n\t\t\tif(prev == 1 && streak > 1) return 0;\n\t\t\tif(prev == 0 && (streak > pr || (streak&1) == 0)) return 0;\n\t\t\tstreak = 1;\n\t\t}\n\t\t//cout << i << \" \" << cur << \" \" << streak << '\\n';\n\t\tprev = cur;\n\t}\n\tif(prev == 1 && streak > 1) return 0;\n\t\t\tif(prev == 0 && (streak > pr || (streak&1) == 0)) return 0;\n\t\n\treturn true;\n}\nint brute() {\n\tint ans = 0;\n\tfor(int i = 0; i < 1<<n; i++) {\n\t\tans += check(i, 1);\n\t}\n\treturn ans;\n}\nint main() {\n\tcin >> n >> m >> s;\n\tif(s[0] == 'R')\n\t\tfor(auto &i : s) i ^= 'B'^'R';\n\twhile(pr < m && s[pr] == 'B') pr++;\n\tif(m == pr) return cout << corner(), 0;\n\tpr += pr%2 == 0;\n\tint cur = 0;\n\tfor(auto &i : s) {\n\t\tif(i == 'B') cur++;\n\t\telse {\n\t\t\tif(cur&1) pr = min(cur, pr);\n\t\t\tcur = 0;\n\t\t}\n\t}\n\tcout << normal();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long word;\ntypedef pair<int, int> pi;\nconst int MAXN = 200005;\nconst int mod = 1e9 + 7;\n\nint n, m;\nint f[MAXN];\nchar s[MAXN];\nint sum[MAXN][2];\n\nint main(){\n\tscanf(\"%d %d %s\",&n,&m,s);\n\tfor(int i=0; i<m; i++) if(s[i] == 'R') s[i] = 'A';\n\tif(s[0] == 'B'){\n\t\tfor(int i=0; i<m; i++) s[i] = 'A' + 'B' - s[i];\n\t}\n\tif(count(s, s + m, 'B') == 0){\n\t\tf[0] = 1; f[1] = 2;\n\t\tfor(int i=2; i<=n; i++){\n\t\t\tf[i] = f[i-1] + f[i-2];\n\t\t\tf[i] %= mod;\n\t\t}\n\t\tlint ret = f[n];\n\t\tif(n == 3) ret += mod - 1;\n\t\telse if(n >= 4) ret += mod - f[n - 4];\n\t\tret %= mod;\n\t\tcout << ret << endl;\n\t\treturn 0;\n\t}\n\tint alt = 1e9;\n\tint pref = 0;\n\twhile(s[pref] == 'A') pref++;\n\tfor(int i=0; i<m; i++){\n\t\tif(s[i] == 'B'){\n\t\t\tint e = i + 1;\n\t\t\twhile(s[e] == 'A') e++;\n\t\t\tif(e > i + 1 && e % 2 == i % 2){\n\t\t\t\talt = min(alt, e - i - 1);\n\t\t\t}\n\t\t\ti = e - 1;\n\t\t}\n\t}\n\tint x = min(alt, pref + 1);\n\tf[0] = 1;\n\tsum[0][0] = 1;\n\tfor(int i=1; i<=n; i++){\n\t\tint cnt = sum[i - 1][i % 2];\n\t\tif(i - x - 2 >= 0) cnt -= sum[i - x - 2][i % 2];\n\t\tcnt += mod;\n\t\tcnt %= mod;\n\t\tf[i] = cnt;\n\t\tsum[i][0] = sum[i-1][0];\n\t\tsum[i][1] = sum[i-1][1];\n\t\tsum[i][i % 2] += f[i]; \n\t\tsum[i][i % 2] %= mod;\n\t}\n\tint ret = 0;\n\tfor(int i=0; i<n;i++){\n\t\tfor(int j=i; j<n; j++){\n\t\t\tint len = n - (j - i + 1);\n\t\t\tif(len % 2 == 1 && len <= x) ret += f[j - i];\n\t\t\tret %= mod;\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint N, M; char S[200200];\n\nconst long long mod = 1000000007;\nlong long D[200200], V[200200];\n\nint main()\n{\n\tscanf (\"%d %d %s\", &N, &M, S);\n\tif (S[0] == 'B'){\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tif (S[i] == 'R') S[i] = 'B';\n\t\t\telse S[i] = 'R';\n\t\t}\n\t}\n\n\tvector<int> len;\n\tfor (int i = 1, l = -1; i < M; i++){\n\t\tif (S[i-1] == 'R' && S[i] == 'B'){\n\t\t\tint u = i - l - 1;\n\t\t\tlen.push_back(u);\n\t\t\tl = i;\n\t\t}\n\t}\n\n\tif (len.empty()){\n\t\tif (N == 2){\n\t\t\tprintf (\"3\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tD[0] = 1;\n\t\tD[1] = 1;\n\t\tfor (int i = 2; i <= N; i++) D[i] = (D[i - 1] + D[i - 2]) % mod;\n\t\tprintf (\"%lld\\n\", (D[N - 1] + D[N - 3] + 1) % mod);\n\t\treturn 0;\n\t}\n\n\tint lim = len[0];\n\tif (lim % 2 == 0) lim++;\n\tfor (int i = 1; i < len.size(); i++){\n\t\tif (len[i] % 2){\n\t\t\tif (lim > len[i])\n\t\t\t\tlim = len[i];\n\t\t}\n\t}\n\n\tD[0] = V[0] = 1;\n\tfor (int i = 1; i <= N; i++){\n\t\tif (i <= lim + 1) D[i] = i - 1;\n\t\tlong long u = 0, v = 0;\n\t\tif (i >= 2) u = V[i - 2];\n\t\tif (i >= lim + 3) v = V[i - (lim + 3)];\n\t\tD[i] = (D[i] + u + mod - v) % mod;\n\n\t\tV[i] = D[i];\n\t\tif (i >= 2) V[i] = (V[i] + V[i - 2]) % mod;\n\t}\n\tprintf (\"%lld\\n\", D[N]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=200005,mod=1e9+7;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nint n,m;\nchar s[N];\nint dp[N],pre[N];\nint main(){\n\tn=read(),m=read();\n\tcin>>(s+1);\n\tint p=1;\n\twhile (p<=m&&s[p]==s[1])\n\t\tp++;\n\tp--;\n\tif (p==m){\n\t\tFor(i,2,n)\n\t\t\tdp[i]=i;\n\t\tFor(i,1,n){\n\t\t\tAdd(dp[i],pre[i-2]);\n\t\t\tpre[i]=Add(pre[i-1]+dp[i]);\n\t\t}\n\t\tcout<<Add(dp[n]+1)<<endl;\n\t\treturn 0;\n\t}\n\tFor(i,1,m-1)\n\t\tif (s[i]!=s[1]&&s[i+1]!=s[1])\n\t\t\treturn puts(\"0\"),0;\n\tif (n&1)\n\t\treturn puts(\"0\"),0;\n\tint maxlen=p+(~p&1);\n\tint las=p+1;\n\tFor(i,p+2,m)\n\t\tif (s[i]!=s[1]){\n\t\t\tif ((i-las-1)&1)\n\t\t\t\tmaxlen=min(maxlen,i-las-1);\n\t\t\tlas=i;\n\t\t}\n\tn/=2,maxlen=(maxlen+1)/2;\n\tFor(i,1,maxlen)\n\t\tdp[i]=i*2;\n\tFor(i,1,n){\n\t\tAdd(dp[i],Del(pre[i-1]-pre[max(0,i-maxlen-1)]));\n\t\tpre[i]=Add(pre[i-1]+dp[i]);\n\t}\n\tcout<<dp[n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long word;\ntypedef pair<int, int> pi;\nconst int MAXN = 200005;\nconst int mod = 1e9 + 7;\n\nint n, m;\nint f[MAXN];\nchar s[MAXN];\n\nint main(){\n\tscanf(\"%d %d %s\",&n,&m,s);\n\tfor(int i=0; i<m; i++) if(s[i] == 'R') s[i] = 'A';\n\tif(s[0] == 'B'){\n\t\tfor(int i=0; i<m; i++) s[i] = 'A' + 'B' - s[i];\n\t}\n\tif(count(s, s + m, 'B') == 0){\n\t\tf[0] = 1; f[1] = 2;\n\t\tfor(int i=2; i<=n; i++){\n\t\t\tf[i] = f[i-1] + f[i-2];\n\t\t\tf[i] %= mod;\n\t\t}\n\t\tlint ret = f[n];\n\t\tif(n == 3) ret += mod - 1;\n\t\telse if(n >= 4) ret += mod - f[n - 4];\n\t\tret %= mod;\n\t\tcout << ret << endl;\n\t\treturn 0;\n\t}\n\tint alt = 1e9;\n\tint pref = 0;\n\twhile(s[pref] == 'A') pref++;\n\tfor(int i=0; i<m; i++){\n\t\tif(s[i] == 'B'){\n\t\t\tint e = i + 1;\n\t\t\twhile(s[e] == 'A') e++;\n\t\t\tif(e > i + 1 && e % 2 == i % 2){\n\t\t\t\talt = min(alt, e - i - 1);\n\t\t\t}\n\t\t\ti = e - 1;\n\t\t}\n\t}\n\tint x = min(alt, pref + 1);\n\tf[0] = 1;\n\tfor(int i=1; i<=n; i++){\n\t\tfor(int j=0; j<i; j++){\n\t\t\tif((i - j) % 2 == 0 && i - j <= x + 1){\n\t\t\t\tf[i] += f[j];\n\t\t\t\tf[i] %= mod;\n\t\t\t}\n\t\t}\n\t}\n\tint ret = 0;\n\tfor(int i=0; i<n;i++){\n\t\tfor(int j=i; j<n; j++){\n\t\t\tint len = n - (j - i + 1);\n\t\t\tif(len % 2 == 1 && len <= x) ret += f[j - i];\n\t\t\tret %= mod;\n\t\t}\n\t}\n\tif(n % 2 == 1 && n <= x) ret++;\n\tret %= mod;\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long word;\ntypedef pair<int, int> pi;\nconst int MAXN = 200005;\nconst int mod = 1e9 + 7;\n\nint n, m;\nint f[MAXN];\nchar s[MAXN];\nint sum[MAXN];\n\nint main(){\n\tscanf(\"%d %d %s\",&n,&m,s);\n\tfor(int i=0; i<m; i++) if(s[i] == 'R') s[i] = 'A';\n\tif(s[0] == 'B'){\n\t\tfor(int i=0; i<m; i++) s[i] = 'A' + 'B' - s[i];\n\t}\n\tif(count(s, s + m, 'B') == 0){\n\t\tf[0] = 1; f[1] = 2;\n\t\tfor(int i=2; i<=n; i++){\n\t\t\tf[i] = f[i-1] + f[i-2];\n\t\t\tf[i] %= mod;\n\t\t}\n\t\tlint ret = f[n];\n\t\tif(n == 3) ret += mod - 1;\n\t\telse if(n >= 4) ret += mod - f[n - 4];\n\t\tret %= mod;\n\t\tcout << ret << endl;\n\t\treturn 0;\n\t}\n\tint alt = 1e9;\n\tint pref = 0;\n\twhile(s[pref] == 'A') pref++;\n\tfor(int i=0; i<m; i++){\n\t\tif(s[i] == 'B'){\n\t\t\tint e = i + 1;\n\t\t\twhile(s[e] == 'A') e++;\n\t\t\tif(e > i + 1 && e % 2 == i % 2){\n\t\t\t\talt = min(alt, e - i - 1);\n\t\t\t}\n\t\t\ti = e - 1;\n\t\t}\n\t}\n\tif(n % 2 == 1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint x = min(alt, pref + 1 - pref % 2);\n\tf[0] = 1;\n\tsum[0] = 1;\n\tfor(int i=1; i<=n/2; i++){\n\t\tf[i] = sum[i - 1];\n\t\tif(i >= (x + 3) / 2) f[i] += mod - sum[i - (x + 3) / 2];\n\t\tf[i] %= mod;\n\t\tsum[i] = (sum[i-1] + f[i]) % mod;\n\t}\n\tlint ret = 0;\n\tfor(int i=0; i<n;i++){\n\t\tint len = n - 1 - x;\n\t\tif(n - 1 - x > n - 1 - i) continue;\n\t\tret += sum[(n - 1 - i) / 2];\n\t\tif(len >= 1){\n\t\t\tret += mod - sum[(len - 1) / 2];\n\t\t}\n\t}\n\n\tcout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) FOR(i,0,b)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n#define fs first\n#define sc second\n\ntemplate<class T> using V=vector<T>;\ntemplate<class T> using VV=V<V<T>>;\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\trep(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"(\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\")\";\n}\n\nll read(){\n\tll i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconstexpr ll TEN(int n){\n\treturn n==0?1:TEN(n-1)*10;\n}\n\ntemplate<class T>\nvector<T> Uniqued(const vector<T>&vv){\n\tauto v(vv);\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n\treturn v;\n}\ntemplate<class T>\nvoid MakeUniqued(vector<T>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tstatic constexpr int base=mod;\n\tint v;\n\tModInt():v(0){}\n\tModInt(ll vv){\n\t\tv=vv%mod;\n\t\tif(v<0)v+=mod;\n\t}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n\texplicit operator int()const{\n\t\treturn v;\n\t}\n\tbool operator==(const ModInt&rhs)const{\n\t\treturn v==rhs.v;\n\t}\n\tbool operator!=(const ModInt&rhs)const{\n\t\treturn v!=rhs.v;\n\t}\n\tModInt operator-()const{\n\t\treturn ModInt(0)-*this;\n\t}\n\tModInt& operator+=(const ModInt&rhs){\n\t\tv+=rhs.v;\n\t\tif(v>=mod)v-=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator-=(const ModInt&rhs){\n\t\tv-=rhs.v;\n\t\tif(v<0)v+=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator*=(const ModInt&rhs){\n\t\tv=ll(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tModInt&operator/=(const ModInt&rhs){\n\t\toperator*=(rhs.inv());\n\t\treturn *this;\n\t}\n\tModInt operator+(const ModInt&rhs)const{\n\t\treturn ModInt(*this)+=rhs;\n\t}\n\tModInt operator-(const ModInt&rhs)const{\n\t\treturn ModInt(*this)-=rhs;\n\t}\n\tModInt operator*(const ModInt&rhs)const{\n\t\treturn ModInt(*this)*=rhs;\n\t}\n\tModInt operator/(const ModInt&rhs)const{\n\t\treturn ModInt(*this)/=rhs;\n\t}\n\tfriend ModInt operator+(int x,const ModInt&y){\n\t\treturn ModInt(x)+y;\n\t}\n\tfriend ModInt operator-(int x,const ModInt&y){\n\t\treturn ModInt(x)-y;\n\t}\n\tfriend ModInt operator*(int x,const ModInt&y){\n\t\treturn ModInt(x)*y;\n\t}\n\tfriend ModInt operator/(int x,const ModInt&y){\n\t\treturn ModInt(x)/y;\n\t}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tModInt inv()const{\n\t\treturn pow(mod-2);\n\t}\n};\n\ntemplate<int mod>\nostream& operator<<(ostream&os,const ModInt<mod>&m){\n\treturn os<<m.v;\n}\ntemplate<int mod>\nvoid print(const ModInt<mod>&m,int suc=1){\n\tprint(m.v,suc);\n}\n\n//using mint=ModInt<1000000007>;\nusing mint=ModInt<998244353>;\n\nconst int Vmax=min<int>(2000010,mint::base);\nmint fact[Vmax],factInv[Vmax],invs[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfactInv[Vmax-1]=fact[Vmax-1].inv();\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1]*(i+1);\n\t}\n\tfor(int i=Vmax-1;i>=1;i--){\n\t\tinvs[i]=factInv[i]*fact[i-1];\n\t}\n}\nstruct InitFactDummy{\n\tInitFactDummy(){\n\t\tInitFact();\n\t}\n} initFactDummy;\nmint Choose(int n,int k){\n\treturn fact[n]*factInv[n-k]*factInv[k];\n}\nmint Binom(int a,int b){\n\treturn fact[a+b]*factInv[a]*factInv[b];\n}\nmint Catalan(int n){\n\treturn Binom(n,n)-(n-1>=0?Binom(n-1,n+1):0);\n}\n\nV<mint> getDP(int m,int a,int b){\n\tV<mint> dp(m+1),sum(m+1);\n\tdp[0]=sum[0]=1;\n\tFOR(i,1,m+1){\n\t\tmint w;\n\t\tif(i-a>=0)w+=sum[i-a];\n\t\tif(i-b-1>=0)w-=sum[i-b-1];\n\t\tdp[i]=w;\n\t\tsum[i]=sum[i-1]+dp[i];\n\t}\n\treturn dp;\n}\n\nsigned main(){\n\tint n=read(),m=read();\n\tstring s=readString();\n\tif(s[0]!='R'){\n\t\tfor(auto&c:s){\n\t\t\tc='R'+'B'-c;\n\t\t}\n\t}\n\tif(s==string(n,'R')){\n\t\tauto dp=getDP(n,2,inf);\n\t\tmint ans=1;\n\t\tfor(int k=1;k<=n-1;k++){\n\t\t\tint rem=n-k-1;\n\t\t\tans+=dp[rem]*(k+1);\n\t\t}\n\t\tprint(ans);\n\t\treturn 0;\n\t}\n\tint lim=n-1;\n\tif(lim%2==0)lim--;\n\tfor(int i=0;i<m;){\n\t\tif(s[i]=='R'){\n\t\t\tint len=0;\n\t\t\twhile(i+len<m&&s[i+len]=='R')\n\t\t\t\tlen++;\n\t\t\ti+=len;\n\t\t\tif(i<m&&len%2)\n\t\t\t\tchmin(lim,len);\n\t\t\tif(i==len&&len%2==0)\n\t\t\t\tchmin(lim,len+1);\n\t\t}else{\n\t\t\ti++;\n\t\t}\n\t}\n\tconst int L=(lim+1)/2;\n\tauto dp=getDP(n,1,L);\n\tcerr<<L<<endl;\n\tcerr<<dp<<endl;\n\tmint ans;\n\tfor(int k=1;k<=lim;k+=2){\n\t\tint rem=(n-k-1);\n\t\tcerr<<rem<<endl;\n\t\tif(rem%2)continue;\n\t\tmint w=dp[rem/2];\n\t\tans+=w*(k+1);\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 200000, md = 1000000007;\n\nchar s[MX + 1];\nint dp[MX + 1], sum[MX + 1];\n\nint main() {\n\tint n, m;\n\tignore = scanf(\"%d %d %s\", &n, &m, s);\n\t\n\tchar R = s[0];\n\t\n\tvector<int> sizes;\n\tfor (int i = 0, sz = 0; i < m; i++) {\n\t\tif (s[i] == R) sz++;\n\t\telse if (sz > 0) {\n\t\t\tsizes.push_back(sz);\n\t\t\tsz = 0;\n\t\t}\n\t}\n\t\n\tif (sizes.empty()) {\n\t\tauto count = [](int n, int first) {\n\t\t\tint f = first, g = 1 - first;\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\ttie(f, g) = make_pair(f + g, f);\n\t\t\t\tf %= md;\n\t\t\t\tg %= md;\n\t\t\t}\n\t\t\t\n\t\t\treturn (f + first * g) % md;\n\t\t};\n\t\t\n\t\tint ans = count(n, 0) + count(n, 1);\n\t\tans %= md;\n\t\tprintf(\"%d\\n\", ans);\n\t\t\n\t\treturn 0;\n\t}\n\t\n\tint maxSize = sizes[0] + 1;\n\tfor (int sz : sizes) if (sz % 2 == 1) maxSize = min(maxSize, sz);\n\t\n\tif (maxSize % 2 == 0) maxSize--;\n\t\n\tfor (int i = 2; i <= n; i++) {\n\t\tdp[i] = sum[i - 2];\n\t\t\n\t\tif (i - maxSize - 3 >= 0) {\n\t\t\tdp[i] += md - sum[i - maxSize - 3];\n\t\t\tdp[i] %= md;\n\t\t}\n\t\t\n\t\tif (1 <= i - 1 && i - 1 <= maxSize && i % 2 == 0) {\n\t\t\tdp[i] += i;\n\t\t\tdp[i] %= md;\n\t\t}\n\t\t\n\t\tsum[i] = dp[i];\n\t\tif (i - 2 > 0) {\n\t\t\tsum[i] += sum[i - 2];\n\t\t\tsum[i] %= md;\n\t\t}\n\t}\n\t\n\tprintf(\"%d\\n\", dp[n]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << (a) << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int MOD = 1e9 + 7;\n\nvi split(string s) {\n    vi ans;\n    char last = 'X'; \n    s += 'X';\n    int streak = 0;\n    for (char c : s) {\n        if (c != last) {\n            if (streak) ans.pb(streak);\n            streak = 0;\n            last = c;\n        }\n        streak++;\n    }\n    return ans;\n}\n\nvoid add(int &x, int y) {\n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n\nvi go(int n, int lim, int start) {\n    vi dp(n+1);\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = 0;\n        if (i >= start) add(dp[i], dp[i-start]);\n        if (i >= lim+1) add(dp[i], MOD-dp[i-lim-1]);\n        add(dp[i], dp[i-1]);\n    }\n    for (int i = n; i >= 1; i--) add(dp[i], MOD-dp[i-1]);\n    return dp;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    int n,l;\n    string s;\n    cin >> n >> l >> s;\n    auto p = split(s);\n    if (si(p) == 1) {\n        auto dp = go(n,n,2);\n        int ans = 0;\n        for (int dif = 1; dif <= n; dif++) {\n            if (dif == 1 || dif == n-1) continue;\n            add(ans, ll(dif) * dp[n-dif] % MOD);\n        }\n        cout << (ans+1)%MOD << endl;\n    }\n    else {\n        if (n%2 == 1) {\n            cout << 0 << endl;\n        }\n        else {\n            int lim = p[0]/2+1;\n            forn(i,si(p)) if (i%2 == 0 && p[i]%2 == 1) \n                lim = min(lim, p[i]/2+1);\n            n /= 2;\n            auto dp = go(n, lim, 1);\n            int ans = 0;\n            for (int dif = 1; dif <= lim; dif++)\n                add(ans, ll(dif) * dp[n-dif] % MOD);\n            cout << 2LL*ans%MOD << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb push_back\n#define szz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nconst int mod = 1e9 + 7;\n\nint n, m;\nchar S[200020];\nll res[200020];\nll D[200020], sum[200020];\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", S + 1);\n\tif(S[1] == 'B') {\n\t\tfor(int i=1;i<=m;i++) S[i] = (S[i] == 'B' ? 'R' : 'B');\n\t}\n\tvector <int> v;\n\tfor(int i=1, c=0;i<=m;i++) {\n\t\tif(S[i] == 'R') ++c;\n\t\tif(S[i] == 'R' && (i == m || S[i+1] == 'B')) {\n\t\t\tv.pb(c);\n\t\t\tc = 0;\n\t\t}\n\t}\n\tif(szz(v) == 1) {\n\t\tint dp[200020][2] = {};\n\t\tdp[1][0] = 1; dp[1][1] = 0;\n\t\tfor(int i=2;i<=n;i++) {\n\t\t\tdp[i][0] = (dp[i-1][0] + dp[i-1][1]) % mod;\n\t\t\tdp[i][1] = dp[i-1][0];\n\t\t}\n\t\tint ans = (dp[n][0] + dp[n][1]) % mod;\n\t\tmemset(dp, 0, sizeof dp);\n\t\tdp[1][0] = 0; dp[1][1] = 1;\n\t\tfor(int i=2;i<=n;i++) {\n\t\t\tdp[i][0] = (dp[i-1][0] + dp[i-1][1]) % mod;\n\t\t\tdp[i][1] = dp[i-1][0];\n\t\t}\n\t\tans = (ans + dp[n][0]) % mod;\n\t\tprintf(\"%d\\n\", ans);\n\t\treturn 0;\n\t}\n\tif(n % 2) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint lmn = n - 1;\n\tint temp = szz(v); if(S[m] == 'R') --temp;\n\trep(i, temp) {\n\t\tif(v[i] % 2) {\n\t\t\tlmn = min(lmn, v[i]);\n\t\t}\n\t\telse lmn = min(lmn, v[i] + 1);\n\t}\n\tlmn = (lmn + 1) / 2;\n\t\n\tint sn = n / 2;\n\t\n\tD[0] = sum[0] = 1;\n\tfor(int i=1;i<=sn;i++) {\n\t\tD[i] = (sum[i-1] - (i-lmn-1 < 0 ? 0 : sum[i-lmn-1]));\n\t\tif(D[i] < 0) D[i] += mod;\n\t\tsum[i] = (sum[i-1] + D[i]) % mod;\n\t}\n\t\n\tll ans = 0;\n\tfor(int i=1;i<=lmn;i++) {\n\t\tans = (ans + (2 * i) * D[sn - i]) % mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\ntemplate<typename T>\nclass RangeAddQuery {\npublic:\n    explicit RangeAddQuery(int n) : N(calcN_(n)) {\n        mVal.assign(2*N+1, 0);\n    }\n    void update(int l, int r, T value){\n        l = max(0, l);\n        r = min(N, r);\n        int offset = N;\n        while(offset > 0){\n            if(l >= r) break;\n            if(l&1){ update_(mVal[offset+l-1], value); l++; }\n            if(r&1){ update_(mVal[offset+r-2], value); }\n            l /= 2;\n            r /= 2;\n            offset /= 2;\n        }\n    }\n    T get(int idx){\n        int i = N + idx - 1;\n        auto res = mVal[i];\n        while(i > 0){\n            i = (i-1)/2;\n            update_(res, mVal[i]);\n        }\n        return res;\n    }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    inline void update_(T& data, T val) { data = (data + val) % MOD; }\n    const int N;\n    vector<T> mVal;\n};\n\nint maxSegment(const string& S){\n    char c = S[0];\n    bool first = true;\n    int cnt = 0;\n    int res = MOD;\n    for(auto& s : S){\n        if(c == s) ++cnt;\n        else {\n            if(first || cnt%2 == 1){\n                res = min(res, cnt/2+1);\n                cnt = 0;\n                first = false;\n            }\n        }\n    }\n    return res < MOD ? res : -1;\n}\n\nint solve(const string& S, int N){\n    int seg = maxSegment(S);\n    if(seg != -1 && N%2 == 1) return 0;\n    long long res = 0;\n    if(seg == -1){\n      \treturn -1;\n        RangeAddQuery<long long> raq(N);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N;i++){\n            auto a = raq.get(i);\n            raq.update(i+2, N, a);\n        }\n        res = 1;\n        for(int i=N-2;i>=0;i--){\n            res = (res + raq.get(i) * (N-i)) % MOD;\n        }\n    } else {\n        seg = min(seg, N/2);\n        RangeAddQuery<long long> raq(N/2);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N/2;i++){\n            auto a = raq.get(i);\n            raq.update(i+1, i+1+seg, a);\n        }\n        for(int i=N/2-1;i>=N/2-seg;i--){\n            res = (res + raq.get(i) * 2 * (N/2-i)) % MOD;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    cout << solve(S, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n        if(dp[i-1] < 0)dp[i-1] %= MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i > 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    return res;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i <= m;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nchar str[200005];\nint arr[200005];\nlong long MOD=1000000007;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",str);\n\tfor(int i=0;i<m;i++)if(str[i]=='R')arr[i]=0;else arr[i]=1;\n\tbool all[2];all[0]=all[1]=1;\n\tfor(int i=0;i<m;i++)all[arr[i]^1]=0;\n\tif(all[0]||all[1]){\n\t\tlong long dp[2][n];memset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;dp[1][0]=0; //start with red (or blue if everything is blue)\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tlong long ans=(dp[0][n-1]+dp[1][n-1])%MOD;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=0;dp[1][0]=1; //start with blue\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tans+=dp[0][n-1];ans%=MOD;ans+=MOD;ans%=MOD;\n\t\tprintf(\"%lld\",ans);\n\t\treturn 0;\n\t}\n\tif(n%2!=0){printf(\"0\");return 0;}\n\tint cur=0;bool b=0;\n\tint mxl=n-1;\n\tfor(int i=0;i<m;i++){\n\t\tif(arr[i]==arr[0])cur++;\n\t\telse{\n\t\t\tif(!b){\n\t\t\t\tb=1;mxl=min(mxl,cur^1);\n\t\t\t}else if(cur%2==1)mxl=min(mxl,cur);\n\t\t}\n\t}\n\t//comments: wlog red is first\n\tn/=2; mxl/=2; //remove the ones that are different parity from blue\n\tlong long dp[100005],pref[100005];\n\tmemset(dp,0,sizeof(dp));memset(pref,0,sizeof(pref));\n\t//i segments on a line, first and last are blue, max mxl consecutive reds\n\t//blues may be consecutive because the reds in between were removed\n\tdp[1]=pref[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tdp[i]=pref[i-1]-pref[max(0,i-(mxl+2))];\n\t\tdp[i]%=MOD;dp[i]+=MOD;dp[i]%=MOD;\n\t\tpref[i]=dp[i]+pref[i-1];\n\t\tpref[i]%=MOD;pref[i]+=MOD;pref[i]%=MOD;\n\t}\n\tlong long ans=0;\n\tfor(long long i=2;i<=min(n,mxl+2);i++){\n\t\tans+=(i-1LL)*dp[n-i+2];\n\t\tans%=MOD;\n\t}\n\tans+=MOD;ans%=MOD;\n\tprintf(\"%lld\",(ans*2)%MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 2e5 + 10;\nconst ll MOD = 1e9 + 7;\n\nint N, M, K;\nbool S[MAX_N];\n\nvoid init() {\n    scanf(\"%d%d\", &N, &M);\n    static char _S[MAX_N];\n    scanf(\"%s\", _S + 1);\n    for (int i = 1; i <= M; i++) S[i] = _S[i] == 'R';\n    for (int i = M; i; i--) S[i] ^= S[1];\n    K = N | 1;\n    int curr = 0;\n    bool first = true;\n    for (int i = 1; i <= M; i++) {\n        if (S[i]) {\n            if (curr & 1) {\n                K = min(K, curr);\n            } else {\n                if (first) K = min(K, curr + 1);\n            }\n            first = false;\n            curr = 0;\n        } else curr++;\n    }\n    if (first) {\n        static ll fib[MAX_N];\n        fib[1] = fib[2] = 1;\n        for (int i = 3; i <= N + 1; i++) (fib[i] = fib[i - 1] + fib[i - 2]) %= MOD;\n        ll ans = (2 * fib[N + 1] - fib[N] + MOD) % MOD;\n        printf(\"%lld\\n\", ans);\n        exit(0);\n    }\n}\n\nll f[MAX_N], pre[MAX_N];\nvoid solve() {\n    f[0] = pre[0] = 1;\n    for (int i = 1; i <= N; i++) {\n        f[i] = ((i - 2 >= 0 ? pre[i - 2] : 0) - (i - K - 3 >= 0 ? pre[i - K - 3] : 0) + MOD) % MOD;\n        pre[i] = (i >= 2 ? pre[i - 2] + f[i] : f[i]) % MOD;\n    }\n    ll ans = 0;\n    for (int i = 1; i <= min(K + 1, N); i++) {\n        int l = N - (K + 1), r = N - (i + (i & 1));\n        (ans += pre[r] - (l - 2 >= 0 ? pre[l - 2] : 0) + MOD) %= MOD;\n    }\n    printf(\"%lld\\n\", ans);\n}\n\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define N 300000\n\nconst LL mod=1000000007;\nLL n,m,p,ans,f[N];\nchar s[N];\n\nvoid upd(LL &x,LL y){x=(x+y)%mod;}\n\nint main(){\n\tscanf(\"%lld%lld%s\",&n,&m,s+1);\n\tif (s[1]=='B') for (LL i=1;i<=m;++i) s[i]=s[i]=='B'?'R':'B';\n\tp=n;\n\tans=1;\n\tfor (LL i=1,j=0,fst=0;i<=m;++i){\n\t\tif (s[i]=='R') ++j;\n\t\telse{\n\t\t\tans=0;\n\t\t\tif (!fst) p=min(p,j&1?j:j+1);\n\t\t\tfst=1;\n\t\t\tif (j&1) p=min(p,j);\n\t\t\tj=0;\n\t\t}\n\t}\n\tif (!ans&&(n&1)){puts(\"0\"); return 0;}\n\tif (ans){\n\t\tans=0;\n\t\tf[1]=1;\n\t\tfor (LL i=2;i<=n;++i) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tupd(ans,f[n]+f[n-1]*2);\n\t}\n\telse{\n\t\tp=(p+1)/2;\n\t\tf[0]=1;\n\t\tfor (LL i=1,j=0,k=0;i<=n/2;++i){\n\t\t\tupd(k,f[i-1]);\n\t\t\tif (j<i-p){upd(k,-f[j]); ++j;}\n\t\t\tupd(f[i],k);\n\t\t}\n\t\tfor (LL i=2;i<=n&&i<=p*2;i+=2) upd(ans,i*f[(n-i)/2]);\n\t}\n\tprintf(\"%lld\\n\",(ans+mod)%mod);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\n\n/// --- Modulo Integer {{{ ///\n#include <ostream>\ntemplate < long long mod = static_cast< long long >(1e9 + 7) >\nstruct ModuloInteger {\n  static_assert(mod > 0, \"mod must be positive\");\n  static_assert(mod <= 3037000499, \"mod is too big\");\n  using integer = long long;\n  static ModuloInteger unused;\n  // math {{{\n  static inline integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  static inline integer modpow(integer a, long long b) {\n    if(b < 0) b = -b, a = modinv(a);\n    integer r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  integer val;\n  constexpr ModuloInteger() : val(0) {}\n  constexpr ModuloInteger(integer t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\nprivate:\n  // strict constructor\n  constexpr ModuloInteger(integer t, int) : val(t) {}\n\npublic:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // operator bool() { return bool(val); }\n  // ModuloInteger <arithmetic-operator>[=] ModuloInteger {{{\n  ModuloInteger operator+(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModuloInteger operator-(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModuloInteger operator*(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModuloInteger operator/(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModuloInteger &operator+=(ModuloInteger const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModuloInteger &operator-=(ModuloInteger const &rhs) { return *this += -rhs; }\n  ModuloInteger &operator*=(ModuloInteger const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModuloInteger &operator/=(ModuloInteger const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModuloInteger operator++(int) {\n    ModuloInteger tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModuloInteger operator--(int) {\n    ModuloInteger tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModuloInteger &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModuloInteger &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModuloInteger operator-() const { return ModuloInteger(val == 0 ? 0 : mod - val, 0); }\n  // ModuloInteger <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModuloInteger operator+(T const &rhs) const {\n      return ModuloInteger(val + rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator-(T const &rhs) const {\n      return ModuloInteger(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator*(T const &rhs) const {\n      return ModuloInteger(val * (rhs % mod));\n    }\n  template < typename T >\n    ModuloInteger operator/(T const &rhs) const {\n      return ModuloInteger(val * modinv(rhs));\n    }\n  template < typename T >\n    ModuloInteger &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator/=(T const &rhs) {\n      val = val * modinv(rhs) % mod;\n      return *this;\n    }\n  // }}}\n  ModuloInteger inv() const { return ModuloInteger(modinv(val), 0); }\n  ModuloInteger operator~() const { return inv(); }\n  friend std::ostream &operator<<(std::ostream &os, ModuloInteger const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // equality operator {{{\n  ModuloInteger operator==(const ModuloInteger &a) const { return val == a.val; }\n  ModuloInteger operator!=(const ModuloInteger &a) const { return val != a.val; }\n  ModuloInteger operator==(const integer &a) const { return val == ModuloInteger(a); }\n  ModuloInteger operator!=(const integer &a) const { return val != ModuloInteger(a); }\n  // }}}\n  // T <arithmetic-operator> ModuloInteger {{{\n  friend constexpr ModuloInteger operator+(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod + mv.val);\n  }\n  friend constexpr ModuloInteger operator-(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod - mv.val);\n  }\n  friend constexpr ModuloInteger operator*(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModuloInteger operator/(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModuloInteger operator^(integer x) const { return pow(*this, x); }\n  ModuloInteger &operator^=(integer x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModuloInteger pow(ModuloInteger x, integer y) {\n    return ModuloInteger(modpow(x.val, y), 0);\n  }\n  // }}}\n};\ntemplate < long long mod >\nModuloInteger< mod > ModuloInteger< mod >::unused(mod, 0);\n/// }}}--- ///\n\nusing modint = ModuloInteger<>;\n\n\n// LazySegmentTree( size [, initial] )\n// LazySegmentTree( <data> )\n/// --- LazySegmentTree {{{ ///\n#include <cassert>\n#include <initializer_list>\n#include <iostream>\n#include <vector>\ntemplate < class M_act >\nstruct LazySegmentTree {\npublic:\n  using Monoid = typename M_act::Monoid;\n  using X = typename Monoid::T;\n  using M = typename M_act::M;\n\nprivate:\n  size_t n;\n  int h;\n  vector< X > data;\n  vector< M > lazy;\n  vector< size_t > nodeLength;\n  // call before use data[i]\n  void eval(size_t i) {\n    if(lazy[i] == M_act::identity()) return;\n    data[i] = M_act::actInto(lazy[i], nodeLength[i], data[i]);\n    if(i < n) {\n      lazy[i * 2] = M_act::op(lazy[i], lazy[i * 2]);\n      lazy[i * 2 + 1] = M_act::op(lazy[i], lazy[i * 2 + 1]);\n    }\n    lazy[i] = M_act::identity();\n  }\n  // call before use seg[i] = data[i + n]\n  void evalDown(size_t i) {\n    i += n;\n    for(int j = h - 1; j >= 0; j--) eval(i >> j);\n  }\n  // call after touch seg[i] = data[i + n]\n  void propUp(size_t i) {\n    i += n;\n    while(i >>= 1)\n      eval(i * 2), eval(i * 2 + 1), data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n  }\n\npublic:\n  LazySegmentTree() : n(0) {}\n  LazySegmentTree(size_t n, X initial = Monoid::identity()) : n(n) {\n    if(n > 0) {\n      h = 1;\n      while(1u << h < n) h++;\n      data.resize(2 * n, initial);\n      lazy.resize(2 * n, M_act::identity());\n      nodeLength.resize(2 * n, 1);\n      for(size_t i = n - 1; i > 0; i--) // fill from deep\n        data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]),\n          nodeLength[i] = nodeLength[i * 2] + nodeLength[i * 2 + 1];\n    }\n  }\n  template < class InputIter, class = typename iterator_traits< InputIter >::value_type >\n    LazySegmentTree(InputIter first, InputIter last)\n    : LazySegmentTree(distance(first, last)) {\n      if(n > 0) {\n        copy(first, last, begin(data) + n);\n        for(size_t i = n - 1; i > 0; i--) // fill from deep\n          data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n      }\n    }\n  LazySegmentTree(vector< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  LazySegmentTree(initializer_list< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  void act(int l, int r, const M &m) {\n    if(l < 0) l = 0;\n    if(l >= r) return;\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    int tl = l, tr = r;\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), lazy[l] = m, eval(l), l++;\n      if(r & 1) --r, eval(r), lazy[r] = m, eval(r);\n    }\n    propUp(tl);\n    propUp(tr - 1);\n  }\n  void set(size_t i, const X &x) {\n    assert(i < n);\n    evalDown(i);\n    data[i + n] = x;\n    propUp(i);\n  }\n  X get(size_t i) {\n    assert(i < n);\n    evalDown(i);\n    return data[i + n];\n  }\n  X fold(int l, int r) {\n    if(l < 0) l = 0;\n    if(l >= r) return Monoid::identity();\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    X tmpL = Monoid::identity(), tmpR = Monoid::identity();\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), tmpL = Monoid::op(tmpL, data[l]), l++;\n      if(r & 1) --r, eval(r), tmpR = Monoid::op(data[r], tmpR);\n    }\n    return Monoid::op(tmpL, tmpR);\n  }\n  int size() { return n; }\n  inline void dum(int r = -1) {\n#ifdef DEBUG\n    if(r < 0) r = n;\n    DEBUG_OUT << \"{\";\n    for(int i = 0; i < min(r, (int) n); i++) DEBUG_OUT << (i ? \", \" : \"\") << get(i);\n    DEBUG_OUT << \"}\" << endl;\n#endif\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid examples {{{ ///\nconstexpr long long inf_monoid = 1e18 + 100;\n#include <algorithm>\nstruct Nothing {\n  using T = char;\n  using Monoid = Nothing;\n  using M = T;\n  static constexpr T op(const T &, const T &) { return T(); }\n  static constexpr T identity() { return T(); }\n  template < class X >\n    static constexpr X actInto(const M &, long long, const X &x) {\n      return x;\n    }\n};\n\ntemplate < class U = long long >\nstruct RangeMin {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::min< T >(a, b); }\n  static constexpr T identity() { return T(inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeMax {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::max< T >(a, b); }\n  static constexpr T identity() { return T(-inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeSum {\n  using T = U;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return T(0); }\n};\n\ntemplate < class U >\nstruct RangeProd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a * b; }\n  static constexpr T identity() { return T(1); }\n};\n\ntemplate < class U = long long >\nstruct RangeOr {\n  using T = U;\n  static T op(const T &a, const T &b) { return a | b; }\n  static constexpr T identity() { return T(0); }\n};\n\n#include <bitset>\n\ntemplate < class U = long long >\nstruct RangeAnd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return T(-1); }\n};\n\ntemplate < size_t N >\nstruct RangeAnd< std::bitset< N > > {\n  using T = std::bitset< N >;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return std::bitset< N >().set(); }\n};\n\n/// }}}--- ///\n\n/// --- M_act examples {{{ ///\ntemplate < class U = long long, class V = U >\nstruct RangeMinAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMin< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMax< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMinSet {\n  using M = U;\n  using Monoid = RangeMin< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxSet {\n  using M = U;\n  using Monoid = RangeMax< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long n, const X &x) { return m * n + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long n, const X &x) {\n    return m == identity() ? x : m * n;\n  }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdMul {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M mpow(M a, long long b) {\n    X r(1);\n    while(b) {\n      if(b & 1) r = r * a;\n      a = a * a;\n      b >>= 1;\n    }\n    return r;\n  }\n  static M op(const M &a, const M &b) { return a * b; }\n  static constexpr M identity() { return M(1); }\n  static X actInto(const M &m, long long n, const X &x) { return x * mpow(m, n); }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return V::unused; }\n  static X actInto(const M &m, long long n, const X &) {\n    if(m == identity()) return;\n    return RangeProdMul< U, V >::mpow(m, n);\n  }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeOr2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeOr< U >;\n  static M op(const M &a, const M &b) { return a | b; }\n  static constexpr M identity() { return M(0); }\n  static X actInto(const M &m, long long, const X &x) { return m | x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeAnd2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return M(-1); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n\ntemplate < class U, size_t N >\nstruct RangeAnd2< U, std::bitset< N > > {\n  using X = U;\n  using M = std::bitset< N >;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return std::bitset< N >().set(); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n/// }}}--- ///\n\nusing Seg = LazySegmentTree< RangeSumAdd<modint> >;\n\n\n// NOTE : use H with larger N\n/// --- Modulo Factorial {{{ ///\n#include <cassert>\n#include <cstddef>\ntemplate < std::size_t N, int mod = static_cast< int >(1e9 + 7) >\nstruct Factorial {\n  using integer = long long;\n  constexpr integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d = 0;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  constexpr integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  int arr[N + 1], inv[N + 1];\n  integer operator[](int i) const { return arr[i]; }\n  Factorial() : arr(), inv() {\n    arr[0] = 1;\n    for(std::size_t i = 1; i <= N; i++) {\n      arr[i] = (integer) i * arr[i - 1] % mod;\n    }\n    inv[N] = modinv(arr[N]);\n    for(int i = N - 1; i >= 0; i--) {\n      inv[i] = (integer)(i + 1) * inv[i + 1] % mod;\n    }\n  }\n  integer C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    assert(n <= N);\n    return (integer) arr[n] * inv[r] % mod * inv[n - r] % mod;\n  }\n  integer H(int n, int r) const { return C(n + r - 1, r); }\n};\n/// }}}--- ///\n\nconstexpr int mod = 1e9 + 7;\nconst int N = 2e5 + 10;\nFactorial< N * 2, mod > fact;\n\n\n\nint n, m;\nint r, b;\nint rmax;\nstring s;\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n >> m;\n  cin >> s;\n  if(s[0] == 'B') for(auto &e : s) e = e == 'R' ? 'B' : 'R';\n  bool allR = 1;\n  for(auto e : s) allR &= e == 'R';\n\n  if(allR) {\n    dump(\"allR\");\n    modint ans;\n    for(int B = 0; B <= n; B++) {\n      int R = n - B - B;\n      ans += modint(fact.C(R + B, R));\n      ans += modint(fact.C(R + B - 1, R));\n    }\n    cout << ans << endl;\n    return 0;\n  }\n\n  if(n % 2 == 1) {\n    cout << 0 << endl;\n    dump(\"odd\");\n    assert(0);\n    return 0;\n  }\n\n  int c = 0;\n  rmax = m;\n  bool first = 1;\n  for(int i = 0; i <= m; i++) {\n    if(i == n || s[i] == 'B') {\n      if(c) {\n        if(c % 2 == 0 && first) rmax = min(rmax, c + 1);\n        if(c % 2 == 1) rmax = min(rmax, c);\n      }\n      c = 0;\n      first = 0;\n    } else c++;\n  }\n\n  dump(rmax);\n\n  // RB\n\n  // vector<modint> dp(n + 1);\n  Seg dp(n + 1);\n  dp.set(0, 1);\n\n  modint ans;\n\n  for(int i = 0; i <= n - 1; i+=2) {\n    dp.act(i + 2, min<int>(n - 1, i + 1 + rmax) + 1, dp.get(i));\n    if(i + 1 + rmax >= n) {\n      int f = n - i - 1;\n      if (f >= 1) {\n        dump(i, dp.get(i), f);\n        ans += dp.get(i) * (f + 1);\n      }\n    }\n  }\n  cout << ans << endl;\n  dp.dum();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\n#include<cassert>\nusing namespace std;\nusing lint = long long;\nusing ld = long double;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(lint i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nint n, m;\nstring s;\n\nvoid allred() {\n\tlint v1 = 0, v2 = 0;\n\tlint ans = 0;\n\tv1 = 1;\n\tREP(i, n - 1) {\n\t\tlint nv1 = (v1 + v2) % MOD;\n\t\tlint nv2 = v1;\n\t\tv1 = nv1;\n\t\tv2 = nv2;\n\t}\n\tans += (v1 + v2) % MOD;\n\tv1 = 0; v2 = 1;\n\tREP(i, n - 1) {\n\t\tlint nv1 = (v1 + v2) % MOD;\n\t\tlint nv2 = v1;\n\t\tv1 = nv1;\n\t\tv2 = nv2;\n\t}\n\tans += v1;\n\tcout << (ans % MOD + MOD) % MOD << endl;\n\treturn;\n}\n\nvoid solve(vector<int> suc_red, int omn) {\n\tint th = omn;\n\tif(suc_red[0] % 2 == 0) th = min(th, suc_red[0] + 1);\n\tlint ans = 0;\n\t/*\n\tif((n - 1) % 2 && (n - 1) <= th) {\n\t\tans += n;\n\t}*/\n\tvector<lint> dpr(n), dpb(n);\n\tdpr[0] = 0;\n\tdpb[0] = 1;\n\tqueue<lint> q0;\n\tqueue<lint> q1;\n\tlint sum0 = 1, sum1 = 0;\n\tq0.push(1);\n\tFOR(i, 1, n) {\n\t\tif(i % 2 == 1) {\n\t\t\twhile(!q0.empty() && (int)q0.size() > (th + 1) / 2) {\n\t\t\t\tsum0 -= q0.front(); sum0 %= MOD;\n\t\t\t\tq0.pop();\n\t\t\t}\n\t\t\tdpr[i] = sum0;\n\t\t} else {\n\t\t\twhile(!q1.empty() && (int)q1.size() > (th + 1) / 2) {\n\t\t\t\tsum1 -= q1.front(); sum1 %= MOD;\n\t\t\t\tq1.pop();\n\t\t\t}\n\t\t\tdpr[i] = sum1;\n\t\t}\n\t\tdpb[i] = dpr[i - 1];\n\t\tif(i % 2 == 0) {\n\t\t\tq0.push(dpb[i]);\n\t\t\tsum0 += dpb[i]; sum0 %= MOD;\n\t\t} else {\n\t\t\tq1.push(dpb[i]);\n\t\t\tsum1 += dpb[i]; sum1 %= MOD;\n\t\t}\n\t}\n\tFOR(i, 1, n) {\n\t\tif(i > th) break;\n\t\tans += dpb[n - 1 - i] * i;\n\t\tans %= MOD;\n\t}\n\tans += dpr[n - 1]; ans %= MOD;\n\tcout << (ans % MOD + MOD) % MOD << endl;\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> m;\n\tcin >> s;\n\tif(s[0] == 'B') {\n\t\tREP(i, m) {\n\t\t\tif(s[i] == 'B') s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\n\tvector<int> suc_red;\n\tint c = 0;\n\tREP(i, n) {\n\t\tif(s[i] == 'R') c++;\n\t\telse {\n\t\t\tif(c != 0) suc_red.pb(c);\n\t\t\tc = 0;\n\t\t}\n\t}\n\tif(c != 0) suc_red.pb(c);\n\n\tif((int)suc_red.size() == 1) {\n\t\tallred();\n\t\treturn 0;\n\t}\n\n\tassert(false);\n\n\tint omn = INF;\n\tREP(i, suc_red.size()) {\n\t\tif(suc_red[i] % 2) omn = min(omn, suc_red[i]);\n\t}\n\tsolve(suc_red, omn);\n\treturn 0;\n}\n/* --------------------------------------- */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define pii pair<int, int>\n#define p3i pair<pii, int>\n#define pll pair<ll, ll>\n#define p3l pair<pll, ll>\n#define vi vector<int>\n#define vpii vector<pii>\n#define vp3i vector<p3i>\n#define vpll vector<pll>\n#define vp3l vector<p3l>\n#define lseg L, (L+R)/2, N*2+1\n#define rseg (L+R)/2+1, R, N*2+2\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define MN 1000000007\n#define fox(k, x) for (int k=0; k<x; ++k)\n#define fox1(k, x) for (int k=1; k<=x; ++k)\n#define foxr(k, x) for (int k=x-1; k>=0; --k)\n#define fox1r(k, x) for (int k=x; k>0; --k)\n#define ms multiset\n#define flood(x) memset(x, 0x3f3f3f3f, sizeof x)\n#define drain(x) memset(x, 0, sizeof x)\n#define rng() ((rand() << 14)+rand())\n#define scan(X) do{while((X=getchar())<'0'); for(X-='0'; '0'<=(_=getchar()); X=(X<<3)+(X<<1)+_-'0');}while(0)\nchar _;\n#define pi 3.14159265358979323846\n\nint n, m, dp[200005], psa[200005];\nint sum, ans=0;\nstring s;\nint get(int N, int L){\n  int hi = N;\n  int lo = hi - L - 1;\n  //cout << N << ' ' << L << ' ' <<lo << ' ' << hi << endl;\n  int res = psa[hi];\n  if (lo >= 0) res -= psa[lo];\n  return res%MN;\n}\nint32_t main(){\n  cin >> n >> m >> s;\n  int pref = 0, lim, c = 0;\n  fox(l, m){\n    if (s[l] != s[0]) break;\n    pref++;\n  }\n  if (pref % 2 == 1)\n    lim = pref;\n  else\n    lim = pref + 1;\n  if (pref == m){\n    dp[0] = 1;\n    dp[1] = 1;\n    for(int l = 2; l <= n; ++l){\n      dp[l] = (dp[l-1]+dp[l-2])%MN;\n    }\n    cout << (dp[n-2] + dp[n])%MN;\n    return 0;\n  }\n  if (n%2 == 1){\n    if (pref != m){\n      printf(\"0\\n\");\n      return 0;\n    }\n  }\n  fox(l, m){\n    if (s[l]!=s[0]){\n      if (c%2 == 1){\n        lim = min(lim, c);\n      }\n      c=0;\n    } else {\n      c++;\n    }\n  }\n  if (c%2 == 1){\n    lim = min(lim, c);\n  }\n  n/=2;\n  lim /= 2;\n  lim = min(lim, n-1);\n  dp[0]= 1;\n  int p=0;\n  sum = 1;\n  psa[0] = 1;\n  fox1(l, n){\n    while(l-p-1 > lim){\n      sum = (sum - dp[p]) % MN;\n      ++p;\n    }\n    dp[l] = sum;\n    psa[l] = (psa[l-1] + dp[l]) % MN;\n    sum = (sum + dp[l]) % MN;\n    //cout << dp[l] << ' ';\n  }\n  fox(l, lim+1){\n    //starting component\n    ans = (ans + get(n-1-l, lim-l))%MN;\n  }\n  if (ans < 0) ans += MN;\n  cout << ans*2%MN;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,INF=0X3F3F3F3F,P=1e9+7;\nint n,m,f[N];\nchar s[N];\nvoid sol1(){\n\tf[1]=1;\n\trep(i,2,n+1)f[i]=(f[i-1]+f[i-2])%P;\n\tprintf(\"%d\\n\",(f[n-1]+f[n+1])%P);\n}\nvoid sol2(int n,int lim){\n\tD(\"n=%d lim=%d\\n\",n,lim);\n\tint cur=0;\n\tfor(int i=1;i<=n;++i){\n\t\tif(i>lim+1)cur=(cur-f[i-lim-1]+P)%P;\n\t\tf[i]=(cur+(i<=lim?i:0))%P;\n\t\tcur=(cur+f[i])%P;\n\t}\n\tprintf(\"%lld\\n\",2LL*f[n]%P);\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,s);\n\tif(s[0]=='B'){\n\t\trep(i,0,m-1)s[i]=(s[i]=='R'?'B':'R');\n\t}\n\tif(count(s,s+m,s[0])==m){\n\t\tsol1();\n\t\treturn 0;\n\t}\n\tbool fir=1;\n\tint mn=INF;\n\tfor(int i=0,j;i<m;i=j){\n\t\tj=i+1;\n\t\twhile(j<m&&s[j]==s[i])++j;\n\t\tif(s[i]=='R'&&(fir||(j-i)%2))mn=min(mn,j-i),fir=0;\n\t}\n\tsol2(n/2,mn/2+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  if(vs==vector<Int>(m,1)){\n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n\n  if(n&1){\n    cout<<0<<endl;\n    return 0;\n  }\n  \n  Int lim=n;  \n  for(Int i=0;i<m;i++){\n    if(vs[i]==0) continue;\n    Int j=i;\n    while(j<m&&vs[j]==1) j++;\n    if(j==m) break;\n    \n    if(i==0) chmin(lim,(j-i)+(~(j-i)&1));    \n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }  \n  \n  vector<M> dp(n+2,0),sm(n+2,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n+1;i++){\n    sm[i]=sm[i-1]+dp[i-1];\n    if(i&1) dp[i]=sm[i-1]-sm[max<Int>(1,i-1-lim)];\n  }\n  \n  M ans{0};\n  for(Int i=0;i<n;i++)\n    if(n-i+1>=max<Int>(1,n-lim))\n      ans+=sm[n-i+1]-sm[max<Int>(1,n-lim)];\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\ntypedef pair<int, int> P;\nconst long long inf = 1ll << 61;\n\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (n & 1) {\n\t\tcout << 0 << endl; return 0;\n\t}\n\telse assert(0);\n}"
  },
  {
    "language": "C++",
    "code": "//I forgot you...\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = (int)1e9 + 7;\nconst int MAXN = (int)2e5 + 3;\nconst int infint = (int)1e9 + 3;\nconst ll inf = (ll)1e18;\nint n, m, ans, mika = infint, dp[MAXN], part[MAXN];\nstring s;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif(c >= MOD)\n\t\tc -= MOD;\n\tif(c < 0)\n\t\tc += MOD;\n\treturn c;\n}\nint mul(int a, int b)\n{\n\tint c = 1LL * a * b % MOD;\n\treturn c;\n}\nvoid find_mika()\n{\n\tmika = n - 1;\n\tif(n % 2 == 1)\n\t\tmika--;\n\tif(s[0] == 'R')\n\t{\n\t\tbool first = 0;\n\t\tint ted = 0;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tif(s[i] == 'R')\n\t\t\t\tted++;\n\t\t\telse\n\t\t\tif(s[i] == 'B' && ted > 0)\n\t\t\t{\n\t\t\t\tif(ted % 2)\t\n\t\t\t\t\tmika = min(mika, ted);\n\t\t\t\telse\n\t\t\t\tif(first == 0)\n\t\t\t\t\tmika = min(mika, ted + 1);\n\t\t\t\tfirst = 1;\n\t\t\t\tted = 0;\n\t\t\t}\n\t}\n\telse\n\t{\n\t\tint ted = 0;\n\t\tbool first = 0;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tif(s[i] == 'B')\n\t\t\t\tted++;\n\t\t\telse\n\t\t\tif(s[i] == 'R' && ted > 0)\n\t\t\t{\n\t\t\t\tif(ted % 2)\n\t\t\t\t\tmika = min(mika, ted);\n\t\t\t\telse\n\t\t\t\tif(first == 0)\n\t\t\t\t\tmika = min(mika, ted + 1);\n\t\t\t\tfirst = 1;\n\t\t\t\tted = 0;\n\t\t\t}\n\t}\n}\nint getzarib(int kaman)\n{\n\tint emp = n - kaman;\n\tif(emp == 0)\n\t\treturn 1;\n\telse\n\t\treturn n - emp;\n}\nint main()\n{\n\tios::sync_with_stdio(false); \n\tcin.tie(0); cout.tie(0);\n\tcin >> n >> m >> s;\n\tbool flg = 1;\n\tfor (int i = 1; i < m; i++)\n\t\tif(s[i] != s[0])\t\n\t\t\tflg = 0;\n\tif(flg)\n\t{\n\t\tdp[0] = 1, dp[1] = 1, dp[2] = 2;\n\t\tfor (int i = 3; i <= n; i++)\n\t\t\tdp[i] = add(dp[i - 1], dp[i - 2]);\n\t\t\n\t\tans = dp[n];\n\t\tif(n >= 2)\n\t\t\tans = add(ans, dp[n - 2]);\n\t\tcout << ans;\n\t\treturn 0;\n\t}\n\tfind_mika();\n\t//cout << mika << endl;\n\n\tdp[0] = 1;\n\tpart[0] = 1;\n\tfor (int i = 2; i <= n; i += 2)\n\t{\n\t\tdp[i] = part[i - 2];\n\t\tif(i - mika - 3 >= 0)\n\t\t\tdp[i] = add(dp[i], -part[i - mika - 3]);\n\t\tpart[i] = add(part[i - 2], dp[i]);\n\t}\n\tans = add(ans, dp[n]);\n\tfor (int i = 1; i <= mika; i += 2)\n\t\tif(i != n - 2 && i != n)\n\t\t\tans = add(ans, mul(getzarib(i), dp[n - i - 1]));\n\t\telse\n\t\tif(i == n)\n\t\t\tans = add(ans, 1);\n\tcout << ans;\n}\n\n\n\n\n/*\n8 10\nRRRRBRRBBR\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define Md 1000000007\n#define MN 200005\nint n,m;\nchar c[MN];\nlg Pow(lg x,lg y){\n\tlg res=1;for(;y;y>>=1,x=x*x%Md)if(y&1)res=res*x%Md;return res;\n}\nint Fix(int x){\n\tif(x<0)return x+Md;\n\tif(x>=Md)return x-Md;\n\treturn x;\n}\nint dp[MN],tmp[MN];\nint miu[MN];\nint main(){\n\tread(n);read(m);\n\tscanf(\"%s\",c+1);\n\tmiu[1]=1;\n\tfor(int i=1;i<MN;++i){\n\t\tfor(int j=i+i;j<MN;j+=i){\n\t\t\tmiu[j]-=miu[i];\n\t\t}\n\t}\n\tchar Hd=c[1];\n\tint cnt=0,mx;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse break;\n\t}\n\tif(cnt&1)mx=cnt;else mx=0x3f3f3f3f;\n\tif(n&1){\n\t\tif(cnt!=m)return puts(\"0\"),0;\n\t\tint res=0;\n\t\ttmp[0]=tmp[1]=1;\n\t\tdp[0]=1;\n\t\tmx+=2;\n\t\tif(n>2)res=n;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tdp[i]=(i>=2?tmp[i-2]:0);\n\t\t\ttmp[i]=Fix(tmp[i-1]+dp[i]);\n\t\t\tif(i<n-1)res=Fix(res+1ll*dp[i]*(n-i)%Md);\n\t\t\t//cerr<<i<<' '<<dp[i]<<' '<<n<<' '<<i<<' '<<n/i<<endl;\n\t\t}\n\t\tprintf(\"%d\",res+1);\n\t\treturn 0;\n\t}\n\tint res=(cnt==m);\n\tcnt=0;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse{\n\t\t\tif(cnt&1)mx=min(mx,cnt);\n\t\t\telse if(cnt!=i)mx=min(mx,cnt+1);\n\t\t\tcnt=0;\n\t\t}\n\t}\n\t//for(int i=1;i<=5;++i)cerr<<miu[i]<<' ';cerr<<endl;\n\ttmp[0]=tmp[1]=1;\n\tdp[0]=1;\n\tmx+=2;\n\tif(n<mx)res=n;\n\tfor(int i=2;i<=n;i+=2){\n\t\tdp[i]=Fix(tmp[i-1]-(mx>i?0:tmp[i-mx]));\n\t\ttmp[i]=tmp[i+1]=Fix(tmp[i-1]+dp[i]);\n\t\tif((n-i)%2==0&&n-i<mx)res=Fix(res+dp[i]*(n-i)%Md);\n\t}\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define F first\n#define S second\n#define prev azaza\n#define MP make_pair\n#define PB push_back\n \nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n \nconst int max_n = 200111, inf = 1000111222;\nconst ll mod = 1000000007;\n \nint n, m;\nstring s;\n \nll dp[max_n];\nll pr[max_n];\nll dp2[max_n];\n \nll solve_allr() {\n    ll ans = 1;\n    dp[1] = 1;\n    dp[2] = 0;\n    ll sum = dp[1];\n    for (int i = 3; i < max_n; ++i) {\n        dp[i] = sum;\n        sum += dp[i - 1];\n        sum %= mod;\n    }\n    for (int len = 1; len < n; ++len) {\n        ans += dp[n - len] * (len + 1);\n        ans %= mod;\n    }\n    return ans;\n}\n \nll solve(int L) {\n    int L1 = L / 2;\n    pr[0] = 0;\n    pr[1] = 1;\n    dp2[1] = 1;\n    for (int i = 2; i < max_n; ++i) {\n        dp2[i] = (pr[i - 1] - pr[max(1, i - L1 - 1) - 1] + 2 * mod) % mod;\n        pr[i] = pr[i - 1] + dp2[i];\n        pr[i] %= mod;\n    }\n    dp[1] = 1;\n    for (int i = 3; i < max_n; i += 2) {\n        dp[i] = dp2[i / 2 + 1];\n    }\n    ll ans = 0;\n    for (int len = 1; len <= L; len += 2) {\n        ans += dp[n - len] * (len + 1);\n        ans %= mod;\n    }\n    return ans;\n}\n \nint main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> m;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (int i = 0; i < s.size(); ++i) {\n            s[i] = (s[i] == 'B' ? 'R' : 'B');\n        }\n    }\n    bool allr = 1;\n    for (char c : s) {\n        if (c == 'B') {\n            allr = 0;\n            break;\n        }\n    }\n    if (allr) {\n        cout << solve_allr() << endl;\n        return 0;\n    }\n    if (n % 2 == 1) {\n        cout << 0 << endl;\n        return 0;\n    }\n    while (s.back() == 'R') {\n        s.pop_back();\n    }\n    int L = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] == 'B') {\n            break;\n        } else {\n            ++L;\n        }\n    }\n    if (L % 2 == 0) {\n        ++L;\n    }\n    int len = 0;\n    for (int i = L; i < s.size(); ++i) {\n        if (s[i] == s[i - 1]) {\n            ++len;\n        } else {\n            if (s[i] == 'B' && len % 2 == 1) {\n                L = min(L, len);\n            }\n            len = 1;\n        }\n    }\n    cout << solve(L) << endl;\n    return 0;\n}\n \n// think 2:06"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=200005;\nconst int mo=1000000007;\nint n,m;\nchar s[N];\nnamespace solver1{\n\tint f[N][2][2];\n\tvoid solve(){\n\t\tf[1][0][0]=f[1][1][1]=1;\n\t\tFor(i,2,n) For(j,0,1) For(k,0,1) For(l,0,1)\n\t\t\tif (k|l) f[i][j][l]=(f[i][j][l]+f[i-1][j][k])%mo;\n\t\tint ans=0;\n\t\tFor(i,0,1) For(j,0,1)\n\t\t\tif (i|j) ans=(ans+f[n][i][j])%mo;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\nnamespace solver2{\n\tint pre[N],mn;\n\tint g[N],h[N];\n\tvoid solve(){\n\t\tpre[1]=1;\n\t\tmn=1<<30;\n\t\tFor(i,2,m)\n\t\t\tpre[i]=(s[i]==s[i-1]?pre[i-1]+1:1);\n\t\tFor(i,2,m)\n\t\t\tif (s[i-1]=='R'&&s[i]!='R'){\n\t\t\t\tif (pre[i-1]==i-1){\n\t\t\t\t\tif ((i-1)%2==0) mn=min(mn,pre[i-1]+1);\n\t\t\t\t\telse mn=min(mn,pre[i-1]);\n\t\t\t\t}\n\t\t\t\telse if (pre[i-1]%2)\n\t\t\t\t\tmn=min(mn,pre[i-1]);\n\t\t\t}\n\t\t++mn;\n\t\t//printf(\"%d\\n\",mn);\n\t\tg[0]=h[0]=1;\n\t\tFor(i,1,n){\n\t\t\tg[i]=((i>=2?h[i-2]:0)+mo-(i>=mn+2?h[i-mn-2]:0))%mo;\n\t\t\th[i]=(g[i]+(i>=2?h[i-2]:0))%mo;\n\t\t\t//printf(\"%d %d\\n\",g[i],h[i]);\n\t\t}\n\t\tint ans=0;\n\t\tfor (int i=2;i<=n&&i<=mn;i+=2)\n\t\t\tans=(ans+1ll*i*g[n-i])%mo;\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tif (s[1]=='B'){\n\t\tFor(i,1,m)\n\t\t\tif (s[i]=='B') s[i]='R';\n\t\t\telse s[i]='B';\n\t}\n\tbool flag=0;\n\tFor(i,1,m)\n\t\tif (s[i]!=s[1])\n\t\t\tflag=1;\n\tif (!flag)\n\t\tsolver1::solve();\n\telse solver2::solve();\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n \n#include <algorithm>\n#include <tuple>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n \n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n \ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 200010, P = 1000000007;\n\nint n, m;\nchar s[N];\n\nvoid add(int& x, int y) {\n  if ((x += y) >= P)\n    x -= P;\n}\n\nvoid sub(int& x, int y) {\n  if ((x -= y) < 0)\n    x += P;\n}\n\nint norm(int x) {\n  return x >= P ? x - P : x;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n >> m >> (s + 1);\n  char a = s[1];\n  if (count(s + 1, s + m + 1, a) == m) {\n    static int dp[N][2][2];\n    dp[1][0][0] = dp[1][1][1] = 1;\n    for (int i = 2; i <= n; ++i)\n      for (int j = 0; j < 2; ++j) {\n        add(dp[i][j][0], dp[i - 1][j][0]);\n        add(dp[i][j][0], dp[i - 1][j][1]);\n        add(dp[i][j][1], dp[i - 1][j][0]);\n      }\n    int ans = norm(norm(dp[n][0][0] + dp[n][0][1]) + dp[n][1][0]);\n    cout << ans << '\\n';\n    return 0;\n  }\n  int len = m;\n  int p = 1;\n  while (s[p] == a) ++p;\n  len = p - 1;\n  if (len % 2 == 0) ++len;\n  else len += 2;\n  int cur = 0;\n  for (; p <= m; ++p)\n    if (s[p] != a) {\n      if (cur & 1)\n        len = min(len, cur);\n      cur = 0;\n    } else\n      ++cur;\n  static int dp[N], sum[N];\n  dp[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    sum[i - 1] = dp[i - 1];\n    if (i - 3 >= 0)\n      add(sum[i - 1], sum[i - 3]);\n    dp[i] = sum[i - 2];\n    if (i - len - 3 > 0)\n      sub(dp[i], sum[i - len - 3]);\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; ++i)\n    if ((n - i) <= len && ((n - i) & 1))\n      ans = ans + (dp[i] * (n - i + 1LL)) % P;\n  cout << ans << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define prev azaza\n#define MP make_pair\n#define PB push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int max_n = 200111, inf = 1000111222;\nconst ll mod = 1000000007;\n\nint n, m;\nstring s;\n\nll dp[max_n];\nll pr[max_n];\nll dp2[max_n];\n\nll solve_allr() {\n    ll ans = 1;\n    dp[1] = 1;\n    dp[2] = 0;\n    ll sum = dp[1];\n    for (int i = 3; i < max_n; ++i) {\n        dp[i] = sum;\n        sum += dp[i - 1];\n        sum %= mod;\n    }\n    for (int len = 1; len < n; ++len) {\n        ans += dp[n - len] * (len + 1);\n        ans %= mod;\n    }\n    return ans;\n}\n\nll solve(int L) {\n    int L1 = L / 2;\n    pr[1] = 1;\n    dp2[1] = 1;\n    for (int i = 2; i < max_n; ++i) {\n        dp2[i] = (pr[i - 1] - pr[max(1, i - L1 - 1) - 1] + 2 * mod) % mod;\n        pr[i] = pr[i - 1] + dp2[i];\n        pr[i] %= mod;\n    }\n    dp[1] = 1;\n    for (int i = 3; i < max_n; i += 2) {\n        dp[i] = dp2[i / 2 + 1];\n    }\n    ll ans = 0;\n    for (int len = 1; len <= min(L, n - 1); len += 2) {\n        ans += dp[n - len] * (len + 1);\n        ans %= mod;\n    }\n    return ans;\n}\n\nint main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> m;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (int i = 0; i < s.size(); ++i) {\n            s[i] = (s[i] == 'B' ? 'R' : 'B');\n        }\n    }\n    bool allr = 1;\n    for (char c : s) {\n        if (c == 'B') {\n            allr = 0;\n            break;\n        }\n    }\n    if (allr) {\n        cout << solve_allr() << endl;\n        return 0;\n    }\n    if (n % 2 == 1) {\n        cout << 0 << endl;\n        return 0;\n    }\n    while (s.back() == 'R') {\n        s.pop_back();\n    }\n    int L = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] == 'B') {\n            break;\n        } else {\n            ++L;\n        }\n    }\n    if (L % 2 == 0) {\n        ++L;\n    }\n    int len = 0;\n    for (int i = L; i < s.size(); ++i) {\n        if (s[i] == s[i - 1]) {\n            ++len;\n        } else {\n            if (s[i] == 'B' && len % 2 == 1) {\n                L = min(L, len);\n            }\n            len = 1;\n        }\n    }\n    cout << solve(L) << endl;\n    return 0;\n}\n\n// think 2:06\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int N=2e5+5;\nconst int mod=1e9+7;\nint n,m,k,f[N],ans;char str[N];\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,str+1);\n\tk=n;while(m&&str[m]==str[1])--m;\n\tif(!m)ans=1;\n\tfor(int i=1,j=1;i<=m;i=j=j+1)\n\t\tif(str[i]==str[1]){\n\t\t\twhile(j<m&&str[j+1]==str[1])++j;\n\t\t\tif(i==1)\n\t\t\t\tif(j-i+1&1)k=min(k,j-i+1);\n\t\t\t\telse k=min(k,j-i+2);\n\t\t\telse\n\t\t\t\tif(j-i+1&1)k=min(k,j-i+1);\n\t\t}\n\tif(k==n){\n\t\tfor(int i=f[0]=1,j=0;i<=n;++i){\n\t\t\tf[i]=j;j=(j+f[i-1])%mod;\n\t\t}\n\t\tfor(int i=2;i<=n;++i)\n\t\t\tans=(ans+1ll*i*f[n-i])%mod;\n\t}else{\n\t\t++k;\n\t\tfor(int i=2,j=f[0]=1;i<=n;i+=2){\n\t\t\tf[i]=j;j=(j+f[i])%mod;\n\t\t\tif(i>=k)j=(j-f[i-k]+mod)%mod;\n\t\t}\n\t\tfor(int i=2;i<=k;i+=2)\n\t\t\tans=(ans+1ll*i*f[n-i])%mod;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 2e5 + 10, mod = 1e9 + 7;\n\nll dp[N], pref[N][2];\n\nll solve(int n, int bound, bool parity);\n\nint main() {\n\tfast_cin();\n\tint n, m; string s;\n\tcin >> n >> m >> s;\n\ts += (s.back() ^ 'R' ^ 'B');\n\tvector<int> parts;\n\tint cur = 1;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (s[i] != s[i - 1]) {\n\t\t\tparts.pb(cur);\n\t\t\tcur = 1;\n\t\t} else {\n\t\t\t++cur;\n\t\t}\n\t}\n\tint bound = parts[0] + (1 - (parts[0] & 1));\n\tfor (int i = 2; i < parts.size(); i += 2) {\n\t\tif (parts[i] & 1) {\n\t\t\tbound = min(bound, parts[i]);\n\t\t}\n\t}\n\tif (parts.size() == 1) {\n\t\tcout << (solve(n, n, false) + 1) % mod << '\\n';\n\t} else {\n\t\tcout << solve(n, bound, true) << '\\n';\n\t}\n}\n\nll solve(int n, int bound, bool parity) {\n\tdp[0] = 1;\n\tpref[0][0] = 1;\n\tif (!parity) {\n\t\tpref[0][1] = 1;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint lo = max(0, i - bound - 1), hi = i - 2;\n\t\tif (lo <= hi) {\n\t\t\tdp[i] = pref[hi][hi & 1] - (lo > 0 ? pref[lo - 1][hi & 1] : 0);\n\t\t\tdp[i] += mod;\n\t\t\tdp[i] %= mod; \n\t\t}\n\t\tpref[i][0] = pref[i - 1][0];\n\t\tpref[i][1] = pref[i - 1][1];\n\t\tpref[i][i & 1] += dp[i];\n\t\tpref[i][i & 1] %= mod;\n\t\tif (!parity) {\n\t\t\tpref[i][(i + 1) & 1] = pref[i][i & 1];\n\t\t}\n\t\t// cout << i << ' ' << dp[i] << '\\n';\n\t}\n\tll ans = dp[n];\n\tfor (int i = 1; i < n and i <= bound; ++i) {\n\t\tint lo = max(i, n + (i - 1) - bound) - i, hi = n - i - 1;\n\t\tif (lo <= hi) {\n\t\t\tans += pref[hi][n & 1] - (lo > 0 ? pref[lo - 1][n & 1] : 0);\n\t\t\tans += mod;\n\t\t\tans %= mod;\n\t\t}\n\t}\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << (a) << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int MOD = 1e9 + 7;\n\nvi split(string s) {\n    vi ans;\n    char last = 'X'; \n    s += 'X';\n    int streak = 0;\n    for (char c : s) {\n        if (c != last) {\n            if (streak) ans.pb(streak);\n            streak = 0;\n            last = c;\n        }\n        streak++;\n    }\n    return ans;\n}\n\nvoid add(int &x, int y) {\n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n\nvi go(int n, int lim, int start) {\n    vi dp(n+1);\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = 0;\n        if (i >= start) add(dp[i], dp[i-start]);\n        if (i >= lim+1) add(dp[i], MOD-dp[i-lim-1]);\n        add(dp[i], dp[i-1]);\n    }\n    for (int i = n; i >= 1; i--) add(dp[i], MOD-dp[i-1]);\n    return dp;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    int n,l;\n    string s;\n    while (cin >> n >> l >> s) {\n        auto p = split(s);\n        if (si(p) == 1) {\n            assert(0);\n            //cout << \"TODO\" << endl;\n            auto dp = go(n,n,2);\n            int ans = 0;\n            for (int dif = 1; dif <= n; dif++) {\n                if (dif == 1 || dif == n-1) continue;\n                add(ans, ll(dif) * dp[n-dif] % MOD);\n            }\n            cout << (ans+1)%MOD << endl;\n        }\n        else {\n            if (n%2 == 1) {\n                cout << 0 << endl;\n                continue;\n            }\n            int lim = n+l;\n            forn(i,si(p)) if (i == 0 || (i%2 == 0 && p[i]%2 == 1)) {\n                lim = min(lim, p[i]/2+1);\n            }\n            n /= 2;\n            auto dp = go(n, lim, 1);\n            int ans = 0;\n            for (int dif = 1; dif <= lim; dif++)\n                add(ans, ll(dif) * dp[n-dif] % MOD);\n            cout << 2*ans%MOD << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // clang-format off\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define in2(s,t)     rep(i,sz(s)){in(s[i] , t[i]);}\n#define in3(s,t,u)   rep(i,sz(s)){in(s[i] , t[i] , u[i]);}\n#define in4(s,t,u,v) rep(i,sz(s)){in(s[i] , t[i] , u[i] , v[i]);}\n#ifdef ONLINE_JUDGE\n  #define rep(i,N) for(int i = 0; i < (int)(N); i++)\n  #define repr(i,N) for(int i = (int)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(int i = 1; i <= (int)(N) ; i++)\n  #define repr1(i,N) for(int i = (N) ; (int)(i) > 0 ; i--)\n#else\n  #define rep(i,N) for(long long i = 0; i < (long long)(N); i++)\n  #define repr(i,N) for(long long i = (long long)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(long long i = 1; i <= (long long)(N) ; i++)\n  #define repr1(i,N) for(long long i = (N) ; (long long)(i) > 0 ; i--)\n#endif\nusing namespace std; void solve();\nusing ll = long long; template<class T = ll> using V = vector<T>;\nusing vi = V<int>; using vl = V<>; using vvi = V< V<int> >;\nusing vd = V<double>; using vs = V<string>; using vvl = V< V<> >;\nconstexpr int inf = 1001001001; constexpr ll infLL = (1LL << 61) - 1;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T,typename U>ll ceil(T a,U b){return (a + b - 1) / b;}\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); for(int i=0;i<s;i++) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);} while(0)\n  #define trcc(v) do { cerr << \"name : \" << #v << \"\\n\"; int cnt = 0; each(x , v){cerr << (cnt++) << \" : \"; trc(x); } } while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  #define trcc(...)\n  int main(){solve();}\n#endif\n\nconstexpr ll TEN(int n){ll ret=1,x=10;while(n){if(n&1)ret*=x;x*=x;n>>=1;}return ret;}\n#define mem(a, val) memset(a, val, sizeof(a))\n\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\nusing P = pair<ll,ll>; using vp = V<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n// clang-format on\n////////////////////////////////////////////////////\n\n\nvector<pair<char,int>> RunLengthEncoding(string& S){\n  vector<pair<char,int>> ret;\n  char c = -1;\n  int n = 0;\n  for(char x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate<typename T>\nvector<pair<T,int>> RunLengthEncoding(vector<T>& S){\n  vector<pair<T,int>> ret;\n  T c = -1;\n  int n = 0;\n  for(T& x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\nusing mint = modint;\n\nnamespace FastFourierTransform {\n  using real = double;\n\n  struct C {\n    real x, y;\n\n    C() : x(0), y(0) {}\n\n    C(real x, real y) : x(x), y(y) {}\n\n    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }\n\n    inline C conj() const { return C(x, -y); }\n  };\n\n  const real PI = acosl(-1);\n  int base = 1;\n  vector< C > rts = { {0, 0},\n                     {1, 0} };\n  vector< int > rev = {0, 1};\n\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    while(base < nbase) {\n      real angle = PI * 2.0 / (1 << (base + 1));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        real angle_i = angle * (2 * i + 1 - (1 << base));\n        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n      }\n      ++base;\n    }\n  }\n\n  void fft(vector< C > &a, int n) {\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          C z = a[i + j + k] * rts[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n  }\n\n  vector< int64_t > multiply(const vector< int > &a, const vector< int > &b) {\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = C(x, y);\n    }\n    fft(fa, sz);\n    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n      fa[i] = z;\n    }\n    for(int i = 0; i < (sz >> 1); i++) {\n      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n      fa[i] = A0 + A1 * s;\n    }\n    fft(fa, sz >> 1);\n    vector< int64_t > ret(need);\n    for(int i = 0; i < need; i++) {\n      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n    }\n    return ret;\n  }\n};\n\ntemplate< typename T >\nstruct ArbitraryModConvolution {\n  using real = FastFourierTransform::real;\n  using C = FastFourierTransform::C;\n\n  ArbitraryModConvolution() = default;\n\n  vector< T > multiply(const vector< T > &a, const vector< T > &b, int need = -1) {\n    if(need == -1) need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while((1 << nbase) < need) nbase++;\n    FastFourierTransform::ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < (int)a.size(); i++) {\n      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);\n    }\n    fft(fa, sz);\n    vector< C > fb(sz);\n    if(a == b) {\n      fb = fa;\n    } else {\n      for(int i = 0; i < (int)b.size(); i++) {\n        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);\n      }\n      fft(fb, sz);\n    }\n    real ratio = 0.25 / sz;\n    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C a1 = (fa[i] + fa[j].conj());\n      C a2 = (fa[i] - fa[j].conj()) * r2;\n      C b1 = (fb[i] + fb[j].conj()) * r3;\n      C b2 = (fb[i] - fb[j].conj()) * r4;\n      if(i != j) {\n        C c1 = (fa[j] + fa[i].conj());\n        C c2 = (fa[j] - fa[i].conj()) * r2;\n        C d1 = (fb[j] + fb[i].conj()) * r3;\n        C d2 = (fb[j] - fb[i].conj()) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector< T > ret(need);\n    for(int i = 0; i < need; i++) {\n      int64_t aa = llround(fa[i].x);\n      int64_t bb = llround(fb[i].x);\n      int64_t cc = llround(fa[i].y);\n      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;\n      ret[i] = aa + (bb << 15) + (cc << 30);\n    }\n    return ret;\n  }\n};\n\ntemplate< int mod >\nstruct NumberTheoreticTransform {\n\n  int base, max_base, root;\n  vector< int > rev, rts;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while(tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while(n > 0) {\n      if(n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) {\n    return mod_pow(x, mod - 2);\n  }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long) mod;\n  }\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while(base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n\n  void ntt(vector< int > &a) {\n    const int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n\n  vector< int > multiply(vector< int > a, vector< int > b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for(int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n\n  vector<modint> multiply_for_fps(const vector<modint> &a,const vector<modint> &b){\n    vector<int> A(a.size()) , B(b.size());\n    for(int i = 0;i < (int)a.size(); i++) A[i] = a[i].x;\n    for(int i = 0;i < (int)b.size(); i++) B[i] = b[i].x;\n    auto C = multiply( A , B );\n    vector<modint> ret(C.size());\n    for(int i = 0; i < (int)C.size() ;i++) ret[i].x = C[i];\n    return ret;\n  }\n};\n\n\ntemplate< typename T >\nstruct FormalPowerSeries : vector< T > {\n  using vector< T >::vector;\n  using P = FormalPowerSeries;\n\n  using MULT = function< P(P, P) >;\n\n  static MULT &get_mult() {\n    static MULT mult = nullptr;\n    return mult;\n  }\n\n  static void set_fft(MULT f) {\n    get_mult() = f;\n  }\n\n  void shrink() {\n    while(this->size() && this->back() == T(0)) this->pop_back();\n  }\n\n  P operator+(const P &r) const { return P(*this) += r; }\n\n  P operator+(const T &v) const { return P(*this) += v; }\n\n  P operator-(const P &r) const { return P(*this) -= r; }\n\n  P operator-(const T &v) const { return P(*this) -= v; }\n\n  P operator*(const P &r) const { return P(*this) *= r; }\n\n  P operator*(const T &v) const { return P(*this) *= v; }\n\n  P operator/(const P &r) const { return P(*this) /= r; }\n\n  P operator%(const P &r) const { return P(*this) %= r; }\n\n  P &operator+=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] += r[i];\n    return *this;\n  }\n\n  P &operator+=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] += r;\n    return *this;\n  }\n\n  P &operator-=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] -= r[i];\n    shrink();\n    return *this;\n  }\n\n  P &operator-=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] -= r;\n    shrink();\n    return *this;\n  }\n\n  P &operator*=(const T &v) {\n    const int n = (int) this->size();\n    for(int k = 0; k < n; k++) (*this)[k] *= v;\n    return *this;\n  }\n\n  P &operator*=(const P &r) {\n    if(this->empty() || r.empty()) {\n      this->clear();\n      return *this;\n    }\n    assert(get_mult() != nullptr);\n    return *this = get_mult()(*this, r);\n  }\n\n  P &operator%=(const P &r) {\n    return *this -= *this / r * r;\n  }\n\n  P operator-() const {\n    P ret(this->size());\n    for(int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];\n    return ret;\n  }\n\n  P &operator/=(const P &r) {\n    if(this->size() < r.size()) {\n      this->clear();\n      return *this;\n    }\n    int n = this->size() - r.size() + 1;\n    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);\n  }\n\n  P pre(int sz) const {\n    return P(begin(*this), begin(*this) + min((int) this->size(), sz));\n  }\n\n  P operator>>(int sz) const {\n    if(this->size() <= sz) return {};\n    P ret(*this);\n    ret.erase(ret.begin(), ret.begin() + sz);\n    return ret;\n  }\n\n  P operator<<(int sz) const {\n    P ret(*this);\n    ret.insert(ret.begin(), sz, T(0));\n    return ret;\n  }\n\n  P rev(int deg = -1) const {\n    P ret(*this);\n    if(deg != -1) ret.resize(deg, T(0));\n    reverse(begin(ret), end(ret));\n    return ret;\n  }\n\n  P diff() const {\n    const int n = (int) this->size();\n    P ret(max(0, n - 1));\n    for(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);\n    return ret;\n  }\n\n  P integral() const {\n    const int n = (int) this->size();\n    P ret(n + 1);\n    ret[0] = T(0);\n    for(int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);\n    return ret;\n  }\n\n  // F(0) must not be 0\n  P inv(int deg = -1) const {\n    assert(((*this)[0]) != T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1) / (*this)[0]});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 1\n  P log(int deg = -1) const {\n    assert((*this)[0] == 1);\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();\n  }\n\n  P sqrt(int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n\n    if((*this)[0] == T(0)) {\n      for(int i = 1; i < n; i++) {\n        if((*this)[i] != T(0)) {\n          if(i & 1) return {};\n          if(deg - i / 2 <= 0) break;\n          auto ret = (*this >> i).sqrt(deg - i / 2) << (i / 2);\n          if(ret.size() < deg) ret.resize(deg, T(0));\n          return ret;\n        }\n      }\n      return P(deg, 0);\n    }\n\n    P ret({T(1)});\n    T inv2 = T(1) / T(2);\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 0\n  P exp(int deg = -1) const {\n    assert((*this)[0] == T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1)});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  P pow(int64_t k, int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    for(int i = 0; i < n; i++) {\n      if((*this)[i] != T(0)) {\n        T rev = T(1) / (*this)[i];\n        P C(*this * rev);\n        P D(n - i);\n        for(int j = i; j < n; j++) D[j - i] = C[j];\n        D = (D.log() * k).exp() * (*this)[i].pow(k);\n        P E(deg);\n        if(i * k > deg) return E;\n        auto S = i * k;\n        for(int j = 0; j + S < deg && j < D.size(); j++) E[j + S] = D[j];\n        return E;\n      }\n    }\n    return *this;\n  }\n\n  T eval(T x) const {\n    T r = 0, w = 1;\n    for(auto &v : *this) {\n      r += w * v;\n      w *= x;\n    }\n    return r;\n  }\n};\n\nusing FPS = FormalPowerSeries< modint >;\n\n// fにa * x^n + bを掛ける\nvoid mul_simple(FPS &f,modint a ,int n, modint b){\n  for(int i = (int)f.size() - 1 ; i >= 0 ; i--){\n    f[i] *= b;\n    if(i >= n) f[i] += f[i - n] * a; \n  }\n}\n\n// fからa * x^n + bを割る\nvoid div_simple(FPS &f,modint a,int n,modint b){\n  for(int i = 0 ; i < (int)f.size() ; i++){\n    f[i] /= b;\n    if(i + n < (int)f.size() ) f[n + i] -= f[i] * a; \n  }\n}\n\n// f / gをdeg(f)次まで求める\nFPS div_(FPS &f , FPS g){\n  int n = f.size();\n  return (f * g.inv(n)).pre(n);\n}\n\n\n// solve関数内で\n//\n// FPS::set_fft(mul);\n//\n// とすること。\n\n/**\nNumberTheoreticTransform<MOD> ntt;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret =ntt.multiply_for_fps(a , b);\n  return FPS::P(ret.begin(), ret.end());\n};\n/*///\nArbitraryModConvolution< modint > fft;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret = fft.multiply(a, b);\n  return FPS::P(ret.begin(), ret.end());\n};\n//*/\n\n// 下記のリンクを実装(kitamasa法のモンゴメリ乗算を使わない版)\n// http://q.c.titech.ac.jp/docs/progs/polynomial_division.html\n// k項間漸化式のa_Nを求める O(k log k log N)\n// N ... 求めたい項　(0-indexed)\n// Q ... 漸化式 (1 - \\sum_i c_i x^i)の形\n// a ... 初期解 (a_0 , a_1 , ... , a_k-1)\n// x^N を fでわった剰余を求め、aと内積を取る\nmodint kitamasa(ll N, FPS &Q, FPS &a){\n  int k = Q.size() - 1;\n  assert( (int)a.size() == k );\n  FPS P = a * Q; P.resize(k);\n  while(N){\n    auto Q2 = Q;\n    for(int i = 1; i < (int)Q2.size(); i += 2) Q2[i].x = MOD - Q2[i].x;\n    auto S = P * Q2;\n    auto T = Q * Q2;\n    if(N & 1){\n      for(int i = 1 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    else{\n      for(int i = 0 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    N >>= 1;\n  }\n  return P[0];\n}\n\nvoid solve(){\n  ini(N , M);\n  ins(S);\n  auto run = RunLengthEncoding(S);\n  if(run.size() == 1){\n    // DP\n    V<mint> dp(N),ep(N),fp(N),gp(N);\n    // [0]がR\n    // -> [1],[-1]はどちらでもよい\n    dp[0] = gp[0] = 1;\n    rep1(i , N - 1){\n      dp[i] = dp[i - 1] + ep[i - 1];\n      ep[i] = dp[i - 1];\n      fp[i] = fp[i - 1] + gp[i - 1];\n      gp[i] = fp[i - 1];\n    }\n    out(dp[N-1] + ep[N-1] + fp[N-1]);\n    return;\n  }\n  if(N % 2 == 1){\n    out(0);\n    return;\n  }\n\n  FPS::set_fft(mul);\n  // rの最小値\n  int r = N-1 , b = N-1;\n  // 偶数は無視していい\n  // \n  if(run[0].second % 2 == 0) exit(1);\n  auto trans = [](int n){\n    return (n % 2 == 1) ? n : (n + 1);\n  };\n  rep(i , sz(run)){\n    if(i==0)continue;\n    auto p = run[i];\n    if(p.first == 'R' && p.second % 2 == 1) amin(r , trans(p.second));\n    if(p.first == 'B' && p.second % 2 == 1) amin(b , trans(p.second));\n  }\n\n  // 初手の制約\n  amin( (run[0].first == 'R' ? r : b) , trans(run[0].second) );\n  // 初手とは異なる方が1である必要あり\n  (run[0].first == 'R' ? b : r) = 1;\n  trc(r , b);\n  if(r < b) swap(r , b);  \n  auto nyaan = [&](ll n,int flg = false) -> FPS{\n    FPS ret(n + 1);\n    for(int i = 1 ; i <= n ; i += 2) ret[i] = (flg ? i + 1 : 1);\n    return ret;\n  };\n  FPS f({0 , 1});\n  f *= nyaan(r);\n  f *= -1; f[0] = 1;\n  if((int)f.size() <= N) f.resize(N + 2);\n  trc(f);\n  f = f.inv();\n  trc(f);\n  // [0]の置き方\n  f *= nyaan(r,1);\n  trc(f);\n  out(f[N-1]);\n  \n  \n  /*\n  //trc(f);\n  // 倍数包除\n  for(int i = 2 ; i <= N ; i++){\n    // i番目は？\n    //引こう！\n    for(int j = 2 ; i * j <= N ; j++){\n      f[i * j] -= f[i];\n    }\n  }\n  trc(f);\n  */\n\n}"
  },
  {
    "language": "C++",
    "code": "//*\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <numeric>\n#include <functional>\n#define MOD 1000000007\n#define MAX 0x3f3f3f3f\n#define MAX2 0x3f3f3f3f3f3f3f3fll\n#define ERR 1e-10\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#pragma warning(disable:4996)\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n\nint n, m;\nchar s[300000];\n\nll d[300000][2];\n\nll u[300000], v[300000];\n\nint main()\n{\n    int i, j, k, l;\n    ll ans=0;\n    cin>>n>>m;\n    scanf(\"%s\", s);\n    if(s[0] == 'B')\n    {\n        for(i=0;i<m;i++) s[i]=s[i]=='R'?'B':'R';\n    }\n    for(i=0;i<m;i++)\n    {\n        if(s[i] == 'R') s[i]='o';\n        else s[i]='x';\n    }\n    if(count(s, s+m, 'o') == m)\n    {\n        for(k=0;k<2;k++)\n        {\n            d[0][k]=1;\n            d[0][!k]=0;\n            for(i=1;i<n;i++)\n            {\n                d[i][0]=d[i-1][0]+d[i-1][1];\n                d[i][1]=d[i-1][0];\n                d[i][0]%=MOD, d[i][1]%=MOD;\n            }\n            if(k == 0)\n            {\n                ans+=d[n-1][0]+d[n-1][1];\n            }\n            else\n            {\n                ans+=d[n-1][0];\n            }\n        }\n        ans%=MOD;\n    }\n    else\n    {\n        if(n%2 == 1)\n        {\n            return !printf(\"0\");\n        }\n        n/=2;\n        int mi=MAX;\n        int cur=0;\n        int flag=0;\n        for(i=0;i<m;i++)\n        {\n            if(s[i] == 'o') cur++;\n            else\n            {\n                if(cur)\n                {\n                    if(flag == 0)\n                    {\n                        if(cur%2 == 0) cur++;\n                    }\n                    else\n                    {\n                        if(cur%2 == 0) continue;\n                    }\n                    mi=min(mi, cur);\n                    flag=1;\n                }\n                cur=0;\n            }\n        }\n        mi/=2;\n        if(mi >= n-1)\n        {\n            ans=1;\n            for(i=0;i<n;i++) ans*=2, ans%=MOD;\n            ans--;\n            ans+=MOD;\n            ans%=MOD;\n        }\n        else\n        {\n            u[0]=v[0]=1;\n            u[1]=1, v[1]=2;\n            for(i=2;i<n;i++)\n            {\n                int idx=max(-1, i-mi-2);\n                u[i]=(v[i-1]-(idx==-1?0:v[idx]))%MOD;\n                u[i]+=MOD;\n                u[i]%=MOD;\n                v[i]=v[i-1]+u[i];\n                v[i]%=MOD;\n            }\n            for(i=n-1;i>=n-1-mi;i--)\n            {\n                ans+=u[i]*(n-i);\n                ans%=MOD;\n            }\n        }\n        ans*=2;\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n//*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint n, m;\nstring s;\nint dp[212123];\nint dpsum[212123];\nbool nonmono;\n\n// msize EVEN\nvoid snon(int msize) {\n\tassert(msize % 2 == 0);\n\tdp[0] = 1;\n\tdpsum[0] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tdp[i] = dpsum[i-2];\n\t\tif (i-msize-2 >= 0) {\n\t\t\tdp[i] += MOD - dpsum[i-msize-2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tdpsum[i] = dp[i] + dpsum[i-2];\n\t}\n\tint ans = dp[n];\n\tfor (int i = 1; i < n; i++) {\n\t\t// first colour must be i + 1 + evener\n\t\tint x = i + 1;\n\t\tif (x % 2 != 0) x++;\n\t\t// x now even\n\t\tif (x > msize) break;\n\t\tans = (ans + dpsum[n-x]) % MOD;\n\t\tif (n-msize-2 >= 0) {\n\t\t\tans += MOD - dpsum[n-msize-2];\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\nvoid mono() {\n\tdp[0] = 1;\n\tdpsum[0] = 1;\n\tdpsum[1] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tdp[i] = dpsum[i-2];\n\t\tdpsum[i] = (dpsum[i-1] + dp[i]) % MOD;\n\t}\n\tint ans = dp[n] + 1;\n\tfor (int i = 0; i <= n-2; i++) {\n\t\tans = (ans + dpsum[i]) % MOD;\n\t}\n\tcout << ans << '\\n';\n}\n\nint main() {\n\tcin >> n >> m >> s;\n\tfor (int i = 1; i < m; i++) {\n\t\tif (s[i] != s[0]) {\n\t\t\tnonmono = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (nonmono) {\n\t\tint msize = n;\n\t\tif (msize % 2 == 1) msize--;\n\t\tint fcur = -1;\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (s[i] == s[0]) cur++;\n\t\t\telse if (cur) {\n\t\t\t\tif (fcur == -1) fcur = cur;\n\t\t\t\tif (cur % 2 == 1) {\n\t\t\t\t\tcur++;\n\t\t\t\t\tmsize = min(msize, cur);\n\t\t\t\t}\n\t\t\t\tcur = 0;\n\t\t\t}\n\t\t}\n\t\tif (cur > 0 && cur % 2 == 1) {\n\t\t\tcur++;\n\t\t\tmsize = min(msize, cur);\n\t\t}\n\t\tfcur += 2;\n\t\tif (fcur % 2 == 1) fcur--;\n\t\tmsize = min(fcur, msize);\n\t\t//cout << msize << '\\n';\n\t\tsnon(msize);\n\t} else {\n\t\tmono();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) FOR(i,0,b)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n#define fs first\n#define sc second\n\ntemplate<class T> using V=vector<T>;\ntemplate<class T> using VV=V<V<T>>;\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\trep(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"(\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\")\";\n}\n\nll read(){\n\tll i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconstexpr ll TEN(int n){\n\treturn n==0?1:TEN(n-1)*10;\n}\n\ntemplate<class T>\nvector<T> Uniqued(const vector<T>&vv){\n\tauto v(vv);\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n\treturn v;\n}\ntemplate<class T>\nvoid MakeUniqued(vector<T>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tstatic constexpr int base=mod;\n\tint v;\n\tModInt():v(0){}\n\tModInt(ll vv){\n\t\tv=vv%mod;\n\t\tif(v<0)v+=mod;\n\t}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n\texplicit operator int()const{\n\t\treturn v;\n\t}\n\tbool operator==(const ModInt&rhs)const{\n\t\treturn v==rhs.v;\n\t}\n\tbool operator!=(const ModInt&rhs)const{\n\t\treturn v!=rhs.v;\n\t}\n\tModInt operator-()const{\n\t\treturn ModInt(0)-*this;\n\t}\n\tModInt& operator+=(const ModInt&rhs){\n\t\tv+=rhs.v;\n\t\tif(v>=mod)v-=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator-=(const ModInt&rhs){\n\t\tv-=rhs.v;\n\t\tif(v<0)v+=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator*=(const ModInt&rhs){\n\t\tv=ll(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tModInt&operator/=(const ModInt&rhs){\n\t\toperator*=(rhs.inv());\n\t\treturn *this;\n\t}\n\tModInt operator+(const ModInt&rhs)const{\n\t\treturn ModInt(*this)+=rhs;\n\t}\n\tModInt operator-(const ModInt&rhs)const{\n\t\treturn ModInt(*this)-=rhs;\n\t}\n\tModInt operator*(const ModInt&rhs)const{\n\t\treturn ModInt(*this)*=rhs;\n\t}\n\tModInt operator/(const ModInt&rhs)const{\n\t\treturn ModInt(*this)/=rhs;\n\t}\n\tfriend ModInt operator+(int x,const ModInt&y){\n\t\treturn ModInt(x)+y;\n\t}\n\tfriend ModInt operator-(int x,const ModInt&y){\n\t\treturn ModInt(x)-y;\n\t}\n\tfriend ModInt operator*(int x,const ModInt&y){\n\t\treturn ModInt(x)*y;\n\t}\n\tfriend ModInt operator/(int x,const ModInt&y){\n\t\treturn ModInt(x)/y;\n\t}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tModInt inv()const{\n\t\treturn pow(mod-2);\n\t}\n};\n\ntemplate<int mod>\nostream& operator<<(ostream&os,const ModInt<mod>&m){\n\treturn os<<m.v;\n}\ntemplate<int mod>\nvoid print(const ModInt<mod>&m,int suc=1){\n\tprint(m.v,suc);\n}\n\nusing mint=ModInt<1000000007>;\n//using mint=ModInt<998244353>;\n\nconst int Vmax=min<int>(2000010,mint::base);\nmint fact[Vmax],factInv[Vmax],invs[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfactInv[Vmax-1]=fact[Vmax-1].inv();\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1]*(i+1);\n\t}\n\tfor(int i=Vmax-1;i>=1;i--){\n\t\tinvs[i]=factInv[i]*fact[i-1];\n\t}\n}\nstruct InitFactDummy{\n\tInitFactDummy(){\n\t\tInitFact();\n\t}\n} initFactDummy;\nmint Choose(int n,int k){\n\treturn fact[n]*factInv[n-k]*factInv[k];\n}\nmint Binom(int a,int b){\n\treturn fact[a+b]*factInv[a]*factInv[b];\n}\nmint Catalan(int n){\n\treturn Binom(n,n)-(n-1>=0?Binom(n-1,n+1):0);\n}\n\nV<mint> getDP(int m,int a,int b){\n\tV<mint> dp(m+1),sum(m+1);\n\tdp[0]=sum[0]=1;\n\tFOR(i,1,m+1){\n\t\tmint w;\n\t\tif(i-a>=0)w+=sum[i-a];\n\t\tif(i-b-1>=0)w-=sum[i-b-1];\n\t\tdp[i]=w;\n\t\tsum[i]=sum[i-1]+dp[i];\n\t}\n\treturn dp;\n}\n\nsigned main(){\n\tint n=read(),m=read();\n\tstring s=readString();\n\tif(s[0]!='R'){\n\t\tfor(auto&c:s){\n\t\t\tc='R'+'B'-c;\n\t\t}\n\t}\n\tif(s==string(m,'R')){\n\t\tauto dp=getDP(n,2,inf);\n\t\tmint ans=1;\n\t\tfor(int k=1;k<=n-1;k++){\n\t\t\tint rem=n-k-1;\n\t\t\tans+=dp[rem]*(k+1);\n\t\t}\n\t\tprint(ans);\n\t\treturn 0;\n\t}\n\tint lim=n-1;\n\tif(lim%2==0)lim--;\n\tfor(int i=0;i<m;){\n\t\tif(s[i]=='R'){\n\t\t\tint len=0;\n\t\t\twhile(i+len<m&&s[i+len]=='R')\n\t\t\t\tlen++;\n\t\t\ti+=len;\n\t\t\tif(i<m&&len%2)\n\t\t\t\tchmin(lim,len);\n\t\t\tif(i==len&&len%2==0)\n\t\t\t\tchmin(lim,len+1);\n\t\t}else{\n\t\t\ti++;\n\t\t}\n\t}\n\tconst int L=(lim+1)/2;\n\tauto dp=getDP(n,1,L);\n\tcerr<<L<<endl;\n\tcerr<<dp<<endl;\n\tmint ans;\n\tfor(int k=1;k<=lim;k+=2){\n\t\tint rem=(n-k-1);\n\t\tcerr<<rem<<endl;\n\t\tif(rem%2)continue;\n\t\tmint w=dp[rem/2];\n\t\tans+=w*(k+1);\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll md = 1e9+7;\n\nvector<ll> calc(int n, int k){\n\tvector<ll> todo(n);\n\ttodo[0] = -1;\n\tif(n > 1) todo[1] = 1;\n\trep(i,0,n){\n\t\tif(i+1 < n) todo[i+1] = (todo[i+1] + 2*todo[i]) % md;\n\t\tif(i + k+1 < n) todo[i+k+1] = (todo[i+k+1] - todo[i]) % md;\n\t\ttodo[i] *= -1;\n\t}\n\treturn todo;\n}\n\nvector<ll> calc1(int n){\n\tvector<ll> todo(n);\n\ttodo[0] = -1;\n\tif(n > 1) todo[1] = 1;\n\tvector<ll> ans(n);\n\trep(i,0,n){\n\t\tif(i+1 < n) todo[i+1] = (todo[i+1] + todo[i]) % md;\n\t\tif(i+2 < n) todo[i+2] = (todo[i+2] + todo[i]) % md;\n\t\ttodo[i] *= -1;\n\t}\n\treturn todo;\n}\n\nll solve(){\n\tint n, m;\n\tstring s;\n\tcin >> n >> m >> s;\n\tif(s[0]=='B') trav(c, s) c = 'B'+'R'-c;\n\tif(count(all(s), 'R') == m){\n      assert(false);\n\t\tll ans = 1;\n\t\tauto dp = calc1(n-1);\n\t\tfor(int l = 1; l < n; ++l)\n\t\t\tans += (l+1) * dp[n-l-1] % md;\n\t\treturn ans;\n\t} else {\n\t\tif(n%2) return 0;\n\t\tint mx = n-1;\n\t\trep(i,0,m) if(s[i]=='B' && s[i-1]=='R'){\n\t\t\tint j = i-1;\n\t\t\twhile(j >= 0 && s[j] =='R') --j;\n\t\t\tif(j == -1) mx = min(mx, 2*i-1);\n\t\t\telse if((i-j)%2) mx = min(mx, i-j);\n\t\t}\n\t\tauto dp = calc(n/2, (mx+1)/2);\n\t\tll ans = 0;\n\t\tfor(int l = 1; l <= mx; l += 2)\n\t\t\tans += (l+1) * dp[(n-l-1)/2] % md;\n\t\treturn ans;\n\t}\n}\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\n\tll res = solve();\n\tres %= md;\n\tif(res < 0) res += md;\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct SegT {\nprivate:\n\tint sz; vector<ll> node;\n\tconst ll init_c = 0;\npublic:\n\tSegT(int n) {\n\t\tsz = 1;\n\t\twhile (sz < n)sz *= 2;\n\t\tnode.resize(2 * sz - 1, init_c);\n\t}\n\tll f(ll a, ll b) {\n\t\treturn (a + b)%mod;\n\t}\n\tvoid update(int k, ll a) {\n\t\tk += sz - 1;\n\t\tnode[k] = a;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\tll query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = sz;\n\t\tif (r <= a || b <= l)return init_c;\n\t\telse if (a <= l && r <= b)return node[k];\n\t\telse {\n\t\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn f(vl, vr);\n\t\t}\n\t}\n};\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nll dp[1 << 18][2][2];\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (s[0] == 'B') {\n\t\trep(i, m) {\n\t\t\tif (s[i] == 'B')s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\tvector<int> v;\n\trep(i, m) {\n\t\tint le = i;\n\t\twhile (i + 1 < m&&s[i + 1] == s[i])i++;\n\t\tv.push_back(i - le + 1);\n\t}\n\tif (v.size() == 1) {\n\t\tdp[0][0][0] = 1;\n\t\tdp[0][1][1] = 1;\n\t\trep(i, n - 1) {\n\t\t\trep(j, 2) {\n\t\t\t\t(dp[i + 1][0][j] += dp[i][0][j] + dp[i][1][j]) %= mod;\n\t\t\t\tdp[i + 1][1][j] += dp[i][0][j];\n\t\t\t}\n\t\t}\n\t\tll ans = dp[n - 1][0][0] + dp[n - 1][1][0] + dp[n - 1][0][1];\n\t\tcout << ans % mod << endl; return;\n\t}\n\tif (n % 2) {\n\t\tcout << 0 << endl; return;\n\t}\n\tint d = n / 2;\n\tint x = v[0] / 2 + 1;\n\tfor (int i = 0; i < v.size(); i += 2) {\n\t\tif (v[i] % 2) {\n\t\t\tx = min(x, v[i] / 2 + 1);\n\t\t}\n\t}\n\tif (x >= d) {\n\t\tll ans = mod_pow(2, d) - 1;\n\t\tans = ans * 2;\n\t\tans = (ans + mod) % mod;\n\t\tcout << ans << endl;\n\t}\n\telse {\n\t\tSegT dp(d + 1);\n\t\tdp.update(0, 1);\n\t\trep1(i, d - 1) {\n\t\t\tint le = i - x;\n\t\t\tle = max(le, 0);\n\t\t\tll nex = dp.query(le, i);\n\t\t\tdp.update(i, nex);\n\t\t}\n\t\tll ans = 0;\n\t\trep(i, x) {\n\t\t\tll z = dp.query(d - x, d - i); ans += z;\n\t\t\tif (ans >= mod)ans -= mod;\n\t\t}\n\t\tans = ans * 2 % mod;\n\t\tcout << ans << endl;\n\t}\n\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PI 3.14159265358979323846264338327950288419\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint n, m;\nint col[200005];\n\nint expo(int a, int b){\n\tint c = 1, d = a;\n\twhile(b){\n\t\tif(b & 1){\n\t\t\tc = 1LL * c * d % mod;\n\t\t}\n\t\td = 1LL * d * d % mod;\n\t\tb >>= 1;\n\t}\n\treturn c;\n}\n\nint inv(int x){\n\treturn expo(x, mod - 2);\n}\n\nint calc(int n){\n\tif(n == 2){\n\t\treturn 2;\n\t}\n\t\n\tint fib[200005];\n\tfib[1] = fib[2] = 1;\n\tfor(int i = 3; i <= n + 1; i++){\n\t\tfib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t}\n\t\n\t// force first one to be 1, last one to be 0: fib[N - 1]\n\t// force first one to be 0: fib[N + 1]\n\treturn (fib[n - 1] + fib[n + 1]) % mod;\n}\n\nint calc2(int n, int ub){\n\tassert(ub & 1);\n\t\n\t// want a bunch of numbers, in [0, ub], to sum to n\n\t\n\tub++;\n\tub = min(ub, n); // coz it can actually be HUGE\n\t\n\tint dp[200005]; // dp[i]: number of possible sums, that sum to i\n\tlong long cumu[200005];\n\t\n\tdp[0] = 1;\n\tcumu[0] = 1;\n\t\n\tfor(int i = 2; i <= n; i += 2){\n\t\t// sum from dp[l_index .. i - 2].. oh, only the even ones!\n\t\tint l_index = i - ub;\n\t//\tprintf(\"%d: sum %d..%d\\n\", i, l_index, r_index);\n\t\tdp[i] = cumu[i - 2];\n\t\tif(l_index > 0){\n\t\t\tdp[i] -= cumu[l_index - 2];\n\t\t}\n\t\t\n\t\tif(dp[i] < 0) dp[i] += mod;\n\t\t\n\t\tcumu[i] = (cumu[i - 2] + dp[i]) % mod;\n\t}\n\t\n\tint ret = 0;\n\t\n\tfor(int space = 0; space < ub; space++){\n\t\t// last 1 is at (n - space), leaving _ space at the end\n\t\t// where can the first 1 be?\n\t\tint left_pos = 1;\n\t\tint right_pos = ub - space;\n\t\tint most_remain = (n - space) - 1;\n\t\tint least_remain = n - ub;\n\t\tif(most_remain & 1) most_remain--;\n\t\t\n\t\tint combin = 0;\n\t\tif(most_remain >= least_remain){\n\t\t\tcombin = cumu[most_remain];\n\t\t\tif(least_remain > 0){\n\t\t\t\tcombin = (combin - cumu[least_remain - 2] + mod) % mod;\n\t\t\t}\n\t\t}\n\t\tret = (ret + combin) % mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= m; i++){\n\t\tchar c;\n\t\tscanf(\" %c\", &c);\n\t\tcol[i] = (c == 'B');\n\t}\n\tif(col[1] != 0){\n\t\t// WLOG first one is 0\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tcol[i] = 1 - col[i];\n\t\t}\n\t}\n\t\n\tbool monochrome = true;\n\tfor(int i = 2; i <= m; i++){\n\t\tif(col[i]){\n\t\t\tmonochrome = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(monochrome){\n\t\t// ok as long as 1s are not adjacent\n\t\tprintf(\"%d\\n\", calc(n));\n\t\treturn 0;\n\t}else{\n\t\t// 00...010..010..0\n\t\t// each block of 0 is of add length\n\t\t// so, n odd -> definitely no solution\n\t\t// more conditions depending on specifics of col[]\n\t\tif(n % 2 == 1){\n\t\t \tprintf(\"0\\n\");\n\t\t \treturn 0;\n\t\t}\n\t\tint first_run = 0, subseq_run = 0;\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tint len = 0;\n\t\t\twhile(i + len <= m && col[i + len] == 0){\n\t\t \t\tlen++;\n\t\t \t}\n\t\t \tif(first_run == 0){\n\t\t \t\tfirst_run = len;\n\t\t \t}else if(len & 1){\n\t\t \t\tsubseq_run = max(subseq_run, len);\n\t\t \t}\n\t\t \ti += len;\n\t\t}\n\t\tint ub = first_run + (first_run % 2 == 0);\n\t\tub = max(ub, subseq_run);\n\t\tprintf(\"%d\\n\", calc2(n, ub));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n+10, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    if(res > MOD/2)exit(1);\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    if(str.size() != m)return 1;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i < vec.size();i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n\treturn powmod(a, MOD-2);\n}\nll f[200001], invf[200001];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n    invf[n]=inv(f[n]);\n    for(ll i=n-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n}\nll comb(int x, int y){\n    if(x<y) return 0;\n    return f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nint main()\n{\n    int n, m; cin>>n>>m;\n    string s; cin>>s;\n    if(s[0]=='B'){\n        for(int i=0; i<m; i++){\n            if(s[i]=='B') s[i]='R';\n            else s[i]='B';\n        }\n    }\n    int j=-1;\n    vector<int> v;\n    bool nuo=1;\n    for(int i=0; i<n; i++){\n        if(s[i]=='B') nuo=0;\n        if(i==n-1 || s[i+1]=='B'){\n            v.push_back(i-j);\n            j=i+1;\n        }\n    }\n    if(nuo){\n        ll dp[2][200002]={};\n        dp[0][0]=1;\n        for(int i=1; i<n; i++){\n            dp[1][i]+=dp[0][i-1];\n            dp[0][i]+=(dp[0][i-1]+dp[1][i-1]);\n            dp[0][i]%=MOD;\n            dp[1][i]%=MOD;\n        }\n        ll ans=dp[0][n-1]+dp[1][n-1];\n        fill(dp[0], dp[0]+n+1, 0);\n        fill(dp[1], dp[1]+n+1, 0);\n        dp[1][0]=1;\n        for(int i=1; i<n; i++){\n            dp[1][i]+=dp[0][i-1];\n            dp[0][i]+=(dp[0][i-1]+dp[1][i-1]);\n            dp[0][i]%=MOD;\n            dp[1][i]%=MOD;\n        }\n        ans+=dp[0][n-1];\n        ans%=MOD;\n        cout<<ans<<endl;\n        return 0;\n    }\n    if(n%2==1){\n        cout<<0<<endl;\n        return 0;\n    }\n    int mx=v[0]+1-v[0]%2;\n    for(int i=1; i<v.size(); i++){\n        if(v[i]&1) mx=min(mx, v[i]);\n    }\n    ll dp[200002]={}, sum[200002];\n    dp[0]=1;\n    sum[0]=1;\n    for(int i=1; i<=n; i++){\n        if(i&1) sum[i]=sum[i-1];\n        else{\n            if(i-mx-3>=0) dp[i]=(sum[i-2]-sum[i-mx-3]+MOD)%MOD;\n            else dp[i]=sum[i-2];\n            sum[i]=(sum[i-1]+dp[i])%MOD;\n        }\n    }\n    ll ans=0;\n    for(int i=1; i<=mx; i+=2){\n        ans+=(ll)(i+1)*dp[n-i-1];\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef pair<int, int> pi;\nconst int MAXN = 200005;\nconst int mod = 1e9 + 7;\n\nint n, m;\nint f[MAXN];\nchar s[MAXN];\nint sum[MAXN];\n\nint main(){\n\tscanf(\"%d %d %s\",&n,&m,s);\n\tfor(int i=0; i<m; i++) if(s[i] == 'R') s[i] = 'A';\n\tif(s[0] == 'B'){\n\t\tfor(int i=0; i<m; i++) s[i] = 'A' + 'B' - s[i];\n\t}\n\tif(count(s, s + m, 'B') == 0){\n\t\tf[0] = 1; f[1] = 2;\n\t\tfor(int i=2; i<=n; i++){\n\t\t\tf[i] = f[i-1] + f[i-2];\n\t\t\tf[i] %= mod;\n\t\t}\n\t\tlint ret = f[n];\n\t\tif(n == 3) ret += mod - 1;\n\t\telse if(n >= 4) ret += mod - f[n - 4];\n\t\tret %= mod;\n\t\tcout << ret << endl;\n\t\treturn 0;\n\t}\n\tint alt = 1e9;\n\tint pref = 0;\n\twhile(s[pref] == 'A') pref++;\n\tfor(int i=0; i<m; i++){\n\t\tif(s[i] == 'B'){\n\t\t\tint e = i + 1;\n\t\t\twhile(s[e] == 'A') e++;\n\t\t\tif(e == m) break;\n\t\t\tif(e > i + 1 && e % 2 == i % 2){\n\t\t\t\talt = min(alt, e - i - 1);\n\t\t\t}\n\t\t\ti = e - 1;\n\t\t}\n\t}\n\tif(n % 2 == 1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint x = min(alt, pref + 1);\n\tf[0] = 1;\n\tsum[0] = 1;\n\tfor(int i=1; i<=n/2; i++){\n\t\tf[i] = sum[i - 1];\n\t\tif(i >= (x + 3) / 2) f[i] += mod - sum[i - (x + 3) / 2];\n\t\tf[i] %= mod;\n\t\tsum[i] = (sum[i-1] + f[i]) % mod;\n\t}\n\tlint ret = 0;\n\tfor(int i=0; i<n;i++){\n\t\tint len = n - 1 - x;\n\t\tif(n - 1 - x > n - 1 - i) continue;\n\t\tret += sum[(n - 1 - i) / 2];\n\t\tif(len >= 1){\n\t\t\tret += mod - sum[(len - 1) / 2];\n\t\t}\n\t}\n\n\tcout << ret % mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vec>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\nmain(){\n    ios\n    calc();\n    int n=in(),m=in();\n    string s;cin>>s;\n    bool all_same=true;\n    rep(i,m){\n        if(s[i]!=s[0])all_same=false;\n    }\n    if(!all_same and (n&1)) cout<<0<<endl;\n    else if(all_same ){\n        mint dp[n+1][2]={};\n        dp[0][0]=1;\n        rep(i,n-1){\n            dp[i+1][1]+=dp[i][0];\n            dp[i+1][0]+=dp[i][0]+dp[i][1];\n        }\n        mint ans=dp[n-1][0]+dp[n-1][1];\n        rep(i,n)dp[i][0]=dp[i][1]=0;\n        dp[0][1]=1;\n        rep(i,n-1){\n            dp[i+1][1]+=dp[i][0];\n            dp[i+1][0]+=dp[i][0]+dp[i][1];\n        }\n        ans+=dp[n-1][0];\n        cout<<ans.a<<endl;\n    }\n    else{\n        char c=s[0];\n        int mi=INT_MAX;\n        rep(i,m){\n            int cnt=0;\n            while(i<m && s[i]==c)cnt++,i++;\n            chmin(mi,cnt);break;\n        }\n        if(mi %2 ==0)mi++;\n        rep(i,m){\n            if(s[i]==c){\n                int cnt=0;\n                while(i<m && s[i]==c)cnt++,i++;\n                if(cnt&1)\n                chmin(mi,cnt);\n            }\n        }\n        mint dp[700000]={};\n        mi=(mi+1)/2;\n        rep(i,mi){\n            dp[i]=2;\n        }\n        dp[mi]=-2*mi;\n        rep(i,n/2){\n            dp[i+1]+=dp[i]*2;\n            dp[i+1+mi]-=dp[i];\n        }\n        cout<<dp[n/2-1].a<<endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MOD = 1e9 + 7;\n\nvoid update(int& x, int a)\n{\n  x += a;\n  if (x >= MOD) {\n    x -= MOD;\n  }\n}\n\nint solve(int n, int m, const std::string& s)\n{\n  bool has_b = false;\n  int max_len = -1;\n  for (int i = 0, len = 0; i < m; ++ i) {\n    if (i && s[i - 1] != s[i]) {\n      if (s[i - 1] == s[0]) {\n        if (max_len == -1) {\n          max_len = len + 1;\n        } else if (len & 1) {\n          max_len = std::min(max_len, len + 1);\n        }\n      }\n      // printf(\"%c %d\\n\", s[i - 1], len);\n      len = 0;\n    }\n    has_b |= s[i] != s[0];\n    len ++;\n  }\n  std::vector<int> dp(n);\n  dp[0] = 1;\n  if (has_b) {\n    // <=> has A + has B + no consecutive B + len <= max_len\n    for (int i = 2, j = 0, sum = 0; i < n; i += 2) {\n      update(sum, dp[i - 2]);\n      if (i - j > max_len + 1) {\n        update(sum, MOD - dp[j]);\n        j += 2;\n      }\n      dp[i] = sum;\n    }\n    int result = 0;\n    for (int len = 2; len <= n && len - 1 <= max_len; len += 2) {\n      update(result, 1LL * len * dp[n - len] % MOD);\n    }\n    return result;\n  } else {\n    // AA...A <=> has A + no consecutive B\n    for (int i = 1, sum = 0; i < n; ++ i) {\n      if (i >= 2) {\n        update(sum, dp[i - 2]);\n      }\n      dp[i] = sum;\n    }\n    int result = 1; // no B\n    for (int len = 2; len <= n; ++ len) {\n      update(result, 1LL * len * dp[n - len] % MOD);\n    }\n    return result;\n  }\n}\n\nint main()\n{\n  int n, m;\n  while (std::cin >> n >> m) {\n    std::string s;\n    std::cin >> s;\n    std::cout << solve(n, m, s) << std::endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=2e5+20;\nconst int mod=1e9+7;\n\nint n,m;\nchar str[maxn];\nint lim;\nint f[maxn];\n\ninline void CHECK1()\n{\n\tREP(i,1,n)if(str[i]=='B')return;\n\tf[0]=1;f[1]=1;\n\tREP(i,2,n)f[i]=(f[i-1]+f[i-2])%mod;\n\tprintf(\"%d\\n\",(f[n-2]+f[n])%mod);\n\texit(0);\n}\n\ninline void init()\n{\n\tn=read();m=read();\n\tscanf(\"%s\",str+1);\n\tif(str[1]=='B')\n\t{\n\t\tREP(i,1,n)str[i]=str[i]=='B'?'R':'B';\n\t}\n\tCHECK1();\n\tlim=n;\n\tint lstb=0;\n\tREP(i,1,n)\n\t{\n\t\tif(str[i]=='B')\n\t\t{\n\t\t\tint num=i-lstb-1;\n\t\t\tif(lstb==0)chkmin(lim,num+(num+1&1));\n\t\t\telse if(num&1)chkmin(lim,num);\n\t\t\tlstb=i;\n\t\t}\n\t}\n\tlim=lim+1>>1;\n}\n\ninline void doing()\n{\n\tif(n&1)puts(\"0\"),exit(0);\n\tn>>=1;\n\tf[0]=1;int s=1;\n\tREP(i,1,n)\n\t{\n\t\tf[i]=s;\n\t\ts=(s+f[i])%mod;\n\t\tif(i-lim>=0)s=(s-f[i-lim]+mod)%mod;\n\t}\n\t//int ans=f[n>>1];\n\tint ans=0;\n\tREP(i,1,lim)ans=(ans+(ll)i*f[n-i])%mod;\n\tans=(ll)ans*2%mod;\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint N, M; char S[200200];\n\nconst long long mod = 1000000007;\nlong long D[200200], V[200200];\n\nint main()\n{\n\tscanf (\"%d %d %s\", &N, &M, S);\n\tif (S[0] == 'B'){\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tif (S[i] == 'R') S[i] = 'B';\n\t\t\telse S[i] = 'R';\n\t\t}\n\t}\n\n\tvector<int> len;\n\tfor (int i = 1, l = -1; i < M; i++){\n\t\tif (S[i-1] == 'R' && S[i] == 'B'){\n\t\t\tint u = i - l - 1;\n\t\t\tlen.push_back(u);\n\t\t\tl = i;\n\t\t}\n\t}\n\n\tif (len.empty()){\n\t\tif (N == 2){\n\t\t\tprintf (\"3\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tD[0] = 1;\n\t\tD[1] = 2;\n\t\tfor (int i = 2; i <= N; i++) D[i] = (D[i - 1] + D[i - 2]) % mod;\n\t\tprintf (\"%lld\\n\", (D[N - 1] + D[N - 3]) % mod);\n\t\treturn 0;\n\t}\n\n\tint lim = len[0];\n\tif (lim % 2 == 0) lim++;\n\tfor (int i = 1; i < len.size(); i++){\n\t\tif (len[i] % 2){\n\t\t\tif (lim > len[i])\n\t\t\t\tlim = len[i];\n\t\t}\n\t}\n\n\tD[0] = V[0] = 1;\n\tfor (int i = 1; i <= N; i++){\n\t\tif (i <= lim + 1) D[i] = i - 1;\n\t\tlong long u = 0, v = 0;\n\t\tif (i >= 2) u = V[i - 2];\n\t\tif (i >= lim + 3) v = V[i - (lim + 3)];\n\t\tD[i] = (D[i] + u + mod - v) % mod;\n\n\t\tV[i] = D[i];\n\t\tif (i >= 2) V[i] = (V[i] + V[i - 2]) % mod;\n\t}\n\tprintf (\"%lld\\n\", D[N]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"base.hpp\"//5\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//5b\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n#line 1 \"mod.hpp\"//5b\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//5bm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//5b\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//5b\nusing unit = tuple<>;using int128=__int128;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing VM=vec<mint>;using VI=vec<int>;\n#line 1 \"alias.hpp\"//5b\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//5b\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nnamespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}TL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){\nRT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//5b\nTL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)\n#line 6001 \"base.hpp\"//5\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1001 \"5.cpp\"//\n//#include \"consts.hpp\"\n// #include \"prime.hpp\"\n\nvoid solve() {\n// NM\"S\"\n/* <foxy.memo-area> */\nint N;int M;string S;cin>>N;cin>>M;cin>>S;\n/* </foxy.memo-area> */\n\n  if(S[0] == 'B') {\n    times(M, i) S[i] = 'R' + 'B' - S[i];\n  }\n\n  int p = 1ll << 60;\n  {\n    int ren = 1;\n    times(M, i) {\n      if(S[i] == 'R') {\n        ++ren;\n      } else {\n        if(p == 1ll << 60 || ren % 2 == 1) {\n          amin(p, ren);\n        }\n        ren = 0;\n      }\n    }\n  }\n  {if(debug)cerr<<\"p: \"<<(p)ln;}\n  if(p > M) {\n#define M hoge\n    mint ans = 0_m;\n    {\n      // [0]->R\n      VM dp(N);\n      dp[0] = 1_m;\n      dp[1] = 2_m;\n      uptil(2, N, i) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n      }\n      ans += dp[N - 1];\n      {if(debug)cerr<<\"dp: \"<<(dp)ln;}\n    }\n    {\n      // [0]->B\n      VM dp(N - 1);\n      dp[0] = 1_m;\n      if(N >= 3) dp[1] = 1_m;\n      uptil(2, N - 1, i) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n      }\n      ans += dp[N - 2];\n      {if(debug)cerr<<\"dp: \"<<(dp)ln;}\n    }\n\n    cout << ans ln;\n    return;\n  }\n\n  if(N % 2 == 1) {\n    cout << 0 ln;\n    return;\n  }\n\n  int m = N / 2;\n  int q = (p + 1) / 2;\n\n#define N hoge\n#define p hoge\n\n  /*\n  auto pfh = prime_factor(m);\n  int zpf = size(pfh);\n  VI pf; pf.reserve(zpf);\n  for(auto &p : pfh) pf.PB(p.first);\n  {if(debug)cerr<<\"pf: \"<<(pf)ln;}\n  */\n\n  /*\n  VI pf;\n  for(int i = 1; i*i <= m; ++i) {\n    if(m % i == 0) {\n      pf.PB(i);\n      if(i*i != m) pf.PB(m / i);\n    }\n  }\n  sort(iter(pf));\n  */\n  VI pf = {m};\n  {if(debug)cerr<<\"pf: \"<<(pf)ln;}\n  int zpf = size(pf);\n\n  VM dp(m);\n  VM g(zpf);\n\n  mint ans = 0_m;\n\n  times(zpf, h) {\n    mint s = dp[0] = 1_m;\n    uptil(1, pf[h], i) {\n      s += dp[i] = s;\n      if(i >= q) {\n        s -= dp[i - q];\n      }\n      if(i <= q) {\n        dp[i] += dp[0] * mint(i - 1);\n        s += dp[0] * mint(i - 1);\n      }\n    }\n\n    g[h] = s;\n    times(h, hh) {\n      if(pf[h] % pf[hh] == 0) g[h] -= g[hh];\n    }\n    ans += g[h] ;//* mint(pf[h]);\n\n    {if(debug)cerr<<'#'<<__LINE__ ln<<\"  h:     \"<<(h)ln<<\"  pf[h]: \"<<(pf[h])ln<<\"  s:     \"<<(s)ln<<\"  g[h]:  \"<<(g[h])ln<<\"  dp:    \"<<(dp)ln;}\n  }\n\n  cout << ans * 2_m ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 2e5 + 10,mod = 1e9 + 7;\n\nchar str[N];\nint dp[N];\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Add(int &x,int y) { if((x += y) >= mod) x -= mod; }\ninline int chk(int v) { return v < 0 ? 0 : dp[v]; }\ninline int val(int v) { return v & 1 ? v - 1 : v; }\n\nint main() {\n\n\tint n = read(),m = read(),flag = true;\n\tscanf(\"%s\",str + 1);\n\tFor(i,1,m - 1) if(str[i] != str[i + 1]) flag = false;\n\tif(flag) {\n\t\tint v00 = 1,v11 = 1,v01 = 0,v10 = 0;\n\t\tFor(i,2,n) {\n\t\t\tint c00 = v00,c10 = v10;\n\t\t\tAdd(v00,v10),Add(v10,v11);\n\t\t\tv01 = c00,v11 = c10;\n\t\t}\n\t\tprintf(\"%lld\\n\",(1ll * v00 + v10 + v01) % mod);\n\t\treturn 0;\n\t}\n\tif(n & 1) return puts(\"0\"),0;\n\tint v = INF,tot = 0;\n\tFor(i,1,m) {\n\t\tif(str[i] == str[1]) tot++;\n\t\telse {\n\t\t\tif(tot == i - 1) chkmin(v,tot + (tot % 2 == 0));\n\t\t\tif(tot & 1) chkmin(v,tot);\n\t\t\ttot = 0;\n\t\t}\n\t}\n\tv ++, dp[0] = 1;\n\tfor(int i = 2;i <= n;i += 2) dp[i] = (2 * dp[i - 2] - chk(i - 2 - v)) % mod;\n\tint ans = dp[n] - dp[n - 2];\n\tFor(i,1,v - 1) ans = (ans + dp[val(n - i - 1)] - dp[n - v - 2]) % mod;\n\tprintf(\"%d\\n\",(ans + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define Md 1000000007\n#define MN 200005\nint n,m;\nchar c[MN];\nlg Pow(lg x,lg y){\n\tlg res=1;for(;y;y>>=1,x=x*x%Md)if(y&1)res=res*x%Md;return res;\n}\nint Fix(int x){\n\tif(x<0)return x+Md;\n\tif(x>=Md)return x-Md;\n\treturn x;\n}\nint dp[MN],tmp[MN];\nint miu[MN];\nint main(){\n\tread(n);read(m);\n\tscanf(\"%s\",c+1);\n\tmiu[1]=1;\n\tfor(int i=1;i<MN;++i){\n\t\tfor(int j=i+i;j<MN;j+=i){\n\t\t\tmiu[j]-=miu[i];\n\t\t}\n\t}\n\tchar Hd=c[1];\n\tint cnt=0,mx;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse break;\n\t}\n\tif(cnt&1)mx=cnt;else mx=0x3f3f3f3f;\n\tif(n&1){\n\t\tif(cnt!=m)return puts(\"0\"),0;\n\t\tint res=0;\n\t\ttmp[0]=tmp[1]=1;\n\t\tdp[0]=1;\n\t\tmx+=2;\n\t\tif(n>2)res=n;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tdp[i]=(i>=2?tmp[i-2]:0);\n\t\t\ttmp[i]=Fix(tmp[i-1]+dp[i]);\n\t\t\tif(i<n-1)res=Fix(res+1ll*dp[i]*(n-i)%Md);\n\t\t\t//cerr<<i<<' '<<dp[i]<<' '<<n<<' '<<i<<' '<<n/i<<endl;\n\t\t}\n\t\tprintf(\"%d\",res+1);\n\t\treturn 0;\n\t}\n\tint res=(cnt==m);\n\tcnt=0;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse{\n\t\t\tif(cnt&1)mx=min(mx,cnt);\n\t\t\telse if(cnt!=i)mx=min(mx,cnt+1);\n\t\t\tcnt=0;\n\t\t}\n\t}\n\t//for(int i=1;i<=5;++i)cerr<<miu[i]<<' ';cerr<<endl;\n\ttmp[0]=tmp[1]=1;\n\tdp[0]=1;\n\tmx+=2;\n\tif(n<mx)res+=n;\n\tfor(int i=2;i<=n;i+=2){\n\t\tdp[i]=Fix(tmp[i-1]-(mx>i?0:tmp[i-mx]));\n\t\ttmp[i]=tmp[i+1]=Fix(tmp[i-1]+dp[i]);\n\t\tcerr<<dp[i]<<' '<<i<<endl;\n\t\tif((n-i)%2==0&&n-i<mx)res=Fix(res+dp[i]*(n-i)%Md);\n\t}\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nint (*rd)()=read<int>;\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\nconst u32 P=1e9+7;\nu32 &inc(u32 &a, u32 b) {return (a+=b)<P?a:(a-=P);}\nu32 &dec(u32 &a, u32 b) {return (a-=b)&0x80000000?(a+=P):a;}\nu32 sum(u32 a, u32 b) {return inc(a, b);}\nu32 dif(u32 a, u32 b) {return dec(a, b);}\n\nconst int N=1e5+5;\nint n, m;\nu32 f[N];\nchar s[N];\nint main() {\n\tassert(scanf(\"%d%d%s\", &n, &m, s)==3);\n\tif(s[0]=='B') for(int i=0; i<m; ++i) s[i]^='B'^'R';\n\tif(std::count(s, s+m, 'B')==0) {\n\t\tf[0]=f[1]=1;\n\t\tfor(int i=2; i<=n; ++i) f[i]=sum(f[i-1], f[i-2]);\n\t\tprintf(\"%u\\n\", sum(f[n], f[n-2]));\n\t\treturn 0;\n\t}\n\tif(n%2==1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint ml=n;\n\tfor(int l=0, r; l<n; l=r+1) {\n\t\tfor(r=l; r<n&&s[r]=='R'; ++r);\n\t\tif(r==n) break;\n\t\tif(l==0) cmin(ml, r+1); else if((r-l)%2==1) cmin(ml, r-l);\n\t}\n\tml=(ml+1)/2;\n\tn/=2;\n\tu32 s=0;\n\tfor(int i=1; i<=n; ++i) {\n\t\tf[i]=s;\n\t\tif(i<=ml) inc(f[i], 2*i);\n\t\tinc(s, f[i]);\n\t\tif(i>=ml) dec(s, f[i-ml]);\n\t}\n\tprintf(\"%u\\n\", f[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=2e5+10,mod=1e9+7;\ninline void Dec(int &x,int y) { x-=y; if(x<0) x+=mod; }\ninline void Add(int &x,int y) { x+=y; if(x>=mod) x-=mod; }\nchar S[N];\nint n,m,f[N];\nint main() {\n\trd(n),rd(m);\n\tscanf(\"%s\",S+1);\n\tchar c=S[1];\n\tint p=1,r=1,L=m;\n\t\n\twhile(r<=m&&S[r]==c) r++;\n\tif(r==m+1) {\n\t\tif(n==2) { printf(\"3\\n\"); return 0; }\n\t\tf[0]=1,f[1]=2;\n\t\tfor(int i=2;i<=n;++i) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",(f[n-3]+f[n-1])%mod);\n\t\treturn 0;\n\t}\n\t\n\tL=min(L,(r-p)|1);\t\n\tp=r;\n\twhile(p<=m&&S[p]!=c) p++;\n\t\n\tdo {\n\t\tr=p;\n\t\twhile(r<=m&&S[r]==c) r++;\n\t\tL=min(L,(r-p)|1);\n\t\tp=r;\n\t\twhile(p<=m&&S[p]!=c) p++;\n\t} while(p<=m);\n\t\n\tint sum[2]={0,0};\n\tf[1]=1,sum[1]=1;\n\tfor(int i=2;i<=n;++i) {\n\t\tf[i]=sum[i&1];\n\t\tif(i-L-1>=1) Dec(sum[i&1],f[i-L-1]);\n\t\tAdd(sum[i&1],f[i]);\n\t}\n\tint ans=0;\n\tfor(int i=2;i<=n;++i) {\n\t\tif(n-i>L||!((n-i)&1)) continue;\n\t\tAdd(ans,f[i]*(ll)(n-i+1)%mod);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nconst int MOD = 1000000007; // 998244353\n\ntemplate <typename T>\nstruct modular {\n    constexpr modular() : val(0){}\n    constexpr modular(const modular<T>& _m) : val(_m.val) {}\n    template <typename U> constexpr modular(const U& _r = U()) {\n        val = -MOD <= _r && _r < MOD ? _r: _r % MOD;\n        if (val < 0) { val += MOD; } }\n    const T operator()() { return val; }\n    template <typename U> explicit operator U() const { return static_cast<U>(val); }\n    modular<T>& operator+=(const modular<T>& _m) { if ((val += _m.val) >= MOD) { val -= MOD; } return *this; }\n    modular<T>& operator-=(const modular<T>& _m) { if ((val -= _m.val) < 0) { val += MOD; } return *this; }\n    modular<T>& operator*=(const modular<T>& _m) { val = modular<T>(static_cast<int64_t>(val) * static_cast<int64_t>(_m.val)).val; return *this; }\n    modular<T>& operator/=(const modular<T>& _m) {\n        T a = _m.val, b = MOD, u = 0, v = 1;\n        while (a != 0) {\n            T q = b / a;\n            b -= q * a; swap(a, b);\n            u -= q * v; swap(u, v); \n        } return *this *= u; }\n    modular<T>& operator =(const modular<T>& _m) { val = _m.val; return *this; }\n    template <typename U> modular<T>& operator+=(const U& _r) { return *this += modular<T>(_r); }\n    template <typename U> modular<T>& operator-=(const U& _r) { return *this -= modular<T>(_r); }\n    template <typename U> modular<T>& operator*=(const U& _r) { return *this *= modular<T>(_r); }\n    template <typename U> modular<T>& operator/=(const U& _r) { return *this /= modular<T>(_r); } \n    template <typename U> modular<T>& operator =(const U& _r) { val = modular<T>(_r).val; return *this; }\n    modular<T> operator-() { return modular<T>(-val); }    \n    template <typename U> friend bool operator==(const modular<U>&, const modular<U>&);\n    friend std::istream& operator>>(std::istream& os, modular<T>& _m) { os >> _m.val; _m *= 1; return os; }\n    friend std::ostream& operator<<(std::ostream& os, const modular<T>& _m) { return os << _m.val; }\n    template <typename U>\n    modular<T> exp(U e) {\n        modular<T> res = 1;\n        modular<T> b = val;\n        if (e < 0) { b = 1/b; e *= -1; }\n        for (; e; e >>= 1) {\n            if (e & 1) { res *= b; }\n            b *= b;\n        } return res; }\nprivate:\n    T val;\n};\ntemplate <typename T> inline modular<T> operator+(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator+(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) += _rhs; }\ntemplate <typename T> inline modular<T> operator-(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator-(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) -= _rhs; }\ntemplate <typename T> inline modular<T> operator*(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator*(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) *= _rhs; }\ntemplate <typename T> inline modular<T> operator/(const modular<T>& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const modular<T>& _lhs, const U& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T, typename U> inline modular<T> operator/(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) /= _rhs; }\ntemplate <typename T> inline bool operator==(const modular<T>& _lhs, const modular<T>& _rhs) { return _lhs.val == _rhs.val; }\ntemplate <typename T, typename U> inline bool operator==(const modular<T>& _lhs, const U& _rhs) { return _lhs == modular<T>(_rhs); }\ntemplate <typename T, typename U> inline bool operator==(const U& _lhs, const modular<T>& _rhs) { return modular<T>(_lhs) == _rhs; }\ntemplate <typename T> inline bool operator!=(const modular<T>& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const modular<T>& _lhs, const U& _rhs) { return !(_lhs == _rhs); }\ntemplate <typename T, typename U> inline bool operator!=(const U& _lhs, const modular<T>& _rhs) { return !(_lhs == _rhs); }\ntypedef modular<int> mint;\n\nvoid solve() {\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if (s == string(m, s[0])) {\n        vector<mint> dp(n+1, 0);\n        vector<mint> su(n+1, 0);\n        dp[0] = 1; su[0] = 1;\n        for (int i = 1; i < n; i++) {\n            int j = max(0, i-2);\n            dp[i] = su[j];\n            su[i] = su[i-1] + dp[i];\n        }\n        dp[n] = dp[n-1];\n        su[n] = su[n-1] + dp[n];\n        cout << su[n];\n        return;\n    }\n    if (n & 1) {\n        cout << 0; return;\n    }\n    vector<int> candi; candi.reserve(n);\n    int cnt = 0;\n    for (char c: s) {\n        if (c == s[0]) {\n            cnt++;\n        } else {\n            if (cnt)\n                candi.emplace_back(cnt);\n            cnt = 0;\n        }\n    }\n    int L = candi[0];\n    if (!(L&1)) L++;\n    for (int l: candi) {\n        if (l&1)\n            L = min(L, l);\n    }\n    n >>= 1;\n    L >>= 1;\n    vector<mint> dp(n+1, 0);\n    vector<mint> su(n+1, 0);\n    dp[1] = 1; su[1] = 1;\n    for (int i = 2; i <= n; i++) {\n        int j = max(0, i-L-2);\n        dp[i] = su[i-1] - su[j];\n        su[i] = su[i-1] + dp[i];\n    }\n    mint res = 0;\n    for (int i = max(1, n-L); i <= n; i++) {\n        res += dp[i] * (n-i+1);\n    }\n    res *= 2;\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for ((i)=1;(i)<=(n);(i)++)\nusing namespace std;\nconst int mod=1e9+7;\nint n,m,i,lst,dp[100005],s[100005],f[100005][2],tmp,mi=0x3f3f3f3f,l;\nstring st;\nint main(){\n\tcin>>n>>m;\n\tcin>>st;\n\tst=\" \"+st;\n\ti=1;lst=1;\n\twhile(i<=n){\n\t\tif(st[i]!=st[i-1]){\n\t\t\tif(st[i]!=st[1]){\n\t\t\t\tif(lst==1||((i-lst)&1)){\n\t\t\t\t\tmi=min(mi,i-lst);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlst=i;\n\t\t\t}\n\t\t}\n\t\ti++;\n\t}\n\tif(mi<0x3f3f3f3f){\n\t\tif(n&1){\n\t\t\tputs(\"0\");\n\t\t\treturn 0;\n\t\t}\n\t\tmi=mi/2+1;\n\t\tn/=2;\n\t\tl=1;\n/*\t\ts[1]=1;s[mi+1]+=mod-1;\n\t\trep(i,n){\n\t\t\ttmp=(tmp+s[i])%mod;\n\t\t\tdp[i]=tmp;\n\t\t\ts[min(n,i+1)]=(s[min(n,i+1)]+dp[i])%mod;\n\t\t\ts[min(n,i+mi)+1]=(s[min(n,i+mi)+1]+mod-dp[i])%mod;\n\t\t}\n\t\tcout<<dp[n]<<endl;*/\n\t}\n\telse{\n\t\tl=2;\n\t}\n\tfor(i=l;i<=n;i++){\n\t\tdp[i]=(s[i-l]+(i>mi?-s[i-mi-1]:(3ll-l)*i))%mod;\n\t\ts[i]=(s[i-1]+dp[i])%mod;\n\t}\n\tcout<<(dp[n]+l-1+mod)%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tstring s;\n\tcin >> s;\n\tset<char>st;\n\tfor (auto i : s)st.insert(i);\n\tif (st.size() == 1) {\n\t\tvector<long long int>dp(N + 1);\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1];\n\t\t\tif (i > 1)dp[i] += dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tlong long int ans = dp.back();\n\t\tdp[0] = 1;\n\t\tdp[1] = 0;\n\t\tfor (int i = 2; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tans += dp.back();\n\t\tans %= MOD;\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\ts.push_back(s[0] + 1);\n\tvector<int>num(s.size() + 1);\n\tfor (int i = 0; i <= s.size(); i++) {\n\t\tnum[i] = s[i] == s[0];\n\t\tif (i)num[i] = num[i] * (num[i - 1] + 1);\n\t}\n\tint fst = 0;\n\tint m = MOD;\n\tbool even = true;\n\tfor (int i = 1; i < s.size()-1; i++) {\n\t\tif (!num[i] && num[i - 1]) {\n\t\t\tif (num[i - 1] & 1) {\n\t\t\t\teven = false;\n\t\t\t\tm = min(m, num[i - 1]);\n\t\t\t}\n\t\t\tif (fst == 0) {\n\t\t\t\tfst = num[i - 1];\n\t\t\t\tif (fst % 2 == 0)m = MOD;\n\t\t\t}\n\t\t}\n\t}\n\tif (even) {\n\t\tm = fst + 2;\n\t}\n\telse if (fst % 2 == 0) {\n\t\tm = min(m, fst+2);\n\t}\n\tif (m & 1)m++;\n\t//cout << m << endl;\n\tvector<long long int>dp(N + 2);\n\tvector<long long int>sum(N + 2);\n\tfor (int i = 2; i <= m; i += 2)dp[i] = i;\n\tfor (int i = 2; i <= N; i++) {\n\t\tdp[i] += sum[i - 2] + MOD;\n\t\tif (i - m - 2 >= 0)dp[i] -= sum[i - m - 2];\n\t\tdp[i] %= MOD;\n\t\tif (i == N) {\n\t\t\tcout << dp[i] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsum[i] = sum[i - 2] + dp[i];\n\t\tsum[i] %= MOD;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\n\nint n;\nint m;\nstring s;\nconst int mod = 1e9 + 7;\n\nconst int maxn = 2e5 + 5;\nint f[maxn];\nint pre[maxn];\n\nvoid add(int &a, int b){\n    a += b;\n    if(a >= mod)\n        a -= mod;\n}\n\nvoid single(){\n    f[0] = 1;\n    f[1] = 2;\n    for(int i = 2;i <= n;i++){\n        f[i] = (f[i - 1] + f[i - 2]) % mod;\n    }\n    int ans = (2 * f[n - 1] - f[n - 2]) % mod;\n    ans = (ans + mod) % mod;\n    cout << ans << endl;\n}\n\nvoid solve(int v){\n    v /= 2, n /= 2; \n    v = min(v, n);\n    f[0] = 1;\n    pre[0] = 1;\n    for(int i = 1;i <= v;i++){\n        f[i] = pre[i - 1];\n        pre[i] = pre[i - 1];\n        add(pre[i], f[i]);\n    }\n    for(int i = v + 1;i <= n;i++){\n        f[i] = (pre[i - 1] - pre[i - v - 1] + mod) % mod;\n        pre[i] = pre[i - 1];\n        add(pre[i], f[i]);\n    }\n    int ans = 0;\n    for(int i = 1;i <= v;i++){\n        int r = n - i;\n        int l = n - v;\n        int tmp;\n        if(l == 0){\n            tmp = pre[r];\n        }else{\n            tmp = (pre[r] - pre[l - 1] + mod) % mod;\n        }\n        add(ans, tmp);\n    }\n    ans = ans * 2 % mod;\n    cout << ans << endl;\n}\n\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    cin >> n >> m;\n    cin >> s; \n    if(s[0] == 'B'){\n        for(int i = 0;i < m;i++){\n            if(s[i] == 'R')\n                s[i] = 'B';\n            else\n                s[i] = 'R';\n        }\n    } \n    int first = -1, last = -1;\n    for(int i = 0;i < m;i++){\n        if(s[i] == 'B'){\n            if(first == -1)\n                first = i;\n            last = max(last, i);\n        }\n    }\n    if(first == -1){\n        single();\n    }else{\n        if(n & 1){\n            cout << 0 << endl;\n        }else{\n            string s1 = s.substr(0, last + 1);\n            int len = s1.length();\n            if(first == 1){\n                cout << 2 << endl;\n            }else{\n                int val = first / 2 * 2 + 2;\n                int pre = first;\n                for(int i = first + 1;i < len;i++){\n                    if(s[i] == 'B'){\n                        int x = i - pre;\n                        pre = i;\n                        if(x % 2 == 0){\n                            val = min(val, x);\n                        }\n                    } \n                }\n                solve(val);\n            }\n        }\n    }    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\ntemplate <typename T> void chmin(T &x,const T &y)\n{\n\tif(x>y)x=y;\n}\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\ntypedef long long s64;\nconst int N=2e5+5,D=1e9+7;\nchar s[N];\ns64 dp[N],sum[N];\n\nint main()\n{\n#ifdef kcz\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tint n,m;\n\tcin>>n>>m;\n\tscanf(\"%s\",s+1);\n\tif(s[1]=='B')\n\trep(i,1,m)s[i]=\"RB\"[s[i]=='R'];\n\tint mn[2]={N,N},now=0;\n\trep(i,1,m+1)\n\tif(s[i]=='R')++now;\n\telse \n\t{\n\t\tif(now)chmin(mn[now%2],now);\n\t\tnow=0;\n\t}\n\tif(min(mn[0],mn[1])==N)\n\t{\n\t\tdp[0]=1;\n\t\trep(i,2,n+2)dp[i]=(dp[i-1]+dp[i-2])%D;\n\t\tcout<<(dp[n]+dp[n+2])%D;\n\t}\n\telse\n\t{\n\t\tchmin(mn[1],mn[0]+1);\n\t\tif(n%2){puts(\"0\");exit(0);}\n\t\tdp[0]=sum[0]=1;\n\t\trep(i,2,n)\n\t\t{\n\t\t\tdp[i]=sum[i-2];\n\t\t\tint j=i-mn[1]-1-2;\n\t\t\tif(j>=0)dp[i]-=sum[j];\n\t\t\tdp[i]%=D;\n\t\t\tsum[i]=(sum[i-2]+dp[i])%D;\n\t\t}\n\t\ts64 ans=0;\n\t\trep(x,0,min(n/2-1,mn[1]/2))\n\t\t{\n\t\t\tans+=sum[n-2*x-2];\n\t\t\tif(mn[1]+3<=n)ans-=sum[n-mn[1]-1-2];\n\t\t}\n\t\tcout<<(ans*2%D+D)%D;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <list>\n#include <iterator>\n#include <assert.h>\n#pragma warning(disable:4996) \n\ntypedef long long ll;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF 9223300000000000000\n#define INF 2140000000\nconst long long MOD = 1000000007;\nusing namespace std;\n\nchar str[200005];\n\n// A(Bを数個)A(Bを数個)..A(Bを数個) \n// という列の作り方が何通りあるか、を求める\n// ただし列の長さをn、Bを重ねるのは各箇所について0個以上k個以下とする\n// また両端がつながっているものとする。\nll func( int n, int k)\n{\n#ifdef _DEBUG\n    printf(\"%d %d\\n\", n, k);\n#endif\n    vector<ll> dp(n+1);   // dp[i]: func(i,k)と同じ。ただし両端がつながっていなくてAから始まるものとする。\n    vector<ll> sdp(n+2);  // dpの累積和\n    dp[0]=1;\n    sdp[0]=0; sdp[1]=1;\n    int i;\n    for(i=1; i<=n; i++) {\n        dp[i]=(sdp[i]-sdp[MAX(0,i-k-1)]+MOD)%MOD;\n        sdp[i+1]=(sdp[i]+dp[i])%MOD;\n    }\n    ll ans = dp[n];\n\n    // dp[n]は、Aから始まるものだけを数えたもの。\n    // 両端がつながっている状況で、Bから始まるものを数える\n    // Bが最初にp個重なった場合を考えて足し合わせればよい\n    int p;\n    for(p=1; p<=k; p++) {\n        // dp[n-p-1],dp[n-p-2],..という(k-p+1)個を足し合わせればよい\n        ans = (ans + sdp[n-p] - sdp[n-k-1] +MOD)%MOD;\n    }\n\n    return ans;\n}\n\nint main(int argc, char* argv[])\n{\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    scanf(\"%s\", str);\n\n    char c=str[0];\n    int max_odd=0;\n    int cnt_first=-1;\n    int cnt=0;\n    int cnt2=0;\n    int i;\n    for(i=0; i<m; i++) {\n        if(str[i]==c) {\n            cnt++;\n        }\n        else {\n            if(cnt>0) {\n                if(cnt_first<0) cnt_first=cnt;\n                if(cnt%2) max_odd = MAX(max_odd, cnt);\n                cnt=0;\n            }\n            cnt2++;\n        }        \n    }\n\n    if(cnt2==0) {\n        printf(\"%lld\\n\", func(n, 1));\n    }\n    else {\n        if(n%2==0) {\n            int k = (cnt_first%2==0? cnt_first+1: cnt_first);\n            if(max_odd>0) k = MIN(k, max_odd);\n            printf(\"%lld\\n\", func(n/2, (k-1)/2) *2 %MOD);\n        }\n        else {\n            printf(\"0\\n\");\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)//  cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ld PI = 3.14159265359;\n\nconst ll MOD = (ll) 1e9 + 7;\nconst ll MAXN = (ll) 3e5 + 10;\nconst ll INF = (ll) 2242545357980376863;\nconst ld EPS = (ld) 1e-8;\n\nvector<ll> A;\nll dp[MAXN], sm[MAXN];\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll n, m;\n\tcin >> n >> m;\n\tstr s;\n\tcin >> s;\n\t\n\tif(s[0] == 'B'){\n\t\tfor(int i = 0; i < m;i++){\n\t\t\tif(s[i] == 'R') s[i] = 'B';\n\t\t\telse s[i] = 'R';\n\t\t}\n\t}\n\tll cnt = 1;\n\tfor(int i = 1; i < m; i++){\n\t\tif(s[i] == s[i - 1]) cnt ++;\n\t\telse {\n\t\t\tA.pb(cnt);\n\t\t\tcnt = 1;\n\t\t}\n\t}\n\tA.pb(cnt);\n\tif(A.size() == 1){\n\t\t//debug(\"S\");\n\t\tdp[1] = 1;\n\t\tdp[2] = 0;\n\t\tsm[1] = 1;\n\t\tsm[2] = 1;\n\t\tfor(int i = 3; i <= n; i++){\n\t\t\tdp[i] = sm[i - 2];\n\t\t\tsm[i] = (dp[i] + sm[i - 1]) % MOD;\n\t\t}\n\t\tll ans = 1;\n\t\tfor(int len = 1; len <= n - 1; len ++){\n\t\t\tans += (len + 1ll) * dp[n - len];\n\t\t\tans %= MOD;\n\t\t}\n\t\tcout << ans;\n\t\treturn 0;\n\t\t/////\n\t}\n\t\n\tll mx;\n\t\n\tif(A[0] % 2 == 0 ) mx = A[0] + 1;\n\telse mx = A[0];\n\tfor(int i = 2; i + 2 < A.size(); i += 2){\n\t\tif(A[i] % 2 == 1) mx = max(mx, A[i]);\n\t}\n\tdebug(mx);\n\tdp[0] = 0;\n\tdp[1] = 1;\n\tdp[3] = 1;\n\tfor(int i = 5; i <= n; i++){\n\t\tdp[i] = dp[i - 2] + dp[i - 2];\n\t\tif(i >= mx + 3) dp[i] -= dp[i - mx - 3];\n\t\tdp[i] %= MOD;\n\t}\n\t//debug(dp[1]);\n\t//debug(dp[3]);\n\tll ans = 0;\n\tfor(int len = 1; len <= min(n, mx); len += 2){\n\t\tans += (len + 1ll) * dp[n - len];\n\t\tans %= MOD;\n\t}\n\tcout << ((ans % MOD) + MOD)%MOD;\n\t\n\treturn 0;\n}\n\n\n/*\n\n                                 ____              ,----..               ,----..\n   ,---,                       ,'  , `.           /   /   \\             /   /   \\\n  '  .' \\                   ,-+-,.' _ |          /   .     :           /   .     :\n /  ;    '.              ,-+-. ;   , ||         .   /   ;.  \\         .   /   ;.  \\\n:  :       \\            ,--.'|'   |  ;|        .   ;   /  ` ;        .   ;   /  ` ;\n:  |   /\\   \\          |   |  ,', |  ':        ;   |  ; \\ ; |        ;   |  ; \\ ; |\n|  :  ' ;.   :         |   | /  | |  ||        |   :  | ; | '        |   :  | ; | '\n|  |  ;/  \\   \\        '   | :  | :  |,        .   |  ' ' ' :        .   |  ' ' ' :\n'  :  | \\  \\ ,'        ;   . |  ; |--'         '   ;  \\; /  |        '   ;  \\; /  |\n|  |  '  '--'          |   : |  | ,             \\   \\  ',  /          \\   \\  ',  /\n|  :  :                |   : '  |/               ;   :    /            ;   :    /\n|  | ,'                ;   | |`-'                 \\   \\ .'              \\   \\ .'\n`--''                  |   ;/                      `---`                 `---`\n                       '---'\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \n#define mod 998244353\n\nusing namespace std;\nconst int N=200010;\nint n,m,ans,f[N],g[N];\nchar s[N];\nvoid inc(int&x,int y){x+=y;if(x>=mod)x-=mod;}\nvoid dec(int&x,int y){x-=y;if(x<0)x+=mod;}\n\nint main(){\n//\tfreopen(\"E.in\",\"r\",stdin);\n//\tfreopen(\"E.out\",\"w\",stdout);\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tint p=0;while(p<m&&s[p+1]==s[1])++p;\n\tif(p==m){\n\t\tans=f[0]=g[0]=1;\n\t\tfor(int i=0;i<n-2;++i){\n\t\t\tif(i)f[i]=g[max(i-2,0)];\n\t\t\tif(i)g[i]=(g[i-1]+f[i])%mod;\n\t\t\tinc(ans,(ll)(n-i)*f[i]%mod);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}else{\n\t\tif(n&1)puts(\"0\"),exit(0);\n\t\tint L=p|1;\n\t\twhile(1){\n\t\t\tint tmp=0;\n\t\t\twhile(p<m&&s[p+1]!=s[1])++p;tmp-=p;\n\t\t\twhile(p<m&&s[p+1]==s[1])++p;tmp+=p;\n\t\t\tif(p==m)break;\n\t\t\tif(tmp&1)L=min(L,tmp);\n\t\t}\n\t\tf[0]=g[0]=1;\n\t\tL=(L+1)>>1;n>>=1;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tif(i)f[i]=g[i-1];\n\t\t\tif(i>L)dec(f[i],g[i-L-1]);\n\t\t\tif(i)g[i]=(g[i-1]+f[i])%mod;\n\t\t\tif(n-i<=L)inc(ans,(ll)(n-i)*f[i]%mod);\n\t\t}\n\t\tcout<<ans*2%mod<<endl;\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\nconst int N = 100054, mod = 1000000007;\n\nint n, m, L;\nint f[N];\nchar s[N];\n\ninline void down(int &x, const int y) {x > y ? x = y : 0;}\ninline void add(int &x, const int y) {x += y - mod, x += x >> 31 & mod;}\ninline void sub(int &x, const int y) {x -= y, x += x >> 31 & mod;}\n\nint main() {\n\tint i, j, u, v, ans = 0;\n\tscanf(\"%d%d%s\", &L, &n, s);\n\tfor (i = 0; i < n; ++i) s[i] = s[i] >> 4 & 1;\n\tif (*s) for (i = 0; i < n; ++i) s[i] ^= 1;\n\tfor (j = 0; j < n && !s[j]; ++j);\n\tif (j == n) {\n\t\tfor (u = 2, v = i = 1; i < L; ++i) j = u, u = v, add(v, j);\n\t\treturn printf(\"%d\\n\", v), 0;\n\t}\n\tif (L & 1) return putchar(48), putchar(10), 0;\n\tm = j | 1, L /= 2;\n\tfor (i = j + 1; i < n; ++i) if (s[i]) (i ^ j) & 1 || (down(m, i - j - 1), 0), j = i;\n\tassert(m & 1), m = (m + 1) / 2;\n\tfor (f[1] = *f = i = 1; i < L; ++i)\n\t\tif (add(f[i + 1] = f[i], f[i]), i >= m) sub(f[i + 1], f[i - m]);\n\tfor (i = std::max(L - m, 0); i < L; ++i) ans = (ans + ll(L - i) * f[i]) % mod;\n\tprintf(\"%d\\n\", ans * 2 % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  if(vs==vector<Int>(m,1)){\n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n  \n  Int lim=m;  \n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    Int j=i;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n    \n    if(i==0) chmin(lim,j-i);\n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }\n  \n  //cout<<lim<<endl;\n  if(lim>=n-1){\n    M ans=M(2).pow(n)-M(1);\n    cout<<ans.v<<endl;\n    return 0;\n  }\n  \n  assert(0);  \n  \n  vector<M> dp(n+1,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n;i++){\n    for(Int j=i-2;j>=1&&(i-j-1)<=lim;j-=2){\n      dp[i]+=dp[j];\n    }\n  }\n\n  M ans{0};\n  for(Int i=0;i<n;i++){\n    for(Int j=n-i;j>=n-lim;j--){\n      if(~(i+(n-j))&1) continue;\n      ans+=dp[j];      \n    }\n  }\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1<<18, mod = 1e9 + 7;\nint n, m, pr = 0, dp[maxn], p[maxn][2];\nstring s;\nint corner() {\n\tdp[0] = 2, dp[1] = 1;\n\tfor(int i = 2; i <= n; i++) dp[i] = (dp[i-1] + dp[i-2])%mod;\n\treturn dp[n];\n}\nvoid add(int &a, int b) {\n\ta += b;\n\tif(a >= mod) a -= mod;\n}\nint normal() {\n\tint ans = 0;\n\tfor(int i = 0; i <= n; i++) {\n\t\tif(i) {\n\t\t\tadd(p[i][0], p[i-1][0]);\n\t\t\tadd(p[i][1], p[i-1][1]);\n\t\t}\n\t\tdp[i] = p[i][i&1];\n\t\tif(i == 1) {\n\t\t\tdp[i] = 1;\n\t\t}\n\t\tadd(p[i+2][i&1], dp[i]);\n\t\tadd(p[i+pr+2][i&1], mod - dp[i]);\n\t}\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(i + pr < n || ((i+pr)&1) != (n&1)) continue;\n\t\tans = (ans + (n-i+1)*1ll*dp[i]);\n\t}\n\treturn ans;\n}\nbool check(int msk, int f = 0) {\n\tif((msk&1) && ((msk>>(n-1))&1)) return 0;\n\tif(msk == 0) return 0;\n\tint prev = -1, streak = 0, i = 0;\n\tif(f) while(!(msk&1)) {\n\t\tmsk = (msk/2);}\n\tfor(; i < n; i++) {\n\t\tint cur = (msk>>i)&1;\n\t\tif(prev == cur) streak++;\n\t\telse {\n\t\t\tif(prev == 1 && streak > 1) return 0;\n\t\t\tif(prev == 0 && (streak > pr || (streak&1) == 0)) return 0;\n\t\t\tstreak = 1;\n\t\t}\n\t\t//cout << i << \" \" << cur << \" \" << streak << '\\n';\n\t\tprev = cur;\n\t}\n\tif(prev == 1 && streak > 1) return 0;\n\t\t\tif(prev == 0 && (streak > pr || (streak&1) == 0)) return 0;\n\t\n\treturn true;\n}\nint brute() {\n\tint ans = 0;\n\tfor(int i = 0; i < 1<<n; i++) {\n\t\tans += check(i, 1);\n\t}\n\treturn ans;\n}\nint main() {\n\tcin >> n >> m >> s;\n\tif(s[0] == 'R')\n\t\tfor(auto &i : s) i ^= 'B'^'R';\n\twhile(pr < m && s[pr] == 'B') pr++;\n\tif(m == pr) return cout << corner(), 0;\n\tpr += pr%2 == 0;\n\tint cur = 0;\n\tfor(auto &i : s) {\n\t\tif(i == 'B') cur++;\n\t\telse {\n\t\t\tif(cur&1) pr = min(cur, pr);\n\t\t\tcur = 0;\n\t\t}\n\t}\n\tif(cur&1) pr = min(cur, pr);\n\tcout << normal();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nint const N = 200000, md = 1e9 + 7;\nchar s[N + 1];\nint dp[N + 1], n, m;\n\ninline void ad(int &x, int y) { if ((x += y) >= md)x -= md; }\ninline void sb(int &x, int y) { if ((x -= y) <  0 )x += md; }\ninline void out(int an) { printf(\"%d\\n\", an); exit(0); }\n\nvoid sad(){\n\tdp[0] = 1;\n\tdp[1] = 1;\n\tf(i, 2, n + 1)ad(dp[i] = dp[i - 1], dp[i - 2]);\n\tint an = dp[n];\n\tad(an, dp[n - 1]);\n\tif (n >= 3)sb(an, dp[n - 3]);\n\tout(an);\n}\n\nint main(){\n\tscanf(\"%d%d%s\", &n, &m, s);\n\tint mx = md;\n\tbool im = false;\n\tf(i, 0, m){\n\t\tint j = i;\n\t\twhile (j + 1 < m && s[j + 1] == s[i])++j;\n\t\tif (i == 0 && j + 1 == m)sad();\n\t\tim = !im;\n\t\tif (im){\n\t\t\tint ln = j - i + 1;\n\t\t\tif (ln & 1)mx = min(mx, ln);\n\t\t\telse if (i == 0)mx = min(mx, ln | 1);\n\t\t}\n\t\ti = j;\n\t}\n\tif (n & 1)out(0);\n\tmx = mx + 1 >> 1;\n\tint l = 1, s = 0;\n\tn >>= 1;\n\tf(i, 1, n + 1){\n\t\tif (i - l > mx)sb(s, dp[l++]);\n\t\tdp[i] = s;\n\t\tif (i <= mx)ad(dp[i], i << 1);\n\t\tad(s, dp[i]);\n\t}\n\tprintf(\"%d\\n\", dp[n]);\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-03 17:07:09\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=2000010,mod=1000000007;\ni64 n,m,flag,l,Flag;\ni64 f[N],F[N],ans;\nchar s[N];\nint main()\n{\n\tn=read(); m=read();\n\tscanf(\"%s\",s+1);\n\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\tif(!flag)\n\t{\n\t\tf[0]=1; f[1]=1; f[2]=2;\n\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t\treturn 0;\n\t}\n\tfor(int i=1,j;i<=m;)\n\t\tif(s[i]==s[1])\n\t\t{\n\t\t\tj=i;\n\t\t\twhile(s[j]==s[1]) j++;\n\t\t\tif(j>n) break;\n\t\t\tif(!Flag) l=j-i+((j-i)%2==0);\n\t\t\telse if((j-i)&1) l=std::min(l,(i64)(j-i));\n\t\t\ti=j+1; Flag=1;\n\t\t}\n\t\telse i++;\n\tif(n&1){ printf(\"0\\n\"); return 0; }\n\tn/=2; l=(l+1)/2;\n//\tprintf(\"%d %d\\n\",int(n),int(l));\n\tf[0]=F[0]=1;\n\tfr(i,1,n)\n\t{\n\t\tf[i]=(F[i-1]+mod-(i-l-1>=0?F[i-l-1]:0))%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t}\n\tans=f[n];\n\tfr(i,1,l) ans=(ans+f[n-i]*(2*i-1))%mod;\n\tprintf(\"%d\\n\",int(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#if DEBUG\n// basic debugging macros\nint __i__,__j__;\n#define printLine(l) for(__i__=0;__i__<l;__i__++){cout<<\"-\";}cout<<endl\n#define printLine2(l,c) for(__i__=0;__i__<l;__i__++){cout<<c;}cout<<endl\n#define printVar(n) cout<<#n<<\": \"<<n<<endl\n#define printArr(a,l) cout<<#a<<\": \";for(__i__=0;__i__<l;__i__++){cout<<a[__i__]<<\" \";}cout<<endl\n#define print2dArr(a,r,c) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<a[__i__][__j__]<<\" \";}cout<<endl;}\n#define print2dArr2(a,r,c,l) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<setw(l)<<setfill(' ')<<a[__i__][__j__]<<\" \";}cout<<endl;}\n\n// advanced debugging class\n// debug 1,2,'A',\"test\";\nclass _Debug {\n    public:\n        template<typename T>\n        _Debug& operator,(T val) {\n            cout << val << endl;\n            return *this;\n        }\n};\n#define debug _Debug(),\n#else\n#define printLine(l)\n#define printLine2(l,c)\n#define printVar(n)\n#define printArr(a,l)\n#define print2dArr(a,r,c)\n#define print2dArr2(a,r,c,l)\n#define debug\n#endif\n\n// define\n#define MAX_VAL 999999999\n#define MAX_VAL_2 999999999999999999LL\n#define EPS 1e-6\n#define mp make_pair\n#define pb push_back\n\n// typedef\ntypedef unsigned int UI;\ntypedef long long int LLI;\ntypedef unsigned long long int ULLI;\ntypedef unsigned short int US;\ntypedef pair<int,int> pii;\ntypedef pair<LLI,LLI> plli;\ntypedef vector<int> vi;\ntypedef vector<LLI> vlli;\ntypedef vector<pii> vpii;\ntypedef vector<plli> vplli;\n\n// ---------- END OF TEMPLATE ----------\n#define MOD 1000000007\n\nchar S[200000];\nint fib[200005],dp[200005];\nint main() {\n    int i;\n    int N,M;\n    scanf(\"%d %d\",&N,&M);\n    for (i = 0; i < M; i++) scanf(\" %c\",&S[i]);\n\n    for (i = 0; i < M; i++) {\n        if (S[i] != S[0]) break;\n    }\n    if (i == M) {\n        fib[0] = fib[1] = 1;\n        for (i = 2; i < N+5; i++) fib[i] = (fib[i-1]+fib[i-2]) % MOD;\n        printf(\"%d\\n\",(fib[N-2]+fib[N]) % MOD);\n    }\n    else {\n        if (N & 1) printf(\"0\\n\");\n        else {\n            N /= 2;\n            int B = 1e9,c = 0;\n            for (i = 0; i < M; i++) {\n                if (S[i] == S[0]) c++;\n                else B = min(B,(c & 1) ? c:c+1),c = 0;\n            }\n            B = (B+1)/2;\n            dp[0] = 1;\n            int sum = 1;\n            for (i = 1; i < N+5; i++) {\n                dp[i] = sum;\n                sum += dp[i],sum %= MOD;\n                if (i >= B) sum -= dp[i-B],sum %= MOD;\n            }\n            int ans = dp[N];\n            for (i = 1; i < B; i++) {\n                if (N-i-1 >= 0) {\n                    ans += ((LLI) i*dp[N-i-1]) % MOD;\n                    ans %= MOD;\n                }\n            }\n            ans = (2*ans) % MOD;\n            if (ans < 0) ans += MOD;\n            printf(\"%d\\n\",ans);\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn = 200111;\nint n, m;\nchar s[maxn];\nint fac[maxn], ifac[maxn];\nll C(int x, int y) {return 1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\nll F(int n, int x)\n{\n\treturn C(n-(x-1), x);\n}\nint dp[maxn];\nint sum[maxn], sum2[maxn];\nint calc(int lim)\n{\n//\tcerr<<\"calc:\"<<lim<<endl;\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(sum, 0, sizeof(sum));\n\tmemset(sum2, 0, sizeof(sum2));\n\tdp[0] = 1;\n\tsum[0] = sum[1] = 1;\n\tsum2[0] = 1;\n\tsum2[1] = 0;\n\tfor (int i=2; i<maxn; i++)\n\t{\n\t\tdp[i] = sum2[i-2];\n\t\tif (i-2-lim-1>=0) dp[i] = (dp[i]-sum2[i-2-lim-1]+mod)%mod;\n\t\tsum[i] = (sum[i-1]+dp[i])%mod;\n\t\tsum2[i] = (sum2[i-2]+dp[i])%mod;\n\t}\n\tll ret = lim>=n;\n\tfor (int i=1; i<=lim+1&&i<=n; i++)\n\t{\n\t\tint l = max(i, n-(lim-(i-1)))-i;\n\t\tint r = (i==1?n-1-i:n-i);\n//\t\tcerr<<l<<\",\"<<r<<endl;\n\t\tret = (ret+(sum[r]-(l==0?0:sum[l-1])+mod))%mod;\n\t}\n\treturn ret;\n}\nint solve()\n{\n//\tcerr<<\"solve:\"<<endl;\n\tvector<int> v;\n\tint lst = 0;\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tif (s[i]=='B')\n\t\t{\n\t\t\tv.PB(lst);\n\t\t\tlst = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlst++;\n\t\t}\n\t}\n\tint lim = n;\n\tif (v.size()>0) lim = min(lim, v[0]+(v[0]%2==0));\n\tfor (int i=1; i<v.size(); i++) if (v[i]%2==1) lim = min(lim, v[i]);\n\treturn calc(lim);\n}\nint main()\n{\n\t\n\tfac[0] = 1;\n\tfor (int i=1; i<maxn; i++) fac[i] = 1ll*fac[i-1]*i%mod;\n\tfor (int i=0; i<maxn; i++) ifac[i] = qpow(fac[i], mod-2);\n\tgetii(n, m);\n\tint cntR=0, cntB=0;\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\ts[i] = getreal();\n\t\tcntR += s[i]=='R';\n\t\tcntB += s[i]=='B';\n\t}\n\tif (s[1]=='B') for (int i=1; i<=m; i++) s[i] ^= 'R'^'B';\n\tint ans = 0;\n\tans = (ans+solve())%mod;\n//\tcerr<<\"ans=\"<<ans<<endl;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline tuple<int, int, int> extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nunsigned ModInt::MOD = 1000000007;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\n\n\nconst int limit = 200010;\nmint dp[limit];\nmint csum[limit];\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\n\tint cmin = m, cons = 0;\n\trep(i, m){\n\t\tif(s[i] == s[0]){\n\t\t\tcons++;\n\t\t} else {\n\t\t\tchmin(cmin, cons);\n\t\t}\n\t}\n\n\tif(cmin % 2 == 0) cmin++;\n\tdp[1] = csum[1] = ONE;\n\n\trep(i, 1, n){\n\t\tconst int pos = max(i - cmin - 1, 0);\n\t\tif((i + 1) % 2 == 1) dp[i + 1] =  csum[i] - csum[pos];\n\t\tcsum[i + 1] = csum[i] + dp[i + 1];\n\t}\n\n\tmint ans = ZERO;\n\n\trep(i, max(0, n - cmin), n + 1){\n\t\tconst mint coef = mint(n - i + 1);\n\t\tans += coef * dp[i];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\nint f[200005];\n\nint solve(int n,int up) {\n  int s=0;\n  for(int i=1;i<=n;i++) {\n  \tif (i>up+1) s=(s-f[i-up-1]+MOD)%MOD;\n  \tf[i]=(s+((i<=up)?i:0))%MOD;\n  \ts=(s+f[i])%MOD;\n  }\n  return f[n];\n}\n\nint solve2(int n) {\n  f[1]=1;\n  for(int i=2;i<=n+1;i++) f[i]=(f[i-1]+f[i-2])%MOD;\n  return (f[n+1]+f[n-1])%MOD;\n}\n\nchar str[200005];\n\nint main() {\n  int n,m;\n  scanf(\"%d%d%s\",&n,&m,str+1);\n  if (str[1]=='B') {\n  \tfor(int i=1;i<=m;i++) str[i]=((str[i]=='R')?'B':'R');\n  }\n  bool v=0;\n  for(int i=1;i<=m;i++)\n    if (str[i]=='B') {\n    \tv=1;\n    \tbreak;\n\t}\n  if (!v) {\n  \tprintf(\"%d\\n\",solve2(n));\n  \treturn 0;\n  }\n  if (n&1) {\n  \tputs(\"0\");\n  \treturn 0;\n  }\n  int minn=n,s=0;\n  bool fir=1;\n  for(int i=1;i<=m;i++)\n    if (str[i]=='R') s++;\n    else {\n    \tif (s&&(fir||(s&1))) minn=min(minn,s);\n    \ts=fir=0;\n\t}\n  printf(\"%d\\n\",2*solve(n>>1,(minn>>1)+1)%MOD);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 200005\n#define mo 1000000007\n#define ll long long\nint n,m,L;\nchar s[M];\nll ans,f[M],g[M];\nll dp[M][2];\nvoid work() {\n    L=1e9;\n    char ch=s[1];\n    for(int i=2,l=1;i<=m;i++)\n\t{\n\t    if(s[i]==ch) l++;\n\t    else\n\t\t{\n\t\t    if(l&1) L=min(L,l);\n\t\t    else L=min(L,l+1);\n\t\t    l=0;\n\t\t}\n\t}\n    if(L==1e9)\n\t{\n\t    dp[1][0]=1;\n\t    for(int i=2;i<=n;i++)\n\t\t{\n\t\t    dp[i][0]=(dp[i-1][0]+dp[i-1][1])%mo;\n\t\t    dp[i][1]=dp[i-1][0];\n\t\t}\n\t    ans=(dp[n][1]+dp[n][0])%mo;\n\t    memset(dp,0,sizeof(dp));\n\t    dp[1][1]=1;\n\t    for(int i=2;i<=n;i++)\n\t\t{\n\t\t    dp[i][0]=(dp[i-1][0]+dp[i-1][1])%mo;\n\t\t    dp[i][1]=dp[i-1][0];\n\t\t}\n\t    ans=(ans+dp[n][0])%mo;\n\t    cout<<ans<<'\\n';\n\t}\n    else\n\t{\n\t    f[1]=g[1]=1;\n\t    for(int i=2;i<=n;i++)\n\t\t{\n\t\t    if(i<=L&&(i&1)) f[i]=1;\n\t\t    //for(int j=i-2;j>=i-L-1;j-=2) f[i]=(f[i]+f[j])%mo;\n\t\t    f[i]=(f[i]+g[i-2]-(i-L-3>=0?g[i-L-3]:0)+mo)%mo;\n\t\t    g[i]=(g[i-2]+f[i])%mo;\n\t\t}\n\t    for(int i=3;i<=L+2&&i<=n;i+=2) ans=(ans+f[n-i]*(i-1)%mo)%mo;\n\t    cout<<ans<<'\\n';\n\t}\n}\nint main()\n{\n    cin>>n>>m;\n    scanf(\"%s\",s+1);\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#define N 201000\ntypedef long long ll;\ntemplate <typename T> inline void read(T &x) {\n\tx = 0; char c = getchar(); bool flag = false;\n\twhile (!isdigit(c)) { if (c == '-')\tflag = true; c = getchar(); }\n\twhile (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }\n\tif (flag)\tx = -x;\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nconst int inf = 987654321;\ninline void MIN(int &a, int b) {\n\tif (b < a)\ta = b;\n}\nint n, m;\nchar s[N];\nnamespace jzp1 {\n\tll jie[N], jieni[N];\n\tinline ll get_c(int n, int m) {\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\tif (n < 0 || m < 0 || n - m < 0)\treturn 0;\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\treturn jie[n] * jieni[m] % P * jieni[n - m] % P;\n\t}\n\tinline ll quickpow(ll x, int k) {\n\t\tll res = 1;\n\t\twhile (k) {\n\t\t\tif (k & 1)\tres = res * x % P;\n\t\t\tx = x * x % P;\n\t\t\tk >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline void sol() {\n\t\tif (n == 1) { puts(\"1\"); return ; }\n\t\tjie[0] = jieni[0] = 1;\n\t\tint up = n + 1;\n\t\tfor (int i = 1; i <= up; ++i)\tjie[i] = jie[i - 1] * i % P;\n\t\tjieni[up] = quickpow(jie[up], P - 2);\n\t\tfor (int i = up - 1; i; --i)\tjieni[i] = jieni[i + 1] * (i + 1) % P;\n\t\tll res = 0;\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tres = (res + get_c(n - i + 1, i) - get_c(n - i - 1, i - 2)) % P;\n//\t\t\tprintf(\"res = %lld\\n\", res);\n\t\t}\n\t\tprintf(\"%lld\\n\", (res % P + P) % P);\n\t}\n}\nll f[N];\nll sum[N];\nint main() {\n\tread(n), read(m);\n\tscanf(\"%s\", s + 1);\n\tbool flag = false;\n\tfor (int i = 1; i <= m; ++i)\tif (s[i] != s[1]) { flag = true; break; }\n\tif (!flag) { jzp1::sol(); return 0; }\n\tif (n & 1) { puts(\"0\"); return 0; }\n\tint lst = 1, mn = inf;\n\tfor (int i = 2; i <= m + 1; ++i) {\n\t\tif (s[i] != s[1]) {\n\t\t\tif (lst & 1)\tMIN(mn, lst);\n\t\t\tlst = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == s[i - 1])\t++lst;\n\t\telse {\n\t\t\tif (lst & 1) MIN(mn, lst);\n\t\t\tlst = 1;\n\t\t}\n\t}\n\tif (mn == inf) {\n\t\twhile (1);\n\t\tint memo = 1;\n\t\tfor (int i = 1; s[i] == s[1]; ++i) memo = i;\n\t\tmn = memo + 1;\n\t}\n\tn >>= 1;\n\tint k = (mn + 1) >> 1;\n\tf[0] = 1; sum[0] = 1;\n//\tprintf(\"n = %d, k = %d\\n\", n, k);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (i <= k)\tf[i] = sum[i - 1];\n\t\telse f[i] = (sum[i - 1] - sum[i - k - 1]) % P;\n\t\tsum[i] = (sum[i - 1] + f[i]) % P;\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tans += (f[n - i] * i) % P;\n\t}\n\tans = (ans << 1) % P;\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n\n/*\n3 3\nBBB\n//4\n\n1 1\nB\n//1\n\n12 10\nRRRRBRRRRB\n//78\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\n#define MAX_N 200000\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - inv[MOD % i] * (MOD / i);\n        fac[i] = fac[i-1] * i;\n        finv[i] = finv[i-1] * inv[i];\n    }\n}\n\nmod comb(int a, int b)\n{\n    if(a<b) return 0;\n    return fac[a] * finv[b] * finv[a-b];\n}\ntypedef pair<int, int> Pii;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\nll mod_pow(ll a, ll n, ll mod) { ll ret = 1; ll p = a % mod; while (n) { if (n & 1) ret = ret * p % mod; p = p * p % mod; n >>= 1; } return ret; }\n\ntemplate<int mod, int primitive_root>\nclass NTT {\npublic:\n\tint get_mod() const { return mod; }\n\tvoid _ntt(vector<ll>& a, int sign) {\n\t\tconst int n = sz(a);\n\t\tassert((n ^ (n&-n)) == 0); //n = 2^k\n\n\t\tconst int g = 3; //g is primitive root of mod\n\t\tint h = (int)mod_pow(g, (mod - 1) / n, mod); // h^n = 1\n\t\tif (sign == -1) h = (int)mod_inv(h, mod); //h = h^-1 % mod\n\n\t\t//bit reverse\n\t\tint i = 0;\n\t\tfor (int j = 1; j < n - 1; ++j) {\n\t\t\tfor (int k = n >> 1; k >(i ^= k); k >>= 1);\n\t\t\tif (j < i) swap(a[i], a[j]);\n\t\t}\n\n\t\tfor (int m = 1; m < n; m *= 2) {\n\t\t\tconst int m2 = 2 * m;\n\t\t\tconst ll base = mod_pow(h, n / m2, mod);\n\t\t\tll w = 1;\n\t\t\tFOR(x, m) {\n\t\t\t\tfor (int s = x; s < n; s += m2) {\n\t\t\t\t\tll u = a[s];\n\t\t\t\t\tll d = a[s + m] * w % mod;\n\t\t\t\t\ta[s] = u + d;\n\t\t\t\t\tif (a[s] >= mod) a[s] -= mod;\n\t\t\t\t\ta[s + m] = u - d;\n\t\t\t\t\tif (a[s + m] < 0) a[s + m] += mod;\n\t\t\t\t}\n\t\t\t\tw = w * base % mod;\n\t\t\t}\n\t\t}\n\n\t\tfor (auto& x : a) if (x < 0) x += mod;\n\t}\n\tvoid ntt(vector<ll>& input) {\n\t\t_ntt(input, 1);\n\t}\n\tvoid intt(vector<ll>& input) {\n\t\t_ntt(input, -1);\n\t\tconst int n_inv = mod_inv(sz(input), mod);\n\t\tfor (auto& x : input) x = x * n_inv % mod;\n\t}\n\n\t// 畳み込み演算を行う\n\tvector<ll> convolution(const vector<ll>& a, const vector<ll>& b){\n\t\tint ntt_size = 1;\n\t\twhile (ntt_size < sz(a) + sz(b)) ntt_size *= 2;\n\n\t\tvector<ll> _a = a, _b = b;\n\t\t_a.resize(ntt_size); _b.resize(ntt_size);\n\n\t\tntt(_a);\n\t\tntt(_b);\n\n\t\tFOR(i, ntt_size){\n\t\t\t(_a[i] *= _b[i]) %= mod;\n\t\t}\n\n\t\tintt(_a);\n\t\treturn _a;\n\t}\n};\n\nll garner(vector<Pii> mr, int mod){\n\tmr.emplace_back(mod, 0);\n\n\tvector<ll> coffs(sz(mr), 1);\n\tvector<ll> constants(sz(mr), 0);\n\tFOR(i, sz(mr) - 1){\n\t\t// coffs[i] * v + constants[i] == mr[i].second (mod mr[i].first) を解く\n\t\tll v = (mr[i].second - constants[i]) * mod_inv<ll>(coffs[i], mr[i].first) % mr[i].first;\n\t\tif (v < 0) v += mr[i].first;\n\n\t\tfor (int j = i + 1; j < sz(mr); j++) {\n\t\t\t(constants[j] += coffs[j] * v) %= mr[j].first;\n\t\t\t(coffs[j] *= mr[i].first) %= mr[j].first;\n\t\t}\n\t}\n\n\treturn constants[sz(mr) - 1];\n}\n\ntypedef NTT<167772161, 3> NTT_1;\ntypedef NTT<469762049, 3> NTT_2;\ntypedef NTT<1224736769, 3> NTT_3;\n\n//任意のmodで畳み込み演算 O(n log n)\nvector<ll> int32mod_convolution(vector<ll> a, vector<ll> b,int mod){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\tvector<ll> ret(sz(x));\n\tvector<Pii> mr(3);\n\tFOR(i, sz(x)){\n\t\tmr[0].first = ntt1.get_mod(), mr[0].second = (int)x[i];\n\t\tmr[1].first = ntt2.get_mod(), mr[1].second = (int)y[i];\n\t\tmr[2].first = ntt3.get_mod(), mr[2].second = (int)z[i];\n\t\tret[i] = garner(mr, mod);\n\t}\n\n\treturn ret;\n}\n\n// garnerのアルゴリズムを直書きしたversion，速い\nvector<ll> fast_int32mod_convolution(vector<ll> a, vector<ll> b,int mod,int len){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\t\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tassert(ntt1.get_mod() < ntt2.get_mod() && ntt2.get_mod() < ntt3.get_mod());\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\t// garnerのアルゴリズムを極力高速化した\n\tconst ll m1 = ntt1.get_mod(), m2 = ntt2.get_mod(), m3 = ntt3.get_mod();\n\tconst ll m1_inv_m2 = mod_inv<ll>(m1, m2);\n\tconst ll m12_inv_m3 = mod_inv<ll>(m1 * m2, m3);\n\tconst ll m12_mod = m1 * m2 % mod;\n\tint L = min(len,sz(x));\n    vector<ll> ret(L);\n\tFOR(i, L){\n\t\tll v1 = (y[i] - x[i]) *  m1_inv_m2 % m2;\n\t\tif (v1 < 0) v1 += m2;\n\t\tll v2 = (z[i] - (x[i] + m1 * v1) % m3) * m12_inv_m3 % m3;\n\t\tif (v2 < 0) v2 += m3;\n\t\tll constants3 = (x[i] + m1 * v1 + m12_mod * v2) % mod;\n\t\tif (constants3 < 0) constants3 += mod;\n\t\tret[i] = constants3;\n\t}\n\n\treturn ret;\n}\n\n\nunsigned int add(const unsigned int x, const unsigned int y)\n{\n    return (x + y < MOD) ? x + y : x + y - MOD;\n}\n \nunsigned int sub(const unsigned int x, const unsigned int y)\n{\n    return (x >= y) ? (x - y) : (MOD - y + x);\n}\n \nunsigned int mul(const unsigned int x, const unsigned int y)\n{\n    return (unsigned long long)x * y % MOD;\n}\n \nunsigned int mod_pow(unsigned int x, unsigned int n)\n{\n    unsigned int res = 1;\n    while(n > 0){\n        if(n & 1){ res = mul(res, x); }\n        x = mul(x, x);\n        n >>= 1;\n    }\n    return res;\n}\n \nunsigned int inverse(const unsigned int x)\n{\n    return mod_pow(x, MOD - 2);\n}\n \nvector<ll> polynomial_inverse(const vector<ll>& a, int r)\n{\n    assert(a[0] != 0);\n    vector<ll> h = {(ll)inverse(a[0])};\n    int t = 1;\n    vector<ll> b;\n    int id =  0;\n    for(int i = 0; t < r; ++i){\n    \n        t <<= 1;\n        while(id<min((int)a.size(),t)){\n            b.push_back(a[id]);\n            id++;\n        }\n        vector<ll> res = fast_int32mod_convolution(b, fast_int32mod_convolution(h, h, MOD,t), MOD,t);\n        res.resize(t);\n        for(int j = 0; j < t; ++j){\n            res[j] = sub(0, res[j]);\n            if(j < t / 2) res[j] = add(res[j], mul(2, h[j]));\n        }\n        swap(h, res);\n    }\n    h.resize(r);\n    return h;\n}\n\nmod dp[200010][2][2];\nint main(){\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if(s[0]=='R'){\n        rep(i,m){\n            if(s[i]=='R'){\n                s[i] ='B';\n            }else{\n                s[i] ='R'; \n            }\n        }\n    }\n    int a = inf;\n    int c = 0;\n    bool flag = 1;\n    rep(i,m){\n        if(s[i]=='B'){\n            c++;\n        }else{\n            if(flag){\n                chmin(a,c);\n            }else if(c%2==1){\n                chmin(a,c); \n            }\n            c = 0;   \n        }\n    }\n    if(a==inf){\n        dp[0][0][0] = 1;\n        dp[0][1][1] = 1;\n        for(int i=1;i<n;i++){\n            for(int j=0;j<2;j++){\n                if(j==0){\n                    dp[i][j][0] += dp[i-1][1][0];\n                    dp[i][j][1] += dp[i-1][1][1];\n                }else{\n                    dp[i][j][0] += dp[i-1][1][0] + dp[i-1][0][0];\n                    dp[i][j][1] += dp[i-1][1][1] + dp[i-1][0][1];    \n                }\n            }\n        }\n        cout << dp[n-1][1][0] + dp[n-1][1][1] + dp[n-1][1][0] << endl;\n    }else{\n        int len = (a/2)*2+1;\n        //cerr << len << endl;\n        vector<ll> X(n+1),Y(n+1);\n        len++;\n        len = min(n,len);\n        for(int i=2;i<=len;i+=2){\n            X[i] = i;\n        }\n        Y[0] = 1;\n        for(int i=2;i<=len;i+=2){\n            Y[i] = MOD-1;\n        }\n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        Y =polynomial_inverse(Y,n+1);\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        X = fast_int32mod_convolution(X,Y,MOD,n+1);\n        \n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        cout << X[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  if(vs==vector<Int>(m,1)){\n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n\n  if(n&1){\n    cout<<0<<endl;\n    return 0;\n  }\n  \n  Int lim=n;  \n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    Int j=i;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n    \n    if(i==0) chmin(lim,(j-i)+(~(j-i)&1));    \n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }  \n  \n  vector<M> dp(n+2,0),sm(n+2,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n+1;i++){\n    sm[i]=sm[i-1]+dp[i-1];\n    if(i&1) dp[i]=sm[i-1]-sm[max<Int>(1,i-1-lim)];\n  }\n  \n  M ans{0};\n  for(Int i=0;i<n;i++)\n    if(n-i+1>=max<Int>(1,n-lim))\n      ans+=sm[n-i+1]-sm[max<Int>(1,n-lim)];\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n//#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MaxN = 2e5 + 100;\nconst int Mod = 1e9 + 7;\n\nint dp[MaxN];\nint pref_dp[MaxN];\n\nint small_dp[MaxN][2][2];\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N, M;\n  string s;\n  cin >> N >> M >> s;\n\n  if (count(ALL(s), s[0]) == M) {\n    small_dp[1][1][1] = small_dp[1][0][0] = 1;\n    for (int len = 2; len <= N; ++len) {\n      for (int fst : {0, 1}) {\n        // add gut\n        small_dp[len][fst][0] =\n          (small_dp[len - 1][fst][0] + small_dp[len - 1][fst][1]) % Mod;\n        // add no gut\n        small_dp[len][fst][1] = small_dp[len - 1][fst][0];\n      }\n    }\n\n    int ans = 0;\n    for (int x : {0, 1}) {\n      for (int y : {0, 1}) {\n        if (x + y <= 1) {\n          ans = (ans + small_dp[N][x][y]) % Mod;\n        }\n      }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n  }\n\n  if (s[0] != s[1]) {\n    if (N % 2 == 0) {\n      cout << \"2\\n\";\n    } else {\n      cout << \"0\\n\";\n    }\n    return 0;\n  }\n\n  int min_seg_len = N - 1;\n  int cur_len = 0;\n  while (s[cur_len] == s[0]) { ++cur_len; }\n  min_seg_len = cur_len;\n  cur_len = 0;\n  for (char ch : s) {\n    if (ch == s[0]) {\n      ++cur_len;\n    } else {\n      if (cur_len % 2 == 1) { mini(min_seg_len, cur_len); }\n      cur_len = 0;\n    }\n  }\n  //if (cur_len) { mini(min_seg_len, cur_len); }\n\n\n  int answer = 0;\n\n  dp[0] = pref_dp[2] = 1;\n\n  const int min_jump = 2;\n  int max_jump = min_seg_len + 2;\n  // jump must be even as well\n  if (max_jump % 2 == 1) { --max_jump; }\n\n  debug(min_jump, max_jump);\n\n  for (int len = 1; len <= N; ++len) {\n    const int add_from = max(0, len - max_jump);\n    const int add_to = len - min_jump;\n\n    if (add_from <= add_to) {\n      dp[len] = pref_dp[add_to + 2] - pref_dp[add_from];\n      if (dp[len] < 0) { dp[len] += Mod; }\n    }\n\n    debug(len, dp[len]);\n\n    pref_dp[len + 2] = (pref_dp[len] + dp[len]) % Mod;\n  }\n\n  for (int chain_len = 0; chain_len < N; ++chain_len) {\n    const int rem_len = N - chain_len;\n    if (2 <= rem_len && rem_len <= max_jump && rem_len % 2 == 0) {\n      const int coef = dp[chain_len];\n      answer = (answer + (LL)coef * (rem_len )) % Mod;\n    }\n  }\n\n  cout << answer << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=1000005,mod=1e9+7;\nint n,m,lim;\nchar s[N];\n\nvoid special(int n){\n\tstatic int f[N],s[N];\n\ts[1]=s[0]=f[0]=1;\n\trep(i,2,n){\n\t\tf[i]=s[i-2];\n\t\ts[i]=(s[i-1]+f[i])%mod;\n\t}\n\tint ans=1;\n\trep(i,2,n)\n\t\tans=(ans+(ll)i*f[n-i])%mod;\n\tcout<<ans<<endl;\n}\n\nvoid solve(int n,int k){\n\tstatic int f[N],s[N];\n\ts[0]=f[0]=1;\n\tfor(int i=2;i<=n;i+=2){\n\t\tf[i]=(s[i-2]+(i>=k+3?mod-s[i-k-3]:0))%mod;\n\t\ts[i]=(s[i-2]+f[i])%mod;\n\t}\n\tint ans=0;\n\tfor(int i=2;i<=k+1;i+=2)\n\t\tans=(ans+(ll)i*f[n-i])%mod;\n\tcout<<ans<<endl;\n}\n\nint main(){\n\tread(n),read(m);\n\tscanf(\"%s\",s+1);\n\tlim=n-1;\n\tfor(int l=1,r;l<=m;l++)\n\t\tif(s[l]==s[1]){\n\t\t\tr=l;\n\t\t\twhile(r<m&&s[r+1]==s[l])\n\t\t\t\tr++;\n\t\t\tif(l==1&&r==m){\n\t\t\t\tspecial(n);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(l==1){\n\t\t\t\tif(r%2==0) lim=min(lim,r+1);\n\t\t\t\telse lim=min(lim,r);\n\t\t\t}\n\t\t\telse if(r!=m&&(r-l)%2==0){\n\t\t\t\tlim=min(lim,r-l+1);\n\t\t\t}\n\t\t\tl=r;\n\t\t}\n\tsolve(n,lim);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nchar s[262144];\nint dp[262144];\nint pre[262144];\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s);\n\tbool fir=true;\n\tint num=0;\n\tint mx=n;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tif(s[i]==s[0])\n\t\t{\n\t\t\tnum++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(fir||(num&1))\n\t\t\t{\n\t\t\t\tif(num<mx)\n\t\t\t\t{\n\t\t\t\t\tmx=num;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfir=false;\n\t\t\tnum=0;\n\t\t}\n\t}\n\tif(fir)\n\t{\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tdp[i]=i;\n\t\t\tdp[i]+=pre[i-2];\n\t\t\tif(dp[i]>=1000000007)\n\t\t\t{\n\t\t\t\tdp[i]-=1000000007;\n\t\t\t}\n\t\t\tpre[i]=pre[i-1]+dp[i];\n\t\t\tif(pre[i]>=1000000007)\n\t\t\t{\n\t\t\t\tpre[i]-=1000000007;\n\t\t\t}\n\t\t}\n\t\tint ans=dp[n]+1;\n\t\tif(ans>=1000000007)\n\t\t{\n\t\t\tans-=1000000007;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(n&1)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tif(!(mx&1))\n\t{\n\t\tmx++;\n\t}\n\tmx++;\n\tn>>=1;\n\tmx>>=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tdp[i]=pre[i-1];\n\t\tif(i<=mx)\n\t\t{\n\t\t\tdp[i]+=(i<<1);\n\t\t\tif(dp[i]>=1000000007)\n\t\t\t{\n\t\t\t\tdp[i]-=1000000007;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdp[i]-=pre[i-mx-1];\n\t\t\tif(dp[i]<0)\n\t\t\t{\n\t\t\t\tdp[i]+=1000000007;\n\t\t\t}\n\t\t}\n\t\tpre[i]=pre[i-1]+dp[i];\n\t\tif(pre[i]>=1000000007)\n\t\t{\n\t\t\tpre[i]-=1000000007;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\n#define MAX_N 200000\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - inv[MOD % i] * (MOD / i);\n        fac[i] = fac[i-1] * i;\n        finv[i] = finv[i-1] * inv[i];\n    }\n}\n\nmod comb(int a, int b)\n{\n    if(a<b) return 0;\n    return fac[a] * finv[b] * finv[a-b];\n}\ntypedef pair<int, int> Pii;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\nll mod_pow(ll a, ll n, ll mod) { ll ret = 1; ll p = a % mod; while (n) { if (n & 1) ret = ret * p % mod; p = p * p % mod; n >>= 1; } return ret; }\n\ntemplate<int mod, int primitive_root>\nclass NTT {\npublic:\n\tint get_mod() const { return mod; }\n\tvoid _ntt(vector<ll>& a, int sign) {\n\t\tconst int n = sz(a);\n\t\tassert((n ^ (n&-n)) == 0); //n = 2^k\n\n\t\tconst int g = 3; //g is primitive root of mod\n\t\tint h = (int)mod_pow(g, (mod - 1) / n, mod); // h^n = 1\n\t\tif (sign == -1) h = (int)mod_inv(h, mod); //h = h^-1 % mod\n\n\t\t//bit reverse\n\t\tint i = 0;\n\t\tfor (int j = 1; j < n - 1; ++j) {\n\t\t\tfor (int k = n >> 1; k >(i ^= k); k >>= 1);\n\t\t\tif (j < i) swap(a[i], a[j]);\n\t\t}\n\n\t\tfor (int m = 1; m < n; m *= 2) {\n\t\t\tconst int m2 = 2 * m;\n\t\t\tconst ll base = mod_pow(h, n / m2, mod);\n\t\t\tll w = 1;\n\t\t\tFOR(x, m) {\n\t\t\t\tfor (int s = x; s < n; s += m2) {\n\t\t\t\t\tll u = a[s];\n\t\t\t\t\tll d = a[s + m] * w % mod;\n\t\t\t\t\ta[s] = u + d;\n\t\t\t\t\tif (a[s] >= mod) a[s] -= mod;\n\t\t\t\t\ta[s + m] = u - d;\n\t\t\t\t\tif (a[s + m] < 0) a[s + m] += mod;\n\t\t\t\t}\n\t\t\t\tw = w * base % mod;\n\t\t\t}\n\t\t}\n\n\t\tfor (auto& x : a) if (x < 0) x += mod;\n\t}\n\tvoid ntt(vector<ll>& input) {\n\t\t_ntt(input, 1);\n\t}\n\tvoid intt(vector<ll>& input) {\n\t\t_ntt(input, -1);\n\t\tconst int n_inv = mod_inv(sz(input), mod);\n\t\tfor (auto& x : input) x = x * n_inv % mod;\n\t}\n\n\t// 畳み込み演算を行う\n\tvector<ll> convolution(const vector<ll>& a, const vector<ll>& b){\n\t\tint ntt_size = 1;\n\t\twhile (ntt_size < sz(a) + sz(b)) ntt_size *= 2;\n\n\t\tvector<ll> _a = a, _b = b;\n\t\t_a.resize(ntt_size); _b.resize(ntt_size);\n\n\t\tntt(_a);\n\t\tntt(_b);\n\n\t\tFOR(i, ntt_size){\n\t\t\t(_a[i] *= _b[i]) %= mod;\n\t\t}\n\n\t\tintt(_a);\n\t\treturn _a;\n\t}\n};\n\nll garner(vector<Pii> mr, int mod){\n\tmr.emplace_back(mod, 0);\n\n\tvector<ll> coffs(sz(mr), 1);\n\tvector<ll> constants(sz(mr), 0);\n\tFOR(i, sz(mr) - 1){\n\t\t// coffs[i] * v + constants[i] == mr[i].second (mod mr[i].first) を解く\n\t\tll v = (mr[i].second - constants[i]) * mod_inv<ll>(coffs[i], mr[i].first) % mr[i].first;\n\t\tif (v < 0) v += mr[i].first;\n\n\t\tfor (int j = i + 1; j < sz(mr); j++) {\n\t\t\t(constants[j] += coffs[j] * v) %= mr[j].first;\n\t\t\t(coffs[j] *= mr[i].first) %= mr[j].first;\n\t\t}\n\t}\n\n\treturn constants[sz(mr) - 1];\n}\n\ntypedef NTT<167772161, 3> NTT_1;\ntypedef NTT<469762049, 3> NTT_2;\ntypedef NTT<1224736769, 3> NTT_3;\n\n//任意のmodで畳み込み演算 O(n log n)\nvector<ll> int32mod_convolution(vector<ll> a, vector<ll> b,int mod){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\tvector<ll> ret(sz(x));\n\tvector<Pii> mr(3);\n\tFOR(i, sz(x)){\n\t\tmr[0].first = ntt1.get_mod(), mr[0].second = (int)x[i];\n\t\tmr[1].first = ntt2.get_mod(), mr[1].second = (int)y[i];\n\t\tmr[2].first = ntt3.get_mod(), mr[2].second = (int)z[i];\n\t\tret[i] = garner(mr, mod);\n\t}\n\n\treturn ret;\n}\n\n// garnerのアルゴリズムを直書きしたversion，速い\nvector<ll> fast_int32mod_convolution(vector<ll> a, vector<ll> b,int mod){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\t\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tassert(ntt1.get_mod() < ntt2.get_mod() && ntt2.get_mod() < ntt3.get_mod());\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\t// garnerのアルゴリズムを極力高速化した\n\tconst ll m1 = ntt1.get_mod(), m2 = ntt2.get_mod(), m3 = ntt3.get_mod();\n\tconst ll m1_inv_m2 = mod_inv<ll>(m1, m2);\n\tconst ll m12_inv_m3 = mod_inv<ll>(m1 * m2, m3);\n\tconst ll m12_mod = m1 * m2 % mod;\n\tvector<ll> ret(sz(x));\n\tFOR(i, sz(x)){\n\t\tll v1 = (y[i] - x[i]) *  m1_inv_m2 % m2;\n\t\tif (v1 < 0) v1 += m2;\n\t\tll v2 = (z[i] - (x[i] + m1 * v1) % m3) * m12_inv_m3 % m3;\n\t\tif (v2 < 0) v2 += m3;\n\t\tll constants3 = (x[i] + m1 * v1 + m12_mod * v2) % mod;\n\t\tif (constants3 < 0) constants3 += mod;\n\t\tret[i] = constants3;\n\t}\n\n\treturn ret;\n}\n\n\nunsigned int add(const unsigned int x, const unsigned int y)\n{\n    return (x + y < MOD) ? x + y : x + y - MOD;\n}\n \nunsigned int sub(const unsigned int x, const unsigned int y)\n{\n    return (x >= y) ? (x - y) : (MOD - y + x);\n}\n \nunsigned int mul(const unsigned int x, const unsigned int y)\n{\n    return (unsigned long long)x * y % MOD;\n}\n \nunsigned int mod_pow(unsigned int x, unsigned int n)\n{\n    unsigned int res = 1;\n    while(n > 0){\n        if(n & 1){ res = mul(res, x); }\n        x = mul(x, x);\n        n >>= 1;\n    }\n    return res;\n}\n \nunsigned int inverse(const unsigned int x)\n{\n    return mod_pow(x, MOD - 2);\n}\n \nvector<ll> polynomial_inverse(const vector<ll>& a, int r)\n{\n    assert(a[0] != 0);\n    vector<ll> h = {(ll)inverse(a[0])};\n    int t = 1;\n    for(int i = 0; t < r; ++i){\n        t <<= 1;\n        // vector<ll> tmp = int32mod_convolution(h, h, MOD);\n        vector<ll> res = int32mod_convolution(a, int32mod_convolution(h, h, MOD), MOD);\n        res.resize(t);\n        for(int j = 0; j < t; ++j){\n            res[j] = sub(0, res[j]);\n            if(j < t / 2) res[j] = add(res[j], mul(2, h[j]));\n        }\n        swap(h, res);\n    }\n    h.resize(r);\n    return h;\n}\n\nmod dp[200010][2][2];\nint main(){\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if(s[0]=='R'){\n        rep(i,m){\n            if(s[i]=='R'){\n                s[i] ='B';\n            }else{\n                s[i] ='R'; \n            }\n        }\n    }\n    int a = inf;\n    int c = 0;\n    rep(i,m){\n        if(s[i]=='B'){\n            c++;\n        }else{\n            chmin(a,c);    \n        }\n    }\n    if(a==inf){\n        dp[0][0][0] = 1;\n        dp[0][1][1] = 1;\n        for(int i=1;i<n;i++){\n            for(int j=0;j<2;j++){\n                if(j==0){\n                    dp[i][j][0] += dp[i-1][1][0];\n                    dp[i][j][1] += dp[i-1][1][1];\n                }else{\n                    dp[i][j][0] += dp[i-1][1][0] + dp[i-1][0][0];\n                    dp[i][j][1] += dp[i-1][1][1] + dp[i-1][0][1];    \n                }\n            }\n        }\n        cout << dp[n-1][1][0] + dp[n-1][1][1] + dp[n-1][1][0] << endl;\n    }else{\n        int len = (a/2)*2+1;\n        cerr << len << endl;\n        vector<ll> X(n+1),Y(n+1);\n        len++;\n        for(int i=2;i<=len;i+=2){\n            X[i] = i;\n        }\n        Y[0] = 1;\n        for(int i=2;i<=len;i+=2){\n            Y[i] = MOD-1;\n        }\n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        Y =polynomial_inverse(Y,n+1);\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        X = int32mod_convolution(X,Y,MOD);\n        \n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        cout << X[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PI 3.14159265358979323846264338327950288419\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint n, m;\nint col[200005];\n\nint calc(int n){\n\tint fib[200005];\n\tfib[1] = fib[2] = 1;\n\tfor(int i = 3; i <= n + 1; i++){\n\t\tfib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t}\n\t\n\t// force first one to be 1, last one to be 0: fib[n - 1]\n\t// force first one to be 0: fib[n + 1]\n\treturn (fib[n - 1] + fib[n + 1]) % mod;\n}\n\nint calc2(int n, int ub){\n\tassert(ub & 1);\n\t\n\t// want a bunch of numbers, in [2, ub], to sum to n\n\t\n\tub++;\n\tub = min(ub, n); // coz it can actually be HUGE\n\t\n\tint dp[200005]; // dp[i]: number of possible sums, that sum to i\n\tint cumu[200005];\n\t\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(cumu, 0, sizeof(cumu));\n\tdp[0] = 1;\n\tcumu[0] = 1;\n\t\n\tfor(int i = 2; i <= n; i += 2){\n\t\t// sum dp[l_index .. i - 2].. oh, only the even ones!\n\t\tint l_index = i - ub;\n\t//\tprintf(\"%d: sum %d..%d\\n\", i, l_index, r_index);\n\t\tdp[i] = cumu[i - 2];\n\t\t\n\t\tif(l_index > 0){\n\t\t\tdp[i] -= cumu[l_index - 2];\n\t\t\tif(dp[i] < 0){\n\t\t\t\tdp[i] += mod;\n\t\t\t}\n\t\t}\n//\t\tprintf(\"%d: %d\\n\", i, dp[i]);\n\t\tcumu[i] = (cumu[i - 2] + dp[i]) % mod;\n\t}\n\t\n\tint ret = 0;\n\t\n\tfor(int space = 0; space < ub; space++){\n\t\t// last 1 is at (n - space), leaving _ space at the end\n\t\t// where can the first 1 be?\n\t\tint left_pos = 1;\n\t\tint right_pos = ub - space;\n\t\t\n\t\tint most_remain = (n - space) - 1;\n\t\tint least_remain = n - ub;\n\t\t\n\t\tif(most_remain & 1) most_remain--;\n\t\t\n\t\tint combin = cumu[most_remain];\n\t\tif(least_remain > 0){\n\t\t\tcombin = (combin - cumu[least_remain - 2] + mod) % mod;\n\t\t}\n\t\tret = (ret + combin) % mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= m; i++){\n\t\tchar c;\n\t\tscanf(\" %c\", &c);\n\t\tcol[i] = (c == 'B');\n\t}\n\t\n\tif(col[1] != 0){\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tcol[i] = 1 - col[i];\n\t\t}\n\t}\n\t\n\t// WLOG first one is 0\n\tbool monochrome = true;\n\tfor(int i = 2; i <= m; i++){\n\t\tif(col[i]){\n\t\t\tmonochrome = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(monochrome){\n\t\t// ok as long as 1s are not adjacent\n\t\tprintf(\"%d\\n\", calc(n));\n\t\treturn 0;\n\t}else{\n\t\t// 00...010..010..0\n\t\t// each block of 0 is of add length\n\t\t// so, n odd -> definitely no solution\n\t\t// more conditions depending on specifics of col[]\n\t\tif(n % 2 == 1){\n\t\t\tassert(false);\n\t\t \tprintf(\"0\\n\");\n\t\t \treturn 0;\n\t\t}\n\t\tint first_run = 0, subseq_run = n - 1;\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tint len = 0;\n\t\t\twhile(i + len <= m && col[i + len] == 0){\n\t\t \t\tlen++;\n\t\t \t}\n\t\t \tif(first_run == 0){\n\t\t \t\tfirst_run = len;\n\t\t \t}else if(len & 1){\n\t\t \t\tsubseq_run = min(subseq_run, len);\n\t\t \t}\n\t\t \ti += len;\n\t\t}\n\t\tint ub = first_run + (first_run % 2 == 0);\n\t\tub = min(ub, subseq_run);\n\t\tprintf(\"%d\\n\", calc2(n, ub));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n \n#include <algorithm>\n#include <tuple>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n \n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n \ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 200010, P = 1000000007;\n\nint n, m;\nchar s[N];\n\nvoid add(int& x, int y) {\n  if ((x += y) >= P)\n    x -= P;\n}\n\nvoid sub(int& x, int y) {\n  if ((x -= y) < 0)\n    x += P;\n}\n\nint norm(int x) {\n  return x >= P ? x - P : x;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n >> m >> (s + 1);\n  char a = s[1];\n  if (count(s + 1, s + m + 1, a) == m) {\n    static int dp[N][2][2];\n    dp[1][0][0] = dp[1][1][1] = 1;\n    for (int i = 2; i <= n; ++i)\n      for (int j = 0; j < 2; ++j) {\n        add(dp[i][j][0], dp[i - 1][j][0]);\n        add(dp[i][j][0], dp[i - 1][j][1]);\n        add(dp[i][j][1], dp[i - 1][j][0]);\n      }\n    int ans = norm(norm(dp[n][0][0] + dp[n][0][1]) + dp[n][1][0]);\n    cout << ans << '\\n';\n    return 0;\n  }\n  int len = m;\n  int p = 1;\n  while (s[p] == a) ++p;\n  len = p - 1;\n  if (len % 2 == 0) ++len;\n  int cur = 0;\n  for (; p <= m; ++p)\n    if (s[p] != a) {\n      if (cur & 1)\n        len = min(len, cur);\n      cur = 0;\n    } else\n      ++cur;\n  static int dp[N], sum[N];\n  dp[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    sum[i - 1] = dp[i - 1];\n    if (i - 3 >= 0)\n      add(sum[i - 1], sum[i - 3]);\n    dp[i] = sum[i - 2];\n    if (i - len - 3 > 0)\n      sub(dp[i], sum[i - len - 3]);\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; ++i)\n    if ((n - i) <= len && ((n - i) & 1))\n      ans = ans + (dp[i] * (n - i + 1LL)) % P;\n  cout << ans << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll modminus(ll x, ll y) {\n    return (x - y + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll modpower(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y == 1) {\n        return x % mod;\n    } else if (y % 2 == 0) {\n        ll p = modpower(x, y / 2);\n        return p * p % mod;\n    } else {\n        ll p = modpower (x, y / 2);\n        return (p * p) % mod * (x % mod) % mod;\n    }\n}\n\nll divide(ll x, ll y) {\n    return multiply(x, modpower(y, mod - 2));\n}\n\nll frac[1000000];\nll invfrac[1000000];\n\nvoid fracinvfrac(ll n) {\n    frac[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        frac[i] = multiply(frac[i - 1], i);\n    }\n    invfrac[n] = divide(1, frac[n]);\n    for (int i = n - 1; i >= 0; i--) {\n        invfrac[i] = multiply(invfrac[i + 1], i + 1);\n    }\n}\n\nll modcombi(ll x, ll y) {\n    if (x < y || y < 0) {\n        return 0;\n    } else if (y == 0) {\n        return 1;\n    } else {\n        return multiply(multiply(frac[x], invfrac[x - y]), invfrac[y]);\n    }\n}\n\nll N, M;\nll dp[200010][2];\n\nll solve(ll num) {\n    dp[0][0] = 1;\n    REP(i, 0, num) {\n        dp[i + 1][0] = modadd(dp[i + 1][0], dp[i][0]);\n        dp[i + 1][0] = modadd(dp[i + 1][0], dp[i][1]);\n        dp[i + 1][1] = modadd(dp[i + 1][1], dp[i][0]);\n    }\n    return (dp[num - 1][0] + dp[num - 1][1] + dp[num - 2][0]) % mod;\n}\n\nll dpb[200010][2];\n\nll solveb(ll num, ll len) {\n    // cout << num << \" \" << len << endl;\n    ll p = num / 2;\n    ll q = len / 2;\n    dpb[0][0] = 1;\n    dpb[0][1] = 1;\n    // ll sum = 0;\n    REP(i, 0, p) {\n        dpb[i + 1][0] = modadd(dpb[i + 1][0], dpb[i][1]);\n        if (i - (q + 1) >= 0) {\n            dpb[i + 1][0] = modminus(dpb[i + 1][0], dpb[i - (q + 1)][1]);\n        }\n        // dpb[i + 1][0] = modadd(dpb[i + 1][0], dpb[i][1]);\n        dpb[i + 1][1] = modadd(modadd(dpb[i + 1][1], dpb[i + 1][0]), dpb[i][1]);\n        // sum = modadd(sum, dpb[i + 1][1]);\n        // if (i >= q) {\n        //     sum = modminus(sum, dpb[i + 1 - q][0]);\n        // }\n        // if (i == 0) {\n        //     sum--;\n        // }\n    }\n    // dpb[0][0] = 1;\n    // dpb[0][1] = 1;\n    // REP(i, 0, num) {\n    //     dpb[i + 1][0] = modadd(dpb[i + 1][0], dpb[i][0]);\n    //     dpb[i + 1][0] = modadd(dpb[i + 1][0], dpb[i][1]);\n    //     dpb[i + 1][1] = modadd(dpb[i + 1][1], dpb[i][0]);\n    // }\n    // dp[0][0] = 1;\n    // REP(i, 0, num) {\n    //     dp[i + 1][0] = modadd(dp[i + 1][0], dp[i][0]);\n    //     dp[i + 1][0] = modadd(dp[i + 1][0], dp[i][1]);\n    //     dp[i + 1][1] = modadd(dp[i + 1][1], dp[i][0]);\n    // }\n    // REP(i, 0, p) {\n    //     cout << dpb[i][0] << \" \" << dpb[i][1] << endl;\n    // }\n    ll ans = 0;\n    REP(i, 0, q + 1) {\n        if (p - 1 - i >= 0) {\n            ll val = multiply((i + 1) * 2, dpb[p - 1 - i][0]);\n            // cout << val << endl;\n            ans = modadd(ans, val);\n        }\n    }\n    return ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    if (N & 1) {\n        bool ok = true;\n        char c = S[0];\n        REP(i, 0, M) {\n            if (S[i] != c) {\n                ok = false;\n            }\n        }\n        if (ok) {\n            cout << solve(N) << endl;\n        } else {\n            cout << 0 << endl;\n        }\n        return 0;\n    } else {\n        ll len = 0;\n        char c = S[0];\n        ll num = 0;\n        while (num < M && S[num] == c) {\n            num++;\n        }\n        len = num;\n        if (len == M) {\n            cout << solve(N) << endl;\n            return 0;\n        }\n        if (!(len & 1)) {\n            len++;\n        }\n        ll tmp = 0;\n        num++;\n        while (num < M) {\n            if (num == c) {\n                tmp++;\n            } else {\n                if (tmp & 1) {\n                    len = min(len, tmp);\n                }\n                tmp = 0;\n            }\n            num++;\n        }\n        // cout << len << endl;\n        cout << solveb(N, len) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\ntemplate <typename T> bool in(T a, T b, T c) { return a <= b && b < c; }\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n#ifndef MOD_H\n#define MOD_H\n\n\n\ntemplate <unsigned int N> class Field {\n    typedef unsigned int ui;\n    typedef unsigned long long ull;\n\tinline ui pow(ui a, ui p){ui r=1,e=a;while(p){if(p&1){r=((ull)r*e)%N;}e=((ull)e*e)%N;p>>=1;}return r;}\n\t/*extended GCD(slow):ll t=0,nt=1,r=N,nr=a;while(nr){ll q=r/nr;t-=q*nt;swap(t,nt);r-=q*nr;swap(r,nr);}assert(r<=1);return(t<0)?t+N:t;*/\n\tinline ui inv(ui a){return pow(a,N-2);}\npublic:\n    inline Field(int x = 0) : v(x) {}\n\tinline Field<N> pow(int p){return (*this)^p; }\n\tinline Field<N> operator^(int p){return {(int)pow(v,(ui)p)};}\n    inline Field<N>&operator+=(const Field<N>&o) {if (v+o.v >= N) v += o.v - N; else v += o.v; return *this; }\n    inline Field<N>&operator-=(const Field<N>&o) {if (v<o.v) v -= o.v-N; else v-=o.v; return *this; }\n    inline Field<N>&operator*=(const Field<N>&o) {v=(ull)v*o.v % N; return *this; }\n    inline Field<N>&operator/=(const Field<N>&o) { return *this*=inv(o.v); }\n    inline Field<N> operator+(const Field<N>&o) const {Field<N>r{*this};return r+=o;}\n    inline Field<N> operator-(const Field<N>&o) const {Field<N>r{*this};return r-=o;}\n    inline Field<N> operator*(const Field<N>&o) const {Field<N>r{*this};return r*=o;}\n    inline Field<N> operator/(const Field<N>&o) const {Field<N>r{*this};return r/=o;}\n    inline Field<N> operator-() {if(v) return {(int)(N-v)}; else return {0};};\n    inline Field<N>& operator++() { ++v; if (v==N) v=0; return *this; }\n    inline Field<N> operator++(int) { Field<N>r{*this}; ++*this; return r; }\n    inline Field<N>& operator--() { --v; if (v==-1) v=N-1; return *this; }\n    inline Field<N> operator--(int) { Field<N>r{*this}; --*this; return r; }\n    inline bool operator==(const Field<N>&o) const { return o.v==v; }\n\tinline bool operator!=(const Field<N>&o) const { return o.v!=v; }\n\tinline explicit operator ui() const { return v; }\n\tinline static vector<Field<N>>fact(int t){vector<Field<N>>F(t+1,1);for(int i=2;i<=t;++i){F[i]=F[i-1]*i;}return F;}\n\tinline static vector<Field<N>>invfact(int t){vector<Field<N>>F(t+1,1);Field<N> X{1};for(int i=2;i<=t;++i){X=X*i;}F[t]=1/X;for(int i=t-1;i>=2;--i){F[i]=F[i+1]*(i+1);}return F;}\nprivate: ui v;\n};\ntemplate<unsigned int N>istream &operator>>(std::istream&is,Field<N>&f){unsigned int v;is>>v;f=v;return is;}\ntemplate<unsigned int N>ostream &operator<<(std::ostream&os,const Field<N>&f){return os<<(unsigned int)f;}\ntemplate<unsigned int N>Field<N> operator+(int i,const Field<N>&f){return Field<N>(i)+f;}\ntemplate<unsigned int N>Field<N> operator-(int i,const Field<N>&f){return Field<N>(i)-f;}\ntemplate<unsigned int N>Field<N> operator*(int i,const Field<N>&f){return Field<N>(i)*f;}\ntemplate<unsigned int N>Field<N> operator/(int i,const Field<N>&f){return Field<N>(i)/f;}\n\n\ntypedef Field<1000000007> FieldMod;\n\nstruct Ring {\n\ttemplate <typename T>\n\tstatic T div(T p, T q, T N) {\n\t\tT t=0,nt=1,r=N,nr=q;\n\t\twhile(nr!=0){ T q=r/nr;t-=q*nt;r-=q*nr;swap(t,nt);swap(r,nr); }\n\t\tt=(t<0)?t+N:t;\n\t\tr=(r<0)?r+N:r;\n\t\tif (gcd(p,N)%r!=0) { return 0; }\n\t\treturn (t*p/r)%N;\n\t}\n};\n#endif\n\n\nclass EGoAroundACircle {\npublic:\n    void solve(istream& cin, ostream& cout) {\n        int N, M; cin >> N >> M;\n        string S; cin >> S;\n        char c = S[0];\n        int d = 1, m = -1, so = 1e9;\n        for (int i = 1; i < M; ++i) {\n            if (S[i] == c) {\n                d++;\n            } else {\n                if (m == -1) m = d;\n                if (d % 2 == 1) so = min(so, d);\n                d = 0;\n            }\n        }\n\n        if (N % 2 == 1) {\n            if (m == -1) {\n                vector2<FieldMod> X(N, 2, 0);\n                X[0][0] = 1;\n                for (int i = 1; i < N; ++i) {\n                    X[i][0] = X[i-1][0] + X[i-1][1];\n                    X[i][1] = X[i-1][0];\n                }\n\n                vector2<FieldMod> Y(N, 2, 0);\n                Y[0][1] = 1;\n                for (int i = 1; i < N; ++i) {\n                    Y[i][0] = Y[i-1][0] + Y[i-1][1];\n                    Y[i][1] = Y[i-1][0];\n                }\n\n\n                cout << X.back()[0] + X.back()[1] + Y.back()[1] << endl;\n            } else {\n                cout << 0 << endl;\n            }\n            return;\n        }\n\n        if (m == -1) {\n            cout << FieldMod{2}.pow(N/2) * 2 - 1;\n            return;\n        }\n\n        if (m % 2 == 0) ++m;\n        m = min(m, so);\n        // max size of consecutive Rs => m\n        int b = min(N/2, (m+1)/2);\n\n        vector<FieldMod> H(N/2, 0);\n        FieldMod tot = 1;\n        H[0] = 1;\n        for (int j = 1; j < N/2; ++j) {\n            if (j > b)  tot -= H[j-b-1];\n            H[j] = tot;\n            tot += H[j];\n        }\n\n//        cout << H;\n        FieldMod ans = 0;\n        for (int i = 1; i <= b; ++i) {\n            ans += i * H[N/2-i];\n        }\n        cout << 2*ans << endl;\n\n\n//        int ans = 0;\n//        for (int i = 0; i < (1<<N); ++i) {\n//            vector<bool> A(N, true);\n//            for (int j = M-1; j >= 0; --j) {\n//                int s = (S[j] == 'R') ? 1 : 0;\n//                vector<bool> B(N, false);\n//                for (int k = 0; k < N; ++k) {\n//                    if (!A[k]) continue;\n//                    int l = k == 0 ? N-1 : k-1;\n//                    int r = k == N-1 ? 0 : k+1;\n//                    if (((i>>l)&1) == s) B[l] = true;\n//                    if (((i>>k)&1) == s) B[r] = true;\n//                }\n//                swap(A,B);\n//            }\n//\n//            if (count(A.begin(),A.end(),true) == N) {\n//                ans++;\n////                for (int j = 0; j < N; ++j) {\n////                    cout << \"BR\"[(i>>j)&1];\n////                }\n////                cout << endl;\n//            }\n//        }\n//        cout << ans << endl;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tEGoAroundACircle solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=200005;\nconst int mod=1e9+7;\nint n,m,mn,ans;\nchar s[maxn],ch;\nint f[maxn],sum[maxn],g[maxn][2];\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d%d%s\",&n,&m,s);\n\tch=s[0];\n\tint cnt=0;\n\tmn=INF;\n\trep(i,m){\n\t\tif(s[i]!=ch){\n\t\t\tif(!cnt)continue;\n\t\t\tif(cnt%2==0)cnt++;\n\t\t\tmn=min(mn,cnt);\n\t\t\tcnt=0;\t\n\t\t}\n\t\telse cnt++;\n\t}\n\tif(mn==INF){\n\t\tg[1][0]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tg[i][0]=(g[i-1][0]+g[i-1][1])%mod;\n\t\t\tg[i][1]=g[i-1][0];\n\t\t}\n\t\tans=(g[n][0]+g[n][1])%mod;\n\t\tREP(i,n)g[i][0]=g[i][1]=0;\n\t\tg[1][1]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tg[i][0]=(g[i-1][0]+g[i-1][1])%mod;\n\t\t\tg[i][1]=g[i-1][0];\n\t\t}\n\t\tans=(ans+g[n][0])%mod;\n\t}\n\telse{\n\t\tif(n&1)ans=0;\n\t\telse{\n\t\t\tassert(false);\n\t\t\tn/=2;\n\t\t\tmn=(mn+1)/2;\n\t\t\tf[0]=1;sum[0]=1;\n\t\t\tREP(i,n){\n\t\t\t\tf[i]=(sum[i-1]-(i-mn-1>=0?sum[i-mn-1]:0)+mod)%mod;\n\t\t\t\tsum[i]=(sum[i-1]+f[i])%mod;\n\t\t\t}\n\t\t\trep(i,n)if(n-i<=mn)ans=(ans+2LL*(n-i)*f[i]%mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=200005,M=1e9+7;\nint n,m,f[N],g[N],ans;\nchar s[N];\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tif (s[1]=='R'){\n\t\tfor (int i=1;i<=m;i++){\n\t\t\tif (s[i]=='R')s[i]='B';\n\t\t\telse s[i]='R';\n\t\t}\n\t}\n\tint l=0,mi=0;\n\tfor (int i=1;i<=m;i++)\n\t\tif (s[i]=='R'){\n\t\t\tl=i-1;\n\t\t\tbreak;\n\t\t}\n\tif (!l){\n\t\tf[0]=g[0]=1;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tf[i]=g[i-2];\n\t\t\tg[i]=(g[i-1]+f[i])%M;\n\t\t}\n\t\tfor (int i=2;i<=n;i++)(ans+=i*f[n-i])%=M;\n\t\tprintf(\"%lld\\n\",(ans+1)%M);\n\t\treturn 0;\n\t}\n\tmi=l+!(l%2);\n\tfor (int i=1,j=1;i<=m;i=j){\n\t\twhile (j<=m&&s[j]=='B')j++;\n\t\tif (j>m)break;\n\t\tif ((j-i)&1)mi=min(mi,j-i);\n\t\twhile (j<=m&&s[j]=='R')j++;\n\t}\n\tif (n%2==1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tmi=(mi+1)/2;\n\tn/=2;\n\tf[0]=g[0]=1;\n\tfor (int i=1;i<=n;i++){\n\t\tf[i]=(g[i-1]-(i-mi-1<0?0:g[i-mi-1])+M)%M;\n\t\tg[i]=(g[i-1]+f[i])%M;\n\t}\n\tfor (int i=1;i<=mi;i++)(ans+=i*2*f[n-i])%=M;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+10;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    lim = min(lim,(ll)n-1);\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    ans = dp[n+1];\n    for(ll i = 1;i<=lim;i+=2)\n    {\n        ans += (i*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    int mn = 1e9;\n    if (vc[0]%2==0)\n        mn = vc[0]+1;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 1;\n    rdp[0] = 1;\n    for(int i = 1;i <= n+1;i++){\n        dp[i] = (rdp[i-1] - ((i-limit-1)>=0?rdp[i-limit-1]:0)) % MOD;\n        if(dp[i] < 0)dp[i] += MOD;\n        rdp[i] = (rdp[i-1] + dp[i]) % MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n+10, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    return 2;\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    bool allsame = true;\n    for(int i = 0;i < m;i++)allsame &= (str[i] == str[0]);\n    if(allsame){\n        cout << all(n) << endl;\n        return 0;\n    }\n    for(int i = 0;i < m;i++)vec.push_back(str[i] == str[0]);\n    vec.push_back(0);\n    Int l = 0;\n    while(vec[l] == 1)l++;\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i < vec.size();i++){\n        if(vec[i] == 1)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define pld pair <ld, ld>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n#define cld complex <double>\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 3e5;\nconst ll mod = 1e9 + 7;\n\nll n, m, k, t;\n\nstring s;\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;\n}\n\nll simple() {\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    ll q;\n    for (q = 1; q < n; q++) {\n        D[q] += D[q - 1];\n        if (q >= 2) {\n            D[q] += D[q - 2];\n            D[q] %= mod;\n        }\n    }\n    return (D[n - 2] * 2 + D[n - 1]) % mod;\n    // if (n % 2 == 1) {\n    //     return \n    // }\n    // return step(2, n / 2 + 1);\n}\n\nint main() {\n    pyshnapyshnakaa\n    ll q, w, e, a, b, c;\n    cin >> n >> m;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (q = 0; q < s.length(); q++) {\n            if (s[q] == 'R') {\n                s[q] = 'B';\n            }\n            else {\n                s[q] = 'R';\n            }\n        }\n    }\n    vector <pll> A;\n    A.pb(mp(1, s[0]));\n    for (q = 1; q < s.length(); q++) {\n        if (s[q] == A.back().second) {\n            A.back().first++;\n        }\n        else {\n            A.pb(mp(1, s[q]));\n        }\n    }\n    // cout << \"FALL\" << endl;\n    bool blue = 0; /*kill = 0;*/\n    ll mx = maxn;\n    // cout << \"\"\n    for (q = 0; q < A.size(); q++) {\n        if (A[q].second == 'B') {\n            blue = 1;\n        }\n        else {\n            if (1/*q == 0 || A[q].first % 2 == 1*/) {\n                mx = min(mx, A[q].first + 1 - A[q].first % 2);\n            }\n        }\n    }\n    // cout << \"MX \" << mx << endl;\n    // if (fail) {\n    //     cout << 0;\n    //     return 0;\n    // }\n    if (!blue) {\n        cout << simple();\n        return 0;\n    }\n    // ll mx = maxn, cur = 0;\n    // for (q = 0; q < s.length(); q++) {\n    //     if (s[q] == 'B') {\n    //         if (cur % 2 == 1) {\n    //             mx = min(mx, cur);\n    //         }\n    //         else {\n    //             mx = min(mx, cur + 1);\n    //         }\n    //         cur = 0;\n    //     }\n    //     else {\n    //         cur++;\n    //     }\n    // }\n    vector <ll> S(2);\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    S[0] = 1;\n    for (q = 1; q < n; q++) {\n        D[q] = S[q % 2];\n        S[q % 2] = (S[q % 2] + D[q]) % mod;\n        ll deli = q - mx - 1;\n        if (deli >= 0) {\n            // cout << \"DELETING \" << q << endl;\n            S[deli % 2] = (S[deli % 2] - D[deli] + mod) % mod;\n        }\n        // cout << q << \" \" << D[q] << endl;\n    }\n    // cout << \"mx \" << mx << endl;\n    ll ans = 0;\n    for (q = 0; q < n; q++) {\n        ll len = n - q - 1;\n        if (len % 2 == 0 || len > mx) {\n            continue;\n        }\n        ans += D[q] * (len + 1) % mod;\n        ans %= mod;\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\n\n/// --- Modulo Integer {{{ ///\n#include <ostream>\ntemplate < long long mod = static_cast< long long >(1e9 + 7) >\nstruct ModuloInteger {\n  static_assert(mod > 0, \"mod must be positive\");\n  static_assert(mod <= 3037000499, \"mod is too big\");\n  using integer = long long;\n  static ModuloInteger unused;\n  // math {{{\n  static inline integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  static inline integer modpow(integer a, long long b) {\n    if(b < 0) b = -b, a = modinv(a);\n    integer r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  integer val;\n  constexpr ModuloInteger() : val(0) {}\n  constexpr ModuloInteger(integer t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\nprivate:\n  // strict constructor\n  constexpr ModuloInteger(integer t, int) : val(t) {}\n\npublic:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // operator bool() { return bool(val); }\n  // ModuloInteger <arithmetic-operator>[=] ModuloInteger {{{\n  ModuloInteger operator+(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModuloInteger operator-(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModuloInteger operator*(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModuloInteger operator/(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModuloInteger &operator+=(ModuloInteger const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModuloInteger &operator-=(ModuloInteger const &rhs) { return *this += -rhs; }\n  ModuloInteger &operator*=(ModuloInteger const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModuloInteger &operator/=(ModuloInteger const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModuloInteger operator++(int) {\n    ModuloInteger tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModuloInteger operator--(int) {\n    ModuloInteger tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModuloInteger &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModuloInteger &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModuloInteger operator-() const { return ModuloInteger(val == 0 ? 0 : mod - val, 0); }\n  // ModuloInteger <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModuloInteger operator+(T const &rhs) const {\n      return ModuloInteger(val + rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator-(T const &rhs) const {\n      return ModuloInteger(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator*(T const &rhs) const {\n      return ModuloInteger(val * (rhs % mod));\n    }\n  template < typename T >\n    ModuloInteger operator/(T const &rhs) const {\n      return ModuloInteger(val * modinv(rhs));\n    }\n  template < typename T >\n    ModuloInteger &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator/=(T const &rhs) {\n      val = val * modinv(rhs) % mod;\n      return *this;\n    }\n  // }}}\n  ModuloInteger inv() const { return ModuloInteger(modinv(val), 0); }\n  ModuloInteger operator~() const { return inv(); }\n  friend std::ostream &operator<<(std::ostream &os, ModuloInteger const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // equality operator {{{\n  ModuloInteger operator==(const ModuloInteger &a) const { return val == a.val; }\n  ModuloInteger operator!=(const ModuloInteger &a) const { return val != a.val; }\n  ModuloInteger operator==(const integer &a) const { return val == ModuloInteger(a); }\n  ModuloInteger operator!=(const integer &a) const { return val != ModuloInteger(a); }\n  // }}}\n  // T <arithmetic-operator> ModuloInteger {{{\n  friend constexpr ModuloInteger operator+(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod + mv.val);\n  }\n  friend constexpr ModuloInteger operator-(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod - mv.val);\n  }\n  friend constexpr ModuloInteger operator*(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModuloInteger operator/(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModuloInteger operator^(integer x) const { return pow(*this, x); }\n  ModuloInteger &operator^=(integer x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModuloInteger pow(ModuloInteger x, integer y) {\n    return ModuloInteger(modpow(x.val, y), 0);\n  }\n  // }}}\n};\ntemplate < long long mod >\nModuloInteger< mod > ModuloInteger< mod >::unused(mod, 0);\n/// }}}--- ///\n\nusing modint = ModuloInteger<>;\n\n\n// LazySegmentTree( size [, initial] )\n// LazySegmentTree( <data> )\n/// --- LazySegmentTree {{{ ///\n#include <cassert>\n#include <initializer_list>\n#include <iostream>\n#include <vector>\ntemplate < class M_act >\nstruct LazySegmentTree {\npublic:\n  using Monoid = typename M_act::Monoid;\n  using X = typename Monoid::T;\n  using M = typename M_act::M;\n\nprivate:\n  size_t n;\n  int h;\n  vector< X > data;\n  vector< M > lazy;\n  vector< size_t > nodeLength;\n  // call before use data[i]\n  void eval(size_t i) {\n    if(lazy[i] == M_act::identity()) return;\n    data[i] = M_act::actInto(lazy[i], nodeLength[i], data[i]);\n    if(i < n) {\n      lazy[i * 2] = M_act::op(lazy[i], lazy[i * 2]);\n      lazy[i * 2 + 1] = M_act::op(lazy[i], lazy[i * 2 + 1]);\n    }\n    lazy[i] = M_act::identity();\n  }\n  // call before use seg[i] = data[i + n]\n  void evalDown(size_t i) {\n    i += n;\n    for(int j = h - 1; j >= 0; j--) eval(i >> j);\n  }\n  // call after touch seg[i] = data[i + n]\n  void propUp(size_t i) {\n    i += n;\n    while(i >>= 1)\n      eval(i * 2), eval(i * 2 + 1), data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n  }\n\npublic:\n  LazySegmentTree() : n(0) {}\n  LazySegmentTree(size_t n, X initial = Monoid::identity()) : n(n) {\n    if(n > 0) {\n      h = 1;\n      while(1u << h < n) h++;\n      data.resize(2 * n, initial);\n      lazy.resize(2 * n, M_act::identity());\n      nodeLength.resize(2 * n, 1);\n      for(size_t i = n - 1; i > 0; i--) // fill from deep\n        data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]),\n          nodeLength[i] = nodeLength[i * 2] + nodeLength[i * 2 + 1];\n    }\n  }\n  template < class InputIter, class = typename iterator_traits< InputIter >::value_type >\n    LazySegmentTree(InputIter first, InputIter last)\n    : LazySegmentTree(distance(first, last)) {\n      if(n > 0) {\n        copy(first, last, begin(data) + n);\n        for(size_t i = n - 1; i > 0; i--) // fill from deep\n          data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n      }\n    }\n  LazySegmentTree(vector< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  LazySegmentTree(initializer_list< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  void act(int l, int r, const M &m) {\n    if(l < 0) l = 0;\n    if(l >= r) return;\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    int tl = l, tr = r;\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), lazy[l] = m, eval(l), l++;\n      if(r & 1) --r, eval(r), lazy[r] = m, eval(r);\n    }\n    propUp(tl);\n    propUp(tr - 1);\n  }\n  void set(size_t i, const X &x) {\n    assert(i < n);\n    evalDown(i);\n    data[i + n] = x;\n    propUp(i);\n  }\n  X get(size_t i) {\n    assert(i < n);\n    evalDown(i);\n    return data[i + n];\n  }\n  X fold(int l, int r) {\n    if(l < 0) l = 0;\n    if(l >= r) return Monoid::identity();\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    X tmpL = Monoid::identity(), tmpR = Monoid::identity();\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), tmpL = Monoid::op(tmpL, data[l]), l++;\n      if(r & 1) --r, eval(r), tmpR = Monoid::op(data[r], tmpR);\n    }\n    return Monoid::op(tmpL, tmpR);\n  }\n  int size() { return n; }\n  inline void dum(int r = -1) {\n#ifdef DEBUG\n    if(r < 0) r = n;\n    DEBUG_OUT << \"{\";\n    for(int i = 0; i < min(r, (int) n); i++) DEBUG_OUT << (i ? \", \" : \"\") << get(i);\n    DEBUG_OUT << \"}\" << endl;\n#endif\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid examples {{{ ///\nconstexpr long long inf_monoid = 1e18 + 100;\n#include <algorithm>\nstruct Nothing {\n  using T = char;\n  using Monoid = Nothing;\n  using M = T;\n  static constexpr T op(const T &, const T &) { return T(); }\n  static constexpr T identity() { return T(); }\n  template < class X >\n    static constexpr X actInto(const M &, long long, const X &x) {\n      return x;\n    }\n};\n\ntemplate < class U = long long >\nstruct RangeMin {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::min< T >(a, b); }\n  static constexpr T identity() { return T(inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeMax {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::max< T >(a, b); }\n  static constexpr T identity() { return T(-inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeSum {\n  using T = U;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return T(0); }\n};\n\ntemplate < class U >\nstruct RangeProd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a * b; }\n  static constexpr T identity() { return T(1); }\n};\n\ntemplate < class U = long long >\nstruct RangeOr {\n  using T = U;\n  static T op(const T &a, const T &b) { return a | b; }\n  static constexpr T identity() { return T(0); }\n};\n\n#include <bitset>\n\ntemplate < class U = long long >\nstruct RangeAnd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return T(-1); }\n};\n\ntemplate < size_t N >\nstruct RangeAnd< std::bitset< N > > {\n  using T = std::bitset< N >;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return std::bitset< N >().set(); }\n};\n\n/// }}}--- ///\n\n/// --- M_act examples {{{ ///\ntemplate < class U = long long, class V = U >\nstruct RangeMinAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMin< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMax< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMinSet {\n  using M = U;\n  using Monoid = RangeMin< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxSet {\n  using M = U;\n  using Monoid = RangeMax< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long n, const X &x) { return m * n + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long n, const X &x) {\n    return m == identity() ? x : m * n;\n  }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdMul {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M mpow(M a, long long b) {\n    X r(1);\n    while(b) {\n      if(b & 1) r = r * a;\n      a = a * a;\n      b >>= 1;\n    }\n    return r;\n  }\n  static M op(const M &a, const M &b) { return a * b; }\n  static constexpr M identity() { return M(1); }\n  static X actInto(const M &m, long long n, const X &x) { return x * mpow(m, n); }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return V::unused; }\n  static X actInto(const M &m, long long n, const X &) {\n    if(m == identity()) return;\n    return RangeProdMul< U, V >::mpow(m, n);\n  }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeOr2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeOr< U >;\n  static M op(const M &a, const M &b) { return a | b; }\n  static constexpr M identity() { return M(0); }\n  static X actInto(const M &m, long long, const X &x) { return m | x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeAnd2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return M(-1); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n\ntemplate < class U, size_t N >\nstruct RangeAnd2< U, std::bitset< N > > {\n  using X = U;\n  using M = std::bitset< N >;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return std::bitset< N >().set(); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n/// }}}--- ///\n\nusing Seg = LazySegmentTree< RangeSumAdd<modint> >;\n\n\n// NOTE : use H with larger N\n/// --- Modulo Factorial {{{ ///\n#include <cassert>\n#include <cstddef>\ntemplate < std::size_t N, int mod = static_cast< int >(1e9 + 7) >\nstruct Factorial {\n  using integer = long long;\n  constexpr integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d = 0;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  constexpr integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  int arr[N + 1], inv[N + 1];\n  integer operator[](int i) const { return arr[i]; }\n  Factorial() : arr(), inv() {\n    arr[0] = 1;\n    for(std::size_t i = 1; i <= N; i++) {\n      arr[i] = (integer) i * arr[i - 1] % mod;\n    }\n    inv[N] = modinv(arr[N]);\n    for(int i = N - 1; i >= 0; i--) {\n      inv[i] = (integer)(i + 1) * inv[i + 1] % mod;\n    }\n  }\n  integer C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    assert(n <= N);\n    return (integer) arr[n] * inv[r] % mod * inv[n - r] % mod;\n  }\n  integer H(int n, int r) const { return C(n + r - 1, r); }\n};\n/// }}}--- ///\n\nconstexpr int mod = 1e9 + 7;\nconst int N = 2e5 + 10;\nFactorial< N * 2, mod > fact;\n\n\n\nint n, m;\nint r, b;\nint rmax;\nstring s;\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n >> m;\n  cin >> s;\n  if(s[0] == 'B') for(auto &e : s) e = e == 'R' ? 'B' : 'R';\n  bool allR = 1;\n  for(auto e : s) allR &= e == 'R';\n\n  if(allR) {\n    dump(\"allR\");\n    modint ans;\n    for(int B = 0; B <= n; B++) {\n      int R = n - B - B;\n      ans += modint(fact.C(R + B, R));\n      ans += modint(fact.C(R + B - 1, R));\n    }\n    cout << ans << endl;\n    return 0;\n  }\n\n  if(n % 2 == 1) {\n    cout << 0 << endl;\n    dump(\"odd\");\n    return 0;\n  }\n\n  int c = 0;\n  rmax = m;\n  bool first = 1;\n  for(int i = 0; i <= m; i++) {\n    if(i == n || s[i] == 'B') {\n      if(c) {\n        if(c % 2 == 0 && first) rmax = min(rmax, c + 1);\n        if(c % 2 == 1) rmax = min(rmax, c);\n      }\n      c = 0;\n      first = 0;\n    } else c++;\n  }\n\n  dump(rmax);\n\n  // RB\n\n  // vector<modint> dp(n + 1);\n  Seg dp(n + 1);\n  dp.set(0, 1);\n\n  modint ans;\n\n  for(int i = 0; i <= n - 1; i+=2) {\n    dp.act(i + 2, min<int>(n - 1, i + 1 + rmax) + 1, dp.get(i));\n    if(i + 1 + rmax >= n) {\n      int f = n - i - 1;\n      if (f >= 1) {\n        dump(i, dp.get(i), f);\n        ans += dp.get(i) * (f + 1);\n      }\n    }\n  }\n  cout << ans << endl;\n  dp.dum();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n/*\n0-index\nfunctionの中を書いて使う\n宣言の時に単位元を書く\n*/\ntemplate<typename T>\nstruct segtree{\n\tint n;\n\tvector<T> dat;\n\tT ZERO;\n\tfunction<T(T,T)> func;\n\tsegtree(int n_, function<T(T,T)> func_, T zero):func(func_), ZERO(zero){\n\t  n = 1;\n\t  while(n < n_)n*=2;\n\t  dat.resize(2*n);\n\t  for(int i = 0;i < 2*n;i++)dat[i] = ZERO;\n\t}\n\tvoid update(int k, T a){\n\t  k += n - 1;dat[k] = a;\n\t  while(k > 0){\n\t\tk = (k-1)/2;\n\t\tdat[k] = func(dat[k*2+1],dat[k*2+2]);\n\t  }\n\t}\n\n\tvoid set(int k, T a) {\n\t\tk += n - 1;dat[k] = a;\n\t}\n\n\tvoid build(){\n\t\tfor(int i = n - 2;i >= 0;i--){\n\t\t\tdat[i] = func(dat[2 * i + 1], dat[2 * i + 2]);\n\t\t}\n\t}\n\n\tT get(int k){return dat[k+n-1];}\n\n\tT que(int a,int b){\n\t\tT L = ZERO,R = ZERO;\n\t\tint A = a + n - 1;\n\t\tint B = b + n - 1;\n\t\twhile(A < B){\n\t\t\tif((A & 1) == 0)L = func(L,dat[A++]);\n            if((B & 1) == 0)R = func(dat[--B],R);\n            A = A >> 1;\n            B = B >> 1;\n\t\t}\n\t\treturn func(L,R);\n\t}\n};\n\n\nint getmin(string str){\n\tchar c = str[0];\n\tbool isFirst = true;\n\tint cou = 0;\n\tint ret = INF;\n\tREP(i, str.size()){\n\t\tif(str[i] == c)cou++;\n\t\telse {\n\t\t\tif(isFirst && cou % 2 == 0)cou++;\n\t\t\tif(cou % 2)ret = min(ret, cou);\n\t\t\tisFirst = false;\n\t\t\tcou = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nbool oneKind(string str){\n\tREP(i, str.size())if(str[0] != str[i])return false;\n\treturn true;\n}\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\tll n, m;cin >> n >> m;\n\tstring str;cin >> str;\n\n\tint k = getmin(str);\n\tsegtree<ll> seg(n, [](ll a, ll b){return (a + b) % MOD;}, 0);\n\n\tseg.update(0, 1);\n\tfor(ll i = 2;i < n;i++){\n\t\tif(i % 2)continue;\n\t\tll l = max(0LL, i - k - 1);\n\t\tll r = i - 1;\n\t\tseg.update(i, seg.que(l, r));\n\t}\n\n\t//REP(i, n)cout << seg.get(i) << \" \";cout << endl;\n\n\tll ans = 0;\n\tbool flag = oneKind(str);\n\tREP(i, n-1){\n\t\tif(n - (i + 1) <= k && ((n - (i + 1)) % 2 || flag)){\n\t\t\t//cout << \"pass \" << seg.get(i) * (n - i) % MOD << endl;\n\t\t\tans = (ans + seg.get(i) * (n - i) % MOD) % MOD;\n\t\t}\n\t}\n\tif(flag)ans = (ans + 1) % MOD;\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=401000;\nchar s[N];\nint n,m;\n\nll dp[N],sdp[N],ans;\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s);\n\tbool mono=1;\n\trep(i,0,m) mono&=s[i]==s[0];\n\tif (mono) {\n\t\tint a=2,b=1;\n\t\trep(i,1,n) {\n\t\t\ta=(a+b)%mod;\n\t\t\tswap(a,b);\n\t\t}\n\t\tprintf(\"%d\\n\",b);\n\t\treturn 0;\n\t}\n\tint sR=2*n+1,sB=2*n+1;\n\tif (s[0]=='B') {\n\t\trep(i,0,m) if (s[i]=='R') s[i]='B'; else s[i]='R';\n\t}\n\trep(l,0,m) {\n\t\tint r=l;\n\t\twhile (r<m&&s[r]==s[l]) r++;\n\t\tint len=r-l;\n\t\tif (len%2==0) len=len+1;\n\t\tif (r==m) break;\n\t\tif (s[l]=='R') sR=min(sR,len);\n\t\telse sB=min(sB,len);\n\t\tl=r-1;\n\t}\n\tif (n%2==1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tprintf(\"%d %d\\n\",sR,sB);\n\tauto solve=[&](int sR,int sB) {\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(sdp,0,sizeof(sdp));\n\t\tdp[0]=1;\n\t\tsdp[2]=1;\n\t\trep(i,1,n+1) {\n\t\t\tif (i%2==1) {\n\t\t\t\tdp[i]=(sdp[i+1]-sdp[max(0,i-sR)])%mod;\n\t\t\t} else {\n\t\t\t\tif (i!=n) {\n\t\t\t\t\tdp[i]=(sdp[i+1]-sdp[max(1,i-sB)])%mod;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j=1;j<=sB&&j<=i;j+=2) {\n\t\t\t\t\t\tdp[i]=(dp[i]+dp[i-j]*j)%mod;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsdp[i+2]=(sdp[i]+dp[i])%mod;\n\t\t}\n\t\tans+=dp[n];\n\t};\n\tsolve(sR,sB);\n\tsolve(sB,sR);\n\tans%=mod;\n\tif (ans<0) ans+=mod;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 2e5 + 10,mod = 1e9 + 7;\n\nchar str[N];\nint dp[N];\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Add(int &x,int y) { if((x += y) >= mod) x -= mod; }\ninline int chk(int v) { return v < 0 ? 0 : dp[v]; }\ninline int val(int v) { return v & 1 ? v - 1 : v; }\n\nint main() {\n\n\tint n = read(),m = read(),flag = true;\n\tscanf(\"%s\",str + 1);\n\tFor(i,1,m - 1) if(str[i] != str[i + 1]) flag = false;\n\tif(flag) {\n\t\tint v00 = 1,v11 = 1,v01 = 0,v10 = 0;\n\t\tFor(i,2,n) {\n\t\t\tint c00 = v00,c10 = v10;\n\t\t\tAdd(v00,v10),Add(v10,v11);\n\t\t\tv01 = c00,v11 = c10;\n\t\t}\n\t\tprintf(\"%lld\\n\",(1ll * v00 + v10 + v01) % mod);\n\t\treturn 0;\n\t}\n\tif(n & 1) return puts(\"0\"),0;\n\tint v = INF,tot = 0;\n\tFor(i,1,m) {\n\t\tif(str[i] == str[1]) tot++;\n\t\telse {\n\t\t\tif(tot == i - 1) chkmin(v,tot + (tot % 2 == 0));\n\t\t\tif(tot & 1) chkmin(v,tot);\n\t\t\ttot = 0;\n\t\t}\n\t}\n\tv++, dp[0] = 1;\n\tfor(int i = 2;i <= n;i += 2) dp[i] = (2ll * dp[i - 2] - chk(i - 2 - v)) % mod;\n\tint ans = dp[n] - dp[n - 2];\n\tFor(i,1,v - 1) ans = (ans + 1ll * dp[val(n - i - 1)] - dp[n - v - 2]) % mod;\n\tprintf(\"%d\\n\",(ans + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\nusing namespace std;\n\ntypedef long long li;\n\nconst int mod = 1e9 + 7;\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (li)x * y % mod; }\n\n// ----------------------------------------\n\nconst int maxn = 2e5;\n\nint n, m, lim;\nchar s[maxn + 1];\nint dp[maxn + 1];\nint sum[maxn + 2];\n\nvoid GetLim(void) {\n  int cnt = 0;\n  for (int i = 0; i < m; ++i) {\n    if (s[i] == 'R') ++cnt; else break;\n  }\n  if (cnt & 1) lim = cnt; else lim = cnt + 1;\n  cnt = 0;\n  for (int i = 0; i < m; ++i) {\n    if (s[i] == 'R') ++cnt; else {\n      if (cnt & 1) lim = max(lim, cnt);\n      cnt = 0;\n    }\n  }\n}\n\nvoid SolveSame(void) {\n  static int dp[maxn + 1][2][2];\n  dp[0][0][0] = dp[0][1][1] = 1;\n  for (int i = 1; i < n; ++i) {\n    for (int x = 0; x <= 1; ++x) {\n      for (int y = 0; y <= 1; ++y) {\n        for (int z = 0; z <= 1; ++z) {\n          if (y != 1 || z != 1) {\n            Add(dp[i][x][z], dp[i - 1][x][y]);\n          }\n        }\n      }\n    }\n  }\n  int ans = Add(Add(dp[n - 1][0][0] + dp[n - 1][0][1]) + dp[n - 1][1][0]);\n  printf(\"%d\\n\", ans);\n}\n\nint main(void) {\n  scanf(\"%d%d%s\", &n, &m, s);\n  if (s[0] == 'B') {\n    for (int i = 0; i < m; ++i) {\n      s[i] ^= 'R' ^ 'B';\n    }\n  }\n  if (count(s, s + m, 'R') == m) {\n    // the same\n    SolveSame();\n    return 0;\n  }\n\n  GetLim();\n  lim = lim + 1 >> 1;\n  if (n & 1) {\n    puts(\"0\");\n    return 0;\n  }\n  n /= 2;\n\n  for (int i = 1; i <= lim; ++i) {\n    Add(dp[i], 2 * i);\n  }\n  for (int i = 1; i <= n; ++i) {\n    // printf(\"this is %d\\n\", i);\n    // calc dp[i]\n    int L = max(1, i - lim), R = i;\n    Add(dp[i], Sub(sum[R] - sum[L]));\n    sum[i + 1] = Add(sum[i] + dp[i]);\n  }\n  printf(\"%d\\n\", dp[n]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 200002\n#define p 1000000007\ninline int mod(int x){return x<p?x:x-p;}\nint f[N][2],g[N],i,j,m,n,t,x;char s[N];\nint main()\n{\n    scanf(\"%d%d%s\",&n,&m,s+1),f[0][0]=g[0]=1;\n    if(s[1]=='B')for(i=1;i<=n;i++)s[i]=s[i]=='B'?'R':'B';\n    while(s[m]=='R')s[m--]=0;\n    for(i=0;s[i+1]=='R';i++);\n    for(t=i++|1;s[i];t=(i-j&1)&&t<i-j?i-j:t)\n    {\n        while(s[i]=='B')i++;\n        for(j=i;s[i]=='R';i++);\n    }\n    if(m)for(i=1;i<=n;f[i][i&1]=mod(f[i-1][i&1]+g[i]),f[i][i&1^1]=f[i-1][i&1^1],i++)g[i]=i<t+2?f[i-1][i&1]:mod(p+f[i-1][i&1]-f[i-t-2][i&1]);\n    else for(g[1]=1,i=2;i<=n;i++)g[i]=mod(g[i-2]+g[i-1]);\n    if(m)for(i=n-2;0<=i&&n-i<=t+1;i-=2)x=(x+(long long)g[i]*(n-i))%p;\n    else x=mod(g[n]+g[n-2]);\n    return 0*printf(\"%d\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mo 1000000007\n#define N 200010\nusing namespace std;\nint n,m,a[N],b[N],nb;\nll dp[N],s[N],ans;\nint main(){\n\tcin>>n>>m;\n\tfor (int i=1;i<=m;i++){char ch=getchar();while (ch!='R'&&ch!='B')ch=getchar();a[i]=(ch=='R');}\n\tfor (int la=0,i=1;i<=m;i++)if (a[i]!=a[1]){b[++nb]=i-la-1;la=i;}\n\tif (nb==0){\n\t\ts[0]=s[1]=ans=1;\n\t\tfor (int i=2;i<n;i++)s[i]=(s[i-1]+s[i-2])%mo;\n\t\tfor (int j=0;j<n-1;j++)ans=(ans+s[j])%mo;ans=(ans+s[n-2])%mo;\n\t}else{\n\t\tint ma=b[1];\n\t\tfor (int i=2;i<=nb;i++)if (b[i]%2)ma=min(ma,b[i]);\n\t\tif (ma%2==0)ma++;ma++;\n\t\tdp[0]=1;s[0]=1;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tif (i%2)dp[i]=0;\n\t\t\telse{dp[i]=s[i-1];if (i-ma-1>=0)dp[i]=(dp[i]-s[i-ma-1]+mo)%mo;}\n\t\t\ts[i]=(s[i-1]+dp[i])%mo;\n\t\t}\n\t\tfor (int j=n-2;j>=0;j-=2)if (n-j<=ma)ans=(ans+dp[j]*(n-j))%mo;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n//#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int M = 1e9 + 7;\n\nvoid solve_fib(int n) {\n    vi f(n + 1);\n    f[0] = f[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        f[i] = (f[i - 1] + f[i - 2]) % M;\n    }\n    cout << (f[n] + f[n - 2]) % M;\n}\nconst int oo = 1e9 + 10;\n\nint kek(int cnt, bool & first, bool last = false) {\n    if (last) {\n        return oo;\n    }\n    if (first) {\n        first = false;\n        if (cnt & 1)\n            return cnt;\n        return cnt + 1;\n    }\n    if (cnt & 1)\n        return cnt;\n    return oo;\n}\n\nvoid insum(int &a, int b) {\n    a = (a + b) % M;\n}\n\nvoid smain() {\n\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    m = s.size();\n    if (count(ALL(s), 'R') == 0 || count(ALL(s), 'B') == 0) {\n        solve_fib(n);\n        return;\n    }\n\n    vi a(m);\n    fori (i, m) {\n        a[i] = s[i] == 'R';\n    }\n\n    vi min_sz(2, oo);\n    int cur = -1;\n    int cnt = 0;\n    bool first = true;\n    for (auto c : a) {\n        if (c != cur) {\n            if (cur != -1) {\n                inmin(min_sz[cur], kek(cnt, first));\n            }\n            cur = c;\n            cnt = 1;\n        } else {\n            cnt++;\n        }\n    }\n    inmin(min_sz[cur], kek(cnt, first, true));\n    vvi f(2);\n    fori (z, 2) {\n        vvi dp(2, vi(n, 0));\n        vvi p(2, vi(n, 0));\n        p[!z][0] = dp[!z][0] = 1;\n        for (int i = 1; i < n; ++i) {\n            fori (zz, 2) {\n                int j = i - min_sz[zz];\n                if (j < i) {\n                    dp[zz][i] = (p[!zz][i - 1] - (j - 2 >= 0 ? p[!zz][j - 2] : 0) + M) % M;\n                }\n            }\n            fori (zz, 2) {\n                p[zz][i] = (dp[zz][i] + (i - 2 >= 0 ? p[zz][i - 2] : 0)) % M;\n            }\n        }\n        f[z] = dp[z];\n    }\n    int ans = 0;\n    fori (z, 2) {\n        for (int sz = 1; sz <= min_sz[z]; sz += 2) if (sz < n) {\n            insum(ans, (ll)f[!z][n - sz] * sz % M);\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1<<19, mod = 1e9 + 7;\nint n, m, pr = 0, dp[maxn], p[maxn][2];\nstring s;\nint corner() {\n\tdp[0] = 2, dp[1] = 1;\n\tfor(int i = 2; i <= n; i++) dp[i] = (dp[i-1] + dp[i-2])%mod;\n\treturn dp[n];\n}\nvoid add(int &a, int b) {\n\ta += b;\n\tif(a >= mod) a -= mod;\n}\nint normal() {\n\tint ans = 0;\n\tfor(int i = 0; i <= n; i++) {\n\t\tif(i) {\n\t\t\tadd(p[i][0], p[i-1][0]);\n\t\t\tadd(p[i][1], p[i-1][1]);\n\t\t}\n\t\tdp[i] = p[i][i&1];\n\t\tif(i == 1) {\n\t\t\tdp[i] = 1;\n\t\t}\n\t\tadd(p[i+2][i&1], dp[i]);\n\t\tadd(p[i+pr+2][i&1], mod - dp[i]);\n\t}\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(i + pr < n || ((i+pr)&1) != (n&1)) continue;\n\t\tans = (ans + (n-i+1)*1ll*dp[i])%mod;\n\t}\n\treturn ans;\n}\nbool check(int msk, int f = 0) {\n\tif((msk&1) && ((msk>>(n-1))&1)) return 0;\n\tif(msk == 0) return 0;\n\tint prev = -1, streak = 0, i = 0;\n\tif(f) while(!(msk&1)) {\n\t\tmsk = (msk/2);}\n\tfor(; i < n; i++) {\n\t\tint cur = (msk>>i)&1;\n\t\tif(prev == cur) streak++;\n\t\telse {\n\t\t\tif(prev == 1 && streak > 1) return 0;\n\t\t\tif(prev == 0 && (streak > pr || (streak&1) == 0)) return 0;\n\t\t\tstreak = 1;\n\t\t}\n\t\t//cout << i << \" \" << cur << \" \" << streak << '\\n';\n\t\tprev = cur;\n\t}\n\tif(prev == 1 && streak > 1) return 0;\n\t\t\tif(prev == 0 && (streak > pr || (streak&1) == 0)) return 0;\n\t\n\treturn true;\n}\nint brute() {\n\tint ans = 0;\n\tfor(int i = 0; i < 1<<n; i++) {\n\t\tans += check(i, 1);\n\t}\n\treturn ans;\n}\nint main() {\n\tcin >> n >> m >> s;\n\tif(s[0] == 'R')\n\t\tfor(auto &i : s) i ^= 'B'^'R';\n\twhile(pr < m && s[pr] == 'B') pr++;\n\tif(m == pr) return cout << corner(), 0;\n\tpr += pr%2 == 0;\n\tint cur = 0;\n\tfor(auto &i : s) {\n\t\tif(i == 'B') cur++;\n\t\telse {\n\t\t\tif(cur&1) pr = min(cur, pr);\n\t\t\tcur = 0;\n\t\t}\n\t}\n\tcout << normal();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\n\n#define rep(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rrep(i, a, b) for(int i = (a) - 1; i >= int(b); --i)\n#define trav(it, v) for(auto &it : (v))\n#define all(v) (v).begin(), (v).end()\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n#define sz(x) (int)(x).size()\n\ntypedef double fl;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\nbool canGo(string S, int sind, string T, int tind) {\n    if (tind == sz(T))\n        return true;\n    if (S[sind] == T[tind]) {\n        if (canGo(S, (sind+1)%sz(S), T, tind+1))\n            return true;\n    }\n    if (S[(sind+sz(S)-1)%sz(S)] == T[tind]) {\n        if (canGo(S, (sind+sz(S)-1)%sz(S), T, tind+1))\n            return true;\n    }\n    return false;\n}\n\nll solve(int N, int M, string S) {\n    if (S[0] == 'B') {\n        rep(i,0,M) {\n            if (S[i] == 'R')\n                S[i] = 'B';\n            else\n                S[i] = 'R';\n        }\n    }\n    bool anyB = false;\n    int maxRInRow = N+1;\n    int rInRow = 0;\n    rep(i,0,M) {\n        if (S[i] == 'B') {\n            if (rInRow%2) {\n                maxRInRow = min(maxRInRow, rInRow);\n            }\n            if (!anyB && rInRow%2 == 0) {\n                maxRInRow = min(maxRInRow, rInRow+1);\n            }\n            anyB = true;\n            rInRow = 0;\n        }\n        else {\n            ++rInRow;\n        }\n    }\n    if (anyB) {\n        if (N%2) {\n            return 0;\n        }\n        vector<ll> dp(N+1);\n        dp[0] = 1;\n        ll add = 1;\n        rep(i,1,N+1) {\n            if (i%2)\n                dp[i] = 0;\n            else {\n                dp[i] = add;\n                add += dp[i];\n                if (i > maxRInRow) {\n                    add -= dp[i-maxRInRow-1];\n                }\n                add %= MOD;\n                if (add < 0)\n                    add += MOD;\n            }\n        }\n        ll ans = 0;\n        for (int i = 2; i <= maxRInRow+1 && i <= N; i += 2) {\n            ans += i*dp[N-i];\n        }\n        ans %= MOD;\n        return ans;\n    }\n    else {\n        vector<ll> dp[2][2];\n        rep(i,0,2)\n        rep(j,0,2)\n            dp[i][j] = vector<ll>(N+1);\n        dp[0][0][0] = 1;\n        dp[1][1][0] = 1;\n        rep(i,1,N+1) {\n            rep(j,0,2)\n            rep(k,0,2) {\n                dp[j][k][i] += dp[j][!k][i-1];\n                if (k == 0)\n                    dp[j][k][i] += dp[j][k][i-1];\n                dp[j][k][i] %= MOD;\n            }\n        }\n        ll ans = 0;\n        ans += dp[0][0][N];\n        ans += dp[1][1][N];\n        ans %= MOD;\n        return ans;\n    }\n}\n\nint main(){\n    /*while (true) {\n        int N = (rand()%6) + 2;\n        int M = (rand()%7) + 1;\n        string S;\n        rep(i,0,M) {\n            if (rand()%2)\n                S.push_back('R');\n            else \n                S.push_back('B');\n        }\n        ll ans = 0;\n        vector<string> answers;\n        rep(i,0,(1<<N)) {\n            string T;\n            rep(j,0,N) {\n                if (i&(1<<j))\n                    T.push_back('R');\n                else\n                    T.push_back('B');\n            }\n            bool ok = 1;\n            rep(j,0,N) {\n                if (!canGo(T, j, S, 0))\n                    ok = 0;\n            }\n            if (ok)\n            answers.push_back(T);\n            ans += ok;\n        }\n        ll guess = solve(N, M, S);\n        if (ans != guess) {\n            cerr << N << \" \" << M << \" \" << S << endl;\n            cerr << ans << \" \" << guess << endl;\n            for (string s : answers)\n                cerr << s << endl;\n            assert(0);\n        }\n    }*/\n\tios::sync_with_stdio(0);\n    int N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    cout << solve(N, M, S) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9+7;\nint n,m;\nchar ss[200005];\nint f[200005],qz[200005];\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",&ss[1]);\n\tbool mk = 0;\n\tint mx = 0;\n\tfor(int i=1;i<=m;i++) {\n\t\tif(ss[i]!=ss[1]) { mk = 1; mx = i-1; break; }\n\t}\n\tif(!mk) {\n\t\tint ans = 1;\n\t\tf[0] = qz[0] = 1;\n\t\tfor(int i=0;i<=n;i++) {\n\t\t\tif(i>=2) f[i] = qz[i-2];\n\t\t\tif(i!=0)qz[i] = (qz[i-1]+f[i])%mod;\n\t\t\tif(n-i>=2) ans = (ans+1ll*f[i]*(n-i)%mod)%mod;\n\t\t}\n\t\tprintf(\"%d\",ans);\n\t\treturn 0;\n\t}\n\tif(n&1) {\n\t\tputs(\"0\"); return 0;\n\t}\n\tint lx = 0;\n\tfor(int i=1;i<=m;i++) {\n\t\tif(ss[i]==ss[1]) lx++;\n\t\telse {\n\t\t\tif(lx&1) mx = min(mx,lx);\n\t\t\tlx = 0;\n\t\t}\n\t}\n\tmx = mx/2+1;\n\tn/=2;\n\tf[0] = qz[0] = 1;\n\tint ans = 0;\n\tfor(int i=0;i<=n;i++) {\n\t\tif(i) {\n\t\t\tf[i] = (qz[i-1] - (i-mx-1>=0?qz[i-mx-1]:0) )%mod;\n\t\t\tqz[i] = (qz[i-1]+f[i])%mod;\n\t\t}\n\t\tif(n-i<=mx) ans = (ans + 1ll * f[i]*2%mod*(n-i)%mod )%mod;\n\t}\n\tprintf(\"%d\",(ans%mod+mod)%mod );\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+10,mo=1e9+7;\nint f[N],n,m,lim,q[N];\nchar s[N];\nvoid move(int &a,int b){a=(a+b)%mo;}\nint main(){\n\tcin>>n>>m;\n\tscanf(\"%s\",s+1);\n\tif (s[1]=='B'){\n\t\tfor (int i=1;i<=m;i++)s[i]='B'+'R'-s[i];\n\t}\n\tint cnt=0;\n\tfor (int i=1;i<=m;i++){\n\t\tif (s[i]=='R')cnt++;\n\t\telse {\n\t\t\tif (!lim)lim=cnt|1;\n\t\t\telse if (cnt&1)lim=min(lim,cnt);\n\t\t}\n\t}\n\tif (!lim)lim=n+1;\n\tlim++;\n\tfor (int i=1;i<=n;i++){\n\t\tf[i]=q[i-2];\n\t\tif (i<=lim&&(i%2==0))move(f[i],i);\n\t\tq[i]=((ll)q[i-2]+f[i]-(i>lim?f[i-lim]:0)+mo)%mo;\n\t}\n\tcout<<f[n]+(lim==n+1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  if(vs==vector<Int>(m,1)){\n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n\n  if(n&1){\n    cout<<0<<endl;\n    return 0;\n  }\n  \n  Int lim=n-1;  \n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    Int j=i;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n    \n    if(i==0) chmin(lim,(j-i)+(~(j-i)&1));    \n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }\n  \n  vector<M> dp(n+2,0),sm(n+2,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n+1;i++){\n    sm[i]=sm[i-1]+dp[i-1];\n    if(i&1) dp[i]=sm[i-1]-sm[max<Int>(1,i-1-lim)];\n  }\n  \n  M ans{0};\n  for(Int i=0;i<=lim;i++)\n    ans+=sm[n-i+1]-sm[max<Int>(1,n-lim)];\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define YES \"YES\"\n#define Yes \"Yes\"\n#define NO \"NO\"\n#define No \"No\"\n#define YESNO OUT(three(solve(),YES,NO))\n#define YesNo OUT(three(solve(),Yes,No))\n#define ECHO OUT(solve())\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(a);i>=(LL)(b);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b-1,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB emplace_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define int long long\n#define zero 0LL\n#define pb PB\nusing namespace std;\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntypedef long long LL;\ntypedef long double ld;\ntypedef LL ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef priority_queue<pr, Vpr, greater<pr> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nint dx[] = { 0,1,0,-1,1,1,-1,-1,0 }, dy[] = { 1,0,-1,0,1,-1,1,-1,0 };\nconst int SIZE1 = 5e5 + 1000;\nconst int SIZE2 = 1010;\nconst int SIZE3 = 201;\nconst int SIZE = SIZE1;\nconst LL p = 7+1e9;\nconst LL INF = 1LL<<60;\nconst long double EPS = 1e-7;\nut N, M, K, L, H, W, Q, D, T;\n// ut A,B,C,D,E,F,G,H,I,J,O,P,Q,R,T,U;\nVpr edges[SIZE];\nLL vals[SIZE], nums[SIZE], maps[SIZE2][SIZE2], answer = zero;\nLL A[SIZE], B[SIZE], C[SIZE], X, Y[SIZE];\nLL DP[SIZE][2][2];\nLL DP2[SIZE];\nLL same() {\n\tDP[0][0][0] = 1;\n\tDP[0][1][1] = 1;\n\tFOR(i, 1, N) {\n\t\tREP(j, 2) {\n\t\t\tDP[i][j][0] = DP[i - 1][j][1]%p;\n\t\t\tDP[i][j][1] = (DP[i - 1][j][1]+DP[i-1][j][0]) % p;\n\t\t}\n\t}\n\tLL ans = DP[N - 1][0][1] + DP[N - 1][1][0] + DP[N - 1][1][1];\n//\tcout << DP[N - 1][0][1] << DP[N - 1][1][1] << DP[N - 1][1][1] << endl;\n\treturn ans % p;\n}\nLL BIT[SIZE];\nvoid add(LL x, LL val) {\n\tx++;\n\twhile (x < SIZE) {\n\t\tBIT[x] += val;\n\t\tBIT[x] %= p;\n\t\tx += x & -x;\n\t}\n\n}\nLL sum(LL x) {\n\tx++;\n\tLL ans = 0;\n\twhile (x > 0) {\n\t\tans += BIT[x]%p;\n\t\tx -= x & -x;\n\t}\n\treturn ans%p;\n}\nLL sum(LL a, LL b) {\n\tMX(a, 0LL);\n\tMX(b, 0LL);\n\treturn (sum(b) - sum(a - 1)+p)%p;\n}\nLL solve2(LL n,LL range) {\n\tif (n % 2) return 0;\n\tDP2[0] = 1;\n\tadd(0, 1);\n\tFOR(i, 1, n) {\n\t\tif (i % 2) continue;\n\t\tDP2[i] = sum(i - range-1, i - 1)%p;\n\t\tadd(i, DP2[i]);\n\t}\n\tLL ans = 0;\n\tREP(i, n) {\n\t\tif (n - (i+1)<=range) {\n\t\t\tans += DP2[i] * (n-i)%p;\n\t\t\tans %= p;\n\t\t}\n\t\t\n\t}\n\treturn ans;\n}\nLL solve() {\n\tcin >> N >> M;\n\t\n\tstring s;\n\tcin >> s;\n\tREP(i, M) {\n\t\tif (s[i] != s[0])\n\t\t\tbreak;\n\t\tif (M - 1 == i) {\n\t\t\treturn same();\n\t\t}\n\t}\n\tif (s[0] != s[1]) {\n\t\treturn 2;\n\t}\n\tLL minium = INF;\n\tLL diffed = 0;\n\tint now = 0;\n\tREP(i, M) {\n\t\tif (s[i] != s[0]) {\n\t\t\tif (diffed == 0) {\n\t\t\t\tMN(minium, now / 2 * 2 + 1);\n\t\t\t}\n\t\t\telse if (now % 2 == 0);\n\t\t\telse {\n\n\t\t\t\tMN(minium, now);\n\t\t\t}\n\t\t\tnow = 0;\n\t\t\tdiffed++;\n\t\t}\n\t\telse {\n\t\t\tnow++;\n\t\t}\n\t}\n\t//cout << minium << endl;\n\n\tLL ans = solve2(N,minium);\n\treturn ans%p;\n}\nsigned main() {\n\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(10);\n\tcout << solve() << endl;\n\t//\tcin >> N;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1e9+7;\nchar s[200005];\nint f[200005];\nint main(){\n\t// freopen(\"b.in\",\"r\",stdin);\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tif(s[1]=='B')\n\t\tfor(int i=1;i<=m;i++)s[i]=(s[i]=='R'?'B':'R');\n\tint lst=0,k=n&1?n-2:n-1;\n\tfor(int i=1;i<=m;i++){\n\t\tif(s[i]=='B'){\n\t\t\tif(lst!=i-1){\n\t\t\t\tif(!lst){\n\t\t\t\t\tif((i-lst-1)&1)k=min(k,i-lst-1);\n\t\t\t\t\telse k=min(k,i-lst-1+1);\n\t\t\t\t}\n\t\t\t\tif((i-lst-1)&1)k=min(k,i-lst-1);\n\t\t\t}\n\t\t\tlst=i;\n\t\t}\n\t}\n\tif(!lst){\n\t\tint ans=2;\n\t\tf[1]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tf[i]=(f[i-1]+f[i-2])%mod;\n\t\t\tif(i!=n)ans=(ans+f[i])%mod;\n\t\t\telse ans=(ans+f[i-1])%mod;\n\t\t}\n\t\t// puts(\"ok\");\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tk++;\n\tf[1]=f[3]=1;\n\tfor(int i=5;i<=n;i+=2)f[i]=(2ll*f[i-2]+(i>=k+2?mod-f[i-k-2]:0))%mod;\t\n\tint ans=0;\n\tfor(int i=1;i<=min(n,k);i++)if(i&1)ans=(ans+1ll*f[n-i]*(i+1))%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nchar S[210000];\nlong long bit[210000];\nlong long sum(int a,int b){\n\tif(a)return (sum(0,b)-sum(0,a-1)+mod)%mod;\n\tlong long ret=0;\n\tfor(;b>=0;b=(b&(b+1))-1)ret+=bit[b];\n\treturn ret%mod;\n}\nvoid add(int a,long long b){\n\tfor(;a<210000;a|=a+1)bit[a]=(bit[a]+b)%mod;\n}\nlong long dp[210000][2][2];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tscanf(\"%s\",S);\n\tif(S[0]=='B'){\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(S[i]=='B')S[i]='R';\n\t\t\telse S[i]='B';\n\t\t}\n\t}\n\tlong long ret=0;\n\tint chk=0;\n\tfor(int i=0;i<b;i++){\n\t\tif(S[i]=='B')chk=1;\n\t}\n\tif(chk==0){\n\t\tdp[1][0][0]=1;\n\t\tdp[1][1][1]=1;\n\t\tfor(int i=1;i<a;i++){\n\t\t\tdp[i+1][0][0]=(dp[i+1][0][0]+dp[i][0][0]+dp[i][1][0])%mod;\n\t\t\tdp[i+1][1][0]=(dp[i+1][1][0]+dp[i][0][0])%mod;\n\t\t\tdp[i+1][0][1]=(dp[i+1][0][1]+dp[i][0][1]+dp[i][1][1])%mod;\n\t\t\tdp[i+1][1][1]=(dp[i+1][1][1]+dp[i][0][1])%mod;\n\t\t\t\n\t\t}\n\t\tret=(dp[a][0][0]+dp[a][0][1]+dp[a][1][0])%mod;\n\t\tprintf(\"%lld\\n\",ret);\n\t\treturn 0;\n\t}\n\tif(a%2){\n\t\tprintf(\"0\\n\");return 0;\n\t}\n\tbool wolf=true;\n\tint fi=0;\n\tint tmp=0;\n\tfor(int i=0;i<b;i++){\n\t\tif(S[i]=='B'){\n\t\t\tif(wolf){\n\t\t\t\tfi=tmp;tmp=0;\n\t\t\t\twolf=false;\n\t\t\t}else{\n\t\t\t\tif(tmp%2){\n\t\t\t\t\tfi=min(fi,tmp);\n\t\t\t\t\t//printf(\"2\\n\");return 0;\n\t\t\t\t}\n\t\t\t\ttmp=0;\n\t\t\t}\n\t\t}else{\n\t\t\ttmp++;\n\t\t}\n\t}\n\ta/=2;\n\tadd(1,1);\n\t//if(fi%2)return 1;\n\tfor(int i=2;i<=a;i++){\n\t\tint L;\n\t\tL=max(1,i-1-fi/2);\n\t\tlong long tmp=sum(L,i-1);\n\t\tadd(i,tmp);\n\t}\n\tfor(int i=1;i<=a;i++){\n\t//\tif(a-i>fi)continue;\n\t\tif(a-i>fi/2)continue;\n\t//\tprintf(\"%d: %lld\\n\",i,sum(i,i));\n\t\tret=(ret+(a+1-i)*sum(i,i))%mod;\n\t}\n\tret=ret*2%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-03 17:07:09\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=200010,mod=1000000007;\nint n,m,flag,l,Flag;\ni64 f[N],F[N],ans;\nchar s[N];\nint main()\n{\n\tn=read(); m=read();\n\tscanf(\"%s\",s+1);\n\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\tif(!flag)\n\t{\n\t\tf[0]=1; f[1]=1; f[2]=2;\n\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t\treturn 0;\n\t}\n\tl=n-1;\n\tfor(int i=1,j;i<=m;)\n\t\tif(s[i]==s[1])\n\t\t{\n\t\t\tj=i;\n\t\t\twhile(s[j]==s[1]) j++;\n\t\t\tif(j>n) break;\n\t\t\tif(((j-i)&1)||(!Flag)) l=std::min(l,(j-i)+((j-i)%2==0));\n\t\t\ti=j+1; Flag=1;\n\t\t}\n\t\telse i++;\n\tif(n&1){ printf(\"0\\n\"); return 1; }\n\tn/=2; l=(l+1)/2;\n//\tprintf(\"%d %d\\n\",int(n),int(l));\n\tf[0]=F[0]=1;\n\tfr(i,1,n)\n\t{\n\t\tf[i]=(F[i-1]+mod-(i-l-1>=0?F[i-l-1]:0))%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t}\n\tans=f[n];\n\tfr(i,1,l) ans=(ans+f[n-i]*(2*i-1))%mod;\n\tprintf(\"%d\\n\",int(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\ntemplate<typename T>\nclass RangeAddQuery {\npublic:\n    explicit RangeAddQuery(int n) : N(calcN_(n)) {\n        mVal.assign(2*N+1, 0);\n    }\n    void update(int l, int r, T value){\n        l = max(0, l);\n        r = min(N, r);\n        int offset = N;\n        while(offset > 0){\n            if(l >= r) break;\n            if(l&1){ update_(mVal[offset+l-1], value); l++; }\n            if(r&1){ update_(mVal[offset+r-2], value); }\n            l /= 2;\n            r /= 2;\n            offset /= 2;\n        }\n    }\n    T get(int idx){\n        int i = N + idx - 1;\n        auto res = mVal[i];\n        while(i > 0){\n            i = (i-1)/2;\n            update_(res, mVal[i]);\n        }\n        return res;\n    }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    inline void update_(T& data, T val) { data = (data + val) % MOD; }\n    const int N;\n    vector<T> mVal;\n};\n\nint maxSegment(const string& S){\n    char c = S[0];\n    bool first = true;\n    int cnt = 0;\n    int res = MOD;\n    for(auto& s : S){\n        if(c == s) ++cnt;\n        else {\n            if(first || cnt%2 == 1){\n                res = min(res, cnt/2+1);\n                first = false;\n            }\n        }\n    }\n    return res < MOD ? res : -1;\n}\n\nint solve(const string& S, int N){\n    int seg = maxSegment(S);\n    if(seg != -1 && N%2 == 1) return 0;\n    long long res = 0;\n    if(seg == -1){\n        RangeAddQuery<long long> raq(N);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N;i++){\n            auto a = raq.get(i);\n            raq.update(i+2, N, a);\n        }\n        res = 1;\n        for(int i=N-2;i>=0;i--){\n            res = (res + raq.get(i) * (N-i)) % MOD;\n        }\n    } else {\n        RangeAddQuery<long long> raq(N/2);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N/2;i++){\n            auto a = raq.get(i);\n            raq.update(i+1, i+1+seg, a);\n        }\n        for(int i=N/2-1;i>=N/2-seg;i--){\n            res = (res + raq.get(i) * 2 * (N/2-i)) % MOD;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    cout << solve(S, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (200010)\n#define P (1000000007)\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c){\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,m,f[N]; char s[N];\nvoid spj(){\n\tint f[N][2];\n\tfor(int i=1;i<=n;i++)if(s[i]=='R')return;\n\tint ans=0; f[1][0]=0,f[1][1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tf[i][0]=f[i-1][1];\n\t\tf[i][1]=(f[i-1][0]+f[i-1][1])%P;\n\t}\n\t(ans+=(f[n][0]+f[n][1])%P)%=P;\n\tf[1][0]=1,f[1][1]=0,f[2][0]=0,f[2][1]=1;\n\tfor(int i=3;i<=n;i++){\n\t\tf[i][0]=f[i-1][1];\n\t\tf[i][1]=(f[i-1][0]+f[i-1][1])%P;\n\t}\n\t(ans+=f[n][1])%=P;\n\tprintf(\"%d\\n\",ans);\n\texit(0);\n}\nint main(){\n\tread(n),read(m);\n\tfor(int i=1;i<=m;i++)readc(s[i]);\n\tif(s[0]=='R'){for(int i=1;i<=m;i++)s[i]^='R'^'B';}\n\tspj(); int lst=m,lim=n,cnt=0; while(s[lst]=='B')lst--;\n\tfor(int i=lst;~i;i--)\n\tif(!i||s[i]=='R'){\n\t\tif(cnt&1)lim=min(lim,cnt+1);\n\t\telse if((!i)&&cnt)lim=min(lim,cnt+2);\n\t\tcnt=0;\n\t}\n\telse cnt++;\n\tf[0]=f[2]=1;\n\tfor(int i=4;i<=n;i++){\n\t\tf[i]=1ll*f[i-2]*2%P;\n\t\tif(i-2>=lim)f[i]=(f[i]-f[i-lim-2]+P)%P;\n\t}\n\tint ans=0;\n\tfor(int i=2;i<=lim;i+=2)\n\t(ans+=1ll*f[n-i]*i%P)%=P;\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 04.05.2019 15:19:43       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring to_string(string s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\nvoid debug_out() { cerr << endl; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\ntemplate <typename T>\nT inverse(T a, T m) {\n  T u = 0, v = 1;\n  while (a != 0) {\n    T t = m / a;\n    m -= t * a; swap(a, m);\n    u -= t * v; swap(u, v);\n  }\n  assert(m == 1);\n  return u;\n}\n\ntemplate <typename T>\nclass Modular {\n public:\n  using Type = typename decay<decltype(T::value)>::type;\n\n  constexpr Modular() : value() {}\n  template <typename U>\n  Modular(const U& x) {\n    value = normalize(x);\n  }\n\n  template <typename U>\n  static Type normalize(const U& x) {\n    Type v;\n    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n    else v = static_cast<Type>(x % mod());\n    if (v < 0) v += mod();\n    return v;\n  }\n\n  const Type& operator()() const { return value; }\n  template <typename U>\n  explicit operator U() const { return static_cast<U>(value); }\n  constexpr static Type mod() { return T::value; }\n\n  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n  Modular& operator++() { return *this += 1; }\n  Modular& operator--() { return *this -= 1; }\n  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n  Modular operator-() const { return Modular(-value); }\n\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n    asm(\n      \"divl %4; \\n\\t\"\n      : \"=a\" (d), \"=d\" (m)\n      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n    );\n    value = m;\n#else\n    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n    value = normalize(value * rhs.value - q * mod());\n    return *this;\n  }\n  template <typename U = T>\n  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n    value = normalize(value * rhs.value);\n    return *this;\n  }\n\n  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n  template <typename U>\n  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n  template <typename U>\n  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\n private:\n  Type value;\n};\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n  assert(b >= 0);\n  Modular<T> x = a, res = 1;\n  U p = b;\n  while (p > 0) {\n    if (p & 1) res *= x;\n    x *= x;\n    p >>= 1;\n  }\n  return res;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n  return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n  return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n  stream >> x;\n  number.value = Modular<T>::normalize(x);\n  return stream;\n}\n\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n*/\n\nconstexpr int md = (int) 1e9 + 7;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, m;\n  string s;\n  cin >> n >> m;\n  cin >> s;\n  if (s == string(m, s[0])) {\n    Mint ans = 0;\n    for (int first = 0; first < 2; first++) {\n      vector<Mint> dp(2, 0);\n      dp[first] = 1;\n      for (int i = 1; i < n; i++) {\n        vector<Mint> new_dp(2, 0);\n        for (int j = 0; j < 2; j++) {\n          for (int x = 0; x < 2; x++) {\n            if (j + x < 2) {\n              new_dp[j] += dp[x];\n            }\n          }\n        }\n        swap(dp, new_dp);\n      }\n      for (int j = 0; j < 2; j++) {\n        if (j + first < 2) {\n          ans += dp[j];\n        }\n      }\n    }\n    cout << ans << '\\n';\n    return 0;\n  }\n  if (n % 2 == 1) {\n    cout << 0 << '\\n';\n    return 0;\n  }\n  vector<int> seqs;\n  int t = 0;\n  for (int i = 0; i < m; i++) {\n    if (s[i] == s[0]) {\n      ++t;\n    } else {\n      seqs.push_back(t);\n      t = 0;\n    }\n  }\n  int bound = seqs[0];\n  if (bound % 2 == 0) {\n    ++bound;\n  }\n  for (int it = 1; it < (int) seqs.size(); it++) {\n    if (seqs[it] % 2 == 1) {\n      bound = min(bound, seqs[it]);\n    }\n  }\n  n /= 2;\n  bound /= 2;\n  Mint ans = 0;\n  if (bound == 0) {\n    ans = 1;\n  } else {\n    vector<Mint> dp(n);\n    vector<Mint> pref(n + 1);\n    dp[0] = 1;\n    pref[1] = 1;\n    for (int i = 1; i < n; i++) {\n      dp[i] = pref[i];\n      if (i - bound - 1 >= 0) {\n        dp[i] -= pref[i - bound - 1];\n      }\n      pref[i + 1] = pref[i] + dp[i];\n    }\n    for (int i = n - 1 - bound; i < n; i++) {\n      ans += dp[i] * (n - i);\n    }\n  }\n  cout << 2 * ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long word;\ntypedef pair<int, int> pi;\nconst int MAXN = 200005;\nconst int mod = 1e9 + 7;\n\nint n, m;\nint f[MAXN];\nchar s[MAXN];\n\nint main(){\n\tscanf(\"%d %d %s\",&n,&m,s);\n\tfor(int i=0; i<m; i++) if(s[i] == 'R') s[i] = 'A';\n\tif(s[0] == 'B'){\n\t\tfor(int i=0; i<m; i++) s[i] = 'A' + 'B' - s[i];\n\t}\n\tif(count(s, s + m, 'B') == 0){\n\t\tf[0] = 1; f[1] = 2;\n\t\tfor(int i=2; i<=n; i++){\n\t\t\tf[i] = f[i-1] + f[i-2];\n\t\t\tf[i] %= mod;\n\t\t}\n\t\tlint ret = f[n];\n\t\tif(n == 3) ret += mod - 1;\n\t\telse if(n >= 4) ret += mod - f[n - 4];\n\t\tret %= mod;\n\t\tcout << ret << endl;\n\t\treturn 0;\n\t}\n\tassert(0);\n\treturn 0;\n\tint alt = 1e9;\n\tint pref = 0;\n\twhile(s[pref] == 'A') pref++;\n\tfor(int i=0; i<m; i++){\n\t\tif(s[i] == 'B'){\n\t\t\tint e = i + 1;\n\t\t\twhile(s[e] == 'A') e++;\n\t\t\tif(e > i + 1 && e % 2 == i % 2){\n\t\t\t\talt = min(alt, e - i - 1);\n\t\t\t}\n\t\t\ti = e - 1;\n\t\t}\n\t}\n\talt = min(alt, pref + 1);\n\tint ret = 0;\n\tfor(int i=0; i<(1<<n); i++){\n\t\tstring t;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif((i >> j) & 1) t.push_back('B');\n\t\t\telse t.push_back('A');\n\t\t}\n\t\tbool good = 1;\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(t[j] == 'B' && t[(j+1)%n] == 'B') good = 0;\n\t\t}\n\t\trotate(t.begin(), max_element(t.begin(), t.end()), t.end());\n\t\tfor(int i=0; i<t.size(); ){\n\t\t\tif(t[i] == 'B'){\n\t\t\t\ti++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint e = i;\n\t\t\twhile(e < t.size() && t[i] == t[e]) e++;\n\t\t\tif(e - i > alt) good = 0;\n\t\t\tif((e - i) % 2 == 0) good = 0;\n\t\t\ti = e;\n\t\t}\n\t\tif(good){\n\t\t\tret++;\n\t\t}\n\t}\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nint Mn(int a,int b){return a<b?a:b;}\nconst int N=2e5+5,mod=1e9+7;\nint upt(int x){while(x>=mod)x-=mod;while(x<0)x+=mod;return x;}\n\nint n,m,lm,dp[N],sm[N],ans,f[N][5];\nchar s[N];\nvoid solve()\n{\n  f[1][0]=1;\n  for(int i=2;i<=n;i++)\n    {\n      f[i][0]=f[i-1][0];\n      f[i][1]=upt(f[i-1][1]+f[i-1][2]);\n      f[i][2]=upt(f[i-1][0]+f[i-1][1]);\n    }\n  int ans=(f[n][0]+upt(f[n][1]+f[n][2]));\n  f[1][2]=1; f[1][0]=f[1][1]=0;\n  for(int i=2;i<=n;i++)\n    {\n      f[i][1]=upt(f[i-1][1]+f[i-1][2]);\n      f[i][2]=f[i-1][1];\n    }\n  ans=upt(ans+f[n][1]); printf(\"%d\\n\",ans);\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&m);\n  scanf(\"%s\",s+1); bool fg=0;\n  for(int i=1;i<=m;i++)\n    if(s[i]!=s[1]){fg=1;break;}\n  if(!fg){solve();return 0;}\n  if(n&1){puts(\"0\");return 0;}\n  lm=n+1; int lst;\n  for(int i=m;i;i--)if(s[i]==s[1]){lst=i;break;}\n  for(int i=1;i<=m;i++)\n    if(s[i]==s[1])//== not !=\n      {\n\tint j=i;\n\twhile(j+1<=m&&s[j+1]==s[j])j++;\n\tswap(i,j); j=i-j+1;\n\tif(i-j==0) lm=Mn(lm,j+((j&1)==0));\n\telse if((j&1)&&i!=lst)lm=Mn(lm,j);//i!=lst!!!\n      }\n  n>>=1; lm=(lm+1)>>1; dp[0]=sm[0]=1;\n  for(int i=1;i<=n;i++)\n    {\n      dp[i]=sm[i-1]; if(i>lm)dp[i]=upt(dp[i]-sm[i-lm-1]);\n      sm[i]=upt(sm[i-1]+dp[i]);\n    }\n  int ans=0;\n  for(int i=1;i<=lm;i++)//lm not n\n    ans=(ans+(ll)i*2%mod*dp[n-i])%mod;\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,m;\nchar str[200050];\nconst int mod = 1000000007;\nint dp[200050];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str + 1);\n\tbool c1 = 0,c2 = 0;\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tc1 |= str[i] == 'R';\n\t\tc2 |= str[i] == 'B';\n\t}\n\tint p = 1;\n\tint lim;\n\tif(c1 && c2)\n\t{\n\t\tif(n & 1)\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(;str[p + 1] == str[1]; ++ p);\n\t\tlim = p + (p % 2 == 0);\n\t\tint len = 0;\n\t\tfor(int i = p + 1;i <= m; ++ i)\n\t\t{\n\t\t\tif(str[i] != str[1]) lim = min(lim,len % 2 ? len : 10000000),len = 0;\n\t\t\telse len ++;\n\t\t}\n\t\tlim ++;\n\t\tlim /= 2;\n\t\tint pre = 1;\n\t\tint cur = 0;\n\t\tdp[0] = 1;\n\t\tlong long ans = 0;\n\t\tfor(int i = 0;i <= n; ++ i)\n\t\t{\n\t\t\tif(i)\n\t\t\t{\n\t\t\t\twhile(i - cur > lim) pre -= dp[cur],pre = (pre + mod) % mod,cur ++;\n\t\t\t\tdp[i] = pre;\n\t\t\t\tpre += dp[i];\n\t\t\t\tpre %= mod;\n\t\t\t}\n\t\t\tif(n - i * 2 > 0 && (n - i * 2) / 2 <= lim)\n\t\t\t\tans = ans + (n - i * 2) * dp[i] % mod,ans %= mod;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse\n\t{\n\t\tint pre = 1;\n\t\tint cur = 0;\n\t\tdp[0] = 1;\n\t\tlong long ans = 0;\n\t\tfor(int i = 0;i <= n; ++ i)\n\t\t{\n\t\t\tif(i > 1)\n\t\t\t{\n\t\t\t\tdp[i] = pre;\n\t\t\t\tpre += dp[i - 1];\n\t\t\t\tpre %= mod;\n\t\t\t}\n\t\t\tif(n - i > 1)\n\t\t\t\tans = ans + (n - i) * dp[i] % mod,ans %= mod;\n\t\t}\n\t\tprintf(\"%lld\\n\",(ans + 1) % mod);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  if(vs==vector<Int>(m,1)){\n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n  assert(0);\n  \n  Int lim=n;\n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    Int j=i;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n    \n    if(i==0) chmin(lim,j-i);\n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }\n  //cout<<lim<<endl;\n  \n  vector<M> dp(n+1,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n;i++){\n    for(Int j=i-2;j>=1&&(i-j-1)<=lim;j-=2){\n      dp[i]+=dp[j];\n    }\n  }\n\n  M ans{0};\n  for(Int i=0;i<n;i++){\n    for(Int j=n;j>=n-lim;j--){\n      if(~(i+(n-j))&1) continue;\n      ans+=dp[j];      \n    }\n  }\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)//  cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ld PI = 3.14159265359;\n\nconst ll MOD = (ll) 1e9 + 7;\nconst ll MAXN = (ll) 2e5 + 10;\nconst ll INF = (ll) 2242545357980376863;\nconst ld EPS = (ld) 1e-8;\n\nvector<ll> A;\nll dp[MAXN], sm[MAXN];\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll n, m;\n\tcin >> n >> m;\n\tstr s;\n\tcin >> s;\n\t\n\tif(s[0] == 'B'){\n\t\tfor(int i = 0; i < m;i++){\n\t\t\tif(s[i] == 'R') s[i] = 'B';\n\t\t\telse s[i] = 'R';\n\t\t}\n\t}\n\tll cnt = 1;\n\tfor(int i = 1; i< m; i++){\n\t\tif(s[i] == s[i - 1]) cnt ++;\n\t\telse {\n\t\t\tA.pb(cnt);\n\t\t\tcnt = 1;\n\t\t}\n\t}\n\tA.pb(cnt);\n\tif(A.size() == 1){\n\t\t//debug(\"S\");\n\t\tdp[1] = 1;\n\t\tdp[2] = 0;\n\t\tsm[1] = 1;\n\t\tsm[2] = 1;\n\t\tfor(int i = 3; i <= n; i++){\n\t\t\tdp[i] = sm[i - 2];\n\t\t\tsm[i] = (dp[i] + sm[i - 1]) % MOD;\n\t\t}\n\t\tll ans = 1;\n\t\tfor(int len = 1; len <= n - 1; len ++){\n\t\t\tans += (len + 1ll) * dp[n - len];\n\t\t\tans %= MOD;\n\t\t}\n\t\tcout << ans;\n\t\treturn 0;\n\t\t/////\n\t}\n\t\n\tll mx;\n\t\n\tif(A[0] % 2 == 0 ) mx = A[0] + 1;\n\telse mx = A[0];\n\tfor(int i = 2; i < A.size(); i += 2){\n\t\tif(A[i] % 2 == 1) mx = max(mx, A[i]);\n\t}\n\tdebug(mx);\n\tdp[0] = 0;\n\tdp[1] = 1;\n\tdp[3] = 1;\n\tfor(int i = 5; i <= n; i++){\n\t\tdp[i] = dp[i - 2] + dp[i - 2];\n\t\tif(i >= mx + 3) dp[i] -= dp[i - mx - 3];\n\t\tdp[i] %= MOD;\n\t}\n\t//debug(dp[1]);\n\t//debug(dp[3]);\n\tll ans = 0;\n\tfor(int len = 1; len <= min(n, mx); len += 2){\n\t\tans += (len + 1ll) * dp[n - len];\n\t\tans %= MOD;\n\t}\n\tcout << ((ans % MOD) + MOD)%MOD;\n\t\n\treturn 0;\n}\n\n\n/*\n\n                                 ____              ,----..               ,----..\n   ,---,                       ,'  , `.           /   /   \\             /   /   \\\n  '  .' \\                   ,-+-,.' _ |          /   .     :           /   .     :\n /  ;    '.              ,-+-. ;   , ||         .   /   ;.  \\         .   /   ;.  \\\n:  :       \\            ,--.'|'   |  ;|        .   ;   /  ` ;        .   ;   /  ` ;\n:  |   /\\   \\          |   |  ,', |  ':        ;   |  ; \\ ; |        ;   |  ; \\ ; |\n|  :  ' ;.   :         |   | /  | |  ||        |   :  | ; | '        |   :  | ; | '\n|  |  ;/  \\   \\        '   | :  | :  |,        .   |  ' ' ' :        .   |  ' ' ' :\n'  :  | \\  \\ ,'        ;   . |  ; |--'         '   ;  \\; /  |        '   ;  \\; /  |\n|  |  '  '--'          |   : |  | ,             \\   \\  ',  /          \\   \\  ',  /\n|  :  :                |   : '  |/               ;   :    /            ;   :    /\n|  | ,'                ;   | |`-'                 \\   \\ .'              \\   \\ .'\n`--''                  |   ;/                      `---`                 `---`\n                       '---'\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n \n#include <algorithm>\n#include <tuple>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n \n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n \ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 200010, P = 1000000007;\n\nint n, m;\nchar s[N];\n\nvoid add(int& x, int y) {\n  if ((x += y) >= P)\n    x -= P;\n}\n\nvoid sub(int& x, int y) {\n  if ((x -= y) < 0)\n    x += P;\n}\n\nint norm(int x) {\n  return x >= P ? x - P : x;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n >> m >> (s + 1);\n  char a = s[1];\n  if (count(s + 1, s + m + 1, a) == m) {\n    static int dp[N][2][2];\n    dp[1][0][0] = dp[1][1][1] = 1;\n    for (int i = 2; i <= n; ++i)\n      for (int j = 0; j < 2; ++j) {\n        add(dp[i][j][0], dp[i - 1][j][0]);\n        add(dp[i][j][0], dp[i - 1][j][1]);\n        add(dp[i][j][1], dp[i - 1][j][0]);\n      }\n    int ans = norm(norm(dp[n][0][0] + dp[n][0][1]) + dp[n][1][0]);\n    cout << ans << '\\n';\n    return 0;\n  }\n  int len = m;\n  int p = 1;\n  while (s[p] == a) ++p;\n  len = p - 1;\n  if (len % 2 == 0) ++len;\n  int cur = 0;\n  for (; p <= m; ++p)\n    if (s[p] != a) {\n      if (cur & 1)\n        len = min(len, cur);\n      cur = 0;\n    } else\n      ++cur;\n  if (cur & 1) len = min(len, cur);\n  static int dp[N], sum[N];\n  dp[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    sum[i - 1] = dp[i - 1];\n    if (i - 3 >= 0)\n      add(sum[i - 1], sum[i - 3]);\n    dp[i] = sum[i - 2];\n    if (i - len - 3 > 0)\n      sub(dp[i], sum[i - len - 3]);\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; ++i)\n    if ((n - i) <= len && ((n - i) & 1))\n      ans = ans + (dp[i] * (n - i + 1LL)) % P;\n  cout << ans << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,m;\nchar str[200050];\nconst int mod = 1000000007;\nint dp[200050];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str + 1);\n\tbool c1 = 0,c2 = 0;\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tc1 |= str[i] == 'R';\n\t\tc2 |= str[i] == 'B';\n\t}\n\tint p = 1;\n\tint lim;\n\tif(c1 && c2)\n\t{\n\t\tif(n & 1)\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(;str[p + 1] == str[1]; ++ p);\n\t\tlim = p + (p % 2 == 0);\n\t\tint len = 0;\n\t\tfor(int i = p + 1;i <= m; ++ i)\n\t\t{\n\t\t\tif(str[i] != str[1]) lim = min(lim,len % 2 ? len : 10000000),len = 0;\n\t\t\telse len ++;\n\t\t}\n\t\tlim ++;\n\t\tlim /= 2;\n\t\tint pre = 1;\n\t\tint cur = 0;\n\t\tdp[0] = 1;\n\t\tlong long ans = 0;\n\t\tfor(int i = 1;i <= n; ++ i)\n\t\t{\n\t\t\twhile(i - cur > lim) pre -= dp[cur],pre = (pre + mod) % mod,cur ++;\n\t\t\tdp[i] = pre;\n\t\t\tpre += dp[i];\n\t\t\tpre %= mod;\n\t\t\tif(n - i * 2 > 0 && (n - i * 2) / 2 <= lim)\n\t\t\t\tans = ans + (n - i * 2) * dp[i] % mod,ans %= mod;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse\n\t{\n\t\tint pre = 1;\n\t\tint cur = 0;\n\t\tdp[0] = 1;\n\t\tlong long ans = 0;\n\t\tfor(int i = 1;i <= n; ++ i)\n\t\t{\n\t\t\tdp[i] = pre;\n\t\t\tpre += dp[i];\n\t\t\tpre %= mod;\n\t\t\tif(n - i > 0)\n\t\t\t\tans = ans + (n - i) * dp[i] % mod,ans %= mod;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___CLASS_MODINT\n#define ___CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::uint64_t n_) : n(n_ % mod) {};\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tstd::uint32_t get() const { return n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint binpow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tmodint inv() { return (*this).binpow(mod - 2); }\n};\n\n#endif // ___CLASS_MODINT\n\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nusing modulo = modint<1000000007>;\nconst int inf = 1012345678;\nint main() {\n\tint N, M; string S;\n\tcin >> N >> M >> S;\n\tif (S[0] == 'B') {\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (S[i] == 'B') S[i] = 'R';\n\t\t\telse S[i] = 'B';\n\t\t}\n\t}\n\tint pre = 0, mn = inf;\n\tfor (int i = 1; i < M; ++i) {\n\t\tif (pre != -1 && S[i] == 'B') {\n\t\t\tif (pre == 0 || (i - pre) % 2 == 1) mn = min(mn, i - pre + 1);\n\t\t}\n\t\telse if (i != M && pre == -1 && S[i] == 'R') pre = i;\n\t}\n\tvector<modulo> dp(N + 1);\n\tdp[1] = 1;\n\tint lim = (mn + 1) / 2 * 2;\n\tmodulo sum = 1;\n\tfor (int i = 3; i <= N; i += 2) {\n\t\tif (i - lim - 2 >= 0) sum -= dp[i - lim - 2];\n\t\tdp[i] = sum;\n\t\tsum += dp[i];\n\t}\n\tmodulo ans = 0;\n\tfor (int i = 1; i <= mn; i += 2) {\n\t\tans += dp[N - i] * (i + 1);\n\t}\n\tcout << ans.get() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___CLASS_MODINT\n#define ___CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::uint64_t n_) : n(n_ % mod) {};\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tstd::uint32_t get() const { return n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint binpow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tmodint inv() { return (*this).binpow(mod - 2); }\n};\n\n#endif // ___CLASS_MODINT\n\n#include <string>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nusing modulo = modint<1000000007>;\nconst int inf = 1012345678;\nint solve(int N, int M, string S) {\n\tif (S[0] == 'B') {\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (S[i] == 'B') S[i] = 'R';\n\t\t\telse S[i] = 'B';\n\t\t}\n\t}\n\tint pre = 0, mn = inf; bool bluemove = true;\n\tfor (int i = 1; i < M; ++i) {\n\t\tif (S[i - 1] != S[i]) {\n\t\t\tif (S[i - 1] == 'R' && (pre == 0 || (i - pre) % 2 == 1)) {\n\t\t\t\tmn = min(mn, i - pre + 1);\n\t\t\t}\n\t\t\tif (S[i - 1] == 'B' && (i - pre) % 2 == 1) {\n\t\t\t\tbluemove = false;\n\t\t\t}\n\t\t\tpre = i;\n\t\t}\n\t}\n\tif (mn == inf) {\n\t\tvector<modulo> fib(N + 3);\n\t\tfib[1] = 1;\n\t\tfor (int i = 2; i <= N + 2; ++i) {\n\t\t\tfib[i] = fib[i - 1] + fib[i - 2];\n\t\t}\n\t\tmodulo ans = fib[N + 2] - fib[N - 2];\n\t\treturn ans.get();\n\t}\n\telse if (bluemove) {\n\t\tvector<modulo> dp1(N + 1), dp2(N + 1);\n\t\tdp2[0] = 1;\n\t\tfor (int i = 1; i <= N; ++i) {\n\t\t\tdp1[i] = dp1[i - 1] + dp2[i - 1];\n\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\tif ((i - j) % 2 == 1 && i - j <= mn) {\n\t\t\t\t\tdp2[i] += dp1[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmodulo ans = dp1[N];\n\t\tfor (int i = 1; i <= mn && i <= N; i += 2) {\n\t\t\tans += dp1[N - i] * (i + 1);\n\t\t}\n\t\treturn ans.get();\n\t}\n\telse {\n\t\tvector<modulo> dp(N + 1);\n\t\tdp[1] = 1;\n\t\tint lim = (mn + 1) / 2 * 2;\n\t\tmodulo sum = 1;\n\t\tfor (int i = 3; i <= N; i += 2) {\n\t\t\tif (i - lim - 2 >= 0) sum -= dp[i - lim - 2];\n\t\t\tdp[i] = sum;\n\t\t\tsum += dp[i];\n\t\t}\n\t\tmodulo ans = 0;\n\t\tfor (int i = 1; i <= mn && i <= N; i += 2) {\n\t\t\tans += dp[N - i] * (i + 1);\n\t\t}\n\t\treturn ans.get();\n\t}\n\treturn -1;\n}\nint main() {\n\tint N, M; string S;\n\tcin >> N >> M >> S;\n\tcout << solve(N, M, S) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\n\n\nconst int MAX = 501010;\nconst int MOD = 1000000007;\nusing mint = Fp<MOD>;\n\nint N, M;\nstring S;\n\nmint solve() {\n    BiCoef<mint> bc(MAX);\n    if (S[0] == 'R') {\n        for (auto &c : S) {\n            if (c == 'R') c = 'B';\n            else c = 'R';\n        }\n    }\n    vector<int> nums;\n    for (int i = 0; i < M;) {\n        int j = i+1;\n        while (j < M && S[j] == S[i]) ++j;\n        nums.push_back(j-i);\n        i = j;\n    }\n    if (nums.size() > 1 && N % 2 == 1) return 0;\n\n    int minv = 1, maxv = N;\n    if (nums.size() == 1) minv = 2, maxv = N;\n    else {\n        N /= 2;\n        maxv = nums[0] / 2 + 1;\n        for (int i = 0; i+1 < nums.size(); i += 2) {\n            if (nums[i] & 1) maxv = min(maxv, (nums[i] + 1) / 2);\n        }\n    }\n    //COUT(maxv); COUT(N);\n\n    vector<mint> dp(N+1, 0), sdp(N+2, 0);\n    dp[0] = 1, sdp[1] = 1;\n    for (int i = 1; i <= N; ++i) {\n        dp[i] = sdp[max(0, i + 1 - minv)] - sdp[max(0, i - maxv)];\n        sdp[i+1] = sdp[i] + dp[i];\n\n        //cout << i << \": \" << dp[i] << endl;\n    }\n    mint res = 0;\n    if (nums.size() == 1) {\n        for (int r = minv; r <= min(maxv, N); ++r) res += dp[N-r] * r;\n        res += 1; // all B\n    }\n    else {\n        for (int r = minv; r <= min(maxv, N); ++r) res += dp[N-r] * r * 2;\n    }\n    return res;\n}\n\nint main() {     \n    while (cin >> N >> M >> S) {\n        cout << solve() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint int\nusing namespace std;\n     \ntypedef long long lo;\n     \ntemplate<typename tp> inline void read(tp &x) {\n\tx = 0; char c = getchar(); int f = 0;\n\tfor (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n\tfor (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n\tif (f) x = -x;\n}\nnamespace {\n    const int mo = 1e9 + 7;\n    inline int add(int x, int y) { x += y; return x >= mo ? x - mo : x; }\n    inline int sub(int x, int y) { x -= y; return x < 0 ? x + mo : x; }\n    inline int mul(int x, int y) { return (lo) x * y % mo; }\n    inline int power(int a, int k = mo - 2) {\n\t\tint ans = 1;\n\t\tfor (; k; k >>= 1, a = mul(a, a))\n\t\t\tif (k & 1) ans = mul(ans, a);\n\t\treturn ans;\n    }\n\tinline void U(int &x, int y) { x = add(x, y); } \n}\n\nconst int N = 3e5 + 23;\nint n, m;\nchar str[N];\n\ninline int spj() {\n\tint ans = 0;\n\tfor (int fi = 0; fi < 2; fi++) {\n\t\tvector <vector <int> > dp(n + 1, vector <int> (2, 0));\n\t\tdp[1][fi] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tU(dp[i][0], dp[i - 1][1]);\n\t\t\tU(dp[i][0], dp[i - 1][0]);\n\t\t\tU(dp[i][1], dp[i - 1][0]);\n\t\t\t// cout << dp[i][0] << \" \" << dp[i][1] << \"\\n\";\n\t\t}\n\t\tif (fi == 0) ans = add(ans, add(dp[n][0], dp[n][1]));\n\t\telse ans = add(ans, dp[n][0]);\n\t}\n\treturn ans;\n}\n\ninline int doit(int limit) {\n\t++limit;\n\tvector <int> dp(n + 1, 0);\n\tvector <int> sum(n + 1, 0);\n\tdp[0] = sum[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tauto getsum = [&](int l, int r) {\n\t\t\tif ((l & 1) != (r & 1)) ++l;\n\t\t\tif (l > r || r < 0) return 0;\n\t\t\telse return sub(sum[r], l >= 2 ? sum[l - 2] : 0);\n\t\t};\n\t\t// for (int k = i - 2; k >= 0 && k >= i - limit; k -= 2)\n\t\t// \tU(dp[i], dp[k]);\n\t\tU(dp[i], getsum(max(0, i - limit), i - 2));\n\t\tsum[i] = dp[i];\n\t\tif (i > 1) U(sum[i], sum[i - 2]);\n\t}\n\tint ans = 0;\n\tfor (int pre = 2; pre <= limit; pre += 2) {\n\t\tU(ans, mul(pre, dp[n - pre]));\n\t}\n\treturn ans;\n}\n\nint main(void) {\n\tread(n); read(m);\n\tscanf(\"%s\", str + 1);\n\tint first = 0;\n\tfor (int i = 1; i <= m; i++) \n\t\tif (str[i] != str[1]) { first = i; break; }\n\tif (first == 0) {\n\t\tcout << spj() << \"\\n\";\n\t\treturn 0;\n\t}\n\t--first;\n\twhile (m && str[m] == str[1]) --m;\n\t// cout << \"first = \" << first << \"\\n\";\n\tint limit = first & 1 ? first : first + 1;\n\tint con = limit;\n\tfor (int i = first + 1; i <= m; i++) {\n\t\tif (str[i] != str[1]) {\n\t\t\tif (con & 1) limit = min(limit, con);\n\t\t\tcon = 0;\n\t\t} else {\n\t\t\t++con;\n\t\t}\t\t\t   \n\t}\n\tif (con & 1) limit = min(limit, con);\n\tcerr << \"limit = \" << limit << \"\\n\";\n\tcout << doit(limit) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nconst int mod=1e9+7;\n\nvoid U(int &x,int y){\n    x=(x+y)%mod;\n}\n\nint n, m, a[202000];\nchar s[202000];\n\nint main(){\n    cin>>n>>m>>s+1;\n    for (int i=1;i<=m;++i)\n        a[i]= s[i]==s[1];\n    if (*min_element(a+1,a+m+1)==1){\n        static int f[202000][2][2];\n        f[1][0][0]=f[1][1][1]=1;\n        for (int i=1;i<n;++i){\n            for (int s=0;s<=1;++s)\n                for (int t=0;t<=1;++t)\n                    for (int tt=0;tt<=1;++tt){\n                        if (t==0&&tt==0) continue;\n                        U(f[i+1][s][tt],f[i][s][t]);\n                    }\n        }\n        int ans=(1ll*f[n][0][1]+f[n][1][0]+f[n][1][1])%mod;\n        cout<<ans<<endl;\n        return 0;\n    }\n    int las=0, mx=1e9; vector<int>vec;\n    for (int i=1;i<=m;++i)\n        if (a[i]){\n            ++las;\n        }else{\n            vec.push_back(las);\n            las=0;\n        }\n    {\n        int t=vec.front(); vec.erase(vec.begin());\n        mx=min(mx,(t&1? t: t+1));\n    }\n    for (auto t:vec){\n        if (t&1) mx=min(mx,t);\n    }\n\n\n    static int ans=0, f[202000], sum[202000];\n    f[1]=sum[1]=1;\n    for (int i=1;i<=n;++i){\n        if (i!=1){\n            f[i]=(sum[i-2]-sum[max(0,i-mx-3)]+mod)%mod;\n            sum[i]=(sum[i-2]+f[i])%mod;\n        }\n        if ((n-i&1)&&n-i<=mx){\n            ans=(ans+(ll)f[i]*(n-i+1))%mod;\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n \nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 1e9 + 7;\n \nint n, m;\nchar S[200005];\nvector<int> sizs;\nint dp[200005], prs[200005];\n\nint main()\n{\n\tscanf(\"%d%d%s\", &n, &m, S);\n\t\n\tint ccnt = 1;\n\tfor(int i = 1; i < m; i ++)\n\tif(S[i] != S[i - 1]) {\n\t\tsizs.push_back(ccnt);\n\t\tccnt = 1;\n\t} else ccnt ++;\n\tsizs.push_back(ccnt);\n\t\n\tif(sizs.size() == 1) {\n\t\tdp[1] = 2;\n\t\tdp[2] = MOD - 1;\n\t\trep(i, n) {\n\t\t\tif(i >= 1) dp[i] = (dp[i] + dp[i - 1]) % MOD;\n\t\t}\n\t\trep(i, n) {\n\t\t\tif(i >= 1) dp[i] = (dp[i] + dp[i - 1]) % MOD;\n\t\t\tif(i >= 2) dp[i] = (dp[i] + dp[i - 2]) % MOD;\n\t\t}\n\t\tprintf(\"%d\\n\", dp[n - 1] + 1);\n\t} else {\n\t\tint maxl = min(n, sizs[0] + 2);\n\t\trep(i, sizs.size()) if(i < sizs.size() && !(i & 1) && sizs[i] & 1)\n\t\tmaxl = min(maxl, sizs[i] + 1);\n\t\t\n\t\trep1(i, maxl) if(!(i & 1)) dp[i] = i;\n\t\t\n\t\trep1(i, n) {\n\t\t\tif(i >= 2) dp[i] = (dp[i] + prs[i - 2]) % MOD;\n\t\t\tif(i >= 2 + maxl) dp[i] = (dp[i] + (MOD - 1LL) * prs[i - 2 - maxl]) % MOD;\n\t\t\tif(i >= 2) prs[i] = (dp[i] + prs[i - 2]) % MOD;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", dp[n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nLL dp[SIZE][2][2];\nvoid solve_same(int N){\n    dp[1][0][0]=1;\n    dp[1][1][1]=1;\n    REPP(i,1,N){\n        REP(j,2){\n            ADD(dp[i+1][j][0],dp[i][j][1]);\n            ADD(dp[i+1][j][1],dp[i][j][0]);\n            ADD(dp[i+1][j][1],dp[i][j][1]);\n        }\n    }\n    LL an=0;\n    ADD(an,dp[N][0][1]);\n    ADD(an,dp[N][1][1]);\n    ADD(an,dp[N][1][0]);\n    W(an);\n}\nLL mypow(LL x,LL y){\n    x%=MOD;\n    LL res=1%MOD;\n    while(y){\n        if(y&1)res=res*x%MOD;\n        y>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nLL dp2[SIZE],dp2_sum[SIZE];\nvoid solve(int ma,int N){\n    LL an=0;\n    if(ma+1>=N){\n        ADD(an,(mypow(2,N/2)-1)*2);\n    }\n    else{\n        ma=(ma+1)/2;\n        dp2[0]=dp2_sum[0]=1;\n        FOR(i,1,N/2){\n            dp2_sum[i]=dp2_sum[i-1];\n            dp2[i]=dp2_sum[i-1];\n            if(i>ma)ADD(dp2[i],-dp2_sum[i-ma-1]);\n            ADD(dp2_sum[i],dp2[i]);\n        }\n        ADD(an,dp2[N/2]);\n        FOR(i,2,ma){\n            ADD(an,(i-1)*dp2[N/2-i]);\n        }\n        ADD(an,an);\n    }\n    W(an);\n}\nint main(){\n    int N,M; R(N,M);\n    string s; R(s);\n    bool same=1;\n    REPP(i,1,M){\n        if(s[i]!=s[i-1])same=0;\n    }\n    if(same)solve_same(N);\n    else{\n        if(N%2){\n            W(0);\n            return 0;\n        }\n        VI AA;\n        for(int i=0,j;i<M;i=j){\n            for(j=i+1;j<M&&s[j]==s[i];j++);\n            if(s[i]==s[0]&&j!=M)AA.PB(j-i);\n        }\n        int ma=-1;\n        if(AA[0]%2)ma=AA[0];\n        else ma=AA[0]+1;\n        REPP(i,1,SZ(AA)){\n            if(AA[i]%2==1)ma=min(ma,AA[i]);\n        }\n        solve(ma,N);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i <= vec.size() + 1;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n    d=0;int f=1;char c=getchar();\n    for(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n    for(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n    d*=f;\n}\n\n/************************************************/\n#define Md 1000000007\n#define MN 200005\nint n,m;\nchar c[MN];\nlg Pow(lg x,lg y){\n    lg res=1;for(;y;y>>=1,x=x*x%Md)if(y&1)res=res*x%Md;return res;\n}\nint Fix(int x){\n    if(x<0)return x+Md;\n    if(x>=Md)return x-Md;\n    x%=Md;\n    return x;\n}\nint dp[MN],tmp[MN];\nint miu[MN];\nint main(){\n    read(n);read(m);\n    scanf(\"%s\",c+1);\n    miu[1]=1;\n    for(int i=1;i<MN;++i){\n\tfor(int j=i+i;j<MN;j+=i){\n\t    miu[j]-=miu[i];\n\t}\n    }\n    char Hd=c[1];\n    int cnt=0,mx;\n    for(int i=1;i<=m;++i){\n\tif(c[i]==Hd)++cnt;\n\telse break;\n    }\n    if(cnt&1)mx=cnt;else mx=cnt+1;\n    if(n&1){\n\tif(cnt!=m)return puts(\"0\"),0;\n\tint res=0;\n\ttmp[0]=tmp[1]=1;\n\tdp[0]=1;\n\tmx+=2;\n\tfor(int i=0;i<=n;++i){\n\t    if(i)\n\t    {\n\t\tdp[i]=(i>=2?tmp[i-2]:0);\n\t\ttmp[i]=Fix(tmp[i-1]+dp[i]);\n\t    }\n\t    if(n-i>=2)\n\t    {\n\t\tres=(res+dp[i]*(n-i)%Md)%Md;\n\t    }\n\t}\n\tprintf(\"%d\",res+1);\n\treturn 0;\n    }\n    int res=(cnt==m);\n    cnt=0;\n    for(int i=1;i<=m;++i)\n    {\n\tif(c[i]==Hd)++cnt;\n\telse\n\t{\n\t    if(cnt&1)mx=min(mx,cnt);\n\t    cnt=0;\n\t}\n    }\n    //for(int i=1;i<=5;++i)cerr<<miu[i]<<' ';cerr<<endl;\n    tmp[0]=tmp[1]=1;\n    dp[0]=1;\n    mx+=2;\n    for(int i=2;i<n;i+=2)\n    {\n\tdp[i]=Fix(tmp[i-1]-(mx>i?0:tmp[i-mx]));\n\ttmp[i]=tmp[i+1]=Fix(tmp[i-2]+dp[i]);\n\tif(n-i<=mx)\n\t{\n\t    res=(res+dp[i]*(n-i)%Md)%Md;\n\t}\n    }\n    cout<<res;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define prev azaza\n#define MP make_pair\n#define PB push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int max_n = 200111, inf = 1000111222;\nconst ll mod = 1000000007;\n\nint n, m;\nstring s;\n\nll dp[max_n];\nll pr[max_n];\nll dp2[max_n];\n\nll solve_allr() {\n    ll ans = 1;\n    dp[1] = 1;\n    dp[2] = 0;\n    ll sum = dp[1];\n    for (int i = 3; i < max_n; ++i) {\n        dp[i] = sum;\n        sum += dp[i - 1];\n        sum %= mod;\n    }\n    for (int len = 1; len < n; ++len) {\n        ans += dp[n - len] * (len + 1);\n        ans %= mod;\n    }\n    return ans;\n}\n\nll solve(int L) {\n    int L1 = L / 2;\n    pr[0] = 0;\n    pr[1] = 1;\n    dp2[1] = 1;\n    for (int i = 2; i < max_n; ++i) {\n        dp2[i] = pr[i - 1] - pr[max(1, i - L1 - 1) - 1];\n        pr[i] = pr[i - 1] + dp2[i];\n        pr[i] %= mod;\n    }\n    dp[1] = 1;\n    for (int i = 3; i < max_n; i += 2) {\n        dp[i] = dp2[i / 2 + 1];\n    }\n    ll ans = 0;\n    for (int len = 1; len <= L; len += 2) {\n        ans += dp[n - len] * (len + 1);\n    }\n    return ans;\n}\n\nint main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> m;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (int i = 0; i < s.size(); ++i) {\n            s[i] = (s[i] == 'B' ? 'R' : 'B');\n        }\n    }\n    bool allr = 1;\n    for (char c : s) {\n        if (c == 'B') {\n            allr = 0;\n            break;\n        }\n    }\n    if (allr) {\n        cout << solve_allr() << endl;\n        return 0;\n    }\n    if (n % 2 == 1) {\n        cout << 0 << endl;\n        return 0;\n    }\n    while (s.back() == 'R') {\n        s.pop_back();\n    }\n    int L = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] == 'B') {\n            break;\n        } else {\n            ++L;\n        }\n    }\n    if (L % 2 == 0) {\n        ++L;\n    }\n    int len = 1;\n    for (int i = L; i < s.size(); ++i) {\n        if (s[i] == s[i - 1]) {\n            ++len;\n        } else {\n            if (s[i] == 'B' && len % 2 == 1) {\n                L = min(L, len);\n            }\n            len = 1;\n        }\n    }\n    cout << solve(L) << endl;\n    return 0;\n}\n\n// think 2:06\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  if(vs==vector<Int>(m,1)){\n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n\n  if(n&1){\n    cout<<0<<endl;\n    return 0;\n  }\n  assert(0);\n  \n  Int lim=n;  \n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    Int j=i;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n    \n    if(i==0) chmin(lim,j-i);\n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }\n  \n  cout<<lim<<endl;\n  \n  vector<M> dp(n+1,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n;i++){\n    for(Int j=i-2;j>=1&&j>=i-1-lim;j-=2){      \n      dp[i]+=dp[j];\n    }\n    cout<<i<<\":\"<<dp[i].v<<endl;\n  }\n\n  M ans{0};\n  for(Int i=0;i<n;i++){\n    for(Int j=n-i;j>=1&&j>=n-lim;j--){\n      if(~(n-j)&1) continue;\n      ans+=dp[j];      \n    }\n  }  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\n\nint main() {\n\tll N, M;\n\tcin >> N >> M;\n\tstring S;\n\tcin >> S;\n\n\tll c = S[0];\n\n\tll K = -1;\n\trep(i, M) {\n\t\tif (S[i] != c) { K = i; }\n\t}\n\t\n\tif (K == -1) {\n\t\tvmint dp(N + 1, 0);\n\t\tdp[0] = 1;\n\t\tdp[1] = 2;\n\n\t\tfor (ll i = 2; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 2] + dp[i - 1];\n\t\t}\n\n\t\tmint ans = dp[N - 1];\n\t\tif (N == 1) { ans += dp[N - 1]; }\n\t\tif (N >= 3) { ans += dp[N - 3]; }\n\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\tif (N % 2 != 0) { cout << 0 << endl; return 0; }\n\n\tvll ren(K + 1, 0);\n\trep(i, K + 1) {\n\t\tif (S[i] != c) { ren[i] = 0; }\n\t\telse if (i == 0) { ren[i] = 1; }\n\t\telse { ren[i] = ren[i - 1] + 1; }\n\t}\n\n\tll mn = INF;\n\trep(i, K) {\n\t\tif (ren[i + 1] == 0) {\n\t\t\tif (ren[i] % 2 == 1) { mn = min(ren[i], mn); }\n\t\t\tif (ren[i] == i + 1) { mn = min(ren[i]+ 1, mn); }\n\t\t\t}\n\t}\n\n\t//cout << mn << endl;\n\n\tN /= 2;\n\tmn = (mn - 1) / 2;\n\n\tvmint dp(N + 1, 0), rdp(N + 1, 0);\n\tdp[0] = 1;\n\trdp[0] = 1;\n\n\trepn(i, N) {\n\t\tif (i <= mn + 1)dp[i] = rdp[i - 1];\n\t\telse dp[i] = rdp[i - 1] - rdp[i - mn - 2];\n\n\t\trdp[i] = rdp[i - 1] + dp[i];\n\n\t\t//cout << i << dp[i] << rdp[i] << endl;\n\t}\n\n\tmint ans = 0;\n\tif (mn >= N) { ans = pw(2, N); }\n\telse if (mn == N - 1) { ans = pw(2, N) - 1; }\n\telse {\n\t\trep(i, mn + 1) {\n\t\t\tans += rdp[N - i - 1] - rdp[N - mn - 2];\n\t\t}\n\t}\n\tans *= 2;\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int mo=1e9+7,N=2e5+5;\nint n,m,i,j,ans,lm=N,f[N],s[N];\nchar c[N];\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,c+1);\n\tfor(i=1;c[i]==c[1];++i);\n\tif(i>m){\n\t\tstatic int f[N][2];\n\t\tf[0][0]=1;\n\t\tfor(i=1;i<=n;++i)f[i][0]=(f[i-1][0]+f[i-1][1])%mo,f[i][1]=f[i-1][0];\n\t\tans=f[n][0];\n\t\tmemset(f,0,sizeof f);\n\t\tf[0][1]=1;\n\t\tfor(i=1;i<=n;++i)f[i][0]=(f[i-1][0]+f[i-1][1])%mo,f[i][1]=f[i-1][0];\n\t\tans=(ans+f[n][1])%mo;\n\t}else{\n\t\tlm=i&1?i:i-1;\n\t\tfor(;i<=m;i=j){\n\t\t\tfor(j=i+1;c[j]==c[1];++j);\n\t\t\tif(j<=m && (j-i-1)%2==1)lm=std::min(lm,j-i-1);\n\t\t}\n\t\tif(n&1){puts(\"0\");return 0;}\n\t\tlm-=lm%2==0;lm=lm+1>>1;\n\t\ts[0]=f[0]=1;\n\t\tfor(i=1;i<=n;++i)f[i]=(s[i-1]+mo-(i>lm?s[i-lm-1]:0))%mo,s[i]=(s[i-1]+f[i])%mo;\n\t\tfor(i=1;i<=lm*2-1 && i+1<=n;i+=2)ans=(ans+1ll*(i+1)*f[n-i-1>>1])%mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//I forgot you...\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = (int)1e9 + 7;\nconst int MAXN = (int)2e5 + 3;\nconst int infint = (int)1e9 + 3;\nconst ll inf = (ll)1e18;\nint n, m, ans, mika = infint, dp[MAXN], part[MAXN];\nstring s;\nint add(int a, int b)\n{\n\tint c = a + b;\n\tif(c >= MOD)\n\t\tc -= MOD;\n\tif(c < 0)\n\t\tc += MOD;\n\treturn c;\n}\nint mul(int a, int b)\n{\n\tint c = 1LL * a * b % MOD;\n\treturn c;\n}\nvoid find_mika()\n{\n\tif(s[0] == 'R')\n\t{\n\t\tint ted = 0;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tif(s[i] == 'R')\n\t\t\t\tted++;\n\t\t\telse\n\t\t\tif(s[i] == 'B' && ted > 0)\n\t\t\t{\n\t\t\t\tif(ted % 2)\t\n\t\t\t\t\tmika = min(mika, ted);\n\t\t\t\telse\n\t\t\t\t\tmika = min(mika, ted + 1);\n\t\t\t\tted = 0;\n\t\t\t}\n\t\tif(ted > 0)\n\t\t{\n\t\t\tif(ted % 2)\n\t\t\t\tmika = min(mika, ted);\n\t\t\telse\n\t\t\t\tmika = min(mika, ted + 1);\n\t\t}\n\t}\n\telse\n\t{\n\t\tint ted = 0;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tif(s[i] == 'B')\n\t\t\t\tted++;\n\t\t\telse\n\t\t\tif(s[i] == 'R' && ted > 0)\n\t\t\t{\n\t\t\t\tif(ted % 2)\n\t\t\t\t\tmika = min(mika, ted);\n\t\t\t\telse\n\t\t\t\t\tmika = min(mika, ted + 1);\n\t\t\t\tted = 0;\n\t\t\t}\n\t\tif(ted > 0)\n\t\t{\n\t\t\tif(ted % 2)\n\t\t\t\tmika = min(mika, ted);\n\t\t\telse\n\t\t\t\tmika = min(mika, ted + 1);\n\t\t}\n\t}\n}\nint getzarib(int kaman)\n{\n\tint emp = n - kaman;\n\tif(emp == 0)\n\t\treturn 1;\n\telse\n\t\treturn n - emp;\n}\nint main()\n{\n\tios::sync_with_stdio(false); \n\tcin.tie(0); cout.tie(0);\n\tcin >> n >> m >> s;\n\tfind_mika();\n\tbool flg = 1;\n\tfor (int i = 1; i < m; i++)\n\t\tif(s[i] != s[0])\t\n\t\t\tflg = 0;\n\tif(flg)\n\t{\n\t\tdp[1] = 1, dp[2] = 2;\n\t\tfor (int i = 3; i <= n; i++)\n\t\t\tdp[i] = add(dp[i - 1], dp[i - 2]);\n\t\t\n\t\tans = dp[n];\n\t\tif(n >= 3)\n\t\t\tans = add(ans, dp[n - 2]);\n\t\tcout << ans;\n\t\treturn 0;\n\t}\n\tdp[0] = 1;\n\tpart[0] = 1;\n\tfor (int i = 2; i <= n; i += 2)\n\t{\n\t\tdp[i] = part[i - 2];\n\t\tif(i - mika - 3 >= 0)\n\t\t\tdp[i] = add(dp[i], -part[i - mika - 3]);\n\t\tpart[i] = add(part[i - 2], dp[i]);\n\t}\n\tans = add(ans, dp[n]);\n\tfor (int i = 1; i <= mika; i += 2)\n\t\tif(i != n - 2 && i != n)\n\t\t\tans = add(ans, mul(getzarib(i), dp[n - i - 1]));\n\t\telse\n\t\tif(i == n)\n\t\t\tans = add(ans, 1);\n\tcout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt all(Int n) {  // no bb\n  Int rr = 1, bb = 1, rb = 0, br = 0;\n  for (int i = 1; i < n; i++) {\n    Int nrr = (rr + rb) % MOD;\n    Int nbb = br;\n    Int nrb = rr;\n    Int nbr = (bb + br) % MOD;\n    rr = nrr;\n    bb = nbb;\n    rb = nrb;\n    br = nbr;\n  }\n  return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit) {\n  dp[0] = 1;\n  rdp[0] = 1;\n  for (int i = 1; i <= n + 1; i++) {\n    dp[i] =\n        (rdp[i - 1] - ((i - limit - 1) >= 0 ? rdp[i - limit - 1] : 0)) % MOD;\n    if (dp[i] < 0) dp[i] += MOD;\n    rdp[i] = (rdp[i - 1] + dp[i]) % MOD;\n  }\n}\n\nInt solve(Int n, Int limit) {\n  if (n % 2 == 1) return 0;\n  if (limit % 2 != 1) exit(1);\n  limit = (limit + 1) / 2;\n  n /= 2;\n  Int res = 0;\n  calc(n + 10, limit);\n  for (Int i = 1; i <= limit; i++) {\n    if (n - i >= 0) res = (res + dp[n - i] * 2 * i) % MOD;\n  }\n  if (res < 0) exit(1);\n  return res % MOD;\n}\n\nint main() {\n  Int n, m;\n  string str;\n  vector<Int> vec;\n  cin >> n >> m;\n  cin >> str;\n  bool allsame = true;\n  for (int i = 0; i < m; i++) allsame &= (str[i] == str[0]);\n  if (allsame) {\n    cout << all(n) << endl;\n    return 0;\n  }\n  for (int i = 0; i < m; i++) vec.push_back(str[i] == str[0]);\n  // vec.push_back(0);\n  Int l = 0;\n  while (vec[l] == 1) l++;\n  if (l % 2 == 0) l++;\n  Int limit = l;\n  l = 0;\n  for (int i = 0; i < vec.size(); i++) {\n    if (vec[i] == 1)\n      l++;\n    else {\n      if (l % 2 == 1) limit = min(limit, l);\n      l = 0;\n    }\n  }\n  cout << solve(n, limit) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 500008\n#define mod 1000000007\nchar str[nn];int n,m;\nlong long dp[nn],sum[nn];\n#define err return 0*puts(\"0\");\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str+1);\n\t\n\tint cnt=0;\n\tif(str[1]=='B') for(int i=1;i<=m;i++) if(str[i]=='R') str[i]='B';else str[i]='R';\n\tfor(int i=1;i<=m;i++) if(str[i]=='B') cnt++;\n\tint mx=n;int flg=0;\n\tif(cnt)\n\t{\n\t\tcnt=0;\n\t\tif(n%2) err;int j=1;\n\t\tfor(int i=m;i>=1;i--)\n\t\t\tif(str[i]=='B')  {for(int j=i;j<=m;j++) str[j]='B';break;}\n\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(str[i]=='B') break;\n\t\t\tcnt++;j=i;\n\t\t}\n\t\tmx=min(mx,cnt/2+1);\n\t\t\n\t\tj++;\n\t\tcnt=0;str[m+1]='B';\n\t\tfor(;j<=m+1;j++)\n\t\t{\n\t\t\tif(str[j]=='B')\n\t\t\t{\n\t\t\t\tif(cnt%2) mx=min(mx,cnt/2+1);\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t\telse cnt++;\n\t\t}\n\t\tflg=1;\n\t\tn/=2;\n\t}\n\t\n\tdp[0]=sum[0]=1;\n\tint ls=0;if(!flg) ls=1,sum[1]=1;\n\tfor(int i=ls+1;i<=n;i++) \n\t{\n\t\tif(i-mx-1>=0 and flg) dp[i]=(sum[i-1-ls]-sum[i-mx-1]+mod)%mod;\n\t\telse dp[i]=sum[i-1-ls];\n\t\tsum[i]=(sum[i-1]+dp[i])%mod;\n\t}\n\tlong long ans=0;\n\tfor(int i=1+ls;i<=n and i<=mx;i++)\n\t{\n\t\tans+=1ll*dp[n-i]*i%mod;\n\t\tif(flg) ans+=1ll*dp[n-i]*i%mod;\n\t\tans%=mod;\n\t}\n\tif(ls==1) ans++;\n\t\n\tprintf(\"%lld\\n\",(ans%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \n#define mod 1000000007\n\nusing namespace std;\nconst int N=200010;\nint n,m,ans,f[N],g[N];\nchar s[N];\n\nvoid inc(int&x,int y){x+=y;if(x>=mod)x-=mod;}\nvoid dec(int&x,int y){x-=y;if(x<0)x+=mod;}\n\nint main(){\n//\tfreopen(\"E.in\",\"r\",stdin);\n//\tfreopen(\"E.out\",\"w\",stdout);\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tint p=0;while(p<m&&s[p+1]==s[1])++p;\n\tif(p==m){\n\t\tans=f[0]=g[0]=1;\n\t\tfor(int i=0;i<=n;++i){\n\t\t\tif(i>1)f[i]=g[i-2];\n\t\t\tif(i)g[i]=(g[i-1]+f[i])%mod;\n\t\t\tif(n-i!=1)inc(ans,(ll)(n-i)*f[i]%mod);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}else{\n\t\tif(n&1)puts(\"0\"),exit(0);\n\t\tint L=p|1;\n\t\twhile(1){\n\t\t\tint tmp=0;\n\t\t\twhile(p<m&&s[p+1]!=s[1])++p;tmp-=p;\n\t\t\twhile(p<m&&s[p+1]==s[1])++p;tmp+=p;\n\t\t\tif(p==m)break;\n\t\t\tif(tmp&1)L=min(L,tmp);\n\t\t}\n\t\tf[0]=g[0]=1;\n\t\tL=(L+1)>>1;n>>=1;\n\t\tfor(int i=0;i<=n;++i){\n\t\t\tif(i)f[i]=g[i-1];\n\t\t\tif(i>L)dec(f[i],g[i-L-1]);\n\t\t\tif(i)g[i]=(g[i-1]+f[i])%mod;\n\t\t\tif(n-i<=L)inc(ans,(ll)(n-i)*f[i]%mod);\n\t\t}\n\t\tcout<<ans*2%mod<<endl;\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"base.hpp\"//5\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//5b\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n#line 1 \"mod.hpp\"//5b\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//5bm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//5b\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//5b\nusing unit = tuple<>;using int128=__int128;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing VM=vec<mint>;using VI=vec<int>;\n#line 1 \"alias.hpp\"//5b\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//5b\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nnamespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}TL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){\nRT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//5b\nTL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)\n#line 6001 \"base.hpp\"//5\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1001 \"5.cpp\"//\n//#include \"consts.hpp\"\n// #include \"prime.hpp\"\n\nvoid solve() {\n// NM\"S\"\n/* <foxy.memo-area> */\nint N;int M;string S;cin>>N;cin>>M;cin>>S;\n/* </foxy.memo-area> */\n\n  if(S[0] == 'B') {\n    times(M, i) S[i] = 'R' + 'B' - S[i];\n  }\n\n  int p = 1ll << 60;\n  {\n    int ren = 1;\n    times(M, i) {\n      if(S[i] == 'R') {\n        ++ren;\n      } else {\n        if(p == 0 || ren % 2 == 1) {\n          amin(p, ren);\n        }\n        ren = 0;\n      }\n    }\n    if(p == 0 || ren % 2 == 1) {\n      amin(p, ren);\n    }\n  }\n  {if(debug)cerr<<\"p: \"<<(p)ln;}\n#define M hoge\n\n  if(p > N) {\n    mint ans = 0_m;\n    {\n      // [0]->R\n      VM dp(N);\n      dp[0] = 1_m;\n      dp[1] = 2_m;\n      uptil(2, N, i) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n      }\n      ans += dp[N - 1];\n      {if(debug)cerr<<\"dp: \"<<(dp)ln;}\n    }\n    {\n      // [0]->B\n      VM dp(N - 1);\n      dp[0] = 1_m;\n      if(N >= 3) dp[1] = 1_m;\n      uptil(2, N - 1, i) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n      }\n      ans += dp[N - 2];\n      {if(debug)cerr<<\"dp: \"<<(dp)ln;}\n    }\n\n    cout << ans ln;\n    return;\n  }\n\n  if(N % 2 == 1) {\n    cout << 0 ln;\n    return;\n  }\n\n  int m = N / 2;\n  int q = (p + 1) / 2;\n\n#define N hoge\n#define p hoge\n\n  /*\n  auto pfh = prime_factor(m);\n  int zpf = size(pfh);\n  VI pf; pf.reserve(zpf);\n  for(auto &p : pfh) pf.PB(p.first);\n  {if(debug)cerr<<\"pf: \"<<(pf)ln;}\n  */\n\n  /*\n  VI pf;\n  for(int i = 1; i*i <= m; ++i) {\n    if(m % i == 0) {\n      pf.PB(i);\n      if(i*i != m) pf.PB(m / i);\n    }\n  }\n  sort(iter(pf));\n  */\n  VI pf = {m};\n  {if(debug)cerr<<\"pf: \"<<(pf)ln;}\n  int zpf = size(pf);\n\n  VM dp(m);\n  VM g(zpf);\n\n  mint ans = 0_m;\n\n  times(zpf, h) {\n    mint s = dp[0] = 1_m;\n    uptil(1, pf[h], i) {\n      s += dp[i] = s;\n      if(i >= q) {\n        s -= dp[i - q];\n      }\n      if(i <= q) {\n        dp[i] += dp[0] * mint(i - 1);\n        s += dp[0] * mint(i - 1);\n      }\n    }\n\n    g[h] = s;\n    times(h, hh) {\n      if(pf[h] % pf[hh] == 0) g[h] -= g[hh];\n    }\n    ans += g[h] ;//* mint(pf[h]);\n\n    {if(debug)cerr<<'#'<<__LINE__ ln<<\"  h:     \"<<(h)ln<<\"  pf[h]: \"<<(pf[h])ln<<\"  s:     \"<<(s)ln<<\"  g[h]:  \"<<(g[h])ln<<\"  dp:    \"<<(dp)ln;}\n  }\n\n  cout << ans * 2_m ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  if(vs==vector<Int>(m,1)){\n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n  \n  Int lim=n;\n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    Int j=i;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n    \n    if(i==0) chmin(lim,j-i);\n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }\n  //cout<<lim<<endl;\n  \n  vector<M> dp(n+1,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n;i++){\n    for(Int j=0;j<i;j++){\n      if((i-j)&1) continue;\n      if((i-j-1)>lim) continue;\n      //cout<<i<<\"<-\"<<j<<endl;\n      dp[i]+=dp[j];\n    }\n    //cout<<i<<\":\"<<dp[i].v<<endl;\n  }\n\n  M ans{0};\n  for(Int i=0;i<n;i++){\n    for(Int j=1;j<=n;j++){\n      if(~(i+(n-j))&1) continue;\n      if(i+(n-(i+j))>lim) continue;\n      //cout<<i<<\" \"<<j<<\":\"<<dp[j].v<<endl;\n      ans+=dp[j];      \n    }\n  }\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MAX_N 200000\n#define MAX_M 200000\n#define MOD 1000000007\n\n#define INF 1 << 29\n\nint N, M;\nstring S;\n\nlong long dp[MAX_N + 1], rdp[MAX_N + 1];\n\nint all_color_is_same()\n{\n    long long rr = 1, bb = 1, rb = 0, br = 0;\n\n    for ( int i = 1; i < N; i++ )\n    {\n        long long nrr = ( rr + rb ) % MOD;\n        long long nbb = br;\n        long long nrb = rr;\n        long long nbr = ( bb + br ) % MOD;\n\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n\n    return ( rr + rb + br ) % MOD;\n}\n\n/**\n * S の先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n */\nint min_freq()\n{\n    int l = 0;\n    while ( l < M && S[0] == S[l] ) l++;\n\n    int ans = ( l & 1 ) ? l : l + 1;\n\n    l = 0;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[0] == S[i] )\n            l++;\n        else\n        {\n            if ( l & 1 ) ans = min( ans, l );\n            l = 0;\n        }\n    }\n    return l ? min( ans, l ) : ans;\n}\n\nint solve()\n{\n    // 一色\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n        return all_color_is_same();\n\n    // N が奇数\n    if ( N & 1 ) return 0;\n\n    int L = min_freq();\n\n    L = ( L + 1 ) >> 1;\n    N >>= 1;\n\n    dp[0] = rdp[0] = 1;\n    for ( int i = 1; i <= N + 1; i++ )\n    {\n        dp[i] = rdp[i - 1];\n        if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n\n    long long res = 0;\n    for ( int i = 1; i <= L; i++ )\n        if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n    return res % MOD;\n}\n\nint main( int argc, char **argv )\n{\n    cin >> N >> M;\n    cin >> S;\n\n    int ans = solve();\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nll modinv(ll a, ll m) {\n\tassert(m > 0);\n\tif (m == 1) return 0;\n\ta %= m;\n\tif (a < 0) a += m;\n\tassert(a != 0);\n\tif (a == 1) return 1;\n\treturn m - modinv(m, a) * m / a;\n}\n\ntemplate <int MOD_> struct modnum {\nprivate:\n\tint v;\npublic:\n\tstatic const int MOD = MOD_;\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int () const { return v; }\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum operator ~ () const {\n\t\tmodnum res;\n\t\tres.v = modinv(v, MOD);\n\t\treturn res;\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= (~o);\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<int(1e9)+7>;\n\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\tvector<int> q;\n\tfor(int i = 0; i < m; i++){\n\t\tq.push_back((s[i] == 'R') ^ (s[0] == 'R'));\n\t}\n\tfor(int i = 0; i + 1 < q.size(); i++){\n\t\tif(q[i] && q[i+1]){\n\t\t\tcout << 0 << '\\n';\n\t\t\texit(0);\n\t\t}\n\t}\n\tint nonzero = 0;\n\tfor(int x : q){\n\t\tif(x > 0) nonzero = 1;\n\t}\n\tif(!nonzero){\n\t\tvector<num> fib = {0, 1};\n\t\twhile(fib.size() <= n+1){\n\t\t\tfib.push_back(fib[fib.size()-1] + fib[fib.size()-2]);\n\t\t}\n\t\tcout << int(fib[n+1] + fib[n-1]) << '\\n';\n\t\texit(0);\n\t}\n\tint constraint = 1e8;\n\tint cur = 0;\n\tint st = 1;\n\tfor(int x : q){\n\t\tif(x == 1){\n\t\t\tif(st){\n\t\t\t\tif(cur % 2 == 1){\n\t\t\t\t\tconstraint = min(constraint, cur);\n\t\t\t\t} else {\n\t\t\t\t\tconstraint = min(constraint, cur + 1);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(cur % 2 == 1){\n\t\t\t\t\tconstraint = min(constraint, cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur = 0;\n\t\t\tst = 0;\n\t\t} else {\n\t\t\tcur += 1;\n\t\t}\n\t}\n\tif(n & 1){\n\t\tcout << 0 << '\\n';\n\t\texit(0);\n\t}\n\tn /= 2;\n\tconstraint = (constraint + 1) / 2;\n\tvector<num> dp(n+1, 0);\n\tvector<num> dpsum(n+1, 0);\n\tdp[0] = 1;\n\tdpsum[0] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tdp[i] = dpsum[i-1];\n\t\tif(i-1-constraint >= 0) dp[i] -= dpsum[i-1-constraint];\n\t\tdpsum[i] = dpsum[i-1] + dp[i];\n\t}\n\tnum ans = 0;\n\tfor(int i = 1; i <= constraint; i++){\n\t\tif(i <= n){\n\t\t\tans += dp[n - i] * (2 * i);\n\t\t}\n\t}\n\tcout << int(ans) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // clang-format off\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define in2(s,t)     rep(i,sz(s)){in(s[i] , t[i]);}\n#define in3(s,t,u)   rep(i,sz(s)){in(s[i] , t[i] , u[i]);}\n#define in4(s,t,u,v) rep(i,sz(s)){in(s[i] , t[i] , u[i] , v[i]);}\n#ifdef ONLINE_JUDGE\n  #define rep(i,N) for(int i = 0; i < (int)(N); i++)\n  #define repr(i,N) for(int i = (int)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(int i = 1; i <= (int)(N) ; i++)\n  #define repr1(i,N) for(int i = (N) ; (int)(i) > 0 ; i--)\n#else\n  #define rep(i,N) for(long long i = 0; i < (long long)(N); i++)\n  #define repr(i,N) for(long long i = (long long)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(long long i = 1; i <= (long long)(N) ; i++)\n  #define repr1(i,N) for(long long i = (N) ; (long long)(i) > 0 ; i--)\n#endif\nusing namespace std; void solve();\nusing ll = long long; template<class T = ll> using V = vector<T>;\nusing vi = V<int>; using vl = V<>; using vvi = V< V<int> >;\nusing vd = V<double>; using vs = V<string>; using vvl = V< V<> >;\nconstexpr int inf = 1001001001; constexpr ll infLL = (1LL << 61) - 1;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T,typename U>ll ceil(T a,U b){return (a + b - 1) / b;}\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); for(int i=0;i<s;i++) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);} while(0)\n  #define trcc(v) do { cerr << \"name : \" << #v << \"\\n\"; int cnt = 0; each(x , v){cerr << (cnt++) << \" : \"; trc(x); } } while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  #define trcc(...)\n  int main(){solve();}\n#endif\n\nconstexpr ll TEN(int n){ll ret=1,x=10;while(n){if(n&1)ret*=x;x*=x;n>>=1;}return ret;}\n#define mem(a, val) memset(a, val, sizeof(a))\n\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\nusing P = pair<ll,ll>; using vp = V<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n// clang-format on\n////////////////////////////////////////////////////\n\n\nvector<pair<char,int>> RunLengthEncoding(string& S){\n  vector<pair<char,int>> ret;\n  char c = -1;\n  int n = 0;\n  for(char x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate<typename T>\nvector<pair<T,int>> RunLengthEncoding(vector<T>& S){\n  vector<pair<T,int>> ret;\n  T c = -1;\n  int n = 0;\n  for(T& x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\nusing mint = modint;\n\nnamespace FastFourierTransform {\n  using real = double;\n\n  struct C {\n    real x, y;\n\n    C() : x(0), y(0) {}\n\n    C(real x, real y) : x(x), y(y) {}\n\n    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }\n\n    inline C conj() const { return C(x, -y); }\n  };\n\n  const real PI = acosl(-1);\n  int base = 1;\n  vector< C > rts = { {0, 0},\n                     {1, 0} };\n  vector< int > rev = {0, 1};\n\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    while(base < nbase) {\n      real angle = PI * 2.0 / (1 << (base + 1));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        real angle_i = angle * (2 * i + 1 - (1 << base));\n        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n      }\n      ++base;\n    }\n  }\n\n  void fft(vector< C > &a, int n) {\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          C z = a[i + j + k] * rts[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n  }\n\n  vector< int64_t > multiply(const vector< int > &a, const vector< int > &b) {\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = C(x, y);\n    }\n    fft(fa, sz);\n    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n      fa[i] = z;\n    }\n    for(int i = 0; i < (sz >> 1); i++) {\n      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n      fa[i] = A0 + A1 * s;\n    }\n    fft(fa, sz >> 1);\n    vector< int64_t > ret(need);\n    for(int i = 0; i < need; i++) {\n      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n    }\n    return ret;\n  }\n};\n\ntemplate< typename T >\nstruct ArbitraryModConvolution {\n  using real = FastFourierTransform::real;\n  using C = FastFourierTransform::C;\n\n  ArbitraryModConvolution() = default;\n\n  vector< T > multiply(const vector< T > &a, const vector< T > &b, int need = -1) {\n    if(need == -1) need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while((1 << nbase) < need) nbase++;\n    FastFourierTransform::ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < (int)a.size(); i++) {\n      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);\n    }\n    fft(fa, sz);\n    vector< C > fb(sz);\n    if(a == b) {\n      fb = fa;\n    } else {\n      for(int i = 0; i < (int)b.size(); i++) {\n        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);\n      }\n      fft(fb, sz);\n    }\n    real ratio = 0.25 / sz;\n    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C a1 = (fa[i] + fa[j].conj());\n      C a2 = (fa[i] - fa[j].conj()) * r2;\n      C b1 = (fb[i] + fb[j].conj()) * r3;\n      C b2 = (fb[i] - fb[j].conj()) * r4;\n      if(i != j) {\n        C c1 = (fa[j] + fa[i].conj());\n        C c2 = (fa[j] - fa[i].conj()) * r2;\n        C d1 = (fb[j] + fb[i].conj()) * r3;\n        C d2 = (fb[j] - fb[i].conj()) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector< T > ret(need);\n    for(int i = 0; i < need; i++) {\n      int64_t aa = llround(fa[i].x);\n      int64_t bb = llround(fb[i].x);\n      int64_t cc = llround(fa[i].y);\n      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;\n      ret[i] = aa + (bb << 15) + (cc << 30);\n    }\n    return ret;\n  }\n};\n\ntemplate< int mod >\nstruct NumberTheoreticTransform {\n\n  int base, max_base, root;\n  vector< int > rev, rts;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while(tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while(n > 0) {\n      if(n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) {\n    return mod_pow(x, mod - 2);\n  }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long) mod;\n  }\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while(base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n\n  void ntt(vector< int > &a) {\n    const int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n\n  vector< int > multiply(vector< int > a, vector< int > b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for(int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n\n  vector<modint> multiply_for_fps(const vector<modint> &a,const vector<modint> &b){\n    vector<int> A(a.size()) , B(b.size());\n    for(int i = 0;i < (int)a.size(); i++) A[i] = a[i].x;\n    for(int i = 0;i < (int)b.size(); i++) B[i] = b[i].x;\n    auto C = multiply( A , B );\n    vector<modint> ret(C.size());\n    for(int i = 0; i < (int)C.size() ;i++) ret[i].x = C[i];\n    return ret;\n  }\n};\n\n\ntemplate< typename T >\nstruct FormalPowerSeries : vector< T > {\n  using vector< T >::vector;\n  using P = FormalPowerSeries;\n\n  using MULT = function< P(P, P) >;\n\n  static MULT &get_mult() {\n    static MULT mult = nullptr;\n    return mult;\n  }\n\n  static void set_fft(MULT f) {\n    get_mult() = f;\n  }\n\n  void shrink() {\n    while(this->size() && this->back() == T(0)) this->pop_back();\n  }\n\n  P operator+(const P &r) const { return P(*this) += r; }\n\n  P operator+(const T &v) const { return P(*this) += v; }\n\n  P operator-(const P &r) const { return P(*this) -= r; }\n\n  P operator-(const T &v) const { return P(*this) -= v; }\n\n  P operator*(const P &r) const { return P(*this) *= r; }\n\n  P operator*(const T &v) const { return P(*this) *= v; }\n\n  P operator/(const P &r) const { return P(*this) /= r; }\n\n  P operator%(const P &r) const { return P(*this) %= r; }\n\n  P &operator+=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] += r[i];\n    return *this;\n  }\n\n  P &operator+=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] += r;\n    return *this;\n  }\n\n  P &operator-=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] -= r[i];\n    shrink();\n    return *this;\n  }\n\n  P &operator-=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] -= r;\n    shrink();\n    return *this;\n  }\n\n  P &operator*=(const T &v) {\n    const int n = (int) this->size();\n    for(int k = 0; k < n; k++) (*this)[k] *= v;\n    return *this;\n  }\n\n  P &operator*=(const P &r) {\n    if(this->empty() || r.empty()) {\n      this->clear();\n      return *this;\n    }\n    assert(get_mult() != nullptr);\n    return *this = get_mult()(*this, r);\n  }\n\n  P &operator%=(const P &r) {\n    return *this -= *this / r * r;\n  }\n\n  P operator-() const {\n    P ret(this->size());\n    for(int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];\n    return ret;\n  }\n\n  P &operator/=(const P &r) {\n    if(this->size() < r.size()) {\n      this->clear();\n      return *this;\n    }\n    int n = this->size() - r.size() + 1;\n    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);\n  }\n\n  P pre(int sz) const {\n    return P(begin(*this), begin(*this) + min((int) this->size(), sz));\n  }\n\n  P operator>>(int sz) const {\n    if(this->size() <= sz) return {};\n    P ret(*this);\n    ret.erase(ret.begin(), ret.begin() + sz);\n    return ret;\n  }\n\n  P operator<<(int sz) const {\n    P ret(*this);\n    ret.insert(ret.begin(), sz, T(0));\n    return ret;\n  }\n\n  P rev(int deg = -1) const {\n    P ret(*this);\n    if(deg != -1) ret.resize(deg, T(0));\n    reverse(begin(ret), end(ret));\n    return ret;\n  }\n\n  P diff() const {\n    const int n = (int) this->size();\n    P ret(max(0, n - 1));\n    for(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);\n    return ret;\n  }\n\n  P integral() const {\n    const int n = (int) this->size();\n    P ret(n + 1);\n    ret[0] = T(0);\n    for(int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);\n    return ret;\n  }\n\n  // F(0) must not be 0\n  P inv(int deg = -1) const {\n    assert(((*this)[0]) != T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1) / (*this)[0]});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 1\n  P log(int deg = -1) const {\n    assert((*this)[0] == 1);\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();\n  }\n\n  P sqrt(int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n\n    if((*this)[0] == T(0)) {\n      for(int i = 1; i < n; i++) {\n        if((*this)[i] != T(0)) {\n          if(i & 1) return {};\n          if(deg - i / 2 <= 0) break;\n          auto ret = (*this >> i).sqrt(deg - i / 2) << (i / 2);\n          if(ret.size() < deg) ret.resize(deg, T(0));\n          return ret;\n        }\n      }\n      return P(deg, 0);\n    }\n\n    P ret({T(1)});\n    T inv2 = T(1) / T(2);\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 0\n  P exp(int deg = -1) const {\n    assert((*this)[0] == T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1)});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  P pow(int64_t k, int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    for(int i = 0; i < n; i++) {\n      if((*this)[i] != T(0)) {\n        T rev = T(1) / (*this)[i];\n        P C(*this * rev);\n        P D(n - i);\n        for(int j = i; j < n; j++) D[j - i] = C[j];\n        D = (D.log() * k).exp() * (*this)[i].pow(k);\n        P E(deg);\n        if(i * k > deg) return E;\n        auto S = i * k;\n        for(int j = 0; j + S < deg && j < D.size(); j++) E[j + S] = D[j];\n        return E;\n      }\n    }\n    return *this;\n  }\n\n  T eval(T x) const {\n    T r = 0, w = 1;\n    for(auto &v : *this) {\n      r += w * v;\n      w *= x;\n    }\n    return r;\n  }\n};\n\nusing FPS = FormalPowerSeries< modint >;\n\n// fにa * x^n + bを掛ける\nvoid mul_simple(FPS &f,modint a ,int n, modint b){\n  for(int i = (int)f.size() - 1 ; i >= 0 ; i--){\n    f[i] *= b;\n    if(i >= n) f[i] += f[i - n] * a; \n  }\n}\n\n// fからa * x^n + bを割る\nvoid div_simple(FPS &f,modint a,int n,modint b){\n  for(int i = 0 ; i < (int)f.size() ; i++){\n    f[i] /= b;\n    if(i + n < (int)f.size() ) f[n + i] -= f[i] * a; \n  }\n}\n\n// f / gをdeg(f)次まで求める\nFPS div_(FPS &f , FPS g){\n  int n = f.size();\n  return (f * g.inv(n)).pre(n);\n}\n\n\n// solve関数内で\n//\n// FPS::set_fft(mul);\n//\n// とすること。\n\n/**\nNumberTheoreticTransform<MOD> ntt;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret =ntt.multiply_for_fps(a , b);\n  return FPS::P(ret.begin(), ret.end());\n};\n/*///\nArbitraryModConvolution< modint > fft;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret = fft.multiply(a, b);\n  return FPS::P(ret.begin(), ret.end());\n};\n//*/\n\n// 下記のリンクを実装(kitamasa法のモンゴメリ乗算を使わない版)\n// http://q.c.titech.ac.jp/docs/progs/polynomial_division.html\n// k項間漸化式のa_Nを求める O(k log k log N)\n// N ... 求めたい項　(0-indexed)\n// Q ... 漸化式 (1 - \\sum_i c_i x^i)の形\n// a ... 初期解 (a_0 , a_1 , ... , a_k-1)\n// x^N を fでわった剰余を求め、aと内積を取る\nmodint kitamasa(ll N, FPS &Q, FPS &a){\n  int k = Q.size() - 1;\n  assert( (int)a.size() == k );\n  FPS P = a * Q; P.resize(k);\n  while(N){\n    auto Q2 = Q;\n    for(int i = 1; i < (int)Q2.size(); i += 2) Q2[i].x = MOD - Q2[i].x;\n    auto S = P * Q2;\n    auto T = Q * Q2;\n    if(N & 1){\n      for(int i = 1 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    else{\n      for(int i = 0 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    N >>= 1;\n  }\n  return P[0];\n}\n\nvoid solve(){\n  ini(N , M);\n  ins(S);\n  auto run = RunLengthEncoding(S);\n  if(run.size() == 1){\n    // DP\n    V<mint> dp(N),ep(N),fp(N),gp(N);\n    // [0]がR\n    // -> [1],[-1]はどちらでもよい\n    dp[0] = gp[0] = 1;\n    rep1(i , N - 1){\n      dp[i] = dp[i - 1] + ep[i - 1];\n      ep[i] = dp[i - 1];\n      fp[i] = fp[i - 1] + gp[i - 1];\n      gp[i] = fp[i - 1];\n    }\n    out(dp[N-1] + ep[N-1] + fp[N-1]);\n    return;\n  }\n  if(N % 2 == 1){\n    out(0);\n    return;\n  }\n  FPS::set_fft(mul);\n  // rの最小値\n  int r = inf , b = inf;\n  each(p , run){\n    if(p.first == 'R') amin(r , (p.second%2==0 ? p.second+1:p.second));\n    if(p.first == 'B') amin(b , (p.second%2==0 ? p.second+1:p.second));\n  }\n  trc(r , b);\n  // 初手とは異なる方が1である必要あり\n  (run[0].first == 'R' ? b : r) = 1;\n  FPS f({1});\n  auto nyaan = [&](ll n,int flg = false) -> FPS{\n    FPS ret(n + 1);\n    for(int i = 1 ; i <= n ; i += 2) ret[i] = (flg ? i : 1);\n    return ret;\n  };\n  trc(f);\n  f *= nyaan(r);\n  f *= nyaan(b);\n  trc(f);\n  f = FPS({1}) - f;\n  if((int)f.size() <= N) f.resize(N + 2);\n  f = f.inv();\n  f *= nyaan(r,1) * nyaan(b) + nyaan(b,1) * nyaan(r); \n  trc(f);\n  out(f[N]);\n  \n  /*\n  //trc(f);\n  // 倍数包除\n  for(int i = 2 ; i <= N ; i++){\n    // i番目は？\n    //引こう！\n    for(int j = 2 ; i * j <= N ; j++){\n      f[i * j] -= f[i];\n    }\n  }\n  trc(f);\n  */\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << (a) << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int MOD = 1e9 + 7;\n\nvi split(string s) {\n    vi ans;\n    char last = 'X'; \n    s += 'X';\n    int streak = 0;\n    for (char c : s) {\n        if (c != last) {\n            if (streak) ans.pb(streak);\n            streak = 0;\n            last = c;\n        }\n        streak++;\n    }\n    return ans;\n}\n\nvoid add(int &x, int y) {\n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n\nvi go(int n, int lim, int start) {\n    vi dp(n+1);\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = 0;\n        if (i >= start) add(dp[i], dp[i-start]);\n        if (i >= lim+1) add(dp[i], MOD-dp[i-lim-1]);\n        add(dp[i], dp[i-1]);\n    }\n    for (int i = n; i >= 1; i--) add(dp[i], MOD-dp[i-1]);\n    return dp;\n}\n\nint sum(const vi &dp, int n, int lim) {\n    int ans = 0;\n    for (int dif = 1; dif <= lim; dif++) {\n        add(ans, ll(dif) * dp[n-dif] % MOD);\n    }\n    return ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    int n,l;\n    string s;\n    while (cin >> n >> l >> s) {\n        auto p = split(s);\n        if (si(p) == 1) {\n            //cout << \"TODO\" << endl;\n            auto dp = go(n,n,2);\n            auto ans = sum(dp,n,n);\n            cout << (ans)%MOD << endl;\n        }\n        else {\n            if (n%2 == 1) {\n                cout << 0 << endl;\n                continue;\n            }\n            int lim = n+l;\n            forn(i,si(p)) if (i == 0 || (i%2 == 0 && p[i]%2 == 1)) {\n                lim = min(lim, p[i]/2+1);\n            }\n            n /= 2;\n            auto dp = go(n, lim, 1);\n            auto ans = sum(dp,n,lim);\n            cout << 2*ans%MOD << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PI 3.14159265358979323846264338327950288419\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint n, m;\nint col[200005];\n\nint calc(int n){\n\tint fib[200005];\n\tfib[1] = fib[2] = 1;\n\tfor(int i = 3; i <= n + 1; i++){\n\t\tfib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t}\n\t\n\t// force first one to be 1, last one to be 0: fib[n - 1]\n\t// force first one to be 0: fib[n + 1]\n\treturn (fib[n - 1] + fib[n + 1]) % mod;\n}\n\nint calc2(int n, int ub){\n\tassert(ub & 1);\n\t\n\t// want a bunch of numbers, in [2, ub], to sum to n\n\t\n\tub++;\n\tub = min(ub, n); // coz it can actually be HUGE\n\t\n\tint dp[200005]; // dp[i]: number of possible sums, that sum to i\n\tint cumu[200005];\n\t\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(cumu, 0, sizeof(cumu));\n\tdp[0] = 1;\n\tcumu[0] = 1;\n\t\n\tfor(int i = 2; i <= n; i += 2){\n\t\t// sum dp[l_index .. i - 2].. oh, only the even ones!\n\t\tint l_index = i - ub;\n\t//\tprintf(\"%d: sum %d..%d\\n\", i, l_index, r_index);\n\t\tdp[i] = cumu[i - 2];\n\t\t\n\t\tif(l_index > 0){\n\t\t\tdp[i] -= cumu[l_index - 2];\n\t\t\tif(dp[i] < 0){\n\t\t\t\tdp[i] += mod;\n\t\t\t}\n\t\t}\n//\t\tprintf(\"%d: %d\\n\", i, dp[i]);\n\t\tcumu[i] = (cumu[i - 2] + dp[i]) % mod;\n\t}\n\t\n\tint ret = 0;\n\t\n\tfor(int space = 0; space < ub; space++){\n\t\t// last 1 is at (n - space), leaving _ space at the end\n\t\t// where can the first 1 be?\n\t\tint most_remain = n - (space + 1);\n\t\tint least_remain = n - ub;\n\t\t\n\t\tif(most_remain & 1) most_remain--;\n\t\t\n\t\t// sum up dp[least_remain..most_remain] (even indices only)\n\t\t\n\t\tint combin = cumu[most_remain];\n\t\tif(least_remain > 0){\n\t\t\tcombin = (combin - cumu[least_remain - 2] + mod) % mod;\n\t\t}\n\t\tret = (ret + combin) % mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= m; i++){\n\t\tchar c;\n\t\tscanf(\" %c\", &c);\n\t\tcol[i] = (c == 'B');\n\t}\n\t\n\tif(col[1] != 0){\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tcol[i] = 1 - col[i];\n\t\t}\n\t}\n\t\n\t// WLOG first one is 0\n\tbool monochrome = true;\n\tfor(int i = 2; i <= m; i++){\n\t\tif(col[i]){\n\t\t\tmonochrome = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(monochrome){\n\t\t// ok as long as 1s are not adjacent\n\t\tprintf(\"%d\\n\", calc(n));\n\t\treturn 0;\n\t}else{\n\t\t// 00...010..010..0\n\t\t// each block of 0 is of add length\n\t\t// so, n odd -> definitely no solution\n\t\t// more conditions depending on specifics of col[]\n\t\tif(n % 2 == 1){\n\t\t \tprintf(\"0\\n\");\n\t\t \treturn 0;\n\t\t}\n\t\tint first_run = 0, subseq_run = n - 1;\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tint len = 0;\n\t\t\twhile(i + len <= m && col[i + len] == 0){\n\t\t \t\tlen++;\n\t\t \t}\n\t\t \tif(first_run == 0){\n\t\t \t\tfirst_run = len;\n\t\t \t}else if(len & 1){\n\t\t \t\tsubseq_run = min(subseq_run, len);\n\t\t \t}\n\t\t \ti += len;\n\t\t}\n\t\tint ub = first_run + (first_run % 2 == 0);\n\t\tassert(ub < n);\n\t\tub = min(ub, subseq_run);\n\t\tprintf(\"%d\\n\", calc2(n, ub));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 200100;\nconst int mod = 1e9 + 7;\nconst int oo = 1e9;\nlong long power(long long x, long long k)\n{\n\tlong long ans = 1;\n\twhile(k)\n\t{\n\t\tif(k & 1)\n\t\t\t(ans *= x) %= mod;\n\t\tk >>= 1;\n\t\t(x *= x) %= mod;\n\t}\n\treturn ans;\n}\nint n, m;\nchar s[maxn];\nint l = oo;\nlong long ans = 0;\nlong long dp[maxn][2][2] = {0}, h[maxn][2][2] = {0}, f[maxn];\nint main()\n{\n\tstd::ios::sync_with_stdio(false);\n\tcin >> n >> m;\n\tfor(int i = 1; i <= m; i ++)\n\t\tcin >> s[i];\n\twhile(s[m] == s[1] && m >= 1)\n\t\tm --;\n\tif(m != 0)\n\t{\n\t\tint len;\n\t\tfor(len = 1; len <= m && s[len] == s[1]; len ++);\n\t\tlen --;\n\t\tif(len & 1)\n\t\t\tl = min(l, len);\n\t\telse\n\t\t\tl = min(l, len + 1);\n\t\tint now = 0;\n\t\tfor(int i = len + 2; i <= m; i ++)\n\t\t{\n\t\t\tif(s[i] != s[1])\n\t\t\t{\n\t\t\t\tif(now & 1)\n\t\t\t\t\tl = min(l, now);\n\t\t\t\tnow = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t\tnow ++;\n\t\t}\n\t}\n\tif(m == 0)\n\t{\n\t\tf[0] = 2;\n\t\tf[1] = 1;\n\t\tfor(int i = 2; i <= n; i ++)\n\t\t\tf[i] = (f[i - 1] + f[i - 2]) % mod;\n\t\tcout << f[n] << endl;\n\t\treturn 0;\n\t}\n\tif(n & 1)\n\t{\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tn >>= 1;\n\tl >>= 1;\n\t//cout << n << \" \" << l << endl;\n\tdp[1][0][0] = h[1][0][0] = 1;\n\tdp[1][1][1] = h[1][1][1] = (l > 0);\n\t//dp[0][0][0] = dp[0][1][1] = h[0][0][0] = h[0][1][1] = 1;\n\tfor(int i = 2; i <= n; i ++)\n\t{\n\t\t//cout << i << \" : \" << endl;\n\t\tdp[i][0][0] = (dp[i - 1][0][1] + dp[i - 1][0][0]) % mod;\n\t\tdp[i][0][1] = (h[i - 1][0][0] - h[max(0, i - l - 1)][0][0] + mod) % mod;\n\t\tdp[i][1][0] = (dp[i - 1][1][1] + dp[i - 1][1][0]) % mod;\n\t\tdp[i][1][1] = (h[i - 1][1][0] - h[max(0, i - l - 1)][1][0] + mod) % mod;\n\t\tif(i <= l)\n\t\t\tdp[i][1][1] ++;\n\t\tfor(int asd1 = 0; asd1 < 2; asd1 ++)\n\t\t\tfor(int asd2 = 0; asd2 < 2; asd2 ++)\n\t\t\t\th[i][asd1][asd2] = (h[i - 1][asd1][asd2] + dp[i][asd1][asd2]) % mod;\n\t\t//cout << dp[i][0][0] << \" \" << dp[i][0][1] << \" \" << dp[i][1][0] << \" \" << dp[i][1][1] << endl;\n\t\t//cout << h[i][0][0] << \" \" << h[i][0][1] << \" \" << h[i][1][0] << \" \" << h[i][1][1] << endl;\n\t}\n\tfor(int i = 1; i <= min(l, n); i ++)\n\t\tdp[i][1][1] --;\n\tlong long ans = 0;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\t(ans += (n - i) * dp[i][1][1]) %= mod;\n\t\tif(i <= l && n - i > 1)\n\t\t\t(ans += (n - i)) %= mod;\n\t\tif(n - i <= l && i >= 2)\n\t\t\t(ans += (n - i) * dp[i][0][0]) %= mod;\n\t\t//cout << i << \" \" << ans << endl;\n\t}\n\tans ++;\n\t//cout << ans << endl;\n\tif((l >= n - 1) && n != 1)\n\t\tans += n;\n\tcout << (ans * 2 + (m == 0 && n != 1)) % mod << endl;\n\treturn 0;\n}\n/*\n1 3\nBBB\n*/"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)2e6];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(__int128 x) {\n\tif (x == 0) { fast_print('0'); return; }\n\tif (x < 0) {\n\t\tfast_print('-');\n\t\tx = -x;\n\t}\n\t__int128 p = 1;\n\twhile (x / (p * 10)) p *= 10;\n\twhile (p) {\n\t\t__int128 symb = x / p;\n\t\tfast_print((int)symb);\n\t\tx -= p * symb;\n\t\tp /= 10;\n\t}\n};\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n, m;\nstring s;\n\nconst ll MOD = 1e9 + 7;\ntemplate<ll MOD>\nstruct Ring {\n\tll value = 0;\n\tRing() {}\n\tRing(int _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing(ll _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing pow(ll p) const {\n\t\tif (p == 0) return 1;\t\n\t\tif (p & 1) {\n\t\t\treturn Ring(value).pow(p - 1) * value;\n\t\t} else {\n\t\t\tRing sub = Ring(value).pow(p / 2);\n\t\t\treturn sub * sub;\n\t\t}\n\t}\n\tRing inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tvoid operator*=(const Ring<MOD> &b) {\n\t\tvalue *= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator*(Ring<MOD> a, const Ring<MOD> &b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\tvoid operator+=(const Ring<MOD> &b) {\n\t\tvalue += b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator+(Ring a, const Ring &b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\tvoid operator-=(const Ring<MOD> &b) {\n\t\tvalue -= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator-(Ring a, const Ring &b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\tvoid operator/=(const Ring<MOD> &b) {\n\t\t(*this) *= b.inv();\t\n\t}\n\tfriend Ring operator/(Ring a, const Ring &b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\tbool operator==(const Ring<MOD> &b) {\n\t\treturn value == b.value;\n\t}\n\tbool operator!=(const Ring<MOD> &b) {\n\t\treturn value != b.value;\n\t}\n\tfriend void fast_print(const Ring<MOD> &b) {\n\t\tfast_print(b.value);\n\t}\n};\n\ntypedef Ring<MOD> num;\n\nsigned main(signed argc, char *argv[]) {\n\tscan n, m;\n\tscan s;\n\tif (count(s.begin(), s.end(), s[0]) == len(s)) {\n\t\tvector<num> dp(n + 1);\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) \n\t\t\tfor (int j = 2; j <= i; j++)\n\t\t\t\tdp[i] += dp[i - j];\n\t\tnum final = 0;\n\t\tfor (int a = 0; a <= n; a++) \n\t\t\tfor (int b = 0; a + b + 1 <= n; b++)\n\t\t\t\tfinal += dp[n - a - b - 1];\n\t\tprint final;\n\t\treturn 123;\n\t}\n\tif (n & 1) {\n\t\tprint 0;\n\t\treturn 0;\n\t}\n\tif (s[0] == 'B') {\n\t\tfor (char &c : s) \n\t\t\tc = (c == 'R') ? 'B' : 'R';\n\t}\n\tint _max = 1e9;\n\tchar pref = '!';\n\tint _size = 0;\n\tfor (int i = 0; i <= len(s); i++) {\n\t\tif (s[i] != pref) {\n\t\t\tif ((_size & 1) && pref == 'R')\n\t\t\t\t_max = min(_max, _size);\n\t\t\tif (_max == 1e9 && pref != '!') {\n\t\t\t\t_max = min(_max, _size | 1);\n\t\t\t}\n\t\t\t_size = 1;\n\t\t} else {\n\t\t\t_size++;\n\t\t}\n\t\tpref = s[i];\n\t}\n\tvector<num> dp(n + 1);\n\tdp[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 2; j <= min(i, _max + 1); j += 2)\n\t\t\tdp[i] += dp[i - j];\n\tnum final = 0;\n\tfor (int a = 0; a <= n; a++)\n\t\tfor (int b = 0; a + b <= min(_max, n); b++)\n\t\t\tif ((a + b) & 1)\n\t\t\t\tif (n - a - b - 1 >= 0) {\n\t\t\t\t\t// print a, b, n - a - b - 1, dp[n - a - b - 1];\n\t\t\t\t\tfinal += dp[n - a - b - 1];\n\t\t\t\t}\n\tprint final;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define nn 500008\n#define mod 1000000007\nchar str[nn];int n,m;\nlong long dp[nn],sum[nn];\n#define err return 0*puts(\"0\");\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str+1);\n\t\n\tint cnt=0;\n\tif(str[1]=='B') for(int i=1;i<=m;i++) if(str[i]=='R') str[i]='B';else str[i]='R';\n\tfor(int i=1;i<=m;i++) if(str[i]=='B') cnt++;\n\tint mx=n;int flg=0;\n\tif(cnt)\n\t{\n\t\tcnt=0;\n\t\tif(n%2) err;int j=1;\n\t\tfor(int i=m;i>=1;i--)\n\t\t\tif(str[i]=='B')  {for(int j=i;j<=m;j++) str[j]='B';break;}\n\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(str[i]=='B') break;\n\t\t\tcnt++;j=i;\n\t\t}\n\t\tmx=min(mx,cnt/2+1);\n\t\t\n\t\tj++;\n\t\tcnt=0;str[m+1]='B';\n\t\tfor(;j<=m+1;j++)\n\t\t{\n\t\t\tif(str[j]=='B')\n\t\t\t{\n\t\t\t\tif(cnt%2) mx=min(mx,(cnt+1)/2);\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t\telse cnt++;\n\t\t}\n\t\tflg=1;\n\t\tn/=2;\n\t}\n\t\n\tdp[0]=sum[0]=1;\n\tint ls=0;if(!flg) ls=1,sum[1]=1;\n\tfor(int i=ls+1;i<=n;i++) \n\t{\n\t\tif(i-mx-1>=0) dp[i]=(sum[i-1-ls]-sum[i-mx-1]+mod)%mod;\n\t\telse dp[i]=sum[i-1-ls];\n\t\tsum[i]=(sum[i-1]+dp[i])%mod;\n\t}\n\tlong long ans=0;\n\tfor(int i=1;i<=n and i<=mx;i++)\n\t{\n\t\tans+=1ll*dp[n-i]*i%mod;\n\t\tif(flg) ans+=1ll*dp[n-i]*i%mod;\n\t\tans%=mod;\n\t}\n\t\n\tprintf(\"%lld\\n\",(ans%mod+mod)%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <iomanip>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <chrono>\n#include <ctime>\n#include <cassert>\n#include <bitset>\n#include <iterator>\n#include <cmath>\n#include <stack>\n#include <random>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define debug(x) cerr << #x << \": \" << x << \", \"\n#define debugln(x) cerr << #x << \": \" << x << '\\n'\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\n//constexpr ll mod = 998244353;\nconstexpr ll mod = 1e9+7;\nconst double PI = acos(-1.0);\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m; cin >> n >> m;\n  string s; cin >> s;\n\n  char c0 = s[0];\n  bool same = true;\n  rep(i, m) {\n    if (s[i] != c0) {\n      same = false;\n      break;\n    }\n  }\n  \n  if (same) {\n    // 0: s[0] = c[0] && s[i] = c[0]\n    // 1: s[0] = c[0] && s[i] != c[0]\n    // 2: s[0] != c[0] && s[i] = c[0]\n    // 3: s[0] != c[0] && s[i] != c[0]\n    vector<ll> dp1(4); \n    vector<ll> dp2(4);\n    dp1[0] = 1;\n    dp1[3] = 1;\n    for(int i=1; i<n-1; i++) {\n      dp2[0] = dp1[0] + dp1[1];\n      dp2[0] %= mod;\n      dp2[1] = dp1[0];\n      dp2[2] = dp1[2] + dp1[3];\n      dp2[2] %= mod;\n      dp2[3] = dp1[2];\n      rep(j, 4) {\n        dp1[j] = dp2[j];\n        //debug(j);debugln(dp1[j]);\n      }\n    }\n    ll ans = 0;\n    ans += dp1[0] + dp1[1];\n    ans += dp1[0];\n    ans += dp2[2] + dp2[3];\n    cout << ans%mod << endl;\n    return 0;\n  }\n\n  if (n%2 != 0) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  char before = c0;\n  int cnt = 0;\n  int minfirst = INT_MAX;\n  int minodd = INT_MAX;\n  rep(i, m) {\n    if (s[i] == c0) {\n      cnt++;\n    } else {\n      if (minfirst == INT_MAX) {\n        chmin(minfirst, cnt);\n      }\n      if (cnt&1) {\n        chmin(minodd, cnt);\n      }\n      cnt = 0;\n    }\n  }\n\n  cnt = INT_MAX;\n  if (minfirst%2 == 0) {\n    chmin(cnt, minfirst+1);\n  }\n  chmin(cnt, minodd);\n  int p = (cnt-1)/2;\n  //debugln(p);\n  n = n/2;\n  \n  vector<ll> dp(n+1);\n  vector<ll> rdp(n+1);\n  dp[1] = 1; rdp[1] = 1;\n  dp[2] = 1; rdp[2] = 2;\n  for(int i=3; i<=n; i++) {\n    dp[i] = rdp[i-1] - rdp[max(0, i-p-2)] + mod;\n    dp[i] %= mod;\n    rdp[i] = rdp[i-1] + dp[i];\n    rdp[i] %= mod;\n    //debug(i); debugln(dp[i]);\n  }\n\n  ll ans = 0;\n  for(ll L=0; L<=p && L<n; L++) {\n    //debug(L); debugln(dp[max(0LL, n-L)]);\n    ans += dp[max(0LL, n-L)]*(L+1)*2;\n    ans %= mod;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename T> void chmax(T &x,const T &y)\n{\n\tif(x<y)x=y;\n}\ntemplate <typename T> void chmin(T &x,const T &y)\n{\n\tif(x>y)x=y;\n}\n#define rep(i,l,r) for(int i=l;i<=r;++i)\n#define per(i,r,l) for(int i=r;i>=l;--i)\ntypedef long long s64;\nconst int N=2e5+5,D=1e9+7;\nchar s[N];\ns64 dp[N],sum[N];\n\nint main()\n{\n#ifdef kcz\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\tint n,m;\n\tcin>>n>>m;\n\tscanf(\"%s\",s+1);\n\tif(s[1]=='B')\n\trep(i,1,m)s[i]=\"RB\"[s[i]=='R'];\n\tint mn[2]={N,N},now=0;\n\trep(i,1,m)\n\tif(s[i]=='R')++now;\n\telse \n\t{\n\t\tif(now)chmin(mn[now%2],now);\n\t\tnow=0;\n\t}\n\tif(now==m)\n\t{\n\t\tdp[0]=1;\n\t\trep(i,2,n+2)dp[i]=(dp[i-1]+dp[i-2])%D;\n\t\tcout<<(dp[n]+dp[n+2])%D<<endl;\n\t}\n\telse\n\t{\n\t\tint fir=1;\n\t\twhile(s[fir]=='R')++fir;\n\t\tif(fir%2)chmin(mn[1],fir);\n\t\tif(n%2){puts(\"0\");exit(0);}\n\t\tdp[0]=sum[0]=1;\n\t\trep(i,2,n)\n\t\t{\n\t\t\tdp[i]=sum[i-2];\n\t\t\tint j=i-mn[1]-1-2;\n\t\t\tif(j>=0)dp[i]-=sum[j];\n\t\t\tdp[i]%=D;\n\t\t\tsum[i]=(sum[i-2]+dp[i])%D;\n\t\t}\n\t\ts64 ans=0;\n\t\trep(x,0,min(n/2-1,mn[1]/2))\n\t\t{\n\t\t\tans+=sum[n-2*x-2];\n\t\t\tif(mn[1]+3<=n)ans-=sum[n-mn[1]-1-2];\n\t\t}\n\t\tcout<<(ans*2%D+D)%D<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n/*\n0-index\nfunctionの中を書いて使う\n宣言の時に単位元を書く\n*/\ntemplate<typename T>\nstruct segtree{\n\tint n;\n\tvector<T> dat;\n\tT ZERO;\n\tfunction<T(T,T)> func;\n\tsegtree(int n_, function<T(T,T)> func_, T zero):func(func_), ZERO(zero){\n\t  n = 1;\n\t  while(n < n_)n*=2;\n\t  dat.resize(2*n);\n\t  for(int i = 0;i < 2*n;i++)dat[i] = ZERO;\n\t}\n\tvoid update(int k, T a){\n\t  k += n - 1;dat[k] = a;\n\t  while(k > 0){\n\t\tk = (k-1)/2;\n\t\tdat[k] = func(dat[k*2+1],dat[k*2+2]);\n\t  }\n\t}\n\n\tvoid set(int k, T a) {\n\t\tk += n - 1;dat[k] = a;\n\t}\n\n\tvoid build(){\n\t\tfor(int i = n - 2;i >= 0;i--){\n\t\t\tdat[i] = func(dat[2 * i + 1], dat[2 * i + 2]);\n\t\t}\n\t}\n\n\tT get(int k){return dat[k+n-1];}\n\n\tT que(int a,int b){\n\t\tT L = ZERO,R = ZERO;\n\t\tint A = a + n - 1;\n\t\tint B = b + n - 1;\n\t\twhile(A < B){\n\t\t\tif((A & 1) == 0)L = func(L,dat[A++]);\n            if((B & 1) == 0)R = func(dat[--B],R);\n            A = A >> 1;\n            B = B >> 1;\n\t\t}\n\t\treturn func(L,R);\n\t}\n};\n\n\nint getmin(string str){\n\tchar c = str[0];\n\tbool isFirst = true;\n\tint cou = 0;\n\tint ret = INF;\n\tREP(i, str.size()){\n\t\tif(str[i] == c)cou++;\n\t\telse {\n\t\t\tif(isFirst && cou % 2 == 0)cou++;\n\t\t\tif(cou % 2)ret = min(ret, cou);\n\t\t\tisFirst = false;\n\t\t\tcou = 0;\n\t\t}\n\t}\n\n\tif(isFirst && cou % 2 == 0)cou++;\n\tif(cou % 2)ret = min(ret, cou);\n\treturn ret;\n}\n\nbool oneKind(string str){\n\tREP(i, str.size())if(str[0] != str[i])return false;\n\treturn true;\n}\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\tll n, m;cin >> n >> m;\n\tstring str;cin >> str;\n\n\tint k = getmin(str);\n\tsegtree<ll> seg(n, [](ll a, ll b){return (a + b) % MOD;}, 0);\n\n\tseg.update(0, 1);\n\tfor(ll i = 2;i < n;i++){\n\t\tif(i % 2)continue;\n\t\tll l = max(0LL, i - k - 1);\n\t\tll r = i - 1;\n\t\tseg.update(i, seg.que(l, r));\n\t}\n\n\t//REP(i, n)cout << seg.get(i) << \" \";cout << endl;\n\n\tll ans = 0;\n\tbool flag = oneKind(str);\n\tREP(i, n-1){\n\t\tif(n - (i + 1) <= k && ((n - (i + 1)) % 2 || flag)){\n\t\t\t//cout << \"pass \" << seg.get(i) * (n - i) % MOD << endl;\n\t\t\tans = (ans + seg.get(i) * (n - i) % MOD) % MOD;\n\t\t}\n\t}\n\tif(flag)ans = (ans + 1) % MOD;\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tstring s;\n\tcin >> s;\n\tset<char>st;\n\tfor (auto i : s)st.insert(i);\n\tif (st.size() == 1) {\n\t\tvector<long long int>dp(N + 1);\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1];\n\t\t\tif (i > 1)dp[i] += dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tlong long int ans = dp.back();\n\t\tdp[0] = 1;\n\t\tdp[1] = 0;\n\t\tfor (int i = 2; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tans += dp.back();\n\t\tans %= MOD;\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\ts.push_back(s[0] + 1);\n\tvector<int>num(s.size() + 1);\n\tfor (int i = 0; i <= s.size(); i++) {\n\t\tnum[i] = s[i] == s[0];\n\t\tif (i)num[i] = num[i] * (num[i - 1] + 1);\n\t}\n\tint m = MOD;\n\tfor (int i = 1; i <= s.size(); i++) {\n\t\tif (!num[i] && num[i - 1])m = min(m, num[i - 1]);\n\t}\n\tif (m % 2 == 0)m++;\n\tm++;\n\tvector<long long int>dp(N + 2);\n\tvector<long long int>sum(N + 2);\n\tfor (int i = 2; i <= m; i += 2)dp[i] = i;\n\tfor (int i = 2; i <= N; i++) {\n\t\tdp[i] += sum[i - 2] + MOD;\n\t\tif (i - m - 2 >= 0)dp[i] -= sum[i - m - 2];\n\t\tdp[i] %= MOD;\n\t\tif (i == N) {\n\t\t\tcout << dp[i] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsum[i] = sum[i - 2] + dp[i];\n\t\tsum[i] %= MOD;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nllint solve(llint n,llint K){\n\tllint i;\n\tif(K>n){\n\t\tllint ans=1;\n\t\twhile(n--){ans*=2;ans%=mod;}\n\t\treturn ans;\n\t}\n\t//円環上にAマークとBマーク\n\t//BマークがKこ連続してはいけない\n\tvector<llint>dp(n+1);//最後のAマーク\n\tllint gen=1;//くぎりてん\n\tdp[0]=1;//最後のBマーク\n\tfor(i=1;i<n;i++){\n\t\tdp[i]=gen;\n\t\tgen*=2;\n\t\tif(i-K>=0){gen-=dp[i-K];}\n\t\tgen+=mod;gen%=mod;\n\t}\n\tllint ans=0;\n\tfor(i=1;i<=K;i++){\n\t\tans+=i*dp[n-i];\n\t\tans%=mod;\n\t}\n\treturn ans;\n}\nint main(void){\n\tint i,n,m;cin>>n>>m;\n\tstring S;cin>>S;\n\tvector<int>suu;\n\tchar now=S[0];\n\tint ban=0;\n\tfor(i=0;i<m;i++){\n\t\tif(S[i]==now){ban++;}\n\t\telse{suu.pub(ban);ban=1;}\n\t\tnow=S[i];\n\t}\n\tsuu.pub(ban);\n\t//for(auto it:suu){cerr<<it<<endl;}\n\tif(suu.size()==1){\n\t\tcout<<solve(n,2)<<endl;\n\t\treturn 0;\n\t}\n\tif(n%2==1){cout<<0<<endl;return 0;}\n\tint sei=suu[0];\n\tif(suu[0]%2==0){sei=suu[0]+1;}\n\tfor(i=2;i<suu.size();i+=2){\n\t\tif(suu[i]%2==1){mineq(sei,suu[i]);}\n\t}\n\tsei++;\n\t//cerr<<sei<<endl;\n\tcout<<(2*solve(n/2,sei/2))%mod<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nconstexpr lint MOD = 1000000007;\n\nlint corner_case(int N)\n{\n    lint a = 1, b = 0; // R始まり\n    lint c = 0, d = 1; // B始まり\n    REP(i, N - 1)\n    {\n        lint bnew = a;\n        lint anew = (a + b) % MOD;\n        a = anew;\n        b = bnew;\n\n        lint dnew = c;\n        lint cnew = (c + d) % MOD;\n        c = cnew;\n        d = dnew;\n    }\n    return (a + b + d) % MOD;\n}\n\nint main()\n{\n    lint N;\n    cin >> N;\n    lint M;\n    cin >> M;\n    string S;\n    cin >> S;\n    if (S[0] == 'B')\n    {\n        for (auto &c : S)\n        {\n            c = 'R' + 'B' - c;\n        }\n    }\n    int n = 0;\n    vector<int> con;\n    for (auto c : S)\n    {\n        if (c == 'R') n++;\n        else con.push_back(n), n = 0;\n    }\n    if (con.size() == 0)\n    {\n        lint ret = corner_case(N);\n        cout << ret << endl;\n        return 0;\n    }\n\n    if (N % 2)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int Lmaxi = (con[0] % 2 ? con[0] : con[0] + 1);\n    FOR(i, 1, con.size())\n    {\n        if (con[i] % 2) mmin(Lmaxi, con[i]); // 奇数だとヤバい\n    }\n\n    int P = (Lmaxi + 1) / 2;\n    int Q = N / 2;\n    // QをP以下で分割\n\n    vector<lint> dp(Q + 1);\n    dp[0] = 1;\n    lint acc = dp[0];\n    REP(i, Q)\n    {\n        dp[i + 1] = acc;\n        (acc += dp[i + 1]) %= MOD;\n        if (i + 1 - P >= 0) (acc += MOD - dp[i + 1 - P]) %= MOD;\n    }\n\n    vector<lint> dp_acc(Q + 2);\n    REP(i, Q + 1) dp_acc[i + 1] = (dp_acc[i] + dp[i]) % MOD;\n\n    lint ret = 0;\n    REP(l, Lmaxi + 1)\n    {\n        lint n = l / 2;\n        (ret += (dp_acc[max(Q - n, 0LL)] - dp_acc[max(Q - P, 0)] + MOD)) %= MOD;\n    }\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vec>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\nmain(){\n    ios\n    calc();\n    int n=in(),m=in();\n    string s;cin>>s;\n    bool all_same=true;\n    rep(i,m){\n        if(s[i]!=s[0])all_same=false;\n    }\n    if(!all_same and (n&1)){\n        cout<<0<<endl;\n    }\n    else if(all_same){\n        mint dp[n+1][2]={};\n        dp[0][0]=1;\n        rep(i,n-1){\n            dp[i+1][1]+=dp[i][0];\n            dp[i+1][0]+=dp[i][0]+dp[i][1];\n        }\n        mint ans=dp[n-1][0]+dp[n-1][1];\n        rep(i,n)dp[i][0]=dp[i][1]=0;\n        dp[0][1]=1;\n        rep(i,n-1){\n            dp[i+1][1]+=dp[i][0];\n            dp[i+1][0]+=dp[i][0]+dp[i][1];\n        }\n        ans+=dp[n-1][0];\n        cout<<ans.a<<endl;\n    }\n    else{\n        char c=s[0];\n        int mi=INT_MAX;\n        rep(i,m){\n            int cnt=0;\n            while(i<m && s[i]==c)cnt++,i++;\n            chmin(mi,cnt);break;\n        }\n        if(mi %2 ==0)mi++;\n        rep(i,m){\n            if(s[i]==c){\n                int cnt=0;\n                while(i<m && s[i]==c)cnt++,i++;\n                if((cnt&1) && (i!=m))\n                chmin(mi,cnt);\n            }\n        }\n        mint dp[300000]={};\n        mi=(mi+1)/2;\n        rep(i,mi){\n            dp[i]=2;\n        }\n        dp[mi]=-2*mi;\n        rep(i,n/2){\n            dp[i+1]+=dp[i]*2;\n            dp[i+1+mi]-=dp[i];\n        }\n        cout<<dp[n/2-1].a<<endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};  // namespace modular\nusing namespace modular;\n\nnamespace Base {\n    template <typename Tp>\n    inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp>\n    inline void read(Tp &x) {\n        x = input<Tp>();\n    }\n    template <typename Tp>\n    inline void chmax(Tp &x, Tp y) {\n        x < y ? x = y : 0;\n    }\n    template <typename Tp>\n    inline void chmin(Tp &x, Tp y) {\n        x > y ? x = y : 0;\n    }\n};  // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 300007\n\nint N, M;\nint f[MAX_N], g[MAX_N];\nchar s[MAX_N];\n\nint main() {\n    read(N), read(M);\n    scanf(\"%s\", s + 1);\n    bool vis = false;\n    int len = 0, mn = N;\n    Rep(i, M) {\n        if (s[i] != s[1]) {\n            if (!vis || (len & 1)) chmin(mn, len / 2 + 1);\n            vis = true, len = 0;\n        } else\n            ++len;\n    }\n    // printf(\"%d\\n\", len);\n    if (!vis) {\n        int a = 0, b = 1;\n        Lep(i, N) {\n            std::swap(a, b);\n            inc(b, a);\n        }\n        printf(\"%d\\n\", add(mul(a, 2), b));\n        return 0;\n    }\n    if (N & 1) return puts(\"0\"), 0;\n    N >>= 1;\n    f[0] = g[0] = 1;\n    Rep(i, N) {\n        f[i] = g[i - 1];\n        if (i > mn) inc(f[i], MOD - g[i - mn - 1]);\n        // printf(\"%d %d %d\\n\", i, g[i - 1], f[i]);\n        g[i] = add(f[i], g[i - 1]);\n    }\n    int res = 0;\n    Rep(i, mn) inc(res, mul(mul(i, 2), f[N - i]));\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\n#define MAX_N 200000\nmod inv[MAX_N],fac[MAX_N],finv[MAX_N];\n\nvoid make()\n{\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i=2;i<MAX_N;i++){\n        inv[i] = MOD - inv[MOD % i] * (MOD / i);\n        fac[i] = fac[i-1] * i;\n        finv[i] = finv[i-1] * inv[i];\n    }\n}\n\nmod comb(int a, int b)\n{\n    if(a<b) return 0;\n    return fac[a] * finv[b] * finv[a-b];\n}\ntypedef pair<int, int> Pii;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\nll mod_pow(ll a, ll n, ll mod) { ll ret = 1; ll p = a % mod; while (n) { if (n & 1) ret = ret * p % mod; p = p * p % mod; n >>= 1; } return ret; }\n\ntemplate<int mod, int primitive_root>\nclass NTT {\npublic:\n\tint get_mod() const { return mod; }\n\tvoid _ntt(vector<ll>& a, int sign) {\n\t\tconst int n = sz(a);\n\t\tassert((n ^ (n&-n)) == 0); //n = 2^k\n\n\t\tconst int g = 3; //g is primitive root of mod\n\t\tint h = (int)mod_pow(g, (mod - 1) / n, mod); // h^n = 1\n\t\tif (sign == -1) h = (int)mod_inv(h, mod); //h = h^-1 % mod\n\n\t\t//bit reverse\n\t\tint i = 0;\n\t\tfor (int j = 1; j < n - 1; ++j) {\n\t\t\tfor (int k = n >> 1; k >(i ^= k); k >>= 1);\n\t\t\tif (j < i) swap(a[i], a[j]);\n\t\t}\n\n\t\tfor (int m = 1; m < n; m *= 2) {\n\t\t\tconst int m2 = 2 * m;\n\t\t\tconst ll base = mod_pow(h, n / m2, mod);\n\t\t\tll w = 1;\n\t\t\tFOR(x, m) {\n\t\t\t\tfor (int s = x; s < n; s += m2) {\n\t\t\t\t\tll u = a[s];\n\t\t\t\t\tll d = a[s + m] * w % mod;\n\t\t\t\t\ta[s] = u + d;\n\t\t\t\t\tif (a[s] >= mod) a[s] -= mod;\n\t\t\t\t\ta[s + m] = u - d;\n\t\t\t\t\tif (a[s + m] < 0) a[s + m] += mod;\n\t\t\t\t}\n\t\t\t\tw = w * base % mod;\n\t\t\t}\n\t\t}\n\n\t\tfor (auto& x : a) if (x < 0) x += mod;\n\t}\n\tvoid ntt(vector<ll>& input) {\n\t\t_ntt(input, 1);\n\t}\n\tvoid intt(vector<ll>& input) {\n\t\t_ntt(input, -1);\n\t\tconst int n_inv = mod_inv(sz(input), mod);\n\t\tfor (auto& x : input) x = x * n_inv % mod;\n\t}\n\n\t// 畳み込み演算を行う\n\tvector<ll> convolution(const vector<ll>& a, const vector<ll>& b){\n\t\tint ntt_size = 1;\n\t\twhile (ntt_size < sz(a) + sz(b)) ntt_size *= 2;\n\n\t\tvector<ll> _a = a, _b = b;\n\t\t_a.resize(ntt_size); _b.resize(ntt_size);\n\n\t\tntt(_a);\n\t\tntt(_b);\n\n\t\tFOR(i, ntt_size){\n\t\t\t(_a[i] *= _b[i]) %= mod;\n\t\t}\n\n\t\tintt(_a);\n\t\treturn _a;\n\t}\n};\n\nll garner(vector<Pii> mr, int mod){\n\tmr.emplace_back(mod, 0);\n\n\tvector<ll> coffs(sz(mr), 1);\n\tvector<ll> constants(sz(mr), 0);\n\tFOR(i, sz(mr) - 1){\n\t\t// coffs[i] * v + constants[i] == mr[i].second (mod mr[i].first) を解く\n\t\tll v = (mr[i].second - constants[i]) * mod_inv<ll>(coffs[i], mr[i].first) % mr[i].first;\n\t\tif (v < 0) v += mr[i].first;\n\n\t\tfor (int j = i + 1; j < sz(mr); j++) {\n\t\t\t(constants[j] += coffs[j] * v) %= mr[j].first;\n\t\t\t(coffs[j] *= mr[i].first) %= mr[j].first;\n\t\t}\n\t}\n\n\treturn constants[sz(mr) - 1];\n}\n\ntypedef NTT<167772161, 3> NTT_1;\ntypedef NTT<469762049, 3> NTT_2;\ntypedef NTT<1224736769, 3> NTT_3;\n\n//任意のmodで畳み込み演算 O(n log n)\nvector<ll> int32mod_convolution(vector<ll> a, vector<ll> b,int mod){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\tvector<ll> ret(sz(x));\n\tvector<Pii> mr(3);\n\tFOR(i, sz(x)){\n\t\tmr[0].first = ntt1.get_mod(), mr[0].second = (int)x[i];\n\t\tmr[1].first = ntt2.get_mod(), mr[1].second = (int)y[i];\n\t\tmr[2].first = ntt3.get_mod(), mr[2].second = (int)z[i];\n\t\tret[i] = garner(mr, mod);\n\t}\n\n\treturn ret;\n}\n\n// garnerのアルゴリズムを直書きしたversion，速い\nvector<ll> fast_int32mod_convolution(vector<ll> a, vector<ll> b,int mod,int len){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\t\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tassert(ntt1.get_mod() < ntt2.get_mod() && ntt2.get_mod() < ntt3.get_mod());\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\t// garnerのアルゴリズムを極力高速化した\n\tconst ll m1 = ntt1.get_mod(), m2 = ntt2.get_mod(), m3 = ntt3.get_mod();\n\tconst ll m1_inv_m2 = mod_inv<ll>(m1, m2);\n\tconst ll m12_inv_m3 = mod_inv<ll>(m1 * m2, m3);\n\tconst ll m12_mod = m1 * m2 % mod;\n\tint L = min(len,sz(x));\n    vector<ll> ret(L);\n\tFOR(i, L){\n\t\tll v1 = (y[i] - x[i]) *  m1_inv_m2 % m2;\n\t\tif (v1 < 0) v1 += m2;\n\t\tll v2 = (z[i] - (x[i] + m1 * v1) % m3) * m12_inv_m3 % m3;\n\t\tif (v2 < 0) v2 += m3;\n\t\tll constants3 = (x[i] + m1 * v1 + m12_mod * v2) % mod;\n\t\tif (constants3 < 0) constants3 += mod;\n\t\tret[i] = constants3;\n\t}\n\n\treturn ret;\n}\n\n\nunsigned int add(const unsigned int x, const unsigned int y)\n{\n    return (x + y < MOD) ? x + y : x + y - MOD;\n}\n \nunsigned int sub(const unsigned int x, const unsigned int y)\n{\n    return (x >= y) ? (x - y) : (MOD - y + x);\n}\n \nunsigned int mul(const unsigned int x, const unsigned int y)\n{\n    return (unsigned long long)x * y % MOD;\n}\n \nunsigned int mod_pow(unsigned int x, unsigned int n)\n{\n    unsigned int res = 1;\n    while(n > 0){\n        if(n & 1){ res = mul(res, x); }\n        x = mul(x, x);\n        n >>= 1;\n    }\n    return res;\n}\n \nunsigned int inverse(const unsigned int x)\n{\n    return mod_pow(x, MOD - 2);\n}\n \nvector<ll> polynomial_inverse(const vector<ll>& a, int r)\n{\n    assert(a[0] != 0);\n    vector<ll> h = {(ll)inverse(a[0])};\n    int t = 1;\n    vector<ll> b;\n    int id =  0;\n    for(int i = 0; t < r; ++i){\n    \n        t <<= 1;\n        while(id<min((int)a.size(),t)){\n            b.push_back(a[id]);\n            id++;\n        }\n        vector<ll> res = fast_int32mod_convolution(b, fast_int32mod_convolution(h, h, MOD,t), MOD,t);\n        res.resize(t);\n        for(int j = 0; j < t; ++j){\n            res[j] = sub(0, res[j]);\n            if(j < t / 2) res[j] = add(res[j], mul(2, h[j]));\n        }\n        swap(h, res);\n    }\n    h.resize(r);\n    return h;\n}\n\nmod dp[200010][2][2];\nint main(){\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if(s[0]=='R'){\n        rep(i,m){\n            if(s[i]=='R'){\n                s[i] ='B';\n            }else{\n                s[i] ='R'; \n            }\n        }\n    }\n    int a = inf;\n    int c = 0;\n    rep(i,m){\n        if(s[i]=='B'){\n            c++;\n        }else{\n            chmin(a,c); \n            c = 0;   \n        }\n    }\n    if(a==inf){\n        dp[0][0][0] = 1;\n        dp[0][1][1] = 1;\n        for(int i=1;i<n;i++){\n            for(int j=0;j<2;j++){\n                if(j==0){\n                    dp[i][j][0] += dp[i-1][1][0];\n                    dp[i][j][1] += dp[i-1][1][1];\n                }else{\n                    dp[i][j][0] += dp[i-1][1][0] + dp[i-1][0][0];\n                    dp[i][j][1] += dp[i-1][1][1] + dp[i-1][0][1];    \n                }\n            }\n        }\n        cout << dp[n-1][1][0] + dp[n-1][1][1] + dp[n-1][1][0] << endl;\n    }else{\n        int len = (a/2)*2+1;\n        //cerr << len << endl;\n        vector<ll> X(n+1),Y(n+1);\n        len++;\n        for(int i=2;i<=len;i+=2){\n            X[i] = i;\n        }\n        Y[0] = 1;\n        for(int i=2;i<=len;i+=2){\n            Y[i] = MOD-1;\n        }\n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        Y =polynomial_inverse(Y,n+1);\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        X = fast_int32mod_convolution(X,Y,MOD,n+1);\n        \n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        cout << X[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nconst int mod=1e9+7;\n\nvoid U(int &x,int y){\n    x=(x+y)%mod;\n}\n\nint n, m, a[202000];\nchar s[202000];\n\nint main(){\n    cin>>n>>m>>s+1;\n    for (int i=1;i<=m;++i)\n        a[i]= s[i]==s[1];\n    if (*min_element(a+1,a+m+1)==1){\n        static int f[202000][2][2];\n        f[1][0][0]=f[1][1][1]=1;\n        for (int i=1;i<n;++i){\n            for (int s=0;s<=1;++s)\n                for (int t=0;t<=1;++t)\n                    for (int tt=0;tt<=1;++tt){\n                        if (t==0&&tt==0) continue;\n                        U(f[i+1][s][tt],f[i][s][t]);\n                    }\n        }\n        int ans=(1ll*f[n][0][1]+f[n][1][0]+f[n][1][1])%mod;\n        cout<<ans<<endl;\n        return 0;\n    }\n    int las=0, mx=1e9; vector<int>vec;\n    for (int i=1;i<=m;++i)\n        if (a[i]){\n            ++las;\n        }else{\n            vec.push_back(las);\n            las=0;\n        }\n    {\n        int t=vec.front(); vec.erase(vec.begin());\n        mx=min(mx,(t&1? t: t+1));\n    }\n    for (auto t:vec){\n        if (t&1) mx=min(mx,t);\n    }\n\n\n    static int ans=0, f[202000], sum[202000];\n    f[1]=sum[1]=1;\n    for (int i=2;i<=n;++i){\n        f[i]=(sum[i-2]-sum[max(0,i-mx-3)]+mod)%mod;\n        sum[i]=(sum[i-2]+f[i])%mod;\n        if ((n-i&1)&&n-i<=mx){\n            ans=(ans+(ll)f[i]*(n-i+1))%mod;\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    return res;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i <= m;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[2160000];\nInt rdp[2160000];\nInt dp[2160000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n+10, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    if(str.size() != m)return 1;\n    bool allsame = true;\n    for(auto c:str)allsame &= (c == str[0]);\n    if(allsame){\n        cout << all(n) << endl;\n        return 0;\n    }\n    for(auto c:str)vec.push_back(c == str[0]);\n    vec.push_back(0);\n    Int l = 0;\n    while(vec[l] == 1)l++;\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i < vec.size();i++){\n        if(vec[i] == 1)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 200010\n#define int long long\n#define mod 1000000007\n#define debug cerr<<__LINE__<<\" \"<<__FUNCTION__<<\"\\n\"\n\ninline int read(){\n    int x=0,y=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n    return x*y;\n}\nvoid put(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>=10) put(x/10);\n    putchar((x%10)+48);\n}\nint n,m,A[N],B[N];\nstring s;\nsigned main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tn=read();m=read();\n\tcin>>s;\n\tif(s[0]=='B'){\n\t\tfor(int i=0;i<m;i++) s[i]=(s[i]=='B'?'R':'B');\n\t}\n\tint pos=s.find('B');\n\tif(pos==string::npos){\n\t\tA[1]=A[2]=1;\n\t\tfor(int i=3;i<=n;i++) A[i]=(A[i-1]+A[i-2])%mod;\n\t\tcout<<(A[n]+2*A[n-1]%mod)%mod<<\"\\n\";\n\t\treturn 0;\n\t}\n\tif(n&1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint l=n,res=0,flag=0;\n\tfor(int i=0;i<m;i++){\n\t\tif(s[i]=='B'){\n\t\t\tif(flag) l=min(l,res+(res&1));\n\t\t\tflag=1;\n\t\t\tres=0;\n\t\t}\n\t\tres++;\n\t}\n//\tcout<<l<<\"\\n\";\n\tl/=2;n/=2;\n\tA[0]=B[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tA[i]=B[i-1];\n\t\tif(i>l) A[i]=(A[i]-B[i-l-1]+mod)%mod;\n\t\tB[i]=(B[i-1]+A[i])%mod;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=l;i++){\n\t\tans=(ans+2*i%mod*A[n-i]%mod)%mod;\n\t}\n\tcout<<ans<<\"\\n\";\n//\tfclose(stdin);\n//\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define int long long\nusing namespace std;\nconst int N=2e5+2;\nconst int mod=1e9+7;\nint dp[N],sum[N];\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,max1,ans=0,m;\n\tstring s;\n\tcin>>n>>m>>s;\n\tif(s[0]=='B'){\n\t\tfor(i=0;i<m;i++){\n\t\t\tif(s[i]=='B'){\n\t\t\t\ts[i]='R';\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts[i]='B';\n\t\t\t}\n\t\t}\n//\t\tcout<<s<<endl;\n\t}\n\tbool cac=true;\n\tfor(i=1;i<m;i++){\n\t\tif(s[i]!=s[i-1]){\n\t\t\tcac=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(cac){\n\t\tdp[0]=1;\n\t\tsum[0]=1;\n\t\tans=1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(i!=1){\n\t\t\t\tdp[i]=sum[i-2];\n\t\t\t}\n\t\t\tsum[i]=sum[i-1];\n\t\t\tsum[i]+=dp[i];\n\t\t\tif(sum[i]>=mod){\n\t\t\t\tsum[i]-mod;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n-1;i++){\n\t\t\tans+=(i+1)*dp[n-i-1];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout<<ans;\n\t}\n\telse{\n\t\tif(n%2!=0){\n\t\t\tcout<<0;\n\t\t\treturn 0;\n\t\t}\n\t\tmax1=n-1;\n\t\tcac=true;\n\t\tj=1;\n\t\tfor(i=1;i<m;i++){\n\t\t\tif(s[i]==s[i-1]){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(s[i]=='B'){\n\t\t\t\t\tif(cac){\n\t\t\t\t\t\tif(j&1){\n\t\t\t\t\t\t\tmax1=min(max1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmax1=min(max1,j+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcac=false;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(j&1){\n\t\t\t\t\t\t\tmax1=min(max1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj=1;\n\t\t\t}\n\t\t}\n\t\tdp[0]=1;\n\t\tsum[0]=1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tsum[i]=sum[i-1];\n\t\t\tif(i&1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i]=sum[i-2];\n\t\t\tif(i-max1-2>=0){\n\t\t\t\tdp[i]-=sum[i-max1-2];\n\t\t\t\tif(dp[i]<0){\n\t\t\t\t\tdp[i]+=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum[i]+=dp[i];\n\t\t\tif(sum[i]>=mod){\n\t\t\t\tsum[i]-=mod;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=max1;i+=2){\t\n\t\t\tans+=(i+1)*dp[n-i-1];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout<<ans;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nconst ll MOD=1e9+7;\nint n,m;\nchar s[200005];\nll f[200005][2],sum[200005];\nll DP(int n,int l)\n{\n\tf[1][1]=1;\n\tfor(int i=2;i<=n+1;i++)\n\t{\n\t\tf[i][1]=(f[i-1][1]+f[i-1][0])%MOD;\n\t\tf[i][0]=(f[i-1][1]+f[i-1][0]-(i-1>l?f[i-l-1][1]:0)+MOD)%MOD;\n\t}\n\tsum[1]=f[1][1];\n\tfor(int i=2;i<=n+1;i++)\n\t  sum[i]=(sum[i-1]+f[i][1])%MOD;\n\tll ans=f[n+1][1];\n\tfor(int st=2;st<=l+1;st++)\n\t  ans+=sum[n-st+1]-sum[n-l-1];\n\tans%=MOD;\n\tif(ans<0)ans+=MOD;\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tif(s[1]=='B')\n\t{\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(s[i]=='B')s[i]='R';\n\t\t\telse s[i]='B';\n\t\t}\n\t}\n\tint l=200001;\n\tint i=1;\n\twhile(s[i]=='R')i++;\n\tif(i>m)\n\t{\n\t\tprintf(\"%lld\\n\",DP(n,1));\n\t\treturn 0;\n\t}\n\tif(n&1)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tif(i&1)l=min(l,i);\n\telse l=min(l,i-1);\n\twhile(i<=m)\n\t{\n\t\twhile(s[i]=='B')i++;\n\t\tint len=0;\n\t\twhile(s[i]=='R')len++,i++;\n\t\tif(i>m)break;\n\t\tif(len&1)l=min(l,len);\n\t}\n\tprintf(\"%lld\\n\",DP(n/2,l/2)*2%MOD);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst ll MOD = 1e9 + 7;\n\nint N, M;\nstring S;\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N >> M >> S;\n\tif (S[0] == 'B') {\n\t\tfor (char& c : S) {\n\t\t\tc ^= 'B' ^ 'R';\n\t\t}\n\t}\n\tassert(S[0] == 'R');\n\n\tif (S == string(M, S[0])) {\n\t\t// there are no consecutive Bs\n\t\tarray<array<ll, 2>, 2> dp = {};\n\t\tdp[0][0] = dp[1][1] = 1;\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tarray<array<ll, 2>, 2> ndp = {};\n\t\t\tfor (int a = 0; a < 2; a++) {\n\t\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\t\tfor (int c = 0; c < 2; c++) {\n\t\t\t\t\t\tif (b || c) {\n\t\t\t\t\t\t\tndp[a][c] = (ndp[a][c] + dp[a][b]) % MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(dp, ndp);\n\t\t}\n\n\t\tll ans = 0;\n\t\tfor (int a = 0; a < 2; a++) {\n\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\tif (a || b) {\n\t\t\t\t\tans = (ans + dp[a][b]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\n\tif (N % 2 == 1) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tbool foundBlue = false;\n\tint maxRed = N-1;\n\tint cntRed = 0;\n\tfor (char c : S) {\n\t\tif (c == 'R') {\n\t\t\tcntRed++;\n\t\t} else {\n\t\t\tassert(c == 'B');\n\t\t\tif (foundBlue) {\n\t\t\t\tif (cntRed % 2 == 1) {\n\t\t\t\t\tmaxRed = min(maxRed, cntRed);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmaxRed = min(maxRed, cntRed + 1);\n\t\t\t}\n\t\t\tfoundBlue = true;\n\t\t\tcntRed = 0;\n\t\t}\n\t}\n\n\tassert(maxRed >= 1);\n\tmaxRed = (maxRed + 1) / 2;\n\tN /= 2;\n\n\tvector<ll> dp(N+1);\n\tdp[0] = 1;\n\tll sum = dp[0];\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (i - maxRed - 1 >= 0) sum = (sum - dp[i - maxRed - 1] + MOD) % MOD;\n\t\tdp[i] = sum;\n\t\tsum = (sum + dp[i]) % MOD;\n\t}\n\n\tll ans = 0;\n\tfor (int i = 1; i <= maxRed; i++) {\n\t\tans = (ans + i * dp[N - i]) % MOD;\n\t}\n\tans = ans * 2 % MOD;\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,Mod=1e9+7;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\n//inline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\ninline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n,m,Mx,p,ans,F[MAXN],Sum[MAXN];char s[MAXN];\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),m=read(),scanf(\"%s\",s+1),Mx=m,p=m+1;\n\tRep(i,1,m)if(s[i]!=s[1]){Mx=i-1,p=i;break;}\n\tif(Mx==m){\n\t\tF[0]=Sum[0]=ans=1;\n\t\tRep(i,0,n)(i>=2?F[i]=Sum[i-2]:0),(i?Sum[i]=(Sum[i-1]+F[i])%Mod:0),(n-i>=2?ans=(ans+1ll*F[i]*(n-i))%Mod:0);\n\t\tcout<<ans<<'\\n';return 0;\n\t}if(n&1)return puts(\"0\"),0;\n\tMx+=!(Mx&1);\n\tfor(int t=0,i=p;i<=m;i++)if(s[i]==s[1])t++;else (t&1?Mx=max(Mx,t):0),t=0;\n\tn/=2,Mx=(Mx+1)/2,F[0]=Sum[0]=1;\n\tRep(i,0,n){\n\t\tif(i)F[i]=(Sum[i-1]-(i-Mx-1>=0?Sum[i-Mx-1]:0)+Mod)%Mod,Sum[i]=(Sum[i-1]+F[i])%Mod;\n\t\tif(n-i<=Mx)ans=(ans+1ll*F[i]*(n-i)*2)%Mod;\n\t}cout<<ans<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\ntemplate<typename T>\nstruct SegmentTree{\nprivate:\n    int n;\n    T E;\n    vector<T> node;\n    inline void updatef(T& x,T& y){\n        x = y;\n        //x += y;\n        //x = max(x,y);\n        //x = min(x,y);\n    }\n    inline T queryf(T& x,T& y){\n        //return x*y;\n        return (x+y)%mod;\n        //return max(x,y);\n        //return min(x,y);\n    }\n\npublic:\n    SegmentTree(int sz,T E_):E(E_){\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n    }\n\n    SegmentTree(vector<T>& A,T E_):E(E_){\n        int sz=A.size();\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n        rep(i,sz)node[i+n-1]=A[i];\n        for(int i=n-2;i>=0;--i){\n            node[i]=queryf(node[2*i+1], node[2*i+2]);\n        }\n    }\n    void update(int k,T x){\n        k+=n-1;\n        updatef(node[k],x);\n        while(k>0){\n            k=(k-1)/2;\n            node[k]=queryf(node[2*k+1], node[2*k+2]);\n        }\n    }\n       //[a,b)での和を返す\n    T get(int a,int b,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        if(r<=a||b<=l)return E;\n        if(a<=l&&r<=b)return node[k];\n        T xl=get(a,b,2*k+1,l,(l+r)/2);\n        T xr=get(a,b,2*k+2,(l+r)/2,r);\n        return queryf(xl, xr);\n    }\n};\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n    fact.resize(n+1);\n    inv.resize(n+1);\n    invfact.resize(n+1);\n    fact[0]=inv[0]=invfact[0]=1;\n    inv[1]=1;\n    rep(i,n){\n        fact[i+1]=fact[i]*(i+1)%mod;\n        if(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n        invfact[i+1]=invfact[i]*inv[i+1]%mod;\n    }\n}\nll perm(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n    k%=mod-1;\n    if(k<0)k+=mod-1;\n    ll ret=1;\n    while(k){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\nint main(){\n    int n,m;\n    cin>>n>>m;\n    string s;\n    cin>>s;\n    int len=0;\n    while(len<m&&s[len]==s[0])++len;\n    if(len==m){\n        vector<ll> ans(n+1);\n        ans[0]=2,ans[1]=1;\n        rep(i,n-1)ans[i+2]=(ans[i+1]+ans[i])%mod;\n        cout<<ans[n]<<endl;\n        return 0;\n    }\n    if(n%2){\n        cout<<0<<endl;\n        return 0;\n    }\n    if (len%2==0)++len;\n    int cnt=0;\n    rep(i,n){\n        if(s[i]!=s[0]){\n            if(cnt%2)len=min(len,cnt);\n            cnt=0;\n        }\n        else ++cnt;\n    }\n    n/=2;\n    len = (len+1)/2;\n    SegmentTree<ll> sg(n+5,0);\n    sg.update(0,1);\n    rep(i,n+1){\n        ll ret=sg.get(max(0,i+1-len),i+1);\n        sg.update(i+1,ret);\n    }\n    ll ans=0;\n    rep(i,min(n,len)){\n        ans+=sg.get(max(0,n-len),n-i);\n    }\n    cout<<2*ans%mod<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nchar str[200005];\nint arr[200005];\nlong long MOD=1000000007;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",str);\n\tfor(int i=0;i<m;i++)if(str[i]=='R')arr[i]=0;else arr[i]=1;\n\tbool all[2];all[0]=all[1]=1;\n\tfor(int i=0;i<m;i++)all[arr[i]^1]=0;\n\tif(all[0]||all[1]){\n\t\tlong long dp[2][n];memset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;dp[1][0]=0; //start with red (or blue if everything is blue)\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tlong long ans=(dp[0][n-1]+dp[1][n-1])%MOD;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=0;dp[1][0]=1; //start with blue\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tans+=dp[0][n-1];\n\t\tprintf(\"%lld\",ans);\n\t\treturn 0;\n\t}\n\tif(n%2!=0){printf(\"0\");return 0;}\n\tint cur=0;vector<int> v;\n\tfor(int i=0;i<n;i++){\n\t\tif(arr[i]==arr[0])cur++;\n\t\telse{if(cur!=0)v.push_back(cur);cur=0;}\n\t}\n\tif(cur!=0)v.push_back(cur);\n\tint mxl=(v[0]%2==0?v[0]+1:v[0]);\n\tfor(int i=1;i<(int)v.size();i++){\n\t\tif(v[i]%2==1)mxl=min(mxl,v[i]);\n\t}\n\t//comments: wlog red is first\n\tmxl=mxl/2; //remove the ones that are different parity from blue\n\tlong long dp[100005],pref[100005];\n\tmemset(dp,0,sizeof(dp));memset(pref,0,sizeof(pref));\n\t//i segments on a line, first and last are blue, max mxl consecutive reds\n\t//blues may be consecutive because the reds in between were removed\n\tdp[1]=pref[1]=1;dp[2]=1;pref[2]=2;\n\tfor(int i=3;i<=n;i++){\n\t\tdp[i]=pref[i-1]-pref[max(0,i-(mxl+2))];\n\t\tdp[i]%=MOD;dp[i]+=MOD;dp[i]%=MOD;\n\t\tpref[i]=dp[i]+pref[i-1];\n\t\tpref[i]%=MOD;pref[i]+=MOD;pref[i]%=MOD;\n\t}\n\tlong long ans=0;\n\tfor(long long i=2;i<=min(n/2,mxl+2);i++){\n\t\tans+=2LL*(i-1LL)*dp[n/2-i+2];\n\t\tans%=MOD;\n\t}\n\tprintf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  for(Int i=0;i<m;i++)\n    s[i]=\"BR\"[vs[i]];\n  \n  if(vs!=vector<Int>(m,1)){    \n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n  assert(vs!=vector<Int>(m,0));\n\n  if(n&1){\n    cout<<0<<endl;\n    return 0;\n  }\n  \n  Int lim=n-1;  \n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    Int j=i;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n\n    if(i==0&&(j-i)%2==0) chmin(lim,j-i+1);\n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }\n  \n  vector<M> dp(n+2,0),sm(n+2,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n+1;i++){\n    sm[i]=sm[i-1]+dp[i-1];\n    if(i&1) dp[i]=sm[i-1]-sm[max<Int>(1,i-1-lim)];\n  }\n  \n  M ans{0};\n  for(Int i=0;i<=lim;i++)\n    ans+=sm[n-i+1]-sm[max<Int>(1,n-lim)];\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n//#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int M = 1e9 + 7;\n\nvoid solve_fib(int n) {\n    vi f(n + 1);\n    f[0] = f[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        f[i] = (f[i - 1] + f[i - 2]) % M;\n    }\n    cout << (f[n] + f[n - 2]) % M;\n}\nconst int oo = 1e9 + 10;\n\nint kek(int cnt, bool & first) {\n    if (first) {\n        first = false;\n        if (cnt & 1)\n            return cnt;\n        return cnt + 1;\n    }\n    if (cnt & 1)\n        return cnt;\n    return oo;\n}\n\nvoid insum(int &a, int b) {\n    a = (a + b) % M;\n}\n\nvoid smain() {\n\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    m = s.size();\n    if (count(ALL(s), 'R') == 0 || count(ALL(s), 'B') == 0) {\n        solve_fib(n);\n        return;\n    }\n\n    vi a(m);\n    fori (i, m) {\n        a[i] = s[i] == 'R';\n    }\n\n    vi min_sz(2, oo);\n    int cur = -1;\n    int cnt = 0;\n    bool first = true;\n    for (auto c : a) {\n        if (c != cur) {\n            if (cur != -1) {\n                inmin(min_sz[cur], kek(cnt, first));\n            }\n            cur = c;\n            cnt = 1;\n        } else {\n            cnt++;\n        }\n    }\n    vvi f(2);\n    fori (z, 2) {\n        vvi dp(2, vi(n, 0));\n        vvi p(2, vi(n, 0));\n        p[!z][0] = dp[!z][0] = 1;\n        for (int i = 1; i < n; ++i) {\n            fori (zz, 2) {\n                int j = i - min_sz[zz];\n                dp[zz][i] = (p[!zz][i - 1] - (j - 2 >= 0 ? p[!zz][j - 2] : 0) + M) % M;\n            }\n            fori (zz, 2) {\n                p[zz][i] = (dp[zz][i] + (i - 2 >= 0 ? p[zz][i - 2] : 0)) % M;\n            }\n        }\n        f[z] = dp[z];\n    }\n    int ans = 0;\n    fori (z, 2) {\n        for (int sz = 1; sz <= min(n - 1, min_sz[z]); sz += 2) {\n            insum(ans, (ll)f[!z][n - sz] * sz % M);\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=200005;\nconst int mod=1e9+7;\nint n,m,mn,ans;\nchar s[maxn],ch;\nint f[maxn],sum[maxn],g[maxn][2];\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d%d%s\",&n,&m,s);\n\tch=s[0];\n\tint cnt=0;\n\tmn=INF;\n\tbool fir=true;\n\trep(i,m){\n\t\tif(s[i]!=ch){\n\t\t\tif(!cnt)continue;\n\t\t\tif(fir){\n\t\t\t\tif(cnt%2==0)cnt++;\n\t\t\t\tmn=min(mn,cnt);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(cnt&1)mn=min(mn,cnt);\n\t\t\t}\n\t\t\tcnt=0;\t\n\t\t\tfir=false;\n\t\t}\n\t\telse cnt++;\n\t}\n\tif(mn==INF){\n\t\tg[1][0]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tg[i][0]=(g[i-1][0]+g[i-1][1])%mod;\n\t\t\tg[i][1]=g[i-1][0];\n\t\t}\n\t\tans=(g[n][0]+g[n][1])%mod;\n\t\tREP(i,n)g[i][0]=g[i][1]=0;\n\t\tg[1][1]=1;\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tg[i][0]=(g[i-1][0]+g[i-1][1])%mod;\n\t\t\tg[i][1]=g[i-1][0];\n\t\t}\n\t\tans=(ans+g[n][0])%mod;\n\t}\n\telse{\n\t\tif(n&1)ans=0;\n\t\telse{\n\t\t\tn/=2;\n\t\t\tmn=(mn+1)/2;\n\t\t\tf[0]=1;sum[0]=1;\n\t\t\tREP(i,n){\n\t\t\t\tf[i]=(sum[i-1]-(i-mn-1>=0?sum[i-mn-1]:0)+mod)%mod;\n\t\t\t\tsum[i]=(sum[i-1]+f[i])%mod;\n\t\t\t}\n\t\t\trep(i,n)if(n-i<=mn)ans=(ans+2LL*(n-i)*f[i]%mod)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll dp[202020][2][2];\nll mo=1000000007;\n\nll dp2[202020];\nll dps[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\tif(S[0]=='B') {\n\t\tFORR(c,S) c='R'+'B'-c;\n\t}\n\tif(count(ALL(S),'B')==0) {\n\t\tdp[0][0][0]=dp[0][1][1]=1;\n\t\tfor(i=1;i<N;i++) {\n\t\t\t(dp[i][0][0]=dp[i-1][0][0]+dp[i-1][0][1])%=mo;\n\t\t\t(dp[i][0][1]=dp[i-1][0][0])%=mo;\n\t\t\t(dp[i][1][0]=dp[i-1][1][0]+dp[i-1][1][1])%=mo;\n\t\t\t(dp[i][1][1]=dp[i-1][1][0])%=mo;\n\t\t}\n\t\tcout<<(dp[N-1][0][0]+dp[N-1][0][1]+dp[N-1][1][0])%mo<<endl;\n\t\treturn;\n\t}\n\t\n\tif(N%2) return _P(\"0\\n\");\n\t\n\tint L=0;\n\twhile(L<S.size()&&S[L]=='R') L++;\n\t\n\tif(L%2==0) L++;\n\t\n\tdp2[0]=dps[0]=dps[1]=1;\n\tfor(i=2;i<=N;i++) {\n\t\tif(i%2==0) {\n\t\t\tdp2[i]=dps[i-2];\n\t\t\tif(i-(L+1)>0) dp2[i]+=mo-dps[i-(L+1)-1];\n\t\t\tdp2[i]%=mo;\n\t\t}\n\t\t(dps[i]=dps[i-1]+dp2[i])%=mo;\n\t\t//cout<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=min(L,N-1);i++) {\n\t\t//cout<<i<<\" \"<<(i+1)<<\"*\"<<dp2[N-(i+1)]<<endl;\n\t\t(ret+=(i+1)*dp2[N-(i+1)])%=mo;\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#if DEBUG\n// basic debugging macros\nint __i__,__j__;\n#define printLine(l) for(__i__=0;__i__<l;__i__++){cout<<\"-\";}cout<<endl\n#define printLine2(l,c) for(__i__=0;__i__<l;__i__++){cout<<c;}cout<<endl\n#define printVar(n) cout<<#n<<\": \"<<n<<endl\n#define printArr(a,l) cout<<#a<<\": \";for(__i__=0;__i__<l;__i__++){cout<<a[__i__]<<\" \";}cout<<endl\n#define print2dArr(a,r,c) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<a[__i__][__j__]<<\" \";}cout<<endl;}\n#define print2dArr2(a,r,c,l) cout<<#a<<\":\\n\";for(__i__=0;__i__<r;__i__++){for(__j__=0;__j__<c;__j__++){cout<<setw(l)<<setfill(' ')<<a[__i__][__j__]<<\" \";}cout<<endl;}\n\n// advanced debugging class\n// debug 1,2,'A',\"test\";\nclass _Debug {\n    public:\n        template<typename T>\n        _Debug& operator,(T val) {\n            cout << val << endl;\n            return *this;\n        }\n};\n#define debug _Debug(),\n#else\n#define printLine(l)\n#define printLine2(l,c)\n#define printVar(n)\n#define printArr(a,l)\n#define print2dArr(a,r,c)\n#define print2dArr2(a,r,c,l)\n#define debug\n#endif\n\n// define\n#define MAX_VAL 999999999\n#define MAX_VAL_2 999999999999999999LL\n#define EPS 1e-6\n#define mp make_pair\n#define pb push_back\n\n// typedef\ntypedef unsigned int UI;\ntypedef long long int LLI;\ntypedef unsigned long long int ULLI;\ntypedef unsigned short int US;\ntypedef pair<int,int> pii;\ntypedef pair<LLI,LLI> plli;\ntypedef vector<int> vi;\ntypedef vector<LLI> vlli;\ntypedef vector<pii> vpii;\ntypedef vector<plli> vplli;\n\n// ---------- END OF TEMPLATE ----------\n#define MOD 1000000007\n\nchar S[200000];\nint fib[200005],dp[200005];\nint main() {\n    int i;\n    int N,M;\n    scanf(\"%d %d\",&N,&M);\n    for (i = 0; i < M; i++) scanf(\" %c\",&S[i]);\n\n    for (i = 0; i < M; i++) {\n        if (S[i] != S[0]) break;\n    }\n    if (i == M) {\n        fib[0] = fib[1] = 1;\n        for (i = 2; i < N+5; i++) fib[i] = (fib[i-1]+fib[i-2]) % MOD;\n        printf(\"%d\\n\",(fib[N-2]+fib[N]) % MOD);\n    }\n    else {\n        if (N & 1) printf(\"0\\n\");\n        else {\n            N /= 2;\n            int B = 1e9,c = 0,f = 1;\n            for (i = 0; i < M; i++) {\n                if (S[i] == S[0]) c++;\n                else {\n                    if (f) B = min(B,(c & 1) ? c:c+1),f = 0;\n                    else if (c & 1) B = min(B,c);\n                    c = 0;\n                }\n            }\n            B = (B+1)/2;\n            dp[0] = 1;\n            int sum = 1;\n            for (i = 1; i < N+5; i++) {\n                dp[i] = sum;\n                sum += dp[i],sum %= MOD;\n                if (i >= B) sum -= dp[i-B],sum %= MOD;\n            }\n            int ans = dp[N];\n            for (i = 1; i < B; i++) {\n                if (N-i-1 >= 0) {\n                    ans += ((LLI) i*dp[N-i-1]) % MOD;\n                    ans %= MOD;\n                }\n            }\n            ans = (2*ans) % MOD;\n            if (ans < 0) ans += MOD;\n            printf(\"%d\\n\",ans);\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PI 3.14159265358979323846264338327950288419\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint n, m;\nint col[200005];\n\nint calc(int n){\n\tint fib[200005];\n\tfib[1] = fib[2] = 1;\n\tfor(int i = 3; i <= n + 1; i++){\n\t\tfib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t}\n\t\n\t// force first one to be 1, last one to be 0: fib[n - 1]\n\t// force first one to be 0: fib[n + 1]\n\treturn (fib[n - 1] + fib[n + 1]) % mod;\n}\n\nint calc2(int n, int ub){\n\tassert(ub & 1);\n\t\n\t// want a bunch of numbers, in [2, ub], to sum to n\n\t\n\tub++;\n\tub = min(ub, n); // coz it can actually be HUGE\n\t\n\tint dp[200005]; // dp[i]: number of possible sums, that sum to i\n\tint cumu[200005];\n\t\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(cumu, 0, sizeof(cumu));\n\tdp[0] = 1;\n\tcumu[0] = 1;\n\t\n\tfor(int i = 2; i <= n; i += 2){\n\t\t// sum dp[l_index .. i - 2].. oh, only the even ones!\n\t\tint l_index = i - ub;\n\t//\tprintf(\"%d: sum %d..%d\\n\", i, l_index, r_index);\n\t\tdp[i] = cumu[i - 2];\n\t\t\n\t\tif(l_index > 0){\n\t\t\tdp[i] -= cumu[l_index - 2];\n\t\t\tif(dp[i] < 0){\n\t\t\t\tdp[i] += mod;\n\t\t\t}\n\t\t}\n//\t\tprintf(\"%d: %d\\n\", i, dp[i]);\n\t\tcumu[i] = (cumu[i - 2] + dp[i]) % mod;\n\t}\n\t\n\tint ret = 0;\n\t\n\tfor(int space = 0; space < ub; space++){\n\t\t// last 1 is at (n - space), leaving _ space at the end\n\t\t// where can the first 1 be?\n\t\tint most_remain = n - (space + 1);\n\t\tint least_remain = n - ub;\n\t\t\n\t\tif(most_remain & 1) most_remain--;\n\t\t\n\t\t// sum up dp[least_remain..most_remain] (even indices only)\n\t\t\n\t\tint combin = cumu[most_remain];\n\t\tif(least_remain > 0){\n\t\t\tcombin = (combin - cumu[least_remain - 2] + mod) % mod;\n\t\t}\n\t\tret = (ret + combin) % mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= m; i++){\n\t\tchar c;\n\t\tscanf(\" %c\", &c);\n\t\tcol[i] = (c == 'B');\n\t}\n\t\n\tif(col[1] != 0){\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tcol[i] = 1 - col[i];\n\t\t}\n\t}\n\t\n\t// WLOG first one is 0\n\tbool monochrome = true;\n\tfor(int i = 2; i <= m; i++){\n\t\tif(col[i]){\n\t\t\tmonochrome = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(monochrome){\n\t\t// ok as long as 1s are not adjacent\n\t\tprintf(\"%d\\n\", calc(n));\n\t\treturn 0;\n\t}else{\n\t\t// 00...010..010..0\n\t\t// each block of 0 is of add length\n\t\t// so, n odd -> definitely no solution\n\t\t// more conditions depending on specifics of col[]\n\t\tif(n % 2 == 1){\n\t\t \tprintf(\"0\\n\");\n\t\t \treturn 0;\n\t\t}\n\t\tint first_run = 0, subseq_run = n - 1;\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tint len = 0;\n\t\t\twhile(i + len <= m && col[i + len] == 0){\n\t\t \t\tlen++;\n\t\t \t}\n\t\t \tif(first_run == 0){\n\t\t \t\tfirst_run = len;\n\t\t \t}else if(i + len <= m && len % 2 == 1){\n\t\t \t\tsubseq_run = min(subseq_run, len);\n\t\t \t}\n\t\t \ti += len;\n\t\t}\n\t\tint ub = first_run + (first_run % 2 == 0);\n\t\tub = min(ub, subseq_run);\n\t\tprintf(\"%d\\n\", calc2(n, ub));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1000000007;\nint n, m, dp[200005], sum[2][200005];\nchar s[200005];\n\nint main() {\n\tscanf(\"%d%d%s\", &n, &m, s + 1);\n\tif (s[1] == 'B')\n\t\tfor (int i = 1; i <= m; ++i)\n\t\t\ts[i] = 'R' + 'B' - s[i];\n\tif (count(s + 1, s + 1 + m, 'R') == m) {\n\t\tif (n == 1) return puts(\"1\"), 0;\n\t\tint ans = 0;\n\t\tfor (int c = 0; c < 2; ++c) {\n\t\t\tint dp[2] = {1, 0};\n\t\t\tfor (int i = 1; i < n; ++i) {\n\t\t\t\tint t = dp[1];\n\t\t\t\tdp[1] = dp[0];\n\t\t\t\tdp[0] = (dp[0] + t) % P;\n\t\t\t}\n\t\t\tans = (ans + dp[0]) % P;\n\t\t\tif (!c) ans = (ans + dp[1]) % P;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t\treturn 0;\n\t}\n\tint lim = n - 1;\n\tfor (int i = 1, j; i <= m; i = j) {\n\t\tfor (j = i; j <= m && s[j] == s[i]; ++j);\n\t\tif (s[i] == 'B') continue;\n\t\tif (j - i & 1)\n\t\t\tlim = min(lim, j - i);\n\t\telse if (i == 1)\n\t\t\tlim = min(lim, j - i + 1);\n\t}\n\tdp[0] = 1;\n\tsum[0][0] = sum[0][1] = 1;\n\tsum[1][0] = sum[1][1] = 0;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tint d = max(0, i - lim - 1);\n\t\tdp[i] = (sum[i & 1][i - 2] - (d == 0 ? 0 : sum[i & 1][d - 1])) % P;\n\t\tsum[0][i] = sum[0][i - 1];\n\t\tsum[1][i] = sum[1][i - 1];\n\t\tsum[i & 1][i] = (sum[i & 1][i] + dp[i]) % P;\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i <= lim; ++i)\n\t\tans += sum[n & 1][n - (i + 1)] - (n == lim + 1 ? 0 : sum[n & 1][n - (lim + 1) - 1]);\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PI 3.14159265358979323846264338327950288419\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint n, m;\nint col[200005];\n\nint expo(int a, int b){\n\tint c = 1, d = a;\n\twhile(b){\n\t\tif(b & 1){\n\t\t\tc = 1LL * c * d % mod;\n\t\t}\n\t\td = 1LL * d * d % mod;\n\t\tb >>= 1;\n\t}\n\treturn c;\n}\n\nint inv(int x){\n\treturn expo(x, mod - 2);\n}\n\nint calc(int n){\n\tif(n == 2){\n\t\treturn 2;\n\t}\n\t\n\tint fib[200005];\n\tfib[1] = fib[2] = 1;\n\tfor(int i = 3; i <= n + 1; i++){\n\t\tfib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t}\n\t\n\t// force first one to be 1, last one to be 0: fib[N - 1]\n\t// force first one to be 0: fib[N + 1]\n\treturn (fib[n - 1] + fib[n + 1]) % mod;\n}\n\nint calc2(int n, int lb, int ub){\n\tassert(lb & 1);\n\tassert(ub & 1);\n\tif(lb > ub){\n\t\treturn 0;\n\t}\n\t\n\t// want a bunch of numbers, in [lb, rb], to sum to n\n\t\n\tlb++;\n\tub++;\n\tub = min(ub, n); // coz it can actually be HUGE\n\t\n\tint dp[200005]; // dp[i]: number of possible sums, that sum to i\n\tlong long cumu[200005];\n\t\n\tdp[0] = 1;\n\tcumu[0] = 1;\n\t\n\tfor(int i = 2; i <= n; i += 2){\n\t\t// sum from dp[l_index .. r_index].. oh, only the even ones!\n\t\tint l_index = i - ub;\n\t\tint r_index = i - lb;\n\t//\tprintf(\"%d: sum %d..%d\\n\", i, l_index, r_index);\n\t\tif(r_index >= 0) dp[i] = cumu[r_index];\n\t\tif(l_index > 0) dp[i] -= cumu[l_index - 2];\n\t\t\n\t\tif(dp[i] < 0) dp[i] += mod;\n\t\t\n\t\tcumu[i] = (cumu[i - 2] + dp[i]) % mod;\n\t//\tprintf(\"dp %d, cumu %d\\n\", dp[i], cumu[i]);\n\t}\n\t\n\tint ret = 0;\n\t\n\tfor(int space = 0; space < ub; space++){\n\t\t// last 1 is at (n - space), leaving _ space at the end\n\t\t// where can the first 1 be?\n\t\tint left_pos = max(1, lb - space);\n\t\tint right_pos = ub - space;\n\t\tint most_remain = (n - space) - left_pos;\n\t\tint least_remain = (n - space) - right_pos;\n\t\tif(most_remain & 1) most_remain--;\n\t\tif(least_remain & 1) least_remain++;\n\t\t\n\t\tint combin = 0;\n\t\tif(most_remain >= least_remain){\n\t\t\tcombin = cumu[most_remain];\n\t\t\tif(least_remain > 0){\n\t\t\t\tcombin = (combin - cumu[least_remain - 2] + mod) % mod;\n\t\t\t}\n\t\t}\n\t\tret += combin;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= m; i++){\n\t\tchar c;\n\t\tscanf(\" %c\", &c);\n\t\tcol[i] = (c == 'B');\n\t}\n\tif(col[1] != 0){\n\t\t// WLOG first one is 0\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tcol[i] = 1 - col[i];\n\t\t}\n\t}\n\t\n\tbool monochrome = true;\n\tfor(int i = 2; i <= m; i++){\n\t\tif(col[i]){\n\t\t\tmonochrome = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(monochrome){\n\t\t// ok as long as 1s are not adjacent\n\t\tprintf(\"%d\\n\", calc(n));\n\t\treturn 0;\n\t}else{\n\t\t// 00...010..010..0\n\t\t// each block of 0 is of add length\n\t\t// so, n odd -> definitely no solution\n\t\t// more conditions depending on specifics of col[]\n\t\tif(n % 2 == 1){\n\t\t \tprintf(\"0\\n\");\n\t\t \treturn 0;\n\t\t}\n\t\tint first_run = 0, subseq_run = 0;\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tint len = 0;\n\t\t\twhile(i + len <= m && col[i + len] == 0){\n\t\t \t\tlen++;\n\t\t \t}\n\t\t \tif(first_run == 0){\n\t\t \t\tfirst_run = len;\n\t\t \t}else if(len & 1){\n\t\t \t\tsubseq_run = max(subseq_run, len);\n\t\t \t}\n\t\t \ti += len;\n\t\t}\n\t\tint lb = max(1, subseq_run);\n\t\tint ub = first_run + (first_run % 2 == 0);\n\t//printf(\"%d %d\\n\", lb, ub);\n\t\tprintf(\"%d\\n\", calc2(n, lb, ub));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+10;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    lim = min(lim,(ll)n-1);\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    ans = dp[n+1];\n    for(ll i = 1;i<=lim;i+=2)\n    {\n        ans += (i*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n    {\n        exit(1);\n        return cout << solve(vc[0]+1),0;\n    }\n    int mn = 1e9;\n    if (vc[0]%2==0)\n        mn = vc[0]+1;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define inline __inline__ __attribute__((always_inline))\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=2e5+5,P=1e9+7;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nchar s[N];int f[N],dp[2][5],n,m,res,t;\nvoid solve1(){\n\tdp[0][0]=dp[0][3]=1,t=0;\n\tfor(R int i=1;i<n;++i,t^=1){\n\t\tdp[t^1][0]=dp[t^1][1]=dp[t^1][2]=dp[t^1][3]=0;\n\t\tdp[t^1][0]=add(dp[t][0],dp[t][1]),\n\t\tdp[t^1][1]=dp[t][0],\n\t\tdp[t^1][2]=add(dp[t][2],dp[t][3]),\n\t\tdp[t^1][3]=dp[t][2];\n\t}\n\tres=add(dp[t][0],add(dp[t][1],dp[t][2]));\n\tprintf(\"%d\\n\",res);\n}\nvoid solve2(){\n\tint lim=n,cur=0,las=m;\n\twhile(s[las]=='R')--las;\n\tfd(i,las,1)if(s[i]=='B'){\n\t\tif(cur&1)cmin(lim,cur+1);\n\t\tcur=0;\n\t}else ++cur;\n\tcmin(lim,cur+1+(cur&1^1));\n\tf[0]=f[2]=1;\n\tfor(R int i=4;i<=n;i+=2){\n\t\tf[i]=mul(f[i-2],2);\n\t\tif(i>=lim+2)f[i]=dec(f[i],f[i-(lim+2)]);\n\t}\n\tres=0;\n\tfor(R int i=2;i<=lim;i+=2)upd(res,mul(f[n-i],i));\n\tprintf(\"%d\\n\",res);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tif(s[1]=='B')fp(i,1,m)s[i]^='B'^'R';\n\tbool flag=0;\n\tfp(i,1,n)if(s[i]=='B'){flag=1;break;}\n\tif(!flag)solve1();else solve2();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n#ifdef DEBUG\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n)\\\n\t{cerr << #a << \" = {\";\\\n\tfor(int qwq = (st); qwq <= (n); ++qwq) {\\\n\t\tif(qwq == (st)) cerr << a[qwq];\\\n\t\telse cerr << \", \" << a[qwq];\\\n\t} cerr << \"}\" << endl;}\n#define displayv(v) displaya(v, 0, (int)(v).size() - 1)\n#endif\ntemplate<typename T> bool chmin(T &a, const T &b) { return a > b ? a = b, true : false; }\ntemplate<typename T> bool chmax(T &a, const T &b) { return a < b ? a = b, true : false; }\n\nconst int maxN = 200000 + 233;\nconst LL P = 1000000007;\nint n, m;\nchar s[maxN];\nLL f[maxN];\n\nLL purity() {\n\tLL f00 = 1, f11 = 1, f01 = 0, f10 = 0;\n\t// '11' is not OK\n\tfor(int i = 2; i <= n; ++i) {\n\t\tLL g00 = f00 + f01, g01 = f00,\n\t\t   g10 = f10 + f11, g11 = f10;\n\t\tf00 = g00 % P; f01 = g01;\n\t\tf10 = g10 % P; f11 = g11;\n\t}\n\treturn (f00 + f01 + f10) % P;\n}\n\nLL recur(int lim) {\n\t// sum( x ^ (p + 1) )\n\t// sum( (c + 1) * x ^ (p + 1) )\n//\tdisplay(lim);\n\tmemset(f, 0, sizeof(f));\n\tf[0] = 1; f[1] = 0; f[2] = 1; f[3] = 0;\n\tfor(int i = 4; i <= n; ++i) {\n\t\tf[i] = f[i - 2] * 2 % P;\n\t\tif(i - lim - 3 >= 0) f[i] = (f[i] + P - f[i - lim - 3]) % P;\n\t}\n//\tdisplaya(f, 0, n);\n\tLL ans = 0;\n\tfor(int i = 1; i <= lim; i += 2) if(n - i - 1 >= 0)\n\t\t(ans += f[n - i - 1] * (i + 1)) %= P;\n\treturn ans;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> m >> (s + 1);\n\tassert((int)strlen(s + 1) == m);\n\tchar major = s[1], minor = (int)'R' + 'B' - major;\n\tint cons = 0;\n\tint mn = maxN;\n\tbool first = true;\n\tfor(int i = 1; i <= m; ++i) {\n\t\tif(s[i] == major) cons++;\n\t\telse {\n\t\t\tif(first) chmin(mn, cons | 1), cons = 0, assert(s[i] == minor), first = false;\n\t\t\telse if(cons & 1) chmin(mn, cons), cons = 0, assert(s[i] == minor);\n\t\t}\n\t}\n\tif(mn == maxN) cout << purity() << endl;\n\telse cout << recur(mn) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define pld pair <ld, ld>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n#define cld complex <double>\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 3e5;\nconst ll mod = 1e9 + 7;\n\nll n, m, k, t;\n\nstring s;\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;\n}\n\nll simple() {\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    ll q;\n    for (q = 1; q < n; q++) {\n        D[q] += D[q - 1];\n        if (q >= 2) {\n            D[q] += D[q - 2];\n            D[q] %= mod;\n        }\n    }\n    return (D[n - 2] * 2 + D[n - 1]) % mod;\n    // if (n % 2 == 1) {\n    //     return \n    // }\n    // return step(2, n / 2 + 1);\n}\n\nint main() {\n    pyshnapyshnakaa\n    ll q, w, e, a, b, c;\n    cin >> n >> m;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (q = 0; q < s.length(); q++) {\n            if (s[q] == 'R') {\n                s[q] = 'B';\n            }\n            else {\n                s[q] = 'R';\n            }\n        }\n    }\n    vector <pll> A;\n    A.pb(mp(1, s[0]));\n    for (q = 1; q < s.length(); q++) {\n        if (s[q] == A.back().second) {\n            A.back().first++;\n        }\n        else {\n            A.pb(mp(1, s[q]));\n        }\n    }\n    // cout << \"FALL\" << endl;\n    bool blue = 0; /*kill = 0;*/\n    ll mx = maxn;\n    // cout << \"\"\n    for (q = 0; q < A.size(); q++) {\n        if (A[q].second == 'B') {\n            blue = 1;\n        }\n        else {\n            if (q == 0 || A[q].first % 2 == 1) {\n                mx = min(mx, A[q].first + 1 - A[q].first % 2);\n            }\n        }\n    }\n    // cout << \"MX \" << mx << endl;\n    // if (fail) {\n    //     cout << 0;\n    //     return 0;\n    // }\n    if (!blue) {\n        cout << simple();\n        return 0;\n    }\n    // ll mx = maxn, cur = 0;\n    // for (q = 0; q < s.length(); q++) {\n    //     if (s[q] == 'B') {\n    //         if (cur % 2 == 1) {\n    //             mx = min(mx, cur);\n    //         }\n    //         else {\n    //             mx = min(mx, cur + 1);\n    //         }\n    //         cur = 0;\n    //     }\n    //     else {\n    //         cur++;\n    //     }\n    // }\n    vector <ll> S(2);\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    S[0] = 1;\n    for (q = 1; q < n; q++) {\n        D[q] = S[q % 2];\n        S[q % 2] = (S[q % 2] + D[q]) % mod;\n        ll deli = q - mx - 1;\n        if (deli >= 0) {\n            // cout << \"DELETING \" << q << endl;\n            S[deli % 2] = (S[deli % 2] - D[deli] + mod) % mod;\n        }\n        // cout << q << \" \" << D[q] << endl;\n    }\n    // cout << \"mx \" << mx << endl;\n    ll ans = 0;\n    for (q = 0; q < n; q++) {\n        ll len = n - q - 1;\n        if (len % 2 == 0 || len > mx) {\n            continue;\n        }\n        ans += D[q] * (len + 1) % mod;\n        ans %= mod;\n    }\n    cout << ans;\n    return -1;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+100;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    lim = min(lim,(ll)n-1);\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    ans = dp[n+1];\n    for(ll i = 1;i<=lim;i+=2)\n    {\n        ans += (i*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    if (vc[0]%2==0)\n    {\n        int mn = vc[0]+1;\n        for(auto x:vc)\n        {\n            if (x&1)\n                mn = min(mn,x);\n        }\n        cout << solve(mn);\n    }\n    else\n        cout << solve(vc[0]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\nint f[200005];\n\nint solve(int n,int up) {\n  int s=0;\n  for(int i=1;i<=n;i++) {\n  \tif (i>up+1) s=(s-f[i-up-1]+MOD)%MOD;\n  \tf[i]=(s+((i<=up)?i:0))%MOD;\n  \ts=(s+f[i])%MOD;\n  }\n  return f[n];\n}\n\nint solve2(int n) {\n  f[1]=1;\n  for(int i=2;i<=n+1;i++) f[i]=(f[i-1]+f[i-2])%MOD;\n  return (f[n+1]+f[n-1])%MOD;\n}\n\nchar str[200005];\n\nint main() {\n  int n,m;\n  scanf(\"%d%d%s\",&n,&m,str+1);\n  if (str[1]=='B') {\n  \tfor(int i=1;i<=m;i++) str[i]=((str[i]=='R')?'B':'R');\n  }\n  bool v=0;\n  for(int i=1;i<=m;i++)\n    if (str[i]=='B') {\n    \tv=1;\n    \tbreak;\n\t}\n  if (!v) {\n  \t//printf(\"%d\\n\",solve2(n));\n  \treturn 0;\n  }\n  if (n&1) {\n  \tputs(\"0\");\n  \treturn 0;\n  }\n  int minn=n,s=0;\n  for(int i=1;i<=m;i++)\n    if (str[i]=='R') s++;\n    else {\n    \tif (s) minn=min(minn,s);\n    \ts=0;\n\t}\n  printf(\"%d\\n\",2*solve(n>>1,(minn>>1)+1)%MOD);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint n, m;\nchar s[MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nint main() {\n\tread(n), read(m);\n\tscanf(\"%s\", s + 1);\n\tbool same = true;\n\tfor (int i = 1; i <= m; i++)\n\t\tif (s[i] != s[1]) same = false;\n\tif (same) {\n\t\tstatic int dp[MAXN], sum[MAXN];\n\t\tdp[1] = sum[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tdp[i] = sum[i - 2];\n\t\t\tsum[i] = (sum[i - 1] + dp[i]) % P;\n\t\t}\n\t\tint ans = (sum[n - 1] + 1) % P;\n\t\tfor (int i = 2, j = n - 1; i <= n; i++, j--)\n\t\t\tupdate(ans, sum[j]);\n\t\tprintf(\"%d\\n\", ans);\n\t\treturn 0;\n\t}\n\tif (n & 1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint Min = n - (n - 1) % 2;\n\tint last = 0;\n\tfor (int i = 1; i <= m; i++)\n\t\tif (s[i] != s[1]) {\n\t\t\tint len = i - last - 1;\n\t\t\tif (last == 0) chkmin(Min, len + 1);\n\t\t\tif (len % 2 == 1) chkmin(Min, len);\n\t\t\tlast = i;\n\t\t}\n\tstatic int dp[MAXN], sum[MAXN];\n\tdp[1] = sum[1] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (i % 2 == 1) {\n\t\t\tdp[i] = sum[i - 2];\n\t\t\tupdate(dp[i], P - sum[max(i - Min - 3, 0)]);\n\t\t}\n\t\tsum[i] = (sum[i - 1] + dp[i]) % P;\n\t}\n\tint ans = (sum[n - 1] - sum[max(n - Min - 2, 0)] + P) % P;\n\tfor (int i = 2, j = n - 1; i <= n && j >= n - Min - 2; i++, j--)\n\t\tupdate(ans, (sum[j] - sum[max(n - Min - 2, 0)] + P) % P);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200010;\nconst int mod = 1e9 + 7;\n\ntypedef long long LL;\n\nchar s[N];\n\nint f[N], g[N], dp[2][2][N];\n\nint main() {\n    int n, m; scanf(\"%d%d%s\", &n, &m, s + 1);\n    bool flag = false;\n    for (int i = 1; i <= m; i++) if (s[i] != s[1]) {\n        flag = true; break;\n    } \n    if (flag) {\n        if (n & 1) return puts(\"0\"), 0;\n        int fir = 0;\n        for (int i = 1; i <= m; i++) if (s[i] != s[1]) {\n            fir = i - 1; break;\n        }\n        int lim = fir | 1;\n        for (int i = fir + 1; i <= m; i++) if (s[i] != s[1]) {\n            int j = i + 1;\n            while (j <= m && s[j] == s[1]) j++;\n            if (j <= m && (j - i - 1) % 2 == 1) lim = min(lim, j - i - 1); \n        } \n        n /= 2, lim = (lim + 1) / 2;\n        for (int i = 1; i <= lim; i++) f[i] = i * 2;\n        for (int i = 1, diff = 0; i <= n; i++) {\n            diff = (diff + g[i]) % mod, f[i] = (f[i] + diff) % mod;\n            if (i + 1 <= n) g[i + 1] = (g[i + 1] + f[i]) % mod;\n            if (i + lim + 1 <= n) g[i + lim + 1] = (g[i + lim + 1] - f[i] + mod) % mod;\n        }\n        printf(\"%d\\n\", f[n]);\n    } else {\n        dp[1][1][1] = dp[0][0][1] = 1;\n        for (int i = 2; i <= n; i++) \n            for (int t = 0; t <= 1; t++) {\n                dp[t][0][i] = (dp[t][1][i - 1] + dp[t][0][i - 1]) % mod;\n                dp[t][1][i] = dp[t][0][i - 1];\n            }\n        printf(\"%d\\n\", ((LL)dp[1][0][n] + dp[0][0][n] + dp[0][1][n]) % mod);\n    }\n    return 0;\n}//"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define pld pair <ld, ld>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n#define cld complex <double>\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 3e5;\nconst ll mod = 1e9 + 7;\n\nll n, m, k, t;\n\nstring s;\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;\n}\n\nll simple() {\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    ll q;\n    for (q = 1; q < n; q++) {\n        D[q] += D[q - 1];\n        if (q >= 2) {\n            D[q] += D[q - 2];\n            D[q] %= mod;\n        }\n    }\n    return (D[n - 2] * 2 + D[n - 1]) % mod;\n    // if (n % 2 == 1) {\n    //     return \n    // }\n    // return step(2, n / 2 + 1);\n}\n\nint main() {\n    pyshnapyshnakaa\n    ll q, w, e, a, b, c;\n    cin >> n >> m;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (q = 0; q < s.length(); q++) {\n            if (s[q] == 'R') {\n                s[q] = 'B';\n            }\n            else {\n                s[q] = 'R';\n            }\n        }\n    }\n    bool fail = 0, blue = 0;\n    for (q = 0; q < s.length(); q++) {\n        if (s[q] == 'B') {\n            blue = 1;\n        }\n        if (q >= 1) {\n            if (s[q - 1] == s[q] && s[q] == 'B') {\n                fail = 1;\n            }\n        }\n    }\n    if (fail) {\n        cout << 0;\n        return -1;\n    }\n    if (!blue) {\n        cout << simple();\n        return -1;\n    }\n    ll mx = maxn, cur = 0;\n    for (q = 0; q < s.length(); q++) {\n        if (s[q] == 'B') {\n            if (cur % 2 == 1) {\n                mx = min(mx, cur);\n            }\n            else {\n                mx = min(mx, cur + 1);\n            }\n            cur = 0;\n        }\n        else {\n            cur++;\n        }\n    }\n    vector <ll> S(2);\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    S[0] = 1;\n    for (q = 1; q < n; q++) {\n        D[q] = S[q % 2];\n        S[q % 2] = (S[q % 2] + D[q]) % mod;\n        ll deli = q - mx - 1;\n        if (deli >= 0) {\n            // cout << \"DELETING \" << q << endl;\n            S[deli % 2] = (S[deli % 2] - D[deli] + mod) % mod;\n        }\n        // cout << q << \" \" << D[q] << endl;\n    }\n    // cout << \"mx \" << mx << endl;\n    ll ans = 0;\n    for (q = 0; q < n; q++) {\n        ll len = n - q - 1;\n        if (len % 2 == 0 || len > mx) {\n            continue;\n        }\n        ans += D[q] * (len + 1) % mod;\n        ans %= mod;\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll dp[202020][2][2];\nll mo=1000000007;\n\nll dp2[202020];\nll dps[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\tif(S[0]=='B') {\n\t\tFORR(c,S) c='R'+'B'-c;\n\t}\n\tif(count(ALL(S),'B')==0) {\n\t\tdp[0][0][0]=dp[0][1][1]=1;\n\t\tfor(i=1;i<N;i++) {\n\t\t\t(dp[i][0][0]=dp[i-1][0][0]+dp[i-1][0][1])%=mo;\n\t\t\t(dp[i][0][1]=dp[i-1][0][0])%=mo;\n\t\t\t(dp[i][1][0]=dp[i-1][1][0]+dp[i-1][1][1])%=mo;\n\t\t\t(dp[i][1][1]=dp[i-1][1][0])%=mo;\n\t\t}\n\t\tcout<<(dp[N-1][0][0]+dp[N-1][0][1]+dp[N-1][1][0])%mo<<endl;\n\t\treturn;\n\t}\n\t\n\tint L=0;\n\twhile(S[L]=='R') L++;\n\t\n\tif(L%2==0) L++;\n\t\n\tdp2[0]=dps[0]=1;\n\tfor(i=2;i<=N;i+=2) {\n\t\tdp2[i]=dps[i-2];\n\t\tif(i-(L+1)>0) (dp2[i]+=mo-dps[i-(L+1)-2])%=mo;\n\t\tdps[i]=(dps[i-2]+dp2[i])%mo;\n\t\t//cout<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=min(L,N-1);i+=2) {\n\t\t//cout<<i<<\" \"<<(i+1)<<\"*\"<<dp2[N-(i+1)]<<endl;\n\t\t(ret+=(i+1)*dp2[N-(i+1)])%=mo;\n\t}\n\tcout<<ret%mo<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,inline\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#include<bits/stdc++.h>\n#define ll long long\n#define int ll\nusing namespace std;\nconst int md=1000000007;\nconst int mxn=200005;\nint n,m,mx,ans,dp[mxn],f[mxn];\nchar s[mxn];\ninline void add(int&x,int y){\n\tx+=y;\n\tif(x>=md)x-=md;\n}\nsigned main(){\n\tint i,j,t;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(i=1;i<=m;++i)if(s[i]!=s[1])break;mx=i-1;\n\tif(mx==m){\n\t\tdp[0]=f[i]=ans=1;\n\t\tfor(int i=0;i<=n;++i){\n\t\t\tif(i>=2)dp[i]=f[i-2];\n\t\t\tf[i]=(f[i-1]+dp[i])%md;\n\t\t\tif(n-i>1)add(ans,dp[i]*(n-i)%md);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(n&1)return 0*puts(\"0\");\n\tif(!(mx&1))++mx;\n\tfor(t=0;i<=m;++i){\n\t\tif(s[i]==s[1])++t;\n\t\telse{\n\t\t\tif(t&1)mx=min(mx,t);\n\t\t\tt=0;\n\t\t}\n\t}\n\tn>>=1,mx=mx+1>>1;\n\tdp[0]=f[0]=1;\n\tfor(i=0;i<=n;++i){\n\t\tif(i){\n\t\t\tdp[i]=(md+f[i-1]-(i-mx-1>=0?f[i-mx-1]:0))%md;\n\t\t\tf[i]=(f[i-1]+dp[i])%md;\n\t\t}\n\t\tif(n-i<=mx) add(ans,(n-i)*dp[i]*2%md);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\ntemplate<typename T>\nclass RangeAddQuery {\npublic:\n    explicit RangeAddQuery(int n) : N(calcN_(n)) {\n        mVal.assign(2*N+1, 0);\n    }\n    void update(int l, int r, T value){\n        l = max(0, l);\n        r = min(N, r);\n        int offset = N;\n        while(offset > 0){\n            if(l >= r) break;\n            if(l&1){ update_(mVal[offset+l-1], value); l++; }\n            if(r&1){ update_(mVal[offset+r-2], value); }\n            l /= 2;\n            r /= 2;\n            offset /= 2;\n        }\n    }\n    T get(int idx){\n        int i = N + idx - 1;\n        auto res = mVal[i];\n        while(i > 0){\n            i = (i-1)/2;\n            update_(res, mVal[i]);\n        }\n        return res;\n    }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    inline void update_(T& data, T val) { data = (data + val) % MOD; }\n    const int N;\n    vector<T> mVal;\n};\n\nint maxSegment(const string& S){\n    char c = S[0];\n    bool first = true;\n    int cnt = 0;\n    int res = MOD;\n    for(auto& s : S){\n        if(c == s) ++cnt;\n        else {\n            if(first || cnt%2 == 1){\n                res = min(res, cnt/2+1);\n                first = false;\n            }\n            cnt = 0;\n        }\n    }\n    return res < MOD ? res : -1;\n}\n\nint solve(const string& S, int N){\n    int seg = maxSegment(S);\n    if(seg != -1 && N%2 == 1) return 0;\n    long long res = 0;\n    if(seg == -1){\n        RangeAddQuery<long long> raq(N);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N;i++){\n            auto a = raq.get(i);\n            raq.update(i+2, N, a);\n        }\n        res = 1;\n        for(int i=N-2;i>=0;i--){\n            res = (res + raq.get(i) * (N-i)) % MOD;\n        }\n    } else {\n        seg = min(seg, N/2);\n        RangeAddQuery<long long> raq(N/2);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N/2;i++){\n            auto a = raq.get(i);\n            raq.update(i+1, i+1+seg, a);\n        }\n        for(int i=N/2-1;i>=N/2-seg;i--){\n            res = (res + raq.get(i) * 2 * (N/2-i)) % MOD;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    cout << solve(S, N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\n#ifdef AIM\n#include <sys/resource.h>\n#endif\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\nusing li = long long;\nusing ld = long double;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  freopen(\"/home/alexandero/CLionProjects/ACM/input.txt\", \"r\", stdin);\n  //freopen(\"/home/alexandero/CLionProjects/ACM/output.txt\", \"w\", stdout);\n//freopen(\"out.txt\", \"w\", stdout);\n#else\n  //freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n#ifdef AIM\n  const rlim_t kStackSize = 256 * 1024 * 1024;\n  struct rlimit rl;\n  int result;\n\n  result = getrlimit(RLIMIT_STACK, &rl);\n  if (result == 0) {\n    if (rl.rlim_cur < kStackSize) {\n      rl.rlim_cur = kStackSize;\n      result = setrlimit(RLIMIT_STACK, &rl);\n      if (result != 0) {\n        fprintf(stderr, \"setrlimit returned result = %d\\n\", result);\n      }\n    }\n  }\n#endif\n\n  start = clock();\n  int t = 1;\n#ifndef AIM\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n#endif\n  cout.precision(20);\n  cout << fixed;\n  //cin >> t;\n  precalc();\n  while (t--) {\n    solve(true);\n  }\n  cout.flush();\n\n#ifdef AIM1\n  while (true) {\n    solve(false);\n  }\n#endif\n\n#ifdef AIM\n  cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\ntemplate <typename T>\nvoid make_unique(vector<T>& vec) {\n  sort(all(vec));\n  vec.erase(unique(all(vec)), vec.end());\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\nmt19937 rng((unsigned long long)chrono::steady_clock::now().time_since_epoch().count());\n\nvoid precalc() {\n\n}\n\n#define int li\nconst li mod = 1000000007;\n//const int mod = 998244353;\n//using ull = unsigned long long;\n\nvoid add(int& cur, int val) {\n  cur += val;\n  cur %= mod;\n  if (cur < 0) {\n    cur += mod;\n  }\n}\n\nint get_stupid(int n, int m, string s) {\n  int ans = 0;\n  for (int mask = 0; mask < (1 << n); ++mask) {\n    vector<int> dp(n);\n    for (int i = 0; i < n; ++i) {\n      dp[i] = (1 << i);\n    }\n    bool f = true;\n    for (char c : s) {\n      bool need = (c == 'R');\n      vector<int> new_dp(n, 0);\n      for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n          if (dp[i] & (1 << j)) {\n            if ((bool)(mask & (1 << j)) == need) {\n              new_dp[i] |= (1 << ((j + 1) % n));\n            }\n            int prev = ((j - 1 + n) % n);\n            if ((bool)(mask & (1 << prev)) == need) {\n              new_dp[i] |= (1 << prev);\n            }\n          }\n        }\n        if (new_dp[i] == 0) {\n          f = false;\n          break;\n        }\n      }\n      if (!f) {\n        break;\n      }\n      new_dp.swap(dp);\n    }\n    if (f) {\n      ++ans;\n    }\n  }\n  return ans;\n}\n\nvoid solve(__attribute__((unused)) bool read) {\n  int n, m;\n  string s;\n  if (read) {\n    cin >> n >> m;\n    cin >> s;\n  } else {\n    n = rand() % 10 + 2;\n    m = rand() % 10 + 1;\n    for (int i = 0; i < m; ++i) {\n      s += \"RB\"[rand() & 1];\n    }\n  }\n\n  //int stupid_res = get_stupid(n, m, s);\n\n  if (s[0] == 'B') {\n    for (char& c : s) {\n      c = 'B' + 'R' - c;\n    }\n  }\n  const int INF = (int)1e9;\n  int max_segment = INF;\n  int last = 0;\n  for (int i = 0; i < s.length(); ++i) {\n    if (s[i] == 'B') {\n      int cur_len = i - last;\n      if (last == 0) {\n        if (cur_len % 2 == 0) {\n          ++cur_len;\n        }\n        relax_min(max_segment, cur_len);\n      } else if (cur_len % 2) {\n        relax_min(max_segment, cur_len);\n      }\n      last = i + 1;\n    }\n  }\n  int res = 0;\n  if (last == 0) {\n    vector<int> fib(n + 1);\n    fib[0] = 1;\n    fib[1] = 2;\n    for (int i = 2; i < fib.size(); ++i) {\n      fib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n    }\n    if (n == 2) {\n      res = 3;\n    } else {\n      add(res, fib[n - 1]);\n      if (n > 2) {\n        add(res, fib[n - 3]);\n      }\n    }\n  } else {\n    int max_divided = (max_segment + 1) / 2;\n    //cout << max_segment << \" \" << max_divided << endl;\n    vector<int> dp(n + 1, 0);\n    dp[0] = 1;\n    vector<int> add_to_pref(n + 1, 0);\n    int pref_add = 0;\n    for (int i = 0; i <= n; ++i) {\n      add(pref_add, add_to_pref[i]);\n      add(dp[i], pref_add);\n      add(pref_add, dp[i]);\n      if (i + max_divided < n) {\n        add(add_to_pref[i + max_divided + 1], -dp[i]);\n      }\n      /*if (i < n / 2) {\n        cout << i << \" \" << dp[i] << endl;\n      }*/\n    }\n    if (n % 2 == 0) {\n      for (int seg = 2; seg <= 2 * max_divided && seg <= n; seg += 2) {\n        //cout << \"add seg: \" << seg << \" rest: \" << (n - seg) / 2 << \" dp: \" << dp[(n - seg) / 2] << endl;\n        res += dp[(n - seg) / 2] * seg;\n        res %= mod;\n      }\n    }\n  }\n\n  /*if (res != stupid_res) {\n    cout << \"FOUND res: \" << res << \" stupid: \" << stupid_res << endl;\n    cout << n << \" \" << m << \"\\n\" << s << endl;\n    exit(0);\n  } else {\n    cout << \"ok res: \" << res << endl;\n    return;\n  }*/\n\n  cout << res << \"\\n\";\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint N, M; char S[200200];\n\nconst long long mod = 1000000007;\nlong long D[200200], V[200200];\n\nint main()\n{\n\tscanf (\"%d %d %s\", &N, &M, S);\n\tif (S[0] == 'B'){\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tif (S[i] == 'R') S[i] = 'B';\n\t\t\telse S[i] = 'R';\n\t\t}\n\t}\n\n\tvector<int> len;\n\tfor (int i = 1, l = -1; i < M; i++){\n\t\tif (S[i-1] == 'R' && S[i] == 'B'){\n\t\t\tint u = i - l - 1;\n\t\t\tlen.push_back(u);\n\t\t\tl = i;\n\t\t}\n\t}\n\n\tif (len.empty()){\n\t\tif (N == 2){\n\t\t\tprintf (\"3\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tD[0] = 1;\n\t\tD[1] = 1;\n\t\tfor (int i = 2; i <= N; i++) D[i] = (D[i - 1] + D[i - 2]) % mod;\n\t\tprintf (\"%lld\\n\", (D[N - 1] + D[N - 3] + 1) % mod);\n\t\treturn 0;\n\t}\n\n\tint lim = len[0];\n\tif (lim % 2 == 0) lim++;\n\telse lim += 2;\n\tfor (int i = 1; i < len.size(); i++){\n\t\tif (len[i] % 2){\n\t\t\tif (lim > len[i])\n\t\t\t\tlim = len[i];\n\t\t}\n\t}\n\n\tD[0] = V[0] = 1;\n\tfor (int i = 1; i <= N; i++){\n\t\tif (i <= lim + 1) D[i] = i - 1;\n\t\tlong long u = 0, v = 0;\n\t\tif (i >= 2) u = V[i - 2];\n\t\tif (i >= lim + 3) v = V[i - (lim + 3)];\n\t\tD[i] = (D[i] + u + mod - v) % mod;\n\n\t\tV[i] = D[i];\n\t\tif (i >= 2) V[i] = (V[i] + V[i - 2]) % mod;\n\t}\n\tprintf (\"%lld\\n\", D[N]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint int\nusing namespace std;\n     \ntypedef long long lo;\n     \ntemplate<typename tp> inline void read(tp &x) {\n\tx = 0; char c = getchar(); int f = 0;\n\tfor (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n\tfor (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n\tif (f) x = -x;\n}\nnamespace {\n    const int mo = 1e9 + 7;\n    inline int add(int x, int y) { x += y; return x >= mo ? x - mo : x; }\n    inline int sub(int x, int y) { x -= y; return x < 0 ? x + mo : x; }\n    inline int mul(int x, int y) { return (lo) x * y % mo; }\n    inline int power(int a, int k = mo - 2) {\n\t\tint ans = 1;\n\t\tfor (; k; k >>= 1, a = mul(a, a))\n\t\t\tif (k & 1) ans = mul(ans, a);\n\t\treturn ans;\n    }\n\tinline void U(int &x, int y) { x = add(x, y); } \n}\n\nconst int N = 3e5 + 23;\nint n, m;\nchar str[N];\n\ninline int spj() {\n\tint ans = 0;\n\tfor (int fi = 0; fi < 2; fi++) {\n\t\tvector <vector <int> > dp(n + 1, vector <int> (2, 0));\n\t\tdp[1][fi] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tU(dp[i][0], dp[i - 1][1]);\n\t\t\tU(dp[i][0], dp[i - 1][0]);\n\t\t\tU(dp[i][1], dp[i - 1][0]);\n\t\t\t// cout << dp[i][0] << \" \" << dp[i][1] << \"\\n\";\n\t\t}\n\t\tif (fi == 0) ans = add(ans, add(dp[n][0], dp[n][1]));\n\t\telse ans = add(ans, dp[n][0]);\n\t}\n\treturn ans;\n}\n\ninline int doit(int limit) {\n\t++limit;\n\tvector <int> dp(n + 1, 0);\n\tvector <int> sum(n + 1, 0);\n\tdp[0] = sum[0] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tauto getsum = [&](int l, int r) {\n\t\t\tif ((l & 1) != (r & 1)) ++l;\n\t\t\tif (l > r || r < 0) return 0;\n\t\t\telse return sub(sum[r], l >= 2 ? sum[l - 2] : 0);\n\t\t};\n\t\t// for (int k = i - 2; k >= 0 && k >= i - limit; k -= 2)\n\t\t// \tU(dp[i], dp[k]);\n\t\tU(dp[i], getsum(max(0, i - limit), i - 2));\n\t\tsum[i] = dp[i];\n\t\tif (i > 1) U(sum[i], sum[i - 2]);\n\t}\n\tint ans = 0;\n\tfor (int pre = 2; pre <= limit; pre += 2) {\n\t\tU(ans, mul(pre, dp[n - pre]));\n\t}\n\treturn ans;\n}\n\nint main(void) {\n\tread(n); read(m);\n\tscanf(\"%s\", str + 1);\n\tint first = 0;\n\tfor (int i = 1; i <= m; i++) \n\t\tif (str[i] != str[1]) { first = i; break; }\n\tif (first == 0) {\n\t\tcout << spj() << \"\\n\";\n\t\treturn 0;\n\t}\n\t--first;\n\t// cout << \"first = \" << first << \"\\n\";\n\tint limit = first & 1 ? first : first + 1;\n\tint con = limit;\n\tfor (int i = first + 1; i <= m; i++) {\n\t\tif (str[i] != str[1]) {\n\t\t\tif (con & 1) limit = min(limit, con);\n\t\t\tcon = 0;\n\t\t} else {\n\t\t\t++con;\n\t\t}\t\t\t   \n\t}\n\tif (con & 1) limit = min(limit, con);\n\t// cerr << \"limit = \" << limit << \"\\n\";\n\tcout << doit(limit) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vvvvi=vector<vvvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst ll INF=1001001001;\nconst ll mod=1000000007;\nconst long double eps=1e-60;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\n\nll solve(ll n,ll k){\n    //outp(P(n,k));\n    chmin(k,n-1);\n    vi dp(n+1);\n    ll sum=1;\n    dp[0]=1;\n    REP(i,1,n+1){\n        dp[i]=sum;\n        sum=(sum+dp[i])%mod;\n        if(i>k)sum=(sum-dp[i-k-1]+mod)%mod;\n    }\n    //outv(dp);\n    ll res=0;\n    REP(i,n-k,n+1)res=(res+dp[i-1]*(n-i+1))%mod;\n    //rep(i,k+1)res=(res+dp[n-i-1]*(i+1))%mod;\n    return res;\n}\n\nint main(){\n    ll n,m;cin>>n>>m;\n    string s;cin>>s;\n    vi v(m);\n    bool dif=false;\n    rep(i,m){\n        if(s[i]==s[0])v[i]=1;\n        else dif=true;\n    }\n    if(!dif){\n        out(solve(n,1));\n    }\n    else{\n        if(n&1)dame(0);\n        int w=0;\n        while(w<m){\n            if(!v[w])break;\n            w++;\n        }\n        ll mi=w;\n        w++;\n        ll cnt=0;\n        while(w<m){\n            if(!v[w]){\n                if(cnt&1)chmin(mi,cnt);\n                cnt=0;\n            }\n            else cnt++;\n            w++;\n        }\n        out(solve(n/2,mi/2)*2%mod);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define pld pair <ld, ld>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n#define cld complex <double>\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 3e5;\nconst ll mod = 1e9 + 7;\n\nll n, m, k, t;\n\nstring s;\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;\n}\n\nll simple() {\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    ll q;\n    for (q = 1; q < n; q++) {\n        D[q] += D[q - 1];\n        if (q >= 2) {\n            D[q] += D[q - 2];\n            D[q] %= mod;\n        }\n    }\n    return (D[n - 2] * 2 + D[n - 1]) % mod;\n    // if (n % 2 == 1) {\n    //     return \n    // }\n    // return step(2, n / 2 + 1);\n}\n\nint main() {\n    pyshnapyshnakaa\n    ll q, w, e, a, b, c;\n    cin >> n >> m;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (q = 0; q < s.length(); q++) {\n            if (s[q] == 'R') {\n                s[q] = 'B';\n            }\n            else {\n                s[q] = 'R';\n            }\n        }\n    }\n    vector <pll> A;\n    A.pb(mp(1, s[0]));\n    for (q = 1; q < s.length(); q++) {\n        if (s[q] == A.back().second) {\n            A.back().first++;\n        }\n        else {\n            A.pb(mp(1, s[q]));\n        }\n    }\n    // cout << \"FALL\" << endl;\n    bool blue = 0, kill = 0;\n    ll mx = maxn;\n    // cout << \"\"\n    for (q = 0; q < A.size(); q++) {\n        if (A[q].second == 'B') {\n            blue = 1;\n            if (A[q].first == 0) {\n                kill = 0;\n            }\n        }\n        else {\n            if (!(A[q].first % 2 == 0 && kill)) {\n                mx = min(mx, A[q].first + 1 - A[q].first % 2);\n            }\n            kill = 0;\n        }\n    }\n    // cout << \"MX \" << mx << endl;\n    // if (fail) {\n    //     cout << 0;\n    //     return 0;\n    // }\n    if (!blue) {\n        cout << simple();\n        return 0;\n    }\n    // ll mx = maxn, cur = 0;\n    // for (q = 0; q < s.length(); q++) {\n    //     if (s[q] == 'B') {\n    //         if (cur % 2 == 1) {\n    //             mx = min(mx, cur);\n    //         }\n    //         else {\n    //             mx = min(mx, cur + 1);\n    //         }\n    //         cur = 0;\n    //     }\n    //     else {\n    //         cur++;\n    //     }\n    // }\n    vector <ll> S(2);\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    S[0] = 1;\n    for (q = 1; q < n; q++) {\n        D[q] = S[q % 2];\n        S[q % 2] = (S[q % 2] + D[q]) % mod;\n        ll deli = q - mx - 1;\n        if (deli >= 0) {\n            // cout << \"DELETING \" << q << endl;\n            S[deli % 2] = (S[deli % 2] - D[deli] + mod) % mod;\n        }\n        // cout << q << \" \" << D[q] << endl;\n    }\n    // cout << \"mx \" << mx << endl;\n    ll ans = 0;\n    for (q = 0; q < n; q++) {\n        ll len = n - q - 1;\n        if (len % 2 == 0 || len > mx) {\n            continue;\n        }\n        ans += D[q] * (len + 1) % mod;\n        ans %= mod;\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"base.hpp\"//5\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//5b\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n#line 1 \"mod.hpp\"//5b\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//5bm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//5b\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//5b\nusing unit = tuple<>;using int128=__int128;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing VM=vec<mint>;using VI=vec<int>;\n#line 1 \"alias.hpp\"//5b\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//5b\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nnamespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}TL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){\nRT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//5b\nTL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)\n#line 6001 \"base.hpp\"//5\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1001 \"5.cpp\"//\n//#include \"consts.hpp\"\n// #include \"prime.hpp\"\n\nvoid solve() {\n// NM\"S\"\n/* <foxy.memo-area> */\nint N;int M;string S;cin>>N;cin>>M;cin>>S;\n/* </foxy.memo-area> */\n\n  if(S[0] == 'B') {\n    times(M, i) S[i] = 'R' + 'B' - S[i];\n  }\n\n  int p = 1ll << 60;\n  {\n    int ren = 1;\n    times(M, i) {\n      if(S[i] == 'R') {\n        ++ren;\n      } else {\n        if(p == 1ll << 60 || ren % 2 == 1) {\n          amin(p, ren);\n        }\n        ren = 0;\n      }\n    }\n  }\n  {if(debug)cerr<<\"p: \"<<(p)ln;}\n#define M hoge\n\n  if(p > N) {\n    mint ans = 0_m;\n    {\n      // [0]->R\n      VM dp(N);\n      dp[0] = 1_m;\n      dp[1] = 2_m;\n      uptil(2, N, i) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n      }\n      ans += dp[N - 1];\n      {if(debug)cerr<<\"dp: \"<<(dp)ln;}\n    }\n    {\n      // [0]->B\n      VM dp(N - 1);\n      dp[0] = 1_m;\n      if(N >= 3) dp[1] = 1_m;\n      uptil(2, N - 1, i) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n      }\n      ans += dp[N - 2];\n      {if(debug)cerr<<\"dp: \"<<(dp)ln;}\n    }\n\n    cout << ans ln;\n    return;\n  }\n\n  if(N % 2 == 1) {\n    cout << 0 ln;\n    return;\n  }\n\n  int m = N / 2;\n  int q = (p + 1) / 2;\n\n#define N hoge\n#define p hoge\n\n  /*\n  auto pfh = prime_factor(m);\n  int zpf = size(pfh);\n  VI pf; pf.reserve(zpf);\n  for(auto &p : pfh) pf.PB(p.first);\n  {if(debug)cerr<<\"pf: \"<<(pf)ln;}\n  */\n\n  /*\n  VI pf;\n  for(int i = 1; i*i <= m; ++i) {\n    if(m % i == 0) {\n      pf.PB(i);\n      if(i*i != m) pf.PB(m / i);\n    }\n  }\n  sort(iter(pf));\n  */\n  VI pf = {m};\n  {if(debug)cerr<<\"pf: \"<<(pf)ln;}\n  int zpf = size(pf);\n\n  VM dp(m);\n  VM g(zpf);\n\n  mint ans = 0_m;\n\n  times(zpf, h) {\n    mint s = dp[0] = 1_m;\n    uptil(1, pf[h], i) {\n      s += dp[i] = s;\n      if(i >= q) {\n        s -= dp[i - q];\n      }\n      if(i <= q) {\n        dp[i] += dp[0] * mint(i - 1);\n        s += dp[0] * mint(i - 1);\n      }\n    }\n\n    g[h] = s;\n    times(h, hh) {\n      if(pf[h] % pf[hh] == 0) g[h] -= g[hh];\n    }\n    ans += g[h] ;//* mint(pf[h]);\n\n    {if(debug)cerr<<'#'<<__LINE__ ln<<\"  h:     \"<<(h)ln<<\"  pf[h]: \"<<(pf[h])ln<<\"  s:     \"<<(s)ln<<\"  g[h]:  \"<<(g[h])ln<<\"  dp:    \"<<(dp)ln;}\n  }\n\n  cout << ans * 2_m ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-03 17:07:09\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=200010,mod=1000000007;\nint n,m,flag,l,Flag;\ni64 f[N],F[N],ans;\nchar s[N];\nint main()\n{\n\tn=read(); m=read();\n\tscanf(\"%s\",s+1);\n\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\tif(!flag)\n\t{\n\t\tf[1]=1; f[2]=2;\n\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t\treturn 1;\n\t}\n\tl=n-1;\n\tfor(int i=1,j;i<=m;)\n\t\tif(s[i]==s[1])\n\t\t{\n\t\t\tj=i;\n\t\t\twhile(s[j]==s[1]) j++;\n\t\t\tif(j>n) break;\n\t\t\tif(((j-i)&1)||(!Flag)) l=std::min(l,(j-i)+(!((j-i)&1)));\n\t\t\ti=j+1; Flag=1;\n\t\t}\n\t\telse i++;\n\tif(n&1){ printf(\"0\\n\"); return 0; }\n\tn/=2; l=(l+1)/2;\n//\tprintf(\"%d %d\\n\",int(n),int(l));\n\tf[0]=F[0]=1;\n\tfr(i,1,n)\n\t{\n\t\tf[i]=(F[i-1]+mod-(i-l-1>=0?F[i-l-1]:0))%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t}\n\tans=f[n];\n\tfr(i,1,l) ans=(ans+f[n-i]*(2*i-1))%mod;\n\tprintf(\"%d\\n\",int(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD_> struct ModInt {\n    static const unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    ModInt extgcd() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 1000000007;\n//const LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\nint N, M;\nchar S[200011];\nMint dp0[200011];\nMint dp1[200011];\n\nvoid MAIN() {\n    scanf(\"%d%d%s\", &N, &M, S);\n\n    Mint ans;\n    char h = S[0];\n    REP (i, M) S[i] = (S[i] == h? '0': '1');\n    int z = count(S, S+M, '0');\n\n    if (z == M || z == 0) {\n\tans = 1;\n\t// fib\n\tREP (i, N) {\n\t    // 0;\n\t    dp0[i+1] += dp0[i] + dp1[i];\n\t    // 1\n\t    dp1[i+1] += dp0[i];\n\t    // 0...01;\n\t    dp1[i+2] += i+2;\n\t}\n\tans += dp1[N];\n    } else if (N % 2 == 0) {\n\tint head = -1;\n\tint cnt = 0;\n\tint mi = N-1;\n\tREP (i, M) {\n\t    if (S[i] == '0') cnt++;\n\t    else {\n\t\tif (head == -1) head = cnt;\n\t\tif (cnt % 2 == 1) amin(mi, cnt);\n\t\tcnt = 0;\n\t    }\n\t}\n\tif (head % 2 == 0) amin(mi, head+1);\n\n\tMint t0 = 0, t1 = 0;\n\tREP (i, N+1) {\n\t    dp1[i] += t0;\n\n\t    if (2 <= i && i % 2 == 0 && i-1 <= mi) {\n\t\tdp1[i] += i;\n\t    }\n\n\t    if (i-mi-1 >= 0) t0 -= dp1[i-mi-1];\n\t    t0 += dp1[i];\n\t    swap(t0, t1);\n\t}\n\tans = dp1[N];\n\n    } else {\n\tans = 0;\n    }\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n        if(dp[i-1] < 0)dp[i-1] %= MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0);res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    return res;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i <= m;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nll dp[1 << 18][2][2];\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (s[0] == 'B') {\n\t\trep(i, m) {\n\t\t\tif (s[i] == 'B')s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\tvector<int> v;\n\trep(i, m) {\n\t\tint le = i;\n\t\twhile (i + 1 < m&&s[i + 1] == s[i])i++;\n\t\tv.push_back(i - le + 1);\n\t}\n\tif (v.size() == 1) {\n\t\tdp[0][0][0] = 1;\n\t\tdp[0][1][1] = 1;\n\t\trep(i, n-1) {\n\t\t\trep(j, 2) {\n\t\t\t\t(dp[i + 1][0][j] += dp[i][0][j] + dp[i][1][j])%=mod;\n\t\t\t\tdp[i + 1][1][j] += dp[i][0][j];\n\t\t\t}\n\t\t}\n\t\tll ans = dp[n-1][0][0] + dp[n-1][1][0] + dp[n-1][0][1];\n\t\tcout << ans % mod << endl; return;\n\t}\n\tfor (int i = 0; i < v.size(); i += 2) {\n\t\tif (v[i] % 2) {\n\t\t\tif (n % 2) {\n\t\t\t\tcout << 0 << endl; return;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << 2 << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tint d = n / 2;\n\tint x = v[0] / 2+1;\n\tif (x >= d+1) {\n\t\tll ans = mod_pow(2, d) - 1;\n\t\tans = ans * 2;\n\t\tans = (ans + mod) % mod;\n\t\tcout << ans << endl;\n\t}\n\telse {\n\t\tll ans = d * mod_pow(2, d -x-1)%mod;\n\t\t\n\t\tans = mod_pow(2, d) - 1 - ans;\n\t\tans = (ans%mod + mod) % mod;\n\t\tcout << ans*2%mod << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\nll dp[200010] = {},mod = 1000000007;\nstring s;\nvector<pair<char,int>> v;\nint main(){\n\tll i,j,n,m;\n\tcin >> n >> m >> s;\n\tif(s[0]=='B'){\n\t\tfor(i=0;i<m;i++){\n\t\t\tif(s[i]=='R') s[i] = 'B';\n\t\t\telse s[i] = 'R';\n\t\t}\n\t}\n\tfor(i=0;i<m;i++){\n\t\tif(i==0 || v.back().first!=s[i]){\n\t\t\tv.push_back({s[i],1});\n\t\t}else{\n\t\t\tv.back().second++;\n\t\t}\n\t}\n\tif(v.size()==1){\n\t\tcout << n + 1 << endl;\n\t\treturn 0;\n\t}\n\tif(n&1){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tif(v.back().first=='R'){\n\t\tv.pop_back();\n\t}\n\tint mn = -1;\n\tfor(i=0;i<v.size();i++){\n\t\tif(i==0){\n\t\t\tmn = v[i].second + 1 - (v[i].second&1);\n\t\t}\n\t\tif(v[i].first=='R' && (v[i].second&1)){\n\t\t\tmn = min(mn,v[i].second);\n\t\t}\n\t}\n\tmn++;\n\tdp[0] = 1;\n\tll sum = 1;\n\tfor(i=2;i<=n;i+=2){\n\t\t(dp[i] += sum) %= mod;\n\t\t(sum += dp[i]) %= mod;\n\t\tif(i>=mn) sum -= dp[i - mn];\n\t\tif(sum<0) sum += mod;\n\t}\n\tll ans = 0;\n\tfor(i=2;i<=mn;i+=2){\n\t\t(ans += i*dp[n - i]) %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,Mod=1e9+7;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\n//inline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\ninline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n,m,Mx,p,ans,F[MAXN],Sum[MAXN];char s[MAXN];\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),m=read(),scanf(\"%s\",s+1),Mx=m,p=m+1;\n\tRep(i,1,m)if(s[i]!=s[1]){Mx=i-1,p=i;break;}\n\tif(Mx==m){\n\t\tF[0]=Sum[0]=ans=1;\n\t\tRep(i,0,n)(i>=2?F[i]=Sum[i-2]:0),(i?Sum[i]=(Sum[i-1]+F[i])%Mod:0),(n-i>=2?ans=(ans+1ll*F[i]*(n-i))%Mod:0);\n\t\tcout<<ans<<'\\n';return 0;\n\t}if(n&1)return puts(\"0\"),0;if(!(Mx&1))Mx++;\n\tfor(int t=0,i=p;i<=m;i++)if(s[i]==s[1])t++;else (t&1?Mx=min(Mx,t):0),t=0;\n\tn/=2,Mx=(Mx+1)/2,F[0]=Sum[0]=1;\n\tRep(i,0,n){\n\t\tif(i)F[i]=(Sum[i-1]-(i-Mx-1>=0?Sum[i-Mx-1]:0)+Mod)%Mod,Sum[i]=(Sum[i-1]+F[i])%Mod;\n\t\tif(n-i<=Mx)ans=(ans+1ll*F[i]*(n-i)*2)%Mod;\n\t}cout<<ans<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define int long long\nusing namespace std;\nconst int N=2e5+2;\nconst int mod=1e9+7;\nint dp[N],sum[N];\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,max1,ans=0,m;\n\tstring s;\n\tcin>>n>>m>>s;\n\tif(s[0]=='B'){\n\t\tfor(i=0;i<m;i++){\n\t\t\tif(s[i]=='B'){\n\t\t\t\ts[i]='R';\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts[i]='B';\n\t\t\t}\n\t\t}\n//\t\tcout<<s<<endl;\n\t}\n\tbool cac=true;\n\tfor(i=1;i<m;i++){\n\t\tif(s[i]!=s[i-1]){\n\t\t\tcac=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(cac){\n\t\tdp[0]=1;\n\t\tsum[0]=1;\n\t\tans=1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(i!=1){\n\t\t\t\tdp[i]=sum[i-2];\n\t\t\t}\n\t\t\tsum[i]=sum[i-1];\n\t\t\tsum[i]+=dp[i];\n\t\t\tif(sum[i]>=mod){\n\t\t\t\tsum[i]-mod;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n-1;i++){\n\t\t\tans+=(i+1)*dp[n-i-1];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout<<ans;\n\t}\n\telse{\n\t\tif(n&1){\n\t\t\tcout<<1/0;\n\t\t\treturn 0;\n\t\t}\n\t\tmax1=n-1;\n\t\tcac=true;\n\t\tj=1;\n\t\tfor(i=1;i<m;i++){\n\t\t\tif(s[i]==s[i-1]){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(s[i]=='B'){\n\t\t\t\t\tif(cac){\n\t\t\t\t\t\tif(j&1){\n\t\t\t\t\t\t\tmax1=min(max1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmax1=min(max1,j+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcac=false;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(j&1){\n\t\t\t\t\t\t\tmax1=min(max1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj=1;\n\t\t\t}\n\t\t}\n\t\tdp[0]=1;\n\t\tsum[0]=1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tsum[i]=sum[i-1];\n\t\t\tif(i&1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i]=sum[i-2];\n\t\t\tif(i-max1-2>=0){\n\t\t\t\tdp[i]-=sum[i-max1-2];\n\t\t\t\tif(dp[i]<0){\n\t\t\t\t\tdp[i]+=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum[i]+=dp[i];\n\t\t\tif(sum[i]>=mod){\n\t\t\t\tsum[i]-=mod;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=max1;i+=2){\t\n\t\t\tans+=(i+1)*dp[n-i-1];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout<<ans;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+10;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nint a[MAX_N];\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    ans = dp[n+1];\n    for(ll i = 1;i<=lim;i+=2)\n    {\n        ans += (i*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[0] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-2]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1];\n        for(ll i = 1;i<=n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    int mn = 1e9;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long prime = 1000000007;\n\nbool all_chars_equal(string s) {\n    for (char c : s) {\n        if (c != s[0]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> get_runs(string s) {\n    vector<int> runs;\n    int current_run = 0;\n    for (char c : s) {\n        if (c == s[0]) {\n            ++current_run;\n        } else if (current_run > 0) {\n            runs.push_back(current_run);\n            current_run = 0;\n        }\n    }\n    if (current_run > 0) {\n        runs.push_back(current_run);\n    }\n    return runs;\n}\n\nlong long f(int n, int k) {\n    vector<long long> pow_2(2 * k + 4);\n    pow_2[0] = 1LL;\n    for (int i = 1; i < 2 * k + 4; ++i) {\n        pow_2[i] = pow_2[i - 1] * 2 % prime;\n    }\n\n    vector<long long> f1(n + 1, 0);\n    for (int i = 1; i <= k; ++i) {\n        f1[i] = pow_2[i];\n    }\n    f1[k + 1] = (pow_2[k+1] - 1 + prime) % prime;\n    for (int n1 = k + 2; n1 <= 2 * k + 3; ++n1) {\n        f1[n1] = ((pow_2[n1] - 1 - n1 * pow_2[n1 - k - 2]) % prime + prime) % prime;\n    }\n    for (int n1 = 2 * k + 4; n1 <= n; ++n1) {\n        f1[n1] = ((2 * f1[n1 - 1] - f1[n1 - k - 2]) % prime + prime) % prime;\n    }\n    return f1[n];\n}\n\n/*\nf(n, k) = antal cirkler af længde n med højst k røde i streg (ingen andre begrænsninger)\n\nf(n, k) = 2^n for n <= k\nf(n, k) = 2^n - 1 for n = k+1\nf(n, k) = 2^n - 1 - n * 2^{n-k-2} for k+2 <= n <= 2k+3\nf(n, k) = 2f(n-1, k) - f(n-k-2, k) for n >= 2k + 4\n\n*/\n\nlong long different_case(int n, int k) {\n    return f(n / 2, (k - 1) / 2) * 2LL;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    string s;\n    cin >> n >> m;\n    cin >> s;\n    auto t0 = clock();\n    if (all_chars_equal(s)) {\n        cout << f(n, 1) << endl;  // OK since n >= 2\n        cerr << \"Time used: \" << clock() - t0 << \" ms\" << endl;\n        return 0;\n    }\n    if (n % 2 != 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n    vector<int> runs = get_runs(s);\n    int bound = runs[0] / 2 * 2 + 1;\n    bound = min(bound, n - 1);\n    for (int run : runs) {\n        if (run % 2 == 1) {\n            bound = min(bound, run);\n        }\n    }\n    cout << different_case(n, bound) << endl;\n\n    cerr << \"Time used: \" << clock() - t0 << \" ms\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+100;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    if (lim>n)\n        exit(1);\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    ans = dp[n+1];\n    for(ll i = 1;i<=lim;i+=2)\n    {\n        ans += (i*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    int mn = 1e9;\n    if (vc[0]%2==0)\n        mn = vc[0]+1;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\ntypedef pair<int, int> P;\nconst long long inf = 1ll << 61;\nconst long long mod = 1000000007;\n\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (s[0] == 'B') {\n\t\trep(i, m) {\n\t\t\tif (s[i] == 'R')s[i] = 'B'; else s[i] = 'R';\n\t\t}\n\t}\n\tvector<int>r, b;\n\tchar now = 'R'; int cnt1 = 0;\n\ts.push_back('A');\n\trep(i, m+1) {\n\t\tif (now == s[i])cnt1++;\n\t\telse {\n\t\t\tif (now == 'R')r.push_back(cnt1);\n\t\t\telse b.push_back(cnt1);\n\t\t\tnow = s[i];\n\t\t\tcnt1 = 1;\n\t\t}\n\t}\n\ts.pop_back();\n\n\tif (b.empty()) {//全部一緒\n\t\tvector<int>L(200005);\n\t\tL[0] = 2; L[1] = 1;\n\t\trep(i, 200002)L[i + 2] = (L[i] + L[i + 1]) % mod;\n\t\tcout << L[n] << endl;\n\t\treturn 0;\n\t}\n\n\tif (n & 1) {\n\t\tcout << 0 << endl; return 0;\n\t}\n\telse {\n\t\tint MR = r[0];\n\t\tif (MR & 1)MR += 2;\n\t\telse MR += 1;\n\t\trep(i,r.size()-1){\n\t\t\tint e = r[i];\n\t\t\tif (e & 1)MR = min(MR, e);\n\t\t}\n\t\tif (r.size() == b.size()) {\n\t\t\tint e = r[r.size() - 1];\n\t\t\tMR = min(MR, e);\n\t\t}\n\t\tMR = (MR + 1) / 2;\n\t\tvector<int>dp(200005);\n\t\tint s = 1, as = 1;\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= MR; i++) {\n\t\t\tdp[i] = (as + i) % mod;\n\t\t\tas = (as + dp[i]) % mod;\n\t\t}\n\t\tfor (int i = MR + 1; i <= n; i++) {\n\t\t\tdp[i] = as;\n\t\t\tas += dp[i];\n\t\t\tas -= dp[i - MR];\n\t\t\tas = (as + mod) % mod;\n\t\t}\n\t\tcout << (dp[n/2]*2)%mod << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // clang-format off\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define in2(s,t)     rep(i,sz(s)){in(s[i] , t[i]);}\n#define in3(s,t,u)   rep(i,sz(s)){in(s[i] , t[i] , u[i]);}\n#define in4(s,t,u,v) rep(i,sz(s)){in(s[i] , t[i] , u[i] , v[i]);}\n#ifdef ONLINE_JUDGE\n  #define rep(i,N) for(int i = 0; i < (int)(N); i++)\n  #define repr(i,N) for(int i = (int)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(int i = 1; i <= (int)(N) ; i++)\n  #define repr1(i,N) for(int i = (N) ; (int)(i) > 0 ; i--)\n#else\n  #define rep(i,N) for(long long i = 0; i < (long long)(N); i++)\n  #define repr(i,N) for(long long i = (long long)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(long long i = 1; i <= (long long)(N) ; i++)\n  #define repr1(i,N) for(long long i = (N) ; (long long)(i) > 0 ; i--)\n#endif\nusing namespace std; void solve();\nusing ll = long long; template<class T = ll> using V = vector<T>;\nusing vi = V<int>; using vl = V<>; using vvi = V< V<int> >;\nusing vd = V<double>; using vs = V<string>; using vvl = V< V<> >;\nconstexpr int inf = 1001001001; constexpr ll infLL = (1LL << 61) - 1;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T,typename U>ll ceil(T a,U b){return (a + b - 1) / b;}\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); for(int i=0;i<s;i++) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);} while(0)\n  #define trcc(v) do { cerr << \"name : \" << #v << \"\\n\"; int cnt = 0; each(x , v){cerr << (cnt++) << \" : \"; trc(x); } } while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  #define trcc(...)\n  int main(){solve();}\n#endif\n\nconstexpr ll TEN(int n){ll ret=1,x=10;while(n){if(n&1)ret*=x;x*=x;n>>=1;}return ret;}\n#define mem(a, val) memset(a, val, sizeof(a))\n\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\nusing P = pair<ll,ll>; using vp = V<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n// clang-format on\n////////////////////////////////////////////////////\n\n\nvector<pair<char,int>> RunLengthEncoding(string& S){\n  vector<pair<char,int>> ret;\n  char c = -1;\n  int n = 0;\n  for(char x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate<typename T>\nvector<pair<T,int>> RunLengthEncoding(vector<T>& S){\n  vector<pair<T,int>> ret;\n  T c = -1;\n  int n = 0;\n  for(T& x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\nusing mint = modint;\n\nnamespace FastFourierTransform {\n  using real = double;\n\n  struct C {\n    real x, y;\n\n    C() : x(0), y(0) {}\n\n    C(real x, real y) : x(x), y(y) {}\n\n    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }\n\n    inline C conj() const { return C(x, -y); }\n  };\n\n  const real PI = acosl(-1);\n  int base = 1;\n  vector< C > rts = { {0, 0},\n                     {1, 0} };\n  vector< int > rev = {0, 1};\n\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    while(base < nbase) {\n      real angle = PI * 2.0 / (1 << (base + 1));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        real angle_i = angle * (2 * i + 1 - (1 << base));\n        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n      }\n      ++base;\n    }\n  }\n\n  void fft(vector< C > &a, int n) {\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          C z = a[i + j + k] * rts[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n  }\n\n  vector< int64_t > multiply(const vector< int > &a, const vector< int > &b) {\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = C(x, y);\n    }\n    fft(fa, sz);\n    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n      fa[i] = z;\n    }\n    for(int i = 0; i < (sz >> 1); i++) {\n      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n      fa[i] = A0 + A1 * s;\n    }\n    fft(fa, sz >> 1);\n    vector< int64_t > ret(need);\n    for(int i = 0; i < need; i++) {\n      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n    }\n    return ret;\n  }\n};\n\ntemplate< typename T >\nstruct ArbitraryModConvolution {\n  using real = FastFourierTransform::real;\n  using C = FastFourierTransform::C;\n\n  ArbitraryModConvolution() = default;\n\n  vector< T > multiply(const vector< T > &a, const vector< T > &b, int need = -1) {\n    if(need == -1) need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while((1 << nbase) < need) nbase++;\n    FastFourierTransform::ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < (int)a.size(); i++) {\n      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);\n    }\n    fft(fa, sz);\n    vector< C > fb(sz);\n    if(a == b) {\n      fb = fa;\n    } else {\n      for(int i = 0; i < (int)b.size(); i++) {\n        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);\n      }\n      fft(fb, sz);\n    }\n    real ratio = 0.25 / sz;\n    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C a1 = (fa[i] + fa[j].conj());\n      C a2 = (fa[i] - fa[j].conj()) * r2;\n      C b1 = (fb[i] + fb[j].conj()) * r3;\n      C b2 = (fb[i] - fb[j].conj()) * r4;\n      if(i != j) {\n        C c1 = (fa[j] + fa[i].conj());\n        C c2 = (fa[j] - fa[i].conj()) * r2;\n        C d1 = (fb[j] + fb[i].conj()) * r3;\n        C d2 = (fb[j] - fb[i].conj()) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector< T > ret(need);\n    for(int i = 0; i < need; i++) {\n      int64_t aa = llround(fa[i].x);\n      int64_t bb = llround(fb[i].x);\n      int64_t cc = llround(fa[i].y);\n      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;\n      ret[i] = aa + (bb << 15) + (cc << 30);\n    }\n    return ret;\n  }\n};\n\ntemplate< int mod >\nstruct NumberTheoreticTransform {\n\n  int base, max_base, root;\n  vector< int > rev, rts;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while(tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while(n > 0) {\n      if(n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) {\n    return mod_pow(x, mod - 2);\n  }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long) mod;\n  }\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while(base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n\n  void ntt(vector< int > &a) {\n    const int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n\n  vector< int > multiply(vector< int > a, vector< int > b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for(int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n\n  vector<modint> multiply_for_fps(const vector<modint> &a,const vector<modint> &b){\n    vector<int> A(a.size()) , B(b.size());\n    for(int i = 0;i < (int)a.size(); i++) A[i] = a[i].x;\n    for(int i = 0;i < (int)b.size(); i++) B[i] = b[i].x;\n    auto C = multiply( A , B );\n    vector<modint> ret(C.size());\n    for(int i = 0; i < (int)C.size() ;i++) ret[i].x = C[i];\n    return ret;\n  }\n};\n\n\ntemplate< typename T >\nstruct FormalPowerSeries : vector< T > {\n  using vector< T >::vector;\n  using P = FormalPowerSeries;\n\n  using MULT = function< P(P, P) >;\n\n  static MULT &get_mult() {\n    static MULT mult = nullptr;\n    return mult;\n  }\n\n  static void set_fft(MULT f) {\n    get_mult() = f;\n  }\n\n  void shrink() {\n    while(this->size() && this->back() == T(0)) this->pop_back();\n  }\n\n  P operator+(const P &r) const { return P(*this) += r; }\n\n  P operator+(const T &v) const { return P(*this) += v; }\n\n  P operator-(const P &r) const { return P(*this) -= r; }\n\n  P operator-(const T &v) const { return P(*this) -= v; }\n\n  P operator*(const P &r) const { return P(*this) *= r; }\n\n  P operator*(const T &v) const { return P(*this) *= v; }\n\n  P operator/(const P &r) const { return P(*this) /= r; }\n\n  P operator%(const P &r) const { return P(*this) %= r; }\n\n  P &operator+=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] += r[i];\n    return *this;\n  }\n\n  P &operator+=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] += r;\n    return *this;\n  }\n\n  P &operator-=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] -= r[i];\n    shrink();\n    return *this;\n  }\n\n  P &operator-=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] -= r;\n    shrink();\n    return *this;\n  }\n\n  P &operator*=(const T &v) {\n    const int n = (int) this->size();\n    for(int k = 0; k < n; k++) (*this)[k] *= v;\n    return *this;\n  }\n\n  P &operator*=(const P &r) {\n    if(this->empty() || r.empty()) {\n      this->clear();\n      return *this;\n    }\n    assert(get_mult() != nullptr);\n    return *this = get_mult()(*this, r);\n  }\n\n  P &operator%=(const P &r) {\n    return *this -= *this / r * r;\n  }\n\n  P operator-() const {\n    P ret(this->size());\n    for(int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];\n    return ret;\n  }\n\n  P &operator/=(const P &r) {\n    if(this->size() < r.size()) {\n      this->clear();\n      return *this;\n    }\n    int n = this->size() - r.size() + 1;\n    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);\n  }\n\n  P pre(int sz) const {\n    return P(begin(*this), begin(*this) + min((int) this->size(), sz));\n  }\n\n  P operator>>(int sz) const {\n    if(this->size() <= sz) return {};\n    P ret(*this);\n    ret.erase(ret.begin(), ret.begin() + sz);\n    return ret;\n  }\n\n  P operator<<(int sz) const {\n    P ret(*this);\n    ret.insert(ret.begin(), sz, T(0));\n    return ret;\n  }\n\n  P rev(int deg = -1) const {\n    P ret(*this);\n    if(deg != -1) ret.resize(deg, T(0));\n    reverse(begin(ret), end(ret));\n    return ret;\n  }\n\n  P diff() const {\n    const int n = (int) this->size();\n    P ret(max(0, n - 1));\n    for(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);\n    return ret;\n  }\n\n  P integral() const {\n    const int n = (int) this->size();\n    P ret(n + 1);\n    ret[0] = T(0);\n    for(int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);\n    return ret;\n  }\n\n  // F(0) must not be 0\n  P inv(int deg = -1) const {\n    assert(((*this)[0]) != T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1) / (*this)[0]});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 1\n  P log(int deg = -1) const {\n    assert((*this)[0] == 1);\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();\n  }\n\n  P sqrt(int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n\n    if((*this)[0] == T(0)) {\n      for(int i = 1; i < n; i++) {\n        if((*this)[i] != T(0)) {\n          if(i & 1) return {};\n          if(deg - i / 2 <= 0) break;\n          auto ret = (*this >> i).sqrt(deg - i / 2) << (i / 2);\n          if(ret.size() < deg) ret.resize(deg, T(0));\n          return ret;\n        }\n      }\n      return P(deg, 0);\n    }\n\n    P ret({T(1)});\n    T inv2 = T(1) / T(2);\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 0\n  P exp(int deg = -1) const {\n    assert((*this)[0] == T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1)});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  P pow(int64_t k, int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    for(int i = 0; i < n; i++) {\n      if((*this)[i] != T(0)) {\n        T rev = T(1) / (*this)[i];\n        P C(*this * rev);\n        P D(n - i);\n        for(int j = i; j < n; j++) D[j - i] = C[j];\n        D = (D.log() * k).exp() * (*this)[i].pow(k);\n        P E(deg);\n        if(i * k > deg) return E;\n        auto S = i * k;\n        for(int j = 0; j + S < deg && j < D.size(); j++) E[j + S] = D[j];\n        return E;\n      }\n    }\n    return *this;\n  }\n\n  T eval(T x) const {\n    T r = 0, w = 1;\n    for(auto &v : *this) {\n      r += w * v;\n      w *= x;\n    }\n    return r;\n  }\n};\n\nusing FPS = FormalPowerSeries< modint >;\n\n// fにa * x^n + bを掛ける\nvoid mul_simple(FPS &f,modint a ,int n, modint b){\n  for(int i = (int)f.size() - 1 ; i >= 0 ; i--){\n    f[i] *= b;\n    if(i >= n) f[i] += f[i - n] * a; \n  }\n}\n\n// fからa * x^n + bを割る\nvoid div_simple(FPS &f,modint a,int n,modint b){\n  for(int i = 0 ; i < (int)f.size() ; i++){\n    f[i] /= b;\n    if(i + n < (int)f.size() ) f[n + i] -= f[i] * a; \n  }\n}\n\n// f / gをdeg(f)次まで求める\nFPS div_(FPS &f , FPS g){\n  int n = f.size();\n  return (f * g.inv(n)).pre(n);\n}\n\n\n// solve関数内で\n//\n// FPS::set_fft(mul);\n//\n// とすること。\n\n/**\nNumberTheoreticTransform<MOD> ntt;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret =ntt.multiply_for_fps(a , b);\n  return FPS::P(ret.begin(), ret.end());\n};\n/*///\nArbitraryModConvolution< modint > fft;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret = fft.multiply(a, b);\n  return FPS::P(ret.begin(), ret.end());\n};\n//*/\n\n// 下記のリンクを実装(kitamasa法のモンゴメリ乗算を使わない版)\n// http://q.c.titech.ac.jp/docs/progs/polynomial_division.html\n// k項間漸化式のa_Nを求める O(k log k log N)\n// N ... 求めたい項　(0-indexed)\n// Q ... 漸化式 (1 - \\sum_i c_i x^i)の形\n// a ... 初期解 (a_0 , a_1 , ... , a_k-1)\n// x^N を fでわった剰余を求め、aと内積を取る\nmodint kitamasa(ll N, FPS &Q, FPS &a){\n  int k = Q.size() - 1;\n  assert( (int)a.size() == k );\n  FPS P = a * Q; P.resize(k);\n  while(N){\n    auto Q2 = Q;\n    for(int i = 1; i < (int)Q2.size(); i += 2) Q2[i].x = MOD - Q2[i].x;\n    auto S = P * Q2;\n    auto T = Q * Q2;\n    if(N & 1){\n      for(int i = 1 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    else{\n      for(int i = 0 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    N >>= 1;\n  }\n  return P[0];\n}\n\nvoid solve(){\n  ini(N , M);\n  ins(S);\n  auto run = RunLengthEncoding(S);\n  if(run.size() == 1){\n    // DP\n    V<mint> dp(N),ep(N),fp(N),gp(N);\n    // [0]がR\n    // -> [1],[-1]はどちらでもよい\n    dp[0] = gp[0] = 1;\n    rep1(i , N - 1){\n      dp[i] = dp[i - 1] + ep[i - 1];\n      ep[i] = dp[i - 1];\n      fp[i] = fp[i - 1] + gp[i - 1];\n      gp[i] = fp[i - 1];\n    }\n    out(dp[N-1] + ep[N-1] + fp[N-1]);\n    return;\n  }\n  if(N % 2 == 1){\n    out(0);\n    return;\n  }\n  exit(1);\n  FPS::set_fft(mul);\n  // rの最小値\n  int r = inf , b = inf;\n  each(p , run){\n    if(p.first == 'R') amin(r , (p.second%2==0 ? p.second+1:p.second));\n    if(p.first == 'B') amin(b , (p.second%2==0 ? p.second+1:p.second));\n  }\n  trc(r , b);\n  // 初手とは異なる方が1である必要あり\n  (run[0].first == 'R' ? b : r) = 1;\n  FPS f({1});\n  auto nyaan = [&](ll n,int flg = false) -> FPS{\n    FPS ret(n + 1);\n    for(int i = 1 ; i <= n ; i += 2) ret[i] = (flg ? i : 1);\n    return ret;\n  };\n  trc(f);\n  f *= nyaan(r);\n  f *= nyaan(b);\n  trc(f);\n  f = FPS({1}) - f;\n  if((int)f.size() <= N) f.resize(N + 2);\n  f = f.inv();\n  f *= nyaan(r,1) * nyaan(b) + nyaan(b,1) * nyaan(r); \n  trc(f);\n  out(f[N]);\n  \n  /*\n  //trc(f);\n  // 倍数包除\n  for(int i = 2 ; i <= N ; i++){\n    // i番目は？\n    //引こう！\n    for(int j = 2 ; i * j <= N ; j++){\n      f[i * j] -= f[i];\n    }\n  }\n  trc(f);\n  */\n\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\ninline void add(int &x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nll bin_pow(ll a, ll p) {\n    ll res = 1;\n    while (p) {\n        if (p & 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return res;\n}\n\nll rev(ll x) {\n    return bin_pow(x, MOD - 2);\n}\n\nll fact[N + 1], rfact[N + 1];\n\nvoid init() {\n    fact[0] = 1;\n    rep(i, 1, N + 1) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    rfact[N] = rev(fact[N]);\n    repb(i, N - 1, -1) {\n        rfact[i] = rfact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nll C(int n, int k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    return fact[n] * rfact[k] % MOD * rfact[n - k] % MOD;\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    init();\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    repb(i, m - 1, -1) {\n        s[i] = char('0' + (s[0] != s[i]));\n    }\n    int c1 = 0;\n    rep(i, 0, m) {\n        if (s[i] == '1') {\n            c1++;\n        }\n    }\n    if (c1 == 0) {\n        int ans = 0;\n        for (int i = 0; i * 2 <= n; i++) {\n            add(ans, C(n - i, i));\n            if (i >= 1) {\n                add(ans, C(n - 2 - (i - 1), (i - 1)));\n            }\n        }\n        cout << ans << \"\\n\";\n        return 0;\n    }\n    if (n % 2 == 1) {\n        cout << 0 << \"\\n\";\n        return 0;\n    }\n    int k = n - 1, cur = 0;\n    rep(i, 0, m) {\n        if (s[i] == '0') {\n            cur++;\n        }\n        if (i == m - 1 || s[i + 1] == '1') {\n            if (cur % 2 == 1) {\n                setmin(k, cur);\n            } else if (cur > 0) {\n                setmin(k, cur + 1);\n            }\n            cur = 0;\n        }\n    }\n    //cout << k << endl;\n    int dp[n + 2], pref1[n + 2];\n    fill(dp, dp + n + 1, 0);\n    fill(pref1, pref1 + n + 2, 0);\n    dp[1] = 1;\n    pref1[1] = 1;\n    for (int i = 3; i <= n + 1; i += 2) {\n        int last_add = max(1, i - (k + 1));\n        dp[i] = pref1[i - 2] - (last_add - 2 >= 0 ? pref1[last_add - 2] : 0);\n        pref1[i] = (pref1[i - 2] + dp[i]) % MOD;\n    }\n    /*rep(i, 1, n + 2) {\n        cout << dp[i] << \" \";\n    }\n    cout << \"\\n\";*/\n    int ans = dp[n + 1];\n    //cout << k << endl;\n    for (int c = 1; c <= k; c += 2) {\n        //cout << c << \" \" << dp[n - c] << endl;\n        ans = (ans + 1LL * c * dp[n - c]) % MOD;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i < vec.size();i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+10;\nconst int mod=1e9+7;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nvoid inc(int &a,int b) {\n\ta=a+b>=mod?a+b-mod:a+b;\n}\n\nint n,m,f[N];\nchar s[N];\n\nint main() {\n\tcin>>n>>m;\n\tscanf(\"%s\",s+1);\n\tint p=n+1;\n\tfor(int i=2;i<=n;i++)\n\t\tif(s[1]!=s[i]) { p=i;break; }\n\tif(p==n+1) {\n\t\tf[0]=1;\n\t\tfor(int i=2,s=1;i<=n;i++) {\n\t\t\tf[i]=s;inc(s,f[i-1]);\n\t\t}\n\t\tint ans=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t\tans=(ans+1ll*i*f[n-i])%mod;\n\t\tcout<<ans;\n\t}\n\telse {\n\t\t--p;int mx=p+!(p&1),len=0;\n\t\tfor(int i=p+1;i<=n;i++) {\n\t\t\tif(s[i]==s[1]) ++len;\n\t\t\telse {\n\t\t\t\tif(len&1) mx=min(mx,len);\n\t\t\t\tlen=0;\n\t\t\t}\n\t\t}\n\t\t++mx;f[0]=1;\n\t\tfor(int i=2,s=1;i<=n;i+=2) {\n\t\t\tf[i]=s;\n\t\t\tif(i>=mx) inc(s,mod-f[i-mx]);\n\t\t\tinc(s,f[i]);\n\t\t\t//cerr<<i<<' '<<f[i]<<endl;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=2;i<=mx;i+=2)\n\t\t\tans=(ans+1ll*i*f[n-i])%mod;\n\t\tcout<<ans;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ΔAGC033E\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 222222;\nconst int MO = 1e9+7;\nchar ch[N];\nint n,m,ans,f[N],s[N];\nint main()\n{\n\tint i,x,y,o;\n\tscanf(\"%d%d%s\",&n,&m,ch+1);\n\tfor(i=1;i<=n;i=i+1)\n\t\tif(ch[i]!=ch[1])\n\t\t\tbreak;\n\to=n;\n\tif(i<=n){\n\t\to=i-1;\n\t\tif(o%2==0)\n\t\t\to++;\n\t\tx=1,y=0;\n\t\tfor(i=i+1;i<=n;i=i+1){\n\t\t\tif(ch[i]==ch[i-1])\n\t\t\t\tx++;\n\t\t\telse{\n\t\t\t\tif(y&&x%2==1)\n\t\t\t\t\to=min(o,x);\n\t\t\t\ty^=1;\n\t\t\t\tx=1;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tf[1]=1;\n\t\ts[1]=1;\n\t\tfor(i=2;i<=n;i=i+1){\n\t\t\tf[i]=s[i-2];\n\t\t\ts[i]=(s[i-1]+f[i])%MO;\n\t\t}\n\t\tx=0;\n\t\tfor(i=1;i<n;i=i+1)\n\t\t\tx+=(LL)f[i]*(n-i+1)%MO,x%=MO;\n\t\tcout<<x;\n\t\treturn 0;\n\t}\n\tif(n&1){\n\t\tcout<<0;\n\t\treturn 0;\n\t}\n\to++;\n\to/=2;\n\tn/=2;\n\tf[1]=1;\n\ts[1]=1;\n\tfor(i=2;i<=n;i=i+1){\n\t\tx=i-o-1;\n\t\tif(x<0)\n\t\t\ty=0;\n\t\telse\n\t\t\ty=s[x];\n\t\tf[i]=(s[i-1]-y+MO)%MO;\n\t\ts[i]=(s[i-1]+f[i])%MO;\n\t}\n\tx=0;\n\tfor(i=n-o+1;i<=n;i=i+1)\n\t\tx+=(LL)f[i]*((n-i+1)*2)%MO,x%=MO;\n\tcout<<x;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\n#ifdef AIM\n#include <sys/resource.h>\n#endif\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\nusing li = long long;\nusing ld = long double;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  freopen(\"/home/alexandero/CLionProjects/ACM/input.txt\", \"r\", stdin);\n  //freopen(\"/home/alexandero/CLionProjects/ACM/output.txt\", \"w\", stdout);\n//freopen(\"out.txt\", \"w\", stdout);\n#else\n  //freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n#ifdef AIM\n  const rlim_t kStackSize = 256 * 1024 * 1024;\n  struct rlimit rl;\n  int result;\n\n  result = getrlimit(RLIMIT_STACK, &rl);\n  if (result == 0) {\n    if (rl.rlim_cur < kStackSize) {\n      rl.rlim_cur = kStackSize;\n      result = setrlimit(RLIMIT_STACK, &rl);\n      if (result != 0) {\n        fprintf(stderr, \"setrlimit returned result = %d\\n\", result);\n      }\n    }\n  }\n#endif\n\n  start = clock();\n  int t = 1;\n#ifndef AIM\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n#endif\n  cout.precision(20);\n  cout << fixed;\n  //cin >> t;\n  precalc();\n  while (t--) {\n    solve(true);\n  }\n  cout.flush();\n\n#ifdef AIM1\n  while (true) {\n    solve(false);\n  }\n#endif\n\n#ifdef AIM\n  cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\ntemplate <typename T>\nvoid make_unique(vector<T>& vec) {\n  sort(all(vec));\n  vec.erase(unique(all(vec)), vec.end());\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\nmt19937 rng((unsigned long long)chrono::steady_clock::now().time_since_epoch().count());\n\nvoid precalc() {\n\n}\n\n#define int li\nconst li mod = 1000000007;\n//const int mod = 998244353;\n//using ull = unsigned long long;\n\nvoid add(int& cur, int val) {\n  cur += val;\n  cur %= mod;\n  if (cur < 0) {\n    cur += mod;\n  }\n}\n\nvoid solve(__attribute__((unused)) bool read) {\n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n  if (s[0] == 'B') {\n    for (char& c : s) {\n      c = 'B' + 'R' - c;\n    }\n  }\n  const int INF = (int)1e9;\n  int max_segment = INF;\n  int last = 0;\n  for (int i = 0; i < s.length(); ++i) {\n    if (s[i] == 'B') {\n      int cur_len = i - last;\n      if (last == 0) {\n        if (cur_len % 2 == 0) {\n          ++cur_len;\n        }\n        relax_min(max_segment, cur_len);\n      } else if (cur_len % 2) {\n        relax_min(max_segment, cur_len);\n      }\n      last = i + 1;\n    }\n  }\n  if (last == 0) {\n    vector<int> fib(n + 1);\n    fib[0] = 1;\n    fib[1] = 2;\n    for (int i = 2; i < fib.size(); ++i) {\n      fib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n    }\n    int res = (fib[n - 1] + fib[n - 3]) % mod;\n    cout << res << endl;\n    return;\n  }\n  int max_divided = (max_segment + 1) / 2;\n  //cout << max_segment << \" \" << max_divided << endl;\n  vector<int> dp(n + 1, 0);\n  dp[0] = 1;\n  vector<int> add_to_pref(n + 1, 0);\n  int pref_add = 0;\n  for (int i = 0; i <= n; ++i) {\n    add(pref_add, add_to_pref[i]);\n    add(dp[i], pref_add);\n    add(pref_add, dp[i]);\n    if (i + max_divided < n) {\n      add(add_to_pref[i + max_divided + 1], -dp[i]);\n    }\n    /*if (i < n / 2) {\n      cout << i << \" \" << dp[i] << endl;\n    }*/\n  }\n  if (n % 2) {\n    cout << \"0\\n\";\n    return;\n  }\n  int res = 0;\n  for (int seg = 2; seg <= 2 * max_divided && seg <= n; seg += 2) {\n    //cout << \"add seg: \" << seg << \" rest: \" << (n - seg) / 2 << \" dp: \" << dp[(n - seg) / 2] << endl;\n    res += dp[(n - seg) / 2] * seg;\n    res %= mod;\n  }\n  cout << res << \"\\n\";\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline tuple<int, int, int> extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nunsigned ModInt::MOD = 1000000007;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\n\n\nconst int limit = 200010;\nmint dp[limit];\nmint csum[limit];\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\n\tint cmin = n, cons = 0;\n\n\trep(i, m){\n\t\tif(s[i] == s[0]){\n\t\t\tcons++;\n\t\t} else {\n\t\t\tchmin(cmin, cons);\n\t\t\tcons = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\trep(i, m){\n\t\tif(s[i] == s[0]){\n\t\t\tcons++;\n\t\t} else {\n\t\t\tif(cons % 2 == 1) chmin(cmin, cons);\n\t\t\tcons = 0;\n\t\t}\n\t}\n\n\tif(cmin % 2 == 0) cmin++;\n\tdp[1] = csum[1] = ONE;\n\n\trep(i, 1, n){\n\t\tconst int pos = max(i - cmin - 1, 0);\n\t\tif((i + 1) % 2 == 1) dp[i + 1] =  csum[i] - csum[pos];\n\t\tcsum[i + 1] = csum[i] + dp[i + 1];\n\t}\n\n\tmint ans = ZERO;\n\n\trep(i, max(0, n - cmin), n + 1){\n\t\tconst mint coef = mint(n - i + 1);\n\t\tans += coef * dp[i];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\ntemplate <unsigned int MOD>\nstruct ModInt {\n    using uint = unsigned int;\n    using ull = unsigned long long;\n    using M = ModInt;\n\n    uint v;\n\n    ModInt(ll _v = 0) { set_norm(_v % MOD + MOD); }\n    M& set_norm(uint _v) {  //[0, MOD * 2)->[0, MOD)\n        v = (_v < MOD) ? _v : _v - MOD;\n        return *this;\n    }\n\n    explicit operator bool() const { return v != 0; }\n    M operator+(const M& a) const { return M().set_norm(v + a.v); }\n    M operator-(const M& a) const { return M().set_norm(v + MOD - a.v); }\n    M operator*(const M& a) const { return M().set_norm(ull(v) * a.v % MOD); }\n    M operator/(const M& a) const { return *this * a.inv(); }\n    M& operator+=(const M& a) { return *this = *this + a; }\n    M& operator-=(const M& a) { return *this = *this - a; }\n    M& operator*=(const M& a) { return *this = *this * a; }\n    M& operator/=(const M& a) { return *this = *this / a; }\n    M operator-() const { return M() - *this; }\n    M& operator++(int) { return *this = *this + 1; }\n    M& operator--(int) { return *this = *this - 1; }\n\n    M pow(ll n) const {\n        if (n < 0) return inv().pow(-n);\n        M x = *this, res = 1;\n        while (n) {\n            if (n & 1) res *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    M inv() const {\n        ll a = v, b = MOD, p = 1, q = 0, t;\n        while (b != 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(p -= t * q, q);\n        }\n        return M(p);\n    }\n\n    bool operator==(const M& a) const { return v == a.v; }\n    bool operator!=(const M& a) const { return v != a.v; }\n    friend ostream& operator<<(ostream& os, const M& a) { return os << a.v; }\n    static uint get_mod() { return MOD; }\n};\n\nusing Mint = ModInt<1000000007>;\n\nMint uni(int n) {\n    V<Mint> dp(n + 1), prf(n + 1);\n    dp[1] = prf[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        dp[i] = prf[i - 2];\n        prf[i] = prf[i - 1] + dp[i];\n    }\n    Mint res(1);\n    for (int l = 1; l <= n; l++) {\n        res += dp[n - l] * (l + 1);\n    }\n    return res;\n}\n\nMint solve(int n, int ml) {\n    V<Mint> dp(n + 1), prf(n + 1);\n\n    dp[1] = prf[1] = 1;\n\n    for (int i = 2; i <= n; ++i) {\n        prf[i] = prf[i - 1];\n        if (i & 1) {\n            dp[i] = prf[i - 1];\n            if (i - ml - 1 > 0) {\n                dp[i] -= prf[i - ml - 2];\n            }\n        }\n        prf[i] += dp[i];\n    }\n    Mint res;\n    for (int l = 1; l <= min(n, ml); l += 2) {\n        res += dp[n - l] * (l + 1);\n    }\n    return res;\n}\n\nint main() {\n    int N, M;\n    string S;\n    cin >> N >> M >> S;\n    V<pii> vec;\n\n    rep(i, M) {\n        if (vec.size() > 0 && vec.back().fi == S[i]) {\n            vec.back().se++;\n        } else {\n            vec.eb(S[i], 1);\n        }\n    }\n\n    if (vec.size() == 1) {\n        cout << uni(N) << endl;\n        return 0;\n    }\n\n    if (N % 2) {\n        puts(\"0\");\n        return 0;\n    }\n\n    if (vec.back().fi == vec[0].fi) {\n        vec.pop_back();\n    }\n\n    debug(vec);\n\n    int ml = vec[0].se;\n    if (ml % 2 == 0) ml++;\n\n    int sc = vec[0].fi;\n    for (auto p : vec) {\n        if (p.fi == sc && p.se % 2) {\n            chmin(ml, p.se);\n        }\n    }\n    debug(ml);\n\n    cout << solve(N, ml) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define prev azaza\n#define MP make_pair\n#define PB push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int max_n = 200111, inf = 1000111222;\nconst ll mod = 1000000007;\n\nint n, m;\nstring s;\n\nll dp[max_n];\nll pr[max_n];\nll dp2[max_n];\n\nll solve_allr() {\n    ll ans = 1;\n    dp[1] = 1;\n    dp[2] = 0;\n    ll sum = dp[1];\n    for (int i = 3; i < max_n; ++i) {\n        dp[i] = sum;\n        sum += dp[i - 1];\n        sum %= mod;\n    }\n    for (int len = 1; len < n; ++len) {\n        ans += dp[n - len] * (len + 1);\n        ans %= mod;\n    }\n    return ans;\n}\n\nll solve(int L) {\n    int L1 = L / 2;\n    pr[1] = 1;\n    dp2[1] = 1;\n    for (int i = 2; i < max_n; ++i) {\n        dp2[i] = (pr[i - 1] - pr[max(1, i - L1 - 1) - 1] + 2 * mod) % mod;\n        pr[i] = pr[i - 1] + dp2[i];\n        pr[i] %= mod;\n    }\n    dp[1] = 1;\n    for (int i = 3; i < max_n; i += 2) {\n        dp[i] = dp2[i / 2 + 1];\n    }\n    ll ans = 0;\n    for (int len = 1; len <= min(L, n - 1); len += 2) {\n        ans += dp[n - len] * (len + 1);\n        ans %= mod;\n    }\n    return ans;\n}\n\nint main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> m;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (int i = 0; i < s.size(); ++i) {\n            s[i] = (s[i] == 'B' ? 'R' : 'B');\n        }\n    }\n    bool allr = 1;\n    for (char c : s) {\n        if (c == 'B') {\n            allr = 0;\n            break;\n        }\n    }\n    if (allr) {\n        cout << solve_allr() << endl;\n        return 0;\n    }\n    if (n % 2 == 1) {\n        cout << 0 << endl;\n        return 0;\n    }\n    while (s.back() == 'R') {\n        s.pop_back();\n    }\n    int L = 0;\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] == 'B') {\n            break;\n        } else {\n            ++L;\n        }\n    }\n    if (L % 2 == 0) {\n        ++L;\n    }\n    int len = 1;\n    for (int i = L; i < s.size(); ++i) {\n        if (s[i] == s[i - 1]) {\n            ++len;\n        } else {\n            if (s[i] == 'B' && len % 2 == 1) {\n                L = min(L, len);\n            }\n            len = 1;\n        }\n    }\n    cout << solve(L) << endl;\n    return 0;\n}\n\n// think 2:06\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tstring s;\n\tcin >> s;\n\tset<char>st;\n\tfor (auto i : s)st.insert(i);\n\tif (st.size() == 1) {\n\t\tvector<long long int>dp(N + 1);\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1];\n\t\t\tif (i > 1)dp[i] += dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tlong long int ans = dp.back();\n\t\tdp[0] = 1;\n\t\tdp[1] = 0;\n\t\tfor (int i = 2; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tans += dp.back();\n\t\tans %= MOD;\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\ts.push_back(s[0] + 1);\n\tvector<int>num(s.size() + 1);\n\tfor (int i = 0; i <= s.size(); i++) {\n\t\tnum[i] = s[i] == s[0];\n\t\tif (i)num[i] = num[i] * (num[i - 1] + 1);\n\t}\n\tint fst = 0;\n\tint m = MOD;\n\tfor (int i = 1; i <= s.size(); i++) {\n\t\tif (!num[i] && num[i - 1]) {\n\t\t\tif (fst == 0) {\n\t\t\t\tfst = num[i - 1];\n\t\t\t\tif (num[i - 1] % 2 == 0)num[i - 1]++;\n\t\t\t}\n\t\t\tm = min(m, num[i - 1]);\n\t\t}\n\t}\n\tif (m & 1)m++;\n\tvector<long long int>dp(N + 2);\n\tvector<long long int>sum(N + 2);\n\tfor (int i = 2; i <= m; i += 2)dp[i] = i;\n\tfor (int i = 2; i <= N; i++) {\n\t\tdp[i] += sum[i - 2] + MOD;\n\t\tif (i - m - 2 >= 0)dp[i] -= sum[i - m - 2];\n\t\tdp[i] %= MOD;\n\t\tif (i == N) {\n\t\t\tcout << dp[i] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsum[i] = sum[i - 2] + dp[i];\n\t\tsum[i] %= MOD;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/01/29] 12:36:49\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nvoid outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\n\n\ntemplate<typename T> T gcd(const T& a, const T& b) { return a < 0 ? gcd(-a, b) : b < 0 ? gcd(a, -b) : (a > b ? gcd(b, a) : a == 0 ? b : gcd(b % a, a)); }\ntemplate<typename T> T lcm(const T& a, const T& b) { return a / gcd(a, b) * b; }\ntemplate<typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto g = gcd(a, b), da = std::abs(b) / g;\n    const auto p = extgcd(b, a % b);\n    const auto x = (da + p.second % da) % da, y = (g - a * x) / b;\n    return {x, y};\n}\ntemplate<typename T>\nconstexpr T inverse(const T a, const T mod) { return extgcd(a, mod).first; }\ntemplate<uint mod_value, bool dynamic = false>\nclass modint_base\n{\npublic:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, const UInt> mod() { return mod_ref(); }\n    template<typename UInt = uint>\n    static constexpr std::enable_if_t<not dynamic, const UInt> mod() { return mod_value; }\n    template<typename UInt = uint>\n    static void set_mod(const std::enable_if_t<dynamic, const UInt> mod) { mod_ref() = mod, inv_ref() = {1, 1}; }\n    modint_base() : v{0} {}\n    modint_base(const ll val) : v{norm(static_cast<uint>(val % static_cast<ll>(mod()) + static_cast<ll>(mod())))} {}\n    modint_base(const modint_base& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    modint_base& operator=(const modint_base& m) { return v = m(), (*this); }\n    modint_base& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod()) + static_cast<ll>(mod()))), (*this); }\n    friend modint_base operator+(const modint_base& m) { return m; }\n    friend modint_base operator-(const modint_base& m) { return make(norm(mod() - m.v)); }\n    friend modint_base operator+(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + m2.v)); }\n    friend modint_base operator-(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + mod() - m2.v)); }\n    friend modint_base operator*(const modint_base& m1, const modint_base& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod()))); }\n    friend modint_base operator/(const modint_base& m1, const modint_base& m2) { return m1 * inv(m2.v); }\n    friend modint_base operator+(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) - val}; }\n    friend modint_base operator*(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * inv(val)}; }\n    friend modint_base operator+(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const ll val, const modint_base& m) { return modint_base{-static_cast<ll>(m.v) + val}; }\n    friend modint_base operator*(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const ll val, const modint_base& m) { return modint_base{val * inv(static_cast<ll>(m.v))}; }\n    friend modint_base& operator+=(modint_base& m1, const modint_base& m2) { return m1 = m1 + m2; }\n    friend modint_base& operator-=(modint_base& m1, const modint_base& m2) { return m1 = m1 - m2; }\n    friend modint_base& operator*=(modint_base& m1, const modint_base& m2) { return m1 = m1 * m2; }\n    friend modint_base& operator/=(modint_base& m1, const modint_base& m2) { return m1 = m1 / m2; }\n    friend modint_base& operator+=(modint_base& m, const ll val) { return m = m + val; }\n    friend modint_base& operator-=(modint_base& m, const ll val) { return m = m - val; }\n    friend modint_base& operator*=(modint_base& m, const ll val) { return m = m * val; }\n    friend modint_base& operator/=(modint_base& m, const ll val) { return m = m / val; }\n    friend modint_base operator^(const modint_base& m, const ll n) { return power(m.v, n); }\n    friend modint_base& operator^=(modint_base& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const modint_base& m1, const modint_base& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const modint_base& m1, const modint_base& m2) { return not(m1 == m2); }\n    friend bool operator==(const modint_base& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const modint_base& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const modint_base& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const ll val, const modint_base& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, modint_base& m)\n    {\n        ll v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const modint_base& m) { return os << m(); }\n    uint operator()() const { return v; }\n    static modint_base small_inv(const usize n)\n    {\n        auto& in = inv_ref();\n        if (n < in.size()) { return in[n]; }\n        for (usize i = in.size(); i <= n; i++) { in.push_back(-in[modint_base::mod() % i] * (modint_base::mod() / i)); }\n        return in.back();\n    }\n    std::pair<ll, ll> quad() const\n    {\n        const auto ans = quad_r(v, mod());\n        ll x = std::get<0>(ans), y = std::get<1>(ans);\n        if (y < 0) { x = -x, y = -y; }\n        return {x, y};\n    }\n\nprivate:\n    static std::tuple<ll, ll, ll> quad_r(const ll r, const ll p)  // r = x/y (mod p), (x,y,z) s.t. x=yr+pz\n    {\n        if (std::abs(r) <= 1000) { return {r, 1, 0}; }\n        ll nr = p % r, q = p / r;\n        if (nr * 2LL >= r) { nr -= r, q++; }\n        if (nr * 2LL <= -r) { nr += r, q--; }\n        const auto sub = quad_r(nr, r);\n        const ll x = std::get<0>(sub), z = std::get<1>(sub), y = std::get<2>(sub);\n        return {x, y - q * z, z};\n    }\n\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, UInt&> mod_ref()\n    {\n        static UInt mod = 0;\n        return mod;\n    }\n    static uint norm(const uint x) { return x < mod() ? x : x - mod(); }\n    static modint_base make(const uint x)\n    {\n        modint_base m;\n        return m.v = x, m;\n    }\n    static modint_base power(modint_base x, ull n)\n    {\n        modint_base ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static modint_base inv(const ll v) { return v <= 2000000 ? small_inv(static_cast<usize>(v)) : modint_base{inverse(v, static_cast<ll>(mod()))}; }\n    static std::vector<modint_base>& inv_ref()\n    {\n        static std::vector<modint_base> in{1, 1};\n        return in;\n    }\n    uint v;\n};\ntemplate<uint mod>\nusing modint = modint_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modint = modint_base<id, true>;\nint main()\n{\n    using mint   = modint<mod>;\n    const auto N = in<int>(), M = in<int>();\n    auto S = in<std::string>();\n    if (S[0] == 'B') {\n        for (auto& c : S) { c = (c == 'R' ? 'B' : 'R'); }\n    }\n    if (S == std::string(M, 'R')) {\n        mint ans = 0;\n        mint r = 0, b = 1;\n        for (int i = 0; i < N - 1; i++) {\n            mint r_ = r, b_ = b;\n            r = r_ + b_, b = r_;\n        }\n        ans += r;\n        r = 1, b = 0;\n        for (int i = 0; i < N - 1; i++) {\n            mint r_ = r, b_ = b;\n            r = r_ + b_, b = r_;\n        }\n        ans += r + b;\n        return outln(ans);\n    }\n    if (N % 2 == 1) { return outln(0); }\n    S.push_back('$');\n    std::vector<int> ls;\n    char p = 'R';\n    int l  = 0;\n    for (int i = 0; i <= M; i++) {\n        if (S[i] != p) {\n            p = S[i];\n            ls.push_back(l);\n            l = 1;\n        } else {\n            l++;\n        }\n    }\n    SHOW(ls);\n    int m = inf_v<int>;\n    for (int i = 0; i + 1 < ls.size(); i += 2) {\n        if (i == 0) {\n            chmin(m, ls[i] / 2 + 1);\n        } else if (ls[i] % 2 == 1) {\n            chmin(m, (ls[i] + 1) / 2);\n        }\n    }\n    SHOW(m);\n    const int n = N / 2;\n    // x1+x2+...+xk = n (円環)\n    // xi <= m\n    std::vector<mint> dp(n + 1, 0);\n    std::vector<mint> sm(n + 1, 0);\n    dp[0] = sm[0] = 1;\n    auto sum      = [&](int i, int j) { return sm[j - 1] - (i == 0 ? mint(0) : sm[i - 1]); };\n    for (int i = 1; i <= n; i++) {\n        dp[i] = sum(std::max(0, i - m), i);\n        sm[i] = sm[i - 1] + dp[i];\n    }\n    mint ans = 0;\n    for (int r1 = 1; r1 <= std::min(n, m); r1++) { ans += dp[n - r1] * 2 * r1; }\n    outln(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\nusing namespace std;\n#define SIZE 262144\ntypedef long long ll;\nll mod = 1000000007;\nclass BIT\n{\npublic:\n\tll bit[SIZE + 1];\n\tvoid add(int a, ll b)\n\t{\n\t\ta+=120000;\n\t\tfor (;;)\n\t\t{\n\t\t\tbit[a] += b;\n\t\t\tbit[a] %= mod;\n\t\t\ta += a&-a;\n\t\t\tif (a > SIZE)return;\n\t\t}\n\t}\n\tll get(int a)\n\t{\n\t\ta+=120000;\n\t\tll ret = 0;\n\t\tfor (;;)\n\t\t{\n\t\t\tret += bit[a];\n\t\t\ta -= a&-a;\n\t\t\tif (a == 0)return ret%mod;\n\t\t}\n\t}\n};\nBIT bi;\nll dp[202020];\nll sub[2][202020][2];\nint main()\n{\n\tint num, len;\n\tscanf(\"%d%d\", &num, &len);\n\tstring s;\n\tcin >> s;\n\tif (s[0] == 'B')\n\t{\n\t\tfor (int i = 0; i < s.size(); i++)s[i] = 'R' + 'B' - s[i];\n\t}\n\tint mini = 1000000000, cnt = 0;\n\tbool ff = false;\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tif (s[i] == 'R')cnt++;\n\t\telse\n\t\t{\n\t\t\tif (!ff)\n\t\t\t{\n\t\t\t\tif (cnt % 2 == 0)mini = min(mini, cnt + 1);\n\t\t\t\telse mini = min(mini, cnt);\n\t\t\t\tff = true;\n\t\t\t}\n\t\t\telse if (cnt % 2 == 1)mini = min(mini, cnt);\n\t\t\tcnt = 0;\n\t\t}\n\t}\n\tif (!ff)\n\t{\n\t\tsub[0][0][0] = sub[1][0][1] = 1;\n\t\tfor (int i = 0; i < 2; i++)\n\t\t{\n\t\t\tfor (int j = 1; j < num; j++)\n\t\t\t{\n\t\t\t\tsub[i][j][0] = (sub[i][j - 1][0] + sub[i][j - 1][1]) % mod;\n\t\t\t\tsub[i][j][1] = sub[i][j - 1][0];\n\t\t\t}\n\t\t}\n\t\tll r = sub[0][num - 1][0] + sub[0][num - 1][1] + sub[1][num - 1][0];\n\t\tprintf(\"%lld\\n\", r%mod);\n\t\treturn 0;\n\t}\n\tif (num % 2 == 1)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tmini = (mini + 1) / 2;\n\tnum /= 2;\n\tmini = min(mini, num);\n\tdp[0] = 1;\n\tbi.add(0, 1);\n\tfor (int i = 1; i <= num; i++)\n\t{\n\t\tdp[i] = (bi.get(i - 1) - bi.get(i - mini - 1) + mod) % mod;\n\t\tbi.add(i, dp[i]);\n\t\t//printf(\"%d %lld\\n\", i, dp[i]);\n\t}\n\tll r = 0;\n\tfor (int i = 1; i <= mini; i++)r = (r + dp[num - i] * i * 2) % mod;\n\tprintf(\"%lld\\n\", r);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint N, M; char S[200200];\n\nconst long long mod = 1000000007;\nlong long D[200200], V[200200];\n\nint main()\n{\n\tscanf (\"%d %d %s\", &N, &M, S);\n\tif (S[0] == 'B'){\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tif (S[i] == 'R') S[i] = 'B';\n\t\t\telse S[i] = 'R';\n\t\t}\n\t}\n\n\tvector<int> len;\n\tfor (int i = 1, l = -1; i < M; i++){\n\t\tif (S[i-1] == 'R' && S[i] == 'B'){\n\t\t\tint u = i - l - 1;\n\t\t\tlen.push_back(u);\n\t\t\tl = i;\n\t\t}\n\t}\n\n\tif (len.empty()){\n\t\tif (N == 2){\n\t\t\tprintf (\"3\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tD[0] = 1;\n\t\tD[1] = 1;\n\t\tfor (int i = 2; i <= N; i++) D[i] = (D[i - 1] + D[i - 2]) % mod;\n\t\tprintf (\"%lld\\n\", (D[N - 1] + D[N - 3] + 1) % mod);\n\t\treturn 0;\n\t}\n\n\tint lim = N + 1;\n\tif (!len.empty()){\n\t\tlim = len[0] * 2 + 1;\n\t\tif (lim % 2 == 0) lim--;\n\t}\n\n\tD[0] = V[0] = 1;\n\tfor (int i = 1; i <= N; i++){\n\t\tif (i <= lim + 1) D[i] = i - 1;\n\t\tlong long u = 0, v = 0;\n\t\tif (i >= 2) u = V[i - 2];\n\t\tif (i >= lim + 3) v = V[i - (lim + 3)];\n\t\tD[i] = (D[i] + u + mod - v) % mod;\n\n\t\tV[i] = D[i];\n\t\tif (i >= 2) V[i] = (V[i] + V[i - 2]) % mod;\n\t}\n\tprintf (\"%lld\\n\", D[N]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long LL;\nconst int N = 200005, mod = 1000000007;\n\nvoid reduce(int &x) { x += x >> 31 & mod; }\n\n\nint n, m, f[N], g[N]; std::string s;\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n >> m >> s;\n\tif (s[0] == 'B') for (char &ch : s) ch ^= 'R' ^ 'B';\n\tif (std::count(s.begin(), s.end(), 'B')) {\n\t\tif (n & 1) return std::cout << \"0\\n\", 0;\n\t\tint now = 0, bound = std::find(s.begin(), s.end(), 'B') - s.begin() | 1;\n\t\tfor (char ch : s) {\n\t\t\tif (ch == 'B') {\n\t\t\t\tif (now & 1) bound = std::min(bound, now);\n\t\t\t\tnow = 0;\n\t\t\t} else ++now;\n\t\t}\n\t\tbound = bound + 1 >> 1;\n\t\tf[0] = 1, g[0] = 1;\n\t\tfor (int i = 1; i <= n / 2; ++i) {\n\t\t\treduce(f[i] = g[i - 1] - (i >= bound + 1 ? g[i - bound - 1] : 0));\n\t\t\treduce(g[i] = g[i - 1] + f[i] - mod);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= bound && i <= n / 2; ++i)\n\t\t\tans = (ans + 2LL * i * f[n / 2 - i]) % mod;\n\t\tstd::cout << ans << '\\n';\n\t} else {\n\t\tf[0] = 2, f[1] = 1;\n\t\tfor (int i = 2; i <= n; ++i)\n\t\t\treduce(f[i] = f[i - 1] + f[i - 2] - mod);\n\t\tstd::cout << f[n] << '\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=a*b%mod\n\nll n,m;\nstring s;\nll f[200010],rui[200010];\n\nint main(){\n    cin>>n>>m>>s;\n    if(s[0]=='R'){\n\tfor(int i=0;i<m;i++){\n\t    if(s[i]=='R')s[i]='B';\n\t    else s[i]='R';\n\t}\n    }\n    bool th=0;\n    ll cnt=0,mi=1e17;\n    bool fi=1; ll lead;\n    for(int i=0;i<m;i++){\n\tif(s[i]=='R'){\n\t    if(fi)lead=cnt; fi=0;\n\t    th=1;\n\t    if(cnt%2==1)chmin(mi,cnt);\n\t    cnt=0;\n\t}\n\telse cnt++;\n    }\n    \n    if(th==0){\n\tf[0]=f[1]=1;\n\tfor(int i=2;i<n;i++){\n\t    f[i]=(f[i-1]+f[i-2])%mod;\n\t}\n\tll ans=(f[n-2]*2+f[n-1])%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n    }\n    if(n%2==1){\n\tcout<<0<<endl;\n\treturn 0;\n    }\n    \n    if(lead%2==0)lead++;\n    chmin(mi,lead);\n    mi=(mi+1)/2;\n    chmin(mi,n/2);\n    if(mi==n/2)cout<<1/0<<endl;\n    f[0]=rui[0]=0;\n    for(ll i=1;i<=mi;i++){\n\tf[i]=i;\n    }\n    for(int i=1;i<n/2;i++){\n\tmad(f[i],rui[i-1]);\n\tif(i-mi-1>=0)mad(f[i],-rui[i-mi-1]);\n\trui[i]=(rui[i-1]+f[i])%mod;\n    }\n    ll ans=0;\n    for(int i=1;i<=mi;i++)mad(ans,f[n/2-i]);\n    //cout<<mi<<endl;\n    //for(int i=0;i<n/2;i++)cout<<i<<\":\"<<f[i]<<endl;\n    ans=ans*2%mod;\n    if(ans<0)ans+=mod;\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nint Mn(int a,int b){return a<b?a:b;}\nconst int N=2e5+5,mod=1e9+7;\nint upt(int x){while(x>=mod)x-=mod;while(x<0)x+=mod;return x;}\n\nint n,m,lm,dp[N],sm[N],ans,f[N][5],g[N];\nchar s[N];\n/*void solve()\n{\n  f[1][0]=1;\n  for(int i=2;i<=n;i++)\n    {\n      f[i][0]=f[i-1][0];\n      f[i][1]=upt(f[i-1][1]+f[i-1][2]);\n      f[i][2]=upt(f[i-1][0]+f[i-1][1]);\n    }\n  int ans=(f[n][0]+upt(f[n][1]+f[n][2]));\n  f[1][2]=1; f[1][0]=f[1][1]=0;\n  for(int i=2;i<=n;i++)\n    {\n      f[i][1]=upt(f[i-1][1]+f[i-1][2]);\n      f[i][2]=f[i-1][1];\n    }\n  ans=upt(ans+f[n][1]); printf(\"%d\\n\",ans);\n  }*/\nvoid solve()\n{\n  g[0]=sm[0]=1;\n  for(int i=1;i<=n;i++)\n    {\n      if(i>=2)g[i]=sm[i-2];\n      sm[i]=upt(sm[i-1]+g[i]);\n    }\n  int ans=1;//ans=1 for all one color\n  for(int i=2;i<=n;i++)\n    ans=(ans+(ll)i*g[n-i])%mod;\n  printf(\"%d\\n\",ans);\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&m);\n  scanf(\"%s\",s+1); bool fg=0;\n  for(int i=1;i<=m;i++)\n    if(s[i]!=s[1]){fg=1;break;}\n  if(!fg){solve();return 0;}\n  if(n&1){puts(\"0\");return 0;}\n  lm=n+1; int lst;\n  for(int i=m;i;i--)if(s[i]==s[1]){lst=i;break;}\n  for(int i=1;i<=m;i++)\n    if(s[i]==s[1])//== not !=\n      {\n\tint j=i;\n\twhile(j+1<=m&&s[j+1]==s[j])j++;\n\tswap(i,j); j=i-j+1;\n\tif(i-j==0) lm=Mn(lm,j+((j&1)==0));\n\telse if((j&1)&&i!=lst)lm=Mn(lm,j);//i!=lst!!!\n      }\n  n>>=1; lm=(lm+1)>>1; dp[0]=sm[0]=1;\n  for(int i=1;i<=n;i++)\n    {\n      dp[i]=sm[i-1]; if(i>lm)dp[i]=upt(dp[i]-sm[i-lm-1]);\n      sm[i]=upt(sm[i-1]+dp[i]);\n    }\n  int ans=0;\n  for(int i=1;i<=lm;i++)//lm not n\n    ans=(ans+i*2%mod*dp[n-i])%mod;\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  for(Int i=0;i<m;i++)\n    s[i]=\"BR\"[vs[i]];\n  \n  if(flg){    \n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n  assert(vs!=vector<Int>(m,0));\n\n  if(n&1){\n    cout<<0<<endl;\n    return 0;\n  }\n  \n  Int lim=n-1;  \n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    Int j=i;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n\n    if(i==0&&(j-i)%2==0) chmin(lim,j-i+1);\n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }\n  \n  vector<M> dp(n+2,0),sm(n+2,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n+1;i++){\n    sm[i]=sm[i-1]+dp[i-1];\n    if(i&1) dp[i]=sm[i-1]-sm[max<Int>(1,i-1-lim)];\n  }\n  \n  M ans{0};\n  for(Int i=0;i<=lim;i++)\n    ans+=sm[n-i+1]-sm[max<Int>(1,n-lim)];\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=2e5+20;\nconst int mod=1e9+7;\n\nint n,m;\nchar str[maxn];\nint lim;\nint f[maxn];\n\ninline void CHECK1()\n{\n\tREP(i,1,n)if(str[i]=='B')return;\n\tf[0]=1;f[1]=1;\n\tREP(i,2,n)f[i]=(f[i-1]+f[i-2])%mod;\n\tprintf(\"%d\\n\",(f[n-2]+f[n])%mod);\n\texit(0);\n}\n\ninline void init()\n{\n\tn=read();m=read();\n\tscanf(\"%s\",str+1);\n\tif(str[1]=='B')\n\t{\n\t\tREP(i,1,m)str[i]=str[i]=='B'?'R':'B';\n\t}\n\tCHECK1();\n\tlim=n;\n\tint lstb=0;\n\tREP(i,1,m)\n\t{\n\t\tif(str[i]=='B')\n\t\t{\n\t\t\tint num=i-lstb-1;\n\t\t\tif(lstb==0)chkmin(lim,num+(num+1&1));\n\t\t\telse if(num&1)chkmin(lim,num);\n\t\t\tlstb=i;\n\t\t}\n\t}\n\tlim=lim+1>>1;\n}\n\ninline void doing()\n{\n\tif(n&1)puts(\"0\"),exit(0);\n\tn>>=1;\n\tf[0]=1;int s=1;\n\tREP(i,1,n)\n\t{\n\t\tf[i]=s;\n\t\ts=(s+f[i])%mod;\n\t\tif(i-lim>=0)s=(s-f[i-lim]+mod)%mod;\n\t}\n\t//int ans=f[n>>1];\n\tint ans=0;\n\tREP(i,1,lim)ans=(ans+(ll)i*f[n-i])%mod;\n\tans=(ll)ans*2%mod;\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n        if(dp[i-1] < 0)dp[i-1] %= MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    return res;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 1;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i <= m;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int mo=1e9+7,N=2e5+5;\nint vf[N],fac[N],inv[N];\ninline int C(int n,int m){return 1ll*vf[m]*vf[n-m]%mo*fac[n]%mo;}\nint n,m,i,j,ans,lm=N,f[N],s[N];\nchar c[N];\nint main(){\n\tfor(int i=*vf=*fac=1;i<N;++i)\n\t\tinv[i]=i==1?1:1ll*(mo-mo/i)*inv[mo%i]%mo,\n\t\tvf[i]=1ll*vf[i-1]*inv[i]%mo,\n\t\tfac[i]=1ll*fac[i-1]*i%mo;\n\tscanf(\"%d%d%s\",&n,&m,c+1);\n\tfor(i=1;c[i]==c[1];++i);\n\tif(i>m){\n\t\tstatic int f[N][2];\n\t\tf[0][0]=1;\n\t\tfor(i=1;i<=n;++i)f[i][0]=(f[i-1][0]+f[i-1][1])%mo,f[i][1]=f[i-1][0];\n\t\tans=f[n][0];\n\t\tmemset(f,0,sizeof f);\n\t\tf[0][1]=1;\n\t\tfor(i=1;i<=n;++i)f[i][0]=(f[i-1][0]+f[i-1][1])%mo,f[i][1]=f[i-1][0];\n\t\tans=(ans+f[n][1])%mo;\n\t}else{\n\t\tlm=i&1?i:i-1;\n\t\tfor(;i<=m;i=j){\n\t\t\tif(c[i+1]==c[i]){puts(\"0\");return 0;}\n\t\t\tfor(j=i+1;c[j]==c[1];++j);\n\t\t\tif((j-i-1)%2==1)lm=std::min(lm,j-i-1);\n\t\t}\n\t\tif(n&1){puts(\"0\");return 0;}\n\t\tlm-=lm%2==0;lm=lm+1>>1;\n\t\ts[0]=1;\n\t\tfor(i=1;i<=n;++i)f[i]=(s[i-1]+mo-(i>lm?s[i-lm-1]:0))%mo,s[i]=(s[i-1]+f[i])%mo;\n\t\tfor(i=1;i<=lm*2-1 && i+2<=n;i+=2)ans=(ans+1ll*(i+1)*f[n-i-1>>1])%mo;\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\ntemplate<typename T>\nstruct BIT {\n    int n;\n    vector<T> dat;\n\n    BIT(int n=0){\n        initialize(n);\n    }\n\n    void initialize(int nin){\n        n = nin;\n        dat.resize(n);\n        for(int i = 0; i<n; i++) dat[i] = 0;\n    }\n\n    T sum(int i){\n        T s = 0;\n        while(i >= 0){\n            add(s, dat[i]);\n            i = (i & (i+1)) - 1;\n        }\n        return s;\n    }\n\n    T sum_between(int i, int j){\n        int64_t res = sum(j);\n        if(i>0) add(res, MOD - sum(i-1));\n        return res;\n    }\n\n    void plus(int i, T x){\n        while(i < n){\n            add(dat[i], x);\n            i |= i+1;\n        }\n    }\n\n    // a[0]+...+a[ret] >= x\n    int lower_bound(T x){\n        int ret = -1;\n        int k = 1;\n        while(2*k <= n) k <<= 1;\n        for( ;k>0; k>>=1){\n            if(ret+k < n && dat[ret+k] < x){\n                x -= dat[ret+k];\n                ret += k;\n            }\n        }\n        return ret + 1;\n    }\n};\n\nvoid solve1(int N){\n    static int64_t dp[200001][2][2] = {0};\n    dp[0][0][0] = dp[0][1][1] = 1;\n    for(int i=0; i<N-1; i++){\n        for(int j=0; j<2; j++){\n            add(dp[i+1][0][j], dp[i][0][j] + dp[i][1][j]);\n            add(dp[i+1][1][j], dp[i][0][j]);\n        }\n    }\n    int64_t ans = (dp[N-1][0][0] + dp[N-1][1][0] + dp[N-1][0][1]) % MOD;\n    cout << ans << endl;\n    exit(0);\n}\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    if(S[0] == 'B'){\n        for(int i=0; i<M; i++) S[i] = (S[i] == 'B' ? 'R' : 'B');\n    }\n\n    int len = 0, first = -1, lim = N;\n    for(int i=0; i<M; i++){\n        if(S[i] == 'R'){\n            len++;\n        }else if(len > 0){\n            if(first == -1){\n                first = len;\n            }else{\n                if(len%2) lim = min(lim, len+1);\n            }\n            len = 0;\n        }\n    }\n    if(len == M){\n        solve1(N);\n    }\n    if(N%2){\n        cout << 0 << endl;\n        return 0;\n    }\n    lim = min(lim, (first/2+1)*2);\n\n    BIT<int64_t> bit(N+1);\n    bit.plus(0, 1);\n    for(int i=2; i<=N; i+=2){\n        int l = max(0, i-lim);\n        int64_t res = bit.sum_between(l, i-1);\n        bit.plus(i, res);\n    }\n\n    int64_t ans = 0;\n    for(int i=1; i<=min(N-1, lim-1); i+=2){\n        add(ans, (i+1) * bit.sum_between(N-i-1, N-i-1) % MOD);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 200005;\nconst ll MOD = 1000000007;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n, m, nR, nB;\nchar str[MX];\nll f[MX], sum[2][MX];\n\nvector<int> divide(int x)\n{\n\tvector<int> ret;\n\tfor(int i=1; i<=x; i++)\n\t\tif(x%i == 0)\n\t\t\tret.push_back(i);\n\treturn ret;\n}\n\nint main()\n{\n\tll ans = 0;\n\tread(n), read(m);\n\tscanf(\"%s\", str+1);\n\tfor(int i=1; i<=m; i++)\n\t\tif(str[i] == 'R') nR++;\n\t\telse nB++;\n\tvector<int> dvs = divide(n);\n\tif(!nR || !nB)\n\t{\n\t\tf[0] = 1;\n\t\tsum[0][0] = sum[0][1] = 1;\n\t\tfor(int i=2; i<=n; i++)\n\t\t{\n\t\t\tf[i] = sum[0][i-2];\n\t\t\tsum[0][i] = (sum[0][i-1] + f[i]) % MOD;\n\t\t}\n\t\tans = 1;\n\t\tfor(int i=1; i<n; i++) ans = (ans+f[n-i-1]*(i+1)) % MOD;\n\t}\n\telse\n\t{\n\t\tint len = n-1;\n\t\tint pre = 0;\n\t\twhile(str[pre+1] == str[1]) pre++;\n\t\t/*if(pre&1) cmin(len, pre);\t\t//the worst case isn't when the initial position is in the middle!\n\t\telse cmin(len, pre*2-1);*/\n\t\tcmin(len, pre|1);\n\t\tint cur = 0;\n\t\tfor(int i=pre+1; i<=m+1; i++)\n\t\t{\n\t\t\tif(str[i] != str[1])\n\t\t\t{\n\t\t\t\tif(cur & 1) cmin(len, cur);\n\t\t\t\tcur = 0;\n\t\t\t}\n\t\t\telse cur++;\n\t\t}\n\t\tf[0] = sum[0][0] = 1;\n\t\tfor(int i=1; i<=n; i++)\n\t\t{\n\t\t\tf[i] = (((i-2>=0) ? (sum[i&1][i-2]) : (0)) - ((i-2-len>=0) ? (sum[i&1][i-2-len]) : (0)) + MOD) % MOD;\n\t\t\tsum[i&1][i] = (sum[i&1][i-1] + f[i]) % MOD;\n\t\t\tsum[i&1^1][i] = sum[i&1^1][i-1];\n\t\t}\n\t\tfor(int i=1; i<=len; i+=2) ans = (ans+f[n-i-1]*(i+1)) % MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nusing Int = long long;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T>\nstruct FormalPowerSeries{\n  using Poly = vector<T>;\n  using Conv = function<Poly(Poly, Poly)>;\n  Conv conv;\n  FormalPowerSeries(Conv conv):conv(conv){}\n\n  Poly pre(const Poly &as,int deg){\n    return Poly(as.begin(),as.begin()+min((int)as.size(),deg));\n  }\n\n  Poly add(Poly as,Poly bs){\n    int sz=max(as.size(),bs.size());\n    Poly cs(sz,T(0));\n    for(int i=0;i<(int)as.size();i++) cs[i]+=as[i];\n    for(int i=0;i<(int)bs.size();i++) cs[i]+=bs[i];\n    return cs;\n  }\n\n  Poly sub(Poly as,Poly bs){\n    int sz=max(as.size(),bs.size());\n    Poly cs(sz,T(0));\n    for(int i=0;i<(int)as.size();i++) cs[i]+=as[i];\n    for(int i=0;i<(int)bs.size();i++) cs[i]-=bs[i];\n    return cs;\n  }\n\n  Poly mul(Poly as,Poly bs){\n    return conv(as,bs);\n  }\n\n  Poly mul(Poly as,T k){\n    for(auto &a:as) a*=k;\n    return as;\n  }\n\n  // F(0) must not be 0\n  Poly inv(Poly as,int deg){\n    assert(as[0]!=T(0));\n    Poly rs({T(1)/as[0]});\n    for(int i=1;i<deg;i<<=1)\n      rs=pre(sub(add(rs,rs),mul(mul(rs,rs),pre(as,i<<1))),i<<1);\n    return rs;\n  }\n\n  // not zero\n  Poly div(Poly as,Poly bs){\n    while(as.back()==T(0)) as.pop_back();\n    while(bs.back()==T(0)) bs.pop_back();\n    if(bs.size()>as.size()) return Poly();\n    reverse(as.begin(),as.end());\n    reverse(bs.begin(),bs.end());\n    int need=as.size()-bs.size()+1;\n    Poly ds=pre(mul(as,inv(bs,need)),need);\n    reverse(ds.begin(),ds.end());\n    return ds;\n  }\n\n  // F(0) must be 1\n  Poly sqrt(Poly as,int deg){\n    assert(as[0]==T(1));\n    T inv2=T(1)/T(2);\n    Poly ss({T(1)});\n    for(int i=1;i<deg;i<<=1){\n      ss=pre(add(ss,mul(pre(as,i<<1),inv(ss,i<<1))),i<<1);\n      for(T &x:ss) x*=inv2;\n    }\n    return ss;\n  }\n\n  Poly diff(Poly as){\n    int n=as.size();\n    Poly res(n-1);\n    for(int i=1;i<n;i++) res[i-1]=as[i]*T(i);\n    return res;\n  }\n\n  Poly integral(Poly as){\n    int n=as.size();\n    Poly res(n+1);\n    res[0]=T(0);\n    for(int i=0;i<n;i++) res[i+1]=as[i]/T(i+1);\n    return res;\n  }\n\n  // F(0) must be 1\n  Poly log(Poly as,int deg){\n    return pre(integral(mul(diff(as),inv(as,deg))),deg);\n  }\n\n  // F(0) must be 0\n  Poly exp(Poly as,int deg){\n    Poly f({T(1)});\n    as[0]+=T(1);\n    for(int i=1;i<deg;i<<=1)\n      f=pre(mul(f,sub(pre(as,i<<1),log(f,i<<1))),i<<1);\n    return f;\n  }\n\n  Poly partition(int n){\n    Poly rs(n+1);\n    rs[0]=T(1);\n    for(int k=1;k<=n;k++){\n      if(1LL*k*(3*k+1)/2<=n) rs[k*(3*k+1)/2]+=T(k%2?-1LL:1LL);\n      if(1LL*k*(3*k-1)/2<=n) rs[k*(3*k-1)/2]+=T(k%2?-1LL:1LL);\n    }\n    return inv(rs,n+1);\n  }\n};\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\nconstexpr int bmds(int x){\n  const int v[] = {1012924417, 924844033, 998244353,\n                   897581057, 645922817};\n  return v[x];\n}\nconstexpr int brts(int x){\n  const int v[] = {5, 5, 3, 3, 3};\n  return v[x];\n}\n\ntemplate<int X>\nstruct NTT{\n  static constexpr int md = bmds(X);\n  static constexpr int rt = brts(X);\n  using M = Mint<int, md>;\n  vector< vector<M> > rts,rrts;\n\n  void ensure_base(int n){\n    if((int)rts.size()>=n) return;\n    rts.resize(n);rrts.resize(n);\n    for(int i=1;i<n;i<<=1){\n      if(!rts[i].empty()) continue;\n      M w=M(rt).pow((md-1)/(i<<1));\n      M rw=w.inv();\n      rts[i].resize(i);rrts[i].resize(i);\n      rts[i][0]=M(1);rrts[i][0]=M(1);\n      for(int k=1;k<i;k++){\n        rts[i][k]=rts[i][k-1]*w;\n        rrts[i][k]=rrts[i][k-1]*rw;\n      }\n    }\n  }\n\n  void ntt(vector<M> &as,bool f,int n=-1){\n    if(n==-1) n=as.size();\n    assert((n&(n-1))==0);\n    ensure_base(n);\n\n    for(int i=0,j=1;j+1<n;j++){\n      for(int k=n>>1;k>(i^=k);k>>=1);\n      if(i>j) swap(as[i],as[j]);\n    }\n\n    for(int i=1;i<n;i<<=1){\n      for(int j=0;j<n;j+=i*2){\n        for(int k=0;k<i;k++){\n          M z=as[i+j+k]*(f?rrts[i][k]:rts[i][k]);\n          as[i+j+k]=as[j+k]-z;\n          as[j+k]+=z;\n        }\n      }\n    }\n\n    if(f){\n      M tmp=M(n).inv();\n      for(int i=0;i<n;i++) as[i]*=tmp;\n    }\n  }\n\n  vector<M> multiply(vector<M> as,vector<M> bs){\n    int need=as.size()+bs.size()-1;\n    int sz=1;\n    while(sz<need) sz<<=1;\n    as.resize(sz,M(0));\n    bs.resize(sz,M(0));\n\n    ntt(as,0);ntt(bs,0);\n    for(int i=0;i<sz;i++) as[i]*=bs[i];\n    ntt(as,1);\n\n    as.resize(need);\n    return as;\n  }\n\n  vector<int> multiply(vector<int> as,vector<int> bs){\n    vector<M> am(as.size()),bm(bs.size());\n    for(int i=0;i<(int)am.size();i++) am[i]=M(as[i]);\n    for(int i=0;i<(int)bm.size();i++) bm[i]=M(bs[i]);\n    vector<M> cm=multiply(am,bm);\n    vector<int> cs(cm.size());\n    for(int i=0;i<(int)cs.size();i++) cs[i]=cm[i].v;\n    return cs;\n  }\n};\ntemplate<int X> constexpr int NTT<X>::md;\ntemplate<int X> constexpr int NTT<X>::rt;\n\n\nnamespace FFT{\n  using dbl = double;\n\n  struct num{\n    dbl x,y;\n    num(){x=y=0;}\n    num(dbl x,dbl y):x(x),y(y){}\n  };\n\n  inline num operator+(num a,num b){\n    return num(a.x+b.x,a.y+b.y);\n  }\n  inline num operator-(num a,num b){\n    return num(a.x-b.x,a.y-b.y);\n  }\n  inline num operator*(num a,num b){\n    return num(a.x*b.x-a.y*b.y,a.x*b.y+a.y*b.x);\n  }\n  inline num conj(num a){\n    return num(a.x,-a.y);\n  }\n\n  int base=1;\n  vector<num> rts={{0,0},{1,0}};\n  vector<int> rev={0,1};\n\n  const dbl PI=acosl(-1.0);\n\n  void ensure_base(int nbase){\n    if(nbase<=base) return;\n\n    rev.resize(1<<nbase);\n    for(int i=0;i<(1<<nbase);i++)\n      rev[i]=(rev[i>>1]>>1)+((i&1)<<(nbase-1));\n\n    rts.resize(1<<nbase);\n    while(base<nbase){\n      dbl angle=2*PI/(1<<(base+1));\n      for(int i=1<<(base-1);i<(1<<base);i++){\n        rts[i<<1]=rts[i];\n        dbl angle_i=angle*(2*i+1-(1<<base));\n        rts[(i<<1)+1]=num(cos(angle_i),sin(angle_i));\n      }\n      base++;\n    }\n  }\n\n  void fft(vector<num> &a,int n=-1){\n    if(n==-1) n=a.size();\n    assert((n&(n-1))==0);\n\n    int zeros=__builtin_ctz(n);\n    ensure_base(zeros);\n    int shift=base-zeros;\n    for(int i=0;i<n;i++)\n      if(i<(rev[i]>>shift))\n        swap(a[i],a[rev[i]>>shift]);\n\n    for(int k=1;k<n;k<<=1){\n      for(int i=0;i<n;i+=2*k){\n        for(int j=0;j<k;j++){\n          num z=a[i+j+k]*rts[j+k];\n          a[i+j+k]=a[i+j]-z;\n          a[i+j]=a[i+j]+z;\n        }\n      }\n    }\n  }\n\n  vector<num> fa;\n\n  vector<Int> multiply(vector<int> &a,vector<int> &b){\n    int need=a.size()+b.size()-1;\n    int nbase=0;\n    while((1<<nbase)<need) nbase++;\n    ensure_base(nbase);\n\n    int sz=1<<nbase;\n    if(sz>(int)fa.size()) fa.resize(sz);\n    for(int i=0;i<sz;i++){\n      int x=(i<(int)a.size()?a[i]:0);\n      int y=(i<(int)b.size()?b[i]:0);\n      fa[i]=num(x,y);\n    }\n    fft(fa,sz);\n\n    num r(0,-0.25/sz);\n    for(int i=0;i<=(sz>>1);i++){\n      int j=(sz-i)&(sz-1);\n      num z=(fa[j]*fa[j]-conj(fa[i]*fa[i]))*r;\n      if(i!=j)\n        fa[j]=(fa[i]*fa[i]-conj(fa[j]*fa[j]))*r;\n      fa[i]=z;\n    }\n    fft(fa,sz);\n\n    vector<Int> res(need);\n    for(int i=0;i<need;i++)\n      res[i]=fa[i].x+0.5;\n\n    return res;\n  }\n\n};\n\n\ntemplate<typename T>\nstruct ArbitraryModConvolution{\n  using dbl=FFT::dbl;\n  using num=FFT::num;\n\n  vector<T> multiply(vector<T> as,vector<T> bs){\n    int need=as.size()+bs.size()-1;\n    int sz=1;\n    while(sz<need) sz<<=1;\n    vector<num> fa(sz),fb(sz);\n    for(int i=0;i<(int)as.size();i++)\n      fa[i]=num(as[i].v&((1<<15)-1),as[i].v>>15);\n    for(int i=0;i<(int)bs.size();i++)\n      fb[i]=num(bs[i].v&((1<<15)-1),bs[i].v>>15);\n\n    fft(fa,sz);fft(fb,sz);\n\n    dbl ratio=0.25/sz;\n    num r2(0,-1),r3(ratio,0),r4(0,-ratio),r5(0,1);\n    for(int i=0;i<=(sz>>1);i++){\n      int j=(sz-i)&(sz-1);\n      num a1=(fa[i]+conj(fa[j]));\n      num a2=(fa[i]-conj(fa[j]))*r2;\n      num b1=(fb[i]+conj(fb[j]))*r3;\n      num b2=(fb[i]-conj(fb[j]))*r4;\n      if(i!=j){\n        num c1=(fa[j]+conj(fa[i]));\n        num c2=(fa[j]-conj(fa[i]))*r2;\n        num d1=(fb[j]+conj(fb[i]))*r3;\n        num d2=(fb[j]-conj(fb[i]))*r4;\n        fa[i]=c1*d1+c2*d2*r5;\n        fb[i]=c1*d2+c2*d1;\n      }\n      fa[j]=a1*b1+a2*b2*r5;\n      fb[j]=a1*b2+a2*b1;\n    }\n    fft(fa,sz);fft(fb,sz);\n\n    vector<T> cs(need);\n    using ll = long long;\n    for(int i=0;i<need;i++){\n      ll aa=T(llround(fa[i].x)).v;\n      ll bb=T(llround(fb[i].x)).v;\n      ll cc=T(llround(fa[i].y)).v;\n      cs[i]=T(aa+(bb<<15)+(cc<<30));\n    }\n    return cs;\n  }\n};\n\n//INSERT ABOVE HERE\n\nsigned HAPPYQUERY_E(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n,m,q;\n  cin>>n>>m>>q;\n  vector<int> ls(q),rs(q);\n  for(int i=0;i<q;i++) cin>>ls[i]>>rs[i],ls[i]--;\n\n  vector<int> as(n);\n  for(int i=0;i<n;i++) cin>>as[i];\n\n  if(as==vector<int>(n,0)){\n    for(int i=0;i<m;i++){\n      if(i) cout<<\" \";\n      cout<<0;\n    }\n    cout<<endl;\n    return 0;\n  }\n\n  vector<int> cs(n-m+1,0);\n  for(int l:ls) cs[l]++;\n\n  NTT<0> ntt;\n  using M = NTT<0>::M;\n  auto conv=[&](auto as,auto bs){return ntt.multiply(as,bs);};\n  FormalPowerSeries<M> FPS(conv);\n\n  vector<M> ps(as.size()),qs(cs.size());\n  for(int i=0;i<(int)ps.size();i++) ps[i]=M(as[i]);\n  for(int i=0;i<(int)qs.size();i++) qs[i]=M(cs[i]);\n\n  auto bs=FPS.div(ps,qs);\n  for(int i=0;i<m;i++){\n    if(i) cout<<\" \";\n    cout<<bs[i];\n  }\n  cout<<endl;\n  return 0;\n}\n/*\n  verified on 2019/09/17\n  https://www.hackerrank.com/contests/happy-query-contest/challenges/array-restoring\n*/\n\nsigned CFR250_E(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n,m;\n  cin>>n>>m;\n  vector<int> cs(n);\n  for(int i=0;i<n;i++) cin>>cs[i];\n\n  NTT<2> ntt;\n  using M = NTT<2>::M;\n  auto conv=[&](auto as,auto bs){return ntt.multiply(as,bs);};\n  FormalPowerSeries<M> FPS(conv);\n\n  const int deg=1<<18;\n  vector<M> as(deg,0);\n  as[0]=M(1);\n  for(int c:cs) as[c]-=M(4);\n\n  auto bs=FPS.sqrt(as,deg);\n  bs[0]+=M(1);\n\n  vector<M> vs({2});\n\n  auto ans=FPS.mul(vs,FPS.inv(bs,deg));\n  for(int i=1;i<=m;i++) cout<<ans[i]<<\"\\n\";\n  cout<<flush;\n\n  return 0;\n}\n/*\n  verified on 2019/09/17\n  https://codeforces.com/contest/438/problem/E\n*/\n\nsigned YUKI_3046(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int k,n;\n  cin>>k>>n;\n  vector<int> xs(n);\n  for(int i=0;i<n;i++) cin>>xs[i];\n\n  using M = Mint<int>;\n  ArbitraryModConvolution<M> arb;\n  auto conv=[&](auto as,auto bs){return arb.multiply(as,bs);};\n  FormalPowerSeries<M> FPS(conv);\n\n  const int sz=1<<17;\n  vector<M> bs(sz,M(0));\n  bs[0]=1;\n  for(int x:xs) bs[x]-=M(1);\n  cout<<FPS.inv(bs,k+1)[k]<<endl;\n  return 0;\n}\n/*\n  verified on 2019/09/17\n  https://yukicoder.me/problems/no/3046\n*/\n\nconst int md = 998244353;\ninline int add(int a,int b){\n  a+=b;\n  if(a>=md) a-=md;\n  return a;\n}\n\ninline int mul(int a,int b){\n  return 1LL*a*b%md;\n}\n\ninline int pow(int a,int b){\n  int res=1;\n  while(b){\n    if(b&1) res=mul(res,a);\n    a=mul(a,a);\n    b>>=1;\n  }\n  return res;\n}\n\ninline int sqrt(int a){\n  if(a==0) return 0;\n  if(pow(a,(md-1)/2)!=1) return -1;\n  int q=md-1,m=0;\n  while(~q&1) q>>=1,m++;\n  mt19937 mt;\n  int z=mt()%md;\n  while(pow(z,(md-1)/2)!=md-1) z=mt()%md;\n  int c=pow(z,q),t=pow(a,q),r=pow(a,(q+1)/2);\n  while(m>1){\n    if(pow(t,1<<(m-2))!=1)\n      r=mul(r,c),t=mul(t,mul(c,c));\n    c=mul(c,c);\n    m--;\n  }\n  return min(r,md-r);\n}\n\nsigned LOJ_150(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  NTT<2> ntt;\n  using M = NTT<2>::M;\n  auto conv=[&](auto as,auto bs){return ntt.multiply(as,bs);};\n  FormalPowerSeries<M> FPS(conv);\n\n  int n,k;\n  cin>>n>>k;\n\n  vector<M> F(n+1);\n  for(int i=0;i<=n;i++) cin>>F[i].v;\n\n  const int deg = 1<<17;\n  auto as=FPS.log(FPS.mul(F,F[0].inv()),deg);\n  auto bs=FPS.exp(FPS.mul(as,M((md-1)/2)),deg);\n  M s(sqrt(F[0].v));\n  auto cs=FPS.integral(FPS.mul(bs,s.inv()));\n  auto ds=FPS.exp(cs,deg);\n  auto es=FPS.sub(F,ds);\n  es[0]+=M(2);\n  es[0]-=F[0];\n  auto fs=FPS.log(es,deg);\n  fs[0]+=M(1);\n  auto gs=FPS.log(fs,deg);\n  auto hs=FPS.mul(gs,M(k));\n  auto is=FPS.exp(hs,deg);\n  auto G=FPS.diff(is);\n\n  for(int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<G[i];\n  }\n  cout<<endl;\n  return 0;\n}\n#define mod 1000000007\n\nMint<int,mod> dp[400010][2][2];\nint main(){\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if(s[0]=='R'){\n        rep(i,m){\n            if(s[i]=='R'){\n                s[i] ='B';\n            }else{\n                s[i] ='R'; \n            }\n        }\n    }\n    int a = inf;\n    int c = 0;\n    bool flag = 1;\n    rep(i,m){\n        if(s[i]=='B'){\n            c++;\n        }else{\n            if(flag){\n                chmin(a,c);\n                flag = false;\n            }\n            if(c%2==1){\n                chmin(a,c);\n            }    \n            c = 0;\n        }\n    }\n    if(a==inf){\n        dp[0][0][0] = 1;\n        dp[0][1][1] = 1;\n        for(int i=1;i<n;i++){\n            for(int j=0;j<2;j++){\n                if(j==0){\n                    dp[i][j][0] += dp[i-1][1][0];\n                    dp[i][j][1] += dp[i-1][1][1];\n                }else{\n                    dp[i][j][0] += dp[i-1][1][0] + dp[i-1][0][0];\n                    dp[i][j][1] += dp[i-1][1][1] + dp[i-1][0][1];    \n                }\n            }\n        }\n        cout << dp[n-1][1][0] + dp[n-1][1][1] + dp[n-1][0][1] << endl;\n    }else{\n        int len = (a/2)*2+1;\n        cerr << len << endl;\n        vector<Mint<int> > X(n+1),Y(n+1);\n        len++;\n        len = min(len,n);\n        for(int i=2;i<=len;i+=2){\n            X[i] = i;\n        }\n        Y[0] = 1;\n        for(int i=2;i<=len;i+=2){\n            Y[i] = mod-1;\n        }\n        ArbitraryModConvolution<Mint<int,mod> > arb;\n        auto conv=[&](auto as,auto bs){return arb.multiply(as,bs);};\n        FormalPowerSeries<Mint<int> > FPS(conv);\n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        auto cs = FPS.inv(Y,n+1);\n        \n        // rep(i,n+1){\n        //     cerr << cs[i] << \" \";\n        // }\n        auto res = FPS.mul(X,cs);\n        cout << res[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  // clang-format off\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) long long __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define in2(s,t)     rep(i,sz(s)){in(s[i] , t[i]);}\n#define in3(s,t,u)   rep(i,sz(s)){in(s[i] , t[i] , u[i]);}\n#define in4(s,t,u,v) rep(i,sz(s)){in(s[i] , t[i] , u[i] , v[i]);}\n#ifdef ONLINE_JUDGE\n  #define rep(i,N) for(int i = 0; i < (int)(N); i++)\n  #define repr(i,N) for(int i = (int)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(int i = 1; i <= (int)(N) ; i++)\n  #define repr1(i,N) for(int i = (N) ; (int)(i) > 0 ; i--)\n#else\n  #define rep(i,N) for(long long i = 0; i < (long long)(N); i++)\n  #define repr(i,N) for(long long i = (long long)(N) - 1; i >= 0; i--)\n  #define rep1(i,N) for(long long i = 1; i <= (long long)(N) ; i++)\n  #define repr1(i,N) for(long long i = (N) ; (long long)(i) > 0 ; i--)\n#endif\nusing namespace std; void solve();\nusing ll = long long; template<class T = ll> using V = vector<T>;\nusing vi = V<int>; using vl = V<>; using vvi = V< V<int> >;\nusing vd = V<double>; using vs = V<string>; using vvl = V< V<> >;\nconstexpr int inf = 1001001001; constexpr ll infLL = (1LL << 61) - 1;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T,typename U>ll ceil(T a,U b){return (a + b - 1) / b;}\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); for(int i=0;i<s;i++) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);} while(0)\n  #define trcc(v) do { cerr << \"name : \" << #v << \"\\n\"; int cnt = 0; each(x , v){cerr << (cnt++) << \" : \"; trc(x); } } while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  #define trcc(...)\n  int main(){solve();}\n#endif\n\nconstexpr ll TEN(int n){ll ret=1,x=10;while(n){if(n&1)ret*=x;x*=x;n>>=1;}return ret;}\n#define mem(a, val) memset(a, val, sizeof(a))\n\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\nusing P = pair<ll,ll>; using vp = V<P>;\nconstexpr int MOD = /**/ 1000000007; //*/ 998244353;\n// clang-format on\n////////////////////////////////////////////////////\n\n\nvector<pair<char,int>> RunLengthEncoding(string& S){\n  vector<pair<char,int>> ret;\n  char c = -1;\n  int n = 0;\n  for(char x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate<typename T>\nvector<pair<T,int>> RunLengthEncoding(vector<T>& S){\n  vector<pair<T,int>> ret;\n  T c = -1;\n  int n = 0;\n  for(T& x : S){\n    if(c == x) n++;\n    else{\n      if(n) ret.emplace_back(c , n);\n      c = x , n = 1;\n    }\n  }\n  if(n) ret.emplace_back(c , n);\n  return ret;\n}\n\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt< MOD >;\nusing mint = modint;\n\nnamespace FastFourierTransform {\n  using real = double;\n\n  struct C {\n    real x, y;\n\n    C() : x(0), y(0) {}\n\n    C(real x, real y) : x(x), y(y) {}\n\n    inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n    inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n    inline C operator*(const C &c) const { return C(x * c.x - y * c.y, x * c.y + y * c.x); }\n\n    inline C conj() const { return C(x, -y); }\n  };\n\n  const real PI = acosl(-1);\n  int base = 1;\n  vector< C > rts = { {0, 0},\n                     {1, 0} };\n  vector< int > rev = {0, 1};\n\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    while(base < nbase) {\n      real angle = PI * 2.0 / (1 << (base + 1));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        real angle_i = angle * (2 * i + 1 - (1 << base));\n        rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n      }\n      ++base;\n    }\n  }\n\n  void fft(vector< C > &a, int n) {\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          C z = a[i + j + k] * rts[j + k];\n          a[i + j + k] = a[i + j] - z;\n          a[i + j] = a[i + j] + z;\n        }\n      }\n    }\n  }\n\n  vector< int64_t > multiply(const vector< int > &a, const vector< int > &b) {\n    int need = (int) a.size() + (int) b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < sz; i++) {\n      int x = (i < (int) a.size() ? a[i] : 0);\n      int y = (i < (int) b.size() ? b[i] : 0);\n      fa[i] = C(x, y);\n    }\n    fft(fa, sz);\n    C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n      fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n      fa[i] = z;\n    }\n    for(int i = 0; i < (sz >> 1); i++) {\n      C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n      C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n      fa[i] = A0 + A1 * s;\n    }\n    fft(fa, sz >> 1);\n    vector< int64_t > ret(need);\n    for(int i = 0; i < need; i++) {\n      ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n    }\n    return ret;\n  }\n};\n\ntemplate< typename T >\nstruct ArbitraryModConvolution {\n  using real = FastFourierTransform::real;\n  using C = FastFourierTransform::C;\n\n  ArbitraryModConvolution() = default;\n\n  vector< T > multiply(const vector< T > &a, const vector< T > &b, int need = -1) {\n    if(need == -1) need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while((1 << nbase) < need) nbase++;\n    FastFourierTransform::ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector< C > fa(sz);\n    for(int i = 0; i < (int)a.size(); i++) {\n      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);\n    }\n    fft(fa, sz);\n    vector< C > fb(sz);\n    if(a == b) {\n      fb = fa;\n    } else {\n      for(int i = 0; i < (int)b.size(); i++) {\n        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);\n      }\n      fft(fb, sz);\n    }\n    real ratio = 0.25 / sz;\n    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);\n    for(int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C a1 = (fa[i] + fa[j].conj());\n      C a2 = (fa[i] - fa[j].conj()) * r2;\n      C b1 = (fb[i] + fb[j].conj()) * r3;\n      C b2 = (fb[i] - fb[j].conj()) * r4;\n      if(i != j) {\n        C c1 = (fa[j] + fa[i].conj());\n        C c2 = (fa[j] - fa[i].conj()) * r2;\n        C d1 = (fb[j] + fb[i].conj()) * r3;\n        C d2 = (fb[j] - fb[i].conj()) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector< T > ret(need);\n    for(int i = 0; i < need; i++) {\n      int64_t aa = llround(fa[i].x);\n      int64_t bb = llround(fb[i].x);\n      int64_t cc = llround(fa[i].y);\n      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;\n      ret[i] = aa + (bb << 15) + (cc << 30);\n    }\n    return ret;\n  }\n};\n\ntemplate< int mod >\nstruct NumberTheoreticTransform {\n\n  int base, max_base, root;\n  vector< int > rev, rts;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while(tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while(mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while(n > 0) {\n      if(n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) {\n    return mod_pow(x, mod - 2);\n  }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if(x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long) mod;\n  }\n\n  void ensure_base(int nbase) {\n    if(nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for(int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while(base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for(int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n\n  void ntt(vector< int > &a) {\n    const int n = (int) a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for(int i = 0; i < n; i++) {\n      if(i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for(int k = 1; k < n; k <<= 1) {\n      for(int i = 0; i < n; i += 2 * k) {\n        for(int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n\n  vector< int > multiply(vector< int > a, vector< int > b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for(int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n\n  vector<modint> multiply_for_fps(const vector<modint> &a,const vector<modint> &b){\n    vector<int> A(a.size()) , B(b.size());\n    for(int i = 0;i < (int)a.size(); i++) A[i] = a[i].x;\n    for(int i = 0;i < (int)b.size(); i++) B[i] = b[i].x;\n    auto C = multiply( A , B );\n    vector<modint> ret(C.size());\n    for(int i = 0; i < (int)C.size() ;i++) ret[i].x = C[i];\n    return ret;\n  }\n};\n\n\ntemplate< typename T >\nstruct FormalPowerSeries : vector< T > {\n  using vector< T >::vector;\n  using P = FormalPowerSeries;\n\n  using MULT = function< P(P, P) >;\n\n  static MULT &get_mult() {\n    static MULT mult = nullptr;\n    return mult;\n  }\n\n  static void set_fft(MULT f) {\n    get_mult() = f;\n  }\n\n  void shrink() {\n    while(this->size() && this->back() == T(0)) this->pop_back();\n  }\n\n  P operator+(const P &r) const { return P(*this) += r; }\n\n  P operator+(const T &v) const { return P(*this) += v; }\n\n  P operator-(const P &r) const { return P(*this) -= r; }\n\n  P operator-(const T &v) const { return P(*this) -= v; }\n\n  P operator*(const P &r) const { return P(*this) *= r; }\n\n  P operator*(const T &v) const { return P(*this) *= v; }\n\n  P operator/(const P &r) const { return P(*this) /= r; }\n\n  P operator%(const P &r) const { return P(*this) %= r; }\n\n  P &operator+=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] += r[i];\n    return *this;\n  }\n\n  P &operator+=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] += r;\n    return *this;\n  }\n\n  P &operator-=(const P &r) {\n    if(r.size() > this->size()) this->resize(r.size());\n    for(int i = 0; i < (int)r.size(); i++) (*this)[i] -= r[i];\n    shrink();\n    return *this;\n  }\n\n  P &operator-=(const T &r) {\n    if(this->empty()) this->resize(1);\n    (*this)[0] -= r;\n    shrink();\n    return *this;\n  }\n\n  P &operator*=(const T &v) {\n    const int n = (int) this->size();\n    for(int k = 0; k < n; k++) (*this)[k] *= v;\n    return *this;\n  }\n\n  P &operator*=(const P &r) {\n    if(this->empty() || r.empty()) {\n      this->clear();\n      return *this;\n    }\n    assert(get_mult() != nullptr);\n    return *this = get_mult()(*this, r);\n  }\n\n  P &operator%=(const P &r) {\n    return *this -= *this / r * r;\n  }\n\n  P operator-() const {\n    P ret(this->size());\n    for(int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];\n    return ret;\n  }\n\n  P &operator/=(const P &r) {\n    if(this->size() < r.size()) {\n      this->clear();\n      return *this;\n    }\n    int n = this->size() - r.size() + 1;\n    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);\n  }\n\n  P pre(int sz) const {\n    return P(begin(*this), begin(*this) + min((int) this->size(), sz));\n  }\n\n  P operator>>(int sz) const {\n    if(this->size() <= sz) return {};\n    P ret(*this);\n    ret.erase(ret.begin(), ret.begin() + sz);\n    return ret;\n  }\n\n  P operator<<(int sz) const {\n    P ret(*this);\n    ret.insert(ret.begin(), sz, T(0));\n    return ret;\n  }\n\n  P rev(int deg = -1) const {\n    P ret(*this);\n    if(deg != -1) ret.resize(deg, T(0));\n    reverse(begin(ret), end(ret));\n    return ret;\n  }\n\n  P diff() const {\n    const int n = (int) this->size();\n    P ret(max(0, n - 1));\n    for(int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);\n    return ret;\n  }\n\n  P integral() const {\n    const int n = (int) this->size();\n    P ret(n + 1);\n    ret[0] = T(0);\n    for(int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);\n    return ret;\n  }\n\n  // F(0) must not be 0\n  P inv(int deg = -1) const {\n    assert(((*this)[0]) != T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1) / (*this)[0]});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 1\n  P log(int deg = -1) const {\n    assert((*this)[0] == 1);\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();\n  }\n\n  P sqrt(int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n\n    if((*this)[0] == T(0)) {\n      for(int i = 1; i < n; i++) {\n        if((*this)[i] != T(0)) {\n          if(i & 1) return {};\n          if(deg - i / 2 <= 0) break;\n          auto ret = (*this >> i).sqrt(deg - i / 2) << (i / 2);\n          if(ret.size() < deg) ret.resize(deg, T(0));\n          return ret;\n        }\n      }\n      return P(deg, 0);\n    }\n\n    P ret({T(1)});\n    T inv2 = T(1) / T(2);\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 0\n  P exp(int deg = -1) const {\n    assert((*this)[0] == T(0));\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    P ret({T(1)});\n    for(int i = 1; i < deg; i <<= 1) {\n      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  P pow(int64_t k, int deg = -1) const {\n    const int n = (int) this->size();\n    if(deg == -1) deg = n;\n    for(int i = 0; i < n; i++) {\n      if((*this)[i] != T(0)) {\n        T rev = T(1) / (*this)[i];\n        P C(*this * rev);\n        P D(n - i);\n        for(int j = i; j < n; j++) D[j - i] = C[j];\n        D = (D.log() * k).exp() * (*this)[i].pow(k);\n        P E(deg);\n        if(i * k > deg) return E;\n        auto S = i * k;\n        for(int j = 0; j + S < deg && j < D.size(); j++) E[j + S] = D[j];\n        return E;\n      }\n    }\n    return *this;\n  }\n\n  T eval(T x) const {\n    T r = 0, w = 1;\n    for(auto &v : *this) {\n      r += w * v;\n      w *= x;\n    }\n    return r;\n  }\n};\n\nusing FPS = FormalPowerSeries< modint >;\n\n// fにa * x^n + bを掛ける\nvoid mul_simple(FPS &f,modint a ,int n, modint b){\n  for(int i = (int)f.size() - 1 ; i >= 0 ; i--){\n    f[i] *= b;\n    if(i >= n) f[i] += f[i - n] * a; \n  }\n}\n\n// fからa * x^n + bを割る\nvoid div_simple(FPS &f,modint a,int n,modint b){\n  for(int i = 0 ; i < (int)f.size() ; i++){\n    f[i] /= b;\n    if(i + n < (int)f.size() ) f[n + i] -= f[i] * a; \n  }\n}\n\n// f / gをdeg(f)次まで求める\nFPS div_(FPS &f , FPS g){\n  int n = f.size();\n  return (f * g.inv(n)).pre(n);\n}\n\n\n// solve関数内で\n//\n// FPS::set_fft(mul);\n//\n// とすること。\n\n/**\nNumberTheoreticTransform<MOD> ntt;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret =ntt.multiply_for_fps(a , b);\n  return FPS::P(ret.begin(), ret.end());\n};\n/*///\nArbitraryModConvolution< modint > fft;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret = fft.multiply(a, b);\n  return FPS::P(ret.begin(), ret.end());\n};\n//*/\n\n// 下記のリンクを実装(kitamasa法のモンゴメリ乗算を使わない版)\n// http://q.c.titech.ac.jp/docs/progs/polynomial_division.html\n// k項間漸化式のa_Nを求める O(k log k log N)\n// N ... 求めたい項　(0-indexed)\n// Q ... 漸化式 (1 - \\sum_i c_i x^i)の形\n// a ... 初期解 (a_0 , a_1 , ... , a_k-1)\n// x^N を fでわった剰余を求め、aと内積を取る\nmodint kitamasa(ll N, FPS &Q, FPS &a){\n  int k = Q.size() - 1;\n  assert( (int)a.size() == k );\n  FPS P = a * Q; P.resize(k);\n  while(N){\n    auto Q2 = Q;\n    for(int i = 1; i < (int)Q2.size(); i += 2) Q2[i].x = MOD - Q2[i].x;\n    auto S = P * Q2;\n    auto T = Q * Q2;\n    if(N & 1){\n      for(int i = 1 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    else{\n      for(int i = 0 ; i < (int)S.size() ; i += 2) P[i>>1].x = S[i].x;\n      for(int i = 0 ; i < (int)T.size() ; i += 2) Q[i>>1].x = T[i].x;\n    }\n    N >>= 1;\n  }\n  return P[0];\n}\n\nvoid solve(){\n  ini(N , M);\n  ins(S);\n  auto run = RunLengthEncoding(S);\n  if(run.size() == 1){\n    // DP\n    V<mint> dp(N),ep(N),fp(N),gp(N);\n    // [0]がR\n    // -> [1],[-1]はどちらでもよい\n    dp[0] = gp[0] = 1;\n    rep1(i , N - 1){\n      dp[i] = dp[i - 1] + ep[i - 1];\n      ep[i] = dp[i - 1];\n      fp[i] = fp[i - 1] + gp[i - 1];\n      gp[i] = fp[i - 1];\n    }\n    out(dp[N-1] + ep[N-1] + fp[N-1]);\n    return;\n  }\n  if(N % 2 == 1){\n    out(0);\n    return;\n  }\n\n  FPS::set_fft(mul);\n  // rの最小値\n  int r = N-1 , b = N-1;\n  auto trans = [](int n){\n    return (n % 2 == 1) ? n : (n + 1);\n  };\n  rep(i , sz(run)){\n    if(i==0)continue;\n    auto p = run[i];\n    if(p.first == 'R' && p.second % 2 == 1) amin(r , trans(p.second));\n    if(p.first == 'B' && p.second % 2 == 1) amin(b , trans(p.second));\n  }\n\n  // 初手の制約\n  amin( (run[0].first == 'R' ? r : b) , trans(run[0].second) );\n  // 初手とは異なる方が1である必要あり\n  (run[0].first == 'R' ? b : r) = 1;\n  trc(r , b);\n  if(r < b) swap(r , b);  \n  if(r == N - 1) exit(1);\n  auto nyaan = [&](ll n,int flg = false) -> FPS{\n    FPS ret(n + 1);\n    for(int i = 1 ; i <= n ; i += 2) ret[i] = (flg ? i + 1 : 1);\n    return ret;\n  };\n  FPS f({0 , 1});\n  f *= nyaan(r);\n  f *= -1; f[0] = 1;\n  if((int)f.size() <= N) f.resize(N * 2 + 100);\n  trc(f);\n  f = f.inv();\n  trc(f);\n  // [0]の置き方\n  f *= nyaan(r,1);\n  trc(f);\n  out(f[N-1]);\n  \n  \n  /*\n  //trc(f);\n  // 倍数包除\n  for(int i = 2 ; i <= N ; i++){\n    // i番目は？\n    //引こう！\n    for(int j = 2 ; i * j <= N ; j++){\n      f[i * j] -= f[i];\n    }\n  }\n  trc(f);\n  */\n\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; trav(a,x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N,M;\nstring S;\n// if all red / blue: each must be adjacent to at least one red \n// otherwise: red/blue are odds: at most length of smallest odd string \n\nvoid init() {\n    setIO(); re(N,M,S);\n    if (S[0] == 'R') {\n        trav(t,S) {\n            if (t == 'B') t = 'R';\n            else t = 'B';\n        }\n    }\n    int co = 0;\n    trav(t,S) if (t == 'R') co ++;\n    if (co) return;\n    mi fib[200001];\n    fib[0] = fib[1] = 1;\n    FOR(i,2,N+1) fib[i] = fib[i-1]+fib[i-2];\n    ps(fib[N]+fib[N-2]); exit(0);\n}\n\nmi dp[200001];\n\nint main() {\n    init();\n    int maxLen = MOD;\n    // ps(S);\n    bool fst = 1;\n    for (int i = 0; i < sz(S); ) {\n        if (S[i] == 'B') {\n            int I = i; \n            while (i < sz(S) && S[i] == S[I]) i ++;\n            if ((i-I)&1) {\n                if (i == sz(S)) break;\n                ckmin(maxLen,i-I);\n                fst = 0;\n            } else if (fst) ckmin(maxLen,i-I+1);\n            fst = 0;\n        } else i++;\n    }\n    maxLen = (maxLen+1)/2;\n    if (N&1) { ps(0); exit(0); }\n    N /= 2; dp[0] = 1;\n    mi sum(0);\n    FOR(i,1,N+1) {\n        sum += dp[i-1];\n        if (i-maxLen-1 >= 0) sum -= dp[i-maxLen-1];\n        dp[i] = sum;\n    }\n    mi ans(0);\n    F0R(i,N) if (N-i <= maxLen) ans += 2*(N-i)*dp[i];\n    ps(ans);\n    // ps(maxLen);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nchar str[200005];\nint arr[200005];\nlong long MOD=1000000007;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",str);\n\tfor(int i=0;i<m;i++)if(str[i]=='R')arr[i]=0;else arr[i]=1;\n\tbool all[2];all[0]=all[1]=1;\n\tfor(int i=0;i<m;i++)all[arr[i]^1]=0;\n\tif(all[0]||all[1]){\n\t\tlong long dp[2][n];memset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;dp[1][0]=0; //start with red (or blue if everything is blue)\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tlong long ans=(dp[0][n-1]+dp[1][n-1])%MOD;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=0;dp[1][0]=1; //start with blue\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tans+=dp[0][n-1];\n\t\tprintf(\"%lld\",ans%MOD);\n\t\treturn 0;\n\t}\n\tif(n%2!=0){printf(\"0\");return 0;}\n\tint cur=0;vector<int> v;\n\tfor(int i=0;i<n;i++){\n\t\tif(arr[i]==arr[0])cur++;\n\t\telse{if(cur!=0)v.push_back(cur);cur=0;}\n\t}\n\tif(cur!=0)v.push_back(cur);\n\tint mxl=min((v[0]%2==0?v[0]+1:v[0]),n-1);\n\tfor(int i=1;i<(int)v.size();i++){\n\t\tif(v[i]%2==1)mxl=min(mxl,v[i]);\n\t}\n\t//comments: wlog red is first\n\tn/=2; mxl=mxl/2; //remove the ones that are different parity from blue\n\tlong long dp[100005],pref[100005];\n\tmemset(dp,0,sizeof(dp));memset(pref,0,sizeof(pref));\n\t//i segments on a line, first and last are blue, max mxl consecutive reds\n\t//blues may be consecutive because the reds in between were removed\n\tdp[1]=pref[1]=1;dp[2]=1;pref[2]=2;\n\tfor(int i=3;i<=n;i++){\n\t\tdp[i]=pref[i-1]-pref[max(0,i-(mxl+2))];\n\t\tdp[i]%=MOD;dp[i]+=MOD;dp[i]%=MOD;\n\t\tpref[i]=dp[i]+pref[i-1];\n\t\tpref[i]%=MOD;pref[i]+=MOD;pref[i]%=MOD;\n\t}\n\tlong long ans=0;\n\tfor(long long i=2;i<=min(n,mxl+2);i++){\n\t\tans+=2LL*(i-1LL)*dp[n-i+2];\n\t\tans%=MOD;\n\t}\n\tprintf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define Pr(f,...) printf(f,##__VA_ARGS__),fflush(stdout)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define lop(i,s,t) for(int i=s;i<(t);++i)\nusing namespace std; \n\nconst int N=200050,P=1e9+7; \n\nint n,m,limit,f[N],sum[N]; \nchar s[N]; \n\nint main(int argc,char *argv[]){\n\t//freopen(\"d.in.cpp\",\"r\",stdin); \n    scanf(\"%d%d%s\",&n,&m,s); \n    if(s[0]=='B')lop(i,0,m)s[i]=s[i]=='R'?'B':'R';\n\t//Pr(\"%d,%d,%s\\n\",n,m,s);  \n    while(m&&s[m-1]=='R')--m;\n    if(m==0){\n    \tf[0]=2,f[1]=1;\n\t\trep(i,2,n)f[i]=(f[i-1]+f[i-2])%P;\n\t\tprintf(\"%d\\n\",f[n]); \n\t\treturn 0; \t\n    }\n    if(n%2!=0){\n        puts(\"0\"); \n        return 0; \n    }\n    limit=n-1; \n    for(int p=0,prv=0;p<m;++p){\n        while(p<m&&s[p]=='R')++p;\n\t\tif(prv==0){\n            if(p-prv%2==1)limit=p-prv;\n            else limit=p-prv+1;\n        }\n        if(p-prv%2==1)limit=min(limit,p-prv);\n        prv=p;\n    }          \n\tf[1]=sum[1]=0,f[2]=sum[2]=2;\n\tfor(int i=4;i<=n;i+=2){\n\t\tsum[i-1]=(sum[i-2]+f[i-1])%P;\n\t\tif(i<=limit+1)(f[i]+=i)%=P;\n\t\t(f[i]+=(sum[i-1]-sum[max(1,i-limit-2)]+P)%P)%=P;\n\t\tsum[i]=(sum[i-1]+f[i])%P;\n\t}\n\tprintf(\"%d\\n\",f[n]); \n    return 0; \n}    "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 200005\n#define mo 1000000007\n#define ll long long\nint n,m,L;\nchar s[M];\nll ans,f[M],g[M];\nll dp[M][2];\nvoid work() {\n    L=1e9;\n    char ch=s[1];\n    for(int i=2,l=1;i<=m;i++)\n\t{\n\t    if(s[i]==ch) l++;\n\t    else\n\t\t{\n\t\t    if(l&1) L=min(L,l);\n\t\t    else L=min(L,l+1);\n\t\t    l=0;\n\t\t}\n\t}\n    if(L==1e9)\n\t{\n\t    dp[1][0]=1;\n\t    for(int i=2;i<=n;i++)\n\t\t{\n\t\t    dp[i][0]=(dp[i-1][0]+dp[i-1][1])%mo;\n\t\t    dp[i][1]=dp[i-1][0];\n\t\t}\n\t    ans=(dp[n][1]+dp[n][0])%mo;\n\t    memset(dp,0,sizeof(dp));\n\t    dp[1][1]=1;\n\t    for(int i=2;i<=n;i++)\n\t\t{\n\t\t    dp[i][0]=(dp[i-1][0]+dp[i-1][1])%mo;\n\t\t    dp[i][1]=dp[i-1][0];\n\t\t}\n\t    ans=(ans+dp[n][0])%mo;\n\t    cout<<ans<<'\\n';\n\t}\n    else\n\t{\n\t    f[1]=g[1]=1;\n\t    for(int i=2;i<=n;i++)\n\t\t{\n\t\t    if(i<=L&&(i&1)) f[i]=1;\n\t\t    //for(int j=i-2;j>=i-L-1;j-=2) f[i]=(f[i]+f[j])%mo;\n\t\t    f[i]=(f[i]+g[i-2]-(i-L-3>=0?g[i-L-3]:0)+mo)%mo;\n\t\t    g[i]=(g[i-2]+f[i])%mo;\n\t\t}\n\t    for(int i=3;i<=L+2&&i<=n;i+=2) ans=(ans+f[n-i]*(i-1)%mo)%mo;\n\t    if(n-1<=L&&((n-1)&1)) ans=(ans+n)%mo;\n\t    cout<<ans<<'\\n';\n\t}\n}\nint main()\n{\n    cin>>n>>m;\n    scanf(\"%s\",s+1);\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nint fact[1111111];\nint inv[1111111];\n\nint mpow(int n,int m){\n\tint ret=1;\n\twhile(m){\n\t\tif(m&1)ret=ret*n%mod;\n\t\tn=n*n%mod;\n\t\tm>>=1;\n\t}\n\treturn ret;\n}\n\nint binom(int n,int k){\n\treturn fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\ninline void add(int &a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\nint N,M;\nstring S;\n\nint dp[222222];\nint sum[222222];\n\nsigned main(){\n\tfact[0]=1;\n\tfor(int i=1;i<1111111;i++)fact[i]=fact[i-1]*i%mod;\n\tinv[1111111-1]=mpow(fact[1111111],mod-2);\n\tfor(int i=1111111-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n\n\n\tcin>>N>>M;\n\tcin>>S;\n\n\tif(S[0]=='B'){\n\t\trep(i,M){\n\t\t\tif(S[i]=='R')S[i]='B';\n\t\t\telse S[i]='R';\n\t\t}\n\t}\n\n\twhile(S.size()&&S.back()=='R')S.pop_back();\n\n\tif(S.size()==0){\n\t\tint ans=0;\n\t\tint a=1,b=0;\n\t\trep(i,N){\n\t\t\tint aa=(a+b)%mod;\n\t\t\tint bb=a;\n\t\t\ta=aa;b=bb;\n\t\t}\n\t\tadd(ans,a);\n\n\t\ta=0;b=1;\n\t\trep(i,N){\n\t\t\tint aa=(a+b)%mod;\n\t\t\tint bb=a;\n\t\t\ta=aa;b=bb;\n\t\t}\n\t\tadd(ans,b);\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\n\tif(N%2){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\n\tint ma=1001001001;\n\tint cur=0;\n\twhile(cur<S.size()){\n\t\tint nex=cur;\n\t\twhile(nex<S.size()&&S[cur]==S[nex])nex++;\n\t\tif(S[cur]=='R'){\n\t\t\tint l=nex-cur;\n\t\t\tif(cur==0){\n\t\t\t\tif(l%2)chmin(ma,l);\n\t\t\t\telse chmin(ma,l+1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(l%2)chmin(ma,l);\n\t\t\t}\n\t\t}\n\t\tcur=nex;\n\t}\n\n    ma=(ma+1)/2;\n    N/=2;\n\n    dp[0]=sum[0]=1;\n\n    int ans=0;\n    for(int i=1;i<=N;i++){\n        dp[i]=sum[i-1];\n        if(i>ma)dp[i]=(dp[i]-sum[i-ma-1]+mod)%mod;\n        sum[i]=(sum[i-1]+dp[i])%mod;\n    }\n\n    for(int i=1;i<=ma;i++){\n        add(ans,dp[N-i]*i%mod*2%mod);\n    }\n    cout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n//#define int ll\nusing namespace std;\nconst int md=1000000007;\nconst int mxn=200005;\nint n,m,mx,ans,dp[mxn],f[mxn];\nchar s[mxn];\ninline void add(int&x,int y){\n\tx+=y;\n\tif(x>=md)x-=md;\n}\nsigned main(){\n\tint i,j,t;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(i=1;i<=m;++i)if(s[i]!=s[1])break;mx=i-1;\n\tif(mx==m){\n\t\tdp[0]=f[i]=ans=1;\n\t\tfor(int i=0;i<=n;++i){\n\t\t\tif(i>=2)dp[i]=f[i-2];\n\t\t\tf[i]=(f[i-1]+dp[i])%md;\n\t\t\tif(n-i>1)add(ans,(ll)dp[i]*(n-i)%md);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(n&1)return 0*puts(\"0\");\n\tif(!(mx&1))++mx;\n\tfor(t=0;i<=m;++i){\n\t\tif(s[i]==s[1])++t;\n\t\telse{\n\t\t\tif(t&1)mx=min(mx,t);\n\t\t\tt=0;\n\t\t}\n\t}\n\tn>>=1,mx=mx+1>>1;\n\tdp[0]=f[0]=1;\n\tfor(i=0;i<=n;++i){\n\t\tif(i){\n\t\t\tdp[i]=(md+f[i-1]-(i-mx-1>=0?f[i-mx-1]:0))%md;\n\t\t\tf[i]=(f[i-1]+dp[i])%md;\n\t\t}\n\t\tif(n-i<=mx) add(ans,(ll)(n-i)*dp[i]*2ll%md);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-03 17:07:09\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=200010,mod=1000000007;\nint n,m,flag,l,Flag;\ni64 f[N],F[N],ans;\nchar s[N];\nint main()\n{\n\tn=read(); m=read();\n\tscanf(\"%s\",s+1);\n\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\tif(!flag)\n\t{\n\t\tf[0]=1; f[1]=1; f[2]=2;\n\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t\treturn 0;\n\t}\n\tfor(int i=1,j;i<=m;)\n\t\tif(s[i]==s[1])\n\t\t{\n\t\t\tj=i;\n\t\t\twhile(s[j]==s[1]) j++;\n\t\t\tif(j>n) break;\n\t\t\tif(!Flag)\n\t\t\t{\n\t\t\t\tl=j-i+((j-i)%2==0);\n\t\t\t}\n\t\t\telse if((j-i)&1) l=std::min(l,(j-i));\n\t\t\ti=j+1; Flag=1;\n\t\t}\n\t\telse i++;\n\tif(n&1){ printf(\"0\\n\"); return 0; }\n\tn/=2; l=(l+1)/2;\n//\tprintf(\"%d %d\\n\",int(n),int(l));\n\tf[0]=F[0]=1;\n\tfr(i,1,n)\n\t{\n\t\tf[i]=(F[i-1]+mod-(i-l-1>=0?F[i-l-1]:0))%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t}\n\tans=f[n];\n\tfr(i,1,l) ans=(ans+f[n-i]*(2*i-1))%mod;\n\tprintf(\"%d\\n\",int(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nconst int mo=1000000007;\nconst int N=200005;\nint n,m;\nchar s[N];\nint f[N][2][2];\nvoid solve1(){\n\tf[1][0][0]=f[1][1][1]=1;\n\tFor(i,2,n) For(j,0,1) For(k,0,1) For(l,0,1)\n\t\tif (k|l) f[i][j][l]=(f[i][j][l]+f[i-1][j][k])%mo;\n\tint ans=0;\n\tFor(i,0,1) For(j,0,1)\n\t\tif (i|j) ans=(ans+f[n][i][j])%mo;\n\tprintf(\"%d\\n\",ans);\n}\nint pre[N];\nint g[N],h[N];\n\nvoid solve2(){\n\tpre[1]=1;\n\tint mnv=(1<<30);\n\tFor(i,2,m)\n\t\tpre[i]=(s[i]==s[i-1]?pre[i-1]:0)+1;\n\tFor(i,2,m) if (s[i-1]=='R'&&s[i]!='R')\n\t\tif (pre[i-1]==i-1){\n\t\t\tif (pre[i-1]%2==0) mnv=min(mnv,pre[i-1]+1);\n\t\t\telse mnv=min(mnv,pre[i-1]);\n\t\t}\n\t\telse if (pre[i-1]%2==1)\n\t\t\tmnv=min(mnv,pre[i-1]);\n\tg[0]=h[0]=1;\n\tFor(i,1,n){\n\t\tg[i]=((i>=2?h[i-2]:0)+mo-(i>=mnv+3?h[i-mnv-3]:0))%mo;\n\t\th[i]=(g[i]+(i>=2?h[i-2]:0))%mo;\n\t}\n\tint ans=0;\n\tfor (int i=2;i<=min(mnv+1,n);i+=2)\n\t\tans=(ans+1ll*i*g[n-i])%mo;\n\tprintf(\"%d\\n\",ans);\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tif (s[1]=='B'){\n\t\tFor(i,1,m)\n\t\t\tif (s[i]=='R') s[i]='B';\n\t\t\telse s[i]='R';\n\t}\n\tbool flag=0;\n\tFor(i,1,m) if (s[i]!=s[1]) flag=1;\n\tif (!flag) return solve1(),0;\n\tsolve2();\n}\n/*\n偶数个R||B回到该端点 \n奇数个R||B到达另一端点\n\nRBRBRBRBRB\n\n一段长度为奇数的开头字母 \n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate <int MOD_> struct modnum {\n\tstatic constexpr int MOD = MOD_;\n\tstatic_assert(MOD_ > 0, \"MOD must be positive\");\n\nprivate:\n\tusing ll = long long;\n\n\tint v;\n\n\tstatic int minv(int a, int m) {\n\t\ta %= m;\n\t\tassert(a);\n\t\treturn a == 1 ? 1 : int(m - ll(minv(m, a)) * ll(m) / a);\n\t}\n\npublic:\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int() const { return v; }\n\tfriend std::ostream& operator << (std::ostream& out, const modnum& n) { return out << int(n); }\n\tfriend std::istream& operator >> (std::istream& in, modnum& n) { ll v_; in >> v_; n = modnum(v_); return in; }\n\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum inv() const {\n\t\tmodnum res;\n\t\tres.v = minv(v, MOD);\n\t\treturn res;\n\t}\n\tmodnum neg() const {\n\t\tmodnum res;\n\t\tres.v = v ? MOD-v : 0;\n\t\treturn res;\n\t}\n\tmodnum operator- () const {\n\t\treturn neg();\n\t}\n\tmodnum operator+ () const {\n\t\treturn modnum(*this);\n\t}\n\n\tmodnum& operator ++ () {\n\t\tv ++;\n\t\tif (v == MOD) v = 0;\n\t\treturn *this;\n\t}\n\tmodnum& operator -- () {\n\t\tif (v == 0) v = MOD;\n\t\tv --;\n\t\treturn *this;\n\t}\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= o.inv();\n\t}\n\n\tfriend modnum operator ++ (modnum& a, int) { modnum r = a; ++a; return r; }\n\tfriend modnum operator -- (modnum& a, int) { modnum r = a; --a; return r; }\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\nusing num = modnum<int(1e9)+7>;\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint N, M; cin >> N >> M;\n\tstring S; cin >> S;\n\tif (S[0] == 'B') {\n\t\tfor (char& c : S) {\n\t\t\tc ^= 'R' ^ 'B';\n\t\t}\n\t}\n\tassert(S[0] == 'R');\n\tbool hasBlue = false;\n\tfor (char c : S) {\n\t\tif (c == 'B') {\n\t\t\thasBlue = true;\n\t\t}\n\t}\n\tassert(N >= 2);\n\tif (!hasBlue) {\n\t\t// 1 is red, 0 is blue\n\t\tnum dp[2][2] = {{1, 0}, {0, 1}};\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tnum ndp[2][2] = {{0,0}, {0,0}};\n\t\t\tfor (int a = 0; a < 2; a++) {\n\t\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\t\tfor (int c = 0; c < 2; c++) {\n\t\t\t\t\t\tif (b || c) {\n\t\t\t\t\t\t\tndp[a][c] += dp[a][b];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemcpy(dp, ndp, sizeof(ndp));\n\t\t}\n\t\tnum ans = 0;\n\t\tfor (int a = 0; a < 2; a++) {\n\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\tif (a || b) {\n\t\t\t\t\tans += dp[a][b];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << '\\n';\n\t\texit(0);\n\t}\n\n\tassert(hasBlue);\n\thasBlue = false;\n\tint maxRed = N-1;\n\tint cntRed = 0;\n\tfor (char c : S) {\n\t\tif (c == 'B') {\n\t\t\tif (hasBlue) {\n\t\t\t\tif (cntRed % 2 == 1) {\n\t\t\t\t\tmaxRed = min(maxRed, cntRed);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmaxRed = min(maxRed, cntRed + 1);\n\t\t\t}\n\t\t\thasBlue = true;\n\t\t\tcntRed = 0;\n\t\t} else if (c == 'R') {\n\t\t\tcntRed++;\n\t\t} else assert(false);\n\t}\n\n\tassert(maxRed >= 1);\n\n\tif (maxRed % 2 == 0) maxRed --;\n\n\tassert(maxRed % 2 == 1);\n\n\t//cerr << maxRed << '\\n';\n\n\tif (N % 2 == 1) {\n\t\tcout << 0 << '\\n';\n\t\texit(0);\n\t}\n\n\tassert(N % 2 == 0);\n\tN /= 2;\n\tmaxRed ++;\n\tmaxRed /= 2;\n\tassert(maxRed <= N);\n\n\tvector<num> dp;\n\tdp.push_back(1);\n\n\tnum sum = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tsum += dp[i];\n\t\tif (i >= maxRed) sum -= dp[i - maxRed];\n\t\tdp.push_back(sum);\n\t}\n\n\tnum ans = 0;\n\tfor (int i = 1; i <= maxRed; i++) {\n\t\tans += num(2 * i) * dp[N - i];\n\t}\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long prime = 1000000007;\n\nbool all_chars_equal(string s) {\n    for (char c : s) {\n        if (c != s[0]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> get_runs(string s) {\n    vector<int> runs;\n    int current_run = 0;\n    for (char c : s) {\n        if (c == s[0]) {\n            ++current_run;\n        } else if (current_run > 0) {\n            runs.push_back(current_run);\n            current_run = 0;\n        }\n    }\n    if (current_run > 0) {\n        runs.push_back(current_run);\n    }\n    return runs;\n}\n    \nlong long f(int n, int k) {\n    vector<long long> pow_2(2 * k + 4);\n    pow_2[0] = 1LL;\n    for (int i = 1; i < 2 * k + 4; ++i) {\n        pow_2[i] = pow_2[i - 1] * 2 % prime;\n    }\n\n    vector<long long> f1(max(n + 1, 2 * k + 4), 0);\n    for (int i = 1; i <= k; ++i) {\n        f1[i] = pow_2[i];\n    }\n    f1[k + 1] = (pow_2[k+1] - 1 + prime) % prime;\n    for (int n1 = k + 2; n1 <= 2 * k + 3; ++n1) {\n        f1[n1] = ((pow_2[n1] - 1 - n1 * pow_2[n1 - k - 2]) % prime + prime) % prime;\n    }\n    for (int n1 = 2 * k + 4; n1 <= n; ++n1) {\n        f1[n1] = ((2 * f1[n1 - 1] - f1[n1 - k - 2]) % prime + prime) % prime;\n    }\n    return f1[n];\n}\n\n/*\nf(n, k) = antal cirkler af længde n med højst k røde i streg (ingen andre begrænsninger)\n\nf(n, k) = 2^n for n <= k\nf(n, k) = 2^n - 1 for n = k+1\nf(n, k) = 2^n - 1 - n * 2^{n-k-2} for k+2 <= n <= 2k+3\nf(n, k) = 2f(n-1, k) - f(n-k-2, k) for n >= 2k + 4\n\n*/\n\nlong long different_case(int n, int k) {\n    return f(n / 2, (k - 1) / 2) * 2LL % prime;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    string s;\n    cin >> n >> m;\n    cin >> s;\n    auto t0 = clock();\n    if (all_chars_equal(s)) {\n        cout << f(n, 1) << endl;  // OK since n >= 2\n        cerr << \"Time used: \" << clock() - t0 << \" ms\" << endl;\n        return 0;\n    }\n    if (n % 2 != 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n    vector<int> runs = get_runs(s);\n    int bound = runs[0] / 2 * 2 + 1;\n    bound = min(bound, n - 1);\n    for (int run : runs) {\n        if (run % 2 == 1) {\n            bound = min(bound, run);\n        }\n    }\n    cout << different_case(n, bound) << endl;\n\n    cerr << \"Time used: \" << clock() - t0 << \" ms\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nint (*rd)()=read<int>;\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\nconst u32 P=1e9+7;\nu32 &inc(u32 &a, u32 b) {return (a+=b)<P?a:(a-=P);}\nu32 &dec(u32 &a, u32 b) {return (a-=b)&0x80000000?(a+=P):a;}\nu32 sum(u32 a, u32 b) {return inc(a, b);}\nu32 dif(u32 a, u32 b) {return dec(a, b);}\n\nconst int N=2e5+5;\nint n, m;\nu32 f[N];\nchar s[N];\nint main() {\n\tassert(scanf(\"%d%d%s\", &n, &m, s)==3);\n\tif(s[0]=='B') for(int i=0; i<m; ++i) s[i]^='B'^'R';\n\tif(std::count(s, s+m, 'B')==0) {\n\t\tf[0]=f[1]=1;\n\t\tfor(int i=2; i<=n; ++i) f[i]=sum(f[i-1], f[i-2]);\n\t\tprintf(\"%u\\n\", sum(f[n], f[n-2]));\n\t\treturn 0;\n\t}\n\tif(n%2==1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint ml=n;\n\tfor(int l=0, r; l<m; l=r+1) {\n\t\tfor(r=l; r<m&&s[r]=='R'; ++r);\n\t\tif(r==m) break;\n\t\tif(l==0) cmin(ml, r+1); else if((r-l)%2==1) cmin(ml, r-l);\n\t}\n\tml=(ml+1)/2;\n\tn/=2;\n\tu32 s=0;\n\tfor(int i=1; i<=n; ++i) {\n\t\tf[i]=s;\n\t\tif(i<=ml) inc(f[i], 2*i);\n\t\tinc(s, f[i]);\n\t\tif(i>=ml) dec(s, f[i-ml]);\n\t}\n\tprintf(\"%u\\n\", f[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\nll dp[200010] = {},fib[200010],mod = 1000000007;\nstring s;\nvector<pair<char,int>> v;\nint main(){\n\tll i,j,n,m;\n\tcin >> n >> m >> s;\n\tif(s[0]=='B'){\n\t\tfor(i=0;i<m;i++){\n\t\t\tif(s[i]=='R') s[i] = 'B';\n\t\t\telse s[i] = 'R';\n\t\t}\n\t}\n\tfor(i=0;i<m;i++){\n\t\tif(i==0 || v.back().first!=s[i]){\n\t\t\tv.push_back({s[i],1});\n\t\t}else{\n\t\t\tv.back().second++;\n\t\t}\n\t}\n\tif(v.size()==1){\n\t\tfib[0] = 1,fib[1] = 1;\n\t\tfor(i=2;i<=n;i++){\n\t\t\tfib[i] = (fib[i - 1] + fib[i - 2])%mod;\n\t\t}\n\t\tcout << (fib[n] + fib[n - 2])%mod << endl;\n\t\treturn 0;\n\t}\n\tif(n&1){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tif(v.back().first=='R'){\n\t\tv.pop_back();\n\t}\n\tint mn = -1;\n\tfor(i=0;i<v.size();i++){\n\t\tif(i==0){\n\t\t\tmn = v[i].second + 1 - (v[i].second&1);\n\t\t}\n\t\tif(v[i].first=='R' && (v[i].second&1)){\n\t\t\tmn = min(mn,v[i].second);\n\t\t}\n\t}\n\tmn++;\n\tdp[0] = 1;\n\tll sum = 1;\n\tfor(i=2;i<=n;i+=2){\n\t\t(dp[i] += sum) %= mod;\n\t\t(sum += dp[i]) %= mod;\n\t\tif(i>=mn) sum -= dp[i - mn];\n\t\tif(sum<0) sum += mod;\n\t}\n\tll ans = 0;\n\tfor(i=2;i<=mn;i+=2){\n\t\t(ans += i*dp[n - i]) %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll dp[202020][2][2];\nll mo=1000000007;\n\nll dp2[202020];\nll dps[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\tif(S[0]=='B') {\n\t\tFORR(c,S) c='R'+'B'-c;\n\t}\n\tif(count(ALL(S),'B')==0) {\n\t\tdp[0][0][0]=dp[0][1][1]=1;\n\t\tfor(i=1;i<N;i++) {\n\t\t\t(dp[i][0][0]=dp[i-1][0][0]+dp[i-1][0][1])%=mo;\n\t\t\t(dp[i][0][1]=dp[i-1][0][0])%=mo;\n\t\t\t(dp[i][1][0]=dp[i-1][1][0]+dp[i-1][1][1])%=mo;\n\t\t\t(dp[i][1][1]=dp[i-1][1][0])%=mo;\n\t\t}\n\t\tassert(0);\n\t\tcout<<(dp[N-1][0][0]+dp[N-1][0][1]+dp[N-1][1][0])%mo<<endl;\n\t\treturn;\n\t}\n\tint L=0;\n\twhile(S[L]=='R') L++;\n\t\n\tif(L%2==0) L++;\n\t\n\tdp2[0]=dps[0]=dps[1]=1;\n\tfor(i=2;i<=N;i++) {\n\t\tif(i%2==0) {\n\t\t\tdp2[i]=dps[i-2];\n\t\t\tif(i-(L+1)>0) dp2[i]+=mo-dps[i-(L+1)-1];\n\t\t\tdp2[i]%=mo;\n\t\t}\n\t\t(dps[i]=dps[i-1]+dp2[i])%=mo;\n\t\t//cout<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=min(L,N-1);i++) {\n\t\t//cout<<i<<\" \"<<(i+1)<<\"*\"<<dp2[N-(i+1)]<<endl;\n\t\t(ret+=(i+1)*dp2[N-(i+1)])%=mo;\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include <algorithm>\n// #include <iostream>\n// #include <string>\n\n// using namespace std;\n\n// #define MAX_N 200000\n// #define MAX_M 200000\n// #define MOD 1000000007\n\n// #define INF 1 << 29\n\n// int N, M;\n// string S;\n\n// long long dp[MAX_N + 2], rdp[MAX_N + 2];\n\n// int all_color_is_same()\n// {\n//     long long rr = 1, bb = 1, rb = 0, br = 0;\n\n//     for ( int i = 1; i < N; i++ )\n//     {\n//         long long nrr = ( rr + rb ) % MOD;\n//         long long nbb = br;\n//         long long nrb = rr;\n//         long long nbr = ( bb + br ) % MOD;\n\n//         rr = nrr;\n//         bb = nbb;\n//         rb = nrb;\n//         br = nbr;\n//     }\n\n//     return ( rr + rb + br ) % MOD;\n// }\n\n// /**\n//  * S\n//  の先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n//  */\n// int min_freq()\n// {\n//     int l = 0;\n//     while ( l < M && S[0] == S[l] ) l++;\n\n//     int ans = ( l & 1 ) ? l : l + 1;\n\n//     l = 0;\n//     for ( int i = 0; i < M; i++ )\n//     {\n//         if ( S[0] == S[i] )\n//             l++;\n//         else if ( l & 1 )\n//         {\n//             ans = min( ans, l );\n//             l = 0;\n//         }\n//     }\n//     return l ? min( ans, l ) : ans;\n// }\n\n// int solve()\n// {\n//     // 一色\n//     if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n//         return all_color_is_same();\n\n//     // N が奇数\n//     if ( N & 1 ) return 0;\n\n//     int L = min_freq();\n\n//     L = ( L + 1 ) >> 1;\n//     N >>= 1;\n\n//     dp[0] = rdp[0] = 1;\n//     for ( int i = 1; i <= N + 1; i++ )\n//     {\n//         dp[i] = rdp[i - 1];\n//         if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n//         if ( dp[i] < 0 ) dp[i] += MOD;\n//         rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n//     }\n\n//     long long res = 0;\n//     for ( int i = 1; i <= L; i++ )\n//         if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n//     return res % MOD;\n// }\n\n// int main( int argc, char **argv )\n// {\n//     cin >> N >> M;\n//     cin >> S;\n\n//     int ans = solve();\n\n//     cout << ans << endl;\n\n//     return 0;\n// }\n#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define INF ( 1 << 29 )\n#define LINF ( 1LL << 60 )\n#define EPS ( 1e-10 )\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt all( Int n )\n{ // no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for ( int i = 1; i < n; i++ )\n    {\n        Int nrr = ( rr + rb ) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = ( bb + br ) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return ( rr + rb + br ) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc( Int n, Int limit )\n{\n    dp[0] = 1;\n    rdp[0] = 1;\n    for ( int i = 1; i <= n + 1; i++ )\n    {\n        dp[i] = ( rdp[i - 1] -\n                  ( ( i - limit - 1 ) >= 0 ? rdp[i - limit - 1] : 0 ) ) %\n                MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n}\n\nInt solve( Int n, Int limit )\n{\n    if ( n % 2 == 1 ) return 0;\n    if ( limit % 2 != 1 ) exit( 1 );\n    limit = ( limit + 1 ) / 2;\n    n /= 2;\n    Int res = 0;\n    calc( n + 10, limit );\n    for ( Int i = 1; i <= limit; i++ )\n    {\n        if ( n - i >= 0 ) res = ( res + dp[n - i] * 2 * i ) % MOD;\n    }\n    if ( res < 0 ) exit( 1 );\n    return res % MOD;\n}\n\nint main()\n{\n    Int n, m;\n    string S;\n    cin >> n >> m;\n    cin >> S;\n\n    // bool allsame = true;\n    // for ( int i = 0; i < m; i++ ) allsame &= ( str[i] == str[0] );\n    // if ( allsame )\n    // {\n    //     cout << all( n ) << endl;\n    //     return 0;\n    // }\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n        return all( n );\n\n    Int l = 0;\n    while ( S[0] == S[l] ) l++;\n    if ( l % 2 == 0 ) l++;\n    Int limit = l;\n    l = 0;\n    for ( int i = 0; i < m; i++ )\n    {\n        if ( S[i] == S[0] )\n            l++;\n        else\n        {\n            if ( l % 2 == 1 ) limit = min( limit, l );\n            l = 0;\n        }\n    }\n    cout << solve( n, limit ) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+100;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    lim = min(lim,(ll)n-1);\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    ans = (dp[n+1]*2)%MOD;\n    for(ll i = 3;i<=lim;i+=2)\n    {\n        ans += ((i-1)*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    int mn = 1e9;\n    if (vc[0]%2==0)\n        mn = vc[0]+1;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\n\n/// --- Modulo Integer {{{ ///\n#include <ostream>\ntemplate < long long mod = static_cast< long long >(1e9 + 7) >\nstruct ModuloInteger {\n  static_assert(mod > 0, \"mod must be positive\");\n  static_assert(mod <= 3037000499, \"mod is too big\");\n  using integer = long long;\n  static ModuloInteger unused;\n  // math {{{\n  static inline integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  static inline integer modpow(integer a, long long b) {\n    if(b < 0) b = -b, a = modinv(a);\n    integer r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  integer val;\n  constexpr ModuloInteger() : val(0) {}\n  constexpr ModuloInteger(integer t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\nprivate:\n  // strict constructor\n  constexpr ModuloInteger(integer t, int) : val(t) {}\n\npublic:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // operator bool() { return bool(val); }\n  // ModuloInteger <arithmetic-operator>[=] ModuloInteger {{{\n  ModuloInteger operator+(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModuloInteger operator-(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModuloInteger operator*(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModuloInteger operator/(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModuloInteger &operator+=(ModuloInteger const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModuloInteger &operator-=(ModuloInteger const &rhs) { return *this += -rhs; }\n  ModuloInteger &operator*=(ModuloInteger const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModuloInteger &operator/=(ModuloInteger const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModuloInteger operator++(int) {\n    ModuloInteger tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModuloInteger operator--(int) {\n    ModuloInteger tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModuloInteger &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModuloInteger &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModuloInteger operator-() const { return ModuloInteger(val == 0 ? 0 : mod - val, 0); }\n  // ModuloInteger <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModuloInteger operator+(T const &rhs) const {\n      return ModuloInteger(val + rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator-(T const &rhs) const {\n      return ModuloInteger(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator*(T const &rhs) const {\n      return ModuloInteger(val * (rhs % mod));\n    }\n  template < typename T >\n    ModuloInteger operator/(T const &rhs) const {\n      return ModuloInteger(val * modinv(rhs));\n    }\n  template < typename T >\n    ModuloInteger &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator/=(T const &rhs) {\n      val = val * modinv(rhs) % mod;\n      return *this;\n    }\n  // }}}\n  ModuloInteger inv() const { return ModuloInteger(modinv(val), 0); }\n  ModuloInteger operator~() const { return inv(); }\n  friend std::ostream &operator<<(std::ostream &os, ModuloInteger const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // equality operator {{{\n  ModuloInteger operator==(const ModuloInteger &a) const { return val == a.val; }\n  ModuloInteger operator!=(const ModuloInteger &a) const { return val != a.val; }\n  ModuloInteger operator==(const integer &a) const { return val == ModuloInteger(a); }\n  ModuloInteger operator!=(const integer &a) const { return val != ModuloInteger(a); }\n  // }}}\n  // T <arithmetic-operator> ModuloInteger {{{\n  friend constexpr ModuloInteger operator+(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod + mv.val);\n  }\n  friend constexpr ModuloInteger operator-(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod - mv.val);\n  }\n  friend constexpr ModuloInteger operator*(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModuloInteger operator/(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModuloInteger operator^(integer x) const { return pow(*this, x); }\n  ModuloInteger &operator^=(integer x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModuloInteger pow(ModuloInteger x, integer y) {\n    return ModuloInteger(modpow(x.val, y), 0);\n  }\n  // }}}\n};\ntemplate < long long mod >\nModuloInteger< mod > ModuloInteger< mod >::unused(mod, 0);\n/// }}}--- ///\n\nusing modint = ModuloInteger<>;\n\n\n// LazySegmentTree( size [, initial] )\n// LazySegmentTree( <data> )\n/// --- LazySegmentTree {{{ ///\n#include <cassert>\n#include <initializer_list>\n#include <iostream>\n#include <vector>\ntemplate < class M_act >\nstruct LazySegmentTree {\npublic:\n  using Monoid = typename M_act::Monoid;\n  using X = typename Monoid::T;\n  using M = typename M_act::M;\n\nprivate:\n  size_t n;\n  int h;\n  vector< X > data;\n  vector< M > lazy;\n  vector< size_t > nodeLength;\n  // call before use data[i]\n  void eval(size_t i) {\n    if(lazy[i] == M_act::identity()) return;\n    data[i] = M_act::actInto(lazy[i], nodeLength[i], data[i]);\n    if(i < n) {\n      lazy[i * 2] = M_act::op(lazy[i], lazy[i * 2]);\n      lazy[i * 2 + 1] = M_act::op(lazy[i], lazy[i * 2 + 1]);\n    }\n    lazy[i] = M_act::identity();\n  }\n  // call before use seg[i] = data[i + n]\n  void evalDown(size_t i) {\n    i += n;\n    for(int j = h - 1; j >= 0; j--) eval(i >> j);\n  }\n  // call after touch seg[i] = data[i + n]\n  void propUp(size_t i) {\n    i += n;\n    while(i >>= 1)\n      eval(i * 2), eval(i * 2 + 1), data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n  }\n\npublic:\n  LazySegmentTree() : n(0) {}\n  LazySegmentTree(size_t n, X initial = Monoid::identity()) : n(n) {\n    if(n > 0) {\n      h = 1;\n      while(1u << h < n) h++;\n      data.resize(2 * n, initial);\n      lazy.resize(2 * n, M_act::identity());\n      nodeLength.resize(2 * n, 1);\n      for(size_t i = n - 1; i > 0; i--) // fill from deep\n        data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]),\n          nodeLength[i] = nodeLength[i * 2] + nodeLength[i * 2 + 1];\n    }\n  }\n  template < class InputIter, class = typename iterator_traits< InputIter >::value_type >\n    LazySegmentTree(InputIter first, InputIter last)\n    : LazySegmentTree(distance(first, last)) {\n      if(n > 0) {\n        copy(first, last, begin(data) + n);\n        for(size_t i = n - 1; i > 0; i--) // fill from deep\n          data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n      }\n    }\n  LazySegmentTree(vector< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  LazySegmentTree(initializer_list< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  void act(int l, int r, const M &m) {\n    if(l < 0) l = 0;\n    if(l >= r) return;\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    int tl = l, tr = r;\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), lazy[l] = m, eval(l), l++;\n      if(r & 1) --r, eval(r), lazy[r] = m, eval(r);\n    }\n    propUp(tl);\n    propUp(tr - 1);\n  }\n  void set(size_t i, const X &x) {\n    assert(i < n);\n    evalDown(i);\n    data[i + n] = x;\n    propUp(i);\n  }\n  X get(size_t i) {\n    assert(i < n);\n    evalDown(i);\n    return data[i + n];\n  }\n  X fold(int l, int r) {\n    if(l < 0) l = 0;\n    if(l >= r) return Monoid::identity();\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    X tmpL = Monoid::identity(), tmpR = Monoid::identity();\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), tmpL = Monoid::op(tmpL, data[l]), l++;\n      if(r & 1) --r, eval(r), tmpR = Monoid::op(data[r], tmpR);\n    }\n    return Monoid::op(tmpL, tmpR);\n  }\n  int size() { return n; }\n  inline void dum(int r = -1) {\n#ifdef DEBUG\n    if(r < 0) r = n;\n    DEBUG_OUT << \"{\";\n    for(int i = 0; i < min(r, (int) n); i++) DEBUG_OUT << (i ? \", \" : \"\") << get(i);\n    DEBUG_OUT << \"}\" << endl;\n#endif\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid examples {{{ ///\nconstexpr long long inf_monoid = 1e18 + 100;\n#include <algorithm>\nstruct Nothing {\n  using T = char;\n  using Monoid = Nothing;\n  using M = T;\n  static constexpr T op(const T &, const T &) { return T(); }\n  static constexpr T identity() { return T(); }\n  template < class X >\n    static constexpr X actInto(const M &, long long, const X &x) {\n      return x;\n    }\n};\n\ntemplate < class U = long long >\nstruct RangeMin {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::min< T >(a, b); }\n  static constexpr T identity() { return T(inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeMax {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::max< T >(a, b); }\n  static constexpr T identity() { return T(-inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeSum {\n  using T = U;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return T(0); }\n};\n\ntemplate < class U >\nstruct RangeProd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a * b; }\n  static constexpr T identity() { return T(1); }\n};\n\ntemplate < class U = long long >\nstruct RangeOr {\n  using T = U;\n  static T op(const T &a, const T &b) { return a | b; }\n  static constexpr T identity() { return T(0); }\n};\n\n#include <bitset>\n\ntemplate < class U = long long >\nstruct RangeAnd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return T(-1); }\n};\n\ntemplate < size_t N >\nstruct RangeAnd< std::bitset< N > > {\n  using T = std::bitset< N >;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return std::bitset< N >().set(); }\n};\n\n/// }}}--- ///\n\n/// --- M_act examples {{{ ///\ntemplate < class U = long long, class V = U >\nstruct RangeMinAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMin< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMax< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMinSet {\n  using M = U;\n  using Monoid = RangeMin< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxSet {\n  using M = U;\n  using Monoid = RangeMax< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long n, const X &x) { return m * n + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long n, const X &x) {\n    return m == identity() ? x : m * n;\n  }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdMul {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M mpow(M a, long long b) {\n    X r(1);\n    while(b) {\n      if(b & 1) r = r * a;\n      a = a * a;\n      b >>= 1;\n    }\n    return r;\n  }\n  static M op(const M &a, const M &b) { return a * b; }\n  static constexpr M identity() { return M(1); }\n  static X actInto(const M &m, long long n, const X &x) { return x * mpow(m, n); }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return V::unused; }\n  static X actInto(const M &m, long long n, const X &) {\n    if(m == identity()) return;\n    return RangeProdMul< U, V >::mpow(m, n);\n  }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeOr2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeOr< U >;\n  static M op(const M &a, const M &b) { return a | b; }\n  static constexpr M identity() { return M(0); }\n  static X actInto(const M &m, long long, const X &x) { return m | x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeAnd2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return M(-1); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n\ntemplate < class U, size_t N >\nstruct RangeAnd2< U, std::bitset< N > > {\n  using X = U;\n  using M = std::bitset< N >;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return std::bitset< N >().set(); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n/// }}}--- ///\n\nusing Seg = LazySegmentTree< RangeSumAdd<modint> >;\n\n\n// NOTE : use H with larger N\n/// --- Modulo Factorial {{{ ///\n#include <cassert>\n#include <cstddef>\ntemplate < std::size_t N, int mod = static_cast< int >(1e9 + 7) >\nstruct Factorial {\n  using integer = long long;\n  constexpr integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d = 0;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  constexpr integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  int arr[N + 1], inv[N + 1];\n  integer operator[](int i) const { return arr[i]; }\n  Factorial() : arr(), inv() {\n    arr[0] = 1;\n    for(std::size_t i = 1; i <= N; i++) {\n      arr[i] = (integer) i * arr[i - 1] % mod;\n    }\n    inv[N] = modinv(arr[N]);\n    for(int i = N - 1; i >= 0; i--) {\n      inv[i] = (integer)(i + 1) * inv[i + 1] % mod;\n    }\n  }\n  integer C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    assert(n <= N);\n    return (integer) arr[n] * inv[r] % mod * inv[n - r] % mod;\n  }\n  integer H(int n, int r) const { return C(n + r - 1, r); }\n};\n/// }}}--- ///\n\nconstexpr int mod = 1e9 + 7;\nconst int N = 2e5 + 10;\nFactorial< N * 2, mod > fact;\n\n\n\nint n, m;\nint r, b;\nint rmax;\nstring s;\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n >> m;\n  cin >> s;\n  if(s[0] == 'B') for(auto &e : s) e = e == 'R' ? 'B' : 'R';\n  bool allR = 1;\n  for(auto e : s) allR &= e == 'R';\n\n  if(allR) {\n    dump(\"allR\");\n    modint ans;\n    assert(0);\n    for(int B = 0; B <= n; B++) {\n      int R = n - B - B;\n      ans += modint(fact.C(R + B, R));\n      ans += modint(fact.C(R + B - 1, R));\n    }\n    cout << ans << endl;\n    return 0;\n  }\n\n  if(n % 2 == 1) {\n    cout << 0 << endl;\n    dump(\"odd\");\n    return 0;\n  }\n\n  int c = 0;\n  rmax = m;\n  bool first = 1;\n  for(int i = 0; i <= m; i++) {\n    if(i == n || s[i] == 'B') {\n      if(c) {\n        if(c % 2 == 0 && first) rmax = min(rmax, c + 1);\n        if(c % 2 == 1) rmax = min(rmax, c);\n      }\n      c = 0;\n      first = 0;\n    } else c++;\n  }\n\n  dump(rmax);\n\n  // RB\n\n  // vector<modint> dp(n + 1);\n  Seg dp(n + 1);\n  dp.set(0, 1);\n\n  modint ans;\n\n  for(int i = 0; i <= n - 1; i+=2) {\n    dp.act(i + 2, min<int>(n - 1, i + 1 + rmax) + 1, dp.get(i));\n    if(i + 1 + rmax >= n) {\n      int f = n - i - 1;\n      if (f >= 1) {\n        dump(i, dp.get(i), f);\n        ans += dp.get(i) * (f + 1);\n      }\n    }\n  }\n  cout << ans << endl;\n  dp.dum();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nint gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);}\n\n#define ll long long\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=2e5+500;\nconst ll mod=1e9+7;\nconst ll inf=1e9+9;\n\nll dp[maxn];\nll par[maxn];\nvoid update(ll a){\n\tif(a<2)par[a]=dp[a];\n\tpar[a]=(par[a-2]+dp[a])%mod;\t\n}\nll find_sum(ll l,ll r){\n\tif(!(l<=r))return 0;\n\tl=max(l,0LL);\n\tif(l%2!=r%2){\n\t\treturn find_sum(l+1,r);\n\t}\n\tif(l<2)return par[r];\n\treturn (par[r]-par[l-2]+mod)%mod;\n}\n\n\nll find_ans(ll n,ll s){\n\tif(s%2==0){\n\t\texit(1);\n\t}\n\tmemset(dp,0,sizeof dp);\n\tmemset(par,0,sizeof par);\n\n\tdp[0]=1;\n\tdp[1]=0;\n\tupdate(1);\n\tupdate(0);\n\tfor(ll i=2;i<=n;i++){\n\t\tdp[i]=find_sum(i-s-1,i-2);\n\t\tupdate(i);\n\t}\n\tll ans=0;\n\tfor(ll i=2;i<=n && i-1<=s;i++){\n\t\tll lp=0;\n\t\tif((i-1)%2==0)lp=1;\n\t\tll rp=s-i+1;\n\t\t\n\t\tll lw=n-i-rp;\n\t\tll rw=n-i-lp;\n\t\tif(lw%2!=rw%2 || rp%2!=lp%2){\n\t\t\texit(1);\n\t\t}\n\t\tans+=find_sum(lw,rw);\n\t}\n\tans+=dp[n];\n\treturn ans%mod;\n}\nstring ok(string s,ll m){\n\tif(s[0]=='B'){\n\t\tfor(ll i=0;i<m;i++){\n\t\t\tif(s[i]=='B'){\n\t\t\t\ts[i]='R';\n\t\t\t}else{\n\t\t\t\ts[i]='B';\n\t\t\t}\n\t\t}\n\t}\n\treturn s;\n}\nint main(){\n\tll n,m;\n\tstring s;\n\tcin>>n>>m>>s;\n\ts=ok(s,m);\n\tvector<ll> vec;\n\tll res=0;\n\tfor(ll i=0;i<m;i++){\n\t\tif(s[i]=='R'){\n\t\t\tres++;\n\t\t}\n\t\tif(res!=0 && (i==m-1 || s[i]=='B')){\n\t\t\tvec.pb(res);\n\t\t\tres=0;\n\t\t}\n\t}\n\tll si=inf;\n\tif(vec[0]==m){\n\t\tdp[2]=1;\n\t\tdp[1]=1;\n\t\tfor(ll i=3;i<=n;i++){\n\t\t\tdp[i]=(dp[i-2]+dp[i-1])%mod;\n\t\t}\n\t\tll ans=1;\n\t\tfor(ll i=2;i<=n;i++){\n\t\t\tans+=dp[n-i+1];\n\t\t}\n\t\tans+=dp[n-1];\n\t\tcout<<ans%mod;\n\t\treturn 0;\n\t}\n\tfor(auto v:vec){\n\t\tif(v%2==1)si=min(si,v);\n\t}\n\tsi=min(si,vec[0]+1);\n\tcout<<find_ans(n,si)<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  if(vs==vector<Int>(m,1)){\n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n  assert(vs!=vector<Int>(m,0));\n\n  if(n&1){\n    cout<<0<<endl;\n    return 0;\n  }\n  \n  Int lim=n-1;  \n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    Int j=i;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n\n    if(i==0&&(j-i)%2==0) assert(0);    \n    if(i==0&&(j-i)%2==0) chmin(lim,j-i+1);\n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }\n  \n  vector<M> dp(n+2,0),sm(n+2,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n+1;i++){\n    sm[i]=sm[i-1]+dp[i-1];\n    if(i&1) dp[i]=sm[i-1]-sm[max<Int>(1,i-1-lim)];\n  }\n  \n  M ans{0};\n  for(Int i=0;i<=lim;i++)\n    ans+=sm[n-i+1]-sm[max<Int>(1,n-lim)];\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nchar str[200005];\nint arr[200005];\nlong long MOD=1000000007;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",str);\n\tfor(int i=0;i<m;i++)if(str[i]=='R')arr[i]=0;else arr[i]=1;\n\tbool all[2];all[0]=all[1]=1;\n\tfor(int i=0;i<m;i++)all[arr[i]^1]=0;\n\tif(all[0]||all[1]){\n\t\tlong long dp[2][n];memset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;dp[1][0]=0; //start with red (or blue if everything is blue)\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tlong long ans=(dp[0][n-1]+dp[1][n-1])%MOD;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=0;dp[1][0]=1; //start with blue\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tans+=dp[0][n-1];ans%=MOD;ans+=MOD;ans%=MOD;\n\t\tprintf(\"%lld\",ans);\n\t\treturn 0;\n\t}\n\tif(n%2!=0){printf(\"0\");return 0;}\n\tint mxl=(int)MOD; //large number\n\tint st=1,cur=0;\n\tfor(int i=1;i<m;i++){\n\t\tif(arr[i]==arr[0]){\n\t\t\tif(st!=-1)st++;\n\t\t\telse cur++;\n\t\t}else{\n\t\t\tif(st!=-1){\n\t\t\t\tmxl=st|1; //+1 if even\n\t\t\t\tst=-1;\n\t\t\t}else{\n\t\t\t\tif(cur%2!=0)mxl=min(mxl,cur);\n\t\t\t\tcur=0;\n\t\t\t}\n\t\t}\n\t}\n\t//comments: wlog red is first\n\t//can ignore last segment of red\n\tn/=2; mxl/=2; //remove the ones that are different parity from blue\n\tlong long dp[100005],pref[100005];\n\tmemset(dp,0,sizeof(dp));memset(pref,0,sizeof(pref));\n\t//i segments on a line, first and last are blue, max mxl consecutive reds\n\t//blues may be consecutive because the reds in between were removed\n\tdp[1]=pref[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tdp[i]=pref[i-1]-pref[max(0,i-(mxl+2))];\n\t\tdp[i]%=MOD;dp[i]+=MOD;dp[i]%=MOD;\n\t\tpref[i]=dp[i]+pref[i-1];\n\t\tpref[i]%=MOD;pref[i]+=MOD;pref[i]%=MOD;\n\t}\n\tlong long ans=0;\n\tfor(long long i=2;i<=min(n,mxl+2);i++){\n\t\tans+=(i-1LL)*dp[n-i+2];\n\t\tans%=MOD;\n\t}\n\tans+=MOD;ans%=MOD;\n\tprintf(\"%lld\",(ans*2)%MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"base.hpp\"//5\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//5b\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n#line 1 \"mod.hpp\"//5b\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//5bm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//5b\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//5b\nusing unit = tuple<>;using int128=__int128;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing VM=vec<mint>;using VI=vec<int>;\n#line 1 \"alias.hpp\"//5b\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//5b\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nnamespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}TL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){\nRT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//5b\nTL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)\n#line 6001 \"base.hpp\"//5\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1001 \"5.cpp\"//\n//#include \"consts.hpp\"\n// #include \"prime.hpp\"\n\nvoid solve() {\n// NM\"S\"\n/* <foxy.memo-area> */\nint N;int M;string S;cin>>N;cin>>M;cin>>S;\n/* </foxy.memo-area> */\n\n  if(S[0] == 'B') {\n    times(M, i) S[i] = 'R' + 'B' - S[i];\n  }\n\n  int p = 1ll << 60;\n  {\n    int ren = 1;\n    times(M, i) {\n      if(S[i] == 'R') {\n        ++ren;\n      } else {\n        if(p == 0 || ren % 2 == 1) {\n          amin(p, ren);\n        }\n        ren = 0;\n      }\n    }\n    // if(p == 0 || ren % 2 == 1) {\n    //   amin(p, ren);\n    // }\n  }\n  {if(debug)cerr<<\"p: \"<<(p)ln;}\n#define M hoge\n\n  if(p > N) {\n    mint ans = 0_m;\n    {\n      // [0]->R\n      VM dp(N);\n      dp[0] = 1_m;\n      dp[1] = 2_m;\n      uptil(2, N, i) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n      }\n      ans += dp[N - 1];\n      {if(debug)cerr<<\"dp: \"<<(dp)ln;}\n    }\n    {\n      // [0]->B\n      VM dp(N - 1);\n      dp[0] = 1_m;\n      if(N >= 3) dp[1] = 1_m;\n      uptil(2, N - 1, i) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n      }\n      ans += dp[N - 2];\n      {if(debug)cerr<<\"dp: \"<<(dp)ln;}\n    }\n\n    cout << ans ln;\n    return;\n  }\n\n  if(N % 2 == 1) {\n    cout << 0 ln;\n    return;\n  }\n\n  int m = N / 2;\n  int q = (p + 1) / 2;\n\n#define N hoge\n#define p hoge\n\n  /*\n  auto pfh = prime_factor(m);\n  int zpf = size(pfh);\n  VI pf; pf.reserve(zpf);\n  for(auto &p : pfh) pf.PB(p.first);\n  {if(debug)cerr<<\"pf: \"<<(pf)ln;}\n  */\n\n  /*\n  VI pf;\n  for(int i = 1; i*i <= m; ++i) {\n    if(m % i == 0) {\n      pf.PB(i);\n      if(i*i != m) pf.PB(m / i);\n    }\n  }\n  sort(iter(pf));\n  */\n  VI pf = {m};\n  {if(debug)cerr<<\"pf: \"<<(pf)ln;}\n  int zpf = size(pf);\n\n  VM dp(m);\n  VM g(zpf);\n\n  mint ans = 0_m;\n\n  times(zpf, h) {\n    mint s = dp[0] = 1_m;\n    uptil(1, pf[h], i) {\n      s += dp[i] = s;\n      if(i >= q) {\n        s -= dp[i - q];\n      }\n      if(i <= q) {\n        dp[i] += dp[0] * mint(i - 1);\n        s += dp[0] * mint(i - 1);\n      }\n    }\n\n    g[h] = s;\n    times(h, hh) {\n      if(pf[h] % pf[hh] == 0) g[h] -= g[hh];\n    }\n    ans += g[h] ;//* mint(pf[h]);\n\n    {if(debug)cerr<<'#'<<__LINE__ ln<<\"  h:     \"<<(h)ln<<\"  pf[h]: \"<<(pf[h])ln<<\"  s:     \"<<(s)ln<<\"  g[h]:  \"<<(g[h])ln<<\"  dp:    \"<<(dp)ln;}\n  }\n\n  cout << ans * 2_m ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Fail puts(\"NO\"),exit(0);\n#define eps 1e-10\n#define maxn 200010\n#define maxm 100010\n#define inf 1000000007\n#define mod 1000000007\n#define pi acos(-1)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int>pii;\ntypedef bitset<maxn> bit;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,m;\nchar s[maxn];\nint a[maxn];\nbool check()\n{\n    for(int i=1;i<=m;i++)  if(a[i])  return false;\n    return true;\n}\nint g[maxn],f[maxn],sum[maxn][2];\nint L=inf;\nint main()\n{\n    n=read();m=read();\n    scanf(\"%s\",s+1);\n    for(int i=1;i<=m;i++)  a[i]=(s[i]=='B');\n    if(a[1])  for(int i=1;i<=m;i++)  a[i]^=1;\n    if(check())\n    {\n        if(n==2) return puts(\"3\"),0;\n        g[0]=1;g[1]=2;\n        for(int i=2;i<=n;i++)  g[i]=(g[i-1]+g[i-2])%mod;\n        return printf(\"%d\\n\",(g[n-1]+g[n-3])%mod),0;\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(a[i])  continue;\n        int R=i;\n        while(R<m&&!a[R+1])  R++;\n        if(R==m)  break;\n        if(i==1)  L=min(L,R-i+2);\n        if((R-i+1)&1)  L=min(L,R-i+1);\n        i=R;\n    }\n    f[0]=1;sum[0][0]=1;\n    for(int i=1;i<=n;i++)\n    {\n        if(i>=2)\n        {\n            f[i]=sum[i-2][i&1];\n            if(i>=L+2)  f[i]=(f[i]-sum[i-L-2][i&1])%mod;\n        }\n        sum[i][0]=sum[i-1][0];sum[i][1]=sum[i-1][1];\n        sum[i][i&1]=(sum[i][i&1]+f[i])%mod;\n    }\n    int ans=f[n];\n    for(int i=1;i<=L;i+=2)  ans=(ans+1ll*i*f[n-i-1])%mod;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#include <time.h>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\ntypedef vector<ll> vll;\ntypedef vector< vector<ll> > matrix;\n#define REP(i, x, y) for(ll i = (ll)x; i < (ll)y; i++)\n#define DREP(i, x, y, d) for(ll i = (ll)x; i < (ll)y; i += (ll)d)\n#define PER(i, x, y) for(ll i = (ll)x; i > (ll)y; i--)\n#define DPER(i, x, y, d) for(ll i = (ll)x; i > (ll)y; i -= (ll)d)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-12;\n\nll modadd(ll x, ll y) {\n    return ((x + y) % mod + mod) % mod;\n}\n\nll modminus(ll x, ll y) {\n    return (x - y + mod) % mod;\n}\n\nll multiply(ll x, ll y) {\n    return (x % mod) * (y % mod) % mod;\n}\n\nll modpower(ll x, ll y) {\n    if (y == 0) {\n        return 1;\n    } else if (y == 1) {\n        return x % mod;\n    } else if (y % 2 == 0) {\n        ll p = modpower(x, y / 2);\n        return p * p % mod;\n    } else {\n        ll p = modpower (x, y / 2);\n        return (p * p) % mod * (x % mod) % mod;\n    }\n}\n\nll divide(ll x, ll y) {\n    return multiply(x, modpower(y, mod - 2));\n}\n\nll frac[1000000];\nll invfrac[1000000];\n\nvoid fracinvfrac(ll n) {\n    frac[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        frac[i] = multiply(frac[i - 1], i);\n    }\n    invfrac[n] = divide(1, frac[n]);\n    for (int i = n - 1; i >= 0; i--) {\n        invfrac[i] = multiply(invfrac[i + 1], i + 1);\n    }\n}\n\nll modcombi(ll x, ll y) {\n    if (x < y || y < 0) {\n        return 0;\n    } else if (y == 0) {\n        return 1;\n    } else {\n        return multiply(multiply(frac[x], invfrac[x - y]), invfrac[y]);\n    }\n}\n\nll N, M;\nll dp[200010][2];\n\nll solve(ll num) {\n    dp[0][0] = 1;\n    REP(i, 0, num) {\n        dp[i + 1][0] = modadd(dp[i + 1][0], dp[i][0]);\n        dp[i + 1][0] = modadd(dp[i + 1][0], dp[i][1]);\n        dp[i + 1][1] = modadd(dp[i + 1][1], dp[i][0]);\n    }\n    return (dp[num - 1][0] + dp[num - 1][1] + dp[num - 2][0]) % mod;\n}\n\nll dpb[200010][2];\n\nll solveb(ll num, ll len) {\n    // cout << num << \" \" << len << endl;\n    ll p = num / 2;\n    ll q = len / 2;\n    dpb[0][0] = 1;\n    dpb[0][1] = 1;\n    // ll sum = 0;\n    REP(i, 0, p) {\n        dpb[i + 1][0] = modadd(dpb[i + 1][0], dpb[i][1]);\n        if (i - (q + 1) >= 0) {\n            dpb[i + 1][0] = modminus(dpb[i + 1][0], dpb[i - (q + 1)][1]);\n        }\n        // dpb[i + 1][0] = modadd(dpb[i + 1][0], dpb[i][1]);\n        dpb[i + 1][1] = modadd(modadd(dpb[i + 1][1], dpb[i + 1][0]), dpb[i][1]);\n        // sum = modadd(sum, dpb[i + 1][1]);\n        // if (i >= q) {\n        //     sum = modminus(sum, dpb[i + 1 - q][0]);\n        // }\n        // if (i == 0) {\n        //     sum--;\n        // }\n    }\n    // dpb[0][0] = 1;\n    // dpb[0][1] = 1;\n    // REP(i, 0, num) {\n    //     dpb[i + 1][0] = modadd(dpb[i + 1][0], dpb[i][0]);\n    //     dpb[i + 1][0] = modadd(dpb[i + 1][0], dpb[i][1]);\n    //     dpb[i + 1][1] = modadd(dpb[i + 1][1], dpb[i][0]);\n    // }\n    // dp[0][0] = 1;\n    // REP(i, 0, num) {\n    //     dp[i + 1][0] = modadd(dp[i + 1][0], dp[i][0]);\n    //     dp[i + 1][0] = modadd(dp[i + 1][0], dp[i][1]);\n    //     dp[i + 1][1] = modadd(dp[i + 1][1], dp[i][0]);\n    // }\n    // REP(i, 0, p) {\n    //     cout << dpb[i][0] << \" \" << dpb[i][1] << endl;\n    // }\n    ll ans = 0;\n    REP(i, 0, q + 1) {\n        if (p - 1 - i >= 0) {\n            ll val = multiply((i + 1) * 2, dpb[p - 1 - i][0]);\n            // cout << val << endl;\n            ans = modadd(ans, val);\n        }\n    }\n    return ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    if (N & 1) {\n        bool ok = true;\n        char c = S[0];\n        REP(i, 0, M) {\n            if (S[i] != c) {\n                ok = false;\n            }\n        }\n        if (ok) {\n            cout << solve(N) << endl;\n        } else {\n            cout << 0 << endl;\n        }\n        return 0;\n    } else {\n        ll len = 0;\n        char c = S[0];\n        ll num = 0;\n        while (num < M && S[num] == c) {\n            num++;\n        }\n        len = num;\n        if (len == M) {\n            cout << solve(N) << endl;\n            return 0;\n        }\n        if (!(len & 1)) {\n            len++;\n        }\n        ll tmp = 0;\n        num++;\n        while (num < M) {\n            if (S[num] == c) {\n                tmp++;\n            } else {\n                if (tmp & 1) {\n                    len = min(len, tmp);\n                }\n                tmp = 0;\n            }\n            num++;\n        }\n        // cout << len << endl;\n        cout << solveb(N, len) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=2e5+10,mod=1e9+7;\ninline void Dec(int &x,int y) { x-=y; if(x<0) x+=mod; }\ninline void Add(int &x,int y) { x+=y; if(x>=mod) x-=mod; }\nchar S[N];\nint n,m,f[N];\nint main() {\n\trd(n),rd(m);\n\tscanf(\"%s\",S+1);\n\tchar c=S[1];\n\tint p=1,r=1,L=m;\n\t\n\twhile(r<=m&&S[r]==c) r++;\n\tif(r==m+1) {\n\t\tif(n==2) { printf(\"3\\n\"); return 0; }\n\t\tf[0]=1,f[1]=2;\n\t\tfor(int i=2;i<=n;++i) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",(f[n-3]+f[n-1])%mod);\n\t\treturn 0;\n\t}\n\t\n\tL=min(L,(r-p)|1);\t\n\tp=r;\n\twhile(p<=m&&S[p]!=c) p++;\n\t\n\twhile(1) {\n\t\tr=p;\n\t\twhile(r<=m&&S[r]==c) r++;\n\t\tif(r>m) break;\n\t\tif((r-p)&1) L=min(L,r-p);\n\t\tp=r;\n\t\twhile(p<=m&&S[p]!=c) p++;\n\t}\n\tint sum[2]={0,0};\n\tf[1]=1,sum[1]=1;\n\tfor(int i=2;i<=n;++i) {\n\t\tf[i]=sum[i&1];\n\t\tif(i-L-1>=1) Dec(sum[i&1],f[i-L-1]);\n\t\tAdd(sum[i&1],f[i]);\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=n;++i) {\n\t\tif(n-i>L||!((n-i)&1)) continue;\n\t\tAdd(ans,f[i]*(ll)(n-i+1)%mod);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n//#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MaxN = 2e5 + 100;\nconst int Mod = 1e9 + 7;\n\nint dp[MaxN];\nint pref_dp[MaxN];\n\nint small_dp[MaxN][2][2];\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N, M;\n  string s;\n  cin >> N >> M >> s;\n\n  if (count(ALL(s), s[0]) == M) {\n    small_dp[1][1][1] = small_dp[1][0][0] = 1;\n    for (int len = 2; len <= N; ++len) {\n      for (int fst : {0, 1}) {\n        // add gut\n        small_dp[len][fst][0] =\n          (small_dp[len - 1][fst][0] + small_dp[len - 1][fst][1]) % Mod;\n        // add no gut\n        small_dp[len][fst][1] = small_dp[len - 1][fst][0];\n      }\n    }\n\n    int ans = 0;\n    for (int x : {0, 1}) {\n      for (int y : {0, 1}) {\n        if (x + y <= 1) {\n          ans = (ans + small_dp[N][x][y]) % Mod;\n        }\n      }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n  }\n\n  if (s[0] != s[1]) {\n    if (N % 2 == 0) {\n      cout << \"2\\n\";\n    } else {\n      cout << \"0\\n\";\n    }\n    return 0;\n  }\n\n  int min_seg_len = N - 1;\n  int cur_len = 0;\n  for (char ch : s) {\n    if (ch == s[0]) {\n      ++cur_len;\n    } else {\n      if (cur_len) { mini(min_seg_len, cur_len); }\n      cur_len = 0;\n    }\n  }\n  if (cur_len) { mini(min_seg_len, cur_len); }\n\n\n  int answer = 0;\n\n  dp[0] = pref_dp[2] = 1;\n\n  const int min_jump = 2;\n  int max_jump = min_seg_len + 2;\n  // jump must be even as well\n  if (max_jump % 2 == 1) { --max_jump; }\n\n  debug(min_jump, max_jump);\n\n  for (int len = 1; len <= N; ++len) {\n    const int add_from = max(0, len - max_jump);\n    const int add_to = len - min_jump;\n\n    if (add_from <= add_to) {\n      dp[len] = pref_dp[add_to + 2] - pref_dp[add_from];\n      if (dp[len] < 0) { dp[len] += Mod; }\n    }\n\n    debug(len, dp[len]);\n\n    pref_dp[len + 2] = (pref_dp[len] + dp[len]) % Mod;\n  }\n\n  for (int chain_len = 0; chain_len < N; ++chain_len) {\n    const int rem_len = N - chain_len;\n    if (2 <= rem_len && rem_len <= max_jump) {\n      const int coef = dp[chain_len];\n      answer = (answer + (LL)coef * (rem_len )) % Mod;\n    }\n  }\n\n  cout << answer << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\ntemplate<typename T>\nclass RangeAddQuery {\npublic:\n    explicit RangeAddQuery(int n) : N(calcN_(n)) {\n        mVal.assign(2*N+1, 0);\n    }\n    void update(int l, int r, T value){\n        l = max(0, l);\n        r = min(N, r);\n        int offset = N;\n        while(offset > 0){\n            if(l >= r) break;\n            if(l&1){ update_(mVal[offset+l-1], value); l++; }\n            if(r&1){ update_(mVal[offset+r-2], value); }\n            l /= 2;\n            r /= 2;\n            offset /= 2;\n        }\n    }\n    T get(int idx){\n        int i = N + idx - 1;\n        auto res = mVal[i];\n        while(i > 0){\n            i = (i-1)/2;\n            update_(res, mVal[i]);\n        }\n        return res;\n    }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    inline void update_(T& data, T val) { data = (data + val) % MOD; }\n    const int N;\n    vector<T> mVal;\n};\n\nint maxSegment(const string& S){\n    char c = S[0];\n    bool first = true;\n    int cnt = 0;\n    int res = MOD;\n    for(auto& s : S){\n        if(c == s) ++cnt;\n        else {\n            if(first || cnt%2 == 1){\n                res = min(res, cnt/2+1);\n                cnt = 0;\n                first = false;\n            }\n        }\n    }\n    return res < MOD ? res : -1;\n}\n\nint solve(const string& S, int N){\n    int seg = maxSegment(S);\n    if(seg != -1 && N%2 == 1) return 0;\n    long long res = 0;\n    if(seg == -1){\n        RangeAddQuery<long long> raq(N);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N;i++){\n            auto a = raq.get(i);\n            raq.update(i+2, N, a);\n        }\n        res = 1;\n        for(int i=N-2;i>=0;i--){\n            res = (res + raq.get(i) * (N-i)) % MOD;\n        }\n    } else {\n        seg = min(seg, N/2);\n        RangeAddQuery<long long> raq(N/2);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N/2;i++){\n            auto a = raq.get(i);\n            raq.update(i+1, i+1+seg, a);\n        }\n        for(int i=N/2-1;i>=N/2-seg;i--){\n            res = (res + raq.get(i) * 2LL * (N/2-i)) % MOD;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    cout << solve(S, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,inline\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int md=1000000007;\nconst int mxn=200005;\nint n,m,mx,ans,dp[mxn],f[mxn];\nchar s[mxn];\ninline void add(int&x,int y){\n\tx+=y;\n\tif(x>=md)x-=md;\n}\nint main(){\n\tint i,j,t;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(i=1;i<=m;++i)if(s[i]!=s[1])break;mx=i-1;\n\tif(mx==m){\n\t\tdp[0]=f[i]=ans=1;\n\t\tfor(int i=0;i<n-2;++i){\n\t\t\tif(i>=2)dp[i]=f[i-2];\n\t\t\tf[i]=(f[i-1]+dp[i])%md;\n\t\t\tadd(ans,dp[i]*(n-i)%md);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(n&1)return 0*puts(\"0\");\n\tif(!(mx&1))++mx;\n\tfor(t=0;i<=m;++i){\n\t\tif(s[i]==s[1])++t;\n\t\telse{\n\t\t\tif(t&1)mx=min(mx,t);\n\t\t\tt=0;\n\t\t}\n\t}\n\tn>>=1,mx=mx+1>>1;\n\tdp[0]=f[0]=1;\n\tfor(i=0;i<=n;++i){\n\t\tif(i){\n\t\t\tdp[i]=(md+f[i-1]-(i-mx-1>=0?f[i-mx-1]:0))%md;\n\t\t\tf[i]=(f[i-1]+dp[i])%md;\n\t\t}\n\t\tif(n-i<=mx) add(ans,(n-i)*dp[i]*2%md);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n//#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int M = 1e9 + 7;\n\nvoid solve_fib(int n) {\n    vi f(n + 1);\n    f[0] = f[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        f[i] = (f[i - 1] + f[i - 2]) % M;\n    }\n    cout << (f[n] + f[n - 2]) % M;\n}\nconst int oo = 1e9 + 10;\n\nint kek(int cnt, bool & first) {\n    if (first) {\n        first = false;\n        if (cnt & 1)\n            return cnt;\n        return cnt + 1;\n    }\n    if (cnt & 1)\n        return cnt;\n    return oo;\n}\n\nvoid insum(int &a, int b) {\n    a = (a + b) % M;\n}\n\nvoid smain() {\n\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    m = s.size();\n    if (count(ALL(s), 'R') == 0 || count(ALL(s), 'B') == 0) {\n        solve_fib(n);\n        return;\n    }\n\n    vi a(m);\n    fori (i, m) {\n        a[i] = s[i] == 'R';\n    }\n\n    vi min_sz(2, oo);\n    int cur = -1;\n    int cnt = 0;\n    bool first = true;\n    for (auto c : a) {\n        if (c != cur) {\n            if (cur != -1) {\n                inmin(min_sz[cur], kek(cnt, first));\n            }\n            cur = c;\n            cnt = 1;\n        } else {\n            cnt++;\n        }\n    }\n    inmin(min_sz[cur], kek(cnt, first));\n    vvi f(2);\n    fori (z, 2) {\n        vvi dp(2, vi(n, 0));\n        vvi p(2, vi(n, 0));\n        p[!z][0] = dp[!z][0] = 1;\n        for (int i = 1; i < n; ++i) {\n            fori (zz, 2) {\n                int j = i - min_sz[zz];\n                if (j < i) {\n                    dp[zz][i] = (p[!zz][i - 1] - (j - 2 >= 0 ? p[!zz][j - 2] : 0) + M) % M;\n                }\n            }\n            fori (zz, 2) {\n                p[zz][i] = (dp[zz][i] + (i - 2 >= 0 ? p[zz][i - 2] : 0)) % M;\n            }\n        }\n        f[z] = dp[z];\n    }\n    int ans = 0;\n    fori (z, 2) {\n        for (int sz = 1; sz <= min_sz[z]; sz += 2) if (sz < n) {\n            insum(ans, (ll)f[!z][n - sz] * sz % M);\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=200005,p=1000000007;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint n,m,cnt,a[N],f[N];\nchar ch[N];\nint calc(int n,int l,int r){\n\tf[0]=1;\n\tint s=0;\n\tfor (int i=1;i<=n;i++){\n\t\tif (i>=l) s=(s+f[i-l])%p;\n\t\tf[i]=s;\n\t\tif (i>=r) s=(s-f[i-r]+p)%p;\n\t}\n\tint ans=0;\n\tfor (int i=l;i<=r;i++)\n\t\tans=(ans+(ll)f[n-i]*i)%p;\n\treturn ans;\n}\nint main(){\n\tn=read();m=read();\n\tscanf(\" %s\",ch+1);\n\tcnt=0;\n\tfor (int i=1;i<=m;i++)\n\tif (ch[i]==ch[1]) a[cnt]++;\n\telse cnt++;\n\tif (cnt==0) printf(\"%d\\n\",(calc(n,2,n)+1)%p);\n\telse{\n\t\tint r=a[0]+1-(a[0]&1);\n\t\tfor (int i=1;i<cnt;i++)\n\t\tif (a[i]%2==1) r=min(r,a[i]);\n\t\tprintf(\"%d\\n\",calc(n/2,1,(r+1)/2)*2%p);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define reg register\n#define pr std::pair<int, int>\n#define fi first\n#define se second\n#define FIN(s) freopen(s, \"r\", stdin)\n#define FOUT(s) freopen(s, \"w\", stdout)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, l, r) for (int i = l; i <= r; ++i)\n#define lep(i, l, r) for (int i = l; i < r; ++i)\n#define irep(i, r, l) for (int i = r; i >= l; --i)\n#define ilep(i, r, l) for (int i = r; i > l; --i)\n#define Rep(i, n) rep(i, 1, n)\n#define Lep(i, n) lep(i, 1, n)\n#define IRep(i, n) irep(i, n, 1)\n#define ILep(i, n) ilep(i, n, 1)\ntypedef long long ll;\ntypedef long double ld;\n\nnamespace modular {\n    const int MOD = 1000000007;\n    inline int add(int x, int y) { return (x += y) >= MOD ? x -= MOD : x; }\n    inline void inc(int &x, int y) { (x += y) >= MOD ? x -= MOD : 0; }\n    inline int mul(int x, int y) { return 1LL * x * y % MOD; }\n    inline int qpow(int x, int y) {\n        int ans = 1;\n        for (; y; y >>= 1, x = mul(x, x))\n            if (y & 1) ans = mul(ans, x);\n        return ans;\n    }\n};  // namespace modular\nusing namespace modular;\n\nnamespace Base {\n    template <typename Tp>\n    inline Tp input() {\n        Tp x = 0, y = 1;\n        char c = getchar();\n        while ((c < '0' || '9' < c) && c != EOF) {\n            if (c == '-') y = -1;\n            c = getchar();\n        }\n        if (c == EOF) return 0;\n        while ('0' <= c && c <= '9') x = x * 10 + c - '0', c = getchar();\n        return x *= y;\n    }\n    template <typename Tp>\n    inline void read(Tp &x) {\n        x = input<Tp>();\n    }\n    template <typename Tp>\n    inline void chmax(Tp &x, Tp y) {\n        x < y ? x = y : 0;\n    }\n    template <typename Tp>\n    inline void chmin(Tp &x, Tp y) {\n        x > y ? x = y : 0;\n    }\n};  // namespace Base\nusing namespace Base;\n/*----------------------------------------------------------------------------*/\n\n#define MAX_N 300007\n\nint N, M;\nint f[MAX_N], g[MAX_N];\nchar s[MAX_N];\n\nint main() {\n#ifndef ONLINE_JUDGE\n    FIN(\"3.in\");\n    FOUT(\"1.out\");\n#endif\n    read(N), read(M);\n    scanf(\"%s\", s + 1);\n    bool vis = false;\n    int len = 0, mn = N;\n    Rep(i, M) {\n        if (s[i] != s[1]) {\n            if (!vis || (len & 1)) chmin(mn, len / 2 + 1);\n            vis = true, len = 0;\n        } else\n            ++len;\n    }\n    // printf(\"%d\\n\", len);\n    if (!vis) {\n        int a = 0, b = 1;\n        Lep(i, N) {\n            std::swap(a, b);\n            inc(b, a);\n        }\n        printf(\"%d\\n\", add(mul(a, 2), b));\n        return 0;\n    }\n    if (N & 1) return puts(\"0\"), 0;\n    N >>= 1;\n    f[0] = g[0] = 1;\n    Rep(i, N) {\n        f[i] = g[i - 1];\n        if (i > mn) inc(f[i], MOD - g[i - mn - 1]);\n        // printf(\"%d %d %d\\n\", i, g[i - 1], f[i]);\n        g[i] = add(f[i], g[i - 1]);\n    }\n    int res = 0;\n    Rep(i, mn) inc(res, mul(mul(i, 2), f[N - i]));\n    printf(\"%d\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 200005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n\tif(c == '-') f = -1;\n\tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n\tres = res * 10 +c - '0';\n\tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nconst int MOD = 1000000007;\nint N,M,L;\nchar s[MAXN];\nbool flag = 0;\nint f[MAXN][2],dp[MAXN],sum[MAXN][2];\nint inc(int a,int b) {\n    return a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n    return 1LL * a * b % MOD;\n}\nvoid update(int &x,int y) {\n    x = inc(x,y);\n}\nvoid Solve1() {\n    int ans = 0;\n    f[1][1] = 1;f[1][0] = 1;\n    for(int i = 2 ; i <= N ; ++i) {\n\tf[i][0] = f[i - 1][1];\n\tf[i][1] = inc(f[i - 1][1],f[i - 1][0]);\n    }\n    ans = inc(f[N][0],f[N][1]);\n    memset(f,0,sizeof(f));\n    f[1][0] = 1;\n    for(int i = 2 ; i < N ; ++i) {\n\tf[i][0] = f[i - 1][1];\n\tf[i][1] = inc(f[i - 1][1],f[i - 1][0]);\n    }\n    ans = inc(ans,MOD - f[N - 1][1]);\n    out(ans);enter;\n}\nvoid Solve2() {\n    dp[0] = 1;sum[0][0] = 1;\n    for(int i = 1 ; i <= N ; ++i) {\n\tif(i >= 2) {\n\t    int t = sum[i - 2][i & 1];\n\t    if(i > L + 1) update(t,MOD - sum[i - L - 2][i & 1]);\n\t    dp[i] = t;\n\t}\n\tsum[i][0] = sum[i - 1][0];sum[i][1] = sum[i - 1][1];\n\tsum[i][i & 1] = inc(sum[i][i & 1],dp[i]);\n\t\n    }\n    int ans = dp[N];\n    for(int i = 1 ; i <= L ; i += 2) {\n\tupdate(ans,mul(i,dp[N - i - 1]));\n    }\n    out(ans);enter;\n}\nvoid Init() {\n    read(N);read(M);\n    scanf(\"%s\",s + 1);\n    while(M >= 1 && s[M] == s[1]) --M;\n    L = N;\n    if(M == 0) flag = 1;\n    else {\n\tfor(int i = 1 ; i <= M ; ++i) {\n\t    if(s[i] != s[1]) continue;\n\t    else {\n\t\tint j = i;\n\t\twhile(s[j + 1] == s[1]) ++j;\n\t\tint t = j - i + 1;\n\t\tif(i == 1) {\n\t\t    if(t % 2 == 0) L = min(L,t + 1);\n\t\t    else L = min(L,t); \n\t\t}\n\t\telse {\n\t\t    if(t % 2 == 1) L = min(L,t);\n\t\t}\n\t\ti = j;\n\t    }\n\t}\n    }\n    if(L == N) flag = 1;\n    if(flag) Solve1();\n    else Solve2();\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=201000;\nchar s[N];\nint n,m;\n\nll dp[N],sdp[N],ans;\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s);\n\tbool mono=1;\n\trep(i,0,m) mono&=s[i]==s[0];\n\tif (mono) {\n\t\tint a=2,b=1;\n\t\trep(i,1,n) {\n\t\t\ta=(a+b)%mod;\n\t\t\tswap(a,b);\n\t\t}\n\t\tprintf(\"%d\\n\",b);\n\t\treturn 0;\n\t}\n\tint sR=2*n+1,sB=2*n+1;\n\tif (s[0]=='B') {\n\t\trep(i,0,m) if (s[i]=='R') s[i]='B'; else s[i]='R';\n\t}\n\trep(l,0,n) {\n\t\tint r=l;\n\t\twhile (r<n&&s[r]==s[l]) r++;\n\t\tint len=r-l;\n\t\tif (len%2==0) len=len+1;\n\t\tif (r==n) break;\n\t\tif (s[l]=='R') sR=min(sR,len);\n\t\telse sB=min(sB,len);\n\t\tl=r-1;\n\t}\n\tif (n%2==1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tauto solve=[&](int sR,int sB) {\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(sdp,0,sizeof(sdp));\n\t\tdp[0]=1;\n\t\tsdp[2]=1;\n\t\trep(i,1,n+1) {\n\t\t\tif (i%2==1) {\n\t\t\t\tdp[i]=(sdp[i+1]-sdp[max(0,i-sR)])%mod;\n\t\t\t} else {\n\t\t\t\tif (i!=n) {\n\t\t\t\t\tdp[i]=(sdp[i+1]-sdp[max(1,i-sB)])%mod;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j=1;j<=sB&&j<=i;j+=2) {\n\t\t\t\t\t\tdp[i]=(dp[i]+dp[i-j]*j)%mod;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsdp[i+2]=(sdp[i]+dp[i])%mod;\n\t\t}\n\t\tans+=dp[n];\n\t};\n\tsolve(sR,sB);\n\tsolve(sB,sR);\n\tans%=mod;\n\tif (ans<0) ans+=mod;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\ntemplate<typename T>\nclass RangeAddQuery {\npublic:\n    explicit RangeAddQuery(int n) : N(calcN_(n)) {\n        mVal.assign(2*N+1, 0);\n    }\n    void update(int l, int r, T value){\n        l = max(0, l);\n        r = min(N, r);\n        int offset = N;\n        while(offset > 0){\n            if(l >= r) break;\n            if(l&1){ update_(mVal[offset+l-1], value); l++; }\n            if(r&1){ update_(mVal[offset+r-2], value); }\n            l /= 2;\n            r /= 2;\n            offset /= 2;\n        }\n    }\n    T get(int idx){\n        int i = N + idx - 1;\n        auto res = mVal[i];\n        while(i > 0){\n            i = (i-1)/2;\n            update_(res, mVal[i]);\n        }\n        return res;\n    }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    inline void update_(T& data, T val) { data = (data + val) % MOD; }\n    const int N;\n    vector<T> mVal;\n};\n\nint maxSegment(const string& S){\n    char c = S[0];\n    bool first = true;\n    int cnt = 0;\n    int res = MOD;\n    for(auto& s : S){\n        if(c == s) ++cnt;\n        else {\n            if(first || cnt%2 == 1){\n                res = min(res, cnt/2+1);\n                cnt = 0;\n                first = false;\n            }\n        }\n    }\n    return res < MOD ? res : -1;\n}\n\nint solve(const string& S, int N){\n    int seg = maxSegment(S);\n    if(seg != -1 && N%2 == 1) return 0;\n    long long res = 0;\n    if(seg == -1){\n        RangeAddQuery<long long> raq(N);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N;i++){\n            auto a = raq.get(i);\n            raq.update(i+2, N, a);\n        }\n        res = 1;\n        for(int i=N-2;i>=0;i--){\n            res = (res + raq.get(i) * (N-i)) % MOD;\n        }\n    } else {\n        seg = min(seg, N/2);\n        RangeAddQuery<long long> raq(N/2);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N/2;i++){\n            auto a = raq.get(i);\n            raq.update(i+1, i+1+seg, a);\n        }\n        for(int i=N/2-1;i>=N/2-seg;i--){\n            res = (res + raq.get(i) * 2 * (N/2-i)) % MOD;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    cout << solve(S, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n//#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int M = 1e9 + 7;\n\nvoid solve_fib(int n) {\n    vi f(n + 1);\n    f[0] = f[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        f[i] = (f[i - 1] + f[i - 2]) % M;\n    }\n    cout << (f[n] + f[n - 2]) % M;\n}\n\nint kek(int cnt) {\n    if (cnt & 1)\n        return cnt;\n    return cnt + 1;\n}\n\nvoid insum(int &a, int b) {\n    a = (a + b) % M;\n}\n\nvoid smain() {\n\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if (count(ALL(s), 'R') == 0 || count(ALL(s), 'B') == 0) {\n        solve_fib(n);\n        return;\n    }\n\n    vi a(m);\n    fori (i, m) {\n        a[i] = s[i] == 'R';\n    }\n\n    vi min_sz(2, m);\n    int cur = -1;\n    int cnt = 0;\n    for (auto c : a) {\n        if (c != cur) {\n            if (cur != -1) {\n                inmin(min_sz[cur], kek(cnt));\n            }\n            cur = c;\n            cnt = 1;\n        } else {\n            cnt++;\n        }\n    }\n    inmin(min_sz[cur], kek(cnt));\n    vvi f(2);\n    fori (z, 2) {\n        vvi dp(2, vi(n, 0));\n        vvi p(2, vi(n, 0));\n        p[!z][0] = dp[!z][0] = 1;\n        for (int i = 1; i < n; ++i) {\n            fori (zz, 2) {\n                int j = i - min_sz[zz];\n                if (j < 0) {\n                    if (i & 1) {\n                        j = 0;\n                    } else {\n                        j = 1;\n                    }\n                }\n                if (j < i) {\n                    dp[zz][i] = (p[!zz][i - 1] - (j - 2 >= 0 ? p[!zz][j - 2] : 0) + M) % M;\n                }\n            }\n            fori (zz, 2) {\n                p[zz][i] = (dp[zz][i] + (i - 2 >= 0 ? p[zz][i - 2] : 0)) % M;\n            }\n        }\n        f[z] = dp[z];\n    }\n    int ans = 0;\n    fori (z, 2) {\n        for (int sz = 1; sz <= min_sz[z]; sz += 2) if (sz < n){\n            insum(ans, (ll)f[!z][n - sz] * sz % M);\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nint const N = 200000, md = 1e9 + 7;\nchar s[N + 1];\nint dp[N + 1], n, m;\n\ninline void ad(int &x, int y) { if ((x += y) >= md)x -= md; }\ninline void sb(int &x, int y) { if ((x -= y) <  0 )x += md; }\ninline void out(int an) { printf(\"%d\\n\", an); exit(0); }\n\nvoid sad(){\n\tdp[0] = 1;\n\tdp[1] = 1;\n\tf(i, 2, n + 1)ad(dp[i] = dp[i - 1], dp[i - 2]);\n\tint an = dp[n];\n\tad(an, dp[n - 1]);\n\tsb(an, dp[n - 2]);\n\tout(an);\n}\n\nint main(){\n\tscanf(\"%d%d%s\", &n, &m, s);\n\tint mx = md;\n\tbool im = false;\n\tf(i, 0, m){\n\t\tint j = i;\n\t\twhile (j + 1 < m && s[j + 1] == s[i])++j;\n\t\tif (i == 0 && j + 1 == m)sad();\n\t\tim = !im;\n\t\tif (im){\n\t\t\tint ln = j - i + 1;\n\t\t\tif (ln & 1)mx = min(mx, ln);\n\t\t\telse if (i == 0)mx = min(mx, ln | 1);\n\t\t}\n\t\ti = j;\n\t}\n\tif (n & 1)out(0);\n\tmx = mx + 1 >> 1;\n\tint l = 1, s = 0;\n\tn >>= 1;\n\tf(i, 1, n + 1){\n\t\tif (i - l > mx)sb(s, dp[l++]);\n\t\tdp[i] = s;\n\t\tif (i <= mx)ad(dp[i], i << 1);\n\t\tad(s, dp[i]);\n\t}\n\tprintf(\"%d\\n\", dp[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 200005\n#define mo 1000000007\n#define ll long long\nint n,m,L;\nchar s[M];\nll ans,f[M],g[M];\nll dp[M][2];\nvoid work() {\n    while(s[m]==s[1]) m--;\n    L=1e9;\n    char ch=s[1];\n    for(int i=2,l=1;i<=m;i++)\n\t{\n\t    if(s[i]==ch) l++;\n\t    else\n\t\t{\n\t\t    if(l&1) L=min(L,l);\n\t\t    else L=min(L,l+1);\n\t\t    l=0;\n\t\t}\n\t}\n    if(L==1e9)\n\t{\n\t    dp[1][0]=1;\n\t    for(int i=2;i<=n;i++)\n\t\t{\n\t\t    dp[i][0]=(dp[i-1][0]+dp[i-1][1])%mo;\n\t\t    dp[i][1]=dp[i-1][0];\n\t\t}\n\t    ans=(dp[n][1]+dp[n][0])%mo;\n\t    memset(dp,0,sizeof(dp));\n\t    dp[1][1]=1;\n\t    for(int i=2;i<=n;i++)\n\t\t{\n\t\t    dp[i][0]=(dp[i-1][0]+dp[i-1][1])%mo;\n\t\t    dp[i][1]=dp[i-1][0];\n\t\t}\n\t    ans=(ans+dp[n][0])%mo;\n\t    cout<<ans<<'\\n';\n\t}\n    else\n\t{\n\t    f[1]=g[1]=1;\n\t    for(int i=2;i<=n;i++)\n\t\t{\n\t\t    if(i<=L&&(i&1)) f[i]=1;\n\t\t    //for(int j=i-2;j>=max(i-L-1,0);j-=2) f[i]=(f[i]+f[j])%mo;\n\t\t    f[i]=(f[i]+g[i-2]-(i-L-3>=0?g[i-L-3]:0)+mo)%mo;\n\t\t    g[i]=(g[i-2]+f[i])%mo;\n\t\t}\n\t    for(int i=3;i<=L+2&&i<=n;i+=2) ans=(ans+f[n-i]*(i-1)%mo)%mo;\n\t    if(n-1<=L&&((n-1)&1)) ans=(ans+n)%mo;\n\t    cout<<ans<<'\\n';\n\t}\n}\nint main()\n{\n    cin>>n>>m;\n    scanf(\"%s\",s+1);\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\n#include<cassert>\nusing namespace std;\nusing lint = long long;\nusing ld = long double;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(lint i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nint n, m;\nstring s;\n\nvoid allred() {\n\tlint v1 = 0, v2 = 0;\n\tlint ans = 0;\n\tv1 = 1;\n\tREP(i, n - 1) {\n\t\tlint nv1 = (v1 + v2) % MOD;\n\t\tlint nv2 = v1;\n\t\tv1 = nv1;\n\t\tv2 = nv2;\n\t}\n\tans += (v1 + v2) % MOD;\n\tv1 = 0; v2 = 1;\n\tREP(i, n - 1) {\n\t\tlint nv1 = (v1 + v2) % MOD;\n\t\tlint nv2 = v1;\n\t\tv1 = nv1;\n\t\tv2 = nv2;\n\t}\n\tans += v1;\n\tcout << (ans % MOD + MOD) % MOD << endl;\n\treturn;\n}\n\nvoid solve(vector<int> suc_red, int omn) {\n\tint th = omn;\n\tif(suc_red[0] % 2 == 0) th = min(th, suc_red[0] + 1);\n\tlint ans = 0;\n\t/*\n\tif((n - 1) % 2 && (n - 1) <= th) {\n\t\tans += n;\n\t}*/\n\tvector<lint> dpr(n), dpb(n);\n\tdpr[0] = 0;\n\tdpb[0] = 1;\n\tqueue<lint> q0;\n\tqueue<lint> q1;\n\tlint sum0 = 1, sum1 = 0;\n\tq0.push(1);\n\tFOR(i, 1, n) {\n\t\tif(i % 2 == 1) {\n\t\t\twhile(!q0.empty() && (int)q0.size() > (th + 1) / 2) {\n\t\t\t\tsum0 -= q0.front(); sum0 %= MOD;\n\t\t\t\tq0.pop();\n\t\t\t}\n\t\t\tdpr[i] = sum0;\n\t\t} else {\n\t\t\twhile(!q1.empty() && (int)q1.size() > (th + 1) / 2) {\n\t\t\t\tsum1 -= q1.front(); sum1 %= MOD;\n\t\t\t\tq1.pop();\n\t\t\t}\n\t\t\tdpr[i] = sum1;\n\t\t}\n\t\tdpb[i] = dpr[i - 1];\n\t\tif(i % 2 == 0) {\n\t\t\tq0.push(dpb[i]);\n\t\t\tsum0 += dpb[i]; sum0 %= MOD;\n\t\t} else {\n\t\t\tq1.push(dpb[i]);\n\t\t\tsum1 += dpb[i]; sum1 %= MOD;\n\t\t}\n\t}\n\tFOR(i, 1, n) {\n\t\tif(i > th) break;\n\t\tans += dpb[n - 1 - i] * i;\n\t\tans %= MOD;\n\t}\n\tans += dpr[n - 1]; ans %= MOD;\n\tcout << (ans % MOD + MOD) % MOD << endl;\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> m;\n\tcin >> s;\n\tif(s[0] == 'B') {\n\t\tREP(i, m) {\n\t\t\tif(s[i] == 'B') s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\n\tvector<int> suc_red;\n\tint c = 0;\n\tREP(i, m) {\n\t\tif(s[i] == 'R') c++;\n\t\telse {\n\t\t\tif(c != 0) suc_red.pb(c);\n\t\t\tc = 0;\n\t\t}\n\t}\n\tif(c != 0) suc_red.pb(c);\n\n\tif(suc_red[0] == m) {\n\t\tallred();\n\t\treturn 0;\n\t}\n\n\tassert(false);\n\n\tint omn = INF;\n\tREP(i, suc_red.size()) {\n\t\tif(suc_red[i] % 2) omn = min(omn, suc_red[i]);\n\t}\n\tsolve(suc_red, omn);\n\treturn 0;\n}\n/* --------------------------------------- */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nconst int md = 1e9 + 7;\n\nint dp[N];\n\nsigned main() {\n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n  vector<int> y;\n  for (int i = 0; i < m; i++) {\n    int cnt = 1;\n    while (i + 1 < m && s[i + 1] == s[i]) {\n      ++i;\n      ++cnt;\n    }\n    y.push_back(cnt);\n  }\n  if (y.size() == 1) {\n    vector<int> f(n + 1), g(n + 1);\n    f[1] = 2, f[2] = 3;\n    for (int i = 3; i <= n; i++) {\n      f[i] = (f[i - 1] + f[i - 2]) % md;\n    }\n    g[2] = 3, g[3] = 4;\n    for (int i = 4; i <= n; i++) {\n      g[i] = ((long long) f[i - 1] + f[i - 3]) % md;\n    }\n    cout << g[n] << '\\n';\n    return 0;\n  } else if (n % 2 == 1) {\n    cout << 0 << '\\n';\n    return 0;\n  }\n  y.pop_back();\n  int C = y[0] + 1;\n  bool is = true;\n  for (int x : y) {\n    if (is && (x % 2 == 1)) {\n      C = min(C, x);\n    }\n    is ^= 1;\n  }\n  dp[0] = dp[2] = 1;\n  for (int i = 4; i < N; i += 2) {\n    dp[i] = 2 * dp[i - 2] % md;\n    if (i - 3 - C >= 0) {\n      (dp[i] += md - dp[i - 3 - C]) %= md;\n    }\n  }\n  int ans = dp[n];\n  for (int l = 1; l <= C; l += 2) {\n    if (n - l - 1 >= 0) {\n      (ans += (long long) l * dp[n - l - 1] % md) %= md;\n    }\n  }\n  ((ans %= md) += md) %= md;\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 200005;\nconst ll MOD = 1000000007;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n, m, nR, nB;\nchar str[MX];\nll f[MX], sum[2][MX];\n\nvector<int> divide(int x)\n{\n\tvector<int> ret;\n\tfor(int i=1; i<=x; i++)\n\t\tif(x%i == 0)\n\t\t\tret.push_back(i);\n\treturn ret;\n}\n\nint main()\n{\n\tll ans = 0;\n\tread(n), read(m);\n\tscanf(\"%s\", str+1);\n\tfor(int i=1; i<=m; i++)\n\t\tif(str[i] == 'R') nR++;\n\t\telse nB++;\n\tvector<int> dvs = divide(n);\n\tif(!nR || !nB)\n\t{\n\t\tf[0] = 1;\n\t\tsum[0][0] = sum[0][1] = 1;\n\t\tfor(int i=2; i<=n; i++)\n\t\t{\n\t\t\tf[i] = sum[0][i-2];\n\t\t\tsum[0][i] = (sum[0][i-1] + f[i]) % MOD;\n\t\t}\n\t\tans = 1;\n\t\tfor(int i=1; i<n; i++) ans = (ans+f[n-i-1]*(i+1)) % MOD;\n\t}\n\telse\n\t{\n\t\tint len = n-1;\n\t\tint pre = 0;\n\t\twhile(str[pre+1] == str[1]) pre++;\n\t\tif(pre&1) cmin(len, pre);\n\t\telse cmin(len, pre*2-1);\n\t\tint cur = 0;\n\t\tfor(int i=pre+1; i<=n+1; i++)\n\t\t{\n\t\t\tif(str[i] != str[1])\n\t\t\t{\n\t\t\t\tif(cur & 1) cmin(len, cur);\n\t\t\t\tcur = 0;\n\t\t\t}\n\t\t\telse cur++;\n\t\t}\n\t\tf[0] = sum[0][0] = 1;\n\t\tfor(int i=1; i<=n; i++)\n\t\t{\n\t\t\tf[i] = (((i-2>=0) ? (sum[i&1][i-2]) : (0)) - ((i-2-len>=0) ? (sum[i&1][i-2-len]) : (0)) + MOD) % MOD;\n\t\t\tsum[i&1][i] = (sum[i&1][i-1] + f[i]) % MOD;\n\t\t\tsum[i&1^1][i] = sum[i&1^1][i-1];\n\t\t}\n\t\tfor(int i=1; i<=len; i++) ans = (ans+f[n-i-1]*(i+1)) % MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define prev azaza\n#define MP make_pair\n#define PB push_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int max_n = 200111, inf = 1000111222;\nconst ll mod = 1000000007;\n\nint n, m;\nstring s;\n\nll dp[max_n];\nll pr[max_n];\nll dp2[max_n];\n\nll solve_allr() {\n    ll ans = 1;\n    dp[1] = 1;\n    dp[2] = 0;\n    ll sum = dp[1];\n    for (int i = 3; i < max_n; ++i) {\n        dp[i] = sum;\n        sum += dp[i - 1];\n        sum %= mod;\n    }\n    for (int len = 1; len < n; ++len) {\n        ans += dp[n - len] * (len + 1);\n        ans %= mod;\n    }\n    return ans;\n}\n\nll solve(int L) {\n    int L1 = L / 2;\n    pr[1] = 1;\n    dp2[1] = 1;\n    for (int i = 2; i < max_n; ++i) {\n        dp2[i] = (pr[i - 1] - pr[max(1, i - L1 - 1) - 1] + 2 * mod) % mod;\n        pr[i] = pr[i - 1] + dp2[i];\n        pr[i] %= mod;\n    }\n    dp[1] = 1;\n    for (int i = 3; i < max_n; i += 2) {\n        dp[i] = dp2[i / 2 + 1];\n    }\n    ll ans = 0;\n    for (int len = 1; len <= min(L, n - 1); len += 2) {\n        ans += dp[n - len] * (len + 1);\n        ans %= mod;\n    }\n    return ans;\n}\n\nint main()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> m;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (int i = 0; i < s.size(); ++i) {\n            s[i] = (s[i] == 'B' ? 'R' : 'B');\n        }\n    }\n    bool allr = 1;\n    for (char c : s) {\n        if (c == 'B') {\n            allr = 0;\n            break;\n        }\n    }\n    if (allr) {\n        cout << solve_allr() << endl;\n        return 0;\n    }\n    if (n % 2 == 1) {\n        cout << 0 << endl;\n        return 0;\n    }\n    while (s.back() == 'R') {\n        s.pop_back();\n    }\n    int L = 0;\n    int st;\n    for (int i = 0; i < s.size(); ++i) {\n        if (s[i] == 'B') {\n            st = i;\n            break;\n        } else {\n            ++L;\n        }\n    }\n    if (L % 2 == 0) {\n        ++L;\n    }\n    int len = 1;\n    for (int i = st + 1; i < s.size(); ++i) {\n        if (s[i] == s[i - 1]) {\n            ++len;\n        } else {\n            if (s[i] == 'B' && len % 2 == 1) {\n                L = min(L, len);\n            }\n            len = 1;\n        }\n    }\n    cout << solve(L) << endl;\n    return 0;\n}\n\n// think 2:06\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\n#define MN 200000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nchar s[MN+5];\nint g[MN+5],n,m,R,all=1;\nvoid Dp1()//每个都有一个合法相连\n{\n    g[1]=1;int ans=1;\n    for(int i=2;i<=n;++i) g[i]=(g[i-1]+g[i-2])%mod;\n    for(int i=1;i<n;++i) ans=(ans+1LL*(g[i]-g[i-1]+mod)*(n-i+1))%mod;\n    printf(\"%d\",ans);\n}\nvoid Dp2()//长度为奇数且处于[1,R]\n{\n    int ans=0;R=n-1;\n    for(int i=1,j;i<=m;i=j)\n    {\n        for(j=i;j<=m&&s[j]==s[1];++j);\n        if(j>m) break;\n        int len=j-i;\n        if(len&1) R=min(R,len);\n        else R=min(R,len+1);\n        for(;j<=m&&s[j]!=s[1];++j);\n    }\n    g[1]=1;\n    for(int i=3;i<=n;i+=2)\n    {\n        g[i]=(g[i-2]-g[max(0,i-R-3)]+mod)%mod;\n        g[i]=(g[i]+g[i-2])%mod;\n    }\n    for(int i=max(1,n-R);i<=n;i+=2) ans=(ans+1LL*(n-i+1)*(g[i]-g[max(0,i-2)]+mod))%mod;\n    printf(\"%d\",ans);\n}\nint main()\n{\n    R=n=read();m=read();scanf(\"%s\",s+1);\n    for(int i=1;i<=m;++i) if(s[i]!=s[1]) all=0;\n    if(all) Dp1();\n    else (n&1)?puts(\"0\"):(Dp2(),0);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nconst int mo=1000000007;\nconst int N=200005;\nint n,m;\nchar s[N];\nint f[N][2][2];\nvoid solve1(){\n\tf[1][0][0]=f[1][1][1]=1;\n\tFor(i,2,n) For(j,0,1) For(k,0,1) For(l,0,1)\n\t\tif (k|l) f[i][j][l]=(f[i][j][l]+f[i-1][j][k])%mo;\n\tint ans=0;\n\tFor(i,0,1) For(j,0,1)\n\t\tif (i|j) ans=(ans+f[n][i][j])%mo;\n\tprintf(\"%d\\n\",ans);\n}\nint pre[N];\nint g[N],h[N];\nvoid solve2(){\n\tpre[1]=1;\n\tint mnv=(1<<30);\n\tFor(i,2,m)\n\t\tpre[i]=(s[i]==s[i-1]?pre[i-1]:0)+1;\n\tFor(i,2,m) if (s[i-1]=='R'&&s[i]!='R')\n\t\tif (pre[i-1]%2==0) mnv=min(mnv,pre[i-1]+1);\n\t\telse mnv=min(mnv,pre[i-1]);\n\tg[0]=h[0]=1;\n\tFor(i,1,n){\n\t\tg[i]=((i>=2?h[i-2]:0)+mo-(i>=mnv+3?h[i-mnv-3]:0))%mo;\n\t\th[i]=(g[i]+(i>=2?h[i-2]:0))%mo;\n\t}\n\tint ans=0;\n\tfor (int i=2;i<=min(mnv+1,n);i++)\n\t\tans=(ans+1ll*i*g[n-i])%mo;\n\tprintf(\"%d\\n\",ans);\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tif (s[1]=='B'){\n\t\tFor(i,1,m)\n\t\t\tif (s[i]=='R') s[i]='B';\n\t\t\telse s[i]='R';\n\t}\n\tbool flag=0;\n\tFor(i,1,m) if (s[i]!=s[1]) flag=1;\n\tif (!flag) return solve1(),0;\n\tsolve2();\n}\n/*\n偶数个R||B回到该端点 \n奇数个R||B到达另一端点\n\nRBRBRBRBRB\n\n一段长度为奇数的开头字母 \n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define inf 1010000000\n#define infll 1010000000000000000ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define mpr make_pair\n#define fi first\n#define se second\n#define vi vector<int>\n#define pb push_back\n#define mod 1000000007\n#define ad(x,y) (x=(x+(y))%mod)\n#define up(x,y) (x<(y)?x=(y):0)\n#define dn(x,y) (x>(y)?x=(y):0)\n#define N 200009\nusing namespace std;\n\nint n,m,dp[N][2][2],f[N]; char ch[N]; vi e;\nvoid solve0(){\n\tint i,j,k,l; dp[1][0][0]=dp[1][1][1]=1;\n\tfor (i=2; i<=n; i++)\n\t\tfor (j=0; j<2; j++)\n\t\t\tfor (k=0; k<2; k++)\n\t\t\t\tfor (l=0; k+l<2; l++)\n\t\t\t\t\tad(dp[i][j][l],dp[i-1][j][k]);\n\tprintf(\"%d\\n\",((dp[n][0][0]+dp[n][0][1])%mod+dp[n][1][0])%mod);\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,ch+1);\n\tint i;\n\tif (ch[1]=='B')\n\t\tfor (i=1; i<=m; i++)  ch[i]=(ch[i]=='R'?'B':'R');\n\tfor (i=2; i<=m; i++) if (ch[i]=='B') break;\n\tif (i>m){\n\t\tsolve0(); return 0;\t\t\t\n\t}\n\tmemset(dp,0,sizeof(dp));\n\tfor (i=m; i; i--) if (ch[i]=='B') break;\n\tint lim=n,now=0;\n\tfor (; i>=0; i--){\n\t\tif (!i || ch[i]=='B'){\n\t\t\tif (now) e.pb(now);\n\t\t\tnow=0;\n\t\t} else now++;\n\t}\n\treverse(e.begin(),e.end());\n\tfor (i=0; i<e.size(); i++){\n\t\tif (i==0 && !(e[i]&1)) dn(lim,e[i]+2);\n\t\tif (e[i]&1) dn(lim,e[i]+1);\t\n\t}\n\tf[0]=f[2]=1;\n\tfor (i=3; i<=n; i++)\n\t\tf[i]=((ll)f[i-2]-(i-2-lim>=0?f[i-2-lim]:0)+f[i-2]+mod)%mod;\n\tint ans=0;\n\tfor (i=2; i<=lim; i+=2) ad(ans,(ll)f[n-i]*i);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\ntemplate<typename T>\nstruct BIT {\n    int n;\n    vector<T> dat;\n\n    BIT(int n=0){\n        initialize(n);\n    }\n\n    void initialize(int nin){\n        n = nin;\n        dat.resize(n);\n        for(int i = 0; i<n; i++) dat[i] = 0;\n    }\n\n    T sum(int i){\n        T s = 0;\n        while(i >= 0){\n            add(s, dat[i]);\n            i = (i & (i+1)) - 1;\n        }\n        return s;\n    }\n\n    T sum_between(int i, int j){\n        int64_t res = sum(j);\n        if(i>0) add(res, MOD - sum(i-1));\n        return res;\n    }\n\n    void plus(int i, T x){\n        while(i < n){\n            add(dat[i], x);\n            i |= i+1;\n        }\n    }\n\n    // a[0]+...+a[ret] >= x\n    int lower_bound(T x){\n        int ret = -1;\n        int k = 1;\n        while(2*k <= n) k <<= 1;\n        for( ;k>0; k>>=1){\n            if(ret+k < n && dat[ret+k] < x){\n                x -= dat[ret+k];\n                ret += k;\n            }\n        }\n        return ret + 1;\n    }\n};\n\nvoid solve1(int N){\n    static int64_t dp[200001][2][2] = {0};\n    dp[0][0][0] = dp[0][1][1] = 1;\n    for(int i=0; i<N-1; i++){\n        for(int j=0; j<2; j++){\n            add(dp[i+1][0][j], dp[i][0][j] + dp[i][1][j]);\n            add(dp[i+1][1][j], dp[i][0][j]);\n        }\n    }\n    int64_t ans = (dp[N-1][0][0] + dp[N-1][1][0] + dp[N-1][0][1]) % MOD;\n    cout << ans << endl;\n    exit(0);\n}\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    if(S[0] == 'B'){\n        for(int i=0; i<M; i++) S[i] = (S[i] == 'B' ? 'R' : 'B');\n    }\n\n    int mn = 0;\n    for(int i=0; i<M; i++){\n        if(S[i] == 'R'){\n            mn++;\n        }else{\n            break;\n        }\n    }\n    if(mn == M){\n        solve1(N);\n    }\n    if(N%2){\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int lim = (mn/2+1)*2;\n    BIT<int64_t> bit(N+1);\n    bit.plus(0, 1);\n    for(int i=2; i<=N; i+=2){\n        int l = max(0, i-lim);\n        int64_t res = bit.sum_between(l, i-1);\n        bit.plus(i, res);\n    }\n\n    int64_t ans = 0;\n    for(int i=1; i<=min(N-1, lim-1); i+=2){\n        add(ans, (i+1) * bit.sum_between(N-i-1, N-i-1) % MOD);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inv(x) power(x,Mod-2)\n#define NO() {puts(\"0\");return 0;}\nusing namespace std;\ntypedef long long ll;\nconst int Mod=1e9+7;\nint add(int a,const int b){a+=b;if(a>=Mod)a-=Mod;return a;}\nint sub(int a,const int b){a-=b;if(a<0)a+=Mod;return a;}\nint mul(const int a,const int b){return (ll)a*b%Mod;}\nint power(int x,int cs)\n{\n\tint ras=1;\n\twhile(cs)\n\t{\n\t\tif(cs&1) ras=mul(ras,x);\n\t\tx=mul(x,x);cs>>=1;\n\t}\n\treturn ras;\n}\nconst int N=2e5+50;\nint n,m,tag=0,mx,ans=0;\nchar s[N];\nint val[N],dp[N],sum[N];\nint q(int l,int r)\n{\n\tif(l>r) return 0;\n\tint ras=sum[r];\n\tif(l!=0) ras=sub(ras,sum[l-1]);\n\treturn ras;\n}\nint main()\n{\n\t\n\tint i,x,pos;\n\tscanf(\"%d%d\",&n,&m);\t\n\t\n\tscanf(\"%s\",s+1);\n\tif(s[1]=='B') tag=1;\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tif(s[i]=='R') val[i]=(1^tag);\n\t\telse val[i]=(0^tag);\n\t}\n\tfor(x=1;x<=m&&val[x]==1;x++);\n\tx--;\n\tif(x==m)\n\t{\n\t\tmx=n;ans=1;\n\t\tdp[0]=1;sum[0]=1;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tdp[i]=q(max(i-mx,0),i-2);\n\t\t\tsum[i]=add(sum[i-1],dp[i]);\n\t\t}\n\t\t//printf(\"%d %d\\n\",dp[1],dp[2]);\n\t\tfor(i=2;i<=mx;i++)\n\t\t{\n\t\t\tans=add(ans,mul(i,dp[n-i]));\n\t\t}\n\t}\n\telse\n\t{\n\t\tif(n&1) NO();\n\t\tif(x&1) mx=x;\n\t\telse mx=x+1;\n\t\tfor(i=x+1;i<=m;)\n\t\t{\n\t\t\tif(val[i]==0) \n\t\t\t{\n\t\t\t\ti++;continue;\n\t\t\t}\n\t\t\tpos=i;\n\t\t\twhile(val[pos]==1) pos++;\n\t\t\tpos--;\n\t\t\tif(pos==m) break;\n\t\t\tif((pos-i+1)&1) mx=min(mx,pos-i+1);\n\t\t\ti=pos+1;\n\t\t}\n\t\tn=(n+1)/2;mx=(mx+1)/2;\n\t\tdp[0]=1;sum[0]=1;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tdp[i]=q(max(i-mx,0),i-1);\n\t\t\tsum[i]=add(sum[i-1],dp[i]);\n\t\t}\n\t\tfor(i=1;i<=mx;i++)\n\t\t{\n\t\t\tans=add(ans,mul(i<<1,dp[n-i]));\n\t\t}\n\t}\n\t//printf(\"n%d mx%d\\n\",n,mx);\n\t\n\t\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst ll MOD = 1e9 + 7;\n\nint N, M;\nstring S;\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N >> M >> S;\n\tif (S[0] == 'B') {\n\t\tfor (char& c : S) {\n\t\t\tc ^= 'B' ^ 'R';\n\t\t}\n\t}\n\tassert(S[0] == 'R');\n\n\tif (S == string(M, S[0])) {\n\t\t// there are no consecutive Bs\n\t\tarray<array<ll, 2>, 2> dp = {};\n\t\tdp[0][0] = dp[1][1] = 1;\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tarray<array<ll, 2>, 2> ndp = {};\n\t\t\tfor (int a = 0; a < 2; a++) {\n\t\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\t\tfor (int c = 0; c < 2; c++) {\n\t\t\t\t\t\tif (b || c) {\n\t\t\t\t\t\t\tndp[a][c] = (ndp[a][c] + dp[a][b]) % MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(dp, ndp);\n\t\t}\n\n\t\tll ans = 0;\n\t\tfor (int a = 0; a < 2; a++) {\n\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\tif (a || b) {\n\t\t\t\t\tans = (ans + dp[a][b]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\n\tif (N % 2 == 1) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tbool foundBlue = false;\n\tint maxRed = N-1;\n\tint cntRed = 0;\n\tfor (char c : S) {\n\t\tif (c == 'R') {\n\t\t\tcntRed++;\n\t\t} else {\n\t\t\tassert(c == 'B');\n\t\t\tif (foundBlue) {\n\t\t\t\tif (cntRed % 2 == 1) {\n\t\t\t\t\tmaxRed = min(maxRed, cntRed);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmaxRed = min(maxRed, cntRed + 1);\n\t\t\t}\n\t\t\tfoundBlue = true;\n\t\t\tcntRed = 0;\n\t\t}\n\t}\n\n\tassert(maxRed >= 1);\n\tmaxRed = (maxRed + 1) / 2;\n\tN /= 2;\n\n\tvector<ll> dp(N+1);\n\tdp[0] = 1;\n\tll sum = dp[0];\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (i - maxRed - 1 >= 0) sum = (sum - dp[i - maxRed - 1] + MOD) % MOD;\n\t\tdp[i] = sum;\n\t\tsum = (sum + dp[i]) % MOD;\n\t}\n\n\tll ans = 0;\n\tfor (int i = 1; i <= maxRed; i++) {\n\t\tans = (ans + i * dp[N - i]) % MOD;\n\t}\n\tans = ans * 2 % MOD;\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\n#define debug(x)//  cerr << #x << \" = \" << x << endl\ntypedef long long ll;\nconst ll MAX_N = 2e5+100;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    lim = min(lim,(ll)n-1);\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    for(ll i = 1;i<=lim;i+=2)\n    {\n        ans += ((i+1)*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    int mn = 1e9;\n    if (vc[0]%2==0)\n        mn = vc[0]+1;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=a*b%mod\n\nll n,m;\nstring s;\nll f[200010],rui[200010];\n\nint main(){\n    cin>>n>>m>>s;\n    if(s[0]=='R'){\n\tfor(int i=0;i<m;i++){\n\t    if(s[i]=='R')s[i]='B';\n\t    else s[i]='R';\n\t}\n    }\n    bool th=0;\n    ll cnt=0,mi=1e17;\n    bool fi=1; ll lead;\n    for(int i=0;i<m;i++){\n\tif(s[i]=='R'){\n\t    if(fi)lead=cnt; fi=0;\n\t    th=1;\n\t    if(cnt%2==1)chmin(mi,cnt);\n\t    cnt=0;\n\t}\n\telse cnt++;\n    }\n    \n    if(th==0){\n\tf[0]=f[1]=1;\n\tfor(int i=2;i<n;i++){\n\t    f[i]=(f[i-1]+f[i-2])%mod;\n\t}\n\tll ans=(f[n-2]*2+f[n-1])%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n    }\n    if(n%2==1){\n\tcout<<0<<endl;\n\treturn 0;\n    }\n    \n    if(lead%2==0)lead++;\n    chmin(mi,lead);\n    mi=(mi+1)/2;\n    chmin(mi,n/2);\n    f[0]=rui[0]=0;\n    for(ll i=1;i<=mi;i++){\n\tf[i]=i;\n    }\n    for(int i=1;i<n/2;i++){\n\tmad(f[i],rui[i-1]);\n\tif(i-mi-1>=0)mad(f[i],-rui[i-mi-1]);\n\trui[i]=(rui[i-1]+f[i])%mod;\n    }\n    ll ans=0;\n    for(int i=1;i<=mi;i++)mad(ans,f[n/2-i]);\n    //cout<<mi<<endl;\n    //for(int i=0;i<n/2;i++)cout<<i<<\":\"<<f[i]<<endl;\n    ans=ans*2%mod;\n    if(mi==n/2)mad(ans,n);\n    if(ans<0)ans+=mod;\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll dp[202020][2][2];\nll mo=1000000007;\n\nll dp2[202020];\nll dps[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\tif(S[0]=='B') {\n\t\tFORR(c,S) c='R'+'B'-c;\n\t}\n\tif(count(ALL(S),'B')==0) {\n\t\tdp[0][0][0]=dp[0][1][1]=1;\n\t\tfor(i=1;i<N;i++) {\n\t\t\t(dp[i][0][0]=dp[i-1][0][0]+dp[i-1][0][1])%=mo;\n\t\t\t(dp[i][0][1]=dp[i-1][0][0])%=mo;\n\t\t\t(dp[i][1][0]=dp[i-1][1][0]+dp[i-1][1][1])%=mo;\n\t\t\t(dp[i][1][1]=dp[i-1][1][0])%=mo;\n\t\t}\n\t\tcout<<(dp[N-1][0][0]+dp[N-1][0][1]+dp[N-1][1][0])%mo<<endl;\n\t\treturn;\n\t}\n\twhile(S.back()=='B') S.pop_back(), M--;\n\tint L=0;\n\twhile(S[L]=='R') L++;\n\t\n\tdp2[0]=dps[0]=dps[1]=1;\n\tfor(i=2;i<=N;i++) {\n\t\tif(i%2==0) {\n\t\t\tdp2[i]=dps[i-2];\n\t\t\tif(i-(L+1)>=0) dp2[i]+=mo-dps[i-(L+1)];\n\t\t\tdp2[i]%=mo;\n\t\t}\n\t\t(dps[i]=dps[i-1]+dp2[i])%=mo;\n\t\t//cout<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=min(L,N-1);i++) {\n\t\t//cout<<i<<\" \"<<(i+1)<<\"*\"<<dp2[N-(i+1)]<<endl;\n\t\t(ret+=(i+1)*dp2[N-(i+1)])%=mo;\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nll dp[1 << 18][2][2];\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (s[0] == 'B') {\n\t\trep(i, m) {\n\t\t\tif (s[i] == 'B')s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\tvector<int> v;\n\trep(i, m) {\n\t\tint le = i;\n\t\twhile (i + 1 < m&&s[i + 1] == s[i])i++;\n\t\tv.push_back(i - le + 1);\n\t}\n\tif (v.size() == 1) {\n\t\tdp[0][0][0] = 1;\n\t\tdp[0][1][1] = 1;\n\t\trep(i, n - 1) {\n\t\t\trep(j, 2) {\n\t\t\t\t(dp[i + 1][0][j] += dp[i][0][j] + dp[i][1][j]) %= mod;\n\t\t\t\tdp[i + 1][1][j] += dp[i][0][j];\n\t\t\t}\n\t\t}\n\t\tll ans = dp[n - 1][0][0] + dp[n - 1][1][0] + dp[n - 1][0][1];\n\t\tcout << ans % mod << endl; return;\n\t}\n\tif (n % 2) {\n\t\tcout << 0 << endl; return;\n\t}\n\tfor (int i = 0; i < v.size(); i += 2) {\n\t\tif (v[i] % 2) {\n\t\t\tif (n % 2) {\n\t\t\t\tcout << 0 << endl; return;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << 2 << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tint d = n / 2;\n\tint x = v[0] / 2 + 1;\n\tif (x >= d+1) {\n\t\tll ans = mod_pow(2, d) - 1;\n\t\tans = ans * 2;\n\t\tans = (ans + mod) % mod;\n\t\tcout << ans << endl;\n\t}\n\telse {\n\t\tll ans = d * mod_pow(2, d - x - 1) % mod;\n\n\t\tans = mod_pow(2, d) - 1 - ans;\n\t\tans = (ans%mod + mod) % mod;\n\t\tcout << ans * 2 % mod << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200233, mod = 1000000007;\nint n, m, f[N];\nchar s[N];\n\nint main() {\n  scanf(\"%d%d%s\", &n, &m, s + 1);\n  if (*min_element(s + 1, s + 1 + m) == *max_element(s + 1, s + 1 + m)) {\n    int x = 2, y = 1;\n    for (int i = 1; i <= n; i++) {\n      y = (y + x) % mod;\n      x = (mod + y - x) % mod;\n    }\n    printf(\"%d\\n\", x);\n    return 0;\n  }\n  int limit, x = 1;\n  while (x + 1 <= m && s[x + 1] == s[1]) x++;\n  limit = x | 1;\n  for (int i = x + 1, j = 0; i <= m; i++) {\n    if (s[i] != s[1]) {\n      if (j & 1) limit = min(limit, j);\n      j = 0;\n    } else {\n      ++j;\n    }\n  }\n  if (n & 1) {\n    puts(\"0\");\n    return 0;\n  }\n  n >>= 1;\n  limit = min(n, (limit + 1) >> 1);\n  f[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    f[i] = ((long long) mod + f[i - 1] + f[i - 1] - (i > limit ? f[i - limit - 1] : 0)) % mod;\n  }\n  int ans = 0;\n  for (int i = 1; i <= limit; i++) {\n    ans = (ans + (long long) (mod + f[n - i] - (n > i ? f[n - i - 1] : 0)) * i * 2) % mod;\n  }\n  printf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ri register int\ntypedef long long ll;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// input a letter\n\ttemplate <class I>\n\tinline void get (I &x) {\n\t\tfor (c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tx = c;\n\t}\n\t// input a string\n\tinline void read (char *s){\n\t\tfor(c = gc(); c < 'A' || c > 'Z'; c = gc()) ;\n\t\tfor(; c >= 'A' && c <= 'Z'; c = gc()) *++s = c;\n\t\t*++s = '\\0';\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: get;\nusing io :: read;\nusing io :: putc;\nusing io :: print;\nconst int N=2e5+5,mod=1e9+7,inf=2e9; \nchar s[N];\nint n,f[N]; \ninline int solve0(ri n){\n\t// f[i] 表示 col_i = R 1 ~ i 的染色方案\n\tf[1]=1; // 强制钦定 col_1 = R \n\tfor(ri i=2;i<=n;++i) f[i]=(f[i-1]+f[i-2])%mod;\n\t// BR...R f[n-1]\n\t// R...RB f[n-1]\n\t// R....R f[n]\n\treturn ((ll)f[n-1]+f[n-1]+f[n])%mod;\n}\nint pre[N]; \ninline int solve1(ri r){\n\t// f[i] 表示 col_i = B 1 ~ i的染色方案 \n\tri i,ans;\n\tfor(i=1;i<=n/2;++i){\n\t\tif(i<=r/2) f[i]=1;\n\t\tf[i]=((ll)f[i]+pre[i-1]-pre[max(0,i-r/2-1)]+mod)%mod;\n\t\tpre[i]=(pre[i-1]+f[i])%mod;\n\t}\n\t// 首先考虑只有一个 B 的情况\n\tif(n<=r)\n\t\tans=n;\n\telse\n\t\tans=0;\n\tfor(i=0;i+1<=n&&i+1<=r;++i) // 枚举 1 ~ i 都为 R \n\t\tans=((ll)ans+pre[max(0,(n-i-1)/2)]-pre[max(0,(n-r)/2-1)]+mod)%mod; \n\treturn ans;\n}\nint main(){\n\tri m,i,j,flag,r;\n\tgi(n);gi(m);\n\tread(s);\n\tif(s[1]=='B'){\n\t\tfor(i=1;i<=m;++i)\n\t\t\ts[i]=s[i]=='B'?'R':'B';\n\t}\n\tflag=1;\n\tfor(i=1;i<=m;++i)\n\t\tif(s[i]!='R'){\n\t\t\tflag=0;\n\t\t\tbreak;\n\t\t}\n\tif(flag)\n\t\treturn printf(\"%d\\n\",solve0(n)),0;\n\tif(n&1) return puts(\"0\"),0;\n\tr=inf;\n\tfor(i=1;i<=m;++i){\n\t\tif(s[i]!='R') continue;\n\t\tfor(j=i;j+1<=m&&s[j+1]=='R';++j);\n\t\tif(i==1) r=min(r,j-i+1+1);\n\t\telse if(j==m) continue;\n\t\telse if(j-i+1&1) r=min(r,j-i+1);\n\t\ti=j;\n\t}\n\tif(~r&1) --r;\n\tprintf(\"%d\\n\",solve1(r+1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define int long long\nusing namespace std;\nconst int N=2e5+2;\nconst int mod=1e9+7;\nint dp[N],sum[N];\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,max1,ans=0,m;\n\tstring s;\n\tcin>>n>>m>>s;\n\tif(s[0]=='B'){\n\t\tfor(i=0;i<m;i++){\n\t\t\tif(s[i]=='B'){\n\t\t\t\ts[i]='R';\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts[i]='B';\n\t\t\t}\n\t\t}\n//\t\tcout<<s<<endl;\n\t}\n\tbool cac=true;\n\tfor(i=1;i<m;i++){\n\t\tif(s[i]!=s[i-1]){\n\t\t\tcac=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(cac){\n//\t\tcout<<0<<endl;\n\t\tdp[0]=1;\n\t\tsum[0]=1;\n\t\tans=1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(i!=1){\n\t\t\t\tdp[i]=sum[i-2];\n\t\t\t}\n\t\t\tsum[i]=sum[i-1]+dp[i];\n\t\t\tif(sum[i]>=mod){\n\t\t\t\tsum[i]-=mod;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n-1;i++){\n\t\t\tans+=(i+1)*dp[n-i-1];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout<<ans;\n\t}\n\telse{\n\t\tif(n&1){\n\t\t\tcout<<0;\n\t\t\treturn 0;\n\t\t}\n\t\tmax1=n-1;\n\t\tcac=true;\n\t\tj=1;\n\t\tfor(i=1;i<m;i++){\n\t\t\tif(s[i]==s[i-1]){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(s[i]=='B'){\n\t\t\t\t\tif(cac){\n\t\t\t\t\t\tif(j&1){\n\t\t\t\t\t\t\tmax1=min(max1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmax1=min(max1,j+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcac=false;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(j&1){\n\t\t\t\t\t\t\tmax1=min(max1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj=1;\n\t\t\t}\n\t\t}\n\t\tdp[0]=1;\n\t\tsum[0]=1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tsum[i]=sum[i-1];\n\t\t\tif(i&1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i]=sum[i-2];\n\t\t\tif(i-max1-2>=0){\n\t\t\t\tdp[i]-=sum[i-max1-2];\n\t\t\t\tif(dp[i]<0){\n\t\t\t\t\tdp[i]+=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum[i]+=dp[i];\n\t\t\tif(sum[i]>=mod){\n\t\t\t\tsum[i]-=mod;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=max1;i+=2){\t\n\t\t\tans+=(i+1)*dp[n-i-1];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout<<ans;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define int long long\nusing namespace std;\nconst int N=2e5+2;\nconst int mod=1e9+7;\nint dp[N],sum[N];\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,max1,ans=0,m;\n\tstring s;\n\tcin>>n>>m>>s;\n\tif(s[0]=='B'){\n\t\tfor(i=0;i<m;i++){\n\t\t\tif(s[i]=='B'){\n\t\t\t\ts[i]='R';\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts[i]='B';\n\t\t\t}\n\t\t}\n//\t\tcout<<s<<endl;\n\t}\n\tbool cac=true;\n\tfor(i=1;i<m;i++){\n\t\tif(s[i]!=s[i-1]){\n\t\t\tcac=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(cac){\n\t\tcout<<1/0<<endl;\n\t\tdp[0]=1;\n\t\tsum[0]=1;\n\t\tans=1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(i!=1){\n\t\t\t\tdp[i]=sum[i-2];\n\t\t\t}\n\t\t\tsum[i]=sum[i-1];\n\t\t\tsum[i]+=dp[i];\n\t\t\tif(sum[i]>=mod){\n\t\t\t\tsum[i]-mod;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n-1;i++){\n\t\t\tans+=(i+1)*dp[n-i-1];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout<<ans;\n\t}\n\telse{\n\t\tif(n&1){\n\t\t\tcout<<0;\n\t\t\treturn 0;\n\t\t}\n\t\tmax1=n-1;\n\t\tcac=true;\n\t\tj=1;\n\t\tfor(i=1;i<m;i++){\n\t\t\tif(s[i]==s[i-1]){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(s[i]=='B'){\n\t\t\t\t\tif(cac){\n\t\t\t\t\t\tif(j&1){\n\t\t\t\t\t\t\tmax1=min(max1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmax1=min(max1,j+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcac=false;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(j&1){\n\t\t\t\t\t\t\tmax1=min(max1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj=1;\n\t\t\t}\n\t\t}\n\t\tdp[0]=1;\n\t\tsum[0]=1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tsum[i]=sum[i-1];\n\t\t\tif(i&1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i]=sum[i-2];\n\t\t\tif(i-max1-2>=0){\n\t\t\t\tdp[i]-=sum[i-max1-2];\n\t\t\t\tif(dp[i]<0){\n\t\t\t\t\tdp[i]+=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum[i]+=dp[i];\n\t\t\tif(sum[i]>=mod){\n\t\t\t\tsum[i]-=mod;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=max1;i+=2){\t\n\t\t\tans+=(i+1)*dp[n-i-1];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout<<ans;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nint Mn(int a,int b){return a<b?a:b;}\nconst int N=2e5+5,mod=1e9+7;\nint upt(int x){while(x>=mod)x-=mod;while(x<0)x+=mod;return x;}\n\nint n,m,lm,dp[N],sm[N],ans,f[N][5];\nchar s[N];\nvoid solve()\n{\n  f[1][0]=1;\n  for(int i=2;i<=n;i++)\n    {\n      f[i][0]=f[i-1][0];\n      f[i][1]=upt(f[i-1][1]+f[i-1][2]);\n      f[i][2]=upt(f[i-1][0]+f[i-1][1]);\n    }\n  int ans=(f[n][0]+upt(f[n][1]+f[n][2]));\n  f[1][2]=1; f[1][0]=f[1][1]=0;\n  for(int i=2;i<=n;i++)\n    {\n      f[i][1]=upt(f[i-1][1]+f[i-1][2]);\n      f[i][2]=f[i-1][1];\n    }\n  ans=upt(ans+f[n][1]); printf(\"%d\\n\",ans);\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&m);\n  scanf(\"%s\",s+1); bool fg=0;\n  for(int i=1;i<=m;i++)\n    if(s[i]!=s[1]){fg=1;break;}\n  if(!fg){solve();return 0;}\n  if(n&1){puts(\"0\");return 0;}\n  lm=n+1; int lst;\n  for(int i=m;i;i--)if(s[i]==s[1]){lst=i;break;}\n  for(int i=1;i<=m;i++)\n    if(s[i]==s[1])//== not !=\n      {\n\tint j=i;\n\twhile(j+1<=m&&s[j+1]==s[j])j++;\n\tswap(i,j); j=i-j+1;\n\tif(i-j==0) lm=Mn(lm,j+((j&1)==0));\n\telse if((j&1)&&i!=lst)lm=Mn(lm,j);//i!=lst!!!\n      }\n  n>>=1; lm=(lm+1)>>1; dp[0]=sm[0]=1;\n  for(int i=1;i<=n;i++)\n    {\n      dp[i]=sm[i-1]; if(i>lm)dp[i]=upt(dp[i]-sm[i-lm-1]);\n      sm[i]=upt(sm[i-1]+dp[i]);\n    }\n  int ans=0;\n  for(int i=1;i<=lm;i++)//lm not n\n    ans=(ans+(ll)i*2*dp[n-i])%mod;\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nconst int inf = 0x3f3f3f3f;\n#define Rep(i,a,b) for(register int i=(a);i<=int(b);++i)\n#define Dep(i,a,b) for(register int i=(a);i>=int(b);--i)\n#define rep(i,a,b) for(register int i=(a);i<int(b);++i)\n#define mem(x,v) memset(x,v,sizeof(x))\n#define fi first\n#define se second\n#define lowbit(x) ((x)&-(x))\n#define debug(x) cout << #x \" = \" << x << endl;\nnamespace IO{\n\tconst int L = 1 << 15;\n\tchar ibuf[L|1],*iS=ibuf,*iT=ibuf;\n\tchar obuf[L|1],*oS=obuf,*oT=obuf+L;\n\tchar c,st[66];int tp=0,f;\n\tinline char gc(){\n\t\tif(iS==iT) iT=(iS=ibuf)+fread(ibuf,sizeof(char),L,stdin);\n\t\treturn (*iS++);\n\t}\n\tinline void flush() {\n\t\tfwrite(obuf,sizeof(char),oS-obuf,stdout);\n\t\toS = obuf;\n\t}\n\tinline void pc(char c){*oS++=c;if(oS==oT) flush();}\n\t#define gc getchar\n\t#define pc putchar\n\tinline ll read(){\n\t\tll x=0;f=1,c=gc();\n\t\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\t\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c&15);\n\t\treturn x*f;\n\t}\n\tvoid write(ll x){\n\t\tif(!x) pc('0');if(x<0) pc('-'),x=-x;\n\t\twhile(x) st[++tp]=x%10+'0',x/=10;\n\t\twhile(tp) pc(st[tp--]);\n\t}\n\tvoid wri(ll x){write(x);pc(' ');}\n\tvoid writeln(ll x){write(x);pc('\\n');}\n\tstruct IOflusher{~IOflusher(){flush();}}_ioflusher_;\n}\nusing IO::read;\nusing IO::writeln;\nusing IO::wri;\ninline void gg(string s){cout << s << endl;exit(0);}\ninline void gg(ll x){writeln(x);exit(0);}\nconst int maxn = 2e5+233;\nconst int mod = 1e9+7;\nint n,m,k,f[maxn],ans;char s[maxn];\nint main(){\n#ifdef LOCAL\n\tfreopen(\"1.in\",\"r\",stdin);\n#endif\n\t\n\tn = read(),m = read();\n\tscanf(\"%s\",s + 1);\n\tk = n;while(m && s[m]==s[1])--m;\n\tif(!m) ans = 1;\n\tfor(int i=1,j=1;i<=m;i=j+1){\n\t\tj = i;\n\t\tif(s[i]==s[1]){\n\t\t\twhile(j<m&&s[j+1]==s[1]) ++j;\n\t\t\tif(i==1){\n\t\t\t\tif((j-i+1)&1) k=min(k,j-i+1); else k=min(k,j-i+2);\n\t\t\t}else{\n\t\t\t \tif((j-i+1)&1) k=min(k,j-i+1);\n\t\t\t}\n\t\t}\n\t}\n\tif(k==n){\n\t\tfor(int i=f[0]=1,j=0;i<=n;++i){\n\t\t\tf[i] = j;\n\t\t\tj = (j + f[i-1]) % mod;\n\t\t}\n\t\tRep(i,2,n){\n\t\t\tans = (ans + 1ll * i * f[n-i]) % mod;\n\t\t}\n\t} else{\n\t\t++k;\n\t\tfor(int i=2,j=f[0]=1;i<=n;i+=2){\n\t\t\tf[i] = j;\n\t\t\tj = (j + f[i]) % mod;\n\t\t\tif(i>=k) j = (j - f[i-k] + mod) % mod;\n\t\t}\n\t\tfor(int i=2;i<=k;i+=2) ans = (ans + 1ll * i * f[n-i]) % mod;\n\t}writeln(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nconst int mo=1000000007;\nconst int N=200005;\nint n,m;\nchar s[N];\nint f[N][2][2];\nvoid solve1(){\n\tf[1][0][0]=f[1][1][1]=1;\n\tFor(i,2,n) For(j,0,1) For(k,0,1) For(l,0,1)\n\t\tif (k|l) f[i][j][l]=(f[i][j][l]+f[i-1][j][k])%mo;\n\tint ans=0;\n\tFor(i,0,1) For(j,0,1)\n\t\tif (i|j) ans=(ans+f[n][i][j])%mo;\n\tprintf(\"%d\\n\",ans);\n}\nint pre[N];\nint g[N],h[N];\n\nvoid solve2(){\n\tpre[1]=1;\n\tint mnv=(1<<30);\n\tFor(i,2,m)\n\t\tpre[i]=(s[i]==s[i-1]?pre[i-1]:0)+1;\n\tFor(i,2,m) if (s[i-1]=='R'&&s[i]!='R')\n\t\tif (pre[i-1]%2==0) mnv=min(mnv,pre[i-1]+1);\n\t\telse mnv=min(mnv,pre[i-1]);\n\tg[0]=h[0]=1;\n\tFor(i,1,n){\n\t\tg[i]=((i>=2?h[i-2]:0)+mo-(i>=mnv+3?h[i-mnv-3]:0))%mo;\n\t\th[i]=(g[i]+(i>=2?h[i-2]:0))%mo;\n\t}\n\tint ans=0;\n\tfor (int i=2;i<=min(mnv+1,n);i+=2)\n\t\tans=(ans+1ll*i*g[n-i])%mo;\n\tprintf(\"%d\\n\",ans);\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tif (s[1]=='B'){\n\t\tFor(i,1,m)\n\t\t\tif (s[i]=='R') s[i]='B';\n\t\t\telse s[i]='R';\n\t}\n\tbool flag=0;\n\tFor(i,1,m) if (s[i]!=s[1]) flag=1;\n\tif (!flag) return solve1(),0;\n\tsolve2();\n}\n/*\n偶数个R||B回到该端点 \n奇数个R||B到达另一端点\n\nRBRBRBRBRB\n\n一段长度为奇数的开头字母 \n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define Pr(f,...) printf(f,##__VA_ARGS__),fflush(stdout)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define lop(i,s,t) for(int i=s;i<(t);++i)\nusing namespace std; \n\nconst int N=200050,P=1e9+7; \n\nint n,m,limit,f[N],sum[N]; \nchar s[N]; \n\nint main(int argc,char *argv[]){\n\t//freopen(\"d.in.cpp\",\"r\",stdin); \n    scanf(\"%d%d%s\",&n,&m,s); \n    if(s[0]=='B')lop(i,0,m)s[i]=s[i]=='R'?'B':'R';\n\t//Pr(\"%d,%d,%s\\n\",n,m,s);  \n    while(m&&s[m-1]=='R')--m;\n    if(m==0){\n    \tf[0]=2,f[1]=1;\n\t\trep(i,2,n)f[i]=(f[i-1]+f[i-2])%P;\n\t\tprintf(\"%d\\n\",f[n]); \n\t\treturn 0; \t\n    }\n    if(n%2!=0){\n        puts(\"0\"); \n        return 0; \n    }\n    limit=n-1; \n    for(int p=0,prv=0;p<m;++p){\n        while(p<m&&s[p]=='R')++p;\n\t\tif(prv==0){\n            if(p-prv%2==1)limit=p-prv;\n            else limit=p-prv+1;\n        }\n        if(p-prv%2==1)limit=min(limit,p-prv);\n        prv=p;\n    }          \n\tf[1]=sum[1]=0,f[2]=sum[2]=2;\n\tfor(int i=4;i<=n;i+=2){\n\t\tsum[i-1]=(sum[i-2]+f[i-1])%P;\n\t\tif(i<=limit+1)(f[i]+=i)%=P;\n\t\t(f[i]+=(sum[i-1]-sum[i-limit-2]+P)%P)%=P;\n\t\tsum[i]=(sum[i-1]+f[i])%P;\n\t}\n\tprintf(\"%d\\n\",f[n]); \n    return 0; \n}    "
  },
  {
    "language": "C++",
    "code": "/*\n¼ÙÉèS[1] = R¡£ÄÇÃ´ÏÔÈ»£¬»·ÉÏ²»»á³öÏÖÁ½¸öÁ¬ÐøµÄ±ß¶¼ÊÇB£¬·ñÔòÔÚËüÃÇ½»µã´¦µÚÒ»²½ÍùÁ½±ß×ß¶¼²»ºÏ·¨\nÌØÅÐµôSÖÐÈ«ÊÇRµÄÇé¿ö£¬¿¼ÂÇÒ»°ãÇé¿ö \nÊ×ÏÈ°ÑËùÓÐÊÇBµÄÎ»ÖÃ¶Ï¿ª£¬ÄÇÃ´¾ÍÐÎ³ÉÁËÈô¸É¸öRµÄÁ¬Ðø¶Î¡£¿ÉÒÔ·¢ÏÖÕâÃ´Ò»¸öÐÔÖÊ£ºÃ¿¸öÁ¬Ðø¶ÎµÄ³¤¶È¾ùÎªÆæÊý\nÖ¤Ã÷¿¼ÂÇ·´Ö¤¡£¼ÙÉèÓÐÒ»¸öÅ¼ÊýµÄ¶Î£¬¿¼ÂÇ¶þ·ÖÍ¼¿ÉÒÔ·¢ÏÖ£¬ÄÇÃ´ÓÐµÄµã×ßµ½ÕâÒ»¶ÎµÄ¶Ëµã¾àÀëÓÀÔ¶ÊÇÅ¼Êý¡¢ÓÐµÄµã×ßµ½ÕâÒ»¶ÎµÄ¶Ëµã¾àÀëÓÀÔ¶ÊÇÆæÊý£¬ÒòÎª¶ËµãÍ¬É«\n¶øSµÄµÚÒ»¶ÎÁ¬ÐøR³¤¶ÈÊÇ¹Ì¶¨µÄ£¬²»ÄÜÍ¬Ê±ÎªÅ¼Êý»òÆæÊý£¬Ã¬¶Ü¡£ËùÒÔ¿ÉÒÔµÃµ½½áÂÛ\nÍ¬Ê±£¬SÖÐÃ¿¸öRµÄÁ¬Ðø¶Î¶¼»á¶Ô»·ÉÏÃ¿¸öRµÄÁ¬Ðø¶ÎÓÐ¸öÉÏ½çµÄÏÞÖÆ \n*/\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int Max_NM(200050);\nconst int MOD(1000000000 + 7);\ntypedef long long int LL;\n\nint N, M, L, F[Max_NM], Pre[Max_NM][2], Ans;\nchar S[Max_NM];\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nconstexpr int Sub(int a, int b)\n{\n\treturn a - b < 0 ? a - b + MOD : a - b;\n}\n\nconstexpr int Mult(int a, int b)\n{\n\treturn a * 1LL * b % MOD;\n}\n\ninline void upd(int &a, int b)\n{\n\ta = Add(a, b);\n}\n\nvoid dp(bool have)\n{\n\tF[1] = 1, Pre[1][1 & 1] = 1;\n\tfor (int i = 2, j;i <= N;++i)\n\t{\n\t\tPre[i][0] = Pre[i - 1][0], Pre[i][1] = Pre[i - 1][1];\n\t\tupd(Pre[i][i & 1], F[i - 2]);\n\t\t//jµ½iÊÇR£¬i - j + 1 <= L   =>   j >= i - L + 1\n\t\t//i - j + 1ÊÇÆæÊý£¬i - jÊÇÅ¼Êý£¬iºÍjÆæÅ¼ÐÔÏàµÈ\n\t\tj = max(1, i - L + 1);\n\t\tif (j <= i)\n\t\t{\n\t\t\tF[i] = Sub(Pre[i][i & 1], Pre[j - 1][i & 1]);\n\t\t\tif (have)\n\t\t\t\tupd(F[i], Sub(Pre[i][(i & 1) ^ 1], Pre[j - 1][(i & 1) ^ 1]));\n\t\t}\n\t}\n\t\n}\n\nint main()\n{ \n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tbool haveB = false;\n\tif (S[1] == 'B')\n\t\tfor (int i = 1;i <= M;++i)\n\t\t\tS[i] = 'R' + 'B' - S[i];\n\tfor (int i = 1;i <= M;++i)\n\t\thaveB |= (S[i] == 'B');\n\tL = N;\n\tfor (int i = 1, length = 0, stop = 0;i <= M;++i)\n\t\tif (S[i] == 'B')\n\t\t\tlength = 0, stop = 1;\n\t\telse\n\t\t{\n\t\t\t++length;\n\t\t\tif (i + 1 <= N && S[i + 1] == 'B')\n\t\t\t\tif (stop == 0)\n\t\t\t\t\tif (length & 1)\n\t\t\t\t\t\tL = min(L, length);\n\t\t\t\t\telse\n\t\t\t\t\t\tL = min(L, length + 1);\n\t\t\t\telse\n\t\t\t\t\tif (length & 1)\n\t\t\t\t\t\tL = min(L, length);\n\t\t}\n\tdp(!haveB);\n\tupd(Ans, F[N - 1]);//edge(1, 2) = B\n\tfor (int x = 1, val;x <= L && x < N;++x)//edge(1, 2) = R\n\t{\n\t\tif (haveB && ((x & 1) == 0))\n\t\t\tcontinue;\n\t\tif (x + 1 == N)\n\t\t\tval = 1;\n\t\telse\n\t\t\tval = F[N - x - 2];\n\t\tupd(Ans, Mult(x, val));\n\t}\n\tif ((L & 1) && L == N)\n\t\tupd(Ans, 1);\n\tprintf(\"%d\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mo 1000000007\n#define N 200010\nusing namespace std;\nint n,m,a[N],b[N],nb;\nll dp[N],s[N],ans;\nint main(){\n\tcin>>n>>m;\n\tfor (int i=1;i<=m;i++){char ch=getchar();while (ch!='R'&&ch!='B')ch=getchar();a[i]=(ch=='R');}\n\tfor (int la=0,i=1;i<=m;i++)if (a[i]!=a[1]){b[++nb]=i-la-1;la=i;}\n\tif (nb==0){\n\t\ts[0]=s[1]=ans=1;\n\t\tfor (int i=2;i<n;i++)s[i]=(s[i-1]+s[i-2])%mo;\n\t\tfor (int j=0;j<n-1;j++)ans=(ans+s[j])%mo;ans=(ans+s[n-2])%mo;\n\t}else{\n\t\tint ma=b[1];\n\t\tfor (int i=2;i<=nb;i++)if (b[i]%2)ma=max(ma,b[i]);\n\t\tif (ma%2==0)ma++;ma++;\n\t\tdp[0]=1;s[0]=1;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tif (i%2)dp[i]=0;\n\t\t\telse{dp[i]=s[i-1];if (i-ma-1>=0)dp[i]=(dp[i]-s[i-ma-1]+mo)%mo;}\n\t\t\ts[i]=(s[i-1]+dp[i])%mo;\n\t\t}\n\t\tfor (int j=n-2;j>=0;j-=2)if (n-j<=ma)ans=(ans+dp[j]*(n-j))%mo;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=a*b%mod\n\nll n,m;\nstring s;\nll f[200010],rui[200010];\n\nint main(){\n    cin>>n>>m>>s;\n    if(s[0]=='R'){\n\tfor(int i=0;i<m;i++){\n\t    if(s[i]=='R')s[i]='B';\n\t    else s[i]='R';\n\t}\n    }\n    bool th=0;\n    ll cnt=0,mi=1e17;\n    bool fi=1; ll lead;\n    for(int i=0;i<m;i++){\n\tif(s[i]=='R'){\n\t    if(fi)lead=cnt; fi=0;\n\t    th=1;\n\t    if(cnt%2==1)chmin(mi,cnt);\n\t    cnt=0;\n\t}\n\telse cnt++;\n    }\n    if(cnt%2==1)chmin(mi,cnt);\n    if(th==0){\n\tf[0]=f[1]=1;\n\tfor(int i=2;i<n;i++){\n\t    f[i]=(f[i-1]+f[i-2])%mod;\n\t}\n\tll ans=(f[n-2]*2+f[n-1])%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n    }\n    if(n%2==1){\n\tcout<<0<<endl;\n\treturn 0;\n    }\n    \n    if(lead%2==0)lead++;\n    chmin(mi,lead);\n    mi=(mi+1)/2;\n    chmin(mi,n/2);\n    f[0]=rui[0]=0;\n    for(ll i=1;i<=mi;i++){\n\tf[i]=i;\n\trui[i]=(rui[i-1]+i)%mod;\n    }\n    for(int i=1;i<n/2;i++){\n\tmad(f[i],rui[i-1]);\n\tif(i-mi-1>=0)mad(f[i],-rui[i-mi-1]);\n\trui[i]=(rui[i-1]+f[i])%mod;\n    }\n    ll ans=0;\n    for(int i=1;i<=mi;i++)mad(ans,f[n/2-i]);\n    //cout<<mi<<endl;\n    //for(int i=0;i<n/2;i++)cout<<i<<\":\"<<f[i]<<endl;\n    ans=ans*2%mod;\n    if(ans<0)ans+=mod;\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#define N 201000\ntypedef long long ll;\ntemplate <typename T> inline void read(T &x) {\n\tx = 0; char c = getchar(); bool flag = false;\n\twhile (!isdigit(c)) { if (c == '-')\tflag = true; c = getchar(); }\n\twhile (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }\n\tif (flag)\tx = -x;\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nconst int inf = 987654321;\ninline void MIN(int &a, int b) {\n\tif (b < a)\ta = b;\n}\nint n, m;\nchar s[N];\nnamespace jzp1 {\n\tll jie[N], jieni[N];\n\tinline ll get_c(int n, int m) {\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\tif (n < 0 || m < 0 || n - m < 0)\treturn 0;\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\treturn jie[n] * jieni[m] % P * jieni[n - m] % P;\n\t}\n\tinline ll quickpow(ll x, int k) {\n\t\tll res = 1;\n\t\twhile (k) {\n\t\t\tif (k & 1)\tres = res * x % P;\n\t\t\tx = x * x % P;\n\t\t\tk >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline void sol() {\n//\t\twhile(1);\n\t\tif (n == 1) { puts(\"1\"); return ; }\n\t\tjie[0] = jieni[0] = 1;\n\t\tint up = n + 1;\n\t\tfor (int i = 1; i <= up; ++i)\tjie[i] = jie[i - 1] * i % P;\n\t\tjieni[up] = quickpow(jie[up], P - 2);\n\t\tfor (int i = up - 1; i; --i)\tjieni[i] = jieni[i + 1] * (i + 1) % P;\n\t\tll res = 0;\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tres = (res + get_c(n - i + 1, i) - get_c(n - i - 1, i - 2)) % P;\n//\t\t\tprintf(\"res = %lld\\n\", res);\n\t\t}\n\t\tprintf(\"%lld\\n\", (res % P + P) % P);\n\t}\n}\nll f[N];\nll sum[N];\nint main() {\n\tread(n), read(m);\n\tscanf(\"%s\", s + 1);\n\tbool flag = false;\n\tfor (int i = 1; i <= m; ++i)\tif (s[i] != s[1]) { flag = true; break; }\n\tif (!flag) { jzp1::sol(); return 0; }\n\tif (n & 1) { puts(\"0\"); return 0; }\n\tint lst = 1, mn = inf;\n\tfor (int i = 2; i <= m + 1; ++i) {\n\t\tif (s[i] != s[1]) {\n\t\t\tif (lst & 1)\tMIN(mn, lst);\n\t\t\tlst = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == s[i - 1])\t++lst;\n\t\telse {\n\t\t\tif (lst & 1) MIN(mn, lst);\n\t\t\tlst = 1;\n\t\t}\n\t}\n\tif (mn == inf) {\n//\t\twhile (1);\n\t\tint memo = 1;\n\t\tfor (int i = 1; s[i] == s[1]; ++i) memo = i;\n\t\tmn = memo + 1;\n\t} else while(1);\n\tn >>= 1;\n\tint k = (mn + 1) >> 1;\n\tMIN(k, n);\n\tf[0] = 1; sum[0] = 1;\n//\tprintf(\"n = %d, k = %d\\n\", n, k);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (i <= k)\tf[i] = sum[i - 1];\n\t\telse f[i] = (sum[i - 1] - sum[i - k - 1]) % P;\n\t\tsum[i] = (sum[i - 1] + f[i]) % P;\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tans += (f[n - i] * i) % P;\n\t}\n\tans = (ans << 1) % P;\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n\n/*\n3 3\nBBB\n//4\n\n1 1\nB\n//1\n\n12 10\nRRRRBRRRRB\n//78\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n#ifdef DEBUG\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n)\\\n\t{cerr << #a << \" = {\";\\\n\tfor(int qwq = (st); qwq <= (n); ++qwq) {\\\n\t\tif(qwq == (st)) cerr << a[qwq];\\\n\t\telse cerr << \", \" << a[qwq];\\\n\t} cerr << \"}\" << endl;}\n#define displayv(v) displaya(v, 0, (int)(v).size() - 1)\n#endif\ntemplate<typename T> bool chmin(T &a, const T &b) { return a > b ? a = b, true : false; }\ntemplate<typename T> bool chmax(T &a, const T &b) { return a < b ? a = b, true : false; }\n\nconst int maxN = 200000 + 233;\nconst LL P = 1000000007;\nint n, m;\nchar s[maxN];\nLL f[maxN];\n\nLL purity() {\n\tLL f00 = 1, f11 = 1, f01 = 0, f10 = 0;\n\t// '11' is not OK\n\tfor(int i = 2; i <= n; ++i) {\n\t\tLL g00 = f00 + f01, g01 = f00,\n\t\t   g10 = f10 + f11, g11 = f10;\n\t\tf00 = g00 % P; f01 = g01;\n\t\tf10 = g10 % P; f11 = g11;\n\t}\n\treturn (f00 + f01 + f10) % P;\n}\n\nLL recur(int lim) {\n\t// sum( x ^ (p + 1) )\n\t// sum( (c + 1) * x ^ (p + 1) )\n//\tdisplay(lim);\n\tmemset(f, 0, sizeof(f));\n\tf[0] = 1; f[1] = 0; f[2] = 1; f[3] = 0;\n\tfor(int i = 4; i <= n; ++i) {\n\t\tf[i] = f[i - 2] * 2 % P;\n\t\tif(i - lim - 3 >= 0) f[i] = (f[i] + P - f[i - lim - 3]) % P;\n\t}\n//\tdisplaya(f, 0, n);\n\tLL ans = 0;\n\tfor(int i = 1; i <= lim; ++i) if(n - i - 1 >= 0)\n\t\t(ans += f[n - i - 1] * (i + 1)) %= P;\n\treturn ans;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> m >> (s + 1);\n\tassert((int)strlen(s + 1) == m);\n\tchar major = s[1], minor = (int)'R' + 'B' - major;\n\tint cons = 0;\n\tint mn = maxN;\n\tfor(int i = 1; i <= m; ++i) {\n\t\tif(s[i] == major) cons++;\n\t\telse chmin(mn, cons | 1), cons = 0, assert(s[i] == minor);\n\t}\n\tif(mn == maxN) cout << purity() << endl;\n\telse cout << recur(mn) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n//#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MaxN = 2e5 + 100;\nconst int Mod = 1e9 + 7;\n\nint dp[MaxN];\nint pref_dp[MaxN];\n\nint small_dp[MaxN][2][2];\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  int N, M;\n  string s;\n  cin >> N >> M >> s;\n\n  if (count(ALL(s), s[0]) == M) {\n    small_dp[1][1][1] = small_dp[1][0][0] = 1;\n    for (int len = 2; len <= N; ++len) {\n      for (int fst : {0, 1}) {\n        // add gut\n        small_dp[len][fst][0] =\n          (small_dp[len - 1][fst][0] + small_dp[len - 1][fst][1]) % Mod;\n        // add no gut\n        small_dp[len][fst][1] = small_dp[len - 1][fst][0];\n      }\n    }\n\n    int ans = 0;\n    for (int x : {0, 1}) {\n      for (int y : {0, 1}) {\n        if (x + y <= 1) {\n          ans = (ans + small_dp[N][x][y]) % Mod;\n        }\n      }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n  }\n\n  if (s[0] != s[1]) {\n    if (N % 2 == 0) {\n      cout << \"2\\n\";\n    } else {\n      cout << \"0\\n\";\n    }\n    return 0;\n  }\n\n  int min_seg_len = N - 1;\n  int cur_len = 0;\n  for (char ch : s) {\n    if (ch == s[0]) {\n      ++cur_len;\n    } else {\n      if (cur_len) { mini(min_seg_len, cur_len); }\n      cur_len = 0;\n    }\n  }\n  //if (cur_len) { mini(min_seg_len, cur_len); }\n\n\n  int answer = 0;\n\n  dp[0] = pref_dp[2] = 1;\n\n  const int min_jump = 2;\n  int max_jump = min_seg_len + 2;\n  // jump must be even as well\n  if (max_jump % 2 == 1) { --max_jump; }\n\n  debug(min_jump, max_jump);\n\n  for (int len = 1; len <= N; ++len) {\n    const int add_from = max(0, len - max_jump);\n    const int add_to = len - min_jump;\n\n    if (add_from <= add_to) {\n      dp[len] = pref_dp[add_to + 2] - pref_dp[add_from];\n      if (dp[len] < 0) { dp[len] += Mod; }\n    }\n\n    debug(len, dp[len]);\n\n    pref_dp[len + 2] = (pref_dp[len] + dp[len]) % Mod;\n  }\n\n  for (int chain_len = 0; chain_len < N; ++chain_len) {\n    const int rem_len = N - chain_len;\n    if (2 <= rem_len && rem_len <= max_jump && rem_len % 2 == 0) {\n      const int coef = dp[chain_len];\n      answer = (answer + (LL)coef * (rem_len )) % Mod;\n    }\n  }\n\n  cout << answer << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1 << 29)\n#define LINF (1LL << 60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt all(Int n) {  // no bb\n  Int rr = 1, bb = 1, rb = 0, br = 0;\n  for (int i = 1; i < n; i++) {\n    Int nrr = (rr + rb) % MOD;\n    Int nbb = br;\n    Int nrb = rr;\n    Int nbr = (bb + br) % MOD;\n    rr = nrr;\n    bb = nbb;\n    rb = nrb;\n    br = nbr;\n  }\n  return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit) {\n  dp[0] = 1;\n  rdp[0] = 1;\n  for (int i = 1; i <= n + 1; i++) {\n    dp[i] =\n        (rdp[i - 1] - ((i - limit - 1) >= 0 ? rdp[i - limit - 1] : 0)) % MOD;\n    if (dp[i] < 0) dp[i] += MOD;\n    rdp[i] = (rdp[i - 1] + dp[i]) % MOD;\n  }\n}\n\nInt solve(Int n, Int limit) {\n  if (n % 2 == 1) return 0;\n  if (limit % 2 != 1) exit(1);\n  limit = (limit + 1) / 2;\n  n /= 2;\n  Int res = 0;\n  calc(n + 10, limit);\n  for (Int i = 1; i <= limit; i++) {\n    if (n - i >= 0)\n      res = (res + (rdp[n - i] - rdp[n - limit - 1] + MOD) * 2) % MOD;\n  }\n  if (res < 0) exit(1);\n  return res % MOD;\n}\n\nint main() {\n  Int n, m;\n  string str;\n  vector<Int> vec;\n  cin >> n >> m;\n  cin >> str;\n  bool allsame = true;\n  for (int i = 0; i < m; i++) allsame &= (str[i] == str[0]);\n  if (allsame) {\n    cout << all(n) << endl;\n    return 0;\n  }\n  for (int i = 0; i < m; i++) vec.push_back(str[i] == str[0]);\n  vec.push_back(0);\n  Int l = 0;\n  while (vec[l] == 1) l++;\n  if (l % 2 == 0) l++;\n  Int limit = l;\n  l = 0;\n  for (int i = 0; i < vec.size(); i++) {\n    if (vec[i] == 1)\n      l++;\n    else {\n      if (l % 2 == 1) limit = min(limit, l);\n      l = 0;\n    }\n  }\n  cout << solve(n, limit) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn = 200111;\nint n, m;\nint cntR=0, cntB=0;\nchar s[maxn];\nint fac[maxn], ifac[maxn];\nll C(int x, int y) {return 1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\nll F(int n, int x)\n{\n\treturn C(n-(x-1), x);\n}\nint dp[maxn];\nint sum[maxn], sum2[maxn];\nint get_sum(int l, int r, int p)\n{\n\tif (l%2!=p) l++;\n\tif (r%2!=p) r--;\n\treturn (sum2[r]-(l>=2?sum2[l-2]:0)+mod)%mod;\n}\nint calc(int lim)\n{\n//\tcerr<<\"calc:\"<<lim<<endl;\n\tassert(lim%2==1);\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(sum, 0, sizeof(sum));\n\tmemset(sum2, 0, sizeof(sum2));\n\tdp[0] = 1;\n\tsum[0] = sum[1] = 1;\n\tsum2[0] = 1;\n\tsum2[1] = 0;\n\tfor (int i=2; i<maxn; i++)\n\t{\n\t\tdp[i] = sum2[i-2];\n\t\tif (i-2-lim-1>=0) dp[i] = (dp[i]-sum2[i-2-lim-1]+mod)%mod;\n\t\tsum[i] = (sum[i-1]+dp[i])%mod;\n\t\tsum2[i] = (sum2[i-2]+dp[i])%mod;\n\t}\n\tll ret = lim>=n&&cntB==0;\n\tfor (int i=1; i<=lim+1&&i<=n; i++)\n\t{\n\t\tint l = max(i, n-(lim-(i-1)))-i;\n\t\tint r = (i==1?n-1-i:n-i);\n//\t\tcerr<<l<<\",\"<<r<<endl;\n//\t\tret = (ret+(sum[r]-(l==0?0:sum[l-1])+mod))%mod;\n\t\tret = (ret+get_sum(l, r, n%2==1))%mod;\n\t}\n\treturn ret;\n}\nint solve()\n{\n//\tcerr<<\"solve:\"<<endl;\n\tvector<int> v;\n\tint lst = 0;\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tif (s[i]=='B')\n\t\t{\n\t\t\tv.PB(lst);\n\t\t\tlst = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlst++;\n\t\t}\n\t}\n\tint lim = 1000000001;\n\tif (v.size()>0) lim = min(lim, v[0]+(v[0]%2==0));\n\tfor (int i=1; i<v.size(); i++) if (v[i]%2==1) lim = min(lim, v[i]);\n\treturn calc(lim);\n}\nint main()\n{\n\t\n\tfac[0] = 1;\n\tfor (int i=1; i<maxn; i++) fac[i] = 1ll*fac[i-1]*i%mod;\n\tfor (int i=0; i<maxn; i++) ifac[i] = qpow(fac[i], mod-2);\n\tgetii(n, m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\ts[i] = getreal();\n\t}\n\tif (s[1]=='B') for (int i=1; i<=m; i++) s[i] ^= 'R'^'B';\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tcntR += s[i]=='R';\n\t\tcntB += s[i]=='B';\n\t}\n\tif (cntR==m)\n\t{\n\t\tint ans = 0;\n\t\tstatic int f[maxn][2];\n\t\tfor (int s=0; s<2; s++)\n\t\t{\n\t\t\tmemset(f, 0, sizeof(f));\n\t\t\tf[1][s] = 1;\n\t\t\tfor (int i=1; i<=n; i++)\n\t\t\t{\n\t\t\t\tfor (int t=0; t<2; t++)\n\t\t\t\t{\n\t\t\t\t\tfor (int k=0; k<2; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (t==0&&k==0) continue;\n\t\t\t\t\t\tf[i+1][k] = (f[i+1][k]+f[i][t])%mod;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = (ans+f[n+1][s])%mod;\n\t\t}\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\tint ans = 0;\n\tans = (ans+solve())%mod;\n//\tcerr<<\"ans=\"<<ans<<endl;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+10;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    lim = min(lim,(ll)n-1);\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    ans = dp[n+1];\n    for(ll i = 1;i<=lim;i+=2)\n    {\n        ans += (i*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    int mn = 1e9;\n    if (vc[0]%2==0)\n    {\n        exit(1);\n        mn = vc[0]+1;\n    }\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; trav(a,x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N,M;\nstring S;\n// if all red / blue: each must be adjacent to at least one red \n// otherwise: red/blue are odds: at most length of smallest odd string \n\nvoid init() {\n    setIO(); re(N,M,S);\n    if (S[0] == 'R') {\n        trav(t,S) {\n            if (t == 'B') t = 'R';\n            else t = 'B';\n        }\n    }\n    int co = 0;\n    trav(t,S) if (t == 'R') co ++;\n    if (co) return;\n    mi fib[200001];\n    fib[0] = fib[1] = 1;\n    FOR(i,2,N+1) fib[i] = fib[i-1]+fib[i-2];\n    ps(fib[N]+fib[N-2]); exit(0);\n}\n\nmi dp[200001];\n\nint main() {\n    init();\n    int maxLen = MOD;\n    // ps(S);\n    bool fst = 1;\n    for (int i = 0; i < sz(S); ) {\n        if (S[i] == 'B') {\n            int I = i; \n            while (i < sz(S) && S[i] == S[I]) i ++;\n            if ((i-I)&1) {\n                ckmin(maxLen,i-I);\n                fst = 0;\n            } else if (fst) ckmin(maxLen,i-I+1);\n            fst = 0;\n        } else i++;\n    }\n    maxLen = (maxLen+1)/2;\n    if (N&1) { ps(0); exit(0); }\n    N /= 2; dp[0] = 1;\n    mi sum(0);\n    FOR(i,1,N+1) {\n        sum += dp[i-1];\n        if (i-maxLen-1 >= 0) sum -= dp[i-maxLen-1];\n        dp[i] = sum;\n    }\n    mi ans(0);\n    F0R(i,N) if (N-i <= maxLen) ans += 2*(N-i)*dp[i];\n    ps(ans);\n    // ps(maxLen);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define pii pair<int, int>\n#define p3i pair<pii, int>\n#define pll pair<ll, ll>\n#define p3l pair<pll, ll>\n#define vi vector<int>\n#define vpii vector<pii>\n#define vp3i vector<p3i>\n#define vpll vector<pll>\n#define vp3l vector<p3l>\n#define lseg L, (L+R)/2, N*2+1\n#define rseg (L+R)/2+1, R, N*2+2\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define MN 1000000007\n#define fox(k, x) for (int k=0; k<x; ++k)\n#define fox1(k, x) for (int k=1; k<=x; ++k)\n#define foxr(k, x) for (int k=x-1; k>=0; --k)\n#define fox1r(k, x) for (int k=x; k>0; --k)\n#define ms multiset\n#define flood(x) memset(x, 0x3f3f3f3f, sizeof x)\n#define drain(x) memset(x, 0, sizeof x)\n#define rng() ((rand() << 14)+rand())\n#define scan(X) do{while((X=getchar())<'0'); for(X-='0'; '0'<=(_=getchar()); X=(X<<3)+(X<<1)+_-'0');}while(0)\nchar _;\n#define pi 3.14159265358979323846\n\nint n, m, dp[200005], psa[200005];\nint sum, ans=0;\nstring s;\nint get(int N, int L){\n  int hi = N;\n  int lo = hi - L - 1;\n  //cout << N << ' ' << L << ' ' <<lo << ' ' << hi << endl;\n  int res = psa[hi];\n  if (lo >= 0) res -= psa[lo];\n  return res;\n}\nint32_t main(){\n  cin >> n >> m >> s;\n  int pref = 0, lim, c = 0;\n  fox(l, m){\n    if (s[l] != s[0]) break;\n    pref++;\n  }\n  if (pref % 2 == 1)\n    lim = pref;\n  else\n    lim = pref + 1;\n  if (pref == m){\n    dp[0] = 1;\n    dp[1] = 1;\n    for(int l = 2; l <= n; ++l){\n      dp[l] = (dp[l-1]+dp[l-2])%MN;\n    }\n    cout << (dp[n-2] + dp[n])%MN;\n    return 0;\n  }\n  if (n%2 == 1){\n    if (pref != m){\n      printf(\"0\\n\");\n      return 0;\n    }\n  }\n  fox(l, m){\n    if (s[l]!=s[0]){\n      if (c%2 == 1){\n        lim = min(lim, c);\n      }\n      c=0;\n    } else {\n      c++;\n    }\n  }\n  if (c%2 == 1){\n    lim = min(lim, c);\n  }\n  n/=2;\n  lim /= 2;\n  dp[0]= 1;\n  int p=0;\n  sum = 1;\n  psa[0] = 1;\n  fox1(l, n){\n    while(l-p-1 > lim){\n      sum = (sum - dp[p]) % MN;\n      ++p;\n    }\n    dp[l] = sum;\n    psa[l] = (psa[l-1] + dp[l]) % MN;\n    sum = (sum + dp[l]) % MN;\n    //cout << dp[l] << ' ';\n  }\n  fox(l, lim+1){\n    //starting component\n    ans = (ans + get(n-1-l, lim-l))%MN;\n  }\n  cout << ans*2%MN;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\nusing namespace std;\n\ntypedef long long li;\n\nconst int mod = 1e9 + 7;\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x -= y; if (x < 0) x += mod; }\ninline int Mul(int x, int y) { return (li)x * y % mod; }\n\n// ----------------------------------------\n\nconst int maxn = 2e5;\n\nint n, m, lim;\nchar s[maxn + 1];\nint dp[maxn + 1];\nint sum[maxn + 2];\n\nvoid GetLim(void) {\n  int cnt = 0;\n  for (int i = 0; i < m; ++i) {\n    if (s[i] == 'R') ++cnt; else break;\n  }\n  if (cnt & 1) lim = cnt; else lim = cnt + 1;\n  cnt = 0;\n  for (int i = 0; i < m; ++i) {\n    if (s[i] == 'R') ++cnt; else {\n      if (cnt & 1) lim = max(lim, cnt);\n      cnt = 0;\n    }\n  }\n}\n\nvoid SolveSame(void) {\n  static int dp[maxn + 1][2][2];\n  dp[0][0][0] = dp[0][1][1] = 1;\n  for (int i = 1; i < n; ++i) {\n    for (int x = 0; x <= 1; ++x) {\n      for (int y = 0; y <= 1; ++y) {\n        for (int z = 0; z <= 1; ++z) {\n          if (y != 1 || z != 1) {\n            Add(dp[i][x][z], dp[i - 1][x][y]);\n          }\n        }\n      }\n    }\n  }\n  int ans = Add(Add(dp[n - 1][0][0] + dp[n - 1][0][1]) + dp[n - 1][1][0]);\n  printf(\"%d\\n\", ans);\n}\n\nint main(void) {\n  scanf(\"%d%d%s\", &n, &m, s);\n  if (s[0] == 'B') {\n    for (int i = 0; i < m; ++i) {\n      s[i] ^= 'R' ^ 'B';\n    }\n  }\n  if (count(s, s + m, 'R') == m) {\n    // the same\n    SolveSame();\n    return 0;\n  }\n\n  GetLim();\n  lim = lim + 1 >> 1;\n  if (n & 1) {\n    puts(\"0\");\n    return 0;\n  }\n  n /= 2;\n\n  for (int i = 1; i <= lim; ++i) {\n    Add(dp[i], 2 * i);\n  }\n  for (int i = 1; i <= n; ++i) {\n    // calc dp[i]\n    int L = max(1, i - lim), R = i;\n    Add(dp[i], sum[R] - sum[L]);\n    sum[i + 1] = Add(sum[i] + dp[i]);\n  }\n  printf(\"%d\\n\", dp[n]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(long long i=0; i<(long long)(n); i++)\n#define REP(i, k, n) for(long long i=(long long)(k); i<(long long)(n); i++)\n#define all(a) (a).begin(), (a).end()\n#define pb push_back\n#define PQ(T) priority_queue<T>\n#define PQS(T) priority_queue<T, vector<T>, greater<T> >\n#define deci cout << fixed << setprecision(15);\ntypedef long long ll;\nconst ll inf = 1020304050607080910;\nconst int mod = 1000000007;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> PP;\ntemplate<class T> bool chmin(T&x,T y){if(x>y){x=y;return true;}return false;}\ntemplate<class T> bool chmax(T&x,T y){if(x<y){x=y;return true;}return false;}\nll gcd(ll x,ll y){if(x>y)swap(x, y);while(x!=0){y%=x;swap(x, y);}return y;}\nll mpow(ll x,ll r){if(r==0)return 1;if(r%2==1){return x*mpow(x,r-1)%mod;}else{ll aa=mpow(x,r/2);return aa*aa%mod;}}\n\nll N, M, ans, cnt, ch, f, mi = 1e9, dp[200010], s1[200010], s2[200010];\nstring S;\nchar c;\n\nconst int MAX = 300002;\n\n// fac[]・・・a! finv[]・・・(a!)^(-1) inv[]・・・a^(-1)\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nvoid pre_comb(void){\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor(int i=2; i<MAX; i++){\n\t\tfac[i] = fac[i-1] * i % mod;\n\t\tinv[i] = mod - inv[mod%i] * (mod/i) % mod;\n\t\tfinv[i] = finv[i-1] * inv[i] % mod;\n\t}\n}\n\nlong long comb(int n, int k){\n\tif(n < k) return 0;\n\tif(n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n-k] % mod) % mod;\n}\n\n\nint main(){\n\tpre_comb();\n\tcin >> N >> M >> S;\n\trep(i, M){\n\t\tif(i==0){\n\t\t\tcnt = 1; c = S[i];\n\t\t}else{\n\t\t\tif(S[i] != S[i-1]){\n\t\t\t\tch = 1;\n\t\t\t\tif(f == 0){\n\t\t\t\t\tif(cnt % 2 == 0) cnt++;\n\t\t\t\t\tchmin(mi, cnt);\n\t\t\t\t\tf = 1;\n\t\t\t\t}else if(S[i-1] == c){\n\t\t\t\t\tif(cnt % 2 == 1) chmin(mi, cnt);\n\t\t\t\t}\n\t\t\t\tcnt = 1;\n\t\t\t}else cnt++;\n\t\t}\n\t}\n\tif(!ch){\n\t\trep(i, N/2+1){\n\t\t\tif(i==0) ans++;\n\t\t\telse{\n\t\t\t\tans = (ans + comb(N-i+1, i))%mod;\n\t\t\t\tif(i >= 2){\n\t\t\t\t\tans = (ans + mod - comb(N-i-1, i-2))%mod;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\tdp[0] = 0, dp[1] = 1, dp[2] = 0;\n\ts1[1] = 1, s1[2] = 0;\n\ts2[1] = 1, s2[2] = 0;\n\tREP(i, 3, N){\n\t\tif(i % 2 == 1){\n\t\t\tif(i <= mi+2){\n\t\t\t\tdp[i] = (i-1)/2;\n\t\t\t}else{\n\t\t\t\tdp[i] = (2*mi-i+3)/2;\n\t\t\t}\n\t\t}\n\t\tif(i <= mi && i % 2 == 1) dp[i]++;\n\t\tif(i > 4){\n\t\t\tif((i-3)/2 <= mi){\n\t\t\t\tdp[i] = (dp[i] + s1[i-4]) % mod;\n\t\t\t}else{\n\t\t\t\tdp[i] = (dp[i] + s1[i-4] + mod - (s1[i-2*mi-4]+mi*s2[i-2*mi-4])%mod)%mod;\n\t\t\t}\n\t\t}\n\t\ts1[i] = (s1[i-2] + s2[i-2] + dp[i]) % mod;\n\t\ts2[i] = (s2[i-2] + dp[i]) % mod;\n\t}\n\tif(N-1 <= mi) ans = N;\n\tfor(int i=1; i<=mi && i<=N-3; i=i+2){\n\t\tans = (ans + dp[N-i-2]*(i+1)%mod)%mod;\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\ntypedef pair<int, int> P;\nconst long long inf = 1ll << 61;\nconst long long mod = 1000000007;\n\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (s[0] == 'B') {\n\t\trep(i, m) {\n\t\t\tif (s[i] == 'R')s[i] = 'B'; else s[i] = 'R';\n\t\t}\n\t}\n\tvector<int>r, b;\n\tchar now = 'R'; int cnt1 = 0;\n\ts.push_back('A');\n\trep(i, m+1) {\n\t\tif (now == s[i])cnt1++;\n\t\telse {\n\t\t\tif (now == 'R')r.push_back(cnt1);\n\t\t\telse b.push_back(cnt1);\n\t\t\tnow = s[i];\n\t\t\tcnt1 = 1;\n\t\t}\n\t}\n\ts.pop_back();\n\n\tif (b.empty()) {//全部一緒\n\t\tvector<int>L(200005);\n\t\tL[0] = 2; L[1] = 1;\n\t\trep(i, 200002)L[i + 2] = (L[i] + L[i + 1]) % mod;\n\t\tcout << L[n] << endl;\n\t\treturn 0;\n\t}\n\n\tif (n & 1) {\n\t\tcout << 0 << endl; return 0;\n\t}\n\telse {\n\t\tint MR = r[0];\n\t\tif (MR & 1)MR += 2;\n\t\telse MR += 1;\n\t\trep(i,r.size()-1){\n\t\t\tint e = r[i];\n\t\t\tif (e & 1)MR = min(MR, e);\n\t\t}\n\t\tif (r.size() == b.size()) {\n\t\t\tint e = r[r.size() - 1];\n\t\t\tif(e&1)MR = min(MR, e);\n\t\t}\n\t\tMR = (MR + 1) / 2;\n\t\tvector<int>dp(200005);\n\t\tint s = 1, as = 1;\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= MR; i++) {\n\t\t\tdp[i] = (as + i) % mod;\n\t\t\tas = (as + dp[i]) % mod;\n\t\t}\n\t\tfor (int i = MR + 1; i <= n; i++) {\n\t\t\tdp[i] = as;\n\t\t\tas += dp[i];\n\t\t\tas -= dp[i - MR];\n\t\t\tas = (as + mod) % mod;\n\t\t}\n\t\tcout << (dp[n/2]*2)%mod << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int N = 2e5;\nconst int P = 1e9+7;\nchar a[N+3];\nllong f[N+3],sf[N+3];\nint n,m; llong ans;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m); scanf(\"%s\",a+1);\n\tfor(int i=1; i<=n; i++) a[i] = a[i]=='R'?0:1;\n\tif(a[1]) {for(int i=1; i<=m; i++) a[i] ^= 1;}\n\tint lim = m,cur = 0;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tif(a[i]==a[1]) {cur++;}\n\t\telse\n\t\t{\n\t\t\tif(cur==i-1) {lim = cur&1?cur:cur+1;}\n\t\t\telse {if(cur&1) lim = min(lim,cur);}\n\t\t\tcur = 0;\n\t\t}\n\t}\n\tif(cur==m)\n\t{\n\t\tf[1] = 1ll; for(int i=2; i<=n; i++) f[i] = (f[i-1]+f[i-2])%P;\n\t\tans = (f[n]+f[n-1]+f[n-1])%P;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse\n\t{\n\t\tif(n&1) {puts(\"0\"); return 0;}\n//\t\tprintf(\"lim=%d\\n\",lim);\n\t\tlim>>=1,n>>=1; f[1] = sf[1] = 1ll;\n\t\tfor(int i=2; i<=n; i++)\n\t\t{\n\t\t\tf[i] = (sf[i-1]-sf[max(0,i-lim-2)]+P)%P; sf[i] = (sf[i-1]+f[i])%P;\n\t\t}\n\t\tfor(int i=1; i<=n; i++) if(n-i<=lim)\n\t\t{\n\t\t\tans = (ans+f[i]*(n-i+1ll))%P;\n\t\t}\n\t\tprintf(\"%lld\\n\",(ans+ans)%P);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#define N 201000\ntypedef long long ll;\ntemplate <typename T> inline void read(T &x) {\n\tx = 0; char c = getchar(); bool flag = false;\n\twhile (!isdigit(c)) { if (c == '-')\tflag = true; c = getchar(); }\n\twhile (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }\n\tif (flag)\tx = -x;\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nconst int inf = 987654321;\ninline void MIN(int &a, int b) {\n\tif (b < a)\ta = b;\n}\nint n, m;\nchar s[N];\nnamespace jzp1 {\n\tll jie[N], jieni[N];\n\tinline ll get_c(int n, int m) {\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\tif (n < 0 || m < 0 || n - m < 0)\treturn 0;\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\treturn jie[n] * jieni[m] % P * jieni[n - m] % P;\n\t}\n\tinline ll quickpow(ll x, int k) {\n\t\tll res = 1;\n\t\twhile (k) {\n\t\t\tif (k & 1)\tres = res * x % P;\n\t\t\tx = x * x % P;\n\t\t\tk >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline void sol() {\n//\t\twhile(1);\n\t\tif (n == 1) { puts(\"1\"); return ; }\n\t\tjie[0] = jieni[0] = 1;\n\t\tint up = n + 1;\n\t\tfor (int i = 1; i <= up; ++i)\tjie[i] = jie[i - 1] * i % P;\n\t\tjieni[up] = quickpow(jie[up], P - 2);\n\t\tfor (int i = up - 1; i; --i)\tjieni[i] = jieni[i + 1] * (i + 1) % P;\n\t\tll res = 0;\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tres = (res + get_c(n - i + 1, i) - get_c(n - i - 1, i - 2)) % P;\n//\t\t\tprintf(\"res = %lld\\n\", res);\n\t\t}\n\t\tprintf(\"%lld\\n\", (res % P + P) % P);\n\t}\n}\nll f[N];\nll sum[N];\nint main() {\n\tread(n), read(m);\n\tscanf(\"%s\", s + 1);\n\tbool flag = false;\n\tint tmp = 0;\n\tfor (int i = 1; i <= m; ++i)\tif (s[i] != s[1]) { flag = true; tmp = i - 1; break; }\n\tif (!flag) { jzp1::sol(); return 0; }\n\tif (n & 1) { puts(\"0\"); return 0; }\n\tint lst = 1, mn = tmp | 1;\n\tfor (int i = 2; i <= m; ++i) {\n//\t\tprintf(\"i = %d, mn = %d\\n\", i, mn);\n\t\tif (s[i] != s[1]) {\n\t\t\tif (lst & 1)\tMIN(mn, lst);\n\t\t\tlst = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == s[i - 1])\t++lst;\n\t\telse {\n\t\t\tif (lst & 1) MIN(mn, lst);\n\t\t\tlst = 1;\n\t\t}\n\t}\n\tif (mn == inf) {\n//\t\twhile (1);\n\t\tint memo = 1;\n\t\tfor (int i = 1; s[i] == s[1]; ++i) memo = i;\n\t\tmn = memo + 1;\n\t\tprintf(\"memo = %d\\n\", memo);\n\t}\n\tn >>= 1;\n\tint k = (mn + 1) >> 1;\n\tMIN(k, n);\n\tf[0] = 1; sum[0] = 1;\n//\tprintf(\"n = %d, k = %d\\n\", n, k);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (i <= k)\tf[i] = sum[i - 1];\n\t\telse f[i] = (sum[i - 1] - sum[i - k - 1]) % P;\n\t\tsum[i] = (sum[i - 1] + f[i]) % P;\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tans = (ans + f[n - i] * i) % P;\n\t}\n\tans = (ans << 1) % P;\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n\n/*\n3 3\nBBB\n//4\n\n1 1\nB\n//1\n\n12 10\nRRRRBRRRRB\n//78\n\n6 5\nRRBBR\n//8\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n\n\ttemplate<typename T> inline int ts(T *s)\n\t{\n\t\tint a=0,c=fetch();\n\t\twhile(c<=32 && c!=EOF)c=fetch();\n\t\twhile(c>32 && c!=EOF)s[a++]=c,c=fetch();\n\t\ts[a]=0;\n\t\treturn a;\n\t}\n}\nusing ae86::ty;\nusing ae86::ts;\n\nconst int _ = 200007 , mo = 1000000007;\n\nint n,m,s[_];\nlint f[_]={0};\n\nint main()\n{\n\tn=ty(),m=ty(),ts(s+1);\n\tfor(int i=m;i>=1;i--)s[i]=s[i]==s[1];\n\n\tlint ans=0;\n\twhile(m>1 && s[m])m--;\n\tif(m<=1)ans=1;\n\t\n\tint lim=n;\n\tfor(int l=1,r=1;l<=m;l=r+1)\n\t{\n\t\twhile(l<=m && !s[l])l++;\n\t\tif(l>m)break;\n\t\tr=l;\n\t\twhile(r<m && s[r+1])r++;\n\t\tint len=r-l+1;\n\t\tif(l==1)lim=min(lim,len+(1-len%2));\n\t\tif(len&1)lim=min(lim,len);\n\t}\n\n\tif(lim>=n)\n\t{\n\t\tf[0]=1;\n\t\tfor(int i=1,x=0;i<=n;i++)f[i]=x,x=(x+f[i-1])%mo;\n\t\tfor(int i=2;i<=n;i++)ans=(ans+f[n-i]*i%mo)%mo;\n\t}\n\telse\n\t{\n\t\tf[0]=1;\n\t\tfor(int i=2,x=f[0];i<=n;i+=2)\n\t\t{\n\t\t\tf[i]=x,x=(x+f[i])%mo;\n\t\t\tif(i>lim)x=(x-f[i-lim-1]+mo)%mo;\t\n\t\t}\n\t\tfor(int i=2;i<=lim+1;i+=2)ans=(ans+f[n-i]*i%mo)%mo;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint N, M; char S[200200];\n\nconst long long mod = 1000000007;\nlong long D[200200], V[200200];\n\nint main()\n{\n\tscanf (\"%d %d %s\", &N, &M, S);\n\tif (S[0] == 'B'){\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tif (S[i] == 'R') S[i] = 'B';\n\t\t\telse S[i] = 'R';\n\t\t}\n\t}\n\n\tvector<int> len;\n\tfor (int i = 1, l = -1; i < M; i++){\n\t\tif (S[i-1] == 'R' && S[i] == 'B'){\n\t\t\tint u = i - l - 1;\n\t\t\tlen.push_back(u);\n\t\t}\n\t\tif (S[i] == 'B') l = i;\n\t}\n\n\tif (len.empty()){\n\t\tif (N == 2){\n\t\t\tprintf (\"3\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tD[0] = 1;\n\t\tD[1] = 2;\n\t\tfor (int i = 2; i <= N; i++) D[i] = (D[i - 1] + D[i - 2]) % mod;\n\t\tprintf (\"%lld\\n\", (D[N - 1] + D[N - 3]) % mod);\n\t\treturn 0;\n\t}\n\tif (N == 2){\n\t\tprintf (\"2\\n\");\n\t\treturn 0;\n\t}\n\tif (N % 2){\n\t\tprintf (\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tint lim = len[0];\n\tif (lim % 2 == 0) lim++;\n\tfor (int i = 1; i < len.size(); i++){\n\t\tif (len[i] % 2){\n\t\t\tif (lim > len[i])\n\t\t\t\tlim = len[i];\n\t\t}\n\t}\n\n\tD[0] = V[0] = 1;\n\tfor (int i = 1; i <= N; i++){\n\t\tif (i <= lim + 1) D[i] = i - 1;\n\t\tif (i >= 2) D[i] = (D[i] + V[i - 2]) % mod;\n\t\tif (i >= lim + 3) D[i] = (D[i] + mod - V[i - (lim + 3)]) % mod;\n\t\tV[i] = D[i];\n\t\tif (i >= 2) V[i] = (V[i] + V[i - 2]) % mod;\n\t}\n\tprintf (\"%lld\\n\", D[N]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* cerberus97 - Hanit Banga */\n\n#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define pb push_back\n#define fast_cin() ios_base::sync_with_stdio(false); cin.tie(NULL)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nconst int N = 2e5 + 10, mod = 1e9 + 7;\n\nll dp[N], pref[N][2];\n\nll solve(int n, int bound, bool parity);\n\nint main() {\n\tfast_cin();\n\tint n, m; string s;\n\tcin >> n >> m >> s;\n\ts += (s[0] ^ 'R' ^ 'B');\n\tvector<int> parts;\n\tint cur = 1;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tif (s[i] != s[i - 1]) {\n\t\t\tparts.pb(cur);\n\t\t\tcur = 1;\n\t\t} else {\n\t\t\t++cur;\n\t\t}\n\t}\n\tint bound = parts[0] + (1 - (parts[0] & 1));\n\tfor (int i = 2; i < parts.size(); ++i) {\n\t\tif (parts[i] & 1) {\n\t\t\tbound = min(bound, parts[i]);\n\t\t}\n\t}\n\tif (parts.size() == 1) {\n\t\tcout << (solve(n, n, false) + 1) % mod << '\\n';\n\t} else {\n\t\tcout << solve(n, bound, true) << '\\n';\n\t}\n}\n\nll solve(int n, int bound, bool parity) {\n\tdp[0] = 1;\n\tpref[0][0] = 1;\n\tif (!parity) {\n\t\tpref[0][1] = 1;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint lo = max(0, i - bound - 1), hi = i - 2;\n\t\tif (lo <= hi) {\n\t\t\tdp[i] = pref[hi][hi & 1] - (lo > 0 ? pref[lo - 1][hi & 1] : 0);\n\t\t\tdp[i] += mod;\n\t\t\tdp[i] %= mod; \n\t\t}\n\t\tpref[i][0] = pref[i - 1][0];\n\t\tpref[i][1] = pref[i - 1][1];\n\t\tpref[i][i & 1] += dp[i];\n\t\tpref[i][i & 1] %= mod;\n\t\tif (!parity) {\n\t\t\tpref[i][(i + 1) & 1] = pref[i][i & 1];\n\t\t}\n\t\t// cout << i << ' ' << dp[i] << '\\n';\n\t}\n\tll ans = dp[n];\n\tfor (int i = 1; i < n and i <= bound; ++i) {\n\t\tint lo = max(i, n + (i - 1) - bound) - i, hi = n - i - 1;\n\t\tif (lo <= hi) {\n\t\t\tans += pref[hi][n & 1] - (lo > 0 ? pref[lo - 1][n & 1] : 0);\n\t\t\tans += mod;\n\t\t\tans %= mod;\n\t\t}\n\t}\n\treturn ans;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___CLASS_MODINT\n#define ___CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::uint64_t n_) : n(n_ % mod) {};\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tstd::uint32_t get() const { return n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint binpow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tmodint inv() { return (*this).binpow(mod - 2); }\n};\n\n#endif // ___CLASS_MODINT\n\n#include <string>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nusing modulo = modint<1000000007>;\nconst int inf = 1012345678;\nint main() {\n\tint N, M; string S;\n\tcin >> N >> M >> S;\n\tif (S[0] == 'B') {\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (S[i] == 'B') S[i] = 'R';\n\t\t\telse S[i] = 'B';\n\t\t}\n\t}\n\tint pre = 0, mn = inf;\n\tfor (int i = 1; i < M; ++i) {\n\t\tif (pre != -1 && S[i] == 'B') {\n\t\t\tif (pre == 0 || (i - pre) % 2 == 1) mn = min(mn, i - pre + 1);\n\t\t}\n\t\telse if (i != M && pre == -1 && S[i] == 'R') pre = i;\n\t}\n\tif (mn == inf) {\n\t\tvector<modulo> fib(N + 3);\n\t\tfib[1] = 1;\n\t\tfor (int i = 2; i <= N + 2; ++i) {\n\t\t\tfib[i] = fib[i - 1] + fib[i - 2];\n\t\t}\n\t\tmodulo ans = fib[N + 2] - fib[N - 2];\n\t\tcout << ans.get() << endl;\n\t}\n\telse {\n\t\tvector<modulo> dp(N + 1);\n\t\tdp[1] = 1;\n\t\tint lim = (mn + 1) / 2 * 2;\n\t\tmodulo sum = 1;\n\t\tfor (int i = 3; i <= N; i += 2) {\n\t\t\tif (i - lim - 2 >= 0) sum -= dp[i - lim - 2];\n\t\t\tdp[i] = sum;\n\t\t\tsum += dp[i];\n\t\t}\n\t\tmodulo ans = 0;\n\t\tfor (int i = 1; i <= mn && i <= N; i += 2) {\n\t\t\tans += dp[N - i] * (i + 1);\n\t\t}\n\t\tcout << ans.get() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nint Mn(int a,int b){return a<b?a:b;}\nconst int N=2e5+5,mod=1e9+7;\nint upt(int x){while(x>=mod)x-=mod;while(x<0)x+=mod;return x;}\n\nint n,m,lm,dp[N],sm[N],ans,f[N][3];\nchar s[N];\nvoid solve()\n{\n  f[1][0]=1;\n  for(int i=2;i<=n;i++)\n    {\n      f[i][0]=f[i-1][0];\n      f[i][1]=(f[i-1][1]+f[i-1][2]);\n      f[i][2]=upt(f[i-1][0]+f[i-1][1]);\n    }\n  int ans=(f[n][0]+upt(f[n][1]+f[n][2]));\n  f[1][2]=1; f[1][0]=f[1][1]=0;\n  for(int i=2;i<=n;i++)\n    {\n      f[i][1]=(f[i-1][1]+f[i-1][2]);\n      f[i][2]=f[i-1][1];\n    }\n  ans=upt(ans+f[n][1]); printf(\"%d\\n\",ans);\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&m);\n  scanf(\"%s\",s+1); bool fg=0;\n  for(int i=1;i<=m;i++)\n    if(s[i]!=s[1]){fg=1;break;}\n  if(!fg){solve();return 0;}\n  if(n&1){puts(\"0\");return 0;}\n  lm=n+1;\n  for(int i=1;i<=m;i++)\n    if(s[i]==s[1])//== not !=\n      {\n\tint j=i;\n\twhile(j+1<=m&&s[j+1]==s[j])j++;\n\tswap(i,j); j=i-j+1;\n\tif(i-j==0) lm=Mn(lm,j+((j&1)==0));\n\telse if(j&1)lm=Mn(lm,j);\n      }\n  n>>=1; lm=(lm+1)>>1; dp[0]=sm[0]=1;\n  for(int i=1;i<=n;i++)\n    {\n      dp[i]=sm[i-1]; if(i>lm)dp[i]=upt(dp[i]-sm[i-lm-1]);\n      sm[i]=upt(sm[i-1]+dp[i]);\n    }\n  int ans=0;\n  for(int i=1;i<=lm;i++)//lm not n\n    ans=(ans+(ll)i*2*dp[n-i])%mod;\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MAX_N 200000\n#define MAX_M 200000\n#define MOD 1000000007\n\n#define INF 1 << 29\n\nint N, M;\nstring S;\n\nlong long dp[MAX_N + 1], rdp[MAX_N + 1];\n\nint all_color_is_same()\n{\n    long long rr = 1, bb = 1, rb = 0, br = 0;\n\n    for ( int i = 1; i < N; i++ )\n    {\n        long long nrr = ( rr + rb ) % MOD;\n        long long nbb = br;\n        long long nrb = rr;\n        long long nbr = ( bb + br ) % MOD;\n\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n\n    return ( rr + rb + br ) % MOD;\n}\n\n/**\n * S の先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n */\nint min_freq()\n{\n    int l = 0;\n    while ( l < M && S[0] == S[l] ) l++;\n\n    int ans = ( l & 1 ) ? l : l + 1;\n\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[0] == S[i] )\n            l++;\n        else\n        {\n            if ( l & 1 ) ans = min( ans, l );\n            l = 0;\n        }\n    }\n    return l ? min( ans, l ) : ans;\n}\n\nint solve()\n{\n    // 一色\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n        return all_color_is_same();\n\n    // N が奇数\n    if ( N & 1 ) return 0;\n\n    int L = min_freq();\n\n    L = ( L + 1 ) >> 1;\n    N >>= 1;\n\n    dp[0] = rdp[0] = 1;\n    for ( int i = 1; i <= N + 1; i++ )\n    {\n        dp[i] = rdp[i - 1];\n        if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n\n    long long res = 0;\n    for ( int i = 1; i <= L; i++ )\n        if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n    return res % MOD;\n}\n\nint main( int argc, char **argv )\n{\n    cin >> N >> M;\n    cin >> S;\n\n    int ans = solve();\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct SegT {\nprivate:\n\tint sz; vector<ll> node;\n\tconst ll init_c = 0;\npublic:\n\tSegT(int n) {\n\t\tsz = 1;\n\t\twhile (sz < n)sz *= 2;\n\t\tnode.resize(2 * sz - 1, init_c);\n\t}\n\tll f(ll a, ll b) {\n\t\treturn (a + b)%mod;\n\t}\n\tvoid update(int k, ll a) {\n\t\tk += sz - 1;\n\t\tnode[k] = a;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\tll query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = sz;\n\t\tif (r <= a || b <= l)return init_c;\n\t\telse if (a <= l && r <= b)return node[k];\n\t\telse {\n\t\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn f(vl, vr);\n\t\t}\n\t}\n};\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nll dp[1 << 18][2][2];\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (s[0] == 'B') {\n\t\trep(i, m) {\n\t\t\tif (s[i] == 'B')s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\tvector<int> v;\n\trep(i, m) {\n\t\tint le = i;\n\t\twhile (i + 1 < m&&s[i + 1] == s[i])i++;\n\t\tv.push_back(i - le + 1);\n\t}\n\tif (v.size() == 1) {\n\t\tdp[0][0][0] = 1;\n\t\tdp[0][1][1] = 1;\n\t\trep(i, n - 1) {\n\t\t\trep(j, 2) {\n\t\t\t\t(dp[i + 1][0][j] += dp[i][0][j] + dp[i][1][j]) %= mod;\n\t\t\t\tdp[i + 1][1][j] += dp[i][0][j];\n\t\t\t}\n\t\t}\n\t\tll ans = dp[n - 1][0][0] + dp[n - 1][1][0] + dp[n - 1][0][1];\n\t\tcout << ans % mod << endl; return;\n\t}\n\tif (n % 2) {\n\t\tcout << 0 << endl; return;\n\t}\n\tint d = n / 2;\n\tint x = v[0] / 2 + 1;\n\tif (x >= d) {\n\t\tll ans = mod_pow(2, d) - 1;\n\t\tans = ans * 2;\n\t\tans = (ans + mod) % mod;\n\t\tcout << ans << endl;\n\t}\n\telse {\n\t\tSegT dp(d + 1);\n\t\tdp.update(0, 1);\n\t\trep1(i, d - 1) {\n\t\t\tint le = i - x;\n\t\t\tle = max(le, 0);\n\t\t\tll nex = dp.query(le, i);\n\t\t\tdp.update(i, nex);\n\t\t}\n\t\tll ans = 0;\n\t\trep(i, x) {\n\t\t\tll z = dp.query(d - x, d - i); ans += z;\n\t\t\tif (ans >= mod)ans -= mod;\n\t\t}\n\t\tans = ans * 2 % mod;\n\t\tcout << ans << endl;\n\t}\n\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\n#define debug(x)//  cerr << #x << \" = \" << x << endl\ntypedef long long ll;\nconst ll MAX_N = 2e5+100;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    int mn = 1e9;\n    if (vc[0]%2==0)\n        mn = vc[0]+1;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    int lim = mn;\n    dp[1] = 1;\n    dp[3] = 1;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = (dp[i-2]*2)%MOD;\n        if (i-2>lim)\n            dp[i] = (dp[i]-dp[i-lim-3]+MOD)%MOD;\n    }\n    ll ans = 0;\n    for(ll i = 1;i<=min(n-1,lim);i+=2)\n    {\n        ans += ((i+1)*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n \n#include <algorithm>\n#include <tuple>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n \n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n \ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 200010, P = 1000000007;\n\nint n, m;\nchar s[N];\n\nvoid add(int& x, int y) {\n  if ((x += y) >= P)\n    x -= P;\n}\n\nvoid sub(int& x, int y) {\n  if ((x -= y) < 0)\n    x += P;\n}\n\nint norm(int x) {\n  return x >= P ? x - P : x;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n >> m >> (s + 1);\n  char a = s[1];\n  if (count(s + 1, s + m + 1, a) == m) {\n    static int dp[N][2][2];\n    dp[1][0][0] = dp[1][1][1] = 1;\n    for (int i = 2; i <= n; ++i)\n      for (int j = 0; j < 2; ++j) {\n        add(dp[i][j][0], dp[i - 1][j][0]);\n        add(dp[i][j][0], dp[i - 1][j][1]);\n        add(dp[i][j][1], dp[i - 1][j][0]);\n      }\n    int ans = norm(norm(dp[n][0][0] + dp[n][0][1]) + dp[n][1][0]);\n    cout << ans << '\\n';\n    return 0;\n  }\n  int p = 1;\n  while (s[p] == a) ++p;\n  int len = p - 1;\n  if (len % 2 == 0) ++len;\n  int cur = 0;\n  for (; p <= m; ++p)\n    if (s[p] != a) {\n      if (cur & 1)\n        len = min(len, cur);\n      cur = 0;\n    } else\n      ++cur;\n  static int dp[N], sum[N];\n  dp[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    sum[i - 1] = dp[i - 1];\n    if (i - 3 >= 0)\n      add(sum[i - 1], sum[i - 3]);\n    dp[i] = sum[i - 2];\n    if (i - len - 3 >= 0)\n      sub(dp[i], sum[i - len - 3]);\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; ++i)\n    if ((n - i) <= len && ((n - i) & 1))\n      ans = (ans + dp[i] * (n - i + 1LL)) % P;\n  cout << ans << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n\treturn powmod(a, MOD-2);\n}\nll f[200001], invf[200001];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n    invf[n]=inv(f[n]);\n    for(ll i=n-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n}\nll comb(int x, int y){\n    if(x<y) return 0;\n    return f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nint main()\n{\n    int n, m; cin>>n>>m;\n    string s; cin>>s;\n    if(s[0]=='B'){\n        for(int i=0; i<m; i++){\n            if(s[i]=='B') s[i]='R';\n            else s[i]='B';\n        }\n    }\n    int j=-1;\n    vector<int> v;\n    bool nuo=1;\n    for(int i=0; i<n; i++){\n        if(s[i]=='B') nuo=0;\n        if(i==n-1 || s[i+1]=='B'){\n            v.push_back(i-j);\n            j=i+1;\n        }\n    }\n    if(nuo){\n        ll dp[2][200002]={};\n        dp[0][0]=1;\n        for(int i=1; i<n; i++){\n            dp[1][i]+=dp[0][i-1];\n            dp[0][i]+=(dp[0][i-1]+dp[1][i-1]);\n            dp[0][i]%=MOD;\n            dp[1][i]%=MOD;\n        }\n        ll ans=dp[0][n-1]+dp[1][n-1];\n        fill(dp[0], dp[0]+n+1, 0);\n        fill(dp[1], dp[1]+n+1, 0);\n        dp[1][0]=1;\n        for(int i=1; i<n; i++){\n            dp[1][i]+=dp[0][i-1];\n            dp[0][i]+=(dp[0][i-1]+dp[1][i-1]);\n            dp[0][i]%=MOD;\n            dp[1][i]%=MOD;\n        }\n        ans+=dp[0][n-1];\n        ans%=MOD;\n        cout<<ans<<endl;\n        return 0;\n    }\n    if(n%2==1){\n        cout<<0<<endl;\n        return 0;\n    }\n    int mx=v[0]+1-v[0]%2;\n    for(int i=1; i<v.size(); i++){\n        if(v[i]&1) mx=min(mx, v[i]);\n    }\n    ll dp[200002]={}, sum[200002];\n    dp[0]=1;\n    sum[0]=1;\n    for(int i=1; i<=n; i++){\n        if(i&1) sum[i]=sum[i-1];\n        else{\n            if(i-mx-3>=0) dp[i]=(sum[i-2]-sum[i-mx-3]+MOD)%MOD;\n            else dp[i]=sum[i-2];\n            sum[i]=(sum[i-1]+dp[i])%MOD;\n        }\n    }\n    ll ans=0;\n    for(int i=1; i<=min(mx, n); i+=2){\n        ans+=(ll)(i+1)*dp[n-i-1];\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define int long long\nusing namespace std;\nconst int N=2e5+2;\nconst int mod=1e9+7;\nint dp[N],sum[N];\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,max1,ans=0,m;\n\tstring s;\n\tcin>>n>>m>>s;\n\tif(s[0]=='B'){\n\t\tfor(i=0;i<m;i++){\n\t\t\tif(s[i]=='B'){\n\t\t\t\ts[i]='R';\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts[i]='B';\n\t\t\t}\n\t\t}\n//\t\tcout<<s<<endl;\n\t}\n\tbool cac=true;\n\tfor(i=1;i<m;i++){\n\t\tif(s[i]!=s[i-1]){\n\t\t\tcac=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(cac){\n//\t\tcout<<0<<endl;\n\t\tdp[0]=1;\n\t\tsum[0]=1;\n\t\tans=1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(i!=1){\n\t\t\t\tdp[i]=sum[i-2];\n\t\t\t}\n\t\t\tsum[i]=sum[i-1]+dp[i];\n\t\t\tif(sum[i]>=mod){\n\t\t\t\tsum[i]-mod;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n-1;i++){\n\t\t\tans+=(i+1)*dp[n-i-1];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout<<ans;\n\t}\n\telse{\n\t\tif(n&1){\n\t\t\tcout<<0;\n\t\t\treturn 0;\n\t\t}\n\t\tmax1=n-1;\n\t\tcac=true;\n\t\tj=1;\n\t\tfor(i=1;i<m;i++){\n\t\t\tif(s[i]==s[i-1]){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(s[i]=='B'){\n\t\t\t\t\tif(cac){\n\t\t\t\t\t\tif(j&1){\n\t\t\t\t\t\t\tmax1=min(max1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmax1=min(max1,j+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcac=false;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(j&1){\n\t\t\t\t\t\t\tmax1=min(max1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj=1;\n\t\t\t}\n\t\t}\n\t\tif(s[m-1]=='R'){\n\t\t\tif(cac){\n\t\t\t\tif(j&1){\n\t\t\t\t\tmax1=min(max1,j);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmax1=min(max1,j+1);\n\t\t\t\t}\n\t\t\t\tcac=false;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(j&1){\n\t\t\t\t\tmax1=min(max1,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[0]=1;\n\t\tsum[0]=1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tsum[i]=sum[i-1];\n\t\t\tif(i&1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i]=sum[i-2];\n\t\t\tif(i-max1-2>=0){\n\t\t\t\tdp[i]-=sum[i-max1-2];\n\t\t\t\tif(dp[i]<0){\n\t\t\t\t\tdp[i]+=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum[i]+=dp[i];\n\t\t\tif(sum[i]>=mod){\n\t\t\t\tsum[i]-=mod;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=max1;i+=2){\t\n\t\t\tans+=(i+1)*dp[n-i-1];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout<<ans;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <list>\n#include <iterator>\n#include <assert.h>\n#pragma warning(disable:4996) \n\ntypedef long long ll;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF 9223300000000000000\n#define INF 2140000000\nconst long long MOD = 1000000007;\nusing namespace std;\n\nchar str[200005];\n\n// A(Bを数個)A(Bを数個)..A(Bを数個) \n// という列の作り方が何通りあるか、を求める\n// ただし列の長さをn、Bを重ねるのは各箇所について0個以上k個以下とする\n// また両端がつながっているものとする。\nll func( int n, int k)\n{\n    if(k>=n) k=n-1;\n\n#ifdef _DEBUG\n    printf(\"%d %d\\n\", n, k);\n#endif\n    vector<ll> dp(n+1);   // dp[i]: func(i,k)と同じ。ただし両端がつながっていなくてAから始まるものとする。\n    vector<ll> sdp(n+2);  // dpの累積和\n    dp[0]=1;\n    sdp[0]=0; sdp[1]=1;\n    int i;\n    for(i=1; i<=n; i++) {\n        dp[i]=(sdp[i]-sdp[MAX(0,i-k-1)]+MOD)%MOD;\n        sdp[i+1]=(sdp[i]+dp[i])%MOD;\n    }\n    ll ans = dp[n];\n\n    // dp[n]は、Aから始まるものだけを数えたもの。\n    // 両端がつながっている状況で、Bから始まるものを数える\n    // Bが最初にp個重なった場合を考えて足し合わせればよい\n    int p;\n    for(p=1; p<=k; p++) {\n        // dp[n-p-1],dp[n-p-2],..という(k-p+1)個を足し合わせればよい\n        ans = (ans + sdp[n-p] - sdp[n-k-1] +MOD)%MOD;\n    }\n\n    return ans;\n}\n\nint main(int argc, char* argv[])\n{\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    scanf(\"%s\", str);\n\n    char c=str[0];\n    int min_odd=INF-1;\n    int cnt_first=-1;\n    int cnt=0;\n    int cnt2=0;\n    int i;\n    for(i=0; i<m; i++) {\n        if(str[i]==c) {\n            cnt++;\n        }\n        else {\n            if(cnt>0) {\n                if(cnt_first<0) cnt_first=cnt;\n                if(cnt%2) min_odd = MIN(min_odd, cnt);\n                cnt=0;\n            }\n            cnt2++;\n        }        \n    }\n\n    if(cnt2==0) {\n        printf(\"%lld\\n\", func(n, 1));\n    }\n    else {\n        if(n%2==0) {\n            int k = (cnt_first%2==0? cnt_first+1: cnt_first);\n            if(min_odd>0) k = MIN(k, min_odd);\n            printf(\"%lld\\n\", func(n/2, (k-1)/2) *2 %MOD);\n        }\n        else {\n            printf(\"0\\n\");\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nconst int P = 1e9 + 7;\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n, m;\n  cin>>n>>m;\n  VI fib(n + m + 2);\n  fib[1] = 1;\n  \n  FOR (i, 2, n + m + 1) {\n    fib[i] = (fib[i - 1] + fib[i - 2]) % P;\n  }\n  string s;\n  cin>>s;\n  if (s == string(m, s[0])) {\n    cout<<(fib[n + 1] + fib[n - 1]) % P<<endl;\n    return 0;\n  }\n  if (n % 2 == 1) {\n    cout<<\"0\\n\";\n    return 0;\n  }\n  int too_far = n + 1;\n  int cur = 0;\n  REP (i, m) {\n    if (s[i] != s[0]) {\n      if (cur % 2 == 0 && cur == i) {\n        mini(too_far, (cur + 4) / 2);\n      } else if (cur % 2 == 1) {\n        mini(too_far, (cur + 3) / 2);\n      }\n      cur = 0;\n    } else {\n      cur++;\n    }\n  }\n  //debug(shortest_odd);\n  //int too_far = (shortest_odd + 3) / 2;\n  debug(too_far);\n  int ans = 0;\n  VI dp(n + 2);\n  VI pref(n + 2);\n  dp[1] = 1;\n  pref[1] = 1;\n  n /= 2;\n  FOR (i, 1, n) {\n    if (i > 1) {\n      dp[i] = pref[i - 1];\n      if (i >= too_far) {\n        dp[i] -= pref[i - too_far];\n      }\n      dp[i] = (dp[i] + P) % P;\n      pref[i] = (pref[i - 1] + dp[i]) % P;\n    }\n    debug(i, dp[i], pref[i]);\n    if (i >= n - too_far + 2) {\n      ans = (ans + dp[i] * (n - i + 1)) % P;\n    }\n  }\n  cout<<2 * ans % P<<endl;\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200233, mod = 1000000007;\nint n, m, f[N];\nchar s[N];\n\nint main() {\n  scanf(\"%d%d%s\", &n, &m, s + 1);\n  if (*min_element(s + 1, s + 1 + n) == *max_element(s + 1, s + 1 + n)) {\n    int x = 2, y = 1;\n    for (int i = 1; i <= n; i++) {\n      y = y + x;\n      x = y - x;\n    }\n    printf(\"%d\\n\", x);\n    return 0;\n  }\n  int limit, x = 1;\n  while (x + 1 <= m && s[x + 1] == s[1]) x++;\n  limit = x | 1;\n  for (int i = x + 1, j = 0; i <= m + 1; i++) {\n    if (i > m || s[i] != s[1]) {\n      if (j & 1) limit = min(limit, j);\n      j = 0;\n    } else {\n      ++j;\n    }\n  }\n  if (n & 1) {\n    puts(\"0\");\n    return 0;\n  }\n  n >>= 1;\n  limit = min(n, (limit + 1) >> 1);\n  f[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    f[i] = ((long long) mod + f[i - 1] + f[i - 1] - (i > limit ? f[i - limit - 1] : 0)) % mod;\n  }\n  int ans = 0;\n  for (int i = 1; i <= limit; i++) {\n    ans = (ans + (long long) (mod + f[n - i] - (n > i ? f[n - i - 1] : 0)) * i * 2) % mod;\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e5+10,inf=0x3f3f3f3f,mod=1e9+7;\nchar s[maxn];\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\ty>>=1;\n\t\tx=(ll)x*x%mod;\n\t}\n\treturn res;\n}\nint dp[maxn],sum[maxn];\nint main(){\n\tint n=read(),m=read();\n\tscanf(\"%s\",s+1);\n\tint Min=inf;\n\tfor(int i=1,j;i<=m;i++) if(s[i]==s[1]){\n\t\tj=i;\n\t\twhile(j<m && s[j+1]==s[1]) ++j;\n\t\tif((j-i+1)%2==1) chkmin(Min,j-i+1);\n\t\telse if(i==1) chkmin(Min,j-i+2);\n\t\ti=j;\n\t}\n\tint flag=1;\n\tREP(i,2,m) flag&=(s[i]==s[1]);\n\tdp[1]=sum[1]=1;\n\tREP(i,2,n+1){\n\t\tif(flag){\n\t\t\tdp[i]=sum[i-2];\n\t\t\tsum[i]=(sum[i-1]+dp[i])%mod;\n\t\t}\n\t\telse{\n\t\t\tdp[i]=(sum[i-2]-sum[max(i-Min-3,0)]+mod)%mod;\n\t\t\tsum[i]=(sum[i-2]+dp[i])%mod;\n\t\t}\n\t}\n\tint ans=(dp[n+1]*2+flag)%mod;\n\tREP(i,1,n-2) if(((n-i)%2==1 || flag) && n-i<=Min) ans=(ans+(ll)dp[i]*(n-i-1))%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#define N 201000\ntypedef long long ll;\ntemplate <typename T> inline void read(T &x) {\n\tx = 0; char c = getchar(); bool flag = false;\n\twhile (!isdigit(c)) { if (c == '-')\tflag = true; c = getchar(); }\n\twhile (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }\n\tif (flag)\tx = -x;\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nconst int inf = 987654321;\ninline void MIN(int &a, int b) {\n\tif (b < a)\ta = b;\n}\nint n, m;\nchar s[N];\nnamespace jzp1 {\n\tll jie[N], jieni[N];\n\tinline ll get_c(int n, int m) {\n\t\tif (n < 0 || m < 0 || n - m < 0)\treturn 0;\n\t\treturn jie[n] * jieni[m] % P * jieni[n - m] % P;\n\t}\n\tinline ll quickpow(ll x, int k) {\n\t\tll res = 1;\n\t\twhile (k) {\n\t\t\tif (k & 1)\tres = res * x % P;\n\t\t\tx = x * x % P;\n\t\t\tk >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline void sol() {\n\t\tif (n == 1) { puts(\"1\"); return ; }\n\t\tjie[0] = jieni[0] = 1;\n\t\tint up = n + 1;\n\t\tfor (int i = 1; i <= up; ++i)\tjie[i] = jie[i - 1] * i % P;\n\t\tjieni[up] = quickpow(jie[up], P - 2);\n\t\tfor (int i = up - 1; i; --i)\tjieni[i] = jieni[i + 1] * (i + 1) % P;\n\t\tll res = 0;\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tres = (res + get_c(n - i + 1, i) - get_c(n - i - 1, i - 2)) % P;\n\t\t}\n\t\tprintf(\"%lld\\n\", (res % P + P) % P);\n\t}\n}\nll f[N];\nll sum[N];\nint main() {\n\tread(n), read(m);\n\tscanf(\"%s\", s + 1);\n\tbool flag = false;\n\tint tmp = 0;\n\tfor (int i = 1; i <= m; ++i)\tif (s[i] != s[1]) { flag = true; tmp = i - 1; break; }\n\tif (!flag) { jzp1::sol(); return 0; }\n\tif (n & 1) { puts(\"0\"); return 0; }\n\tint lst = 1, mn = tmp | 1;\n\tfor (int i = 2; i <= m; ++i) {\n\t\tif (s[i] != s[1]) {\n\t\t\tif (lst & 1)\tMIN(mn, lst);\n\t\t\tlst = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == s[i - 1])\t++lst;\n\t\telse {\n\t\t\tif (lst & 1) MIN(mn, lst);\n\t\t\tlst = 1;\n\t\t}\n\t}\n\tn >>= 1;\n\tint k = (mn + 1) >> 1;\n\tMIN(k, n);\n\tf[0] = 1; sum[0] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (i <= k)\tf[i] = sum[i - 1];\n\t\telse f[i] = (sum[i - 1] - sum[i - k - 1]) % P;\n\t\tsum[i] = (sum[i - 1] + f[i]) % P;\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tans = (ans + f[n - i] * i) % P;\n\t}\n\tans = (ans << 1) % P;\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n\n/*\n3 3\nBBB\n//4\n\n1 1\nB\n//1\n\n12 10\nRRRRBRRRRB\n//78\n\n6 5\nRRBBR\n//8\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n        if(dp[i-1] < 0)dp[i-1] %= MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    return res;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i <= m;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int maxn=200111;\nconst int mod=1e9+7;\n\nint n,m,dp[maxn],pre[maxn];\nchar s[maxn];\n\nint main()\n{\n\tget2(n,m);\n\tscanf(\"%s\",s+1);\n\t\n\twhile(m>1&&s[m]==s[m-1])m--;\n\tif(m==1)\n\t{\n\t\tdp[0]=2;dp[1]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tdp[i]=dp[i-1]+dp[i-2];\n\t\t\tif(dp[i]>=mod)dp[i]-=mod;\n\t\t}\n\t\tprintf(\"%d\\n\",dp[n]);\n\t\treturn 0;\n\t}\n\t\n\tif(n%2==1)\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\t\n\tint bound=inf;\n\tfor(int i=1;i<=m;i++)if(s[i]==s[1]&&s[i]!=s[i-1])\n\t{\n\t\tint len=0;\n\t\twhile(s[i+len]==s[i])len++;\n\t\tif(len%2==1)bound=min(bound,len);\n\t\telse if(i==1)bound=min(bound,len+1);\n\t}\n\tbound=min(bound,n-1);\n\t\n\tn/=2;bound=(bound+1)/2;\n\tdp[0]=1;pre[0]=1;\n\tint sum=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i<=bound)dp[i]=pre[i-1];\n\t\telse dp[i]=(pre[i-1]-pre[i-bound-1]+mod)%mod;\n\t\tpre[i]=(pre[i-1]+dp[i])%mod;\n\t\tif(i>=n-bound)\n\t\t{\n\t\t\tint coef=((n-i)*2-1);\n\t\t\tif(i==n)coef=1;\n\t\t\tsum=(sum+(LL)dp[i]*coef)%mod;\n\t\t}\n\t}\n\tprintendl(sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for (int i = x; i < (int)(n); ++i)\n\nint const N = 200000, md = 1e9 + 7;\nchar s[N + 1];\nint dp[N + 1], n, m;\n\ninline void ad(int &x, int y) { if ((x += y) >= md)x -= md; }\ninline void sb(int &x, int y) { if ((x -= y) <  0 )x += md; }\ninline void out(int an) { printf(\"%d\\n\", an); exit(0); }\n\nvoid sad(){\n\tdp[0] = 1;\n\tdp[1] = 1;\n\tf(i, 2, n + 1)ad(dp[i] = dp[i - 1], dp[i - 2]);\n\tint an = dp[n];\n\tad(an, dp[n - 2]);\n\tout(an);\n}\n\nint main(){\n\tscanf(\"%d%d%s\", &n, &m, s);\n\tint mx = md;\n\tbool im = false;\n\tf(i, 0, m){\n\t\tint j = i;\n\t\twhile (j + 1 < m && s[j + 1] == s[i])++j;\n\t\tif (i == 0 && j + 1 == m)sad();\n\t\tim = !im;\n\t\tif (im){\n\t\t\tint ln = j - i + 1;\n\t\t\tif (ln & 1)mx = min(mx, ln);\n\t\t\telse if (i == 0)mx = min(mx, ln | 1);\n\t\t}\n\t\ti = j;\n\t}\n\tif (n & 1)out(0);\n\tn >>= 1;\n\tmx = mx + 1 >> 1;\n\tint l = 1, s = 0;\n\tf(i, 1, n + 1){\n\t\tif (i - l > mx)sb(s, dp[l++]);\n\t\tdp[i] = s;\n\t\tif (i <= mx)ad(dp[i], i << 1);\n\t\tad(s, dp[i]);\n\t}\n\tout(dp[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define P 1000000007\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n, m;\n\nchar ch[400010];\n\nll powmod(ll x, ll y = P - 2, ll p = P) {\n\tll ans = 1;\n\twhile(y) {\n\t\tif(y & 1) ans = ans * x % p;\n\t\tx = x * x % p;\n\t\ty >>= 1;\n\t}\n\treturn ans;\n}\n\nll F[400010][2][2], G[400010][2][2], H[400010], SH[400010], SG[400010][2][2];\n\n// G1 : ABABABA\n// G2 : BABABAB\n\nvoid cmin(int &x, int y) {if(x > y) x = y;}\n\nvoid add(ll &x, ll y) {x = (x + y) % P;}\n\nint main() {\n  puts(\"0\");\n  return 0;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", ch + 1);\n\tll ans = 0;\n\t// qingyise\n\tint sub1 = 1;\n\tfor(int i = 2; i <= m; i++) if(ch[i] != ch[1]) sub1 = 0;\n\tif(sub1 == 1) {\n\t\tF[0][0][0] = 1;\n\t\tF[0][1][1] = 1;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tfor(int j = 0; j < 2; j++) {\n\t\t\t\tF[i][j][0] = (F[i - 1][j][0] + F[i - 1][j][1]) % P;\n\t\t\t\tF[i][j][1] = (F[i - 1][j][0]) % P;\n\t\t\t}\n\t\tans = (F[n][0][0] + F[n][1][1]) % P;\n\t\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\t\treturn 0;\n\t}\n\tif(n % 2 == 1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tvector <int> V(1, 1);\n\tfor(int i = 2; i <= m; i++) if(ch[i] == ch[i - 1]) V.back()++; else V.push_back(1);\n\tint l = 0, r = 0, mnA = n + 5, mnB = n + 5, nw = 0;\n\tfor(int i = 1; i < V.size(); i += 2) {\n\t\tif(V[i] % 2 == 1) nw ^= 1;\n\t\tif(V[i + 1] % 2 == 1) {\n\t\t\tif(nw == 0) cmin(mnA, V[i + 1]); else cmin(mnB, V[i + 1]);\n\t\t}\n\t}\n\tcmin(mnA, V[0] + !(V[0] % 2));\n\tH[1] = 1, SH[1] = 1;\n\tfor(int i = 3; i <= n + 1; i += 2) {\n\t\tH[i] = SH[i - 2];\n\t\tif(i >= min(mnA, mnB) + 3) {\n\t\t\tadd(H[i], -SH[i - (min(mnA, mnB) + 3)]);\n\t\t}\n\t\t//H[i] = -H[i];\n\t\tSH[i] = (H[i] + SH[i - 2]) % P;\n\t}\n\tfor(int i = 1; i <= n; i += 2) {\n\t\t//if(n - i <= mnA) add(ans, G[i][1][1] * (n - i + 1));\n\t\t//if(n - i <= mnB) add(ans, G[i][0][0] * (n - i + 1));\n\t\tif(n - i <= min(mnA, mnB)) add(ans, H[i] * (n - i + 1));\n\t}\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/01/29] 12:36:49\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nvoid outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\n\n\ntemplate<typename T> T gcd(const T& a, const T& b) { return a < 0 ? gcd(-a, b) : b < 0 ? gcd(a, -b) : (a > b ? gcd(b, a) : a == 0 ? b : gcd(b % a, a)); }\ntemplate<typename T> T lcm(const T& a, const T& b) { return a / gcd(a, b) * b; }\ntemplate<typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto g = gcd(a, b), da = std::abs(b) / g;\n    const auto p = extgcd(b, a % b);\n    const auto x = (da + p.second % da) % da, y = (g - a * x) / b;\n    return {x, y};\n}\ntemplate<typename T>\nconstexpr T inverse(const T a, const T mod) { return extgcd(a, mod).first; }\ntemplate<uint mod_value, bool dynamic = false>\nclass modint_base\n{\npublic:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, const UInt> mod() { return mod_ref(); }\n    template<typename UInt = uint>\n    static constexpr std::enable_if_t<not dynamic, const UInt> mod() { return mod_value; }\n    template<typename UInt = uint>\n    static void set_mod(const std::enable_if_t<dynamic, const UInt> mod) { mod_ref() = mod, inv_ref() = {1, 1}; }\n    modint_base() : v{0} {}\n    modint_base(const ll val) : v{norm(static_cast<uint>(val % static_cast<ll>(mod()) + static_cast<ll>(mod())))} {}\n    modint_base(const modint_base& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    modint_base& operator=(const modint_base& m) { return v = m(), (*this); }\n    modint_base& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod()) + static_cast<ll>(mod()))), (*this); }\n    friend modint_base operator+(const modint_base& m) { return m; }\n    friend modint_base operator-(const modint_base& m) { return make(norm(mod() - m.v)); }\n    friend modint_base operator+(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + m2.v)); }\n    friend modint_base operator-(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + mod() - m2.v)); }\n    friend modint_base operator*(const modint_base& m1, const modint_base& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod()))); }\n    friend modint_base operator/(const modint_base& m1, const modint_base& m2) { return m1 * inv(m2.v); }\n    friend modint_base operator+(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) - val}; }\n    friend modint_base operator*(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * inv(val)}; }\n    friend modint_base operator+(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const ll val, const modint_base& m) { return modint_base{-static_cast<ll>(m.v) + val}; }\n    friend modint_base operator*(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const ll val, const modint_base& m) { return modint_base{val * inv(static_cast<ll>(m.v))}; }\n    friend modint_base& operator+=(modint_base& m1, const modint_base& m2) { return m1 = m1 + m2; }\n    friend modint_base& operator-=(modint_base& m1, const modint_base& m2) { return m1 = m1 - m2; }\n    friend modint_base& operator*=(modint_base& m1, const modint_base& m2) { return m1 = m1 * m2; }\n    friend modint_base& operator/=(modint_base& m1, const modint_base& m2) { return m1 = m1 / m2; }\n    friend modint_base& operator+=(modint_base& m, const ll val) { return m = m + val; }\n    friend modint_base& operator-=(modint_base& m, const ll val) { return m = m - val; }\n    friend modint_base& operator*=(modint_base& m, const ll val) { return m = m * val; }\n    friend modint_base& operator/=(modint_base& m, const ll val) { return m = m / val; }\n    friend modint_base operator^(const modint_base& m, const ll n) { return power(m.v, n); }\n    friend modint_base& operator^=(modint_base& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const modint_base& m1, const modint_base& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const modint_base& m1, const modint_base& m2) { return not(m1 == m2); }\n    friend bool operator==(const modint_base& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const modint_base& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const modint_base& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const ll val, const modint_base& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, modint_base& m)\n    {\n        ll v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const modint_base& m) { return os << m(); }\n    uint operator()() const { return v; }\n    static modint_base small_inv(const usize n)\n    {\n        auto& in = inv_ref();\n        if (n < in.size()) { return in[n]; }\n        for (usize i = in.size(); i <= n; i++) { in.push_back(-in[modint_base::mod() % i] * (modint_base::mod() / i)); }\n        return in.back();\n    }\n    std::pair<ll, ll> quad() const\n    {\n        const auto ans = quad_r(v, mod());\n        ll x = std::get<0>(ans), y = std::get<1>(ans);\n        if (y < 0) { x = -x, y = -y; }\n        return {x, y};\n    }\n\nprivate:\n    static std::tuple<ll, ll, ll> quad_r(const ll r, const ll p)  // r = x/y (mod p), (x,y,z) s.t. x=yr+pz\n    {\n        if (std::abs(r) <= 1000) { return {r, 1, 0}; }\n        ll nr = p % r, q = p / r;\n        if (nr * 2LL >= r) { nr -= r, q++; }\n        if (nr * 2LL <= -r) { nr += r, q--; }\n        const auto sub = quad_r(nr, r);\n        const ll x = std::get<0>(sub), z = std::get<1>(sub), y = std::get<2>(sub);\n        return {x, y - q * z, z};\n    }\n\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, UInt&> mod_ref()\n    {\n        static UInt mod = 0;\n        return mod;\n    }\n    static uint norm(const uint x) { return x < mod() ? x : x - mod(); }\n    static modint_base make(const uint x)\n    {\n        modint_base m;\n        return m.v = x, m;\n    }\n    static modint_base power(modint_base x, ull n)\n    {\n        modint_base ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static modint_base inv(const ll v) { return v <= 2000000 ? small_inv(static_cast<usize>(v)) : modint_base{inverse(v, static_cast<ll>(mod()))}; }\n    static std::vector<modint_base>& inv_ref()\n    {\n        static std::vector<modint_base> in{1, 1};\n        return in;\n    }\n    uint v;\n};\ntemplate<uint mod>\nusing modint = modint_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modint = modint_base<id, true>;\n\n\ntemplate<typename Real>\nstruct complex\n{\n    using value_type = Real;\n    complex() : real{Real{0}}, imag{Real{0}} {}\n    complex(const complex&) = default;\n    complex(const Real& theta) : real(std::cos(theta)), imag(std::sin(theta)) {}\n    complex(const Real& r, const Real& i) : real{r}, imag{i} {}\n    ~complex() = default;\n    friend complex operator+(const complex& c) { return c; }\n    friend complex operator-(const complex& c) { return complex{-c.real, -c.imag}; }\n    friend complex operator+(const complex& c1, const complex& c2) { return complex{c1.real + c2.real, c1.imag + c2.imag}; }\n    friend complex operator-(const complex& c1, const complex& c2) { return complex{c1.real - c2.real, c1.imag - c2.imag}; }\n    friend complex operator*(const complex& c1, const complex& c2) { return complex{c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real}; }\n    friend complex operator*(const complex& c, const Real& r) { return complex{c.real * r, c.imag * r}; }\n    friend complex operator/(complex& c1, complex& c2) { c1* c2.conj() / c2.norm(); }\n    friend bool operator==(const complex& c1, const complex& c2) { return c1.real == c2.real and c1.imag == c2.imag; }\n    friend bool operator!=(const complex& c1, const complex& c2) { return not(c1 == c2); }\n    friend complex& operator+=(complex& c1, const complex& c2) { return c1.real += c2.real, c1.imag += c2.imag, c1; }\n    friend complex& operator-=(complex& c1, const complex& c2) { return c1.real += c2.real, c1.imag += c2.imag, c1; }\n    friend complex& operator*=(complex& c1, const complex& c2) { return c1 = c1 * c2; }\n    friend complex& operator*=(complex& c, const Real& r) { return c = c * r; }\n    friend complex& operator/=(complex& c1, const complex& c2) { return c1 = c1 / c2; }\n    complex conj() const { return complex{real, -imag}; }\n    Real norm() const { return real * real + imag * imag; }\n    Real abs() const { return std::sqrt(norm()); }\n    Real arg() const { return std::atan2(imag, real); }\n    friend std::ostream& operator<<(std::ostream& os, const complex& c) { return os << c.real << \"+\" << c.imag << \"i\"; }\n    Real real, imag;\n};\ntemplate<typename Real = double>\nclass fft\n{\nprivate:\n    static constexpr usize depth = 30;\n    static constexpr Real pi     = pi_v<Real>;\n    static void transform(std::vector<complex<Real>>& a, const usize lg, const bool rev)\n    {\n        static std::vector<complex<Real>> root[depth];\n        const usize sz = a.size();\n        assert((1UL << lg) == sz);\n        if (root[lg].empty()) {\n            root[lg].reserve(sz), root[lg].resize(sz);\n            for (usize i = 0; i < sz; i++) { root[lg][i] = complex<Real>(pi * Real(2 * i) / Real(sz)); }\n        }\n        std::vector<complex<Real>> tmp(sz);\n        for (usize w = (sz >> 1); w > 0; w >>= 1) {\n            for (usize y = 0; y < (sz >> 1); y += w) {\n                const complex<Real> r = rev ? root[lg][y].conj() : root[lg][y];\n                for (usize x = 0; x < w; x++) {\n                    const auto u = a[y << 1 | x], v = a[y << 1 | x | w] * r;\n                    tmp[y | x] = u + v, tmp[y | x | (sz >> 1)] = u - v;\n                }\n            }\n            std::swap(tmp, a);\n        }\n    }\n\npublic:\n    using value_type = Real;\n    fft()            = delete;\n    template<typename T = ll, typename I = int>\n    static std::vector<T> simple_convolute(const std::vector<I>& a, const std::vector<I>& b)\n    {\n        const usize need = a.size() + b.size() - 1, lg = clog(need), sz = 1UL << lg;\n        std::vector<complex<Real>> x(sz), y(sz);\n        for (usize i = 0; i < a.size(); i++) { x[i] = {(Real)a[i], (Real)0}; }\n        for (usize i = 0; i < b.size(); i++) { y[i] = {(Real)b[i], (Real)0}; }\n        transform(x, lg, false), transform(y, lg, false);\n        for (usize i = 0; i < sz; i++) { x[i] *= y[i]; }\n        transform(x, lg, true);\n        std::vector<T> ans(need);\n        for (usize i = 0; i < need; i++) { ans[i] = (T)std::round(x[i].real / (Real)sz); }\n        return ans;\n    }\n    template<typename T = ll, usize division = 2, typename I = int>\n    static std::vector<T> convolute(const std::vector<I>& a, const std::vector<I>& b)\n    {\n        constexpr usize bitnum = (depth + division - 1) / division;\n        const usize need = a.size() + b.size() - 1, lg = clog(need), sz = 1UL << lg;\n        std::vector<complex<value_type>> x[division], y[division], tmp(sz);\n        for (usize i = 0; i < division; i++) {\n            x[i].reserve(sz), x[i].resize(sz), y[i].reserve(sz), y[i].resize(sz);\n            std::fill(tmp.begin() + std::min(a.size(), b.size()), tmp.end(), complex<value_type>{});\n            for (usize j = 0; j < a.size(); j++) { tmp[j].real = value_type((a[j] >> (bitnum * i)) & ((1 << bitnum) - 1)); }\n            for (usize j = 0; j < b.size(); j++) { tmp[j].imag = value_type((b[j] >> (bitnum * i)) & ((1 << bitnum) - 1)); }\n            transform(tmp, lg, false);\n            for (usize j = 0; j < sz; j++) { tmp[j] *= value_type(0.5); }\n            for (usize j = 0; j < sz; j++) {\n                const usize k = j == 0 ? 0UL : sz - j;\n                x[i][j] = complex<value_type>{tmp[j].real + tmp[k].real, tmp[j].imag - tmp[k].imag}, y[i][j] = complex<value_type>{tmp[j].imag + tmp[k].imag, -tmp[j].real + tmp[k].real};\n            }\n        }\n        std::vector<complex<value_type>> z[division];\n        for (usize i = 0; i < division; i++) { z[i].reserve(sz), z[i].resize(sz); }\n        for (usize a = 0; a < division; a++) {\n            for (usize b = 0; b < division; b++) {\n                for (usize i = 0; i < sz; i++) {\n                    if (a + b < division) {\n                        z[a + b][i] += x[a][i] * y[b][i];\n                    } else {\n                        z[a + b - division][i] += x[a][i] * y[b][i] * complex<value_type>(0, 1);\n                    }\n                }\n            }\n        }\n        for (usize i = 0; i < division; i++) { transform(z[i], lg, true); }\n        std::vector<T> ans(need);\n        T base = 1;\n        for (usize k = 0; k < 2 * division - 1; k++, base *= (1LL << bitnum)) {\n            for (usize i = 0; i < need; i++) {\n                if (k < division) {\n                    ans[i] += base * T(std::round(z[k][i].real / value_type(sz)));\n                } else {\n                    ans[i] += base * T(std::round(z[k - division][i].imag / value_type(sz)));\n                }\n            }\n        }\n        return ans;\n    }\n    template<uint mod, bool dynamic = false, usize division = 2>\n    static std::vector<modint_base<mod, dynamic>> convolute(const std::vector<modint_base<mod, dynamic>>& a, const std::vector<modint_base<mod, dynamic>>& b)\n    {\n        using mint             = modint_base<mod, dynamic>;\n        constexpr usize bitnum = (depth + division - 1) / division;\n        const usize need = a.size() + b.size() - 1, lg = clog(need), sz = 1UL << lg;\n        std::vector<complex<value_type>> x[division], y[division], tmp(sz);\n        for (usize i = 0; i < division; i++) {\n            x[i].reserve(sz), x[i].resize(sz), y[i].reserve(sz), y[i].resize(sz);\n            std::fill(tmp.begin() + std::min(a.size(), b.size()), tmp.end(), complex<value_type>{});\n            for (usize j = 0; j < a.size(); j++) { tmp[j].real = value_type((a[j]() >> (bitnum * i)) & ((1 << bitnum) - 1)); }\n            for (usize j = 0; j < b.size(); j++) { tmp[j].imag = value_type((b[j]() >> (bitnum * i)) & ((1 << bitnum) - 1)); }\n            transform(tmp, lg, false);\n            for (usize j = 0; j < sz; j++) { tmp[j] *= value_type(0.5); }\n            for (usize j = 0; j < sz; j++) {\n                const usize k = j == 0 ? 0UL : sz - j;\n                x[i][j] = complex<value_type>{tmp[j].real + tmp[k].real, tmp[j].imag - tmp[k].imag}, y[i][j] = complex<value_type>{tmp[j].imag + tmp[k].imag, -tmp[j].real + tmp[k].real};\n            }\n        }\n        std::vector<complex<value_type>> z[division];\n        for (usize i = 0; i < division; i++) { z[i].reserve(sz), z[i].resize(sz); }\n        for (usize a = 0; a < division; a++) {\n            for (usize b = 0; b < division; b++) {\n                for (usize i = 0; i < sz; i++) {\n                    if (a + b < division) {\n                        z[a + b][i] += x[a][i] * y[b][i];\n                    } else {\n                        z[a + b - division][i] += x[a][i] * y[b][i] * complex<value_type>(0, 1);\n                    }\n                }\n            }\n        }\n        for (usize i = 0; i < division; i++) { transform(z[i], lg, true); }\n        std::vector<mint> ans(need);\n        mint base = 1;\n        for (usize k = 0; k < 2 * division - 1; k++, base *= (1LL << bitnum)) {\n            for (usize i = 0; i < need; i++) {\n                if (k < division) {\n                    ans[i] += int((base * ll(std::round(z[k][i].real / value_type(sz))))());\n                } else {\n                    ans[i] += int((base * ll(std::round(z[k - division][i].imag / value_type(sz))))());\n                }\n            }\n        }\n        return ans;\n    }\n};\n\ntemplate<uint mod = 924844033, uint root = 5>\nclass ntt\n{\nprivate:\n    using value_type             = modint<mod>;\n    static constexpr usize depth = 30;\n    static void transform(std::vector<value_type>& a, const usize lg, const bool rev)\n    {\n        const usize N = a.size();\n        assert(1UL << lg == N);\n        static std::vector<value_type> R[depth];\n        if (R[lg].empty()) {\n            R[lg].reserve(N), R[lg].resize(N, value_type(1));\n            const value_type r = value_type(root) ^ ((mod - 1) / N);\n            for (usize i = 1; i < N; i++) { R[lg][i] = R[lg][i - 1] * r; }\n        }\n        std::vector<value_type> tmp(N);\n        for (usize w = (N >> 1); w > 0; w >>= 1) {\n            for (usize y = 0; y < (N >> 1); y += w) {\n                const value_type r = rev ? R[lg][y == 0 ? 0 : N - y] : R[lg][y];\n                for (usize x = 0; x < w; x++) {\n                    const auto u = a[y << 1 | x], v = a[y << 1 | x | w]() * r;\n                    tmp[y | x] = u + v, tmp[y | x | (N >> 1)] = u - v;\n                }\n            }\n            std::swap(tmp, a);\n        }\n        if (rev) {\n            for (usize i = 0; i < N; i++) { a[i] /= value_type(N); }\n        }\n    }\n\npublic:\n    ntt() = delete;\n    static std::vector<value_type> convolute(const std::vector<value_type>& a, const std::vector<value_type>& b)\n    {\n        const usize need = a.size() + b.size() - 1, lg = clog(need), sz = 1UL << lg;\n        std::vector<value_type> A(sz, 0), B(sz, 0);\n        for (usize i = 0; i < a.size(); i++) { A[i] = a[i](); }\n        for (usize i = 0; i < b.size(); i++) { B[i] = b[i](); }\n        transform(A, lg, false), transform(B, lg, false);\n        for (usize i = 0; i < sz; i++) { A[i] *= B[i]; }\n        transform(A, lg, true);\n        std::vector<value_type> ans(need);\n        for (usize i = 0; i < need; i++) { ans[i] = int(A[i]()); }\n        return ans;\n    }\n};\ntemplate<uint mod, uint root, bool dynamic, uint fft_division>\nclass poly_base\n{\npublic:\n    using value_type = modint_base<mod, dynamic>;\n    poly_base() : v(0) {}\n    poly_base(const value_type& r) : v{r} { shrink(); }\n    poly_base(const std::vector<value_type>& v) : v{v} { shrink(); }\n    poly_base(const std::initializer_list<value_type>&& list) : v{list} { shrink(); }\n    std::vector<value_type> operator()() const { return v; }\n    value_type& operator[](const usize i) { return v[i]; }\n    const value_type& operator[](const usize i) const { return v[i]; }\n    value_type at(const usize i) const { return i < size() ? v[i] : value_type(0); }\n    friend poly_base operator+(const poly_base& p) { return p; }\n    friend poly_base operator-(const poly_base& p)\n    {\n        std::vector<value_type> ans = p.v;\n        for (auto& e : ans) { e = -e; }\n        return poly_base(ans);\n    }\n    friend poly_base operator+(const poly_base& p, const poly_base& q)\n    {\n        const usize sz = std::max(p.size(), q.size());\n        std::vector<value_type> ans(sz);\n        for (usize i = 0; i < sz; i++) { ans[i] = p.at(i) + q.at(i); }\n        return poly_base(ans);\n    }\n    friend poly_base operator-(const poly_base& p, const poly_base& q)\n    {\n        const usize sz = std::max(p.size(), q.size());\n        std::vector<value_type> ans(sz);\n        for (usize i = 0; i < sz; i++) { ans[i] = p.at(i) - q.at(i); }\n        return poly_base(ans);\n    }\n    friend poly_base operator*(const poly_base& p, const poly_base& q) { return p.size() <= 300 or q.size() <= 300 ? naive_multiply(p, q) : fft_multiply(p, q); }\n    friend poly_base operator*(const poly_base& p, const value_type& r)\n    {\n        std::vector<value_type> ans = p.v;\n        for (auto& e : ans) { e *= r; }\n        return poly_base(ans);\n    }\n    friend poly_base operator/(const poly_base& p, const value_type& r)\n    {\n        std::vector<value_type> ans = p.v;\n        for (auto& e : ans) { e /= r; }\n        return poly_base(ans);\n    }\n    friend poly_base operator>>(const poly_base& p, const usize s) { return p.divide_by_power(s); }\n    friend poly_base operator<<(const poly_base& p, const usize s) { return p.multiply_power(s); }\n    friend poly_base operator/(const poly_base& p, const poly_base& q) { return p.div(q); }\n    friend poly_base operator%(const poly_base& p, const poly_base& q) { return p.rem(q); }\n    friend poly_base& operator+=(poly_base& p, const poly_base& q) { return p = p + q; }\n    friend poly_base& operator-=(poly_base& p, const poly_base& q) { return p = p - q; }\n    friend poly_base& operator*=(poly_base& p, const poly_base& q) { return p = p * q; }\n    friend poly_base& operator*=(poly_base& p, const value_type& r) { return p = p * r; }\n    friend poly_base& operator/=(poly_base& p, const value_type& r) { return p = p / r; }\n    friend poly_base& operator>>=(poly_base& p, const usize s) { return p = (p >> s); }\n    friend poly_base& operator<<=(poly_base& p, const usize s) { return p = (p << s); }\n    friend poly_base& operator/=(poly_base& p, const poly_base& q) { return p = p / q; }\n    friend poly_base& operator%=(poly_base& p, const poly_base& q) { return p = p % q; }\n    poly_base multiply_power(const usize s) const\n    {\n        const usize sz = size();\n        if (sz == 0) { return poly_base(); }\n        std::vector<value_type> ans(sz + s, 0);\n        for (usize i = 0; i < sz; i++) { ans[i + s] = v[i]; }\n        return poly_base(ans);\n    }\n    poly_base divide_by_power(const usize s) const\n    {\n        const usize N = size();\n        if (N <= s) { return poly_base(); }\n        std::vector<value_type> ans(N - s);\n        for (usize i = 0; i < N - s; i++) { ans[i] = v[i + s]; }\n        return poly_base(ans);\n    }\n    poly_base rem_by_power(const usize k) const { return size() <= k ? *this : poly_base(std::vector<value_type>(v.begin(), v.begin() + k)); }\n    poly_base inverse(const usize k) const\n    {\n        poly_base q{value_type(1) / v[0]};\n        const auto T = poly_base{2};\n        for (usize i = 1, j = 0; j < k; j++, i *= 2) { q = (q * (T - rem_by_power(2 * i) * q)).rem_by_power(2 * i); }\n        return q;\n    }\n    template<typename Int>\n    poly_base power_and_rem(const Int k, const usize s)\n    {\n        if (k == 0) { return poly_base(1); }\n        if (k % 2 == 1) {\n            return (power_and_rem(k - 1, s) * (*this)).rem_by_power(s);\n        } else {\n            const auto q = power_and_rem(k / 2, s);\n            return (q * q).rem_by_power(s);\n        }\n    }\n    template<typename Int>\n    static poly_base rem_of_power(const Int k, const poly_base& p)\n    {\n        const usize B = p.size() * 2 - 1;\n        const auto q  = p.pseudo_inv(B);\n        poly_base ans{1};\n        const usize D = log2p1<usize>(k);\n        for (usize i = 0; i < D; i++) {\n            if (k & (static_cast<Int>(1) << (D - i - 1))) { ans = (ans.multiply_power(1)).rem(p, q, B); }\n            if (D - i - 1) { ans = (ans * ans).rem(p, q, B); }\n        }\n        return ans;\n    }\n    usize size() const { return v.size(); }\n    friend std::ostream& operator<<(std::ostream& os, const poly_base& p)\n    {\n        if (p.size() == 0) { return os << \"0\"; }\n        for (usize i = 0; i < p.size(); i++) { os << (i != 0 ? \"+\" : \"\") << p[i] << (i != 0 ? i == 1 ? \"X\" : \"X^\" + std::to_string(i) : \"\"); }\n        return os;\n    }\n\nprivate:\n    static std::vector<value_type> naive_convolute(const std::vector<value_type>& a, const std::vector<value_type>& b)\n    {\n        std::vector<value_type> ans(a.size() + b.size() - 1, 0);\n        for (usize i = 0; i < a.size(); i++) {\n            for (usize j = 0; j < b.size(); j++) { ans[i + j] += a[i] * b[j]; }\n        }\n        return ans;\n    }\n    static poly_base naive_multiply(const poly_base& p, const poly_base& q) { return p.size() == 0 or q.size() == 0 ? poly_base{} : poly_base{naive_convolute(p(), q())}; }\n    template<typename Poly = poly_base>\n    static std::enable_if_t<root == 0, Poly> fft_multiply(const poly_base& p, const poly_base& q) { return p.size() == 0 or q.size() == 0 ? poly_base() : poly_base{fft<double>::convolute<mod, dynamic, fft_division>(p(), q())}; }\n    template<typename Poly = poly_base>\n    static std::enable_if_t<root != 0, Poly> fft_multiply(const poly_base& p, const poly_base& q) { return p.size() == 0 or q.size() == 0 ? poly_base() : poly_base{ntt<mod, root>::convolute(p(), q())}; }\n    poly_base rev(const usize l) const\n    {\n        std::vector<value_type> ans = v;\n        ans.resize(l), std::reverse(ans.begin(), ans.end());\n        return poly_base(ans);\n    }\n    poly_base div(const poly_base& q) const\n    {\n        assert(q.size() > 0);\n        if (size() < q.size()) { return poly_base(); }\n        const usize N = size();\n        const auto iq = q.pseudoInv(N);\n        return (*this * iq).divide_by_power(N - 1);\n    }\n    poly_base rem(const poly_base& q) const { return *this - div(q) * q; }\n    poly_base rem(const poly_base& q, const poly_base& iq, const usize B) { return *this - q * ((*this * iq).divide_by_power(B - 1)); }\n    void shrink()\n    {\n        for (; not v.empty() and v.back() == 0; v.pop_back()) {}\n    }\n    poly_base pseudo_inv(const usize B) const\n    {\n        const usize N = size();\n        return rev(N).inverse(B + 2 > N ? clog(B - N + 2) : 0).rev(B + 1 - N);\n    }\n    std::vector<value_type> v;\n};\ntemplate<uint mod, uint fft_division = 2>\nusing poly = poly_base<mod, 0, false, fft_division>;\ntemplate<uint mod, uint fft_division = 2>\nusing dynamic_poly = poly_base<mod, 0, true, fft_division>;\ntemplate<uint mod = 924844033, uint root = 5>\nusing ntt_poly = poly_base<mod, root, false, 0>;\nint main()\n{\n    using mint   = modint<mod>;\n    using P      = poly<mod>;\n    const auto N = in<int>(), M = in<int>();\n    auto S = in<std::string>();\n    if (S[0] == 'B') {\n        for (auto& c : S) { c = (c == 'R' ? 'B' : 'R'); }\n    }\n    if (S == std::string(M, 'R')) {\n        assert(false);\n        mint ans = 0;\n        mint r = 1, b = 0;\n        for (int i = 0; i < N - 2; i++) {\n            mint r_ = r, b_ = b;\n            r = r_ + b_, b = r_;\n        }\n        ans += r;\n        r = 1, b = 1;\n        for (int i = 0; i < N - 2; i++) {\n            mint r_ = r, b_ = b;\n            r = r_ + b_, b = r_;\n        }\n        ans += r + b;\n        return outln(ans);\n    }\n    if (N % 2 == 1) { return outln(0); }\n    S.push_back('$');\n    std::vector<int> ls;\n    char p = 'R';\n    int l  = 0;\n    for (int i = 0; i <= M; i++) {\n        if (S[i] != p) {\n            p = S[i];\n            ls.push_back(l);\n            l = 1;\n        } else {\n            l++;\n        }\n    }\n    SHOW(ls);\n    int m = inf_v<int>;\n    for (int i = 0; i < ls.size(); i += 2) {\n        if (i == 0) {\n            chmin(m, ls[i] / 2 + 1);\n        } else if (ls[i] % 2 == 1) {\n            chmin(m, (ls[i] + 1) / 2);\n        }\n    }\n    SHOW(m);\n    const int n = N / 2;\n    // x1+x2+...+xk = n\n    // xi <= max\n    std::vector<mint> c(m + 1, 1);\n    for (int i = 1; i <= m; i++) { c[i] = -1; }\n    P f{c};\n    const auto g = f.inverse(clog(n + 1));\n    mint ans     = 0;\n    for (int r1 = 1; r1 <= std::min(n, m); r1++) { ans += g.at(n - r1) * 2 * r1; }\n    outln(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint N, M; char S[200200];\n\nconst long long mod = 1000000007;\nlong long D[200200], V[200200];\n\nint main()\n{\n\tscanf (\"%d %d %s\", &N, &M, S);\n\tif (S[0] == 'B'){\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tif (S[i] == 'R') S[i] = 'B';\n\t\t\telse S[i] = 'R';\n\t\t}\n\t}\n\n\tvector<int> len;\n\tfor (int i = 1, l = -1; i < M; i++){\n\t\tif (S[i-1] == 'R' && S[i] == 'B'){\n\t\t\tint u = i - l - 1;\n\t\t\tlen.push_back(u);\n\t\t}\n\t\tif (S[i] == 'B') l = i;\n\t}\n\n\tif (len.empty()){\n\t\tif (N == 2){\n\t\t\tprintf (\"3\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tD[0] = 1;\n\t\tD[1] = 2;\n\t\tfor (int i = 2; i <= N; i++) D[i] = (D[i - 1] + D[i - 2]) % mod;\n\t\tprintf (\"%lld\\n\", (D[N - 1] + D[N - 3]) % mod);\n\t\treturn 0;\n\t}\n\n\tint lim = len[0];\n\tif (lim % 2 == 0) lim++;\n\tfor (int i = 1; i < len.size(); i++){\n\t\tif (len[i] % 2){\n\t\t\tif (lim > len[i])\n\t\t\t\tlim = len[i];\n\t\t}\n\t}\n\n\tD[0] = V[0] = 1;\n\tfor (int i = 1; i <= N; i++){\n\t\tif (i <= lim + 1) D[i] = i - 1;\n\t\tlong long u = 0, v = 0;\n\t\tif (i >= 2) u = V[i - 2];\n\t\tif (i >= lim + 3) v = V[i - (lim + 3)];\n\t\tD[i] = (D[i] + u + mod - v) % mod;\n\n\t\tV[i] = D[i];\n\t\tif (i >= 2) V[i] = (V[i] + V[i - 2]) % mod;\n\t}\n\tprintf (\"%lld\\n\", D[N]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const deque<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class S, class T,class U,class V,class W> ostream& operator<<(ostream &os, const tuple<S,T,U,V,W> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\",\"<<get<4>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7;\n\nll modpow(ll r,ll n,ll m=MOD){\n  ll re=1,d=r%m;\n  if(n<0)(n%=m-1)+=m-1;\n  for(;n;n/=2){\n    if(n&1)(re*=d)%=m;\n    (d*=d)%=m;\n  }\n  return re;\n}\ntemplate <int mod=MOD> struct modInt{\n  int v;\n  modInt(int v=0):v(v){}\n  modInt(ll v):v(v%MOD){}\n  modInt operator+(const modInt &n)const{return v+n.v<mod ? v+n.v : v+n.v-mod;}\n  modInt operator-(const modInt &n)const{return v-n.v<0 ? v-n.v+mod : v-n.v;}\n  modInt operator*(const modInt &n)const{return ll(v)*n.v%mod;}\n  modInt operator/(const modInt &n)const{return ll(v)*modpow(n.v%mod,-1,mod)%mod;}\n  modInt operator+(const ll &n)const{return v+n<mod ? v+n : v+n-mod;}\n  modInt operator-(const ll &n)const{return v-n<0 ? v-n+mod : v-n;}\n  modInt operator*(const ll &n)const{return ll(v)*(n%mod)%mod;}\n  modInt operator/(const ll &n)const{return ll(v)*modpow(n%mod,-1,mod)%mod;}\n  modInt& operator+=(const modInt &n){v+=n.v; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const modInt &n){v-=n.v; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const modInt &n){v=ll(v)*n.v%mod; return *this;}\n  modInt& operator/=(const modInt &n){v=ll(v)*modpow(n.v,-1,mod)%mod; return *this;}\n  modInt& operator+=(const ll &n){v+=n; if(v>=mod) v-=mod; return *this;}\n  modInt& operator-=(const ll &n){v-=n; if(v<0) v+=mod; return *this;}\n  modInt& operator*=(const ll &n){v=ll(v)*n%mod; return *this;}\n  modInt& operator/=(const ll &n){v=ll(v)*modpow(n,-1,mod)%mod; return *this;}\n};\n#ifdef NUIP\nclass MINT_FRAC____{\npublic:\n\tunordered_map<int,pii> dict;\n\tMINT_FRAC____(int n){\n\t\trep(p,n+1)reps(q,1,n+1)if(__gcd(p,q)==1){\n\t\t\tdict[1ll*p*modpow(q,-1)%MOD]=pii(p,q);\n\t\t\tdict[MOD-1ll*p*modpow(q,-1)%MOD]=pii(-p,q);\n\t\t}\n\t}\n} Il1Il1Il1(1000);\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){if(Il1Il1Il1.dict.count(n.v)) os<<n.v<<\"(\"<<Il1Il1Il1.dict[n.v].X<<\"/\"<<Il1Il1Il1.dict[n.v].Y<<\")\";else os<<n.v;return os;};\n#else\ntemplate<int mod> ostream& operator<<(ostream &os,const modInt<mod> &n){return os<<n.v;};\n#endif\ntemplate<int mod> modInt<mod> operator+(const ll &n,const modInt<mod> &m){return m.v+n<mod ? m.v+n : m.v+n-mod;}\ntemplate<int mod> modInt<mod> operator-(const ll &n,const modInt<mod> &m){return n-m.v<0 ? n-m.v+mod : n-m.v;}\ntemplate<int mod> modInt<mod> operator*(const ll &n,const modInt<mod> &m){return ll(m.v)*(n%mod)%mod;}\ntemplate<int mod> modInt<mod> operator/(const ll &n,const modInt<mod> &m){return modInt<mod>(n%mod)/m;}\ntypedef modInt<MOD> mint;\ntemplate <int mod> modInt<mod> modpow(modInt<mod> r,ll n){ modInt<mod> re(1); if(n<0)(n%=mod-1)+=mod-1; for(;n;n/=2){if(n&1) re*=r; r*=r;} return re;}\nvector<mint> fact,finv,inv;\nmint comb(ll n,ll r){ if(n<r||r<0)return 0; return fact[n]*finv[n-r]*finv[r];}\nclass Doralion{\n  void Modinvs(vector<mint> &re,int n){ re.resize(n+1); re[1]=1; for(int i=2;i<=n;++i)re[i]=re[MOD%i]*(MOD-MOD/i);}\n  void Facts(vector<mint> &re,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*(i+1);}\n  void Factinvs(vector<mint> &re,const vector<mint> &inv,int n){ re.resize(n+1); re[0]=1; rep(i,n)re[i+1]=re[i]*inv[i+1];}\npublic:\n  Doralion(int n){ Modinvs(inv,n); Facts(fact,n); Factinvs(finv,inv,n);}\n} doralion(212345);\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\tint n,m;\n\tstring s;\n\tcin>>n>>m>>s;\n\tif(s==string(m,'R') || s==string(m,'B')){\n\t\tvector<mint> dp(212345);\n\t\tdp[1]=1;\n\t\trep(i,210345){\n\t\t\tdp[i+1]+=dp[i];\n\t\t\tdp[i+2]+=dp[i];\n\t\t}\n\t\t// rep(i,10) out(i,dp[i],1);\n\t\tmint re=dp[n];\n\t\tre+=dp[n-1]*2;\n\t\tcout<<re<<endl;\n\t\treturn 0;\n\t}\n\tint r=0,b=0;\n\t{\n\t\tint con=0;\n\t\tchar prv='.';\n\t\tstring str=s+'!';\n\t\tfor(char c:str){\n\t\t\tif(c!=prv){\n\t\t\t\tif(prv=='R') MX(r,con);\n\t\t\t\tif(prv=='B') MX(b,con);\n\t\t\t\tcon=0;\n\t\t\t\tprv=c;\n\t\t\t}\n\t\t\t++con;\n\t\t}\n\t}\n\tif(r%2==0) --r;\n\tif(b%2==0) --b;\n\n\tmint re=0;\n\t{\n\tvector<mint> dpr(n+1),dpb(n+1);\n\tqueue<mint> currq,nxtrq,curbq,nxtbq;\n\tmint curr=0,nxtr=0,curb=0,nxtb=0;\n\tdpr[0]=1;\n\tcurrq.emplace(1); curr=1;\n\trep(i,n){\n\t\twhile(currq.size()>r){ curr-=currq.front(); currq.pop();}\n\t\twhile(curbq.size()>b){ curb-=curbq.front(); curbq.pop();}\n\t\tdpr[i]=curr;\n\t\tdpb[i]=curb;\n\t\tnxtr+=dpr[i]; nxtrq.emplace(dpr[i]);\n\t\tnxtb+=dpb[i]; nxtbq.emplace(dpb[i]);\n\t\tswap(currq,nxtrq); swap(curr,nxtr);\n\t\tswap(curbq,nxtbq); swap(curb,nxtb);\n\t}\n\treps(i,1,min(n,r)+1)if(i%2) re+=dpb[n-i-1];\n\t}\n\n\t{\n\tvector<mint> dpr(n+1),dpb(n+1);\n\tqueue<mint> currq,nxtrq,curbq,nxtbq;\n\tmint curr=0,nxtr=0,curb=0,nxtb=0;\n\tdpb[0]=1;\n\tcurbq.emplace(1); curb=1;\n\trep(i,n){\n\t\twhile(currq.size()>r){ curr-=currq.front(); currq.pop();}\n\t\twhile(curbq.size()>b){ curb-=curbq.front(); curbq.pop();}\n\t\tdpr[i]=curr;\n\t\tdpb[i]=curb;\n\t\tnxtr+=dpr[i]; nxtrq.emplace(dpr[i]);\n\t\tnxtb+=dpb[i]; nxtbq.emplace(dpb[i]);\n\t\tswap(currq,nxtrq); swap(curr,nxtr);\n\t\tswap(curbq,nxtbq); swap(curb,nxtb);\n\t}\n\treps(i,1,min(n,b)+1)if(i%2) re+=dpr[n-i-1];\n\t}\n\tcout<<re<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,m;\nchar str[200050];\nconst int mod = 1000000007;\nint dp[200050];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str + 1);\n\tbool c1 = 0,c2 = 0;\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tc1 |= str[i] == 'R';\n\t\tc2 |= str[i] == 'B';\n\t}\n\tint p = 1;\n\tint lim;\n\tif(c1 && c2)\n\t{\n\t\tif(n & 1)\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(;str[p + 1] == str[1]; ++ p);\n\t\tlim = p + (p % 2 == 0);\n\t\tint len = 0;\n\t\tfor(int i = p + 1;i <= m; ++ i)\n\t\t{\n\t\t\tif(str[i] != str[1]) lim = min(lim,len % 2 ? len : 10000000),len = 0;\n\t\t\telse len ++;\n\t\t}\n\t\tlim ++;\n\t\tlim /= 2;\n\t\tlim = min(lim,n / 2);\n\t\tint pre = 1;\n\t\tint cur = 0;\n\t\tdp[0] = 1;\n\t\tlong long ans = 0;\n\t\tfor(int i = 0;i <= n / 2; ++ i)\n\t\t{\n\t\t\tif(i)\n\t\t\t{\n\t\t\t\twhile(i - cur > lim) pre -= dp[cur],pre = (pre + mod) % mod,cur ++;\n\t\t\t\tdp[i] = pre;\n\t\t\t\tpre += dp[i];\n\t\t\t\tpre %= mod;\n\t\t\t}\n\t\t\tif(n - i * 2 > 0 && (n - i * 2) / 2 <= lim)\n\t\t\t\tans = ans + 1LL * (n - i * 2) * dp[i] % mod,ans %= mod;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse\n\t{\n\t\tint pre = 0;\n\t\tint cur = 0;\n\t\tdp[0] = 1;\n\t\tlong long ans = 0;\n\t\tfor(int i = 0;i <= n; ++ i)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\tdp[i] = pre;\n\t\t\t\tpre += dp[i - 1];\n\t\t\t\tpre %= mod;\n\t\t\t}\n\t\t\tif(n - i > 1)\n\t\t\t\tans = ans + 1LL * (n - i) * dp[i] % mod,ans %= mod;\n\t\t}\n\t\tprintf(\"%lld\\n\",(ans + 1) % mod);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=2e5+10,mod=1e9+7;\ninline void Dec(int &x,int y) { x-=y; if(x<0) x+=mod; }\ninline void Add(int &x,int y) { x+=y; if(x>=mod) x-=mod; }\nchar S[N];\nint n,m,f[N];\nint main() {\n\trd(n),rd(m);\n\tscanf(\"%s\",S+1);\n\tchar c=S[1];\n\tint p=1,r=1,L=m;\n\t\n\twhile(r<=m&&S[r]==c) r++;\n\tif(r==m+1) {\n\t\tif(n==2) { printf(\"3\\n\"); return 0; }\n\t\tf[0]=1,f[1]=2;\n\t\tfor(int i=2;i<=n;++i) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",(f[n-3]+f[n-1])%mod);\n\t\treturn 0;\n\t}\n\t\n\tL=min(L,(r-p)|1);\t\n\tp=r;\n\twhile(p<=m&&S[p]!=c) p++;\n\t\n\tdo {\n\t\tr=p;\n\t\twhile(r<=m&&S[r]==c) r++;\n\t\tif((r-p)&1) L=min(L,r-p);\n\t\tp=r;\n\t\twhile(p<=m&&S[p]!=c) p++;\n\t} while(p<=m);\n\t\n\tint sum[2]={0,0};\n\tf[1]=1,sum[1]=1;\n\tfor(int i=2;i<=n;++i) {\n\t\tf[i]=sum[i&1];\n\t\tif(i-L-1>=1) Dec(sum[i&1],f[i-L-1]);\n\t\tAdd(sum[i&1],f[i]);\n\t}\n\tint ans=0;\n\tfor(int i=2;i<=n;++i) {\n\t\tif(n-i>L||!((n-i)&1)) continue;\n\t\tAdd(ans,f[i]*(ll)(n-i+1)%mod);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tstring s;\n\tcin >> s;\n\tset<char>st;\n\tfor (auto i : s)st.insert(i);\n\tif (st.size() == 1) {\n\t\tvector<long long int>dp(N + 1);\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1];\n\t\t\tif (i > 1)dp[i] += dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tlong long int ans = dp.back();\n\t\tdp[0] = 1;\n\t\tdp[1] = 0;\n\t\tfor (int i = 2; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tans += dp.back();\n\t\tans %= MOD;\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\ts.push_back(s[0] + 1);\n\tvector<int>num(s.size() + 1);\n\tfor (int i = 0; i <= s.size(); i++) {\n\t\tnum[i] = s[i] == s[0];\n\t\tif (i)num[i] = num[i] * (num[i - 1] + 1);\n\t}\n\tint fst = 0;\n\tint m = MOD;\n\tbool even = true;\n\tfor (int i = 1; i <= s.size(); i++) {\n\t\tif (!num[i] && num[i - 1]) {\n\t\t\tif (num[i - 1] & 1) {\n\t\t\t\teven = false;\n\t\t\t\tm = min(m, num[i - 1]);\n\t\t\t}\n\t\t\tif (fst == 0) {\n\t\t\t\tfst = num[i - 1];\n\t\t\t\tif (fst % 2 == 0)m = MOD;\n\t\t\t}\n\t\t}\n\t}\n\tif (even) {\n\t\tm = fst + 2;\n\t}\n\telse if (fst % 2 == 0) {\n\t\tm = min(m, fst + 1);\n\t}\n\telse assert(0);\n\tif (m & 1)m++;\n\tvector<long long int>dp(N + 2);\n\tvector<long long int>sum(N + 2);\n\tfor (int i = 2; i <= m; i += 2)dp[i] = i;\n\tfor (int i = 2; i <= N; i++) {\n\t\tdp[i] += sum[i - 2] + MOD;\n\t\tif (i - m - 2 >= 0)dp[i] -= sum[i - m - 2];\n\t\tdp[i] %= MOD;\n\t\tif (i == N) {\n\t\t\tcout << dp[i] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsum[i] = sum[i - 2] + dp[i];\n\t\tsum[i] %= MOD;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nint Mn(int a,int b){return a<b?a:b;}\nconst int N=2e5+5,mod=1e9+7;\nint upt(int x){while(x>=mod)x-=mod;while(x<0)x+=mod;return x;}\n\nint n,m,lm,dp[N],sm[N],ans,f[N][5];\nchar s[N];\nvoid solve()\n{\n  f[1][0]=1;\n  for(int i=2;i<=n;i++)\n    {\n      f[i][0]=f[i-1][0];\n      f[i][1]=(f[i-1][1]+f[i-1][2]);\n      f[i][2]=upt(f[i-1][0]+f[i-1][1]);\n    }\n  int ans=(f[n][0]+upt(f[n][1]+f[n][2]));\n  f[1][2]=1; f[1][0]=f[1][1]=0;\n  for(int i=2;i<=n;i++)\n    {\n      f[i][1]=(f[i-1][1]+f[i-1][2]);\n      f[i][2]=f[i-1][1];\n    }\n  ans=upt(ans+f[n][1]); printf(\"%d\\n\",ans);\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&m);\n  scanf(\"%s\",s+1); bool fg=0;\n  for(int i=1;i<=m;i++)\n    if(s[i]!=s[1]){fg=1;break;}\n  if(!fg){solve();return 0;}\n  if(n&1){puts(\"0\");return 0;}\n  lm=n+1; int lst;\n  for(int i=m;i;i--)if(s[i]==s[1]){lst=i;break;}\n  for(int i=1;i<=m;i++)\n    if(s[i]==s[1])//== not !=\n      {\n\tint j=i;\n\twhile(j+1<=m&&s[j+1]==s[j])j++;\n\tswap(i,j); j=i-j+1;\n\tif(i-j==0) lm=Mn(lm,j+((j&1)==0));\n\telse if((j&1)&&i!=lst)lm=Mn(lm,j);//i!=lst!!!\n      }\n  n>>=1; lm=(lm+1)>>1; dp[0]=sm[0]=1;\n  for(int i=1;i<=n;i++)\n    {\n      dp[i]=sm[i-1]; if(i>lm)dp[i]=upt(dp[i]-sm[i-lm-1]);\n      sm[i]=upt(sm[i-1]+dp[i]);\n    }\n  int ans=0;\n  for(int i=1;i<=lm;i++)//lm not n\n    ans=(ans+(ll)i*2*dp[n-i])%mod;\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nbool S[200000];\nlong DP[4][200000];\nlong C[100000];\nvoid Calc(){\n\tint N = rei();\n\tint M = rei();\n\tstring s = res();\n\tfor(int i=0;i<M;i++){\n\t\tS[i] = s[i] == s[0];\n\t}\n\tlong ans;\n\t{\n\t\tbool AllSame = true;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tAllSame &= S[i];\n\t\t}\n\t\tif(AllSame){\n\t\t\tDP[0][0] = 1;\n\t\t\tDP[3][0] = 1;\n\t\t\tfor(int i=1;i<N;i++){\n\t\t\t\tDP[0][i] = DP[1][i-1];\n\t\t\t\tDP[1][i] = (DP[1][i-1]+DP[0][i-1]) % mod;\n\t\t\t\tDP[2][i] = DP[3][i-1];\n\t\t\t\tDP[3][i] = (DP[3][i-1]+DP[2][i-1]) % mod;\n\t\t\t}\n\t\t\tans = DP[1][N-1] + DP[2][N-1] + DP[3][N-1];\n\t\t\tans %= mod;\n\t\t\tcout << ans << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tif(N % 2 != 0){\n\t\tcout << 0 << endl;\n\t\treturn;\n\t}\n\tint K = -1;\n\t{\n\t\tint before = 0;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tif(S[i]){\n\t\t\t\tbefore++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(K == -1){\n\t\t\t\t\tK = (before+2)/2;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(before % 2 != 0){\n\t\t\t\t\t\tK = min(K,(before+2)/2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbefore = 0;\n\t\t\t}\n\t\t}\n\t}\n\tC[0] = 1;\n\tlong sum = 1;\n\tfor(int i=1;i<N/2;i++){\n\t\tC[i] = sum;\n\t\tsum += C[i];\n\t\tif(i-K >= 0){\n\t\t\tsum += mod - C[i-K];\n\t\t}\n\t\tsum %= mod;\n\t}\n\tans = 0;\n\tfor(int i=1;i<=min(N/2,K);i++){\n\t\tans += i*C[N/2-i]%mod;\n\t}\n\tans *= 2;\n\tans %= mod;\n\tcout << ans << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nint fact[1111111];\nint inv[1111111];\n\nint mpow(int n,int m){\n\tint ret=1;\n\twhile(m){\n\t\tif(m&1)ret=ret*n%mod;\n\t\tn=n*n%mod;\n\t\tm>>=1;\n\t}\n\treturn ret;\n}\n\nint binom(int n,int k){\n\treturn fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\ninline void add(int &a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\nint N,M;\nstring S;\n\nsigned main(){\n\tfact[0]=1;\n\tfor(int i=1;i<1111111;i++)fact[i]=fact[i-1]*i%mod;\n\tinv[1111111-1]=mpow(fact[1111111],mod-2);\n\tfor(int i=1111111-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n\n\n\tcin>>N>>M;\n\tcin>>S;\n\n\tif(S[0]=='B'){\n\t\trep(i,M){\n\t\t\tif(S[i]=='R')S[i]='B';\n\t\t\telse S[i]='R';\n\t\t}\n\t}\n\n\twhile(S.size()&&S.back()=='R')S.pop_back();\n\n\tif(S.size()==0){\n\t\tint ans=0;\n\t\tint a=1,b=0;\n\t\trep(i,N){\n\t\t\tint aa=(a+b)%mod;\n\t\t\tint bb=a;\n\t\t\ta=aa;b=bb;\n\t\t}\n\t\tadd(ans,a);\n\n\t\ta=0;b=1;\n\t\trep(i,N){\n\t\t\tint aa=(a+b)%mod;\n\t\t\tint bb=a;\n\t\t\ta=aa;b=bb;\n\t\t}\n\t\tadd(ans,b);\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\n\tif(N%2){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\tassert(0);\n\n\tint ma=1001001001;\n\tint cur=0;\n\twhile(cur<S.size()){\n\t\tint nex=cur;\n\t\twhile(nex<S.size()&&S[cur]==S[nex])nex++;\n\t\tif(S[cur]=='R'){\n\t\t\tint l=nex-cur;\n\t\t\tif(cur==0){\n\t\t\t\tif(l%2)chmin(ma,l);\n\t\t\t\telse chmin(ma,l+1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(l%2)chmin(ma,l);\n\t\t\t}\n\t\t}\n\t\tcur=nex;\n\t}\n\n\tcout<<ma<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    string s;\n    cin>>s;\n    if(s[0]=='B'){\n        for(int i=0;i<m;i++){\n            if(s[i]=='B'){s[i]='R';}\n            else{s[i]='B';}\n        }\n    }\n    ll l=0;\n    while(l<m && s[l]=='R'){l++;}\n    ll mi=E;\n    if(l&1){mi=l;}\n    else{mi=l+1;}\n    for(ll i=l;i<m;i++){\n        if(s[i]=='R'){\n            ll w=i;\n            while(i<m && s[i]=='R'){i++;}\n            if(i!=m){\n                ll L=i-w;\n                if(L&1){mi=min(mi,L);}\n            }\n        }\n    }\n    vector<ll> dp(n,0);\n    vector<ll> sum(n,0);\n    dp[0]=sum[0]=1;\n    for(int i=2;i<n;i+=2){\n        ll r=sum[i-2];\n        ll l=(i-mi-3>=0?sum[i-mi-3]:0LL);\n        dp[i]=r-l;\n        dp[i]%=MOD;\n        sum[i]=sum[i-2]+dp[i];\n        sum[i]%=MOD;\n        //cout<<dp[i]<<\" \"<<sum[i]<<endl;\n    }\n    ll ans=0;\n    for(ll i=2;i<=mi+1 && n-i>=0;i++){\n        ans+=dp[n-i]*i%MOD;\n    }\n    if(l==m){ans++;}\n    ans%=MOD;\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 1;\n    rdp[0] = 1;\n    for(int i = 1;i <= n+1;i++){\n        dp[i] = (rdp[i-1] - ((i-limit-1)>=0?rdp[i-limit-1]:0)) % MOD;\n        if(dp[i] < 0)dp[i] += MOD;\n        rdp[i] = (rdp[i-1] + dp[i]) % MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n+10, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    bool allsame = true;\n    for(int i = 0;i < m;i++)allsame &= (str[i] == str[0]);\n    if(true||allsame){\n        cout << all(n) << endl;\n        return 0;\n    }\n    for(int i = 0;i < m;i++)vec.push_back(str[i] == str[0]);\n    vec.push_back(0);\n    Int l = 0;\n    while(vec[l] == 1)l++;\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i < vec.size();i++){\n        if(vec[i] == 1)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=200005,mod=1000000007;\nll ksm(ll a,int b){\n\tint ans=1;\n\tfor(;b;b>>=1){\n\t\tif(b&1)ans=ans*a%mod;\n\t\ta=a*a%mod;\n\t}\n\treturn ans;\n}\nll fac[N],f[N],ni[N];\nchar ch[N];\nint q[N];\nll c(int a,int b){\n\treturn a>=b&&b>=0?fac[a]*ni[b]%mod*ni[a-b]%mod:0;\n}\nint main(){\n\tFor(i,fac[0]=1,N-1)fac[i]=fac[i-1]*i%mod; ni[N-1]=ksm(fac[N-1],mod-2);\n\tRep(i,N-1,1)ni[i-1]=ni[i]*i%mod;\n\tint n=read(),m=read();\n\tscanf(\"%s\",ch+1);\n\tif(ch[1]=='B')For(i,1,m)ch[i]='R'+'B'-ch[i];\n\tint fr=1;\n\tFor(i,2,m)if(ch[i]!=ch[i-1])fr=0;\n\tif(fr){\n\t\tll ans=0;\n\t\tFor(i,1,n)ans=(ans+c(i-1,n-i)+2*c(i-1,n-i-1))%mod;\n\t\twriteln(ans);\n\t\treturn 0;\n\t}\n\tint cnt=0,mx=1e9;\n\tFor(i,1,m){\n\t\tif(ch[i]=='B'){\n\t\t\tif(cnt&1)mx=min(mx,cnt); else mx=min(mx,cnt+1);\n\t\t\tcnt=0;\n\t\t}else cnt++;\n\t}\n\tif(n&1){\n\t\tputs(\"0\"); return 0;\n\t}\n\tint t=mx; \n\tmx/=2; mx+=2;  //cout<<mx<<endl;\n\tstatic ll ans[N];\n\tans[0]=1;\n\tFor(i,1,n){\n\t\tif(i==1)ans[i]=-1; else ans[i]=0;\n\t\tans[i]=(ans[i]+(ll)ans[i-1]*2)%mod;\n\t\tif(i>=mx)ans[i]=(ans[i]-ans[i-mx])%mod;\n\t}\n\t//For(i,0,n)cout<<ans[i]<<\" \";puts(\"\");\n\tll sum=0;\n\tfor(int i=1;i<=t&&i<=n;i+=2){\n\t\tsum=(sum+(i+1)*ans[(n-i-1)/2])%mod;// cout<<(i+1)<<\" \"<<ans[(n-i-1)/2]<<endl;\n\t}\n\tcout<<(sum+mod)%mod<<endl;\n}\n/*\n6 3\nRRB\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 200010\n#define int long long\n#define mod 1000000007\n#define debug cerr<<__LINE__<<\" \"<<__FUNCTION__<<\"\\n\"\n\ninline int read(){\n    int x=0,y=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')y=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=(x<<1)+(x<<3)+(ch^48);ch=getchar();}\n    return x*y;\n}\nvoid put(int x){\n    if(x<0) putchar('-'),x=-x;\n    if(x>=10) put(x/10);\n    putchar((x%10)+48);\n}\nint n,m,A[N],B[N];\nstring s;\nsigned main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tn=read();m=read();\n\tcin>>s;\n\tif(s[0]=='B'){\n\t\tfor(int i=0;i<m;i++) s[i]=(s[i]=='B'?'R':'B');\n\t}\n\tint pos=s.find('B');\n\tif(pos==string::npos){\n\t\tA[1]=A[2]=1;\n\t\tfor(int i=3;i<=n;i++) A[i]=(A[i-1]+A[i-2])%mod;\n\t\tcout<<(A[n]+2*A[n-1]%mod)%mod<<\"\\n\";\n\t\treturn 0;\n\t}\n\tif(n&1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint l=0x7ffffffff,res=0,flag=1;\n\tfor(int i=0;i<m;i++){\n\t\tif(s[i]=='B'){\n\t\t\tif(flag||(res&1)) l=min(l,res+2);\n\t\t\tflag=0;\n\t\t\tres=0;\n\t\t}else res++;\n\t}\n//\tcerr<<l<<\"\\n\";\n\tl/=2;n/=2;\n\tA[0]=B[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tA[i]=B[i-1];\n\t\tif(i>l) A[i]=(A[i]-B[i-l-1]+mod)%mod;\n\t\tB[i]=(B[i-1]+A[i])%mod;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=l;i++){\n\t\tans=(ans+2*i%mod*A[n-i]%mod)%mod;\n\t}\n\tcout<<ans<<\"\\n\";\n//\tfclose(stdin);\n//\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tstring s;\n\tcin >> s;\n\tset<char>st;\n\tfor (auto i : s)st.insert(i);\n\tif (st.size() == 1) {\n\t\tvector<long long int>dp(N + 1);\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1];\n\t\t\tif (i > 1)dp[i] += dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tlong long int ans = dp.back();\n\t\tdp[0] = 1;\n\t\tdp[1] = 0;\n\t\tfor (int i = 2; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tans += dp.back();\n\t\tans %= MOD;\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\tassert(N&1);\n\ts.push_back(s[0] + 1);\n\tvector<int>num(s.size() + 1);\n\tfor (int i = 0; i <= s.size(); i++) {\n\t\tnum[i] = s[i] == s[0];\n\t\tif (i)num[i] = num[i] * (num[i - 1] + 1);\n\t}\n\tint fst = 0;\n\tint m = MOD;\n\tbool even = true;\n\tfor (int i = 1; i <= s.size(); i++) {\n\t\tif (!num[i] && num[i - 1]) {\n\t\t\tif (num[i - 1] & 1) {\n\t\t\t\teven = false;\n\t\t\t\tm = min(m, num[i - 1]);\n\t\t\t}\n\t\t\tif (fst == 0) {\n\t\t\t\tfst = num[i - 1];\n\t\t\t\tif (fst % 2 == 0)m = MOD;\n\t\t\t}\n\t\t}\n\t}\n\tif (even) {\n\t\tm = fst + 2;\n\t}\n\telse if (fst % 2 == 0) {\n\t\tm = min(m, fst + 1);\n\t}\n\tif (m & 1)m++;\n\tcout << m << endl;\n\tvector<long long int>dp(N + 2);\n\tvector<long long int>sum(N + 2);\n\tfor (int i = 2; i <= m; i += 2)dp[i] = i;\n\tfor (int i = 2; i <= N; i++) {\n\t\tdp[i] += sum[i - 2] + MOD;\n\t\tif (i - m - 2 >= 0)dp[i] -= sum[i - m - 2];\n\t\tdp[i] %= MOD;\n\t\tif (i == N) {\n\t\t\tcout << dp[i] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsum[i] = sum[i - 2] + dp[i];\n\t\tsum[i] %= MOD;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-03 17:07:09\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=200010,mod=1000000007;\nint n,m,flag,l,Flag;\ni64 f[N],F[N],ans;\nchar s[N];\nint main()\n{\n\tn=read(); m=read();\n\tscanf(\"%s\",s+1);\n\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\tif(!flag)\n\t{\n\t\tf[1]=1; f[2]=2;\n\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t}\n\tl=n-1;\n\tfor(int i=1,j;i<=m;)\n\t\tif(s[i]==s[1])\n\t\t{\n\t\t\tj=i;\n\t\t\twhile(s[j]==s[1]) j++;\n\t\t\tif(j>n) break;\n\t\t\tif(((j-i)&1)||(!Flag)){ l=std::min(l,(j-i)+(!((j-i)&1))); Flag=1; }\n\t\t\ti=j+1;\n\t\t}\n\t\telse i++;\n\tif(n&1){ printf(\"0\\n\"); return 0; }\n\tn/=2; l=(l+1)/2;\n//\tprintf(\"%d %d\\n\",int(n),int(l));\n\tf[0]=F[0]=1;\n\tfr(i,1,n)\n\t{\n\t\tf[i]=(F[i-1]+mod-(i-l-1>=0?F[i-l-1]:0))%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t}\n\tans=f[n];\n\tfr(i,1,l) ans=(ans+f[n-i]*(2*i-1))%mod;\n\tprintf(\"%d\\n\",int(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9+7;\nint n,m;\nchar ss[200005];\nint f[200005],qz[200005];\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",&ss[1]);\n\tbool mk = 0;\n\tint mx = 0;\n\tfor(int i=1;i<=m;i++) {\n\t\tif(ss[i]!=ss[1]) { mk = 1; mx = i-1; break; }\n\t}\n\tif(!mk) {\n\t\tint ans = 1;\n\t\tf[0] = qz[0] = 1;\n\t\tfor(int i=0;i<=n;i++) {\n\t\t\tif(i>=2) f[i] = qz[i-2];\n\t\t\tif(i!=0)qz[i] = (qz[i-1]+f[i])%mod;\n\t\t\tif(n-i>=2) ans = (ans+1ll*f[i]*(n-i)%mod)%mod;\n\t\t}\n\t\tprintf(\"%d\",ans);\n\t\treturn 0;\n\t}\n\tif(n&1) {\n\t\tputs(\"0\"); return 0;\n\t}\n\tint lx = 0;\n\tfor(int i=1;i<=m;i++) {\n\t\tif(ss[i]==ss[1]) lx++;\n\t\telse {\n\t\t\tif(lx&1) mx = min(mx,lx);\n\t\t\tlx = 0;\n\t\t}\n\t}\n\tmx = mx/2+1;\n\tn/=2;\n\tf[0] = qz[0] = 1;\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tf[i] = (qz[i-1] - (i-mx-1>=0?qz[i-mx-1]:0) )%mod;\n\t\tqz[i] = (qz[i-1]+f[i])%mod;\n\t\tif(n-i<=mx) ans = (ans + 1ll * f[i]*2%mod*(n-i)%mod )%mod;\n\t}\n\tprintf(\"%d\",(ans%mod+mod)%mod );\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <list>\n#include <iterator>\n#include <assert.h>\n#pragma warning(disable:4996) \n\ntypedef long long ll;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF 9223300000000000000\n#define INF 2140000000\nconst long long MOD = 1000000007;\nusing namespace std;\n\nchar str[200005];\n\n// A(Bを数個)A(Bを数個)..A(Bを数個) \n// という列の作り方が何通りあるか、を求める\n// ただし列の長さをn、Bを重ねるのは各箇所について0個以上k個以下とする\n// また両端がつながっているものとする\nll func( int n, int k)\n{\n#ifdef _DEBUG\n    printf(\"%d %d\\n\", n, k);\n#endif\n    vector<ll> dp(n+1);   // dp[i]: func(i,k)と同じ。ただし両端がつながっていないものとする。\n    vector<ll> sdp(n+2);  // dpの累積和\n    dp[0]=1;\n    sdp[0]=0; sdp[1]=1;\n    int i;\n    for(i=1; i<=n; i++) {\n        dp[i]=(sdp[i]-sdp[MAX(0,i-k-1)]+MOD)%MOD;\n        sdp[i+1]=(sdp[i]+dp[i])%MOD;\n    }\n    ll ans = dp[n];\n\n    // dp[n]は、Aから始まるものだけを数えたもの。\n    // 両端がつながっている状況で、Bから始まるものを数える\n    // Bが最初にp個重なった場合を考えて足し合わせればよい\n    int p;\n    for(p=1; p<=k; p++) {\n        // dp[n-p-1],dp[n-p-2],..という(k-p+1)個を足し合わせればよい\n        ans = (ans + sdp[n-p] - sdp[n-k-1])%MOD;\n    }\n\n    return ans;\n}\n\nint main(int argc, char* argv[])\n{\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    scanf(\"%s\", str);\n\n    char c=str[0];\n    int max_odd=0;\n    int cnt_first=-1;\n    int cnt=0;\n    int cnt2=0;\n    int i;\n    for(i=0; i<m; i++) {\n        if(str[i]==c) {\n            cnt++;\n        }\n        else {\n            if(cnt==0) {\n                if(n%2==0) printf(\"2\\n\");\n                else       printf(\"0\\n\");\n                return 0;\n            }\n            if(cnt_first<0) cnt_first=cnt;\n            if(cnt%2) max_odd = MAX(max_odd, cnt);\n            cnt=0;\n            cnt2++;\n        }        \n    }\n\n    if(cnt2==0) {\n        printf(\"%lld\\n\", func(n, 1));\n    }\n    else {\n        if(n%2==0) {\n            int k = (cnt_first%2==0? cnt_first+1: cnt_first);\n            if(max_odd>0) k = MIN(k, max_odd);\n            printf(\"%lld\\n\", func(n/2, (k-1)/2) *2 %MOD);\n        }\n        else {\n            printf(\"0\\n\");\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cassert>\n\nusing namespace std;\n\nconst int mod = 1000000007;\nchar s[200001];\nlong long dp[200001][2];\nlong long dp2[200001][2];\n\nint main() {\n    int n, m, c, i, j;\n    long long ans = 0;\n    vector <int> v, w;\n    \n    scanf(\"%d %d\", &n, &m);\n    scanf(\"%s\", s);\n    \n    for (i = 0; i < m; ) {\n        for (j = i; j < m; j++) {\n            if (s[i] != s[j]) break;\n        }\n        \n        v.push_back(j - i);\n        i = j;\n    }\n    v.back() = 1e9;\n    \n    c = v[0] + 1;\n    for (i = 0; i < v.size(); i += 2) {\n        if (v[i] % 2 == 1) c = min(c, v[i]);\n    }\n    \n    dp[0][1] = 1;\n    dp[1][1] = mod - 1;\n    dp2[0][1] = 1;\n    dp2[1][1] = mod - 1;\n    \n    for (i = 0; i <= n; i++) {\n        if (i > 0) {\n            for (j = 0; j < 2; j++) {\n                dp[i][j] += dp[i - 1][j];\n                if (dp[i][j] >= mod) dp[i][j] -= mod;\n                \n                dp2[i][j] += dp2[i - 1][j];\n                if (dp2[i][j] >= mod) dp2[i][j] -= mod;\n            }\n        }\n        \n        if (i == 0) {\n            dp[1][0] = 2;\n            for (j = 2; j <= c && j <= n; j++) dp[j][0] = 1;\n            if (c + 1 <= n) dp[c + 1][0] = mod - (c + 1);\n        } else if (i % 2 == 1) {\n            if (i + 1 <= n) {\n                dp[i + 1][1] += dp[i][0];\n                if (dp[i + 1][1] >= mod) dp[i + 1][1] -= mod;\n            }\n            \n            if (i + 2 <= n) {\n                dp[i + 2][1] -= dp[i][0];\n                if (dp[i + 2][1] < 0) dp[i + 2][1] += mod;\n            }\n        } else {\n            if (i + 1 <= n) {\n                dp[i + 1][0] += dp[i][1];\n                if (dp[i + 1][0] >= mod) dp[i + 1][0] -= mod;\n            }\n            \n            if (i + c + 1 <= n) {\n                dp[i + c + 1][0] -= dp[i][1];\n                if (dp[i + c + 1][0] < 0) dp[i + c + 1][0] += mod;\n            }\n        }\n        \n        if (i == 0) {\n            dp2[1][0] = 2;\n            for (j = 2; j <= c && j <= n; j++) dp2[j][0] = 1;\n            if (c + 1 <= n) dp2[c + 1][0] = mod - (c + 1);\n        } else {\n            if (i + 1 <= n) {\n                dp2[i + 1][1] += dp2[i][0];\n                if (dp2[i + 1][1] >= mod) dp2[i + 1][1] -= mod;\n            }\n            \n            if (i + 2 <= n) {\n                dp2[i + 2][1] -= dp2[i][0];\n                if (dp2[i + 2][1] < 0) dp2[i + 2][1] += mod;\n            }\n            \n            if (i + 1 <= n) {\n                dp2[i + 1][0] += dp2[i][1];\n                if (dp2[i + 1][0] >= mod) dp2[i + 1][0] -= mod;\n            }\n            \n            if (i + c + 1 <= n) {\n                dp2[i + c + 1][0] -= dp2[i][1];\n                if (dp2[i + c + 1][0] < 0) dp2[i + c + 1][0] += mod;\n            }\n        }\n    }\n        \n    if (n % 2 == 0) ans = dp[n][1];\n    if (v.size() == 1) ans = (ans + dp2[n][1] + 1) % mod;\n    \n    assert(v.size() >= 2);\n    \n    printf(\"%lld\\n\", ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"base.hpp\"//5\n#ifndef __clang__\n#pragma GCC optimize (\"O3\")\n#endif\nvoid solve(\n#ifdef GCJ_CASE\nlong long case_id\n#endif\n);\n#if defined(EBUG) && !defined(ONLINE_JUDGE)\n#define debug true\n#define _GLIBCXX_DEBUG\n// #define _LIBCPP_DEBUG 0\n#define _LIBCPP_DEBUG2 0\n#else\n#define NDEBUG\n#define debug false\n#endif\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<limits>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<type_traits>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\nusing LL=long long;\nusing ULL=unsigned long long;\n#define int LL\n#define CS const\n#define CX constexpr\n#define IL inline\n#define OP operator\n#define RT return\n#define TL template\n#define TN typename\n#define lambda [&]\n#define rep(f,t,i,c,u)for(int Rb_=(t),i=(f);i c Rb_;u(i))\n#define upto(f,t,i)rep(f,t,i,<=,++)\n#define uptil(f,t,i)rep(f,t,i,<,++)\n#define downto(f,t,i)rep(f,t,i,>=,--)\n#define downtil(f,t,i)rep(f,t,i,>,--)\n#define times(n,i)uptil(0,n,i)\n#define rtimes(n,i)downto((n)-1,0,i)\n#define iter(v)begin(v),end(v)\n#define citer(v)cbegin(v),cend(v)\n#define riter(v)rbegin(v),rend(v)\n#define criter(v)crbegin(v),crend(v)\n#define IF(a,b,c)((a)?(b):(c))\n#if debug\n#define ln <<endl\n#else\n#define ln <<'\\n'\n#endif\n#define tb <<'\\t'\n#define sp <<' '\n#line 1 \"base_util.hpp\"//5b\n#define BINOPa(t,u,op)t OP op(CS u&o)CS{RT t(*this)op##=o;}\n#define CMPOP(t,op,f1,f2,x)bool OP op(CS t&x)CS{RT f1 op f2;}\n#define CMPOPS(t,f1,f2,x)CMPOP(t,==,f1,f2,x)CMPOP(t,!=,f1,f2,x)\\\nCMPOP(t,<,f1,f2,x)CMPOP(t,<=,f1,f2,x)CMPOP(t,>,f1,f2,x)CMPOP(t,>=,f1,f2,x)\n#line 1 \"mod.hpp\"//5b\n#ifndef MOD\n#define MOD 1000000007\n#endif\n#if !defined(FORCE_MOD)&&MOD!=1000000007&&MOD!=1000000009&&MOD!=998244353\n#error mod\n#endif\n#line 1 \"power.hpp\"//5bm\nTL<TN T>IL T power(T x,int n){T r(1);for(;n;n/=2){if(n%2)r*=x;x*=x;}RT r;}IL int pow_mod(int x,int n,int m){int r=1;\nfor(;n;n/=2){if(n%2)r=r*x%m;x=x*x%m;}RT r;}\n#line 2001 \"mod.hpp\"//5b\nIL CX int modulo(int a,int b){a%=b;RT a&&(a>0)!=(b>0)?a+b:a;}IL CX int divide(int a,int b){RT(a-modulo(a,b))/b;}\nTL<int d=MOD>struct MInt{\n/*!https://ei1333.github.io/luzhiled/snippets/other/mod-int.html*/\nint v;CX MInt():v(0){}explicit CX MInt(int i):v(modulo(i,d)){}MInt&OP+=(CS MInt&m){v+=m.v;if(v>=d)v-=d;RT*this;}\nMInt&OP-=(CS MInt&m){v-=m.v;if(v<0)v+=d;RT*this;}MInt&OP*=(CS MInt&m){v=v*m.v%d;RT*this;}MInt&OP/=(CS MInt&m){\nRT*this*=m.inv();}BINOPa(MInt,MInt,+)BINOPa(MInt,MInt,-)BINOPa(MInt,MInt,*)BINOPa(MInt,MInt,/)MInt OP-()CS{\nRT MInt()-=*this;}CMPOP(MInt,==,v,m.v,m)CMPOP(MInt,!=,v,m.v,m)MInt pow(int n)CS{RT power(*this,n);}MInt inv()CS{\nint a=v,b=d,x=1,y=0;while(b){swap(y,x-=a/b*y);swap(b,a%=b);}RT(MInt)x;}\nfriend ostream&OP<<(ostream&o,CS MInt&m){RT o<<m.v;}friend istream&OP>>(istream&i,MInt&m){i>>m.v;m.v%=d;RT i;}};\nusing mint=MInt<>;CX mint OP\"\" _m(ULL n){RT mint(n);}CX MInt<998244353>OP\"\" _m998244353(ULL n){RT MInt<998244353>(n);}\nCX MInt<1000000007>OP\"\" _m1e9_7(ULL n){RT MInt<1000000007>(n);}\nCX MInt<1000000009>OP\"\" _m1e9_9(ULL n){RT MInt<1000000009>(n);}\n#line 1 \"typedefs.hpp\"//5b\nusing unit = tuple<>;using int128=__int128;using LD=long double;TL<TN T>using vec=vector<T>;\nTL<TN T>using vvec=vec<vec<T>>;TL<TN T>using vvvec=vec<vvec<T>>;TL<TN T>using vvvvec=vec<vvvec<T>>;\nusing VM=vec<mint>;using VI=vec<int>;\n#line 1 \"alias.hpp\"//5b\n#define EB emplace_back\n#define PB push_back\n#define foldl accumulate\n#define scanl partial_sum\n#line 1 \"util.hpp\"//5b\nTL<TN T>IL bool amax(T&v,CS T&a){RT v<a&&(v=a,1);}TL<TN T>IL bool amin(T&v,CS T&a){RT v>a&&(v=a,1);}\nTL<TN T>IL int sizeRAB(T t){RT t.size();}\n#define size sizeRAB\n#define clamp clampRAB\nTL<TN T>IL CX CS T&clamp(CS T&a,CS T&l,CS T&r){RT a<l?l:r<a?r:a;}TL<TN V>IL void uniq2(V&v){\nv.erase(unique(iter(v)),v.end());}TL<TN V>IL void uniq(V&v){sort(iter(v));uniq2(v);}\n#define leftmost_ge lower_bound\n#define leftmost_gt upper_bound\nnamespace rab{TL<TN I>IL bool is_in(I x,I l,I r){RT l<=x&&x<r;}TL<TN T>IL T fetch(CS T&d,CS vec<T>&v,int i){\nRT 0<=i&&i<size(v)?v[i]:d;}}\n#line 1 \"debug.hpp\"//5b\nTL<TN T>IL istream&OP>>(istream&s,vec<T>&v){for(auto&&p:v)s>>p;RT s;}TL<TN T,TN S>\nIL ostream&OP<<(ostream&s,CS pair<T,S>&p){RT s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\n#define Rdebug1(sep, ...)IL ostream& OP<<(ostream&s,CS __VA_ARGS__&v){\\\nint i=0;for(CS auto&e:v){i++&&s<<sep;s<<e;}RT s;}\nTL<TN T>Rdebug1(' ',vec<T>)TL<TN T,TN S>Rdebug1(' ',map<T,S>)TL<TN T>Rdebug1('\\n',vvec<T>)\nTL<TN T,TN S>Rdebug1('\\n',vec<map<T,S>>)\n#line 6001 \"base.hpp\"//5\nsigned main(){if(debug)cerr<<\"MOD: \"<<MOD ln;else cin.tie(0),cerr.tie(0),ios::sync_with_stdio(0);\nauto p=setprecision(20);cout<<fixed<<p;cerr<<fixed<<p;\n#ifdef GCJ_CASE\nint T;cin>>T;times(T,t){cout<<\"Case #\"<<t+1<<\": \";solve(t);}\n#else\nsolve();\n#endif\nRT 0;}\n#line 1001 \"5.cpp\"//\n//#include \"consts.hpp\"\n// #include \"prime.hpp\"\n\nvoid solve() {\n// NM\"S\"\n/* <foxy.memo-area> */\nint N;int M;string S;cin>>N;cin>>M;cin>>S;\n/* </foxy.memo-area> */\n\n  if(S[0] == 'B') {\n    times(M, i) S[i] = 'R' + 'B' - S[i];\n  }\n\n  {\n    times(M, i) if(S[i] != 'R') goto not_same;\n\n    int i = 0, j = 1;\n    times(100, o)\n      while(++i) i == 100 || (j *= i);\n\n    mint ans = 0_m;\n    {\n      // [0]->R\n      VM dp(N);\n      dp[0] = 1_m;\n      dp[1] = 2_m;\n      uptil(2, N, i) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n      }\n      ans += dp[N - 1];\n      {if(debug)cerr<<\"dp: \"<<(dp)ln;}\n    }\n    {\n      // [0]->B\n      VM dp(N - 1);\n      dp[0] = 1_m;\n      if(N >= 3) dp[1] = 1_m;\n      uptil(2, N - 1, i) {\n        dp[i] = dp[i - 1] + dp[i - 2];\n      }\n      ans += dp[N - 2];\n      {if(debug)cerr<<\"dp: \"<<(dp)ln;}\n    }\n\n    cout << ans ln;\n    return;\n  }\n  not_same:;\n\n  int p = 1ll << 60;\n  {\n    int ren = 1;\n    times(M, i) {\n      if(S[i] == 'R') {\n        ++ren;\n      } else {\n        if(p == 1ll << 60 || ren % 2 == 1) {\n          amin(p, ren);\n        }\n        ren = 0;\n      }\n    }\n  }\n  {if(debug)cerr<<\"p: \"<<(p)ln;}\n#define M hoge\n\n  if(N % 2 == 1) {\n    cout << 0 ln;\n    return;\n  }\n\n  int m = N / 2;\n  int q = (p + 1) / 2;\n\n#define N hoge\n#define p hoge\n\n  /*\n  auto pfh = prime_factor(m);\n  int zpf = size(pfh);\n  VI pf; pf.reserve(zpf);\n  for(auto &p : pfh) pf.PB(p.first);\n  {if(debug)cerr<<\"pf: \"<<(pf)ln;}\n  */\n\n  /*\n  VI pf;\n  for(int i = 1; i*i <= m; ++i) {\n    if(m % i == 0) {\n      pf.PB(i);\n      if(i*i != m) pf.PB(m / i);\n    }\n  }\n  sort(iter(pf));\n  */\n  VI pf = {m};\n  {if(debug)cerr<<\"pf: \"<<(pf)ln;}\n  int zpf = size(pf);\n\n  VM dp(m);\n  VM g(zpf);\n\n  mint ans = 0_m;\n\n  times(zpf, h) {\n    mint s = dp[0] = 1_m;\n    uptil(1, pf[h], i) {\n      s += dp[i] = s;\n      if(i >= q) {\n        s -= dp[i - q];\n      }\n      if(i <= q) {\n        dp[i] += dp[0] * mint(i - 1);\n        s += dp[0] * mint(i - 1);\n      }\n    }\n\n    g[h] = s;\n    times(h, hh) {\n      if(pf[h] % pf[hh] == 0) g[h] -= g[hh];\n    }\n    ans += g[h] ;//* mint(pf[h]);\n\n    {if(debug)cerr<<'#'<<__LINE__ ln<<\"  h:     \"<<(h)ln<<\"  pf[h]: \"<<(pf[h])ln<<\"  s:     \"<<(s)ln<<\"  g[h]:  \"<<(g[h])ln<<\"  dp:    \"<<(dp)ln;}\n  }\n\n  cout << ans * 2_m ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nconst int maxn=2e5+50;\nint n,m;\nint f[maxn];\nint s[maxn];\nchar S[maxn];\ninline int add(int x)\n{\n\treturn x>=mod?x-mod:x;\n}\ninline int dec(int x)\n{\n\treturn x<0?x+mod:x;\n}\nvoid dp(int L)\n{\n\tf[1]=s[1]=1;\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tf[i]=dec(s[i-1]-s[max(0,i-L-2)]);\n\t\ts[i]=add(s[i-1]+f[i]);\n\t} \n}\nint solve()\n{\n\tif(S[1]=='B')\n\t{\n\t\tfor(int i=1;i<=m;++i)\n\t\t{\n\t\t\tS[i]=S[i]=='R'?'B':'R'; \n\t\t}\n\t}\n\tint an=0,k=1,L=n;\n\twhile(k<m&&S[k+1]=='R')\n\t{\n\t\t++k;\n\t}\n\tif(k==m)\n\t{\n\t\tstatic int f[maxn][2];\n\t\tmemset(f,0,sizeof(f)); \n\t\tf[1][0]=1;\n\t\tfor(int i=1;i<n;++i)\n\t\t{\n\t\t\tf[i+1][0]=add(f[i][0]+f[i][1]);\n\t\t\tf[i+1][1]=add(f[i][0]);\n\t\t}\n\t\tan=add(an+f[n][0]);\n\t\tan=add(an+f[n][1]);\n\t\tmemset(f,0,sizeof(f));\n\t\tf[1][1]=1;\n\t\tfor(int i=1;i<n;++i)\n\t\t{\n\t\t\tf[i+1][0]=add(f[i][0]+f[i][1]);\n\t\t\tf[i+1][1]=add(f[i][0]);\n\t\t}\n\t\tan=add(an+f[n][0]);\n\t\treturn an;\n\t}\n\tif(n&1) return 0;\n\tL=k&1?k:k+1;\n\tfor(int i=k+1,j;i<=m;i=j+1)\n\t{\n\t\tj=i;\n\t\twhile(j<=m&&S[j]!='B')\n\t\t{\n\t\t\t++j;\n\t\t}\n\t\tif(j==m+1) continue;\n\t\tint _k=j-i;\n\t\tif(_k&1) L=min(L,_k);\n\t}\n\tn>>=1,L>>=1;\n\tdp(L);\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tif(n-i>L) break;\n\t\tan=(an+(ll)(n-i+1)*f[i])%mod;\n\t}\n\tan=add(an<<1);\n\treturn an;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",S+1);\n\tprintf(\"%d\\n\",solve());\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define pii pair<int, int>\n#define p3i pair<pii, int>\n#define pll pair<ll, ll>\n#define p3l pair<pll, ll>\n#define vi vector<int>\n#define vpii vector<pii>\n#define vp3i vector<p3i>\n#define vpll vector<pll>\n#define vp3l vector<p3l>\n#define lseg L, (L+R)/2, N*2+1\n#define rseg (L+R)/2+1, R, N*2+2\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define MN 1000000007\n#define fox(k, x) for (int k=0; k<x; ++k)\n#define fox1(k, x) for (int k=1; k<=x; ++k)\n#define foxr(k, x) for (int k=x-1; k>=0; --k)\n#define fox1r(k, x) for (int k=x; k>0; --k)\n#define ms multiset\n#define flood(x) memset(x, 0x3f3f3f3f, sizeof x)\n#define drain(x) memset(x, 0, sizeof x)\n#define rng() ((rand() << 14)+rand())\n#define scan(X) do{while((X=getchar())<'0'); for(X-='0'; '0'<=(_=getchar()); X=(X<<3)+(X<<1)+_-'0');}while(0)\nchar _;\n#define pi 3.14159265358979323846\n\nint n, m, dp[200005], psa[200005];\nint sum, ans=0;\nstring s;\nint get(int N, int L){\n  int hi = N;\n  int lo = hi - L - 1;\n  //cout << N << ' ' << L << ' ' <<lo << ' ' << hi << endl;\n  int res = psa[hi];\n  if (lo >= 0) res -= psa[lo];\n  return res%MN;\n}\nint32_t main(){\n  cin >> n >> m >> s;\n  int pref = 0, lim, c = 0;\n  fox(l, m){\n    if (s[l] != s[0]) break;\n    pref++;\n  }\n  if (pref % 2 == 1)\n    lim = pref;\n  else\n    lim = pref + 1;\n  if (pref == m){\n    dp[0] = 1;\n    dp[1] = 1;\n    for(int l = 2; l <= n; ++l){\n      dp[l] = (dp[l-1]+dp[l-2])%MN;\n    }\n    cout << (dp[n-2] + dp[n] + 0LL + MN)%MN;\n    return 0;\n  }\n  if (n%2 == 1){\n    if (pref != m){\n      printf(\"0\\n\");\n      return 0;\n    }\n  }\n  fox(l, m){\n    if (s[l]!=s[0]){\n      if (c%2 == 1){\n        lim = min(lim, c);\n      }\n      c=0;\n    } else {\n      c++;\n    }\n  }\n  n/=2;\n  lim /= 2;\n  lim = min(lim, n-1);\n  //cout << lim << endl;\n  dp[0]= 1;\n  int p=0;\n  sum = 1;\n  psa[0] = 1;\n  fox1(l, n){\n    while(l-p-1 > lim){\n      sum = (sum - dp[p]) % MN;\n      ++p;\n    }\n    dp[l] = sum;\n    psa[l] = (psa[l-1] + dp[l]) % MN;\n    sum = (sum + dp[l]) % MN;\n    //cout << dp[l] << ' ';\n  }\n  fox(l, lim+1){\n    //starting component\n    ans = (ans + get(n-1-l, lim-l))%MN;\n  }\n  if (ans < 0) ans += MN;\n  cout << ans*2%MN;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MAX_N 200000\n#define MAX_M 200000\n#define MOD 1000000007\n\n#define INF 1 << 29\n\nint N, M;\nstring S;\n\n// long long dp[MAX_N + 2], rdp[MAX_N + 2];\n\n// int all_color_is_same()\n// {\n//     long long rr = 1, bb = 1, rb = 0, br = 0;\n\n//     for ( int i = 1; i < N; i++ )\n//     {\n//         long long nrr = ( rr + rb ) % MOD;\n//         long long nbb = br;\n//         long long nrb = rr;\n//         long long nbr = ( bb + br ) % MOD;\n\n//         rr = nrr;\n//         bb = nbb;\n//         rb = nrb;\n//         br = nbr;\n//     }\n\n//     return ( rr + rb + br ) % MOD;\n// }\n\n// /**\n\n/* S\nの先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n*/\nint min_freq()\n{\n    int l = 0;\n    while ( l < M && S[0] == S[l] ) l++;\n\n    int ans = ( l & 1 ) ? l : l + 1;\n\n    l = 0;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[0] == S[i] )\n            l++;\n        else if ( l & 1 )\n        {\n            ans = min( ans, l );\n            l = 0;\n        }\n    }\n    return l ? min( ans, l ) : ans;\n}\n\n// int solve()\n// {\n//     // 一色\n//     if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n//         return all_color_is_same();\n\n//     // N が奇数\n//     if ( N & 1 ) return 0;\n\n//     int L = min_freq();\n\n//     L = ( L + 1 ) >> 1;\n//     N >>= 1;\n\n//     dp[0] = rdp[0] = 1;\n//     for ( int i = 1; i <= N + 1; i++ )\n//     {\n//         dp[i] = rdp[i - 1];\n//         if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n//         if ( dp[i] < 0 ) dp[i] += MOD;\n//         rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n//     }\n\n//     long long res = 0;\n//     for ( int i = 1; i <= L; i++ )\n//         if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n//     return res % MOD;\n// }\n\n// int main( int argc, char **argv )\n// {\n//     cin >> N >> M;\n//     cin >> S;\n\n//     int ans = solve();\n\n//     cout << ans << endl;\n\n//     return 0;\n// }\n// #include <algorithm>\n// #include <iostream>\n// #include <string>\n\n// using namespace std;\n\n// #define MOD 1000000007\n// #define INF ( 1 << 29 )\n// #define LINF ( 1LL << 60 )\n// #define EPS ( 1e-10 )\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt all( Int n )\n{ // no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for ( int i = 1; i < n; i++ )\n    {\n        Int nrr = ( rr + rb ) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = ( bb + br ) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return ( rr + rb + br ) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc( Int n, Int limit )\n{\n    dp[0] = 1;\n    rdp[0] = 1;\n    for ( int i = 1; i <= n + 1; i++ )\n    {\n        dp[i] = ( rdp[i - 1] -\n                  ( ( i - limit - 1 ) >= 0 ? rdp[i - limit - 1] : 0 ) ) %\n                MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n}\n\nInt solve( Int n, Int limit )\n{\n    if ( n % 2 == 1 ) return 0;\n    if ( limit % 2 != 1 ) exit( 1 );\n    limit = ( limit + 1 ) / 2;\n    n /= 2;\n    Int res = 0;\n    calc( n + 10, limit );\n    for ( Int i = 1; i <= limit; i++ )\n    {\n        if ( n - i >= 0 ) res = ( res + dp[n - i] * 2 * i ) % MOD;\n    }\n    if ( res < 0 ) exit( 1 );\n    return res % MOD;\n}\n\nint main()\n{\n    cin >> N >> M;\n    cin >> S;\n\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n    {\n        cout << all( N ) << endl;\n        return 0;\n    }\n\n    // Int l = 0;\n    // while ( S[0] == S[l] ) l++;\n    // if ( l % 2 == 0 ) l++;\n    // Int limit = l;\n    // l = 0;\n    // for ( int i = 0; i < M; i++ )\n    // {\n    //     if ( S[i] == S[0] )\n    //         l++;\n    //     else\n    //     {\n    //         if ( l % 2 == 1 ) limit = min( limit, l );\n    //         l = 0;\n    //     }\n    // }\n    int limit = min_freq();\n    cout << solve( N, limit ) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5, mod = 1e9 + 7;\nint n, m, a[maxn + 10], lim;\nchar s[maxn + 10];\nbool fd, fir = 1;\nint f[maxn + 10], sum[maxn + 10], ans;\nint main() {\n\tscanf(\"%d%d%s\", &n, &m, s + 1);\n\tfor (int i = 1; i <= m; ++i) a[i] = s[i] == 'R';\n\tif (a[1]) {\n\t\tfor (int i = 1; i <= m; ++i) a[i] ^= 1;\n\t}\n\tfor (int i = 1; i <= m; ++i)\n\t\tif (a[i]) fd = 1;\n\tlim = n;\n\tif (fd) {\n\t\tfor (int i = 1, cnt = 0; i <= m; ++i)\n\t\t\tif (!a[i]) ++cnt;\n\t\t\telse {\n\t\t\t\tif (fir) {\n\t\t\t\t\tlim = min(lim, cnt % 2 ? cnt : cnt + 1);\n\t\t\t\t\tfir = 0;\n\t\t\t\t} else if (cnt % 2) \n\t\t\t\t\tlim = min(lim, cnt);\n\t\t\t\tcnt = 0;\n\t\t\t}\n\t\tif (n % 2) {\n\t\t\tprintf(\"0\"); return 0;\n\t\t}\n\t\tn /= 2; lim = (lim + 1) / 2;\n\t\tf[0] = sum[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (i <= lim) f[i] = sum[i - 1];\n\t\t\telse f[i] = (sum[i - 1] - sum[i - lim - 1] + mod) % mod;\n\t\t\tsum[i] = (sum[i - 1] + f[i]) % mod;\n\t\t}\n\t\tfor (int i = 1; i <= lim; ++i)\n\t\t\t(ans += 2ll * i * f[n - i] % mod) %= mod;\n\t} else {\n\t\tf[0] = sum[0] = 1;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (i > 1) f[i] = sum[i - 2];\n\t\t\tsum[i] = (sum[i - 1] + f[i]) % mod;\n\t\t}\n\t\tans = 1;\n\t\tfor (int i = 2; i <= lim; ++i)\n\t\t\t(ans += 1ll * i * f[n - i] % mod) %= mod;\n\t}\n\tprintf(\"%d\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n;\nint m;\nstring s;\nint mn = INF;\nll ans ;\nll dp[200005][2][2];\n\nstruct RMQ{\n\t#define ss (1<<19)\n\tll seg[ss];\n\tvoid update(int k,ll a){\n\t\tk+=ss/2-1; seg[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tseg[k]=(seg[k*2+1]+seg[k*2+2])%mod;\n\t\t}\n\t}\n\tll query(int a,int b,int k,int l,int r){\n\t\tif(r<a || b<l) return 0;\n\t\tif(a<=l && r<=b) return seg[k];\n\t\telse{\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2+1,r);\n\t\t\treturn (vl+vr)%mod;\n\t\t}\n\t}\n}rmq[2];\n\nint main(){\n\tcin>>n>>m>>s;\n    \tif(s[0] == 'B'){\n    \t\trep(i,m){\n    \t\t\tif(s[i] == 'B') s[i] = 'R';\n    \t\t\telse s[i] = 'B';\n    \t\t}\n    \t}\n\t\tint cur = 0;\n\t\tchar ch;\n\t\tbool beg = 0;\n\t\tint C = 0;\n\t\trep(i,m){\n\t\t\tif(i == 0){\n\t\t\t\tch = s[i];\n\t\t\t\tcur = 1;\n\t\t\t}\n\t\t\telse if(ch != s[i]){\n\t\t\t\tif(ch == 'R'){\n\t\t\t\t\tif(cur%2 == 1) mn = min(mn,cur);\n\t\t\t\t\telse if(!beg) mn = min(mn,cur+1);\n\t\t\t\t\tbeg = 1; \n\t\t\t\t}\n\t\t\t\t\tch = s[i];\n\t\t\t\t\tcur = 1; C++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse cur++;\n\t\t}\n\t\t\t\tif(ch == 'R'){\n\t\t\t\t\tif(cur%2 == 1) mn = min(mn,cur);\n\t\t\t\t\telse if(!beg) mn = min(mn,cur+1);\n\t\t\t\t\tbeg = 1; \n\t\t\t\t}\n\t\t\t\tC++;\n\t\t\t\t\n\t\tif(C == 1){\n\t\t\t//BBが存在しなければOK\n\t\t\tdp[0][0][0] = dp[0][1][1] = 1;\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\trep(x,2){\n\t\t\t\t\tdp[i+1][0][x] += dp[i][0][x];\n\t\t\t\t\tdp[i+1][1][x] += dp[i][0][x];\n\t\t\t\t\tdp[i+1][0][x] += dp[i][1][x];\n\t\t\t\t\tdp[i+1][0][x] %= mod;\n\t\t\t\t\tdp[i+1][1][x] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<((dp[n-1][0][0]+dp[n-1][0][1]+dp[n-1][1][0])%mod+mod)%mod<<endl;\n\t\t}\n\t\telse{\n\t\t\tdp[0][0][0] = 1;\n\t\t\trmq[0].update(0,1);\n\t\t\tfor(int i=2;i<n;i+=2){\n\t\t\t\tdp[i][0][0] = rmq[i%2].query(max(0,i-mn-1),i,0,0,(1<<18)-1);\n\t\t\t\trmq[i%2].update(i,dp[i][0][0]);\n\t\t\t}\n\t\t\tll ans = 0;\n\t\t\tfor(int m=1;m<=n;m++){\n\t\t\t\tif(m-1 > mn) continue;\n\t\t\t\tif((m-1)%2 == 0) continue;\n\t\t\t\tans += dp[n-m][0][0] * 1LL * m % mod;\n\t\t\t}\n\t\t\tcout << (ans%mod+mod)%mod << endl;\n\t\t\n\t\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long prime = 1000000007;\n\nbool all_chars_equal(string s) {\n    for (char c : s) {\n        if (c != s[0]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> get_runs(string s) {\n    vector<int> runs;\n    int current_run = 0;\n    for (char c : s) {\n        if (c == s[0]) {\n            ++current_run;\n        } else if (current_run > 0) {\n            runs.push_back(current_run);\n            current_run = 0;\n        }\n    }\n    // We intentionally don't add the last run\n    return runs;\n}\n\nlong long mod(long long x) {\n    return (x % prime + prime) % prime;\n}\n\nlong long f(int n, int k) {\n    vector<long long> pow_2(2 * k + 4);\n    pow_2[0] = 1LL;\n    for (int i = 1; i < 2 * k + 4; ++i) {\n        pow_2[i] = pow_2[i - 1] * 2 % prime;\n    }\n\n    vector<long long> f1(max(n + 1, 2 * k + 4), 0);\n    for (int i = 1; i <= k; ++i) {\n        f1[i] = pow_2[i];\n    }\n    f1[k + 1] = mod(pow_2[k+1] - 1);\n    for (int n1 = k + 2; n1 <= 2 * k + 3; ++n1) {\n        f1[n1] = mod(pow_2[n1] - 1 - n1 * pow_2[n1 - k - 2]);\n    }\n    for (int n1 = 2 * k + 4; n1 <= n; ++n1) {\n        f1[n1] = mod(2 * f1[n1 - 1] - f1[n1 - k - 2]);\n    }\n    return f1[n];\n}\n\n/*\nf(n, k) = antal cirkler af længde n med højst k røde i streg (ingen andre begrænsninger)\n\nf(n, k) = 2^n for n <= k\nf(n, k) = 2^n - 1 for n = k+1\nf(n, k) = 2^n - 1 - n * 2^{n-k-2} for k+2 <= n <= 2k+3\nf(n, k) = 2f(n-1, k) - f(n-k-2, k) for n >= 2k + 4\n\n*/\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    string s;\n    cin >> n >> m;\n    cin >> s;\n    if (all_chars_equal(s)) {\n        cout << f(n, 1) << endl;  // OK since n >= 2\n        return 0;\n    }\n    if (n % 2 != 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n    vector<int> runs = get_runs(s);\n    int bound = runs[0] % 2 == 1 ? runs[0] : runs[0] + 1;\n    bound = min(bound, n - 1);\n    cout << mod(f(n / 2, (bound - 1) / 2) * 2) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define N 200100\n#define M 1000000007\nusing namespace std;\n\nll n,m,mx,ans,dp[N],qz[N];\nchar str[N];\n\ninline void Add(ll &u,ll v){u=(u+v)%M;}\nint main()\n{\n    ll i,j,t;\n    cin>>n>>m;\n    scanf(\"%s\",str+1);\n    for(i=1;i<=m;i++) if(str[i]!=str[1]) break;\n    mx=i-1;\n    if(mx==m)\n    {\n\tdp[0]=qz[0]=ans=1;\n\tfor(i=0;i<=n;i++)\n\t{\n\t    if(i>=2) dp[i]=qz[i-2];\n\t    qz[i]=(qz[i-1]+dp[i])%M;\n\t    if(n-i>=2) Add(ans,dp[i]*(n-i)%M);\n\t}\n\tcout<<ans;\n\treturn 0;\n    }\n    if(n&1)\n    {\n\tputs(\"0\");\n\treturn 0;\n    }\n    if(mx%2==0) mx++;\n    for(t=0;i<=m;i++)\n    {\n\tif(str[i]==str[1]) t++;\n\telse\n\t{\n\t    if(t&1) mx=min(mx,t);\n\t    t=0;\n\t}\n    }\n    n/=2,mx=(mx+1)/2;\n    dp[0]=qz[0]=1;\n    for(i=0;i<=n;i++)\n    {\n\tif(i)\n\t{\n\t    dp[i]=(M+qz[i-1]-(i-mx-1>=0?qz[i-mx-1]:0))%M;\n\t    qz[i]=(qz[i-1]+dp[i])%M;\n\t}\n\tif(n-i<=mx) Add(ans,(n-i)*dp[i]*2%M);\n    }\n    cout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define inline __inline__ __attribute__((always_inline))\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=2e5+5,P=1e9+7;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nchar s[N];int f[N],dp[2][5],n,m,res,t;\nvoid solve1(){\n\tdp[0][0]=dp[0][3]=1,t=0;\n\tfor(R int i=1;i<n;++i,t^=1){\n\t\tdp[t^1][0]=dp[t^1][1]=dp[t^1][2]=dp[t^1][3]=0;\n\t\tdp[t^1][0]=add(dp[t][0],dp[t][1]),\n\t\tdp[t^1][1]=dp[t][0],\n\t\tdp[t^1][2]=add(dp[t][2],dp[t][3]),\n\t\tdp[t^1][3]=dp[t][2];\n\t}\n\tres=add(dp[t][0],add(dp[t][1],dp[t][2]));\n\tprintf(\"%d\\n\",res);\n}\nvoid solve2(){\n\tint lim=n,cur=0,las=m;\n\twhile(s[las]=='R')--las;\n\tfd(i,las,1)if(s[i]=='B'){\n\t\tif(cur&1)cmin(lim,cur+1);\n\t\tcur=0;\n\t}else ++cur;\n\tcmin(lim,cur+1+(cur&1^1));\n\tf[0]=f[2]=1;\n\tfor(R int i=4;i<=n;i+=2){\n\t\tf[i]=mul(f[i-2],2);\n\t\tif(i>=lim+2)f[i]=dec(f[i],f[i-(lim+2)]);\n\t}\n\tres=0;\n\tfor(R int i=2;i<=lim;i+=2)upd(res,mul(f[n-i],i));\n\tprintf(\"%d\\n\",res);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tif(s[1]=='B')fp(i,1,m)s[i]^='B'^'R';\n\tbool flag=0;\n\tfp(i,1,m)if(s[i]=='B'){flag=1;break;}\n\tif(!flag)solve1();else solve2();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << (a) << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int MOD = 1e9 + 7;\n\nvi split(string s) {\n    vi ans;\n    char last = 'X'; \n    s += 'X';\n    int streak = 0;\n    for (char c : s) {\n        if (c != last) {\n            if (streak) ans.pb(streak);\n            streak = 0;\n            last = c;\n        }\n        streak++;\n    }\n    return ans;\n}\n\nvoid add(int &x, int y) {\n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n\nvi go(int n, int lim, int start) {\n    vi dp(n+1);\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = 0;\n        if (i >= start) add(dp[i], dp[i-start]);\n        if (i >= lim+1) add(dp[i], MOD-dp[i-lim-1]);\n        add(dp[i], dp[i-1]);\n    }\n    for (int i = n; i >= 1; i--) add(dp[i], MOD-dp[i-1]);\n    return dp;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    int n,l;\n    string s;\n    auto p = split(s);\n    if (si(p) == 1) {\n        auto dp = go(n,n,2);\n        int ans = 0;\n        for (int dif = 1; dif <= n; dif++) {\n            if (dif == 1 || dif == n-1) continue;\n            add(ans, ll(dif) * dp[n-dif] % MOD);\n        }\n        cout << (ans+1)%MOD << endl;\n    }\n    else {\n        if (n%2 == 1) {\n            cout << 0 << endl;\n            continue;\n        }\n        else {\n            int lim = p[0]/2+1;\n            forn(i,si(p)) if (i%2 == 0 && p[i]%2 == 1) \n                lim = min(lim, p[i]/2+1);\n            n /= 2;\n            auto dp = go(n, lim, 1);\n            int ans = 0;\n            for (int dif = 1; dif <= lim; dif++)\n                add(ans, ll(dif) * dp[n-dif] % MOD);\n            cout << 2LL*ans%MOD << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-03 17:07:09\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=200010,mod=1000000007;\nint n,m,flag,l,Flag;\ni64 f[N],F[N],ans;\nchar s[N];\nint main()\n{\n\tn=read(); m=read();\n\tscanf(\"%s\",s+1);\n\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\tif(!flag)\n\t{\n\t\tf[1]=1; f[2]=2;\n\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t\treturn 0;\n\t}\n\tl=n-1;\n\tfor(int i=1,j;i<=m;)\n\t\tif(s[i]==s[1])\n\t\t{\n\t\t\tj=i;\n\t\t\twhile(s[j]==s[1]) j++;\n\t\t\tif(j>n) break;\n\t\t\tif(((j-i)&1)||(!Flag)){ l=std::min(l,(j-i)+(!((j-i)&1))); Flag=1; }\n\t\t\ti=j+1;\n\t\t}\n\t\telse i++;\n\tif(n&1){ printf(\"0\\n\"); return 0; }\n\tn/=2; l=(l+1)/2;\n//\tprintf(\"%d %d\\n\",int(n),int(l));\n\tf[0]=F[0]=1;\n\tfr(i,1,n)\n\t{\n\t\tf[i]=(F[i-1]+mod-(i-l-1>=0?F[i-l-1]:0))%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t}\n\tans=f[n];\n\tfr(i,1,l) ans=(ans+f[n-i]*(2*i-1))%mod;\n\tprintf(\"%d\\n\",int(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//第8回シンデレラガール総選挙は是非本田未央ちゃんに投票をお願いします！\n//ファンのことも他のアイドルの子たちのことも本当に大事にしてて、今まで周りに色んなものを与えてくれました。\n//今度は私たちが未央ちゃんにお返しをする番です。みんなでガラスの靴を履かせてあげましょう！\n// #本田未央を一番星に #本田未央を令和のシンデレラガールに #第8回シンデレラガール総選挙\n#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nlint mo=1000000007;\ntemplate <class typ> struct BIT{\n\tvector<typ> x;\n\tBIT(int n):x(n,0){}\n\ttyp sum(int a,int b){\n\t\tif(a>b) return 0;\n\t\tif(a==0){\n\t\t\ttyp s=0;\n\t\t\tfor(int i=b;i>=0;i=(i&(i+1))-1){\n\t\t\t\ts+=x[i];s%=mo;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\telse return sum(0,b)-sum(0,a-1);\n\t}\n\tvoid add(int ind,typ f){\n\t\tfor(int i=ind;i<x.size();i|=i+1){\n\t\t\tx[i]+=f;x[i]%=mo;\n\t\t}\n\t}\n};\nvector<int> le;\nlint dp[200100][2][2];\nint main()\n{\n\tint n,m,now=0;string s;\n\tcin>>n>>m;\n\tcin>>s;s+='X';\n\trep(i,m){\n\t\tnow++;\n\t\tif(s[i]!=s[i+1]){\n\t\t\tle.pb(now);now=0;\n\t\t}\n\t}\n\tif(le.size()==1){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[1][0][0]=dp[1][1][1]=1;\n\t\tREP(i,1,n) rep(j,2){\n\t\t\tdp[i+1][0][j]+=dp[i][0][j]+dp[i][1][j];\n\t\t\tdp[i+1][1][j]+=dp[i][0][j];\n\t\t\tdp[i+1][0][j]%=mo;\n\t\t\tdp[i+1][1][j]%=mo;\n\t\t}\n\t\tcout<<(dp[n][0][0]+dp[n][0][1]+dp[n][1][0])%mo<<endl;\n\t\treturn 0;\n\t}\n\tif(n%2>0){\n\t\tcout<<0<<endl;return 0;\n\t}\n\tint ma=le[0]/2+1;\n\tfor(int i=0;i<(int)le.size()-1;i+=2){\n\t\tif(le[i]%2>0) ma=min(ma,le[i]/2+1);\n\t}\n\t//cout<<ma<<endl;\n\tBIT<lint> bit(n/2+10);\n\tbit.add(0,1);\n\tREP(i,1,n/2){\n\t\t//cout<<i<<' '<<bit.sum(max(0,i-ma),i-1)<<endl;\n\t\tbit.add(i,bit.sum(max(0,i-ma),i-1));\n\t}\n\tlint out=0;\n\tREP(i,1,min(n/2,ma)+1){\n\t\t//cout<<i<<endl;\n\t\tout+=bit.sum(n/2-i,n/2-i)*i*2;out%=mo;\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nint main()\n{\n    int n, m; cin>>n>>m;\n    string s; cin>>s;\n    int j=0;\n    vector<int> v;\n    bool nuo=1;\n    for(int i=1; i<m; i++){\n        if(s[i]!=s[0]){\n            nuo=0;\n            v.push_back(i-j);\n            j=i+1;\n        }\n    }\n    if(nuo){\n        ll dp[2][200002]={};\n        dp[0][0]=1;\n        for(int i=1; i<n; i++){\n            dp[1][i]+=dp[0][i-1];\n            dp[0][i]+=(dp[0][i-1]+dp[1][i-1]);\n            dp[0][i]%=MOD;\n            dp[1][i]%=MOD;\n        }\n        ll ans=dp[0][n-1]+dp[1][n-1];\n        fill(dp[0], dp[0]+n+1, 0);\n        fill(dp[1], dp[1]+n+1, 0);\n        dp[1][0]=1;\n        for(int i=1; i<n; i++){\n            dp[1][i]+=dp[0][i-1];\n            dp[0][i]+=(dp[0][i-1]+dp[1][i-1]);\n            dp[0][i]%=MOD;\n            dp[1][i]%=MOD;\n        }\n        ans+=dp[0][n-1];\n        ans%=MOD;\n        cout<<ans<<endl;\n        return 0;\n    }\n    if(n%2==1){\n        cout<<0<<endl;\n        return 0;\n    }\n    int mx=v[0]+1-v[0]%2;\n    for(int i=1; i<v.size(); i++){\n        if(v[i]&1) mx=min(mx, v[i]);\n    }\n    ll dp[200002]={}, sum[200002];\n    dp[0]=1;\n    sum[0]=1;\n    for(int i=1; i<=n; i++){\n        if(i&1) sum[i]=sum[i-1];\n        else{\n            if(i-mx-3>=0) dp[i]=(sum[i-2]-sum[i-mx-3]+MOD)%MOD;\n            else dp[i]=sum[i-2];\n            sum[i]=(sum[i-1]+dp[i])%MOD;\n        }\n    }\n    ll ans=0;\n    for(int i=1; i<=min(mx, n-1); i+=2){\n        ans+=(ll)(i+1)*dp[n-i-1];\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//{{{\n#include<algorithm>\n#include<cmath>\n#include<fstream>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<random>\n#include<set>\n#include<sstream>\n#include<sys/time.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\nusing ll = long long;\nenum : int { M = (int)1e9 + 7 };\nenum : ll { MLL = (ll)1e18L + 9 };\nusing namespace std;\n#ifdef LOCAL\n#include\"rprint2.hpp\"\n#else\n#define FUNC(name) template <ostream& out = cout, class... T> void name(T&&...){ }\nFUNC(prints) FUNC(printw) FUNC(printwe) FUNC(printb) FUNC(printbe) FUNC(printd) FUNC(printde) FUNC(printdu);\n#endif\ntemplate <class S, class T>\nistream& operator >> (istream& in, pair<S, T>& p){ return in >> p.first >> p.second; }\ntemplate <class T>\nistream& operator >> (istream& in, vector<T>& v){ for(auto& e : v){ in >> e; } return in; }\n//}}}\n\nint memo[(int)1e6];\nint func(int n, int flim){\n    if(n < 0){ return 0; }\n    if(n == 0){ return 1; }\n    if(memo[n]){ return memo[n]; }\n    int ret = 0;\n    for(int i = 2; i <= flim + 1; i += 2){\n        ret += func(n - i, flim);\n        ret %= M;\n    }\n    printde(n, ret);\n    return memo[n] = ret;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    cin >> n >> m;\n    string s; cin >> s;\n    char first = s[0];\n    int fcnt = 0;\n    int fmin = M;\n    for(auto c : s){\n        if(c == first){\n            fcnt++;\n        }else if(fcnt){\n            fmin = min(fmin, fcnt);\n            fcnt = 0;\n        }\n    }\n    if(fcnt){\n        fmin = min(fmin, fcnt);\n    }\n    int flim = fmin / 2 * 2 + 1;\n    printde(flim);\n    if(n & 1){\n        if(fcnt == n){\n            return 1;\n        }else{\n            cout << 2 << '\\n';\n        }\n        return 0;\n    }\n    // cout << func(n, flim) << '\\n';\n    int ans = 0;\n    for(int i = 2; i <= flim + 1; i += 2){\n        ans += func(n - i, flim) * i;\n        ans %= M;\n    }\n    cout << ans << '\\n';\n}\n/*\nRB      RBRB\nRRB     RBRB    RRRBRRRB\nRRRB    RBRB    RRRBRRRB\nRRRRB   RBRB    RRRBRRRB    RRRRRBRRRRRB\nRRRRRB  RBRB    RRRBRRRB    RRRRRBRRRRRB\n\nRBRRB   RBRB\nRRBRRB  RBRB    RRRBRRRB    RBRRRB  RRRB\nRRBRB\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int mod = 1000000007;\nchar s[200001];\nlong long dp[200001][2];\nlong long dp2[200001][2];\n\nint main() {\n    int n, m, c, i, j;\n    long long ans = 0;\n    vector <int> v, w;\n    \n    scanf(\"%d %d\", &n, &m);\n    scanf(\"%s\", s);\n    \n    for (i = 0; i < m; ) {\n        for (j = i; j < m; j++) {\n            if (s[i] != s[j]) break;\n        }\n        \n        v.push_back(j - i);\n        i = j;\n    }\n    v.back() = 1e9;\n    \n    c = v[0] + 1;\n    for (i = 0; i < v.size(); i += 2) {\n        if (v[i] % 2 == 1) c = min(c, v[i]);\n    }\n    \n    dp[0][1] = 1;\n    dp[1][1] = mod - 1;\n    dp2[0][1] = 1;\n    dp2[1][1] = mod - 1;\n    \n    for (i = 0; i <= n; i++) {\n        if (i > 0) {\n            for (j = 0; j < 2; j++) {\n                dp[i][j] += dp[i - 1][j];\n                if (dp[i][j] >= mod) dp[i][j] -= mod;\n                \n                dp2[i][j] += dp2[i - 1][j];\n                if (dp2[i][j] >= mod) dp2[i][j] -= mod;\n            }\n        }\n        \n        if (i == 0) {\n            dp[1][0] = 2;\n            for (j = 2; j <= c && j <= n; j++) dp[j][0] = 1;\n            if (c + 1 <= n) dp[c + 1][0] = mod - (c + 1);\n        } else if (i % 2 == 1) {\n            if (i + 1 <= n) {\n                dp[i + 1][1] += dp[i][0];\n                if (dp[i + 1][1] >= mod) dp[i + 1][1] -= mod;\n            }\n            \n            if (i + 2 <= n) {\n                dp[i + 2][1] -= dp[i][0];\n                if (dp[i + 2][1] < 0) dp[i + 2][1] += mod;\n            }\n        } else {\n            if (i + 1 <= n) {\n                dp[i + 1][0] += dp[i][1];\n                if (dp[i + 1][0] >= mod) dp[i + 1][0] -= mod;\n            }\n            \n            if (i + c + 1 <= n) {\n                dp[i + c + 1][0] -= dp[i][1];\n                if (dp[i + c + 1][0] < 0) dp[i + c + 1][0] += mod;\n            }\n        }\n        \n        if (i == 0) {\n            dp2[1][0] = 2;\n            for (j = 2; j <= c && j <= n; j++) dp2[j][0] = 1;\n            if (c + 1 <= n) dp2[c + 1][0] = mod - (c + 1);\n        } else {\n            if (i + 1 <= n) {\n                dp2[i + 1][1] += dp2[i][0];\n                if (dp2[i + 1][1] >= mod) dp2[i + 1][1] -= mod;\n            }\n            \n            if (i + 2 <= n) {\n                dp2[i + 2][1] -= dp2[i][0];\n                if (dp2[i + 2][1] < 0) dp2[i + 2][1] += mod;\n            }\n            \n            if (i + 1 <= n) {\n                dp2[i + 1][0] += dp2[i][1];\n                if (dp2[i + 1][0] >= mod) dp2[i + 1][0] -= mod;\n            }\n            \n            if (i + c + 1 <= n) {\n                dp2[i + c + 1][0] -= dp2[i][1];\n                if (dp2[i + c + 1][0] < 0) dp2[i + c + 1][0] += mod;\n            }\n        }\n    }\n        \n    if (n % 2 == 0) ans = dp[n][1];\n    if (v.size() == 1) ans = (ans + dp2[n][1] + 1) % mod;\n    \n    printf(\"%lld\\n\", ans);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define mod 1000000007\n#define DIM 200005\nusing namespace std;\nint n, m, i, k, nr, sol;\nchar s[DIM];\nint d[DIM], sum[DIM];\nint main(){\n    cin>> n >> m;\n    cin>> s + 1;\n    k = m;\n    for(i = 1; i <= m; i++){\n        if(s[i] == s[1]){\n            nr++;\n        }\n        else{\n            if(nr == i - 1){\n                if(nr % 2 == 1){\n                    k = min(k, nr);\n                }\n                else{\n                    k = min(k, nr + 1);\n                }\n            }\n            else{\n                if(nr % 2 == 1){\n                    k = min(k, nr);\n                }\n            }\n            nr = 0;\n        }\n    }\n    sum[1] = d[1] = 1;\n    if(k == m){\n        sum[2] = 1;\n        for(i = 3; i < n; i++){\n            d[i] = sum[i - 2];\n            sum[i] = (d[i] + sum[i - 1]) % mod;\n        }\n        sol = 1;\n        for(i = 1; i < n; i++){\n            sol = (sol + d[n - i] * 1LL * (i + 1) ) % mod;\n        }\n        cout<< sol;\n        return 0;\n    }\n    for(i = 3; i < n; i += 2){\n        d[i] = sum[i - 2];\n        if(i - k - 3 > 0){\n            d[i] -= sum[i - k - 3];\n            if(d[i] < 0){\n                d[i] += mod;\n            }\n        }\n        sum[i] = d[i] + sum[i - 2];\n        if(sum[i] >= mod){\n            sum[i] -= mod;\n        }\n    }\n    for(i = 1; i < min(n, k + 2); i += 2){\n        sol = (sol + d[n - i] * 1LL * (i + 1) ) % mod;\n    }\n    cout<< sol;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Dmitry _kun_ Sayutin (2019)\n\n#include <bits/stdc++.h>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::tuple;\nusing std::make_tuple;\nusing std::get;\n\nusing std::min;\nusing std::abs;\nusing std::max;\nusing std::swap;\n\nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n\n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n\ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n\ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n\n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n\nconst int mod = 1000 * 1000 * 1000 + 7;\nint add(int a, int b) {\n    return (a + b >= mod ? a + b - mod : a + b);\n}\n\nint sub(int a, int b) {\n    return (a >= b ? a - b : mod + a - b);\n}\n\nint mult(int a, int b) {\n    return (int64_t(a) * b) % mod;\n}\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    // code here\n    int n = input<int>();\n    int m = input<int>();\n    \n    string s = input<string>();\n\n    if (s[0] == 'B')\n        for (int i = 0; i != m; ++i)\n            s[i] = ('R' + 'B' - s[i]);\n\n    if (std::find(ALL(s), 'B') == s.end()) {\n        int ans = 0;\n        \n        for (int fst = 0; fst != 2; ++fst) {\n            pair<int, int> cur_dp = {0, 0};\n\n            if (fst == 0)\n                cur_dp.first += 1;\n            else\n                cur_dp.second += 1;\n\n            for (int i = 0; i != n - 1; ++i) {\n                pair<int, int> newdp = {0, 0};\n                newdp.first = cur_dp.second;\n                newdp.second = add(cur_dp.first, cur_dp.second);\n\n                cur_dp = newdp;\n            }\n\n            if (fst == 1)\n                ans = add(ans, add(cur_dp.first, cur_dp.second));\n            else\n                ans = add(ans, cur_dp.second);\n        }\n\n        cout << ans << \"\\n\";\n        return 0;\n    } else {\n        vector<int> lens = {1};\n        assert(s[0] == 'R');\n\n        for (int i = 1; i != m; ++i)\n            if (s[i] == 'R' and s[i - 1] == 'R')\n                lens.back() += 1;\n            else if (s[i] == 'R')\n                lens.push_back(1);\n\n        int limit = 1000 * 1000 * 1000 + 1;\n        \n        for (int len: {lens[0]})\n            if (len % 2 == 0)\n                limit = min(limit, len + 1);\n            else\n                limit = min(limit, len);\n\n        for (int i = 1; i != SZ(lens); ++i)\n            if (lens[i] % 2 == 1)\n                limit = min(limit, lens[i]);\n        \n        // dp[k]: start with 0, end with zero, length k.\n        vector<int> dp(n + 5);\n        vector<int> dp_sum(n + 5);\n\n        dp[0] = 0;\n        dp[1] = 1;\n\n        dp_sum[0] = 0;\n        dp_sum[1] = 1;\n        for (int p = 2; p < SZ(dp); ++p) {\n            // for (int last = 1; last <= limit and last + 1 <= p; last += 2)\n            //     dp[p] = add(dp[p], dp[p - 1 - last]);\n\n            int upto = min(limit, p - 1);\n            if (upto % 2 == 0)\n                --upto;\n\n            dp[p] = dp_sum[p - 2];\n\n            if (p - upto - 3 >= 0)\n                dp[p] = sub(dp[p], dp_sum[p - upto - 3]);\n\n            dp_sum[p] = add(dp_sum[p - 2], dp[p]);\n        }\n\n        int ans = 0;\n        for (int beg = 1; beg <= n - 1 and beg <= limit; beg += 2)\n            ans = add(ans, mult(beg + 1, dp[n - beg]));\n\n        cout << ans << \"\\n\";\n\n        if (0) {\n            auto N = n;\n            auto lim = limit;\n            int cnt = 0;\n            \n            for (int mask = 0; mask != (1 << N); ++mask) {\n                if (mask == 0 or mask + 1 == (1 << N))\n                    continue;\n        \n                vector<char> s(N);\n                for (int i = 0; i != N; ++i)\n                    s[i] = bool((mask & (1 << i)) != 0);\n\n                int p = 0;\n                while (s[p] != 0 or s[(p + 1) % N] != 1)\n                    ++p;\n\n                std::rotate(s.begin(), s.begin() + p, s.end());\n                vector<int> lens;\n                for (int i = 1; i != N; ++i)\n                    if (s[i] == 1 and s[i - 1] == 0)\n                        lens.push_back(1);\n                    else if (s[i] == 1)\n                        lens.back() += 1;\n\n                bool fail = false;\n                for (int i = 0; i != N; ++i)\n                    if (s[i] == 0 and s[(i + 1) % N] == 0)\n                        fail = 1;\n                \n                if (fail)\n                    continue;\n\n                if (*std::max_element(ALL(lens)) > lim)\n                    fail = true;\n\n                for (auto elem: lens)\n                    if (elem % 2 == 0)\n                        fail = true;\n\n                if (fail)\n                    continue;\n\n                // for (int i = 0; i != N; ++i)\n                //     cout << ((mask & (1 << i)) != 0 ? '1' : '0');\n\n                // cout << \"\\n\";\n                cnt += 1;\n            }\n\n            assert(ans == cnt);\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <algorithm>\n#define N 201000\ntypedef long long ll;\ntemplate <typename T> inline void read(T &x) {\n\tx = 0; char c = getchar(); bool flag = false;\n\twhile (!isdigit(c)) { if (c == '-')\tflag = true; c = getchar(); }\n\twhile (isdigit(c)) { x = (x << 1) + (x << 3) + (c ^ 48); c = getchar(); }\n\tif (flag)\tx = -x;\n}\nusing namespace std;\nconst int P = 1e9 + 7;\nconst int inf = 987654321;\ninline void MIN(int &a, int b) {\n\tif (b < a)\ta = b;\n}\nint n, m;\nchar s[N];\nnamespace jzp1 {\n\tll jie[N], jieni[N];\n\tinline ll get_c(int n, int m) {\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\tif (n < 0 || m < 0 || n - m < 0)\treturn 0;\n//\t\tprintf(\"get_c(%d, %d)\\n\", n, m);\n\t\treturn jie[n] * jieni[m] % P * jieni[n - m] % P;\n\t}\n\tinline ll quickpow(ll x, int k) {\n\t\tll res = 1;\n\t\twhile (k) {\n\t\t\tif (k & 1)\tres = res * x % P;\n\t\t\tx = x * x % P;\n\t\t\tk >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n\tinline void sol() {\n\t\tif (n == 1) { puts(\"1\"); return ; }\n\t\tjie[0] = jieni[0] = 1;\n\t\tint up = n + 1;\n\t\tfor (int i = 1; i <= up; ++i)\tjie[i] = jie[i - 1] * i % P;\n\t\tjieni[up] = quickpow(jie[up], P - 2);\n\t\tfor (int i = up - 1; i; --i)\tjieni[i] = jieni[i + 1] * (i + 1) % P;\n\t\tll res = 0;\n\t\tfor (int i = 0; i <= n; ++i) {\n\t\t\tres = (res + get_c(n - i + 1, i) - get_c(n - i - 1, i - 2)) % P;\n//\t\t\tprintf(\"res = %lld\\n\", res);\n\t\t}\n\t\tprintf(\"%lld\\n\", (res % P + P) % P);\n\t}\n}\nll f[N];\nll sum[N];\nint main() {\n\tread(n), read(m);\n\tscanf(\"%s\", s + 1);\n\tbool flag = false;\n\tfor (int i = 1; i <= m; ++i)\tif (s[i] != s[1]) { flag = true; break; }\n\tif (!flag) { jzp1::sol(); return 0; }\n\tif (n & 1) { puts(\"0\"); return 0; }\n\tint lst = 1, mn = inf;\n\tfor (int i = 2; i <= m + 1; ++i) {\n\t\tif (s[i] != s[1]) {\n\t\t\tif (lst & 1)\tMIN(mn, lst);\n\t\t\tlst = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (s[i] == s[i - 1])\t++lst;\n\t\telse {\n\t\t\tif (lst & 1) MIN(mn, lst);\n\t\t\tlst = 1;\n\t\t}\n\t}\n\tif (mn == inf) {\n\t\tint memo = 1;\n\t\tfor (int i = 1; s[i] == s[1]; ++i) memo = i;\n\t\tmn = memo + 1;\n\t}\n\tn >>= 1;\n\tint k = (mn + 1) >> 1;\n\tf[0] = 1; sum[0] = 1;\n//\tprintf(\"n = %d, k = %d\\n\", n, k);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif (i <= k)\tf[i] = sum[i - 1];\n\t\telse f[i] = (sum[i - 1] - sum[i - k - 1]) % P;\n\t\tsum[i] = (sum[i - 1] + f[i]) % P;\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= k; ++i) {\n\t\tans += (f[n - i] * i) % P;\n\t}\n\tans = (ans << 1) % P;\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n\n/*\n3 3\nBBB\n//4\n\n1 1\nB\n//1\n\n12 10\nRRRRBRRRRB\n//78\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, m;\nlong long Mod = 1000000007, D[401000], S[401000];\nchar p[301000];\nlong long DD[401000][2][2];\nint main() {\n\tint i, j;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", p);\n\tint ck = 0;\n\tfor (i = 0; p[i]; i++) {\n\t\tif (p[i] == 'R')ck |= 1;\n\t\tif (p[i] == 'B')ck |= 2;\n\t}\n\tif (ck!=3) {\n\t\tDD[1][0][0] = 1;\n\t\tDD[1][1][1] = 1;\n\t\tfor (i = 2; i <= n; i++) {\n\t\t\tDD[i][0][0] = (DD[i - 1][0][0] + DD[i - 1][0][1]) % Mod;\n\t\t\tDD[i][0][1] = (DD[i - 1][0][0]) % Mod;\n\t\t\tDD[i][1][0] = (DD[i - 1][1][0] + DD[i - 1][1][1]) % Mod;\n\t\t\tDD[i][1][1] = (DD[i - 1][1][0]) % Mod;\n\t\t}\n\t\tprintf(\"%lld\\n\", (DD[n][0][0] + DD[n][0][1] + DD[n][1][0]) % Mod);\n\t\treturn 0;\n\t}\n\tif (n % 2 == 1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tif (p[0] == 'B') {\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tp[i] = 'R' + 'B' - p[i];\n\t\t}\n\t}\n\tint c = 0, Mn = 1e9;\n\tck = 0;\n\tfor (i = 0; i < m; i++) {\n\t\tif (p[i] == 'R') {\n\t\t\tc++;\n\t\t\tif (p[i + 1] == 'B') {\n\t\t\t\tif (!ck) {\n\t\t\t\t\tif (c % 2 == 0)Mn = min(Mn, c + 1);\n\t\t\t\t\telse Mn = min(Mn, c);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (c % 2 == 1)Mn = min(Mn, c);\n\t\t\t\t}\n\t\t\t\tck = 1;\n\t\t\t}\n\t\t}\n\t\telse c = 0;\n\t}\n\n\tint K = (Mn + 1) / 2;\n\tD[0] = 1;\n\tS[0] = 1;\n\tfor (i = 1; i <= n; i++) {\n\t\tlong long t = S[i - 1];\n\t\tif (i - K - 1 >= 0)t -= S[i - K - 1];\n\t\tD[i] = (t + Mod) % Mod;\n\t\tS[i] = (S[i - 1] + D[i]) % Mod;\n\t}\n\tlong long res = D[n / 2];\n\tfor (i = 1; i <= Mn && i<=n; i+=2) {\n\t\tres = (res + 1ll*i*D[(n - i - 1) / 2])%Mod;\n\t}\n\tprintf(\"%lld\\n\", res);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x)\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<int MOD> struct modnum {\n    int v;\n    modnum() : v(0) {}\n    modnum(ll _v) : v(_v % MOD) { if (v < 0) v += MOD; }\n    explicit operator int() const { return v; }\n    friend ostream& operator << (ostream& o, const modnum& n) { return o << n.v; }\n    friend istream& operator << (istream& i, modnum& n) { ll v; i >> v; n = modnum(v); return i; }\n\n    friend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n    friend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n    modnum& operator += (const modnum& o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }\n    modnum& operator -= (const modnum& o) { v -= o.v; if (v < 0) v += MOD; return *this; }\n    modnum& operator *= (const modnum& o) { v = int(ll(v) * ll(o.v) % MOD); return *this; }\n    modnum operator - () { modnum res; if (v) res.v = MOD - v; return res; }\n    friend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n    friend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n    friend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\n    modnum pow(int e) const {\n        if (e == 0) return 1;\n        if (e & 1) return *this * this->pow(e-1);\n        return (*this * *this).pow(e/2);\n    }\n\n    modnum inv() const {\n        int g = MOD, x = 0, y = 1;\n        for (int r = v; r != 0; ) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        assert(g == 1);\n        assert(y == MOD || y == -MOD);\n        return x < 0 ? x + MOD : x;\n    }\n    modnum& operator /= (const modnum& o) { return (*this) *= o.inv(); }\n    friend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= modnum(b); }\n};\nusing mn = modnum<1000000007>;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N, M;\n    cin >> N >> M;\n\n    string str;\n    cin >> str;\n\n    bool mono = true;\n    for (int i = 1; i < M; i++)\n        mono &= str[i] == str[0];\n\n    if (mono) {\n        vector<mn> dp(N + 1);\n        dp[0] = 1;\n        dp[1] = 1;\n        dp[2] = 3;\n        for (int l = 3; l <= N; l++) {\n            dp[l] = dp[l-2] + dp[l-1];\n        }\n        cout << dp.back() << endl;\n        return 0;\n    }\n\n    if (N&1) {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int t = str.size() - 1;\n    while (str[t] == str[0])\n        t--;\n    str = str.substr(0, t + 1);\n    M = str.size();\n\n    int begin = -1, limit = INT_MAX;\n    for (int i = 0; i < M; i++) {\n        if (str[i] == str[0]) {\n            if (begin == -1) begin = i;\n        } else {\n            if (begin != -1) {\n                int len = i - begin;\n                if (begin == 0) {\n                    if (len&1) limit = min(limit, len);\n                    else limit = min(limit, len + 1);\n                } else if (len&1) {\n                    limit = min(limit, len);\n                }\n            }\n            begin = -1;\n        }\n    }\n\n    WATCH(limit);\n\n    vector<mn> ways(N + 1), pref(N + 1);\n    ways[0] = 1, pref[0] = 0;\n    for (int ln = 1; ln <= N; ln++) {\n        if (ln % 2 == 0)\n            ways[ln] = pref[ln - 1] - pref[max(0, ln - 1 - limit)];\n        pref[ln] = pref[ln-1] + ways[ln-1];\n    }\n\n    WATCHC(ways);\n\n    mn ans = 0;\n    for (int fs = 2; fs <= limit + 1; fs += 2) {\n        WATCH(fs);\n        WATCH(ways[N - fs]);\n        ans += fs * ways[N - fs];\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: E.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define int long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nchar s[200005];\nint f[200005],g[200005];\nconst int p=1000000007;\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint n,m;\n\tread(n,m);\n\tread(s+1);\n\tchar fir=s[1];\n\tint mn=inf;\n\tfor(int i=1,j=1;i<=m;i=j){\n\t\twhile(s[i]==s[j])++j;\n\t\tif(s[i]==fir){\n\t\t\tif(i==1)chkmin(mn,(j-i)|1);\n\t\t\telse if(j<=m && (j-i)&1)chkmin(mn,j-i);\n//\t\t\tchkmin(mn,j-i);\n\n\t\t}\n\n\t}\n\tif(mn>=m){\n\t\tf[0]=1;\n\t\tint s=0;\n\t\tfor(int i=2;i<=n;++i){\n\t\t\tf[i]=(s+i-f[i-1]+p)%p;\n\t\t\t(s+=f[i])%=p;\n\t\t}\n\t\twrite((f[n]+1)%p,'\\n');\n\t}\n\telse{\n\t\tif(n&1)return write(\"0\\n\");\n\t\tf[0]=1;\n\t\t++mn;\n\t\tg[0]=1;\n\t\tfor(int i=2;i<=n;i+=2){\n\t\t\tf[i]=(g[i-2]-g[i-min(i,mn+2)]+p)%p;\n//\t\t\tfor(int j=2;j<=mn && j<i;j+=2)f[i]+=f[i-j];\n\t\t\tif(i<=mn)(f[i]+=i)%=p;\n\t\t\tg[i]=(f[i]+g[i-2])%p;\n\t\t}\n\t\twrite(f[n],'\\n');\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n¼ÙÉèS[1] = R¡£ÄÇÃ´ÏÔÈ»£¬»·ÉÏ²»»á³öÏÖÁ½¸öÁ¬ÐøµÄ±ß¶¼ÊÇB£¬·ñÔòÔÚËüÃÇ½»µã´¦µÚÒ»²½ÍùÁ½±ß×ß¶¼²»ºÏ·¨\nÌØÅÐµôSÖÐÈ«ÊÇRµÄÇé¿ö£¬¿¼ÂÇÒ»°ãÇé¿ö \nÊ×ÏÈ°ÑËùÓÐÊÇBµÄÎ»ÖÃ¶Ï¿ª£¬ÄÇÃ´¾ÍÐÎ³ÉÁËÈô¸É¸öRµÄÁ¬Ðø¶Î¡£¿ÉÒÔ·¢ÏÖÕâÃ´Ò»¸öÐÔÖÊ£ºÃ¿¸öÁ¬Ðø¶ÎµÄ³¤¶È¾ùÎªÆæÊý\nÖ¤Ã÷¿¼ÂÇ·´Ö¤¡£¼ÙÉèÓÐÒ»¸öÅ¼ÊýµÄ¶Î£¬¿¼ÂÇ¶þ·ÖÍ¼¿ÉÒÔ·¢ÏÖ£¬ÄÇÃ´ÓÐµÄµã×ßµ½ÕâÒ»¶ÎµÄ¶Ëµã¾àÀëÓÀÔ¶ÊÇÅ¼Êý¡¢ÓÐµÄµã×ßµ½ÕâÒ»¶ÎµÄ¶Ëµã¾àÀëÓÀÔ¶ÊÇÆæÊý£¬ÒòÎª¶ËµãÍ¬É«\n¶øSµÄµÚÒ»¶ÎÁ¬ÐøR³¤¶ÈÊÇ¹Ì¶¨µÄ£¬²»ÄÜÍ¬Ê±ÎªÅ¼Êý»òÆæÊý£¬Ã¬¶Ü¡£ËùÒÔ¿ÉÒÔµÃµ½½áÂÛ\nÍ¬Ê±£¬SÖÐÃ¿¸öRµÄÁ¬Ðø¶Î¶¼»á¶Ô»·ÉÏÃ¿¸öRµÄÁ¬Ðø¶ÎÓÐ¸öÉÏ½çµÄÏÞÖÆ \n*/\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int Max_NM(200050);\nconst int MOD(1000000000 + 7);\ntypedef long long int LL;\n\nint N, M, L, F[Max_NM], Pre[Max_NM][2], Ans;\nchar S[Max_NM];\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nconstexpr int Sub(int a, int b)\n{\n\treturn a - b < 0 ? a - b + MOD : a - b;\n}\n\nconstexpr int Mult(int a, int b)\n{\n\treturn a * 1LL * b % MOD;\n}\n\ninline void upd(int &a, int b)\n{\n\ta = Add(a, b);\n}\n\nvoid dp(bool have)\n{\n\tF[1] = 1, Pre[1][1 & 1] = 1;\n\tfor (int i = 2, j;i <= N;++i)\n\t{\n\t\tPre[i][0] = Pre[i - 1][0], Pre[i][1] = Pre[i - 1][1];\n\t\tupd(Pre[i][i & 1], F[i - 2]);\n\t\t//jµ½iÊÇR£¬i - j + 1 <= L   =>   j >= i - L + 1\n\t\t//i - j + 1ÊÇÆæÊý£¬i - jÊÇÅ¼Êý£¬iºÍjÆæÅ¼ÐÔÏàµÈ\n\t\tj = max(1, i - L + 1);\n\t\tif (j <= i)\n\t\t{\n\t\t\tF[i] = Sub(Pre[i][i & 1], Pre[j - 1][i & 1]);\n\t\t\tif (have)\n\t\t\t\tupd(F[i], Sub(Pre[i][(i & 1) ^ 1], Pre[j - 1][(i & 1) ^ 1]));\n\t\t}\n\t}\n\t\n}\n\nint main()\n{ \n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tbool haveB = false;\n\tif (S[1] == 'B')\n\t\tfor (int i = 1;i <= M;++i)\n\t\t\tS[i] = 'R' + 'B' - S[i];\n\tfor (int i = 1;i <= M;++i)\n\t\thaveB |= (S[i] == 'B');\n\tL = N;\n\tfor (int i = 1, length = 0, stop = 0;i <= M;++i)\n\t\tif (S[i] == 'B')\n\t\t\tlength = 0, stop = 1;\n\t\telse\n\t\t{\n\t\t\t++length;\n\t\t\tif (i + 1 <= N && S[i + 1] == 'B')\n\t\t\t\tif (stop == 0)\n\t\t\t\t\tif (length & 1)\n\t\t\t\t\t\tL = min(L, length);\n\t\t\t\t\telse\n\t\t\t\t\t\tL = min(L, length + 1);\n\t\t\t\telse\n\t\t\t\t\tif (length & 1)\n\t\t\t\t\t\tL = min(L, length);\n\t\t}\n\tdp(!haveB);\n\tupd(Ans, F[N - 1]);//edge(1, 2) = B\n\tfor (int x = 1, val;x <= L;x += 2)//edge(1, 2) = R\n\t{\n\t\tif (x == N)\n\t\t\tval = 1;\n\t\telse\n\t\t\tif (x + 1 == N)\n\t\t\t\tval = 1;\n\t\t\telse\n\t\t\t\tval = F[N - x - 2];\n\t\tupd(Ans, Mult(x, val));\n\t}\n\tprintf(\"%d\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    constexpr unsigned long MOD = 1000000007;\n    unsigned long N, M;\n    string s;\n    cin >> N >> M >> s;\n\n    if(equal(s.begin(), s.end() - 1, s.begin() + 1)){\n        vector<unsigned long> fib(N + 1);\n        fib[0] = 1;\n        fib[1] = 1;\n        for(unsigned long i = 2; i <= N; ++i){\n            fib[i] = fib[i - 1] + fib[i - 2] % MOD;\n        }\n        cout << (fib[N - 2] + fib[N]) % MOD << endl;\n    }else{\n        if(N & 1)return 0 & puts(\"0\");\n        auto t = find(s.begin(), s.end(), 'R' ^ 'B' ^ s[0]) - s.begin();\n        auto k = t | 1UL;\n        {\n            unsigned long cnt{0};\n            for(auto &i : s){\n                if(i == s[0])++cnt;\n                else{\n                    if(cnt & 1)k = min(k, cnt);\n                    cnt = 0;\n                }\n            }\n        }\n        vector<unsigned long> dp(N + 1), sum(N + 1);\n        dp[0] = 1;\n        dp[1] = 1;\n        sum[0] = 1;\n        sum[1] = 1;\n        for(unsigned long i = 2; i <= N; ++i){\n            dp[i] = sum[i - 2];\n            if(i > k + 2)dp[i] += MOD - sum[i - k - 3];\n            (sum[i] = sum[i - 2] + (dp[i] %= MOD)) %= MOD;\n        }\n        unsigned long ans{0};\n        for(unsigned long l = 1; l <= k; l += 2)(ans += (l + 1) * dp[N - l - 1] % MOD) %= MOD;\n        cout << ans % MOD << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb push_back\n#define szz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nconst int mod = 1e9 + 7;\n\nint n, m;\nchar S[200020];\nll res[200020];\nll D[200020], sum[200020];\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", S + 1);\n\tif(S[1] == 'B') {\n\t\tfor(int i=1;i<=m;i++) S[i] = (S[i] == 'B' ? 'R' : 'B');\n\t}\n\tint all_r = 1;\n\tfor(int i=1;i<=m;i++) if(S[i] != 'R') all_r = 0;\n\tif(all_r) {\n\t\tint dp[200020][2] = {};\n\t\tdp[1][0] = 1; dp[1][1] = 0;\n\t\tfor(int i=2;i<=n;i++) {\n\t\t\tdp[i][0] = (dp[i-1][0] + dp[i-1][1]) % mod;\n\t\t\tdp[i][1] = dp[i-1][0];\n\t\t}\n\t\tint ans = (dp[n][0] + dp[n][1]) % mod;\n\t\tmemset(dp, 0, sizeof dp);\n\t\tdp[1][0] = 0; dp[1][1] = 1;\n\t\tfor(int i=2;i<=n;i++) {\n\t\t\tdp[i][0] = (dp[i-1][0] + dp[i-1][1]) % mod;\n\t\t\tdp[i][1] = dp[i-1][0];\n\t\t}\n\t\tans = (ans + dp[n][0]) % mod;\n\t\tprintf(\"%d\\n\", ans);\n\t\treturn 0;\n\t}\n\twhile(S[m] == 'R') --m;\n\tvector <int> v;\n\tfor(int i=1, c=0;i<=m;i++) {\n\t\tif(S[i] == 'R') ++c;\n\t\tif(S[i] == 'R' && (i == m || S[i+1] == 'B')) {\n\t\t\tv.pb(c);\n\t\t\tc = 0;\n\t\t}\n\t}\n\t\n\tif(n % 2) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint lmn = n - 1;\n\tif(v[0] % 2) lmn = min(lmn, v[0]);\n\telse lmn = min(lmn, v[0] + 1);\n\tfor(int i=1;i<szz(v);i++) {\n\t\tif(v[i] % 2) {\n\t\t\tlmn = min(lmn, v[i]);\n\t\t}\n\t}\n\tlmn = (lmn + 1) / 2;\n\t\n\tint sn = n / 2;\n\t\n\tD[0] = sum[0] = 1;\n\tfor(int i=1;i<=sn;i++) {\n\t\tD[i] = (sum[i-1] - (i-lmn-1 < 0 ? 0 : sum[i-lmn-1]));\n\t\tif(D[i] < 0) D[i] += mod;\n\t\tsum[i] = (sum[i-1] + D[i]) % mod;\n\t}\n\t\n\tll ans = 0;\n\tfor(int i=1;i<=lmn;i++) {\n\t\tans = (ans + (2 * i) * D[sn - i]) % mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll dp[202020][2][2];\nll mo=1000000007;\n\nll dp2[202020];\nll dps[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\tif(S[0]=='B') {\n\t\tFORR(c,S) c='R'+'B'-c;\n\t}\n\tif(count(ALL(S),'B')==0) {\n\t\tdp[0][0][0]=dp[0][1][1]=1;\n\t\tfor(i=1;i<N;i++) {\n\t\t\t(dp[i][0][0]=dp[i-1][0][0]+dp[i-1][0][1])%=mo;\n\t\t\t(dp[i][0][1]=dp[i-1][0][0])%=mo;\n\t\t\t(dp[i][1][0]=dp[i-1][1][0]+dp[i-1][1][1])%=mo;\n\t\t\t(dp[i][1][1]=dp[i-1][1][0])%=mo;\n\t\t}\n\t\tcout<<(dp[N-1][0][0]+dp[N-1][0][1]+dp[N-1][1][0])%mo<<endl;\n\t\treturn;\n\t}\n\tint L=0;\n\twhile(S[L]=='R') L++;\n\t\n\tif(L%2==0) L++;\n\t\n\tdp2[0]=dps[0]=dps[1]=1;\n\tfor(i=2;i<=N;i++) {\n\t\tif(i%2==0) {\n\t\t\tdp2[i]=dps[i-2];\n\t\t\tif(i-(L+1)>0) dp2[i]+=mo-dps[i-(L+1)-1];\n\t\t\tdp2[i]%=mo;\n\t\t}\n\t\t(dps[i]=dps[i-1]+dp2[i])%=mo;\n\t\t//cout<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=min(L,N-1);i++) {\n\t\t//cout<<i<<\" \"<<(i+1)<<\"*\"<<dp2[N-(i+1)]<<endl;\n\t\t(ret+=(i+1)*dp2[N-(i+1)])%=mo;\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 1000000007;\n\nconst long long MOD_CONST = 1000000007;\nlong long mul_mod(long long a, long long b, const long long MOD) {\n  return b ? (mul_mod(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow_mod(long long a, long long b, const long long MOD) {\n  return (b ? bpow_mod(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv_mod(long long a, const long long MOD) {\n  return bpow_mod(a, MOD - 2, MOD);\n}\ntemplate <long long param = MOD_CONST, bool fast = false>\nclass mint {\n private:\n  using Z = int;\n  using N = unsigned int;\n  using ZZ = long long;\n  using NN = unsigned long long;\n  struct {\n  } constexpr static exact{};\n  // Using Z deliberately to avoid Z -> N promotion.\n  template <class Ret = ZZ&>\n  static auto modulo() -> std::enable_if_t<(param <= 0), Ret> {\n    static ZZ mod = 0;\n    return mod;\n  }\n  template <class Ret = const ZZ>\n  static auto mod() -> std::enable_if_t<(param <= 0), Ret> {\n    return modulo();\n  }\n  template <class Ret = const ZZ>\n  static constexpr auto mod() -> std::enable_if_t<(param > 0), Ret> {\n    return param;\n  }\n\n public:\n  template <class Arg = ZZ>\n  static void set_modulo(const std::enable_if_t<(param <= 0), Arg> mod) {\n    modulo() = mod;\n  }\n  long long v;\n\n  constexpr mint() : v(0) {}\n\n  constexpr mint(long long v)\n      : v(fast ? (v)\n               : (v < 0 ? (v % mod() + mod()) % mod()\n                        : (v >= mod() ? v % mod() : v))) {}\n  constexpr long long get_mod() { return mod(); }\n  long long get_val() { return v; }\n  void take_mod() { v %= mod(); }\n};\ntemplate <long long param, bool fast>\nostream& operator<<(ostream& os, mint<param, fast>& x) {\n  return os << (x.v % x.get_mod() + x.get_mod()) % x.get_mod();\n}\n\ntemplate <long long param, bool fast, bool fast2>\nbool operator==(mint<param, fast>& a, mint<param, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast>& operator+=(mint<param, fast>& a, mint<param, fast2> b) {\n  return a = a.v + b.v;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, mint<param> b) {\n  return a = a.v - b.v;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, mint<param> b) {\n  return a = a.v * b.v;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, mint<param> b) {\n  return a = a.v * inv_mod(b.v, a.get_mod());\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast> operator+(mint<param, fast> a, mint<param, fast2> b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, mint<param> b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, mint<param> b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, mint<param> b) {\n  return a /= b;\n}\ntemplate <long long param, bool fast>\nmint<param, fast>& operator+=(mint<param, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, long long b) {\n  return a = a.v * inv_mod(b, a.get_mod());\n}\ntemplate <long long param, bool fast>\nmint<param, fast> operator+(mint<param> a, long long b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, long long b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, long long b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, long long b) {\n  return a /= b;\n}\n\nvoid special(int N) {\n  vector<mint<>> vals = {mint<>(1), mint<>(1)};\n  for (int i = 0; i < N; i++) {\n    int sz = vals.size();\n    vals.push_back(vals[sz - 1] + vals[sz - 2]);\n  }\n  mint<> ans = vals[N] + vals[N - 2];\n  cout << ans << endl;\n}\n\nint con(string& S, char t) {\n  int ans = 1000000;\n  int cur = 0;\n  for (auto c : S) {\n    if (c == t)\n      cur++;\n    else {\n      if (cur != 0) ans = min(ans, cur);\n      cur = 0;\n    }\n  }\n  return ans;\n}\n\nmint<> calcDP(int N, int conB, int conR) {\n  vector<mint<>> dpR(N + 2, mint<>(0));\n  vector<mint<>> dpB(N + 2, mint<>(0));\n  vector<mint<>> sumR(N + 2, mint<>(0));\n  vector<mint<>> sumB(N + 2, mint<>(0));\n  dpR[1] = 1;\n  sumR[1] = 1;\n  for (int i = 2; i <= N + 1; i++) {\n    if (i % 2 == 1) {\n      dpR[i] = sumB[i - 1] - sumB[max(0, i - conB - 1)];\n      // if (i <= conB) dpR[i] += 1;\n\n    } else\n      dpB[i] = sumR[i - 1] - sumR[max(0, i - conR - 1)];\n    sumB[i] = sumB[i - 1] + dpB[i];\n    sumR[i] = sumR[i - 1] + dpR[i];\n  }\n  mint<> ans = 0;\n  for (int i = 0; i < conB + 1; i++) {\n    ans += sumR[N - i] - sumR[N - conB - 1];\n  }\n  return ans;\n}\n\nvoid solve(long long N, long long M, std::string S) {\n  int cntB = 0;\n\n  int conR = con(S, 'R');\n  int conB = con(S, 'B');\n  for (int i = 0; i < N; i++) {\n    if (S[i] == 'B') cntB++;\n  }\n  if (cntB == N || cntB == 0) {\n    special(N);\n    return;\n  }\n  if (N % 2 == 1) {\n    cout << 0 << endl;\n    return;\n  }\n  if (S[0] == 'R') swap(conR, conB);\n  conR = 1;\n  if (conB % 2 == 0) conB++;\n  // if (conR % 2 == 0) conR--;\n\n  mint<> ans = calcDP(N, conB, conR);\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long M;\n  scanf(\"%lld\", &M);\n  std::string S;\n  std::cin >> S;\n  solve(N, M, S);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define pld pair <ld, ld>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n#define cld complex <double>\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 3e5;\nconst ll mod = 1e9 + 7;\n\nll n, m, k, t;\n\nstring s;\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;\n}\n\nll simple() {\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    ll q;\n    for (q = 1; q < n; q++) {\n        D[q] += D[q - 1];\n        if (q >= 2) {\n            D[q] += D[q - 2];\n            D[q] %= mod;\n        }\n    }\n    return (D[n - 2] * 2 + D[n - 1]) % mod;\n    // if (n % 2 == 1) {\n    //     return \n    // }\n    // return step(2, n / 2 + 1);\n}\n\nint main() {\n    pyshnapyshnakaa\n    ll q, w, e, a, b, c;\n    cin >> n >> m;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (q = 0; q < s.length(); q++) {\n            if (s[q] == 'R') {\n                s[q] = 'B';\n            }\n            else {\n                s[q] = 'R';\n            }\n        }\n    }\n    vector <pll> A;\n    A.pb(mp(1, s[0]));\n    for (q = 1; q < s.length(); q++) {\n        if (s[q] == A.back().second) {\n            A.back().first++;\n        }\n        else {\n            A.pb(mp(1, s[q]));\n        }\n    }\n    // cout << \"FALL\" << endl;\n    bool blue = 0; /*kill = 0;*/\n    ll mx = maxn;\n    // cout << \"\"\n    for (q = 0; q < A.size(); q++) {\n        if (A[q].second == 'B') {\n            blue = 1;\n        }\n        else {\n            if ((q == 0 || A[q].first % 2 == 1) && q != A.size() - 1) {\n                // cout << q << endl;\n                mx = min(mx, A[q].first + 1 - A[q].first % 2);\n            }\n        }\n    }\n    // cout << mx;\n    // return 0;\n    // cout << \"MX \" << mx << endl;\n    // if (fail) {\n    //     cout << 0;\n    //     return 0;\n    // }\n    if (!blue) {\n        cout << simple();\n        return 0;\n    }\n    // ll mx = maxn, cur = 0;\n    // for (q = 0; q < s.length(); q++) {\n    //     if (s[q] == 'B') {\n    //         if (cur % 2 == 1) {\n    //             mx = min(mx, cur);\n    //         }\n    //         else {\n    //             mx = min(mx, cur + 1);\n    //         }\n    //         cur = 0;\n    //     }\n    //     else {\n    //         cur++;\n    //     }\n    // }\n    vector <ll> S(2);\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    S[0] = 1;\n    for (q = 1; q < n; q++) {\n        D[q] = S[q % 2];\n        S[q % 2] = (S[q % 2] + D[q]) % mod;\n        ll deli = q - mx - 1;\n        if (deli >= 0) {\n            // cout << \"DELETING \" << q << endl;\n            S[deli % 2] = (S[deli % 2] - D[deli] + mod) % mod;\n        }\n        // cout << q << \" \" << D[q] << endl;\n    }\n    // cout << \"mx \" << mx << endl;\n    ll ans = 0;\n    for (q = 0; q < n; q++) {\n        ll len = n - q - 1;\n        if (len % 2 == 0 || len > mx) {\n            continue;\n        }\n        ans += D[q] * (len + 1) % mod;\n        ans %= mod;\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll MOD = (ll)1e9 + 7;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\n\nconst int N = 200200;\nchar s[N];\nint n, m;\nll dp[N];\n\nvoid solve1() {\n\tdp[0] = 0;\n\tdp[1] = 1;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tdp[i] = add(dp[i], dp[i - 1]);\n\t\tdp[i + 1] = dp[i - 1];\n\t}\n\tll ans = 1;\n\tfor (int i = 2; i <= n; i++)\n\t\tans = add(ans, mult(i, sub(dp[n - i + 1], dp[n - i])));\n\tprintf(\"%lld\\n\", ans);\n\treturn;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", s);\n\tbool allEq = true;\n\tfor (int i = 1; i < m; i++)\n\t\tallEq &= s[i] == s[0];\n\tif (allEq) {\n\t\tsolve1();\n\t\treturn 0;\n\t}\n\tif (n & 1) {\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tint b = n;\n\tint lst = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (s[i] == s[0]) continue;\n\t\tint x = i - lst - 1;\n\t\tif (x % 2 == 0) {\n\t\t\tif (lst == -1) b = min(b, x + 2);\n\t\t} else {\n\t\t\tb = min(b, x + 1);\n\t\t}\n\t\tlst = i;\n\t}\n\tb /= 2;\n\tn /= 2;\n\n\tdp[0] = 0;\n\tdp[1] = 1;\n\tfor (int i = 1; i <= n + 1; i++) {\n\t\tdp[i] = add(dp[i], dp[i - 1]);\n\t\tdp[i + 1] = sub(dp[i], dp[max(0, i - b)]);\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= b; i++)\n\t\tans = add(ans, mult(2 * i, sub(dp[n - i + 1], dp[n - i])));\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,m;\nchar str[200050];\nconst int mod = 1000000007;\nint dp[200050];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str + 1);\n\tbool c1 = 0,c2 = 0;\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tc1 |= str[i] == 'R';\n\t\tc2 |= str[i] == 'B';\n\t}\n\tint p = 1;\n\tint lim;\n\tif(c1 && c2)\n\t{\n\t\tif(n & 1)\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(;str[p + 1] == str[1]; ++ p);\n\t\tlim = p + (p % 2 == 0);\n\t\tint len = 0;\n\t\tfor(int i = p + 1;i <= m; ++ i)\n\t\t{\n\t\t\tif(str[i] != str[1]) lim = min(lim,len % 2 ? len : 10000000),len = 0;\n\t\t\telse len ++;\n\t\t}\n\t\tlim ++;\n\t\tlim /= 2;\n\t\tlim = min(lim,n / 2);\n\t\tint pre = 1;\n\t\tint cur = 0;\n\t\tdp[0] = 1;\n\t\tlong long ans = 0;\n\t\tfor(int i = 0;i <= n / 2; ++ i)\n\t\t{\n\t\t\tif(i)\n\t\t\t{\n\t\t\t\twhile(i - cur > lim) pre -= dp[cur],pre = (pre + mod) % mod,cur ++;\n\t\t\t\tdp[i] = pre;\n\t\t\t\tpre += dp[i];\n\t\t\t\tpre %= mod;\n\t\t\t}\n\t\t\tif(n - i * 2 > 0 && (n - i * 2) / 2 <= lim)\n\t\t\t\tans = ans + 1LL * (n - i * 2) * dp[i] % mod,ans %= mod;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse\n\t{\n\t\tint pre = 0;\n\t\tint cur = 0;\n\t\tdp[0] = 1;\n\t\tlong long ans = 0;\n\t\tfor(int i = 0;i <= n; ++ i)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\tdp[i] = pre;\n\t\t\t\tpre += dp[i - 1];\n\t\t\t\tpre %= mod;\n\t\t\t}\n\t\t\tif(n - i > 1)\n\t\t\t\tans = ans + 1LL * (n - i) * dp[i] % mod,ans %= mod;\n\t\t}\n\t\tprintf(\"%lld\\n\",(ans + 1) % mod);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Tp template<typename Ty>\n#define Ts template<typename Ty,typename... Ar>\n#define Reg register\n#define RI Reg int\n#define Con const\n#define CI Con int&\n#define I inline\n#define W while\n#define N 200000\n#define X 1000000007\nusing namespace std;\nint n,m,t,a[N+5],f[N+5],g[N+5];char s[N+5];\nint w[N+5][2];I void Work()\n{\n\t#define DP() for(RI i=2;i<=n;++i) w[i][0]=w[i-1][1],w[i][1]=(w[i-1][0]+w[i-1][1])%X;\n\tw[1][1]=1;DP();RI t=(w[n][0]+w[n][1])%X;\n\tw[1][0]=1,w[1][1]=0;DP();printf(\"%d\\n\",(t+w[n][1])%X);\n}\nint main()\n{\n\tRI i;for(scanf(\"%d%d%s\",&n,&m,s+1),i=1;i<=m;++i) s[i]^s[i-1]&&++t,++a[t];\n\tif(t&1&&--t,!t) return Work(),0;if(n&1) return puts(\"0\"),0;\n\tRI p=a[1]+(a[1]&1^1);for(i=3;i<=t;i+=2) a[i]&1&&(p=min(p,a[i]));\n\tfor(f[0]=g[0]=1,i=2;i<=n;++i) f[i]=(g[i-2]+(i-p-3>=0?X-g[i-p-3]:0))%X,g[i]=(g[i-2]+f[i])%X;\n\tRI res=0;for(i=2;i<=p+1&&i<=n;++i) res=(1LL*i*f[n-i]+res)%X;return printf(\"%d\\n\",res),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int N = 501000,mod = 1e9+7;\nchar s[N];\nint a[N],n,m;\nvoid solve1(){\n\tint f[N][2][2];memset(f,0,sizeof(f));\n\tf[1][1][1]=f[1][0][0]=1;\n\tauto upd=[](int&a,int b){a+=b;if(a>=mod)a-=mod;};\n\tfor(int i=2;i<=n;i++){\n\t\tupd(f[i][1][1],f[i-1][1][0]);\n\t\tupd(f[i][1][1],f[i-1][1][1]);\n\t\tupd(f[i][1][0],f[i-1][1][1]);\n\t\tupd(f[i][0][1],f[i-1][0][0]);\n\t\tupd(f[i][0][1],f[i-1][0][1]);\n\t\tupd(f[i][0][0],f[i-1][0][1]);\n\t}\n\tcout<<(0ll+f[n][1][1]+f[n][1][0]+f[n][0][1])%mod<<'\\n';\n}\nvoid solve2(){\n\tint _f[N],*f;memset(_f,0,sizeof(_f));\n\tf=_f+100;\n\tint len=n|1,now=0,pos=m;\n\twhile(a[pos]) pos--;\n\tfor(int i=pos;i;i--)\n\t\tif(!a[i]){\n\t\t\tif(now&1) len=min(len,now);\n\t\t\tnow=0;\n\t\t}\n\t\telse now++;\n\tlen=min(len,now|1);\n\tf[-1]=f[1]=1;\n\tfor(int i=3;i<=n;i+=2){\n\t\tf[i]=2ll*f[i-2]%mod;\n\t\tif(i>len) f[i]=(f[i]-f[i-len-3]+mod)%mod;\n\t}\n\tll ans=0;\n\tfor(int i=1;i<=len;i+=2) ans=(1ll*(i+1)*f[n-i-2]+ans)%mod;\n\tcout<<ans<<'\\n';\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>n>>m>>s+1;\n\tfor(int i=1;i<=m;i++)\n\t\ta[i]=s[i]==s[1];\n\tint flag=1;\n\tfor(int i=1;i<=m;i++)\n\t\tflag&=a[i];\n\tif(flag) solve1();\n\telse solve2();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include <algorithm>\n// #include <iostream>\n// #include <string>\n\n// using namespace std;\n\n// #define MAX_N 200000\n// #define MAX_M 200000\n// #define MOD 1000000007\n\n// #define INF 1 << 29\n\n// int N, M;\n// string S;\n\n// long long dp[MAX_N + 2], rdp[MAX_N + 2];\n\n// int all_color_is_same()\n// {\n//     long long rr = 1, bb = 1, rb = 0, br = 0;\n\n//     for ( int i = 1; i < N; i++ )\n//     {\n//         long long nrr = ( rr + rb ) % MOD;\n//         long long nbb = br;\n//         long long nrb = rr;\n//         long long nbr = ( bb + br ) % MOD;\n\n//         rr = nrr;\n//         bb = nbb;\n//         rb = nrb;\n//         br = nbr;\n//     }\n\n//     return ( rr + rb + br ) % MOD;\n// }\n\n// /**\n//  * S\n//  の先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n//  */\n// int min_freq()\n// {\n//     int l = 0;\n//     while ( l < M && S[0] == S[l] ) l++;\n\n//     int ans = ( l & 1 ) ? l : l + 1;\n\n//     l = 0;\n//     for ( int i = 0; i < M; i++ )\n//     {\n//         if ( S[0] == S[i] )\n//             l++;\n//         else if ( l & 1 )\n//         {\n//             ans = min( ans, l );\n//             l = 0;\n//         }\n//     }\n//     return l ? min( ans, l ) : ans;\n// }\n\n// int solve()\n// {\n//     // 一色\n//     if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n//         return all_color_is_same();\n\n//     // N が奇数\n//     if ( N & 1 ) return 0;\n\n//     int L = min_freq();\n\n//     L = ( L + 1 ) >> 1;\n//     N >>= 1;\n\n//     dp[0] = rdp[0] = 1;\n//     for ( int i = 1; i <= N + 1; i++ )\n//     {\n//         dp[i] = rdp[i - 1];\n//         if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n//         if ( dp[i] < 0 ) dp[i] += MOD;\n//         rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n//     }\n\n//     long long res = 0;\n//     for ( int i = 1; i <= L; i++ )\n//         if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n//     return res % MOD;\n// }\n\n// int main( int argc, char **argv )\n// {\n//     cin >> N >> M;\n//     cin >> S;\n\n//     int ans = solve();\n\n//     cout << ans << endl;\n\n//     return 0;\n// }\n#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define INF ( 1 << 29 )\n#define LINF ( 1LL << 60 )\n#define EPS ( 1e-10 )\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt all( Int n )\n{ // no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for ( int i = 1; i < n; i++ )\n    {\n        Int nrr = ( rr + rb ) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = ( bb + br ) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return ( rr + rb + br ) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc( Int n, Int limit )\n{\n    dp[0] = 1;\n    rdp[0] = 1;\n    for ( int i = 1; i <= n + 1; i++ )\n    {\n        dp[i] = ( rdp[i - 1] -\n                  ( ( i - limit - 1 ) >= 0 ? rdp[i - limit - 1] : 0 ) ) %\n                MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n}\n\nInt solve( Int n, Int limit )\n{\n    if ( n % 2 == 1 ) return 0;\n    if ( limit % 2 != 1 ) exit( 1 );\n    limit = ( limit + 1 ) / 2;\n    n /= 2;\n    Int res = 0;\n    calc( n + 10, limit );\n    for ( Int i = 1; i <= limit; i++ )\n    {\n        if ( n - i >= 0 ) res = ( res + dp[n - i] * 2 * i ) % MOD;\n    }\n    if ( res < 0 ) exit( 1 );\n    return res % MOD;\n}\n\nint main()\n{\n    Int n, m;\n    string str;\n    cin >> n >> m;\n    cin >> str;\n\n    bool allsame = true;\n    for ( int i = 0; i < m; i++ ) allsame &= ( str[i] == str[0] );\n    if ( allsame )\n    {\n        cout << all( n ) << endl;\n        return 0;\n    }\n\n    Int l = 0;\n    while ( str[0] == str[l] ) l++;\n    if ( l % 2 == 0 ) l++;\n    Int limit = l;\n    l = 0;\n    for ( int i = 0; i < m; i++ )\n    {\n        if ( str[i] == str[0] )\n            l++;\n        else\n        {\n            if ( l % 2 == 1 ) limit = min( limit, l );\n            l = 0;\n        }\n    }\n    cout << solve( n, limit ) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline tuple<int, int, int> extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nunsigned ModInt::MOD = 1000000007;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\n\nvector<mint> Fact, InvFact;\nvoid makeFact(int n){\n\tFact = vector<mint>(n+1);\n\tFact[0] = mint(1);\n\trep(i,1,n+1) Fact[i] = mint(i) * Fact[i-1];\n\n\tInvFact = vector<mint>(n+1);\n\tInvFact[n] = mint(1) / Fact[n];\n\trrep(i,n) InvFact[i] = mint(i+1) * InvFact[i+1];\n}\n\nmint Factorial(int n){ return Fact[n];}\nmint InverseFactorial(int n){ return InvFact[n];}\nmint Permutation(int n,int k){ return (n < 0 or k < 0 or n - k < 0) ? ZERO : Fact[n] * InvFact[n - k];}\nmint Combination(int n,int k){ return (n < 0 or k < 0 or n - k < 0) ? ZERO : Fact[n] * InvFact[k] * InvFact[n-k];}\n\n\nconst int limit = 200010;\nmint dp[limit][2][2];\nmint dp2[limit];\nmint csum2[limit];\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\n\tmakeFact(2 * limit);\n\n\tbool same = true;\n\trep(i, n) if(s[0] != s[i]) same = false;\n\n\tif(same){\n\t\tdp[1][0][0] = ONE;\n\t\tdp[1][1][1] = ONE;\n\t\trep(i, 1, n) rep(start, 2) rep(prv, 2){\n\t\t\tdp[i + 1][start][0] += dp[i][start][prv];\n\t\t\tif(prv == 0) dp[i + 1][start][1] += dp[i][start][prv];\n\t\t}\n\t\tmint ans = dp[n][0][0] + dp[n][0][1] + dp[n][1][0];\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\t\t\n\tif(n % 2 == 1){\n\t\tcout << ZERO << endl;\n\t\treturn 0;\n\t}\n\n\tint cmin = m, cons = 0;\n\trep(i, m){\n\t\tif(s[i] == s[0]){\n\t\t\tcons++;\n\t\t} else {\n\t\t\tchmin(cmin, cons);\n\t\t}\n\t}\n\n\tif(cmin % 2 == 0) cmin++;\n\tdp2[1] = csum2[1] = ONE;\n\n\trep(i, 1, n){\n\t\tconst int pos = max(i - cmin - 1, 0);\n\t\tif((i + 1) % 2 == 1) dp2[i + 1] =  csum2[i] - csum2[pos];\n\t\tcsum2[i + 1] = csum2[i] + dp2[i + 1];\n\t}\n\n\tmint ans = ZERO;\n\n\trep(i, n - cmin, n + 1){\n\t\tif(n - i % 2 == 0) continue;\n\t\tconst mint coef = mint(n - i + 1);\n\t\tans += coef * dp2[i];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\ntemplate<typename T>\nclass RangeAddQuery {\npublic:\n    explicit RangeAddQuery(int n) : N(calcN_(n)) {\n        mVal.assign(2*N+1, 0);\n    }\n    void update(int l, int r, T value){\n        l = max(0, l);\n        r = min(N, r);\n        int offset = N;\n        while(offset > 0){\n            if(l >= r) break;\n            if(l&1){ update_(mVal[offset+l-1], value); l++; }\n            if(r&1){ update_(mVal[offset+r-2], value); }\n            l /= 2;\n            r /= 2;\n            offset /= 2;\n        }\n    }\n    T get(int idx){\n        int i = N + idx - 1;\n        auto res = mVal[i];\n        while(i > 0){\n            i = (i-1)/2;\n            update_(res, mVal[i]);\n        }\n        return res;\n    }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    inline void update_(T& data, T val) { data = (data + val) % MOD; }\n    const int N;\n    vector<T> mVal;\n};\n\nint maxSegment(const string& S){\n    char c = S[0];\n    bool first = true;\n    int cnt = 0;\n    int res = MOD;\n    for(auto& s : S){\n        if(c == s) ++cnt;\n        else {\n            if(first || cnt%2 == 1){\n                res = min(res, cnt/2+1);\n                cnt = 0;\n                first = false;\n            }\n        }\n    }\n    return res < MOD ? res : -1;\n}\n\nint solve(const string& S, int N){\n    int seg = maxSegment(S);\n    if(seg != -1 && N%2 == 1) return 0;\n    long long res = 0;\n    if(seg == -1){\n        RangeAddQuery<long long> raq(N);\n      raq.get(MOD);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N;i++){\n            auto a = raq.get(i);\n            raq.update(i+2, N, a);\n        }\n        res = 1;\n        for(int i=N-2;i>=0;i--){\n            res = (res + raq.get(i) * (N-i)) % MOD;\n        }\n    } else {\n        seg = min(seg, N/2);\n        RangeAddQuery<long long> raq(N/2);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N/2;i++){\n            auto a = raq.get(i);\n            raq.update(i+1, i+1+seg, a);\n        }\n        for(int i=N/2-1;i>=N/2-seg;i--){\n            res = (res + raq.get(i) * 2 * (N/2-i)) % MOD;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    cout << solve(S, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200233, mod = 1000000007;\nint n, m, f[N];\nchar s[N];\n\nint main() {\n  scanf(\"%d%d%s\", &n, &m, s + 1);\n  if (*min_element(s + 1, s + 1 + n) == *max_element(s + 1, s + 1 + n)) {\n    int x = 2, y = 1;\n    for (int i = 1; i <= n; i++) {\n      y = y + x;\n      x = y - x;\n    }\n    printf(\"%d\\n\", x);\n    return 0;\n  }\n  int limit, x = 1;\n  while (x + 1 <= m && s[x + 1] == s[1]) x++;\n  limit = x | 1;\n  for (int i = x + 1, j = 0; i <= m; i++) {\n    if (s[i] != s[1]) {\n      if (j & 1) limit = min(limit, j);\n      j = 0;\n    } else {\n      ++j;\n    }\n  }\n  if (n & 1) {\n    puts(\"0\");\n    return 0;\n  }\n  n >>= 1;\n  limit = min(n, (limit + 1) >> 1);\n  f[0] = 1;\n  for (int i = 1; i <= n; i++) {\n    f[i] = ((long long) mod + f[i - 1] + f[i - 1] - (i > limit ? f[i - limit - 1] : 0)) % mod;\n  }\n  int ans = 0;\n  for (int i = 1; i <= limit; i++) {\n    ans = (ans + (long long) (mod + f[n - i] - (n > i ? f[n - i - 1] : 0)) * i * 2) % mod;\n  }\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n//#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int M = 1e9 + 7;\n\nvoid solve_fib(int n) {\n    vi f(n + 1);\n    f[0] = f[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        f[i] = (f[i - 1] + f[i - 2]) % M;\n    }\n    cout << (f[n] + f[n - 2]) % M;\n}\n\nint kek(int cnt) {\n    if (cnt & 1)\n        return cnt;\n    return cnt + 1;\n}\n\nvoid insum(int &a, int b) {\n    a = (a + b) % M;\n}\n\nvoid smain() {\n\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    m = s.size();\n    if (count(ALL(s), 'R') == 0 || count(ALL(s), 'B') == 0) {\n        solve_fib(n);\n        return;\n    }\n\n    vi a(m);\n    fori (i, m) {\n        a[i] = s[i] == 'R';\n    }\n\n    vi min_sz(2, m);\n    int cur = -1;\n    int cnt = 0;\n    for (auto c : a) {\n        if (c != cur) {\n            if (cur != -1) {\n                inmin(min_sz[cur], kek(cnt));\n            }\n            cur = c;\n            cnt = 1;\n        } else {\n            cnt++;\n        }\n    }\n    inmin(min_sz[cur], kek(cnt));\n    vvi f(2);\n    fori (z, 2) {\n        vvi dp(2, vi(n, 0));\n        vvi p(2, vi(n, 0));\n        p[!z][0] = dp[!z][0] = 1;\n        for (int i = 1; i < n; ++i) {\n            fori (zz, 2) {\n                int j = i - min_sz[zz];\n                if (j < i) {\n                    dp[zz][i] = (p[!zz][i - 1] - (j - 2 >= 0 ? p[!zz][j - 2] : 0) + M) % M;\n                }\n            }\n            fori (zz, 2) {\n                p[zz][i] = (dp[zz][i] + (i - 2 >= 0 ? p[zz][i - 2] : 0)) % M;\n            }\n        }\n        f[z] = dp[z];\n    }\n    int ans = 0;\n    fori (z, 2) {\n        for (int sz = 1; sz <= min_sz[z]; sz += 2) if (sz < n){\n            insum(ans, (ll)f[!z][n - sz] * sz % M);\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\ntypedef pair<int, int> P;\nconst long long inf = 1ll << 61;\nconst long long mod = 1000000007;\n\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (s[0] == 'B') {\n\t\trep(i, m) {\n\t\t\tif (s[i] == 'R')s[i] = 'B'; else s[i] = 'R';\n\t\t}\n\t}\n\tvector<int>r, b;\n\tchar now = 'R'; int cnt1 = 0;\n\ts.push_back('A');\n\trep(i, m+1) {\n\t\tif (now == s[i])cnt1++;\n\t\telse {\n\t\t\tif (now == 'R')r.push_back(cnt1);\n\t\t\telse b.push_back(cnt1);\n\t\t\tnow = s[i];\n\t\t\tcnt1 = 1;\n\t\t}\n\t}\n\ts.pop_back();\n\n\tif (b.empty()) {//全部一緒\n\t\tvector<int>L(200005);\n\t\tL[0] = 2; L[1] = 1;\n\t\trep(i, 200002)L[i + 2] = (L[i] + L[i + 1]) % mod;\n\t\tcout << L[n] << endl;\n\t\treturn 0;\n\t}\n\n\tif (n & 1) {\n\t\tcout << 0 << endl; return 0;\n\t}\n\telse {\n\t\tint MR = r[0];\n\t\tif (MR & 1)MR += 2;\n\t\telse MR += 1;\n\t\tfor (int e : r){\n\t\t\tif (e & 1)MR = min(MR, e);\n\t\t}\n\t\tMR = (MR + 1) / 2;\n\t\tvector<int>dp(200005);\n\t\tint s = 1, as = 1;\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= MR; i++) {\n\t\t\tdp[i] = (as + i) % mod;\n\t\t\tas = (as + dp[i]) % mod;\n\t\t}\n\t\tfor (int i = MR + 1; i <= n; i++) {\n\t\t\tdp[i] = as;\n\t\t\tas += dp[i];\n\t\t\tas -= dp[i - MR];\n\t\t\tas = (as + mod) % mod;\n\t\t}\n\t\tcout << (dp[n/2]*2)%mod << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nconst int md = 1e9 + 7;\n\nint dp[N];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n  vector<int> y;\n  for (int i = 0; i < m; i++) {\n    int cnt = 1;\n    while (i + 1 < m && s[i + 1] == s[i]) {\n      ++i;\n      ++cnt;\n    }\n    y.push_back(cnt);\n  }\n  if (y.size() == 1) {\n    vector<int> f(n + 1), g(n + 1);\n    f[1] = 2, f[2] = 3;\n    for (int i = 3; i <= n; i++) {\n      f[i] = (f[i - 1] + f[i - 2]) % md;\n    }\n    g[0] = 1, g[1] = 2, g[2] = 3, g[3] = 4;\n    for (int i = 4; i <= n; i++) {\n      g[i] = ((long long) g[i - 1] + g[i - 2] + md - f[n - 4]) % md;\n    }\n    cout << g[n] << '\\n';\n    return 0;\n  } else if (n % 2 == 1) {\n    cout << 0 << '\\n';\n    return 0;\n  }\n  int C = y[0] + 1;\n  bool is = true;\n  for (int x : y) {\n    if (is && (x % 2 == 1)) {\n      C = min(C, x);\n    }\n    is ^= 1;\n  }\n  dp[0] = dp[2] = 1;\n  for (int i = 4; i < N; i += 2) {\n    dp[i] = 2 * dp[i - 2] % md;\n    if (i - 3 - C >= 0) {\n      (dp[i] += md - dp[i - 3 - C]) %= md;\n    }\n  }\n  int ans = dp[n];\n  for (int l = 1; l <= C; l += 2) {\n    if (n - l - 1 >= 0) {\n      (ans += (long long) l * dp[n - l - 1] % md) %= md;\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register\nchar ss[1001000];\nconst int mod=1e9+7;\nint f[1001000],x[2];\nint main()\n{\n\tre int n,m,ans=1,xx=1,mmx=1<<30;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",ss+1);\n\tfor(re int i=1;i<=m;i++)\n\t{\n\t\tif(ss[i]!=ss[1])\n\t\t{\n\t\t\tif(xx<mmx)mmx=xx;\n\t\t\txx=0;ans=0;\n\t\t}else xx++;\n\t}\n\tif(mmx&1)mmx++;\n\tf[0]=1;\n\tfor(re int i=2;i<=n;i++)\n\t{\n\t\tf[i]=x[(i&1)]=((long long)x[(i&1)]+f[i-2]+(i-mmx-2>=0?mod-f[i-mmx-2]:0))%mod;printf(\"**%d %d\\n\",i,f[i]);\n\t}\n\tfor(re int i=2;i<=mmx&&i<=n;i+=2)ans=(ans+(long long)i*f[n-i])%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\nconst int N=200200,P=1e9+7;\nint n,m,ans,lim,all,mxo;\nint b[N],f[N],s[N];\nchar S[N];\nvoid work(int w){\n\tf[0]=s[0]=1;//cout<<w<<' '<<lim<<'\\n';\n\tif(w==1){\n\t\tf[1]=0;s[1]=1;\n\t\tFOR(i,2,n){\n\t\t\tf[i]=s[i-2];\n\t\t\ts[i]=(s[i-1]+f[i])%P;\n\t\t\t//cout<<f[i]<<' ';\n\t\t}\n\t}\n\telse{\n\t\tFOR(i,1,n){\n\t\t\tf[i]=(s[i-1]-(i-lim-1<0?0:s[i-lim-1])+P)%P;\n\t\t\ts[i]=(s[i-1]+f[i])%P;\n\t\t\t//cout<<f[i]<<'\\n';\n\t\t}\n\t}\n\tFOR(i,1+(w==1),min(lim,n)) (ans+=1ll*i*f[n-i]%P)%=P;\n\tcout<<w*ans%P<<'\\n';\n}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d%d%s\",&n,&m,S+1);\n\tROF(i,m,1) b[i]=S[i]=='R'^S[1]=='B';\n\tall=1;\n\tFOR(i,1,m) all&=b[i];\n\tif(all) return lim=n,ans=1,work(1),0;\n\tFOR(i,1,m)if(!b[i]){lim=i-!(i%2);break;}\n\tfor(int l=1,r=1;l<=m;l=r){\n\t\twhile(r<=m && b[r]==b[l]) r++;\n\t\tif(b[l]==0) continue;\n\t\tif(r-l&1) mxo=max(mxo,r-l);\n\t}\n\tif(mxo) lim=min(lim,mxo);\n\tlim=lim+1>>1;\n\tif(n&1) return puts(\"0\"),0;\n\tn/=2;work(2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[2160000];\nInt rdp[2160000];\nInt dp[2160000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n+10, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    if(str.size() != m)return 1;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i < vec.size();i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nlong long prime = 1000000007;\n\nbool all_chars_equal(string s) {\n    for (char c : s) {\n        if (c != s[0]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nvector<int> get_runs(string s) {\n    vector<int> runs;\n    int current_run = 0;\n    for (char c : s) {\n        if (c == s[0]) {\n            ++current_run;\n        } else if (current_run > 0) {\n            runs.push_back(current_run);\n            current_run = 0;\n        }\n    }\n    if (current_run > 0) {\n        runs.push_back(current_run);\n    }\n    return runs;\n}\n    \nlong long f(int n, int k) {\n    vector<long long> pow_2(2 * k + 4);\n    pow_2[0] = 1LL;\n    for (int i = 1; i < 2 * k + 4; ++i) {\n        pow_2[i] = pow_2[i - 1] * 2 % prime;\n    }\n\n    vector<long long> f1(max(n + 1, 2 * k + 4), 0);\n    for (int i = 1; i <= k; ++i) {\n        f1[i] = pow_2[i];\n    }\n    f1[k + 1] = (pow_2[k+1] - 1 + prime) % prime;\n    for (int n1 = k + 2; n1 <= 2 * k + 3; ++n1) {\n        f1[n1] = ((pow_2[n1] - 1 - n1 * pow_2[n1 - k - 2]) % prime + prime) % prime;\n    }\n    for (int n1 = 2 * k + 4; n1 <= n; ++n1) {\n        f1[n1] = ((2 * f1[n1 - 1] - f1[n1 - k - 2]) % prime + prime) % prime;\n    }\n    return f1[n];\n}\n\n/*\nf(n, k) = antal cirkler af længde n med højst k røde i streg (ingen andre begrænsninger)\n\nf(n, k) = 2^n for n <= k\nf(n, k) = 2^n - 1 for n = k+1\nf(n, k) = 2^n - 1 - n * 2^{n-k-2} for k+2 <= n <= 2k+3\nf(n, k) = 2f(n-1, k) - f(n-k-2, k) for n >= 2k + 4\n\n*/\n\nlong long different_case(int n, int k) {\n    return f(n / 2, (k - 1) / 2) * 2LL;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    string s;\n    cin >> n >> m;\n    cin >> s;\n    auto t0 = clock();\n    if (all_chars_equal(s)) {\n        cout << f(n, 1) << endl;  // OK since n >= 2\n        cerr << \"Time used: \" << clock() - t0 << \" ms\" << endl;\n        return 0;\n    }\n    if (n % 2 != 0) {\n        cout << 0 << endl;\n        return 0;\n    }\n    vector<int> runs = get_runs(s);\n    int bound = runs[0] / 2 * 2 + 1;\n    bound = min(bound, n - 1);\n    for (int run : runs) {\n        if (run % 2 == 1) {\n            bound = min(bound, run);\n        }\n    }\n    cout << different_case(n, bound) << endl;\n\n    cerr << \"Time used: \" << clock() - t0 << \" ms\" << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n\n\ttemplate<typename T> inline int ts(T *s)\n\t{\n\t\tint a=0,c=fetch();\n\t\twhile(c<=32 && c!=EOF)c=fetch();\n\t\twhile(c>32 && c!=EOF)s[a++]=c,c=fetch();\n\t\ts[a]=0;\n\t\treturn a;\n\t}\n}\nusing ae86::ty;\nusing ae86::ts;\n\nconst int _ = 200007 , mo = 1000000007;\n\nint n,m,s[_];\nlint f[_]={0};\n\nint main()\n{\n\tn=ty(),m=ty(),ts(s+1);\n\tfor(int i=m;i>=1;i--)s[i]=s[i]==s[1];\n\n\tlint ans=0;\n\twhile(m>1 && s[m])m--;\n\tif(m<=1)ans=1;\n\t\n\tint lim=m;\n\tfor(int l=1,r=1;l<=m;l=r+1)\n\t{\n\t\twhile(l<=m && !s[l])l++;\n\t\tif(l>m)break;\n\t\tr=l;\n\t\twhile(r<m && s[r+1])r++;\n\t\tint len=r-l+1;\n\t\tif(l==1)lim=min(lim,len+(1-len%2));\n\t\tif(len&1)lim=min(lim,len);\n\t}\n\n\tif(lim>=m)\n\t{\n\t\tf[0]=1;\n\t\tfor(int i=1,x=0;i<=n;i++)f[i]=x,x=(x+f[i-1])%mo;\n\t\tfor(int i=2;i<=n;i++)ans=(ans+f[n-i]*i%mo)%mo;\n\t}\n\telse\n\t{\n\t\tf[0]=1;\n\t\tfor(int i=2,x=f[0];i<=n;i+=2)\n\t\t{\n\t\t\tf[i]=x,x=(x+f[i])%mo;\n\t\t\tif(i>lim)x=(x-f[i-lim-1]+mo)%mo;\t\n\t\t}\n\t\tfor(int i=2;i<=lim+1;i+=2)ans=(ans+f[n-i]*i%mo)%mo;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll dp[202020][2][2];\nll mo=1000000007;\n\nll dp2[202020];\nll dps[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\tif(S[0]=='B') {\n\t\tFORR(c,S) c='R'+'B'-c;\n\t}\n\tif(count(ALL(S),'B')==0) {\n\t\tdp[0][0][0]=dp[0][1][1]=1;\n\t\tfor(i=1;i<N;i++) {\n\t\t\t(dp[i][0][0]=dp[i-1][0][0]+dp[i-1][0][1])%=mo;\n\t\t\t(dp[i][0][1]=dp[i-1][0][0])%=mo;\n\t\t\t(dp[i][1][0]=dp[i-1][1][0]+dp[i-1][1][1])%=mo;\n\t\t\t(dp[i][1][1]=dp[i-1][1][0])%=mo;\n\t\t}\n\t\tcout<<(dp[N-1][0][0]+dp[N-1][0][1]+dp[N-1][1][0])%mo<<endl;\n\t\treturn;\n\t}\n\t\n\t\n\tint L=0;\n\twhile(S[L]=='R') L++;\n\t\n\tif(L%2==0) L++;\n\t\n\tdp2[0]=dps[0]=dps[1]=1;\n\tfor(i=2;i<=N;i++) {\n\t\tif(i%2==0) {\n\t\t\tdp2[i]=dps[i-2];\n\t\t\tif(i-(L+1)>0) dp2[i]+=mo-dps[i-(L+1)-1];\n\t\t\tdp2[i]%=mo;\n\t\t}\n\t\tif(i%2 && i==N &&(i-1)>=L) dp2[i]++;\n\t\t(dps[i]=dps[i-1]+dp2[i])%=mo;\n\t\t//cout<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=min(L,N-1);i++) {\n\t\t//cout<<i<<\" \"<<(i+1)<<\"*\"<<dp2[N-(i+1)]<<endl;\n\t\t(ret+=(i+1)*dp2[N-(i+1)])%=mo;\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\n\n/// --- Modulo Integer {{{ ///\n#include <ostream>\ntemplate < long long mod = static_cast< long long >(1e9 + 7) >\nstruct ModuloInteger {\n  static_assert(mod > 0, \"mod must be positive\");\n  static_assert(mod <= 3037000499, \"mod is too big\");\n  using integer = long long;\n  static ModuloInteger unused;\n  // math {{{\n  static inline integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  static inline integer modpow(integer a, long long b) {\n    if(b < 0) b = -b, a = modinv(a);\n    integer r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  integer val;\n  constexpr ModuloInteger() : val(0) {}\n  constexpr ModuloInteger(integer t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\nprivate:\n  // strict constructor\n  constexpr ModuloInteger(integer t, int) : val(t) {}\n\npublic:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // operator bool() { return bool(val); }\n  // ModuloInteger <arithmetic-operator>[=] ModuloInteger {{{\n  ModuloInteger operator+(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModuloInteger operator-(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModuloInteger operator*(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModuloInteger operator/(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModuloInteger &operator+=(ModuloInteger const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModuloInteger &operator-=(ModuloInteger const &rhs) { return *this += -rhs; }\n  ModuloInteger &operator*=(ModuloInteger const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModuloInteger &operator/=(ModuloInteger const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModuloInteger operator++(int) {\n    ModuloInteger tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModuloInteger operator--(int) {\n    ModuloInteger tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModuloInteger &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModuloInteger &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModuloInteger operator-() const { return ModuloInteger(val == 0 ? 0 : mod - val, 0); }\n  // ModuloInteger <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModuloInteger operator+(T const &rhs) const {\n      return ModuloInteger(val + rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator-(T const &rhs) const {\n      return ModuloInteger(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator*(T const &rhs) const {\n      return ModuloInteger(val * (rhs % mod));\n    }\n  template < typename T >\n    ModuloInteger operator/(T const &rhs) const {\n      return ModuloInteger(val * modinv(rhs));\n    }\n  template < typename T >\n    ModuloInteger &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator/=(T const &rhs) {\n      val = val * modinv(rhs) % mod;\n      return *this;\n    }\n  // }}}\n  ModuloInteger inv() const { return ModuloInteger(modinv(val), 0); }\n  ModuloInteger operator~() const { return inv(); }\n  friend std::ostream &operator<<(std::ostream &os, ModuloInteger const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // equality operator {{{\n  ModuloInteger operator==(const ModuloInteger &a) const { return val == a.val; }\n  ModuloInteger operator!=(const ModuloInteger &a) const { return val != a.val; }\n  ModuloInteger operator==(const integer &a) const { return val == ModuloInteger(a); }\n  ModuloInteger operator!=(const integer &a) const { return val != ModuloInteger(a); }\n  // }}}\n  // T <arithmetic-operator> ModuloInteger {{{\n  friend constexpr ModuloInteger operator+(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod + mv.val);\n  }\n  friend constexpr ModuloInteger operator-(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod - mv.val);\n  }\n  friend constexpr ModuloInteger operator*(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModuloInteger operator/(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModuloInteger operator^(integer x) const { return pow(*this, x); }\n  ModuloInteger &operator^=(integer x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModuloInteger pow(ModuloInteger x, integer y) {\n    return ModuloInteger(modpow(x.val, y), 0);\n  }\n  // }}}\n};\ntemplate < long long mod >\nModuloInteger< mod > ModuloInteger< mod >::unused(mod, 0);\n/// }}}--- ///\n\nusing modint = ModuloInteger<>;\n\n\n// LazySegmentTree( size [, initial] )\n// LazySegmentTree( <data> )\n/// --- LazySegmentTree {{{ ///\n#include <cassert>\n#include <initializer_list>\n#include <iostream>\n#include <vector>\ntemplate < class M_act >\nstruct LazySegmentTree {\npublic:\n  using Monoid = typename M_act::Monoid;\n  using X = typename Monoid::T;\n  using M = typename M_act::M;\n\nprivate:\n  size_t n;\n  int h;\n  vector< X > data;\n  vector< M > lazy;\n  vector< size_t > nodeLength;\n  // call before use data[i]\n  void eval(size_t i) {\n    if(lazy[i] == M_act::identity()) return;\n    data[i] = M_act::actInto(lazy[i], nodeLength[i], data[i]);\n    if(i < n) {\n      lazy[i * 2] = M_act::op(lazy[i], lazy[i * 2]);\n      lazy[i * 2 + 1] = M_act::op(lazy[i], lazy[i * 2 + 1]);\n    }\n    lazy[i] = M_act::identity();\n  }\n  // call before use seg[i] = data[i + n]\n  void evalDown(size_t i) {\n    i += n;\n    for(int j = h - 1; j >= 0; j--) eval(i >> j);\n  }\n  // call after touch seg[i] = data[i + n]\n  void propUp(size_t i) {\n    i += n;\n    while(i >>= 1)\n      eval(i * 2), eval(i * 2 + 1), data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n  }\n\npublic:\n  LazySegmentTree() : n(0) {}\n  LazySegmentTree(size_t n, X initial = Monoid::identity()) : n(n) {\n    if(n > 0) {\n      h = 1;\n      while(1u << h < n) h++;\n      data.resize(2 * n, initial);\n      lazy.resize(2 * n, M_act::identity());\n      nodeLength.resize(2 * n, 1);\n      for(size_t i = n - 1; i > 0; i--) // fill from deep\n        data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]),\n          nodeLength[i] = nodeLength[i * 2] + nodeLength[i * 2 + 1];\n    }\n  }\n  template < class InputIter, class = typename iterator_traits< InputIter >::value_type >\n    LazySegmentTree(InputIter first, InputIter last)\n    : LazySegmentTree(distance(first, last)) {\n      if(n > 0) {\n        copy(first, last, begin(data) + n);\n        for(size_t i = n - 1; i > 0; i--) // fill from deep\n          data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n      }\n    }\n  LazySegmentTree(vector< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  LazySegmentTree(initializer_list< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  void act(int l, int r, const M &m) {\n    if(l < 0) l = 0;\n    if(l >= r) return;\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    int tl = l, tr = r;\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), lazy[l] = m, eval(l), l++;\n      if(r & 1) --r, eval(r), lazy[r] = m, eval(r);\n    }\n    propUp(tl);\n    propUp(tr - 1);\n  }\n  void set(size_t i, const X &x) {\n    assert(i < n);\n    evalDown(i);\n    data[i + n] = x;\n    propUp(i);\n  }\n  X get(size_t i) {\n    assert(i < n);\n    evalDown(i);\n    return data[i + n];\n  }\n  X fold(int l, int r) {\n    if(l < 0) l = 0;\n    if(l >= r) return Monoid::identity();\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    X tmpL = Monoid::identity(), tmpR = Monoid::identity();\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), tmpL = Monoid::op(tmpL, data[l]), l++;\n      if(r & 1) --r, eval(r), tmpR = Monoid::op(data[r], tmpR);\n    }\n    return Monoid::op(tmpL, tmpR);\n  }\n  int size() { return n; }\n  inline void dum(int r = -1) {\n#ifdef DEBUG\n    if(r < 0) r = n;\n    DEBUG_OUT << \"{\";\n    for(int i = 0; i < min(r, (int) n); i++) DEBUG_OUT << (i ? \", \" : \"\") << get(i);\n    DEBUG_OUT << \"}\" << endl;\n#endif\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid examples {{{ ///\nconstexpr long long inf_monoid = 1e18 + 100;\n#include <algorithm>\nstruct Nothing {\n  using T = char;\n  using Monoid = Nothing;\n  using M = T;\n  static constexpr T op(const T &, const T &) { return T(); }\n  static constexpr T identity() { return T(); }\n  template < class X >\n    static constexpr X actInto(const M &, long long, const X &x) {\n      return x;\n    }\n};\n\ntemplate < class U = long long >\nstruct RangeMin {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::min< T >(a, b); }\n  static constexpr T identity() { return T(inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeMax {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::max< T >(a, b); }\n  static constexpr T identity() { return T(-inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeSum {\n  using T = U;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return T(0); }\n};\n\ntemplate < class U >\nstruct RangeProd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a * b; }\n  static constexpr T identity() { return T(1); }\n};\n\ntemplate < class U = long long >\nstruct RangeOr {\n  using T = U;\n  static T op(const T &a, const T &b) { return a | b; }\n  static constexpr T identity() { return T(0); }\n};\n\n#include <bitset>\n\ntemplate < class U = long long >\nstruct RangeAnd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return T(-1); }\n};\n\ntemplate < size_t N >\nstruct RangeAnd< std::bitset< N > > {\n  using T = std::bitset< N >;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return std::bitset< N >().set(); }\n};\n\n/// }}}--- ///\n\n/// --- M_act examples {{{ ///\ntemplate < class U = long long, class V = U >\nstruct RangeMinAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMin< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMax< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMinSet {\n  using M = U;\n  using Monoid = RangeMin< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxSet {\n  using M = U;\n  using Monoid = RangeMax< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long n, const X &x) { return m * n + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long n, const X &x) {\n    return m == identity() ? x : m * n;\n  }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdMul {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M mpow(M a, long long b) {\n    X r(1);\n    while(b) {\n      if(b & 1) r = r * a;\n      a = a * a;\n      b >>= 1;\n    }\n    return r;\n  }\n  static M op(const M &a, const M &b) { return a * b; }\n  static constexpr M identity() { return M(1); }\n  static X actInto(const M &m, long long n, const X &x) { return x * mpow(m, n); }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return V::unused; }\n  static X actInto(const M &m, long long n, const X &) {\n    if(m == identity()) return;\n    return RangeProdMul< U, V >::mpow(m, n);\n  }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeOr2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeOr< U >;\n  static M op(const M &a, const M &b) { return a | b; }\n  static constexpr M identity() { return M(0); }\n  static X actInto(const M &m, long long, const X &x) { return m | x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeAnd2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return M(-1); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n\ntemplate < class U, size_t N >\nstruct RangeAnd2< U, std::bitset< N > > {\n  using X = U;\n  using M = std::bitset< N >;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return std::bitset< N >().set(); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n/// }}}--- ///\n\nusing Seg = LazySegmentTree< RangeSumAdd<modint> >;\n\n\n// NOTE : use H with larger N\n/// --- Modulo Factorial {{{ ///\n#include <cassert>\n#include <cstddef>\ntemplate < std::size_t N, int mod = static_cast< int >(1e9 + 7) >\nstruct Factorial {\n  using integer = long long;\n  constexpr integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d = 0;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  constexpr integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  int arr[N + 1], inv[N + 1];\n  integer operator[](int i) const { return arr[i]; }\n  Factorial() : arr(), inv() {\n    arr[0] = 1;\n    for(std::size_t i = 1; i <= N; i++) {\n      arr[i] = (integer) i * arr[i - 1] % mod;\n    }\n    inv[N] = modinv(arr[N]);\n    for(int i = N - 1; i >= 0; i--) {\n      inv[i] = (integer)(i + 1) * inv[i + 1] % mod;\n    }\n  }\n  integer C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    assert(n <= N);\n    return (integer) arr[n] * inv[r] % mod * inv[n - r] % mod;\n  }\n  integer H(int n, int r) const { return C(n + r - 1, r); }\n};\n/// }}}--- ///\n\nconstexpr int mod = 1e9 + 7;\nconst int N = 2e5 + 10;\nFactorial< N * 2, mod > fact;\n\n\n\nint n, m;\nint r, b;\nint rmax;\nstring s;\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n >> m;\n  cin >> s;\n  if(s[0] == 'B') for(auto &e : s) e = e == 'R' ? 'B' : 'R';\n  bool allR = 1;\n  for(auto e : s) allR &= e == 'R';\n\n  if(allR) {\n    dump(\"allR\");\n    modint ans;\n    for(int B = 0; B <= n; B++) {\n      int R = n - B - B;\n      ans += modint(fact.C(R + B, R));\n      ans += modint(fact.C(R + B - 1, R));\n    }\n    cout << ans << endl;\n    return 0;\n  }\n\n  if(n % 2 == 1) {\n    cout << 0 << endl;\n    dump(\"odd\");\n    return 0;\n  }\n\n  int c = 0;\n  rmax = m;\n  bool first = 1;\n  for(int i = 0; i <= m; i++) {\n    if(s[i] == 'B') {\n      if(c) {\n        if(c % 2 == 0 && first) rmax = min(rmax, c + 1);\n        if(c % 2 == 1) rmax = min(rmax, c);\n      }\n      c = 0;\n      first = 0;\n    } else c++;\n  }\n\n  dump(rmax);\n\n  // RB\n\n  // vector<modint> dp(n + 1);\n  Seg dp(n + 1);\n  dp.set(0, 1);\n\n  modint ans;\n\n  for(int i = 0; i <= n - 1; i+=2) {\n    dp.act(i + 2, min<int>(n - 1, i + 1 + rmax) + 1, dp.get(i));\n    if(i + 1 + rmax >= n) {\n      int f = n - i - 1;\n      dump(i, dp.get(i), f);\n      ans += dp.get(i) * (f + 1);\n    }\n  }\n  cout << ans << endl;\n  dp.dum();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <bitset>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#define ll long long\n#define N 200100\n#define M 1000000007\nusing namespace std;\n\nll n,m,mx,ans,dp[N],qz[N];\nchar str[N];\n\ninline void Add(ll &u,ll v){u=(u+v)%M;}\nint main()\n{\n\tll i,j,t;\n\tcin>>n>>m;\n\tscanf(\"%s\",str+1);\n\tfor(i=1;i<=m;i++) if(str[i]!=str[1]) break;\n\tmx=i-1;\n\tif(mx==m)\n\t{\n\t\tdp[0]=qz[0]=ans=1;\n\t\tfor(i=0;i<=n;i++)\n\t\t{\n\t\t\tif(i>=2) dp[i]=qz[i-2];\n\t\t\tqz[i]=(qz[i-1]+dp[i])%M;\n\t\t\tif(n-i>=2) Add(ans,dp[i]*(n-i)%M);\n\t\t}\n\t\tcout<<ans;\n\t\treturn 0;\n\t}\n\tif(n&1)\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tif(mx%2==0) mx++;\n\tfor(t=0;i<=m;i++)\n\t{\n\t\tif(str[i]==str[1]) t++;\n\t\telse\n\t\t{\n\t\t\tif(t&1) mx=min(mx,t);\n\t\t\tt=0;\n\t\t}\n\t}\n\tn/=2,mx=(mx+1)/2;\n\tdp[0]=qz[0]=1;\n\tfor(i=0;i<=n;i++)\n\t{\n\t\tif(i)\n\t\t{\n\t\t\tdp[i]=(M+qz[i-1]-(i-mx-1>=0?qz[i-mx-1]:0))%M;\n\t\t\tqz[i]=(qz[i-1]+dp[i])%M;\n\t\t}\n\t\tif(n-i<=mx) Add(ans,(n-i)*dp[i]*2%M);\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+10;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    ans = dp[n+1];\n    for(ll i = 1;i<=lim;i+=2)\n    {\n        ans += (i*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    int mn = 1e9;\n    if (vc[0]%2==0)\n        mn = vc[0]+1;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nint fact[1111111];\nint inv[1111111];\n\nint mpow(int n,int m){\n\tint ret=1;\n\twhile(m){\n\t\tif(m&1)ret=ret*n%mod;\n\t\tn=n*n%mod;\n\t\tm>>=1;\n\t}\n\treturn ret;\n}\n\nint binom(int n,int k){\n\treturn fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\ninline void add(int &a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\nint N,M;\nstring S;\n\nsigned main(){\n\tfact[0]=1;\n\tfor(int i=1;i<1111111;i++)fact[i]=fact[i-1]*i%mod;\n\tinv[1111111-1]=mpow(fact[1111111],mod-2);\n\tfor(int i=1111111-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n\n\n\tcin>>N>>M;\n\tcin>>S;\n\n\tif(S[0]=='B'){\n\t\trep(i,N){\n\t\t\tif(S[i]=='R')S[i]='B';\n\t\t\telse S[i]='R';\n\t\t}\n\t}\n\n\twhile(S.size()&&S.back()=='R')S.pop_back();\n\n\tif(S.size()==0){\n\t\tint ans=1;\n\t\tfor(int i=1;i*2<=M;i++){\n\t\t\tint n=M-i*2;\n\t\t\tadd(ans,binom(n+i-1,i-1));\n\t\t}\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\n\tif(N%2){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\n\n\tassert(0);\n\n\tint ma=1001001001;\n\tint cur=0;\n\twhile(cur<S.size()){\n\t\tint nex=cur;\n\t\twhile(nex<S.size()&&S[cur]==S[nex])nex++;\n\t\tif(S[cur]=='R'){\n\t\t\tint l=nex-cur;\n\t\t\tif(cur==0){\n\t\t\t\tif(l%2)chmin(ma,l);\n\t\t\t\telse chmin(ma,l+1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(l%2)chmin(ma,l);\n\t\t\t}\n\t\t}\n\t\tcur=nex;\n\t}\n\n\tcout<<ma<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\nconst ll MOD = 1e9 + 7;\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\nconst int N = 2e5 + 100;\n\nint n, m;\nstring s;\n\nint gn(int x) {\n\treturn x + 1 - (x % 2);\n}\n\nll dp[N];\nll dp2[N];\n\nvoid solve(int n) {\n\tdp[0] = 1;\n\tdp[1] = 2;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tdp[i] = (dp[i - 1] + dp[i - 2]) % MOD;\n\t}\n\tll ans = dp[n];\n\tif (n >= 4)\n\t\tans = (ans - dp[n - 4] + MOD) % MOD;\n\tif (n == 2)\n\t\tans = 3;\n\tif (n == 3)\n\t\tans = 4;\n\tcout << ans << \"\\n\";\n}\n\nint main() {\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n >> m;\n\tcin >> s;\n\tif (s[0] != 'R') {\n\t\tfor (int i = 0; i < m; ++i)\n\t\t\tif (s[i] == 'R')\n\t\t\t\ts[i] = 'B';\n\t\t\telse\n\t\t\t\ts[i] = 'R';\n\t}\n\twhile (!s.empty() && s.back() == 'R')\n\t\ts.pop_back();\n\tif (s.empty()) {\n\t\tsolve(n);\n\t\treturn 0;\n\t}\n\tint cur = 0;\n\twhile (s[cur] != 'B')\n\t\t++cur;\n\tint l = gn(cur);\n\t++cur;\n\twhile (cur < s.size()) {\n\t\tif (s[cur] == 'B')\n\t\t\t++cur;\n\t\telse {\n\t\t\tint c = 0;\n\t\t\twhile (s[cur] == 'R')\n\t\t\t\t++cur, ++c;\n\t\t\tif (c % 2 == 1)\n\t\t\t\tl = min(l, c);\n\t\t}\n\t}\n\tif (n % 2 == 1) {\n\t\tcout << 0 << \"\\n\";\n\t\treturn 0;\n\t}\n\t++l;\n\tn /= 2;\n\tl /= 2;\n\tdp[0] = 1;\n\tll sum = dp[0];\n\tll sum2 = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tsum2 = (sum2 + sum) % MOD;\n\t\tif (i > l) {\n\t\t\tsum = (sum - dp[i - l - 1] + MOD) % MOD;\n\t\t\tsum2 = (sum2 - dp[i - l - 1] * (l + 1) % MOD + MOD) % MOD;\n\t\t}\n\t\tdp[i] = sum;\n\t\tdp2[i] = sum2;\n\t\tsum = (sum + dp[i]) % MOD;\n\t}\n\tcout << (2 * dp2[n]) % MOD;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1<<19, mod = 1e9 + 7;\nint n, m, pr = 0, dp[maxn], p[maxn][2];\nstring s;\nint corner() {\n\tdp[0] = 2, dp[1] = 1;\n\tfor(int i = 2; i <= n; i++) dp[i] = (dp[i-1] + dp[i-2])%mod;\n\treturn dp[n];\n}\nvoid add(int &a, int b) {\n\ta += b;\n\tif(a >= mod) a -= mod;\n}\nint normal() {\n\tint ans = 0;\n\tfor(int i = 0; i <= n; i++) {\n\t\tif(i) {\n\t\t\tadd(p[i][0], p[i-1][0]);\n\t\t\tadd(p[i][1], p[i-1][1]);\n\t\t}\n\t\tdp[i] = p[i][i&1];\n\t\tif(i == 1) {\n\t\t\tdp[i] = 1;\n\t\t}\n\t\tadd(p[i+2][i&1], dp[i]);\n\t\tadd(p[i+pr+2][i&1], mod - dp[i]);\n\t}\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(i + pr < n || ((i+pr)&1) != (n&1)) continue;\n\t\tans = (ans + (n-i+1)*1ll*dp[i])%mod;\n\t}\n\treturn ans;\n}\nbool check(int msk, int f = 0) {\n\tif((msk&1) && ((msk>>(n-1))&1)) return 0;\n\tif(msk == 0) return 0;\n\tint prev = -1, streak = 0, i = 0;\n\tif(f) while(!(msk&1)) {\n\t\tmsk = (msk/2);}\n\tfor(; i < n; i++) {\n\t\tint cur = (msk>>i)&1;\n\t\tif(prev == cur) streak++;\n\t\telse {\n\t\t\tif(prev == 1 && streak > 1) return 0;\n\t\t\tif(prev == 0 && (streak > pr || (streak&1) == 0)) return 0;\n\t\t\tstreak = 1;\n\t\t}\n\t\t//cout << i << \" \" << cur << \" \" << streak << '\\n';\n\t\tprev = cur;\n\t}\n\tif(prev == 1 && streak > 1) return 0;\n\t\t\tif(prev == 0 && (streak > pr || (streak&1) == 0)) return 0;\n\t\n\treturn true;\n}\nint brute() {\n\tint ans = 0;\n\tfor(int i = 0; i < 1<<n; i++) {\n\t\tans += check(i, 1);\n\t}\n\treturn ans;\n}\nint main() {\n\tcin >> n >> m >> s;\n\tif(s[0] == 'R')\n\t\tfor(auto &i : s) i ^= 'B'^'R';\n\twhile(pr < m && s[pr] == 'B') pr++;\n\tif(m == pr) return cout << corner(), 0;\n\tcout << s.size() << \" \" << pr << '\\n';\n\tpr += pr%2 == 0;\n\tint cur = 0;\n\tfor(auto &i : s) {\n\t\tif(i == 'B') cur++;\n\t\telse {\n\t\t\tif(cur&1) pr = min(cur, pr);\n\t\t\tcur = 0;\n\t\t}\n\t}\n\tcout << normal();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n        if(dp[i-1] < 0)dp[i-1} %= MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    return res;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i <= m;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define mod 1000000007\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nchar S[200010];\nint f[200010],sf[200010];\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),m=gi(),all=0;\n\tscanf(\"%s\",S+1);\n\tint L=1145141;\n\tfor(int l=1,r;l<=m;l=r+1){\n\t\tr=l;if(S[l]!=S[1])continue;\n\t\twhile(r<m&&S[r+1]==S[r])++r;\n\t\tif(l==1&&r==m)all=1;\n\t\tif((r-l&1)&&r<m)cnk(L,r-l+2);\n\t}\n\tif(all){\n\t\tstatic int f[200010][2];\n\t\tint ans=0;\n\t\tfor(int fir=0;fir<2;++fir){\n\t\t\tmemset(f,0,sizeof f);\n\t\t\tf[1][fir]=1;\n\t\t\tfor(int i=1;i<=n;++i){\n\t\t\t\tinc(f[i+1][0],f[i][1]);\n\t\t\t\tinc(f[i+1][1],f[i][0]);\n\t\t\t\tinc(f[i+1][1],f[i][1]);\n\t\t\t}\n\t\t\tif(fir)inc(ans,f[n][0]);\n\t\t\tinc(ans,f[n][1]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(L&1)++L;\n\tf[1]=sf[1]=1;\n\tfor(int i=2;i<=n;++i)f[i]=(sf[i-2]-(i-L-2<0?0:sf[i-L-2])+mod)%mod,sf[i]=(f[i]+sf[i-2])%mod;\n\tint ans=0;\n\tfor(int i=n-1;n-i<L&&i>=0;i-=2)\n\t\tinc(ans,1ll*(n-i+1)*f[i]%mod);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint mod = 1000000007;\nint sum(int a, int b){\n    if (a+b<0) return a+b+mod;\n    if (a+b >= mod) return a+b-mod;\n    return a+b;\n}\nint mult(int a, int b){\n    return ((ll) a * (ll) b) % (ll) mod;\n}\nmain()\n{\n    //freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if (s[0] == 'B'){\n        for (int i=0; i < s.size(); i++){\n            if (s[i] == 'B') s[i] = 'R';\n            else s[i] = 'B';\n        }\n    }\n    int index = -1;\n    for (int i=0; i < m; i++) if (s[i] == 'B'){\n        index = i;\n        break;\n    }\n    if (index == -1){\n        int dp[n][2][2];\n        for (int i=0; i < n; i++) for (int j=0; j < 2; j++) for (int k=0; k < 2; k++) dp[i][j][k] = 0;\n        dp[0][0][0] = 1, dp[0][1][1] = 1;\n        for (int i=1; i < n; i++){\n            for (int j=0; j < 2; j++) for (int k=0; k < 2; k++) for (int e=0; e < 2; e++){\n                if (j==0 && e==0) continue;\n                dp[i][e][k] = sum(dp[i][e][k], dp[i-1][j][k]);\n            }\n        }\n        int ans = 0;\n        for (int i=0;i<2;i++) for (int j=0;j<2;j++) if (i!=0 || j != 0) ans=sum(ans, dp[n-1][i][j]);\n        cout << ans;\n        return 0;\n    }\n    if (n%2 != 0){\n        cout << 0;\n        return 0;\n    }\n    int mx = n+1;\n    if (index % 2 == 0) mx = min(mx, index+1);\n    else mx = min(mx, index);\n    int cnt = 0;\n    for (int i=index+1; i < m; i++){\n        if (s[i] == 'R') cnt++;\n        else{\n            if (cnt % 2 != 0) mx = min(mx, cnt);\n            cnt = 0;\n        }\n    }\n    int M = (mx+1)/2;\n    //cout << mx << endl;\n    int dp[n/2+1];\n    dp[0] = 1;\n    int ans = 0;\n    int pref[n/2+2];\n    pref[0] = 0;\n    pref[1] = 1;\n    for (int i=1; i <= n/2; i++){\n        if (i < n/2){\n            int brd = max((int) 0, i-M);\n            dp[i] = sum(pref[i], -pref[brd]);\n            pref[i+1] = sum(pref[i], dp[i]);\n        }\n        else{\n            int brd = max((int) 0, i-M);\n            for (int j=i-1; j >= brd; j--){\n                int val = dp[j];\n                int len = 2*(i-j)-1;\n                int shift = len+1;\n                ans = sum(ans, mult(shift, val));\n            }\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200100,mod=1000000007;\ntypedef long long ll;\nint f[N],sum[N],n,m;\nchar s[N];\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>m>>(s+1);\n\tint mn=max(n,m)+1,sz=0,flag=0;\n\tfor(int i=1;i<=m;++i)\t\n\t\tif(s[i]==s[1])++sz;\n\t\telse{\n\t\t\tif(sz&1)mn=min(mn,sz);\n\t\t\telse if(sz)mn=min(mn,sz+1);\n\t\t\tsz=0;flag=1;\n\t\t}\n\tint L=0,R=0;\n\tif(flag){\n\t\tif(n&1){\n\t\t\tcout<<0<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t\tn/=2;L=1;R=min(n,(mn+1)/2);\n\t}else L=2,R=n;\n\tf[0]=sum[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tf[i]=sum[i-L];if(i>R)f[i]=(f[i]-sum[i-R-1]+mod)%mod;\n\t\tsum[i]=(sum[i-1]+f[i])%mod;\n\t}\n\tint ans=0;\n\tfor(int i=L;i<=R;++i)ans=(ans+(ll)i*f[n-i])%mod;\n\tif(flag)ans=ans*2%mod;else ans=(ans+1)%mod;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn = 200111;\nint n, m;\nint cntR=0, cntB=0;\nchar s[maxn];\nint fac[maxn], ifac[maxn];\nll C(int x, int y) {return 1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\nll F(int n, int x)\n{\n\treturn C(n-(x-1), x);\n}\nint dp[maxn];\nint sum[maxn], sum2[maxn];\nint calc(int lim)\n{\n//\tcerr<<\"calc:\"<<lim<<endl;\n\tassert(lim%2==1);\n\tmemset(dp, 0, sizeof(dp));\n\tmemset(sum, 0, sizeof(sum));\n\tmemset(sum2, 0, sizeof(sum2));\n\tdp[0] = 1;\n\tsum[0] = sum[1] = 1;\n\tsum2[0] = 1;\n\tsum2[1] = 0;\n\tfor (int i=2; i<maxn; i++)\n\t{\n\t\tdp[i] = sum2[i-2];\n\t\tif (i-2-lim-1>=0) dp[i] = (dp[i]-sum2[i-2-lim-1]+mod)%mod;\n\t\tsum[i] = (sum[i-1]+dp[i])%mod;\n\t\tsum2[i] = (sum2[i-2]+dp[i])%mod;\n\t}\n\tll ret = lim>=n&&cntB==0;\n\tfor (int i=1; i<=lim+1&&i<=n; i++)\n\t{\n\t\tint l = max(i, n-(lim-(i-1)))-i;\n\t\tint r = (i==1?n-1-i:n-i);\n//\t\tcerr<<l<<\",\"<<r<<endl;\n\t\tret = (ret+(sum[r]-(l==0?0:sum[l-1])+mod))%mod;\n\t}\n\treturn ret;\n}\nint solve()\n{\n//\tcerr<<\"solve:\"<<endl;\n\tvector<int> v;\n\tint lst = 0;\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tif (s[i]=='B')\n\t\t{\n\t\t\tv.PB(lst);\n\t\t\tlst = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlst++;\n\t\t}\n\t}\n\tint lim = 1000000001;\n\tif (v.size()>0) lim = min(lim, v[0]+(v[0]%2==0));\n\tfor (int i=1; i<v.size(); i++) if (v[i]%2==1) lim = min(lim, v[i]);\n\treturn calc(lim);\n}\nint main()\n{\n\t\n\tfac[0] = 1;\n\tfor (int i=1; i<maxn; i++) fac[i] = 1ll*fac[i-1]*i%mod;\n\tfor (int i=0; i<maxn; i++) ifac[i] = qpow(fac[i], mod-2);\n\tgetii(n, m);\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\ts[i] = getreal();\n\t}\n\tif (s[1]=='B') for (int i=1; i<=m; i++) s[i] ^= 'R'^'B';\n\tfor (int i=1; i<=m; i++)\n\t{\n\t\tcntR += s[i]=='R';\n\t\tcntB += s[i]=='B';\n\t}\n\tint ans = 0;\n\tans = (ans+solve())%mod;\n//\tcerr<<\"ans=\"<<ans<<endl;\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nconst ll MOD=1e9+7;\nll powmod(ll a, ll k){\n    ll ap=a, ans=1;\n    while(k){\n        if(k&1){\n            ans*=ap;\n            ans%=MOD;\n        }\n        ap=ap*ap;\n        ap%=MOD;\n        k>>=1;\n    }\n    return ans;\n}\nll inv(ll a){\n\treturn powmod(a, MOD-2);\n}\nll f[200001], invf[200001];\nvoid fac(int n){\n    f[0]=1;\n    for(ll i=1; i<=n; i++) f[i]=f[i-1]*i%MOD;\n    invf[n]=inv(f[n]);\n    for(ll i=n-1; i>=0; i--) invf[i]=invf[i+1]*(i+1)%MOD;\n}\nll comb(int x, int y){\n    if(x<y) return 0;\n    return f[x]*invf[y]%MOD*invf[x-y]%MOD;\n}\nint main()\n{\n    int n, m; cin>>n>>m;\n    string s; cin>>s;\n    if(s[0]=='B'){\n        for(int i=0; i<m; i++){\n            if(s[i]=='B') s[i]='R';\n            else s[i]='B';\n        }\n    }\n    int j=-1;\n    vector<int> v;\n    bool nuo=1;\n    for(int i=0; i<m-1; i++){\n        if(s[i+1]=='B'){\n          nuo=0;\n            v.push_back(i-j);\n            j=i+1;\n        }\n    }\n    if(nuo){\n        ll dp[2][200002]={};\n        dp[0][0]=1;\n        for(int i=1; i<n; i++){\n            dp[1][i]+=dp[0][i-1];\n            dp[0][i]+=(dp[0][i-1]+dp[1][i-1]);\n            dp[0][i]%=MOD;\n            dp[1][i]%=MOD;\n        }\n        ll ans=dp[0][n-1]+dp[1][n-1];\n        fill(dp[0], dp[0]+n+1, 0);\n        fill(dp[1], dp[1]+n+1, 0);\n        dp[1][0]=1;\n        for(int i=1; i<n; i++){\n            dp[1][i]+=dp[0][i-1];\n            dp[0][i]+=(dp[0][i-1]+dp[1][i-1]);\n            dp[0][i]%=MOD;\n            dp[1][i]%=MOD;\n        }\n        ans+=dp[0][n-1];\n        ans%=MOD;\n        cout<<ans<<endl;\n        return 0;\n    }\n    if(n%2==1){\n        cout<<0<<endl;\n        return 0;\n    }\n    int mx=v[0]+1-v[0]%2;\n    for(int i=1; i<v.size(); i++){\n        if(v[i]&1) mx=min(mx, v[i]);\n    }\n    ll dp[200002]={}, sum[200002];\n    dp[0]=1;\n    sum[0]=1;\n    for(int i=1; i<=n; i++){\n        if(i&1) sum[i]=sum[i-1];\n        else{\n            if(i-mx-3>=0) dp[i]=(sum[i-2]-sum[i-mx-3]+MOD)%MOD;\n            else dp[i]=sum[i-2];\n            sum[i]=(sum[i-1]+dp[i])%MOD;\n        }\n    }\n    ll ans=0;\n    for(int i=1; i<=min(mx, n-1); i+=2){\n        ans+=(ll)(i+1)*dp[n-i-1];\n        ans%=MOD;\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PI 3.14159265358979323846264338327950288419\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint n, m;\nint col[200005];\n\nint expo(int a, int b){\n\tint c = 1, d = a;\n\twhile(b){\n\t\tif(b & 1){\n\t\t\tc = 1LL * c * d % mod;\n\t\t}\n\t\td = 1LL * d * d % mod;\n\t\tb >>= 1;\n\t}\n\treturn c;\n}\n\nint inv(int x){\n\treturn expo(x, mod - 2);\n}\n\nint calc(int n){\n\tif(n == 2){\n\t\treturn 2;\n\t}\n\t\n\tint fib[200005];\n\tfib[1] = fib[2] = 1;\n\tfor(int i = 3; i <= n + 1; i++){\n\t\tfib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t}\n\t\n\t// force first one to be 1, last one to be 0: fib[N - 1]\n\t// force first one to be 0: fib[N + 1]\n\treturn (fib[n - 1] + fib[n + 1]) % mod;\n}\n\nint calc2(int n, int ub){\n\tassert(ub & 1);\n\t\n\t// want a bunch of numbers, in [2, ub], to sum to n\n\t\n\tub++;\n\tub = min(ub, n); // coz it can actually be HUGE\n\t\n\tint dp[200005]; // dp[i]: number of possible sums, that sum to i\n\tlong long cumu[200005];\n\t\n\tdp[0] = 1;\n\tcumu[0] = 1;\n\t\n\tfor(int i = 2; i <= n; i += 2){\n\t\t// sum from dp[l_index .. i - 2].. oh, only the even ones!\n\t\tint l_index = i - ub;\n\t//\tprintf(\"%d: sum %d..%d\\n\", i, l_index, r_index);\n\t\tdp[i] = cumu[i - 2];\n\t\t\n\t\tif(l_index > 0){\n\t\t\tdp[i] -= cumu[l_index - 2];\n\t\t\tif(dp[i] < 0){\n\t\t\t\tdp[i] += mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcumu[i] = (cumu[i - 2] + dp[i]) % mod;\n\t}\n\t\n\tint ret = 0;\n\t\n\tfor(int space = 0; space < ub; space++){\n\t\t// last 1 is at (n - space), leaving _ space at the end\n\t\t// where can the first 1 be?\n\t\tint left_pos = max(1, 2 - space);\n\t\tint right_pos = ub - space;\n\t\tint most_remain = (n - space) - left_pos;\n\t\tint least_remain = n - ub;\n\t\t\n\t\tif(most_remain & 1) most_remain--;\n\t\t\n\t\tint combin = cumu[most_remain];\n\t\tif(least_remain > 0){\n\t\t\tcombin = (combin - cumu[least_remain - 2] + mod) % mod;\n\t\t}\n\t\tret = (ret + combin) % mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= m; i++){\n\t\tchar c;\n\t\tscanf(\" %c\", &c);\n\t\tcol[i] = (c == 'B');\n\t}\n\tif(col[1] != 0){\n\t\t// WLOG first one is 0\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tcol[i] = 1 - col[i];\n\t\t}\n\t}\n\t\n\tbool monochrome = true;\n\tfor(int i = 2; i <= m; i++){\n\t\tif(col[i]){\n\t\t\tmonochrome = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(monochrome){\n\t\t// ok as long as 1s are not adjacent\n\t\tprintf(\"%d\\n\", calc(n));\n\t\treturn 0;\n\t}else{\n\t\t// 00...010..010..0\n\t\t// each block of 0 is of add length\n\t\t// so, n odd -> definitely no solution\n\t\t// more conditions depending on specifics of col[]\n\t\tif(n % 2 == 1){\n\t\t \tprintf(\"0\\n\");\n\t\t \treturn 0;\n\t\t}\n\t\tint first_run = 0, subseq_run = n;\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tint len = 0;\n\t\t\twhile(i + len <= m && col[i + len] == 0){\n\t\t \t\tlen++;\n\t\t \t}\n\t\t \tif(first_run == 0){\n\t\t \t\tfirst_run = len;\n\t\t \t}else if(len & 1){\n\t\t \t\tsubseq_run = min(subseq_run, len);\n\t\t \t}\n\t\t \ti += len;\n\t\t}\n\t\tint ub = first_run + (first_run % 2 == 0);\n\t\tub = min(ub, subseq_run);\n\t\tprintf(\"%d\\n\", calc2(n, ub));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ΔAGC033E\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 222222;\nconst int MO = 1e9+7;\nchar ch[N];\nint n,m,ans,f[N],s[N];\nint main()\n{\n\tint i,x,y,o;\n\tscanf(\"%d%d%s\",&n,&m,ch+1);\n\tfor(i=1;i<=n;i=i+1)\n\t\tif(ch[i]!=ch[1])\n\t\t\tbreak;\n\to=n;\n\tif(i<=n){\n\t\to=i-1;\n\t\tif(o%2==0)\n\t\t\to++;\n\t\tx=1,y=0;\n\t\tfor(i=i+1;i<=n;i=i+1){\n\t\t\tif(ch[i]==ch[i-1])\n\t\t\t\tx++;\n\t\t\telse{\n\t\t\t\tif(y&&x%2==1)\n\t\t\t\t\to=min(o,x);\n\t\t\t\ty^=1;\n\t\t\t\tx=1;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tf[1]=1;\n\t\ts[1]=1;\n\t\tfor(i=2;i<=n;i=i+1){\n\t\t\tf[i]=s[i-2];\n\t\t\ts[i]=(s[i-1]+f[i])%MO;\n\t\t}\n\t\tx=1;\n\t\tfor(i=1;i<n;i=i+1)\n\t\t\tx+=(LL)f[i]*(n-i+1)%MO,x%=MO;\n\t\tcout<<x;\n\t\treturn 0;\n\t}\n\tif(n&1){\n\t\tcout<<0;\n\t\treturn 0;\n\t}\n\to++;\n\to/=2;\n\tn/=2;\n\tf[1]=1;\n\ts[1]=1;\n\tfor(i=2;i<=n;i=i+1){\n\t\tx=i-o-1;\n\t\tif(x<0)\n\t\t\ty=0;\n\t\telse\n\t\t\ty=s[x];\n\t\tf[i]=(s[i-1]-y+MO)%MO;\n\t\ts[i]=(s[i-1]+f[i])%MO;\n\t}\n\tx=0;\n\tfor(i=n-o+1;i<=n;i=i+1)\n\t\tx+=(LL)f[i]*((n-i+1)*2)%MO,x%=MO;\n\tcout<<x;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll dp[202020][2][2];\nll mo=1000000007;\n\nll dp2[202020];\nll dps[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\tif(S[0]=='B') {\n\t\tFORR(c,S) c='R'+'B'-c;\n\t}\n\tif(count(ALL(S),'B')==0) {\n\t\tdp[0][0][0]=dp[0][1][1]=1;\n\t\tfor(i=1;i<N;i++) {\n\t\t\t(dp[i][0][0]=dp[i-1][0][0]+dp[i-1][0][1])%=mo;\n\t\t\t(dp[i][0][1]=dp[i-1][0][0])%=mo;\n\t\t\t(dp[i][1][0]=dp[i-1][1][0]+dp[i-1][1][1])%=mo;\n\t\t\t(dp[i][1][1]=dp[i-1][1][0])%=mo;\n\t\t}\n\t\tcout<<(dp[N-1][0][0]+dp[N-1][0][1]+dp[N-1][1][0])%mo<<endl;\n\t\treturn;\n\t}\n\t\n\tvector<int> V;\n\tV.push_back(0);\n\tFORR(c,S) {\n\t\tif(c=='R') V.back()++;\n\t\telse V.push_back(0);\n\t}\n\tV.pop_back();\n\t\n\tint L=1<<20;\n\tif(V[0]%2==0) V[0]++;\n\tFORR(v,V) if(v%2) L=min(L,v);\n\t\n\t\n\tdp2[0]=dps[0]=1;\n\tfor(i=2;i<=N;i+=2) {\n\t\tdp2[i]=dps[i-2];\n\t\tif(i-(L+1)>0) (dp2[i]+=mo-dps[i-(L+1)-2])%=mo;\n\t\tdps[i]=(dps[i-2]+dp2[i])%mo;\n\t\t//cout<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=min(L,N-1);i+=2) {\n\t\t//cout<<i<<\" \"<<(i+1)<<\"*\"<<dp2[N-(i+1)]<<endl;\n\t\t(ret+=(i+1)*dp2[N-(i+1)])%=mo;\n\t}\n\tcout<<ret%mo<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=a*b%mod\n\nll n,m;\nstring s;\nint main(){\n    cin>>n>>m>>s;\n    if(s[0]=='R'){\n\tfor(int i=0;i<n;i++){\n\t    if(s[i]=='R')s[i]='B';\n\t    else s[i]='R';\n\t}\n    }\n    bool th=0;\n    ll cnt=0,mi=1e17;\n    bool fi=1; ll lead;\n    for(int i=0;i<n;i++){\n\tif(s[i]=='R'){\n\t    if(fi)lead=cnt; fi=0;\n\t    th=1;\n\t    if(cnt%2==1)chmin(mi,cnt);\n\t    cnt=0;\n\t}\n\telse cnt++;\n    }\n    if(th==0){\n\tll f[200010];\n\tf[0]=f[1]=1;\n\tfor(int i=2;i<n;i++){\n\t    f[i]=f[i-1]+f[i-2];\n\t}\n\tll ans=(f[n-2]*2+f[n-1])%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n    }\n    if(n%2==1){\n\tcout<<0<<endl;\n\treturn 0;\n    }return 0;\n    if(lead%2==0)lead++;\n    chmin(mi,lead);\n    mi=(mi+1)/2;\n    chmin(mi,n/2);\n    ll f[200010],rui[200010];\n    f[0]=rui[0]=0;\n    for(ll i=1;i<=mi;i++){\n\tf[i]=i;\n\trui[i]=(rui[i-1]+i)%mod;\n    }\n    for(int i=1;i<n/2;i++){\n\tmad(f[i],rui[i-1]);\n\tif(i-mi-1>=0)mad(f[i],-rui[i-mi-1]);\n\trui[i]=(rui[i-1]+f[i])%mod;\n    }\n    ll ans=0;\n    for(int i=1;i<=mi;i++)mad(ans,f[n/2-i]);\n    //cout<<mi<<endl;\n    //for(int i=0;i<n/2;i++)cout<<i<<\":\"<<f[i]<<endl;\n    ans=ans*2%mod;\n    if(ans<0)ans+=mod;\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Fail puts(\"NO\"),exit(0);\n#define eps 1e-10\n#define maxn 200010\n#define maxm 100010\n#define inf 1000000007\n#define mod 1000000007\n#define pi acos(-1)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int>pii;\ntypedef bitset<maxn> bit;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,m;\nchar s[maxn];\nint a[maxn];\nbool check()\n{\n    for(int i=1;i<=m;i++)  if(a[i])  return false;\n    return true;\n}\nint g[maxn],f[maxn],sum[maxn][2];\nint L=inf;\nint main()\n{\n    n=read();m=read();\n    scanf(\"%s\",s+1);\n    for(int i=1;i<=m;i++)  a[i]=(s[i]=='B');\n    if(a[1])  for(int i=1;i<=m;i++)  a[i]^=1;\n    if(check())\n    {\n        if(n==2) return puts(\"3\"),0;\n        g[0]=1;g[1]=2;\n        for(int i=2;i<=n;i++)  g[i]=(g[i-1]+g[i-2])%mod;\n        return printf(\"%d\\n\",(g[n-1]+g[n-3])%mod),0;\n    }\n    for(int i=1;i<=m;i++)\n    {\n        if(a[i])  continue;\n        int R=i;\n        while(R<m&&!a[R+1])  R++;\n        if(R==m)  break;\n        if(i==1)  L=min(L,R-i+2);\n        if((R-i+1)&1)  L=min(L,R-i+1);\n        i=R;\n    }\n    f[0]=1;sum[0][0]=1;\n    for(int i=1;i<=n;i++)\n    {\n        if(i>=2)\n        {\n            f[i]=sum[i-2][i&1];\n            if(i>=L+2)  f[i]=(f[i]-sum[i-L-2][i&1]+mod)%mod;\n        }\n        sum[i][0]=sum[i-1][0];sum[i][1]=sum[i-1][1];\n        sum[i][i&1]=(sum[i][i&1]+f[i])%mod;\n    }\n    int ans=f[n];\n    for(int i=1;i<=L;i+=2)  ans=(ans+1ll*i*f[n-i-1])%mod;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (200010)\n#define P (1000000007)\n#define M ()\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c){\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nint n,m,f[N]; char s[N];\nvoid spj(){\n\tint f[N][2];\n\tfor(int i=1;i<=n;i++)if(s[i]=='R')return;\n\tint ans=0; f[1][0]=0,f[1][1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tf[i][0]=f[i-1][1];\n\t\tf[i][1]=(f[i-1][0]+f[i-1][1])%P;\n\t}\n\t(ans+=(f[n][0]+f[n][1])%P)%=P;\n\tf[1][0]=1,f[1][1]=0,f[2][0]=0,f[2][1]=1;\n\tfor(int i=3;i<=n;i++){\n\t\tf[i][0]=f[i-1][1];\n\t\tf[i][1]=(f[i-1][0]+f[i-1][1])%P;\n\t}\n\t(ans+=f[n][1])%=P;\n\tprintf(\"%d\\n\",ans);\n\texit(0);\n}\nint main(){\n\tread(n),read(m);\n\tfor(int i=1;i<=m;i++)readc(s[i]);\n\tif(s[1]=='R'){for(int i=1;i<=m;i++)s[i]^='R'^'B';}\n\tspj(); int lst=m,lim=n,cnt=0; while(s[lst]=='B')lst--;\n\tfor(int i=lst;~i;i--)\n\tif(!i||s[i]=='R'){\n\t\tif(cnt&1)lim=min(lim,cnt+1);\n\t\telse if((!i)&&cnt)lim=min(lim,cnt+2);\n\t\tcnt=0;\n\t}\n\telse cnt++;\n\tf[0]=f[2]=1;\n\tfor(int i=4;i<=n;i++){\n\t\tf[i]=1ll*f[i-2]*2%P;\n\t\tif(i-2>=lim)f[i]=(f[i]-f[i-lim-2]+P)%P;\n\t}\n\tint ans=0;\n\tfor(int i=2;i<=lim;i+=2)\n\t(ans+=1ll*f[n-i]*i%P)%=P;\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=200000 +117;\nconst int MM=200000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nchar s[NN]={};\nbool a[NN]={};\nLL f[NN]={};\nconst int mod=1e9+7;\nvoid simple(int n){\n\tf[0]=1;\n\tf[1]=1;\n\tfor(int i=2;i<=n;++i){\n\t\tf[i]=(f[i-1]+f[i-2])%mod;\n\t}\n\tLL ans=1+f[n-2];\n\tfor(int i=2;i<=n;++i){\n\t\tans+=f[n-i];\n\t\tans%=mod;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\nvoid solve(int n,int lim){\n\tif(n%2!=0){\n\t\tprintf(\"0\\n\");\n\t\treturn ;\n\t}\n\tn/=2;\n\tlim=(lim+1)/2;\n\tf[0]=1;\n\tLL ans=0;\n\tfor(int i=1;i<=n;++i){\n\t\tf[i]=2*f[i-1];\n\t\tif(i-lim-1>=0)f[i]-=f[i-lim-1];\n\t\tf[i]%=mod;\n\t}\n\tfor(int i=1;i<=min(n,lim);++i){\n\t\tans+=2*i*(f[n-i]-f[n-i-1]);\n\t\tans%=mod;\n\t}\n\tans=(ans+mod)%mod;\n\tprintf(\"%lld\\n\",ans);\n}\nint main(){\n\t//open();\n\tn=read();\n\tm=read();\n\tscanf(\"%s\",s+1);\n\tbool same=1;\n\tfor(int i=1;i<=m;++i){\n\t\ta[i]=(s[i]==s[1]);\n\t\tif(!a[i])same=0;\n\t}\n\tint lim=0;\n\tif(same){\n\t\tsimple(n);\n\t}\n\telse{\n\t\tint pos=1;\n\t\tint cnt=0;\n\t\tbool first=0;\n\t\tint lim=0;\n\t\tfor(pos=1;pos<=m;++pos){\n\t\t\tif(a[pos])++cnt;\n\t\t\telse{\n\t\t\t\tif(!first){\n\t\t\t\t\tfirst=1;\n\t\t\t\t\tlim=cnt+1-(cnt&1);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(cnt&1)lim=min(lim,cnt); \n\t\t\t\t}\n\t\t\t\tcnt=0;\n\t\t\t}\n\t\t}\n\t\tsolve(n,lim);\n\t}\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n;\nint m;\nstring s;\nint mn = INF;\nll ans ;\nll dp[200005][2][2];\n\nstruct RMQ{\n\t#define ss (1<<19)\n\tll seg[ss];\n\tvoid update(int k,ll a){\n\t\tk+=ss/2-1; seg[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tseg[k]=(seg[k*2+1]+seg[k*2+2])%mod;\n\t\t}\n\t}\n\tll query(int a,int b,int k,int l,int r){\n\t\tif(r<a || b<l) return 0;\n\t\tif(a<=l && r<=b) return seg[k];\n\t\telse{\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2+1,r);\n\t\t\treturn (vl+vr)%mod;\n\t\t}\n\t}\n}rmq[2];\n\nint main(){\n\tcin>>n>>m>>s;\n    \tif(s[0] == 'B'){\n    \t\trep(i,m){\n    \t\t\tif(s[i] == 'B') s[i] = 'R';\n    \t\t\telse s[i] = 'B';\n    \t\t}\n    \t}\n\t\tint cur = 0;\n\t\tchar ch;\n\t\tbool beg = 0;\n\t\tint C = 0;\n\t\trep(i,m){\n\t\t\tif(i == 0){\n\t\t\t\tch = s[i];\n\t\t\t\tcur = 1;\n\t\t\t}\n\t\t\telse if(ch != s[i]){\n\t\t\t\tif(ch == 'R'){\n\t\t\t\t\tif(cur%2 == 1) mn = min(mn,cur);\n\t\t\t\t\telse if(!beg) mn = min(mn,cur+1);\n\t\t\t\t\tbeg = 1; \n\t\t\t\t}\n\t\t\t\t\tch = s[i];\n\t\t\t\t\tcur = 1; C++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse cur++;\n\t\t}\n\t\t\t\tif(ch == 'R'){\n\t\t\t\t\tif(cur%2 == 1) mn = min(mn,cur);\n\t\t\t\t\telse if(!beg) mn = min(mn,cur+1);\n\t\t\t\t\tbeg = 1; \n\t\t\t\t}\n\t\t\t\tC++;\n\t\tif(C == 1){\n\t\t    //assert(mn == m);\n\t\t\t//BBが存在しなければOK\n\t\t\tdp[0][0][0] = dp[0][1][1] = 1;\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\trep(x,2){\n\t\t\t\t\tdp[i+1][0][x] += dp[i][0][x];\n\t\t\t\t\tdp[i+1][1][x] += dp[i][0][x];\n\t\t\t\t\tdp[i+1][0][x] += dp[i][1][x];\n\t\t\t\t\tdp[i+1][0][x] %= mod;\n\t\t\t\t\tdp[i+1][1][x] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<((dp[n-1][0][0]+dp[n-1][0][1]+dp[n-1][1][0])%mod+mod)%mod<<endl;\n\t\t}\n\t\telse{\n\t\t\tif(n%2 == 1){\n\t\t\t\tputs(\"0\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tdp[0][0][0] = 1;\n\t\t\trmq[0].update(0,1);\n\t\t\tfor(int i=2;i<n;i+=2){\n\t\t\t\tdp[i][0][0] = rmq[i%2].query(max(0,i-mn-1),i,0,0,(1<<18)-1);\n\t\t\t\trmq[i%2].update(i,dp[i][0][0]);\n\t\t\t}\n\t\t\tll ans = 0;\n\t\t\tfor(int m=1;m<=n;m++){\n\t\t\t\tif(m-1 > mn) continue;\n\t\t\t\tif((m-1)%2 == 0) continue;\n\t\t\t\tans += dp[n-m][0][0] * 1LL * m % mod;\n\t\t\t}\n\t\t\tcout << (ans%mod+mod)%mod << endl;\n\t\t\n\t\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\n\n/// --- Modulo Integer {{{ ///\n#include <ostream>\ntemplate < long long mod = static_cast< long long >(1e9 + 7) >\nstruct ModuloInteger {\n  static_assert(mod > 0, \"mod must be positive\");\n  static_assert(mod <= 3037000499, \"mod is too big\");\n  using integer = long long;\n  static ModuloInteger unused;\n  // math {{{\n  static inline integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  static inline integer modpow(integer a, long long b) {\n    if(b < 0) b = -b, a = modinv(a);\n    integer r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  integer val;\n  constexpr ModuloInteger() : val(0) {}\n  constexpr ModuloInteger(integer t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\nprivate:\n  // strict constructor\n  constexpr ModuloInteger(integer t, int) : val(t) {}\n\npublic:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // operator bool() { return bool(val); }\n  // ModuloInteger <arithmetic-operator>[=] ModuloInteger {{{\n  ModuloInteger operator+(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModuloInteger operator-(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModuloInteger operator*(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModuloInteger operator/(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModuloInteger &operator+=(ModuloInteger const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModuloInteger &operator-=(ModuloInteger const &rhs) { return *this += -rhs; }\n  ModuloInteger &operator*=(ModuloInteger const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModuloInteger &operator/=(ModuloInteger const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModuloInteger operator++(int) {\n    ModuloInteger tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModuloInteger operator--(int) {\n    ModuloInteger tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModuloInteger &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModuloInteger &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModuloInteger operator-() const { return ModuloInteger(val == 0 ? 0 : mod - val, 0); }\n  // ModuloInteger <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModuloInteger operator+(T const &rhs) const {\n      return ModuloInteger(val + rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator-(T const &rhs) const {\n      return ModuloInteger(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator*(T const &rhs) const {\n      return ModuloInteger(val * (rhs % mod));\n    }\n  template < typename T >\n    ModuloInteger operator/(T const &rhs) const {\n      return ModuloInteger(val * modinv(rhs));\n    }\n  template < typename T >\n    ModuloInteger &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator/=(T const &rhs) {\n      val = val * modinv(rhs) % mod;\n      return *this;\n    }\n  // }}}\n  ModuloInteger inv() const { return ModuloInteger(modinv(val), 0); }\n  ModuloInteger operator~() const { return inv(); }\n  friend std::ostream &operator<<(std::ostream &os, ModuloInteger const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // equality operator {{{\n  ModuloInteger operator==(const ModuloInteger &a) const { return val == a.val; }\n  ModuloInteger operator!=(const ModuloInteger &a) const { return val != a.val; }\n  ModuloInteger operator==(const integer &a) const { return val == ModuloInteger(a); }\n  ModuloInteger operator!=(const integer &a) const { return val != ModuloInteger(a); }\n  // }}}\n  // T <arithmetic-operator> ModuloInteger {{{\n  friend constexpr ModuloInteger operator+(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod + mv.val);\n  }\n  friend constexpr ModuloInteger operator-(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod - mv.val);\n  }\n  friend constexpr ModuloInteger operator*(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModuloInteger operator/(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModuloInteger operator^(integer x) const { return pow(*this, x); }\n  ModuloInteger &operator^=(integer x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModuloInteger pow(ModuloInteger x, integer y) {\n    return ModuloInteger(modpow(x.val, y), 0);\n  }\n  // }}}\n};\ntemplate < long long mod >\nModuloInteger< mod > ModuloInteger< mod >::unused(mod, 0);\n/// }}}--- ///\n\nusing modint = ModuloInteger<>;\n\n\n// LazySegmentTree( size [, initial] )\n// LazySegmentTree( <data> )\n/// --- LazySegmentTree {{{ ///\n#include <cassert>\n#include <initializer_list>\n#include <iostream>\n#include <vector>\ntemplate < class M_act >\nstruct LazySegmentTree {\npublic:\n  using Monoid = typename M_act::Monoid;\n  using X = typename Monoid::T;\n  using M = typename M_act::M;\n\nprivate:\n  size_t n;\n  int h;\n  vector< X > data;\n  vector< M > lazy;\n  vector< size_t > nodeLength;\n  // call before use data[i]\n  void eval(size_t i) {\n    if(lazy[i] == M_act::identity()) return;\n    data[i] = M_act::actInto(lazy[i], nodeLength[i], data[i]);\n    if(i < n) {\n      lazy[i * 2] = M_act::op(lazy[i], lazy[i * 2]);\n      lazy[i * 2 + 1] = M_act::op(lazy[i], lazy[i * 2 + 1]);\n    }\n    lazy[i] = M_act::identity();\n  }\n  // call before use seg[i] = data[i + n]\n  void evalDown(size_t i) {\n    i += n;\n    for(int j = h - 1; j >= 0; j--) eval(i >> j);\n  }\n  // call after touch seg[i] = data[i + n]\n  void propUp(size_t i) {\n    i += n;\n    while(i >>= 1)\n      eval(i * 2), eval(i * 2 + 1), data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n  }\n\npublic:\n  LazySegmentTree() : n(0) {}\n  LazySegmentTree(size_t n, X initial = Monoid::identity()) : n(n) {\n    if(n > 0) {\n      h = 1;\n      while(1u << h < n) h++;\n      data.resize(2 * n, initial);\n      lazy.resize(2 * n, M_act::identity());\n      nodeLength.resize(2 * n, 1);\n      for(size_t i = n - 1; i > 0; i--) // fill from deep\n        data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]),\n          nodeLength[i] = nodeLength[i * 2] + nodeLength[i * 2 + 1];\n    }\n  }\n  template < class InputIter, class = typename iterator_traits< InputIter >::value_type >\n    LazySegmentTree(InputIter first, InputIter last)\n    : LazySegmentTree(distance(first, last)) {\n      if(n > 0) {\n        copy(first, last, begin(data) + n);\n        for(size_t i = n - 1; i > 0; i--) // fill from deep\n          data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n      }\n    }\n  LazySegmentTree(vector< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  LazySegmentTree(initializer_list< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  void act(int l, int r, const M &m) {\n    if(l < 0) l = 0;\n    if(l >= r) return;\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    int tl = l, tr = r;\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), lazy[l] = m, eval(l), l++;\n      if(r & 1) --r, eval(r), lazy[r] = m, eval(r);\n    }\n    propUp(tl);\n    propUp(tr - 1);\n  }\n  void set(size_t i, const X &x) {\n    assert(i < n);\n    evalDown(i);\n    data[i + n] = x;\n    propUp(i);\n  }\n  X get(size_t i) {\n    assert(i < n);\n    evalDown(i);\n    return data[i + n];\n  }\n  X fold(int l, int r) {\n    if(l < 0) l = 0;\n    if(l >= r) return Monoid::identity();\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    X tmpL = Monoid::identity(), tmpR = Monoid::identity();\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), tmpL = Monoid::op(tmpL, data[l]), l++;\n      if(r & 1) --r, eval(r), tmpR = Monoid::op(data[r], tmpR);\n    }\n    return Monoid::op(tmpL, tmpR);\n  }\n  int size() { return n; }\n  inline void dum(int r = -1) {\n#ifdef DEBUG\n    if(r < 0) r = n;\n    DEBUG_OUT << \"{\";\n    for(int i = 0; i < min(r, (int) n); i++) DEBUG_OUT << (i ? \", \" : \"\") << get(i);\n    DEBUG_OUT << \"}\" << endl;\n#endif\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid examples {{{ ///\nconstexpr long long inf_monoid = 1e18 + 100;\n#include <algorithm>\nstruct Nothing {\n  using T = char;\n  using Monoid = Nothing;\n  using M = T;\n  static constexpr T op(const T &, const T &) { return T(); }\n  static constexpr T identity() { return T(); }\n  template < class X >\n    static constexpr X actInto(const M &, long long, const X &x) {\n      return x;\n    }\n};\n\ntemplate < class U = long long >\nstruct RangeMin {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::min< T >(a, b); }\n  static constexpr T identity() { return T(inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeMax {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::max< T >(a, b); }\n  static constexpr T identity() { return T(-inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeSum {\n  using T = U;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return T(0); }\n};\n\ntemplate < class U >\nstruct RangeProd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a * b; }\n  static constexpr T identity() { return T(1); }\n};\n\ntemplate < class U = long long >\nstruct RangeOr {\n  using T = U;\n  static T op(const T &a, const T &b) { return a | b; }\n  static constexpr T identity() { return T(0); }\n};\n\n#include <bitset>\n\ntemplate < class U = long long >\nstruct RangeAnd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return T(-1); }\n};\n\ntemplate < size_t N >\nstruct RangeAnd< std::bitset< N > > {\n  using T = std::bitset< N >;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return std::bitset< N >().set(); }\n};\n\n/// }}}--- ///\n\n/// --- M_act examples {{{ ///\ntemplate < class U = long long, class V = U >\nstruct RangeMinAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMin< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMax< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMinSet {\n  using M = U;\n  using Monoid = RangeMin< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxSet {\n  using M = U;\n  using Monoid = RangeMax< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long n, const X &x) { return m * n + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long n, const X &x) {\n    return m == identity() ? x : m * n;\n  }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdMul {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M mpow(M a, long long b) {\n    X r(1);\n    while(b) {\n      if(b & 1) r = r * a;\n      a = a * a;\n      b >>= 1;\n    }\n    return r;\n  }\n  static M op(const M &a, const M &b) { return a * b; }\n  static constexpr M identity() { return M(1); }\n  static X actInto(const M &m, long long n, const X &x) { return x * mpow(m, n); }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return V::unused; }\n  static X actInto(const M &m, long long n, const X &) {\n    if(m == identity()) return;\n    return RangeProdMul< U, V >::mpow(m, n);\n  }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeOr2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeOr< U >;\n  static M op(const M &a, const M &b) { return a | b; }\n  static constexpr M identity() { return M(0); }\n  static X actInto(const M &m, long long, const X &x) { return m | x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeAnd2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return M(-1); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n\ntemplate < class U, size_t N >\nstruct RangeAnd2< U, std::bitset< N > > {\n  using X = U;\n  using M = std::bitset< N >;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return std::bitset< N >().set(); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n/// }}}--- ///\n\nusing Seg = LazySegmentTree< RangeSumAdd<modint> >;\n\n\n// NOTE : use H with larger N\n/// --- Modulo Factorial {{{ ///\n#include <cassert>\n#include <cstddef>\ntemplate < std::size_t N, int mod = static_cast< int >(1e9 + 7) >\nstruct Factorial {\n  using integer = long long;\n  constexpr integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d = 0;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  constexpr integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  int arr[N + 1], inv[N + 1];\n  integer operator[](int i) const { return arr[i]; }\n  Factorial() : arr(), inv() {\n    arr[0] = 1;\n    for(std::size_t i = 1; i <= N; i++) {\n      arr[i] = (integer) i * arr[i - 1] % mod;\n    }\n    inv[N] = modinv(arr[N]);\n    for(int i = N - 1; i >= 0; i--) {\n      inv[i] = (integer)(i + 1) * inv[i + 1] % mod;\n    }\n  }\n  integer C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    assert(n <= N);\n    return (integer) arr[n] * inv[r] % mod * inv[n - r] % mod;\n  }\n  integer H(int n, int r) const { return C(n + r - 1, r); }\n};\n/// }}}--- ///\n\nconstexpr int mod = 1e9 + 7;\nconst int N = 2e5 + 10;\nFactorial< N * 2, mod > fact;\n\n\n\nint n, m;\nint r, b;\nint rmax;\nstring s;\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n >> m;\n  cin >> s;\n  if(s[0] == 'B') for(auto &e : s) e = e == 'R' ? 'B' : 'R';\n  bool allR = 1;\n  for(auto e : s) allR &= e == 'R';\n\n  if(allR) {\n    dump(\"allR\");\n    modint ans;\n    assert(0);\n    for(int B = 0; B <= n; B++) {\n      int R = n - B - B;\n      ans += modint(fact.C(R + B, R));\n      ans += modint(fact.C(R + B - 1, R));\n    }\n    cout << ans << endl;\n    return 0;\n  }\n\n  if(n % 2 == 1) {\n    cout << 0 << endl;\n    dump(\"odd\");\n    return 0;\n  }\n\n  int c = m;\n  bool first = 1;\n  for(int i = 0; i <= m; i++) {\n    if(i == n || s[i] == 'B') {\n      if(c % 2 == 0 && first) rmax = min(rmax, c + 1);\n      if(c % 2 == 1) rmax = min(rmax, c);\n      c = 0;\n      first = 0;\n    } else c++;\n  }\n\n  dump(rmax);\n\n  // RB\n\n  // vector<modint> dp(n + 1);\n  Seg dp(n + 1);\n  dp.set(0, 1);\n\n  modint ans;\n\n  for(int i = 0; i <= n - 1; i+=2) {\n    dp.act(i + 2, min<int>(n - 1, i + 1 + rmax) + 1, dp.get(i));\n    if(i + 1 + rmax >= n) {\n      int f = n - i - 1;\n      if (f >= 1) {\n        dump(i, dp.get(i), f);\n        ans += dp.get(i) * (f + 1);\n      }\n    }\n  }\n  cout << ans << endl;\n  dp.dum();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,inline\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#include<bits/stdc++.h>\n#define ll long long\n#define int ll\nusing namespace std;\nconst int md=1000000007;\nconst int mxn=200005;\nint n,m,mx,ans,dp[mxn],f[mxn];\nchar s[mxn];\ninline void add(int&x,int y){\n\tx+=y;\n\tif(x>=md)x-=md;\n}\nsigned main(){\n\tint i,j,t;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(i=1;i<=m;++i)if(s[i]!=s[1])break;mx=i-1;\n\tif(mx==m){\n\t\tdp[0]=f[i]=ans=1;\n\t\tfor(int i=0;i<n-2;++i){\n\t\t\tif(i>=2)dp[i]=f[i-2];\n\t\t\tf[i]=(f[i-1]+dp[i])%md;\n\t\t\tadd(ans,dp[i]*(n-i)%md);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(n&1)return 0*puts(\"0\");\n\tif(!(mx&1))++mx;\n\tfor(t=0;i<=m;++i){\n\t\tif(s[i]==s[1])++t;\n\t\telse{\n\t\t\tif(t&1)mx=min(mx,t);\n\t\t\tt=0;\n\t\t}\n\t}\n\tn>>=1,mx=mx+1>>1;\n\tdp[0]=f[0]=1;\n\tfor(i=0;i<=n;++i){\n\t\tif(i){\n\t\t\tdp[i]=(md+f[i-1]-(i-mx-1>=0?f[i-mx-1]:0))%md;\n\t\t\tf[i]=(f[i-1]+dp[i])%md;\n\t\t}\n\t\tif(n-i<=mx) add(ans,(n-i)*dp[i]*2%md);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\nusing dd = double;\nusing vdd = std::vector<dd>;\nusing vvdd = std::vector<vdd>;\nusing vvvdd = std::vector<vvdd>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, N-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, N-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S, ll E){ T s=v[S]; REPS(i, S+1, E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = (ll)(1e9 + 7);// 998244353LL;//(ll)(1e9 + 7);\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\n\nll N, M;\nstring S;\n\nvoid solveB(){\n\tmll ans = 0;\n\n\t//先頭がRの時\n\t{\n\t\tvvmll dp(N, vmll(2));\n\t\tdp[0][0] = 1;\n\t\tdp[0][1] = 0;\n\n\t\tREPS(i, 1, N-1){\n\t\t\tdp[i][0] = dp[i-1][0] + dp[i-1][1];\n\t\t\tdp[i][1] = dp[i-1][0];\n\t\t}\n\t\tans += dp[N-1][0] + dp[N-1][1];\n\t}\n\n\t//先頭がBの時\n\t{\n\t\tvvmll dp(N, vmll(2));\n\t\tdp[0][0] = 0;\n\t\tdp[0][1] = 1;\n\n\t\tREPS(i, 1, N-2){\n\t\t\tdp[i][0] = dp[i-1][0] + dp[i-1][1];\n\t\t\tdp[i][1] = dp[i-1][0];\n\t\t}\n\t\tans += dp[N-2][0] + dp[N-2][1];\n\t}\n\tcout << ans << '\\n';\n}\n\n\nvoid solve()\n{\n\tcin >> N >> M >> S;\n\n\tif (S[0] == 'B'){\n\t\tEACH(c, S){\n\t\t\tif (c == 'B') c = 'R';\n\t\t\telse          c = 'B';\n\t\t}\n\t}\n\n\tll renzoku = 0;\n\tll maxRenzoku = 0;\n\tEACH(c, S){\n\t\tif (c == 'R') renzoku++;\n\t\telse{\n\t\t\tchmax(maxRenzoku, renzoku);\n\t\t\trenzoku=0;\n\t\t}\n\t}\n\n\tif (maxRenzoku == 0){\n\t\tsolveB();\n\t\treturn;\n\t}\n\n\t/////\n\n\tif (N%2 == 1){bye(0);}\n\n\tll n = maxRenzoku/2;\n\tif (n == 0){ bye(2); }\n\n\tvmll dp(N/2+1);\n\tvmll sum(N/2+1);\n\n\tdp[1] = 2;\n\tsum[1] = 2;\n\n\tREPS(i, 2, N/2){\n\t\t//dpの計算\n\t\tdp[i] = sum[i-1];\n\t\tif (i <= n+1){ dp[i] += 2*i; }\n\n\t\t//sumの計算\n\t\tif (i <= n+1){sum[i] = sum[i-1] + dp[i];}\n\t\telse         {sum[i] = sum[i-1] + dp[i] - dp[i-n-1];}\n\n\t}\n\tcout << dp[N/2] << '\\n';\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//2019.5.19 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define eps 1e-10\n#define RG register\ninline int read() {\n    res s=0,ch=getchar();\n    while(ch<'0'||ch>'9')ch=getchar();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return s;\n}\ninline LL Read() {\n    RG LL s=0;\n    res ch=getchar();\n    while(ch<'0'||ch>'9')ch=getchar();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return s;\n}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N=2e5+10;\nconst int kcz=1e9+7;\nnamespace MAIN {\n    int n,m,dp[N],p=1,sum[N],ans;\n    char str[N];\n    inline void add(res &x,const res &y){\n        x+=y,x>=kcz?x-=kcz:1;\n    }\n    inline int Add(const res &x,const res &y){\n        return x+y>=kcz?x+y-kcz:x+y;\n    }\n    inline int mul(const res &x,const res &y){\n        return int(1LL*x*y%kcz);\n    }\n    inline void MAIN(){\n        n=read(),m=read(),scanf(\"%s\",str+1);\n        for(;p<=m;p++)if(str[p]!=str[1])break;\n        res o=p;\n        p--,dp[0]=sum[0]=1;\n        if(p==m){\n            ans=1;\n            for(res i=0;i<=n;i++){\n                if(i>=2)dp[i]=sum[i-2];\n                sum[i]=Add(sum[i-1],dp[i]);\n                if(n-i>=2)add(ans,mul(dp[i],n-i));\n            }\n            printf(\"%d\\n\",ans);\n            return;\n        }\n        if(n&1){puts(\"0\");return;}\n        if(p%2==0)p++;\n        for(res t=0,i=o;i<=m;i++)\n            if(str[i]==str[1])t++;\n            else {\n                if(t&1)p=min(p,t);\n                t=0;\n            }\n        n>>=1,p=(p+1)>>1;\n        for(res i=0;i<=n;i++){\n            if(i)dp[i]=Add(sum[i-1],kcz-(i-p>0?sum[i-p-1]:0)),sum[i]=Add(sum[i-1],dp[i]);\n            if(n-i<=p)add(ans,mul(n-i,dp[i]<<1));\n        }\n        printf(\"%d\\n\",ans);\n    }\n}\nint main() {\n//    srand((unsigned)time(NULL));\n//    freopen(\"graph.in\",\"r\",stdin);\n//    freopen(\"graph.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\n#include<cassert>\nusing namespace std;\nusing lint = long long;\nusing ld = long double;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(lint i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nint n, m;\nstring s;\n\nvoid allred() {\n\tlint v1 = 0, v2 = 0;\n\tlint ans = 0;\n\tv1 = 1;\n\tREP(i, n - 1) {\n\t\tlint nv1 = (v1 + v2) % MOD;\n\t\tlint nv2 = v1;\n\t\tv1 = nv1;\n\t\tv2 = nv2;\n\t}\n\tans += (v1 + v2) % MOD;\n\tv1 = 0; v2 = 1;\n\tREP(i, n - 1) {\n\t\tlint nv1 = (v1 + v2) % MOD;\n\t\tlint nv2 = v1;\n\t\tv1 = nv1;\n\t\tv2 = nv2;\n\t}\n\tans += v1;\n\tcout << (ans % MOD + MOD) % MOD << endl;\n\treturn;\n}\n\n\n\nvoid solve(vector<int> suc_red, int omn) {\n\tint th = omn;\n\tif(suc_red[0] % 2 == 0) th = min(th, suc_red[0] + 1);\n\tlint ans = 0;\n\t/*\n\tif((n - 1) % 2 && (n - 1) <= th) {\n\t\tans += n;\n\t}*/\n\tvector<lint> dpr(n), dpb(n);\n\tdpr[0] = 0;\n\tdpb[0] = 1;\n\tqueue<lint> q0;\n\tqueue<lint> q1;\n\tlint sum0 = 1, sum1 = 0;\n\tq0.push(1);\n\tFOR(i, 1, n) {\n\t\tif(i % 2 == 1) {\n\t\t\twhile(!q0.empty() && (int)q0.size() > (th + 1) / 2) {\n\t\t\t\tsum0 -= q0.front(); sum0 %= MOD;\n\t\t\t\tq0.pop();\n\t\t\t}\n\t\t\tdpr[i] = sum0;\n\t\t} else {\n\t\t\twhile(!q1.empty() && (int)q1.size() > (th + 1) / 2) {\n\t\t\t\tsum1 -= q1.front(); sum1 %= MOD;\n\t\t\t\tq1.pop();\n\t\t\t}\n\t\t\tdpr[i] = sum1;\n\t\t}\n\t\tdpb[i] = dpr[i - 1];\n\t\tif(i % 2 == 0) {\n\t\t\tq0.push(dpb[i]);\n\t\t\tsum0 += dpb[i]; sum0 %= MOD;\n\t\t} else {\n\t\t\tq1.push(dpb[i]);\n\t\t\tsum1 += dpb[i]; sum1 %= MOD;\n\t\t}\n\t}\n\tFOR(i, 1, n) {\n\t\tif(i > th) break;\n\t\tif(i % 2 == 0) continue;\n\t\tans += dpb[n - 1 - i] * i;\n\t\tans %= MOD;\n\t}\n\tans += dpr[n - 1]; ans %= MOD;\n\tcout << (ans % MOD + MOD) % MOD << endl;\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> m;\n\tcin >> s;\n\tif(s[0] == 'B') {\n\t\tREP(i, m) {\n\t\t\tif(s[i] == 'B') s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\n\tvector<int> suc_red;\n\tint c = 0;\n\tREP(i, m) {\n\t\tif(s[i] == 'R') c++;\n\t\telse {\n\t\t\tif(c != 0) suc_red.pb(c);\n\t\t\tc = 0;\n\t\t}\n\t}\n\tif(c != 0) suc_red.pb(c);\n\n\tif(suc_red[0] == m) {\n\t\tallred();\n\t\treturn 0;\n\t}\n \tint omn = INF;\n\tint roopmx = (int)suc_red.size();\n\tif(s[m - 1] == 'R') roopmx--;\n\tREP(i, roopmx) {\n\t\tif(suc_red[i] % 2) omn = min(omn, suc_red[i]);\n\t}\n\tsolve(suc_red, omn);\n\treturn 0;\n}\n/* --------------------------------------- */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,a,b) for (int i=(int)(a); i<(int)(b); ++i)\n#define repeq(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define rrep(i,a,b) for (int i=(int)(a)-1; i>=(int)(b); --i)\n#define rrepeq(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\ntemplate<> struct is_plural<string> : true_type{};\n\ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n\nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\ntemplate<uint_fast64_t Modulus = MOD>\nstruct Modint {\n  using u64 = uint_fast64_t;\n  u64 a;\n\n  constexpr Modint(const u64 x = 0) noexcept : a(x % Modulus) {}\n\n  constexpr Modint operator+(const Modint rhs) const noexcept {\n    return Modint(*this) += rhs;\n  }\n  constexpr Modint operator-(const Modint rhs) const noexcept {\n    return Modint(*this) -= rhs;\n  }\n  constexpr Modint operator*(const Modint rhs) const noexcept {\n    return Modint(*this) *= rhs;\n  }\n  constexpr Modint operator/(const Modint rhs) const noexcept {\n    return Modint(*this) /= rhs;\n  }\n\n  constexpr Modint &operator+=(const Modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) a -= Modulus;\n    return *this;\n  }\n  constexpr Modint &operator-=(const Modint rhs) noexcept {\n    if (a < rhs.a) a += Modulus;\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr Modint &operator*=(const Modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr Modint &operator/=(Modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp & 1) *this *= rhs;\n      rhs *= rhs;\n      exp >>= 1;\n    }\n    return *this;\n  }\n\n  Modint pow(u64 t) const {\n    if (!t) return 1;\n    Modint x = pow(t>>1);\n    x *= x;\n    if (t&1) x *= *this;\n    return x;\n  }\n\n  explicit operator bool() const {\n    return a;\n  }\n\n  friend ostream &operator<<(ostream &os, const Modint &m) {\n    return os << m.a;\n  }\n};\n\nusing mint = Modint<>;\n\ntemplate<typename T>\nvector<pair<T, int>> prime_factor(T num) {\n  vector<pair<T, int>> ret;\n  for (T i=2; i*i<=num; ++i) {\n    int cnt = 0;\n    while (num%i == 0) {\n      num /= i;\n      ++cnt;\n    }\n    if (cnt != 0) ret.emplace_back(i, cnt);\n  }\n  if (num != 1) ret.emplace_back(num, 1);\n  return ret;\n}\n\n// if (srt > 0), sorted by ascending order. else if (srt < 0), sorted by descending order.\ntemplate<typename T>\nvector<T> divisor(const vector<pair<T, int>> &pf, int srt = 0) {\n  vector<T> ret;\n  ret.emplace_back(1);\n  for (auto &p : pf) {\n    int sz = ret.size();\n    T x; int y;\n    tie(x,y) = p;\n    T d = 1;\n    for (int i=0; i<y; ++i) {\n      d *= x;\n      for (int j=0; j<sz; ++j) {\n        ret.emplace_back(d * ret[j]);\n      }\n    }\n  }\n  if (srt > 0) sort(ret.begin(), ret.end());\n  else if (srt < 0) sort(ret.rbegin(), ret.rend());\n  return ret;\n}\n\ntemplate<typename T>\nvector<T> divisor(const T &num, int srt = 0) {\n  auto pf = prime_factor(num);\n  return divisor(pf, srt);\n}\n\nvoid solve() {\n  int n, m; cin >> n >> m;\n  string s; cin >> s;\n\n  int MAX = m;\n  int now = 0;\n  rep(i,0,m) {\n    if (s[i] == s[0]) {\n      ++now;\n    } else {\n      if (MAX == m) {\n        MAX = now | 1;\n      } else if (now & 1) {\n        chmin(MAX, now);\n      }\n      now = 0;\n    }\n  }\n\n  if (n & 1) {\n    if (MAX != m) {\n      cout << 0 << endl;\n      return;\n    }\n    \n    Graph<mint> dp(n, vector<mint>(2, 0));\n    dp[0][1] = 1;\n\n    rep(i,1,n) {\n      dp[i][0] = dp[i-1][0] + dp[i-1][1];\n      dp[i][1] = dp[i-1][0];\n    }\n\n    mint ans = dp[n-1][0];\n\n    dp.assign(n, vector<mint>(2, 0));\n    dp[0][0] = 1;\n\n    rep(i,1,n) {\n      dp[i][0] = dp[i-1][0] + dp[i-1][1];\n      dp[i][1] = dp[i-1][0];\n    }\n\n    ans += dp[n-1][0] + dp[n-1][1];\n\n    cout << ans << endl;\n    return;\n  }\n\n  n /= 2;\n  (MAX /= 2) += 1;\n\n  auto div = divisor(n, 1);\n  vector<pair<int, mint>> memo;\n\n  for (auto &d : div) {\n    vector<mint> dp(d+1, 0);\n    dp[0] = 1;\n    mint now = 1;\n\n    repeq(i,1,d) {\n      now += dp[i] = now;\n      if (i >= MAX) now -= dp[i - MAX];\n    }\n\n    vector<mint> sum(d+2, 0);\n    rep(i,1,d+2) sum[i] = sum[i-1] + dp[i-1];\n\n    mint tmp = dp[d];\n    int MIN = min(MAX, d);\n    rep(i,1,MIN) {\n      tmp += sum[d-i] - sum[d-MIN];\n    }\n\n    memo.emplace_back(d, tmp);\n  }\n\n  int sz = memo.size();\n\n  rep(i,0,sz) {\n    rep(j,i+1,sz) {\n      if (memo[j].first % memo[i].first == 0) {\n        memo[j].second -= memo[i].second;\n      }\n    }\n  }\n\n  mint ans = 0;\n  for (auto &p : memo) {\n    ans += p.second;\n  }\n  cout << ans * 2 << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : E.cpp\n * Author  : Kazune Takahashi\n * Created : 2/12/2020, 4:45:12 PM\n * Powered by Visual Studio Code\n */\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n// ----- boost -----\n#include <boost/rational.hpp>\n#include <boost/multiprecision/cpp_int.hpp>\n// ----- using directives and manipulations -----\nusing namespace std;\nusing boost::rational;\nusing boost::multiprecision::cpp_int;\nusing ll = long long;\ntemplate <typename T>\nusing max_heap = priority_queue<T>;\ntemplate <typename T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\n// ----- constexpr for Mint and Combination -----\nconstexpr ll MOD{1000000007LL};\n// constexpr ll MOD{998244353LL}; // be careful\nconstexpr ll MAX_SIZE{3000010LL};\n// constexpr ll MAX_SIZE{30000010LL}; // if 10^7 is needed\n// ----- ch_max and ch_min -----\ntemplate <typename T>\nvoid ch_max(T &left, T right)\n{\n  if (left < right)\n  {\n    left = right;\n  }\n}\ntemplate <typename T>\nvoid ch_min(T &left, T right)\n{\n  if (left > right)\n  {\n    left = right;\n  }\n}\n// ----- Mint -----\ntemplate <ll MOD = MOD>\nclass Mint\n{\npublic:\n  ll x;\n  Mint() : x{0LL} {}\n  Mint(ll x) : x{(x % MOD + MOD) % MOD} {}\n  Mint operator-() const { return x ? MOD - x : 0; }\n  Mint &operator+=(const Mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  Mint &operator-=(const Mint &a) { return *this += -a; }\n  Mint &operator++() { return *this += 1; }\n  Mint &operator++(int)\n  {\n    Mint tmp{*this};\n    ++*this;\n    return tmp;\n  }\n  Mint &operator--() { return *this -= 1; }\n  Mint &operator--(int)\n  {\n    Mint tmp{*this};\n    --*this;\n    return tmp;\n  }\n  Mint &operator*=(const Mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  Mint &operator/=(const Mint &a)\n  {\n    Mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  Mint operator+(const Mint &a) const { return Mint(*this) += a; }\n  Mint operator-(const Mint &a) const { return Mint(*this) -= a; }\n  Mint operator*(const Mint &a) const { return Mint(*this) *= a; }\n  Mint operator/(const Mint &a) const { return Mint(*this) /= a; }\n  bool operator<(const Mint &a) const { return x < a.x; }\n  bool operator<=(const Mint &a) const { return x <= a.x; }\n  bool operator>(const Mint &a) const { return x > a.x; }\n  bool operator>=(const Mint &a) const { return x >= a.x; }\n  bool operator==(const Mint &a) const { return x == a.x; }\n  bool operator!=(const Mint &a) const { return !(*this == a); }\n  const Mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      Mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\ntemplate <ll MOD>\nMint<MOD> operator+(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator-(ll lhs, const Mint<MOD> &rhs)\n{\n  return -rhs + lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator*(ll lhs, const Mint<MOD> &rhs)\n{\n  return rhs * lhs;\n}\ntemplate <ll MOD>\nMint<MOD> operator/(ll lhs, const Mint<MOD> &rhs)\n{\n  return Mint<MOD>{lhs} / rhs;\n}\ntemplate <ll MOD>\nistream &operator>>(istream &stream, Mint<MOD> &a)\n{\n  return stream >> a.x;\n}\ntemplate <ll MOD>\nostream &operator<<(ostream &stream, const Mint<MOD> &a)\n{\n  return stream << a.x;\n}\n// ----- Combination -----\ntemplate <ll MOD = MOD, ll MAX_SIZE = MAX_SIZE>\nclass Combination\n{\npublic:\n  vector<Mint<MOD>> inv, fact, factinv;\n  Combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2LL; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[MOD % i]) * (MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1LL; i < MAX_SIZE; i++)\n    {\n      fact[i] = Mint<MOD>(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  Mint<MOD> operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n  Mint<MOD> catalan(int x, int y)\n  {\n    return (*this)(x + y, y) - (*this)(x + y, y - 1);\n  }\n};\n// ----- for C++14 -----\nusing mint = Mint<MOD>;\nusing combination = Combination<MOD, MAX_SIZE>;\ntemplate <typename T>\nT gcd(T x, T y) { return y ? gcd(y, x % y) : x; }\ntemplate <typename T>\nT lcm(T x, T y) { return x / gcd(x, y) * y; }\n// ----- for C++17 -----\ntemplate <typename T>\nint popcount(T x) // C++20\n{\n  int ans{0};\n  while (x != 0)\n  {\n    ans += x & 1;\n    x >>= 1;\n  }\n  return ans;\n}\n// ----- frequently used constexpr -----\n// constexpr double epsilon{1e-10};\n// constexpr ll infty{1000000000000000LL}; // or\n// constexpr int infty{1'000'000'010};\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\n// ----- Yes() and No() -----\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n// ----- main() -----\n\nclass Solve\n{\n  bool all_red;\n  int N, M;\n  string S;\n  int X;\n\npublic:\n  Solve(int N, int M, string S) : all_red{false}, N{N}, M{M}, S{S}, X{max_length()} {}\n\n  void flush()\n  {\n#if DEBUG == 1\n    cerr << \"X = \" << X << endl;\n#endif\n    if (all_red)\n    {\n      cout << solve_all_red() << endl;\n    }\n    else\n    {\n      cout << solve_normal() << endl;\n    }\n  };\n\nprivate:\n  mint solve_all_red()\n  {\n    vector<vector<mint>> dp(N + 1, vector<mint>(2, 0));\n    dp[0][0] = 1;\n    for (auto i = 1; i <= N; ++i)\n    {\n      dp[i][0] = dp[i - 1][0] + dp[i - 1][1];\n      dp[i][1] = dp[i - 1][0];\n    }\n    return 3 * dp[N - 2][0] + dp[N - 2][1];\n  }\n\n  mint solve_normal()\n  {\n    if (N % 2 == 1)\n    {\n      return 0;\n    }\n    int N{Solve::N / 2}, X{Solve::X / 2};\n    vector<mint> DP(N + 1, 0);\n    DP[0] = 1;\n    for (auto i = 1; i <= N; ++i)\n    {\n      DP[i] = 2 * DP[i - 1];\n      if (i - 1 - X == 0)\n      {\n        DP[i] -= 1;\n      }\n      else if (i - 1 - X > 0)\n      {\n        DP[i] -= DP[i - 2 - X];\n      }\n    }\n#if DEBUG == 1\n    for (auto i = 0; i <= N; ++i)\n    {\n      cerr << \"DP[\" << i << \"] = \" << DP[i] << endl;\n    }\n#endif\n    mint ans{0};\n    for (auto K = 0; K <= X; ++K)\n    {\n      if (N - K - 2 >= 0)\n      {\n        ans += (K + 1) * DP[N - K - 2];\n      }\n      else if (N - K - 1 == 0)\n      {\n        ans += N;\n      }\n    }\n    return ans * 2;\n  }\n\n  int max_length()\n  {\n    if (S[0] == 'B')\n    {\n      for (auto &x : S)\n      {\n        if (x == 'R')\n        {\n          x = 'B';\n        }\n        else\n        {\n          x = 'R';\n        }\n      }\n    }\n    vector<int> V;\n    int now{0};\n    for (auto i = 0; i < M; ++i)\n    {\n      if (S[i] == 'R')\n      {\n        ++now;\n      }\n      else if (now > 0)\n      {\n        V.push_back(now);\n        now = 0;\n      }\n    }\n    if (V.empty())\n    {\n      all_red = true;\n      return N;\n    }\n    if (V[0] % 2 == 0)\n    {\n      ++V[0];\n    }\n    for (auto it = V.begin() + 1; it != V.end(); ++it)\n    {\n      if (*it % 2 == 0)\n      {\n        *it = N;\n      }\n    }\n    return *min_element(V.begin(), V.end());\n  }\n};\n\nint main()\n{\n  int N, M;\n  string S;\n  cin >> N >> M >> S;\n  Solve solve(N, M, S);\n  solve.flush();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint n, m;\nstring s;\nint dp[212123];\nint dpsum[212123];\nbool nonmono;\n\n// msize EVEN\nvoid non(int msize) {\n\tassert(msize % 2 == 0);\n\tdp[0] = 1;\n\tdpsum[0] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tdp[i] = dpsum[i-2];\n\t\tif (i-msize-2 >= 0) {\n\t\t\tdp[i] += MOD - dpsum[i-msize-2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tdpsum[i] = (dp[i] + dpsum[i-2]) % MOD;\n\t}\n\tint ans = dp[n];\n\tfor (int i = 1; i < n; i++) {\n\t\t// first colour must be i + 1 + evener\n\t\tint x = i + 1;\n\t\tif (x % 2 != 0) x++;\n\t\t// x now even\n\t\tif (x > msize) break;\n\t\tans = (ans + dpsum[n-x]) % MOD;\n\t\tif (n-msize-2 >= 0) {\n\t\t\tans += MOD - dpsum[n-msize-2];\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\nvoid mono() {\n\tdp[0] = 1;\n\tdpsum[0] = 1;\n\tdpsum[1] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tdp[i] = dpsum[i-2];\n\t\tdpsum[i] = (dpsum[i-1] + dp[i]) % MOD;\n\t}\n\tint ans = dp[n] + 1;\n\tfor (int i = 0; i <= n-2; i++) {\n\t\tans = (ans + dpsum[i]) % MOD;\n\t}\n\tcout << ans << '\\n';\n}\n\nint main() {\n\tcin >> n >> m >> s;\n\tfor (int i = 1; i < m; i++) {\n\t\tif (s[i] != s[0]) {\n\t\t\tnonmono = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (nonmono) {\n\t\tint msize = n;\n\t\tif (msize % 2 == 1) msize--;\n\t\tint fcur = -1;\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (s[i] == s[0]) cur++;\n\t\t\telse if (cur) {\n\t\t\t\tif (fcur == -1) fcur = cur;\n\t\t\t\tif (cur % 2 == 1) {\n\t\t\t\t\tcur++;\n\t\t\t\t\tmsize = min(msize, cur);\n\t\t\t\t}\n\t\t\t\tcur = 0;\n\t\t\t}\n\t\t}\n\t\tfcur += 2;\n\t\tif (fcur % 2 == 1) fcur--;\n\t\tmsize = min(fcur, msize);\n\t\t//cout << msize << '\\n';\n\t\tnon(msize);\n\t} else {\n\t\tmono();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\nconst ll N=2e5+10,mo=1e9+7;\nll f[N],n,m,lim,q[N];\nchar s[N];\nvoid move(ll &a,ll b){a=(a+b)%mo;}\nint main(){\n\tcin>>n>>m;\n\tscanf(\"%s\",s+1);\n\tif (s[1]=='B'){\n\t\tfor (ll i=1;i<=m;i++)s[i]='B'+'R'-s[i];\n\t}\n\tll cnt=0;\n\tfor (ll i=1;i<=m;i++){\n\t\tif (s[i]=='R')cnt++;\n\t\telse {\n\t\t\tif (!lim)lim=cnt|1;\n\t\t\telse if (cnt&1)lim=min(lim,cnt);\n\t\t\tcnt=0;\n\t\t}\n\t}\n\tif (!lim)lim=n+1;\n\tlim++;\n\tfor (ll i=1;i<=n;i++){\n\t\tf[i]=q[i-2];\n\t\tif (i<=lim&&(i%2==0))move(f[i],i);\n\t\tq[i]=((ll)q[i-2]+f[i]-(i>lim?f[i-lim]:0)+mo)%mo;\n\t}\n\tcout<<f[n]+(lim==n+1)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\ninline void add(int &x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nll bin_pow(ll a, ll p) {\n    ll res = 1;\n    while (p) {\n        if (p & 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return res;\n}\n\nll rev(ll x) {\n    return bin_pow(x, MOD - 2);\n}\n\nll fact[N + 1], rfact[N + 1];\n\nvoid init() {\n    fact[0] = 1;\n    rep(i, 1, N + 1) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    rfact[N] = rev(fact[N]);\n    repb(i, N - 1, -1) {\n        rfact[i] = rfact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nll C(int n, int k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    return fact[n] * rfact[k] % MOD * rfact[n - k] % MOD;\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    init();\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    repb(i, m - 1, -1) {\n        s[i] = char('0' + (s[0] != s[i]));\n    }\n    int c1 = 0;\n    rep(i, 0, m) {\n        if (s[i] == '1') {\n            c1++;\n        }\n    }\n    if (c1 == 0) {\n        assert(false);\n        int ans = 0;\n        for (int i = 0; i * 2 <= n; i++) {\n            //cout << i << \" \" << n - i << \" \" << C(n - i, i) << \"\\n\";\n            add(ans, C(n - i, i));\n            if (i >= 1) {\n                add(ans, C(n - 2 - (i - 1), (i - 1)));\n            }\n        }\n        cout << ans << \"\\n\";\n        return 0;\n    }\n    int k = (n % 2 == 1 ? n : n - 1), cur = 0;\n    rep(i, 0, m) {\n        if (s[i] == '0') {\n            cur++;\n        }\n        if (i == m - 1 || s[i + 1] == '1') {\n            if (cur % 2 == 1) {\n                setmin(k, cur);\n            } else if (cur > 0) {\n                setmin(k, cur * 2 - 3);\n            }\n            cur = 0;\n        }\n    }\n    //cout << k << endl;\n    int dp[n + 2], pref0[n + 2], pref1[n + 2];\n    fill(dp, dp + n + 1, 0);\n    fill(pref0, pref0 + n + 2, 0);\n    fill(pref1, pref1 + n + 2, 0);\n    dp[1] = 1;\n    pref1[1] = 1;\n    rep(i, 2, n + 2) {\n        int last_add = max(2 - i % 2, i - (k + 1));\n        if (i % 2 == 0) {\n            dp[i] = pref0[i - 2] - (last_add - 2 >= 0 ? pref0[last_add - 2] : 0);\n            if (dp[i] < 0) {\n                dp[i] += MOD;\n            }\n        } else {\n            dp[i] = pref1[i - 2] - (last_add - 2 >= 0 ? pref1[last_add - 2] : 0);\n        }\n        if (i % 2 == 0) {\n            pref0[i] = (pref0[i - 2] + dp[i]) % MOD;\n        } else {\n            pref1[i] = (pref1[i - 2] + dp[i]) % MOD;\n        }\n    }\n    /*rep(i, 1, n + 2) {\n        cout << dp[i] << \" \";\n    }\n    cout << \"\\n\";*/\n    if (n % 2 == 1) {\n        cout << 0 << \"\\n\";\n        return 0;\n    }\n    int ans = dp[n + 1];\n    //cout << k << endl;\n    for (int c = 1; c <= k; c += 2) {\n        //cout << c << \" \" << dp[n - c] << endl;\n        ans = (ans + 1LL * c * dp[n - c]) % MOD;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=a*b%mod\n\nll n,m;\nstring s;\nll f[200010],rui[200010];\n\nint main(){\n    cin>>n>>m>>s;\n    if(s[0]=='R'){\n\tfor(int i=0;i<n;i++){\n\t    if(s[i]=='R')s[i]='B';\n\t    else s[i]='R';\n\t}\n    }\n    bool th=0;\n    ll cnt=0,mi=1e17;\n    bool fi=1; ll lead;\n    for(int i=0;i<n;i++){\n\tif(s[i]=='R'){\n\t    if(fi)lead=cnt; fi=0;\n\t    th=1;\n\t    if(cnt%2==1)chmin(mi,cnt);\n\t    cnt=0;\n\t}\n\telse cnt++;\n    }\n    if(th==0){ return 0;\n\tf[0]=f[1]=1;\n\tfor(int i=2;i<n;i++){\n\t    f[i]=(f[i-1]+f[i-2])%mod;\n\t}\n\tll ans=(f[n-2]*2+f[n-1])%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n    }\n    if(n%2==1){\n\tcout<<0<<endl;\n\treturn 0;\n    }\n    \n    if(lead%2==0)lead++;\n    chmin(mi,lead);\n    mi=(mi+1)/2;\n    chmin(mi,n/2);\n    f[0]=rui[0]=0;\n    for(ll i=1;i<=mi;i++){\n\tf[i]=i;\n\trui[i]=(rui[i-1]+i)%mod;\n    }\n    for(int i=1;i<n/2;i++){\n\tmad(f[i],rui[i-1]);\n\tif(i-mi-1>=0)mad(f[i],-rui[i-mi-1]);\n\trui[i]=(rui[i-1]+f[i])%mod;\n    }\n    ll ans=0;\n    for(int i=1;i<=mi;i++)mad(ans,f[n/2-i]);\n    //cout<<mi<<endl;\n    //for(int i=0;i<n/2;i++)cout<<i<<\":\"<<f[i]<<endl;\n    ans=ans*2%mod;\n    if(ans<0)ans+=mod;\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \n#define mod 998244353\n\nusing namespace std;\nconst int N=200010;\nint n,m,ans,f[N],g[N];\nchar s[N];\nvoid inc(int&x,int y){x+=y;if(x>=mod)x-=mod;}\nvoid dec(int&x,int y){x-=y;if(x<0)x+=mod;}\n\nint main(){\n//\tfreopen(\"E.in\",\"r\",stdin);\n//\tfreopen(\"E.out\",\"w\",stdout);\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tint p=0;while(p<m&&s[p+1]==s[1])++p;\n\tif(p==m){\n\t\tans=f[0]=g[0]=1;\n\t\tfor(int i=0;i<=n;++i){\n\t\t\tif(i>1)f[i]=g[max(i-2,0)];\n\t\t\tif(i)g[i]=(g[i-1]+f[i])%mod;\n\t\t\tif(n-i!=1)inc(ans,(ll)(n-i)*f[i]%mod);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}else{\n\t\tif(n&1)puts(\"0\"),exit(0);\n\t\tint L=p|1;\n\t\twhile(1){\n\t\t\tint tmp=0;\n\t\t\twhile(p<m&&s[p+1]!=s[1])++p;tmp-=p;\n\t\t\twhile(p<m&&s[p+1]==s[1])++p;tmp+=p;\n\t\t\tif(p==m)break;\n\t\t\tif(tmp&1)L=min(L,tmp);\n\t\t}\n\t\tf[0]=g[0]=1;\n\t\tL=(L+1)>>1;n>>=1;\n\t\tfor(int i=0;i<=n;++i){\n\t\t\tif(i)f[i]=g[i-1];\n\t\t\tif(i>L)dec(f[i],g[i-L-1]);\n\t\t\tif(i)g[i]=(g[i-1]+f[i])%mod;\n\t\t\tif(n-i<=L)inc(ans,(ll)(n-i)*f[i]%mod);\n\t\t}\n\t\tcout<<ans*2%mod<<endl;\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define Md 1000000007\n#define MN 200005\nint n,m;\nchar c[MN];\nlg Pow(lg x,lg y){\n\tlg res=1;for(;y;y>>=1,x=x*x%Md)if(y&1)res=res*x%Md;return res;\n}\nint Fix(int x){\n\tif(x<0)return x+Md;\n\tif(x>=Md)return x-Md;\n\treturn x;\n}\nint dp[MN],tmp[MN];\nint miu[MN];\nint main(){\n\tread(n);read(m);\n\tscanf(\"%s\",c+1);\n\tmiu[1]=1;\n\tfor(int i=1;i<MN;++i){\n\t\tfor(int j=i+i;j<MN;j+=i){\n\t\t\tmiu[j]-=miu[i];\n\t\t}\n\t}\n\tchar Hd=c[1];\n\tint cnt=0,mx;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse break;\n\t}\n\tif(cnt&1)mx=cnt;else mx=0x3f3f3f3f;\n\tif(n&1){\n\t\tif(cnt!=m)return puts(\"0\"),0;\n\t\tint res=0;\n\t\ttmp[0]=tmp[1]=1;\n\t\tdp[0]=1;\n\t\tmx+=2;\n\t\tif(n>2)res=n;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tdp[i]=(i>=2?tmp[i-2]:0);\n\t\t\ttmp[i]=Fix(tmp[i-1]+dp[i]);\n\t\t\tif(i<n-1)res=Fix(res+1ll*dp[i]*(n-i)%Md);\n\t\t\t//cerr<<i<<' '<<dp[i]<<' '<<n<<' '<<i<<' '<<n/i<<endl;\n\t\t}\n\t\tprintf(\"%d\",res+1);\n\t\treturn 0;\n\t}\n\tint res=(cnt==m);\n\tcnt=0;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse{\n\t\t\tif(!cnt)continue;\n\t\t\tif(cnt&1)mx=min(mx,cnt);\n\t\t\telse if(cnt!=i)mx=min(mx,cnt+1);\n\t\t\tcnt=0;\n\t\t}\n\t}\n\t//for(int i=1;i<=5;++i)cerr<<miu[i]<<' ';cerr<<endl;\n\ttmp[0]=tmp[1]=1;\n\tdp[0]=1;\n\tmx+=2;\n\tif(n<mx)res+=n;\n\tfor(int i=2;i<=n;i+=2){\n\t\tdp[i]=Fix(tmp[i-1]-(mx>i?0:tmp[i-mx]));\n\t\ttmp[i]=tmp[i+1]=Fix(tmp[i-1]+dp[i]);\n\t\t//cerr<<dp[i]<<' '<<i<<endl;\n\t\tif((n-i)%2==0&&n-i<mx)res=Fix(res+dp[i]*(n-i)%Md);\n\t}\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define pll pair <ll, ll>\n#define mp make_pair\n#define pyshnapyshnakaa ios_base :: sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define x first\n#define y second\n#pragma GCC optimize(\"O3\")\n// #pragma GCC optimize(\"Ofast\")\n// #pragma GCC optimize(\"unroll-loops\")\n#define plll pair <pair <ll, ll>, ll>\n#define pllll pair <pair <ll, ll>, pair <ll, ll> >\n#define psl pair <string, ll>\n#define pld pair <ld, ld>\n#define all(a) a.begin(), a.end()\n#define vvl vector <vector <ll> >\n#define cld complex <double>\n\ntypedef long long ll;\n\ntypedef long double ld;\n\nusing namespace std;\n\nconst ll maxn = 3e5;\nconst ll mod = 1e9 + 7;\n\nll n, m, k, t;\n\nstring s;\n\ninline ll step(ll a, ll x) {\n    if (x == 0) {\n        return 1;\n    }\n    if (x % 2 == 1) {\n        return step(a, x - 1) * a % mod;\n    }\n    ll t = step(a, x / 2);\n    return t * t % mod;\n}\n\ninline ll del(ll a, ll b) {\n    return a * step(b, mod - 2) % mod;\n}\n\nll simple() {\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    ll q;\n    for (q = 1; q < n; q++) {\n        D[q] += D[q - 1];\n        if (q >= 2) {\n            D[q] += D[q - 2];\n            D[q] %= mod;\n        }\n    }\n    return (D[n - 2] * 2 + D[n - 1]) % mod;\n    // if (n % 2 == 1) {\n    //     return \n    // }\n    // return step(2, n / 2 + 1);\n}\n\nint main() {\n    pyshnapyshnakaa\n    ll q, w, e, a, b, c;\n    cin >> n >> m;\n    cin >> s;\n    if (s[0] == 'B') {\n        for (q = 0; q < s.length(); q++) {\n            if (s[q] == 'R') {\n                s[q] = 'B';\n            }\n            else {\n                s[q] = 'R';\n            }\n        }\n    }\n    bool fail = 0, blue = 0;\n    for (q = 0; q < s.length(); q++) {\n        if (s[q] == 'B') {\n            blue = 1;\n        }\n        if (q >= 1) {\n            if (s[q - 1] == s[q] && s[q] == 'B') {\n                fail = 1;\n            }\n        }\n    }\n    if (fail) {\n        cout << 0;\n        return 0;\n    }\n    if (!blue) {\n        cout << simple();\n        return 0;\n    }\n    ll mx = maxn, cur = 0;\n    for (q = 0; q < s.length(); q++) {\n        if (s[q] == 'B') {\n            if (cur % 2 == 1) {\n                mx = min(mx, cur);\n            }\n            else {\n                mx = min(mx, cur + 1);\n            }\n            cur = 0;\n        }\n        else {\n            cur++;\n        }\n    }\n    vector <ll> S(2);\n    vector <ll> D(n + 1);\n    D[0] = 1;\n    S[0] = 1;\n    for (q = 1; q < n; q++) {\n        D[q] = S[q % 2];\n        S[q % 2] = (S[q % 2] + D[q]) % mod;\n        ll deli = q - mx - 1;\n        if (deli >= 0) {\n            // cout << \"DELETING \" << q << endl;\n            S[deli % 2] = (S[deli % 2] - D[deli] + mod) % mod;\n        }\n        // cout << q << \" \" << D[q] << endl;\n    }\n    // cout << \"mx \" << mx << endl;\n    ll ans = 0;\n    for (q = 0; q < n; q++) {\n        ll len = n - q - 1;\n        if (len % 2 == 0 || len > mx) {\n            continue;\n        }\n        ans += D[q] * (len + 1) % mod;\n        ans %= mod;\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n        if(dp[i-1] < 0)dp[i-1] %= MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i <= m;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\ninline void add(int &x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nll bin_pow(ll a, ll p) {\n    ll res = 1;\n    while (p) {\n        if (p & 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return res;\n}\n\nll rev(ll x) {\n    return bin_pow(x, MOD - 2);\n}\n\nll fact[N + 1], rfact[N + 1];\n\nvoid init() {\n    fact[0] = 1;\n    rep(i, 1, N + 1) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    rfact[N] = rev(fact[N]);\n    repb(i, N - 1, -1) {\n        rfact[i] = rfact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nll C(int n, int k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    return fact[n] * rfact[k] % MOD * rfact[n - k] % MOD;\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    init();\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    repb(i, m - 1, -1) {\n        s[i] = char('0' + (s[0] != s[i]));\n    }\n    int c1 = 0;\n    rep(i, 0, m) {\n        if (s[i] == '1') {\n            c1++;\n        }\n    }\n    if (c1 == 0) {\n        int ans = 0;\n        for (int i = 0; i * 2 <= n; i++) {\n            add(ans, C(n - i, i));\n            if (i >= 1) {\n                add(ans, C(n - 2 - (i - 1), (i - 1)));\n            }\n        }\n        cout << ans << \"\\n\";\n        return 0;\n    }\n    if (n % 2 == 1) {\n        cout << 0 << \"\\n\";\n        return 0;\n    }\n    int k = n - 1, cur = 0;\n    rep(i, 0, m) {\n        if (s[i] == '0') {\n            cur++;\n        }\n        if (s[i] == '0' && (i == m - 1 || s[i + 1] == '1')) {\n            if (cur % 2 == 1) {\n                setmin(k, cur);\n            } else if (cur > 0) {\n                setmin(k, cur + 1);\n            }\n            cur = 0;\n        }\n    }\n    //cout << k << endl;\n    int dp[n + 2], pref1[n + 2];\n    fill(dp, dp + n + 2, 0);\n    fill(pref1, pref1 + n + 2, 0);\n    dp[1] = 1;\n    pref1[1] = 1;\n    for (int i = 3; i <= n + 1; i += 2) {\n        int last_add = max(1, i - (k + 1));\n        dp[i] = pref1[i - 2] - (last_add - 2 >= 0 ? pref1[last_add - 2] : 0);\n        if (dp[i] < 0) {\n            dp[i] += MOD;\n        }\n        pref1[i] = (pref1[i - 2] + dp[i]) % MOD;\n    }\n    /*rep(i, 1, n + 2) {\n        cout << dp[i] << \" \";\n    }\n    cout << \"\\n\";*/\n    int ans = dp[n + 1];\n    //cout << k << endl;\n    for (int c = 1; c <= k; c += 2) {\n        //cout << c << \" \" << dp[n - c] << endl;\n        ans = (ans + 1LL * c * dp[n - c]) % MOD;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long n,m;\nchar str[200005];\nint arr[200005];\nlong long MOD=1000000007;\n\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);scanf(\"%s\",str);\n\tfor(int i=0;i<m;i++){\n\t\tif(str[i]=='R')arr[i]=0;\n\t\telse arr[i]=1;\n\t}\n\tbool all[2];all[0]=all[1]=1;\n\tfor(int i=0;i<m;i++)all[arr[i]^1]=0;\n\tif(all[0]||all[1]){\n\t\tlong long dp[2][n];memset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;dp[1][0]=0; //start with red (or blue if everything is blue)\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tlong long ans=(dp[0][n-1]+dp[1][n-1])%MOD; //end with red or blue\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=0;dp[1][0]=1; //start with blue\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tans+=dp[0][n-1];ans%=MOD;ans+=MOD;ans%=MOD; //only end with red\n\t\tprintf(\"%lld\",ans);\n\t\treturn 0;\n\t}\n\tif(n%2!=0){printf(\"0\");return 0;}\n\tlong long s=0,l=n-1;\n\tfor(int i=0;i<m;i++){\n\t\tlong long cur=0;\n\t\twhile(i+cur<m&&arr[i+cur]==arr[0])cur++;\n\t\tif(s==0)s=(cur%2==0?cur+1:cur);\n\t\telse if(i+cur<m&&cur%2!=0)l=min(l,cur);\n\t\ti+=cur;\n\t}\n\tlong long mxl=min((s==0?MOD:s),l);\n\t//comments: wlog red is first\n\t//can ignore last segment of red\n\tn/=2; mxl/=2; //remove the ones that are different parity from blue\n\tlong long dp[100100],pref[100100];\n\tmemset(dp,0,sizeof(dp));memset(pref,0,sizeof(pref));\n\t//i segments on a line, first and last are blue, max mxl consecutive reds\n\t//blues may be consecutive because the reds in between were removed\n\tdp[0]=pref[0]=0;dp[1]=pref[1]=1;\n\tfor(long long i=2;i<=n+10;i++){\n\t\tdp[i]=pref[i-1]-pref[max(0LL,i-(mxl+2))];\n\t\tdp[i]%=MOD;dp[i]+=MOD;dp[i]%=MOD;\n\t\tpref[i]=dp[i]+pref[i-1];\n\t\tpref[i]%=MOD;pref[i]+=MOD;pref[i]%=MOD;\n\t}\n\tlong long ans=0;\n\tfor(long long i=2;i<=mxl+2;i++){\n\t\tans+=((i-1LL)*dp[n-i+2])%MOD;\n\t\tans%=MOD;\n\t}\n\tans+=MOD;ans%=MOD;\n\tprintf(\"%lld\",(ans*2LL)%MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\n#define MN 200000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nchar s[MN+5];\nint g[MN+5],n,m,R,all=1;\nvoid Dp1()//每个都有一个合法相连\n{\n    g[1]=1;int ans=1;\n    for(int i=2;i<=n;++i) g[i]=(g[i-1]+g[i-2])%mod;\n    for(int i=1;i<n;++i) ans=(ans+1LL*(g[i]-g[i-1]+mod)*(n-i+1))%mod;\n    printf(\"%d\",ans);\n}\nvoid Dp2()//长度为奇数且处于[1,R]\n{\n    int ans=0;R=n-1;\n    for(int i=1,j;i<=m;i=j)\n    {\n        for(j=i;j<=m&&s[j]==s[1];++j);\n        if(j>m) break;\n        int len=j-i;\n        if(len&1) R=min(R,len);\n        else R=min(R,len+1);\n        for(;j<=m&&s[j]!=s[1];++j);\n    }\n    g[1]=1;\n    for(int i=3;i<=n;i+=2)\n    {\n        g[i]=(g[i-2]-g[max(0,i-R-3)]+mod)%mod;\n        g[i]=(g[i]+g[i-2])%mod;\n    }\n    for(int i=max(1,n-R);i<=n;i+=2) ans=(ans+1LL*(n-i+1)*(g[i]-g[i-2]+mod))%mod;\n    printf(\"%d\",ans);\n}\nint main()\n{\n    R=n=read();m=read();scanf(\"%s\",s+1);\n    for(int i=1;i<=m;++i) if(s[i]!=s[1]) all=0;\n    if(all) Dp1();\n    else (n&1)?puts(\"0\"):(Dp2(),0);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nconst int md = 1e9 + 7;\n\nint dp[N];\n\nsigned main() {\n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n  vector<int> y;\n  for (int i = 0; i < m; i++) {\n    int cnt = 1;\n    while (i + 1 < m && s[i + 1] == s[i]) {\n      ++i;\n      ++cnt;\n    }\n    y.push_back(cnt);\n  }\n  if (y.size() == 1) {\n    vector<int> f(N), g(N);\n    f[1] = 2, f[2] = 3;\n    for (int i = 3; i <= n; i++) {\n      f[i] = (f[i - 1] + f[i - 2]) % md;\n    }\n    g[2] = 3, g[3] = 4;\n    for (int i = 4; i <= n; i++) {\n      g[i] = (f[i - 1] + f[i - 3]) % md;\n    }\n    cout << g[n] << '\\n';\n    return 0;\n  } else if (n % 2 == 1) {\n    cout << 0 << '\\n';\n    return 0;\n  }\n  y.pop_back();\n  int C = y[0] + 1;\n  bool is = true;\n  for (int x : y) {\n    if (is && (x % 2 == 1)) {\n      C = min(C, x);\n    }\n    is ^= 1;\n  }\n  dp[0] = dp[2] = 1;\n  for (int i = 4; i < N; i += 2) {\n    dp[i] = 2 * dp[i - 2] % md;\n    if (i - 3 - C >= 0) {\n      (dp[i] += md - dp[i - 3 - C]) %= md;\n    }\n  }\n  int ans = dp[n];\n  for (int l = 1; l <= C; l += 2) {\n    if (n - l - 1 >= 0) {\n      (ans += l * dp[n - l - 1] % md) %= md;\n    }\n  }\n  ((ans %= md) += md) %= md;\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)2e6];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(__int128 x) {\n\tif (x == 0) { fast_print('0'); return; }\n\tif (x < 0) {\n\t\tfast_print('-');\n\t\tx = -x;\n\t}\n\t__int128 p = 1;\n\twhile (x / (p * 10)) p *= 10;\n\twhile (p) {\n\t\t__int128 symb = x / p;\n\t\tfast_print((int)symb);\n\t\tx -= p * symb;\n\t\tp /= 10;\n\t}\n};\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n, m;\nstring s;\n\nconst ll MOD = 1e9 + 7;\ntemplate<ll MOD>\nstruct Ring {\n\tll value = 0;\n\tRing() {}\n\tRing(int _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing(ll _value) {\n\t\tvalue = _value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tRing pow(ll p) const {\n\t\tif (p == 0) return 1;\t\n\t\tif (p & 1) {\n\t\t\treturn Ring(value).pow(p - 1) * value;\n\t\t} else {\n\t\t\tRing sub = Ring(value).pow(p / 2);\n\t\t\treturn sub * sub;\n\t\t}\n\t}\n\tRing inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tvoid operator*=(const Ring<MOD> &b) {\n\t\tvalue *= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator*(Ring<MOD> a, const Ring<MOD> &b) {\n\t\ta *= b;\n\t\treturn a;\n\t}\n\tvoid operator+=(const Ring<MOD> &b) {\n\t\tvalue += b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator+(Ring a, const Ring &b) {\n\t\ta += b;\n\t\treturn a;\n\t}\n\tvoid operator-=(const Ring<MOD> &b) {\n\t\tvalue -= b.value;\n\t\tvalue = floor_mod(value, MOD);\n\t}\n\tfriend Ring operator-(Ring a, const Ring &b) {\n\t\ta -= b;\n\t\treturn a;\n\t}\n\tvoid operator/=(const Ring<MOD> &b) {\n\t\t(*this) *= b.inv();\t\n\t}\n\tfriend Ring operator/(Ring a, const Ring &b) {\n\t\ta /= b;\n\t\treturn a;\n\t}\n\tbool operator==(const Ring<MOD> &b) {\n\t\treturn value == b.value;\n\t}\n\tbool operator!=(const Ring<MOD> &b) {\n\t\treturn value != b.value;\n\t}\n\tfriend void fast_print(const Ring<MOD> &b) {\n\t\tfast_print(b.value);\n\t}\n};\n\ntypedef Ring<MOD> num;\n\nsigned main(signed argc, char *argv[]) {\n\tscan n, m;\n\tscan s;\n\tif (count(s.begin(), s.end(), s[0]) == len(s)) {\n\t\tvector<num> dp(n + 1);\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) \n\t\t\tfor (int j = 2; j <= i; j++)\n\t\t\t\tdp[i] += dp[i - j];\n\t\tnum final = 0;\n\t\tfor (int a = 0; a <= n; a++) \n\t\t\tfor (int b = 0; a + b + 1 <= n; b++)\n\t\t\t\tfinal += dp[n - a - b - 1];\n\t\tprint final;\n\t\treturn 0;\n\t}\n\tif (n & 1) {\n\t\tprint 0;\n\t\treturn 0;\n\t}\n\tif (s[0] == 'B') {\n\t\tfor (char &c : s) \n\t\t\tc = (c == 'R') ? 'B' : 'R';\n\t}\n\tint _max = 1e9;\n\tchar pref = '!';\n\tint _size = 0;\n\tfor (int i = 0; i <= len(s); i++) {\n\t\tif (s[i] != pref) {\n\t\t\tif ((_size & 1) && pref == 'R')\n\t\t\t\t_max = min(_max, _size);\n\t\t\tif (_max == 1e9 && pref != '!') {\n\t\t\t\t_max = min(_max, _size | 1);\n\t\t\t}\n\t\t\t_size = 1;\n\t\t} else {\n\t\t\t_size++;\n\t\t}\n\t\tpref = s[i];\n\t}\n\t// print _max;\n\tvector<num> dp(n + 1);\n\tdp[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 2; j <= min(i, _max + 1); j += 2)\n\t\t\tdp[i] += dp[i - j];\n\tnum final = 0;\n\tfor (int a = 0; a <= n; a++)\n\t\tfor (int b = 0; a + b <= min(_max, n); b++)\n\t\t\tif ((a + b) & 1)\n\t\t\t\tif (n - a - b - 1 >= 0) {\n\t\t\t\t\t// print a, b, n - a - b - 1, dp[n - a - b - 1];\n\t\t\t\t\tfinal += dp[n - a - b - 1];\n\t\t\t\t}\n\tprint final;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MAXN = 210000;\n\nchar s[MAXN];\n\nconst int MOD = 1000000007;\n\nvoid add(int &a, int b) {\n  if ((a += b) >= MOD) a -= MOD;\n}\n\nvoid sub(int &a, int b) {\n  if ((a -= b) < 0) a += MOD;\n}\n\nint mul(int a, int b) {\n  return (int) ((a * 1LL * b) % MOD);\n}\n\nint mpow(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1) res = mul(res, a);\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\nint minv(int x) {\n  return mpow(x, MOD - 2);\n}\n\nint main() {\n#ifdef LOCAL\n  freopen(\"e.in\", \"r\", stdin);\n  freopen(\"e.out\", \"w\", stdout);\n#endif\n\n  int n, m;\n  while (scanf(\"%d%d\", &n, &m) == 2) {\n    scanf(\"%s\", s);\n    if (s[0] != 'B') {\n      for (int i = 0; i < m; i++) {\n        s[i] = s[i] ^ 'B' ^ 'R';\n      }\n    }\n    int first = find(s, s + m, 'R') - s;\n\n    if (first == m) {\n      vector<int> dp(n + 1);\n      dp[0] = 1;\n      dp[1] = 2;\n      for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1];\n        add(dp[i], dp[i - 2]);\n      }\n      int ans = dp[n];\n      if (n == 3) {\n        sub(ans, dp[n - 3]);\n      } else if (n > 3) {\n        sub(ans, dp[n - 4]);\n      }\n      printf(\"%d\\n\", ans);\n      continue;\n    }\n\n    int lim = n;\n    int prev_r = 0;\n    for (int i = 0; i < m; i++) {\n      if (s[i] == 'R') {\n        if ((i - prev_r) % 2 == 1) {\n          lim = min(lim, i - prev_r);\n        }\n        prev_r = i + 1;\n      }\n    }\n    lim = min(lim, first + 1);\n    eprintf(\"lim = %d\\n\", lim);\n\n    if (n % 2 != 0) {\n      printf(\"0\\n\");\n    } else {\n      vector<int> dp(n / 2 + 1);\n      vector<int> dp2(n / 2 + 2);\n      dp[0] = 1;\n      dp2[1] = 1;\n      for (int i = 1; i <= n / 2; i++) {\n        dp[i] = dp2[i];\n        int pos = i - (lim + 1) / 2;\n        if (pos >= 0)\n          sub(dp[i], dp2[pos]);\n        dp2[i + 1] = dp2[i];\n        add(dp2[i + 1], dp[i]);\n      }\n\n      int ans = 0;\n      for (int i = 1; i <= (lim + 1) / 2; i++) {\n        add(ans, mul(2 * i, dp[n / 2 - i]));\n      }\n      printf(\"%d\\n\", ans);\n    }\n\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=200005,M=1e9+7;\nint n,m,f[N],g[N],ans;\nchar s[N];\nsigned main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tif (s[1]=='R'){\n\t\tfor (int i=1;i<=m;i++){\n\t\t\tif (s[i]=='R')s[i]='B';\n\t\t\telse s[i]='R';\n\t\t}\n\t}\n\tint l=0,mi=0;\n\tfor (int i=1;i<=m;i++)\n\t\tif (s[i]=='R'){\n\t\t\tl=i-1;\n\t\t\tbreak;\n\t\t}\n\tif (!l){\n\t\tf[0]=g[0]=1;\n\t\tfor (int i=1;i<=n;i++){\n\t\t\tf[i]=g[i-2];\n\t\t\tg[i]=(g[i-1]+f[i])%M;\n\t\t}\n\t\tfor (int i=2;i<=n;i++)(ans+=i*f[n-i])%=M;\n\t\tprintf(\"%lld\\n\",(ans+1)%M);\n\t\treturn 0;\n\t}\n\tmi=l+!(l%2);\n\tfor (int i=1,j=1;i<=m;i=j){\n\t\twhile (j<=m&&s[j]=='B')j++;\n\t\tif ((j-i)&1)mi=min(mi,j-i);\n\t\twhile (j<=m&&s[j]=='R')j++;\n\t}\n\tif (n%2==1){\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tmi=(mi+1)/2;\n\tn/=2;\n\tf[0]=g[0]=1;\n\tfor (int i=1;i<=n;i++){\n\t\tf[i]=(g[i-1]-(i-mi-1<0?0:g[i-mi-1])+M)%M;\n\t\tg[i]=(g[i-1]+f[i])%M;\n\t}\n\tfor (int i=1;i<=mi;i++)(ans+=i*2*f[n-i])%=M;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\nconst int md = 1e9 + 7;\n\nint dp[N];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n  vector<int> y;\n  for (int i = 0; i < m; i++) {\n    int cnt = 1;\n    while (i + 1 < m && s[i + 1] == s[i]) {\n      ++i;\n      ++cnt;\n    }\n    y.push_back(cnt);\n  }\n  if (y.size() == 1) {\n    vector<int> f(n + 1), g(n + 1);\n    f[1] = 2, f[2] = 3;\n    for (int i = 3; i <= n; i++) {\n      f[i] = (f[i - 1] + f[i - 2]) % md;\n    }\n    g[0] = 1, g[1] = 2, g[2] = 3, g[3] = 4;\n    for (int i = 4; i <= n; i++) {\n      g[i] = (g[i - 1] + g[i - 2] + md - f[n - 4]) % md;\n    }\n    cout << g[n] << '\\n';\n    return 0;\n  } else if (n % 2 == 1) {\n    cout << 0 << '\\n';\n    return 0;\n  }\n  int C = y[0] + 1;\n  bool is = true;\n  for (int x : y) {\n    if (is && (x % 2 == 1)) {\n      C = min(C, x);\n    }\n    is ^= 1;\n  }\n  dp[0] = dp[2] = 1;\n  for (int i = 4; i < N; i += 2) {\n    dp[i] = 2 * dp[i - 2] % md;\n    if (i - 3 - C >= 0) {\n      (dp[i] += md - dp[i - 3 - C]) %= md;\n    }\n  }\n  int ans = dp[n];\n  for (int l = 1; l <= C; l += 2) {\n    if (n - l - 1 >= 0) {\n      (ans += (long long) l * dp[n - l - 1] % md) %= md;\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n};\n\nstruct SegmentTree\n{\n    using T = mint;\n\n    int N;\n    vector<T> dat;\n\n    T id = 0;\n    T F(T &a, T &b) { return a + b; }\n    \n    SegmentTree(int n){\n        N = 1;\n        while(n > N) N = N << 1;\n        dat = vector<T>(2 * N - 1, id);\n    }\n\n    SegmentTree(int n, vector<T> &v){\n        N = 1;\n        while(n > N) N = N << 1;\n        dat = vector<T>(2 * N - 1, id);\n        for(int i = 0; i < n; i++) dat[i + N - 1] = v[i];\n        for(int i = N - 2; i >= 0; i--) dat[i] = F(dat[i * 2 + 1], dat[i * 2 + 2]); \n    }\n\n\n    void update(int k, T a){\n        k += N - 1;\n        dat[k] = a;\n        while(k > 0){\n            k = (k - 1) / 2;\n            dat[k] = F(dat[k * 2 + 1], dat[k * 2 + 2]);\n        }\n    }\n\n    void reset() { fill(dat.begin(), dat.end(), id); }\n\n    T get(int a, int b, int k, int l, int r){\n        if(r <= a || b <= l) return id;\n        if(a <= l && r <= b) return dat[k];\n        else{\n            T vl = get(a, b, k * 2 + 1, l, (l + r) / 2);\n            T vr = get(a, b, k * 2 + 2, (l + r) / 2, r);\n            return F(vl, vr);\n        }\n    }\n    T get(int a, int b) { return get(a, b, 0, 0, N); }\n\n    T val(int k){ return dat[k + N - 1]; }\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n\n    if(S[0] == 'B'){\n        REP(i, M){\n            if(S[i] == 'B') S[i] = 'R';\n            else S[i] = 'B';\n        }\n    }\n\n    int f = -1, s = INF, t = 0;\n    REP(i, M){\n        if(S[i] == 'R') t++;\n        else{\n            if(f == -1) f = t;\n            else if(t % 2) Min(s, t);\n            t = 0;\n        } \n    }\n\n    mint ans = 0;\n    if(f == -1){\n        mmat dp(N, mvec(2, 0));\n        dp[0][0] = 1;\n        REP(i, N - 1){\n            dp[i + 1][0] += dp[i][0] + dp[i][1];\n            dp[i + 1][1] += dp[i][0];\n        }\n        ans = dp[N - 1][0] + dp[N - 1][1] + dp[N - 2][0];\n    }else if(N % 2 == 0){\n        int d;\n        if(f % 2) d = min(f, s);\n        else d = min(f + 1, s);\n        //debug(d);\n        N /= 2;\n        d /= 2;\n\n        mvec dp(N, 0);\n        dp[0] = 1;\n        SegmentTree ST(N, dp);\n        FOR(i, 1, N){\n            dp[i] = ST.get(i - d - 1, i);\n            ST.update(i, dp[i]);\n        }\n        REP(i, d + 1) if(N - 1 - i >= 0) ans += dp[N - 1 - i] * 2 * (i + 1);\n        //vdebug(dp);\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nchar str[200005];\nint arr[200005];\nlong long MOD=1000000007;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",str);\n\tfor(int i=0;i<m;i++)if(str[i]=='R')arr[i]=0;else arr[i]=1;\n\tbool all[2];all[0]=all[1]=1;\n\tfor(int i=0;i<m;i++)all[arr[i]^1]=0;\n\tif(all[0]||all[1]){\n\t\tlong long dp[2][n];memset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;dp[1][0]=0; //start with red (or blue if everything is blue)\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tlong long ans=(dp[0][n-1]+dp[1][n-1])%MOD;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=0;dp[1][0]=1; //start with blue\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tans+=dp[0][n-1];\n\t\tprintf(\"%lld\",ans);\n\t\treturn 1;\n\t}\n\tif(n%2!=0){printf(\"0\");return 0;}\n\tint cur=0;vector<int> v;\n\tfor(int i=0;i<n;i++){\n\t\tif(arr[i]==arr[0])cur++;\n\t\telse{if(cur!=0)v.push_back(cur);cur=0;}\n\t}\n\tif(cur!=0)v.push_back(cur);\n\tint mxl=(v[0]%2==0?v[0]+1:v[0]);\n\tfor(int i=1;i<(int)v.size();i++){\n\t\tif(v[i]%2==1)mxl=min(mxl,v[i]);\n\t}\n\t//comments: wlog red is first\n\tn/=2; mxl=mxl/2; //remove the ones that are different parity from blue\n\tlong long dp[100005],pref[100005];\n\tmemset(dp,0,sizeof(dp));memset(pref,0,sizeof(pref));\n\t//i segments on a line, first and last are blue, max mxl consecutive reds\n\t//blues may be consecutive because the reds in between were removed\n\tdp[1]=pref[1]=1;dp[2]=1;pref[2]=2;\n\tfor(int i=3;i<=n;i++){\n\t\tdp[i]=pref[i-1]-pref[max(0,i-(mxl+2))];\n\t\tdp[i]%=MOD;dp[i]+=MOD;dp[i]%=MOD;\n\t\tpref[i]=dp[i]+pref[i-1];\n\t\tpref[i]%=MOD;pref[i]+=MOD;pref[i]%=MOD;\n\t}\n\tlong long ans=0;\n\tfor(long long i=2;i<=min(n,mxl+2);i++){\n\t\tans+=2LL*(i-1LL)*dp[n-i+2];\n\t\tans%=MOD;\n\t}\n\tprintf(\"%lld\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tstring s;\n\tcin >> s;\n\tset<char>st;\n\tfor (auto i : s)st.insert(i);\n\tif (st.size() == 1) {\n\t\tvector<long long int>dp(N + 1);\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1];\n\t\t\tif (i > 1)dp[i] += dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tlong long int ans = dp.back();\n\t\tdp[0] = 1;\n\t\tdp[1] = 0;\n\t\tfor (int i = 2; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tans += dp.back();\n\t\tans %= MOD;\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\ts.push_back(s[0] + 1);\n\tvector<int>num(s.size() + 1);\n\tfor (int i = 0; i <= s.size(); i++) {\n\t\tnum[i] = s[i] == s[0];\n\t\tif (i)num[i] = num[i] * (num[i - 1] + 1);\n\t}\n\tint fst = 0;\n\tint m = MOD;\n\tbool even = true;\n\tfor (int i = 1; i <= s.size(); i++) {\n\t\tif (!num[i] && num[i - 1]) {\n\t\t\tif (num[i - 1] & 1) {\n\t\t\t\teven = false;\n\t\t\t\tm = min(m, num[i - 1]);\n\t\t\t}\n\t\t\tif (fst == 0) {\n\t\t\t\tfst = num[i - 1];\n\t\t\t\tif (fst % 2 == 0)m = MOD;\n\t\t\t}\n\t\t}\n\t}\n\tif (even) {\n\t\tm = fst + 2;\n\t}\n\telse if (fst % 2 == 0) {\n\t\tm = min(m, fst);\n\t}\n\tif (m & 1)m++;\n\tvector<long long int>dp(N + 2);\n\tvector<long long int>sum(N + 2);\n\tfor (int i = 2; i <= m; i += 2)dp[i] = i;\n\tfor (int i = 2; i <= N; i++) {\n\t\tdp[i] += sum[i - 2] + MOD;\n\t\tif (i - m - 2 >= 0)dp[i] -= sum[i - m - 2];\n\t\tdp[i] %= MOD;\n\t\tif (i == N) {\n\t\t\tcout << dp[i] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsum[i] = sum[i - 2] + dp[i];\n\t\tsum[i] %= MOD;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define mod 1000000007\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nchar S[200010];\nint f[200010],sf[200010];\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n=gi(),m=gi(),all=0;\n\tscanf(\"%s\",S+1);\n\tint L=1145141;\n\tfor(int l=1,r;l<=m;l=r+1){\n\t\tr=l;if(S[l]!=S[1])continue;\n\t\twhile(r<m&&S[r+1]==S[r])++r;\n\t\tif(r<m)cnk(L,r-l+2);\n\t\telse if(l==1)all=1;\n\t}\n\tif(all){\n\t\tstatic int f[200010][2];\n\t\tint ans=0;\n\t\tfor(int fir=0;fir<2;++fir){\n\t\t\tmemset(f,0,sizeof f);\n\t\t\tf[1][fir]=1;\n\t\t\tfor(int i=1;i<=n;++i){\n\t\t\t\tinc(f[i+1][0],f[i][1]);\n\t\t\t\tinc(f[i+1][1],f[i][0]);\n\t\t\t\tinc(f[i+1][1],f[i][1]);\n\t\t\t}\n\t\t\tif(fir)inc(ans,f[n][0]);\n\t\t\tinc(ans,f[n][1]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(L&1)++L;\n\tf[1]=sf[1]=1;\n\tfor(int i=2;i<=n;++i)f[i]=(sf[i-2]-(i-L-2<0?0:sf[i-L-2])+mod)%mod,sf[i]=(f[i]+sf[i-2])%mod;\n\tint ans=0;\n\tfor(int i=n-1;n-i<=L&&i>=0;i-=2)inc(ans,1ll*(n-i+1)*f[i]%mod);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int maxn=200111;\nconst int mod=1e9+7;\n\nint n,m,dp[maxn],pre[maxn];\nchar s[maxn];\n\nint main()\n{\n\tget2(n,m);\n\tscanf(\"%s\",s+1);\n\t\n\twhile(m>1&&s[m]==s[m-1])m--;\n\tif(m==1)\n\t{\n\t\tdp[0]=2;dp[1]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t{\n\t\t\tdp[i]=dp[i-1]+dp[i-2];\n\t\t\tif(dp[i]>=mod)dp[i]-=mod;\n\t\t}\n\t\tprintf(\"%d\\n\",dp[n]);\n\t\treturn 0;\n\t}\n\t\n\tif(n%2==1)\n\t{\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\t\n\tint bound=inf;\n\tfor(int i=1;i<=m;i++)if(s[i]==s[1]&&s[i]!=s[i-1])\n\t{\n\t\tint len=0;\n\t\twhile(s[i+len]==s[i])len++;\n\t\tif(len%2==1)bound=min(bound,len);\n\t\telse if(i==1)bound=min(bound,len+1);\n\t}\n\tbound=min(bound,n-1);\n\t\n\tn/=2;bound=(bound+1)/2;\n\tdp[0]=1;pre[0]=1;\n\tint sum=0;\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tif(i)\n\t\t{\n\t\t\tif(i<=bound)dp[i]=pre[i-1];\n\t\t\telse dp[i]=(pre[i-1]-pre[i-bound-1]+mod)%mod;\n\t\t\tpre[i]=(pre[i-1]+dp[i])%mod;\n\t\t}\n\t\tif(i>=n-bound)\n\t\t{\n\t\t\tint coef=((n-i)*2-1);\n\t\t\tif(i==n)coef=1;\n\t\t\tsum=(sum+(LL)dp[i]*coef)%mod;\n\t\t}\n\t}\n\tprintendl(sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  if(vs==vector<Int>(m,1)){\n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n\n  if(n&1){\n    cout<<0<<endl;\n    return 0;\n  }\n  \n  Int lim=n;  \n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    Int j=i;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n    \n    if(i==0) chmin(lim,j-i+(~(j-i)&1));    \n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }\n  \n  //cout<<lim<<endl;\n  \n  vector<M> dp(n+1,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n;i++){\n    for(Int j=i-2;j>=1&&j>=i-1-lim;j-=2){      \n      dp[i]+=dp[j];\n    }\n    //cout<<i<<\":\"<<dp[i].v<<endl;\n  }\n\n  M ans{0};\n  for(Int i=0;i<n;i++){\n    for(Int j=n-i;j>=1&&j>=n-lim;j--){\n      if(~(n-j)&1) continue;\n      ans+=dp[j];      \n    }\n  }  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\nchar str[200005];\nint arr[200005];\nlong long MOD=1000000007;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);scanf(\"%s\",str);\n\tfor(int i=0;i<m;i++)if(str[i]=='R')arr[i]=0;else arr[i]=1;\n\tbool all[2];all[0]=all[1]=1;\n\tfor(int i=0;i<m;i++)all[arr[i]^1]=0;\n\tif(all[0]||all[1]){\n\t\tlong long dp[2][n];memset(dp,0,sizeof(dp));\n\t\tdp[0][0]=1;dp[1][0]=0; //start with red (or blue if everything is blue)\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tlong long ans=(dp[0][n-1]+dp[1][n-1])%MOD;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[0][0]=0;dp[1][0]=1; //start with blue\n\t\tfor(int i=1;i<n;i++){\n\t\t\tdp[0][i]=dp[0][i-1]+dp[1][i-1];\n\t\t\tdp[1][i]=dp[0][i-1];\n\t\t\tdp[0][i]%=MOD;dp[1][i]%=MOD;\n\t\t}\n\t\tans+=dp[0][n-1];ans%=MOD;ans+=MOD;ans%=MOD;\n\t\tprintf(\"%lld\",ans);\n\t\treturn 0;\n\t}\n\tif(n%2!=0){printf(\"0\");return 0;}\n\tint cur=0;bool b=0;\n\tint mxl=n-1;\n\tfor(int i=0;i<n;i++){\n\t\tif(arr[i]==arr[0])cur++;\n\t\telse{\n\t\t\tif(!b){\n\t\t\t\tb=1;mxl=min(mxl,cur^1);\n\t\t\t}else if(cur%2==1)mxl=min(mxl,cur);\n\t\t}\n\t}\n\t//comments: wlog red is first\n\tn/=2; mxl/=2; //remove the ones that are different parity from blue\n\tlong long dp[100005],pref[100005];\n\tmemset(dp,0,sizeof(dp));memset(pref,0,sizeof(pref));\n\t//i segments on a line, first and last are blue, max mxl consecutive reds\n\t//blues may be consecutive because the reds in between were removed\n\tdp[1]=pref[1]=1;\n\tfor(int i=2;i<=n;i++){\n\t\tdp[i]=pref[i-1]-pref[max(0,i-(mxl+2))];\n\t\tdp[i]%=MOD;dp[i]+=MOD;dp[i]%=MOD;\n\t\tpref[i]=dp[i]+pref[i-1];\n\t\tpref[i]%=MOD;pref[i]+=MOD;pref[i]%=MOD;\n\t}\n\tlong long ans=0;\n\tfor(long long i=2;i<=min(n,mxl+2);i++){\n\t\tans+=(i-1LL)*dp[n-i+2];\n\t\tans%=MOD;\n\t}\n\tans+=MOD;ans%=MOD;\n\tprintf(\"%lld\",(ans*2)%MOD);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\ntemplate<typename T>\nstruct SegmentTree{\nprivate:\n    int n;\n    T E;\n    vector<T> node;\n    inline void updatef(T& x,T& y){\n        x = y;\n        //x += y;\n        //x = max(x,y);\n        //x = min(x,y);\n    }\n    inline T queryf(T& x,T& y){\n        //return x*y;\n        return (x+y)%mod;\n        //return max(x,y);\n        //return min(x,y);\n    }\n\npublic:\n    SegmentTree(int sz,T E_):E(E_){\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n    }\n\n    SegmentTree(vector<T>& A,T E_):E(E_){\n        int sz=A.size();\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n        rep(i,sz)node[i+n-1]=A[i];\n        for(int i=n-2;i>=0;--i){\n            node[i]=queryf(node[2*i+1], node[2*i+2]);\n        }\n    }\n    void update(int k,T x){\n        k+=n-1;\n        updatef(node[k],x);\n        while(k>0){\n            k=(k-1)/2;\n            node[k]=queryf(node[2*k+1], node[2*k+2]);\n        }\n    }\n       //[a,b)での和を返す\n    T get(int a,int b,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        if(r<=a||b<=l)return E;\n        if(a<=l&&r<=b)return node[k];\n        T xl=get(a,b,2*k+1,l,(l+r)/2);\n        T xr=get(a,b,2*k+2,(l+r)/2,r);\n        return queryf(xl, xr);\n    }\n};\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n    fact.resize(n+1);\n    inv.resize(n+1);\n    invfact.resize(n+1);\n    fact[0]=inv[0]=invfact[0]=1;\n    inv[1]=1;\n    rep(i,n){\n        fact[i+1]=fact[i]*(i+1)%mod;\n        if(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n        invfact[i+1]=invfact[i]*inv[i+1]%mod;\n    }\n}\nll perm(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n    k%=mod-1;\n    if(k<0)k+=mod-1;\n    ll ret=1;\n    while(k){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\nint main(){\n    int n,m;\n    cin>>n>>m;\n    string s;\n    cin>>s;\n    int len=0;\n    while(len<n&&s[len]==s[0])++len;\n    if(len==m){\n        vector<ll> ans(n+1);\n        ans[0]=2,ans[1]=1;\n        rep(i,n-1)ans[i+2]=(ans[i+1]+ans[i])%mod;\n        cout<<ans[n]<<endl;\n        return 0;\n    }\n    if(n%2){\n        cout<<0<<endl;\n        return 0;\n    }\n    if (len%2==0)++len;\n    int cnt=0;\n    rep(i,n){\n        if(s[i]!=s[0]){\n            if(cnt%2)len=min(len,cnt);\n            cnt=0;\n        }\n        else ++cnt;\n    }\n    n/=2;\n    len = (len+1)/2;\n    SegmentTree<ll> sg(n+5,0);\n    sg.update(0,1);\n    rep(i,n+1){\n        ll ret=sg.get(max(0,i+1-len),i+1);\n        sg.update(i+1,ret);\n    }\n    ll ans=0;\n    rep(i,max(n,len)){\n        ans+=sg.get(max(0,n-len),n-i);\n    }\n    cout<<2*ans%mod<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// 入力\nlong long mod = 1000000007;\nlong long N, M;\nstring S;\n\n// その他\nlong long fib[1 << 19];\nlong long dp[1 << 19], ru[1 << 19];\nlong long ret[1 << 19];\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 32; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nlong long Div(long long p, long long q, long long m) {\n\treturn (p * modpow(q, m - 2, m)) % m;\n}\n\nlong long solve(long long n, long long r) {\n\tfor (int i = 0; i <= n / 2; i++) dp[i] = 0;\n\tfor (int i = 1; i <= r / 2; i++) dp[i] = 1LL * (i * 2);\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tlong long v = ru[i - 1]; if (i - (r / 2) - 1 >= 0) v -= ru[i - (r / 2) - 1];\n\t\tv = (v + mod) % mod;\n\t\tdp[i] += v; dp[i] %= mod;\n\t\tru[i] = (dp[i] + ru[i - 1]) % mod;\n\t}\n\t\n\tlong long val = dp[n / 2];\n\treturn val;\n}\n\nint main() {\n\tcin >> N >> M >> S;\n\n\t// 判定\n\tbool flag = false;\n\tfor (int i = 0; i < S.size() - 1; i++) {\n\t\tif (S[i] != S[i + 1]) flag = true;\n\t}\n\n\t// 特殊\n\tif (flag == false) {\n\t\tfib[0] = 1;\n\t\tfib[1] = 1;\n\t\tfor (int i = 2; i <= N; i++) fib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t\tcout << (fib[N] + fib[N - 2]) % mod << endl;\n\t\treturn 0;\n\t}\n\n\t// 奇数\n\tif (N % 2 == 1) {\n\t\tcout << \"0\" << endl;\n\t\treturn 0;\n\t}\n\n\t// 偶数\n\tif (S[0] == 'B') {\n\t\tfor (int i = 0; i < S.size(); i++) {\n\t\t\tif (S[i] == 'B') S[i] = 'R';\n\t\t\telse S[i] = 'B';\n\t\t}\n\t}\n\tint MaxLength = N, cur = 0;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] == 'R') cur++;\n\t\telse {\n\t\t\tMaxLength = min(MaxLength, cur);\n\t\t\tcur = 0;\n\t\t}\n\t}\n\tMaxLength += 2;\n\n\tvector<long long> E;\n\tfor (int i = 1; i <= N / 2; i++) {\n\t\tif ((N / 2) % i == 0) E.push_back(i);\n\t}\n\tfor (int i = E.size() - 1; i >= 0; i--) {\n\t\tlong long d1 = (N / E[i]);\n\t\tlong long d2 = (MaxLength / E[i]);\n\t\tret[i] = solve(d1, d2);\n\t\tfor (int j = i + 1; j < E.size(); j++) {\n\t\t\tif (E[j] % E[i] == 0) { ret[i] -= ret[j]; ret[i] = (ret[i] + mod) % mod; }\n\t\t}\n\t}\n\n\tlong long FinalAns = 0;\n\tfor (int i = 0; i < E.size(); i++) {\n\t\tFinalAns += 1LL * ret[i];\n\t\tFinalAns %= mod;\n\t}\n\tcout << FinalAns << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int _ = 2e5 + 7 , MOD = 1e9 + 7;\nchar str[_]; int N , M;\n\nint main(){\n\tscanf(\"%d %d %s\" , &N , &M , str + 1);\n\tif(str[1] == 'B') for(int i = 1 ; i <= M ; ++i) str[i] = 'B' + 'R' - str[i];\n\tint limit = 1e9 , pre = 1;\n\tfor(int i = 2 ; i <= M ; ++i)\n\t\tif(str[i] == 'B'){\n\t\t\tif(!pre) continue;\n\t\t\tif(pre == 1) limit = min(limit , (i - pre) / 2 * 2 + 1);\n\t\t\tif((i - pre) & 1) limit = min(limit , i - pre);\n\t\t\tpre = 0;\n\t\t}\n\t\telse if(!pre) pre = i;\n\tint ans = 0;\n\tif(limit == 1e9){\n\t\tstatic long long dp[_][2][2]; dp[2][0][0] = dp[2][1][0] = dp[2][0][1] = 1;\n\t\tfor(int i = 3 ; i <= N ; ++i)\n\t\t\tfor(int j = 0 ; j < 2 ; ++j){dp[i][j][0] = (dp[i - 1][j][0] + dp[i - 1][j][1]) % MOD; dp[i][j][1] = dp[i - 1][j][0];}\n\t\tans = (dp[N][0][0] + dp[N][0][1] + dp[N][1][0]) % MOD;\n\t}\n\telse if(!(N & 1)){\n\t\tstatic int dp[_]; dp[1] = 1;\n\t\tif(limit >= N - 1) ans = N;\n\t\tfor(int i = 3 ; i <= N ; i += 2){\n\t\t\tint val = (MOD + dp[i - 2] - dp[max(0 , i - limit - 3)]) % MOD;\n\t\t\tif(N - i <= limit) ans = (ans + 1ll * val * (N - i + 1)) % MOD;\n\t\t\tdp[i] = (dp[i - 2] + val) % MOD;\n\t\t}\n\t}\n\tcout << ans << endl; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e5+10,inf=0x3f3f3f3f,mod=1e9+7;\nchar s[maxn];\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\ty>>=1;\n\t\tx=(ll)x*x%mod;\n\t}\n\treturn res;\n}\nint dp[maxn],sum[maxn];\nint main(){\n\tint n=read(),m=read();\n\tscanf(\"%s\",s+1);\n\tint Min=inf;\n\tfor(int i=1,j;i<=m;i++) if(s[i]==s[1]){\n\t\tj=i;\n\t\twhile(j<m && s[j+1]==s[1]) ++j;\n\t\tif(j==m) continue;\n\t\tif((j-i+1)%2==1) chkmin(Min,j-i+1);\n\t\telse if(i==1) chkmin(Min,j-i+2);\n\t\ti=j;\n\t}\n\tint flag=1;\n\tREP(i,2,m) flag&=(s[i]==s[1]);\n\tdp[1]=sum[1]=1;\n\tREP(i,2,n+1){\n\t\tif(flag){\n\t\t\tdp[i]=sum[i-2];\n\t\t\tsum[i]=(sum[i-1]+dp[i])%mod;\n\t\t}\n\t\telse{\n\t\t\tdp[i]=(sum[i-2]-sum[max(i-Min-3,0)]+mod)%mod;\n\t\t\tsum[i]=(sum[i-2]+dp[i])%mod;\n\t\t}\n\t}\n\tint ans=(dp[n+1]*2+flag)%mod;\n\tREP(i,1,n-2) if(((n-i)%2==1 && n-i<=Min) || flag) ans=(ans+(ll)dp[i]*(n-i-1))%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[2160000];\nInt rdp[2160000];\nInt dp[2160000];\nvoid calc(Int n, Int limit){/*\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n        }*/\n\n    dp[0] = 1;\n    for(int i = 1;i <= n;i++){\n        for(int j = max(0LL, i-limit);j < i;j++)dp[i] = (dp[i] + dp[j]) % MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n+10, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    if(str.size() != m)return 1;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i < vec.size();i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n;i++){\n        dp[i-1] = dp[i];\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)\n            tmp[i] = dp[n-i];\n    }\n    for(int i = limit-1;i >= 0;i--){\n        tmp[i] += tmp[i+1];\n        tmp[i] %= MOD;\n    }\n    for(int i = 1;i <= limit;i++){\n        res = (res + tmp[i] * 2) % MOD;\n    }\n    return res;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i <= m;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst ll MOD = 1e9 + 7;\n\nint N, M;\nstring S;\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N >> M >> S;\n\tif (S[0] == 'B') {\n\t\tfor (char& c : S) {\n\t\t\tc ^= 'B' ^ 'R';\n\t\t}\n\t}\n\tassert(S[0] == 'R');\n\n\tif (S == string(M, S[0])) {\n\t\t// there are no consecutive Bs\n\t\tarray<array<ll, 2>, 2> dp = {};\n\t\tdp[0][0] = dp[1][1] = 1;\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tarray<array<ll, 2>, 2> ndp = {};\n\t\t\tfor (int a = 0; a < 2; a++) {\n\t\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\t\tfor (int c = 0; c < 2; c++) {\n\t\t\t\t\t\tif (b || c) {\n\t\t\t\t\t\t\tndp[a][c] = (ndp[a][c] + dp[a][b]) % MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(dp, ndp);\n\t\t}\n\n\t\tll ans = 0;\n\t\tfor (int a = 0; a < 2; a++) {\n\t\t\tfor (int b = 0; b < 2; b++) {\n\t\t\t\tif (a || b) {\n\t\t\t\t\tans = (ans + dp[a][b]) % MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\n\tif (N % 2 == 1) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\n\tbool foundBlue = false;\n\tint maxRed = N-1;\n\tint cntRed = 0;\n\tfor (char c : S) {\n\t\tif (c == 'R') {\n\t\t\tcntRed++;\n\t\t} else {\n\t\t\tassert(c == 'B');\n\t\t\tif (foundBlue) {\n\t\t\t\tif (cntRed % 2 == 1) {\n\t\t\t\t\tmaxRed = min(maxRed, cntRed);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmaxRed = min(maxRed, cntRed + 1);\n\t\t\t}\n\t\t\tfoundBlue = true;\n\t\t\tcntRed = 0;\n\t\t}\n\t}\n\n\tassert(maxRed >= 1);\n\tmaxRed = (maxRed + 1) / 2;\n\tN /= 2;\n\n\tvector<ll> dp(N+1);\n\tdp[0] = 1;\n\tll sum = dp[0];\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (i - maxRed - 1 >= 0) sum = (sum - dp[i - maxRed - 1] + MOD) % MOD;\n\t\tdp[i] = sum;\n\t\tsum = (sum + dp[i]) % MOD;\n\t}\n\n\tll ans = 0;\n\tfor (int i = 1; i <= maxRed; i++) {\n\t\tans = (ans + i * dp[N - i]) % MOD;\n\t}\n\tans = ans * 2 % MOD;\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  if(vs==vector<Int>(m,1)){\n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n\n  if(n&1){\n    cout<<0<<endl;\n    return 0;\n  }\n  \n  Int lim=n;  \n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    Int j=i;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n    \n    if(i==0) chmin(lim,(j-i)+(~(j-i)&1));    \n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }\n  \n  assert(lim<n-1);\n  \n  vector<M> dp(n+2,0),sm(n+2,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n+1;i++){\n    sm[i]=sm[i-1]+dp[i-1];\n    if(i&1) dp[i]=sm[i-1]-sm[max<Int>(1,i-1-lim)];\n  }\n  \n  M ans{0};\n  for(Int i=0;i<n;i++)\n    if(n-i+1>=max<Int>(1,n-lim))\n      ans+=sm[n-i+1]-sm[max<Int>(1,n-lim)];\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 200005;\nconst ll MOD = 1000000007;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n, m, nR, nB;\nchar str[MX];\nll f[MX], sum[2][MX];\n\nvector<int> divide(int x)\n{\n\tvector<int> ret;\n\tfor(int i=1; i<=x; i++)\n\t\tif(x%i == 0)\n\t\t\tret.push_back(i);\n\treturn ret;\n}\n\nint main()\n{\n\tll ans = 0;\n\tread(n), read(m);\n\tscanf(\"%s\", str+1);\n\tfor(int i=1; i<=m; i++)\n\t\tif(str[i] == 'R') nR++;\n\t\telse nB++;\n\tvector<int> dvs = divide(n);\n\tif(!nR || !nB)\n\t{\n\t\tf[0] = 1;\n\t\tsum[0][0] = sum[0][1] = 1;\n\t\tfor(int i=2; i<=n; i++)\n\t\t{\n\t\t\tf[i] = sum[0][i-2];\n\t\t\tsum[0][i] = (sum[0][i-1] + f[i]) % MOD;\n\t\t}\n\t\tans = 1;\n\t\tfor(int i=1; i<n; i++) ans = (ans+f[n-i-1]*(i+1)) % MOD;\n\t}\n\telse\n\t{\n\t\tint len = n-1;\n\t\tint pre = 0;\n\t\twhile(str[pre+1] == str[1]) pre++;\n\t\t/*if(pre&1) cmin(len, pre);\t\t//the worst case isn't when the initial position is in the middle!\n\t\telse cmin(len, pre*2-1);*/\n\t\tcmin(len, pre|1);\n\t\tint cur = 0;\n\t\tfor(int i=pre+1; i<=m; i++)\n\t\t{\n\t\t\tif(str[i] != str[1])\n\t\t\t{\n\t\t\t\tif(cur & 1) cmin(len, cur);\n\t\t\t\tcur = 0;\n\t\t\t}\n\t\t\telse cur++;\n\t\t}\n\t\tf[0] = sum[0][0] = 1;\n\t\tfor(int i=1; i<=n; i++)\n\t\t{\n\t\t\tf[i] = (((i-2>=0) ? (sum[i&1][i-2]) : (0)) - ((i-2-len>=0) ? (sum[i&1][i-2-len]) : (0)) + MOD) % MOD;\n\t\t\tsum[i&1][i] = (sum[i&1][i-1] + f[i]) % MOD;\n\t\t\tsum[i&1^1][i] = sum[i&1^1][i-1];\n\t\t}\n\t\tfor(int i=1; i<=len; i+=2) ans = (ans+f[n-i-1]*(i+1)) % MOD;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<ll> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nconst int MOD = (1e9 + 7);\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(a<b) return 0;\n\tif(b==0) return 1;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tpow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\n\nint dp[2][2][333333]; //# of sols to a_1+b_1+...+a_n=K in restricted range\nint S[2][2][2][333333];\nconst int INF = int(1e9);\n\nint ss(int parity, int id, int lascolor, int pos)\n{\n\twhile(pos>=0&&((pos+parity)%2!=0)) pos--;\n\tif(pos<0) return 0;\n\treturn S[parity][id][lascolor][pos];\n}\n\n\nint sum(int id, int lascolor, int parity, int l, int r)\n{\n\treturn add(ss(parity,id,lascolor,r),MOD-ss(parity,id,lascolor,l-1));\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tinit(234567);\n\tint n,m; cin>>n;\n\tint mx[2] = {INF,INF};\n\tint pr[2] = {1,1};\n\t//cin>>mx[0];\n\t\n\tcin>>m;\n\tstring s; cin>>s;\n\tvector<int> runs;\n\tint currun=1;\n\tfor(int i=1;i<m;i++)\n\t{\n\t\tif(s[i]==s[i-1]) currun++;\n\t\telse\n\t\t{\n\t\t\truns.pb(currun); currun=1;\n\t\t}\n\t}\n\truns.pb(currun);\n\tfor(int i=0;i+1<runs.size();i++)\n\t{\n\t\tif(i==0||runs[i]%2==1) mx[i%2]=min(mx[i%2],runs[i]+1); \n\t\tpr[i%2]=0;\n\t}\n\t\n\t//cerr<<mx[0]<<' '<<mx[1]<<' '<<pr[0]<<' '<<pr[1]<<'\\n';\n\t//mono color\n\tint ans=0;\n\tif(mx[0]==INF&&mx[1]==INF){ans++;}\n\tmx[1]=1;\n\t//exist at least 2 colors\n\t/*\n\t{\n\t\tint cnt=0;\n\t\tfor(int i=1;i+1<(1<<n);i++)\n\t\t{\n\t\t\tint M[2]={0,0};\n\t\t\tint exeven[2]={0,0};\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tint cur=j;\n\t\t\t\tint vv=0;\n\t\t\t\tif(i&(1<<j)) vv=1;\n\t\t\t\tint r=1;\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\tif(r>=n){break;}\n\t\t\t\t\tcur++;\n\t\t\t\t\tcur%=n;\n\t\t\t\t\tint v=0;\n\t\t\t\t\tif(i&(1<<cur)) v=1;\n\t\t\t\t\tif(vv==v) r++;\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t\tM[vv]=max(M[vv],r);\n\t\t\t\tbool isrun=false;\n\t\t\t\tint tmp = (j+n-1)%n;\n\t\t\t\tint xx=0;\n\t\t\t\tif(i&(1<<tmp)) xx=1;\n\t\t\t\tif(xx!=vv){isrun=1;}\n\t\t\t\tif(r%2==0&&isrun) exeven[vv]=1;\n\t\t\t}\n\t\t\tif(M[0]>mx[0]||M[1]>mx[1]) continue;\n\t\t\tif(exeven[0])\n\t\t\t{\n\t\t\t\tif(!pr[0]) continue;\n\t\t\t}\n\t\t\tif(exeven[1])\n\t\t\t{\n\t\t\t\tif(!pr[1]) continue;\n\t\t\t}\n\t\t\t//cerr<<M[0]<<' '<<M[1]<<' '<<exeven[0]<<' '<<exeven[1]<<'\\n';\n\t\t\tcnt++;\n\t\t}\n\t\tcerr<<\"CNT : \"<<cnt<<'\\n';\n\t}\n\t*/\n\tfor(int i=0;i<2;i++)\n\t{\n\t\t//start with color i\n\t\tfor(int j=1;j<=min(n,mx[i]);j++)\n\t\t{\n\t\t\tif(j%2==0)\n\t\t\t{\n\t\t\t\tif(!pr[i]) continue;\n\t\t\t}\n\t\t\tdp[i][i][j]=1;\n\t\t}\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\t//push dp\n\t\t\tfor(int k=0;k<2;k++)\n\t\t\t{\n\t\t\t\tdp[i][k][j] = add(dp[i][k][j], sum(i,k^1,(j+1)&1,j-mx[k],j-1));\n\t\t\t\tif(pr[k]) dp[i][k][j] = add(dp[i][k][j], sum(i,k^1,j&1,j-mx[k],j-1));\n\t\t\t\t//cerr<<i<<' '<<k<<' '<<j<<' '<<dp[i][k][j]<<'\\n';\n\t\t\t}\n\t\t\tfor(int k=0;k<2;k++)\n\t\t\t{\n\t\t\t\tS[j%2][i][k][j]=dp[i][k][j];\n\t\t\t\tif(j-2>=0) S[j%2][i][k][j]=add(S[j%2][i][k][j],S[j%2][i][k][j-2]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int c=0;c<2;c++)\n\t{\n\t\tfor(int run=1;run<=min(n,mx[c]);run++)\n\t\t{\n\t\t\tif(run%2==0)\n\t\t\t{\n\t\t\t\tif(!pr[c]) continue;\n\t\t\t}\n\t\t\tint val = dp[c^1][c^1][n-run];\n\t\t\t//cerr<<c<<' '<<run<<' '<<val<<'\\n';\n\t\t\tans=add(ans,mult(run,val));\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\ninline void add(int &x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nll bin_pow(ll a, ll p) {\n    ll res = 1;\n    while (p) {\n        if (p & 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return res;\n}\n\nll rev(ll x) {\n    return bin_pow(x, MOD - 2);\n}\n\nll fact[N + 1], rfact[N + 1];\n\nvoid init() {\n    fact[0] = 1;\n    rep(i, 1, N + 1) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    rfact[N] = rev(fact[N]);\n    repb(i, N - 1, -1) {\n        rfact[i] = rfact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nll C(int n, int k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    return fact[n] * rfact[k] % MOD * rfact[n - k] % MOD;\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    init();\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    repb(i, m - 1, -1) {\n        s[i] = char('0' + (s[0] != s[i]));\n    }\n    int c1 = -1;\n    rep(i, 0, m) {\n        if (s[i] == '1') {\n            c1 = i;\n        }\n    }\n    if (c1 == -1) {\n        int ans = 0;\n        for (int i = 0; i * 2 <= n; i++) {\n            add(ans, C(n - i, i));\n            if (i >= 1) {\n                add(ans, C(n - 2 - (i - 1), (i - 1)));\n            }\n        }\n        cout << ans << \"\\n\";\n        return 0;\n    }\n    s = s.substr(0, c1 + 1);\n    m = sz(s);\n    if (n % 2 == 1) {\n        cout << 0 << \"\\n\";\n        return 0;\n    }\n    int k = n - 1, cur = 0;\n    rep(i, 0, m) {\n        if (s[i] == '0') {\n            cur++;\n        }\n        if (s[i] == '0' && (i == m - 1 || s[i + 1] == '1')) {\n            if (cur % 2 == 1) {\n                setmin(k, cur);\n            } else if (cur == i + 1) {\n                setmin(k, cur + 1);\n            }\n            cur = 0;\n        }\n    }\n    //cout << k << endl;\n    int dp[n + 2], pref1[n + 2];\n    fill(dp, dp + n + 2, 0);\n    fill(pref1, pref1 + n + 2, 0);\n    dp[1] = 1;\n    pref1[1] = 1;\n    for (int i = 3; i <= n + 1; i += 2) {\n        int last_add = max(1, i - (k + 1));\n        dp[i] = pref1[i - 2] - (last_add - 2 >= 0 ? pref1[last_add - 2] : 0);\n        if (dp[i] < 0) {\n            dp[i] += MOD;\n        }\n        pref1[i] = (pref1[i - 2] + dp[i]) % MOD;\n    }\n    /*rep(i, 1, n + 2) {\n        cout << dp[i] << \" \";\n    }\n    cout << \"\\n\";*/\n    int ans = dp[n + 1];\n    //cout << k << endl;\n    for (int c = 1; c <= k; c += 2) {\n        //cout << c << \" \" << dp[n - c] << endl;\n        ans = (ans + 1LL * c * dp[n - c]) % MOD;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline tuple<int, int, int> extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nunsigned ModInt::MOD = 1000000007;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\n\n\nconst int limit = 200010;\nmint dp[limit][2][2];\nmint dp2[limit];\nmint csum2[limit];\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\n\tbool same = true;\n\trep(i, n) if(s[0] != s[i]) same = false;\n\n\tint cmin = n, cons = 0;\n\trep(i, n){\n\t\tif(s[i] == s[0]){\n\t\t\tcons++;\n\t\t} else {\n\t\t\tchmin(cmin, cons);\n\t\t}\n\t}\n\n\tif(cmin % 2 == 0) cmin++;\n\tdp2[1] = csum2[1] = ONE;\n\n\trep(i, 1, n){\n\t\tconst int pos = max(i - cmin - 1, 0);\n\t\tif((i + 1) % 2 == 1) dp2[i + 1] =  csum2[i] - csum2[pos];\n\t\tcsum2[i + 1] = csum2[i] + dp2[i + 1];\n\t}\n\n\tmint ans = ZERO;\n\n\trep(i, n - cmin, n + 1){\n\t\tconst mint coef = mint(n - i + 1);\n\t\tans += coef * dp2[i];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1000000007;\nint n, m, dp[200005], sum[2][200005];\nchar s[200005];\n\nint main() {\n\tscanf(\"%d%d%s\", &n, &m, s + 1);\n\tif (count(s + 1, s + 1 + m, s[1]) == m) {\n\t\tif (n == 1) return puts(\"1\"), 0;\n\t\tint ans = 0;\n\t\tfor (int c = 0; c < 2; ++c) {\n\t\t\tint dp[2] = {};\n\t\t\tdp[c] = 1;\n\t\t\tfor (int i = 2; i <= n; ++i) {\n\t\t\t\tint t = dp[1];\n\t\t\t\tdp[1] = dp[0];\n\t\t\t\tdp[0] = (dp[0] + t) % P;\n\t\t\t}\n\t\t\tans = (ans + dp[0]) % P;\n\t\t\tif (!c) ans = (ans + dp[1]) % P;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t\treturn 0;\n\t}\n\tint lim = n - 1;\n\tfor (int i = 1, j; i <= m; i = j) {\n\t\tfor (j = i; j <= m && s[j] == s[i]; ++j);\n\t\tif (s[i] == s[1]) continue;\n\t\tif (j - i & 1)\n\t\t\tlim = min(lim, j - i);\n\t\telse if (i == 1)\n\t\t\tlim = min(lim, j - i + 1);\n\t}\n\tdp[0] = 1;\n\tsum[0][0] = sum[0][1] = 1;\n\tsum[1][0] = sum[1][1] = 0;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tint d = max(0, i - lim - 1);\n\t\tdp[i] = (sum[i & 1][i - 2] - (d == 0 ? 0 : sum[i & 1][d - 1])) % P;\n\t\tsum[0][i] = sum[0][i - 1];\n\t\tsum[1][i] = sum[1][i - 1];\n\t\tsum[i & 1][i] = (sum[i & 1][i] + dp[i]) % P;\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i <= lim; ++i)\n\t\tans += sum[n & 1][n - (i + 1)] - (n == lim + 1 ? 0 : sum[n & 1][n - (lim + 1) - 1]);\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\tconst int N=2e5+9,mod=1e9+7;\n\tinline int add(int x,int y){return x+y>=mod?x-mod+y:x+y;}\n\tinline int sub(int x,int y){return x>=y?x-y:x+mod-y;}\n\tinline int qpow(int x,int y){\n\t\tint ret=1;\n\t\twhile(y){\n\t\t\tif(y&1) ret=1LL*x*ret%mod;\n\t\t\tx=1LL*x*x%mod,y>>=1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint n,m,f[N],sum[N];char s[N];\n\tint main(){\n\t\tn=read<int>(),m=read<int>(),scanf(\"%s\",s+1);\n\t\t\n\t\tint peg=1;\n\t\tfor(int i=2;i<=m;i++) if(s[1]!=s[i]) peg=0;\n\t\tif(peg){\n\t\t\tf[0]=1,f[1]=0,sum[0]=sum[1]=1;\n\t\t\tfor(int i=2;i<=n;i++)\n\t\t\t\tf[i]=sum[i-2],sum[i]=add(sum[i-1],f[i]);\n\t\t//\tfor(int i=1;i<=n;i++) cout<<f[i]<<\" \";cout<<endl;\n\t\t\tint ans=0;\n\t\t\tfor(int i=2;i<=n;i++) ans=add(ans,1LL*f[n-i]*i%mod);\n\t\t\tprintf(\"%d\\n\",add(ans,1));\n\t\t\treturn 0;\n\t\t}\n\t\tint mx=0,i,t;\n\t\tfor(i=1;i<=m;i++)\n\t\t\tif(s[i]!=s[1]){mx=i-1+(~(i-1)&1);break;}\n\t\tfor(t=0;i<=m;i++)\n\t\t\tif(s[i]!=s[1]){\n\t\t\t\tif(t&1) mx=min(mx,t);\n\t\t\t\tt=0;\n\t\t\t}else t++;\n\t\tif(t&1) mx=max(mx,t);\n\t\tcout<<mx<<endl;\n\n\t\tf[0]=1,f[1]=0,sum[0]=sum[1]=1;\n\t\tfor(i=2;i<=n;i++){\n\t\t\tf[i]=sub(sum[i-2],i-mx-2>=0?sum[i-mx-2]:0),sum[i]=sum[i-1];\n\t\t\tif(~i&1) sum[i]=add(sum[i],f[i]);\n\t\t}\n\t//\tfor(int i=1;i<=n;i++) cout<<f[i]<<\" \";cout<<endl;\n\t\tint ans=0;\n\t\tfor(int i=2;i<=mx+1;i++) if(~i&1) ans=add(ans,1LL*f[n-i]*i%mod);\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\ntypedef pair<int, int> P;\nconst long long inf = 1ll << 61;\nconst long long mod = 1000000007;\n\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (s[0] == 'B') {\n\t\trep(i, m) {\n\t\t\tif (s[i] == 'R')s[i] = 'B'; else s[i] = 'R';\n\t\t}\n\t}\n\tvector<int>r, b;\n\tchar now = 'R'; int cnt1 = 0;\n\ts.push_back('A');\n\trep(i, m+1) {\n\t\tif (now == s[i])cnt1++;\n\t\telse {\n\t\t\tif (now == 'R')r.push_back(cnt1);\n\t\t\telse b.push_back(cnt1);\n\t\t\tnow = s[i];\n\t\t\tcnt1 = 1;\n\t\t}\n\t}\n\ts.pop_back();\n\n\tif (b.empty()) {//全部一緒\n\t\tvector<int>L(200005);\n\t\tL[0] = 2; L[1] = 1;\n\t\trep(i, 200002)L[i + 2] = (L[i] + L[i + 1]) % mod;\n\t\tcout << L[n] << endl;\n\t\treturn 0;\n\t}\n\n\tif (n & 1) {\n\t\tcout << 0 << endl; return 0;\n\t}\n\telse {\n\t\tint MR = r[0];\n\t\tif (MR & 1)MR += 2;\n\t\telse MR += 1;\n\t\trep(i,r.size()-1){\n\t\t\tint e = r[i];\n\t\t\tif (e & 1)MR = min(MR, e);\n\t\t}\n\t\tMR = (MR + 1) / 2;\n\t\tvector<int>dp(200005);\n\t\tint s = 1, as = 1;\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= MR; i++) {\n\t\t\tdp[i] = (as + i) % mod;\n\t\t\tas = (as + dp[i]) % mod;\n\t\t}\n\t\tfor (int i = MR + 1; i <= n; i++) {\n\t\t\tdp[i] = as;\n\t\t\tas += dp[i];\n\t\t\tas -= dp[i - MR];\n\t\t\tas = (as + mod) % mod;\n\t\t}\n\t\tcout << (dp[n/2]*2)%mod << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    string s;\n    cin>>s;\n    if(s[0]=='B'){\n        for(int i=0;i<m;i++){\n            if(s[i]=='B'){s[i]='R';}\n            else{s[i]='B';}\n        }\n    }\n    ll l=0;\n    while(l<m && s[l]=='R'){l++;}\n    if(l==m){\n        ll ans=1;\n        vector<ll> dp(n,0);\n        vector<ll> sum(n,0);\n        dp[0]=sum[0]=1;\n        for(int i=2;i<n;i++){\n            dp[i]=sum[i-2];\n            sum[i]=dp[i]+sum[i-1];\n            sum[i]%=MOD;\n        }\n        for(ll i=2;i<=n;i++){\n            ans+=sum[n-i]*i%MOD;\n        }\n        ans%=MOD;\n        cout<<ans<<endl;\n        return 0;\n    }\n    if(n&1){cout<<(l==m?1:0)<<endl; return 0;}\n    ll mi=E;\n    if(l&1){mi=l;}\n    else{mi=l+1;}\n    for(ll i=l;i<m;i++){\n        if(s[i]=='R'){\n            ll w=i;\n            while(i<m && s[i]=='R'){i++;}\n            if(i!=m){\n                ll L=i-w;\n                if(L&1){mi=min(mi,L);}\n            }\n        }\n    }\n    vector<ll> dp(n,0);\n    vector<ll> sum(n,0);\n    dp[0]=sum[0]=1;\n    for(int i=2;i<n;i+=2){\n        ll r=sum[i-2];\n        ll l=(i-mi-3>=0?sum[i-mi-3]:0LL);\n        dp[i]=r-l;\n        dp[i]%=MOD;\n        sum[i]=sum[i-2]+dp[i];\n        sum[i]%=MOD;\n        //cout<<dp[i]<<\" \"<<sum[i]<<endl;\n    }\n    ll ans=0;\n    for(ll i=2;i<=mi+1 && n-i>=0;i++){\n        ans+=dp[n-i]*i%MOD;\n        ans%=MOD;\n    }\n    if(l==m){ans++;}\n    ans%=MOD;\n    if(ans<0){ans+=MOD;}\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n \n#include <algorithm>\n#include <tuple>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n \n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n \ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 200010, P = 1000000007;\n\nint n, m;\nchar s[N];\n\nvoid add(int& x, int y) {\n  if ((x += y) >= P)\n    x -= P;\n}\n\nvoid sub(int& x, int y) {\n  if ((x -= y) < 0)\n    x += P;\n}\n\nint norm(int x) {\n  return x >= P ? x - P : x;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n >> m >> (s + 1);\n  char a = s[1];\n  if (count(s + 1, s + m + 1, a) == m) {\n    static int dp[N][2][2];\n    dp[1][0][0] = dp[1][1][1] = 1;\n    for (int i = 2; i <= n; ++i)\n      for (int j = 0; j < 2; ++j) {\n        add(dp[i][j][0], dp[i - 1][j][0]);\n        add(dp[i][j][0], dp[i - 1][j][1]);\n        add(dp[i][j][1], dp[i - 1][j][0]);\n      }\n    int ans = norm(norm(dp[n][0][0] + dp[n][0][1]) + dp[n][1][0]);\n    cout << ans << '\\n';\n  }\n  int len = m;\n  int p = 1;\n  while (s[p] == a) ++p;\n  len = p - 1;\n  if (len % 2 == 0) ++len;\n  int cur = 0;\n  for (; p <= m; ++p)\n    if (s[p] != a) {\n      if (cur & 1)\n        len = min(len, cur);\n      cur = 0;\n    } else\n      ++cur;\n  if (cur & 1) len = min(len, cur);\n  static int dp[N], sum[N];\n  dp[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    sum[i - 1] = dp[i - 1];\n    if (i - 3 >= 0)\n      add(sum[i - 1], sum[i - 3]);\n    dp[i] = sum[i - 2];\n    if (i - len - 3 > 0)\n      sub(dp[i], sum[i - len - 3]);\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; ++i)\n    if ((n - i) <= len && ((n - i) & 1))\n      ans = ans + (dp[i] * (n - i + 1LL)) % P;\n  cout << ans << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#if __cplusplus >= 201103L\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\nint gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);}\n\n#define ll long long\n#define pb push_back\n#define ld long double\n#define mp make_pair\n#define F first\n#define S second\n#define pii pair<ll,ll> \n\nusing namespace :: std;\n\nconst ll maxn=2e5+500;\nconst ll mod=1e9+7;\nconst ll inf=1e9+9;\n\nll dp[maxn];\nll par[maxn];\nvoid update(ll a){\n\tif(a<2)par[a]=dp[a];\n\tpar[a]=(par[a-2]+dp[a])%mod;\t\n}\nll find_sum(ll l,ll r){\n\tif(!(l<=r))return 0;\n\tl=max(l,0LL);\n\tif(l%2!=r%2){\n\t\treturn find_sum(l+1,r);\n\t}\n\tif(l<2)return par[r];\n\treturn (par[r]-par[l-2]+mod)%mod;\n}\n\n\nll find_ans(ll n,ll s){\n\tif(s%2==0){\n\t\texit(1);\n\t}\n\tmemset(dp,0,sizeof dp);\n\tmemset(par,0,sizeof par);\n\n\tdp[0]=1;\n\tdp[1]=0;\n\tupdate(1);\n\tupdate(0);\n\tfor(ll i=2;i<=n;i++){\n\t\tdp[i]=find_sum(i-s-1,i-2);\n\t\tupdate(i);\n\t}\n\tll ans=0;\n\tfor(ll i=2;i<=n && i-1<=s;i++){\n\t\tll lp=0;\n\t\tif((i-1)%2==0)lp=1;\n\t\tll rp=s-i+1;\n\t\t\n\t\tll lw=n-i-rp;\n\t\tll rw=n-i-lp;\n\t\tif(lw%2!=rw || rp%2!=lp%2){\n\t\t\texit(1);\n\t\t}\n\t\tans+=find_sum(lw,rw);\n\t}\n\tans+=dp[n];\n\treturn ans%mod;\n}\nstring ok(string s,ll m){\n\tif(s[0]=='B'){\n\t\tfor(ll i=0;i<m;i++){\n\t\t\tif(s[i]=='B'){\n\t\t\t\ts[i]='R';\n\t\t\t}else{\n\t\t\t\ts[i]='B';\n\t\t\t}\n\t\t}\n\t}\n\treturn s;\n}\nint main(){\n\tll n,m;\n\tstring s;\n\tcin>>n>>m>>s;\n\ts=ok(s,m);\n\tvector<ll> vec;\n\tll res=0;\n\tfor(ll i=0;i<m;i++){\n\t\tif(s[i]=='R'){\n\t\t\tres++;\n\t\t}\n\t\tif(res!=0 && (i==m-1 || s[i]=='B')){\n\t\t\tvec.pb(res);\n\t\t\tres=0;\n\t\t}\n\t}\n\tll si=inf;\n\tif(vec[0]==m){\n\t\tdp[2]=1;\n\t\tdp[1]=1;\n\t\tfor(ll i=3;i<=n;i++){\n\t\t\tdp[i]=(dp[i-2]+dp[i-1])%mod;\n\t\t}\n\t\tll ans=1;\n\t\tfor(ll i=2;i<=n;i++){\n\t\t\tans+=dp[n-i+1];\n\t\t}\n\t\tans+=dp[n-1];\n\t\tcout<<ans%mod;\n\t\treturn 0;\n\t}\n\tfor(auto v:vec){\n\t\tif(v%2==1)si=min(si,v);\n\t}\n\tsi=min(si,vec[0]+1);\n\tcout<<find_ans(n,si)<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 1000000007\n#define MN 200000\nusing namespace std;\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nchar s[MN+5];\nint g[MN+5],n,m,R,all=1;\nvoid Dp1()//每个都有一个合法相连\n{\n    g[1]=1;int ans=1;\n    for(int i=2;i<=n;++i) g[i]=(g[i-1]+g[i-2])%mod;\n    for(int i=1;i<n;++i) ans=(ans+1LL*(g[i]-g[i-1]+mod)*(n-i+1))%mod;\n    printf(\"%d\",ans);\n}\nvoid Dp2()//长度为奇数且处于[1,R]\n{\n    int ans=0,first=1,R=n-1;\n    for(int i=1,j;i<=m;i=j)\n    {\n        for(j=i;j<=m&&s[j]==s[1];++j);\n        if(j>m) break;\n        int len=j-i;\n        if(len&1) R=min(R,len);\n        else first?R=min(R,len+1):0;\n        first=0;\n        for(;j<=m&&s[j]!=s[1];++j);\n    }\n    g[1]=1;\n    for(int i=3;i<=n;i+=2)\n    {\n        g[i]=(g[i-2]-g[max(0,i-R-3)]+mod)%mod;\n        g[i]=(g[i]+g[i-2])%mod;\n    }\n    for(int i=max(1,n-R);i<=n;i+=2) ans=(ans+1LL*(n-i+1)*(g[i]-g[max(0,i-2)]+mod))%mod;\n    printf(\"%d\",ans);\n}\nint main()\n{\n    R=n=read();m=read();scanf(\"%s\",s+1);\n    for(int i=1;i<=m;++i) if(s[i]!=s[1]) all=0;\n    if(all) Dp1();\n    else (n&1)?puts(\"0\"):(Dp2(),0);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nll modinv(ll a, ll m) {\n\tassert(m > 0);\n\tif (m == 1) return 0;\n\ta %= m;\n\tif (a < 0) a += m;\n\tassert(a != 0);\n\tif (a == 1) return 1;\n\treturn m - modinv(m, a) * m / a;\n}\n\ntemplate <int MOD_> struct modnum {\nprivate:\n\tint v;\npublic:\n\tstatic const int MOD = MOD_;\n\n\tmodnum() : v(0) {}\n\tmodnum(ll v_) : v(int(v_ % MOD)) { if (v < 0) v += MOD; }\n\texplicit operator int () const { return v; }\n\tfriend bool operator == (const modnum& a, const modnum& b) { return a.v == b.v; }\n\tfriend bool operator != (const modnum& a, const modnum& b) { return a.v != b.v; }\n\n\tmodnum operator ~ () const {\n\t\tmodnum res;\n\t\tres.v = modinv(v, MOD);\n\t\treturn res;\n\t}\n\n\tmodnum& operator += (const modnum& o) {\n\t\tv += o.v;\n\t\tif (v >= MOD) v -= MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator -= (const modnum& o) {\n\t\tv -= o.v;\n\t\tif (v < 0) v += MOD;\n\t\treturn *this;\n\t}\n\tmodnum& operator *= (const modnum& o) {\n\t\tv = int(ll(v) * ll(o.v) % MOD);\n\t\treturn *this;\n\t}\n\tmodnum& operator /= (const modnum& o) {\n\t\treturn *this *= (~o);\n\t}\n\n\tfriend modnum operator + (const modnum& a, const modnum& b) { return modnum(a) += b; }\n\tfriend modnum operator - (const modnum& a, const modnum& b) { return modnum(a) -= b; }\n\tfriend modnum operator * (const modnum& a, const modnum& b) { return modnum(a) *= b; }\n\tfriend modnum operator / (const modnum& a, const modnum& b) { return modnum(a) /= b; }\n};\n\nusing num = modnum<int(1e9)+7>;\n\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\tvector<int> q;\n\tfor(int i = 0; i < m; i++){\n\t\tq.push_back((s[i] == 'R') ^ (s[0] == 'R'));\n\t}\n\tint nonzero = 0;\n\tfor(int x : q){\n\t\tif(x > 0) nonzero = 1;\n\t}\n\tif(!nonzero){\n\t\tvector<num> fib = {0, 1};\n\t\twhile(fib.size() <= n+1){\n\t\t\tfib.push_back(fib[fib.size()-1] + fib[fib.size()-2]);\n\t\t}\n\t\tcout << int(fib[n+1] + fib[n-1]) << '\\n';\n\t\texit(0);\n\t}\n\tint constraint = 1e8;\n\tint cur = 0;\n\tint st = 1;\n\tfor(int x : q){\n\t\tif(x == 1){\n\t\t\tif(st){\n\t\t\t\tif(cur % 2 == 1){\n\t\t\t\t\tconstraint = min(constraint, cur);\n\t\t\t\t} else {\n\t\t\t\t\tconstraint = min(constraint, cur + 1);\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif(cur % 2 == 1){\n\t\t\t\t\tconstraint = min(constraint, cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur = 0;\n\t\t\tst = 0;\n\t\t} else {\n\t\t\tcur += 1;\n\t\t}\n\t}\n\tif(n & 1){\n\t\tcout << 0 << '\\n';\n\t\texit(0);\n\t}\n\tn /= 2;\n\tconstraint = (constraint + 1) / 2;\n\tvector<num> dp(n+1, 0);\n\tvector<num> dpsum(n+1, 0);\n\tdp[0] = 1;\n\tdpsum[0] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tdp[i] = dpsum[i-1];\n\t\tif(i-1-constraint >= 0) dp[i] -= dpsum[i-1-constraint];\n\t\tdpsum[i] = dpsum[i-1] + dp[i];\n\t}\n\tnum ans = 0;\n\tfor(int i = 1; i <= constraint; i++){\n\t\tif(i <= n){\n\t\t\tans += dp[n - i] * (2 * i);\n\t\t}\n\t}\n\tcout << int(ans) << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n\nconst int mod=1e9+7;\n\nvoid U(int &x,int y){\n    x=(x+y)%mod;\n}\n\nint n, m, a[202000];\nchar s[202000];\n\nint main(){\n    cin>>n>>m>>s+1;\n    for (int i=1;i<=m;++i)\n        a[i]= s[i]==s[1];\n    if (*min_element(a+1,a+m+1)==1){\n        static int f[202000][2][2];\n        f[1][0][0]=f[1][1][1]=1;\n        for (int i=1;i<n;++i){\n            for (int s=0;s<=1;++s)\n                for (int t=0;t<=1;++t)\n                    for (int tt=0;tt<=1;++tt){\n                        if (t==0&&tt==0) continue;\n                        U(f[i+1][s][tt],f[i][s][t]);\n                    }\n        }\n        int ans=(1ll*f[n][0][1]+f[n][1][0]+f[n][1][1])%mod;\n        cout<<ans<<endl;\n        return 0;\n    }\n    int las=0, mx=1e9; vector<int>vec;\n    for (int i=1;i<=m;++i)\n        if (a[i]){\n            ++las;\n        }else{\n            vec.push_back(las);\n            las=0;\n        }\n    {\n        int t=vec.front(); vec.erase(vec.begin());\n        mx=min(mx,(t&1? t: t+1));\n    }\n    for (auto t:vec){\n        if (t&1) mx=min(mx,t);\n    }\n\n\n    static int ans=0, f[202000], sum[202000];\n    f[1]=sum[1]=1;\n    for (int i=1;i<=n;++i){\n        if (i!=1){\n            f[i]=(sum[i-2]-sum[max(0,i-mx-3)]+mod)%mod;\n            sum[i]=(sum[i-2]+f[i])%mod;\n        }\n        if ((n-i&1)&&n-i<=mx){\n            ans=(ans+(ll)f[i]*(n-i+1))%mod;\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline tuple<int, int, int> extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nunsigned ModInt::MOD = 1000000007;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\n\nvector<mint> Fact, InvFact;\nvoid makeFact(int n){\n\tFact = vector<mint>(n+1);\n\tFact[0] = mint(1);\n\trep(i,1,n+1) Fact[i] = mint(i) * Fact[i-1];\n\n\tInvFact = vector<mint>(n+1);\n\tInvFact[n] = mint(1) / Fact[n];\n\trrep(i,n) InvFact[i] = mint(i+1) * InvFact[i+1];\n}\n\nmint Factorial(int n){ return Fact[n];}\nmint InverseFactorial(int n){ return InvFact[n];}\nmint Permutation(int n,int k){ return (n < 0 or k < 0 or n - k < 0) ? ZERO : Fact[n] * InvFact[n - k];}\nmint Combination(int n,int k){ return (n < 0 or k < 0 or n - k < 0) ? ZERO : Fact[n] * InvFact[k] * InvFact[n-k];}\n\n\nconst int limit = 200010;\nmint dp[limit][2][2];\nmint dp2[limit];\nmint csum2[limit];\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\n\tmakeFact(2 * limit);\n\n\tbool same = true;\n\trep(i, n) if(s[0] != s[i]) same = false;\n\n\tif(same){\n\t\tdp[1][0][0] = ONE;\n\t\tdp[1][1][1] = ONE;\n\t\trep(i, 1, n) rep(start, 2) rep(prv, 2){\n\t\t\tdp[i + 1][start][0] += dp[i][start][prv];\n\t\t\tif(prv == 0) dp[i + 1][start][1] += dp[i][start][prv];\n\t\t}\n\t\tmint ans = dp[n][0][0] + dp[n][0][1] + dp[n][1][0];\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\t\t\n\tif(n % 2 == 1){\n\t\tcout << ZERO << endl;\n\t\treturn 0;\n\t}\n\n\tint cmin = n, cons = 0;\n\trep(i, n){\n\t\tif(s[i] == s[0]){\n\t\t\tcons++;\n\t\t} else {\n\t\t\tchmin(cmin, cons);\n\t\t}\n\t}\n\n\tif(cmin % 2 == 0) cmin++;\n\tdp2[1] = csum2[1] = ONE;\n\n\trep(i, 1, n){\n\t\tconst int pos = max(i - cmin - 1, 0);\n\t\tif((i + 1) % 2 == 1) dp2[i + 1] =  csum2[i] - csum2[pos];\n\t\tcsum2[i + 1] = csum2[i] + dp2[i + 1];\n\t}\n\n\tmint ans = ZERO;\n\n\trep(i, n - cmin, n + 1){\n\t\tif(n - i % 2 == 0) continue;\n\t\tconst mint coef = mint(n - i + 1);\n\t\tans += coef * dp2[i];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: E.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define int long long\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nchar s[200005];\nint f[200005],g[200005];\nconst int p=1000000007;\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint n,m;\n\tread(n,m);\n\tread(s+1);\n\tchar fir=s[1];\n\tint mn=inf;\n\tfor(int i=1,j=1;i<=m;i=j){\n\t\twhile(s[i]==s[j])++j;\n\t\tif(s[i]==fir){\n\t\t\tif(i==1)chkmin(mn,j-i+(!((j-i)&1)));\n\t\t\telse if((j-i)&1)chkmin(mn,j-i);\n//\t\t\tchkmin(mn,j-i);\n\n\t\t}\n\n\t}\n\tif(mn>=m){\n\t\tf[0]=1;\n\t\tint s=0;\n\t\tfor(int i=2;i<=n;++i){\n\t\t\tf[i]=(s+i-f[i-1])%p;\n\t\t\t(s+=f[i])%=p;\n\t\t}\n\t\twrite(f[n]+1,'\\n');\n\t}\n\telse{\n\t\tif(n&1)return write(\"0\\n\");\n\t\tf[0]=1;\n\t\t++mn;\n\t\tg[0]=1;\n\t\tfor(int i=2;i<=n;i+=2){\n\t\t\tf[i]=(g[i-2]-g[i-min(i,mn+2)]+p)%p;\n//\t\t\tfor(int j=2;j<=mn && j<i;j+=2)f[i]+=f[i-j];\n\t\t\tif(i<=mn)(f[i]+=i)%=p;\n\t\t\tg[i]=(f[i]+g[i-2])%p;\n\t\t}\n\t\twrite(f[n],'\\n');\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 1000000007;\n\nconst long long MOD_CONST = 1000000007;\nlong long mul_mod(long long a, long long b, const long long MOD) {\n  return b ? (mul_mod(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow_mod(long long a, long long b, const long long MOD) {\n  return (b ? bpow_mod(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv_mod(long long a, const long long MOD) {\n  return bpow_mod(a, MOD - 2, MOD);\n}\ntemplate <long long param = MOD_CONST, bool fast = false>\nclass mint {\n private:\n  using Z = int;\n  using N = unsigned int;\n  using ZZ = long long;\n  using NN = unsigned long long;\n  struct {\n  } constexpr static exact{};\n  // Using Z deliberately to avoid Z -> N promotion.\n  template <class Ret = ZZ&>\n  static auto modulo() -> std::enable_if_t<(param <= 0), Ret> {\n    static ZZ mod = 0;\n    return mod;\n  }\n  template <class Ret = const ZZ>\n  static auto mod() -> std::enable_if_t<(param <= 0), Ret> {\n    return modulo();\n  }\n  template <class Ret = const ZZ>\n  static constexpr auto mod() -> std::enable_if_t<(param > 0), Ret> {\n    return param;\n  }\n\n public:\n  template <class Arg = ZZ>\n  static void set_modulo(const std::enable_if_t<(param <= 0), Arg> mod) {\n    modulo() = mod;\n  }\n  long long v;\n\n  constexpr mint() : v(0) {}\n\n  constexpr mint(long long v)\n      : v(fast ? (v)\n               : (v < 0 ? (v % mod() + mod()) % mod()\n                        : (v >= mod() ? v % mod() : v))) {}\n  constexpr long long get_mod() { return mod(); }\n  long long get_val() { return v; }\n  void take_mod() { v %= mod(); }\n};\ntemplate <long long param, bool fast>\nostream& operator<<(ostream& os, mint<param, fast>& x) {\n  return os << (x.v % x.get_mod() + x.get_mod()) % x.get_mod();\n}\n\ntemplate <long long param, bool fast, bool fast2>\nbool operator==(mint<param, fast>& a, mint<param, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast>& operator+=(mint<param, fast>& a, mint<param, fast2> b) {\n  return a = a.v + b.v;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, mint<param> b) {\n  return a = a.v - b.v;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, mint<param> b) {\n  return a = a.v * b.v;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, mint<param> b) {\n  return a = a.v * inv_mod(b.v, a.get_mod());\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast> operator+(mint<param, fast> a, mint<param, fast2> b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, mint<param> b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, mint<param> b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, mint<param> b) {\n  return a /= b;\n}\ntemplate <long long param, bool fast>\nmint<param, fast>& operator+=(mint<param, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, long long b) {\n  return a = a.v * inv_mod(b, a.get_mod());\n}\ntemplate <long long param, bool fast>\nmint<param, fast> operator+(mint<param> a, long long b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, long long b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, long long b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, long long b) {\n  return a /= b;\n}\n\nvoid special(int N) {\n  vector<mint<>> vals = {mint<>(1), mint<>(1)};\n  for (int i = 0; i < N; i++) {\n    int sz = vals.size();\n    vals.push_back(vals[sz - 1] + vals[sz - 2]);\n  }\n  mint<> ans = vals[N] + vals[N - 2];\n  cout << ans << endl;\n}\n\nint con(string& S, char t) {\n  int ans = 1000000;\n  int cur = 0;\n  for (auto c : S) {\n    if (c == t)\n      cur++;\n    else {\n      if (cur != 0) ans = min(ans, cur);\n      cur = 0;\n    }\n  }\n  return ans;\n}\n\nmint<> calcDP(int N, int conB, int conR) {\n  vector<mint<>> dpR(N + 2, mint<>(0));\n  vector<mint<>> dpB(N + 2, mint<>(0));\n  vector<mint<>> sumR(N + 2, mint<>(0));\n  vector<mint<>> sumB(N + 2, mint<>(0));\n  dpR[1] = 1;\n  sumR[1] = 1;\n  for (int i = 2; i <= N + 1; i++) {\n    if (i % 2 == 1) {\n      dpR[i] = sumB[i - 1] - sumB[max(0, i - conB - 1)];\n      // if (i <= conB) dpR[i] += 1;\n\n    } else\n      dpB[i] = sumR[i - 1] - sumR[max(0, i - conR - 1)];\n    sumB[i] = sumB[i - 1] + dpB[i];\n    sumR[i] = sumR[i - 1] + dpR[i];\n  }\n  mint<> ans = 0;\n  for (int i = 0; i < min(N, conB + 1); i++) {\n    ans += sumR[N - i] - sumR[max(0, N - conB - 1)];\n  }\n  return ans;\n}\n\nvoid solve(long long N, long long M, std::string S) {\n  int cntB = 0;\n\n  int conR = con(S, 'R');\n  int conB = con(S, 'B');\n  for (int i = 0; i < M; i++) {\n    if (S[i] == 'B') cntB++;\n  }\n  if (cntB == M || cntB == 0) {\n    special(N);\n    return;\n  }\n  if (N % 2 == 1) {\n    cout << 0 << endl;\n    return;\n  }\n  if (S[0] == 'R') swap(conR, conB);\n  conR = 1;\n  if (conB % 2 == 0) conB++;\n  // if (conR % 2 == 0) conR--;\n\n  mint<> ans = calcDP(N, conB, conR);\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long M;\n  scanf(\"%lld\", &M);\n  std::string S;\n  std::cin >> S;\n  solve(N, M, S);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n  \n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n  \n  Mint inv(){return pow(MOD-2);}\n  \n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n  \n  Mint operator+(Mint a) const{return Mint(v)+=a;};\n  Mint operator-(Mint a) const{return Mint(v)-=a;};\n  Mint operator*(Mint a) const{return Mint(v)*=a;};\n  Mint operator/(Mint a) const{return Mint(v)/=a;};\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  // find x s.t. a^x = b\n  static T log(Mint a,Mint b){\n    const T sq=40000;\n    unordered_map<T, T> dp;\n    dp.reserve(sq);\n    Mint res(1);\n    for(Int r=0;r<sq;r++){\n      if(!dp.count(res.v)) dp[res.v]=r;\n      res*=a;\n    }\n    Mint p=a.inv().pow(sq);\n    res=b;\n    for(Int q=0;q<=MOD/sq+1;q++){\n      if(dp.count(res.v)){\n        T idx=q*sq+dp[res.v];\n        if(idx>0) return idx;\n      }\n      res*=p;\n    }\n    assert(0);\n    return T(-1);\n  }\n  \n  static Mint comb(long long n,Int k){\n    Mint res(1);\n    for(Int i=0;i<k;i++){\n      res*=Mint(n-i);\n      res/=Mint(i+1);\n    }\n    return res;\n  }\n};\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\n\n//INSERT ABOVE HERE\n\nsigned main(){\n  using M = Mint<Int>;\n \n  Int n,m;\n  cin>>n>>m;\n\n  string s;\n  cin>>s;\n\n  vector<Int> vs(m);\n  for(Int i=0;i<m;i++)\n    vs[i]=(s[0]!='R')^(s[i]=='R');\n\n  Int flg=1;  \n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n    flg&=(j-i)%2==0; \n    i=j-1;\n  }\n  \n  if(flg){    \n    auto dp=make_v<M>(2,2,n+1);\n    fill_v<M>(dp,M(0));\n    dp[0][0][1]=M(1);\n    dp[1][1][1]=M(1);\n\n    for(Int i=1;i<n;i++)\n      for(Int j=0;j<2;j++)\n        for(Int k=0;k<2;k++)\n          for(Int l=0;l<2;l++)\n            if(k||l) dp[j][l][i+1]+=dp[j][k][i];    \n\n    M ans{0};\n    for(Int j=0;j<2;j++)\n      for(Int k=0;k<2;k++)\n        if(j||k) ans+=dp[j][k][n];\n\n    cout<<ans.v<<endl;\n    return 0;\n  }\n  assert(vs!=vector<Int>(m,0));\n\n  if(n&1){\n    cout<<0<<endl;\n    return 0;\n  }\n  \n  Int lim=n-1;  \n  for(Int i=0;i<m;i++){\n    if(s[i]=='B') continue;\n    Int j=i;\n    while(j<m&&s[j]=='R') j++;\n    if(j==m) break;\n\n    if(i==0&&(j-i)%2==0) chmin(lim,j-i+1);\n    if((j-i)&1) chmin(lim,j-i);    \n    i=j-1;\n  }\n  \n  vector<M> dp(n+2,0),sm(n+2,0);\n  dp[1]=M(1);  \n  for(Int i=2;i<=n+1;i++){\n    sm[i]=sm[i-1]+dp[i-1];\n    if(i&1) dp[i]=sm[i-1]-sm[max<Int>(1,i-1-lim)];\n  }\n  \n  M ans{0};\n  for(Int i=0;i<=lim;i++)\n    ans+=sm[n-i+1]-sm[max<Int>(1,n-lim)];\n  \n  cout<<ans.v<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1000000007;\nint n, m, dp[200005], sum[2][200005];\nchar s[200005];\n\nint main() {\n\tscanf(\"%d%d%s\", &n, &m, s + 1);\n\tif (count(s + 1, s + 1 + m, s[1]) == m) {\n\t\tif (n == 1) return puts(\"1\"), 0;\n\t\tint ans = 0;\n\t\tfor (int c = 0; c < 2; ++c) {\n\t\t\tint dp[2] = {};\n\t\t\tdp[c] = 1;\n\t\t\tfor (int i = 2; i <= n; ++i) {\n\t\t\t\tint t = dp[1];\n\t\t\t\tdp[1] = dp[0];\n\t\t\t\tdp[0] = (dp[0] + t) % P;\n\t\t\t}\n\t\t\tans = (ans + dp[0]) % P;\n\t\t\tif (!c) ans = (ans + dp[1]) % P;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t\treturn 0;\n\t}\n\tint lim = n - 1;\n\tfor (int i = 1, j; i <= m; i = j) {\n\t\tfor (j = i; j <= m && s[j] == s[i]; ++j);\n\t\tif (j > m || s[i] != s[1]) continue;\n\t\tif (j - i & 1)\n\t\t\tlim = min(lim, j - i);\n\t\telse if (i == 1)\n\t\t\tlim = min(lim, j - i + 1);\n\t}\n\tdp[0] = 1;\n\tsum[0][0] = sum[0][1] = 1;\n\tsum[1][0] = sum[1][1] = 0;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tint d = max(0, i - lim - 1);\n\t\tdp[i] = (sum[i & 1][i - 2] - (d == 0 ? 0 : sum[i & 1][d - 1])) % P;\n\t\tsum[0][i] = sum[0][i - 1];\n\t\tsum[1][i] = sum[1][i - 1];\n\t\tsum[i & 1][i] = (sum[i & 1][i] + dp[i]) % P;\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i <= lim; ++i)\n\t\tans += sum[n & 1][n - (i + 1)] - (n == lim + 1 ? 0 : sum[n & 1][n - (lim + 1) - 1]);\n\tprintf(\"%lld\\n\", (ans % P + P) % P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact, _inv;\n\n  Combination(ll sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for(ll i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(ll i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for(ll i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(ll k) const { return _fact[k]; }\n\n  inline T rfact(ll k) const { return _rfact[k]; }\n\n  inline T inv(ll k) const { return _inv[k]; }\n\n  T P(ll n, ll r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n\n  T H(ll n, ll r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\nusing modint = ModInt< MOD1 >;modint pow(ll n, ll x){return modint(n).pow(x);}modint pow(modint n, ll x){return n.pow(x);}\n//using modint=ld;\nusing Comb=Combination<modint>;\n\n\ntemplate<typename T>\nstruct BIT{\n  ll n;\n  ll k=1;\n  vector<T>data;\n  BIT() = default;\n  BIT(ll size):n(size){\n    data.assign(n,0);\n    while(k*2<=n)k*=2;\n  }\n  void add(ll a,T w){\n    for(ll i=a+1;i<=n;i+=i&-i)data[i-1]+=w;\n  }\n  T sum(ll a){\n\tif(a<0)return 0;\n    T ret = 0;\n    for(ll i=a+1;i>0;i-=i&-i)ret+=data[i-1];\n    return ret;\n  }\n  T sum(ll a,ll b){return a>b?0:sum(b)-sum(a-1);}\n  T operator[](ll pos){\n    return sum(pos,pos);\n  }\n  ll lower_bound(ll x){\n    ll ret=0;    \n    for(ll i=k;i>0;i/=2){\n      if(ret+i<=n&&data[ret+i-1]<x){\n        x-=data[ret+i-1];\n        ret+=i;\n      }\n    }\n    return ret;\n  }\n  void print(){\n    for(ll i=0;i<n;i++){\n      if(i!=0)cout<<\" \";\n      cout<<(*this)[i];\n    }\n    cout<<endl;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,m;cin>>n>>m;\n  string s;cin>>s;\n  if(s[0]=='B'){\n    rep(i,0,m){\n      if(s[i]=='R')s[i]='B';\n      else s[i]='R';\n    }\n  }\n  ll mx=INF;\n  {\n    vector<ll>v;\n    ll cnt=0;\n    rep(i,0,m){\n      if(s[i]=='R')cnt++;\n      else{\n        v.PB(cnt);\n        cnt=0;\n      }\n    }\n    if(v.empty()){\n      modint tmp=0;\n      Comb comb(300005);\n      rep(i,0,n+1){\n        tmp+=comb.C(n-i-1,i-1)*2+comb.C(n-i-1,i);\n      }\n      cout<<tmp<<endl;\n      return 0;\n    }\n    rep(i,0,v.size()){\n      if(i==0||v[i]&1)chmin(mx,v[i]);\n    }\n    if(~mx&1)mx++;\n  }\n  vector<modint>v(n+1);\n  BIT<modint>bit(n+1);\n  bit.add(0,1);\n  rep(i,0,n){\n    if(~i&1)continue;\n    bit.add(i+1,bit.sum(max(0LL,i-mx),i));\n  }\n  modint ret=0;\n  rep(i,0,n+1){\n    ret+=bit.sum(max(0LL,n-mx-1),n-i-1);\n    //cout<<n-mx-1 spa n-i spa bit.sum(n-mx-1,n-i)<<endl;\n  }\n  //bit.print();\n  //debug(v,n+1);\n  cout<<ret<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=a*b%mod\n\nll n,m;\nstring s;\nint main(){\n    cin>>n>>m>>s;\n    if(s[0]=='R'){\n\tfor(int i=0;i<n;i++){\n\t    if(s[i]=='R')s[i]='B';\n\t    else s[i]='R';\n\t}\n    }\n    bool th=0;\n    ll cnt=0,mi=1e17;\n    bool fi=1; ll lead;\n    for(int i=0;i<n;i++){\n\tif(s[i]=='R'){\n\t    if(fi)lead=cnt; fi=0;\n\t    th=1;\n\t    if(cnt%2==1)chmin(mi,cnt);\n\t    cnt=0;\n\t}\n\telse cnt++;\n    }\n    if(th==0){\n\tll f[200010];\n\tf[0]=f[1]=1;\n\tfor(int i=2;i<n;i++){\n\t    f[i]=(f[i-1]+f[i-2])%mod;\n\t}\n\tll ans=(f[n-2]*2+f[n-1])%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n    }\n    if(n%2==1){\n\tcout<<0<<endl;\n\treturn 0;\n    }\n    if(lead%2==0)lead++;\n    chmin(mi,lead);\n    mi=(mi+1)/2;\n    chmin(mi,n/2);\n    ll f[200010],rui[200010];\n    f[0]=rui[0]=0;\n    for(ll i=1;i<=mi;i++){\n\tf[i]=i;\n\trui[i]=(rui[i-1]+i)%mod;\n    }\n    for(int i=1;i<n/2;i++){\n\tmad(f[i],rui[i-1]);\n\tif(i-mi-1>=0)mad(f[i],-rui[i-mi-1]);\n\trui[i]=(rui[i-1]+f[i])%mod;\n    }\n    ll ans=0;\n    for(int i=1;i<=mi;i++)mad(ans,f[n/2-i]);\n    //cout<<mi<<endl;\n    //for(int i=0;i<n/2;i++)cout<<i<<\":\"<<f[i]<<endl;\n    ans=ans*2%mod;\n    if(ans<0)ans+=mod;\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint n, m;\nstring s;\nint dp[212123];\nint dpsum[212123];\nbool nonmono;\n\n// msize EVEN\nvoid non(int msize) {\n\tassert(msize % 2 == 0);\n\tdp[0] = 1;\n\tdpsum[0] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tdp[i] = dpsum[i-2];\n\t\tif (i-msize-2 >= 0) {\n\t\t\tdp[i] += MOD - dpsum[i-msize-2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tdpsum[i] = dp[i] + dpsum[i-2];\n\t}\n\tint ans = dp[n];\n\tfor (int i = 1; i < n; i++) {\n\t\t// first colour must be i + 1 + evener\n\t\tint x = i + 1;\n\t\tif (x % 2 != 0) x++;\n\t\t// x now even\n\t\tif (x > msize) break;\n\t\tans = (ans + dpsum[n-x]) % MOD;\n\t\tif (n-msize-2 >= 0) {\n\t\t\tans += MOD - dpsum[n-msize-2];\n\t\t\tans %= MOD;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n}\n\nvoid mono() {\n\tdp[0] = 1;\n\tdpsum[0] = 1;\n\tdpsum[1] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tdp[i] = dpsum[i-2];\n\t\tdpsum[i] = (dpsum[i-1] + dp[i]) % MOD;\n\t}\n\tint ans = dp[n] + 1;\n\tfor (int i = 0; i <= n-2; i++) {\n\t\tans = (ans + dpsum[i]) % MOD;\n\t}\n\tcout << ans << '\\n';\n}\n\nint main() {\n\tcin >> n >> m >> s;\n\tfor (int i = 1; i < m; i++) {\n\t\tif (s[i] != s[0]) {\n\t\t\tnonmono = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (nonmono) {\n\t\tint msize = n;\n\t\tif (msize % 2 == 1) msize--;\n\t\tint fcur = -1;\n\t\tint cur = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (s[i] == s[0]) cur++;\n\t\t\telse if (cur) {\n\t\t\t\tif (fcur == -1) fcur = cur;\n\t\t\t\tif (cur % 2 == 1) {\n\t\t\t\t\tcur++;\n\t\t\t\t\tmsize = min(msize, cur);\n\t\t\t\t}\n\t\t\t\tcur = 0;\n\t\t\t}\n\t\t}\n\t\tfcur += 2;\n\t\tif (fcur % 2 == 1) fcur--;\n\t\tmsize = min(fcur, msize);\n\t\t//cout << msize << '\\n';\n\t\tnon(msize);\n\t} else {\n\t\tmono();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-03 17:07:09\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=200010,mod=1000000007;\nint n,m,flag,l,Flag;\ni64 f[N],F[N],ans;\nchar s[N];\nint main()\n{\n\tn=read(); m=read();\n\tscanf(\"%s\",s+1);\n\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\tif(!flag)\n\t{\n\t\tf[0]=1; f[1]=1; f[2]=2;\n\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t\treturn 0;\n\t}\n\tl=n-1;\n\tfor(int i=1,j;i<=m;)\n\t\tif(s[i]==s[1])\n\t\t{\n\t\t\tj=i;\n\t\t\twhile(s[j]==s[1]) j++;\n\t\t\tif(j>n) break;\n\t\t\tif(((j-i)&1)||(!Flag)) l=std::min(l,(j-i)+(!((j-i)&1)));\n\t\t\ti=j+1; Flag=1;\n\t\t}\n\t\telse i++;\n\tif(n&1){ printf(\"0\\n\"); return 0; }\n\tn/=2; l=(l+1)/2;\n//\tprintf(\"%d %d\\n\",int(n),int(l));\n\tf[0]=F[0]=1;\n\tfr(i,1,n)\n\t{\n\t\tf[i]=(F[i-1]+mod-(i-l-1>=0?F[i-l-1]:0))%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t}\n\tans=f[n];\n\tif(l==n) return 1;\n\tfr(i,1,l) ans=(ans+f[n-i]*(2*i-1))%mod;\n\tprintf(\"%d\\n\",int(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+10;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n    {\n        exit(1);\n        return 0;\n    }\n    lim = min(lim,(ll)n-1);\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    ans = dp[n+1];\n    for(ll i = 1;i<=lim;i+=2)\n    {\n        ans += (i*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    int mn = 1e9;\n    if (vc[0]%2==0)\n        mn = vc[0]+1;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc()) \n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int MOD = (int)(1e9 + 7);\ninline void Add(int& x,int y) {\n  x = x + y >= MOD ? x + y - MOD : x + y;\n}\ninline void Sub(int& x,int y) {\n  x = x - y < 0 ? x - y + MOD : x - y;\n}\nint power(int a,int b) {\n  int ret = 1;\n  while (b) {\n    if (b&1) ret = 1ll * ret * a % MOD;\n    a = 1ll * a * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\n\nconst int N = 200010;\nint n, m, arr[N], acnt;\nchar str[N];\nint dp[N];\nvoid doit(int lim) {\n  if (n%2) {\n    puts(\"0\");\n    return;\n  }\n  lim = (lim + 1) / 2;\n  rep (i, 1, n/2) {\n    Add(dp[i], dp[i-1]);\n    if (i-lim-1 >= 1)\n      Sub(dp[i], dp[i-lim-1]);\n    if (i <= lim) Add(dp[i], 2 * i);\n    Add(dp[i], dp[i-1]);\n  }\n  int ans = dp[n/2];\n  Sub(ans, dp[n/2-1]);\n  printf(\"%d\\n\", ans);\n}\nint main() {\n  read(n), read(m);\n  scanf(\"%s\", str+1);\n  if (str[1] == 'R') {\n    rep (i, 1, m) {\n      if (str[i] == 'R') str[i] = 'B';\n      else str[i] = 'R';\n    }\n  }\n  int key = 1;\n  rep (i, 2, m) if (str[i] == 'R') key = 0;\n  if (key) {\n    dp[0] = 1, dp[1] = 2;\n    rep (i, 2, n) dp[i] = (dp[i-1] + dp[i-2]) % MOD;\n    int ans = dp[n];\n    if (n >= 3) Sub(ans, dp[max(0, n - 4)]);\n    printf(\"%d\\n\", ans);\n    return 0;\n  }\n  for (int i = 1, j = 0; i <= m; ++ i) {\n    if (str[i] == 'B') {\n      ++ j;\n      if (str[i+1] == 'R' && i <= m)\n\tarr[++ acnt] = j;\n    }\n    else j = 0;\n  }\n  int lim = n;\n  rep (i, 2, acnt) {\n    if (arr[i] % 2 != 0)\n      lim = min(lim, arr[i]); \n  }\n  lim = min(lim, arr[1] + 1);\n  doit(lim);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+10;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    ans = dp[n+1];\n    for(ll i = 1;i<=lim;i+=2)\n    {\n        ans += (i*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    int mn = 1e9;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\ntemplate<typename T>\nstruct SegmentTree{\nprivate:\n    int n;\n    T E;\n    vector<T> node;\n    inline void updatef(T& x,T& y){\n        x = y;\n        //x += y;\n        //x = max(x,y);\n        //x = min(x,y);\n    }\n    inline T queryf(T& x,T& y){\n        //return x*y;\n        return (x+y)%mod;\n        //return max(x,y);\n        //return min(x,y);\n    }\n\npublic:\n    SegmentTree(int sz,T E_):E(E_){\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n    }\n\n    SegmentTree(vector<T>& A,T E_):E(E_){\n        int sz=A.size();\n        n=1;\n        while(n<sz)n<<=1;\n        node.resize(2*n-1,E);\n        rep(i,sz)node[i+n-1]=A[i];\n        for(int i=n-2;i>=0;--i){\n            node[i]=queryf(node[2*i+1], node[2*i+2]);\n        }\n    }\n    void update(int k,T x){\n        k+=n-1;\n        updatef(node[k],x);\n        while(k>0){\n            k=(k-1)/2;\n            node[k]=queryf(node[2*k+1], node[2*k+2]);\n        }\n    }\n       //[a,b)での和を返す\n    T get(int a,int b,int k=0,int l=0,int r=-1){\n        if(r<0)r=n;\n        if(r<=a||b<=l)return E;\n        if(a<=l&&r<=b)return node[k];\n        T xl=get(a,b,2*k+1,l,(l+r)/2);\n        T xr=get(a,b,2*k+2,(l+r)/2,r);\n        return queryf(xl, xr);\n    }\n};\n\nvector<ll> inv,fact,invfact;\nvoid mod_build(int n=101010){\n    fact.resize(n+1);\n    inv.resize(n+1);\n    invfact.resize(n+1);\n    fact[0]=inv[0]=invfact[0]=1;\n    inv[1]=1;\n    rep(i,n){\n        fact[i+1]=fact[i]*(i+1)%mod;\n        if(i>0)inv[i+1]=mod-inv[mod%(i+1)]*(mod/(i+1))%mod;\n        invfact[i+1]=invfact[i]*inv[i+1]%mod;\n    }\n}\nll perm(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*invfact[n-k]%mod;\n}\nll comb(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return (fact[n]*invfact[n-k]%mod)*invfact[k]%mod;\n}\nll powmod(ll n,ll k){\n    k%=mod-1;\n    if(k<0)k+=mod-1;\n    ll ret=1;\n    while(k){\n        if(k&1)ret=ret*n%mod;\n        n=n*n%mod;\n        k>>=1;\n    }\n    return ret;\n}\nint main(){\n    int n,m;\n    cin>>n>>m;\n    string s;\n    cin>>s;\n    int len=0;\n    while(len<m&&s[len]==s[0])++len;\n    if(len==m){\n        vector<ll> ans(n+1);\n        ans[0]=2,ans[1]=1;\n        rep(i,n-1)ans[i+2]=(ans[i+1]+ans[i])%mod;\n        cout<<ans[n]<<endl;\n        return 0;\n    }\n    if(n%2){\n        cout<<0<<endl;\n        return 0;\n    }\n    if (len%2==0)++len;\n    int cnt=0;\n    rep(i,n){\n        if(s[i]!=s[0]){\n            if(cnt%2)len=min(len,cnt);\n            cnt=0;\n        }\n        else ++cnt;\n    }\n    n/=2;\n    len = (len+1)/2;\n    SegmentTree<ll> sg(n+5,0);\n    sg.update(0,1);\n    rep(i,n+1){\n        ll ret=sg.get(max(0,i+1-len),i+1);\n        sg.update(i+1,ret);\n    }\n    ll ans=0;\n    rep(i,max(n,len)){\n        ans+=sg.get(max(0,n-len),n-i);\n    }\n    cout<<2*ans%mod<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Dmitry _kun_ Sayutin (2019)\n\n#include <bits/stdc++.h>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::tuple;\nusing std::make_tuple;\nusing std::get;\n\nusing std::min;\nusing std::abs;\nusing std::max;\nusing std::swap;\n\nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n\n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n\ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n\ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n\n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n\nconst int mod = 1000 * 1000 * 1000 + 7;\nint add(int a, int b) {\n    return (a + b >= mod ? a + b - mod : a + b);\n}\n\nint sub(int a, int b) {\n    return (a >= b ? a - b : mod + a - b);\n}\n\nint mult(int a, int b) {\n    return (int64_t(a) * b) % mod;\n}\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    // code here\n    int n = input<int>();\n    int m = input<int>();\n    \n    string s = input<string>();\n\n    if (s[0] == 'B')\n        for (int i = 0; i != m; ++i)\n            s[i] = ('R' + 'B' - s[i]);\n\n    if (std::find(ALL(s), 'B') == s.end()) {\n        int ans = 0;\n        \n        for (int fst = 0; fst != 2; ++fst) {\n            pair<int, int> cur_dp = {0, 0};\n\n            if (fst == 0)\n                cur_dp.first += 1;\n            else\n                cur_dp.second += 1;\n\n            for (int i = 0; i != n - 1; ++i) {\n                pair<int, int> newdp = {0, 0};\n                newdp.first = cur_dp.second;\n                newdp.second = add(cur_dp.first, cur_dp.second);\n\n                cur_dp = newdp;\n            }\n\n            if (fst == 1)\n                ans = add(ans, add(cur_dp.first, cur_dp.second));\n            else\n                ans = add(ans, cur_dp.second);\n        }\n\n        cout << ans << \"\\n\";\n        return 0;\n    } else {\n        vector<int> lens = {1};\n        assert(s[0] == 'R');\n\n        for (int i = 1; i != m; ++i)\n            if (s[i] == 'R' and s[i - 1] == 'R')\n                lens.back() += 1;\n            else if (s[i] == 'R')\n                lens.push_back(1);\n\n        int limit = 1000 * 1000 * 1000 + 1;\n        \n        for (int len: lens)\n            if (len % 2 == 0)\n                limit = min(limit, len + 1);\n            else\n                limit = min(limit, len);\n\n        // dp[k]: start with 0, end with zero, length k.\n        vector<int> dp(n + 5);\n        vector<int> dp_sum(n + 5);\n\n        dp[0] = 0;\n        dp[1] = 1;\n\n        dp_sum[0] = 0;\n        dp_sum[1] = 1;\n        for (int p = 2; p < SZ(dp); ++p) {\n            for (int last = 1; last <= limit and last + 1 <= p; last += 2)\n                dp[p] = add(dp[p], dp[p - 1 - last]);\n\n            // int upto = min(limit, p - 1);\n            // if (upto % 2 == 0)\n            //     --upto;\n\n            // dp[p] = dp_sum[p - 2];\n\n            // if (p - upto - 3 >= 0)\n            //     dp[p] = sub(dp[p], dp_sum[p - upto - 3]);\n\n            // dp_sum[p] = add(dp_sum[p - 2], dp[p]);\n        }\n\n        int ans = 0;\n        for (int beg = 1; beg <= n - 1 and beg <= limit; beg += 2)\n            ans = add(ans, mult(beg + 1, dp[n - beg]));\n\n        cout << ans << \"\\n\";\n\n        if (0) {\n            auto N = n;\n            auto lim = limit;\n            int cnt = 0;\n            \n            for (int mask = 0; mask != (1 << N); ++mask) {\n                if (mask == 0 or mask + 1 == (1 << N))\n                    continue;\n        \n                vector<char> s(N);\n                for (int i = 0; i != N; ++i)\n                    s[i] = bool((mask & (1 << i)) != 0);\n\n                int p = 0;\n                while (s[p] != 0 or s[(p + 1) % N] != 1)\n                    ++p;\n\n                std::rotate(s.begin(), s.begin() + p, s.end());\n                vector<int> lens;\n                for (int i = 1; i != N; ++i)\n                    if (s[i] == 1 and s[i - 1] == 0)\n                        lens.push_back(1);\n                    else if (s[i] == 1)\n                        lens.back() += 1;\n\n                bool fail = false;\n                for (int i = 0; i != N; ++i)\n                    if (s[i] == 0 and s[(i + 1) % N] == 0)\n                        fail = 1;\n                \n                if (fail)\n                    continue;\n\n                if (*std::max_element(ALL(lens)) > lim)\n                    fail = true;\n\n                for (auto elem: lens)\n                    if (elem % 2 == 0)\n                        fail = true;\n\n                if (fail)\n                    continue;\n\n                // for (int i = 0; i != N; ++i)\n                //     cout << ((mask & (1 << i)) != 0 ? '1' : '0');\n\n                // cout << \"\\n\";\n                cnt += 1;\n            }\n\n            assert(ans == cnt);\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)//  cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ld PI = 3.14159265359;\n\nconst ll MOD = (ll) 1e9 + 7;\nconst ll MAXN = (ll) 3e5 + 10;\nconst ll INF = (ll) 2242545357980376863;\nconst ld EPS = (ld) 1e-8;\n\nvector<ll> A;\nll dp[MAXN], sm[MAXN];\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll n, m;\n\tcin >> n >> m;\n\tstr s;\n\tcin >> s;\n\t\n\tif(s[0] == 'B'){\n\t\tfor(int i = 0; i < m;i++){\n\t\t\tif(s[i] == 'R') s[i] = 'B';\n\t\t\telse s[i] = 'R';\n\t\t}\n\t}\n\tll cnt = 1;\n\tfor(int i = 1; i < m; i++){\n\t\tif(s[i] == s[i - 1]) cnt ++;\n\t\telse {\n\t\t\tA.pb(cnt);\n\t\t\tcnt = 1;\n\t\t}\n\t}\n\tA.pb(cnt);\n\tif(A.size() == 1){\n\t\t//debug(\"S\");\n\t\tdp[1] = 1;\n\t\tdp[2] = 0;\n\t\tsm[1] = 1;\n\t\tsm[2] = 1;\n\t\tfor(int i = 3; i <= n; i++){\n\t\t\tdp[i] = sm[i - 2];\n\t\t\tsm[i] = (dp[i] + sm[i - 1]) % MOD;\n\t\t}\n\t\tll ans = 1;\n\t\tfor(int len = 1; len <= n - 1; len ++){\n\t\t\tans += (len + 1ll) * dp[n - len];\n\t\t\tans %= MOD;\n\t\t}\n\t\tcout << ans;\n\t\treturn 0;\n\t\t/////\n\t}\n\t\n\tll mx;\n\t\n\tif(A[0] % 2 == 0) mx = A[0] + 1;\n\telse mx = A[0];\n\tfor(int i = 2; i + 1 < A.size(); i += 2){\n\t\tif(A[i] % 2 == 1) mx = max(mx, A[i]);\n\t}\n\tdebug(mx);\n\tdp[0] = 0;\n\tdp[1] = 1;\n\tdp[3] = 1;\n\tfor(int i = 5; i <= n; i++){\n\t\tdp[i] = dp[i - 2] + dp[i - 2];\n\t\tif(i >= mx + 3) dp[i] -= dp[i - mx - 3];\n\t\tdp[i] %= MOD;\n\t}\n\t//debug(dp[1]);\n\t//debug(dp[3]);\n\tll ans = 0;\n\tfor(ll len = 1; len <= min(n, mx); len += 2){\n\t\tans += (len + 1ll) * dp[n - len];\n\t\tans %= MOD;\n\t}\n\tcout << ((ans % MOD) + MOD)%MOD;\n\t\n\treturn 0;\n}\n\n\n/*\n\n                                 ____              ,----..               ,----..\n   ,---,                       ,'  , `.           /   /   \\             /   /   \\\n  '  .' \\                   ,-+-,.' _ |          /   .     :           /   .     :\n /  ;    '.              ,-+-. ;   , ||         .   /   ;.  \\         .   /   ;.  \\\n:  :       \\            ,--.'|'   |  ;|        .   ;   /  ` ;        .   ;   /  ` ;\n:  |   /\\   \\          |   |  ,', |  ':        ;   |  ; \\ ; |        ;   |  ; \\ ; |\n|  :  ' ;.   :         |   | /  | |  ||        |   :  | ; | '        |   :  | ; | '\n|  |  ;/  \\   \\        '   | :  | :  |,        .   |  ' ' ' :        .   |  ' ' ' :\n'  :  | \\  \\ ,'        ;   . |  ; |--'         '   ;  \\; /  |        '   ;  \\; /  |\n|  |  '  '--'          |   : |  | ,             \\   \\  ',  /          \\   \\  ',  /\n|  :  :                |   : '  |/               ;   :    /            ;   :    /\n|  | ,'                ;   | |`-'                 \\   \\ .'              \\   \\ .'\n`--''                  |   ;/                      `---`                 `---`\n                       '---'\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nconst int maxn=2e5+50;\nint n,m;\nint f[maxn];\nint s[maxn];\nchar S[maxn];\ninline int add(int x)\n{\n\treturn x>=mod?x-mod:x;\n}\ninline int dec(int x)\n{\n\treturn x<0?x+mod:x;\n}\nvoid dp(int L)\n{\n\tf[1]=s[1]=1;\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tf[i]=dec(s[i-1]-s[max(0,i-L-2)]);\n\t\ts[i]=add(s[i-1]+f[i]);\n\t} \n}\nint solve()\n{\n\tif(S[1]=='B')\n\t{\n\t\tfor(int i=1;i<=m;++i)\n\t\t{\n\t\t\tS[i]=S[i]=='R'?'B':'R'; \n\t\t}\n\t}\n\tint an=0,k=1,L=n;\n\twhile(k<m&&S[k+1]=='R')\n\t{\n\t\t++k;\n\t}\n\tif(k==m)\n\t{\n\t\tstatic int f[maxn][2];\n\t\tmemset(f,0,sizeof(f)); \n\t\tf[1][0]=1;\n\t\tfor(int i=1;i<n;++i)\n\t\t{\n\t\t\tf[i+1][0]=add(f[i][0]+f[i][1]);\n\t\t\tf[i+1][1]=add(f[i][0]);\n\t\t}\n\t\tan=add(an+f[n][0]);\n\t\tan=add(an+f[n][1]);\n\t\tmemset(f,0,sizeof(f));\n\t\tf[1][1]=1;\n\t\tfor(int i=1;i<n;++i)\n\t\t{\n\t\t\tf[i+1][0]=add(f[i][0]+f[i][1]);\n\t\t\tf[i+1][1]=add(f[i][0]);\n\t\t}\n\t\tan=add(an+f[n][0]);\n\t\treturn an;\n\t}\n\tif(n&1) return 0;\n\tL=k&1?k:k+1;\n\tfor(int i=k+1,j;i<=m;i=j+1)\n\t{\n\t\tj=i;\n\t\twhile(j<=m&&S[j]!='B')\n\t\t{\n\t\t\t++j;\n\t\t}\n\t\tif(j==m+1) continue;\n\t\tint _k=j-i;\n\t\tif(_k&1) L=min(L,_k);\n\t}\n\tn>>=1,L>>=1;\n\tdp(L);\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tif(n-i>L) break;\n\t\tan=(an+(ll)(n-i+1)*f[i])%mod;\n\t}\n\tan=add(an<<1);\n\treturn an;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",S+1);\n\tprintf(\"%d\\n\",solve());\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define inf 20021225\n#define N 200100\n#define mdn 1000000007\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nint f[N],n,m,pre[2][N]; char ch[N];\nvoid upd(int &x,int y){x+=x+y>=mdn?y-mdn:y;}\nint query(int l,int r,int w){return !l?pre[w][r]:(pre[w][r]-pre[w][l-1]+mdn)%mdn;}\nint main()\n{\n\tn=read(),m=read(); scanf(\"%s\",ch+1);\n\tchar w=ch[1]; int s=0,mn=inf,fs=0;\n\tfor(int i=1;i<=m;i++)\n\t\tif(ch[i]==w)\ts++;\n\t\telse\tmn=s&1?min(s,mn):mn,fs=!fs?s:fs,s=0;\n\tmn=min(fs+!(fs&1),mn); f[0]=1,pre[0][1]=pre[0][0]=1;\n\tint ans=0;\n\tif(s==m)\n\t{\n\t\tf[0]=1; pre[0][0]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\t\tf[i]=query(0,i-2,0),pre[0][i]=(pre[0][i-1]+f[i])%mdn;\n\t\tfor(int i=1;i<=n;i++)\tupd(ans,1ll*(i+1)*f[n-i-1]%mdn);\n\t\tprintf(\"%d\\n\",ans+1);\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=n;i++)\n\t\tf[i]=query(max(0,i-mn-1),i-2,i&1),\n\t\tpre[i&1][i]=(pre[i&1][i-1]+f[i])%mdn,\n\t\tpre[!(i&1)][i]=pre[!(i&1)][i-1];\n\tfor(int i=1;i<=mn;i+=2)\tupd(ans,1ll*(i+1)*f[n-i-1]%mdn);\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\ntypedef long long ll;\nconst ll MAX_N = 2e5+10;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nll solve(ll lim)\n{\n    if (n&1)\n        return 0;\n    dp[1] = 1;\n    dp[3] = 1;\n    sum[1] = 1;\n    sum[3] = 2;\n    for(int i = 5;i<=n+1;i+=2)\n    {\n        dp[i] = sum[i-2];\n        if (i-2>lim)\n            dp[i] = (dp[i]-sum[i-lim-3]+MOD)%MOD;\n        sum[i] = (sum[i-2]+dp[i])%MOD;\n    }\n    ll ans = 0;\n    ans = dp[n+1];\n    for(ll i = 1;i<=lim;i+=2)\n    {\n        ans += (i*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    ok = false;\n    for(auto x:vc)\n        ok |= (x&1);\n    if (!ok)\n        return cout << solve(vc[0]+1),0;\n    int mn = 1e9;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    cout << solve(mn);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define pii pair<int, int>\n#define p3i pair<pii, int>\n#define pll pair<ll, ll>\n#define p3l pair<pll, ll>\n#define vi vector<int>\n#define vpii vector<pii>\n#define vp3i vector<p3i>\n#define vpll vector<pll>\n#define vp3l vector<p3l>\n#define lseg L, (L+R)/2, N*2+1\n#define rseg (L+R)/2+1, R, N*2+2\n#define ub upper_bound\n#define lb lower_bound\n#define pq priority_queue\n#define MN 1000000007\n#define fox(k, x) for (int k=0; k<x; ++k)\n#define fox1(k, x) for (int k=1; k<=x; ++k)\n#define foxr(k, x) for (int k=x-1; k>=0; --k)\n#define fox1r(k, x) for (int k=x; k>0; --k)\n#define ms multiset\n#define flood(x) memset(x, 0x3f3f3f3f, sizeof x)\n#define drain(x) memset(x, 0, sizeof x)\n#define rng() ((rand() << 14)+rand())\n#define scan(X) do{while((X=getchar())<'0'); for(X-='0'; '0'<=(_=getchar()); X=(X<<3)+(X<<1)+_-'0');}while(0)\nchar _;\n#define pi 3.14159265358979323846\n\nint n, m, dp[200005], psa[200005];\nint sum, ans=0;\nstring s;\nint get(int N, int L){\n  int hi = N;\n  int lo = hi - L - 1;\n  //cout << N << ' ' << L << ' ' <<lo << ' ' << hi << endl;\n  int res = psa[hi];\n  if (lo >= 0) res -= psa[lo];\n  return res%MN;\n}\nint32_t main(){\n  cin >> n >> m >> s;\n  int pref = 0, lim, c = 0;\n  fox(l, m){\n    if (s[l] != s[0]) break;\n    pref++;\n  }\n  if (pref % 2 == 1)\n    lim = pref;\n  else\n    lim = pref + 1;\n  if (pref == m){\n    dp[0] = 1;\n    dp[1] = 1;\n    for(int l = 2; l <= n; ++l){\n      dp[l] = (dp[l-1]+dp[l-2])%MN;\n    }\n    cout << (dp[n-2] + dp[n])%MN;\n    return 0;\n  }\n  if (n%2 == 1){\n    if (pref != m){\n      printf(\"0\\n\");\n      return 0;\n    }\n  }\n  fox(l, m){\n    if (s[l]!=s[0]){\n      if (c%2 == 1){\n        lim = min(lim, c);\n      }\n      c=0;\n    } else {\n      c++;\n    }\n  }\n  if (c%2 == 1){\n    lim = min(lim, c);\n  }\n  n/=2;\n  lim /= 2;\n  dp[0]= 1;\n  int p=0;\n  sum = 1;\n  psa[0] = 1;\n  fox1(l, n){\n    while(l-p-1 > lim){\n      sum = (sum - dp[p]) % MN;\n      ++p;\n    }\n    dp[l] = sum;\n    psa[l] = (psa[l-1] + dp[l]) % MN;\n    sum = (sum + dp[l]) % MN;\n    //cout << dp[l] << ' ';\n  }\n  fox(l, lim+1){\n    //starting component\n    ans = (ans + get(n-1-l, lim-l))%MN;\n  }\n  if (ans < 0) ans += MN;\n  cout << ans*2%MN;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define Md 1000000007\n#define MN 200005\nint n,m;\nchar c[MN];\nlg Pow(lg x,lg y){\n\tlg res=1;for(;y;y>>=1,x=x*x%Md)if(y&1)res=res*x%Md;return res;\n}\nint Fix(int x){\n\tif(x<0)return x+Md;\n\tif(x>=Md)return x-Md;\n\treturn x;\n}\nint dp[MN],tmp[MN];\nint miu[MN];\nint main(){\n\tread(n);read(m);\n\tscanf(\"%s\",c+1);\n\tmiu[1]=1;\n\tfor(int i=1;i<MN;++i){\n\t\tfor(int j=i+i;j<MN;j+=i){\n\t\t\tmiu[j]-=miu[i];\n\t\t}\n\t}\n\tchar Hd=c[1];\n\tint cnt=0,mx;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse break;\n\t}\n\tif(cnt&1)mx=cnt;else mx=cnt+1;\n\tif(n&1){\n\t\tif(cnt!=m)return puts(\"0\"),0;\n\t\tint res=0;\n\t\ttmp[0]=tmp[1]=1;\n\t\tdp[0]=1;\n\t\tmx+=2;\n\t\tif(n>2)res=n;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tdp[i]=(i>=2?tmp[i-2]:0);\n\t\t\ttmp[i]=Fix(tmp[i-1]+dp[i]);\n\t\t\tif(i<n-1)res=Fix(res+1ll*dp[i]*(n-i)%Md);\n\t\t\t//cerr<<i<<' '<<dp[i]<<' '<<n<<' '<<i<<' '<<n/i<<endl;\n\t\t}\n\t\tprintf(\"%d\",res+1);\n\t\treturn 0;\n\t}\n\tint res=(cnt==m);\n\tcnt=0;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse{\n\t\t\tif(!cnt)continue;\n\t\t\tif(cnt&1)mx=min(mx,cnt);\n\t\t\tcnt=0;\n\t\t}\n\t}\n\t//for(int i=1;i<=5;++i)cerr<<miu[i]<<' ';cerr<<endl;\n\ttmp[0]=tmp[1]=1;\n\tdp[0]=1;\n\tmx+=2;\n\tif(n<mx)res+=n;\n\tfor(int i=2;i<=n;i+=2){\n\t\tdp[i]=Fix(tmp[i-1]-(mx>i?0:tmp[i-mx]));\n\t\ttmp[i]=tmp[i+1]=Fix(tmp[i-1]+dp[i]);\n\t\t//cerr<<dp[i]<<' '<<i<<endl;\n\t\tif((n-i)%2==0&&n-i<mx)res=Fix(res+dp[i]*(n-i)%Md);\n\t}\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tstring s;\n\tcin >> s;\n\tset<char>st;\n\tfor (auto i : s)st.insert(i);\n\tif (st.size() == 1) {\n\t\tvector<long long int>dp(N + 1);\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1];\n\t\t\tif (i > 1)dp[i] += dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tlong long int ans = dp.back();\n\t\tdp[0] = 1;\n\t\tdp[1] = 0;\n\t\tfor (int i = 2; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tans += dp.back();\n\t\tans %= MOD;\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\ts.push_back(s[0] + 1);\n\tvector<int>num(s.size() + 1);\n\tfor (int i = 0; i <= s.size(); i++) {\n\t\tnum[i] = s[i] == s[0];\n\t\tif (i)num[i] = num[i] * (num[i - 1] + 1);\n\t}\n\tint fst = 0;\n\tint m = MOD;\n\tbool even = true;\n\tfor (int i = 1; i <= s.size(); i++) {\n\t\tif (!num[i] && num[i - 1]) {\n\t\t\tif (num[i - 1] & 1) {\n\t\t\t\teven = false;\n\t\t\t\tm = min(m, num[i - 1]);\n\t\t\t}\n\t\t\tif (fst == 0) {\n\t\t\t\tfst = num[i - 1];\n\t\t\t\tif(fst%2==0)m = MOD;\n\t\t\t}\n\t\t}\n\t}\n\tif (even) {\n\t\tm = fst + 2;\n\t}\n\telse if (fst % 2 == 0) {\n\t\tm = min(m, fst + 1);\n\t}\n\tif (m & 1)m++;\n\tvector<long long int>dp(N + 2);\n\tvector<long long int>sum(N + 2);\n\tfor (int i = 2; i <= m; i += 2)dp[i] = i;\n\tfor (int i = 2; i <= N; i++) {\n\t\tdp[i] += sum[i - 2] + MOD;\n\t\tif (i - m - 2 >= 0)dp[i] -= sum[i - m - 2];\n\t\tdp[i] %= MOD;\n\t\tif (i == N) {\n\t\t\tcout << dp[i] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsum[i] = sum[i - 2] + dp[i];\n\t\tsum[i] %= MOD;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=a*b%mod\n\nll n,m;\nstring s;\nll f[200010],rui[200010];\n\nint main(){\n    cin>>n>>m>>s;\n    if(s[0]=='R'){\n\tfor(int i=0;i<n;i++){\n\t    if(s[i]=='R')s[i]='B';\n\t    else s[i]='R';\n\t}\n    }\n    bool th=0;\n    ll cnt=0,mi=1e17;\n    bool fi=1; ll lead;\n    for(int i=0;i<n;i++){\n\tif(s[i]=='R'){\n\t    if(fi)lead=cnt; fi=0;\n\t    th=1;\n\t    if(cnt%2==1)chmin(mi,cnt);\n\t    cnt=0;\n\t}\n\telse cnt++;\n    }\n    if(th==0){\n\tf[0]=f[1]=1;\n\tfor(int i=2;i<n;i++){\n\t    f[i]=(f[i-1]+f[i-2])%mod;\n\t}\n\tll ans=(f[n-2]*2+f[n-1])%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n    }\n    if(n%2==1){\n\tcout<<0<<endl;\n\treturn 0;\n    }\n    if(lead%2==0)lead++;\n    chmin(mi,lead);\n    mi=(mi+1)/2;\n    chmin(mi,n/2);\n    f[0]=rui[0]=0;\n    for(ll i=1;i<=mi;i++){\n\tf[i]=i;\n\trui[i]=(rui[i-1]+i)%mod;\n    }\n    for(int i=1;i<n/2;i++){\n\tmad(f[i],rui[i-1]);\n\tif(i-mi-1>=0)mad(f[i],-rui[i-mi-1]);\n\trui[i]=(rui[i-1]+f[i])%mod;\n    }\n    ll ans=0;\n    for(int i=1;i<=mi;i++)mad(ans,f[n/2-i]);\n    //cout<<mi<<endl;\n    //for(int i=0;i<n/2;i++)cout<<i<<\":\"<<f[i]<<endl;\n    ans=ans*2%mod;\n    if(ans<0)ans+=mod;\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nint N, M; char S[200200];\n\nconst long long mod = 1000000007;\nlong long D[200200], V[200200];\n\nint main()\n{\n\tscanf (\"%d %d %s\", &N, &M, S);\n\tif (S[0] == 'B'){\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tif (S[i] == 'R') S[i] = 'B';\n\t\t\telse S[i] = 'R';\n\t\t}\n\t}\n\n\tvector<int> len;\n\tfor (int i = 1, l = -1; i < M; i++){\n\t\tif (S[i-1] == 'R' && S[i] == 'B'){\n\t\t\tint u = i - l - 1;\n\t\t\tlen.push_back(u);\n\t\t}\n\t\tif (S[i] == 'B') l = i;\n\t}\n\n\tif (len.empty()){\n\t\tif (N == 2){\n\t\t\tprintf (\"3\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tD[0] = 1;\n\t\tD[1] = 2;\n\t\tfor (int i = 2; i <= N; i++) D[i] = (D[i - 1] + D[i - 2]) % mod;\n\t\tprintf (\"%lld\\n\", (D[N - 1] + D[N - 3]) % mod);\n\t\treturn 0;\n\t}\n\tif (N == 2){\n\t\tprintf (\"2\\n\");\n\t\treturn 0;\n\t}\n\n\tint lim = len[0];\n\tif (lim % 2 == 0) lim++;\n\tfor (int i = 1; i < len.size(); i++){\n\t\tif (len[i] % 2){\n\t\t\tif (lim > len[i])\n\t\t\t\tlim = len[i];\n\t\t}\n\t}\n\n\tD[0] = V[0] = 1;\n\tfor (int i = 1; i <= N; i++){\n\t\tif (i <= lim + 1) D[i] = i - 1;\n\t\tif (i >= 2) D[i] = (D[i] + V[i - 2]) % mod;\n\t\tif (i >= lim + 3) D[i] = (D[i] + mod - V[i - (lim + 3)]) % mod;\n\t\tV[i] = D[i];\n\t\tif (i >= 2) V[i] = (V[i] + V[i - 2]) % mod;\n\t}\n\tprintf (\"%lld\\n\", D[N]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=5e5+6;\ntypedef long long ll;\nconst ll M=1000000007;\nll f[maxn],nf[maxn],inv[maxn],n,m,p[maxn],ans,dp[maxn][2][2],v[maxn],mx,l;\nchar s[maxn];\nll work_dp(int n){\n    if (n==1) return 1;\n    dp[1][0][0]=dp[1][1][1]=1;\n    for (int i=2;i<=n;i++){\n        for (int o=0;o<=1;o++){\n            dp[i][o][0]=(dp[i-1][o][0]+dp[i-1][o][1])%M;\n            dp[i][o][1]=dp[i-1][o][0];\n        }\n    }\n    return (dp[n][0][0]+dp[n][0][1]+dp[n][1][0])%M;\n}\n\nint main(){\n    inv[1]=1; for (int i=2;i<maxn;i++) inv[i]=M-(M/i)*inv[M%i]%M;\n    nf[0]=f[0]=p[0]=1; for (int i=1;i<maxn;i++) f[i]=f[i-1]*i%M,nf[i]=nf[i-1]*inv[i]%M,p[i]=p[i-1]*2%M;\n    cin >> n >> l;\n    scanf(\"%s\",s+1);\n    if (s[1]=='B'){\n        for (int i=1;i<=l;i++) if (s[i]=='B') s[i]='R'; else s[i]='B';\n    }\n    for (int i=1;i<=l;i++) if (s[i]=='R') v[i]=v[i-1]+1; else v[i]=0;\n    if (v[l]==l){\n        cout << work_dp(n) << endl;\n        return 0;\n    }\n    for (int i=1;i<l;i++) if (v[i]>0&&v[i+1]==0){\n        if (mx==0) mx=v[i]/2*2+1;\n        else if (v[i]%2==1) mx=min(mx,v[i]);\n    }\n    if (n%2==1){puts(\"0\");return 0;}\n    n/=2; m=(mx+1)/2;\n    for (int i=0;i*(m+1)<=n&&n-i*m-1>=0;i++){\n        int u=n-i*(m+1);\n        if (i&1) (ans-=p[u]*f[n-i*m-1]%M*nf[i]%M*nf[u])%=M;\n        else (ans+=p[u]*f[n-i*m-1]%M*nf[i]%M*nf[u])%=M;\n    }\n    ans=(ans*n-1)%M;\n    cout << (ans+M)*2%M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL, LL> PII;\n\n// chmax, chmin\ntemplate <class T>\ninline bool chmax(T& a, T b) {\n  if (a < b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\ntemplate <class T>\ninline bool chmin(T& a, T b) {\n  if (a > b) {\n    a = b;\n    return 1;\n  }\n  return 0;\n}\n\ntemplate <typename T>\nfunction<T(T, T)> op_max = [](T a, T b) -> T { return max(a, b); };\ntemplate <typename T>\nfunction<T(T, T)> op_min = [](T a, T b) -> T { return min(a, b); };\n\ntemplate <typename T>\nfunction<T(T, T)> op_sum = [](T a, T b) -> T { return a + b; };\n\nnamespace detail {\ntemplate <typename T, std::size_t NDIMS>\nstruct vector_builder {\n  using type = std::vector<typename vector_builder<T, NDIMS - 1>::type>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    const auto vec = std::vector<T>(dims.empty() ? 0 : dims.back(), v);\n    if (!dims.empty()) dims.pop_back();\n    return vector_builder<std::vector<T>, NDIMS - 1>::make(dims, vec);\n  }\n};\n\ntemplate <typename T>\nstruct vector_builder<T, 1> {\n  using type = std::vector<T>;\n\n  static type make(std::vector<std::size_t> dims, const T& v = {}) {\n    return type(dims.empty() ? 0 : dims.back(), v);\n  }\n};\n}  // namespace detail\n\ntemplate <typename T, typename... SIZE_T>\nauto exvector(const T& v, SIZE_T... dims) {\n  static_assert(sizeof...(dims) != 0, \"invalid dimension\");\n  std::vector<std::size_t> vec_dims{dims...};\n  return detail::vector_builder<T, sizeof...(dims)>::make(vec_dims, v);\n}\n\nusing namespace std;\n//********************  dumps ************************//\n\ntemplate <typename T>\nvoid dump(const T& data, vector<int>& iter) {\n  cout << data << \" \";\n}\ntemplate <typename T>\nvoid dump(const vector<T>& data, vector<int>& iter) {\n  for (auto elem : data) dump(elem, iter);\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<vector<T>>& data, vector<int>& iter) {\n  for (auto elem : iter) {\n    cout << \"[\" << elem << \"]\";\n  }\n  cout << endl;\n  for (int i = 0; i < data.size(); i++) {\n    iter.push_back(i);\n    dump(data[i], iter);\n    iter.pop_back();\n  }\n  cout << endl;\n}\n\ntemplate <typename T>\nvoid dump(const vector<T>& data, int dummy) {\n  for (int i = 0; i < data.size(); i++) {\n    cout << \"[\" << i << \"] \" << data[i] << endl;\n  }\n}\ntemplate <typename T>\nvoid dump(const T& data) {  // T : data, U = base type val.\n  vector<int> iter;\n  dump(data, iter);\n}\n///////////////////////////////////////////////\n\nconst long long MOD = 1000000007;\n\nconst long long MOD_CONST = 1000000007;\nlong long mul_mod(long long a, long long b, const long long MOD) {\n  return b ? (mul_mod(a * 2, b / 2, MOD) + (b & 1 ? a : 0)) % MOD : 0;\n}\n\nlong long bpow_mod(long long a, long long b, const long long MOD) {\n  return (b ? bpow_mod(a * a % MOD, b / 2, MOD) * (b & 1 ? a : 1) : 1) % MOD;\n}\n\nlong long inv_mod(long long a, const long long MOD) {\n  return bpow_mod(a, MOD - 2, MOD);\n}\ntemplate <long long param = MOD_CONST, bool fast = false>\nclass mint {\n private:\n  using Z = int;\n  using N = unsigned int;\n  using ZZ = long long;\n  using NN = unsigned long long;\n  struct {\n  } constexpr static exact{};\n  // Using Z deliberately to avoid Z -> N promotion.\n  template <class Ret = ZZ&>\n  static auto modulo() -> std::enable_if_t<(param <= 0), Ret> {\n    static ZZ mod = 0;\n    return mod;\n  }\n  template <class Ret = const ZZ>\n  static auto mod() -> std::enable_if_t<(param <= 0), Ret> {\n    return modulo();\n  }\n  template <class Ret = const ZZ>\n  static constexpr auto mod() -> std::enable_if_t<(param > 0), Ret> {\n    return param;\n  }\n\n public:\n  template <class Arg = ZZ>\n  static void set_modulo(const std::enable_if_t<(param <= 0), Arg> mod) {\n    modulo() = mod;\n  }\n  long long v;\n\n  constexpr mint() : v(0) {}\n\n  constexpr mint(long long v)\n      : v(fast ? (v)\n               : (v < 0 ? (v % mod() + mod()) % mod()\n                        : (v >= mod() ? v % mod() : v))) {}\n  constexpr long long get_mod() { return mod(); }\n  long long get_val() { return v; }\n  void take_mod() { v %= mod(); }\n};\ntemplate <long long param, bool fast>\nostream& operator<<(ostream& os, mint<param, fast>& x) {\n  return os << (x.v % x.get_mod() + x.get_mod()) % x.get_mod();\n}\n\ntemplate <long long param, bool fast, bool fast2>\nbool operator==(mint<param, fast>& a, mint<param, fast2> b) {\n  return a.v == b.v;\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast>& operator+=(mint<param, fast>& a, mint<param, fast2> b) {\n  return a = a.v + b.v;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, mint<param> b) {\n  return a = a.v - b.v;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, mint<param> b) {\n  return a = a.v * b.v;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, mint<param> b) {\n  return a = a.v * inv_mod(b.v, a.get_mod());\n}\ntemplate <long long param, bool fast, bool fast2>\nmint<param, fast> operator+(mint<param, fast> a, mint<param, fast2> b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, mint<param> b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, mint<param> b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, mint<param> b) {\n  return a /= b;\n}\ntemplate <long long param, bool fast>\nmint<param, fast>& operator+=(mint<param, fast>& a, long long b) {\n  return a = a.v + b;\n}\ntemplate <long long param>\nmint<param>& operator-=(mint<param>& a, long long b) {\n  return a = a.v - b;\n}\ntemplate <long long param>\nmint<param>& operator*=(mint<param>& a, long long b) {\n  return a = a.v * b;\n}\ntemplate <long long param>\nmint<param>& operator/=(mint<param>& a, long long b) {\n  return a = a.v * inv_mod(b, a.get_mod());\n}\ntemplate <long long param, bool fast>\nmint<param, fast> operator+(mint<param> a, long long b) {\n  return a += b;\n}\ntemplate <long long param>\nmint<param> operator-(mint<param> a, long long b) {\n  return a -= b;\n}\ntemplate <long long param>\nmint<param> operator*(mint<param> a, long long b) {\n  return a *= b;\n}\ntemplate <long long param>\nmint<param> operator/(mint<param> a, long long b) {\n  return a /= b;\n}\n\nvoid special(int N) {\n  vector<mint<>> vals = {mint<>(1), mint<>(1)};\n  for (int i = 0; i < N; i++) {\n    int sz = vals.size();\n    vals.push_back(vals[sz - 1] + vals[sz - 2]);\n  }\n  mint<> ans = vals[N] + vals[N - 2];\n  cout << ans << endl;\n}\n\nint con(string& S, char t) {\n  int ans = 1000000;\n  int cur = 0;\n  for (auto c : S) {\n    if (c == t)\n      cur++;\n    else {\n      if (cur != 0) ans = min(ans, cur);\n      cur = 0;\n    }\n  }\n  return ans;\n}\n\nmint<> calcDP(int N, int conB, int conR) {\n  vector<mint<>> dpR(N + 2, mint<>(0));\n  vector<mint<>> dpB(N + 2, mint<>(0));\n  vector<mint<>> sumR(N + 2, mint<>(0));\n  vector<mint<>> sumB(N + 2, mint<>(0));\n  dpR[1] = 1;\n  sumR[1] = 1;\n  for (int i = 2; i <= N + 1; i++) {\n    if (i % 2 == 1) {\n      dpR[i] = sumB[i - 1] - sumB[max(0, i - conB - 1)];\n      // if (i <= conB) dpR[i] += 1;\n\n    } else\n      dpB[i] = sumR[i - 1] - sumR[max(0, i - conR - 1)];\n    sumB[i] = sumB[i - 1] + dpB[i];\n    sumR[i] = sumR[i - 1] + dpR[i];\n  }\n  mint<> ans = 0;\n  for (int i = 0; i < min(N, conB + 1); i++) {\n    ans += sumR[N - i] - sumR[max(0, N - conB - 1)];\n  }\n  return ans;\n}\n\nvoid solve(long long N, long long M, std::string S) {\n  int cntB = 0;\n\n  int conR = con(S, 'R');\n  int conB = con(S, 'B');\n  for (int i = 0; i < M; i++) {\n    if (S[i] == 'B') cntB++;\n  }\n  if (cntB == M || cntB == 0) {\n    special(M);\n    return;\n  }\n  if (N % 2 == 1) {\n    cout << 0 << endl;\n    return;\n  }\n  if (S[0] == 'R') swap(conR, conB);\n  conR = 1;\n  if (conB % 2 == 0) conB++;\n  // if (conR % 2 == 0) conR--;\n\n  mint<> ans = calcDP(N, conB, conR);\n  cout << ans << endl;\n}\n\nint main() {\n  cout << setprecision(10);\n  long long N;\n  scanf(\"%lld\", &N);\n  long long M;\n  scanf(\"%lld\", &M);\n  std::string S;\n  std::cin >> S;\n  solve(N, M, S);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define mod 1000000007\n#define N 200050\nint n,m,dp[N][2][2],fg,mx,fg2,dp2[N],su[N],as;\nchar s[N];\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tfor(int i=2;i<=m;i++)if(s[i]!=s[i-1])fg=1;\n\tif(!fg)\n\t{\n\t\tdp[1][1][1]=dp[1][0][0]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\tdp[i][0][0]=(dp[i-1][0][0]+dp[i-1][1][0])%mod,\n\t\tdp[i][0][1]=(dp[i-1][0][1]+dp[i-1][1][1])%mod,\n\t\tdp[i][1][0]=dp[i-1][0][0],\n\t\tdp[i][1][1]=dp[i-1][0][1];\n\t\tprintf(\"%lld\\n\",(1ll*dp[n][0][0]+dp[n][0][1]+dp[n][1][0])%mod);\n\t\treturn 0;\n\t}\n\tint su1=0;\n\tfor(int i=1;i<=m;i++)\n\tif(s[i]==s[1])su1++;\n\telse\n\t{\n\t\tif((su1&1)&&mx>su1)mx=su1;\n\t\tif(!fg2)mx=su1+1;\n\t\tfg2=1;su1=0;\n\t}\n\tif(mx>n)mx=n;\n\tif(~mx&1)mx--;\n\tdp2[1]=1;su[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(i-mx>3)dp2[i]=(su[i-2]-su[i-mx-3]+mod)%mod;\n\t\telse dp2[i]=su[i-2];\n\t\tsu[i]=(su[i-2]+dp2[i])%mod;\n\t}\n\tfor(int i=1;i<=mx;i+=2)as=(as+1ll*dp2[n-i]*(i+1))%mod;\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int p = 1e9 + 7;\nint main() {\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n, m;\n  cin >> n >> m;\n  string str;\n  cin >> str;\n  if (str[0] == 'B') {\n    for (int i = 0; i < m; i++) {\n      if (str[i] == 'R') {\n        str[i] = 'B';\n      } else {\n        str[i] = 'R';\n      }\n    }\n  }\n  while (!str.empty() && str.back() == 'R') {\n    str.pop_back();\n  }\n  if (str.empty()) {\n    vector<int> dp(n);\n    int sum = 0;\n    for (int i = 1; i < n; i++) {\n      dp[i] = (i + 1 + sum) % p;\n      if (i) {\n        sum = (sum + dp[i - 1]) % p;\n      }\n    }\n    cout << (dp[n - 1] + 1) % p << endl;\n  } else {\n    int limit = INT_MAX, last = -1;\n    for (int i = 0; i < str.size(); i++) {\n      if (str[i] == 'B') {\n        int len = i - last - 1;\n        if (len & 1) {\n          limit = min(limit, len);\n        } else if (-1 == last) {\n          limit = min(limit, len + 1);\n        }\n        last = i;\n      }\n    }\n    vector<int> dp(n);\n    int sum_0 = 0, sum_1 = 0;\n    for (int i = 1; i < n; i++) {\n      if (i & 1) {\n        if (i <= limit) {\n          dp[i] = i + 1;\n        }\n        dp[i] = (dp[i] + sum_1) % p;\n        sum_0 = (sum_0 + dp[i - 1]) % p;\n      } else {\n        dp[i] = (dp[i] + sum_0) % p;\n        sum_1 = (sum_1 + dp[i - 1]) % p;\n      }\n      if (i - limit - 1 > 0) {\n        if (i - limit - 1 & 1) {\n          sum_1 = (sum_1 - dp[i - limit - 1] + p) % p;\n        } else {\n          sum_0 = (sum_0 - dp[i - limit - 1] + p) % p;\n        }\n      }\n    }\n    cout << dp[n - 1] << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//*\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <numeric>\n#include <functional>\n#define MOD 1000000007\n#define MAX 0x3f3f3f3f\n#define MAX2 0x3f3f3f3f3f3f3f3fll\n#define ERR 1e-10\n#define mp make_pair\n#define all(x) (x).begin(), (x).end()\n#pragma warning(disable:4996)\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n\nint n, m;\nchar s[300000];\n\nll d[300000][2];\n\nll u[300000], v[300000];\n\nint main()\n{\n    int i, j, k, l;\n    ll ans=0;\n    cin>>n>>m;\n    scanf(\"%s\", s);\n    m=strlen(s);\n    if(s[0] == 'B')\n    {\n        for(i=0;i<m;i++) s[i]=s[i]=='R'?'B':'R';\n    }\n    for(i=0;i<m;i++)\n    {\n        if(s[i] == 'R') s[i]='o';\n        else s[i]='x';\n    }\n    if(count(s, s+m, 'o') == m)\n    {\n        for(k=0;k<2;k++)\n        {\n            d[0][k]=1;\n            d[0][!k]=0;\n            for(i=1;i<n;i++)\n            {\n                d[i][0]=d[i-1][0]+d[i-1][1];\n                d[i][1]=d[i-1][0];\n                d[i][0]%=MOD, d[i][1]%=MOD;\n            }\n            if(k == 0)\n            {\n                ans+=d[n-1][0]+d[n-1][1];\n            }\n            else\n            {\n                ans+=d[n-1][0];\n            }\n        }\n        ans%=MOD;\n    }\n    else\n    {\n        if(n%2 == 1)\n        {\n            return !printf(\"0\\n\");\n        }\n        n/=2;\n        int mi=MAX;\n        int cur=0;\n        int flag=0;\n        for(i=0;i<m;i++)\n        {\n            if(s[i] == 'o') cur++;\n            else\n            {\n                if(cur)\n                {\n                    if(flag == 0)\n                    {\n                        if(cur%2 == 0) cur++;\n                    }\n                    else\n                    {\n                        if(cur%2 == 0) continue;\n                    }\n                    mi=min(mi, cur);\n                    flag=1;\n                }\n                cur=0;\n            }\n        }\n        mi/=2;\n        if(mi >= n-1)\n        {\n            ans=1;\n            for(i=0;i<n;i++) ans*=2, ans%=MOD;\n            ans--;\n            ans+=MOD;\n            ans%=MOD;\n        }\n        else\n        {\n            u[0]=v[0]=1;\n            u[1]=1, v[1]=2;\n            for(i=2;i<n;i++)\n            {\n                int idx=max(-1, i-mi-2);\n                u[i]=(v[i-1]-(idx==-1?0:v[idx]))%MOD;\n                u[i]+=MOD;\n                u[i]%=MOD;\n                v[i]=v[i-1]+u[i];\n                v[i]%=MOD;\n            }\n            for(i=n-1;i>=n-1-mi;i--)\n            {\n                ans+=u[i]*(n-i);\n                ans%=MOD;\n            }\n        }\n        ans*=2;\n        ans%=MOD;\n    }\n    ans+=MOD;\n    ans%=MOD;\n    cout<<ans<<endl;\n    return 0;\n}\n//*/"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vec>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\nmain(){\n    ios\n    calc();\n    int n=in(),m=in();\n    string s;cin>>s;\n    bool all_same=true;\n    rep(i,m){\n        if(s[i]!=s[0])all_same=false;\n    }\n    if(!all_same and (n&1)){\n        cout<<0<<endl;\n    }\n    else if(all_same){\n        mint dp[n+1][2]={};\n        dp[0][0]=1;\n        rep(i,n-1){\n            dp[i+1][1]+=dp[i][0];\n            dp[i+1][0]+=dp[i][0]+dp[i][1];\n        }\n        mint ans=dp[n-1][0]+dp[n-1][1];\n        rep(i,n)dp[i][0]=dp[i][1]=0;\n        dp[0][1]=1;\n        rep(i,n-1){\n            dp[i+1][1]+=dp[i][0];\n            dp[i+1][0]+=dp[i][0]+dp[i][1];\n        }\n        ans+=dp[n-1][0];\n        cout<<ans.a<<endl;\n    }\n    else{\n        char c=s[0];\n        int mi=INT_MAX;\n        rep(i,m){\n            int cnt=0;\n            while(i<m && s[i]==c)cnt++,i++;\n            chmin(mi,cnt);break;\n        }\n        if(mi %2 ==0)mi++;\n        rep(i,m){\n            if(s[i]==c){\n                int cnt=0;\n                while(i<m && s[i]==c)cnt++,i++;\n                i--;\n                if(cnt&1)\n                chmin(mi,cnt);\n            }\n        }\n        mint dp[700000]={};\n        mi=(mi+1)/2;\n        rep(i,mi){\n            dp[i]=2;\n        }\n        dp[mi]=-2*mi;\n        rep(i,n/2){\n            dp[i+1]+=dp[i]*2;\n            dp[i+1+mi]-=dp[i];\n        }\n        cout<<dp[n/2-1].a<<endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod = 1e9+7;\nint n,m;\nchar ss[200005];\nint f[200005],qz[200005];\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",&ss[1]);\n\tbool mk = 0;\n\tint mx = 0;\n\tfor(int i=1;i<=m;i++) {\n\t\tif(ss[i]!=ss[1]) { mk = 1; mx = i-1; break; }\n\t}\n\tif(!mk) {\n\t\tint ans = 1;\n\t\tf[0] = qz[0] = 1;\n\t\tfor(int i=0;i<=n;i++) {\n\t\t\tif(i>=2) f[i] = qz[i-2];\n\t\t\tif(i!=0)qz[i] = (qz[i-1]+f[i])%mod;\n\t\t\tif(n-i>=2) ans = (ans+1ll*f[i]*(n-i)%mod)%mod;\n\t\t}\n\t\tprintf(\"%d\",ans);\n\t\treturn 0;\n\t}\n\tif(n&1) {\n\t\tputs(\"0\"); return 0;\n\t}\n\tint lx = 0;\n\tfor(int i=1;i<=m;i++) {\n\t\tif(ss[i]==ss[1]) lx++;\n\t\telse {\n\t\t\tif(lx&1) mx = min(mx,lx);\n\t\t\tlx = 0;\n\t\t}\n\t}\n\tmx = (mx+1)/2;\n\tn/=2;\n\tf[0] = qz[0] = 1;\n\tint ans = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tf[i] = (qz[i-1] - (i-mx-1>=0?qz[i-mx-1]:0) )%mod;\n\t\tqz[i] = (qz[i-1]+f[i])%mod;\n\t\tif(n-i<=mx) ans = (ans + 1ll * f[i]*2%mod*(n-i)%mod )%mod;\n\t}\n\tprintf(\"%d\",(ans%mod+mod)%mod );\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n \nusing namespace std;\n \nconst int MOD = 1000000007;\n \ntemplate<typename T>\nclass RangeAddQuery {\npublic:\n    explicit RangeAddQuery(int n) : N(calcN_(n)) {\n        mVal.assign(2*N+1, 0);\n    }\n    void update(int l, int r, T value){\n        l = max(0, l);\n        r = min(N, r);\n        int offset = N;\n        while(offset > 0){\n            if(l >= r) break;\n            if(l&1){ update_(mVal[offset+l-1], value); l++; }\n            if(r&1){ update_(mVal[offset+r-2], value); }\n            l /= 2;\n            r /= 2;\n            offset /= 2;\n        }\n    }\n    T get(int idx){\n        int i = N + idx - 1;\n        auto res = mVal[i];\n        while(i > 0){\n            i = (i-1)/2;\n            update_(res, mVal[i]);\n        }\n        return res;\n    }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    inline void update_(T& data, T val) { data = (data + val) % MOD; }\n    const int N;\n    vector<T> mVal;\n};\n \nint maxSegment(const string& S){\n    char c = S[0];\n    bool first = true;\n    int cnt = 0;\n    int res = MOD;\n    for(auto& s : S){\n        if(c == s) ++cnt;\n        else {\n            if(first || cnt%2 == 1){\n                res = min(res, cnt/2+1);\n                cnt = 0;\n                first = false;\n            }\n        }\n    }\n    return res < MOD ? res : -1;\n}\n \nint solve(const string& S, int N){\n    int seg = maxSegment(S);\n    if(seg != -1 && N%2 == 1) return 0;\n    long long res = 0;\n    if(seg == -1){\n        RangeAddQuery<long long> raq(N);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N;i++){\n            auto a = raq.get(i);\n            raq.update(i+2, N, a);\n        }\n        res = 1;\n        for(int i=N-2;i>=0;i--){\n            res = (res + raq.get(i) * (N-i)) % MOD;\n        }\n    } else {\n        assert(seg <= N/2);\n        seg = min(seg, N/2);\n        RangeAddQuery<long long> raq(N/2);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N/2;i++){\n            auto a = raq.get(i);\n            raq.update(i+1, i+1+seg, a);\n        }\n        for(int i=N/2-1;i>=N/2-seg;i--){\n            res = (res + raq.get(i) * 2LL * (N/2-i)) % MOD;\n        }\n    }\n    return res;\n}\n \nint main(){\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    cout << solve(S, N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = (int) 1e9 + 7;\n\ninline void add(int &x, int y) {\n  x += y;\n  if (x >= md) {\n    x -= md;\n  }\n}\n\ninline void sub(int &x, int y) {\n  x -= y;\n  if (x < 0) {\n    x += md;\n  }\n}\n\ninline int mul(int x, int y) {\n  return (int) ((long long) x * y % md);\n}\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  string s;\n  cin >> n >> m >> s;\n  if (s[0] == 'B') {\n    for (auto &c : s) {\n      c ^= 'R' ^ 'B';\n    }\n  }\n  int first = m;\n  for (int i = 0; i < m; ++i) {\n    if (s[i] == 'B') {\n      first = i;\n      break;\n    }\n  }\n  if (first == m) {\n    vector<int> dp(4);\n    dp[0] = dp[3] = 1;\n    for (int i = 1; i < n; ++i) {\n      vector<int> new_dp(4);\n      for (int a = 0; a < 2; ++a) {\n        for (int b = 0; b < 2; ++b) {\n          for (int c = 0; c < 2; ++c) {\n            if (!b || !c) {\n              add(new_dp[a * 2 + b], dp[a * 2 + c]);\n            }\n          }\n        }\n      }\n      swap(dp, new_dp);\n    }\n    int ans = 0;\n    for (int i = 0; i < 3; ++i) {\n      add(ans, dp[i]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n  }\n  int last = m - 1;\n  while (s[last] == 'R') {\n    --last;\n  }\n  int limit = n, cur = 0;\n  for (int i = last; i >= -1; --i) {\n    if (i == -1 || s[i] == 'B') {\n      if (cur) {\n        if (cur & 1) {\n          limit = min(limit, cur + 1);\n        } else if (i == -1) {\n          limit = min(limit, cur + 2);\n        }\n        cur = 0;\n      }\n    } else {\n      ++cur;\n    }\n  }\n  vector<int> dp(n + 1);\n  dp[0] = dp[2] = 1;\n  for (int i = 4; i <= n; ++i) {\n    dp[i] = mul(dp[i - 2], 2);\n    if (i >= limit + 2) {\n      sub(dp[i], dp[i - (limit + 2)]);\n    }\n  }\n  int ans = 0;\n  for (int i = 2; i <= limit; i += 2) {\n    add(ans, mul(dp[n - i], i));\n  }\n  cout << ans << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n \n#include <algorithm>\n#include <tuple>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n \n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n \ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int N = 200010, P = 1000000007;\n\nint n, m;\nchar s[N];\n\nvoid add(int& x, int y) {\n  if ((x += y) >= P)\n    x -= P;\n}\n\nvoid sub(int& x, int y) {\n  if ((x -= y) < 0)\n    x += P;\n}\n\nint norm(int x) {\n  return x >= P ? x - P : x;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  cin >> n >> m >> (s + 1);\n  char a = s[1];\n  if (count(s + 1, s + m + 1, a) == m) {\n    static int dp[N][2][2];\n    dp[1][0][0] = dp[1][1][1] = 1;\n    for (int i = 2; i <= n; ++i)\n      for (int j = 0; j < 2; ++j) {\n        add(dp[i][j][0], dp[i - 1][j][0]);\n        add(dp[i][j][0], dp[i - 1][j][1]);\n        add(dp[i][j][1], dp[i - 1][j][0]);\n      }\n    int ans = norm(norm(dp[n][0][0] + dp[n][0][1]) + dp[n][1][0]);\n    cout << ans << '\\n';\n    return 0;\n  }\n  int p = 1;\n  while (s[p] == a) ++p;\n  int len = p - 1;\n  if (len % 2 == 0) ++len;\n  int cur = 0;\n  for (; p <= m; ++p)\n    if (s[p] != a) {\n      if (cur & 1)\n        len = min(len, cur);\n      cur = 0;\n    } else\n      ++cur;\n  static int dp[N], sum[N];\n  dp[1] = 1;\n  for (int i = 2; i <= n; ++i) {\n    sum[i - 1] = dp[i - 1];\n    if (i - 3 >= 0)\n      add(sum[i - 1], sum[i - 3]);\n    dp[i] = sum[i - 2];\n    if (i - len - 3 >= 0)\n      sub(dp[i], sum[i - len - 3]);\n  }\n  int ans = 0;\n  for (int i = 1; i <= n; ++i)\n    if ((n - i) <= len && ((n - i) & 1))\n      ans = ans + (dp[i] * (n - i + 1LL)) % P;\n  cout << ans << '\\n';\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define ROF(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\nconst int N=200200,P=1e9+7;\nint n,m,ans,lim,all,mxo;\nint b[N],f[N],s[N];\nchar S[N];\nvoid work(int w){\n\tf[0]=s[0]=1;//cout<<w<<' '<<lim<<'\\n';\n\tif(w==1){\n\t\tf[1]=0;s[1]=1;\n\t\tFOR(i,2,n){\n\t\t\tf[i]=s[i-2];\n\t\t\ts[i]=(s[i-1]+f[i])%P;\n\t\t\t//cout<<f[i]<<' ';\n\t\t}\n\t}\n\telse{\n\t\tFOR(i,1,n){\n\t\t\tf[i]=(s[i-1]-(i-lim-1<0?0:s[i-lim-1])+P)%P;\n\t\t\ts[i]=(s[i-1]+f[i])%P;\n\t\t\t//cout<<f[i]<<'\\n';\n\t\t}\n\t}\n\tFOR(i,1+(w==1),min(lim,n)) (ans+=1ll*i*f[n-i]%P)%=P;\n\tcout<<w*ans%P<<'\\n';\n}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d%d%s\",&n,&m,S+1);\n\tROF(i,m,1) b[i]=S[i]=='R'^S[1]=='B';\n\tall=1;\n\tFOR(i,1,m) all&=b[i];\n\tif(all) return lim=n,ans=1,work(1),0;\n\tFOR(i,1,m)if(!b[i]){lim=i-!(i%2);break;}\n\tfor(int l=1,r=1;l<=m;l=r){\n\t\twhile(r<=m && b[r]==b[l]) r++;\n\t\tif(b[l]==0) continue;\n\t\tif(r-l&1) mxo=max(mxo,r-l);\n\t}\n\tif(mxo) lim=min(lim,mxo);\n\tlim=lim+1>>1;n/=2;work(2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma optimize \"-O3\"\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int mod = (int)1e9 + 7;\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n}\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\nconst int maxN = 2 * (int)1e5 + 100;\nint n, m;\nstring s;\nint dp[maxN][2][2];\nint f[maxN];\nint pref[maxN][2];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n   // freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> m >> s;\n    if (s[0] == 'B') {\n        for (int i = 0; i < m; i++) {\n            s[i] = 'R' + 'B' - s[i];\n        }\n    }\n    while (!s.empty() && s.back() == 'R') s.pop_back();\n    if (s.empty()) {\n        // 1 - B\n        // 0 - R\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                if (i == 1 && j == 1) continue;\n                dp[0][i][j] = 1;\n            }\n        }\n        for (int i = 0; i + 1 <= n - 2; i++) {\n            for (int was = 0; was < 2; was++) {\n                for (int last = 0; last < 2; last++) {\n                    for (int nlast = 0; nlast < 2; nlast++) {\n                        if (nlast == 1 && last == 1) continue;\n                        dp[i + 1][was][nlast] = sum(dp[i + 1][was][nlast], dp[i][was][last]);\n                    }\n                }\n            }\n        }\n        int sm = 0;\n        for (int last = 0; last < 2; last++) {\n            for (int cur = 0; cur < 2; cur++) {\n                if (last == 1 && cur == 1) continue;\n                sm = sum(dp[n - 2][last][cur], sm);\n            }\n        }\n        cout << sm << '\\n';\n        return 0;\n    }\n    int limR = 0;\n    int cnt = 0;\n    m = s.size();\n    for (int i = 0; i < m; i++) {\n        if (s[i] == 'B') break;\n        cnt++;\n    }\n    if (cnt % 2 == 0) {\n        limR = cnt + 1;\n    }\n    else {\n        limR = cnt;\n    }\n    assert(s[m - 1] == 'B');\n    for (int i = 0; i + 1 < m; i++) {\n        if (s[i] == 'B' && s[i + 1] != 'B') {\n            int tot = 0;\n            for (int j = i + 1; ; j++) {\n                if (s[j] == 'B') break;\n                tot++;\n            }\n            if (tot % 2 == 0) continue;\n            limR = min(limR, tot);\n        }\n    }\n  //  cout << limR << endl;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 0; j < 2; j++) {\n            pref[i][j] = sum(pref[i][j], pref[i - 1][j]);\n        }\n        if (i % 2 == 1 && i <= limR) f[i] = sum(f[i], 1);\n        if (i >= 2) {\n            f[i] = sum(f[i], sub(pref[i - 2][i % 2], pref[max(0, i - limR - 2)][i % 2]));\n        }\n        pref[i][i % 2] = sum(pref[i][i % 2], f[i]);\n    }\n    int ans = 0;\n    for (int red1 = 1; red1 <= limR; red1 += 2) {\n        if (n == red1 + 1) {\n            ans = sum(ans, n);\n            continue;\n        }\n        int le = n - red1 - 2;\n        if (le < 0) continue;\n        ans = sum(ans, mult(f[le], red1 + 1));\n    }\n    cout << ans;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define int long long\nusing namespace std;\nconst int N = 2e5 + 5, mod = 1e9 + 7;\nint read() {\n\tint x = 0, f = 1; char ch;\n\twhile(! isdigit(ch = getchar())) (ch == '-') && (f = -f);\n\tfor(x = ch ^ 48; isdigit(ch = getchar()); x = (x << 3) + (x << 1) + (ch ^ 48));\n\treturn x * f;\n}\ntemplate <class T> T Max(T a, T b) { return a > b ? a : b; }\ntemplate <class T> T Min(T a, T b) { return a < b ? a : b; }\nchar s[N];\nint n, m, k = 2e9, ans, a[N], b[N], f[N];\nsigned main() {\n\tn = read(); m = read(); scanf(\"%s\", s + 1);\n\tint tag = 1;\n\tfor(int i = 1, len = 0; i <= m; ++ i) {\n\t\tif(s[i] != s[1]) {\n\t\t\tif(tag || len & 1) k = min(k, len / 2 + 1);\n\t\t\ttag = len = 0;\n\t\t}\n\t\telse ++ len;\n\t}\n\tif(tag) {\n\t\tf[0] = 0; f[1] = 1;\n\t\tfor(int i = 2; i <= n; ++ i) f[i] = (f[i - 1] + f[i - 2]) % mod;\n\t\tprintf(\"%lld\\n\", (2 * f[n - 1] + f[n]) % mod);\n\t\treturn 0;\n\t}\n\tif(n & 1) return puts(\"0\"), 0;\n\tn /= 2;// k = min(k, n);\n\ta[0] = b[0] = 1;\n\tfor(int i = 1; i <= n; ++ i) {\n\t\ta[i] = b[i - 1];\n\t\tif(i > k) a[i] = ((a[i] - b[i - k - 1]) % mod + mod) % mod;\n\t\tb[i] = (b[i - 1] + a[i]) % mod; \n\t}\n\tfor(int i = 1; i <= k; ++ i) ans = (ans + 2 * i * a[n - i]) % mod;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-03 17:07:09\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=2000010,mod=1000000007;\ni64 n,m,flag,l,Flag;\ni64 f[N],F[N],ans;\nchar s[N];\nnamespace std\n{\n\tint main()\n\t{\n\t\ti64 i,j,t;\n\t\tfor(i=1;i<=m;i++) if(s[i]!=s[1]) break;\n//\t\tif(i-1+((i-1)%2==0)!=l) exit(1);\n\t\tl=i-1;\n\t\tif(l%2==0) l++;\n\t\tfor(t=0;i<=m;i++)\n\t\t{\n\t\t\tif(s[i]==s[1]) t++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(t&1) l=min(l,t);\n\t\t\t\tt=0;\n\t\t\t}\n\t\t}\n\t\tn/=2,l=(l+1)/2;\n\t\treturn 0;\n\t}\n}\nint main()\n{\n\tn=read(); m=read();\n\tscanf(\"%s\",s+1);\n\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\tif(!flag)\n\t{\n\t\tf[0]=1; f[1]=1; f[2]=2;\n\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t\treturn 0;\n\t}\n\tfor(int i=1,j;i<=m;)\n\t\tif(s[i]==s[1])\n\t\t{\n\t\t\tj=i;\n\t\t\twhile(s[j]==s[1]) j++;\n\t\t\tif(j>n) break;\n\t\t\tif(i!=1&&!Flag) return 1;\n\t\t\tif(!Flag) l=j-i+((j-i)%2==0);\n\t\t\telse if((j-i)&1) l=std::min(l,(i64)(j-i));\n\t\t\ti=j+1; Flag=1;\n\t\t}\n\t\telse i++;\n\tif(n&1){ printf(\"0\\n\"); return 0; }\n\tstd::main();\n//\tprintf(\"%d %d\\n\",int(n),int(l));\n\tf[0]=F[0]=1;\n\tfr(i,1,n)\n\t{\n\t\tf[i]=(F[i-1]+mod-(i-l-1>=0?F[i-l-1]:0))%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t}\n\tans=f[n];\n\tfr(i,1,l) ans=(ans+f[n-i]*(2*i-1))%mod;\n\tprintf(\"%d\\n\",int(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MAX_N 200000\n#define MAX_M 200000\n#define MOD 1000000007\n\n#define INF 1 << 29\n\nint N, M;\nstring S;\n\n// long long dp[MAX_N + 2], rdp[MAX_N + 2];\n\n// int all_color_is_same()\n// {\n//     long long rr = 1, bb = 1, rb = 0, br = 0;\n\n//     for ( int i = 1; i < N; i++ )\n//     {\n//         long long nrr = ( rr + rb ) % MOD;\n//         long long nbb = br;\n//         long long nrb = rr;\n//         long long nbr = ( bb + br ) % MOD;\n\n//         rr = nrr;\n//         bb = nbb;\n//         rb = nrb;\n//         br = nbr;\n//     }\n\n//     return ( rr + rb + br ) % MOD;\n// }\n\n// /**\n\n/* S\nの先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n*/\nint min_freq()\n{\n    int l = 0;\n    while ( l < M && S[0] == S[l] ) l++;\n\n    int ans = ( l & 1 ) ? l : l + 1;\n\n    l = 0;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[0] == S[i] )\n            l++;\n        else if ( l & 1 )\n        {\n            ans = min( ans, l );\n            l = 0;\n        }\n    }\n    return l ? min( ans, l ) : ans;\n}\n\n// int solve()\n// {\n//     // 一色\n//     if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n//         return all_color_is_same();\n\n//     // N が奇数\n//     if ( N & 1 ) return 0;\n\n//     int L = min_freq();\n\n//     L = ( L + 1 ) >> 1;\n//     N >>= 1;\n\n//     dp[0] = rdp[0] = 1;\n//     for ( int i = 1; i <= N + 1; i++ )\n//     {\n//         dp[i] = rdp[i - 1];\n//         if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n//         if ( dp[i] < 0 ) dp[i] += MOD;\n//         rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n//     }\n\n//     long long res = 0;\n//     for ( int i = 1; i <= L; i++ )\n//         if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n//     return res % MOD;\n// }\n\n// int main( int argc, char **argv )\n// {\n//     cin >> N >> M;\n//     cin >> S;\n\n//     int ans = solve();\n\n//     cout << ans << endl;\n\n//     return 0;\n// }\n// #include <algorithm>\n// #include <iostream>\n// #include <string>\n\n// using namespace std;\n\n// #define MOD 1000000007\n// #define INF ( 1 << 29 )\n// #define LINF ( 1LL << 60 )\n// #define EPS ( 1e-10 )\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt all( Int n )\n{ // no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for ( int i = 1; i < n; i++ )\n    {\n        Int nrr = ( rr + rb ) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = ( bb + br ) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return ( rr + rb + br ) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc( Int n, Int limit )\n{\n    dp[0] = 1;\n    rdp[0] = 1;\n    for ( int i = 1; i <= n + 1; i++ )\n    {\n        dp[i] = ( rdp[i - 1] -\n                  ( ( i - limit - 1 ) >= 0 ? rdp[i - limit - 1] : 0 ) ) %\n                MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n}\n\nInt solve( Int n, Int limit )\n{\n    if ( n % 2 == 1 ) return 0;\n    if ( limit % 2 != 1 ) exit( 1 );\n    limit = ( limit + 1 ) / 2;\n    n /= 2;\n    Int res = 0;\n    calc( n + 10, limit );\n    for ( Int i = 1; i <= limit; i++ )\n    {\n        if ( n - i >= 0 ) res = ( res + dp[n - i] * 2 * i ) % MOD;\n    }\n    if ( res < 0 ) exit( 1 );\n    return res % MOD;\n}\n\nint main()\n{\n    cin >> N >> M;\n    cin >> S;\n\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n    {\n        cout << all( N ) << endl;\n        return 0;\n    }\n\n    Int l = 0;\n    while ( S[0] == S[l] ) l++;\n    if ( l % 2 == 0 ) l++;\n    Int limit = l;\n    l = 0;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[i] == S[0] )\n            l++;\n        else\n        {\n            if ( l % 2 == 1 ) limit = min( limit, l );\n            l = 0;\n        }\n    }\n    cout << solve( N, limit ) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/01/29] 12:36:49\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nvoid outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\n\n\ntemplate<typename T> T gcd(const T& a, const T& b) { return a < 0 ? gcd(-a, b) : b < 0 ? gcd(a, -b) : (a > b ? gcd(b, a) : a == 0 ? b : gcd(b % a, a)); }\ntemplate<typename T> T lcm(const T& a, const T& b) { return a / gcd(a, b) * b; }\ntemplate<typename T>\nconstexpr std::pair<T, T> extgcd(const T a, const T b)\n{\n    if (b == 0) { return std::pair<T, T>{1, 0}; }\n    const auto g = gcd(a, b), da = std::abs(b) / g;\n    const auto p = extgcd(b, a % b);\n    const auto x = (da + p.second % da) % da, y = (g - a * x) / b;\n    return {x, y};\n}\ntemplate<typename T>\nconstexpr T inverse(const T a, const T mod) { return extgcd(a, mod).first; }\ntemplate<uint mod_value, bool dynamic = false>\nclass modint_base\n{\npublic:\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, const UInt> mod() { return mod_ref(); }\n    template<typename UInt = uint>\n    static constexpr std::enable_if_t<not dynamic, const UInt> mod() { return mod_value; }\n    template<typename UInt = uint>\n    static void set_mod(const std::enable_if_t<dynamic, const UInt> mod) { mod_ref() = mod, inv_ref() = {1, 1}; }\n    modint_base() : v{0} {}\n    modint_base(const ll val) : v{norm(static_cast<uint>(val % static_cast<ll>(mod()) + static_cast<ll>(mod())))} {}\n    modint_base(const modint_base& n) : v{n()} {}\n    explicit operator bool() const { return v != 0; }\n    bool operator!() const { return not static_cast<bool>(*this); }\n    modint_base& operator=(const modint_base& m) { return v = m(), (*this); }\n    modint_base& operator=(const ll val) { return v = norm(uint(val % static_cast<ll>(mod()) + static_cast<ll>(mod()))), (*this); }\n    friend modint_base operator+(const modint_base& m) { return m; }\n    friend modint_base operator-(const modint_base& m) { return make(norm(mod() - m.v)); }\n    friend modint_base operator+(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + m2.v)); }\n    friend modint_base operator-(const modint_base& m1, const modint_base& m2) { return make(norm(m1.v + mod() - m2.v)); }\n    friend modint_base operator*(const modint_base& m1, const modint_base& m2) { return make(static_cast<uint>(static_cast<ll>(m1.v) * static_cast<ll>(m2.v) % static_cast<ll>(mod()))); }\n    friend modint_base operator/(const modint_base& m1, const modint_base& m2) { return m1 * inv(m2.v); }\n    friend modint_base operator+(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) - val}; }\n    friend modint_base operator*(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const modint_base& m, const ll val) { return modint_base{static_cast<ll>(m.v) * inv(val)}; }\n    friend modint_base operator+(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) + val}; }\n    friend modint_base operator-(const ll val, const modint_base& m) { return modint_base{-static_cast<ll>(m.v) + val}; }\n    friend modint_base operator*(const ll val, const modint_base& m) { return modint_base{static_cast<ll>(m.v) * (val % static_cast<ll>(mod()))}; }\n    friend modint_base operator/(const ll val, const modint_base& m) { return modint_base{val * inv(static_cast<ll>(m.v))}; }\n    friend modint_base& operator+=(modint_base& m1, const modint_base& m2) { return m1 = m1 + m2; }\n    friend modint_base& operator-=(modint_base& m1, const modint_base& m2) { return m1 = m1 - m2; }\n    friend modint_base& operator*=(modint_base& m1, const modint_base& m2) { return m1 = m1 * m2; }\n    friend modint_base& operator/=(modint_base& m1, const modint_base& m2) { return m1 = m1 / m2; }\n    friend modint_base& operator+=(modint_base& m, const ll val) { return m = m + val; }\n    friend modint_base& operator-=(modint_base& m, const ll val) { return m = m - val; }\n    friend modint_base& operator*=(modint_base& m, const ll val) { return m = m * val; }\n    friend modint_base& operator/=(modint_base& m, const ll val) { return m = m / val; }\n    friend modint_base operator^(const modint_base& m, const ll n) { return power(m.v, n); }\n    friend modint_base& operator^=(modint_base& m, const ll n) { return m = m ^ n; }\n    friend bool operator==(const modint_base& m1, const modint_base& m2) { return m1.v == m2.v; }\n    friend bool operator!=(const modint_base& m1, const modint_base& m2) { return not(m1 == m2); }\n    friend bool operator==(const modint_base& m, const ll val) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const modint_base& m, const ll val) { return not(m == val); }\n    friend bool operator==(const ll val, const modint_base& m) { return m.v == norm(static_cast<uint>(static_cast<ll>(mod()) + val % static_cast<ll>(mod()))); }\n    friend bool operator!=(const ll val, const modint_base& m) { return not(m == val); }\n    friend std::istream& operator>>(std::istream& is, modint_base& m)\n    {\n        ll v;\n        return is >> v, m = v, is;\n    }\n    friend std::ostream& operator<<(std::ostream& os, const modint_base& m) { return os << m(); }\n    uint operator()() const { return v; }\n    static modint_base small_inv(const usize n)\n    {\n        auto& in = inv_ref();\n        if (n < in.size()) { return in[n]; }\n        for (usize i = in.size(); i <= n; i++) { in.push_back(-in[modint_base::mod() % i] * (modint_base::mod() / i)); }\n        return in.back();\n    }\n    std::pair<ll, ll> quad() const\n    {\n        const auto ans = quad_r(v, mod());\n        ll x = std::get<0>(ans), y = std::get<1>(ans);\n        if (y < 0) { x = -x, y = -y; }\n        return {x, y};\n    }\n\nprivate:\n    static std::tuple<ll, ll, ll> quad_r(const ll r, const ll p)  // r = x/y (mod p), (x,y,z) s.t. x=yr+pz\n    {\n        if (std::abs(r) <= 1000) { return {r, 1, 0}; }\n        ll nr = p % r, q = p / r;\n        if (nr * 2LL >= r) { nr -= r, q++; }\n        if (nr * 2LL <= -r) { nr += r, q--; }\n        const auto sub = quad_r(nr, r);\n        const ll x = std::get<0>(sub), z = std::get<1>(sub), y = std::get<2>(sub);\n        return {x, y - q * z, z};\n    }\n\n    template<typename UInt = uint>\n    static std::enable_if_t<dynamic, UInt&> mod_ref()\n    {\n        static UInt mod = 0;\n        return mod;\n    }\n    static uint norm(const uint x) { return x < mod() ? x : x - mod(); }\n    static modint_base make(const uint x)\n    {\n        modint_base m;\n        return m.v = x, m;\n    }\n    static modint_base power(modint_base x, ull n)\n    {\n        modint_base ans = 1;\n        for (; n; n >>= 1, x *= x) {\n            if (n & 1) { ans *= x; }\n        }\n        return ans;\n    }\n    static modint_base inv(const ll v) { return v <= 2000000 ? small_inv(static_cast<usize>(v)) : modint_base{inverse(v, static_cast<ll>(mod()))}; }\n    static std::vector<modint_base>& inv_ref()\n    {\n        static std::vector<modint_base> in{1, 1};\n        return in;\n    }\n    uint v;\n};\ntemplate<uint mod>\nusing modint = modint_base<mod, false>;\ntemplate<uint id>\nusing dynamic_modint = modint_base<id, true>;\n\n\ntemplate<typename Real>\nstruct complex\n{\n    using value_type = Real;\n    complex() : real{Real{0}}, imag{Real{0}} {}\n    complex(const complex&) = default;\n    complex(const Real& theta) : real(std::cos(theta)), imag(std::sin(theta)) {}\n    complex(const Real& r, const Real& i) : real{r}, imag{i} {}\n    ~complex() = default;\n    friend complex operator+(const complex& c) { return c; }\n    friend complex operator-(const complex& c) { return complex{-c.real, -c.imag}; }\n    friend complex operator+(const complex& c1, const complex& c2) { return complex{c1.real + c2.real, c1.imag + c2.imag}; }\n    friend complex operator-(const complex& c1, const complex& c2) { return complex{c1.real - c2.real, c1.imag - c2.imag}; }\n    friend complex operator*(const complex& c1, const complex& c2) { return complex{c1.real * c2.real - c1.imag * c2.imag, c1.real * c2.imag + c1.imag * c2.real}; }\n    friend complex operator*(const complex& c, const Real& r) { return complex{c.real * r, c.imag * r}; }\n    friend complex operator/(complex& c1, complex& c2) { c1* c2.conj() / c2.norm(); }\n    friend bool operator==(const complex& c1, const complex& c2) { return c1.real == c2.real and c1.imag == c2.imag; }\n    friend bool operator!=(const complex& c1, const complex& c2) { return not(c1 == c2); }\n    friend complex& operator+=(complex& c1, const complex& c2) { return c1.real += c2.real, c1.imag += c2.imag, c1; }\n    friend complex& operator-=(complex& c1, const complex& c2) { return c1.real += c2.real, c1.imag += c2.imag, c1; }\n    friend complex& operator*=(complex& c1, const complex& c2) { return c1 = c1 * c2; }\n    friend complex& operator*=(complex& c, const Real& r) { return c = c * r; }\n    friend complex& operator/=(complex& c1, const complex& c2) { return c1 = c1 / c2; }\n    complex conj() const { return complex{real, -imag}; }\n    Real norm() const { return real * real + imag * imag; }\n    Real abs() const { return std::sqrt(norm()); }\n    Real arg() const { return std::atan2(imag, real); }\n    friend std::ostream& operator<<(std::ostream& os, const complex& c) { return os << c.real << \"+\" << c.imag << \"i\"; }\n    Real real, imag;\n};\ntemplate<typename Real = double>\nclass fft\n{\nprivate:\n    static constexpr usize depth = 30;\n    static constexpr Real pi     = pi_v<Real>;\n    static void transform(std::vector<complex<Real>>& a, const usize lg, const bool rev)\n    {\n        static std::vector<complex<Real>> root[depth];\n        const usize sz = a.size();\n        assert((1UL << lg) == sz);\n        if (root[lg].empty()) {\n            root[lg].reserve(sz), root[lg].resize(sz);\n            for (usize i = 0; i < sz; i++) { root[lg][i] = complex<Real>(pi * Real(2 * i) / Real(sz)); }\n        }\n        std::vector<complex<Real>> tmp(sz);\n        for (usize w = (sz >> 1); w > 0; w >>= 1) {\n            for (usize y = 0; y < (sz >> 1); y += w) {\n                const complex<Real> r = rev ? root[lg][y].conj() : root[lg][y];\n                for (usize x = 0; x < w; x++) {\n                    const auto u = a[y << 1 | x], v = a[y << 1 | x | w] * r;\n                    tmp[y | x] = u + v, tmp[y | x | (sz >> 1)] = u - v;\n                }\n            }\n            std::swap(tmp, a);\n        }\n    }\n\npublic:\n    using value_type = Real;\n    fft()            = delete;\n    template<typename T = ll, typename I = int>\n    static std::vector<T> simple_convolute(const std::vector<I>& a, const std::vector<I>& b)\n    {\n        const usize need = a.size() + b.size() - 1, lg = clog(need), sz = 1UL << lg;\n        std::vector<complex<Real>> x(sz), y(sz);\n        for (usize i = 0; i < a.size(); i++) { x[i] = {(Real)a[i], (Real)0}; }\n        for (usize i = 0; i < b.size(); i++) { y[i] = {(Real)b[i], (Real)0}; }\n        transform(x, lg, false), transform(y, lg, false);\n        for (usize i = 0; i < sz; i++) { x[i] *= y[i]; }\n        transform(x, lg, true);\n        std::vector<T> ans(need);\n        for (usize i = 0; i < need; i++) { ans[i] = (T)std::round(x[i].real / (Real)sz); }\n        return ans;\n    }\n    template<typename T = ll, usize division = 2, typename I = int>\n    static std::vector<T> convolute(const std::vector<I>& a, const std::vector<I>& b)\n    {\n        constexpr usize bitnum = (depth + division - 1) / division;\n        const usize need = a.size() + b.size() - 1, lg = clog(need), sz = 1UL << lg;\n        std::vector<complex<value_type>> x[division], y[division], tmp(sz);\n        for (usize i = 0; i < division; i++) {\n            x[i].reserve(sz), x[i].resize(sz), y[i].reserve(sz), y[i].resize(sz);\n            std::fill(tmp.begin() + std::min(a.size(), b.size()), tmp.end(), complex<value_type>{});\n            for (usize j = 0; j < a.size(); j++) { tmp[j].real = value_type((a[j] >> (bitnum * i)) & ((1 << bitnum) - 1)); }\n            for (usize j = 0; j < b.size(); j++) { tmp[j].imag = value_type((b[j] >> (bitnum * i)) & ((1 << bitnum) - 1)); }\n            transform(tmp, lg, false);\n            for (usize j = 0; j < sz; j++) { tmp[j] *= value_type(0.5); }\n            for (usize j = 0; j < sz; j++) {\n                const usize k = j == 0 ? 0UL : sz - j;\n                x[i][j] = complex<value_type>{tmp[j].real + tmp[k].real, tmp[j].imag - tmp[k].imag}, y[i][j] = complex<value_type>{tmp[j].imag + tmp[k].imag, -tmp[j].real + tmp[k].real};\n            }\n        }\n        std::vector<complex<value_type>> z[division];\n        for (usize i = 0; i < division; i++) { z[i].reserve(sz), z[i].resize(sz); }\n        for (usize a = 0; a < division; a++) {\n            for (usize b = 0; b < division; b++) {\n                for (usize i = 0; i < sz; i++) {\n                    if (a + b < division) {\n                        z[a + b][i] += x[a][i] * y[b][i];\n                    } else {\n                        z[a + b - division][i] += x[a][i] * y[b][i] * complex<value_type>(0, 1);\n                    }\n                }\n            }\n        }\n        for (usize i = 0; i < division; i++) { transform(z[i], lg, true); }\n        std::vector<T> ans(need);\n        T base = 1;\n        for (usize k = 0; k < 2 * division - 1; k++, base *= (1LL << bitnum)) {\n            for (usize i = 0; i < need; i++) {\n                if (k < division) {\n                    ans[i] += base * T(std::round(z[k][i].real / value_type(sz)));\n                } else {\n                    ans[i] += base * T(std::round(z[k - division][i].imag / value_type(sz)));\n                }\n            }\n        }\n        return ans;\n    }\n    template<uint mod, bool dynamic = false, usize division = 2>\n    static std::vector<modint_base<mod, dynamic>> convolute(const std::vector<modint_base<mod, dynamic>>& a, const std::vector<modint_base<mod, dynamic>>& b)\n    {\n        using mint             = modint_base<mod, dynamic>;\n        constexpr usize bitnum = (depth + division - 1) / division;\n        const usize need = a.size() + b.size() - 1, lg = clog(need), sz = 1UL << lg;\n        std::vector<complex<value_type>> x[division], y[division], tmp(sz);\n        for (usize i = 0; i < division; i++) {\n            x[i].reserve(sz), x[i].resize(sz), y[i].reserve(sz), y[i].resize(sz);\n            std::fill(tmp.begin() + std::min(a.size(), b.size()), tmp.end(), complex<value_type>{});\n            for (usize j = 0; j < a.size(); j++) { tmp[j].real = value_type((a[j]() >> (bitnum * i)) & ((1 << bitnum) - 1)); }\n            for (usize j = 0; j < b.size(); j++) { tmp[j].imag = value_type((b[j]() >> (bitnum * i)) & ((1 << bitnum) - 1)); }\n            transform(tmp, lg, false);\n            for (usize j = 0; j < sz; j++) { tmp[j] *= value_type(0.5); }\n            for (usize j = 0; j < sz; j++) {\n                const usize k = j == 0 ? 0UL : sz - j;\n                x[i][j] = complex<value_type>{tmp[j].real + tmp[k].real, tmp[j].imag - tmp[k].imag}, y[i][j] = complex<value_type>{tmp[j].imag + tmp[k].imag, -tmp[j].real + tmp[k].real};\n            }\n        }\n        std::vector<complex<value_type>> z[division];\n        for (usize i = 0; i < division; i++) { z[i].reserve(sz), z[i].resize(sz); }\n        for (usize a = 0; a < division; a++) {\n            for (usize b = 0; b < division; b++) {\n                for (usize i = 0; i < sz; i++) {\n                    if (a + b < division) {\n                        z[a + b][i] += x[a][i] * y[b][i];\n                    } else {\n                        z[a + b - division][i] += x[a][i] * y[b][i] * complex<value_type>(0, 1);\n                    }\n                }\n            }\n        }\n        for (usize i = 0; i < division; i++) { transform(z[i], lg, true); }\n        std::vector<mint> ans(need);\n        mint base = 1;\n        for (usize k = 0; k < 2 * division - 1; k++, base *= (1LL << bitnum)) {\n            for (usize i = 0; i < need; i++) {\n                if (k < division) {\n                    ans[i] += int((base * ll(std::round(z[k][i].real / value_type(sz))))());\n                } else {\n                    ans[i] += int((base * ll(std::round(z[k - division][i].imag / value_type(sz))))());\n                }\n            }\n        }\n        return ans;\n    }\n};\n\ntemplate<uint mod = 924844033, uint root = 5>\nclass ntt\n{\nprivate:\n    using value_type             = modint<mod>;\n    static constexpr usize depth = 30;\n    static void transform(std::vector<value_type>& a, const usize lg, const bool rev)\n    {\n        const usize N = a.size();\n        assert(1UL << lg == N);\n        static std::vector<value_type> R[depth];\n        if (R[lg].empty()) {\n            R[lg].reserve(N), R[lg].resize(N, value_type(1));\n            const value_type r = value_type(root) ^ ((mod - 1) / N);\n            for (usize i = 1; i < N; i++) { R[lg][i] = R[lg][i - 1] * r; }\n        }\n        std::vector<value_type> tmp(N);\n        for (usize w = (N >> 1); w > 0; w >>= 1) {\n            for (usize y = 0; y < (N >> 1); y += w) {\n                const value_type r = rev ? R[lg][y == 0 ? 0 : N - y] : R[lg][y];\n                for (usize x = 0; x < w; x++) {\n                    const auto u = a[y << 1 | x], v = a[y << 1 | x | w]() * r;\n                    tmp[y | x] = u + v, tmp[y | x | (N >> 1)] = u - v;\n                }\n            }\n            std::swap(tmp, a);\n        }\n        if (rev) {\n            for (usize i = 0; i < N; i++) { a[i] /= value_type(N); }\n        }\n    }\n\npublic:\n    ntt() = delete;\n    static std::vector<value_type> convolute(const std::vector<value_type>& a, const std::vector<value_type>& b)\n    {\n        const usize need = a.size() + b.size() - 1, lg = clog(need), sz = 1UL << lg;\n        std::vector<value_type> A(sz, 0), B(sz, 0);\n        for (usize i = 0; i < a.size(); i++) { A[i] = a[i](); }\n        for (usize i = 0; i < b.size(); i++) { B[i] = b[i](); }\n        transform(A, lg, false), transform(B, lg, false);\n        for (usize i = 0; i < sz; i++) { A[i] *= B[i]; }\n        transform(A, lg, true);\n        std::vector<value_type> ans(need);\n        for (usize i = 0; i < need; i++) { ans[i] = int(A[i]()); }\n        return ans;\n    }\n};\ntemplate<uint mod, uint root, bool dynamic, uint fft_division>\nclass poly_base\n{\npublic:\n    using value_type = modint_base<mod, dynamic>;\n    poly_base() : v(0) {}\n    poly_base(const value_type& r) : v{r} { shrink(); }\n    poly_base(const std::vector<value_type>& v) : v{v} { shrink(); }\n    poly_base(const std::initializer_list<value_type>&& list) : v{list} { shrink(); }\n    std::vector<value_type> operator()() const { return v; }\n    value_type& operator[](const usize i) { return v[i]; }\n    const value_type& operator[](const usize i) const { return v[i]; }\n    value_type at(const usize i) const { return i < size() ? v[i] : value_type(0); }\n    friend poly_base operator+(const poly_base& p) { return p; }\n    friend poly_base operator-(const poly_base& p)\n    {\n        std::vector<value_type> ans = p.v;\n        for (auto& e : ans) { e = -e; }\n        return poly_base(ans);\n    }\n    friend poly_base operator+(const poly_base& p, const poly_base& q)\n    {\n        const usize sz = std::max(p.size(), q.size());\n        std::vector<value_type> ans(sz);\n        for (usize i = 0; i < sz; i++) { ans[i] = p.at(i) + q.at(i); }\n        return poly_base(ans);\n    }\n    friend poly_base operator-(const poly_base& p, const poly_base& q)\n    {\n        const usize sz = std::max(p.size(), q.size());\n        std::vector<value_type> ans(sz);\n        for (usize i = 0; i < sz; i++) { ans[i] = p.at(i) - q.at(i); }\n        return poly_base(ans);\n    }\n    friend poly_base operator*(const poly_base& p, const poly_base& q) { return p.size() <= 300 or q.size() <= 300 ? naive_multiply(p, q) : fft_multiply(p, q); }\n    friend poly_base operator*(const poly_base& p, const value_type& r)\n    {\n        std::vector<value_type> ans = p.v;\n        for (auto& e : ans) { e *= r; }\n        return poly_base(ans);\n    }\n    friend poly_base operator/(const poly_base& p, const value_type& r)\n    {\n        std::vector<value_type> ans = p.v;\n        for (auto& e : ans) { e /= r; }\n        return poly_base(ans);\n    }\n    friend poly_base operator>>(const poly_base& p, const usize s) { return p.divide_by_power(s); }\n    friend poly_base operator<<(const poly_base& p, const usize s) { return p.multiply_power(s); }\n    friend poly_base operator/(const poly_base& p, const poly_base& q) { return p.div(q); }\n    friend poly_base operator%(const poly_base& p, const poly_base& q) { return p.rem(q); }\n    friend poly_base& operator+=(poly_base& p, const poly_base& q) { return p = p + q; }\n    friend poly_base& operator-=(poly_base& p, const poly_base& q) { return p = p - q; }\n    friend poly_base& operator*=(poly_base& p, const poly_base& q) { return p = p * q; }\n    friend poly_base& operator*=(poly_base& p, const value_type& r) { return p = p * r; }\n    friend poly_base& operator/=(poly_base& p, const value_type& r) { return p = p / r; }\n    friend poly_base& operator>>=(poly_base& p, const usize s) { return p = (p >> s); }\n    friend poly_base& operator<<=(poly_base& p, const usize s) { return p = (p << s); }\n    friend poly_base& operator/=(poly_base& p, const poly_base& q) { return p = p / q; }\n    friend poly_base& operator%=(poly_base& p, const poly_base& q) { return p = p % q; }\n    poly_base multiply_power(const usize s) const\n    {\n        const usize sz = size();\n        if (sz == 0) { return poly_base(); }\n        std::vector<value_type> ans(sz + s, 0);\n        for (usize i = 0; i < sz; i++) { ans[i + s] = v[i]; }\n        return poly_base(ans);\n    }\n    poly_base divide_by_power(const usize s) const\n    {\n        const usize N = size();\n        if (N <= s) { return poly_base(); }\n        std::vector<value_type> ans(N - s);\n        for (usize i = 0; i < N - s; i++) { ans[i] = v[i + s]; }\n        return poly_base(ans);\n    }\n    poly_base rem_by_power(const usize k) const { return size() <= k ? *this : poly_base(std::vector<value_type>(v.begin(), v.begin() + k)); }\n    poly_base inverse(const usize k) const\n    {\n        poly_base q{value_type(1) / v[0]};\n        const auto T = poly_base{2};\n        for (usize i = 1, j = 0; j < k; j++, i *= 2) { q = (q * (T - rem_by_power(2 * i) * q)).rem_by_power(2 * i); }\n        return q;\n    }\n    template<typename Int>\n    poly_base power_and_rem(const Int k, const usize s)\n    {\n        if (k == 0) { return poly_base(1); }\n        if (k % 2 == 1) {\n            return (power_and_rem(k - 1, s) * (*this)).rem_by_power(s);\n        } else {\n            const auto q = power_and_rem(k / 2, s);\n            return (q * q).rem_by_power(s);\n        }\n    }\n    template<typename Int>\n    static poly_base rem_of_power(const Int k, const poly_base& p)\n    {\n        const usize B = p.size() * 2 - 1;\n        const auto q  = p.pseudo_inv(B);\n        poly_base ans{1};\n        const usize D = log2p1<usize>(k);\n        for (usize i = 0; i < D; i++) {\n            if (k & (static_cast<Int>(1) << (D - i - 1))) { ans = (ans.multiply_power(1)).rem(p, q, B); }\n            if (D - i - 1) { ans = (ans * ans).rem(p, q, B); }\n        }\n        return ans;\n    }\n    usize size() const { return v.size(); }\n    friend std::ostream& operator<<(std::ostream& os, const poly_base& p)\n    {\n        if (p.size() == 0) { return os << \"0\"; }\n        for (usize i = 0; i < p.size(); i++) { os << (i != 0 ? \"+\" : \"\") << p[i] << (i != 0 ? i == 1 ? \"X\" : \"X^\" + std::to_string(i) : \"\"); }\n        return os;\n    }\n\nprivate:\n    static std::vector<value_type> naive_convolute(const std::vector<value_type>& a, const std::vector<value_type>& b)\n    {\n        std::vector<value_type> ans(a.size() + b.size() - 1, 0);\n        for (usize i = 0; i < a.size(); i++) {\n            for (usize j = 0; j < b.size(); j++) { ans[i + j] += a[i] * b[j]; }\n        }\n        return ans;\n    }\n    static poly_base naive_multiply(const poly_base& p, const poly_base& q) { return p.size() == 0 or q.size() == 0 ? poly_base{} : poly_base{naive_convolute(p(), q())}; }\n    template<typename Poly = poly_base>\n    static std::enable_if_t<root == 0, Poly> fft_multiply(const poly_base& p, const poly_base& q) { return p.size() == 0 or q.size() == 0 ? poly_base() : poly_base{fft<double>::convolute<mod, dynamic, fft_division>(p(), q())}; }\n    template<typename Poly = poly_base>\n    static std::enable_if_t<root != 0, Poly> fft_multiply(const poly_base& p, const poly_base& q) { return p.size() == 0 or q.size() == 0 ? poly_base() : poly_base{ntt<mod, root>::convolute(p(), q())}; }\n    poly_base rev(const usize l) const\n    {\n        std::vector<value_type> ans = v;\n        ans.resize(l), std::reverse(ans.begin(), ans.end());\n        return poly_base(ans);\n    }\n    poly_base div(const poly_base& q) const\n    {\n        assert(q.size() > 0);\n        if (size() < q.size()) { return poly_base(); }\n        const usize N = size();\n        const auto iq = q.pseudoInv(N);\n        return (*this * iq).divide_by_power(N - 1);\n    }\n    poly_base rem(const poly_base& q) const { return *this - div(q) * q; }\n    poly_base rem(const poly_base& q, const poly_base& iq, const usize B) { return *this - q * ((*this * iq).divide_by_power(B - 1)); }\n    void shrink()\n    {\n        for (; not v.empty() and v.back() == 0; v.pop_back()) {}\n    }\n    poly_base pseudo_inv(const usize B) const\n    {\n        const usize N = size();\n        return rev(N).inverse(B + 2 > N ? clog(B - N + 2) : 0).rev(B + 1 - N);\n    }\n    std::vector<value_type> v;\n};\ntemplate<uint mod, uint fft_division = 2>\nusing poly = poly_base<mod, 0, false, fft_division>;\ntemplate<uint mod, uint fft_division = 2>\nusing dynamic_poly = poly_base<mod, 0, true, fft_division>;\ntemplate<uint mod = 924844033, uint root = 5>\nusing ntt_poly = poly_base<mod, root, false, 0>;\nint main()\n{\n    using mint   = modint<mod>;\n    using P      = poly<mod>;\n    const auto N = in<int>(), M = in<int>();\n    auto S = in<std::string>();\n    if (S[0] == 'B') {\n        for (auto& c : S) { c = (c == 'R' ? 'B' : 'R'); }\n    }\n    if (S == std::string(M, 'R')) {\n        mint ans = 0;\n        mint r = 1, b = 0;\n        for (int i = 0; i < N - 2; i++) {\n            mint r_ = r, b_ = b;\n            r = r_ + b_, b = r_;\n        }\n        ans += r;\n        r = 1, b = 1;\n        for (int i = 0; i < N - 2; i++) {\n            mint r_ = r, b_ = b;\n            r = r_ + b_, b = r_;\n        }\n        ans += r + b;\n        return outln(ans);\n    }\n    if (N % 2 == 1) { return outln(0); }\n    S.push_back('$');\n    std::vector<int> ls;\n    char p = 'R';\n    int l  = 0;\n    for (int i = 0; i <= M; i++) {\n        if (S[i] != p) {\n            p = S[i];\n            ls.push_back(l);\n            l = 1;\n        } else {\n            l++;\n        }\n    }\n    SHOW(ls);\n    int m = inf_v<int>;\n    for (int i = 0; i+1 < ls.size(); i += 2) {\n        if (i == 0) {\n            chmin(m, ls[i] / 2 + 1);\n        } else if (ls[i] % 2 == 1) {\n            chmin(m, (ls[i] + 1) / 2);\n        }\n    }\n    SHOW(m);\n    const int n = N / 2;\n    // x1+x2+...+xk = n\n    // xi <= max\n    std::vector<mint> c(m + 1, 1);\n    for (int i = 1; i <= m; i++) { c[i] = -1; }\n    P f{c};\n    const auto g = f.inverse(clog(n + 1));\n    mint ans     = 0;\n    for (int r1 = 1; r1 <= std::min(n, m); r1++) { ans += g.at(n - r1) * 2 * r1; }\n    outln(ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//2019.5.19 by ljz\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define eps 1e-10\n#define RG register\ninline int read() {\n    res s=0,ch=getchar();\n    while(ch<'0'||ch>'9')ch=getchar();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return s;\n}\ninline LL Read() {\n    RG LL s=0;\n    res ch=getchar();\n    while(ch<'0'||ch>'9')ch=getchar();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=getchar();\n    return s;\n}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N=2e5+10;\nconst int kcz=1e9+7;\nnamespace MAIN {\n    int n,m,dp[N],p=1,sum[N],ans;\n    char str[N];\n    inline void add(res &x,const res &y){\n        x+=y,x>=kcz?x-=kcz:1;\n    }\n    inline int Add(const res &x,const res &y){\n        return x+y>=kcz?x+y-kcz:x+y;\n    }\n    inline int mul(const res &x,const res &y){\n        return int(1LL*x*y%kcz);\n    }\n    inline void MAIN(){\n        n=read(),m=read(),scanf(\"%s\",str+1);\n        for(;p<=m;p++)if(str[p]!=str[1])break;\n        p--,dp[0]=sum[0]=1;\n        if(p==m){\n            ans=1;\n            for(res i=0;i<=n;i++){\n                if(i>=2)dp[i]=sum[i-2];\n                sum[i]=Add(sum[i-1],dp[i]);\n                if(n-i>=2)add(ans,mul(dp[i],n-i));\n            }\n            printf(\"%d\\n\",ans);\n            return;\n        }\n        if(n&1){puts(\"0\");return;}\n        if(p%2==0)p++;\n        for(res t=0,i=p/2*2+1;i<=m;i++)\n            if(str[i]==str[1])t++;\n            else {\n                if(t&1)p=min(p,t);\n                t=0;\n            }\n        n>>=1,p=(p+1)>>1;\n        for(res i=0;i<=n;i++){\n            if(i)dp[i]=Add(sum[i-1],kcz-(i-p>0?sum[i-p-1]:0)),sum[i]=Add(sum[i-1],dp[i]);\n            if(n-i<=p)add(ans,mul(n-i,dp[i]<<1));\n        }\n        printf(\"%d\\n\",ans);\n    }\n}\nint main() {\n//    srand((unsigned)time(NULL));\n//    freopen(\"graph.in\",\"r\",stdin);\n//    freopen(\"graph.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=200005,mod=1e9+7;\nint n,m,c[N],k,lst,f[N],pfx[N],ans; char s[N];\ninline int sum(CI x,CI y)\n{\n\tint t=x+y; return t>=mod?t-mod:t;\n}\nnamespace SP //one char solver\n{\n\tint f[N][2][2];\n\tinline int solve(void)\n\t{\n\t\tf[1][0][0]=f[1][1][1]=1; for (RI i=2;i<=n;++i)\n\t\tf[i][0][0]=sum(f[i-1][0][0],f[i-1][0][1]),f[i][0][1]=f[i-1][0][0],\n\t\tf[i][1][0]=sum(f[i-1][1][0],f[i-1][1][1]),f[i][1][1]=f[i-1][1][0];\n\t\treturn sum(f[n][0][0],sum(f[n][0][1],f[n][1][0]));\n\t}\n};\nint main()\n{\n\tRI i; for (scanf(\"%d%d%s\",&n,&m,s+1),lst=1,i=2;i<=m;++i)\n\tif (s[i]!=s[i-1]) c[++k]=i-lst,lst=i; c[++k]=n-lst+1;\n\tif (k==1) return printf(\"%d\",SP::solve()),0; if (n&1) return puts(\"0\"),0;\n\tif (k&1) --k; int lim=c[1]+!(c[1]&1); for (i=3;i<=k;i+=2) if (c[i]&1) lim=min(lim,c[i]);\n\tfor (n>>=1,lim=lim+1>>1,f[0]=pfx[0]=i=1;i<=n;++i)\n\tf[i]=sum(pfx[i-1],mod-(i-1-lim>=0?pfx[i-1-lim]:0)),\n\tpfx[i]=sum(pfx[i-1],f[i]); for (i=1;i<=min(n,lim);++i)\n\tans=sum(ans,2LL*f[n-i]*i%mod); return printf(\"%d\",ans),0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tstring s;\n\tcin >> s;\n\tset<char>st;\n\tfor (auto i : s)st.insert(i);\n\tif (st.size() == 1) {\n\t\tvector<long long int>dp(N + 1);\n\t\tdp[0] = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1];\n\t\t\tif (i > 1)dp[i] += dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tlong long int ans = dp.back();\n\t\tdp[0] = 1;\n\t\tdp[1] = 0;\n\t\tfor (int i = 2; i <= N; i++) {\n\t\t\tdp[i] = dp[i - 1] + dp[i - 2];\n\t\t\tdp[i] %= MOD;\n\t\t}\n\t\tans += dp.back();\n\t\tans %= MOD;\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n\ts.push_back(s[0] + 1);\n\tvector<int>num(s.size() + 1);\n\tfor (int i = 0; i <= s.size(); i++) {\n\t\tnum[i] = s[i] == s[0];\n\t\tif (i)num[i] = num[i] * (num[i - 1] + 1);\n\t}\n\tbool even = true;\n\tint m = MOD;\n\tfor (int i = 1; i <= s.size(); i++) {\n\t\tif (!num[i] && num[i - 1]) {\n\t\t\tm = min(m, num[i - 1]);\n\t\t\tif (num[i - 1] & 1)even = false;\n\t\t}\n\t}\n\tif (even)m++;\n\tif (m & 1)m++;\n\tvector<long long int>dp(N + 2);\n\tvector<long long int>sum(N + 2);\n\tfor (int i = 2; i <= m; i += 2)dp[i] = i;\n\tfor (int i = 2; i <= N; i++) {\n\t\tdp[i] += sum[i - 2] + MOD;\n\t\tif (i - m - 2 >= 0)dp[i] -= sum[i - m - 2];\n\t\tdp[i] %= MOD;\n\t\tif (i == N) {\n\t\t\tcout << dp[i] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tsum[i] = sum[i - 2] + dp[i];\n\t\tsum[i] %= MOD;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5 + 5;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\ntemplate <typename T> void write(T x) {\n\tif (x < 0) x = -x, putchar('-');\n\tif (x > 9) write(x / 10);\n\tputchar(x % 10 + '0');\n}\ntemplate <typename T> void writeln(T x) {\n\twrite(x);\n\tputs(\"\");\n}\nint n, m;\nchar s[MAXN];\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nint main() {\n\tread(n), read(m);\n\tscanf(\"%s\", s + 1);\n\tbool same = true;\n\tfor (int i = 1; i <= m; i++)\n\t\tif (s[i] != s[1]) same = false;\n\tif (same) {\n\t\tstatic int dp[MAXN], sum[MAXN];\n\t\tdp[1] = sum[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tdp[i] = sum[i - 2];\n\t\t\tsum[i] = (sum[i - 1] + dp[i]) % P;\n\t\t}\n\t\tint ans = (sum[n - 1] + 1) % P;\n\t\tfor (int i = 2, j = n - 1; i <= n; i++, j--)\n\t\t\tupdate(ans, sum[j]);\n\t\tprintf(\"%d\\n\", ans);\n\t\treturn 0;\n\t}\n\tint Min = n - (n - 1) % 2;\n\tint last = 0;\n\tfor (int i = 1; i <= m; i++)\n\t\tif (s[i] != s[1]) {\n\t\t\tint len = i - last - 1;\n\t\t\tif (last == 0) chkmin(Min, len + 1);\n\t\t\tif (len % 2 == 1) chkmin(Min, len);\n\t\t\tlast = i;\n\t\t}\n\tstatic int dp[MAXN], sum[MAXN];\n\tdp[1] = sum[1] = 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tif (i % 2 == 1) {\n\t\t\tdp[i] = sum[i - 2];\n\t\t\tupdate(dp[i], P - sum[max(i - Min - 3, 0)]);\n\t\t}\n\t\tsum[i] = (sum[i - 1] + dp[i]) % P;\n\t}\n\tint ans = (sum[n - 1] - sum[max(n - Min - 2, 0)] + P) % P;\n\tfor (int i = 2, j = n - 1; i <= n && j >= n - Min - 2; i++, j--)\n\t\tupdate(ans, (sum[j] - sum[max(n - Min - 2, 0)] + P) % P);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <list>\n#include <iterator>\n#include <assert.h>\n#pragma warning(disable:4996) \n\ntypedef long long ll;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF 9223300000000000000\n#define INF 2140000000\nconst long long MOD = 1000000007;\nusing namespace std;\n\nchar str[200005];\n\n// A(Bを数個)A(Bを数個)..A(Bを数個) \n// という列の作り方が何通りあるか、を求める\n// ただし列の長さをn、Bを重ねるのは各箇所について0個以上k個以下とする\n// また両端がつながっているものとする。\nll func( int n, int k)\n{\n#ifdef _DEBUG\n    printf(\"%d %d\\n\", n, k);\n#endif\n    vector<ll> dp(n+1);   // dp[i]: func(i,k)と同じ。ただし両端がつながっていなくてAから始まるものとする。\n    vector<ll> sdp(n+2);  // dpの累積和\n    dp[0]=1;\n    sdp[0]=0; sdp[1]=1;\n    int i;\n    for(i=1; i<=n; i++) {\n        dp[i]=(sdp[i]-sdp[MAX(0,i-k-1)]+MOD)%MOD;\n        sdp[i+1]=(sdp[i]+dp[i])%MOD;\n    }\n    ll ans = dp[n];\n\n    // dp[n]は、Aから始まるものだけを数えたもの。\n    // 両端がつながっている状況で、Bから始まるものを数える\n    // Bが最初にp個重なった場合を考えて足し合わせればよい\n    int p;\n    for(p=1; p<=k; p++) {\n        // dp[n-p-1],dp[n-p-2],..という(k-p+1)個を足し合わせればよい\n        ans = (ans + sdp[n-p] - sdp[n-k-1] +MOD)%MOD;\n    }\n\n    return ans;\n}\n\nint main(int argc, char* argv[])\n{\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    scanf(\"%s\", str);\n\n    char c=str[0];\n    int max_odd=0;\n    int cnt_first=-1;\n    int cnt=0;\n    int cnt2=0;\n    int i;\n    for(i=0; i<m; i++) {\n        if(str[i]==c) {\n            cnt++;\n        }\n        else {\n            if(cnt_first<0) cnt_first=cnt;\n            if(cnt%2) max_odd = MAX(max_odd, cnt);\n            cnt=0;\n            cnt2++;\n        }        \n    }\n\n    if(cnt2==0) {\n        printf(\"%lld\\n\", func(n, 1));\n    }\n    else {\n        if(n%2==0) {\n            int k = (cnt_first%2==0? cnt_first+1: cnt_first);\n            if(max_odd>0) k = MIN(k, max_odd);\n            printf(\"%lld\\n\", func(n/2, (k-1)/2) *2 %MOD);\n        }\n        else {\n            printf(\"0\\n\");\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <cstring>\n#include <stdlib.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <list>\n#include <iterator>\n#include <assert.h>\n#pragma warning(disable:4996) \n\ntypedef long long ll;\n#define MIN(a, b) ((a)>(b)? (b): (a))\n#define MAX(a, b) ((a)<(b)? (b): (a))\n#define LINF 9223300000000000000\n#define INF 2140000000\nconst long long MOD = 1000000007;\nusing namespace std;\n\nchar str[200005];\n\n// A(Bを数個)A(Bを数個)..A(Bを数個) \n// という列の作り方が何通りあるか、を求める\n// ただし列の長さをn、Bを重ねるのは各箇所について0個以上k個以下とする\n// また両端がつながっているものとする。\nll func( int n, int k)\n{\n#ifdef _DEBUG\n    printf(\"%d %d\\n\", n, k);\n#endif\n    vector<ll> dp(n+1);   // dp[i]: func(i,k)と同じ。ただし両端がつながっていなくてAから始まるものとする。\n    vector<ll> sdp(n+2);  // dpの累積和\n    dp[0]=1;\n    sdp[0]=0; sdp[1]=1;\n    int i;\n    for(i=1; i<=n; i++) {\n        dp[i]=(sdp[i]-sdp[MAX(0,i-k-1)]+MOD)%MOD;\n        sdp[i+1]=(sdp[i]+dp[i])%MOD;\n    }\n    ll ans = dp[n];\n\n    // dp[n]は、Aから始まるものだけを数えたもの。\n    // 両端がつながっている状況で、Bから始まるものを数える\n    // Bが最初にp個重なった場合を考えて足し合わせればよい\n    int p;\n    for(p=1; p<=k; p++) {\n        // dp[n-p-1],dp[n-p-2],..という(k-p+1)個を足し合わせればよい\n        ans = (ans + sdp[n-p] - sdp[n-k-1] +MOD)%MOD;\n    }\n\n    return ans;\n}\n\nint main(int argc, char* argv[])\n{\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    scanf(\"%s\", str);\n\n    char c=str[0];\n    int max_odd=0;\n    int cnt_first=-1;\n    int cnt=0;\n    int cnt2=0;\n    int i;\n    for(i=0; i<m; i++) {\n        if(str[i]==c) {\n            cnt++;\n        }\n        else {\n            if(cnt==0) {\n                if(n%2==0) printf(\"2\\n\");\n                else       printf(\"0\\n\");\n                return 0;\n            }\n            if(cnt_first<0) cnt_first=cnt;\n            if(cnt%2) max_odd = MAX(max_odd, cnt);\n            cnt=0;\n            cnt2++;\n        }        \n    }\n\n    if(cnt2==0) {\n        printf(\"%lld\\n\", func(n, 1));\n    }\n    else {\n        if(n%2==0) {\n            int k = (cnt_first%2==0? cnt_first+1: cnt_first);\n            if(max_odd>0) k = MIN(k, max_odd);\n            printf(\"%lld\\n\", func(n/2, (k-1)/2) *2 %MOD);\n        }\n        else {\n            printf(\"0\\n\");\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    string s;\n    cin>>s;\n    if(s[0]=='B'){\n        for(int i=0;i<m;i++){\n            if(s[i]=='B'){s[i]='R';}\n            else{s[i]='B';}\n        }\n    }\n    ll l=0;\n    while(l<m && s[l]=='R'){l++;}\n    if(l==m){assert(false);}\n    if(n&1){cout<<(l==m?1:0)<<endl; return 0;}\n    ll mi=E;\n    if(l&1){mi=l;}\n    else{mi=l+1;}\n    for(ll i=l;i<m;i++){\n        if(s[i]=='R'){\n            ll w=i;\n            while(i<m && s[i]=='R'){i++;}\n            if(i!=m){\n                ll L=i-w;\n                if(L&1){mi=min(mi,L);}\n            }\n        }\n    }\n    vector<ll> dp(n,0);\n    vector<ll> sum(n,0);\n    dp[0]=sum[0]=1;\n    for(int i=2;i<n;i+=2){\n        ll r=sum[i-2];\n        ll l=(i-mi-3>=0?sum[i-mi-3]:0LL);\n        dp[i]=r-l;\n        dp[i]%=MOD;\n        sum[i]=sum[i-2]+dp[i];\n        sum[i]%=MOD;\n        //cout<<dp[i]<<\" \"<<sum[i]<<endl;\n    }\n    ll ans=0;\n    for(ll i=2;i<=mi+1 && n-i>=0;i++){\n        ans+=dp[n-i]*i%MOD;\n        ans%=MOD;\n    }\n    if(l==m){ans++;}\n    ans%=MOD;\n    if(ans<0){ans+=MOD;}\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=200005,p=1000000007;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint n,m,cnt,a[N],f[N];\nchar ch[N];\nint calc(int n,int l,int r){\n\tf[0]=1;\n\tint s=0;\n\tfor (int i=1;i<=n;i++){\n\t\tif (i>=l) s=(s+f[i-l])%p;\n\t\tf[i]=s;\n\t\tif (i>=r) s=(s-f[i-r]+p)%p;\n\t}\n\tint ans=0;\n\tfor (int i=l;i<=r;i++)\n\t\tans=(ans+(ll)f[n-i]*i)%p;\n\treturn ans;\n}\nint main(){\n\tn=read();m=read();\n\tscanf(\" %s\",ch+1);\n\tcnt=0;\n\tfor (int i=1;i<=m;i++)\n\tif (ch[i]==ch[1]) a[cnt]++;\n\telse cnt++;\n\tif (cnt==0) printf(\"%d\\n\",(calc(n,2,n)+1)%p);\n\telse if (n&1) puts(\"0\");\n\telse{\n\t\tint r=a[0]+1-(a[0]&1);\n\t\tfor (int i=1;i<cnt;i++)\n\t\tif (a[i]%2==1) r=min(r,a[i]);\n\t\tprintf(\"%d\\n\",calc(n/2,1,(r+1)/2)*2%p);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst int maxn = 210000;\nconst i64 P = 1000000000 + 7;\ni64 dp[2][2][maxn];\n\nvoid add(i64 &x, i64 y) {\n    x += y;\n    x %= P;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int n, l;\n    string s;\n    cin >> n >> l >> s;\n    char c0 = s[0], c1 = c0 ^ 'R' ^ 'B';\n    if (s == string(l, c0)) {\n        forn(i, 2) dp[i][i][1] = 1;\n        for1(i, n - 1) forn(f, 2) forn(j, 2) forn(k, 2) {\n            if (j && k) continue;\n            add(dp[f][k][i + 1], dp[f][j][i]);\n        }\n        i64 ans = 0;\n        forn(f, 2) forn(j, 2) {\n            if (f && j) continue;\n            add(ans, dp[f][j][n]);\n        }\n        cout << ans << '\\n';\n        return 0;\n    }\n\n    if (n % 2) {\n        cout << 0 << '\\n';\n        return 0;\n    }\n\n    vector<pair<int, char> > cl;\n    pii p = {1, c0};\n    for1(i, l - 1) {\n        if (s[i] == p.se) ++p.fi;\n        else cl.pb(p), p = {1, s[i]};\n    }\n\n//    for (auto w: cl) cerr << w.fi << ' ' << w.se << '\\n';\n\n    int ub = n;\n    if (cl[0].fi % 2 == 0) ub = cl[0].fi + 1;\n    for (auto w: cl) if (w.se == c0 && w.fi % 2) uin(ub, w.fi);\n    ub /= 2;\n\n    vi64 vals(n / 2 + 1), svals(n / 2 + 2);\n    vals[0] = 1;\n    svals[1] = 1;\n    cerr << ub << '\\n';\n    for1(i, n / 2) {\n        vals[i] = svals[i] - svals[max(i - ub - 1, 0)];\n        vals[i] %= P;\n//        cerr << i << ' ' << vals[i] << '\\n';\n        svals[i + 1] = (svals[i] + vals[i]) % P;\n    }\n\n    i64 ans = vals[n / 2];\n    for1(i, ub) if (i + 1 <= n / 2) add(ans, vals[n / 2 - i - 1] * i);\n    ans *= 2;\n    ans %= P;\n    if (ans < 0) ans += P;\n    cout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<functional>\n#include<bitset>\n#include<cassert>\nusing namespace std;\nusing lint = long long;\nusing ld = long double;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\n#define MOD 1000000007LL\n#define INF 1000000000LL\n#define EPS 1e-10\n#define FOR(i,n,m) for(lint i=n;i<(int)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v)  sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nint n, m;\nstring s;\n\nvoid allred() {\n\tlint v1 = 0, v2 = 0;\n\tlint ans = 0;\n\tv1 = 1;\n\tREP(i, n - 1) {\n\t\tlint nv1 = (v1 + v2) % MOD;\n\t\tlint nv2 = v1;\n\t\tv1 = nv1;\n\t\tv2 = nv2;\n\t}\n\tans += (v1 + v2) % MOD;\n\tv1 = 0; v2 = 1;\n\tREP(i, n - 1) {\n\t\tlint nv1 = (v1 + v2) % MOD;\n\t\tlint nv2 = v1;\n\t\tv1 = nv1;\n\t\tv2 = nv2;\n\t}\n\tans += v1;\n\tcout << (ans % MOD + MOD) % MOD << endl;\n\treturn;\n}\n\nvoid solve(vector<int> suc_red, int omn) {\n\tint th = omn;\n\tif(suc_red[0] % 2 == 0) th = min(th, suc_red[0] + 1);\n\tlint ans = 0;\n\t/*\n\tif((n - 1) % 2 && (n - 1) <= th) {\n\t\tans += n;\n\t}*/\n\tvector<lint> dpr(n), dpb(n);\n\tdpr[0] = 0;\n\tdpb[0] = 1;\n\tqueue<lint> q0;\n\tqueue<lint> q1;\n\tlint sum0 = 1, sum1 = 0;\n\tq0.push(1);\n\tFOR(i, 1, n) {\n\t\tif(i % 2 == 1) {\n\t\t\twhile(!q0.empty() && (int)q0.size() > (th + 1) / 2) {\n\t\t\t\tsum0 -= q0.front(); sum0 %= MOD;\n\t\t\t\tq0.pop();\n\t\t\t}\n\t\t\tdpr[i] = sum0;\n\t\t} else {\n\t\t\twhile(!q1.empty() && (int)q1.size() > (th + 1) / 2) {\n\t\t\t\tsum1 -= q1.front(); sum1 %= MOD;\n\t\t\t\tq1.pop();\n\t\t\t}\n\t\t\tdpr[i] = sum1;\n\t\t}\n\t\tdpb[i] = dpr[i - 1];\n\t\tif(i % 2 == 0) {\n\t\t\tq0.push(dpb[i]);\n\t\t\tsum0 += dpb[i]; sum0 %= MOD;\n\t\t} else {\n\t\t\tq1.push(dpb[i]);\n\t\t\tsum1 += dpb[i]; sum1 %= MOD;\n\t\t}\n\t}\n\tFOR(i, 1, n) {\n\t\tif(i > th) break;\n\t\tans += dpb[n - 1 - i] * i;\n\t\tans %= MOD;\n\t}\n\tans += dpr[n - 1]; ans %= MOD;\n\tcout << (ans % MOD + MOD) % MOD << endl;\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n >> m;\n\tcin >> s;\n\tif(s[0] == 'B') {\n\t\tREP(i, m) {\n\t\t\tif(s[i] == 'B') s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\n\tvector<int> suc_red;\n\tint c = 0;\n\tREP(i, n) {\n\t\tif(s[i] == 'R') c++;\n\t\telse {\n\t\t\tif(c != 0) suc_red.pb(c);\n\t\t\tc = 0;\n\t\t}\n\t}\n\tif(c != 0) suc_red.pb(c);\n\n\tif((int)suc_red.size() == 1) {\n\t\tallred();\n\t\treturn 0;\n\t}\n\n\tint omn = INF;\n\tREP(i, suc_red.size()) {\n\t\tif(suc_red[i] % 2) omn = min(omn, suc_red[i]);\n\t}\n\tsolve(suc_red, omn);\n\treturn 0;\n}\n/* --------------------------------------- */\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\n\nint main(){\n    ll n,m;\n    cin>>n>>m;\n    string s;\n    cin>>s;\n    if(s[0]=='B'){\n        for(int i=0;i<m;i++){\n            if(s[i]=='B'){s[i]='R';}\n            else{s[i]='B';}\n        }\n    }\n    ll l=0;\n    while(l<m && s[l]=='R'){l++;}\n    if(l==m){assert(false);}\n    if(n&1){cout<<(l==m?1:0)<<endl; return 0;}\n    ll mi=E;\n    if(l&1){mi=l;}\n    else{mi=l+1;}\n    for(ll i=l;i<m;i++){\n        if(s[i]=='R'){\n            ll w=i;\n            while(i<m && s[i]=='R'){i++;}\n            if(i!=m){\n                ll L=i-w;\n                if(L&1){mi=min(mi,L);}\n            }\n        }\n    }\n    vector<ll> dp(n,0);\n    vector<ll> sum(n,0);\n    dp[0]=sum[0]=1;\n    for(int i=2;i<n;i+=2){\n        ll r=sum[i-2];\n        ll l=(i-mi-3>=0?sum[i-mi-3]:0LL);\n        dp[i]=r-l;\n        dp[i]%=MOD;\n        sum[i]=sum[i-2]+dp[i];\n        sum[i]%=MOD;\n        //cout<<dp[i]<<\" \"<<sum[i]<<endl;\n    }\n    ll ans=0;\n    for(ll i=2;i<=mi+1 && n-i>=0;i++){\n        ans+=dp[n-i]*i%MOD;\n    }\n    if(l==m){ans++;}\n    ans%=MOD;\n    cout<<ans<<endl;\n    \n    \n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 1;\n    rdp[0] = 1;\n    for(int i = 1;i <= n+1;i++){\n        dp[i] = (rdp[i-1] - ((i-limit-1)>=0?rdp[i-limit-1]:0)) % MOD;\n        if(dp[i] < 0)dp[i] += MOD;\n        rdp[i] = (rdp[i-1] + dp[i]) % MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n+10, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    bool allsame = true;\n    for(int i = 0;i < m;i++)allsame &= (str[i] == str[0]);\n    if(allsame){\n        cout << all(n) << endl;\n        return 0;\n    }\n    for(int i = 0;i < m;i++)vec.push_back(str[i] == str[0]);\n    Int l = 0;\n    while(vec[l] == 1)l++;\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i < vec.size();i++){\n        if(vec[i] == 1)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll dp[202020][2][2];\nll mo=1000000007;\n\nll dp2[202020];\nll dps[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\tif(S[0]=='B') {\n\t\tFORR(c,S) c='R'+'B'-c;\n\t}\n\tif(count(ALL(S),'B')==0) {\n\t\tdp[0][0][0]=dp[0][1][1]=1;\n\t\tfor(i=1;i<N;i++) {\n\t\t\t(dp[i][0][0]=dp[i-1][0][0]+dp[i-1][0][1])%=mo;\n\t\t\t(dp[i][0][1]=dp[i-1][0][0])%=mo;\n\t\t\t(dp[i][1][0]=dp[i-1][1][0]+dp[i-1][1][1])%=mo;\n\t\t\t(dp[i][1][1]=dp[i-1][1][0])%=mo;\n\t\t}\n\t\tcout<<(dp[N-1][0][0]+dp[N-1][0][1]+dp[N-1][1][0])%mo<<endl;\n\t\treturn;\n\t}\n\t\n\tassert(N%2);\n\tint L=0;\n\twhile(S[L]=='R') L++;\n\t\n\tif(L%2==0) L++;\n\t\n\tdp2[0]=dps[0]=dps[1]=1;\n\tfor(i=2;i<=N;i++) {\n\t\tif(i%2==0) {\n\t\t\tdp2[i]=dps[i-2];\n\t\t\tif(i-(L+1)>0) dp2[i]+=mo-dps[i-(L+1)-1];\n\t\t\tdp2[i]%=mo;\n\t\t}\n\t\t(dps[i]=dps[i-1]+dp2[i])%=mo;\n\t\t//cout<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=min(L,N-1);i++) {\n\t\t//cout<<i<<\" \"<<(i+1)<<\"*\"<<dp2[N-(i+1)]<<endl;\n\t\t(ret+=(i+1)*dp2[N-(i+1)])%=mo;\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n        if(dp[i-1] < 0)dp[i-1] %= MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    return res;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i <= m;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nchar S[210000];\nlong long bit[210000];\nlong long sum(int a,int b){\n\tif(a)return (sum(0,b)-sum(0,a-1)+mod)%mod;\n\tlong long ret=0;\n\tfor(;b>=0;b=(b&(b+1))-1)ret+=bit[b];\n\treturn ret%mod;\n}\nvoid add(int a,long long b){\n\tfor(;a<210000;a|=a+1)bit[a]=(bit[a]+b)%mod;\n}\nlong long dp[210000][2][2];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tscanf(\"%s\",S);\n\tif(S[0]=='B'){\n\t\tfor(int i=0;i<b;i++){\n\t\t\tif(S[i]=='B')S[i]='R';\n\t\t\telse S[i]='B';\n\t\t}\n\t}\n\tlong long ret=0;\n\tint chk=0;\n\tfor(int i=0;i<b;i++){\n\t\tif(S[i]=='B')chk=1;\n\t}\n\tif(chk==0){\n\t\treturn 1;\n\t\tdp[1][0][0]=1;\n\t\tdp[1][1][1]=1;\n\t\tfor(int i=1;i<a;i++){\n\t\t\tdp[i+1][0][0]=(dp[i+1][0][0]+dp[i][0][0]+dp[i][1][0])%mod;\n\t\t\tdp[i+1][1][0]=(dp[i+1][1][0]+dp[i][0][0])%mod;\n\t\t\tdp[i+1][0][1]=(dp[i+1][0][1]+dp[i][0][1]+dp[i][1][1])%mod;\n\t\t\tdp[i+1][1][1]=(dp[i+1][1][1]+dp[i][0][1])%mod;\n\t\t\t\n\t\t}\n\t\tret=(dp[a][0][0]+dp[a][0][1]+dp[a][1][0])%mod;\n\t\tprintf(\"%lld\\n\",ret);\n\t\treturn 0;\n\t}\n\tif(a%2){\n\t\tprintf(\"0\\n\");return 0;\n\t}\n\tbool wolf=true;\n\tint fi=0;\n\tint tmp=0;\n\tfor(int i=0;i<b;i++){\n\t\tif(S[i]=='B'){\n\t\t\tif(wolf){\n\t\t\t\tfi=tmp;tmp=0;\n\t\t\t\twolf=false;\n\t\t\t}else{\n\t\t\t\tif(tmp%2){\n\t\t\t\t\tprintf(\"2\\n\");return 0;\n\t\t\t\t}\n\t\t\t\ttmp=0;\n\t\t\t}\n\t\t}else{\n\t\t\ttmp++;\n\t\t}\n\t}\n\ta/=2;\n\tadd(1,1);\n\tfor(int i=2;i<=a;i++){\n\t\tint L;\n\t\tif(fi%2==0)L=max(1,i-1-fi/2);\n\t\telse L=max(1,i-1-fi/2);\n\t\tlong long tmp=sum(L,i-1);\n\t\tadd(i,tmp);\n\t}\n\tfor(int i=1;i<=a;i++){\n\t//\tif(a-i>fi)continue;\n\t\tif(a-i>fi/2)continue;\n\t//\tprintf(\"%d: %lld\\n\",i,sum(i,i));\n\t\tret=(ret+(a+1-i)*sum(i,i))%mod;\n\t}\n\tret=ret*2%mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "// Dmitry _kun_ Sayutin (2019)\n\n#include <bits/stdc++.h>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\nusing std::vector;\nusing std::map;\nusing std::array;\nusing std::set;\nusing std::string;\n\nusing std::pair;\nusing std::make_pair;\n\nusing std::tuple;\nusing std::make_tuple;\nusing std::get;\n\nusing std::min;\nusing std::abs;\nusing std::max;\nusing std::swap;\n\nusing std::unique;\nusing std::sort;\nusing std::generate;\nusing std::reverse;\nusing std::min_element;\nusing std::max_element;\n\n#ifdef LOCAL\n#define LASSERT(X) assert(X)\n#else\n#define LASSERT(X) {}\n#endif\n\ntemplate <typename T>\nT input() {\n    T res;\n    cin >> res;\n    LASSERT(cin);\n    return res;\n}\n\ntemplate <typename IT>\nvoid input_seq(IT b, IT e) {\n    std::generate(b, e, input<typename std::remove_reference<decltype(*b)>::type>);\n}\n\n#define SZ(vec)         int((vec).size())\n#define ALL(data)       data.begin(),data.end()\n#define RALL(data)      data.rbegin(),data.rend()\n#define TYPEMAX(type)   std::numeric_limits<type>::max()\n#define TYPEMIN(type)   std::numeric_limits<type>::min()\n\nconst int mod = 1000 * 1000 * 1000 + 7;\nint add(int a, int b) {\n    return (a + b >= mod ? a + b - mod : a + b);\n}\n\nint sub(int a, int b) {\n    return (a >= b ? a - b : mod + a - b);\n}\n\nint mult(int a, int b) {\n    return (int64_t(a) * b) % mod;\n}\n\nint main() {\n    std::iostream::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n\n    // code here\n    int n = input<int>();\n    int m = input<int>();\n    \n    string s = input<string>();\n\n    if (s[0] == 'B')\n        for (int i = 0; i != m; ++i)\n            s[i] = ('R' + 'B' - s[i]);\n\n    if (std::find(ALL(s), 'B') == s.end()) {\n        int ans = 0;\n        \n        for (int fst = 0; fst != 2; ++fst) {\n            pair<int, int> cur_dp = {0, 0};\n\n            if (fst == 0)\n                cur_dp.first += 1;\n            else\n                cur_dp.second += 1;\n\n            for (int i = 0; i != n - 1; ++i) {\n                pair<int, int> newdp = {0, 0};\n                newdp.first = cur_dp.second;\n                newdp.second = add(cur_dp.first, cur_dp.second);\n\n                cur_dp = newdp;\n            }\n\n            if (fst == 1)\n                ans = add(ans, add(cur_dp.first, cur_dp.second));\n            else\n                ans = add(ans, cur_dp.second);\n        }\n\n        cout << ans << \"\\n\";\n        return 0;\n    } else {\n        vector<int> lens = {1};\n        assert(s[0] == 'R');\n\n        for (int i = 1; i != m; ++i)\n            if (s[i] == 'R' and s[i - 1] == 'R')\n                lens.back() += 1;\n            else if (s[i] == 'R')\n                lens.push_back(1);\n\n        if (s.back() == 'R')\n            lens.pop_back();\n        \n        int limit = 1000 * 1000 * 1000 + 1;\n        \n        for (int len: {lens[0]})\n            if (len % 2 == 0)\n                limit = min(limit, len + 1);\n            else\n                limit = min(limit, len);\n\n        for (int i = 1; i != SZ(lens); ++i)\n            if (lens[i] % 2 == 1)\n                limit = min(limit, lens[i]);\n        \n        // dp[k]: start with 0, end with zero, length k.\n        vector<int> dp(n + 5);\n        vector<int> dp_sum(n + 5);\n\n        dp[0] = 0;\n        dp[1] = 1;\n\n        dp_sum[0] = 0;\n        dp_sum[1] = 1;\n        for (int p = 2; p < SZ(dp); ++p) {\n            // for (int last = 1; last <= limit and last + 1 <= p; last += 2)\n            //     dp[p] = add(dp[p], dp[p - 1 - last]);\n\n            int upto = min(limit, p - 1);\n            if (upto % 2 == 0)\n                --upto;\n\n            dp[p] = dp_sum[p - 2];\n\n            if (p - upto - 3 >= 0)\n                dp[p] = sub(dp[p], dp_sum[p - upto - 3]);\n\n            dp_sum[p] = add(dp_sum[p - 2], dp[p]);\n        }\n\n        int ans = 0;\n        for (int beg = 1; beg <= n - 1 and beg <= limit; beg += 2)\n            ans = add(ans, mult(beg + 1, dp[n - beg]));\n\n        cout << ans << \"\\n\";\n\n        if (0) {\n            auto N = n;\n            auto lim = limit;\n            int cnt = 0;\n            \n            for (int mask = 0; mask != (1 << N); ++mask) {\n                if (mask == 0 or mask + 1 == (1 << N))\n                    continue;\n        \n                vector<char> s(N);\n                for (int i = 0; i != N; ++i)\n                    s[i] = bool((mask & (1 << i)) != 0);\n\n                int p = 0;\n                while (s[p] != 0 or s[(p + 1) % N] != 1)\n                    ++p;\n\n                std::rotate(s.begin(), s.begin() + p, s.end());\n                vector<int> lens;\n                for (int i = 1; i != N; ++i)\n                    if (s[i] == 1 and s[i - 1] == 0)\n                        lens.push_back(1);\n                    else if (s[i] == 1)\n                        lens.back() += 1;\n\n                bool fail = false;\n                for (int i = 0; i != N; ++i)\n                    if (s[i] == 0 and s[(i + 1) % N] == 0)\n                        fail = 1;\n                \n                if (fail)\n                    continue;\n\n                if (*std::max_element(ALL(lens)) > lim)\n                    fail = true;\n\n                for (auto elem: lens)\n                    if (elem % 2 == 0)\n                        fail = true;\n\n                if (fail)\n                    continue;\n\n                // for (int i = 0; i != N; ++i)\n                //     cout << ((mask & (1 << i)) != 0 ? '1' : '0');\n\n                // cout << \"\\n\";\n                cnt += 1;\n            }\n\n            assert(ans == cnt);\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nint Mn(int a,int b){return a<b?a:b;}\nconst int N=2e5+5,mod=1e9+7;\nint upt(int x){while(x>=mod)x-=mod;while(x<0)x+=mod;return x;}\n\nint n,m,lm,dp[N],sm[N],ans,f[N][5],g[N];\nchar s[N];\n/*void solve()\n{\n  f[1][0]=1;\n  for(int i=2;i<=n;i++)\n    {\n      f[i][0]=f[i-1][0];\n      f[i][1]=upt(f[i-1][1]+f[i-1][2]);\n      f[i][2]=upt(f[i-1][0]+f[i-1][1]);\n    }\n  int ans=(f[n][0]+upt(f[n][1]+f[n][2]));\n  f[1][2]=1; f[1][0]=f[1][1]=0;\n  for(int i=2;i<=n;i++)\n    {\n      f[i][1]=upt(f[i-1][1]+f[i-1][2]);\n      f[i][2]=f[i-1][1];\n    }\n  ans=upt(ans+f[n][1]); printf(\"%d\\n\",ans);\n  }*/\nvoid solve()\n{\n  g[0]=sm[0]=1;\n  for(int i=1;i<=n;i++)\n    {\n      if(i>=2)g[i]=sm[i-2];\n      sm[i]=upt(sm[i-1]+g[i]);\n    }\n  int ans=1;//ans=1 for all one color\n  for(int i=2;i<=n;i++)\n    ans=(ans+(ll)i*g[n-i])%mod;\n  printf(\"%d\\n\",ans);\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&m);\n  scanf(\"%s\",s+1); bool fg=0;\n  for(int i=1;i<=m;i++)\n    if(s[i]!=s[1]){fg=1;break;}\n  if(!fg){solve();return 0;}\n  if(n&1){puts(\"0\");return 0;}\n  lm=n+1;\n  for(int i=1;i<=m;i++)\n    if(s[i]==s[1])//== not !=\n      {\n\tint j=i;\n\twhile(j+1<=m&&s[j+1]==s[j])j++;\n\tswap(i,j); j=i-j+1;\n\tif(i-j==0) lm=Mn(lm,j+((j&1)==0));\n\telse if((j&1)&&i!=m)lm=Mn(lm,j);//i!=m not i!=lst!!!\n      }\n  n>>=1; lm=(lm+1)>>1; dp[0]=sm[0]=1;\n  for(int i=1;i<=n;i++)\n    {\n      dp[i]=sm[i-1]; if(i>lm)dp[i]=upt(dp[i]-sm[i-lm-1]);\n      sm[i]=upt(sm[i-1]+dp[i]);\n    }\n  int ans=0;\n  for(int i=1;i<=lm;i++)//lm not n\n    ans=(ans+i*2%mod*dp[n-i])%mod;\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define N 200002\n#define p 1000000007\ninline int mod(int x){return x<p?x:x-p;}\nint f[N],g[N],i,j,m,n,t,x;char s[N];\nint main()\n{\n    scanf(\"%d%d%s\",&n,&m,s+1),f[0]=g[0]=1;\n    if(s[1]=='B')for(i=1;i<=m;i++)s[i]=s[i]=='B'?'R':'B';\n    while(s[m]=='R')s[m--]=0;\n    for(i=0;s[i+1]=='R';i++);\n    for(t=i++|1;s[i];t=(i-j&1)&&i-j<t?i-j:t)\n    {\n        while(s[i]=='B')i++;\n        for(j=i;s[i]=='R';i++);\n    }\n    if(m)for(i=1;i<=n;f[i]=mod(f[i-1]+g[i]),i++)if(~i&1)g[i]=i<t+2?f[i-1]:mod(p+f[i-1]-f[i-t-2]);else;\n    else for(g[1]=1,i=2;i<=n;i++)g[i]=mod(g[i-2]+g[i-1]);\n    if(m)for(i=n-2;0<=i&&n-i<=t+1;i-=2)x=(x+(long long)g[i]*(n-i))%p;\n    else x=mod(g[n]+g[n-2]);\n    return 0*printf(\"%d\\n\",x);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MAX_N 200000\n#define MAX_M 200000\n#define MOD 1000000007\n\n#define INF 1 << 29\n\nint N, M;\nstring S;\n\nlong long dp[MAX_N + 2], rdp[MAX_N + 2];\n\nint all_color_is_same()\n{\n    long long rr = 1, bb = 1, rb = 0, br = 0;\n\n    for ( int i = 1; i < N; i++ )\n    {\n        long long nrr = ( rr + rb ) % MOD;\n        long long nbb = br;\n        long long nrb = rr;\n        long long nbr = ( bb + br ) % MOD;\n\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n\n    return ( rr + rb + br ) % MOD;\n}\n\n/* S\nの先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n*/\nint min_freq()\n{\n    // int l = 0;\n    // while ( l < M && S[0] == S[l] ) l++;\n\n    // int ans = ( l & 1 ) ? l : l + 1;\n\n    // l = 0;\n    // for ( int i = 0; i < M; i++ )\n    // {\n    //     if ( S[0] == S[i] )\n    //         l++;\n    //     else\n    //     {\n    //         if ( l & 1 ) ans = min( ans, l );\n    //         l = 0;\n    //     }\n    // }\n    // return ( l & 1 ) ? min( ans, l ) : ans;\n    int l = 0;\n    while ( S[0] == S[l] ) l++;\n    if ( l % 2 == 0 ) l++;\n    int limit = l;\n    l = 0;\n    for ( int i = 0; i < M; i++ )\n    {\n        if ( S[i] == S[0] )\n            l++;\n        else\n        {\n            if ( l % 2 == 1 ) limit = min( limit, l );\n            l = 0;\n        }\n    }\n    return limit;\n}\n\nint solve()\n{\n    // 一色\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n        return all_color_is_same();\n\n    // N が奇数\n    if ( N & 1 ) return 0;\n\n    int L = min_freq();\n\n    L = ( L + 1 ) >> 1;\n    N >>= 1;\n\n    dp[0] = rdp[0] = 1;\n    for ( int i = 1; i <= N + 1; i++ )\n    {\n        dp[i] = rdp[i - 1];\n        if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n\n    long long res = 0;\n    for ( int i = 1; i <= L; i++ )\n        if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n    return res % MOD;\n}\n\nint main( int argc, char **argv )\n{\n    cin >> N >> M;\n    cin >> S;\n\n    int ans = solve();\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n// Int all( Int n )\n// { // no bb\n//     Int rr = 1, bb = 1, rb = 0, br = 0;\n//     for ( int i = 1; i < n; i++ )\n//     {\n//         Int nrr = ( rr + rb ) % MOD;\n//         Int nbb = br;\n//         Int nrb = rr;\n//         Int nbr = ( bb + br ) % MOD;\n//         rr = nrr;\n//         bb = nbb;\n//         rb = nrb;\n//         br = nbr;\n//     }\n//     return ( rr + rb + br ) % MOD;\n// }\n\n// Int tmp[216000];\n// Int rdp[216000];\n// Int dp[216000];\n// void calc( Int n, Int limit )\n// {\n//     dp[0] = 1;\n//     rdp[0] = 1;\n//     for ( int i = 1; i <= n + 1; i++ )\n//     {\n//         dp[i] = ( rdp[i - 1] -\n//                   ( ( i - limit - 1 ) >= 0 ? rdp[i - limit - 1] : 0 ) ) %\n//                 MOD;\n//         if ( dp[i] < 0 ) dp[i] += MOD;\n//         rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n//     }\n// }\n\n// Int solve( Int n, Int limit )\n// {\n//     if ( n % 2 == 1 ) return 0;\n//     if ( limit % 2 != 1 ) exit( 1 );\n//     limit = ( limit + 1 ) / 2;\n//     n /= 2;\n//     Int res = 0;\n//     calc( n + 10, limit );\n//     for ( Int i = 1; i <= limit; i++ )\n//     {\n//         if ( n - i >= 0 ) res = ( res + dp[n - i] * 2 * i ) % MOD;\n//     }\n//     if ( res < 0 ) exit( 1 );\n//     return res % MOD;\n// }\n\n// int main()\n// {\n//     cin >> N >> M;\n//     cin >> S;\n\n//     if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n//     {\n//         cout << all( N ) << endl;\n//         return 0;\n//     }\n\n//     int limit = min_freq();\n\n//     cout << solve( N, limit ) << endl;\n//     return 0;\n// }\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int mod = (int) 1e9 + 7;\n\nint mul(int a, int b) {\n  return (long long) a * b % mod;\n}\n\nvoid add(int &a, int b) {\n  a += b;\n  if (a >= mod) {\n    a -= mod;\n  }\n}\n\nconst int maxn = (int) 2e5 + 5;\nint n, m;\nstring s;\nchar tmp[maxn];\n\nbool read() {\n  if (scanf(\"%d%d\", &n, &m) < 2) {\n    return false;\n  }\n  scanf(\"%s\", tmp);\n  s = tmp;\n  return true;\n}\n\nint dp1[maxn][2];\nint dp[maxn];\nint toadd[maxn];\n\nvoid solve() {\n  if (s[0] == 'B') {\n    for (int i = 0; i < m; i++) {\n      if (s[i] == 'B') {\n        s[i] = 'R';\n      } else {\n        s[i] = 'B';\n      }\n    }\n  }\n  int d = inf;\n  for (int j = 0; j < m;) {\n    if (s[j] == 'B') {\n      j++;\n      continue;\n    }\n    int i = j;\n    while (j < m && s[j] == 'R') {\n      j++;\n    }\n    if (j == m) {\n      continue;\n    }\n    int len = j - i;\n    if (!(len & 1)) {\n      if (i) {\n        continue;\n      }\n      len++;\n    }\n    d = min(d, len);\n  }\n  if (d >= inf) {\n    int res = 0;\n    dp1[1][0] = 1;\n    dp1[1][1] = 0;\n    for (int i = 2; i <= n; i++) {\n      {\n        auto &cur = dp1[i][0];\n        cur = dp1[i - 1][0];\n        add(cur, dp1[i - 1][1]);\n      }\n      {\n        auto &cur = dp1[i][1];\n        cur = dp1[i - 1][0];\n      }\n    }\n    add(res, dp1[n][0]);\n    add(res, dp1[n][1]);\n    dp1[1][0] = 0;\n    dp1[1][1] = 1;\n    for (int i = 2; i <= n; i++) {\n      {\n        auto &cur = dp1[i][0];\n        cur = dp1[i - 1][0];\n        add(cur, dp1[i - 1][1]);\n      }\n      {\n        auto &cur = dp1[i][1];\n        cur = dp1[i - 1][0];\n      }\n    }\n    add(res, dp1[n][0]);\n    printf(\"%d\\n\", res);\n    return;\n  }\n  if (n & 1) {\n    printf(\"0\\n\");\n    return;\n  }\n  for (int i = 0; i <= n; i++) {\n    toadd[i] = 0;\n    dp[i] = 0;\n  }\n  dp[0] = 1;\n  int curadd = 0;\n  for (int i = 0; i < n; i += 2) {\n    add(curadd, toadd[i]);\n    auto &cur = dp[i];\n    add(cur, curadd);\n    if (!cur) {\n      continue;\n    }\n    int l = i + 2, r = i + d + 3;\n    if (l >= n) {\n      continue;\n    }\n    add(toadd[l], cur);\n    if (r < n) {\n      add(toadd[r], mod - cur);\n    }\n  }\n  int res = 0;\n  for (int i = max(0, n - d - 1); i < n; i += 2) {\n    auto cur = dp[i];\n    if (!cur) {\n      continue;\n    }\n    int len = n - i;\n    add(res, mul(cur, len));\n  }\n  printf(\"%d\\n\", res);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MAXN = 210000;\n\nchar s[MAXN];\n\nconst int MOD = 1000000007;\n\nvoid add(int &a, int b) {\n  if ((a += b) >= MOD) a -= MOD;\n}\n\nvoid sub(int &a, int b) {\n  if ((a -= b) < 0) a += MOD;\n}\n\nint mul(int a, int b) {\n  return (int) ((a * 1LL * b) % MOD);\n}\n\nint mpow(int a, int b) {\n  int res = 1;\n  while (b) {\n    if (b & 1) res = mul(res, a);\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\nint minv(int x) {\n  return mpow(x, MOD - 2);\n}\n\nint main() {\n#ifdef LOCAL\n  freopen(\"e.in\", \"r\", stdin);\n  freopen(\"e.out\", \"w\", stdout);\n#endif\n\n  int n, m;\n  while (scanf(\"%d%d\", &n, &m) == 2) {\n    scanf(\"%s\", s);\n    if (s[0] != 'B') {\n      for (int i = 0; i < m; i++) {\n        s[i] = s[i] ^ 'B' ^ 'R';\n      }\n    }\n    int first = find(s, s + m, 'R') - s;\n\n    if (first == m) {\n      vector<int> dp(n + 1);\n      dp[0] = 1;\n      dp[1] = 2;\n      for (int i = 2; i <= n; i++) {\n        dp[i] = dp[i - 1];\n        add(dp[i], dp[i - 2]);\n      }\n      int ans = dp[n];\n      if (n == 3) {\n        sub(ans, dp[n - 3]);\n      } else if (n > 3) {\n        sub(ans, dp[n - 4]);\n      }\n      printf(\"%d\\n\", ans);\n      continue;\n    }\n\n    int lim = n;\n    int prev_r = 0;\n    for (int i = 0; i < n; i++) {\n      if (s[i] == 'R') {\n        if ((s[i] - prev_r) % 2 == 1) {\n          lim = min(lim, s[i] - prev_r);\n        }\n        prev_r = i + 1;\n      }\n    }\n    lim = min(lim, first + 1);\n\n    if (n % 2 != 0) {\n      printf(\"0\\n\");\n    } else {\n      vector<int> dp(n / 2 + 1);\n      vector<int> dp2(n / 2 + 1);\n      dp[0] = 1;\n      dp2[1] = 1;\n      for (int i = 1; i <= n / 2; i++) {\n        dp[i] = dp2[i];\n        int pos = i - (lim + 1) / 2 ;\n        if (pos >= 0)\n        sub(dp[i], dp2[pos]);\n        dp2[i + 1] = dp2[i];\n        add(dp2[i + 1], dp[i]);\n      }\n\n      int ans = 0;\n      for (int i = 1; i <= (lim + 1) / 2; i++) {\n        add(ans, mul(2 * i, dp[n / 2 - i]));\n      }\n      printf(\"%d\\n\", ans);\n    }\n\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(LL &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const LL &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nLL dp[SIZE][2][2];\nvoid solve_same(int N){\n    dp[1][0][0]=1;\n    dp[1][1][1]=1;\n    REPP(i,1,N){\n        REP(j,2){\n            ADD(dp[i+1][j][0],dp[i][j][1]);\n            ADD(dp[i+1][j][1],dp[i][j][0]);\n            ADD(dp[i+1][j][1],dp[i][j][1]);\n        }\n    }\n    LL an=0;\n    ADD(an,dp[N][0][1]);\n    ADD(an,dp[N][1][1]);\n    ADD(an,dp[N][1][0]);\n    W(an);\n}\nLL mypow(LL x,LL y){\n    x%=MOD;\n    LL res=1%MOD;\n    while(y){\n        if(y&1)res=res*x%MOD;\n        y>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nLL dp2[SIZE],dp2_sum[SIZE];\nvoid solve(int ma,int N){\n    LL an=0;\n    if(ma+1>=N){\n        ADD(an,(mypow(2,N/2)-1)*2);\n    }\n    else{\n        ma=(ma+1)/2;\n        dp2[0]=dp2_sum[0]=1;\n        FOR(i,1,N/2){\n            dp2_sum[i]=dp2_sum[i-1];\n            dp2[i]=dp2_sum[i-1];\n            if(i>ma)ADD(dp2[i],-dp2_sum[i-ma-1]);\n            ADD(dp2_sum[i],dp2[i]);\n        }\n        ADD(an,dp2[N/2]*2);\n        FOR(i,ma+1,min(ma*2,N/2)){\n            ADD(an,-(ma*2+1-i)*dp2[N/2-i]);\n        }\n        ADD(an,an);\n    }\n    W(an);\n}\nint main(){\n    int N,M; R(N,M);\n    string s; R(s);\n    bool same=1;\n    REPP(i,1,M){\n        if(s[i]!=s[i-1])same=0;\n    }\n    if(same)solve_same(N);\n    else{\n        if(N%2){\n            W(0);\n            return 0;\n        }\n        VI AA;\n        for(int i=0,j;i<M;i=j){\n            for(j=i+1;j<M&&s[j]==s[i];j++);\n            if(s[i]==s[0])AA.PB(j-i);\n        }\n        int ma=-1;\n        if(AA[0]%2)ma=AA[0];\n        else ma=AA[0]+1;\n        REPP(i,1,SZ(AA)){\n            if(AA[i]%2==1)ma=min(ma,AA[i]);\n        }\n        solve(ma,N);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue\n#define pb push_back\n#define eb emplace_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define vec2(a,b) vector<vec>(a,vec(b))\n#define vec2ll(a,b) vector<vec>(a,vecll(b))\n#define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c))\n#define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c))\n#define fi first\n#define se second\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\n#define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define lb(c,x) distance(c.begin(),lower_bound(all(c),x))\n#define ub(c,x) distance(c.begin(),upper_bound(all(c),x))\n#define MM \" \"\nusing namespace std;\nint in() {int x;cin>>x;return x;}\nll lin() {ll x;cin>>x;return x;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> inline void print(pair<T,T> p){cout<<\"(\"<<p.first<<\",\"<<p.second<<\") \";}\ntemplate<class T> inline void print(vector<pair<T,T>> v){for(auto e:v)print(e); cout<<endl;}\ntemplate<class T> inline void print(T v){for(auto e:v)cout<<e<<\" \";cout<<endl;}\n\nconst ll MOD=1e9+7;\nconst int N=1100000;\n \ntemplate <ll Modulus> class modint {\n  using u64 = ll;\n \npublic:\n  u64 a;\n \n  constexpr modint(const u64 x = 0) noexcept : a(((x % Modulus) + Modulus)%Modulus) {}\n  constexpr u64 &value() noexcept { return a; }\n  constexpr const u64 &value() const noexcept { return a; }\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint &operator+=(const modint rhs) noexcept {\n    a += rhs.a;\n    if (a >= Modulus) {\n      a -= Modulus;\n    }\n    return *this;\n  }\n  constexpr modint &operator-=(const modint rhs) noexcept {\n    if (a < rhs.a) {\n      a += Modulus;\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  constexpr modint &operator*=(const modint rhs) noexcept {\n    a = a * rhs.a % Modulus;\n    return *this;\n  }\n  constexpr modint &operator/=(modint rhs) noexcept {\n    u64 exp = Modulus - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\n \n#define mint modint<MOD>\nmint inv[N],comb[N],prd[N],invprd[N];\nvoid calc_inv(){\n    inv[1]=1;\n    rep2(i,2,N-1){\n        inv[i]=inv[MOD%i]*(-MOD/i);\n    }\n    return;\n}\nvoid calc_product(){\n    prd[0]=prd[1]=1;\n    invprd[0]=invprd[1]=1;\n    rep2(i,2,N-1){\n        prd[i]=prd[i-1]*i;\n        invprd[i]=inv[i]*invprd[i-1];\n    }\n    return ;\n}\nmint cmb(int a,int b){\n    if(a<b)return 0;\n    if(a<0||b<0)return 0;\n    return {prd[a]*invprd[b]*invprd[a-b]};\n}\nmint modpow(mint x,ll n){\n    if(n==0) return 1;\n    mint res=modpow(x*x,n/2);\n    if(n&1) res=res*x;\n    return res;\n}\nvoid calc(){calc_inv();calc_product();}\nusing vmint = vector<mint> ;\n\nmain(){\n    ios\n    calc();\n    int n=in(),m=in();\n    string s;cin>>s;\n    bool all_same=true;\n    rep(i,m){\n        if(s[i]!=s[0])all_same=false;\n    }\n    if(!all_same and (n&1)) cout<<0<<endl;\n    else if(all_same ){\n        mint dp[n+1][2]={};\n        dp[0][0]=1;\n        rep(i,n-1){\n            dp[i+1][1]+=dp[i][0];\n            dp[i+1][0]+=dp[i][0]+dp[i][1];\n        }\n        mint ans=dp[n-1][0]+dp[n-1][1];\n        rep(i,n)dp[i][0]=dp[i][1]=0;\n        dp[0][1]=1;\n        rep(i,n-1){\n            dp[i+1][1]+=dp[i][0];\n            dp[i+1][0]+=dp[i][0]+dp[i][1];\n        }\n        ans+=dp[n-1][0];\n        cout<<ans.a<<endl;\n    }\n    else{\n        char c=s[0];\n        int mi=INT_MAX;\n        rep(i,m){\n            int cnt=0;\n            while(i<m && s[i]==c)cnt++,i++;\n            chmin(mi,cnt);break;\n        }\n        if(mi %2) mi=mi*2-1;\n        else mi=mi+1;\n        rep(i,m){\n            if(s[i]==c){\n                int cnt=0;\n                while(i<m && s[i]==c)cnt++,i++;\n                if(cnt&1)\n                chmin(mi,cnt);\n            }\n        }\n        mint dp[700000]={};\n        mi=(mi+1)/2;\n        rep(i,mi){\n            dp[i]=2;\n        }\n        dp[mi]=-2*mi;\n        rep(i,n/2){\n            dp[i+1]+=dp[i]*2;\n            dp[i+1+mi]-=dp[i];\n        }\n        cout<<dp[n/2-1].a<<endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___CLASS_MODINT\n#define ___CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::uint64_t n_) : n(n_ % mod) {};\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tstd::uint32_t get() const { return n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint binpow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tmodint inv() { return (*this).binpow(mod - 2); }\n};\n\n#endif // ___CLASS_MODINT\n\n#include <string>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nusing modulo = modint<1000000007>;\nconst int inf = 1012345678;\nint solve(int N, int M, string S) {\n\tif (S[0] == 'B') {\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (S[i] == 'B') S[i] = 'R';\n\t\t\telse S[i] = 'B';\n\t\t}\n\t}\n\tint pre = 0, mn = inf; bool bluemove = true;\n\tfor (int i = 1; i < M; ++i) {\n\t\tif (S[i - 1] != S[i]) {\n\t\t\tif (S[i - 1] == 'R' && (pre == 0 || (i - pre) % 2 == 1)) {\n\t\t\t\tmn = min(mn, i - pre + 1);\n\t\t\t}\n\t\t\tif (S[i - 1] == 'B' && (i - pre) % 2 == 1) {\n\t\t\t\tbluemove = false;\n\t\t\t}\n\t\t\tpre = i;\n\t\t}\n\t}\n\tif (mn == inf) {\n\t\tvector<modulo> fib(N + 3);\n\t\tfib[1] = 1;\n\t\tfor (int i = 2; i <= N + 2; ++i) {\n\t\t\tfib[i] = fib[i - 1] + fib[i - 2];\n\t\t}\n\t\tmodulo ans = fib[N + 2] - fib[N - 2];\n\t\treturn ans.get();\n\t}\n\telse if (bluemove) {\n\t\tvector<modulo> dp1(N + 1), dp2(N + 1);\n\t\tdp2[0] = 1;\n\t\tint lim = (mn + 1) / 2 * 2;\n\t\tmodulo oddsum = 0, evensum = 0;\n\t\tfor (int i = 1; i <= N; ++i) {\n\t\t\tif (i - lim - 2 >= 0) {\n\t\t\t\tif (i % 2 == 1) evensum -= dp1[i - lim - 2];\n\t\t\t\telse oddsum -= dp1[i - lim - 2];\n\t\t\t}\n\t\t\tdp1[i] = dp2[i - 1] + dp1[i - 1];\n\t\t\tdp2[i] = (i % 2 == 1 ? evensum : oddsum);\n\t\t\tif (i % 2 == 1) oddsum += dp1[i];\n\t\t\telse evensum += dp1[i];\n\t\t}\n\t\tmodulo ans = dp1[N];\n\t\tfor (int i = 1; i <= mn && i <= N; i += 2) {\n\t\t\tans += dp1[N - i] * (i + 1);\n\t\t}\n\t\treturn ans.get();\n\t}\n\telse {\n\t\tvector<modulo> dp(N + 1);\n\t\tdp[1] = 1;\n\t\tint lim = (mn + 1) / 2 * 2;\n\t\tmodulo sum = 1;\n\t\tfor (int i = 3; i <= N; i += 2) {\n\t\t\tif (i - lim - 2 >= 0) sum -= dp[i - lim - 2];\n\t\t\tdp[i] = sum;\n\t\t\tsum += dp[i];\n\t\t}\n\t\tmodulo ans = 0;\n\t\tfor (int i = 1; i <= mn && i <= N; i += 2) {\n\t\t\tans += dp[N - i] * (i + 1);\n\t\t}\n\t\treturn ans.get();\n\t}\n\treturn -1;\n}\nint main() {\n\tint N, M; string S;\n\tcin >> N >> M >> S;\n\tcout << solve(N, M, S) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___CLASS_MODINT\n#define ___CLASS_MODINT\n\n#include <cstdint>\n\ntemplate<std::uint32_t mod>\nclass modint {\nprivate:\n\tstd::uint32_t n;\npublic:\n\tmodint() : n(0) {};\n\tmodint(std::uint64_t n_) : n(n_ % mod) {};\n\tbool operator==(const modint& m) const { return n == m.n; }\n\tbool operator!=(const modint& m) const { return n != m.n; }\n\tstd::uint32_t get() const { return n; }\n\tmodint& operator+=(const modint& m) { n += m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator-=(const modint& m) { n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n\tmodint& operator*=(const modint& m) { n = std::uint64_t(n) * m.n % mod; return *this; }\n\tmodint operator+(const modint& m) const { return modint(*this) += m; }\n\tmodint operator-(const modint& m) const { return modint(*this) -= m; }\n\tmodint operator*(const modint& m) const { return modint(*this) *= m; }\n\tmodint binpow(std::uint64_t b) const {\n\t\tmodint ans = 1, m = modint(*this);\n\t\twhile (b) {\n\t\t\tif (b & 1) ans *= m;\n\t\t\tm *= m;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\tmodint inv() { return (*this).binpow(mod - 2); }\n};\n\n#endif // ___CLASS_MODINT\n\n#include <string>\n#include <vector>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nusing modulo = modint<1000000007>;\nconst int inf = 1012345678;\nint solve(int N, int M, string S) {\n\tif (S[0] == 'B') {\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tif (S[i] == 'B') S[i] = 'R';\n\t\t\telse S[i] = 'B';\n\t\t}\n\t}\n\tint pre = 0, mn = inf; bool bluemove = true;\n\tfor (int i = 1; i < M; ++i) {\n\t\tif (S[i - 1] != S[i]) {\n\t\t\tif (S[i - 1] == 'R' && (pre == 0 || (i - pre) % 2 == 1)) {\n\t\t\t\tmn = min(mn, i - pre + 1);\n\t\t\t}\n\t\t\tif (S[i - 1] == 'B' && (i - pre) % 2 == 1) {\n\t\t\t\tbluemove = false;\n\t\t\t}\n\t\t\tpre = i;\n\t\t}\n\t}\n\tif (mn == inf) {\n\t\tvector<modulo> fib(N + 3);\n\t\tfib[1] = 1;\n\t\tfor (int i = 2; i <= N + 2; ++i) {\n\t\t\tfib[i] = fib[i - 1] + fib[i - 2];\n\t\t}\n\t\tmodulo ans = fib[N + 2] - fib[N - 2];\n\t\treturn ans.get();\n\t}\n\telse if (bluemove) {\n\t\tvector<modulo> dp1(N + 1), dp2(N + 1);\n\t\tdp2[0] = 1;\n\t\tmodulo oddsum = 0, evensum = 0;\n\t\tfor (int i = 1; i <= N; ++i) {\n\t\t\tif (i - mn - 1 >= 0) {\n\t\t\t\tif ((i - mn - 1) % 2 == 0) evensum -= dp1[i - mn - 1];\n\t\t\t\telse oddsum -= dp1[i - mn - 1];\n\t\t\t}\n\t\t\tdp1[i] = dp2[i - 1] + dp1[i - 1];\n\t\t\tdp2[i] = (i % 2 == 1 ? evensum : oddsum);\n\t\t\tif (i % 2 == 1) oddsum += dp1[i];\n\t\t\telse evensum += dp1[i];\n\t\t}\n\t\tmodulo ans = dp1[N];\n\t\tfor (int i = 1; i <= mn && i <= N; i += 2) {\n\t\t\tans += dp1[N - i] * (i + 1);\n\t\t}\n\t\treturn ans.get();\n\t}\n\telse {\n\t\tvector<modulo> dp(N + 1);\n\t\tdp[1] = 1;\n\t\tint lim = (mn + 1) / 2 * 2;\n\t\tmodulo sum = 1;\n\t\tfor (int i = 3; i <= N; i += 2) {\n\t\t\tif (i - lim - 2 >= 0) sum -= dp[i - lim - 2];\n\t\t\tdp[i] = sum;\n\t\t\tsum += dp[i];\n\t\t}\n\t\tmodulo ans = 0;\n\t\tfor (int i = 1; i <= mn && i <= N; i += 2) {\n\t\t\tans += dp[N - i] * (i + 1);\n\t\t}\n\t\treturn ans.get();\n\t}\n\treturn -1;\n}\nint main() {\n\tint N, M; string S;\n\tcin >> N >> M >> S;\n\tcout << solve(N, M, S) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\nll dp[200010] = {},mod = 1000000007;\nstring s;\nvector<pair<char,int>> v;\nint main(){\n\tll i,j,n,m;\n\tcin >> n >> m >> s;\n\tif(s[0]=='B'){\n\t\tfor(i=0;i<m;i++){\n\t\t\tif(s[i]=='R') s[i] = 'B';\n\t\t\telse s[i] = 'R';\n\t\t}\n\t}\n\tfor(i=0;i<m;i++){\n\t\tif(i==0 || v.back().first!=s[i]){\n\t\t\tv.push_back({s[i],1});\n\t\t}else{\n\t\t\tv.back().second++;\n\t\t}\n\t}\n\tif(v.size()==1){\n\t\tcout << n + 1 << endl;\n\t\treturn 0;\n\t}\n\tif(n&1){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tint mn = -1;\n\tfor(i=0;i<m;i++){\n\t\tif(i==0){\n\t\t\tmn = v[i].second + 1 - (v[i].second&1);\n\t\t}\n\t\tif(v[i].first=='R' && (v[i].second&1)){\n\t\t\tmn = min(mn,v[i].second);\n\t\t}\n\t}\n\tmn++;\n\tdp[0] = 1;dp[2] = 1;\n\tll sum = 2;\n\tfor(i=4;i<=n;i+=2){\n\t\t(dp[i] += sum) %= mod;\n\t\t(sum += dp[i]) %= mod;\n\t\tif(i>=mn) sum -= dp[i - mn];\n\t\tif(sum<0) sum += mod;\n\t}\n\tll ans = 0;\n\tfor(i=2;i<=mn;i++){\n\t\t(ans += i*dp[n - i]) %= mod;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\n\n/// --- Modulo Integer {{{ ///\n#include <ostream>\ntemplate < long long mod = static_cast< long long >(1e9 + 7) >\nstruct ModuloInteger {\n  static_assert(mod > 0, \"mod must be positive\");\n  static_assert(mod <= 3037000499, \"mod is too big\");\n  using integer = long long;\n  static ModuloInteger unused;\n  // math {{{\n  static inline integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  static inline integer modpow(integer a, long long b) {\n    if(b < 0) b = -b, a = modinv(a);\n    integer r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  integer val;\n  constexpr ModuloInteger() : val(0) {}\n  constexpr ModuloInteger(integer t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\nprivate:\n  // strict constructor\n  constexpr ModuloInteger(integer t, int) : val(t) {}\n\npublic:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // operator bool() { return bool(val); }\n  // ModuloInteger <arithmetic-operator>[=] ModuloInteger {{{\n  ModuloInteger operator+(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModuloInteger operator-(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModuloInteger operator*(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModuloInteger operator/(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModuloInteger &operator+=(ModuloInteger const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModuloInteger &operator-=(ModuloInteger const &rhs) { return *this += -rhs; }\n  ModuloInteger &operator*=(ModuloInteger const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModuloInteger &operator/=(ModuloInteger const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModuloInteger operator++(int) {\n    ModuloInteger tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModuloInteger operator--(int) {\n    ModuloInteger tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModuloInteger &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModuloInteger &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModuloInteger operator-() const { return ModuloInteger(val == 0 ? 0 : mod - val, 0); }\n  // ModuloInteger <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModuloInteger operator+(T const &rhs) const {\n      return ModuloInteger(val + rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator-(T const &rhs) const {\n      return ModuloInteger(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator*(T const &rhs) const {\n      return ModuloInteger(val * (rhs % mod));\n    }\n  template < typename T >\n    ModuloInteger operator/(T const &rhs) const {\n      return ModuloInteger(val * modinv(rhs));\n    }\n  template < typename T >\n    ModuloInteger &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator/=(T const &rhs) {\n      val = val * modinv(rhs) % mod;\n      return *this;\n    }\n  // }}}\n  ModuloInteger inv() const { return ModuloInteger(modinv(val), 0); }\n  ModuloInteger operator~() const { return inv(); }\n  friend std::ostream &operator<<(std::ostream &os, ModuloInteger const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // equality operator {{{\n  ModuloInteger operator==(const ModuloInteger &a) const { return val == a.val; }\n  ModuloInteger operator!=(const ModuloInteger &a) const { return val != a.val; }\n  ModuloInteger operator==(const integer &a) const { return val == ModuloInteger(a); }\n  ModuloInteger operator!=(const integer &a) const { return val != ModuloInteger(a); }\n  // }}}\n  // T <arithmetic-operator> ModuloInteger {{{\n  friend constexpr ModuloInteger operator+(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod + mv.val);\n  }\n  friend constexpr ModuloInteger operator-(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod - mv.val);\n  }\n  friend constexpr ModuloInteger operator*(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModuloInteger operator/(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModuloInteger operator^(integer x) const { return pow(*this, x); }\n  ModuloInteger &operator^=(integer x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModuloInteger pow(ModuloInteger x, integer y) {\n    return ModuloInteger(modpow(x.val, y), 0);\n  }\n  // }}}\n};\ntemplate < long long mod >\nModuloInteger< mod > ModuloInteger< mod >::unused(mod, 0);\n/// }}}--- ///\n\nusing modint = ModuloInteger<>;\n\n\n// LazySegmentTree( size [, initial] )\n// LazySegmentTree( <data> )\n/// --- LazySegmentTree {{{ ///\n#include <cassert>\n#include <initializer_list>\n#include <iostream>\n#include <vector>\ntemplate < class M_act >\nstruct LazySegmentTree {\npublic:\n  using Monoid = typename M_act::Monoid;\n  using X = typename Monoid::T;\n  using M = typename M_act::M;\n\nprivate:\n  size_t n;\n  int h;\n  vector< X > data;\n  vector< M > lazy;\n  vector< size_t > nodeLength;\n  // call before use data[i]\n  void eval(size_t i) {\n    if(lazy[i] == M_act::identity()) return;\n    data[i] = M_act::actInto(lazy[i], nodeLength[i], data[i]);\n    if(i < n) {\n      lazy[i * 2] = M_act::op(lazy[i], lazy[i * 2]);\n      lazy[i * 2 + 1] = M_act::op(lazy[i], lazy[i * 2 + 1]);\n    }\n    lazy[i] = M_act::identity();\n  }\n  // call before use seg[i] = data[i + n]\n  void evalDown(size_t i) {\n    i += n;\n    for(int j = h - 1; j >= 0; j--) eval(i >> j);\n  }\n  // call after touch seg[i] = data[i + n]\n  void propUp(size_t i) {\n    i += n;\n    while(i >>= 1)\n      eval(i * 2), eval(i * 2 + 1), data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n  }\n\npublic:\n  LazySegmentTree() : n(0) {}\n  LazySegmentTree(size_t n, X initial = Monoid::identity()) : n(n) {\n    if(n > 0) {\n      h = 1;\n      while(1u << h < n) h++;\n      data.resize(2 * n, initial);\n      lazy.resize(2 * n, M_act::identity());\n      nodeLength.resize(2 * n, 1);\n      for(size_t i = n - 1; i > 0; i--) // fill from deep\n        data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]),\n          nodeLength[i] = nodeLength[i * 2] + nodeLength[i * 2 + 1];\n    }\n  }\n  template < class InputIter, class = typename iterator_traits< InputIter >::value_type >\n    LazySegmentTree(InputIter first, InputIter last)\n    : LazySegmentTree(distance(first, last)) {\n      if(n > 0) {\n        copy(first, last, begin(data) + n);\n        for(size_t i = n - 1; i > 0; i--) // fill from deep\n          data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n      }\n    }\n  LazySegmentTree(vector< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  LazySegmentTree(initializer_list< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  void act(int l, int r, const M &m) {\n    if(l < 0) l = 0;\n    if(l >= r) return;\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    int tl = l, tr = r;\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), lazy[l] = m, eval(l), l++;\n      if(r & 1) --r, eval(r), lazy[r] = m, eval(r);\n    }\n    propUp(tl);\n    propUp(tr - 1);\n  }\n  void set(size_t i, const X &x) {\n    assert(i < n);\n    evalDown(i);\n    data[i + n] = x;\n    propUp(i);\n  }\n  X get(size_t i) {\n    assert(i < n);\n    evalDown(i);\n    return data[i + n];\n  }\n  X fold(int l, int r) {\n    if(l < 0) l = 0;\n    if(l >= r) return Monoid::identity();\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    X tmpL = Monoid::identity(), tmpR = Monoid::identity();\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), tmpL = Monoid::op(tmpL, data[l]), l++;\n      if(r & 1) --r, eval(r), tmpR = Monoid::op(data[r], tmpR);\n    }\n    return Monoid::op(tmpL, tmpR);\n  }\n  int size() { return n; }\n  inline void dum(int r = -1) {\n#ifdef DEBUG\n    if(r < 0) r = n;\n    DEBUG_OUT << \"{\";\n    for(int i = 0; i < min(r, (int) n); i++) DEBUG_OUT << (i ? \", \" : \"\") << get(i);\n    DEBUG_OUT << \"}\" << endl;\n#endif\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid examples {{{ ///\nconstexpr long long inf_monoid = 1e18 + 100;\n#include <algorithm>\nstruct Nothing {\n  using T = char;\n  using Monoid = Nothing;\n  using M = T;\n  static constexpr T op(const T &, const T &) { return T(); }\n  static constexpr T identity() { return T(); }\n  template < class X >\n    static constexpr X actInto(const M &, long long, const X &x) {\n      return x;\n    }\n};\n\ntemplate < class U = long long >\nstruct RangeMin {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::min< T >(a, b); }\n  static constexpr T identity() { return T(inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeMax {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::max< T >(a, b); }\n  static constexpr T identity() { return T(-inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeSum {\n  using T = U;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return T(0); }\n};\n\ntemplate < class U >\nstruct RangeProd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a * b; }\n  static constexpr T identity() { return T(1); }\n};\n\ntemplate < class U = long long >\nstruct RangeOr {\n  using T = U;\n  static T op(const T &a, const T &b) { return a | b; }\n  static constexpr T identity() { return T(0); }\n};\n\n#include <bitset>\n\ntemplate < class U = long long >\nstruct RangeAnd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return T(-1); }\n};\n\ntemplate < size_t N >\nstruct RangeAnd< std::bitset< N > > {\n  using T = std::bitset< N >;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return std::bitset< N >().set(); }\n};\n\n/// }}}--- ///\n\n/// --- M_act examples {{{ ///\ntemplate < class U = long long, class V = U >\nstruct RangeMinAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMin< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMax< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMinSet {\n  using M = U;\n  using Monoid = RangeMin< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxSet {\n  using M = U;\n  using Monoid = RangeMax< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long n, const X &x) { return m * n + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long n, const X &x) {\n    return m == identity() ? x : m * n;\n  }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdMul {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M mpow(M a, long long b) {\n    X r(1);\n    while(b) {\n      if(b & 1) r = r * a;\n      a = a * a;\n      b >>= 1;\n    }\n    return r;\n  }\n  static M op(const M &a, const M &b) { return a * b; }\n  static constexpr M identity() { return M(1); }\n  static X actInto(const M &m, long long n, const X &x) { return x * mpow(m, n); }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return V::unused; }\n  static X actInto(const M &m, long long n, const X &) {\n    if(m == identity()) return;\n    return RangeProdMul< U, V >::mpow(m, n);\n  }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeOr2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeOr< U >;\n  static M op(const M &a, const M &b) { return a | b; }\n  static constexpr M identity() { return M(0); }\n  static X actInto(const M &m, long long, const X &x) { return m | x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeAnd2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return M(-1); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n\ntemplate < class U, size_t N >\nstruct RangeAnd2< U, std::bitset< N > > {\n  using X = U;\n  using M = std::bitset< N >;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return std::bitset< N >().set(); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n/// }}}--- ///\n\nusing Seg = LazySegmentTree< RangeSumAdd<modint> >;\n\n\n// NOTE : use H with larger N\n/// --- Modulo Factorial {{{ ///\n#include <cassert>\n#include <cstddef>\ntemplate < std::size_t N, int mod = static_cast< int >(1e9 + 7) >\nstruct Factorial {\n  using integer = long long;\n  constexpr integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d = 0;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  constexpr integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  int arr[N + 1], inv[N + 1];\n  integer operator[](int i) const { return arr[i]; }\n  Factorial() : arr(), inv() {\n    arr[0] = 1;\n    for(std::size_t i = 1; i <= N; i++) {\n      arr[i] = (integer) i * arr[i - 1] % mod;\n    }\n    inv[N] = modinv(arr[N]);\n    for(int i = N - 1; i >= 0; i--) {\n      inv[i] = (integer)(i + 1) * inv[i + 1] % mod;\n    }\n  }\n  integer C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    assert(n <= N);\n    return (integer) arr[n] * inv[r] % mod * inv[n - r] % mod;\n  }\n  integer H(int n, int r) const { return C(n + r - 1, r); }\n};\n/// }}}--- ///\n\nconstexpr int mod = 1e9 + 7;\nconst int N = 2e5 + 10;\nFactorial< N * 2, mod > fact;\n\n\n\nint n, m;\nint r, b;\nint rmax;\nstring s;\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n >> m;\n  cin >> s;\n  if(s[0] == 'B') for(auto &e : s) e = e == 'R' ? 'B' : 'R';\n  bool allR = 1;\n  for(auto e : s) allR &= e == 'R';\n\n  if(allR) {\n    dump(\"allR\");\n    modint ans;\n    assert(0);\n    for(int B = 0; B <= n; B++) {\n      int R = n - B - B;\n      ans += modint(fact.C(R + B, R));\n      ans += modint(fact.C(R + B - 1, R));\n    }\n    cout << ans << endl;\n    return 0;\n  }\n\n  if(n % 2 == 1) {\n    cout << 0 << endl;\n    dump(\"odd\");\n    return 0;\n  }\n\n  int c = 0;\n  bool first = 1;\n  for(int i = 0; i <= m; i++) {\n    if(i == n || s[i] == 'B') {\n      if(c % 2 == 0 && first) rmax = max(rmax, c + 1);\n      if(c % 2 == 1) rmax = max(rmax, c);\n      c = 0;\n      first = 0;\n    } else c++;\n  }\n\n  dump(rmax);\n\n  // RB\n\n  // vector<modint> dp(n + 1);\n  Seg dp(n + 1);\n  dp.set(0, 1);\n\n  modint ans;\n\n  for(int i = 0; i <= n - 1; i+=2) {\n    dp.act(i + 2, min<int>(n - 1, i + 1 + rmax) + 1, dp.get(i));\n    if(i + 1 + rmax >= n) {\n      int f = n - i - 1;\n      if (f >= 1) {\n        dump(i, dp.get(i), f);\n        ans += dp.get(i) * (f + 1);\n      }\n    }\n  }\n  cout << ans << endl;\n  dp.dum();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n#ifdef DEBUG\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n)\\\n\t{cerr << #a << \" = {\";\\\n\tfor(int qwq = (st); qwq <= (n); ++qwq) {\\\n\t\tif(qwq == (st)) cerr << a[qwq];\\\n\t\telse cerr << \", \" << a[qwq];\\\n\t} cerr << \"}\" << endl;}\n#define displayv(v) displaya(v, 0, (int)(v).size() - 1)\n#endif\ntemplate<typename T> bool chmin(T &a, const T &b) { return a > b ? a = b, true : false; }\ntemplate<typename T> bool chmax(T &a, const T &b) { return a < b ? a = b, true : false; }\n\nconst int maxN = 200000 + 233;\nconst LL P = 1000000007;\nint n, m;\nchar s[maxN];\nLL f[maxN];\n\nLL purity() {\n\tLL f00 = 1, f11 = 1, f01 = 0, f10 = 0;\n\t// '11' is not OK\n\tfor(int i = 2; i <= n; ++i) {\n\t\tLL g00 = f00 + f01, g01 = f00,\n\t\t   g10 = f10 + f11, g11 = f10;\n\t\tf00 = g00 % P; f01 = g01;\n\t\tf10 = g10 % P; f11 = g11;\n\t}\n\treturn (f00 + f01 + f10) % P;\n}\n\nLL recur(int lim) {\n\t// sum( x ^ (p + 1) )\n\t// sum( (c + 1) * x ^ (p + 1) )\n//\tdisplay(lim);\n\tmemset(f, 0, sizeof(f));\n\tf[0] = 1; f[1] = 0; f[2] = 1; f[3] = 0;\n\tfor(int i = 4; i <= n; ++i) {\n\t\tf[i] = f[i - 2] * 2 % P;\n\t\tif(i - lim - 3 >= 0) f[i] = (f[i] + P - f[i - lim - 3]) % P;\n\t}\n//\tdisplaya(f, 0, n);\n\tLL ans = 0;\n\tfor(int i = 1; i <= lim; i += 2) if(n - i - 1 >= 0)\n\t\t(ans += f[n - i - 1] * (i + 1)) %= P;\n\treturn ans;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> m >> (s + 1);\n\tassert((int)strlen(s + 1) == m);\n\tchar major = s[1], minor = (int)'R' + 'B' - major;\n\tint cons = 0;\n\tint mn = maxN;\n\tfor(int i = 1; i <= m; ++i) {\n\t\tif(s[i] == major) cons++;\n\t\telse chmin(mn, cons | 1), cons = 0, assert(s[i] == minor);\n\t}\n\tif(mn == maxN) cout << purity() << endl;\n\telse cout << recur(mn) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define M 200005\n#define mo 1000000007\n#define ll long long\nint n,m,L;\nchar s[M];\nll ans,f[M],g[M];\nll dp[M][2];\nvoid work() {\n    L=1e9;\n    char ch=s[1];\n    for(int i=2,l=1;i<=m;i++)\n\t{\n\t    if(s[i]==ch) l++;\n\t    else\n\t\t{\n\t\t    if(l&1) L=min(L,l);\n\t\t    else L=min(L,l+1);\n\t\t    l=0;\n\t\t}\n\t}\n    if(L==1e9)\n\t{\n\t    dp[1][0]=1;\n\t    for(int i=2;i<=n;i++)\n\t\t{\n\t\t    dp[i][0]=(dp[i-1][0]+dp[i-1][1])%mo;\n\t\t    dp[i][1]=dp[i-1][0];\n\t\t}\n\t    ans=(dp[n][1]+dp[n][0])%mo;\n\t    memset(dp,0,sizeof(dp));\n\t    dp[1][1]=1;\n\t    for(int i=2;i<=n;i++)\n\t\t{\n\t\t    dp[i][0]=(dp[i-1][0]+dp[i-1][1])%mo;\n\t\t    dp[i][1]=dp[i-1][0];\n\t\t}\n\t    ans=(ans+dp[n][0])%mo;\n\t    cout<<ans<<'\\n';\n\t}\n    else\n\t{\n\t    f[1]=g[1]=1;\n\t    for(int i=2;i<=n;i++)\n\t\t{\n\t\t    if(i<=L&&(i&1)) f[i]=1;\n\t\t    for(int j=i-2;j>=max(i-L-1,0);j-=2) f[i]=(f[i]+f[j])%mo;\n\t\t    //f[i]=(f[i]+g[i-2]-(i-L-3>=0?g[i-L-3]:0)+mo)%mo;\n\t\t    //g[i]=(g[i-2]+f[i])%mo;\n\t\t}\n\t    for(int i=3;i<=L+2&&i<=n;i+=2) ans=(ans+f[n-i]*(i-1)%mo)%mo;\n\t    if(n-1<=L&&((n-1)&1)) ans=(ans+n)%mo;\n\t    cout<<ans<<'\\n';\n\t}\n}\nint main()\n{\n    cin>>n>>m;\n    scanf(\"%s\",s+1);\n    work();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nint n;\nint m;\nstring s;\nint mn = INF;\nll ans ;\nll dp[200005][2][2];\n\nstruct RMQ{\n\t#define ss (1<<19)\n\tll seg[ss];\n\tvoid update(int k,ll a){\n\t\tk+=ss/2-1; seg[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tseg[k]=(seg[k*2+1]+seg[k*2+2])%mod;\n\t\t}\n\t}\n\tll query(int a,int b,int k,int l,int r){\n\t\tif(r<a || b<l) return 0;\n\t\tif(a<=l && r<=b) return seg[k];\n\t\telse{\n\t\t\tll vl=query(a,b,k*2+1,l,(l+r)/2);\n\t\t\tll vr=query(a,b,k*2+2,(l+r)/2+1,r);\n\t\t\treturn (vl+vr)%mod;\n\t\t}\n\t}\n}rmq[2];\n\nint main(){\n\tcin>>n>>m>>s;\n    \tif(s[0] == 'B'){\n    \t\trep(i,m){\n    \t\t\tif(s[i] == 'B') s[i] = 'R';\n    \t\t\telse s[i] = 'B';\n    \t\t}\n    \t}\n\t\tint cur = 0;\n\t\tchar ch;\n\t\tbool beg = 0;\n\t\tint C = 0;\n\t\trep(i,m){\n\t\t\tif(i == 0){\n\t\t\t\tch = s[i];\n\t\t\t\tcur = 1;\n\t\t\t}\n\t\t\telse if(ch != s[i]){\n\t\t\t\tif(ch == 'R'){\n\t\t\t\t\tif(cur%2 == 1) mn = min(mn,cur);\n\t\t\t\t\telse if(!beg) mn = min(mn,cur+1);\n\t\t\t\t\tbeg = 1; \n\t\t\t\t}\n\t\t\t\t\tch = s[i];\n\t\t\t\t\tcur = 1; C++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse cur++;\n\t\t}\n\t\t\t\tif(ch == 'R'){\n\t\t\t\t\t/*if(cur%2 == 1) mn = min(mn,cur);\n\t\t\t\t\telse if(!beg) mn = min(mn,cur+1);\n\t\t\t\t\tbeg = 1; */\n\t\t\t\t}\n\t\t\t\tC++;\n\t\t\t\t\n\t\tif(C == 1){\n\t\t\t//BBが存在しなければOK\n\t\t\tdp[0][0][0] = dp[0][1][1] = 1;\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\trep(x,2){\n\t\t\t\t\tdp[i+1][0][x] += dp[i][0][x];\n\t\t\t\t\tdp[i+1][1][x] += dp[i][0][x];\n\t\t\t\t\tdp[i+1][0][x] += dp[i][1][x];\n\t\t\t\t\tdp[i+1][0][x] %= mod;\n\t\t\t\t\tdp[i+1][1][x] %= mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<((dp[n-1][0][0]+dp[n-1][0][1]+dp[n-1][1][0])%mod+mod)%mod<<endl;\n\t\t}\n\t\telse{\n\t\t\tdp[0][0][0] = 1;\n\t\t\trmq[0].update(0,1);\n\t\t\tfor(int i=2;i<n;i+=2){\n\t\t\t\tdp[i][0][0] = rmq[i%2].query(max(0,i-mn-1),i,0,0,(1<<18)-1);\n\t\t\t\trmq[i%2].update(i,dp[i][0][0]);\n\t\t\t}\n\t\t\tll ans = 0;\n\t\t\tfor(int m=1;m<=n;m++){\n\t\t\t\tif(m-1 > mn) continue;\n\t\t\t\tif((m-1)%2 == 0) continue;\n\t\t\t\tans += dp[n-m][0][0] * 1LL * m % mod;\n\t\t\t}\n\t\t\tcout << (ans%mod+mod)%mod << endl;\n\t\t\n\t\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define int long long\nusing namespace std;\nconst int N=2e5+2;\nconst int mod=1e9+7;\nint dp[N],sum[N];\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l,max1,ans=0,m;\n\tstring s;\n\tcin>>n>>m>>s;\n\tif(s[0]=='B'){\n\t\tfor(i=0;i<m;i++){\n\t\t\tif(s[i]=='B'){\n\t\t\t\ts[i]='R';\n\t\t\t}\n\t\t\telse{\n\t\t\t\ts[i]='B';\n\t\t\t}\n\t\t}\n\t}\n\tbool cac=true;\n\tfor(i=1;i<m;i++){\n\t\tif(s[i]!=s[i-1]){\n\t\t\tcac=false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(cac){\n\t\tdp[0]=1;\n\t\tsum[0]=1;\n\t\tans=n+1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(i!=1){\n\t\t\t\tdp[i]=sum[i-2];\n\t\t\t}\n\t\t\tsum[i]=sum[i-1];\n\t\t\tsum[i]+=dp[i];\n\t\t\tif(sum[i]>=mod){\n\t\t\t\tsum[i]-mod;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=n-3;i++){\n\t\t\tans+=(i+1)*dp[n-i-1];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout<<ans;\n\t}\n\telse{\n\t\tif(n%2!=0){\n\t\t\tcout<<0;\n\t\t\treturn 0;\n\t\t}\n\t\tmax1=n-1;\n\t\tcac=true;\n\t\tj=1;\n\t\tfor(i=1;i<m;i++){\n\t\t\tif(s[i]==s[i-1]){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(s[i]=='B'){\n\t\t\t\t\tif(cac){\n\t\t\t\t\t\tif(j&1){\n\t\t\t\t\t\t\tmax1=min(max1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tmax1=min(max1,j+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcac=false;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(j&1){\n\t\t\t\t\t\t\tmax1=min(max1,j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tj=1;\n\t\t\t}\n\t\t}\n\t\tdp[0]=1;\n\t\tsum[0]=1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tsum[i]=sum[i-1];\n\t\t\tif(i&1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[i]=sum[i-2];\n\t\t\tif(i-max1-2>=0){\n\t\t\t\tdp[i]-=sum[i-max1-2];\n\t\t\t\tif(dp[i]<0){\n\t\t\t\t\tdp[i]+=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum[i]+=dp[i];\n\t\t\tif(sum[i]>=mod){\n\t\t\t\tsum[i]-=mod;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=max1;i+=2){\t\n\t\t\tans+=(i+1)*dp[n-i-1];\n\t\t\tans%=mod;\n\t\t}\n\t\tcout<<ans;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\ntemplate< int mod >\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int) (1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while(b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while(n > 0) {\n      if(n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n  friend ostream &operator<<(ostream &os, const ModInt &p) {\n    return os << p.x;\n  }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt< mod >(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\ntemplate< typename T >\nstruct Combination {\n  vector< T > _fact, _rfact, _inv;\n\n  Combination(ll sz) : _fact(sz + 1), _rfact(sz + 1), _inv(sz + 1) {\n    _fact[0] = _rfact[sz] = _inv[0] = 1;\n    for(ll i = 1; i <= sz; i++) _fact[i] = _fact[i - 1] * i;\n    _rfact[sz] /= _fact[sz];\n    for(ll i = sz - 1; i >= 0; i--) _rfact[i] = _rfact[i + 1] * (i + 1);\n    for(ll i = 1; i <= sz; i++) _inv[i] = _rfact[i] * _fact[i - 1];\n  }\n\n  inline T fact(ll k) const { return _fact[k]; }\n\n  inline T rfact(ll k) const { return _rfact[k]; }\n\n  inline T inv(ll k) const { return _inv[k]; }\n\n  T P(ll n, ll r) const {\n    if(r < 0 || n < r) return 0;\n    return fact(n) * rfact(n - r);\n  }\n\n  T C(ll p, ll q) const {\n    if(q < 0 || p < q) return 0;\n    return fact(p) * rfact(q) * rfact(p - q);\n  }\n\n  T H(ll n, ll r) const {\n    if(n < 0 || r < 0) return (0);\n    return r == 0 ? 1 : C(n + r - 1, r);\n  }\n};\nusing modint = ModInt< MOD1 >;modint pow(ll n, ll x){return modint(n).pow(x);}modint pow(modint n, ll x){return n.pow(x);}\n//using modint=ld;\nusing Comb=Combination<modint>;\n\n\ntemplate<typename T>\nstruct BIT{\n  ll n;\n  ll k=1;\n  vector<T>data;\n  BIT() = default;\n  BIT(ll size):n(size){\n    data.assign(n,0);\n    while(k*2<=n)k*=2;\n  }\n  void add(ll a,T w){\n    for(ll i=a+1;i<=n;i+=i&-i)data[i-1]+=w;\n  }\n  T sum(ll a){\n\tif(a<0)return 0;\n    T ret = 0;\n    for(ll i=a+1;i>0;i-=i&-i)ret+=data[i-1];\n    return ret;\n  }\n  T sum(ll a,ll b){return a>b?0:sum(b)-sum(a-1);}\n  T operator[](ll pos){\n    return sum(pos,pos);\n  }\n  ll lower_bound(ll x){\n    ll ret=0;    \n    for(ll i=k;i>0;i/=2){\n      if(ret+i<=n&&data[ret+i-1]<x){\n        x-=data[ret+i-1];\n        ret+=i;\n      }\n    }\n    return ret;\n  }\n  void print(){\n    for(ll i=0;i<n;i++){\n      if(i!=0)cout<<\" \";\n      cout<<(*this)[i];\n    }\n    cout<<endl;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,m;cin>>n>>m;\n  string s;cin>>s;\n  if(s[0]=='B'){\n    rep(i,0,m){\n      if(s[i]=='R')s[i]='B';\n      else s[i]='R';\n    }\n  }\n  ll mx=n-1;\n  {\n    vector<ll>v;\n    ll cnt=0;\n    rep(i,0,m){\n      if(s[i]=='R')cnt++;\n      else{\n        v.PB(cnt);\n        cnt=0;\n      }\n    }\n    if(v.empty()){\n      modint tmp=0;\n      Comb comb(300005);\n      rep(i,0,n+1){\n        tmp+=comb.C(n-i-1,i-1)*2+comb.C(n-i-1,i);\n      }\n      cout<<tmp<<endl;\n      return 0;\n    }\n    rep(i,0,v.size()){\n      if(i==0||v[i]&1)chmin(mx,v[i]);\n    }\n    if(~mx&1)mx++;\n  }\n  vector<modint>v(n+1);\n  BIT<modint>bit(n+1);\n  bit.add(0,1);\n  rep(i,0,n){\n    if(~i&1)continue;\n    bit.add(i+1,bit.sum(max(0LL,i-mx),i));\n  }\n  modint ret=0;\n  rep(i,0,n+1){\n    ret+=bit.sum(max(0LL,n-mx-1),n-i-1);\n    //cout<<n-mx-1 spa n-i spa bit.sum(n-mx-1,n-i)<<endl;\n  }\n  //bit.print();\n  //debug(v,n+1);\n  cout<<ret<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register\nchar ss[1001000];\nconst int mod=1e9+7;\nint f[1001000],x[2];\nint main()\n{\n\tre int n,m,ans=1,xx=1,mmx=1<<30;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",ss+1);\n\tfor(re int i=1;i<=m;i++)\n\t{\n\t\tif(ss[i]!=ss[1])\n\t\t{\n\t\t\tif(xx<mmx)mmx=xx;\n\t\t\txx=0;ans=0;\n\t\t}else xx++;\n\t}\n\tif(ans==1)\n\t{\n\t\t\n\t}\n\tmmx+=2;\n\tif(mmx&1)mmx--;\n\tf[0]=f[2]=1;\n\tfor(re int i=4;i<=n;i++)\n\t{\n\t\tf[i]=(2ll*f[i-2]+(i-mmx-2>=0?mod-f[i-mmx-2]:0))%mod;\n\t//\tprintf(\"**%d %d\\n\",i,f[i]);\n\t}\n\tfor(re int i=2;i<=mmx&&i<=n;i+=2)ans=(ans+(long long)i*f[n-i])%mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e5+10,inf=0x3f3f3f3f,mod=1e9+7;\nchar s[maxn];\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\ty>>=1;\n\t\tx=(ll)x*x%mod;\n\t}\n\treturn res;\n}\nint dp[maxn],sum[maxn];\nint main(){\n\tint n=read(),m=read();\n\tscanf(\"%s\",s+1);\n\tint Min=inf;\n\tfor(int i=1,j;i<=m;i++) if(s[i]==s[1]){\n\t\tj=i;\n\t\twhile(j<m && s[j+1]==s[1]) ++j;\n\t\tif(j!=m){\n\t\t\tif((j-i+1)%2==1) chkmin(Min,j-i+1);\n\t\t\telse if(i==1) chkmin(Min,j-i+2);\n\t\t}\n\t\ti=j;\n\t}\n\tint flag=1;\n\tREP(i,2,m) flag&=(s[i]==s[1]);\n\tdp[1]=sum[1]=1;\n\tREP(i,2,n+1){\n\t\tif(flag){\n\t\t\tdp[i]=sum[i-2];\n\t\t\tsum[i]=(sum[i-1]+dp[i])%mod;\n\t\t}\n\t\telse{\n\t\t\tdp[i]=(sum[i-2]-sum[max(i-Min-3,0)]+mod)%mod;\n\t\t\tsum[i]=(sum[i-2]+dp[i])%mod;\n\t\t}\n\t}\n\tint ans=(dp[n+1]*2+flag)%mod;\n\tREP(i,1,n-2) if(((n-i)%2==1 && n-i<=Min) || flag) ans=(ans+(ll)dp[i]*(n-i-1))%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) FOR(i,0,b)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define all(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n#define fs first\n#define sc second\n\ntemplate<class T> using V=vector<T>;\ntemplate<class T> using VV=V<V<T>>;\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\trep(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"(\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\")\";\n}\n\nll read(){\n\tll i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconstexpr ll TEN(int n){\n\treturn n==0?1:TEN(n-1)*10;\n}\n\ntemplate<class T>\nvector<T> Uniqued(const vector<T>&vv){\n\tauto v(vv);\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n\treturn v;\n}\ntemplate<class T>\nvoid MakeUniqued(vector<T>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.end());\n}\n\ntemplate<int mod>\nstruct ModInt{\n\tstatic constexpr int base=mod;\n\tint v;\n\tModInt():v(0){}\n\tModInt(ll vv){\n\t\tv=vv%mod;\n\t\tif(v<0)v+=mod;\n\t}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n\texplicit operator int()const{\n\t\treturn v;\n\t}\n\tbool operator==(const ModInt&rhs)const{\n\t\treturn v==rhs.v;\n\t}\n\tbool operator!=(const ModInt&rhs)const{\n\t\treturn v!=rhs.v;\n\t}\n\tModInt operator-()const{\n\t\treturn ModInt(0)-*this;\n\t}\n\tModInt& operator+=(const ModInt&rhs){\n\t\tv+=rhs.v;\n\t\tif(v>=mod)v-=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator-=(const ModInt&rhs){\n\t\tv-=rhs.v;\n\t\tif(v<0)v+=mod;\n\t\treturn *this;\n\t}\n\tModInt&operator*=(const ModInt&rhs){\n\t\tv=ll(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tModInt&operator/=(const ModInt&rhs){\n\t\toperator*=(rhs.inv());\n\t\treturn *this;\n\t}\n\tModInt operator+(const ModInt&rhs)const{\n\t\treturn ModInt(*this)+=rhs;\n\t}\n\tModInt operator-(const ModInt&rhs)const{\n\t\treturn ModInt(*this)-=rhs;\n\t}\n\tModInt operator*(const ModInt&rhs)const{\n\t\treturn ModInt(*this)*=rhs;\n\t}\n\tModInt operator/(const ModInt&rhs)const{\n\t\treturn ModInt(*this)/=rhs;\n\t}\n\tfriend ModInt operator+(int x,const ModInt&y){\n\t\treturn ModInt(x)+y;\n\t}\n\tfriend ModInt operator-(int x,const ModInt&y){\n\t\treturn ModInt(x)-y;\n\t}\n\tfriend ModInt operator*(int x,const ModInt&y){\n\t\treturn ModInt(x)*y;\n\t}\n\tfriend ModInt operator/(int x,const ModInt&y){\n\t\treturn ModInt(x)/y;\n\t}\n\tModInt pow(int n)const{\n\t\tModInt res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tModInt inv()const{\n\t\treturn pow(mod-2);\n\t}\n};\n\ntemplate<int mod>\nostream& operator<<(ostream&os,const ModInt<mod>&m){\n\treturn os<<m.v;\n}\ntemplate<int mod>\nvoid print(const ModInt<mod>&m,int suc=1){\n\tprint(m.v,suc);\n}\n\n//using mint=ModInt<1000000007>;\nusing mint=ModInt<998244353>;\n\nconst int Vmax=min<int>(2000010,mint::base);\nmint fact[Vmax],factInv[Vmax],invs[Vmax];\nvoid InitFact(){\n\tfact[0]=1;\n\tFOR(i,1,Vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfactInv[Vmax-1]=fact[Vmax-1].inv();\n\tfor(int i=Vmax-2;i>=0;i--){\n\t\tfactInv[i]=factInv[i+1]*(i+1);\n\t}\n\tfor(int i=Vmax-1;i>=1;i--){\n\t\tinvs[i]=factInv[i]*fact[i-1];\n\t}\n}\nstruct InitFactDummy{\n\tInitFactDummy(){\n\t\tInitFact();\n\t}\n} initFactDummy;\nmint Choose(int n,int k){\n\treturn fact[n]*factInv[n-k]*factInv[k];\n}\nmint Binom(int a,int b){\n\treturn fact[a+b]*factInv[a]*factInv[b];\n}\nmint Catalan(int n){\n\treturn Binom(n,n)-(n-1>=0?Binom(n-1,n+1):0);\n}\n\nV<mint> getDP(int m,int a,int b){\n\tV<mint> dp(m+1),sum(m+1);\n\tdp[0]=sum[0]=1;\n\tFOR(i,1,m+1){\n\t\tmint w;\n\t\tif(i-a>=0)w+=sum[i-a];\n\t\tif(i-b-1>=0)w-=sum[i-b-1];\n\t\tdp[i]=w;\n\t\tsum[i]=sum[i-1]+dp[i];\n\t}\n\treturn dp;\n}\n\nsigned main(){\n\tint n=read(),m=read();\n\tstring s=readString();\n\tif(s[0]!='R'){\n\t\tfor(auto&c:s){\n\t\t\tc='R'+'B'-c;\n\t\t}\n\t}\n\tif(s==string(n,'R')){\n\t\tauto dp=getDP(m,2,inf);\n\t\tmint ans=1;\n\t\tfor(int k=1;k<=n-1;k++){\n\t\t\tint rem=n-k-1;\n\t\t\tans+=dp[rem]*(k+1);\n\t\t}\n\t\tprint(ans);\n\t\treturn 0;\n\t}\n\tint lim=n-1;\n\tif(lim%2==0)lim--;\n\tfor(int i=0;i<m;){\n\t\tif(s[i]=='R'){\n\t\t\tint len=0;\n\t\t\twhile(i+len<m&&s[i+len]=='R')\n\t\t\t\tlen++;\n\t\t\ti+=len;\n\t\t\tif(i<m&&len%2)\n\t\t\t\tchmin(lim,len);\n\t\t\tif(i==len&&len%2==0)\n\t\t\t\tchmin(lim,len+1);\n\t\t}else{\n\t\t\ti++;\n\t\t}\n\t}\n\tconst int L=(lim+1)/2;\n\tauto dp=getDP(m,1,L);\n\tcerr<<L<<endl;\n\tcerr<<dp<<endl;\n\tmint ans;\n\tfor(int k=1;k<=lim;k+=2){\n\t\tint rem=(n-k-1);\n\t\tcerr<<rem<<endl;\n\t\tif(rem%2)continue;\n\t\tmint w=dp[rem/2];\n\t\tans+=w*(k+1);\n\t}\n\tprint(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n#define mod 1000000007\n#define N 200050\nint n,m,dp[N][2][2],fg,mx,fg2,dp2[N],su[N],as;\nchar s[N];\nint main()\n{\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tfor(int i=2;i<=m;i++)if(s[i]!=s[i-1])fg=1;\n\tif(!fg)\n\t{\n\t\tdp[1][1][1]=dp[1][0][0]=1;\n\t\tfor(int i=2;i<=n;i++)\n\t\tdp[i][0][0]=(dp[i-1][0][0]+dp[i-1][1][0])%mod,\n\t\tdp[i][0][1]=(dp[i-1][0][1]+dp[i-1][1][1])%mod,\n\t\tdp[i][1][0]=dp[i-1][0][0],\n\t\tdp[i][1][1]=dp[i-1][0][1];\n\t\tprintf(\"%lld\\n\",(1ll*dp[n][0][0]+dp[n][0][1]+dp[n][1][0])%mod);\n\t\treturn 0;\n\t}\n\tint su1=0;\n\tfor(int i=1;i<=n;i++)\n\tif(s[i]==s[1])su1++;\n\telse\n\t{\n\t\tif((su1&1)&&mx>su1)mx=su1;\n\t\tif(!fg2)mx=su1+1;\n\t\tfg2=1;\n\t}\n\tif(~mx&1)mx--;\n\tdp2[1]=1;su[1]=1;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(i-mx>3)dp2[i]=(su[i-2]-su[i-mx-3]+mod)%mod;\n\t\telse dp2[i]=su[i-2];\n\t\tsu[i]=(su[i-2]+dp2[i])%mod;\n\t}\n\tfor(int i=1;i<=mx;i+=2)as=(as+1ll*dp2[n-i]*(i+1))%mod;\n\tprintf(\"%d\\n\",as);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nint Mn(int a,int b){return a<b?a:b;}\nconst int N=2e5+5,mod=1e9+7;\nint upt(int x){while(x>=mod)x-=mod;while(x<0)x+=mod;return x;}\n\nint n,m,lm,dp[N],sm[N],ans,f[N][5],g[N];\nchar s[N];\n/*void solve()\n{\n  f[1][0]=1;\n  for(int i=2;i<=n;i++)\n    {\n      f[i][0]=f[i-1][0];\n      f[i][1]=upt(f[i-1][1]+f[i-1][2]);\n      f[i][2]=upt(f[i-1][0]+f[i-1][1]);\n    }\n  int ans=(f[n][0]+upt(f[n][1]+f[n][2]));\n  f[1][2]=1; f[1][0]=f[1][1]=0;\n  for(int i=2;i<=n;i++)\n    {\n      f[i][1]=upt(f[i-1][1]+f[i-1][2]);\n      f[i][2]=f[i-1][1];\n    }\n  ans=upt(ans+f[n][1]); printf(\"%d\\n\",ans);\n  }*/\nvoid solve()\n{\n  g[0]=sm[0]=1;\n  for(int i=1;i<=n;i++)\n    {\n      if(i>=2)g[i]=sm[i-2];\n      sm[i]=upt(sm[i-1]+g[i]);\n    }\n  int ans=1;//ans=1 for all one color\n  for(int i=2;i<=n;i++)\n    ans=(ans+(ll)i*g[n-i])%mod;\n  printf(\"%d\\n\",ans);\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&m);\n  scanf(\"%s\",s+1); bool fg=0;\n  for(int i=1;i<=m;i++)\n    if(s[i]!=s[1]){fg=1;break;}\n  if(!fg){solve();return 0;}\n  if(n&1){puts(\"0\");return 0;}\n  lm=n+1;\n  for(int i=1;i<=m;i++)\n    if(s[i]==s[1])//== not !=\n      {\n\tint j=i;\n\twhile(j+1<=m&&s[j+1]==s[j])j++;\n\tswap(i,j); j=i-j+1;\n\tif(i-j==0) lm=Mn(lm,j+((j&1)==0));\n\telse if((j&1)&&i!=m)lm=Mn(lm,j);//i!=m not i!=lst!!!\n      }\n  n>>=1; lm=(lm+1)>>1; dp[0]=sm[0]=1;\n  for(int i=1;i<=n;i++)\n    {\n      dp[i]=sm[i-1]; if(i>lm)dp[i]=upt(dp[i]-sm[i-lm-1]);\n      sm[i]=upt(sm[i-1]+dp[i]);\n    }\n  int ans=0;\n  for(int i=1;i<=lm;i++)//lm not n\n    ans=(ans+i*2%mod*dp[n-i])%mod;\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PI 3.14159265358979323846264338327950288419\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint n, m;\nint col[200005];\n\nint expo(int a, int b){\n\tint c = 1, d = a;\n\twhile(b){\n\t\tif(b & 1){\n\t\t\tc = 1LL * c * d % mod;\n\t\t}\n\t\td = 1LL * d * d % mod;\n\t\tb >>= 1;\n\t}\n\treturn c;\n}\n\nint inv(int x){\n\treturn expo(x, mod - 2);\n}\n\nint calc(int n){\n\tif(n == 2){\n\t\treturn 2;\n\t}\n\t\n\tint fib[200005];\n\tfib[1] = fib[2] = 1;\n\tfor(int i = 3; i <= n + 1; i++){\n\t\tfib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t}\n\t\n\t// force first one to be 1, last one to be 0: fib[N - 1]\n\t// force first one to be 0: fib[N + 1]\n\treturn (fib[n - 1] + fib[n + 1]) % mod;\n}\n\nint calc2(int n, int lb, int ub){\n\tassert(lb & 1);\n\tassert(ub & 1);\n\tif(lb > ub){\n\t\treturn 0;\n\t}\n\t\n\t// want a bunch of numbers, in [lb, rb], to sum to n\n\t\n\tlb++;\n\tub++;\n\tub = min(ub, n); // coz it can actually be HUGE\n\t\n\tint dp[200005]; // dp[i]: number of possible sums, that sum to i\n\tlong long cumu[200005];\n\t\n\tdp[0] = 1;\n\tcumu[0] = 1;\n\t\n\tfor(int i = 2; i <= n; i += 2){\n\t\t// sum from dp[l_index .. r_index].. oh, only the even ones!\n\t\tint l_index = i - ub;\n\t\tint r_index = i - lb;\n\t//\tprintf(\"%d: sum %d..%d\\n\", i, l_index, r_index);\n\t\tif(r_index >= 0) dp[i] = cumu[r_index];\n\t\tif(l_index > 0) dp[i] -= cumu[l_index - 2];\n\t\t\n\t\tif(dp[i] < 0) dp[i] += mod;\n\t\t\n\t\tcumu[i] = (cumu[i - 2] + dp[i]) % mod;\n\t//\tprintf(\"dp %d, cumu %d\\n\", dp[i], cumu[i]);\n\t}\n\t\n\tint ret = 0;\n\t\n\tfor(int space = 0; space < ub; space++){\n\t\t// last 1 is at (n - space), leaving _ space at the end\n\t\t// where can the first 1 be?\n\t\tint left_pos = max(1, lb - space);\n\t\tint right_pos = ub - space;\n\t\tint most_remain = (n - space) - left_pos;\n\t\tint least_remain = (n - space) - right_pos;\n\t\tif(most_remain & 1) most_remain--;\n\t\tif(least_remain & 1) least_remain++;\n\t\t\n\t\tint combin = 0;\n\t\tif(most_remain >= least_remain){\n\t\t\tcombin = cumu[most_remain];\n\t\t\tif(least_remain > 0){\n\t\t\t\tcombin = (combin - cumu[least_remain - 2] + mod) % mod;\n\t\t\t}\n\t\t}\n\t\tret = (ret + combin) % mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= m; i++){\n\t\tchar c;\n\t\tscanf(\" %c\", &c);\n\t\tcol[i] = (c == 'B');\n\t}\n\tif(col[1] != 0){\n\t\t// WLOG first one is 0\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tcol[i] = 1 - col[i];\n\t\t}\n\t}\n\t\n\tbool monochrome = true;\n\tfor(int i = 2; i <= m; i++){\n\t\tif(col[i]){\n\t\t\tmonochrome = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(monochrome){\n\t\t// ok as long as 1s are not adjacent\n\t\tprintf(\"%d\\n\", calc(n));\n\t\treturn 0;\n\t}else{\n\t\t// 00...010..010..0\n\t\t// each block of 0 is of add length\n\t\t// so, n odd -> definitely no solution\n\t\t// more conditions depending on specifics of col[]\n\t\tif(n % 2 == 1){\n\t\t \tprintf(\"0\\n\");\n\t\t \treturn 0;\n\t\t}\n\t\tint first_run = 0, subseq_run = 0;\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tint len = 0;\n\t\t\twhile(i + len <= m && col[i + len] == 0){\n\t\t \t\tlen++;\n\t\t \t}\n\t\t \tif(first_run == 0){\n\t\t \t\tfirst_run = len;\n\t\t \t}else if(len & 1){\n\t\t \t\tsubseq_run = max(subseq_run, len);\n\t\t \t}\n\t\t \ti += len;\n\t\t}\n\t\tint lb = max(1, subseq_run);\n\t\tint ub = first_run + (first_run % 2 == 0);\n\t//printf(\"%d %d\\n\", lb, ub);\n\t\tprintf(\"%d\\n\", calc2(n, lb, ub));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_map>\n#define mod 1000000007\nusing namespace std;\ntypedef long long ll;\n#define chmax(a,b) a=max(a,b)\n#define chmin(a,b) a=min(a,b)\n#define mad(a,b) a=(a+b)%mod\n#define mul(a,b) a=a*b%mod\n\nll n,m;\nstring s;\nll f[200010],rui[200010];\n\nint main(){\n    cin>>n>>m>>s;\n    if(s[0]=='R'){\n\tfor(int i=0;i<m;i++){\n\t    if(s[i]=='R')s[i]='B';\n\t    else s[i]='R';\n\t}\n    }\n    bool th=0;\n    ll cnt=0,mi=1e17;\n    bool fi=1; ll lead;\n    for(int i=0;i<n;i++){\n\tif(s[i]=='R'){\n\t    if(fi)lead=cnt; fi=0;\n\t    th=1;\n\t    if(cnt%2==1)chmin(mi,cnt);\n\t    cnt=0;\n\t}\n\telse cnt++;\n    }\n    if(th==0){\n\tf[0]=f[1]=1;\n\tfor(int i=2;i<n;i++){\n\t    f[i]=(f[i-1]+f[i-2])%mod;\n\t}\n\tll ans=(f[n-2]*2+f[n-1])%mod;\n\tcout<<ans<<endl;\n\treturn 0;\n    }\n    if(n%2==1){\n\tcout<<0<<endl;\n\treturn 0;\n    }\n    \n    if(lead%2==0)lead++;\n    chmin(mi,lead);\n    mi=(mi+1)/2;\n    chmin(mi,n/2);\n    f[0]=rui[0]=0;\n    for(ll i=1;i<=mi;i++){\n\tf[i]=i;\n\trui[i]=(rui[i-1]+i)%mod;\n    }\n    for(int i=1;i<n/2;i++){\n\tmad(f[i],rui[i-1]);\n\tif(i-mi-1>=0)mad(f[i],-rui[i-mi-1]);\n\trui[i]=(rui[i-1]+f[i])%mod;\n    }\n    ll ans=0;\n    for(int i=1;i<=mi;i++)mad(ans,f[n/2-i]);\n    //cout<<mi<<endl;\n    //for(int i=0;i<n/2;i++)cout<<i<<\":\"<<f[i]<<endl;\n    ans=ans*2%mod;\n    if(ans<0)ans+=mod;\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-03 17:07:09\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#define i64 long long\nconst int N=200010,mod=1000000007;\nint n,m,flag,l,Flag;\ni64 f[N],F[N],ans;\nchar s[N];\nint main()\n{\n\tn=read(); m=read();\n\tscanf(\"%s\",s+1);\n\tfr(i,2,m) if(s[i]!=s[1]) flag=1;\n\tif(!flag)\n\t{\n\t\tf[1]=1; f[2]=2;\n\t\tfr(i,3,n) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",int((f[n]+f[n-2])%mod));\n\t\treturn 0;\n\t}\n\tl=n-1;\n\tfor(int i=1,j;i<=m;)\n\t\tif(s[i]==s[1])\n\t\t{\n\t\t\tj=i;\n\t\t\twhile(s[j]==s[1]) j++;\n\t\t\tif(j>n) break;\n\t\t\tif(((j-i)&1)||(!Flag)){ l=std::min(l,(j-i)+(!((j-i)&1))); Flag=1; }\n\t\t\ti=j+1;\n\t\t}\n\t\telse i++;\n\tif(n&1){ printf(\"0\\n\"); return 1; }\n\tn/=2; l=(l+1)/2;\n//\tprintf(\"%d %d\\n\",int(n),int(l));\n\tf[0]=F[0]=1;\n\tfr(i,1,n)\n\t{\n\t\tf[i]=(F[i-1]+mod-(i-l-1>=0?F[i-l-1]:0))%mod;\n\t\tF[i]=(F[i-1]+f[i])%mod;\n//\t\tprintf(\"%d%c\",int(f[i]),i==n?'\\n':' ');\n\t}\n\tans=f[n];\n\tfr(i,1,l) ans=(ans+f[n-i]*(2*i-1))%mod;\n\tprintf(\"%d\\n\",int(ans));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long int int64;\nstatic const int64 mod = 1000000007LL;\n\nint n,m;\nchar s[200003];\nint64 dp[200003],rdp[200003];\nint64 solve(int n,int m) // divide circle of n into sections not longer than m\n{\n\tdp[0] = rdp[0] = 1;\n\tfor(int i = 1;i <= n;++i) {\n\t\tdp[i] = (rdp[i-1] - (i>=m+1?rdp[i-m-1]:0)) % mod;\n\t\trdp[i] = (rdp[i-1] + dp[i]) % mod;\n\t}\n\tint64 ans = 0;\n\tfor(int i = 1;i <= m;++i) {\n\t\tans += (n-i>=0?rdp[n-i]:0) - (n-m-1>=0?rdp[n-m-1]:0);\n\t}\n\treturn ans % mod;\n}\nint main()\n{\n\tscanf(\"%d%d \",&n,&m);\n\tfor(int i = 0;i < m;++i) {\n\t\ts[i] = getchar() == 'R' ? 0 : 1;\n\t}\n\tint len = 1;\n\tint maxlen = -1;\n\tfor(int i = 1;i < m;++i) {\n\t\ts[i] ^= s[0];\n\t\tif(s[i] == 0) ++len;\n\t\telse {\n\t\t\tif(len == i) maxlen = (len%2==0?len+1:len);\n\t\t\telse if(len % 2 == 1) maxlen = std::min(maxlen,len);\n\t\t\tlen = 0;\n\t\t}\n\t}\n\tint64 ans;\n\tif(len == m) {\n\t\tswitch(n) {\n\t\tcase 1: {\n\t\t\tans = 1;\n\t\t\tbreak;\n\t\t}\n\t\tcase 2: {\n\t\t\tans = 3;\n\t\t\tbreak;\n\t\t}\n\t\tdefault: {\n\t\t\tdp[0] = dp[1] = 1;\n\t\t\tfor(int i = 2;i <= n+1;++i) {\n\t\t\t\tdp[i] = (dp[i-1] + dp[i-2]) % mod;\n\t\t\t}\n\t\t\tans = dp[n+1]-dp[n-3];\n\t\t\tbreak;\n\t\t}}\n\t} else {\n\t\tif(n%2==1) {\n\t\t\tans = 0;\n\t\t} else {\n\t\t\tans = solve(n/2,(maxlen+1)/2)*2;\n\t\t}\n\t}\n\tans %= mod;\n\tif(ans < 0) ans += mod;\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\nV<mint> fact,ifact;\nmint Choose(int a,int b){\n\tif(b<0 || a<b) return 0;\n\treturn fact[a] * ifact[b] * ifact[a-b];\n}\nvoid InitFact(int N){\n\tfact.resize(N);\n\tifact.resize(N);\n\tfact[0] = 1;\n\trep1(i,N-1) fact[i] = fact[i-1] * i;\n\tifact[N-1] = fact[N-1].inv();\n\tfor(int i=N-2;i>=0;i--) ifact[i] = ifact[i+1] * (i+1);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\n\tInitFact(500000);\n\t\n\tint N,M;\n\tstring s;\n\tcin >> N >> M >> s;\n\tfor(char& c: s) if(c=='R') c = 'A';\n\tif(s[0] == 'B'){\n\t\tfor(char& c: s) c = 'A'^'B'^c;\n\t}\n\t{\n\t\tbool allA = true;\n\t\tfor(char c:s) if(c=='B') allA = false;\n\t\tif(allA){\n\t\t\tmint ans = 1;\n\t\t\trep1(b,N){\n\t\t\t\tmint tmp = Choose(N-1-b,b-1);\n\t\t\t\ttmp *= N;\n\t\t\t\ttmp /= b;\n\t\t\t\tans += tmp;\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint X = 1e9;\n\tint start = 0;\n\trep(i,M){\n\t\tif(s[i] == 'B'){\n\t\t\tif(s[start] == 'A'){\n\t\t\t\tint len = i-start;\n\t\t\t\tif(start == 0){\n\t\t\t\t\tchmin(X,len/2*2+1);\n\t\t\t\t}else{\n\t\t\t\t\tif(len%2 == 1) chmin(X,len);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart = i+1;\n\t\t}\n\t}\n\tif(N%2 == 1){\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tassert(X%2 == 1);\n\t\n\tV<mint> dp(N+1);\n\tdp[0] = 1;\n\tV<mint> a(2);\n\ta[0] = 1;\n\trep1(i,N){\n\t\tif(i-X-3 >= 0) a[i%2] -= dp[i-X-3];\n\t\tdp[i] = a[i%2];\n\t\ta[i%2] += dp[i];\n\t}\n\tmint ans = dp[N];\t//0:B\n\tfor(int A=1;A<=X;A+=2){\n\t\tif(N-A-1 < 0) break;\n\t\tans += dp[N-A-1] * A;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nnamespace ae86\n{\n\tconst int bufl = 1<<15;\n\t\n\tchar buf[bufl],*s=buf,*t=buf;\n\t\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\t\n\tinline int ty()\n\t{\n\t\tint a=0,b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n\n\ttemplate<typename T> inline int ts(T *s)\n\t{\n\t\tint a=0,c=fetch();\n\t\twhile(c<=32 && c!=EOF)c=fetch();\n\t\twhile(c>32 && c!=EOF)s[a++]=c,c=fetch();\n\t\ts[a]=0;\n\t\treturn a;\n\t}\n}\nusing ae86::ty;\nusing ae86::ts;\n\nconst int _ = 200007 , mo = 1000000007;\n\nint n,m,s[_];\nlint f[_]={0};\n\nint main()\n{\n\tn=ty(),m=ty(),ts(s+1);\n\tfor(int i=m;i>=1;i--)s[i]=s[i]==s[1];\n\n\tlint ans=0;\n\twhile(m && s[m])m--;\n\tif(m<=0)ans=1;\n\t\n\tint lim=n;\n\tfor(int l=1,r=1;l<=m;l=r+1)\n\t{\n\t\twhile(l<=m && !s[l])l++;\n\t\tif(l>m)break;\n\t\tr=l;\n\t\twhile(r<m && s[r+1])r++;\n\t\tint len=r-l+1;\n\t\tif(l==1)lim=min(lim,len+(1-len%2));\n\t\tif(len&1)lim=min(lim,len);\n\t}\n\n\tif(lim>=n)\n\t{\n\t\tf[0]=1;\n\t\tfor(int i=1,x=0;i<=n;i++)f[i]=x,x=(x+f[i-1])%mo;\n\t\tfor(int i=2;i<=n;i++)ans=(ans+f[n-i]*i%mo)%mo;\n\t}\n\telse\n\t{\n\t\tf[0]=1;\n\t\tfor(int i=2,x=f[0];i<=n;i+=2)\n\t\t{\n\t\t\tf[i]=x,x=(x+f[i])%mo;\n\t\t\tif(i>lim)x=(x-f[i-lim-1]+mo)%mo;\t\n\t\t}\n\t\tfor(int i=2;i<=lim+1;i+=2)ans=(ans+f[n-i]*i%mo)%mo;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline tuple<int, int, int> extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nunsigned ModInt::MOD = 1000000007;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\n\n\nconst int limit = 200010;\nmint dp[limit];\nmint csum[limit];\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\tstring s;\n\tcin >> s;\n\n\tint cmin = m, cons = 0;\n\trep(i, m){\n\t\tif(s[i] == s[0]){\n\t\t\tcons++;\n\t\t} else {\n\t\t\tchmin(cmin, cons);\n\t\t\tcons = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(cmin % 2 == 0) cmin++;\n\tdp[1] = csum[1] = ONE;\n\n\trep(i, 1, n){\n\t\tconst int pos = max(i - cmin - 1, 0);\n\t\tif((i + 1) % 2 == 1) dp[i + 1] =  csum[i] - csum[pos];\n\t\tcsum[i + 1] = csum[i] + dp[i + 1];\n\t}\n\n\tmint ans = ZERO;\n\n\trep(i, max(0, n - cmin), n + 1){\n\t\tconst mint coef = mint(n - i + 1);\n\t\tans += coef * dp[i];\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb push_back\n#define szz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nconst int mod = 1e9 + 7;\n\nint n, m;\nchar S[200020];\nll res[200020];\nll D[200020], sum[200020];\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", S + 1);\n\tif(S[1] == 'B') {\n\t\tfor(int i=1;i<=m;i++) S[i] = (S[i] == 'B' ? 'R' : 'B');\n\t}\n\tint all_r = 1;\n\tfor(int i=1;i<=m;i++) if(S[i] != 'R') all_r = 0;\n\tif(all_r) {\n\t\tint dp[200020][2] = {};\n\t\tdp[1][0] = 1; dp[1][1] = 0;\n\t\tfor(int i=2;i<=n;i++) {\n\t\t\tdp[i][0] = (dp[i-1][0] + dp[i-1][1]) % mod;\n\t\t\tdp[i][1] = dp[i-1][0];\n\t\t}\n\t\tint ans = (dp[n][0] + dp[n][1]) % mod;\n\t\tmemset(dp, 0, sizeof dp);\n\t\tdp[1][0] = 0; dp[1][1] = 1;\n\t\tfor(int i=2;i<=n;i++) {\n\t\t\tdp[i][0] = (dp[i-1][0] + dp[i-1][1]) % mod;\n\t\t\tdp[i][1] = dp[i-1][0];\n\t\t}\n\t\tans = (ans + dp[n][0]) % mod;\n\t\tprintf(\"%d\\n\", ans);\n\t\treturn 0;\n\t}\n\twhile(S[m] == 'R') --m;\n\tvector <int> v;\n\tfor(int i=1, c=0;i<=m;i++) {\n\t\tif(S[i] == 'R') ++c;\n\t\tif(S[i] == 'R' && (i == m || S[i+1] == 'B')) {\n\t\t\tv.pb(c);\n\t\t\tc = 0;\n\t\t}\n\t}\n\t\n\tif(n % 2) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tint lmn = n - 1;\n\trep(i, szz(v)) {\n\t\tif(v[i] % 2) {\n\t\t\tlmn = min(lmn, v[i]);\n\t\t}\n\t\telse lmn = min(lmn, v[i] + 1);\n\t}\n\tlmn = (lmn + 1) / 2;\n\t\n\tint sn = n / 2;\n\t\n\tD[0] = sum[0] = 1;\n\tfor(int i=1;i<=sn;i++) {\n\t\tD[i] = (sum[i-1] - (i-lmn-1 < 0 ? 0 : sum[i-lmn-1]));\n\t\tif(D[i] < 0) D[i] += mod;\n\t\tsum[i] = (sum[i-1] + D[i]) % mod;\n\t}\n\t\n\tll ans = 0;\n\tfor(int i=1;i<=lmn;i++) {\n\t\tans = (ans + (2 * i) * D[sn - i]) % mod;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define mod 1000000007\n#define DIM 200005\nusing namespace std;\nint n, m, i, k, nr, sol;\nchar s[DIM];\nint d[DIM], sum[DIM];\nint main(){\n    cin>> n >> m;\n    cin>> s + 1;\n    k = n;\n    for(i = 1; i <= n; i++){\n        if(s[i] == s[1]){\n            nr++;\n        }\n        else{\n            if(nr == i - 1){\n                if(nr % 2 == 1){\n                    k = min(k, nr);\n                }\n                else{\n                    k = min(k, nr + 1);\n                }\n            }\n            else{\n                if(nr % 2 == 1){\n                    k = min(k, nr);\n                }\n            }\n        }\n    }\n    sum[1] = d[1] = 1;\n    if(k == n){\n        for(i = 3; i < n; i++){\n            d[i] = sum[i - 2];\n            sum[i] = (d[i] + sum[i - 1]) % mod;\n        }\n        sol = 1;\n        for(i = 1; i < n; i++){\n            sol = (sol + d[n - i] * 1LL * (i + 1) ) % mod;\n        }\n        cout<< sol;\n        return 0;\n    }\n    for(i = 3; i < n; i += 2){\n        d[i] = sum[i - 2];\n        if(i - k - 3 > 0){\n            d[i] -= sum[i - k - 3];\n            if(d[i] < 0){\n                d[i] += mod;\n            }\n        }\n        sum[i] = d[i] + sum[i - 2];\n        if(sum[i] >= mod){\n            sum[i] -= mod;\n        }\n    }\n    for(i = 1; i < min(n, k + 2); i += 2){\n        sol = (sol + d[n - i] * 1LL * (i + 1) ) % mod;\n    }\n    cout<< sol;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct SegT {\nprivate:\n\tint sz; vector<ll> node;\n\tconst ll init_c = 0;\npublic:\n\tSegT(int n) {\n\t\tsz = 1;\n\t\twhile (sz < n)sz *= 2;\n\t\tnode.resize(2 * sz - 1, init_c);\n\t}\n\tll f(ll a, ll b) {\n\t\treturn (a + b)%mod;\n\t}\n\tvoid update(int k, ll a) {\n\t\tk += sz - 1;\n\t\tnode[k] = a;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\tll query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = sz;\n\t\tif (r <= a || b <= l)return init_c;\n\t\telse if (a <= l && r <= b)return node[k];\n\t\telse {\n\t\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn f(vl, vr);\n\t\t}\n\t}\n};\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nll dp[1 << 18][2][2];\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (s[0] == 'B') {\n\t\trep(i, m) {\n\t\t\tif (s[i] == 'B')s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\tvector<int> v;\n\trep(i, m) {\n\t\tint le = i;\n\t\twhile (i + 1 < m&&s[i + 1] == s[i])i++;\n\t\tv.push_back(i - le + 1);\n\t}\n\tif (v.size() == 1) {\n\t\tdp[0][0][0] = 1;\n\t\tdp[0][1][1] = 1;\n\t\trep(i, n - 1) {\n\t\t\trep(j, 2) {\n\t\t\t\t(dp[i + 1][0][j] += dp[i][0][j] + dp[i][1][j]) %= mod;\n\t\t\t\tdp[i + 1][1][j] += dp[i][0][j];\n\t\t\t}\n\t\t}\n\t\tll ans = dp[n - 1][0][0] + dp[n - 1][1][0] + dp[n - 1][0][1];\n\t\tcout << ans % mod << endl; return;\n\t}\n\tif (n % 2) {\n\t\tcout << 0 << endl; return;\n\t}\n\tint d = n / 2;\n\tint x = v[0] / 2 + 1;\n\tfor (int i = 0; i < v.size(); i += 2) {\n\t\tif (i + 1 == v.size())break;\n\t\tif (v[i] % 2) {\n\t\t\tx = min(x, v[i] / 2 + 1);\n\t\t}\n\t}\n\tif (x >= d) {\n\t\tll ans = mod_pow(2, d) - 1;\n\t\tans = ans * 2;\n\t\tans = (ans + mod) % mod;\n\t\tcout << ans << endl;\n\t}\n\telse {\n\t\tSegT dp(d + 1);\n\t\tdp.update(0, 1);\n\t\trep1(i, d - 1) {\n\t\t\tint le = i - x;\n\t\t\tle = max(le, 0);\n\t\t\tll nex = dp.query(le, i);\n\t\t\tdp.update(i, nex);\n\t\t}\n\t\tll ans = 0;\n\t\trep(i, x) {\n\t\t\tll z = dp.query(d - x, d - i); ans += z;\n\t\t\tif (ans >= mod)ans -= mod;\n\t\t}\n\t\tans = ans * 2 % mod;\n\t\tcout << ans << endl;\n\t}\n\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=1000000007;\nint fact[1111111];\nint inv[1111111];\n\nint mpow(int n,int m){\n\tint ret=1;\n\twhile(m){\n\t\tif(m&1)ret=ret*n%mod;\n\t\tn=n*n%mod;\n\t\tm>>=1;\n\t}\n\treturn ret;\n}\n\nint binom(int n,int k){\n\treturn fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\n\ninline void add(int &a,int b){\n\ta+=b;\n\tif(a>=mod)a-=mod;\n}\n\nint N,M;\nstring S;\n\nsigned main(){\n\tfact[0]=1;\n\tfor(int i=1;i<1111111;i++)fact[i]=fact[i-1]*i%mod;\n\tinv[1111111-1]=mpow(fact[1111111],mod-2);\n\tfor(int i=1111111-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n\n\n\tcin>>N>>M;\n\tcin>>S;\n\n\tif(S[0]=='B'){\n\t\trep(i,M){\n\t\t\tif(S[i]=='R')S[i]='B';\n\t\t\telse S[i]='R';\n\t\t}\n\t}\n\n\twhile(S.size()&&S.back()=='R')S.pop_back();\n\n\tif(S.size()==0){\n\t\tint ans=1;\n\t\tfor(int i=1;i*2<=N;i++){\n\t\t\tint n=N-i*2;\n\t\t\tadd(ans,binom(n+i-1,i-1));\n\t\t}\n\t\tcout<<ans<<endl;\n\t\treturn 0;\n\t}\n\n\tif(N%2){\n\t\tcout<<0<<endl;\n\t\treturn 0;\n\t}\n\n\n\tassert(0);\n\n\tint ma=1001001001;\n\tint cur=0;\n\twhile(cur<S.size()){\n\t\tint nex=cur;\n\t\twhile(nex<S.size()&&S[cur]==S[nex])nex++;\n\t\tif(S[cur]=='R'){\n\t\t\tint l=nex-cur;\n\t\t\tif(cur==0){\n\t\t\t\tif(l%2)chmin(ma,l);\n\t\t\t\telse chmin(ma,l+1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(l%2)chmin(ma,l);\n\t\t\t}\n\t\t}\n\t\tcur=nex;\n\t}\n\n\tcout<<ma<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n        if(dp[i-1] < 0)dp[i-1] %= MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    return res;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        return 2;\n        cout << all(n) << endl;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i <= m;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define mod 1000000007\n#define DIM 200005\nusing namespace std;\nint n, m, i, k, nr, sol;\nchar s[DIM];\nint d[DIM], sum[DIM];\nint main(){\n    cin>> n >> m;\n    cin>> s + 1;\n    k = n;\n    for(i = 1; i <= n; i++){\n        if(s[i] == s[1]){\n            nr++;\n        }\n        else{\n            if(nr == i - 1){\n                if(nr % 2 == 1){\n                    k = min(k, nr);\n                }\n                else{\n                    k = min(k, nr + 1);\n                }\n            }\n            else{\n                if(nr % 2 == 1){\n                    k = min(k, nr);\n                }\n            }\n            nr = 0;\n        }\n    }\n    sum[1] = d[1] = 1;\n    if(k == n){\n        for(i = 3; i < n; i++){\n            d[i] = sum[i - 2];\n            sum[i] = (d[i] + sum[i - 1]) % mod;\n        }\n        sol = 1;\n        for(i = 1; i < n; i++){\n            sol = (sol + d[n - i] * 1LL * (i + 1) ) % mod;\n        }\n        cout<< sol;\n        return 0;\n    }\n    for(i = 3; i < n; i += 2){\n        d[i] = sum[i - 2];\n        if(i - k - 3 > 0){\n            d[i] -= sum[i - k - 3];\n            if(d[i] < 0){\n                d[i] += mod;\n            }\n        }\n        sum[i] = d[i] + sum[i - 2];\n        if(sum[i] >= mod){\n            sum[i] -= mod;\n        }\n    }\n    for(i = 1; i < min(n, k + 2); i += 2){\n        sol = (sol + d[n - i] * 1LL * (i + 1) ) % mod;\n    }\n    cout<< sol;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\ntypedef pair<int, int> P;\nconst long long inf = 1ll << 61;\nconst long long mod = 1000000007;\n\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (s[0] == 'B') {\n\t\trep(i, m) {\n\t\t\tif (s[i] == 'R')s[i] = 'B'; else s[i] = 'R';\n\t\t}\n\t}\n\tvector<int>r, b;\n\tchar now = 'R'; int cnt1 = 0;\n\ts.push_back('A');\n\trep(i, m+1) {\n\t\tif (now == s[i])cnt1++;\n\t\telse {\n\t\t\tif (now == 'R')r.push_back(cnt1);\n\t\t\telse b.push_back(cnt1);\n\t\t\tnow = s[i];\n\t\t\tcnt1 = 1;\n\t\t}\n\t}\n\ts.pop_back();\n\n\tif (b.empty()) {//全部一緒\n\t\tvector<int>L(200005);\n\t\tL[0] = 2; L[1] = 1;\n\t\trep(i, 200002)L[i + 2] = (L[i] + L[i + 1]) % mod;\n\t\tcout << L[n] << endl;\n\t\treturn 0;\n\t}\n\n\tif (n & 1) {\n\t\tcout << 0 << endl; return 0;\n\t}\n\telse {\n\t\tassert(0);\n\t\tint MR = r[0];\n\t\tif (MR & 1)MR += 2;\n\t\telse MR += 1;\n\t\tfor (int e : r){\n\t\t\tif (e & 1)MR = min(MR, e);\n\t\t}\n\n\t\tcout << MR << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst ll md = 1e9+7;\n\nvector<ll> calc(int n, int k){\n\tvector<ll> todo(n);\n\ttodo[0] = -1;\n\tif(n > 1) todo[1] = 1;\n\trep(i,0,n){\n\t\tif(i+1 < n) todo[i+1] = (todo[i+1] + 2*todo[i]) % md;\n\t\tif(i + k+1 < n) todo[i+k+1] = (todo[i+k+1] - todo[i]) % md;\n\t\ttodo[i] *= -1;\n\t}\n\treturn todo;\n}\n\nvector<ll> calc1(int n){\n\tvector<ll> todo(n);\n\ttodo[0] = -1;\n\tif(n > 1) todo[1] = 1;\n\tvector<ll> ans(n);\n\trep(i,0,n){\n\t\tif(i+1 < n) todo[i+1] = (todo[i+1] + todo[i]) % md;\n\t\tif(i+2 < n) todo[i+2] = (todo[i+2] + todo[i]) % md;\n\t\ttodo[i] *= -1;\n\t}\n\treturn todo;\n}\n\nll solve(){\n\tint n, m;\n\tstring s;\n\tcin >> n >> m >> s;\n\tif(s[0]=='B') trav(c, s) c = 'B'+'R'-c;\n\tif(count(all(s), 'R') == m){\n\t\tll ans = 1;\n\t\tauto dp = calc1(n-1);\n\t\tfor(int l = 1; l < n; ++l)\n\t\t\tans += (l+1) * dp[n-l-1] % md;\n\t\treturn ans;\n\t} else {\n\t\tif(n%2) return 0;\n\t\tint mx = n-1;\n\t\trep(i,0,m) if(s[i]=='B' && s[i-1]=='R'){\n\t\t\tint j = i;\n\t\t\twhile(j && s[j-1] =='R') --j;\n\t\t\tif(j == 0) mx = min(mx, i + (i%2==0));\n\t\t\telse if((i-j)%2) mx = min(mx, i-j);\n\t\t}\n\t\tauto dp = calc(n/2, (mx+1)/2);\n\t\tll ans = 0;\n\t\tfor(int l = 1; l <= mx; l += 2)\n\t\t\tans += (l+1) * dp[(n-l-1)/2] % md;\n\t\treturn ans;\n\t}\n}\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\n\tll res = solve();\n\tres %= md;\n\tif(res < 0) res += md;\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 1;\n    rdp[0] = 1;\n    for(int i = 1;i <= n+1;i++){\n        dp[i] = (rdp[i-1] - ((i-limit-1)>=0?rdp[i-limit-1]:0)) % MOD;\n        if(dp[i] < 0)dp[i] += MOD;\n        rdp[i] = (rdp[i-1] + dp[i]) % MOD;\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n+10, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2*i) % MOD;\n    }\n    if(res < 0)exit(1);\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    if(str.size() != m)return 1;\n    bool allsame = true;\n    for(int i = 0;i < m;i++)allsame &= (str[i] == str[0]);\n    if(allsame){\n        cout << all(n) << endl;\n        return 0;\n    }\n    for(int i = 0;i < m;i++)vec.push_back(str[i] == str[0]);\n    vec.push_back(0);\n    Int l = 0;\n    while(vec[l] == 1)l++;\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i < vec.size();i++){\n        if(vec[i] == 1)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n#include<bitset>\n#include<cstdlib>\n// #include<deque>\n// #include<multiset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\ntemplate < int n, class... T >\ntypename std::enable_if< (n >= sizeof...(T)) >::type __output_tuple(\n    std::ostream &, std::tuple< T... > const &) {}\ntemplate < int n, class... T >\ntypename std::enable_if< (n < sizeof...(T)) >::type __output_tuple(\n    std::ostream &os, std::tuple< T... > const &t) {\n  os << (n == 0 ? \"\" : \", \") << std::get< n >(t);\n  __output_tuple< n + 1 >(os, t);\n}\ntemplate < class... T >\nstd::ostream &operator<<(std::ostream &os, std::tuple< T... > const &t) {\n  os << \"(\";\n  __output_tuple< 0 >(os, t);\n  os << \")\";\n  return os;\n}\ntemplate < class T, class U >\nstd::ostream &operator<<(std::ostream &os, std::pair< T, U > const &p) {\n  os << \"(\" << p.first << \", \" << p.second << \")\";\n  return os;\n}\ntemplate < class T >\nstd::ostream &operator<<(std::ostream &os, const std::stack< T > &a) {\n  os << \"{\";\n  for(auto tmp = a; tmp.size(); tmp.pop())\n    os << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top();\n  os << \"}\";\n  return os;\n}\ntemplate < class T, class Container, class Compare >\nstd::ostream &operator<<(std::ostream &os,\n    std::priority_queue< T, Container, Compare > a) {\n  os << \"{ (top) \";\n  while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\ntemplate < class T, class Container >\nstd::ostream &operator<<(std::ostream &os, std::queue< T, Container > a) {\n  os << \"{ \";\n  while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop();\n  os << \" }\";\n  return os;\n}\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n// #define DEBUG_OUT std::cerr\n#endif\n#define dump(...)                                                                \\\n  [&]() {                                                                        \\\n    auto __debug_tap = std::make_tuple(__VA_ARGS__);                             \\\n    DEBUG_OUT << \"[\" << __LINE__ << \"] \" << #__VA_ARGS__ << \" = \" << __debug_tap \\\n    << std::endl;                                                      \\\n  }()\ntemplate < class T >\ninline void dump2D(T &d, size_t sizey, size_t sizex) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << \"\\t\";\n    for(size_t j = 0; j < sizex; j++)\n      DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\");\n    DEBUG_OUT << std::endl;\n  }\n}\ntemplate < class T >\ninline void dump1D(T &d, size_t sizey) {\n  for(size_t i = 0; i < sizey; i++) {\n    DEBUG_OUT << d[i] << (i + 1 == sizey ? \"\" : \" \");\n  }\n  DEBUG_OUT << std::endl;\n}\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        os << \"{\";\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \", \") << *ite;\n        os << \"}\";\n        return os;\n      }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\n#define dump1D(...) (42)\ntemplate <\nclass T, class = typename std::iterator_traits< decltype(begin(T())) >::value_type,\n      class = typename std::enable_if< !std::is_same< T, std::string >::value >::type >\n      std::ostream &operator<<(std::ostream &os, const T &a) {\n        for(auto ite = begin(a); ite != end(a); ++ite)\n          os << (ite == begin(a) ? \"\" : \" \") << *ite;\n        return os;\n      }\n#endif\n// }}}\n\n\n/// --- Modulo Integer {{{ ///\n#include <ostream>\ntemplate < long long mod = static_cast< long long >(1e9 + 7) >\nstruct ModuloInteger {\n  static_assert(mod > 0, \"mod must be positive\");\n  static_assert(mod <= 3037000499, \"mod is too big\");\n  using integer = long long;\n  static ModuloInteger unused;\n  // math {{{\n  static inline integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  static inline integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  static inline integer modpow(integer a, long long b) {\n    if(b < 0) b = -b, a = modinv(a);\n    integer r = 1;\n    a %= mod;\n    while(b) {\n      if(b & 1) r = r * a % mod;\n      a = a * a % mod;\n      b >>= 1;\n    }\n    return r;\n  }\n  // }}}\n\n  integer val;\n  constexpr ModuloInteger() : val(0) {}\n  constexpr ModuloInteger(integer t) {\n    val = t % mod;\n    if(val < 0) val += mod;\n  }\n\nprivate:\n  // strict constructor\n  constexpr ModuloInteger(integer t, int) : val(t) {}\n\npublic:\n  template < class T >\n    explicit operator T() {\n      return T(val);\n    }\n  // operator bool() { return bool(val); }\n  // ModuloInteger <arithmetic-operator>[=] ModuloInteger {{{\n  ModuloInteger operator+(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp += rhs;\n    return tmp;\n  }\n  ModuloInteger operator-(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp -= rhs;\n    return tmp;\n  }\n  ModuloInteger operator*(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp *= rhs;\n    return tmp;\n  }\n  ModuloInteger operator/(ModuloInteger const &rhs) const {\n    ModuloInteger tmp = *this;\n    tmp /= rhs;\n    return tmp;\n  }\n  ModuloInteger &operator+=(ModuloInteger const &rhs) {\n    val = val + rhs.val;\n    if(val >= mod) val -= mod;\n    return *this;\n  }\n  ModuloInteger &operator-=(ModuloInteger const &rhs) { return *this += -rhs; }\n  ModuloInteger &operator*=(ModuloInteger const &rhs) {\n    val = val * rhs.val % mod;\n    return *this;\n  }\n  ModuloInteger &operator/=(ModuloInteger const &rhs) { return *this *= rhs.inv(); }\n  // }}}\n  // increment, decrement {{{\n  ModuloInteger operator++(int) {\n    ModuloInteger tmp = *this;\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return tmp;\n  }\n  ModuloInteger operator--(int) {\n    ModuloInteger tmp = *this;\n    val = val == 0 ? mod - 1 : val - 1;\n    return tmp;\n  }\n  ModuloInteger &operator++() {\n    val = val + 1;\n    if(val >= mod) val = 0;\n    return *this;\n  }\n  ModuloInteger &operator--() {\n    val = val == 0 ? mod - 1 : val - 1;\n    return *this;\n  }\n  // }}}\n  ModuloInteger operator-() const { return ModuloInteger(val == 0 ? 0 : mod - val, 0); }\n  // ModuloInteger <arithmetic-operator>[=] T {{{\n  template < typename T >\n    ModuloInteger operator+(T const &rhs) const {\n      return ModuloInteger(val + rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator-(T const &rhs) const {\n      return ModuloInteger(mod + val - rhs % mod);\n    }\n  template < typename T >\n    ModuloInteger operator*(T const &rhs) const {\n      return ModuloInteger(val * (rhs % mod));\n    }\n  template < typename T >\n    ModuloInteger operator/(T const &rhs) const {\n      return ModuloInteger(val * modinv(rhs));\n    }\n  template < typename T >\n    ModuloInteger &operator+=(T const &rhs) {\n      val = (mod + val + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator-=(T const &rhs) {\n      val = (mod + val - rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator*=(T const &rhs) {\n      val = val * (mod + rhs % mod) % mod;\n      return *this;\n    }\n  template < typename T >\n    ModuloInteger &operator/=(T const &rhs) {\n      val = val * modinv(rhs) % mod;\n      return *this;\n    }\n  // }}}\n  ModuloInteger inv() const { return ModuloInteger(modinv(val), 0); }\n  ModuloInteger operator~() const { return inv(); }\n  friend std::ostream &operator<<(std::ostream &os, ModuloInteger const &mv) {\n    os << mv.val;\n    return os;\n  }\n  // equality operator {{{\n  ModuloInteger operator==(const ModuloInteger &a) const { return val == a.val; }\n  ModuloInteger operator!=(const ModuloInteger &a) const { return val != a.val; }\n  ModuloInteger operator==(const integer &a) const { return val == ModuloInteger(a); }\n  ModuloInteger operator!=(const integer &a) const { return val != ModuloInteger(a); }\n  // }}}\n  // T <arithmetic-operator> ModuloInteger {{{\n  friend constexpr ModuloInteger operator+(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod + mv.val);\n  }\n  friend constexpr ModuloInteger operator-(integer a, ModuloInteger const &mv) {\n    return ModuloInteger(a % mod - mv.val);\n  }\n  friend constexpr ModuloInteger operator*(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * mv.val % mod, 0);\n  }\n  friend constexpr ModuloInteger operator/(integer a, ModuloInteger const &mv) {\n    return ModuloInteger((mod + a % mod) * modinv(mv.val) % mod, 0);\n  }\n  // }}}\n  // power {{{\n  ModuloInteger operator^(integer x) const { return pow(*this, x); }\n  ModuloInteger &operator^=(integer x) {\n    val = modpow(val, x);\n    return *this;\n  }\n  friend ModuloInteger pow(ModuloInteger x, integer y) {\n    return ModuloInteger(modpow(x.val, y), 0);\n  }\n  // }}}\n};\ntemplate < long long mod >\nModuloInteger< mod > ModuloInteger< mod >::unused(mod, 0);\n/// }}}--- ///\n\nusing modint = ModuloInteger<>;\n\n\n// LazySegmentTree( size [, initial] )\n// LazySegmentTree( <data> )\n/// --- LazySegmentTree {{{ ///\n#include <cassert>\n#include <initializer_list>\n#include <iostream>\n#include <vector>\ntemplate < class M_act >\nstruct LazySegmentTree {\npublic:\n  using Monoid = typename M_act::Monoid;\n  using X = typename Monoid::T;\n  using M = typename M_act::M;\n\nprivate:\n  size_t n;\n  int h;\n  vector< X > data;\n  vector< M > lazy;\n  vector< size_t > nodeLength;\n  // call before use data[i]\n  void eval(size_t i) {\n    if(lazy[i] == M_act::identity()) return;\n    data[i] = M_act::actInto(lazy[i], nodeLength[i], data[i]);\n    if(i < n) {\n      lazy[i * 2] = M_act::op(lazy[i], lazy[i * 2]);\n      lazy[i * 2 + 1] = M_act::op(lazy[i], lazy[i * 2 + 1]);\n    }\n    lazy[i] = M_act::identity();\n  }\n  // call before use seg[i] = data[i + n]\n  void evalDown(size_t i) {\n    i += n;\n    for(int j = h - 1; j >= 0; j--) eval(i >> j);\n  }\n  // call after touch seg[i] = data[i + n]\n  void propUp(size_t i) {\n    i += n;\n    while(i >>= 1)\n      eval(i * 2), eval(i * 2 + 1), data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n  }\n\npublic:\n  LazySegmentTree() : n(0) {}\n  LazySegmentTree(size_t n, X initial = Monoid::identity()) : n(n) {\n    if(n > 0) {\n      h = 1;\n      while(1u << h < n) h++;\n      data.resize(2 * n, initial);\n      lazy.resize(2 * n, M_act::identity());\n      nodeLength.resize(2 * n, 1);\n      for(size_t i = n - 1; i > 0; i--) // fill from deep\n        data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]),\n          nodeLength[i] = nodeLength[i * 2] + nodeLength[i * 2 + 1];\n    }\n  }\n  template < class InputIter, class = typename iterator_traits< InputIter >::value_type >\n    LazySegmentTree(InputIter first, InputIter last)\n    : LazySegmentTree(distance(first, last)) {\n      if(n > 0) {\n        copy(first, last, begin(data) + n);\n        for(size_t i = n - 1; i > 0; i--) // fill from deep\n          data[i] = Monoid::op(data[i * 2], data[i * 2 + 1]);\n      }\n    }\n  LazySegmentTree(vector< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  LazySegmentTree(initializer_list< X > v) : LazySegmentTree(v.begin(), v.end()) {}\n  void act(int l, int r, const M &m) {\n    if(l < 0) l = 0;\n    if(l >= r) return;\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    int tl = l, tr = r;\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), lazy[l] = m, eval(l), l++;\n      if(r & 1) --r, eval(r), lazy[r] = m, eval(r);\n    }\n    propUp(tl);\n    propUp(tr - 1);\n  }\n  void set(size_t i, const X &x) {\n    assert(i < n);\n    evalDown(i);\n    data[i + n] = x;\n    propUp(i);\n  }\n  X get(size_t i) {\n    assert(i < n);\n    evalDown(i);\n    return data[i + n];\n  }\n  X fold(int l, int r) {\n    if(l < 0) l = 0;\n    if(l >= r) return Monoid::identity();\n    if(r > (int) n) r = n;\n    evalDown(l);\n    evalDown(r - 1);\n    X tmpL = Monoid::identity(), tmpR = Monoid::identity();\n    for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) eval(l), tmpL = Monoid::op(tmpL, data[l]), l++;\n      if(r & 1) --r, eval(r), tmpR = Monoid::op(data[r], tmpR);\n    }\n    return Monoid::op(tmpL, tmpR);\n  }\n  int size() { return n; }\n  inline void dum(int r = -1) {\n#ifdef DEBUG\n    if(r < 0) r = n;\n    DEBUG_OUT << \"{\";\n    for(int i = 0; i < min(r, (int) n); i++) DEBUG_OUT << (i ? \", \" : \"\") << get(i);\n    DEBUG_OUT << \"}\" << endl;\n#endif\n  }\n};\n\n/// }}}--- ///\n\n/// --- Monoid examples {{{ ///\nconstexpr long long inf_monoid = 1e18 + 100;\n#include <algorithm>\nstruct Nothing {\n  using T = char;\n  using Monoid = Nothing;\n  using M = T;\n  static constexpr T op(const T &, const T &) { return T(); }\n  static constexpr T identity() { return T(); }\n  template < class X >\n    static constexpr X actInto(const M &, long long, const X &x) {\n      return x;\n    }\n};\n\ntemplate < class U = long long >\nstruct RangeMin {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::min< T >(a, b); }\n  static constexpr T identity() { return T(inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeMax {\n  using T = U;\n  static T op(const T &a, const T &b) { return std::max< T >(a, b); }\n  static constexpr T identity() { return T(-inf_monoid); }\n};\n\ntemplate < class U = long long >\nstruct RangeSum {\n  using T = U;\n  static T op(const T &a, const T &b) { return a + b; }\n  static constexpr T identity() { return T(0); }\n};\n\ntemplate < class U >\nstruct RangeProd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a * b; }\n  static constexpr T identity() { return T(1); }\n};\n\ntemplate < class U = long long >\nstruct RangeOr {\n  using T = U;\n  static T op(const T &a, const T &b) { return a | b; }\n  static constexpr T identity() { return T(0); }\n};\n\n#include <bitset>\n\ntemplate < class U = long long >\nstruct RangeAnd {\n  using T = U;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return T(-1); }\n};\n\ntemplate < size_t N >\nstruct RangeAnd< std::bitset< N > > {\n  using T = std::bitset< N >;\n  static T op(const T &a, const T &b) { return a & b; }\n  static constexpr T identity() { return std::bitset< N >().set(); }\n};\n\n/// }}}--- ///\n\n/// --- M_act examples {{{ ///\ntemplate < class U = long long, class V = U >\nstruct RangeMinAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMin< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeMax< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long, const X &x) { return m + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMinSet {\n  using M = U;\n  using Monoid = RangeMin< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeMaxSet {\n  using M = U;\n  using Monoid = RangeMax< U >;\n  using X = typename Monoid::T;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long, const X &x) { return m == identity() ? x : m; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumAdd {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &b) { return a + b; }\n  static constexpr M identity() { return 0; }\n  static X actInto(const M &m, long long n, const X &x) { return m * n + x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeSumSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeSum< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return M(-inf_monoid); }\n  static X actInto(const M &m, long long n, const X &x) {\n    return m == identity() ? x : m * n;\n  }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdMul {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M mpow(M a, long long b) {\n    X r(1);\n    while(b) {\n      if(b & 1) r = r * a;\n      a = a * a;\n      b >>= 1;\n    }\n    return r;\n  }\n  static M op(const M &a, const M &b) { return a * b; }\n  static constexpr M identity() { return M(1); }\n  static X actInto(const M &m, long long n, const X &x) { return x * mpow(m, n); }\n};\n\ntemplate < class U, class V = U >\nstruct RangeProdSet {\n  using X = U;\n  using M = V;\n  using Monoid = RangeProd< U >;\n  static M op(const M &a, const M &) { return a; }\n  static constexpr M identity() { return V::unused; }\n  static X actInto(const M &m, long long n, const X &) {\n    if(m == identity()) return;\n    return RangeProdMul< U, V >::mpow(m, n);\n  }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeOr2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeOr< U >;\n  static M op(const M &a, const M &b) { return a | b; }\n  static constexpr M identity() { return M(0); }\n  static X actInto(const M &m, long long, const X &x) { return m | x; }\n};\n\ntemplate < class U = long long, class V = U >\nstruct RangeAnd2 {\n  using X = U;\n  using M = V;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return M(-1); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n\ntemplate < class U, size_t N >\nstruct RangeAnd2< U, std::bitset< N > > {\n  using X = U;\n  using M = std::bitset< N >;\n  using Monoid = RangeAnd< U >;\n  static M op(const M &a, const M &b) { return a & b; }\n  static constexpr M identity() { return std::bitset< N >().set(); }\n  static X actInto(const M &m, long long, const X &x) { return m & x; }\n};\n/// }}}--- ///\n\nusing Seg = LazySegmentTree< RangeSumAdd<modint> >;\n\n\n// NOTE : use H with larger N\n/// --- Modulo Factorial {{{ ///\n#include <cassert>\n#include <cstddef>\ntemplate < std::size_t N, int mod = static_cast< int >(1e9 + 7) >\nstruct Factorial {\n  using integer = long long;\n  constexpr integer extgcd(integer a, integer b, integer &x, integer &y) {\n    integer d = 0;\n    return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n      : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n  }\n  constexpr integer modinv(integer a) {\n    integer x = 0, y = 0;\n    extgcd(a, mod, x, y);\n    if(x < 0)\n      x += mod;\n    else if(x == mod)\n      x = 0;\n    return x;\n  }\n  int arr[N + 1], inv[N + 1];\n  integer operator[](int i) const { return arr[i]; }\n  Factorial() : arr(), inv() {\n    arr[0] = 1;\n    for(std::size_t i = 1; i <= N; i++) {\n      arr[i] = (integer) i * arr[i - 1] % mod;\n    }\n    inv[N] = modinv(arr[N]);\n    for(int i = N - 1; i >= 0; i--) {\n      inv[i] = (integer)(i + 1) * inv[i + 1] % mod;\n    }\n  }\n  integer C(int n, int r) const {\n    if(n < 0 || r < 0 || n < r) return 0;\n    assert(n <= N);\n    return (integer) arr[n] * inv[r] % mod * inv[n - r] % mod;\n  }\n  integer H(int n, int r) const { return C(n + r - 1, r); }\n};\n/// }}}--- ///\n\nconstexpr int mod = 1e9 + 7;\nconst int N = 2e5 + 10;\nFactorial< N * 2, mod > fact;\n\n\n\nint n, m;\nint r, b;\nint rmax;\nstring s;\n\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n >> m;\n  cin >> s;\n  if(s[0] == 'B') for(auto &e : s) e = e == 'R' ? 'B' : 'R';\n  bool allR = 1;\n  for(auto e : s) allR &= e == 'R';\n\n  if(allR) {\n    dump(\"allR\");\n    modint ans;\n    assert(0);\n    for(int B = 0; B <= n; B++) {\n      int R = n - B - B;\n      ans += modint(fact.C(R + B, R));\n      ans += modint(fact.C(R + B - 1, R));\n    }\n    cout << ans << endl;\n    return 0;\n  }\n\n  if(n % 2 == 1) {\n    cout << 0 << endl;\n    dump(\"odd\");\n    return 0;\n  }\n\n  int c = m;\n  bool first = 1;\n  for(int i = 0; i <= m; i++) {\n    if(i == n || s[i] == 'B') {\n      if(c) {\n        if(c % 2 == 0 && first) rmax = min(rmax, c + 1);\n        if(c % 2 == 1) rmax = min(rmax, c);\n      }\n      c = 0;\n      first = 0;\n    } else c++;\n  }\n\n  dump(rmax);\n\n  // RB\n\n  // vector<modint> dp(n + 1);\n  Seg dp(n + 1);\n  dp.set(0, 1);\n\n  modint ans;\n\n  for(int i = 0; i <= n - 1; i+=2) {\n    dp.act(i + 2, min<int>(n - 1, i + 1 + rmax) + 1, dp.get(i));\n    if(i + 1 + rmax >= n) {\n      int f = n - i - 1;\n      if (f >= 1) {\n        dump(i, dp.get(i), f);\n        ans += dp.get(i) * (f + 1);\n      }\n    }\n  }\n  cout << ans << endl;\n  dp.dum();\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=2e5+10,mod=1e9+7;\ninline void Dec(int &x,int y) { x-=y; if(x<0) x+=mod; }\ninline void Add(int &x,int y) { x+=y; if(x>=mod) x-=mod; }\nchar S[N];\nint n,m,f[N];\nint main() {\n\trd(n),rd(m);\n\tscanf(\"%s\",S+1);\n\tchar c=S[1];\n\tint p=1,r,flg=0,L=m;\n\tdo {\n\t\tr=p;\n\t\twhile(r<=m&&S[r]==c) r++;\n\t\tif(r<m) flg=1;\n\t\tL=min(L,(r-p)|1);\n\t\tp=r;\n\t\twhile(p<=m&&S[p]!=c) p++;\n\t} while(p<=m);\n\t\n\tif(!flg) {\n\t\tif(n==2) { printf(\"3\\n\"); return 0; }\n\t\tf[0]=1,f[1]=2;\n\t\tfor(int i=2;i<=n;++i) f[i]=(f[i-1]+f[i-2])%mod;\n\t\tprintf(\"%d\\n\",(f[n-3]+f[n-1])%mod);\n\t\treturn 0;\n\t}\n\t\n\tint sum[2]={0,0};\n\tf[1]=1,sum[1]=1;\n\tfor(int i=2;i<=n;++i) {\n\t\tf[i]=sum[i&1];\n\t\tif(i-L-1>=1) Dec(sum[i&1],f[i-L-1]);\n\t\tAdd(sum[i&1],f[i]);\n\t}\n\tint ans=0;\n\tfor(int i=2;i<=n;++i) {\n\t\tif(n-i>L||!((n-i)&1)) continue;\n\t\tAdd(ans,f[i]*(ll)(n-i+1)%mod);\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int MAXN=200010, LOG=20;\n\nint n, m, k, u, v, x, y, t, a, b, ans;\nint A[MAXN];\nint dp[MAXN];\nstring S;\n\ninline void fix(int &x){\n\tif (x>=mod) x-=mod;\n\tif (x<0) x+=mod;\n}\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tcin>>n>>m>>S;\n\tfor (int i=0; i<m; i++) if (S[i]=='R') S[i]='A'; // :(\n\tif (S[0]=='B'){\n\t\tfor (int i=0; i<m; i++) S[i]='A'+'B'-S[i];\n\t}\n\twhile (S.size()>1 && S.back()=='A') S.pop_back();\n\tm=S.size();\n//\tdebug(S)\n\tif (m==1){\n\t\tdp[1]=1;\n\t\tfor (int i=3; i<=n; i++){\n\t\t\tfix(dp[i]=dp[i-1]+dp[i-2]);\n\t\t}\n\t\tans=n+1;\n\t\tfor (int i=3; i<n; i++) ans=(ans + (n-i+1ll)*dp[i])%mod;\n\t\tfix(ans);\n\t\tcout<<ans<<\"\\n\";\n\t\t\n\t\treturn 0;\n\t}\n\tif (n&1) kill(0)\n\tfor (int i=0, j=0; i<m; i=j){\n\t\tif (S[i]=='B') j++;\n\t\telse{\n\t\t\twhile (S[j]=='A' && j<m) j++;\n\t\t\tif (!i || (j-i)&1) k=max(k, j-i);\n\t\t}\n\t}\n\tk>>=1;\n\tn>>=1;\n//\tdebug2(n, k)\n\tdp[0]=1;\n\tdp[1]=1+(k>=1);\n\tfor (int i=2; i<=n; i++){\n\t\tfix(dp[i]=2*dp[i-1]-(k>=i-1)+(k>=i));\n\t\tif (i>=k+2) fix(dp[i]-=dp[i-k-2]);\n\t}\n//\tdebug(dp[1])\n//\tdebug(dp[2])\n//\tdebug(dp[3])\n\t\n\tfor (int i=0; i+2<=n; i++) if (n-i-2<=k) ans=(ans + (n-i-1ll)*dp[i])%mod;\n\tif (n-1<=k) fix(ans+=dp[n-1]);\n\tfix(ans*=2);\n\tfix(ans);\n\tcout<<ans<<\"\\n\";\n\t\n\treturn 0;\n}\n/*\n12 5\nAAAAB\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define int long long\ntypedef pair<int, int> P;\nconst long long inf = 1ll << 61;\nconst long long mod = 1000000007;\n\nsigned main() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (s[0] == 'B') {\n\t\trep(i, m) {\n\t\t\tif (s[i] == 'R')s[i] = 'B'; else s[i] = 'R';\n\t\t}\n\t}\n\tvector<int>r, b;\n\tchar now = 'R'; int cnt1 = 0;\n\ts.push_back('A');\n\trep(i, m) {\n\t\tif (now == s[i])cnt1++;\n\t\telse {\n\t\t\tif (now == 'R')r.push_back(cnt1);\n\t\t\telse b.push_back(cnt1);\n\t\t\tnow = s[i];\n\t\t\tcnt1 = 1;\n\t\t}\n\t}\n\ts.pop_back();\n\n\tif (b.empty()) {//全部一緒\n\t\tvector<int>L(200005);\n\t\tL[0] = 2; L[1] = 1;\n\t\trep(i, 200002)L[i + 2] = (L[i] + L[i + 1]) % mod;\n\t\tcout << L[n] << endl;\n\t\treturn 0;\n\t}\n\n\tif (n & 1) {\n\t\tcout << 0 << endl; return 0;\n\t}\n\telse {\n\t\tassert(0);\n\t\tint MR = r[0];\n\t\tif (MR & 1)MR += 2;\n\t\telse MR += 1;\n\t\tfor (int e : r){\n\t\t\tif (e & 1)MR = min(MR, e);\n\t\t}\n\n\t\tcout << MR << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1, typename T2>\ninline bool cmn (T1& a, T2 b) {\n  if (a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\ntemplate<typename T1, typename T2>\ninline bool cmx (T1& a, T2 b) {\n  if (a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n}\nconstexpr int md = 1e9 + 7;\ninline void mad(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\ninline void msb(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\ninline int mul(int a, int b) {\n  return (int)((long long)a * b % md);\n}\ntemplate<typename T>\nclass run_length_encoding {\n  vector<pair<int, T>> rle;\n  public:\n    run_length_encoding(\n        vector<T> input\n      ) :\n      rle()\n      {\n        int cnt = 0;\n        for (auto it = input.begin(); it != input.end(); it++) {\n          auto jt = next(it); cnt++;\n          if (jt == input.end() || *it != *jt) {\n            rle.emplace_back(cnt, *it);\n            cnt = 0;\n          }\n        }\n      }\n    auto const& code () const {return rle;}\n};\nint main() {\n  int n, m; string s;\n  cin >> n >> m >> s;\n  vector<int> a(m);\n  for (int i = 0; i < m; i++) a[i] = s[0] == s[i];\n  auto rle = run_length_encoding<int>(a).code();\n  if (rle.size()  == 1) {\n    vector<int> dp(n + 1, 0);\n    dp[1] = 1;\n    for (int i = 2; i <= n; i++) {\n      mad(dp[i], dp[i - 1]);\n      mad(dp[i], dp[i - 2]);\n    }\n    for (int i = n; i >= 1; i--) msb(dp[i], dp[i - 1]);\n    int ret = 1;\n    for (int i = 1; i < n; i++) {\n      mad(ret, mul(i + 1, dp[n - i]));\n    }\n    cout << ret << endl;\n    return 0;\n  }\n  if (n & 1) {\n    cout << 0 << endl;\n    return 0;\n  }\n  n >>= 1;\n  int k = n;\n  for (auto it = rle.begin(); it < rle.end() - 1; it += 2) {\n    int m = it->first;\n    if (m & 1) cmn(k, (m + 1) >> 1);\n    else if (it == rle.begin()) cmn(k, (m + 2) >> 1);\n  }\n  vector<int> dp(n + 1, 0);\n  dp[1] = 1;\n  for (int i = 2; i <= n; i++) {\n    mad(dp[i], dp[i - 1]);\n    mad(dp[i], dp[i - 1]);\n    if (i - k - 1 >= 0) msb(dp[i], dp[i - k - 1]);\n  }\n  for (int i = n; i >= 1; i--) msb(dp[i], dp[i - 1]);\n  int ret = 0;\n  for (int i = 0; i < k; i++) {\n    mad(ret, mul(i + 1, dp[n - i]));\n  }\n  mad(ret, ret);\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//第8回シンデレラガール総選挙は是非本田未央ちゃんに投票をお願いします！\n//ファンのことも他のアイドルの子たちのことも本当に大事にしてて、今まで周りに色んなものを与えてくれました。\n//今度は私たちが未央ちゃんにお返しをする番です。みんなでガラスの靴を履かせてあげましょう！\n// #本田未央を一番星に #本田未央を令和のシンデレラガールに #第8回シンデレラガール総選挙\n#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nlint mo=1000000007;\ntemplate <class typ> struct BIT{\n\tvector<typ> x;\n\tBIT(int n):x(n,0){}\n\ttyp sum(int a,int b){\n\t\tif(a>b) return 0;\n\t\tif(a==0){\n\t\t\ttyp s=0;\n\t\t\tfor(int i=b;i>=0;i=(i&(i+1))-1){\n\t\t\t\ts+=x[i];s%=mo;\n\t\t\t}\n\t\t\treturn s;\n\t\t}\n\t\telse return sum(0,b)-sum(0,a-1);\n\t}\n\tvoid add(int ind,typ f){\n\t\tfor(int i=ind;i<x.size();i|=i+1){\n\t\t\tx[i]+=f;x[i]%=mo;\n\t\t}\n\t}\n};\nvector<int> le;\nlint dp[200100][2][2];\nint main()\n{\n\tint n,m,now=0;string s;\n\tcin>>n>>m;\n\tcin>>s;s+='X';\n\trep(i,m){\n\t\tnow++;\n\t\tif(s[i]!=s[i+1]){\n\t\t\tle.pb(now);now=0;\n\t\t}\n\t}\n\tif(le.size()==1){\n\t\tmemset(dp,0,sizeof(dp));\n\t\tdp[1][0][0]=dp[1][1][1]=1;\n\t\tREP(i,1,n) rep(j,2){\n\t\t\tdp[i+1][0][j]+=dp[i][0][j]+dp[i][1][j];\n\t\t\tdp[i+1][1][j]+=dp[i][0][j];\n\t\t\tdp[i+1][0][j]%=mo;\n\t\t\tdp[i+1][1][j]%=mo;\n\t\t}\n\t\tcout<<(dp[n][0][0]+dp[n][0][1]+dp[n][1][0])%mo<<endl;\n\t\treturn 0;\n\t}\n\tif(n%2>0){\n\t\tcout<<0<<endl;return 0;\n\t}\n\tint ma=le[0]/2+1;\n\tfor(int i=0;i<(int)le.size();i+=2){\n\t\tif(le[i]%2>0) ma=min(ma,le[i]/2+1);\n\t}\n\t//cout<<ma<<endl;\n\tBIT<lint> bit(n/2+10);\n\tbit.add(0,1);\n\tREP(i,1,n/2){\n\t\t//cout<<i<<' '<<bit.sum(max(0,i-ma),i-1)<<endl;\n\t\tbit.add(i,bit.sum(max(0,i-ma),i-1));\n\t}\n\tlint out=0;\n\tREP(i,1,min(n/2,ma)+1){\n\t\t//cout<<i<<endl;\n\t\tout+=bit.sum(n/2-i,n/2-i)*i*2;out%=mo;\n\t}\n\tcout<<out<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n/*\n0-index\nfunctionの中を書いて使う\n宣言の時に単位元を書く\n*/\ntemplate<typename T>\nstruct segtree{\n\tint n;\n\tvector<T> dat;\n\tT ZERO;\n\tfunction<T(T,T)> func;\n\tsegtree(int n_, function<T(T,T)> func_, T zero):func(func_), ZERO(zero){\n\t  n = 1;\n\t  while(n < n_)n*=2;\n\t  dat.resize(2*n);\n\t  for(int i = 0;i < 2*n;i++)dat[i] = ZERO;\n\t}\n\tvoid update(int k, T a){\n\t  k += n - 1;dat[k] = a;\n\t  while(k > 0){\n\t\tk = (k-1)/2;\n\t\tdat[k] = func(dat[k*2+1],dat[k*2+2]);\n\t  }\n\t}\n\n\tvoid set(int k, T a) {\n\t\tk += n - 1;dat[k] = a;\n\t}\n\n\tvoid build(){\n\t\tfor(int i = n - 2;i >= 0;i--){\n\t\t\tdat[i] = func(dat[2 * i + 1], dat[2 * i + 2]);\n\t\t}\n\t}\n\n\tT get(int k){return dat[k+n-1];}\n\n\tT que(int a,int b){\n\t\tT L = ZERO,R = ZERO;\n\t\tint A = a + n - 1;\n\t\tint B = b + n - 1;\n\t\twhile(A < B){\n\t\t\tif((A & 1) == 0)L = func(L,dat[A++]);\n            if((B & 1) == 0)R = func(dat[--B],R);\n            A = A >> 1;\n            B = B >> 1;\n\t\t}\n\t\treturn func(L,R);\n\t}\n};\n\n\nint getmin(string str){\n\tchar c = str[0];\n\tbool isFirst = true;\n\tint cou = 0;\n\tint ret = INF;\n\tREP(i, str.size()){\n\t\tif(str[i] == c)cou++;\n\t\telse {\n\t\t\tif(isFirst && cou % 2 == 0)cou++;\n\t\t\tif(cou % 2)ret = min(ret, cou);\n\t\t\tisFirst = false;\n\t\t\tcou = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nll n, m, k, ans;\nstring str;\n\nbool oneKind(string str){\n\tREP(i, str.size())if(str[0] != str[i])return false;\n\treturn true;\n}\n\nvoid solveA(){\n\tll ans = 0;\n\tsegtree<ll> seg(n, [](ll a, ll b){return (a + b) % MOD;}, 0);\n\tseg.update(0, 1);\n\n\tfor(ll i = 2;i < n;i++){\n\t\tll l = max(0LL, i - k - 1);\n\t\tll r = i - 1;\n\t\tseg.update(i, seg.que(l, r));\n\t}\n\tREP(i, n-1){\n\t\tif(n - (i + 1) <= k){\n\t\t\t//cout << \"pass \" << seg.get(i) * (n - i) % MOD << endl;\n\t\t\tans = (ans + seg.get(i) * (n - i) % MOD) % MOD;\n\t\t}\n\t}\n\tans = (ans + 1) % MOD;\n\tcout << ans << endl;\n}\n\nvoid solveB(){\n\tll ans = 0;\n\tsegtree<ll> seg(n, [](ll a, ll b){return (a + b) % MOD;}, 0);\n\tseg.update(0, 1);\n\n\tfor(ll i = 2;i < n;i++){\n\t\tif(i % 2)continue;\n\t\tll l = max(0LL, i - k - 1);\n\t\tll r = i - 1;\n\t\tseg.update(i, seg.que(l, r));\n\t}\n\n\t//REP(i, n)cout << seg.get(i) << \" \";cout << endl;\n\tREP(i, n-1){\n\t\tif(n - (i + 1) <= k && ((n - (i + 1)) % 2)){\n\t\t\t//cout << \"pass \" << seg.get(i) * (n - i) % MOD << endl;\n\t\t\tans = (ans + seg.get(i) * (n - i) % MOD) % MOD;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n\tcin >> n >> m >> str;\n\tk = getmin(str);\n\n\n\tif(oneKind(str)){\n\t\tsolveA();\n\t}\n\telse {\n\t\tsolveB();\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n,m;\nchar str[200050];\nconst int mod = 1000000007;\nint dp[200050];\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str + 1);\n\tbool c1 = 0,c2 = 0;\n\tfor(int i = 1;i <= m; ++ i)\n\t{\n\t\tc1 |= str[i] == 'R';\n\t\tc2 |= str[i] == 'B';\n\t}\n\tint p = 1;\n\tint lim;\n\tif(c1 && c2)\n\t{\n\t\tif(n & 1)\n\t\t{\n\t\t\tprintf(\"0\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tfor(;str[p + 1] == str[1]; ++ p);\n\t\tlim = p + (p % 2 == 0);\n\t\tint len = 0;\n\t\tfor(int i = p + 1;i <= m; ++ i)\n\t\t{\n\t\t\tif(str[i] != str[1]) lim = min(lim,len % 2 ? len : 10000000),len = 0;\n\t\t\telse len ++;\n\t\t}\n\t\tlim ++;\n\t\tlim /= 2;\n\t\tlim = min(lim,n / 2);\n\t\tint pre = 1;\n\t\tint cur = 0;\n\t\tdp[0] = 1;\n\t\tlong long ans = 0;\n\t\tfor(int i = 0;i <= n / 2; ++ i)\n\t\t{\n\t\t\tif(i)\n\t\t\t{\n\t\t\t\twhile(i - cur > lim) pre -= dp[cur],pre = (pre + mod) % mod,cur ++;\n\t\t\t\tdp[i] = pre;\n\t\t\t\tpre += dp[i];\n\t\t\t\tpre %= mod;\n\t\t\t}\n\t\t\tif(n - i * 2 > 0 && (n - i * 2) / 2 <= lim)\n\t\t\t\tans = ans + (n - i * 2) * dp[i] % mod,ans %= mod;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\telse\n\t{\n\t\tint pre = 1;\n\t\tint cur = 0;\n\t\tdp[0] = 1;\n\t\tlong long ans = 0;\n\t\tfor(int i = 0;i <= n; ++ i)\n\t\t{\n\t\t\tif(i > 0)\n\t\t\t{\n\t\t\t\tdp[i] = pre;\n\t\t\t\tpre += dp[i - 1];\n\t\t\t\tpre %= mod;\n\t\t\t}\n\t\t\tif(n - i > 1)\n\t\t\t\tans = ans + (n - i) * dp[i] % mod,ans %= mod;\n\t\t}\n\t\tprintf(\"%lld\\n\",(ans + 1) % mod);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\nusing dd = double;\nusing vdd = std::vector<dd>;\nusing vvdd = std::vector<vdd>;\nusing vvvdd = std::vector<vvdd>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, N-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, N-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S, ll E){ T s=v[S]; REPS(i, S+1, E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = (ll)(1e9 + 7);// 998244353LL;//(ll)(1e9 + 7);\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\n\nll N, M;\nstring S;\n\nvoid solveB(){\n\tmll ans = 0;\n\n\t//先頭がRの時\n\t{\n\t\tvvmll dp(N, vmll(2));\n\t\tdp[0][0] = 1;\n\t\tdp[0][1] = 0;\n\n\t\tREPS(i, 1, N-1){\n\t\t\tdp[i][0] = dp[i-1][0] + dp[i-1][1];\n\t\t\tdp[i][1] = dp[i-1][0];\n\t\t}\n\t\tans += dp[N-1][0] + dp[N-1][1];\n\t}\n\n\t//先頭がBの時\n\t{\n\t\tvvmll dp(N, vmll(2));\n\t\tdp[0][0] = 0;\n\t\tdp[0][1] = 1;\n\n\t\tREPS(i, 1, N-2){\n\t\t\tdp[i][0] = dp[i-1][0] + dp[i-1][1];\n\t\t\tdp[i][1] = dp[i-1][0];\n\t\t}\n\t\tans += dp[N-2][0] + dp[N-2][1];\n\t}\n\tcout << ans << '\\n';\n}\n\n\nvoid solve()\n{\n\tcin >> N >> M >> S;\n\n\tif (S[0] == 'B'){\n\t\tEACH(c, S){\n\t\t\tif (c == 'B') c = 'R';\n\t\t\telse          c = 'B';\n\t\t}\n\t}\n\n\tll renzoku = 0;\n\tll firstRenzoku = INF; //1回目は偶数も考慮必要\n\tll minOddRenzoku = INF; //2回目以降は偶数は無視\n\tEACH(c, S){\n\t\tif (c == 'R') renzoku++;\n\t\telse if (firstRenzoku == INF){\n\t\t\tfirstRenzoku = renzoku;\n\t\t\trenzoku = 0;\n\t\t}\n\t\telse{\n\t\t\tif (renzoku%2 == 1){\n\t\t\t\tchmin(minOddRenzoku, renzoku);\n\t\t\t}\n\t\t\trenzoku = 0;\n\t\t}\n\t}\n\n\tif (firstRenzoku == INF){\n\t\tsolveB();\n\t\treturn;\n\t}\n\n\t/////\n\n\tif (N%2 == 1){bye(0);}\n\n\tll n = std::min(firstRenzoku/2, minOddRenzoku/2);\n\tif (n == 0){ bye(2); }\n\n\tvmll dp(N/2+1);\n\tvmll sum(N/2+1);\n\n\tdp[1] = 2;\n\tsum[1] = 2;\n\n\tREPS(i, 2, N/2){\n\t\t//dpの計算\n\t\tdp[i] = sum[i-1];\n\t\tif (i <= n+1){ dp[i] += 2*i; }\n\n\t\t//sumの計算\n\t\tif (i <= n+1){sum[i] = sum[i-1] + dp[i];}\n\t\telse         {sum[i] = sum[i-1] + dp[i] - dp[i-n-1];}\n\n\t}\n\tcout << dp[N/2] << '\\n';\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing ll = long long;\nusing vll = std::vector<ll>;\nusing vvll = std::vector<vll>;\nusing vvvll = std::vector<vvll>;\nusing dd = double;\nusing vdd = std::vector<dd>;\nusing vvdd = std::vector<vdd>;\nusing vvvdd = std::vector<vvdd>;\n\nconstexpr ll INF = 1LL << 60;\nconstexpr dd EPS = 1e-11;\n\n//cin,cout高速化のおまじない＋桁数指定\nstruct Fast{\n\tFast(){\n\t\tcin.tie(0);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(std::numeric_limits<double>::max_digits10);\n\t}\n} fast;\n\n#define REPS(i, S, E) for (ll i = (S); i <= (E); i++)\n#define REP(i, N) REPS(i, 0, N-1)\n#define DEPS(i, S, E) for (ll i = (E); i >= (S); i--)\n#define DEP(i, N) DEPS(i, 0, N-1)\n#define EACH(e, v) for (auto&& e : v)\n\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true; }return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true; }return false; }\ntemplate<class T> inline T MaxE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmax(m,v[i]); return m;}//v[S]～v[E]の最大値\ntemplate<class T> inline T MinE(vector<T>&v,ll S,ll E){T m=v[S]; REPS(i,S,E)chmin(m,v[i]); return m;}//v[S]～v[E]の最小値\ntemplate<class T> inline T MaxE(vector<T> &v, ll N) { return MaxE(v, 0, N - 1); } //先頭N個中の最大値\ntemplate<class T> inline T MinE(vector<T> &v, ll N) { return MinE(v, 0, N - 1); }\ntemplate<class T> inline T MaxE(vector<T> &v) { return MaxE(v, (ll)v.size()); }\ntemplate<class T> inline T MinE(vector<T> &v) { return MinE(v, (ll)v.size()); }\ntemplate<class T> inline ll MaxI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]>v[m])m=i;} return m;}\ntemplate<class T> inline ll MinI(vector<T>&v,ll S,ll E){ll m=S; REPS(i,S,E){if(v[i]<v[m])m=i;} return m;}\ntemplate<class T> inline ll MaxI(vector<T> &v, ll N) { return MaxI(v, 0, N - 1); }\ntemplate<class T> inline ll MinI(vector<T> &v, ll N) { return MinI(v, 0, N - 1); }\ntemplate<class T> inline ll MaxI(vector<T> &v) { return MaxI(v, (ll)v.size()); }\ntemplate<class T> inline ll MinI(vector<T> &v) { return MinI(v, (ll)v.size()); }\ntemplate<class T> inline T Sum(vector<T> &v, ll S, ll E){ T s=v[S]; REPS(i, S+1, E)s+=v[i]; return s; }\ntemplate<class T> inline T Sum(vector<T> &v, ll N) { return Sum(v, 0, N - 1); }\ntemplate<class T> inline T Sum(vector<T> &v) { return Sum(v, v.size()); }\ntemplate<class T> inline T POW(T a, ll n){ T r=1; for (; n>0; n>>=1, a*=a){ if (n&1)r*=a; } return r; }\ninline ll POW(int a, ll n){ return POW((ll)a, n); }\ninline ll MSB(ll a){for(ll o=63,x=-1;;){ll m=(o+x)/2; if(a<(1LL<<m))o=m; else x=m; if(o-x==1)return x;}}\ninline ll CEIL(ll a, ll b){ return (a+b-1)/b; }\n\ntemplate<class T=ll> inline vector<T> cinv(ll N){ vector<T> v(N); REP(i, N)cin>>v[i]; return move(v);}\ntemplate<class T=ll, class S=ll> inline vector<pair<T, S>> cinv2(ll N){\n\tvector<pair<T, S>> v(N); REP(i,N){cin>>v[i].first>>v[i].second;} return move(v); }\ntemplate<class T=ll,class S=ll,class R=ll> inline vector<tuple<T, S, R>> cinv3(ll N){\n\tvector<tuple<T,S,R>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i]);} return move(v);}\ntemplate<class T=ll,class S=ll,class R=ll,class Q=ll> inline vector<tuple<T,S,R,Q>> cinv4(ll N){\n\tvector<tuple<T,S,R,Q>> v(N); REP(i,N){cin>>get<0>(v[i])>>get<1>(v[i])>>get<2>(v[i])>>get<3>(v[i]);} return move(v);}\ntemplate<class T> inline void coutv(vector<T> &v, char deli=' '){\n\tll N=(ll)v.size(); REP(i,N){cout << v[i] << ((i==N-1)?'\\n':deli);} }\ntemplate<class T> void bye(T a){cout << a << '\\n'; exit(0);}\n\n\nstruct mll{\n\tstatic ll MOD;\n\tll val;\n\tmll(ll v = 0): val(v % MOD){ if (val < 0) val += MOD; }\n\tmll operator - () const { return -val; }\n\tmll operator + (const mll &b) const { return val + b.val; }\n\tmll operator - (const mll &b) const { return val - b.val; }\n\tmll operator * (const mll &b) const { return val * b.val; }\n\tmll operator / (const mll &b) const { return mll(*this) /= b; }\n\tmll operator + (ll b) const { return *this + mll(b); }\n\tmll operator - (ll b) const { return *this - mll(b); }\n\tmll operator * (ll b) const { return *this * mll(b); }\n\tfriend mll operator + (ll a, const mll &b) { return b + a; }\n\tfriend mll operator - (ll a, const mll &b) { return -b + a; }\n\tfriend mll operator * (ll a, const mll &b) { return b * a; }\n\tmll &operator += (const mll &b) { val=(val+b.val)%MOD; return *this; }\n\tmll &operator -= (const mll &b) { val=(val+MOD-b.val)%MOD; return *this; }\n\tmll &operator *= (const mll &b) { val=(val*b.val)%MOD; return *this; }\n\tmll &operator /= (const mll &b) {\n\t\tll c=b.val, d=MOD, u=1, v=0;\n\t\twhile (d){\n\t\t\tll t = c / d;\n\t\t\tc -= t * d; swap(c, d);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tval = val * u % MOD;\n\t\tif (val < 0) val += MOD;\n\t\treturn *this;\n\t}\n\tmll &operator += (ll b) { return *this += mll(b); }\n\tmll &operator -= (ll b) { return *this -= mll(b); }\n\tmll &operator *= (ll b) { return *this *= mll(b); }\n\tmll &operator /= (ll b) { return *this /= mll(b); }\n\tbool operator == (const mll &b) { return val == b.val; }\n\tbool operator != (const mll &b) { return val != b.val; }\n\tbool operator == (ll b) { return *this == mll(b); }\n\tbool operator != (ll b) { return *this != mll(b); }\n\tfriend bool operator == (ll a, const mll &b) { return mll(a) == b.val; }\n\tfriend bool operator != (ll a, const mll &b) { return mll(a) != b.val; }\n\tfriend ostream &operator << (ostream &os, const mll &a) { return os << a.val; }\n\tfriend istream &operator >> (istream &is, mll &a) { return is >> a.val; }\n\tstatic mll Combination(ll a, ll b){\n\t\tchmin(b, a-b);\n\t\tif (b<0) return mll(0);\n\t\tmll c = 1;\n\t\tREP(i, b) c *= a-i;\n\t\tREP(i, b) c /= i+1;\n\t\treturn c;\n\t}\n};\nll mll::MOD = (ll)(1e9 + 7);// 998244353LL;//(ll)(1e9 + 7);\nusing vmll = std::vector<mll>;\nusing vvmll = std::vector<vmll>;\nusing vvvmll = std::vector<vvmll>;\nusing vvvvmll = std::vector<vvvmll>;\n\nll N, M;\nstring S;\n\nvoid solveB(){\n\tmll ans = 0;\n\n\t//先頭がRの時\n\t{\n\t\tvvmll dp(N, vmll(2));\n\t\tdp[0][0] = 1;\n\t\tdp[0][1] = 0;\n\n\t\tREPS(i, 1, N-1){\n\t\t\tdp[i][0] = dp[i-1][0] + dp[i-1][1];\n\t\t\tdp[i][1] = dp[i-1][0];\n\t\t}\n\t\tans += dp[N-1][0] + dp[N-1][1];\n\t}\n\n\t//先頭がBの時\n\t{\n\t\tvvmll dp(N, vmll(2));\n\t\tdp[0][0] = 0;\n\t\tdp[0][1] = 1;\n\n\t\tREPS(i, 1, N-2){\n\t\t\tdp[i][0] = dp[i-1][0] + dp[i-1][1];\n\t\t\tdp[i][1] = dp[i-1][0];\n\t\t}\n\t\tans += dp[N-2][0] + dp[N-2][1];\n\t}\n\tcout << ans << '\\n';\n}\n\n\nvoid solve()\n{\n\tcin >> N >> M >> S;\n\n\tif (S[0] == 'B'){\n\t\tEACH(c, S){\n\t\t\tif (c == 'B') c = 'R';\n\t\t\telse          c = 'B';\n\t\t}\n\t}\n\n\tll renzoku = 0;\n\tll maxRenzoku = 0;\n\tEACH(c, S){\n\t\tif (c == 'R') renzoku++;\n\t\telse{\n\t\t\tchmax(maxRenzoku, renzoku);\n\t\t\trenzoku=0;\n\t\t}\n\t}\n\n\tif (maxRenzoku == 0){\n\t\tsolveB();\n\t\treturn;\n\t}\n\n\t/////\n\n\tif (N%2 == 1){bye(0);}\n\n\tll n = maxRenzoku/2;\n\tif (n == 0){ bye(2); }\n\n\tvmll dp(N/2);\n\tvmll sum(N/2);\n\n\tdp[1] = 2;\n\tsum[1] = 2;\n\n\tREPS(i, 2, N/2-1){\n#if 0\n\t\t//sumの計算\n\t\tif (i-1 <= n+1){sum[i-1] = sum[i-2] + dp[i-1];}\n\t\telse           {sum[i-1] = sum[i-2] + dp[i-1] - dp[i-n-2];}\n#endif\n\n\t\t//dpの計算\n\t\tdp[i] = sum[i-1];\n\t\tif (i <= n+1){ dp[i] += 2*i; }\n\n\t\t//sumの計算\n\t\tif (i <= n+1){sum[i] = sum[i-1] + dp[i];}\n\t\telse         {sum[i] = sum[i-1] + dp[i] - dp[i-n-1];}\n\n\t}\n\tcout << sum[N/2-1] << '\\n';\n}\n\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e5+10,inf=0x3f3f3f3f,mod=1e9+7;\nchar s[maxn];\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\ty>>=1;\n\t\tx=(ll)x*x%mod;\n\t}\n\treturn res;\n}\nint dp[maxn],sum[maxn];\nint main(){\n\tint n=read(),m=read();\n\tscanf(\"%s\",s+1);\n\tint Min=inf;\n\tfor(int i=1,j;i<=m;i++) if(s[i]==s[1]){\n\t\tj=i;\n\t\twhile(j<m && s[j+1]==s[1]) ++j;\n\t\tif((j-i+1)%2==1) chkmin(Min,j-i+1);\n\t\telse if(i==1) chkmin(Min,j-i+2);\n\t\ti=j;\n\t}\n\tint flag=1;\n\tREP(i,2,n) flag&=(s[i]==s[1]);\n\tdp[1]=sum[1]=1;\n\tREP(i,2,n+1){\n\t\tif(flag){\n\t\t\tdp[i]=sum[i-2];\n\t\t\tsum[i]=(sum[i-1]+dp[i])%mod;\n\t\t}\n\t\telse{\n\t\t\tdp[i]=(sum[i-2]-sum[max(i-Min-3,0)]+mod)%mod;\n\t\t\tsum[i]=(sum[i-2]+dp[i])%mod;\n\t\t}\n\t}\n\tint ans=(dp[n+1]*2+flag)%mod;\n\tREP(i,1,n-2) if(((n-i)%2==1 || flag) && n-i<=Min) ans=(ans+(ll)dp[i]*(n-i-1))%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:512000000\")\n#define _CRT_SECURE_NO_WARNINGS\n//#include \"testlib.h\"\n#include <bits/stdc++.h>\n#ifdef AIM\n#include <sys/resource.h>\n#endif\nusing namespace std;\n\n#define all(a) a.begin(), a.end()\nusing li = long long;\nusing ld = long double;\nvoid solve(bool);\nvoid precalc();\nclock_t start;\nint main() {\n#ifdef AIM\n  freopen(\"/home/alexandero/CLionProjects/ACM/input.txt\", \"r\", stdin);\n  //freopen(\"/home/alexandero/CLionProjects/ACM/output.txt\", \"w\", stdout);\n//freopen(\"out.txt\", \"w\", stdout);\n#else\n  //freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\n#ifdef AIM\n  const rlim_t kStackSize = 256 * 1024 * 1024;\n  struct rlimit rl;\n  int result;\n\n  result = getrlimit(RLIMIT_STACK, &rl);\n  if (result == 0) {\n    if (rl.rlim_cur < kStackSize) {\n      rl.rlim_cur = kStackSize;\n      result = setrlimit(RLIMIT_STACK, &rl);\n      if (result != 0) {\n        fprintf(stderr, \"setrlimit returned result = %d\\n\", result);\n      }\n    }\n  }\n#endif\n\n  start = clock();\n  int t = 1;\n#ifndef AIM\n  cout.sync_with_stdio(0);\n  cin.tie(0);\n#endif\n  cout.precision(20);\n  cout << fixed;\n  //cin >> t;\n  precalc();\n  while (t--) {\n    solve(true);\n  }\n  cout.flush();\n\n#ifdef AIM1\n  while (true) {\n    solve(false);\n  }\n#endif\n\n#ifdef AIM\n  cerr << \"\\n\\n time: \" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\";\n#endif\n  return 0;\n}\n\n//BE CAREFUL: IS INT REALLY INT?\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n  if (!w)\n    return 1 % mod;\n  if (w & 1)\n    return q * 1LL * binpow(q, w - 1, mod) % mod;\n  return binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n  while (w) {\n    q %= w;\n    swap(q, w);\n  }\n  return q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n  return q / gcd(q, w) * w;\n}\n\ntemplate <typename T>\nvoid make_unique(vector<T>& vec) {\n  sort(all(vec));\n  vec.erase(unique(all(vec)), vec.end());\n}\n\ntemplate<typename T>\nvoid relax_min(T& cur, T val) {\n  cur = min(cur, val);\n}\n\ntemplate<typename T>\nvoid relax_max(T& cur, T val) {\n  cur = max(cur, val);\n}\n\nmt19937 rng((unsigned long long)chrono::steady_clock::now().time_since_epoch().count());\n\nvoid precalc() {\n\n}\n\n#define int li\nconst li mod = 1000000007;\n//const int mod = 998244353;\n//using ull = unsigned long long;\n\nvoid add(int& cur, int val) {\n  cur += val;\n  cur %= mod;\n  if (cur < 0) {\n    cur += mod;\n  }\n}\n\nvoid solve(__attribute__((unused)) bool read) {\n  int n, m;\n  cin >> n >> m;\n  string s;\n  cin >> s;\n  if (s[0] == 'B') {\n    for (char& c : s) {\n      c = 'B' + 'R' - c;\n    }\n  }\n  const int INF = (int)1e9;\n  int max_segment = INF;\n  int last = 0;\n  for (int i = 0; i < s.length(); ++i) {\n    if (s[i] == 'B') {\n      int cur_len = i - last;\n      if (last == 0) {\n        if (cur_len % 2 == 0) {\n          ++cur_len;\n        }\n        relax_min(max_segment, cur_len);\n      } else if (cur_len % 2) {\n        relax_min(max_segment, cur_len);\n      }\n      last = i + 1;\n    }\n  }\n  if (last == 0) {\n    vector<int> fib(n + 1);\n    fib[0] = 1;\n    fib[1] = 2;\n    for (int i = 2; i < fib.size(); ++i) {\n      fib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n    }\n    int res = (fib[n - 1] + fib[n - 3]) % mod;\n    cout << res << endl;\n    return;\n  }\n  int max_divided = (max_segment + 1) / 2;\n  //cout << max_segment << \" \" << max_divided << endl;\n  vector<int> dp(n + 1, 0);\n  dp[0] = 1;\n  vector<int> add_to_pref(n + 1, 0);\n  int pref_add = 0;\n  for (int i = 0; i <= n; ++i) {\n    add(pref_add, add_to_pref[i]);\n    add(dp[i], pref_add);\n    add(pref_add, dp[i]);\n    if (i + max_divided < n) {\n      add(add_to_pref[i + max_divided + 1], -dp[i]);\n    }\n    /*if (i < n / 2) {\n      cout << i << \" \" << dp[i] << endl;\n    }*/\n  }\n  if (n % 2) {\n    cout << \"0\\n\";\n    return;\n  }\n  int res = 0;\n  for (int seg = 2; seg <= 2 * max_divided; seg += 2) {\n    //cout << \"add seg: \" << seg << \" rest: \" << (n - seg) / 2 << \" dp: \" << dp[(n - seg) / 2] << endl;\n    res += dp[(n - seg) / 2] * seg;\n    res %= mod;\n  }\n  cout << res << \"\\n\";\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\ntemplate<typename T>\nclass RangeAddQuery {\npublic:\n    explicit RangeAddQuery(int n) : N(calcN_(n)) {\n        mVal.assign(2*N+1, 0);\n    }\n    void update(int l, int r, T value){\n        l = max(0, l);\n        r = min(N, r);\n        int offset = N;\n        while(offset > 0){\n            if(l >= r) break;\n            if(l&1){ update_(mVal[offset+l-1], value); l++; }\n            if(r&1){ update_(mVal[offset+r-2], value); }\n            l /= 2;\n            r /= 2;\n            offset /= 2;\n        }\n    }\n    T get(int idx){\n        int i = N + idx - 1;\n        auto res = mVal[i];\n        while(i > 0){\n            i = (i-1)/2;\n            update_(res, mVal[i]);\n        }\n        return res;\n    }\nprivate:\n    int calcN_(int n){\n        int res = 1;\n        while(res < n) res *= 2;\n        return res;\n    }\n    inline void update_(T& data, T val) { data = (data + val) % MOD; }\n    const int N;\n    vector<T> mVal;\n};\n\nint maxSegment(const string& S){\n    char c = S[0];\n    bool first = true;\n    int cnt = 0;\n    int res = MOD;\n    for(auto& s : S){\n        if(c == s) ++cnt;\n        else {\n            if(first || cnt%2 == 1){\n                res = min(res, cnt/2+1);\n                first = false;\n            }\n        }\n    }\n    return res < MOD ? res : -1;\n}\n\nint solve(const string& S, int N){\n    int seg = maxSegment(S);\n    if(seg != -1 && N%2 == 1) return 0;\n    long long res = 0;\n    if(seg == -1){\n        RangeAddQuery<long long> raq(N);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N;i++){\n            auto a = raq.get(i);\n            raq.update(i+2, N, a);\n        }\n        res = 1;\n        for(int i=N-2;i>=0;i--){\n            res = (res + raq.get(i) * (N-i)) % MOD;\n        }\n    } else {\n        seg = min(seg, N/2);\n        RangeAddQuery<long long> raq(N/2);\n        raq.update(0, 1, 1);\n        for(int i=0;i<N/2;i++){\n            auto a = raq.get(i);\n            raq.update(i+1, i+1+seg, a);\n        }\n        for(int i=N/2-1;i>=N/2-seg;i--){\n            res = (res + raq.get(i) * 2 * (N/2-i)) % MOD;\n        }\n    }\n    return res;\n}\n\nint main(){\n    int N, M; cin >> N >> M;\n    string S; cin >> S;\n    cout << solve(S, N) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define PI 3.14159265358979323846264338327950288419\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nint n, m;\nint col[200005];\n\nint expo(int a, int b){\n\tint c = 1, d = a;\n\twhile(b){\n\t\tif(b & 1){\n\t\t\tc = 1LL * c * d % mod;\n\t\t}\n\t\td = 1LL * d * d % mod;\n\t\tb >>= 1;\n\t}\n\treturn c;\n}\n\nint inv(int x){\n\treturn expo(x, mod - 2);\n}\n\nint calc(int n){\n\tif(n == 2){\n\t\treturn 2;\n\t}\n\t\n\tint fib[200005];\n\tfib[1] = fib[2] = 1;\n\tfor(int i = 3; i <= n + 1; i++){\n\t\tfib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t}\n\t\n\t// force first one to be 1, last one to be 0: fib[N - 1]\n\t// force first one to be 0: fib[N + 1]\n\treturn (fib[n - 1] + fib[n + 1]) % mod;\n}\n\nint calc2(int n, int ub){\n\tassert(ub & 1);\n\t\n\t// want a bunch of numbers, in [2, ub], to sum to n\n\t\n\tub++;\n\tub = min(ub, n); // coz it can actually be HUGE\n\t\n\tint dp[200005]; // dp[i]: number of possible sums, that sum to i\n\tint cumu[200005];\n\t\n\tdp[0] = 1;\n\tcumu[0] = 1;\n\t\n\tfor(int i = 2; i <= n; i += 2){\n\t\t// sum from dp[l_index .. i - 2].. oh, only the even ones!\n\t\tint l_index = i - ub;\n\t//\tprintf(\"%d: sum %d..%d\\n\", i, l_index, r_index);\n\t\tdp[i] = cumu[i - 2];\n\t\t\n\t\tif(l_index > 0){\n\t\t\tdp[i] -= cumu[l_index - 2];\n\t\t\tif(dp[i] < 0){\n\t\t\t\tdp[i] += mod;\n\t\t\t}\n\t\t}\n//\t\tprintf(\"%d: %d\\n\", i, dp[i]);\n\t\tcumu[i] = (cumu[i - 2] + dp[i]) % mod;\n\t}\n\t\n\tint ret = 0;\n\t\n\tfor(int space = 0; space < ub; space++){\n\t\t// last 1 is at (n - space), leaving _ space at the end\n\t\t// where can the first 1 be?\n\t\tint left_pos = 1;\n\t\tint right_pos = ub - space;\n\t\t\n\t\tint most_remain = (n - space) - 1;\n\t\tint least_remain = n - ub;\n\t\t\n\t\tif(most_remain & 1) most_remain--;\n\t\t\n\t\tint combin = cumu[most_remain];\n\t\tif(least_remain > 0){\n\t\t\tcombin = (combin - cumu[least_remain - 2] + mod) % mod;\n\t\t}\n\t\tret = (ret + combin) % mod;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d %d\", &n, &m);\n\tfor(int i = 1; i <= m; i++){\n\t\tchar c;\n\t\tscanf(\" %c\", &c);\n\t\tcol[i] = (c == 'B');\n\t}\n\tif(col[1] != 0){\n\t\t// WLOG first one is 0\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tcol[i] = 1 - col[i];\n\t\t}\n\t}\n\t\n\tbool monochrome = true;\n\tfor(int i = 2; i <= m; i++){\n\t\tif(col[i]){\n\t\t\tmonochrome = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(monochrome){\n\t\t// ok as long as 1s are not adjacent\n\t\tassert(false);\n\t\tprintf(\"%d\\n\", calc(n));\n\t\treturn 0;\n\t}else{\n\t\t// 00...010..010..0\n\t\t// each block of 0 is of add length\n\t\t// so, n odd -> definitely no solution\n\t\t// more conditions depending on specifics of col[]\n\t\tif(n % 2 == 1){\n\t\t \tprintf(\"0\\n\");\n\t\t \treturn 0;\n\t\t}\n\t\tint first_run = 0, subseq_run = n - 1;\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tint len = 0;\n\t\t\twhile(i + len <= m && col[i + len] == 0){\n\t\t \t\tlen++;\n\t\t \t}\n\t\t \tif(first_run == 0){\n\t\t \t\tfirst_run = len;\n\t\t \t}else if(len & 1){\n\t\t \t\tsubseq_run = min(subseq_run, len);\n\t\t \t}\n\t\t \ti += len;\n\t\t}\n\t\tint ub = first_run + (first_run % 2 == 0);\n\t\tub = min(ub, subseq_run);\n\t\tprintf(\"%d\\n\", calc2(n, ub));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n \nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 1e9 + 7;\n \nint n, m;\nchar S[200005];\nvector<int> sizs;\nint dp[200005], prs[200005];\n\nint main()\n{\n\tscanf(\"%d%d%s\", &n, &m, S);\n\t\n\tint ccnt = 1;\n\tfor(int i = 1; i < m; i ++)\n\tif(S[i] != S[i - 1]) {\n\t\tsizs.push_back(ccnt);\n\t\tccnt = 1;\n\t} else ccnt ++;\n\tsizs.push_back(ccnt);\n\t\n\tif(sizs.size() == 1) {\n\t\tdp[1] = 2;\n\t\tdp[2] = MOD - 1;\n\t\trep(i, n) {\n\t\t\tif(i >= 1) dp[i] = (dp[i] + dp[i - 1]) % MOD;\n\t\t}\n\t\trep(i, n) {\n\t\t\tif(i >= 1) dp[i] = (dp[i] + dp[i - 1]) % MOD;\n\t\t\tif(i >= 2) dp[i] = (dp[i] + dp[i - 2]) % MOD;\n\t\t}\n\t\tprintf(\"%d\\n\", dp[n - 1] + 1);\n\t} else {\n\t\tint maxl = min(n, sizs[0] + 2);\n\t\trep(i, sizs.size()) if(i + 1 < sizs.size() && !(i & 1) && (sizs[i] & 1))\n\t\tmaxl = min(maxl, sizs[i] + 1);\n\t\t\n\t\trep1(i, maxl) if(!(i & 1)) dp[i] = i;\n\t\t\n\t\trep1(i, n) {\n\t\t\tif(i >= 2) dp[i] = (dp[i] + prs[i - 2]) % MOD;\n\t\t\tif(i >= 2 + maxl) dp[i] = (dp[i] + (MOD - 1LL) * prs[i - 2 - maxl]) % MOD;\n\t\t\tif(i >= 2) prs[i] = (dp[i] + prs[i - 2]) % MOD;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", dp[n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\ntypedef pair<int, int> Pii;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\nll mod_pow(ll a, ll n, ll mod) { ll ret = 1; ll p = a % mod; while (n) { if (n & 1) ret = ret * p % mod; p = p * p % mod; n >>= 1; } return ret; }\n\ntemplate<int mod, int primitive_root>\nclass NTT {\npublic:\n\tint get_mod() const { return mod; }\n\tvoid _ntt(vector<ll>& a, int sign) {\n\t\tconst int n = sz(a);\n\t\tassert((n ^ (n&-n)) == 0); //n = 2^k\n\n\t\tconst int g = 3; //g is primitive root of mod\n\t\tint h = (int)mod_pow(g, (mod - 1) / n, mod); // h^n = 1\n\t\tif (sign == -1) h = (int)mod_inv(h, mod); //h = h^-1 % mod\n\n\t\t//bit reverse\n\t\tint i = 0;\n\t\tfor (int j = 1; j < n - 1; ++j) {\n\t\t\tfor (int k = n >> 1; k >(i ^= k); k >>= 1);\n\t\t\tif (j < i) swap(a[i], a[j]);\n\t\t}\n\n\t\tfor (int m = 1; m < n; m *= 2) {\n\t\t\tconst int m2 = 2 * m;\n\t\t\tconst ll base = mod_pow(h, n / m2, mod);\n\t\t\tll w = 1;\n\t\t\tFOR(x, m) {\n\t\t\t\tfor (int s = x; s < n; s += m2) {\n\t\t\t\t\tll u = a[s];\n\t\t\t\t\tll d = a[s + m] * w % mod;\n\t\t\t\t\ta[s] = u + d;\n\t\t\t\t\tif (a[s] >= mod) a[s] -= mod;\n\t\t\t\t\ta[s + m] = u - d;\n\t\t\t\t\tif (a[s + m] < 0) a[s + m] += mod;\n\t\t\t\t}\n\t\t\t\tw = w * base % mod;\n\t\t\t}\n\t\t}\n\n\t\tfor (auto& x : a) if (x < 0) x += mod;\n\t}\n\tvoid ntt(vector<ll>& input) {\n\t\t_ntt(input, 1);\n\t}\n\tvoid intt(vector<ll>& input) {\n\t\t_ntt(input, -1);\n\t\tconst int n_inv = mod_inv(sz(input), mod);\n\t\tfor (auto& x : input) x = x * n_inv % mod;\n\t}\n\n\t// 畳み込み演算を行う\n\tvector<ll> convolution(const vector<ll>& a, const vector<ll>& b){\n\t\tint ntt_size = 1;\n\t\twhile (ntt_size < sz(a) + sz(b)) ntt_size *= 2;\n\n\t\tvector<ll> _a = a, _b = b;\n\t\t_a.resize(ntt_size); _b.resize(ntt_size);\n\n\t\tntt(_a);\n\t\tntt(_b);\n\n\t\tFOR(i, ntt_size){\n\t\t\t(_a[i] *= _b[i]) %= mod;\n\t\t}\n\n\t\tintt(_a);\n\t\treturn _a;\n\t}\n};\n\nll garner(vector<Pii> mr, int mod){\n\tmr.emplace_back(mod, 0);\n\n\tvector<ll> coffs(sz(mr), 1);\n\tvector<ll> constants(sz(mr), 0);\n\tFOR(i, sz(mr) - 1){\n\t\t// coffs[i] * v + constants[i] == mr[i].second (mod mr[i].first) を解く\n\t\tll v = (mr[i].second - constants[i]) * mod_inv<ll>(coffs[i], mr[i].first) % mr[i].first;\n\t\tif (v < 0) v += mr[i].first;\n\n\t\tfor (int j = i + 1; j < sz(mr); j++) {\n\t\t\t(constants[j] += coffs[j] * v) %= mr[j].first;\n\t\t\t(coffs[j] *= mr[i].first) %= mr[j].first;\n\t\t}\n\t}\n\n\treturn constants[sz(mr) - 1];\n}\n\ntypedef NTT<167772161, 3> NTT_1;\ntypedef NTT<469762049, 3> NTT_2;\ntypedef NTT<1224736769, 3> NTT_3;\n\n//任意のmodで畳み込み演算 O(n log n)\nvector<ll> int32mod_convolution(vector<ll> a, vector<ll> b,int mod){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\tvector<ll> ret(sz(x));\n\tvector<Pii> mr(3);\n\tFOR(i, sz(x)){\n\t\tmr[0].first = ntt1.get_mod(), mr[0].second = (int)x[i];\n\t\tmr[1].first = ntt2.get_mod(), mr[1].second = (int)y[i];\n\t\tmr[2].first = ntt3.get_mod(), mr[2].second = (int)z[i];\n\t\tret[i] = garner(mr, mod);\n\t}\n\n\treturn ret;\n}\n\n// garnerのアルゴリズムを直書きしたversion，速い\nvector<ll> fast_int32mod_convolution(vector<ll> a, vector<ll> b,int mod,int len){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\t\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tassert(ntt1.get_mod() < ntt2.get_mod() && ntt2.get_mod() < ntt3.get_mod());\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\t// garnerのアルゴリズムを極力高速化した\n\tconst ll m1 = ntt1.get_mod(), m2 = ntt2.get_mod(), m3 = ntt3.get_mod();\n\tconst ll m1_inv_m2 = mod_inv<ll>(m1, m2);\n\tconst ll m12_inv_m3 = mod_inv<ll>(m1 * m2, m3);\n\tconst ll m12_mod = m1 * m2 % mod;\n\tint L = min(len,sz(x));\n    vector<ll> ret(L);\n\tFOR(i, L){\n\t\tll v1 = (y[i] - x[i]) *  m1_inv_m2 % m2;\n\t\tif (v1 < 0) v1 += m2;\n\t\tll v2 = (z[i] - (x[i] + m1 * v1) % m3) * m12_inv_m3 % m3;\n\t\tif (v2 < 0) v2 += m3;\n\t\tll constants3 = (x[i] + m1 * v1 + m12_mod * v2) % mod;\n\t\tif (constants3 < 0) constants3 += mod;\n\t\tret[i] = constants3;\n\t}\n\n\treturn ret;\n}\n\n\nunsigned int add(const unsigned int x, const unsigned int y)\n{\n    return (x + y < MOD) ? x + y : x + y - MOD;\n}\n \nunsigned int sub(const unsigned int x, const unsigned int y)\n{\n    return (x >= y) ? (x - y) : (MOD - y + x);\n}\n \nunsigned int mul(const unsigned int x, const unsigned int y)\n{\n    return (unsigned long long)x * y % MOD;\n}\n \nunsigned int mod_pow(unsigned int x, unsigned int n)\n{\n    unsigned int res = 1;\n    while(n > 0){\n        if(n & 1){ res = mul(res, x); }\n        x = mul(x, x);\n        n >>= 1;\n    }\n    return res;\n}\n \nunsigned int inverse(const unsigned int x)\n{\n    return mod_pow(x, MOD - 2);\n}\n \nvector<ll> polynomial_inverse(const vector<ll>& a, int r)\n{\n    assert(a[0] != 0);\n    vector<ll> h = {(ll)inverse(a[0])};\n    int t = 1;\n    vector<ll> b;\n    int id =  0;\n    for(int i = 0; t < r; ++i){\n    \n        t <<= 1;\n        while(id<min((int)a.size(),t)){\n            b.push_back(a[id]);\n            id++;\n        }\n        vector<ll> res = fast_int32mod_convolution(b, fast_int32mod_convolution(h, h, MOD,t), MOD,t);\n        res.resize(t);\n        for(int j = 0; j < t; ++j){\n            res[j] = sub(0, res[j]);\n            if(j < t / 2) res[j] = add(res[j], mul(2, h[j]));\n        }\n        swap(h, res);\n    }\n    h.resize(r);\n    return h;\n}\n\nmod dp[200010][2][2];\nint main(){\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if(s[0]=='R'){\n        rep(i,m){\n            if(s[i]=='R'){\n                s[i] ='B';\n            }else{\n                s[i] ='R'; \n            }\n        }\n    }\n    int a = inf;\n    int c = 0;\n    bool flag = 1;\n    rep(i,m){\n        if(s[i]=='B'){\n            c++;\n        }else{\n            if(flag){\n                flag = 0;\n                chmin(a,c);\n            }else if(c%2==1){\n                chmin(a,c); \n            }\n            c = 0;   \n        }\n    }\n    if(a==inf){\n        dp[0][0][0] = 1;\n        dp[0][1][1] = 1;\n        for(int i=1;i<n;i++){\n            for(int j=0;j<2;j++){\n                if(j==0){\n                    dp[i][j][0] += dp[i-1][1][0];\n                    dp[i][j][1] += dp[i-1][1][1];\n                }else{\n                    dp[i][j][0] += dp[i-1][1][0] + dp[i-1][0][0];\n                    dp[i][j][1] += dp[i-1][1][1] + dp[i-1][0][1];    \n                }\n            }\n        }\n        cout << dp[n-1][1][0] + dp[n-1][1][1] + dp[n-1][0][1] << endl;\n    }else{\n        int len = (a/2)*2+1;\n        //cerr << len << endl;\n        vector<ll> X(n+1),Y(n+1);\n        len++;\n        len = min(n,len);\n        for(int i=2;i<=len;i+=2){\n            X[i] = i;\n        }\n        Y[0] = 1;\n        for(int i=2;i<=len;i+=2){\n            Y[i] = MOD-1;\n        }\n        rep(i,n+1){\n            cerr << X[i] << \" \";\n        }\n        cerr << endl;\n        \n        rep(i,n+1){\n            cerr << Y[i] << \" \";\n        }\n        cerr << endl;\n        Y =polynomial_inverse(Y,n+1);\n        \n        rep(i,n+1){\n            cerr << Y[i] << \" \";\n        }\n        cerr << endl;\n        X = fast_int32mod_convolution(X,Y,MOD,n+1);\n        \n        rep(i,n+1){\n            cerr << X[i] << \" \";\n        }\n        cerr << endl;\n        cout << X[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n\n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = l; i < r; i++)\n#define repb(i, r, l) for (int i = r; i > l; i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n\nusing namespace std;\n\ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n\nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst double eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\ninline void add(int &x, int y) {\n    x += y;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nll bin_pow(ll a, ll p) {\n    ll res = 1;\n    while (p) {\n        if (p & 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n        p >>= 1;\n    }\n    return res;\n}\n\nll rev(ll x) {\n    return bin_pow(x, MOD - 2);\n}\n\nll fact[N + 1], rfact[N + 1];\n\nvoid init() {\n    fact[0] = 1;\n    rep(i, 1, N + 1) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    rfact[N] = rev(fact[N]);\n    repb(i, N - 1, -1) {\n        rfact[i] = rfact[i + 1] * (i + 1) % MOD;\n    }\n}\n\nll C(int n, int k) {\n    if (k < 0 || k > n) {\n        return 0;\n    }\n    return fact[n] * rfact[k] % MOD * rfact[n - k] % MOD;\n}\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 0.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    init();\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    repb(i, m - 1, -1) {\n        s[i] = char('0' + (s[0] != s[i]));\n    }\n    int c1 = 0;\n    rep(i, 0, m) {\n        if (s[i] == '1') {\n            c1++;\n        }\n    }\n    if (c1 == 0) {\n        int ans = 0;\n        for (int i = 0; i * 2 <= n; i++) {\n            add(ans, C(n - i, i));\n            if (i >= 1) {\n                add(ans, C(n - 2 - (i - 1), (i - 1)));\n            }\n        }\n        cout << ans << \"\\n\";\n        return 0;\n    }\n    if (n % 2 == 1) {\n        cout << 0 << \"\\n\";\n        return 0;\n    }\n    int k = n - 1, cur = 0;\n    rep(i, 0, m) {\n        if (s[i] == '0') {\n            cur++;\n        }\n        if (i == m - 1 || s[i + 1] == '1') {\n            if (cur % 2 == 1) {\n                setmin(k, cur);\n            } else if (cur > 0) {\n                setmin(k, cur + 1);\n            }\n            cur = 0;\n        }\n    }\n    //cout << k << endl;\n    int dp[n + 2], pref1[n + 2];\n    fill(dp, dp + n + 1, 0);\n    fill(pref1, pref1 + n + 2, 0);\n    dp[1] = 1;\n    pref1[1] = 1;\n    for (int i = 3; i <= n + 1; i += 2) {\n        int last_add = max(1, i - (k + 1));\n        dp[i] = pref1[i - 2] - (last_add - 2 >= 0 ? pref1[last_add - 2] : 0);\n        if (dp[i] < 0) {\n            dp[i] += MOD;\n        }\n        pref1[i] = (pref1[i - 2] + dp[i]) % MOD;\n    }\n    /*rep(i, 1, n + 2) {\n        cout << dp[i] << \" \";\n    }\n    cout << \"\\n\";*/\n    int ans = dp[n + 1];\n    //cout << k << endl;\n    for (int c = 1; c <= k; c += 2) {\n        //cout << c << \" \" << dp[n - c] << endl;\n        ans = (ans + 1LL * c * dp[n - c]) % MOD;\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate <unsigned int mod>\nclass ModInt {\nprivate:\n    unsigned int v;\n    static unsigned int norm(const unsigned int& x){ return x < mod ? x : x - mod; }\n    static ModInt make(const unsigned int& x){ ModInt m; return m.v = x, m; }\n    static ModInt inv(const ModInt& x){ return make(inverse(x.v, mod)); }\n    static unsigned int inverse(int a, int m){\n        int u[] = {a, 1, 0}, v[] = {m, 0, 1}, t;\n        while(*v){\n            t = *u / *v;\n            swap(u[0] -= t * v[0], v[0]), swap(u[1] -= t * v[1], v[1]), swap(u[2] -= t * v[2], v[2]);\n        }\n        return (u[1] % m + m) % m;\n    }\n\npublic:\n    ModInt() : v{0}{}\n    ModInt(const long long val) : v{norm(val % mod + mod)} {}\n    ModInt(const ModInt<mod>& n) : v{n()} {}\n    explicit operator bool() const noexcept { return v != 0; }\n    bool operator!() const noexcept { return !static_cast<bool>(*this); }\n    ModInt& operator=(const ModInt& n){ return v = n(), (*this); }\n    ModInt& operator=(const long long val){ return v = norm(val % mod + mod), (*this); }\n    ModInt operator+() const { return *this; }\n    ModInt operator-() const { return v == 0 ? make(0) : make(mod - v); }\n    ModInt operator+(const ModInt& val) const { return make(norm(v + val())); }\n    ModInt operator-(const ModInt& val) const { return make(norm(v + mod - val())); }\n    ModInt operator*(const ModInt& val) const { return make((long long)v * val() % mod); }\n    ModInt operator/(const ModInt& val) const { return *this * inv(val); }\n    ModInt& operator+=(const ModInt& val){ return *this = *this + val; }\n    ModInt& operator-=(const ModInt& val){ return *this = *this - val; }\n    ModInt& operator*=(const ModInt& val){ return *this = *this * val; }\n    ModInt& operator/=(const ModInt& val){ return *this = *this / val; }\n    ModInt operator+(const long long val) const { return ModInt{v + val}; }\n    ModInt operator-(const long long val) const { return ModInt{v - val}; }\n    ModInt operator*(const long long val) const { return ModInt{(long long)v * (val % mod)}; }\n    ModInt operator/(const long long val) const { return ModInt{(long long)v * inv(val)}; }\n    ModInt& operator+=(const long long val){ return *this = *this + val; }\n    ModInt& operator-=(const long long val){ return *this = *this - val; }\n    ModInt& operator*=(const long long val){ return *this = *this * val; }\n    ModInt& operator/=(const long long val){ return *this = *this / val; }\n    bool operator==(const ModInt& val) const { return v == val.v; }\n    bool operator!=(const ModInt& val) const { return !(*this == val); }\n    bool operator==(const long long val) const { return v == norm(val % mod + mod); }\n    bool operator!=(const long long val) const { return !(*this == val); }\n    unsigned int operator()() const { return v; }\n    friend ModInt operator+(const long long val, const ModInt& n) { return n + val; }\n    friend ModInt operator-(const long long val, const ModInt& n) { return ModInt{val - n()}; }\n    friend ModInt operator*(const long long val, const ModInt& n) { return n * val; }\n    friend ModInt operator/(const long long val, const ModInt& n) { return ModInt{val} / n; }\n    friend bool operator==(const long long val, const ModInt& n) { return n == val; }\n    friend bool operator!=(const long long val, const ModInt& n) { return !(val == n); }\n    friend istream& operator>>(istream& is, ModInt& n){\n        unsigned int v;\n        return is >> v, n = v, is;\n    }\n    friend ostream& operator<<(ostream& os, const ModInt& n){ return (os << n()); }\n    friend ModInt mod_pow(ModInt x, long long n){\n        ModInt ans = 1;\n        while(n){\n            if(n & 1) ans *= x;\n            x *= x, n >>= 1;\n        }\n        return ans;\n    }\n};\n\n#define MOD 1000000007\nusing mod = ModInt<MOD>;\n\ntypedef pair<int, int> Pii;\n\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)(c).size())\n\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\nll mod_pow(ll a, ll n, ll mod) { ll ret = 1; ll p = a % mod; while (n) { if (n & 1) ret = ret * p % mod; p = p * p % mod; n >>= 1; } return ret; }\n\ntemplate<int mod, int primitive_root>\nclass NTT {\npublic:\n\tint get_mod() const { return mod; }\n\tvoid _ntt(vector<ll>& a, int sign) {\n\t\tconst int n = sz(a);\n\t\tassert((n ^ (n&-n)) == 0); //n = 2^k\n\n\t\tconst int g = 3; //g is primitive root of mod\n\t\tint h = (int)mod_pow(g, (mod - 1) / n, mod); // h^n = 1\n\t\tif (sign == -1) h = (int)mod_inv(h, mod); //h = h^-1 % mod\n\n\t\t//bit reverse\n\t\tint i = 0;\n\t\tfor (int j = 1; j < n - 1; ++j) {\n\t\t\tfor (int k = n >> 1; k >(i ^= k); k >>= 1);\n\t\t\tif (j < i) swap(a[i], a[j]);\n\t\t}\n\n\t\tfor (int m = 1; m < n; m *= 2) {\n\t\t\tconst int m2 = 2 * m;\n\t\t\tconst ll base = mod_pow(h, n / m2, mod);\n\t\t\tll w = 1;\n\t\t\tFOR(x, m) {\n\t\t\t\tfor (int s = x; s < n; s += m2) {\n\t\t\t\t\tll u = a[s];\n\t\t\t\t\tll d = a[s + m] * w % mod;\n\t\t\t\t\ta[s] = u + d;\n\t\t\t\t\tif (a[s] >= mod) a[s] -= mod;\n\t\t\t\t\ta[s + m] = u - d;\n\t\t\t\t\tif (a[s + m] < 0) a[s + m] += mod;\n\t\t\t\t}\n\t\t\t\tw = w * base % mod;\n\t\t\t}\n\t\t}\n\n\t\tfor (auto& x : a) if (x < 0) x += mod;\n\t}\n\tvoid ntt(vector<ll>& input) {\n\t\t_ntt(input, 1);\n\t}\n\tvoid intt(vector<ll>& input) {\n\t\t_ntt(input, -1);\n\t\tconst int n_inv = mod_inv(sz(input), mod);\n\t\tfor (auto& x : input) x = x * n_inv % mod;\n\t}\n\n\t// 畳み込み演算を行う\n\tvector<ll> convolution(const vector<ll>& a, const vector<ll>& b){\n\t\tint ntt_size = 1;\n\t\twhile (ntt_size < sz(a) + sz(b)) ntt_size *= 2;\n\n\t\tvector<ll> _a = a, _b = b;\n\t\t_a.resize(ntt_size); _b.resize(ntt_size);\n\n\t\tntt(_a);\n\t\tntt(_b);\n\n\t\tFOR(i, ntt_size){\n\t\t\t(_a[i] *= _b[i]) %= mod;\n\t\t}\n\n\t\tintt(_a);\n\t\treturn _a;\n\t}\n};\n\nll garner(vector<Pii> mr, int mod){\n\tmr.emplace_back(mod, 0);\n\n\tvector<ll> coffs(sz(mr), 1);\n\tvector<ll> constants(sz(mr), 0);\n\tFOR(i, sz(mr) - 1){\n\t\t// coffs[i] * v + constants[i] == mr[i].second (mod mr[i].first) を解く\n\t\tll v = (mr[i].second - constants[i]) * mod_inv<ll>(coffs[i], mr[i].first) % mr[i].first;\n\t\tif (v < 0) v += mr[i].first;\n\n\t\tfor (int j = i + 1; j < sz(mr); j++) {\n\t\t\t(constants[j] += coffs[j] * v) %= mr[j].first;\n\t\t\t(coffs[j] *= mr[i].first) %= mr[j].first;\n\t\t}\n\t}\n\n\treturn constants[sz(mr) - 1];\n}\n\ntypedef NTT<167772161, 3> NTT_1;\ntypedef NTT<469762049, 3> NTT_2;\ntypedef NTT<1224736769, 3> NTT_3;\n\n//任意のmodで畳み込み演算 O(n log n)\nvector<ll> int32mod_convolution(vector<ll> a, vector<ll> b,int mod){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\tvector<ll> ret(sz(x));\n\tvector<Pii> mr(3);\n\tFOR(i, sz(x)){\n\t\tmr[0].first = ntt1.get_mod(), mr[0].second = (int)x[i];\n\t\tmr[1].first = ntt2.get_mod(), mr[1].second = (int)y[i];\n\t\tmr[2].first = ntt3.get_mod(), mr[2].second = (int)z[i];\n\t\tret[i] = garner(mr, mod);\n\t}\n\n\treturn ret;\n}\n\n// garnerのアルゴリズムを直書きしたversion，速い\nvector<ll> fast_int32mod_convolution(vector<ll> a, vector<ll> b,int mod,int len){\n\tfor (auto& x : a) x %= mod;\n\tfor (auto& x : b) x %= mod;\n\t\n\tNTT_1 ntt1; NTT_2 ntt2; NTT_3 ntt3;\n\tassert(ntt1.get_mod() < ntt2.get_mod() && ntt2.get_mod() < ntt3.get_mod());\n\tauto x = ntt1.convolution(a, b);\n\tauto y = ntt2.convolution(a, b);\n\tauto z = ntt3.convolution(a, b);\n\n\t// garnerのアルゴリズムを極力高速化した\n\tconst ll m1 = ntt1.get_mod(), m2 = ntt2.get_mod(), m3 = ntt3.get_mod();\n\tconst ll m1_inv_m2 = mod_inv<ll>(m1, m2);\n\tconst ll m12_inv_m3 = mod_inv<ll>(m1 * m2, m3);\n\tconst ll m12_mod = m1 * m2 % mod;\n\tint L = min(len,sz(x));\n    vector<ll> ret(L);\n\tFOR(i, L){\n\t\tll v1 = (y[i] - x[i]) *  m1_inv_m2 % m2;\n\t\tif (v1 < 0) v1 += m2;\n\t\tll v2 = (z[i] - (x[i] + m1 * v1) % m3) * m12_inv_m3 % m3;\n\t\tif (v2 < 0) v2 += m3;\n\t\tll constants3 = (x[i] + m1 * v1 + m12_mod * v2) % mod;\n\t\tif (constants3 < 0) constants3 += mod;\n\t\tret[i] = constants3;\n\t}\n\n\treturn ret;\n}\n\n\nunsigned int add(const unsigned int x, const unsigned int y)\n{\n    return (x + y < MOD) ? x + y : x + y - MOD;\n}\n \nunsigned int sub(const unsigned int x, const unsigned int y)\n{\n    return (x >= y) ? (x - y) : (MOD - y + x);\n}\n \nunsigned int mul(const unsigned int x, const unsigned int y)\n{\n    return (unsigned long long)x * y % MOD;\n}\n \nunsigned int mod_pow(unsigned int x, unsigned int n)\n{\n    unsigned int res = 1;\n    while(n > 0){\n        if(n & 1){ res = mul(res, x); }\n        x = mul(x, x);\n        n >>= 1;\n    }\n    return res;\n}\n \nunsigned int inverse(const unsigned int x)\n{\n    return mod_pow(x, MOD - 2);\n}\n \nvector<ll> polynomial_inverse(const vector<ll>& a, int r)\n{\n    assert(a[0] != 0);\n    vector<ll> h = {(ll)inverse(a[0])};\n    int t = 1;\n    vector<ll> b;\n    int id =  0;\n    for(int i = 0; t < r; ++i){\n    \n        t <<= 1;\n        while(id<min((int)a.size(),t)){\n            b.push_back(a[id]);\n            id++;\n        }\n        vector<ll> res = fast_int32mod_convolution(b, fast_int32mod_convolution(h, h, MOD,t), MOD,t);\n        res.resize(t);\n        for(int j = 0; j < t; ++j){\n            res[j] = sub(0, res[j]);\n            if(j < t / 2) res[j] = add(res[j], mul(2, h[j]));\n        }\n        swap(h, res);\n    }\n    h.resize(r);\n    return h;\n}\n\nmod dp[200010][2][2];\nint main(){\n    int n,m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if(s[0]=='R'){\n        rep(i,m){\n            if(s[i]=='R'){\n                s[i] ='B';\n            }else{\n                s[i] ='R'; \n            }\n        }\n    }\n    int a = inf;\n    int c = 0;\n    bool flag = 1;\n    rep(i,m){\n        if(s[i]=='B'){\n            c++;\n        }else{\n            if(flag){\n                chmin(a,c);\n            }else if(c%2==1){\n                chmin(a,c); \n            }\n            c = 0;   \n        }\n    }\n    if(a==inf){\n        dp[0][0][0] = 1;\n        dp[0][1][1] = 1;\n        for(int i=1;i<n;i++){\n            for(int j=0;j<2;j++){\n                if(j==0){\n                    dp[i][j][0] += dp[i-1][1][0];\n                    dp[i][j][1] += dp[i-1][1][1];\n                }else{\n                    dp[i][j][0] += dp[i-1][1][0] + dp[i-1][0][0];\n                    dp[i][j][1] += dp[i-1][1][1] + dp[i-1][0][1];    \n                }\n            }\n        }\n        cout << dp[n-1][1][0] + dp[n-1][1][1] + dp[n-1][0][1] << endl;\n    }else{\n        int len = (a/2)*2+1;\n        //cerr << len << endl;\n        vector<ll> X(n+1),Y(n+1);\n        len++;\n        len = min(n,len);\n        for(int i=2;i<=len;i+=2){\n            X[i] = i;\n        }\n        Y[0] = 1;\n        for(int i=2;i<=len;i+=2){\n            Y[i] = MOD-1;\n        }\n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        Y =polynomial_inverse(Y,n+1);\n        \n        // rep(i,n+1){\n        //     cerr << Y[i] << \" \";\n        // }\n        // cerr << endl;\n        X = fast_int32mod_convolution(X,Y,MOD,n+1);\n        \n        // rep(i,n+1){\n        //     cerr << X[i] << \" \";\n        // }\n        // cerr << endl;\n        cout << X[n] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200010\n#define ll long long\n#define mod 1000000007\nusing namespace std;\nchar s[maxn];\nint f[maxn], pre[maxn];\nint main()\n{\n\tint n, m, mx = 0, flag = 1;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", s + 1);\n\tfor (int i = 2; i <= m; i++)\n\t\tif (s[i] != s[1]) flag = 0;\n\tif (flag == 0)\n\t{\n\t\tint st;\n\t\tfor (int i = 1; i <= m; i++)\n\t\t\tif (s[i] != s[1])\n\t\t\t{\n\t\t\t\tst = i;\n\t\t\t\tmx = i - 1;\n\t\t\t\tif (mx % 2 == 0) mx++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\twhile (st <= m)\n\t\t{\n\t\t\tint cur = st;\n\t\t\twhile (cur <= m && s[cur] == s[st]) cur++;\n\t\t\tif (s[st] == s[1] && (st - cur) % 2) mx = min(mx, st - cur);\n\t\t\tst = cur;\n\t\t}\n\t\tif (n % 2) {puts(\"0\"); return 0;}\n\t\tn /= 2;\n\t\tmx = (mx + 1) / 2;\n\t}\n\telse mx = n;\n\tf[0] = pre[0] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tf[i] = pre[i - 1];\n\t\tif (i - mx - 1 >= 0) f[i] = (f[i] - pre[i - mx - 1] + mod) % mod;\n\t\tif (flag) f[i] = (f[i] - f[i - 1] + mod) % mod;\n\t\tpre[i] = (pre[i - 1] + f[i]) % mod;\n\t}\n\tint res = flag;\n\tfor (int i = flag + 1; i <= mx; i++)\n\t\tres = (res + (ll)i * f[n - i] % mod) % mod;\n\tif (flag == 0) res = (ll)res * 2 % mod;\n\tprintf(\"%d\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\nconst int mod=1e9+7;\nconst int maxn=2e5+50;\nint n,m;\nint f[maxn];\nint s[maxn];\nchar S[maxn];\ninline int add(int x)\n{\n\treturn x>=mod?x-mod:x;\n}\ninline int dec(int x)\n{\n\treturn x<0?x+mod:x;\n}\nvoid dp(int L)\n{\n\tf[1]=s[1]=1;\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\tf[i]=dec(s[i-1]-s[max(0,i-L-2)]);\n\t\ts[i]=add(s[i-1]+f[i]);\n\t} \n}\nint solve()\n{\n\tif(S[1]=='B')\n\t{\n\t\tfor(int i=1;i<=m;++i)\n\t\t{\n\t\t\tS[i]=S[i]=='R'?'B':'R'; \n\t\t}\n\t}\n\tint an=0,k=1,L=n;\n\twhile(k<m&&S[k+1]=='R')\n\t{\n\t\t++k;\n\t}\n\tif(k==m)\n\t{\n\t\tstatic int f[maxn][2];\n\t\tmemset(f,0,sizeof(f)); \n\t\tf[1][0]=1;\n\t\tfor(int i=1;i<n;++i)\n\t\t{\n\t\t\tf[i+1][0]=add(f[i][0]+f[i][1]);\n\t\t\tf[i+1][1]=add(f[i][0]);\n\t\t}\n\t\tan=add(an+f[n][0]);\n\t\tan=add(an+f[n][1]);\n\t\tmemset(f,0,sizeof(f));\n\t\tf[1][1]=1;\n\t\tfor(int i=1;i<n;++i)\n\t\t{\n\t\t\tf[i+1][0]=add(f[i][0]+f[i][1]);\n\t\t\tf[i+1][1]=add(f[i][0]);\n\t\t}\n\t\tan=add(an+f[n][0]);\n\t\treturn an;\n\t}\n\tL=k&1?k:k+1;\n\tfor(int i=k+1,j;i<=m;i=j+1)\n\t{\n\t\tj=i;\n\t\twhile(j<=m&&S[j]!='B')\n\t\t{\n\t\t\t++j;\n\t\t}\n\t\tif(j==m+1) continue;\n\t\tint _k=j-i;\n\t\tif(_k&1) L=min(L,_k);\n\t}\n\tn>>=1,L>>=1;\n\tdp(L);\n\tfor(int i=n;i>=1;--i)\n\t{\n\t\tif(n-i>L) break;\n\t\tan=(an+(ll)(n-i+1)*f[i])%mod;\n\t}\n\tan=add(an<<1);\n\treturn an;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",S+1);\n\tprintf(\"%d\\n\",solve());\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast,inline\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,sse4.1,sse4.2,popcnt,abm,mmx,avx,avx2,tune=native\")\n#pragma G++ optimize(2)\n#pragma GCC optimize(3)\n#pragma G++ optimize(3)\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#include<bits/stdc++.h>\n#define ll long long\n//#define int ll\nusing namespace std;\nconst int md=1000000007;\nconst int mxn=200005;\nint n,m,mx,ans,dp[mxn],f[mxn];\nchar s[mxn];\ninline void add(int&x,int y){\n\tx+=y;\n\tif(x>=md)x-=md;\n}\nsigned main(){\n\tint i,j,t;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);\n\tfor(i=1;i<=m;++i)if(s[i]!=s[1])break;mx=i-1;\n\tif(mx==m){\n\t\tdp[0]=f[i]=ans=1;\n\t\tfor(int i=0;i<=n;++i){\n\t\t\tif(i>=2)dp[i]=f[i-2];\n\t\t\tf[i]=(f[i-1]+dp[i])%md;\n\t\t\tif(n-i>1)add(ans,dp[i]*(n-i)%md);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n\tif(n&1)return 0*puts(\"0\");\n\tif(!(mx&1))++mx;\n\tfor(t=0;i<=m;++i){\n\t\tif(s[i]==s[1])++t;\n\t\telse{\n\t\t\tif(t&1)mx=min(mx,t);\n\t\t\tt=0;\n\t\t}\n\t}\n\tn>>=1,mx=mx+1>>1;\n\tdp[0]=f[0]=1;\n\tfor(i=0;i<=n;++i){\n\t\tif(i){\n\t\t\tdp[i]=(md+f[i-1]-(i-mx-1>=0?f[i-mx-1]:0))%md;\n\t\t\tf[i]=(f[i-1]+dp[i])%md;\n\t\t}\n\t\tif(n-i<=mx) add(ans,(n-i)*dp[i]*2ll%md);\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// #include <algorithm>\n// #include <iostream>\n// #include <string>\n\n// using namespace std;\n\n// #define MAX_N 200000\n// #define MAX_M 200000\n// #define MOD 1000000007\n\n// #define INF 1 << 29\n\n// int N, M;\n// string S;\n\n// long long dp[MAX_N + 2], rdp[MAX_N + 2];\n\n// int all_color_is_same()\n// {\n//     long long rr = 1, bb = 1, rb = 0, br = 0;\n\n//     for ( int i = 1; i < N; i++ )\n//     {\n//         long long nrr = ( rr + rb ) % MOD;\n//         long long nbb = br;\n//         long long nrb = rr;\n//         long long nbr = ( bb + br ) % MOD;\n\n//         rr = nrr;\n//         bb = nbb;\n//         rb = nrb;\n//         br = nbr;\n//     }\n\n//     return ( rr + rb + br ) % MOD;\n// }\n\n// /**\n//  * S\n//  の先頭の文字の最小連続回数を求める。ただし連続回数が偶数のものは無視する。\n//  */\n// int min_freq()\n// {\n//     int l = 0;\n//     while ( l < M && S[0] == S[l] ) l++;\n\n//     int ans = ( l & 1 ) ? l : l + 1;\n\n//     l = 0;\n//     for ( int i = 0; i < M; i++ )\n//     {\n//         if ( S[0] == S[i] )\n//             l++;\n//         else if ( l & 1 )\n//         {\n//             ans = min( ans, l );\n//             l = 0;\n//         }\n//     }\n//     return l ? min( ans, l ) : ans;\n// }\n\n// int solve()\n// {\n//     // 一色\n//     if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n//         return all_color_is_same();\n\n//     // N が奇数\n//     if ( N & 1 ) return 0;\n\n//     int L = min_freq();\n\n//     L = ( L + 1 ) >> 1;\n//     N >>= 1;\n\n//     dp[0] = rdp[0] = 1;\n//     for ( int i = 1; i <= N + 1; i++ )\n//     {\n//         dp[i] = rdp[i - 1];\n//         if ( i - L - 1 >= 0 ) dp[i] = ( dp[i] - rdp[i - L - 1] ) % MOD;\n//         if ( dp[i] < 0 ) dp[i] += MOD;\n//         rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n//     }\n\n//     long long res = 0;\n//     for ( int i = 1; i <= L; i++ )\n//         if ( N >= i ) res = ( res + dp[N - i] * 2 * i ) % MOD;\n\n//     return res % MOD;\n// }\n\n// int main( int argc, char **argv )\n// {\n//     cin >> N >> M;\n//     cin >> S;\n\n//     int ans = solve();\n\n//     cout << ans << endl;\n\n//     return 0;\n// }\n#include <algorithm>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define MOD 1000000007\n#define INF ( 1 << 29 )\n#define LINF ( 1LL << 60 )\n#define EPS ( 1e-10 )\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nInt all( Int n )\n{ // no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for ( int i = 1; i < n; i++ )\n    {\n        Int nrr = ( rr + rb ) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = ( bb + br ) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return ( rr + rb + br ) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc( Int n, Int limit )\n{\n    dp[0] = 1;\n    rdp[0] = 1;\n    for ( int i = 1; i <= n + 1; i++ )\n    {\n        dp[i] = ( rdp[i - 1] -\n                  ( ( i - limit - 1 ) >= 0 ? rdp[i - limit - 1] : 0 ) ) %\n                MOD;\n        if ( dp[i] < 0 ) dp[i] += MOD;\n        rdp[i] = ( rdp[i - 1] + dp[i] ) % MOD;\n    }\n}\n\nInt solve( Int n, Int limit )\n{\n    if ( n % 2 == 1 ) return 0;\n    if ( limit % 2 != 1 ) exit( 1 );\n    limit = ( limit + 1 ) / 2;\n    n /= 2;\n    Int res = 0;\n    calc( n + 10, limit );\n    for ( Int i = 1; i <= limit; i++ )\n    {\n        if ( n - i >= 0 ) res = ( res + dp[n - i] * 2 * i ) % MOD;\n    }\n    if ( res < 0 ) exit( 1 );\n    return res % MOD;\n}\n\nint main()\n{\n    Int n, m;\n    string S;\n    cin >> n >> m;\n    cin >> S;\n\n    // bool allsame = true;\n    // for ( int i = 0; i < m; i++ ) allsame &= ( str[i] == str[0] );\n    // if ( allsame )\n    // {\n    //     cout << all( n ) << endl;\n    //     return 0;\n    // }\n    if ( S.find( \"R\" ) == string::npos || S.find( \"B\" ) == string::npos )\n    {\n        cout << all( n ) << endl;\n        return 0;\n    }\n\n    Int l = 0;\n    while ( S[0] == S[l] ) l++;\n    if ( l % 2 == 0 ) l++;\n    Int limit = l;\n    l = 0;\n    for ( int i = 0; i < m; i++ )\n    {\n        if ( S[i] == S[0] )\n            l++;\n        else\n        {\n            if ( l % 2 == 1 ) limit = min( limit, l );\n            l = 0;\n        }\n    }\n    cout << solve( n, limit ) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nstring S;\nll dp[202020][2][2];\nll mo=1000000007;\n\nll dp2[202020];\nll dps[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M>>S;\n\tif(S[0]=='B') {\n\t\tFORR(c,S) c='R'+'B'-c;\n\t}\n\tif(count(ALL(S),'B')==0) {\n\t\tdp[0][0][0]=dp[0][1][1]=1;\n\t\tfor(i=1;i<N;i++) {\n\t\t\t(dp[i][0][0]=dp[i-1][0][0]+dp[i-1][0][1])%=mo;\n\t\t\t(dp[i][0][1]=dp[i-1][0][0])%=mo;\n\t\t\t(dp[i][1][0]=dp[i-1][1][0]+dp[i-1][1][1])%=mo;\n\t\t\t(dp[i][1][1]=dp[i-1][1][0])%=mo;\n\t\t}\n\t\tcout<<(dp[N-1][0][0]+dp[N-1][0][1]+dp[N-1][1][0])%mo<<endl;\n\t\treturn;\n\t}\n\t\n\tassert(N%2==0);\n\tint L=0;\n\twhile(S[L]=='R') L++;\n\t\n\tif(L%2==0) L++;\n\t\n\tdp2[0]=dps[0]=dps[1]=1;\n\tfor(i=2;i<=N;i++) {\n\t\tif(i%2==0) {\n\t\t\tdp2[i]=dps[i-2];\n\t\t\tif(i-(L+1)>0) dp2[i]+=mo-dps[i-(L+1)-1];\n\t\t\tdp2[i]%=mo;\n\t\t}\n\t\t(dps[i]=dps[i-1]+dp2[i])%=mo;\n\t\t//cout<<i<<\" \"<<dp2[i]<<endl;\n\t}\n\t\n\tll ret=0;\n\tfor(i=1;i<=min(L,N-1);i++) {\n\t\t//cout<<i<<\" \"<<(i+1)<<\"*\"<<dp2[N-(i+1)]<<endl;\n\t\t(ret+=(i+1)*dp2[N-(i+1)])%=mo;\n\t}\n\tcout<<ret<<endl;\n\t\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ΔAGC033E\n#include<iostream>\n#include<cstdio>\n#include<fstream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nconst int N = 222222;\nconst int MO = 1e9+7;\nchar ch[N];\nint n,m,ans,f[N],s[N];\nint main()\n{\n\tint i,x,y,o;\n\tscanf(\"%d%d%s\",&n,&m,ch+1);\n\tfor(i=1;i<=m;i=i+1)\n\t\tif(ch[i]!=ch[1])\n\t\t\tbreak;\n\tif(i<=m){\n\t\to=i-1;\n\t\tif(o%2==0)\n\t\t\to++;\n\t\tx=1,y=0;\n\t\tfor(i=i+1;i<=m;i=i+1){\n\t\t\tif(ch[i]==ch[i-1])\n\t\t\t\tx++;\n\t\t\telse{\n\t\t\t\tif(y&&x%2==1)\n\t\t\t\t\to=min(o,x);\n\t\t\t\ty^=1;\n\t\t\t\tx=1;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tf[1]=1;\n\t\ts[1]=1;\n\t\tfor(i=2;i<=n;i=i+1){\n\t\t\tf[i]=s[i-2];\n\t\t\ts[i]=(s[i-1]+f[i])%MO;\n\t\t}\n\t\tx=1;\n\t\tfor(i=1;i<n;i=i+1)\n\t\t\tx+=(LL)f[i]*(n-i+1)%MO,x%=MO;\n\t\tcout<<x;\n\t\treturn 0;\n\t}\n\tif(n&1){\n\t\tcout<<0;\n\t\treturn 0;\n\t}\n\to++;\n\to/=2;\n\tn/=2;\n\tif(o>n)\n\t\to=n;\n\tf[1]=1;\n\ts[1]=1;\n\tfor(i=2;i<=n;i=i+1){\n\t\tx=i-o-1;\n\t\tif(x<0)\n\t\t\ty=0;\n\t\telse\n\t\t\ty=s[x];\n\t\tf[i]=(s[i-1]-y+MO)%MO;\n\t\ts[i]=(s[i-1]+f[i])%MO;\n\t}\n\tx=0;\n\tfor(i=n-o+1;i<=n;i=i+1)\n\t\tx+=(LL)f[i]*((n-i+1)*2)%MO,x%=MO;\n\tcout<<x;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n//#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int M = 1e9 + 7;\n\nvoid solve_fib(int n) {\n    vi f(n + 1);\n    f[0] = f[1] = 1;\n    for (int i = 2; i <= n; ++i) {\n        f[i] = (f[i - 1] + f[i - 2]) % M;\n    }\n    cout << (f[n] + f[n - 2]) % M;\n}\nconst int oo = 1e9 + 10;\n\nint kek(int cnt, bool & first) {\n    if (first) {\n        first = false;\n        if (cnt & 1)\n            return cnt;\n        return cnt + 1;\n    }\n    if (cnt & 1)\n        return cnt;\n    return oo;\n}\n\nvoid insum(int &a, int b) {\n    a = (a + b) % M;\n}\n\nvoid smain() {\n\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    m = s.size();\n    if (count(ALL(s), 'R') == 0 || count(ALL(s), 'B') == 0) {\n        solve_fib(n);\n        return;\n    }\n\n    vi a(m);\n    fori (i, m) {\n        a[i] = s[i] == 'R';\n    }\n\n    vi min_sz(2, oo);\n    int cur = -1;\n    int cnt = 0;\n    bool first = true;\n    for (auto c : a) {\n        if (c != cur) {\n            if (cur != -1) {\n                inmin(min_sz[cur], kek(cnt, first));\n            }\n            cur = c;\n            cnt = 1;\n        } else {\n            cnt++;\n        }\n    }\n    vvi f(2);\n    fori (z, 2) {\n        vvi dp(2, vi(n, 0));\n        vvi p(2, vi(n, 0));\n        p[!z][0] = dp[!z][0] = 1;\n        for (int i = 1; i < n; ++i) {\n            fori (zz, 2) {\n                if (min_sz[zz] == oo) {\n                    dp[zz][i] = (p[!zz][i - 1] + (i - 2 >= 0 ? p[!zz][i - 2] : 0));\n                } else {\n                    int j = i - min_sz[zz];\n                    dp[zz][i] = (p[!zz][i - 1] - (j - 2 >= 0 ? p[!zz][j - 2] : 0) + M) % M;\n                }\n            }\n            fori (zz, 2) {\n                p[zz][i] = (dp[zz][i] + (i - 2 >= 0 ? p[zz][i - 2] : 0)) % M;\n            }\n        }\n        f[z] = dp[z];\n    }\n    int ans = 0;\n    fori (z, 2) {\n        for (int sz = 1; sz <= min(n - 1, min_sz[z]); sz += 1 + (min_sz[z] != oo)) {\n            insum(ans, (ll)f[!z][n - sz] * sz % M);\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of Allah. Ya ali!\n#include<bits/stdc++.h>\n#define double long double\n#define debug(x)//  cerr << #x << \" = \" << x << endl\ntypedef long long ll;\nconst ll MAX_N = 2e5+100;\nconst ll MOD = 1e9+7;\nusing namespace std;\n\nll dp[MAX_N];\nll sum[MAX_N];\nint n,m;\n\nint main()\n{\n    cin >> n >> m;\n    if (n==2)\n        return cout << 2,0;\n    string s;\n    cin >> s;\n    if (s[0]=='B')\n    {\n        for(int i = 0;i<m;++i)\n        {\n            if (s[i]=='B')\n                s[i] = 'R';\n            else\n                s[i] = 'B';\n        }\n    }\n    bool ok = false;\n    for(int i = 0;i<m;++i)\n        ok |= (s[i]=='B');\n    if (!ok)\n    {\n        dp[1] = 1;\n        dp[3] = 1;\n        sum[1] = 1;\n        sum[2] = 1;\n        sum[3] = 2;\n        for(int i = 4;i<=n+1;++i)\n        {\n            dp[i] = sum[i-2];\n            sum[i] = (sum[i-1]+dp[i])%MOD;\n        }\n        ll ans = dp[n+1]+1;\n        for(ll i = 1;i<n;++i)\n        {\n            ans += (i*dp[n-i])%MOD;\n            ans %= MOD;\n        }\n        cout << ans;\n        return 0;\n    }\n    for(int i = m-1;i>=0;--i)\n    {\n        if (s[i]=='B')\n        {\n            m = i+1;\n            break;\n        }\n    }\n    vector<int> vc;\n    int cnt = 0;\n    for(int i = 0;i<m;++i)\n    {\n        if (s[i]=='B')\n        {\n            if (cnt)\n                vc.push_back(cnt);\n            cnt = 0;\n        }\n        else\n            cnt++;\n    }\n    int mn = 1e9;\n    if (vc[0]%2==0)\n        mn = vc[0]+1;\n    for(auto x:vc)\n    {\n        if (x&1)\n            mn = min(mn,x);\n    }\n    int lim = mn;\n    dp[1] = 1;\n    dp[3] = 1;\n    for(int i = 5;i<=n;i+=2)\n    {\n        dp[i] = (dp[i-2]*2ll)%MOD;\n        if (i>=lim+3)\n            dp[i] = (dp[i]-dp[i-lim-3]+MOD+MOD)%MOD;\n    }\n    ll ans = 0;\n    for(ll i = 1;i<=min(n-1,lim);i+=2)\n    {\n        ans += ((i+1ll)*dp[n-i])%MOD;\n        ans %= MOD;\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n;i++){\n        dp[i-1] = dp[i];\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)\n            tmp[i] = dp[n-i];\n    }\n    for(int i = limit-1;i >= 0;i--){\n        tmp[i] += tmp[i+1];\n        tmp[i] %= MOD;\n    }\n    for(int i = 1;i <= limit;i++){\n        res = (res + tmp[i] * 2) % MOD;\n    }\n    return res;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i <= n;i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n    d=0;int f=1;char c=getchar();\n    for(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n    for(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n    d*=f;\n}\n\n/************************************************/\n#define Md 1000000007\n#define MN 200005\nint n,m;\nchar c[MN];\nlg Pow(lg x,lg y){\n    lg res=1;for(;y;y>>=1,x=x*x%Md)if(y&1)res=res*x%Md;return res;\n}\nint Fix(int x){\n    if(x<0)return x+Md;\n    if(x>=Md)return x-Md;\n    x%=Md;\n    return x;\n}\nint dp[MN],tmp[MN];\nint miu[MN];\nint main(){\n    read(n);read(m);\n    scanf(\"%s\",c+1);\n    miu[1]=1;\n    for(int i=1;i<MN;++i){\n\tfor(int j=i+i;j<MN;j+=i){\n\t    miu[j]-=miu[i];\n\t}\n    }\n    char Hd=c[1];\n    int cnt=0,mx;\n    for(int i=1;i<=m;++i){\n\tif(c[i]==Hd)++cnt;\n\telse break;\n    }\n    if(cnt&1)mx=cnt;else mx=cnt+1;\n    if(n&1){\n\tif(cnt!=m)return puts(\"0\"),0;\n\tint res=0;\n\ttmp[0]=tmp[1]=1;\n\tdp[0]=1;\n\tmx+=2;\n\tfor(int i=1;i<=n;++i){\n\t    dp[i]=(i>=2?tmp[i-2]:0);\n\t    tmp[i]=Fix(tmp[i-1]+dp[i]);\n\t    if(n%i==0)res=Fix(res+(ll)miu[n/i]*dp[i]*n);\n\t}\n\tprintf(\"%d\",res+1);\n\treturn 0;\n    }\n    int res=(cnt==m);\n    cnt=0;\n    for(int i=1;i<=m;++i)\n    {\n\tif(c[i]==Hd)++cnt;\n\telse\n\t{\n\t    if(cnt&1)mx=min(mx,cnt);\n\t    cnt=0;\n\t}\n    }\n    //for(int i=1;i<=5;++i)cerr<<miu[i]<<' ';cerr<<endl;\n    tmp[0]=tmp[1]=1;\n    dp[0]=1;\n    mx+=2;\n    for(int i=2;i<n;i+=2)\n    {\n\tdp[i]=Fix(tmp[i-1]-(mx>i?0:tmp[i-mx]));\n\ttmp[i]=tmp[i+1]=Fix(tmp[i-2]+dp[i]);\n\tif(n-i<=mx)\n\t{\n\t    res=(res+dp[i]*(n-i)%Md)%Md;\n\t}\n    }\n    cout<<res;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <climits>\n#include <set>\n#include <algorithm>\n#include <unordered_map>\n#include <queue>\n#include <iomanip>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <chrono>\n#include <ctime>\n#include <cassert>\n#include <bitset>\n#include <iterator>\n#include <cmath>\n#include <stack>\n#include <random>\n\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define debug(x) cerr << #x << \": \" << x << \", \"\n#define debugln(x) cerr << #x << \": \" << x << '\\n'\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\n\n//constexpr ll mod = 998244353;\nconstexpr ll mod = 1e9+7;\nconst double PI = acos(-1.0);\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nsigned main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m; cin >> n >> m;\n  string s; cin >> s;\n\n  char c0 = s[0];\n  bool same = true;\n  rep(i, m) {\n    if (s[i] != c0) {\n      same = false;\n      break;\n    }\n  }\n  \n  if (same) {\n    // 0: s[0] = c[0] && s[i] = c[0]\n    // 1: s[0] = c[0] && s[i] != c[0]\n    // 2: s[0] != c[0] && s[i] = c[0]\n    // 3: s[0] != c[0] && s[i] != c[0]\n    vector<ll> dp1(4); \n    vector<ll> dp2(4);\n    dp1[0] = 1;\n    dp1[3] = 1;\n    for(int i=1; i<n-1; i++) {\n      dp2[0] = dp1[0] + dp1[1];\n      dp2[0] %= mod;\n      dp2[1] = dp1[0];\n      dp2[2] = dp1[2] + dp1[3];\n      dp2[2] %= mod;\n      dp2[3] = dp1[2];\n      rep(j, 4) {\n        dp1[j] = dp2[j];\n        //debug(j);debugln(dp1[j]);\n      }\n    }\n    ll ans = 0;\n    ans += dp1[0] + dp1[1];\n    ans += dp1[0];\n    ans += dp1[2] + dp1[3];\n    cout << ans%mod << endl;\n    return 0;\n  }\n\n  if (n%2 != 0) {\n    cout << 0 << endl;\n    return 0;\n  }\n\n  char before = c0;\n  int cnt = 0;\n  int minfirst = INT_MAX;\n  int minodd = INT_MAX;\n  rep(i, m) {\n    if (s[i] == c0) {\n      cnt++;\n    } else {\n      if (minfirst == INT_MAX) {\n        chmin(minfirst, cnt);\n      }\n      if (cnt&1) {\n        chmin(minodd, cnt);\n      }\n      cnt = 0;\n    }\n  }\n\n  cnt = INT_MAX;\n  if (minfirst%2 == 0) {\n    chmin(cnt, minfirst+1);\n  }\n  chmin(cnt, minodd);\n  int p = (cnt-1)/2;\n  //debugln(p);\n  n = n/2;\n  \n  vector<ll> dp(n+1);\n  vector<ll> rdp(n+1);\n  dp[1] = 1; rdp[1] = 1;\n  dp[2] = 1; rdp[2] = 2;\n  for(int i=3; i<=n; i++) {\n    dp[i] = rdp[i-1] - rdp[max(0, i-p-2)] + mod;\n    dp[i] %= mod;\n    rdp[i] = rdp[i-1] + dp[i];\n    rdp[i] %= mod;\n    //debug(i); debugln(dp[i]);\n  }\n\n  ll ans = 0;\n  for(ll L=0; L<=p && L<n; L++) {\n    //debug(L); debugln(dp[max(0LL, n-L)]);\n    ans += dp[max(0LL, n-L)]*(L+1)*2;\n    ans %= mod;\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\nusing namespace std;\n#define SIZE 262144\ntypedef long long ll;\nll mod = 1000000007;\nclass BIT\n{\npublic:\n\tll bit[SIZE + 1];\n\tvoid add(int a, ll b)\n\t{\n\t\ta+=120000;\n\t\tfor (;;)\n\t\t{\n\t\t\tbit[a] += b;\n\t\t\tbit[a] %= mod;\n\t\t\ta += a&-a;\n\t\t\tif (a > SIZE)return;\n\t\t}\n\t}\n\tll get(int a)\n\t{\n\t\ta+=120000;\n\t\tll ret = 0;\n\t\tfor (;;)\n\t\t{\n\t\t\tret += bit[a];\n\t\t\ta -= a&-a;\n\t\t\tif (a == 0)return ret%mod;\n\t\t}\n\t}\n};\nBIT bi;\nll dp[202020];\nll sub[2][202020][2];\nint main()\n{\n\tint num, len;\n\tscanf(\"%d%d\", &num, &len);\n\tstring s;\n\tcin >> s;\n\tif (s[0] == 'B')\n\t{\n\t\tfor (int i = 0; i < s.size(); i++)s[i] = 'R' + 'B' - s[i];\n\t}\n\tint mini = 1000000000, cnt = 0;\n\tbool ff = false;\n\tfor (int i = 0; i < s.size(); i++)\n\t{\n\t\tif (s[i] == 'R')cnt++;\n\t\telse\n\t\t{\n\t\t\tif (!ff)\n\t\t\t{\n\t\t\t\tif (cnt % 2 == 0)mini = min(mini, cnt + 1);\n\t\t\t\telse mini = min(mini, cnt);\n\t\t\t\tff = true;\n\t\t\t}\n\t\t\telse if (cnt % 2 == 1)mini = min(mini, cnt);\n\t\t}\n\t}\n\tif (!ff)\n\t{\n\t\tsub[0][0][0] = sub[1][0][1] = 1;\n\t\tfor (int i = 0; i < 2; i++)\n\t\t{\n\t\t\tfor (int j = 1; j < num; j++)\n\t\t\t{\n\t\t\t\tsub[i][j][0] = (sub[i][j - 1][0] + sub[i][j - 1][1]) % mod;\n\t\t\t\tsub[i][j][1] = sub[i][j - 1][0];\n\t\t\t}\n\t\t}\n\t\tll r = sub[0][num - 1][0] + sub[0][num - 1][1] + sub[1][num - 1][0];\n\t\tprintf(\"%lld\\n\", r%mod);\n\t\treturn 0;\n\t}\n\tif (num % 2 == 1)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tmini = (mini + 1) / 2;\n\tnum /= 2;\n\tmini = min(mini, num);\n\tdp[0] = 1;\n\tbi.add(0, 1);\n\tfor (int i = 1; i <= num; i++)\n\t{\n\t\tdp[i] = (bi.get(i - 1) - bi.get(i - mini - 1) + mod) % mod;\n\t\tbi.add(i, dp[i]);\n\t\t//printf(\"%d %lld\\n\", i, dp[i]);\n\t}\n\tll r = 0;\n\tfor (int i = 1; i <= mini; i++)r = (r + dp[num - i] * i * 2) % mod;\n\tprintf(\"%lld\\n\", r);\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef xay5421\n#define D(...) fprintf(stderr,__VA_ARGS__)\n#else\n#define D(...) ((void)0)\n#define NDEBUG\n#endif\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,INF=0X3F3F3F3F,P=1e9+7;\nint n,m,f[N];\nchar s[N];\nvoid sol1(){\n\tf[1]=1;\n\trep(i,2,n+1)f[i]=(f[i-1]+f[i-2])%P;\n\tprintf(\"%d\\n\",(f[n-1]+f[n+1])%P);\n}\nvoid sol2(int n,int lim){\n\tD(\"n=%d lim=%d\\n\",n,lim);\n\tint cur=0;\n\tfor(int i=1;i<=n;++i){\n\t\tif(i>lim+1)cur=(cur-f[i-lim-1]+P)%P;\n\t\tf[i]=(cur+(i<=lim?i:0))%P;\n\t\tcur=(cur+f[i])%P;\n\t}\n\tprintf(\"%lld\\n\",2LL*f[n]%P);\n}\nint main(){\n\tscanf(\"%d%d%s\",&n,&m,s);\n\tif(s[0]=='B'){\n\t\trep(i,0,m-1)s[i]=(s[i]=='R'?'B':'R');\n\t}\n\tif(count(s,s+m,s[0])==m){\n\t\tsol1();\n\t\treturn 0;\n\t}\n\tif(n&1)puts(\"0\"),exit(0);\n\tbool fir=1;\n\tint mn=INF;\n\tfor(int i=0,j;i<m;i=j){\n\t\tj=i+1;\n\t\twhile(j<m&&s[j]==s[i])++j;\n\t\tif(s[i]=='R'&&(fir||(j-i)%2))mn=min(mn,j-i),fir=0;\n\t}\n\tsol2(n/2,mn/2+1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define Md 1000000007\n#define MN 200005\nint n,m;\nchar c[MN];\nlg Pow(lg x,lg y){\n\tlg res=1;for(;y;y>>=1,x=x*x%Md)if(y&1)res=res*x%Md;return res;\n}\nint Fix(int x){\n\tif(x<0)return x+Md;\n\tif(x>=Md)return x-Md;\n\treturn x;\n}\nint dp[MN],tmp[MN];\nint miu[MN];\nint main(){\n\tread(n);read(m);\n\tscanf(\"%s\",c+1);\n\tmiu[1]=1;\n\tfor(int i=1;i<MN;++i){\n\t\tfor(int j=i+i;j<MN;j+=i){\n\t\t\tmiu[j]-=miu[i];\n\t\t}\n\t}\n\tchar Hd=c[1];\n\tint cnt=0,mx;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse break;\n\t}\n\tif(cnt&1)mx=cnt;else mx=cnt+1;\n\tif(n&1){\n\t\tif(cnt!=m)return puts(\"0\"),0;\n\t\tint res=0;\n\t\ttmp[0]=tmp[1]=1;\n\t\tdp[0]=1;\n\t\tmx+=2;\n\t\tif(n>2)res=n;\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tdp[i]=(i>=2?tmp[i-2]:0);\n\t\t\ttmp[i]=Fix(tmp[i-1]+dp[i]);\n\t\t\tif(i<n-1)res=Fix(res+1ll*dp[i]*(n-i)%Md);\n\t\t\t//cerr<<i<<' '<<dp[i]<<' '<<n<<' '<<i<<' '<<n/i<<endl;\n\t\t}\n\t\tprintf(\"%d\",res+1);\n\t\treturn 0;\n\t}\n\tint res=(cnt==m);\n\tcnt=0;\n\tfor(int i=1;i<=m;++i){\n\t\tif(c[i]==Hd)++cnt;\n\t\telse{\n\t\t\tif(!cnt)continue;\n\t\t\tif(cnt&1)mx=min(mx,cnt);\n\t\t\tcnt=0;\n\t\t}\n\t}\n\t//for(int i=1;i<=5;++i)cerr<<miu[i]<<' ';cerr<<endl;\n\ttmp[0]=tmp[1]=1;\n\tdp[0]=1;\n\tmx+=2;\n\tif(n<mx)res+=n;\n\tfor(int i=2;i<=n;i+=2){\n\t\tdp[i]=Fix(tmp[i-1]-(mx>i?0:tmp[i-mx]));\n\t\ttmp[i]=tmp[i+1]=Fix(tmp[i-1]+dp[i]);\n\t\t//cerr<<dp[i]<<' '<<i<<endl;\n\t\tif((n-i)%2==0&&n-i<mx)res=Fix(res+1ll*dp[i]*(n-i)%Md);\n\t}\n\tcout<<res;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// 入力\nlong long mod = 1000000007;\nlong long N, M;\nstring S;\n\n// その他\nlong long fib[1 << 19];\nlong long dp[1 << 19], ru[1 << 19];\nlong long ret[1 << 19];\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 32; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nlong long Div(long long p, long long q, long long m) {\n\treturn (p * modpow(q, m - 2, m)) % m;\n}\n\nlong long solve(long long n, long long r) {\n\tfor (int i = 0; i <= N; i++) dp[i] = 0;\n\tfor (int i = 0; i <= N; i++) ru[i] = 0;\n\tfor (int i = 1; i <= r / 2; i++) dp[i] = 1LL * (i * 2);\n\tfor (int i = 1; i <= n / 2; i++) {\n\t\tlong long v = ru[i - 1]; if (i - (r / 2) - 1 >= 0) v -= ru[i - (r / 2) - 1];\n\t\tv = (v + mod) % mod;\n\t\tdp[i] += v; dp[i] %= mod;\n\t\tru[i] = (dp[i] + ru[i - 1]) % mod;\n\t}\n\t\n\tlong long val = dp[n / 2];\n\treturn val;\n}\n\nint main() {\n\tcin >> N >> M >> S;\n\n\t// 判定\n\tbool flag = false;\n\tfor (int i = 0; i < S.size() - 1; i++) {\n\t\tif (S[i] != S[i + 1]) flag = true;\n\t}\n\n\t// 特殊\n\tif (flag == false) {\n\t\tfib[0] = 1;\n\t\tfib[1] = 1;\n\t\tfor (int i = 2; i <= N; i++) fib[i] = (fib[i - 1] + fib[i - 2]) % mod;\n\t\tcout << (fib[N] + fib[N - 2]) % mod << endl;\n\t\treturn 0;\n\t}\n\n\t// 奇数\n\tif (N % 2 == 1) {\n\t\tcout << \"0\" << endl;\n\t\treturn 0;\n\t}\n\n\t// 偶数\n\tif (S[0] == 'B') {\n\t\tfor (int i = 0; i < S.size(); i++) {\n\t\t\tif (S[i] == 'B') S[i] = 'R';\n\t\t\telse S[i] = 'B';\n\t\t}\n\t}\n\tint MaxLength = N, cur = 0;\n\tfor (int i = 0; i < S.size(); i++) {\n\t\tif (S[i] == 'R') cur++;\n\t\telse {\n\t\t\tMaxLength = min(MaxLength, cur);\n\t\t\tcur = 0;\n\t\t}\n\t}\n\tMaxLength += 2;\n\n\tvector<long long> E;\n\tfor (int i = 1; i <= N / 2; i++) {\n\t\tif ((N / 2) % i == 0) E.push_back(i);\n\t}\n\tfor (int i = E.size() - 1; i >= 0; i--) {\n\t\tlong long d1 = (N / E[i]);\n\t\tlong long d2 = MaxLength;\n\t\tret[i] = solve(d1, d2);\n\t\tfor (int j = i + 1; j < E.size(); j++) {\n\t\t\tif (E[j] % E[i] == 0) { ret[i] -= ret[j]; ret[i] = (ret[i] + mod) % mod; }\n\t\t}\n\t}\n\n\tlong long FinalAns = 0;\n\tfor (int i = 0; i < E.size(); i++) {\n\t\tFinalAns += 1LL * ret[i];\n\t\tFinalAns %= mod;\n\t}\n\tcout << FinalAns << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass finite_field {\n\tconst int md;\n\tconst int sz;\n\tvector<int> fct, fnv;\n\tpublic :\n\t\tfinite_field(\n\t\t\t\tconst int md,\n\t\t\t\tconst int init_factorial_size = 0\n\t\t\t) :\n\t\t\tmd(md), sz(init_factorial_size),\n\t\t\tfct(sz), fnv(sz)\n\t\t\t{\n\t\t\t\tif (sz) {\n\t\t\t\t\tfct[0] = 1;\n\t\t\t\t\tfor (int i = 1; i < sz; i++) fct[i] = prod(fct[i - 1], i);\n\t\t\t\t\tfnv[sz - 1] = inv(fct[sz - 1]);\n\t\t\t\t\tfor (int i = sz - 1; i >= 1; i--) fnv[i - 1] = prod(fnv[i], i);\n\t\t\t\t}\n\t\t\t}\n\t\tinline void add (int& a, const int b) const {\n\t\t\ta += b;\n\t\t\tif (a >= md) a -= md;\n\t\t}\n\t\tinline void sub (int& a, const int b) const {\n\t\t\ta -= b;\n\t\t\tif (a < 0) a += md;\n\t\t}\n\t\ttemplate<class... A> inline int sum (A... args) const {\n\t\t\tint ret = 0;\n\t\t\tfor (int a : initializer_list<int>{args...}) {\n\t\t\t\tadd(ret, a);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tinline int dif (int a, int b) const {\n\t\t\tsub(a, b);\n\t\t\treturn a;\n\t\t}\n\t\ttemplate<class... A> inline int prod (A... args) const {\n\t\t\tlong long ret = 1;\n\t\t\tfor (int a : initializer_list<int>{args...}) {\n\t\t\t\tret *= a;\n\t\t\t\tret %= md;\n\t\t\t}\n\t\t\treturn (int)ret;\n\t\t}\n\t\tvoid mul (int& a, int b) const {\n\t\t\ta = prod(a, b);\n\t\t}\n\t\tinline int inv (int a) const {\n\t\t\ta %= md; if (a < 0) a += md;\n\t\t\tint b = md, u = 0, v = 1;\n\t\t\twhile (a) {\n\t\t\t\tint t = b / a;\n\t\t\t\tb -= a * t; swap(a, b);\n\t\t\t\tu -= v * t; swap(u, v);\n\t\t\t}\n\t\t\tassert(b == 1);\n\t\t\tif(u < 0) u += md;\n\t\t\treturn u;\n\t\t}\n\t\tinline int quat (int a, int b) const {\n\t\t\treturn prod(a, inv(b));\n\t\t}\n\t\tvoid div (int& a, int b) const {\n\t\t\ta = quat(a, b);\n\t\t}\n\t\tinline int pow (int a, long long b) {\n\t\t\tint ret = 1;\n\t\t\tfor (; b; b >>= 1) {\n\t\t\t\tif (b & 1) mul(ret, a);\n\t\t\t\ta = prod(a, a);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tinline int binom (int n, int k) const {\n\t\t\tassert(0 <= n && n < sz);\n\t\t\tif (k < 0 || n < k) return 0;\n\t\t\treturn prod(fct[n], fnv[k], fnv[n - k]);\n\t\t}\n};\nint main() {\n\tcin.tie(0); cin.sync_with_stdio(false);\n\tint n, m; string s;\n\tcin >> n >> m >> s;\n\tfinite_field fld(1e9 + 7);\n\tif (s == string(m, s[0])) {\n\t\tvector<int> dp(n + 1, 0);\n\t\tdp[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfld.add(dp[i], dp[i - 1]);\n\t\t\tfld.add(dp[i], dp[i - 2]);\n\t\t}\n\t\tint ret = 0;\n\t\tfld.add(ret, dp[n]);\n\t\tfld.add(ret, fld.prod(dp[n - 1], 2));\n\t\tcout << ret << endl;\n\t\treturn 0;\n\t}\n\tif (n % 2 == 1) {\n\t\tcout << 0 << endl;\n\t\treturn 0;\n\t}\n\tvector<int> seqs;\n\tint t = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (s[i] == s[0]) {\n\t\t\t++t;\n\t\t} else {\n\t\t\tseqs.push_back(t);\n\t\t\tt = 0;\n\t\t}\n\t}\n\tint bound = seqs[0];\n\tif (!(bound & 1)) {\n\t\t++bound;\n\t}\n\tfor (int it = 1; it < (int) seqs.size(); it++) {\n\t\tif (seqs[it] % 2 == 1) {\n\t\t\tbound = min(bound, seqs[it]);\n\t\t}\n\t}\n\tn /= 2;\n\tbound /= 2;\n\tint ret = 0;\n\tif (bound == 0) {\n\t\tret = 1;\n\t} else {\n\t\tvector<int> dp(n + 1);\n\t\tdp[1] = 1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tdp[i + 1] = fld.prod(2, dp[i]);\n\t\t\tif (i - bound - 1 >= 0) {\n\t\t\t\tfld.sub(dp[i + 1], dp[i - bound - 1]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfld.sub(dp[i + 1], dp[i]);\n\t\t}\n\t\tfor (int i = n - 1 - bound; i < n; i++) {\n\t\t\tfld.add(ret, fld.prod(dp[i + 1], n - i));\n\t\t}\n\t}\n\tcout << fld.prod(2, ret) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=2e5+5,mod=1e9+7;\nint Mn(int a,int b){return a<b?a:b;}\nint upt(int x){while(x>=mod)x-=mod;while(x<0)x+=mod;return x;}\nint n,m,lm,dp[N],sm[N],ans,g[N];\nchar s[N];\nvoid solve()\n{\n  g[0]=sm[0]=1;\n  for(int i=1;i<=n;i++)\n  {\n    if(i>=2)g[i]=sm[i-2];\n    sm[i]=upt(sm[i-1]+g[i]);\n  }\n  int ans=1;//ans=1 for all one color\n  for(int i=2;i<=n;i++)\n    ans=(ans+(ll)i*g[n-i])%mod;\n  printf(\"%d\\n\",ans);\n}\nint main()\n{\n  scanf(\"%d%d\",&n,&m);\n  scanf(\"%s\",s+1); bool fg=0;\n  for(int i=1;i<=m;i++)if(s[i]!=s[1]){fg=1;break;}\n  if(!fg){solve();return 0;}\n  if(n&1){puts(\"0\");return 0;}\n  lm=n+1;\n  for(int i=1;i<=m;i++)if(s[i]==s[1])//== not !=\n  {\n    int j=i;\n    while(j+1<=m&&s[j+1]==s[j])j++;\n    swap(i,j); j=i-j+1;\n    if(i-j==0) lm=Mn(lm,j+((j&1)==0));\n    else if((j&1)&&i!=m)lm=Mn(lm,j);//i!=m not lst\n    //else if((j&1)&&i!=lst)lm=Mn(lm,j);\n  }\n  n>>=1; lm=(lm+1)>>1; dp[0]=sm[0]=1;\n  for(int i=1;i<=n;i++)\n  {\n    dp[i]=sm[i-1]; if(i>lm)dp[i]=upt(dp[i]-sm[i-lm-1]);\n    sm[i]=upt(sm[i-1]+dp[i]);\n  }\n  int ans=0;\n  for(int i=1;i<=lm;i++)//lm not n\n    ans=(ans+(ll)i*2*dp[n-i])%mod;\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200100,mod=1000000007;\ntypedef long long ll;\nint f[N],sum[N],n,m;\nchar s[N];\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>m>>(s+1);\n\tint mn=max(n,m)+1,sz=0,flag=0;\n\tfor(int i=1;i<=m;++i)\t\n\t\tif(s[i]==s[1])++sz;\n\t\telse{\n\t\t\tif(sz&1)mn=min(mn,sz);\n\t\t\telse if(sz&&!flag)mn=min(mn,sz+1);\n\t\t\tsz=0;flag=1;\n\t\t}\n\tint L=0,R=0;\n\tif(flag){\n\t\tif(n&1){\n\t\t\tcout<<0<<'\\n';\n\t\t\treturn 0;\n\t\t}\n\t\tn/=2;L=1;R=min(n,(mn+1)/2);\n\t}else L=2,R=n;\n\tf[0]=sum[0]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tf[i]=sum[i-L];if(i>R)f[i]=(f[i]-sum[i-R-1]+mod)%mod;\n\t\tsum[i]=(sum[i-1]+f[i])%mod;\n\t}\n\tint ans=0;\n\tfor(int i=L;i<=R;++i)ans=(ans+(ll)i*f[n-i])%mod;\n\tif(flag)ans=ans*2%mod;else ans=(ans+1)%mod;\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\n\n\ntemplate<int MOD> struct Fp {\n    long long val;\n    constexpr Fp(long long v = 0) noexcept : val(v % MOD) {\n        if (val < 0) v += MOD;\n    }\n    constexpr int getmod() { return MOD; }\n    constexpr Fp operator - () const noexcept {\n        return val ? MOD - val : 0;\n    }\n    constexpr Fp operator + (const Fp& r) const noexcept { return Fp(*this) += r; }\n    constexpr Fp operator - (const Fp& r) const noexcept { return Fp(*this) -= r; }\n    constexpr Fp operator * (const Fp& r) const noexcept { return Fp(*this) *= r; }\n    constexpr Fp operator / (const Fp& r) const noexcept { return Fp(*this) /= r; }\n    constexpr Fp& operator += (const Fp& r) noexcept {\n        val += r.val;\n        if (val >= MOD) val -= MOD;\n        return *this;\n    }\n    constexpr Fp& operator -= (const Fp& r) noexcept {\n        val -= r.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr Fp& operator *= (const Fp& r) noexcept {\n        val = val * r.val % MOD;\n        return *this;\n    }\n    constexpr Fp& operator /= (const Fp& r) noexcept {\n        long long a = r.val, b = MOD, u = 1, v = 0;\n        while (b) {\n            long long t = a / b;\n            a -= t * b; swap(a, b);\n            u -= t * v; swap(u, v);\n        }\n        val = val * u % MOD;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n    constexpr bool operator == (const Fp& r) const noexcept {\n        return this->val == r.val;\n    }\n    constexpr bool operator != (const Fp& r) const noexcept {\n        return this->val != r.val;\n    }\n    friend constexpr ostream& operator << (ostream &os, const Fp<MOD>& x) noexcept {\n        return os << x.val;\n    }\n    friend constexpr istream& operator >> (istream &is, Fp<MOD>& x) noexcept {\n        return is >> x.val;\n    }\n    friend constexpr Fp<MOD> modpow(const Fp<MOD> &a, long long n) noexcept {\n        if (n == 0) return 1;\n        auto t = modpow(a, n / 2);\n        t = t * t;\n        if (n & 1) t = t * a;\n        return t;\n    }\n};\n\n\n\n// 二項係数ライブラリ\ntemplate<class T> struct BiCoef {\n    vector<T> fact_, inv_, finv_;\n    constexpr BiCoef(int n) noexcept : fact_(n, 1), inv_(n, 1), finv_(n, 1) {\n        int MOD = fact_[0].getmod();\n        for(int i = 2; i < n; i++){\n            fact_[i] = fact_[i-1] * i;\n            inv_[i] = -inv_[MOD%i] * (MOD/i);\n            finv_[i] = finv_[i-1] * inv_[i];\n        }\n    }\n    constexpr T com(int n, int k) const noexcept {\n        if (n < k || n < 0 || k < 0) return 0;\n        return fact_[n] * finv_[k] * finv_[n-k];\n    }\n    constexpr T fact(int n) const noexcept {\n        if (n < 0) return 0;\n        return fact_[n];\n    }\n    constexpr T inv(int n) const noexcept {\n        if (n < 0) return 0;\n        return inv_[n];\n    }\n    constexpr T finv(int n) const noexcept {\n        if (n < 0) return 0;\n        return finv_[n];\n    }\n};\n\n\n\nconst int MAX = 501010;\nconst int MOD = 1000000007;\nusing mint = Fp<MOD>;\n\nint N, M;\nstring S;\n\nmint solve() {\n    BiCoef<mint> bc(MAX);\n    if (S[0] == 'R') {\n        for (auto &c : S) {\n            if (c == 'R') c = 'B';\n            else c = 'R';\n        }\n    }\n    vector<int> nums;\n    for (int i = 0; i < M;) {\n        int j = i+1;\n        while (j < M && S[j] == S[i]) ++j;\n        nums.push_back(j-i);\n        i = j;\n    }\n    if (nums.size() > 1 && N % 2 == 1) return 0;\n\n    int minv = 1, maxv = N;\n    if (nums.size() == 1) minv = 2, maxv = N;\n    else {\n        N /= 2;\n        maxv = nums[0] / 2 + 1;\n        for (int i = 0; i+1 < nums.size(); i += 2) {\n            if (nums[i] & 1) maxv = min(maxv, nums[i]);\n        }\n    }\n    //COUT(maxv); COUT(N);\n\n    vector<mint> dp(N+1, 0), sdp(N+2, 0);\n    dp[0] = 1, sdp[1] = 1;\n    for (int i = 1; i <= N; ++i) {\n        dp[i] = sdp[max(0, i + 1 - minv)] - sdp[max(0, i - maxv)];\n        sdp[i+1] = sdp[i] + dp[i];\n\n        //cout << i << \": \" << dp[i] << endl;\n    }\n    mint res = 0;\n    if (nums.size() == 1) {\n        for (int r = minv; r <= min(maxv, N); ++r) res += dp[N-r] * r;\n        res += 1; // all B\n    }\n    else {\n        for (int r = minv; r <= min(maxv, N); ++r) res += dp[N-r] * r * 2;\n    }\n    return res;\n}\n\nint main() {     \n    while (cin >> N >> M >> S) {\n        cout << solve() << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst int maxn = 210000;\nconst i64 P = 1000000000 + 7;\ni64 dp[2][2][maxn];\n\nvoid add(i64 &x, i64 y) {\n    x += y;\n    x %= P;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int n, l;\n    string s;\n    cin >> n >> l >> s;\n    char c0 = s[0], c1 = c0 ^ 'R' ^ 'B';\n    if (s == string(l, c0)) {\n        forn(i, 2) dp[i][i][1] = 1;\n        for1(i, n - 1) forn(f, 2) forn(j, 2) forn(k, 2) {\n            if (j && k) continue;\n            add(dp[f][k][i + 1], dp[f][j][i]);\n        }\n        i64 ans = 0;\n        forn(f, 2) forn(j, 2) {\n            if (f && j) continue;\n            add(ans, dp[f][j][n]);\n        }\n        cout << ans << '\\n';\n        return 0;\n    }\n\n    if (n % 2) {\n        cout << 0 << '\\n';\n        return 0;\n    }\n\n    vector<pair<int, char> > cl;\n    pii p = {1, c0};\n    for1(i, n - 1) {\n        if (s[i] == p.se) ++p.fi;\n        else cl.pb(p), p = {1, s[i]};\n    }\n\n    int ub = n / 2;\n    if (cl[0].fi % 2 == 0) ub = cl[0].fi + 1;\n    for (auto w: cl) if (w.se == c0 && w.fi % 2) uin(ub, w.fi);\n    ub /= 2;\n\n    vi64 vals(n / 2 + 1), svals(n / 2 + 2);\n    vals[0] = 1;\n    svals[1] = 1;\n//    cerr << ub << '\\n';\n    for1(i, n / 2) {\n        vals[i] = svals[i] - svals[max(i - ub - 1, 0)];\n        vals[i] %= P;\n//        cerr << i << ' ' << vals[i] << '\\n';\n        svals[i + 1] = (svals[i] + vals[i]) % P;\n    }\n\n    i64 ans = vals[n / 2];\n    for1(i, ub) if (i + 1 <= n / 2) add(ans, vals[n / 2 - i - 1] * i);\n    ans *= 2;\n    ans %= P;\n    if (ans < 0) ans += P;\n    cout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nusing namespace std;\n\n#define rep(i, a, b) for(int i = (a); i < int(b); ++i)\n#define rrep(i, a, b) for(int i = (a) - 1; i >= int(b); --i)\n#define trav(it, v) for(auto &it : (v))\n#define all(v) (v).begin(), (v).end()\n#define what_is(x) cerr << #x << \" is \" << x << endl;\n#define sz(x) (int)(x).size()\n\ntypedef double fl;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\n\nint main(){\n\tios::sync_with_stdio(0);\n    int N, M;\n    cin >> N >> M;\n    string S;\n    cin >> S;\n    if (S[0] == 'B') {\n        rep(i,0,M) {\n            if (S[i] == 'R')\n                S[i] = 'B';\n            else\n                S[i] = 'R';\n        }\n    }\n    bool anyB = false;\n    int maxRInRow = 0;\n    int rInRow = 0;\n    rep(i,0,M) {\n        if (S[i] == 'B') {\n            if (rInRow%2) {\n                maxRInRow = max(maxRInRow, rInRow);\n            }\n            if (!anyB && rInRow%2 == 0) {\n                maxRInRow = max(maxRInRow, rInRow+1);\n            }\n            anyB = true;\n            rInRow = 0;\n        }\n        else {\n            ++rInRow;\n        }\n    }\n    if (anyB) {\n        if (N%2) {\n            cout << \"0\" << endl;\n            return 0;\n        }\n        vector<ll> dp(N+1);\n        dp[0] = 1;\n        ll add = 1;\n        rep(i,1,N+1) {\n            if (i%2)\n                dp[i] = 0;\n            else {\n                dp[i] = add;\n                add += dp[i];\n                if (i > maxRInRow) {\n                    add -= dp[i-maxRInRow-1];\n                }\n                add %= MOD;\n                if (add < 0)\n                    add += MOD;\n            }\n        }\n        ll ans = 0;\n        for (int i = 2; i <= maxRInRow+1 && i <= N; i += 2) {\n            ans += i*dp[N-i];\n        }\n        ans %= MOD;\n        cout << ans << endl;\n    }\n    else {\n        vector<ll> dp[2][2];\n        rep(i,0,2)\n        rep(j,0,2)\n            dp[i][j] = vector<ll>(N+1);\n        dp[0][0][0] = 1;\n        dp[1][1][0] = 1;\n        rep(i,1,N+1) {\n            rep(j,0,2)\n            rep(k,0,2) {\n                dp[j][k][i] += dp[j][!k][i-1];\n                if (k == 0)\n                    dp[j][k][i] += dp[j][k][i-1];\n                dp[j][k][i] %= MOD;\n            }\n        }\n        ll ans = 0;\n        ans += dp[0][0][N];\n        ans += dp[1][1][N];\n        ans %= MOD;\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nstruct SegT {\nprivate:\n\tint sz; vector<ll> node;\n\tconst ll init_c = 0;\npublic:\n\tSegT(int n) {\n\t\tsz = 1;\n\t\twhile (sz < n)sz *= 2;\n\t\tnode.resize(2 * sz - 1, init_c);\n\t}\n\tll f(ll a, ll b) {\n\t\treturn (a + b)%mod;\n\t}\n\tvoid update(int k, ll a) {\n\t\tk += sz - 1;\n\t\tnode[k] = a;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t}\n\t}\n\tll query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = sz;\n\t\tif (r <= a || b <= l)return init_c;\n\t\telse if (a <= l && r <= b)return node[k];\n\t\telse {\n\t\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn f(vl, vr);\n\t\t}\n\t}\n};\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nll dp[1 << 18][2][2];\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (s[0] == 'B') {\n\t\trep(i, m) {\n\t\t\tif (s[i] == 'B')s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\tvector<int> v;\n\trep(i, m) {\n\t\tint le = i;\n\t\twhile (i + 1 < m&&s[i + 1] == s[i])i++;\n\t\tv.push_back(i - le + 1);\n\t}\n\tif (v.size() == 1) {\n\t\tdp[0][0][0] = 1;\n\t\tdp[0][1][1] = 1;\n\t\trep(i, n - 1) {\n\t\t\trep(j, 2) {\n\t\t\t\t(dp[i + 1][0][j] += dp[i][0][j] + dp[i][1][j]) %= mod;\n\t\t\t\tdp[i + 1][1][j] += dp[i][0][j];\n\t\t\t}\n\t\t}\n\t\tll ans = dp[n - 1][0][0] + dp[n - 1][1][0] + dp[n - 1][0][1];\n\t\tcout << ans % mod << endl; return;\n\t}\n\tif (n % 2) {\n\t\tcout << 0 << endl; return;\n\t}\n\tfor (int i = 0; i < v.size(); i += 2) {\n\t\tif (v[i] % 2) {\n\t\t\tif (n % 2) {\n\t\t\t\tcout << 0 << endl; return;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << 2 << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tint d = n / 2;\n\tint x = v[0] / 2 + 1;\n\tif (x >= d) {\n\t\tll ans = mod_pow(2, d) - 1;\n\t\tans = ans * 2;\n\t\tans = (ans + mod) % mod;\n\t\tcout << ans << endl;\n\t}\n\telse {\n\t\tSegT dp(d + 1);\n\t\tdp.update(0, 1);\n\t\trep1(i, d - 1) {\n\t\t\tint le = i - x;\n\t\t\tle = max(le, 0);\n\t\t\tll nex = dp.query(le, i);\n\t\t\tdp.update(i, nex);\n\t\t}\n\t\tll ans = 0;\n\t\trep(i, x) {\n\t\t\tll z = dp.query(d - x, d - i); ans += z;\n\t\t\tif (ans >= mod)ans -= mod;\n\t\t}\n\t\tans = ans * 2 % mod;\n\t\tcout << ans << endl;\n\t}\n\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=401000;\nchar s[N];\nint n,m;\n\nll dp[N],sdp[N],ans;\n\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s);\n\tbool mono=1;\n\trep(i,0,m) mono&=s[i]==s[0];\n\tif (mono) {\n\t\tint a=2,b=1;\n\t\trep(i,1,n) {\n\t\t\ta=(a+b)%mod;\n\t\t\tswap(a,b);\n\t\t}\n\t\tprintf(\"%d\\n\",b);\n\t\treturn 0;\n\t}\n\tint sR=2*n+1,sB=2*n+1;\n\tif (s[0]=='B') {\n\t\trep(i,0,m) if (s[i]=='R') s[i]='B'; else s[i]='R';\n\t}\n\trep(l,0,m) {\n\t\tint r=l;\n\t\twhile (r<m&&s[r]==s[l]) r++;\n\t\tint len=r-l;\n\t\tif (len%2==0) len=len+1;\n\t\tif (r==m) break;\n\t\tif (s[l]=='R') sR=min(sR,len);\n\t\telse sB=min(sB,len);\n\t\tl=r-1;\n\t}\n\tif (n%2==1) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n//\tprintf(\"%d %d\\n\",sR,sB);\n\tauto solve=[&](int sR,int sB) {\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(sdp,0,sizeof(sdp));\n\t\tdp[0]=1;\n\t\tsdp[2]=1;\n\t\trep(i,1,n+1) {\n\t\t\tif (i%2==1) {\n\t\t\t\tdp[i]=(sdp[i+1]-sdp[max(0,i-sR)])%mod;\n\t\t\t} else {\n\t\t\t\tif (i!=n) {\n\t\t\t\t\tdp[i]=(sdp[i+1]-sdp[max(1,i-sB)])%mod;\n\t\t\t\t} else {\n\t\t\t\t\tfor (int j=1;j<=sB&&j<=i;j+=2) {\n\t\t\t\t\t\tdp[i]=(dp[i]+dp[i-j]*j)%mod;\n\t\t\t\t\t}\n\t\t\t\t\tdp[i]%=mod;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsdp[i+2]=(sdp[i]+dp[i])%mod;\n\t\t}\n\t\tans+=dp[n];\n\t};\n\tsolve(sR,sB);\n\tsolve(sB,sR);\n\tans%=mod;\n\tif (ans<0) ans+=mod;\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint mod = 1000000007;\nint sum(int a, int b){\n    if (a+b<0) return a+b+mod;\n    if (a+b >= mod) return a+b-mod;\n    return a+b;\n}\nint mult(int a, int b){\n    return ((ll) a * (ll) b) % (ll) mod;\n}\nmain()\n{\n    freopen(\"input.txt\", \"r\", stdin);\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    string s;\n    cin >> s;\n    if (s[0] == 'B'){\n        for (int i=0; i < s.size(); i++){\n            if (s[i] == 'B') s[i] = 'R';\n            else s[i] = 'B';\n        }\n    }\n    int index = -1;\n    for (int i=0; i < m; i++) if (s[i] == 'B'){\n        index = i;\n        break;\n    }\n    if (index == -1){\n        int dp[n][2][2];\n        for (int i=0; i < n; i++) for (int j=0; j < 2; j++) for (int k=0; k < 2; k++) dp[i][j][k] = 0;\n        dp[0][0][0] = 1, dp[0][1][1] = 1;\n        for (int i=1; i < n; i++){\n            for (int j=0; j < 2; j++) for (int k=0; k < 2; k++) for (int e=0; e < 2; e++){\n                if (j==0 && e==0) continue;\n                dp[i][e][k] = sum(dp[i][e][k], dp[i-1][j][k]);\n            }\n        }\n        int ans = 0;\n        for (int i=0;i<2;i++) for (int j=0;j<2;j++) if (i!=0 || j != 0) ans=sum(ans, dp[n-1][i][j]);\n        cout << ans;\n        return 0;\n    }\n    if (n%2 != 0){\n        cout << 0;\n        return 0;\n    }\n    int mx = n+1;\n    if (index % 2 == 0) mx = min(mx, index+1);\n    else mx = min(mx, index);\n    int cnt = 0;\n    for (int i=index+1; i < m; i++){\n        if (s[i] == 'R') cnt++;\n        else{\n            if (cnt % 2 != 0) mx = min(mx, cnt);\n            cnt = 0;\n        }\n    }\n    int M = (mx+1)/2;\n    //cout << mx << endl;\n    int dp[n/2+1];\n    dp[0] = 1;\n    int ans = 0;\n    int pref[n/2+2];\n    pref[0] = 0;\n    pref[1] = 1;\n    for (int i=1; i <= n/2; i++){\n        if (i < n/2){\n            int brd = max((int) 0, i-M);\n            dp[i] = sum(pref[i], -pref[brd]);\n            pref[i+1] = sum(pref[i], dp[i]);\n        }\n        else{\n            int brd = max((int) 0, i-M);\n            for (int j=i-1; j >= brd; j--){\n                int val = dp[j];\n                int len = 2*(i-j)-1;\n                int shift = len+1;\n                ans = sum(ans, mult(shift, val));\n            }\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n\nInt all(Int n){//no bb\n    Int rr = 1, bb = 1, rb = 0, br = 0;\n    for(int i = 1;i < n;i++){\n        Int nrr = (rr+rb) % MOD;\n        Int nbb = br;\n        Int nrb = rr;\n        Int nbr = (bb + br) % MOD;\n        rr = nrr;\n        bb = nbb;\n        rb = nrb;\n        br = nbr;\n    }\n    return (rr + rb + br) % MOD;\n}\n\nInt tmp[216000];\nInt rdp[216000];\nInt dp[216000];\nvoid calc(Int n, Int limit){\n    dp[0] = 0;\n    dp[1] = 1;\n    rdp[0]= 0;\n    rdp[1] = 1;\n    for(int i = 1;i <= n+1;i++){\n        Int l = max(0LL, i - limit);\n        dp[i+1] = (rdp[i] + MOD - rdp[l]) % MOD;\n        rdp[i+1] = (rdp[i] + dp[i+1]) % MOD;\n    }\n    for(int i = 1;i <= n+1;i++){\n        dp[i-1] = dp[i];\n    }\n}\n\nInt solve(Int n, Int limit){\n    if(n % 2 == 1)return 0;\n    limit = (limit+1) / 2;\n    n /= 2;\n    Int res = 0;\n    calc(n, limit);\n    for(Int i = 1;i <= limit;i++){\n        if(n-i >= 0)res = (res + dp[n-i]*2%MOD*i%MOD) % MOD;\n    }\n    if(res < 0)exit(1);\n    return res % MOD;\n}\n\nint main(){\n    Int n, m;\n    string str;\n    vector<Int> vec;\n    cin >> n >> m;\n    cin >> str;\n    for(auto c:str)vec.push_back(c != str[0]);\n    vec.push_back(1);\n    Int l = 0;\n    while(vec[l] == 0)l++;\n    if(l+1==vec.size()){\n        cout << all(n) << endl;\n        return 0;\n    }\n    if(l % 2 == 0)l++;\n    Int limit = l;\n    l = 0;\n    for(int i = 0;i < vec.size();i++){\n        if(vec[i] == 0)l++;\n        else{\n            if(l % 2 == 1)limit = min(limit, l);\n            l = 0;\n        }\n    }\n    cout << solve(n, limit) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define REP(i,a,b) for(int i=(a),_end_=(b);i<=_end_;i++)\n#define DREP(i,a,b) for(int i=(a),_end_=(b);i>=_end_;i--)\n#define EREP(i,u) for(int i=start[u];i;i=e[i].next)\n#define fi first\n#define se second\n#define mkr(a,b) make_pair(a,b)\n#define SZ(A) ((int)A.size())\ntemplate<class T>inline void chkmin(T &a,T b){ if(a>b)a=b;}\ntemplate<class T>inline void chkmax(T &a,T b){ if(a<b)a=b;}\ninline int read()\n{\n\tint s=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch) && ch!='-')ch=getchar();\n\tif(ch=='-')ch=getchar(),f=-1;\n\twhile(isdigit(ch))s=s*10+ch-'0',ch=getchar();\n\treturn ~f?s:-s;\n}\n\nconst int maxn=2e5+20;\nconst int mod=1e9+7;\nconst int inf=0x3f3f3f3f;\n\nint n,m;\nchar str[maxn];\nint lim;\nint f[maxn];\n\ninline void CHECK1()\n{\n\tREP(i,1,m)if(str[i]=='B')return;\n\tf[0]=1;f[1]=1;\n\tREP(i,2,n)f[i]=(f[i-1]+f[i-2])%mod;\n\tprintf(\"%d\\n\",(f[n-2]+f[n])%mod);\n\texit(0);\n}\n\ninline void init()\n{\n\tn=read();m=read();\n\tscanf(\"%s\",str+1);\n\tif(str[1]=='B')\n\t{\n\t\tREP(i,1,m)str[i]=str[i]=='B'?'R':'B';\n\t}\n\tCHECK1();\n\tlim=inf;\n\tint lstb=0;\n\tREP(i,1,m)\n\t{\n\t\tif(str[i]=='B')\n\t\t{\n\t\t\tint num=i-lstb-1;\n\t\t\tif(lstb==0)chkmin(lim,num+(num+1&1));\n\t\t\telse if(num&1)chkmin(lim,num);\n\t\t\tlstb=i;\n\t\t}\n\t}\n\tlim=lim+1>>1;\n}\n\ninline void doing()\n{\n\tif(n&1)puts(\"0\"),exit(0);\n\tn>>=1;\n\tf[0]=1;int s=1;\n\tREP(i,1,n)\n\t{\n\t\tf[i]=s;\n\t\ts=(s+f[i])%mod;\n\t\tif(i-lim>=0)s=(s-f[i-lim]+mod)%mod;\n\t}\n\t//int ans=f[n>>1];\n\tint ans=0;\n\tREP(i,1,lim)ans=(ans+(ll)i*f[n-i])%mod;\n\tans=(ll)ans*2%mod;\n\tprintf(\"%d\\n\",ans);\n}\n\nint main()\n{\n\tinit();\n\tdoing();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n#ifdef DEBUG\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n)\\\n\t{cerr << #a << \" = {\";\\\n\tfor(int qwq = (st); qwq <= (n); ++qwq) {\\\n\t\tif(qwq == (st)) cerr << a[qwq];\\\n\t\telse cerr << \", \" << a[qwq];\\\n\t} cerr << \"}\" << endl;}\n#define displayv(v) displaya(v, 0, (int)(v).size() - 1)\n#endif\ntemplate<typename T> bool chmin(T &a, const T &b) { return a > b ? a = b, true : false; }\ntemplate<typename T> bool chmax(T &a, const T &b) { return a < b ? a = b, true : false; }\n\nconst int maxN = 200000 + 233;\nconst LL P = 1000000007;\nint n, m;\nchar s[maxN];\nLL f[maxN];\n\nLL purity() {\n\tLL f00 = 1, f11 = 1, f01 = 0, f10 = 0;\n\t// '11' is not OK\n\tfor(int i = 2; i <= n; ++i) {\n\t\tLL g00 = f00 + f01, g01 = f00,\n\t\t   g10 = f10 + f11, g11 = f10;\n\t\tf00 = g00 % P; f01 = g01;\n\t\tf10 = g10 % P; f11 = g11;\n\t}\n\treturn (f00 + f01 + f10) % P;\n}\n\nLL recur(int lim) {\n\t// sum( x ^ (p + 1) )\n\t// sum( (c + 1) * x ^ (p + 1) )\n//\tdisplay(lim);\n\tmemset(f, 0, sizeof(f));\n\tf[0] = 1; f[1] = 0; f[2] = 1; f[3] = 0;\n\tfor(int i = 4; i <= n; ++i) {\n\t\tf[i] = f[i - 2] * 2 % P;\n\t\tif(i - lim - 3 >= 0) f[i] = (f[i] + P - f[i - lim - 3]) % P;\n\t}\n//\tdisplaya(f, 0, n);\n\tLL ans = 0;\n\tfor(int i = 1; i <= lim; i += 2) if(n - i - 1 >= 0)\n\t\t(ans += f[n - i - 1] * (i + 1)) %= P;\n\treturn ans;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> n >> m >> (s + 1);\n\tassert((int)strlen(s + 1) == m);\n\tchar major = s[1], minor = (int)'R' + 'B' - major;\n\tint cons = 0;\n\tint mn = maxN;\n\tbool first = true;\n\tfor(int i = 1; i <= m; ++i) {\n\t\tif(s[i] == major) cons++;\n\t\telse {\n\t\t\tif(first) chmin(mn, cons | 1), cons = 0, assert(s[i] == minor), first = false;\n\t\t\telse if(cons & 1) chmin(mn, cons), cons = 0, assert(s[i] == minor);\n\t\t\telse cons = 0;\n\t\t}\n\t}\n\tif(mn == maxN) cout << purity() << endl;\n\telse cout << recur(mn) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define SZ(x) (int)(x).size()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i, a, b) for (int i=a;i>=b;--i)\n\nconst int MX_N = 2e5+5;\nconst int MX_M = 2e5+5;\nconst int MOD = 1e9+7;\n\nint N, M;\nstring S;\n\nint dp[MX_N];\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> N >> M;\n    cin >> S;\n\n    int k = -1, kp = -1, cur = 0;\n    bool same = true;\n    FOR(i,0,M-1){\n        same &= S[i] == S[0];\n        if (S[i] == 'B') {\n            if (k == -1) {\n                if (cur&1) k = cur;\n                else k = cur+1;\n            } else if (cur&1) kp = max(kp,cur);\n            cur = 0;\n        } else ++cur;\n    }\n\n    if (same) {\n        // dp[i]: no of ways to color s.t. no 2 consec is B & i-th is R\n        int ans = 0;\n        dp[1] = 0; dp[2] = 1;   // 1st is B\n        FOR(i,3,N){\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        ans += dp[N];           // Nth is R\n        if (ans >= MOD) ans -= MOD;\n        dp[1] = 1; dp[2] = 1;   // 1st is R\n        FOR(i,3,N){\n            dp[i] = dp[i-1] + dp[i-2];\n        }\n        ans += dp[N];           // Nth is R\n        if (ans >= MOD) ans -= MOD;\n        ans += dp[N-1];         // Nth is B\n        if (ans >= MOD) ans -= MOD;\n        cout << ans;\n    } else {\n        if (N&1) cout << 0;\n        else {\n            int L = max(k,kp);\n            assert(L&1);\n\n            N /= 2, L /= 2;\n\n            //cout << \"L is \" << L << endl;\n\n            dp[1] = 1;\n            int sum = 0;\n            FOR(i,2,N){\n                if (i-(L+2) >= 1) {\n                    sum -= dp[i-(L+2)];\n                    if (sum < 0) sum += MOD;\n                }\n                if (i-1 >= 1) {\n                    sum += dp[i-1];\n                    if (sum >= MOD) sum -= MOD;\n                }\n                dp[i] = sum;\n            }\n\n            int ans = 0;\n            FOR(i,0,L){\n                ans += 1LL * (i+1) * dp[N-i] % MOD;\n                if (ans >= MOD) ans -= MOD;\n            }\n            cout << ans * 2 % MOD;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n¼ÙÉèS[1] = R¡£ÄÇÃ´ÏÔÈ»£¬»·ÉÏ²»»á³öÏÖÁ½¸öÁ¬ÐøµÄ±ß¶¼ÊÇB£¬·ñÔòÔÚËüÃÇ½»µã´¦µÚÒ»²½ÍùÁ½±ß×ß¶¼²»ºÏ·¨\nÌØÅÐµôSÖÐÈ«ÊÇRµÄÇé¿ö£¬¿¼ÂÇÒ»°ãÇé¿ö \nÊ×ÏÈ°ÑËùÓÐÊÇBµÄÎ»ÖÃ¶Ï¿ª£¬ÄÇÃ´¾ÍÐÎ³ÉÁËÈô¸É¸öRµÄÁ¬Ðø¶Î¡£¿ÉÒÔ·¢ÏÖÕâÃ´Ò»¸öÐÔÖÊ£ºÃ¿¸öÁ¬Ðø¶ÎµÄ³¤¶È¾ùÎªÆæÊý\nÖ¤Ã÷¿¼ÂÇ·´Ö¤¡£¼ÙÉèÓÐÒ»¸öÅ¼ÊýµÄ¶Î£¬¿¼ÂÇ¶þ·ÖÍ¼¿ÉÒÔ·¢ÏÖ£¬ÄÇÃ´ÓÐµÄµã×ßµ½ÕâÒ»¶ÎµÄ¶Ëµã¾àÀëÓÀÔ¶ÊÇÅ¼Êý¡¢ÓÐµÄµã×ßµ½ÕâÒ»¶ÎµÄ¶Ëµã¾àÀëÓÀÔ¶ÊÇÆæÊý£¬ÒòÎª¶ËµãÍ¬É«\n¶øSµÄµÚÒ»¶ÎÁ¬ÐøR³¤¶ÈÊÇ¹Ì¶¨µÄ£¬²»ÄÜÍ¬Ê±ÎªÅ¼Êý»òÆæÊý£¬Ã¬¶Ü¡£ËùÒÔ¿ÉÒÔµÃµ½½áÂÛ\nÍ¬Ê±£¬SÖÐÃ¿¸öRµÄÁ¬Ðø¶Î¶¼»á¶Ô»·ÉÏÃ¿¸öRµÄÁ¬Ðø¶ÎÓÐ¸öÉÏ½çµÄÏÞÖÆ \n*/\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\nconst int Max_NM(200050);\nconst int MOD(1000000000 + 7);\ntypedef long long int LL;\n\nint N, M, L, F[Max_NM], Pre[Max_NM][2], Ans;\nchar S[Max_NM];\n\nconstexpr int Add(int a, int b)\n{\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\n\nconstexpr int Sub(int a, int b)\n{\n\treturn a - b < 0 ? a - b + MOD : a - b;\n}\n\nconstexpr int Mult(int a, int b)\n{\n\treturn a * 1LL * b % MOD;\n}\n\ninline void upd(int &a, int b)\n{\n\ta = Add(a, b);\n}\n\nvoid dp(bool have)\n{\n\tF[1] = 1, Pre[1][1 & 1] = 1;\n\tfor (int i = 2, j;i <= N;++i)\n\t{\n\t\tPre[i][0] = Pre[i - 1][0], Pre[i][1] = Pre[i - 1][1];\n\t\tupd(Pre[i][i & 1], F[i - 2]);\n\t\t//jµ½iÊÇR£¬i - j + 1 <= L   =>   j >= i - L + 1\n\t\t//i - j + 1ÊÇÆæÊý£¬i - jÊÇÅ¼Êý£¬iºÍjÆæÅ¼ÐÔÏàµÈ\n\t\tj = max(1, i - L + 1);\n\t\tif (j <= i)\n\t\t{\n\t\t\tF[i] = Sub(Pre[i][i & 1], Pre[j - 1][i & 1]);\n\t\t\tif (have)\n\t\t\t\tupd(F[i], Sub(Pre[i][(i & 1) ^ 1], Pre[j - 1][(i & 1) ^ 1]));\n\t\t}\n\t}\n\t\n}\n\nint main()\n{ \n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s\", S + 1);\n\tbool haveB = false;\n\tif (S[1] == 'B')\n\t\tfor (int i = 1;i <= M;++i)\n\t\t\tS[i] = 'R' + 'B' - S[i];\n\tfor (int i = 1;i <= M;++i)\n\t\thaveB |= (S[i] == 'B');\n\tL = N;\n\tfor (int i = 1, length = 0, stop = 0;i <= M;++i)\n\t\tif (S[i] == 'B')\n\t\t\tlength = 0, stop = 1;\n\t\telse\n\t\t{\n\t\t\t++length;\n\t\t\tif (i + 1 <= N && S[i + 1] == 'B')\n\t\t\t\tif (stop == 0)\n\t\t\t\t\tif (length & 1)\n\t\t\t\t\t\tL = min(L, length);\n\t\t\t\t\telse\n\t\t\t\t\t\tL = min(L, length + 1);\n\t\t\t\telse\n\t\t\t\t\tif (length & 1)\n\t\t\t\t\t\tL = min(L, length);\n\t\t}\n\tdp(!haveB);\n\tupd(Ans, F[N - 1]);//edge(1, 2) = B\n\tfor (int x = 1, val;x <= L && x < N;x += 2)//edge(1, 2) = R\n\t{\n\t\tif (x + 1 == N)\n\t\t\tval = 1;\n\t\telse\n\t\t\tval = F[N - x - 2];\n\t\tupd(Ans, Mult(x, val));\n\t}\n\tif ((L & 1) && L == N)\n\t\tupd(Ans, 1);\n\tprintf(\"%d\", Ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define int long long\nusing namespace std;\nconst int N = 2e5 + 5;\nconst int mod = 1e9 + 7;\nint n, m, k = 2e9, a[N], b[N], ans, f[N];\nchar s[N];\ninline int read()\n{\n\tint x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') {x = (x << 3) + (x << 1) + (ch ^ 48); ch = getchar();}\n\treturn x * f;\n}\nsigned main()\n{\n//\tfreopen(\".in\", \"r\", stdin);\n//\tfreopen(\".out\", \"w\", stdout);\n\tn = read(); m = read(); scanf(\"%s\", s + 1);\n\tint tag = 1;\n\tfor(int i = 1, len = 0; i <= m; i ++)\n\t{\n\t\tif(s[i] != s[1])\n\t\t{\n\t\t\tif(tag || len & 1) k = min(k, len);\n\t\t\ttag = len = 0;\n\t\t}\n\t\telse len ++;\n\t}\n\tif(tag)\n\t{\n\t\tf[0] = 0; f[1] = 1;\n\t\tfor(int i = 2; i <= n; i ++) f[i] = (f[i - 1] + f[i - 2]) % mod;\n\t\tprintf(\"%lld\\n\", (2 * f[n - 1] + f[n]) % mod);\n\t\treturn 0;\n\t}\n\tif(n & 1) {puts(\"0\"); return 0;}\n\tn /= 2; k = (k + 1) / 2; a[0] = b[0] = 1;\n\tfor(int i = 1; i <= n; i ++)\n\t{\n\t\tif(i <= k) a[i] = b[i - 1];\n\t\telse a[i] = (b[i - 1] - b[i - k - 1] + mod) % mod;\n\t\tb[i] = (b[i - 1] + a[i]) % mod;\n\t}\n\tfor(int i = 1; i <= k; i ++) ans = (ans + 2 * i * a[n - i]) % mod;\n\tprintf(\"%lld\\n\", ans);\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e5+10,inf=0x3f3f3f3f,mod=1e9+7;\nchar s[maxn];\ninline int ksm(int x,int y){\n\tint res=1;\n\twhile(y){\n\t\tif(y&1) res=(ll)res*x%mod;\n\t\ty>>=1;\n\t\tx=(ll)x*x%mod;\n\t}\n\treturn res;\n}\nint dp[maxn],sum[maxn];\nint main(){\n\tint n=read(),m=read();\n\tscanf(\"%s\",s+1);\n\tint Min=inf;\n\tfor(int i=1,j;i<=m;i++) if(s[i]==s[1]){\n\t\tj=i;\n\t\twhile(j<m && s[j+1]==s[1]) ++j;\n\t\tif((j-i+1)%2==1) chkmin(Min,j-i+1);\n\t\telse if(i==1) chkmin(Min,j-i+2);\n\t\ti=j;\n\t}\n\tint flag=1;\n\tREP(i,2,m) flag&=(s[i]==s[1]);\n\tdp[1]=sum[1]=1;\n\tassert(flag==0);\t\n  REP(i,2,n+1){\n\t\tif(flag){\n\t\t\tdp[i]=sum[i-2];\n\t\t\tsum[i]=(sum[i-1]+dp[i])%mod;\n\t\t}\n\t\telse{\n\t\t\tdp[i]=(sum[i-2]-sum[max(i-Min-3,0)]+mod)%mod;\n\t\t\tsum[i]=(sum[i-2]+dp[i])%mod;\n\t\t}\n\t}\n\tint ans=(dp[n+1]*2+flag)%mod;\n\tREP(i,1,n-2) if(((n-i)%2==1 && n-i<=Min) || flag) ans=(ans+(ll)dp[i]*(n-i-1))%mod;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << (a) << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int MOD = 1e9 + 7;\n\nvi split(string s) {\n    vi ans;\n    char last = 'X'; \n    s += 'X';\n    int streak = 0;\n    for (char c : s) {\n        if (c != last) {\n            if (streak) ans.pb(streak);\n            streak = 0;\n            last = c;\n        }\n        streak++;\n    }\n    return ans;\n}\n\nvoid add(int &x, int y) {\n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n\nvi go(int n, int lim, int start) {\n    vi dp(n+1);\n    dp[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        dp[i] = 0;\n        if (i >= start) add(dp[i], dp[i-start]);\n        if (i >= lim+1) add(dp[i], MOD-dp[i-lim-1]);\n        add(dp[i], dp[i-1]);\n    }\n    for (int i = n; i >= 1; i--) add(dp[i], MOD-dp[i-1]);\n    return dp;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    int n,l;\n    string s;\n    cin >> n >> l >> s;\n    auto p = split(s);\n    if (si(p) == 1) {\n        auto dp = go(n,n,2);\n        int ans = 0;\n        for (int dif = 1; dif <= n; dif++) {\n            if (dif == 1 || dif == n-1) continue;\n            add(ans, ll(dif) * dp[n-dif] % MOD);\n        }\n        cout << (ans+1)%MOD << endl;\n    }\n    else {\n        if (n%2 == 1) {\n            cout << 0 << endl;\n        }\n        else {\n            int lim = p[0]/2+1;\n            forn(i,si(p)) if (i%2 == 0 && p[i]%2 == 1 && i+1 != si(p)) \n                lim = min(lim, p[i]/2+1);\n            n /= 2;\n            auto dp = go(n, lim, 1);\n            int ans = 0;\n            for (int dif = 1; dif <= lim; dif++)\n                add(ans, ll(dif) * dp[n-dif] % MOD);\n            cout << 2LL*ans%MOD << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\ntypedef pair<i64, i64> pi64;\ntypedef double ld;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nconst int maxn = 210000;\nconst i64 P = 1000000000 + 7;\ni64 dp[2][2][maxn];\n\nvoid add(i64 &x, i64 y) {\n    x += y;\n    x %= P;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int n, l;\n    string s;\n    cin >> n >> l >> s;\n    char c0 = s[0], c1 = c0 ^ 'R' ^ 'B';\n    if (s == string(l, c0)) {\n        forn(i, 2) dp[i][i][1] = 1;\n        for1(i, n - 1) forn(f, 2) forn(j, 2) forn(k, 2) {\n            if (j && k) continue;\n            add(dp[f][k][i + 1], dp[f][j][i]);\n        }\n        i64 ans = 0;\n        forn(f, 2) forn(j, 2) {\n            if (f && j) continue;\n            add(ans, dp[f][j][n]);\n        }\n        cout << ans << '\\n';\n        return 0;\n    }\n\n    if (n % 2) {\n        cout << 0 << '\\n';\n        return 0;\n    }\n\n    vector<pair<int, char> > cl;\n    pii p = {1, c0};\n    for1(i, l - 1) {\n        if (s[i] == p.se) ++p.fi;\n        else cl.pb(p), p = {1, s[i]};\n    }\n\n    int ub = n / 2;\n    if (cl[0].fi % 2 == 0) ub = cl[0].fi + 1;\n    for (auto w: cl) if (w.se == c0 && w.fi % 2) uin(ub, w.fi);\n    ub /= 2;\n\n    vi64 vals(n / 2 + 1), svals(n / 2 + 2);\n    vals[0] = 1;\n    svals[1] = 1;\n//    cerr << ub << '\\n';\n    for1(i, n / 2) {\n        vals[i] = svals[i] - svals[max(i - ub - 1, 0)];\n        vals[i] %= P;\n//        cerr << i << ' ' << vals[i] << '\\n';\n        svals[i + 1] = (svals[i] + vals[i]) % P;\n    }\n\n    i64 ans = vals[n / 2];\n    for1(i, ub) if (i + 1 <= n / 2) add(ans, vals[n / 2 - i - 1] * i);\n    ans *= 2;\n    ans %= P;\n    if (ans < 0) ans += P;\n    cout << ans << '\\n';\n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)//  cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ld PI = 3.14159265359;\n\nconst ll MOD = (ll) 1e9 + 7;\nconst ll MAXN = (ll) 3e5 + 10;\nconst ll INF = (ll) 2242545357980376863;\nconst ld EPS = (ld) 1e-8;\n\nvector<ll> A;\nll dp[MAXN], sm[MAXN];\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll n, m;\n\tcin >> n >> m;\n\tstr s;\n\tcin >> s;\n\t\n\tll cnt = 1;\n\tfor(int i = 1; i < m; i++){\n\t\tif(s[i] == s[i - 1]) cnt ++;\n\t\telse {\n\t\t\tA.pb(cnt);\n\t\t\tcnt = 1;\n\t\t}\n\t}\n\tA.pb(cnt);\n\tif(A.size() == 1){\n\t\t//debug(\"S\");\n\t\tdp[1] = 1;\n\t\tdp[2] = 0;\n\t\tsm[1] = 1;\n\t\tsm[2] = 1;\n\t\tfor(int i = 3; i <= n; i++){\n\t\t\tdp[i] = sm[i - 2];\n\t\t\tsm[i] = (dp[i] + sm[i - 1]) % MOD;\n\t\t}\n\t\tll ans = 1;\n\t\tfor(int len = 1; len <= n - 1; len ++){\n\t\t\tans += (len + 1ll) * dp[n - len];\n\t\t\tans %= MOD;\n\t\t}\n\t\tcout << ans;\n\t\treturn 0;\n\t\t/////\n\t}\n\t\n\tll mx;\n\t\n\tif(A[0] % 2 == 0) mx = A[0] + 1;\n\telse mx = A[0];\n\tfor(int i = 2; i + 1 < A.size(); i += 2){\n\t\tif(A[i] % 2 == 1) mx = min(mx, A[i]);\n\t}\n\tdebug(mx);\n\tdp[0] = 0;\n\tdp[1] = 1;\n\tdp[3] = 1;\n\tfor(int i = 5; i <= n; i++){\n\t\tdp[i] = dp[i - 2] + dp[i - 2];\n\t\tif(i >= mx + 3) dp[i] -= dp[i - mx - 3];\n\t\tdp[i] %= MOD;\n\t}\n\t//debug(dp[1]);\n\t//debug(dp[3]);\n\tll ans = 0;\n\tfor(ll len = 1; len <= min(n-1ll, mx); len += 2){\n\t\tans += ((len + 1ll) * dp[n - len]);\n\t\tans %= MOD;\n\t}\n\tcout << ((ans % MOD) + MOD)%MOD;\n\t\n\treturn 0;\n}\n\n\n/*\n\n                                 ____              ,----..               ,----..\n   ,---,                       ,'  , `.           /   /   \\             /   /   \\\n  '  .' \\                   ,-+-,.' _ |          /   .     :           /   .     :\n /  ;    '.              ,-+-. ;   , ||         .   /   ;.  \\         .   /   ;.  \\\n:  :       \\            ,--.'|'   |  ;|        .   ;   /  ` ;        .   ;   /  ` ;\n:  |   /\\   \\          |   |  ,', |  ':        ;   |  ; \\ ; |        ;   |  ; \\ ; |\n|  :  ' ;.   :         |   | /  | |  ||        |   :  | ; | '        |   :  | ; | '\n|  |  ;/  \\   \\        '   | :  | :  |,        .   |  ' ' ' :        .   |  ' ' ' :\n'  :  | \\  \\ ,'        ;   . |  ; |--'         '   ;  \\; /  |        '   ;  \\; /  |\n|  |  '  '--'          |   : |  | ,             \\   \\  ',  /          \\   \\  ',  /\n|  :  :                |   : '  |/               ;   :    /            ;   :    /\n|  | ,'                ;   | |`-'                 \\   \\ .'              \\   \\ .'\n`--''                  |   ;/                      `---`                 `---`\n                       '---'\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n \nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 1e9 + 7;\n \nint n, m;\nchar S[200005];\nvector<int> sizs;\nint dp[200005], prs[200005];\n\nint main()\n{\n\tscanf(\"%d%d%s\", &n, &m, S);\n\t\n\tint ccnt = 1;\n\tfor(int i = 1; i < m; i ++)\n\tif(S[i] != S[i - 1]) {\n\t\tsizs.push_back(ccnt);\n\t\tccnt = 1;\n\t} else ccnt ++;\n\tsizs.push_back(ccnt);\n\t\n\tif(sizs.size() == 1) {\n\t\tdp[1] = 2;\n\t\tdp[2] = MOD - 1;\n\t\trep(i, n) {\n\t\t\tif(i >= 1) dp[i] = (dp[i] + dp[i - 1]) % MOD;\n\t\t}\n\t\trep(i, n) {\n\t\t\tif(i >= 1) dp[i] = (dp[i] + dp[i - 1]) % MOD;\n\t\t\tif(i >= 2) dp[i] = (dp[i] + dp[i - 2]) % MOD;\n\t\t}\n\t\tprintf(\"%d\\n\", dp[n - 1] + 1);\n\t} else {\n\t\tint maxl = min(n, sizs[0] + 2);\n\t\trep(i, sizs.size()) if(!(i & 1) && sizs[i] & 1)\n\t\tmaxl = min(maxl, sizs[i] + 1);\n\t\t\n\t\trep1(i, maxl) if(!(i & 1)) dp[i] = i;\n\t\t\n\t\trep1(i, n) {\n\t\t\tif(i >= 2) dp[i] = (dp[i] + prs[i - 2]) % MOD;\n\t\t\tif(i >= 2 + maxl) dp[i] = (dp[i] + MOD - prs[i - 2 - maxl]) % MOD;\n\t\t\tif(i >= 2) prs[i] = (dp[i] + prs[i - 2]) % MOD;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", dp[n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \n#define mod 998244353\n\nusing namespace std;\nconst int N=200010;\nint n,m,ans,f[N],g[N];\nchar s[N];\nvoid inc(int&x,int y){x+=y;if(x>=mod)x-=mod;}\nvoid dec(int&x,int y){x-=y;if(x<0)x+=mod;}\n\nint main(){\n//\tfreopen(\"E.in\",\"r\",stdin);\n//\tfreopen(\"E.out\",\"w\",stdout);\n\tscanf(\"%d%d%s\",&n,&m,s+1);\n\tint p=0;while(p<m&&s[p+1]==s[1])++p;\n\tif(p==m){\n\t\tans=f[0]=g[0]=1;\n\t\tfor(int i=0;i<n-2;++i){\n\t\t\tif(i)f[i]=g[max(i-2,0)];\n\t\t\tif(i)g[i]=(g[i-1]+f[i])%mod;\n\t\t\tinc(ans,(ll)(n-i)*f[i]%mod);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}else{\n\t\tif(n&1)puts(\"0\"),exit(0);\n\t\tint L=p|1;\n\t\twhile(1){\n\t\t\tint tmp=0;\n\t\t\twhile(p<m&&s[p+1]!=s[1])++p;tmp-=p;\n\t\t\twhile(p<m&&s[p+1]==s[1])++p;tmp+=p;\n\t\t\tif(p==m)break;\n\t\t\tif(tmp&1)L=min(L,tmp);\n\t\t}\n\t\tf[0]=g[0]=1;\n\t\tL=(L+1)>>1;n>>=1;\n\t\tfor(int i=1;i<n;++i){\n\t\t\tf[i]=g[i-1];\n\t\t\tif(i>L)dec(f[i],g[i-L-1]);\n\t\t\tg[i]=(g[i-1]+f[i])%mod;\n\t\t\tif(n-i<=L)inc(ans,(ll)(n-i)*f[i]%mod);\n\t\t}\n\t\tcout<<ans*2%mod<<endl;\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MX = 200005;\nconst ll MOD = 1000000007;\n\ntemplate <typename T> void cmin(T &x, const T &y)\n{\n\tif(y < x) x = y;\n}\n\ntemplate <typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nint n, m, nR, nB;\nchar str[MX];\nll f[MX], sum[2][MX];\n\nvector<int> divide(int x)\n{\n\tvector<int> ret;\n\tfor(int i=1; i<=x; i++)\n\t\tif(x%i == 0)\n\t\t\tret.push_back(i);\n\treturn ret;\n}\n\nint main()\n{\n\tll ans = 0;\n\tread(n), read(m);\n\tscanf(\"%s\", str+1);\n\tfor(int i=1; i<=m; i++)\n\t\tif(str[i] == 'R') nR++;\n\t\telse nB++;\n\tvector<int> dvs = divide(n);\n\tif(!nR || !nB)\n\t{\n\t\tf[0] = 1;\n\t\tsum[0][0] = sum[0][1] = 1;\n\t\tfor(int i=2; i<=n; i++)\n\t\t{\n\t\t\tf[i] = sum[0][i-2];\n\t\t\tsum[0][i] = (sum[0][i-1] + f[i]) % MOD;\n\t\t}\n\t\tans = 1;\n\t\tfor(int i=1; i<n; i++) ans = (ans+f[n-i-1]*(i+1)) % MOD;\n\t}\n\telse\n\t{\n\t\tint len = n-1;\n\t\tint pre = 0;\n\t\twhile(str[pre+1] == str[1]) pre++;\n\t\t/*if(pre&1) cmin(len, pre);\n\t\telse cmin(len, pre*2-1);*/\n\t\tcmin(len, pre|1);\n\t\tint cur = 0;\n\t\tfor(int i=pre+1; i<=n+1; i++)\n\t\t{\n\t\t\tif(str[i] != str[1])\n\t\t\t{\n\t\t\t\tif(cur & 1) cmin(len, cur);\n\t\t\t\tcur = 0;\n\t\t\t}\n\t\t\telse cur++;\n\t\t}\n\t\tf[0] = sum[0][0] = 1;\n\t\tfor(int i=1; i<=n; i++)\n\t\t{\n\t\t\tf[i] = (((i-2>=0) ? (sum[i&1][i-2]) : (0)) - ((i-2-len>=0) ? (sum[i&1][i-2-len]) : (0)) + MOD) % MOD;\n\t\t\tsum[i&1][i] = (sum[i&1][i-1] + f[i]) % MOD;\n\t\t\tsum[i&1^1][i] = sum[i&1^1][i-1];\n\t\t}\n\t\tfor(int i=1; i<=len; i+=2)\n\t\t{\n\t\t\t//cout<<i<<\" \"<<f[n-i-1]<<endl;\n\t\t\tans = (ans+f[n-i-1]*(i+1)) % MOD;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\tconst int N=2e5+9,mod=1e9+7;\n\tinline int add(int x,int y){return x+y>=mod?x-mod+y:x+y;}\n\tinline int sub(int x,int y){return x>=y?x-y:x+mod-y;}\n\tinline int qpow(int x,int y){\n\t\tint ret=1;\n\t\twhile(y){\n\t\t\tif(y&1) ret=1LL*x*ret%mod;\n\t\t\tx=1LL*x*x%mod,y>>=1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint n,m,f[N],sum[N];char s[N];\n\tint main(){\n\t\tn=read<int>(),m=read<int>(),scanf(\"%s\",s+1);\n\t\t\n\t\tint peg=1;\n\t\tfor(int i=2;i<=m;i++) if(s[1]!=s[i]) peg=0;\n\t\tif(peg){\n\t\t\tf[0]=1,f[1]=0,sum[0]=sum[1]=1;\n\t\t\tfor(int i=2;i<=n;i++)\n\t\t\t\tf[i]=sum[i-2],sum[i]=add(sum[i-1],f[i]);\n\t\t//\tfor(int i=1;i<=n;i++) cout<<f[i]<<\" \";cout<<endl;\n\t\t\tint ans=0;\n\t\t\tfor(int i=2;i<=n;i++) ans=add(ans,1LL*f[n-i]*i%mod);\n\t\t\tprintf(\"%d\\n\",add(ans,1));\n\t\t\treturn 0;\n\t\t}\n\t\tint mx=0,i,t;\n\t\tfor(i=1;i<=m;i++)\n\t\t\tif(s[i]!=s[1]){mx=i-1+(~(i-1)&1);break;}\n\t\tfor(t=0;i<=m;i++)\n\t\t\tif(s[i]!=s[1]){\n\t\t\t\tif(t&1) mx=min(mx,t);\n\t\t\t\tt=0;\n\t\t\t}else t++;\n\n\t\tf[0]=1,f[1]=0,sum[0]=sum[1]=1;\n\t\tfor(i=2;i<=n;i++){\n\t\t\tif(~i&1) f[i]=sub(sum[i-2],i-mx-2>=0?sum[i-mx-2]:0);\n\t\t\tsum[i]=sum[i-1];\n\t\t\tif(~i&1) sum[i]=add(sum[i],f[i]);\n\t\t}\n\t//\tfor(int i=1;i<=n;i++) cout<<f[i]<<\" \";cout<<endl;\n\t\tint ans=0;\n\t\tfor(int i=2;i<=mx+1;i++) if(~i&1) ans=add(ans,1LL*f[n-i]*i%mod);\n\t\tprintf(\"%d\\n\",ans);\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n#define FI first\n#define SE second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n\nconstexpr lint MOD = 1000000007;\n\nlint corner_case(int N)\n{\n    lint a = 1, b = 0; // R始まり\n    lint c = 0, d = 1; // B始まり\n    REP(i, N - 1)\n    {\n        lint bnew = a;\n        lint anew = (a + b) % MOD;\n        a = anew;\n        b = bnew;\n\n        lint dnew = c;\n        lint cnew = (c + d) % MOD;\n        c = cnew;\n        d = dnew;\n    }\n    return (a + b + d) % MOD;\n}\n\nint main()\n{\n    lint N;\n    cin >> N;\n    lint M;\n    cin >> M;\n    string S;\n    cin >> S;\n    if (S[0] == 'B')\n    {\n        for (auto &c : S)\n        {\n            c = 'R' + 'B' - c;\n        }\n    }\n    int n = 0;\n    vector<int> con;\n    for (auto c : S)\n    {\n        if (c == 'R') n++;\n        else con.push_back(n), n = 0;\n    }\n    if (con.size() == 0)\n    {\n        lint ret = corner_case(N);\n        cout << ret << endl;\n        return 0;\n    }\n\n    if (N % 2)\n    {\n        cout << 0 << endl;\n        return 0;\n    }\n\n    int Lmaxi = (con[0] % 2 ? con[0] : con[0] + 1);\n    FOR(i, 1, con.size())\n    {\n        if (con[i] % 2) mmin(Lmaxi, con[i]); // 奇数だとヤバい\n    }\n\n    int P = (Lmaxi + 1) / 2;\n    int Q = N / 2;\n    // QをP以下で分割\n\n    vector<lint> dp(Q + 1);\n    dp[0] = 1;\n    lint acc = dp[0];\n    REP(i, Q)\n    {\n        dp[i + 1] = acc;\n        (acc += dp[i + 1]) %= MOD;\n        if (i + 1 - P >= 0) (acc += MOD - dp[i + 1 - P]) %= MOD;\n    }\n\n    vector<lint> dp_acc(Q + 2);\n    REP(i, Q + 1) dp_acc[i + 1] = (dp_acc[i] + dp[i]) % MOD;\n\n    lint ret = 0;\n    REP(l, Lmaxi + 1)\n    {\n        int n = l / 2;\n        if (n < P) (ret += (dp_acc[max(Q - n, 0)] - dp_acc[max(Q - P, 0)] + MOD)) %= MOD;\n    }\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nll mod_pow(ll x, ll n) {\n\tll ret = 1;\n\twhile (n) {\n\t\tif (n % 2)ret = ret * x%mod;\n\t\tx = x * x%mod; n >>= 1;\n\t}\n\treturn ret;\n}\nll dp[1 << 18][2][2];\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\tstring s; cin >> s;\n\tif (s[0] == 'B') {\n\t\trep(i, m) {\n\t\t\tif (s[i] == 'B')s[i] = 'R';\n\t\t\telse s[i] = 'B';\n\t\t}\n\t}\n\tvector<int> v;\n\trep(i, m) {\n\t\tint le = i;\n\t\twhile (i + 1 < m&&s[i + 1] == s[i])i++;\n\t\tv.push_back(i - le + 1);\n\t}\n\tif (v.size() == 1) {\n\t\tdp[0][0][0] = 1;\n\t\tdp[0][1][1] = 1;\n\t\trep(i, n-1) {\n\t\t\trep(j, 2) {\n\t\t\t\t(dp[i + 1][0][j] += dp[i][0][j] + dp[i][1][j])%=mod;\n\t\t\t\tdp[i + 1][1][j] += dp[i][0][j];\n\t\t\t}\n\t\t}\n\t\tll ans = dp[n-1][0][0] + dp[n-1][1][0] + dp[n-1][0][1];\n\t\tcout << ans % mod << endl; return;\n\t}\n\tfor (int i = 0; i < v.size(); i += 2) {\n\t\tif (v[i] % 2) {\n\t\t\tif (n % 2) {\n\t\t\t\tcout << 0 << endl; return;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcout << 2 << endl; return;\n\t\t\t}\n\t\t}\n\t}\n\tint d = n / 2;\n\tint x = v[0] / 2+1;\n\tif (x >= d) {\n\t\tll ans = mod_pow(2, d) - 1;\n\t\tans = ans * 2;\n\t\tans = (ans + mod) % mod;\n\t\tcout << ans << endl;\n\t}\n\telse {\n\t\tll ans = d * mod_pow(2, d -x-1)%mod;\n\t\t\n\t\tans = mod_pow(2, d) - 1 - ans;\n\t\tans = (ans%mod + mod) % mod;\n\t\tcout << ans*2%mod << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x)//  cerr << #x << \" = \" << x << endl\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ld PI = 3.14159265359;\n\nconst ll MOD = (ll) 1e9 + 7;\nconst ll MAXN = (ll) 2e5 + 10;\nconst ll INF = (ll) 2242545357980376863;\nconst ld EPS = (ld) 1e-8;\n\nvector<ll> A;\nll dp[MAXN], sm[MAXN];\n\nint main(){\n    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll n, m;\n\tcin >> n >> m;\n\tstr s;\n\tcin >> s;\n\t\n\tif(s[0] == 'B'){\n\t\tfor(int i = 0; i< m;i++) s[i] = ('R' + 'B') - s[i];\n\t}\n\tll cnt = 1;\n\tfor(int i = 1; i< m; i++){\n\t\tif(s[i] == s[i - 1]) cnt ++;\n\t\telse {\n\t\t\tA.pb(cnt);\n\t\t\tcnt = 1;\n\t\t}\n\t}\n\tA.pb(cnt);\n\tif(A.size() == 1){\n\t\t//debug(\"S\");\n\t\tdp[1] = 1;\n\t\tdp[2] = 0;\n\t\tsm[1] = 1;\n\t\tsm[2] = 1;\n\t\tfor(int i = 3; i <= n; i++){\n\t\t\tdp[i] = sm[i - 2];\n\t\t\tsm[i] = (dp[i] + sm[i - 1]) % MOD;\n\t\t}\n\t\tll ans = 1;\n\t\tfor(int len = 1; len <= n - 1; len ++){\n\t\t\tans += (len + 1) * dp[n - len];\n\t\t\tans %= MOD;\n\t\t}\n\t\tcout << ans;\n\t\treturn 0;\n\t\t/////\n\t}\n\t\n\tll mx;\n\t\n\tif(A[0] % 2 == 0 ) mx = A[0] + 1;\n\telse mx = A[0];\n\tfor(int i = 2; i < A.size(); i += 2){\n\t\tif(A[i] % 2 == 1) mx = max(mx, A[i]);\n\t}\n\tdebug(mx);\n\tdp[0] = 0;\n\tdp[1] = 1;\n\tdp[3] = 1;\n\tfor(int i = 5; i <= n; i++){\n\t\tdp[i] = dp[i - 2] + dp[i - 2];\n\t\tif(i >= mx + 3) dp[i] -= dp[i - mx - 3];\n\t\tdp[i] %= MOD;\n\t}\n\t//debug(dp[1]);\n\t//debug(dp[3]);\n\tll ans = 0;\n\tfor(int len = 1; len <= min(n, mx); len ++){\n\t\tans += (len + 1) * dp[n - len];\n\t\tans %= MOD;\n\t}\n\tcout << ans;\n\t\n\treturn 0;\n}\n\n\n/*\n\n                                 ____              ,----..               ,----..\n   ,---,                       ,'  , `.           /   /   \\             /   /   \\\n  '  .' \\                   ,-+-,.' _ |          /   .     :           /   .     :\n /  ;    '.              ,-+-. ;   , ||         .   /   ;.  \\         .   /   ;.  \\\n:  :       \\            ,--.'|'   |  ;|        .   ;   /  ` ;        .   ;   /  ` ;\n:  |   /\\   \\          |   |  ,', |  ':        ;   |  ; \\ ; |        ;   |  ; \\ ; |\n|  :  ' ;.   :         |   | /  | |  ||        |   :  | ; | '        |   :  | ; | '\n|  |  ;/  \\   \\        '   | :  | :  |,        .   |  ' ' ' :        .   |  ' ' ' :\n'  :  | \\  \\ ,'        ;   . |  ; |--'         '   ;  \\; /  |        '   ;  \\; /  |\n|  |  '  '--'          |   : |  | ,             \\   \\  ',  /          \\   \\  ',  /\n|  :  :                |   : '  |/               ;   :    /            ;   :    /\n|  | ,'                ;   | |`-'                 \\   \\ .'              \\   \\ .'\n`--''                  |   ;/                      `---`                 `---`\n                       '---'\n\n*/\n\n"
  },
  {
    "language": "Text",
    "code": "0\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\nint min(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nint sum(int l, int r, int *s){\n\tif(r < l){\n\t\treturn 0;\n\t}\n\tif(l <= 0){\n\t\treturn s[r];\n\t}\n\telse{\n\t\treturn MOD(s[r] - s[l - 1]);\n\t}\n}\n\nsigned main(){\n\tint N, M, i, j;\n\tscanf(\"%lld%lld\", &N, &M);\n\tchar *T = (char *)malloc(sizeof(char) * (M + 1));\n\tscanf(\"%s\", T);\n\tint *A = (int *)malloc(sizeof(int) * M);\n\tfor(i = 0; i < M; i++){\n\t\tif(T[i] == 'R'){\n\t\t\tA[i] = 0;\n\t\t}\n\t\telse{\n\t\t\tA[i] = 1;\n\t\t}\n\t}\n\tif(A[0] == 1){\n\t\tfor(i = 0; i < M; i++){\n\t\t\tA[i] ^= 1;\n\t\t}\n\t}\n\tint *val = (int *)malloc(sizeof(int) * M);\n\tint *num = (int *)malloc(sizeof(int) * M);\n\tval[0] = A[0];\n\tnum[0] = 1;\n\tfor(i = 1, j = 0; i < M; i++){\n\t\tif(A[i] == A[i - 1]){\n\t\t\tnum[j]++;\n\t\t}\n\t\telse{\n\t\t\tj++;\n\t\t\tval[j] = A[i];\n\t\t\tnum[j] = 1;\n\t\t}\n\t}\n\tint K = j + 1;\n\tif(K == 1){\n\t\tint *dp1 = (int *)malloc(sizeof(int) * N);\n\t\tdp1[0] = 1;\n\t\tint *S1 = (int *)malloc(sizeof(int) * N);\n\t\tS1[0] = 1;\n\t\tfor(i = 1; i < N; i++){\n\t\t\tdp1[i] = sum(0, i - 2, S1);\n\t\t\tS1[i] = MOD(S1[i - 1] + dp1[i]);\n\t\t}\n\t\tint ans = 1;\n\t\tfor(i = 1; i < N; i++){\n\t\t\tans = MOD(ans + (i + 1) * dp1[N - i - 1]);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t\treturn 0;\n\t}\n\tint Ooddmin = 2 * (num[0] / 2) + 1;\n\tfor(i = 0; i < K; i++){\n\t\tif(num[i] % 2 == 0 || val[i] == 1){\n\t\t\tcontinue;\n\t\t}\n\t\tOoddmin = min(Ooddmin, num[i]);\n\t}\n\tint *dp = (int *)malloc(sizeof(int) * N);\n\tdp[0] = 1;\n\tint **S = (int **)malloc(sizeof(int *) * 2);\n\tS[0] = (int *)malloc(sizeof(int) * N);\n\tS[0][0] = 1;\n\tS[1] = (int *)malloc(sizeof(int) * N);\n\tS[1][0] = 0;\n\tfor(i = 1; i < N; i++){\n\t\tdp[i] = sum(i - Ooddmin - 1, i - 2, S[i % 2]);\n\t\tS[i % 2][i] = MOD(S[i % 2][i - 1] + dp[i]);\n\t\tS[1 - i % 2][i] = S[1 - i % 2][i - 1];\n\t}\n\tint ans = 0;\n\tfor(i = 1; i <= Ooddmin; i += 2){\n\t\tans = MOD(ans + (i + 1) * dp[N - i - 1]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\nint min(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nint sum(int l, int r, int *s){\n\tif(r < l || r < 0){\n\t\treturn 0;\n\t}\n\tif(l <= 0){\n\t\treturn s[r];\n\t}\n\telse{\n\t\treturn MOD(s[r] - s[l - 1]);\n\t}\n}\n\nsigned main(){\n\tint N, M, i, j;\n\tscanf(\"%lld%lld\", &N, &M);\n\tchar *T = (char *)malloc(sizeof(char) * (M + 1));\n\tscanf(\"%s\", T);\n\tint *A = (int *)malloc(sizeof(int) * M);\n\tfor(i = 0; i < M; i++){\n\t\tif(T[i] == 'R'){\n\t\t\tA[i] = 0;\n\t\t}\n\t\telse{\n\t\t\tA[i] = 1;\n\t\t}\n\t}\n\tif(A[0] == 1){\n\t\tfor(i = 0; i < M; i++){\n\t\t\tA[i] ^= 1;\n\t\t}\n\t}\n\tint *val = (int *)malloc(sizeof(int) * M);\n\tint *num = (int *)malloc(sizeof(int) * M);\n\tval[0] = A[0];\n\tnum[0] = 1;\n\tfor(i = 1, j = 0; i < M; i++){\n\t\tif(A[i] == A[i - 1]){\n\t\t\tnum[j]++;\n\t\t}\n\t\telse{\n\t\t\tj++;\n\t\t\tval[j] = A[i];\n\t\t\tnum[j] = 1;\n\t\t}\n\t}\n\tint K = j + 1;\n\tif(K == 1){\n\t\tint *dp1 = (int *)malloc(sizeof(int) * N);\n\t\tdp1[0] = 1;\n\t\tint *S1 = (int *)malloc(sizeof(int) * N);\n\t\tS1[0] = 1;\n\t\tfor(i = 1; i < N; i++){\n\t\t\tdp1[i] = sum(0, i - 2, S1);\n\t\t\tS1[i] = MOD(S1[i - 1] + dp1[i]);\n\t\t}\n\t\tint ans = 1;\n\t\tfor(i = 1; i < N; i++){\n\t\t\tans = MOD(ans + (i + 1) * dp1[N - i - 1]);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t\treturn 0;\n\t}\n\tif(N % 2 == 1){\n\t\ti = 0;\n\t\tprintf(\"%d\\n\", j / i);\n\t\treturn 0;\n\t}\n\tint Ooddmin = 2 * (num[0] / 2) + 1;\n\tfor(i = 0; i < K; i++){\n\t\tif(num[i] % 2 == 0 || val[i] == 1){\n\t\t\tcontinue;\n\t\t}\n\t\tOoddmin = min(Ooddmin, num[i]);\n\t}\n\tint *dp = (int *)malloc(sizeof(int) * N);\n\tdp[0] = 1;\n\tint **S = (int **)malloc(sizeof(int *) * 2);\n\tS[0] = (int *)malloc(sizeof(int) * N);\n\tS[0][0] = 1;\n\tS[1] = (int *)malloc(sizeof(int) * N);\n\tS[1][0] = 0;\n\tfor(i = 1; i < N; i++){\n\t\tdp[i] = sum(i - Ooddmin - 1, i - 2, S[i % 2]);\n\t\tS[i % 2][i] = MOD(S[i % 2][i - 1] + dp[i]);\n\t\tS[1 - i % 2][i] = S[1 - i % 2][i - 1];\n\t}\n/*\tfor(i = 0; i < N; i++){\n\t\tprintf(\"dp[%lld] = %lld\\n\", i, dp[i]);\n\t}\n*/\tint ans = 0;\n\tfor(i = 1; i <= Ooddmin; i += 2){\n\t\tans = MOD(ans + (i + 1) * dp[N - i - 1]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\nint min(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nint sum(int l, int r, int *s){\n\tif(r < l || r < 0){\n\t\treturn 0;\n\t}\n\tif(l <= 0){\n\t\treturn s[r];\n\t}\n\telse{\n\t\treturn MOD(s[r] - s[l - 1]);\n\t}\n}\n\nsigned main(){\n\tint N, M, i, j;\n\tscanf(\"%lld%lld\", &N, &M);\n\tchar *T = (char *)malloc(sizeof(char) * (M + 1));\n\tscanf(\"%s\", T);\n\tint *A = (int *)malloc(sizeof(int) * M);\n\tfor(i = 0; i < M; i++){\n\t\tif(T[i] == 'R'){\n\t\t\tA[i] = 0;\n\t\t}\n\t\telse{\n\t\t\tA[i] = 1;\n\t\t}\n\t}\n\tif(A[0] == 1){\n\t\tfor(i = 0; i < M; i++){\n\t\t\tA[i] ^= 1;\n\t\t}\n\t}\n\tint *val = (int *)malloc(sizeof(int) * M);\n\tint *num = (int *)malloc(sizeof(int) * M);\n\tval[0] = A[0];\n\tnum[0] = 1;\n\tfor(i = 1, j = 0; i < M; i++){\n\t\tif(A[i] == A[i - 1]){\n\t\t\tnum[j]++;\n\t\t}\n\t\telse{\n\t\t\tj++;\n\t\t\tval[j] = A[i];\n\t\t\tnum[j] = 1;\n\t\t}\n\t}\n\tint K = j + 1;\n\tif(K == 1){\n\t\tint *dp1 = (int *)malloc(sizeof(int) * N);\n\t\tdp1[0] = 1;\n\t\tint *S1 = (int *)malloc(sizeof(int) * N);\n\t\tS1[0] = 1;\n\t\tfor(i = 1; i < N; i++){\n\t\t\tdp1[i] = sum(0, i - 2, S1);\n\t\t\tS1[i] = MOD(S1[i - 1] + dp1[i]);\n\t\t}\n\t\tint ans = 1;\n\t\tfor(i = 1; i < N; i++){\n\t\t\tans = MOD(ans + (i + 1) * dp1[N - i - 1]);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t\treturn 0;\n\t}\n\tint Ooddmin = 2 * (num[0] / 2) + 1;\n\tfor(i = 0; i < K; i++){\n\t\tif(num[i] % 2 == 0 || val[i] == 1){\n\t\t\tcontinue;\n\t\t}\n\t\tOoddmin = min(Ooddmin, num[i]);\n\t}\n\tint *dp = (int *)malloc(sizeof(int) * N);\n\tdp[0] = 1;\n\tint **S = (int **)malloc(sizeof(int *) * 2);\n\tS[0] = (int *)malloc(sizeof(int) * N);\n\tS[0][0] = 1;\n\tS[1] = (int *)malloc(sizeof(int) * N);\n\tS[1][0] = 0;\n\tfor(i = 1; i < N; i++){\n\t\tdp[i] = sum(i - Ooddmin - 1, i - 2, S[i % 2]);\n\t\tS[i % 2][i] = MOD(S[i % 2][i - 1] + dp[i]);\n\t\tS[1 - i % 2][i] = S[1 - i % 2][i - 1];\n\t}\n/*\tfor(i = 0; i < N; i++){\n\t\tprintf(\"dp[%lld] = %lld\\n\", i, dp[i]);\n\t}\n*/\tint ans = 0;\n\tfor(i = 1; i <= min(Ooddmin, N - 1); i += 2){\n\t\tans = MOD(ans + (i + 1) * dp[N - i - 1]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\nint min(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nint sum(int l, int r, int *s){\n\tif(r < l || r < 0){\n\t\treturn 0;\n\t}\n\tif(l <= 0){\n\t\treturn s[r];\n\t}\n\telse{\n\t\treturn MOD(s[r] - s[l - 1]);\n\t}\n}\n\nsigned main(){\n\tint N, M, i, j;\n\tscanf(\"%lld%lld\", &N, &M);\n\tchar *T = (char *)malloc(sizeof(char) * (M + 1));\n\tscanf(\"%s\", T);\n\tint *A = (int *)malloc(sizeof(int) * M);\n\tfor(i = 0; i < M; i++){\n\t\tif(T[i] == 'R'){\n\t\t\tA[i] = 0;\n\t\t}\n\t\telse{\n\t\t\tA[i] = 1;\n\t\t}\n\t}\n\tif(A[0] == 1){\n\t\tfor(i = 0; i < M; i++){\n\t\t\tA[i] ^= 1;\n\t\t}\n\t}\n\tint *val = (int *)malloc(sizeof(int) * M);\n\tint *num = (int *)malloc(sizeof(int) * M);\n\tval[0] = A[0];\n\tnum[0] = 1;\n\tfor(i = 1, j = 0; i < M; i++){\n\t\tif(A[i] == A[i - 1]){\n\t\t\tnum[j]++;\n\t\t}\n\t\telse{\n\t\t\tj++;\n\t\t\tval[j] = A[i];\n\t\t\tnum[j] = 1;\n\t\t}\n\t}\n\tint K = j + 1;\n\tif(K == 1){\n\t\tint *dp1 = (int *)malloc(sizeof(int) * N);\n\t\tdp1[0] = 1;\n\t\tint *S1 = (int *)malloc(sizeof(int) * N);\n\t\tS1[0] = 1;\n\t\tfor(i = 1; i < N; i++){\n\t\t\tdp1[i] = sum(0, i - 2, S1);\n\t\t\tS1[i] = MOD(S1[i - 1] + dp1[i]);\n\t\t}\n\t\tint ans = 1;\n\t\tfor(i = 1; i < N; i++){\n\t\t\tans = MOD(ans + (i + 1) * dp1[N - i - 1]);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t\treturn 0;\n\t}\n\tint Ooddmin = 2 * (num[0] / 2) + 1;\n\tfor(i = 0; i < K; i++){\n\t\tif(num[i] % 2 == 0 || val[i] == 1){\n\t\t\tcontinue;\n\t\t}\n\t\tOoddmin = min(Ooddmin, num[i]);\n\t}\n\tint *dp = (int *)malloc(sizeof(int) * N);\n\tdp[0] = 1;\n\tint **S = (int **)malloc(sizeof(int *) * 2);\n\tS[0] = (int *)malloc(sizeof(int) * N);\n\tS[0][0] = 1;\n\tS[1] = (int *)malloc(sizeof(int) * N);\n\tS[1][0] = 0;\n\tfor(i = 1; i < N; i++){\n\t\tdp[i] = sum(i - Ooddmin - 1, i - 2, S[i % 2]);\n\t\tS[i % 2][i] = MOD(S[i % 2][i - 1] + dp[i]);\n\t\tS[1 - i % 2][i] = S[1 - i % 2][i - 1];\n\t}\n/*\tfor(i = 0; i < N; i++){\n\t\tprintf(\"dp[%lld] = %lld\\n\", i, dp[i]);\n\t}\n*/\tint ans = 0;\n\tfor(i = 1; i <= Ooddmin; i += 2){\n\t\tans = MOD(ans + (i + 1) * dp[N - i - 1]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\nint min(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nint sum(int l, int r, int *s){\n\tif(r < l || r < 0){\n\t\treturn 0;\n\t}\n\tif(l <= 0){\n\t\treturn s[r];\n\t}\n\telse{\n\t\treturn MOD(s[r] - s[l - 1]);\n\t}\n}\n\nsigned main(){\n\tint N, M, i, j;\n\tscanf(\"%lld%lld\", &N, &M);\n\tchar *T = (char *)malloc(sizeof(char) * (M + 1));\n\tscanf(\"%s\", T);\n\tint *A = (int *)malloc(sizeof(int) * M);\n\tfor(i = 0; i < M; i++){\n\t\tif(T[i] == 'R'){\n\t\t\tA[i] = 0;\n\t\t}\n\t\telse{\n\t\t\tA[i] = 1;\n\t\t}\n\t}\n\tif(A[0] == 1){\n\t\tfor(i = 0; i < M; i++){\n\t\t\tA[i] ^= 1;\n\t\t}\n\t}\n\tint *val = (int *)malloc(sizeof(int) * M);\n\tint *num = (int *)malloc(sizeof(int) * M);\n\tval[0] = A[0];\n\tnum[0] = 1;\n\tfor(i = 1, j = 0; i < M; i++){\n\t\tif(A[i] == A[i - 1]){\n\t\t\tnum[j]++;\n\t\t}\n\t\telse{\n\t\t\tj++;\n\t\t\tval[j] = A[i];\n\t\t\tnum[j] = 1;\n\t\t}\n\t}\n\tint K = j + 1;\n\tif(K == 1){\n\t\tint *dp1 = (int *)malloc(sizeof(int) * N);\n\t\tdp1[0] = 1;\n\t\tint *S1 = (int *)malloc(sizeof(int) * N);\n\t\tS1[0] = 1;\n\t\tfor(i = 1; i < N; i++){\n\t\t\tdp1[i] = sum(0, i - 2, S1);\n\t\t\tS1[i] = MOD(S1[i - 1] + dp1[i]);\n\t\t}\n\t\tint ans = 1;\n\t\tfor(i = 1; i < N; i++){\n\t\t\tans = MOD(ans + (i + 1) * dp1[N - i - 1]);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t\treturn 0;\n\t}\n\tint Ooddmin = 2 * (num[0] / 2) + 1;\n\tfor(i = 0; i < K - 1; i++){\n\t\tif(num[i] % 2 == 0 || val[i] == 1){\n\t\t\tcontinue;\n\t\t}\n\t\tOoddmin = min(Ooddmin, num[i]);\n\t}\n\tint *dp = (int *)malloc(sizeof(int) * N);\n\tdp[0] = 1;\n\tint **S = (int **)malloc(sizeof(int *) * 2);\n\tS[0] = (int *)malloc(sizeof(int) * N);\n\tS[0][0] = 1;\n\tS[1] = (int *)malloc(sizeof(int) * N);\n\tS[1][0] = 0;\n\tfor(i = 1; i < N; i++){\n\t\tdp[i] = sum(i - Ooddmin - 1, i - 2, S[i % 2]);\n\t\tS[i % 2][i] = MOD(S[i % 2][i - 1] + dp[i]);\n\t\tS[1 - i % 2][i] = S[1 - i % 2][i - 1];\n\t}\n/*\tprintf(\"dp:\\n\");\n\tfor(i = 0; i < N; i++){\n\t\tprintf(\"%lld \", dp[i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"S0\\n\");\n\tfor(i = 0; i < N; i++){\n\t\tprintf(\"%lld \", S[0][i]);\n\t}\n\tprintf(\"\\n\");\n\tprintf(\"S1\\n\");\n\tfor(i = 0; i < N; i++){\n\t\tprintf(\"%lld \", S[1][i]);\n\t}\n\tprintf(\"\\n\");\n*/\tint ans = 0;\n\tfor(i = 1; i <= min(Ooddmin, N - 1); i += 2){\n\t\tans = MOD(ans + (i + 1) * dp[N - i - 1]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\nint min(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nint sum(int l, int r, int *s){\n\tif(r < l){\n\t\treturn 0;\n\t}\n\tif(l <= 0){\n\t\treturn s[r];\n\t}\n\telse{\n\t\treturn MOD(s[r] - s[l - 1]);\n\t}\n}\n\nsigned main(){\n\tint N, M, i, j;\n\tscanf(\"%lld%lld\", &N, &M);\n\tchar *T = (char *)malloc(sizeof(char) * (M + 1));\n\tscanf(\"%s\", T);\n\tint *A = (int *)malloc(sizeof(int) * M);\n\tfor(i = 0; i < M; i++){\n\t\tif(T[i] == 'R'){\n\t\t\tA[i] = 0;\n\t\t}\n\t\telse{\n\t\t\tA[i] = 1;\n\t\t}\n\t}\n\tif(A[0] == 1){\n\t\tfor(i = 0; i < M; i++){\n\t\t\tA[i] ^= 1;\n\t\t}\n\t}\n\tint *val = (int *)malloc(sizeof(int) * M);\n\tint *num = (int *)malloc(sizeof(int) * M);\n\tval[0] = A[0];\n\tnum[0] = 1;\n\tfor(i = 1, j = 0; i < M; i++){\n\t\tif(A[i] == A[i - 1]){\n\t\t\tnum[j]++;\n\t\t}\n\t\telse{\n\t\t\tj++;\n\t\t\tval[j] = A[i];\n\t\t\tnum[j] = 1;\n\t\t}\n\t}\n\tint K = j + 1;\n\tif(K == 1){\n\t\tint *dp1 = (int *)malloc(sizeof(int) * N);\n\t\tdp1[0] = 1;\n\t\tint *S1 = (int *)malloc(sizeof(int) * N);\n\t\tS1[0] = 1;\n\t\tfor(i = 1; i < N; i++){\n\t\t\tdp1[i] = sum(0, i - 2, S1);\n\t\t\tS1[i] = MOD(S1[i - 1] + dp1[i]);\n\t\t}\n\t\tint ans = 1;\n\t\tfor(i = 1; i < N; i++){\n\t\t\tans = MOD(ans + (i + 1) * dp1[N - i - 1]);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t\treturn 0;\n\t}\n\tint Ooddmin = num[0] + 1;\n\tfor(i = 0; i < K; i++){\n\t\tif(num[i] % 2 == 0 || val[i] == 1){\n\t\t\tcontinue;\n\t\t}\n\t\tOoddmin = min(Ooddmin, num[i]);\n\t}\n\tint *dp = (int *)malloc(sizeof(int) * N);\n\tdp[0] = 1;\n\tint **S = (int **)malloc(sizeof(int *) * 2);\n\tS[0] = (int *)malloc(sizeof(int) * N);\n\tS[0][0] = 1;\n\tS[1] = (int *)malloc(sizeof(int) * N);\n\tS[1][0] = 0;\n\tfor(i = 1; i < N; i++){\n\t\tdp[i] = sum(i - Ooddmin - 1, i - 2, S[i % 2]);\n\t\tS[i % 2][i] = MOD(S[i % 2][i - 1] + dp[i]);\n\t\tS[1 - i % 2][i] = S[1 - i % 2][i - 1];\n\t}\n\tint ans = 0;\n\tfor(i = 1; i <= Ooddmin; i += 2){\n\t\tans = MOD(ans + (i + 1) * dp[N - i - 1]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 20000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX * 2 + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\nhwll gin[N_MAX];\n// here we go\n\null parent[N_MAX], size[N_MAX];\nvoid init (ull n) {\n\tfor (sll i = 0; i < n; i++) {\n\t\tparent[i] = i;\n\t\tsize[i] = 1;\n\t}\n}\null find (ull x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = find(parent[x]);\n}\nbool unite (ull a, ull b) {\n\ta = find(a);\n\tb = find(b);\n\n\tif (a == b) return false;\n\n\tif (size[a] < size[b]) {\n\t\ta ^= b;\n\t\tb ^= a;\n\t\ta ^= b;\n\t}\n\tsize[a] += size[b];\n\tparent[b] = a;\n\treturn true;\n}\n\null fib[N_MAX];\n\null len = 0;\n\null beg = 500000,  end = 500000;\n\null dp[N_MAX], dq[N_MAX];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tfib[0] = fib[1] = 1;\n\tfor (i = 2; i <= n; i++) {\n\t\tfib[i] = (fib[i - 1] + fib[i - 2]) % MOD;\n\t}\n\n\t// if (m >= 2 && s[0] != s[1]) {\n\t// \tif (n % 2) {\n\t// \t\tresult = 0;\n\t// \t} else {\n\t// \t\tresult = 2;\n\t// \t}\n\t// } else {\n\t// \t//\n\t// }\n\tfor (i = 0; i < m; i++) {\n\t\tif (s[i] != s[0]) break;\n\t}\n\tif (i == m) {\n\t\tif (n == 1) result = 1;\n\t\telse result = (fib[n - 1] + fib[n - 2] * 2) % MOD;\n\t} else {\n\n\t\tif (n % 2) goto fail;\n\n\t\tull l;\n\t\tl = 0;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tif (s[i] != s[0]) {\n\t\t\t\tb[len++] = l;\n\t\t\t\tl = 0;\n\t\t\t} else {\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\n\t\tull maxl = n - 1;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (b[i] % 2) {\n\t\t\t\tmaxl = smin(maxl, b[i]);\n\t\t\t} else if (i == 0) {\n\t\t\t\tmaxl = smin(maxl, b[i] + 1);\n\t\t\t}\n\t\t}\n\t\t// maxl = smin(maxl, n - 1);\n\n\t\tdp[0] = dq[0] = 1;\n\t\t// printf(\"%llu!\\n\", maxl);\n\n\t\tfor (i = 2; i <= n; i++) {\n\t\t\tsll sub = ((i >= (maxl + 1) + 2) ? dq[i - (maxl + 1) - 2] : 0);\n\t\t\tdp[i] = (MOD + dq[i - 2] - sub) % MOD;\n\t\t\tdq[i] = (dq[i - 2] + dp[i]) % MOD;\n\t\t\t// printf(\"%lld: %llu\\n\", i, dp[i]);\n\t\t}\n\n\t\tresult = 0;\n\t\tfor (i = 1; i <= (maxl + 1) / 2; i++) {\n\t\t\tresult += dp[n - i * 2] * i * 2 % MOD;\n\t\t\tresult %= MOD;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\t// puts(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\tscanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < 0; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// scanf(\"%lld\", &e[i]);\n\t// \t// d[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define p (int)(1e9 + 7)\n\nint MOD(int a){\n\ta %= p;\n\treturn a >= 0 ? a : a + p;\n}\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\nint min(int a, int b){\n\treturn a <= b ? a : b;\n}\n\nint sum(int l, int r, int *s){\n\tif(r < l){\n\t\treturn 0;\n\t}\n\tif(l <= 0){\n\t\treturn s[r];\n\t}\n\telse{\n\t\treturn MOD(s[r] - s[l - 1]);\n\t}\n}\n\nsigned main(){\n\tint N, M, i, j;\n\tscanf(\"%lld%lld\", &N, &M);\n\tchar *T = (char *)malloc(sizeof(char) * (M + 1));\n\tscanf(\"%s\", T);\n\tint *A = (int *)malloc(sizeof(int) * M);\n\tfor(i = 0; i < M; i++){\n\t\tif(T[i] == 'R'){\n\t\t\tA[i] = 0;\n\t\t}\n\t\telse{\n\t\t\tA[i] = 1;\n\t\t}\n\t}\n\tif(A[0] == 1){\n\t\tfor(i = 0; i < M; i++){\n\t\t\tA[i] ^= 1;\n\t\t}\n\t}\n\tint *val = (int *)malloc(sizeof(int) * M);\n\tint *num = (int *)malloc(sizeof(int) * M);\n\tval[0] = A[0];\n\tnum[0] = 1;\n\tfor(i = 1, j = 0; i < M; i++){\n\t\tif(A[i] == A[i - 1]){\n\t\t\tnum[j]++;\n\t\t}\n\t\telse{\n\t\t\tj++;\n\t\t\tval[j] = A[i];\n\t\t\tnum[j] = 1;\n\t\t}\n\t}\n\tint K = j + 1;\n\tif(K == 1){\n\t\ti = 0;\n\t\tprintf(\"%d\\n\", j / i);\n\t\tint *dp1 = (int *)malloc(sizeof(int) * N);\n\t\tdp1[0] = 1;\n\t\tint *S1 = (int *)malloc(sizeof(int) * N);\n\t\tS1[0] = 1;\n\t\tfor(i = 1; i < N; i++){\n\t\t\tdp1[i] = sum(0, i - 2, S1);\n\t\t\tS1[i] = MOD(S1[i - 1] + dp1[i]);\n\t\t}\n\t\tint ans = 1;\n\t\tfor(i = 1; i < N; i++){\n\t\t\tans = MOD(ans + (i + 1) * dp1[N - i - 1]);\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t\treturn 0;\n\t}\n\tint Ooddmin = 2 * (num[0] / 2) + 1;\n\tfor(i = 0; i < K; i++){\n\t\tif(num[i] % 2 == 0 || val[i] == 1){\n\t\t\tcontinue;\n\t\t}\n\t\tOoddmin = min(Ooddmin, num[i]);\n\t}\n\tint *dp = (int *)malloc(sizeof(int) * N);\n\tdp[0] = 1;\n\tint **S = (int **)malloc(sizeof(int *) * 2);\n\tS[0] = (int *)malloc(sizeof(int) * N);\n\tS[0][0] = 1;\n\tS[1] = (int *)malloc(sizeof(int) * N);\n\tS[1][0] = 0;\n\tfor(i = 1; i < N; i++){\n\t\tdp[i] = sum(i - Ooddmin - 1, i - 2, S[i % 2]);\n\t\tS[i % 2][i] = MOD(S[i % 2][i - 1] + dp[i]);\n\t\tS[1 - i % 2][i] = S[1 - i % 2][i - 1];\n\t}\n\tint ans = 0;\n\tfor(i = 1; i <= Ooddmin; i += 2){\n\t\tans = MOD(ans + (i + 1) * dp[N - i - 1]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 20000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX * 2 + 5];\nhwllc tup[N_MAX + 5];\n// sll table[3005][3005];\nhwll gin[N_MAX];\n// here we go\n\null parent[N_MAX], size[N_MAX];\nvoid init (ull n) {\n\tfor (sll i = 0; i < n; i++) {\n\t\tparent[i] = i;\n\t\tsize[i] = 1;\n\t}\n}\null find (ull x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = find(parent[x]);\n}\nbool unite (ull a, ull b) {\n\ta = find(a);\n\tb = find(b);\n\n\tif (a == b) return false;\n\n\tif (size[a] < size[b]) {\n\t\ta ^= b;\n\t\tb ^= a;\n\t\ta ^= b;\n\t}\n\tsize[a] += size[b];\n\tparent[b] = a;\n\treturn true;\n}\n\null fib[N_MAX];\n\null len = 0;\n\null beg = 500000,  end = 500000;\n\null dp[N_MAX], dq[N_MAX];\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tfib[0] = fib[1] = 1;\n\tfor (i = 2; i <= n; i++) {\n\t\tfib[i] = (fib[i - 1] + fib[i - 2]) % MOD;\n\t}\n\n\t// if (m >= 2 && s[0] != s[1]) {\n\t// \tif (n % 2) {\n\t// \t\tresult = 0;\n\t// \t} else {\n\t// \t\tresult = 2;\n\t// \t}\n\t// } else {\n\t// \t//\n\t// }\n\tfor (i = 0; i < m; i++) {\n\t\tif (s[i] != s[0]) break;\n\t}\n\tif (i == m) {\n\t\tif (n == 1) result = 1;\n\t\telse result = (fib[n - 1] + fib[n - 2] * 2) % MOD;\n\t} else {\n\n\t\tif (n % 2) goto fail;\n\n\t\tull l;\n\t\tl = 0;\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tif (s[i] != s[0]) {\n\t\t\t\tb[len++] = l;\n\t\t\t\tl = 0;\n\t\t\t} else {\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\n\t\tull maxl = VERYBIG;\n\t\tfor (i = 0; i < len; i++) {\n\t\t\tif (b[i] % 2) {\n\t\t\t\tmaxl = smin(maxl, b[i]);\n\t\t\t} else {\n\t\t\t\tmaxl = smin(maxl, b[i] + 1);\n\t\t\t}\n\t\t}\n\t\tmaxl = smin(maxl, n - 1);\n\n\t\tdp[0] = dq[0] = 1;\n\n\t\tfor (i = 2; i <= n; i++) {\n\t\t\tsll sub = ((i >= (maxl + 1) + 2) ? dq[i - (maxl + 1) - 2] : 0);\n\t\t\tdp[i] = (MOD + dq[i - 2] - sub) % MOD;\n\t\t\tdq[i] = (dq[i - 2] + dp[i]) % MOD;\n\t\t}\n\n\t\tresult = 0;\n\t\tfor (i = 1; i <= (maxl + 1) / 2; i++) {\n\t\t\tresult += dp[n - i * 2] * i * 2 % MOD;\n\t\t\tresult %= MOD;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\t// puts(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\tputs(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\tscanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &a[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < 0; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\ta[i]--;\n\t\tb[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \tscanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// scanf(\"%lld\", &e[i]);\n\t// \t// d[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < n; i++) {\n\t// \tfor (j = 0; j < m; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        boolean local = false;\n        boolean async = false;\n\n        Charset charset = Charset.forName(\"ascii\");\n\n        FastIO io = local ? new FastIO(new FileInputStream(\"D:\\\\DATABASE\\\\TESTCASE\\\\Code.in\"), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, \"dalt\", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(\"\\n\\n--memory -- \\n\" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + \"M\");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e8;\n        Modular modular = new Modular((int) 1e9 + 7);\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            solve();\n        }\n\n        public void solve() {\n            int n = io.readInt();\n            int m = io.readInt();\n            char[] s = new char[m];\n            io.readString(s, 0);\n            if (s[0] != 'R') {\n                for (int j = 0; j < m; j++) {\n                    if (s[j] == 'R') {\n                        s[j] = 'B';\n                    } else {\n                        s[j] = 'R';\n                    }\n                }\n            }\n            boolean allR = true;\n            int firstB = 0;\n            for (int i = 0; i < m; i++) {\n                char c = s[i];\n                if (c != 'R') {\n                    firstB = i;\n                    allR = false;\n                    break;\n                }\n            }\n\n            if (allR) {\n                io.cache.append(dp(n, 2, n) + 1);\n                return;\n            }\n            int currentPeriod = 0;\n            int dist = firstB % 2 == 0 ? firstB + 1 : firstB;\n            for (int i = firstB; i < m; i++) {\n                char c = s[i];\n                if (c == 'R') {\n                    currentPeriod++;\n                } else {\n                    if (currentPeriod % 2 != 0) {\n                        dist = Math.min(dist, currentPeriod);\n                    }\n                    currentPeriod = 0;\n                }\n            }\n\n            if (n % 2 != 0) {\n                io.cache.append(0);\n                return;\n            }\n            io.cache.append(modular.mul(dp(n / 2, 1, (dist + 1) / 2), 2));\n        }\n\n        //Paint n edges, each connected edge component has size less than t+1 and greater than 0\n        public int dp(int n, int l, int r) {\n            int[] dp = new int[n + 1];\n            dp[0] = 1;\n            int[] preSum = new int[n + 1];\n            preSum[0] = 1;\n            for (int i = 1; i < n; i++) {\n                preSum[i] = preSum[i - 1];\n                if (l > i) {\n                    continue;\n                }\n                dp[i] = preSum[i - l];\n                if (i - r - 1 >= 0) {\n                    dp[i] = modular.plus(dp[i], -preSum[i - r - 1]);\n                }\n                preSum[i] = modular.plus(dp[i], preSum[i]);\n            }\n            for (int i = l; i <= r && i <= n; i++) {\n                int count = modular.mul(dp[n - i], i);\n                dp[n] = modular.plus(dp[n], count);\n            }\n            return dp[n];\n        }\n    }\n\n    /**\n     * 模运算\n     */\n    public static class Modular {\n        final int m;\n\n        public Modular(int m) {\n            this.m = m;\n        }\n\n        public int valueOf(int x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return x;\n        }\n\n        public int valueOf(long x) {\n            x %= m;\n            if (x < 0) {\n                x += m;\n            }\n            return (int) x;\n        }\n\n        public int mul(int x, int y) {\n            return valueOf((long) x * y);\n        }\n\n        public int plus(int x, int y) {\n            return valueOf(x + y);\n        }\n\n        @Override\n        public String toString() {\n            return \"mod \" + m;\n        }\n    }\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder();\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 8);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(\"ascii\"));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() {\n            try {\n                os.write(cache.toString().getBytes(charset));\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + \" = \");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.min;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic final int MOD = 1000000007;\n\n\tstatic int add(int a, int b) {\n\t\tint res = a + b;\n\t\treturn res >= MOD ? res - MOD : res;\n\t}\n\n\tstatic int sub(int a, int b) {\n\t\tint res = a - b;\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int mul(int a, int b) {\n\t\tint res = (int) ((long) a * b % MOD);\n\t\treturn res < 0 ? res + MOD : res;\n\t}\n\n\tstatic int fib(int i) {\n\t\tint c0 = 0, c1 = 1;\n\t\twhile (i-- > 0) {\n\t\t\tint c2 = add(c0, c1);\n\t\t\tc0 = c1;\n\t\t\tc1 = c2;\n\t\t}\n\t\treturn c0;\n\t}\n\n\tstatic void solve() throws Exception {\n\t\tint n = scanInt(), m = scanInt();\n\t\tString s = scanString();\n\t\tchar c1 = s.charAt(0);\n\t\tboolean diff = false;\n\t\tint cnt = 1, cntMin = Integer.MAX_VALUE;\n\t\tfor (int i = 1; i < m; i++) {\n\t\t\tif (s.charAt(i) == c1) {\n\t\t\t\t++cnt;\n\t\t\t} else {\n\t\t\t\tif (cnt % 2 == 1 || !diff) {\n\t\t\t\t\tcntMin = min(cntMin, cnt);\n\t\t\t\t}\n\t\t\t\tdiff = true;\n\t\t\t\tcnt = 0;\n\t\t\t}\n\t\t}\n\t\tint ans;\n\t\tif (diff) {\n\t\t\tif (n % 2 == 0) {\n\t\t\t\tn /= 2;\n\t\t\t\tans = 0;\n\t\t\t\tint k = cntMin / 2;\n//\t\t\t\tSystem.err.println(n + \" \" + k);\n\t\t\t\tint dyn[] = new int[k + 1];\n\t\t\t\tdyn[0] = 1;\n\t\t\t\tint sum = 1;\n\t\t\t\tfor (int i = 0; i < n; i++) {\n//\t\t\t\t\tSystem.err.println(i + \" \" + dyn[i % (k + 1)]);\n\t\t\t\t\tif (i + 1 + k >= n) {\n\t\t\t\t\t\tans = add(ans, mul(dyn[i % (k + 1)], n - i));\n\t\t\t\t\t}\n\t\t\t\t\tint v = sum;\n\t\t\t\t\tsum = sub(sum, dyn[(i + 1) % (k + 1)]);\n\t\t\t\t\tdyn[(i + 1) % (k + 1)] = v;\n\t\t\t\t\tsum = add(sum, v);\n\t\t\t\t}\n\t\t\t\tans = add(ans, ans);\n\t\t\t} else {\n\t\t\t\tans = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tans = add(fib(n - 1), fib(n + 1));\n\t\t}\n\t\tout.print(ans);\n\t}\n\n\tstatic int scanInt() throws IOException {\n\t\treturn parseInt(scanString());\n\t}\n\n\tstatic long scanLong() throws IOException {\n\t\treturn parseLong(scanString());\n\t}\n\n\tstatic String scanString() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n//\tstatic String INPUT = \"12 10 RRRRBRRRRB\";\n//\tstatic String INPUT = \"4 7 RBRRBRR\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tchar[] s = ns(m);\n\t\t// 1:1\n\t\t// 2:1,3\n\t\t// 3:1,3,5\n\t\tint same = 0;\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tif(s[i] == s[0]){\n\t\t\t\tsame++;\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlong ans = 0;\n\t\tint mod = 1000000007;\n\t\tif(same == m){\n\t\t\tint l0 = -1;\n\t\t\tint l1 = 2;\n\t\t\tfor(int i = 1;i <= n;i++){\n\t\t\t\tint l2 = l1 + l0;\n\t\t\t\tl2 %= mod;\n\t\t\t\tl0 = l1; l1 = l2;\n\t\t\t}\n\t\t\tout.println(l1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(n % 2 == 0){\n\t\t\t// same=2->3->2\n\t\t\t// same=3->3->2\n\t\t\tlong[] dp = new long[n/2+1];\n\t\t\tdp[0] = 1;\n\t\t\tlong sum = dp[0];\n\t\t\tfor(int i = 1;i <= n/2;i++){\n\t\t\t\tif(i-(same/2+1+1) >= 0){\n\t\t\t\t\tsum -= dp[i-(same/2+1+1)];\n\t\t\t\t\tif(sum < 0)sum += mod;\n\t\t\t\t}\n\t\t\t\tdp[i] = sum;\n\t\t\t\tsum += dp[i];\n\t\t\t\tsum %= mod;\n\t\t\t}\n\t\t\t// dp[n/2] + dp[n/2-1]*2\n\t\t\tfor(int i = 1;i <= same/2+1 && i <= n/2;i++){\n\t\t\t\tans += dp[n/2-i] * i;\n\t\t\t\tans %= mod;\n\t\t\t}\n\t\t\tout.println(ans*2%mod);\n\t\t}else{\n\t\t\tout.println(0);\n\t\t}\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            char[] s = in.readCharArray(m);\n            IntList sizes = new IntArrayList();\n            int start = 0;\n            for (int i = 1; i < m; i++) {\n                if (s[i] != s[i - 1]) {\n                    sizes.add(i - start);\n                    start = i;\n                }\n            }\n            sizes.add(m - start);\n            int max = sizes.get(0);\n            if (max % 2 == 0) {\n                max++;\n            }\n            for (int i = 2; i + 1 < sizes.size(); i++) {\n                int current = sizes.get(i);\n                if (current % 2 == 1) {\n                    max = Math.min(max, current);\n                }\n            }\n            if (sizes.size() == 1) {\n                long firstRlastR = 1;\n                long firstRlastB = 0;\n                long firstBlastR = 0;\n                long firstBlastB = 1;\n                for (int i = 1; i < n; i++) {\n                    long nextFirstRlastR = firstRlastB;\n                    long nextFirstRlastB = (firstRlastB + firstRlastR) % MiscUtils.MOD7;\n                    long nextFirstBlastR = firstBlastB;\n                    long nextFirstBlastB = (firstBlastB + firstBlastR) % MiscUtils.MOD7;\n                    firstRlastR = nextFirstRlastR;\n                    firstRlastB = nextFirstRlastB;\n                    firstBlastR = nextFirstBlastR;\n                    firstBlastB = nextFirstBlastB;\n                }\n                out.printLine((firstRlastB + firstBlastR + firstBlastB) % MiscUtils.MOD7);\n                return;\n            }\n            if (n % 2 == 1) {\n                out.printLine(0);\n                return;\n            }\n            n /= 2;\n            max /= 2;\n            long[] qty = new long[n + 1];\n            qty[0] = 1;\n            long sum = 1;\n            for (int i = 1; i <= n; i++) {\n                qty[i] = sum;\n//            if (i > 0) {\n                sum += qty[i];\n//            }\n                if (i >= max + 1) {\n                    sum -= qty[i - (max + 1)];\n                }\n                sum %= MiscUtils.MOD7;\n                if (sum < 0) {\n                    sum += MiscUtils.MOD7;\n                }\n            }\n            long answer = 0;\n            for (int i = 0; i <= max && (i + 1) <= n; i++) {\n                answer += (i + 1) * qty[n - i - 1] % MiscUtils.MOD7;\n            }\n            out.printLine(answer * 2 % MiscUtils.MOD7);\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n    }\n\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        public IntIterator intIterator();\n\n        default public Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n\n        default public int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n\n    }\n\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n\n        public boolean advance();\n\n        public boolean isValid();\n\n    }\n\n    static class IntArrayList extends IntAbstractStream implements IntList {\n        private int size;\n        private int[] data;\n\n        public IntArrayList() {\n            this(3);\n        }\n\n        public IntArrayList(int capacity) {\n            data = new int[capacity];\n        }\n\n        public IntArrayList(IntCollection c) {\n            this(c.size());\n            addAll(c);\n        }\n\n        public IntArrayList(IntStream c) {\n            this();\n            if (c instanceof IntCollection) {\n                ensureCapacity(((IntCollection) c).size());\n            }\n            addAll(c);\n        }\n\n        public IntArrayList(IntArrayList c) {\n            size = c.size();\n            data = c.data.clone();\n        }\n\n        public IntArrayList(int[] arr) {\n            size = arr.length;\n            data = arr.clone();\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int get(int at) {\n            if (at >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size);\n            }\n            return data[at];\n        }\n\n        private void ensureCapacity(int capacity) {\n            if (data.length >= capacity) {\n                return;\n            }\n            capacity = Math.max(2 * data.length, capacity);\n            data = Arrays.copyOf(data, capacity);\n        }\n\n        public void addAt(int index, int value) {\n            ensureCapacity(size + 1);\n            if (index > size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size) {\n                System.arraycopy(data, index, data, index + 1, size - index);\n            }\n            data[index] = value;\n            size++;\n        }\n\n        public void removeAt(int index) {\n            if (index >= size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size - 1) {\n                System.arraycopy(data, index + 1, data, index, size - index - 1);\n            }\n            size--;\n        }\n\n    }\n\n    static interface IntReversableCollection extends IntCollection {\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public char[] readCharArray(int size) {\n            char[] array = new char[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readCharacter();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public char readCharacter() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n\n        public abstract void addAt(int index, int value);\n\n        public abstract void removeAt(int index);\n\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n\n        default public void add(int value) {\n            addAt(size(), value);\n        }\n\n    }\n\n    static interface IntCollection extends IntStream {\n        public int size();\n\n        default public void add(int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        default public IntCollection addAll(IntStream values) {\n            for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {\n                add(it.value());\n            }\n            return this;\n        }\n\n    }\n\n    static abstract class IntAbstractStream implements IntStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String [] args) {\n        Solver s = new Solver();\n        s.solve();\n    }\n}\n\nclass Solver {\n    Reader in = new Reader ();\n    Writer out = new Writer ();\n    final int mod = 1000000000 + 7;\n\n    long same(int n) {\n        long [] dp = new long [n + 1];\n        long sum = 0;\n        dp[1] = 0;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = (i + sum) % mod;\n            sum = (sum + dp[i - 1]) % mod;\n        }\n        return (1 + dp[n]) % mod;\n    }\n    void solve () {\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        char [] s = in.next().toCharArray();\n        \n        int cnt = 0;\n        int min = m;\n        for(int i = 0; i < m; i++) {\n            if(i > 0 && s[i - 1] == s[i]) ++cnt;\n            else {\n                if(s[i] != s[0] && cnt % 2 == 1) {\n                    min = Math.min(min, cnt);\n                }\n                cnt = 1;\n            }\n        }\n        cnt = 0;\n        for(int i = 0; i < m; i++) {\n            if(s[i] == s[0]) ++cnt;\n            else break;\n        }\n        if(cnt % 2 == 0) {\n            min = Math.min(min, cnt + 1);\n        }\n        if(cnt == m) {\n            System.out.println(same(n));\n            System.exit(0);\n        }\n\n        long [] dp = new long [n + 1];\n        dp[1] = 0;\n        long [] sum = new long [2];\n        sum[0] = sum[1] = 0;\n\n        for(int i = 2; i <= n; i++) {\n            if(i - 1 <= min) {\n                dp[i] = i;\n            }\n            dp[i] = (dp[i] + sum[i % 2]) % mod;\n            sum[i % 2] = (sum[i % 2] + dp[i]) % mod;\n            if(i - 1 - min > 1) {\n                sum[i % 2] = (sum[i % 2] - dp[i - 1 - min]) % mod;\n            }\n        }\n        if(dp[n] < 0) dp[n] += mod;\n        System.out.println(dp[n]);\n    }\n}\n\nclass Reader {\n    private StringTokenizer a;\n    private BufferedReader b;\n    Reader () {\n        a = null;\n        try {\n            b = new BufferedReader (new InputStreamReader (System.in)); // for file IO, replace this with new FileReader (\"in.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public String next () {\n        while(a == null || !a.hasMoreTokens()) {\n            try {\n                a = new StringTokenizer (b.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return a.nextToken();\n    }\n    public int nextInt() {\n        return Integer.parseInt(this.next());\n    }\n    public long nextLong () {\n        return Long.parseLong(this.next());\n    }\n    public double nextDouble () {\n        return Double.parseDouble(this.next());\n    }\n    public String nextLine() {\n        try {\n            return b.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n}\nclass Writer {\n    private PrintWriter a;\n    private StringBuffer b;\n    Writer () {\n        try {\n            a = new PrintWriter (System.out); // for file IO, replace this with new FileWriter (\"out.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        b = new StringBuffer (\"\");\n    }\n    public void write (Object s) {\n        b.append(s);\n    }\n    public void writeln(Object s) {\n        b.append(s).append('\\n');\n    }\n    public void flush () {\n        a.print(b);\n        a.flush();\n        a.close();\n    }\n}\nclass Pair implements Comparator <Pair> {\n    int first;\n    int second;\n    Pair  (int a, int b) {\n        this.first = a;\n        this.second = b;\n    }\n    Pair (Pair a) {\n        this.first = a.first;\n        this.second = a.second;\n    }\n    Pair () {}\n    public String toString () {\n        return \"[\" + first + \", \" + second + \"]\";\n    }\n    public int compare (Pair a, Pair b) {\n        if(a.first == b.first) {\n            return a.second - b.second;\n        } else {\n            return a.first - b.first;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String [] args) {\n        Solver s = new Solver();\n        s.solve();\n    }\n}\n\nclass Solver {\n    Reader in = new Reader ();\n    Writer out = new Writer ();\n    final int mod = 1000000000 + 7;\n\n    long same(int n) {\n        long [] dp = new long [n + 1];\n        long sum = 0;\n        dp[1] = 0;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = (i + sum) % mod;\n            sum = (sum + dp[i - 1]) % mod;\n        }\n        return (1 + dp[n]) % mod;\n    }\n    void solve () {\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        char [] s = in.next().toCharArray();\n        \n        int cnt = 0;\n        int min = m;\n        for(int i = 0; i < m; i++) {\n            if(i > 0 && s[i - 1] == s[i]) ++cnt;\n            else {\n                if(s[i] != s[0] && cnt % 2 == 1) {\n                    // min = Math.min(min, cnt);\n                }\n                cnt = 1;\n            }\n        }\n        cnt = 0;\n        for(int i = 0; i < m; i++) {\n            if(s[i] == s[0]) ++cnt;\n            else break;\n        }\n        if(cnt % 2 == 0) {\n            min = Math.min(min, cnt + 1);\n        } else min = Math.min(min, cnt);\n      \n        if(cnt == m) {\n            System.out.println(same(n));\n            // s[1000000] = 'a';\n            System.exit(0);\n        }\n\n        long [] dp = new long [n + 1];\n        dp[1] = 0;\n        long [] sum = new long [2];\n        sum[0] = sum[1] = 0;\n\n        for(int i = 2; i <= n; i++) {\n            if(i - 1 <= min) {\n                dp[i] = i;\n            }\n            dp[i] = (dp[i] + sum[i % 2]) % mod;\n            sum[i % 2] = (sum[i % 2] + dp[i]) % mod;\n            if(i - 1 - min > 1) {\n                sum[i % 2] = (sum[i % 2] - dp[i - 1 - min]) % mod;\n            }\n        }\n        if(dp[n] < 0) dp[n] += mod;\n        System.out.println(dp[n]);\n    }\n}\n\nclass Reader {\n    private StringTokenizer a;\n    private BufferedReader b;\n    Reader () {\n        a = null;\n        try {\n            b = new BufferedReader (new InputStreamReader (System.in)); // for file IO, replace this with new FileReader (\"in.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public String next () {\n        while(a == null || !a.hasMoreTokens()) {\n            try {\n                a = new StringTokenizer (b.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return a.nextToken();\n    }\n    public int nextInt() {\n        return Integer.parseInt(this.next());\n    }\n    public long nextLong () {\n        return Long.parseLong(this.next());\n    }\n    public double nextDouble () {\n        return Double.parseDouble(this.next());\n    }\n    public String nextLine() {\n        try {\n            return b.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n}\nclass Writer {\n    private PrintWriter a;\n    private StringBuffer b;\n    Writer () {\n        try {\n            a = new PrintWriter (System.out); // for file IO, replace this with new FileWriter (\"out.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        b = new StringBuffer (\"\");\n    }\n    public void write (Object s) {\n        b.append(s);\n    }\n    public void writeln(Object s) {\n        b.append(s).append('\\n');\n    }\n    public void flush () {\n        a.print(b);\n        a.flush();\n        a.close();\n    }\n}\nclass Pair implements Comparator <Pair> {\n    int first;\n    int second;\n    Pair  (int a, int b) {\n        this.first = a;\n        this.second = b;\n    }\n    Pair (Pair a) {\n        this.first = a.first;\n        this.second = a.second;\n    }\n    Pair () {}\n    public String toString () {\n        return \"[\" + first + \", \" + second + \"]\";\n    }\n    public int compare (Pair a, Pair b) {\n        if(a.first == b.first) {\n            return a.second - b.second;\n        } else {\n            return a.first - b.first;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String [] args) {\n        Solver s = new Solver();\n        s.solve();\n    }\n}\n\nclass Solver {\n    Reader in = new Reader ();\n    Writer out = new Writer ();\n    final int mod = 1000000000 + 7;\n\n    long same(int n) {\n        long [] dp = new long [n + 1];\n        dp[1] = 0;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = i;\n            for(int j = 1; j < i; j++) {\n                dp[i] += dp[i - 1 - j];\n                dp[i] %= mod;\n            }\n        }\n        return (1 + dp[n]) % mod;\n    }\n    void solve () {\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        char [] s = in.next().toCharArray();\n        \n        int cnt = 0;\n        int min = m;\n        for(int i = 0; i < m; i++) {\n            if(i > 0 && s[i - 1] == s[i]) ++cnt;\n            else {\n                if(s[i] != s[0] && cnt % 2 == 1) {\n                    min = Math.min(min, cnt);\n                }\n                cnt = 1;\n            }\n        }\n        cnt = 0;\n        for(int i = 0; i < m; i++) {\n            if(s[i] == s[0]) ++cnt;\n            else break;\n        }\n        if(cnt % 2 == 0) {\n            min = Math.min(min, cnt + 1);\n        }\n        if(cnt == m) {\n            System.out.println(same(n));\n            System.exit(0);\n        }\n\n        long [] dp = new long [n + 1];\n        dp[1] = 0;\n        for(int i = 2; i <= n; i++) {\n            if(i - 1 <= min) {\n                dp[i] = i;\n            }\n            for(int j = 1; j <= min; j += 2) {\n                if(i - 1 - j < 1) break;\n                dp[i] += dp[i - 1 - j];\n                dp[i] %= mod;\n            } \n        }\n        System.out.println(dp[n]);\n    }\n}\n\nclass Reader {\n    private StringTokenizer a;\n    private BufferedReader b;\n    Reader () {\n        a = null;\n        try {\n            b = new BufferedReader (new InputStreamReader (System.in)); // for file IO, replace this with new FileReader (\"in.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public String next () {\n        while(a == null || !a.hasMoreTokens()) {\n            try {\n                a = new StringTokenizer (b.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return a.nextToken();\n    }\n    public int nextInt() {\n        return Integer.parseInt(this.next());\n    }\n    public long nextLong () {\n        return Long.parseLong(this.next());\n    }\n    public double nextDouble () {\n        return Double.parseDouble(this.next());\n    }\n    public String nextLine() {\n        try {\n            return b.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n}\nclass Writer {\n    private PrintWriter a;\n    private StringBuffer b;\n    Writer () {\n        try {\n            a = new PrintWriter (System.out); // for file IO, replace this with new FileWriter (\"out.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        b = new StringBuffer (\"\");\n    }\n    public void write (Object s) {\n        b.append(s);\n    }\n    public void writeln(Object s) {\n        b.append(s).append('\\n');\n    }\n    public void flush () {\n        a.print(b);\n        a.flush();\n        a.close();\n    }\n}\nclass Pair implements Comparator <Pair> {\n    int first;\n    int second;\n    Pair  (int a, int b) {\n        this.first = a;\n        this.second = b;\n    }\n    Pair (Pair a) {\n        this.first = a.first;\n        this.second = a.second;\n    }\n    Pair () {}\n    public String toString () {\n        return \"[\" + first + \", \" + second + \"]\";\n    }\n    public int compare (Pair a, Pair b) {\n        if(a.first == b.first) {\n            return a.second - b.second;\n        } else {\n            return a.first - b.first;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String [] args) {\n        Solver s = new Solver();\n        s.solve();\n    }\n}\n\nclass Solver {\n    Reader in = new Reader ();\n    Writer out = new Writer ();\n    final int mod = 1000000000 + 7;\n\n    long same(int n) {\n        long [] dp = new long [n + 1];\n        long sum = 0;\n        dp[1] = 0;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = (i + sum) % mod;\n            sum = (sum + dp[i - 1]) % mod;\n        }\n        return (1 + dp[n]) % mod;\n    }\n    void solve () {\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        char [] s = in.next().toCharArray();\n        \n        int cnt = 0;\n        int min = m;\n        for(int i = 0; i < m; i++) {\n            if(i > 0 && s[i - 1] == s[i]) ++cnt;\n            else {\n                if(s[i] != s[0] && cnt % 2 == 1) {\n                    min = Math.min(min, cnt);\n                }\n                cnt = 1;\n            }\n        }\n        cnt = 0;\n        for(int i = 0; i < m; i++) {\n            if(s[i] == s[0]) ++cnt;\n            else break;\n        }\n        if(cnt % 2 == 0) {\n            min = Math.min(min, cnt + 1);\n        }\n        if(cnt == m) {\n            System.out.println(same(n));\n            System.exit(0);\n        }\n\n        long [] dp = new long [n + 1];\n        dp[1] = 0;\n        long [] sum = new long [2];\n        sum[0] = sum[1] = 0;\n\n        for(int i = 2; i <= n; i++) {\n            if(i - 1 <= min && (i - 1) % 2 == 1) {\n                dp[i] = i;\n            }\n            dp[i] = (dp[i] + sum[i % 2]) % mod;\n            sum[i % 2] = (sum[i % 2] + dp[i]) % mod;\n            if(i - 1 - min > 1) {\n                sum[i % 2] = (sum[i % 2] - dp[i - 1 - min]) % mod;\n            }\n        }\n        if(dp[n] < 0) dp[n] += mod;\n        System.out.println(dp[n]);\n    }\n}\n\nclass Reader {\n    private StringTokenizer a;\n    private BufferedReader b;\n    Reader () {\n        a = null;\n        try {\n            b = new BufferedReader (new InputStreamReader (System.in)); // for file IO, replace this with new FileReader (\"in.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public String next () {\n        while(a == null || !a.hasMoreTokens()) {\n            try {\n                a = new StringTokenizer (b.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return a.nextToken();\n    }\n    public int nextInt() {\n        return Integer.parseInt(this.next());\n    }\n    public long nextLong () {\n        return Long.parseLong(this.next());\n    }\n    public double nextDouble () {\n        return Double.parseDouble(this.next());\n    }\n    public String nextLine() {\n        try {\n            return b.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n}\nclass Writer {\n    private PrintWriter a;\n    private StringBuffer b;\n    Writer () {\n        try {\n            a = new PrintWriter (System.out); // for file IO, replace this with new FileWriter (\"out.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        b = new StringBuffer (\"\");\n    }\n    public void write (Object s) {\n        b.append(s);\n    }\n    public void writeln(Object s) {\n        b.append(s).append('\\n');\n    }\n    public void flush () {\n        a.print(b);\n        a.flush();\n        a.close();\n    }\n}\nclass Pair implements Comparator <Pair> {\n    int first;\n    int second;\n    Pair  (int a, int b) {\n        this.first = a;\n        this.second = b;\n    }\n    Pair (Pair a) {\n        this.first = a.first;\n        this.second = a.second;\n    }\n    Pair () {}\n    public String toString () {\n        return \"[\" + first + \", \" + second + \"]\";\n    }\n    public int compare (Pair a, Pair b) {\n        if(a.first == b.first) {\n            return a.second - b.second;\n        } else {\n            return a.first - b.first;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int m = in.readInt();\n            char[] s = in.readCharArray(m);\n            IntList sizes = new IntArrayList();\n            int start = 0;\n            for (int i = 1; i < m; i++) {\n                if (s[i] != s[i - 1]) {\n                    sizes.add(i - start);\n                    start = i;\n                }\n            }\n            sizes.add(m - start);\n            int max = sizes.get(0);\n            if (max % 2 == 0) {\n                max++;\n            }\n            for (int i = 2; i + 1 < sizes.size(); i += 2) {\n                int current = sizes.get(i);\n                if (current % 2 == 1) {\n                    max = Math.min(max, current);\n                }\n            }\n            if (sizes.size() == 1) {\n                long firstRlastR = 1;\n                long firstRlastB = 0;\n                long firstBlastR = 0;\n                long firstBlastB = 1;\n                for (int i = 1; i < n; i++) {\n                    long nextFirstRlastR = firstRlastB;\n                    long nextFirstRlastB = (firstRlastB + firstRlastR) % MiscUtils.MOD7;\n                    long nextFirstBlastR = firstBlastB;\n                    long nextFirstBlastB = (firstBlastB + firstBlastR) % MiscUtils.MOD7;\n                    firstRlastR = nextFirstRlastR;\n                    firstRlastB = nextFirstRlastB;\n                    firstBlastR = nextFirstBlastR;\n                    firstBlastB = nextFirstBlastB;\n                }\n                out.printLine((firstRlastB + firstBlastR + firstBlastB) % MiscUtils.MOD7);\n                return;\n            }\n            if (n % 2 == 1) {\n                out.printLine(0);\n                return;\n            }\n            n /= 2;\n            max /= 2;\n            long[] qty = new long[n + 1];\n            qty[0] = 1;\n            long sum = 1;\n            for (int i = 1; i <= n; i++) {\n                qty[i] = sum;\n                sum += qty[i];\n                if (i >= max + 1) {\n                    sum -= qty[i - (max + 1)];\n                }\n                sum %= MiscUtils.MOD7;\n                if (sum < 0) {\n                    sum += MiscUtils.MOD7;\n                }\n            }\n            long answer = 0;\n            for (int i = 1; i <= max + 1 && i <= n; i++) {\n                answer += i * qty[n - i] % MiscUtils.MOD7;\n            }\n            out.printLine(answer * 2 % MiscUtils.MOD7);\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n    }\n\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        public IntIterator intIterator();\n\n        default public Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n\n        default public int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n\n    }\n\n    static class IntArrayList extends IntAbstractStream implements IntList {\n        private int size;\n        private int[] data;\n\n        public IntArrayList() {\n            this(3);\n        }\n\n        public IntArrayList(int capacity) {\n            data = new int[capacity];\n        }\n\n        public IntArrayList(IntCollection c) {\n            this(c.size());\n            addAll(c);\n        }\n\n        public IntArrayList(IntStream c) {\n            this();\n            if (c instanceof IntCollection) {\n                ensureCapacity(((IntCollection) c).size());\n            }\n            addAll(c);\n        }\n\n        public IntArrayList(IntArrayList c) {\n            size = c.size();\n            data = c.data.clone();\n        }\n\n        public IntArrayList(int[] arr) {\n            size = arr.length;\n            data = arr.clone();\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int get(int at) {\n            if (at >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size);\n            }\n            return data[at];\n        }\n\n        private void ensureCapacity(int capacity) {\n            if (data.length >= capacity) {\n                return;\n            }\n            capacity = Math.max(2 * data.length, capacity);\n            data = Arrays.copyOf(data, capacity);\n        }\n\n        public void addAt(int index, int value) {\n            ensureCapacity(size + 1);\n            if (index > size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size) {\n                System.arraycopy(data, index, data, index + 1, size - index);\n            }\n            data[index] = value;\n            size++;\n        }\n\n        public void removeAt(int index) {\n            if (index >= size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size - 1) {\n                System.arraycopy(data, index + 1, data, index, size - index - 1);\n            }\n            size--;\n        }\n\n    }\n\n    static interface IntReversableCollection extends IntCollection {\n    }\n\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n\n        public boolean advance();\n\n        public boolean isValid();\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public char[] readCharArray(int size) {\n            char[] array = new char[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readCharacter();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public char readCharacter() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            return (char) c;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n\n        public abstract void addAt(int index, int value);\n\n        public abstract void removeAt(int index);\n\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n\n        default public void add(int value) {\n            addAt(size(), value);\n        }\n\n    }\n\n    static interface IntCollection extends IntStream {\n        public int size();\n\n        default public void add(int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        default public IntCollection addAll(IntStream values) {\n            for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {\n                add(it.value());\n            }\n            return this;\n        }\n\n    }\n\n    static abstract class IntAbstractStream implements IntStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\npublic class Circle {\n    public static void main(String [] args) {\n        Solver s = new Solver();\n        s.solve();\n    }\n}\n\nclass Solver {\n    Reader in = new Reader ();\n    Writer out = new Writer ();\n    final int mod = 1000000000 + 7;\n\n    long same(int n) {\n        long [] dp = new long [n + 1];\n        long sum = 0;\n        dp[1] = 0;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = (i + sum) % mod;\n            sum = (sum + dp[i - 1]) % mod;\n        }\n        return (1 + dp[n]) % mod;\n    }\n    void solve () {\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        char [] s = in.next().toCharArray();\n        \n        int cnt = 0;\n        int min = m;\n        for(int i = 0; i < m; i++) {\n            if(i > 0 && s[i - 1] == s[i]) ++cnt;\n            else {\n                if(s[i] != s[0] && cnt % 2 == 1) {\n                    min = Math.min(min, cnt);\n                }\n                cnt = 1;\n            }\n        }\n        cnt = 0;\n        for(int i = 0; i < m; i++) {\n            if(s[i] == s[0]) ++cnt;\n            else break;\n        }\n        if(cnt % 2 == 0) {\n            min = Math.min(min, cnt + 1);\n        }\n        if(cnt == m) {\n            System.out.println(same(n));\n            System.exit(0);\n        }\n\n        long [] dp = new long [n + 1];\n        dp[1] = 0;\n        long [] sum = new long [2];\n        sum[0] = sum[1] = 0;\n\n        for(int i = 2; i <= n; i++) {\n            if(i - 1 <= min) {\n                dp[i] = i;\n            }\n            dp[i] = (mod + dp[i] + sum[i % 2]) % mod;\n            sum[i % 2] = (sum[i % 2] + dp[i]) % mod;\n            if(i - 1 - min > 1) {\n                sum[i % 2] = (sum[i % 2] - dp[i - 1 - min]) % mod;\n            }\n        }\n        System.out.println(dp[n]);\n    }\n}\n\nclass Reader {\n    private StringTokenizer a;\n    private BufferedReader b;\n    Reader () {\n        a = null;\n        try {\n            b = new BufferedReader (new InputStreamReader (System.in)); // for file IO, replace this with new FileReader (\"in.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public String next () {\n        while(a == null || !a.hasMoreTokens()) {\n            try {\n                a = new StringTokenizer (b.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return a.nextToken();\n    }\n    public int nextInt() {\n        return Integer.parseInt(this.next());\n    }\n    public long nextLong () {\n        return Long.parseLong(this.next());\n    }\n    public double nextDouble () {\n        return Double.parseDouble(this.next());\n    }\n    public String nextLine() {\n        try {\n            return b.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n}\nclass Writer {\n    private PrintWriter a;\n    private StringBuffer b;\n    Writer () {\n        try {\n            a = new PrintWriter (System.out); // for file IO, replace this with new FileWriter (\"out.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        b = new StringBuffer (\"\");\n    }\n    public void write (Object s) {\n        b.append(s);\n    }\n    public void writeln(Object s) {\n        b.append(s).append('\\n');\n    }\n    public void flush () {\n        a.print(b);\n        a.flush();\n        a.close();\n    }\n}\nclass Pair implements Comparator <Pair> {\n    int first;\n    int second;\n    Pair  (int a, int b) {\n        this.first = a;\n        this.second = b;\n    }\n    Pair (Pair a) {\n        this.first = a.first;\n        this.second = a.second;\n    }\n    Pair () {}\n    public String toString () {\n        return \"[\" + first + \", \" + second + \"]\";\n    }\n    public int compare (Pair a, Pair b) {\n        if(a.first == b.first) {\n            return a.second - b.second;\n        } else {\n            return a.first - b.first;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tstatic final long MOD = 1000000007;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tchar[] arr = sc.next().toCharArray();\n\t\tchar first = arr[0];\n\t\tint minOdd = Integer.MAX_VALUE;\n\t\tint idx = 0;\n\t\tboolean firstPass = true;\n\t\twhile (idx < M) {\n\t\t\tint cantFirst = 0;\n\t\t\twhile (idx < M && arr[idx] == first) {\n\t\t\t\tcantFirst++;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tif (idx < M) {\n\t\t\t\tif (firstPass && cantFirst % 2 == 0) cantFirst++;\n\t\t\t\tif (cantFirst % 2 == 1) {\n\t\t\t\t\tminOdd = Math.min(minOdd, cantFirst);\n\t\t\t\t}\n\t\t\t\twhile (idx < M && arr[idx] != first) {\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfirstPass = false;\n\t\t}\n\t\tlong ans = 0;\n\t\tif (minOdd == Integer.MAX_VALUE) {\n\t\t\tlong[][][] table = new long[2][2][N-1];\n\t\t\t\n\t\t\ttable[0][1][0] = table[1][0][0] = table[0][0][0] = 1;\n\t\t\tfor (int size = 1; size < N - 1; size++) {\n\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\ttable[i][j][size] = table[0][j][size-1];\n\t\t\t\t\t\tif (i != 1) {\n\t\t\t\t\t\t\ttable[i][j][size] += table[1][j][size-1];\n\t\t\t\t\t\t\ttable[i][j][size] %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tfor (int j = 0; j < 2; j++) if (i != 1 || j != 1) {\n\t\t\t\t\tans += table[i][j][N - 2];\n\t\t\t\t\tans %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (N % 2 == 0) {\n\t\t\tint maxStep = (minOdd + 1) / 2;\n\t\t\tint tot = N / 2;\n\t\t\tlong[] table = new long[tot + 1];\n\t\t\tlong[] acum = new long[tot + 1];\n\t\t\ttable[0] = 1;\n\t\t\tacum[0] = 1;\n\t\t\tfor (int i = 1; i < tot; i++) {\n\t\t\t\ttable[i] = acum[i - 1] - (i - maxStep - 1 >= 0 ? acum[i - maxStep - 1] : 0);\n\t\t\t\tacum[i] = (acum[i - 1] + table[i]) % MOD;\n\t\t\t}\n\t\t\tfor (int i = 1; i <= tot && i <= maxStep; i++) {\n\t\t\t\tans += table[tot - i] * 2 * i;\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tstatic final long MOD = 1000000007;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tchar[] arr = sc.next().toCharArray();\n\t\tchar first = arr[0];\n\t\tint minOdd = Integer.MAX_VALUE;\n\t\tint idx = 0;\n\t\tboolean firstPass = true;\n\t\twhile (idx < M) {\n\t\t\tint cantFirst = 0;\n\t\t\twhile (idx < M && arr[idx] == first) {\n\t\t\t\tcantFirst++;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tif (idx < M) {\n\t\t\t\tif (firstPass && cantFirst % 2 == 0) cantFirst++;\n\t\t\t\tif (cantFirst % 2 == 1) {\n\t\t\t\t\tminOdd = Math.min(minOdd, cantFirst);\n\t\t\t\t}\n\t\t\t\twhile (idx < M && arr[idx] != first) {\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfirstPass = false;\n\t\t}\n\t\tlong ans = 0;\n\t\tif (minOdd == Integer.MAX_VALUE) {\n\t\t\tlong[][][] table = new long[2][2][N-1];\n\t\t\t\n\t\t\ttable[0][1][0] = table[1][0][0] = table[0][0][0] = 1;\n\t\t\tfor (int size = 1; size < N - 1; size++) {\n\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\ttable[i][j][size] = table[0][j][size-1];\n\t\t\t\t\t\tif (i != 1) {\n\t\t\t\t\t\t\ttable[i][j][size] += table[1][j][size-1];\n\t\t\t\t\t\t\ttable[i][j][size] %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tfor (int j = 0; j < 2; j++) if (i != 1 || j != 1) {\n\t\t\t\t\tans += table[i][j][N - 2];\n\t\t\t\t\tans %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (N % 2 == 0) {\n\t\t\tint maxStep = (minOdd + 1) / 2;\n\t\t\tint tot = N / 2;\n\t\t\tlong[] table = new long[tot + 1];\n\t\t\tlong[] acum = new long[tot + 1];\n\t\t\ttable[0] = 1;\n\t\t\tacum[0] = 1;\n\t\t\tfor (int i = 1; i < tot; i++) {\n\t\t\t\ttable[i] = (acum[i - 1] + MOD - (i - maxStep - 1 >= 0 ? acum[i - maxStep - 1] : 0)) % MOD;\n\t\t\t\tacum[i] = (acum[i - 1] + table[i]) % MOD;\n\t\t\t}\n\t\t\tfor (int i = 1; i <= tot && i <= maxStep; i++) {\n\t\t\t\tans += table[tot - i] * 2 * i;\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        static final long MODULO = (long) 1e9 + 7;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            String s = in.next();\n            if (s.charAt(0) == 'B') {\n                s = invert(s);\n            }\n            if (!s.contains(\"B\")) {\n                out.println(countSimple(n));\n                return;\n            }\n            int minOdd = Integer.MAX_VALUE;\n            int start = Integer.MAX_VALUE;\n            int count = 0;\n            for (int i = 0; i < s.length(); ++i) {\n                if (s.charAt(i) == 'R') {\n                    ++count;\n                } else {\n                    if (start == Integer.MAX_VALUE) start = count;\n                    if (count % 2 != 0) {\n                        minOdd = Math.min(minOdd, count);\n                    }\n                    count = 0;\n                }\n            }\n            minOdd = Math.min(minOdd, start);\n            out.println(countComplex(n, minOdd));\n        }\n\n        private long countComplex(int n, int minOdd) {\n            if (n % 2 != 0) return 0;\n            return 2 * countWithMaxRun(n / 2, minOdd / 2) % MODULO;\n        }\n\n        private long countWithMaxRun(int n, int maxRun) {\n            long[] res = new long[n + 1];\n            for (int i = 0; i <= maxRun && i + 1 <= n; ++i) {\n                res[i + 1] = i + 1;\n            }\n            long s = 0;\n            for (int i = 1; i <= n; ++i) {\n                s += res[i - 1];\n                if (i - maxRun - 2 >= 0) {\n                    s -= res[i - maxRun - 2];\n                }\n                s %= MODULO;\n                if (s < 0) s += MODULO;\n                res[i] += s;\n                res[i] %= MODULO;\n            }\n            return res[n];\n        }\n\n        private long countSimple(int n) {\n            return countWithMaxRun(n, 1);\n        }\n\n        private String invert(String s) {\n            char[] res = s.toCharArray();\n            for (int i = 0; i < res.length; ++i) {\n                res[i] ^= 'R' ^ 'B';\n            }\n            return new String(res);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String [] args) {\n        Solver s = new Solver();\n        s.solve();\n    }\n}\n\nclass Solver {\n    Reader in = new Reader ();\n    Writer out = new Writer ();\n    final int mod = 1000000000 + 7;\n\n    long same(int n) {\n        long [] dp = new long [n + 1];\n        long sum = 0;\n        dp[1] = 0;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = (i + sum) % mod;\n            sum = (sum + dp[i - 1]) % mod;\n        }\n        return (1 + dp[n]) % mod;\n    }\n    void solve () {\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        char [] s = in.next().toCharArray();\n        \n        int cnt = 0;\n        int min = m;\n        for(int i = 0; i < m; i++) {\n            if(i > 0 && s[i - 1] == s[i]) ++cnt;\n            else {\n                if(s[i] != s[0] && cnt % 2 == 1) {\n                    min = Math.min(min, cnt);\n                }\n                cnt = 1;\n            }\n        }\n        cnt = 0;\n        for(int i = 0; i < m; i++) {\n            if(s[i] == s[0]) ++cnt;\n            else break;\n        }\n        if(cnt % 2 == 0) {\n            min = Math.min(min, cnt + 1);\n        }\n        if(cnt == m) {\n            // System.out.println(same(n));\n            s[1000000] = 'a';\n            System.exit(0);\n        }\n\n        long [] dp = new long [n + 1];\n        dp[1] = 0;\n        long [] sum = new long [2];\n        sum[0] = sum[1] = 0;\n\n        for(int i = 2; i <= n; i++) {\n            if(i - 1 <= min) {\n                dp[i] = i;\n            }\n            dp[i] = (dp[i] + sum[i % 2]) % mod;\n            sum[i % 2] = (sum[i % 2] + dp[i]) % mod;\n            if(i - 1 - min > 1) {\n                sum[i % 2] = (sum[i % 2] - dp[i - 1 - min]) % mod;\n            }\n        }\n        if(dp[n] < 0) dp[n] += mod;\n        System.out.println(dp[n]);\n    }\n}\n\nclass Reader {\n    private StringTokenizer a;\n    private BufferedReader b;\n    Reader () {\n        a = null;\n        try {\n            b = new BufferedReader (new InputStreamReader (System.in)); // for file IO, replace this with new FileReader (\"in.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public String next () {\n        while(a == null || !a.hasMoreTokens()) {\n            try {\n                a = new StringTokenizer (b.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return a.nextToken();\n    }\n    public int nextInt() {\n        return Integer.parseInt(this.next());\n    }\n    public long nextLong () {\n        return Long.parseLong(this.next());\n    }\n    public double nextDouble () {\n        return Double.parseDouble(this.next());\n    }\n    public String nextLine() {\n        try {\n            return b.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n}\nclass Writer {\n    private PrintWriter a;\n    private StringBuffer b;\n    Writer () {\n        try {\n            a = new PrintWriter (System.out); // for file IO, replace this with new FileWriter (\"out.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        b = new StringBuffer (\"\");\n    }\n    public void write (Object s) {\n        b.append(s);\n    }\n    public void writeln(Object s) {\n        b.append(s).append('\\n');\n    }\n    public void flush () {\n        a.print(b);\n        a.flush();\n        a.close();\n    }\n}\nclass Pair implements Comparator <Pair> {\n    int first;\n    int second;\n    Pair  (int a, int b) {\n        this.first = a;\n        this.second = b;\n    }\n    Pair (Pair a) {\n        this.first = a.first;\n        this.second = a.second;\n    }\n    Pair () {}\n    public String toString () {\n        return \"[\" + first + \", \" + second + \"]\";\n    }\n    public int compare (Pair a, Pair b) {\n        if(a.first == b.first) {\n            return a.second - b.second;\n        } else {\n            return a.first - b.first;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        static final long MODULO = (long) 1e9 + 7;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int m = in.nextInt();\n            String s = in.next();\n            if (s.charAt(0) == 'B') {\n                s = invert(s);\n            }\n            if (!s.contains(\"B\")) {\n                out.println(countSimple(n));\n                return;\n            }\n            int minOdd = Integer.MAX_VALUE;\n            int start = Integer.MAX_VALUE;\n            int count = 0;\n            for (int i = 0; i < s.length(); ++i) {\n                if (s.charAt(i) == 'R') {\n                    ++count;\n                } else {\n                    if (start == Integer.MAX_VALUE) start = count;\n                    if (count % 2 != 0) {\n                        minOdd = Math.min(minOdd, count);\n                    }\n                }\n            }\n            minOdd = Math.min(minOdd, start);\n            out.println(countComplex(n, minOdd));\n        }\n\n        private long countComplex(int n, int minOdd) {\n            if (n % 2 != 0) return 0;\n            return 2 * countWithMaxRun(n / 2, minOdd / 2) % MODULO;\n        }\n\n        private long countWithMaxRun(int n, int maxRun) {\n            long[] res = new long[n + 1];\n            for (int i = 0; i <= maxRun && i + 1 <= n; ++i) {\n                res[i + 1] = i + 1;\n            }\n            long s = 0;\n            for (int i = 1; i <= n; ++i) {\n                s += res[i - 1];\n                if (i - maxRun - 2 >= 0) {\n                    s -= res[i - maxRun - 2];\n                }\n                s %= MODULO;\n                if (s < 0) s += MODULO;\n                res[i] += s;\n                res[i] %= MODULO;\n            }\n            return res[n];\n        }\n\n        private long countSimple(int n) {\n            return countWithMaxRun(n, 1);\n        }\n\n        private String invert(String s) {\n            char[] res = s.toCharArray();\n            for (int i = 0; i < res.length; ++i) {\n                res[i] ^= 'R' ^ 'B';\n            }\n            return new String(res);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String [] args) {\n        Solver s = new Solver();\n        s.solve();\n    }\n}\n\nclass Solver {\n    Reader in = new Reader ();\n    Writer out = new Writer ();\n    final int mod = 1000000000 + 7;\n\n    long same(int n) {\n        long [] dp = new long [n + 1];\n        dp[1] = 0;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = i;\n            for(int j = 1; j < i; j++) {\n                dp[i] += dp[i - 1 - j];\n                dp[i] %= mod;\n            }\n        }\n        return (1 + dp[n]) % mod;\n    }\n    void solve () {\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        char [] s = in.next().toCharArray();\n        \n        int cnt = 0;\n        int min = m;\n        for(int i = 0; i < m; i++) {\n            if(i > 0 && s[i - 1] == s[i]) ++cnt;\n            else {\n                if(s[i] != s[0] && cnt % 2 == 1) {\n                    min = Math.min(min, cnt);\n                }\n                cnt = 1;\n            }\n        }\n        if(s[m - 1] == s[0] && cnt % 2 == 1) {\n            min = Math.min(min, cnt);\n        }\n        cnt = 0;\n        for(int i = 0; i < m; i++) {\n            if(s[i] == s[0]) ++cnt;\n            else break;\n        }\n        if(cnt % 2 == 0) {\n            min = Math.min(min, cnt + 1);\n        }\n        if(cnt == m) {\n            System.out.println(same(n));\n            System.exit(0);\n        }\n\n        long [] dp = new long [n + 1];\n        dp[1] = 0;\n        for(int i = 2; i <= n; i++) {\n            if(i - 1 <= min) {\n                dp[i] = i;\n            }\n            for(int j = 1; j <= min; j += 2) {\n                if(i - 1 - j < 1) break;\n                dp[i] += dp[i - 1 - j];\n                dp[i] %= mod;\n            } \n        }\n        System.out.println(dp[n]);\n    }\n}\n\nclass Reader {\n    private StringTokenizer a;\n    private BufferedReader b;\n    Reader () {\n        a = null;\n        try {\n            b = new BufferedReader (new InputStreamReader (System.in)); // for file IO, replace this with new FileReader (\"in.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public String next () {\n        while(a == null || !a.hasMoreTokens()) {\n            try {\n                a = new StringTokenizer (b.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return a.nextToken();\n    }\n    public int nextInt() {\n        return Integer.parseInt(this.next());\n    }\n    public long nextLong () {\n        return Long.parseLong(this.next());\n    }\n    public double nextDouble () {\n        return Double.parseDouble(this.next());\n    }\n    public String nextLine() {\n        try {\n            return b.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n}\nclass Writer {\n    private PrintWriter a;\n    private StringBuffer b;\n    Writer () {\n        try {\n            a = new PrintWriter (System.out); // for file IO, replace this with new FileWriter (\"out.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        b = new StringBuffer (\"\");\n    }\n    public void write (Object s) {\n        b.append(s);\n    }\n    public void writeln(Object s) {\n        b.append(s).append('\\n');\n    }\n    public void flush () {\n        a.print(b);\n        a.flush();\n        a.close();\n    }\n}\nclass Pair implements Comparator <Pair> {\n    int first;\n    int second;\n    Pair  (int a, int b) {\n        this.first = a;\n        this.second = b;\n    }\n    Pair (Pair a) {\n        this.first = a.first;\n        this.second = a.second;\n    }\n    Pair () {}\n    public String toString () {\n        return \"[\" + first + \", \" + second + \"]\";\n    }\n    public int compare (Pair a, Pair b) {\n        if(a.first == b.first) {\n            return a.second - b.second;\n        } else {\n            return a.first - b.first;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tstatic final long MOD = 1000000007;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tchar[] arr = sc.next().toCharArray();\n\t\tchar first = arr[0];\n\t\tint minOdd = Integer.MAX_VALUE;\n\t\tint idx = 0;\n\t\twhile (idx < M) {\n\t\t\tint cantFirst = 0;\n\t\t\twhile (idx < M && arr[idx] == first) {\n\t\t\t\tcantFirst++;\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tif (idx < M) {\n\t\t\t\tif (cantFirst % 2 == 0) cantFirst++;\n\t\t\t\tminOdd = Math.min(minOdd, cantFirst);\n\t\t\t\twhile (idx < M && arr[idx] != first) {\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong ans = 0;\n\t\tif (minOdd == Integer.MAX_VALUE) {\n\t\t\tlong[][][] table = new long[2][2][N-1];\n\t\t\t\n\t\t\ttable[0][1][0] = table[1][0][0] = table[0][0][0] = 1;\n\t\t\tfor (int size = 1; size < N - 1; size++) {\n\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\t\ttable[i][j][size] = table[0][j][size-1];\n\t\t\t\t\t\tif (i != 1) {\n\t\t\t\t\t\t\ttable[i][j][size] += table[1][j][size-1];\n\t\t\t\t\t\t\ttable[i][j][size] %= MOD;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\tfor (int j = 0; j < 2; j++) if (i != 1 || j != 1) {\n\t\t\t\t\tans += table[i][j][N - 2];\n\t\t\t\t\tans %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (N % 2 == 0) {\n\t\t\tint maxStep = (minOdd + 1) / 2;\n\t\t\tint tot = N / 2;\n\t\t\tlong[] table = new long[tot + 1];\n\t\t\tlong[] acum = new long[tot + 1];\n\t\t\ttable[0] = 1;\n\t\t\tacum[0] = 1;\n\t\t\tfor (int i = 1; i < tot; i++) {\n\t\t\t\ttable[i] = acum[i - 1] - (i - maxStep - 1 >= 0 ? acum[i - maxStep - 1] : 0);\n\t\t\t\tacum[i] = (acum[i - 1] + table[i]) % MOD;\n\t\t\t}\n\t\t\tfor (int i = 1; i <= tot && i <= maxStep; i++) {\n\t\t\t\tans += table[tot - i] * 2 * i;\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String [] args) {\n        Solver s = new Solver();\n        s.solve();\n    }\n}\n\nclass Solver {\n    Reader in = new Reader ();\n    Writer out = new Writer ();\n    final int mod = 1000000000 + 7;\n\n    long same(int n) {\n        long [] dp = new long [n + 1];\n        long sum = 0;\n        dp[1] = 0;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = (i + sum) % mod;\n            sum = (sum + dp[i - 1]) % mod;\n        }\n        return (1 + dp[n]) % mod;\n    }\n    void solve () {\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        char [] s = in.next().toCharArray();\n        \n        int cnt = 0;\n        int min = m;\n        for(int i = 0; i < m; i++) {\n            if(i > 0 && s[i - 1] == s[i]) ++cnt;\n            else {\n                if(s[i] != s[0] && cnt % 2 == 1) {\n                    // min = Math.min(min, cnt);\n                }\n                cnt = 1;\n            }\n        }\n        cnt = 0;\n        for(int i = 0; i < m; i++) {\n            if(s[i] == s[0]) ++cnt;\n            else break;\n        }\n        if(cnt % 2 == 0) {\n            min = Math.min(min, cnt + 1);\n        }\n        if(cnt == m) {\n            System.out.println(same(n));\n            System.exit(0);\n        }\n\n        long [] dp = new long [n + 1];\n        dp[1] = 0;\n        long [] sum = new long [2];\n        sum[0] = sum[1] = 0;\n\n        for(int i = 2; i <= n; i++) {\n            if(i - 1 <= min && (i - 1) % 2 == 1) {\n                dp[i] = i;\n            }\n            dp[i] = (dp[i] + sum[i % 2]) % mod;\n            sum[i % 2] = (sum[i % 2] + dp[i]) % mod;\n            if(i - 1 - min > 1) {\n                sum[i % 2] = (sum[i % 2] - dp[i - 1 - min]) % mod;\n            }\n        }\n        if(dp[n] < 0) dp[n] += mod;\n        System.out.println(dp[n]);\n    }\n}\n\nclass Reader {\n    private StringTokenizer a;\n    private BufferedReader b;\n    Reader () {\n        a = null;\n        try {\n            b = new BufferedReader (new InputStreamReader (System.in)); // for file IO, replace this with new FileReader (\"in.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public String next () {\n        while(a == null || !a.hasMoreTokens()) {\n            try {\n                a = new StringTokenizer (b.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return a.nextToken();\n    }\n    public int nextInt() {\n        return Integer.parseInt(this.next());\n    }\n    public long nextLong () {\n        return Long.parseLong(this.next());\n    }\n    public double nextDouble () {\n        return Double.parseDouble(this.next());\n    }\n    public String nextLine() {\n        try {\n            return b.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n}\nclass Writer {\n    private PrintWriter a;\n    private StringBuffer b;\n    Writer () {\n        try {\n            a = new PrintWriter (System.out); // for file IO, replace this with new FileWriter (\"out.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        b = new StringBuffer (\"\");\n    }\n    public void write (Object s) {\n        b.append(s);\n    }\n    public void writeln(Object s) {\n        b.append(s).append('\\n');\n    }\n    public void flush () {\n        a.print(b);\n        a.flush();\n        a.close();\n    }\n}\nclass Pair implements Comparator <Pair> {\n    int first;\n    int second;\n    Pair  (int a, int b) {\n        this.first = a;\n        this.second = b;\n    }\n    Pair (Pair a) {\n        this.first = a.first;\n        this.second = a.second;\n    }\n    Pair () {}\n    public String toString () {\n        return \"[\" + first + \", \" + second + \"]\";\n    }\n    public int compare (Pair a, Pair b) {\n        if(a.first == b.first) {\n            return a.second - b.second;\n        } else {\n            return a.first - b.first;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String [] args) {\n        Solver s = new Solver();\n        s.solve();\n    }\n}\n\nclass Solver {\n    Reader in = new Reader ();\n    Writer out = new Writer ();\n    final int mod = 1000000000 + 7;\n\n    long same(int n) {\n        long [] dp = new long [n + 1];\n        dp[1] = 0;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = i;\n            for(int j = 1; j < i; j++) {\n                dp[i] += dp[i - 1 - j];\n                dp[i] %= mod;\n            }\n        }\n        return (1 + dp[n]) % mod;\n    }\n    void solve () {\n        int n, m;\n        n = in.nextInt();\n        m = in.nextInt();\n        char [] s = in.next().toCharArray();\n        \n        int cnt = 0;\n        int min = m;\n        for(int i = 0; i < m; i++) {\n            if(i > 0 && s[i - 1] == s[i]) ++cnt;\n            else {\n                if(s[i] != s[0] && cnt % 2 == 1) {\n                    min = Math.min(min, cnt);\n                }\n                cnt = 1;\n            }\n        }\n        cnt = 0;\n        for(int i = 0; i < m; i++) {\n            if(s[i] == s[0]) ++cnt;\n            else break;\n        }\n        if(cnt % 2 == 0) {\n            min = Math.min(min, cnt + 1);\n        }\n        if(cnt == m) {\n            System.out.println(same(n));\n            System.exit(0);\n        }\n\n        long [] dp = new long [n + 1];\n        dp[1] = 0;\n        long [] sum = new long [2];\n        sum[0] = sum[1] = 0;\n\n        for(int i = 2; i <= n; i++) {\n            if(i - 1 <= min) {\n                dp[i] = i;\n            }\n            dp[i] = (mod + dp[i] + sum[i % 2]) % mod;\n            sum[i % 2] = (sum[i % 2] + dp[i]) % mod;\n            if(i - 1 - min > 1) {\n                sum[i % 2] = (sum[i % 2] - dp[i - 1 - min]) % mod;\n            }\n        }\n        System.out.println(dp[n]);\n    }\n}\n\nclass Reader {\n    private StringTokenizer a;\n    private BufferedReader b;\n    Reader () {\n        a = null;\n        try {\n            b = new BufferedReader (new InputStreamReader (System.in)); // for file IO, replace this with new FileReader (\"in.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n    public String next () {\n        while(a == null || !a.hasMoreTokens()) {\n            try {\n                a = new StringTokenizer (b.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return a.nextToken();\n    }\n    public int nextInt() {\n        return Integer.parseInt(this.next());\n    }\n    public long nextLong () {\n        return Long.parseLong(this.next());\n    }\n    public double nextDouble () {\n        return Double.parseDouble(this.next());\n    }\n    public String nextLine() {\n        try {\n            return b.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return \"\";\n    }\n}\nclass Writer {\n    private PrintWriter a;\n    private StringBuffer b;\n    Writer () {\n        try {\n            a = new PrintWriter (System.out); // for file IO, replace this with new FileWriter (\"out.txt\")\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        b = new StringBuffer (\"\");\n    }\n    public void write (Object s) {\n        b.append(s);\n    }\n    public void writeln(Object s) {\n        b.append(s).append('\\n');\n    }\n    public void flush () {\n        a.print(b);\n        a.flush();\n        a.close();\n    }\n}\nclass Pair implements Comparator <Pair> {\n    int first;\n    int second;\n    Pair  (int a, int b) {\n        this.first = a;\n        this.second = b;\n    }\n    Pair (Pair a) {\n        this.first = a.first;\n        this.second = a.second;\n    }\n    Pair () {}\n    public String toString () {\n        return \"[\" + first + \", \" + second + \"]\";\n    }\n    public int compare (Pair a, Pair b) {\n        if(a.first == b.first) {\n            return a.second - b.second;\n        } else {\n            return a.first - b.first;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing static System.Math;\nusing Number = ModInt;\nusing System.Numerics;\nusing static System.Numerics.BigInteger;\nnamespace Program {\n\tpublic class Solver {\n\t\tRandom rnd = new Random(0);\n\t\tpublic void Solve() {\n\t\t\tvar n = ri;\n\t\t\tvar m = ri;\n\t\t\tvar s = rs;\n\t\t\tModInt ans = 0;\n\t\t\tif (s.Distinct().Count() == 1) {\n\t\t\t\tvar dp = new ModInt[n + 1, 2, 2];\n\t\t\t\tdp[1, 0, 0] = 1;\n\t\t\t\tdp[1, 1, 1] = 1;\n\t\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\t\t\t\tfor (int l = 0; l < 2; l++) {\n\t\t\t\t\t\t\t\tif (j == 1 && l == 1) continue;\n\t\t\t\t\t\t\t\tdp[i + 1, l, k] += dp[i, j, k];\n\t\t\t\t\t\t\t}\n\t\t\t\tans += dp[n, 0, 0] + dp[n, 0, 1] + dp[n, 1, 0];\n\t\t\t\tConsole.WriteLine(ans);\n\t\t\t\tthrow new Exception();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar v = 0;\n\t\t\t\tvar min = 1000000;\n\t\t\t\tforeach (var c in s) {\n\t\t\t\t\tif (c == s[0]) v++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (v % 2 == 1) min = Min(min, v);\n\t\t\t\t\t\telse min = Min(min, v + 1);\n\t\t\t\t\t\tv = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDebug.WriteLine(\"po\");\n\t\t\t\tvar even = new FenwickTree(n + 1);\n\t\t\t\tfor (int i = 1; i <= min; i += 2) {\n\t\t\t\t\tDebug.WriteLine(i);\n\t\t\t\t\teven.Add(i + 1, i + 1);\n\t\t\t\t}\n\t\t\t\tDebug.WriteLine(\"po\");\n\t\t\t\tfor (int i = 4; i <= n; i += 2) {\n\t\t\t\t\tDebug.WriteLine($\"[{Max(0, i - 1 - min)} {i - 1}]\");\n\t\t\t\t\tDebug.WriteLine(even.Items.AsJoinedString());\n\t\t\t\t\teven.Add(i, even[Max(0, i - 1 - min), i - 1]);\n\t\t\t\t}\n\t\t\t\tDebug.WriteLine(even.Items.AsJoinedString());\n\t\t\t\tConsole.WriteLine(even[n, n]);\n\t\t\t}\n\t\t}\n\t\tconst long INF = 1L << 60;\n\t\tstatic int[] dx = { -1, 0, 1, 0 };\n\t\tstatic int[] dy = { 0, 1, 0, -1 };\n\t\tint ri { get { return sc.Integer(); } }\n\t\tlong rl { get { return sc.Long(); } }\n\t\tdouble rd { get { return sc.Double(); } }\n\t\tstring rs { get { return sc.Scan(); } }\n\t\tpublic IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\t\tstatic T[] Enumerate<T>(int n, Func<int, T> f) {\n\t\t\tvar a = new T[n]; for (int i = 0; i < a.Length; ++i) a[i] = f(i); return a;\n\t\t}\n\t\tstatic T[][] Enumerate<T>(int n, int m, Func<int, int, T> f) {\n\t\t\treturn Enumerate(n, x => Enumerate(m, y => f(x, y)));\n\t\t}\n\t\tstatic public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\t}\n}\n\n#region main\nstatic class Ex {\n\tstatic public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\tstatic public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n\t\treturn string.Join(st, ie);\n\t}\n\tstatic public void Main() {\n\t\tConsole.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n\t\tvar solver = new Program.Solver();\n\t\t//* \n\t\tvar t = new System.Threading.Thread(solver.Solve, 200000000);\n\t\tt.Start();\n\t\tt.Join();\n\t\t//*/\n\t\t// solver.Solve();\n\t\tConsole.Out.Flush();\n\t}\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n\tusing System.IO;\n\tusing System.Text;\n\tusing System.Globalization;\n\n\tpublic class Printer : StreamWriter {\n\t\tpublic override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n\t\tpublic Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n\t}\n\n\tpublic class StreamScanner {\n\t\tpublic StreamScanner(Stream stream) { str = stream; }\n\n\t\tpublic readonly Stream str;\n\t\tprivate readonly byte[] buf = new byte[1024];\n\t\tprivate int len, ptr;\n\t\tpublic bool isEof = false;\n\t\tpublic bool IsEndOfStream { get { return isEof; } }\n\n\t\tprivate byte read() {\n\t\t\tif (isEof) return 0;\n\t\t\tif (ptr >= len) {\n\t\t\t\tptr = 0;\n\t\t\t\tif ((len = str.Read(buf, 0, 1024)) <= 0) {\n\t\t\t\t\tisEof = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[ptr++];\n\t\t}\n\n\t\tpublic char Char() {\n\t\t\tbyte b = 0;\n\t\t\tdo b = read(); while ((b < 33 || 126 < b) && !isEof);\n\t\t\treturn (char)b;\n\t\t}\n\t\tpublic string Scan() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic string ScanLine() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n\t\tpublic int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n\t\tpublic double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n\t}\n}\n\n#endregion\n#region Fenwick\npublic class FenwickTree {\n\tint n;\n\tNumber[] bit;\n\tint max = 1;\n\tpublic FenwickTree(int size) {\n\t\tn = size; bit = new Number[n + 1];\n\t\twhile ((max << 1) <= n) max <<= 1;\n\t}\n\t/// <summary>sum[a,b]</summary>\n\tpublic Number this[int i, int j] { get { return this[j] - this[i - 1]; } }\n\t/// <summary>sum[0,i]</summary>\n\tpublic Number this[int i] { get { Number s = 0; for (; i > 0; i -= i & -i) s += bit[i]; return s; } }\n\n\t/// <summary>add v to bit[i]</summary>\n\tpublic void Add(int i, Number v) {\n\t\tif (i == 0) System.Diagnostics.Debug.Fail(\"BIT is 1 indexed\");\n\t\tfor (; i <= n; i += i & -i) bit[i] += v;\n\t}\n\tpublic Number[] Items {\n\t\tget {\n\t\t\tvar ret = new Number[n + 1];\n\t\t\tfor (int i = 0; i < ret.Length; i++)\n\t\t\t\tret[i] = this[i, i];\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n#endregion\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n\t/// <summary>\n\t/// 剰余を取る値．\n\t/// </summary>\n\tpublic const long Mod = (long)1e9 + 7;\n\n\t/// <summary>\n\t/// 実際の数値．\n\t/// </summary>\n\tpublic long num;\n\t/// <summary>\n\t/// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n\t/// </summary>\n\t/// <param name=\"n\">インスタンスが持つ値</param>\n\t/// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n\tpublic ModInt(long n) { num = n; }\n\t/// <summary>\n\t/// このインスタンスの数値を文字列に変換します．\n\t/// </summary>\n\t/// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n\tpublic override string ToString() { return num.ToString(); }\n\tpublic static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n\tpublic static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n\tpublic static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n\tpublic static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n\t/// <summary>\n\t/// 与えられた 2 つの数値からべき剰余を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">べき乗の底</param>\n\t/// <param name=\"k\">べき指数</param>\n\t/// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n\tpublic static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n\t/// <summary>\n\t/// 与えられた 2 つの数値からべき剰余を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">べき乗の底</param>\n\t/// <param name=\"k\">べき指数</param>\n\t/// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n\tpublic static ModInt Pow(long v, long k) {\n\t\tlong ret = 1;\n\t\tfor (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n\t\t\tif ((k & 1) == 1) ret = ret * v % Mod;\n\t\treturn new ModInt(ret);\n\t}\n\t/// <summary>\n\t/// 与えられた数の逆元を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">逆元を取る対象となる数</param>\n\t/// <returns>逆元となるような値</returns>\n\t/// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n\tpublic static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing static System.Math;\nusing Number = ModInt;\nusing System.Numerics;\nusing static System.Numerics.BigInteger;\nnamespace Program {\n\tpublic class Solver {\n\t\tRandom rnd = new Random(0);\n\t\tpublic void Solve() {\n\t\t\tvar n = ri;\n\t\t\tvar m = ri;\n\t\t\tvar s = rs;\n\t\t\tModInt ans = 0;\n\t\t\tif (s.Distinct().Count() == 1) {\n\t\t\t\tvar dp = new ModInt[n + 1, 2, 2];\n\t\t\t\tdp[1, 0, 0] = 1;\n\t\t\t\tdp[1, 1, 1] = 1;\n\t\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\t\t\t\tfor (int l = 0; l < 2; l++) {\n\t\t\t\t\t\t\t\tif (j == 1 && l == 1) continue;\n\t\t\t\t\t\t\t\tdp[i + 1, l, k] += dp[i, j, k];\n\t\t\t\t\t\t\t}\n\t\t\t\tans += dp[n, 0, 0] + dp[n, 0, 1] + dp[n, 1, 0];\n\t\t\t\tConsole.WriteLine(ans);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar v = 0;\n\t\t\t\tvar min = 1000000;\n\t\t\t\tforeach (var c in s) {\n\t\t\t\t\tif (c == s[0]) v++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (v % 2 == 1) min = Min(min, v);\n\t\t\t\t\t\telse if (min == 1000000) min = Min(min, v + 1);\n\t\t\t\t\t\tv = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDebug.WriteLine(\"po\");\n\t\t\t\tvar even = new FenwickTree(n + 1);\n\t\t\t\tfor (int i = 1; i <= min; i += 2) {\n\t\t\t\t\tDebug.WriteLine(i);\n\t\t\t\t\teven.Add(i + 1, i + 1);\n\t\t\t\t}\n\t\t\t\tDebug.WriteLine(\"po\");\n\t\t\t\tfor (int i = 4; i <= n; i += 2) {\n\t\t\t\t\tDebug.WriteLine($\"[{Max(0, i - 1 - min)} {i - 1}]\");\n\t\t\t\t\tDebug.WriteLine(even.Items.AsJoinedString());\n\t\t\t\t\teven.Add(i, even[Max(0, i - 1 - min), i - 1]);\n\t\t\t\t}\n\t\t\t\tDebug.WriteLine(even.Items.AsJoinedString());\n\t\t\t\tConsole.WriteLine(even[n, n]);\n\t\t\t}\n\t\t}\n\t\tconst long INF = 1L << 60;\n\t\tstatic int[] dx = { -1, 0, 1, 0 };\n\t\tstatic int[] dy = { 0, 1, 0, -1 };\n\t\tint ri { get { return sc.Integer(); } }\n\t\tlong rl { get { return sc.Long(); } }\n\t\tdouble rd { get { return sc.Double(); } }\n\t\tstring rs { get { return sc.Scan(); } }\n\t\tpublic IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\t\tstatic T[] Enumerate<T>(int n, Func<int, T> f) {\n\t\t\tvar a = new T[n]; for (int i = 0; i < a.Length; ++i) a[i] = f(i); return a;\n\t\t}\n\t\tstatic T[][] Enumerate<T>(int n, int m, Func<int, int, T> f) {\n\t\t\treturn Enumerate(n, x => Enumerate(m, y => f(x, y)));\n\t\t}\n\t\tstatic public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\t}\n}\n\n#region main\nstatic class Ex {\n\tstatic public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\tstatic public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n\t\treturn string.Join(st, ie);\n\t}\n\tstatic public void Main() {\n\t\tConsole.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n\t\tvar solver = new Program.Solver();\n\t\t//* \n\t\tvar t = new System.Threading.Thread(solver.Solve, 200000000);\n\t\tt.Start();\n\t\tt.Join();\n\t\t//*/\n\t\t// solver.Solve();\n\t\tConsole.Out.Flush();\n\t}\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n\tusing System.IO;\n\tusing System.Text;\n\tusing System.Globalization;\n\n\tpublic class Printer : StreamWriter {\n\t\tpublic override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n\t\tpublic Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n\t}\n\n\tpublic class StreamScanner {\n\t\tpublic StreamScanner(Stream stream) { str = stream; }\n\n\t\tpublic readonly Stream str;\n\t\tprivate readonly byte[] buf = new byte[1024];\n\t\tprivate int len, ptr;\n\t\tpublic bool isEof = false;\n\t\tpublic bool IsEndOfStream { get { return isEof; } }\n\n\t\tprivate byte read() {\n\t\t\tif (isEof) return 0;\n\t\t\tif (ptr >= len) {\n\t\t\t\tptr = 0;\n\t\t\t\tif ((len = str.Read(buf, 0, 1024)) <= 0) {\n\t\t\t\t\tisEof = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[ptr++];\n\t\t}\n\n\t\tpublic char Char() {\n\t\t\tbyte b = 0;\n\t\t\tdo b = read(); while ((b < 33 || 126 < b) && !isEof);\n\t\t\treturn (char)b;\n\t\t}\n\t\tpublic string Scan() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic string ScanLine() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n\t\tpublic int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n\t\tpublic double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n\t}\n}\n\n#endregion\n#region Fenwick\npublic class FenwickTree {\n\tint n;\n\tNumber[] bit;\n\tint max = 1;\n\tpublic FenwickTree(int size) {\n\t\tn = size; bit = new Number[n + 1];\n\t\twhile ((max << 1) <= n) max <<= 1;\n\t}\n\t/// <summary>sum[a,b]</summary>\n\tpublic Number this[int i, int j] { get { return this[j] - this[i - 1]; } }\n\t/// <summary>sum[0,i]</summary>\n\tpublic Number this[int i] { get { Number s = 0; for (; i > 0; i -= i & -i) s += bit[i]; return s; } }\n\n\t/// <summary>add v to bit[i]</summary>\n\tpublic void Add(int i, Number v) {\n\t\tif (i == 0) System.Diagnostics.Debug.Fail(\"BIT is 1 indexed\");\n\t\tfor (; i <= n; i += i & -i) bit[i] += v;\n\t}\n\tpublic Number[] Items {\n\t\tget {\n\t\t\tvar ret = new Number[n + 1];\n\t\t\tfor (int i = 0; i < ret.Length; i++)\n\t\t\t\tret[i] = this[i, i];\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n#endregion\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n\t/// <summary>\n\t/// 剰余を取る値．\n\t/// </summary>\n\tpublic const long Mod = (long)1e9 + 7;\n\n\t/// <summary>\n\t/// 実際の数値．\n\t/// </summary>\n\tpublic long num;\n\t/// <summary>\n\t/// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n\t/// </summary>\n\t/// <param name=\"n\">インスタンスが持つ値</param>\n\t/// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n\tpublic ModInt(long n) { num = n; }\n\t/// <summary>\n\t/// このインスタンスの数値を文字列に変換します．\n\t/// </summary>\n\t/// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n\tpublic override string ToString() { return num.ToString(); }\n\tpublic static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n\tpublic static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n\tpublic static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n\tpublic static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n\t/// <summary>\n\t/// 与えられた 2 つの数値からべき剰余を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">べき乗の底</param>\n\t/// <param name=\"k\">べき指数</param>\n\t/// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n\tpublic static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n\t/// <summary>\n\t/// 与えられた 2 つの数値からべき剰余を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">べき乗の底</param>\n\t/// <param name=\"k\">べき指数</param>\n\t/// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n\tpublic static ModInt Pow(long v, long k) {\n\t\tlong ret = 1;\n\t\tfor (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n\t\t\tif ((k & 1) == 1) ret = ret * v % Mod;\n\t\treturn new ModInt(ret);\n\t}\n\t/// <summary>\n\t/// 与えられた数の逆元を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">逆元を取る対象となる数</param>\n\t/// <returns>逆元となるような値</returns>\n\t/// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n\tpublic static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing static System.Math;\nusing Number = ModInt;\nusing System.Numerics;\nusing static System.Numerics.BigInteger;\nnamespace Program {\n\tpublic class Solver {\n\t\tRandom rnd = new Random(0);\n\t\tpublic void Solve() {\n\t\t\tvar n = ri;\n\t\t\tvar m = ri;\n\t\t\tvar s = rs;\n\t\t\tModInt ans = 0;\n\t\t\tif (s.Distinct().Count() == 1) {\n\t\t\t\tvar dp = new ModInt[n + 1, 2, 2];\n\t\t\t\tdp[1, 0, 0] = 1;\n\t\t\t\tdp[1, 1, 1] = 1;\n\t\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\t\t\t\tfor (int l = 0; l < 2; l++) {\n\t\t\t\t\t\t\t\tif (j == 1 && l == 1) continue;\n\t\t\t\t\t\t\t\tdp[i + 1, l, k] += dp[i, j, k];\n\t\t\t\t\t\t\t}\n\t\t\t\tans += dp[n, 0, 0] + dp[n, 0, 1] + dp[n, 1, 0];\n\t\t\t\tConsole.WriteLine(ans);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new Exception();\n\t\t\t\tvar v = 0;\n\t\t\t\tvar min = 1000000;\n\t\t\t\tforeach (var c in s) {\n\t\t\t\t\tif (c == s[0]) v++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (v % 2 == 1) min = Min(min, v);\n\t\t\t\t\t\telse min = Min(min, v + 1);\n\t\t\t\t\t\tv = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDebug.WriteLine(\"po\");\n\t\t\t\tvar even = new FenwickTree(n + 1);\n\t\t\t\tfor (int i = 1; i <= min; i += 2) {\n\t\t\t\t\tDebug.WriteLine(i);\n\t\t\t\t\teven.Add(i + 1, i + 1);\n\t\t\t\t}\n\t\t\t\tDebug.WriteLine(\"po\");\n\t\t\t\tfor (int i = 4; i <= n; i += 2) {\n\t\t\t\t\tDebug.WriteLine($\"[{Max(0, i - 1 - min)} {i - 1}]\");\n\t\t\t\t\tDebug.WriteLine(even.Items.AsJoinedString());\n\t\t\t\t\teven.Add(i, even[Max(0, i - 1 - min), i - 1]);\n\t\t\t\t}\n\t\t\t\tDebug.WriteLine(even.Items.AsJoinedString());\n\t\t\t\tConsole.WriteLine(even[n, n]);\n\t\t\t}\n\t\t}\n\t\tconst long INF = 1L << 60;\n\t\tstatic int[] dx = { -1, 0, 1, 0 };\n\t\tstatic int[] dy = { 0, 1, 0, -1 };\n\t\tint ri { get { return sc.Integer(); } }\n\t\tlong rl { get { return sc.Long(); } }\n\t\tdouble rd { get { return sc.Double(); } }\n\t\tstring rs { get { return sc.Scan(); } }\n\t\tpublic IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\t\tstatic T[] Enumerate<T>(int n, Func<int, T> f) {\n\t\t\tvar a = new T[n]; for (int i = 0; i < a.Length; ++i) a[i] = f(i); return a;\n\t\t}\n\t\tstatic T[][] Enumerate<T>(int n, int m, Func<int, int, T> f) {\n\t\t\treturn Enumerate(n, x => Enumerate(m, y => f(x, y)));\n\t\t}\n\t\tstatic public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\t}\n}\n\n#region main\nstatic class Ex {\n\tstatic public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\tstatic public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n\t\treturn string.Join(st, ie);\n\t}\n\tstatic public void Main() {\n\t\tConsole.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n\t\tvar solver = new Program.Solver();\n\t\t//* \n\t\tvar t = new System.Threading.Thread(solver.Solve, 200000000);\n\t\tt.Start();\n\t\tt.Join();\n\t\t//*/\n\t\t// solver.Solve();\n\t\tConsole.Out.Flush();\n\t}\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n\tusing System.IO;\n\tusing System.Text;\n\tusing System.Globalization;\n\n\tpublic class Printer : StreamWriter {\n\t\tpublic override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n\t\tpublic Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n\t}\n\n\tpublic class StreamScanner {\n\t\tpublic StreamScanner(Stream stream) { str = stream; }\n\n\t\tpublic readonly Stream str;\n\t\tprivate readonly byte[] buf = new byte[1024];\n\t\tprivate int len, ptr;\n\t\tpublic bool isEof = false;\n\t\tpublic bool IsEndOfStream { get { return isEof; } }\n\n\t\tprivate byte read() {\n\t\t\tif (isEof) return 0;\n\t\t\tif (ptr >= len) {\n\t\t\t\tptr = 0;\n\t\t\t\tif ((len = str.Read(buf, 0, 1024)) <= 0) {\n\t\t\t\t\tisEof = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[ptr++];\n\t\t}\n\n\t\tpublic char Char() {\n\t\t\tbyte b = 0;\n\t\t\tdo b = read(); while ((b < 33 || 126 < b) && !isEof);\n\t\t\treturn (char)b;\n\t\t}\n\t\tpublic string Scan() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic string ScanLine() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n\t\tpublic int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n\t\tpublic double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n\t}\n}\n\n#endregion\n#region Fenwick\npublic class FenwickTree {\n\tint n;\n\tNumber[] bit;\n\tint max = 1;\n\tpublic FenwickTree(int size) {\n\t\tn = size; bit = new Number[n + 1];\n\t\twhile ((max << 1) <= n) max <<= 1;\n\t}\n\t/// <summary>sum[a,b]</summary>\n\tpublic Number this[int i, int j] { get { return this[j] - this[i - 1]; } }\n\t/// <summary>sum[0,i]</summary>\n\tpublic Number this[int i] { get { Number s = 0; for (; i > 0; i -= i & -i) s += bit[i]; return s; } }\n\n\t/// <summary>add v to bit[i]</summary>\n\tpublic void Add(int i, Number v) {\n\t\tif (i == 0) System.Diagnostics.Debug.Fail(\"BIT is 1 indexed\");\n\t\tfor (; i <= n; i += i & -i) bit[i] += v;\n\t}\n\tpublic Number[] Items {\n\t\tget {\n\t\t\tvar ret = new Number[n + 1];\n\t\t\tfor (int i = 0; i < ret.Length; i++)\n\t\t\t\tret[i] = this[i, i];\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n#endregion\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n\t/// <summary>\n\t/// 剰余を取る値．\n\t/// </summary>\n\tpublic const long Mod = (long)1e9 + 7;\n\n\t/// <summary>\n\t/// 実際の数値．\n\t/// </summary>\n\tpublic long num;\n\t/// <summary>\n\t/// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n\t/// </summary>\n\t/// <param name=\"n\">インスタンスが持つ値</param>\n\t/// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n\tpublic ModInt(long n) { num = n; }\n\t/// <summary>\n\t/// このインスタンスの数値を文字列に変換します．\n\t/// </summary>\n\t/// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n\tpublic override string ToString() { return num.ToString(); }\n\tpublic static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n\tpublic static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n\tpublic static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n\tpublic static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n\t/// <summary>\n\t/// 与えられた 2 つの数値からべき剰余を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">べき乗の底</param>\n\t/// <param name=\"k\">べき指数</param>\n\t/// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n\tpublic static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n\t/// <summary>\n\t/// 与えられた 2 つの数値からべき剰余を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">べき乗の底</param>\n\t/// <param name=\"k\">べき指数</param>\n\t/// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n\tpublic static ModInt Pow(long v, long k) {\n\t\tlong ret = 1;\n\t\tfor (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n\t\t\tif ((k & 1) == 1) ret = ret * v % Mod;\n\t\treturn new ModInt(ret);\n\t}\n\t/// <summary>\n\t/// 与えられた数の逆元を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">逆元を取る対象となる数</param>\n\t/// <returns>逆元となるような値</returns>\n\t/// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n\tpublic static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing static System.Math;\nusing Number = ModInt;\nusing System.Numerics;\nusing static System.Numerics.BigInteger;\nnamespace Program {\n\tpublic class Solver {\n\t\tRandom rnd = new Random(0);\n\t\tpublic void Solve() {\n\t\t\tvar n = ri;\n\t\t\tvar m = ri;\n\t\t\tvar s = rs;\n\t\t\tModInt ans = 0;\n\t\t\tif (s.Distinct().Count() == 1) {\n\t\t\t\tvar dp = new ModInt[n + 1, 2, 2];\n\t\t\t\tdp[1, 0, 0] = 1;\n\t\t\t\tdp[1, 1, 1] = 1;\n\t\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t\t\tfor (int j = 0; j < 2; j++)\n\t\t\t\t\t\tfor (int k = 0; k < 2; k++)\n\t\t\t\t\t\t\tfor (int l = 0; l < 2; l++) {\n\t\t\t\t\t\t\t\tif (j == 1 && l == 1) continue;\n\t\t\t\t\t\t\t\tdp[i + 1, l, k] += dp[i, j, k];\n\t\t\t\t\t\t\t}\n\t\t\t\tans += dp[n, 0, 0] + dp[n, 0, 1] + dp[n, 1, 0];\n\t\t\t\tConsole.WriteLine(ans);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvar v = 0;\n\t\t\t\tvar min = 1000000;\n\t\t\t\tforeach (var c in s) {\n\t\t\t\t\tif (c == s[0]) v++;\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (v % 2 == 1) min = Min(min, v);\n\t\t\t\t\t\telse min = Min(min, v + 1);\n\t\t\t\t\t\tv = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tDebug.WriteLine(\"po\");\n\t\t\t\tvar even = new FenwickTree(n + 1);\n\t\t\t\tfor (int i = 1; i <= min; i += 2) {\n\t\t\t\t\tDebug.WriteLine(i);\n\t\t\t\t\teven.Add(i + 1, i + 1);\n\t\t\t\t}\n\t\t\t\tDebug.WriteLine(\"po\");\n\t\t\t\tfor (int i = 4; i <= n; i += 2) {\n\t\t\t\t\tDebug.WriteLine($\"[{Max(0, i - 1 - min)} {i - 1}]\");\n\t\t\t\t\tDebug.WriteLine(even.Items.AsJoinedString());\n\t\t\t\t\teven.Add(i, even[Max(0, i - 1 - min), i - 1]);\n\t\t\t\t}\n\t\t\t\tDebug.WriteLine(even.Items.AsJoinedString());\n\t\t\t\tConsole.WriteLine(even[n, n]);\n\t\t\t}\n\t\t}\n\t\tconst long INF = 1L << 60;\n\t\tstatic int[] dx = { -1, 0, 1, 0 };\n\t\tstatic int[] dy = { 0, 1, 0, -1 };\n\t\tint ri { get { return sc.Integer(); } }\n\t\tlong rl { get { return sc.Long(); } }\n\t\tdouble rd { get { return sc.Double(); } }\n\t\tstring rs { get { return sc.Scan(); } }\n\t\tpublic IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\t\tstatic T[] Enumerate<T>(int n, Func<int, T> f) {\n\t\t\tvar a = new T[n]; for (int i = 0; i < a.Length; ++i) a[i] = f(i); return a;\n\t\t}\n\t\tstatic T[][] Enumerate<T>(int n, int m, Func<int, int, T> f) {\n\t\t\treturn Enumerate(n, x => Enumerate(m, y => f(x, y)));\n\t\t}\n\t\tstatic public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\t}\n}\n\n#region main\nstatic class Ex {\n\tstatic public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\tstatic public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n\t\treturn string.Join(st, ie);\n\t}\n\tstatic public void Main() {\n\t\tConsole.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n\t\tvar solver = new Program.Solver();\n\t\t//* \n\t\tvar t = new System.Threading.Thread(solver.Solve, 200000000);\n\t\tt.Start();\n\t\tt.Join();\n\t\t//*/\n\t\t// solver.Solve();\n\t\tConsole.Out.Flush();\n\t}\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n\tusing System.IO;\n\tusing System.Text;\n\tusing System.Globalization;\n\n\tpublic class Printer : StreamWriter {\n\t\tpublic override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n\t\tpublic Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n\t}\n\n\tpublic class StreamScanner {\n\t\tpublic StreamScanner(Stream stream) { str = stream; }\n\n\t\tpublic readonly Stream str;\n\t\tprivate readonly byte[] buf = new byte[1024];\n\t\tprivate int len, ptr;\n\t\tpublic bool isEof = false;\n\t\tpublic bool IsEndOfStream { get { return isEof; } }\n\n\t\tprivate byte read() {\n\t\t\tif (isEof) return 0;\n\t\t\tif (ptr >= len) {\n\t\t\t\tptr = 0;\n\t\t\t\tif ((len = str.Read(buf, 0, 1024)) <= 0) {\n\t\t\t\t\tisEof = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[ptr++];\n\t\t}\n\n\t\tpublic char Char() {\n\t\t\tbyte b = 0;\n\t\t\tdo b = read(); while ((b < 33 || 126 < b) && !isEof);\n\t\t\treturn (char)b;\n\t\t}\n\t\tpublic string Scan() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic string ScanLine() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n\t\tpublic int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n\t\tpublic double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n\t}\n}\n\n#endregion\n#region Fenwick\npublic class FenwickTree {\n\tint n;\n\tNumber[] bit;\n\tint max = 1;\n\tpublic FenwickTree(int size) {\n\t\tn = size; bit = new Number[n + 1];\n\t\twhile ((max << 1) <= n) max <<= 1;\n\t}\n\t/// <summary>sum[a,b]</summary>\n\tpublic Number this[int i, int j] { get { return this[j] - this[i - 1]; } }\n\t/// <summary>sum[0,i]</summary>\n\tpublic Number this[int i] { get { Number s = 0; for (; i > 0; i -= i & -i) s += bit[i]; return s; } }\n\n\t/// <summary>add v to bit[i]</summary>\n\tpublic void Add(int i, Number v) {\n\t\tif (i == 0) System.Diagnostics.Debug.Fail(\"BIT is 1 indexed\");\n\t\tfor (; i <= n; i += i & -i) bit[i] += v;\n\t}\n\tpublic Number[] Items {\n\t\tget {\n\t\t\tvar ret = new Number[n + 1];\n\t\t\tfor (int i = 0; i < ret.Length; i++)\n\t\t\t\tret[i] = this[i, i];\n\t\t\treturn ret;\n\t\t}\n\t}\n}\n#endregion\n#region ModInt\n/// <summary>\n/// [0,<see cref=\"Mod\"/>) までの値を取るような数\n/// </summary>\npublic struct ModInt {\n\t/// <summary>\n\t/// 剰余を取る値．\n\t/// </summary>\n\tpublic const long Mod = (long)1e9 + 7;\n\n\t/// <summary>\n\t/// 実際の数値．\n\t/// </summary>\n\tpublic long num;\n\t/// <summary>\n\t/// 値が <paramref name=\"n\"/> であるようなインスタンスを構築します．\n\t/// </summary>\n\t/// <param name=\"n\">インスタンスが持つ値</param>\n\t/// <remarks>パフォーマンスの問題上，コンストラクタ内では剰余を取りません．そのため，<paramref name=\"n\"/> ∈ [0,<see cref=\"Mod\"/>) を満たすような <paramref name=\"n\"/> を渡してください．このコンストラクタは O(1) で実行されます．</remarks>\n\tpublic ModInt(long n) { num = n; }\n\t/// <summary>\n\t/// このインスタンスの数値を文字列に変換します．\n\t/// </summary>\n\t/// <returns>[0,<see cref=\"Mod\"/>) の範囲内の整数を 10 進表記したもの．</returns>\n\tpublic override string ToString() { return num.ToString(); }\n\tpublic static ModInt operator +(ModInt l, ModInt r) { l.num += r.num; if (l.num >= Mod) l.num -= Mod; return l; }\n\tpublic static ModInt operator -(ModInt l, ModInt r) { l.num -= r.num; if (l.num < 0) l.num += Mod; return l; }\n\tpublic static ModInt operator *(ModInt l, ModInt r) { return new ModInt(l.num * r.num % Mod); }\n\tpublic static implicit operator ModInt(long n) { n %= Mod; if (n < 0) n += Mod; return new ModInt(n); }\n\n\t/// <summary>\n\t/// 与えられた 2 つの数値からべき剰余を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">べき乗の底</param>\n\t/// <param name=\"k\">べき指数</param>\n\t/// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n\tpublic static ModInt Pow(ModInt v, long k) { return Pow(v.num, k); }\n\n\t/// <summary>\n\t/// 与えられた 2 つの数値からべき剰余を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">べき乗の底</param>\n\t/// <param name=\"k\">べき指数</param>\n\t/// <returns>繰り返し二乗法により O(N log N) で実行されます．</returns>\n\tpublic static ModInt Pow(long v, long k) {\n\t\tlong ret = 1;\n\t\tfor (k %= Mod - 1; k > 0; k >>= 1, v = v * v % Mod)\n\t\t\tif ((k & 1) == 1) ret = ret * v % Mod;\n\t\treturn new ModInt(ret);\n\t}\n\t/// <summary>\n\t/// 与えられた数の逆元を計算します．\n\t/// </summary>\n\t/// <param name=\"v\">逆元を取る対象となる数</param>\n\t/// <returns>逆元となるような値</returns>\n\t/// <remarks>法が素数であることを仮定して，フェルマーの小定理に従って逆元を O(log N) で計算します．</remarks>\n\tpublic static ModInt Inverse(ModInt v) { return Pow(v, Mod - 2); }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\n\nstruct Myon2\n{\n    int a;\n}\n\nclass Myon\n{\n    public Myon() { }\n    public static int Main()\n    {\n        new Myon().calc();\n        return 0;\n    }\n\n    Scanner cin;\n\n    void calc()\n    {\n        cin = new Scanner();\n        int N = cin.nextInt();\n        int M = cin.nextInt();\n        string S = cin.next();\n        setFact(420000);\n\n\n        int cnt = 0;\n\n        int MAX = 9999999;\n        int maxLen = MAX;\n        foreach (char c in S)\n        {\n            if (c == S[0]) cnt++;\n            else\n            {\n                if (cnt == 0) continue;\n                if (cnt % 2 == 1) maxLen = Math.Min(maxLen, cnt);\n                if (maxLen == MAX) maxLen = cnt + 1;\n                cnt = 0;\n            }\n        }\n\n        if (maxLen == MAX)\n        {\n            //奇数長Rがない時の条件：\n            //Bが2連続で並ばない\n\n            //Bの数を決めれば二項径数で求められる\n\n            int maxB = N / 2;\n            long ans = 1;\n            for (int B = 1; B <= maxB; B++)\n            {\n                int nokori = N - B * 2;\n                long tmp = getC(nokori + B - 1, B - 1);\n\n                //開始地点をN倍する　Bで割る\n                tmp *= N;\n                tmp %= mod;\n                tmp *= powmod(B, mod - 2);\n                tmp %= mod;\n\n                ans += tmp;\n                ans %= mod;\n            }\n            Console.WriteLine(ans);\n\n        }\n        else\n        {\n            // RRR B RRRRR B みたいなのを作っていく\n            // Rの長さはmaxLen以下の奇数\n\n            // Bの数を決めると？\n            // R B R B R B に RR を割り当てる\n            // RRを一人に配れる最大数が決まってる\n            // どう解くんだっけこういうの……。\n\n            int maxB = N / 2;\n            long ans = 0;\n            for (int B = 1; B <= maxB; B++)\n            {\n                int nokori = N - B * 2;\n                nokori /= 2;\n                long tmp = getC(nokori + B - 1, B - 1);\n\n                int nokori2 = nokori - maxLen / 2 - 1;\n                tmp -= getC(nokori2 + B - 1, B - 1);\n                tmp %= mod;\n                tmp += mod;\n                tmp %= mod;\n\n                //開始地点をN倍する　Bで割る\n                tmp *= N;\n                tmp %= mod;\n                tmp *= powmod(B, mod - 2);\n                tmp %= mod;\n\n                ans += tmp;\n                ans %= mod;\n\n                //Console.WriteLine(B + \" \" + tmp);\n            }\n            Console.WriteLine(ans);\n\n\n\n\n\n        }\n    }\n\n    long mod = 1000000007;\n    long powmod(long a, long p)\n    {\n        long ans = 1;\n        long mul = a;\n        for (; p > 0; p >>= 1, mul = (mul * mul) % mod)\n        {\n            if ((p & 1) == 1) ans = (ans * mul) % mod;\n        }\n        return ans;\n    }\n\n\n    long[] fact; //階乗\n    long[] revFact; //階乗の逆元\n    void setFact(int N)\n    {\n        fact = new long[N];\n        revFact = new long[N];\n        fact[0] = 1;\n        for (int i = 1; i < N; i++)\n        {\n            fact[i] = fact[i - 1] * i;\n            fact[i] %= mod;\n        }\n        revFact[N - 1] = powmod(fact[N - 1], mod - 2);\n        for (int i = N - 2; i >= 0; i--)\n        {\n            revFact[i] = revFact[i + 1] * (i + 1);\n            revFact[i] %= mod;\n        }\n    }\n\n\n    long getC(int a, int b)\n    {\n        if (a < b) return 0;\n        return (((fact[a] * revFact[b]) % mod) * revFact[a - b]) % mod;\n    }\n\n\n\n}\n\n\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        if (s.Length == 0) return next();\n        i = 0;\n        return s[i++];\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n    public int[] ArrayInt(int N, int add = 0)\n    {\n        int[] Array = new int[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextInt() + add;\n        }\n        return Array;\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public long[] ArrayLong(int N, long add = 0)\n    {\n        long[] Array = new long[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextLong() + add;\n        }\n        return Array;\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n\n    public double[] ArrayDouble(int N, double add = 0)\n    {\n        double[] Array = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            Array[i] = nextDouble() + add;\n        }\n        return Array;\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum MO = 10L^^9 + 7;\n\nlong calc(int N, int L) {\n  debug {\n    writeln(\"calc \", N, \" \", L);\n  }\n  long ret;\n  auto dp = new long[N + 1];\n  auto dpSum = new long[N + 2];\n  dp[0] = 1;\n  dpSum[1] = 1;\n  foreach (x; 1 .. N + 1) {\n    dp[x] = (dpSum[x] - dpSum[max(x - L, 0)]) % MO;\n    dpSum[x + 1] = (dpSum[x] + dp[x]) % MO;\n  }\n  foreach (y; 1 .. L + 1) {\n    ret += dp[N - y] * y;\n    ret %= MO;\n  }\n  debug {\n    writeln(\"dp = \", dp);\n    writeln(\"ret = \", ret);\n  }\n  ret *= 2;\n  ret %= MO;\n  return ret;\n}\n\nvoid main() {\n  /*\n  foreach (k; 1 .. 10 + 1) {\n    write(k);\n    foreach (l; 1 .. 10 + 1) {\n      bool ok = true;\n      foreach (a; 0 .. l + 1) {\n        ok = ok && ((a <= k && (k - a) % 2 == 0) || (l - a <= k && (k - (l - a)) % 2 == 0));\n      }\n      if (ok) {\n        write(\" \", l);\n      }\n    }\n    writeln();\n  }\n  */\n  \n  try {\n    for (; ; ) {\n      const N = readInt();\n      const M = readInt();\n      const S = readToken();\n      \n      debug {\n        int ansBrute;\n        foreach (p; 0 .. 1 << N) {\n          bool ok = true;\n          foreach (s; 0 .. N) {\n            auto dp = new bool[][](M + 1, N);\n            dp[0][s] = true;\n            foreach (i; 0 .. M) {\n              foreach (u; 0 .. N) {\n                if (dp[i][u]) {\n                  if (S[i] == \"RB\"[(p >> u) & 1]) {\n                    dp[i + 1][(u + 1) % N] = true;\n                  }\n                  if (S[i] == \"RB\"[(p >> ((u - 1 + N) % N)) & 1]) {\n                    dp[i + 1][(u - 1 + N) % N] = true;\n                  }\n                }\n              }\n            }\n            ok = ok && dp[M].any;\n          }\n          if (ok) {\n            ++ansBrute;\n            /*\n            auto a = iota(N).map!(u => (p >> u) & 1);\n            write(a);\n            foreach (u; 0 .. N) {\n              if ((p >> u) & 1) {\n                for (int v = u, w = u; v < u + N; v = w) {\n                  for (; w < u + N && a[v % N] == a[w % N]; ++w) {}\n                  if (a[v % N] == 0) {\n                    write(\" \", w - v);\n                  }\n                }\n                writeln();\n                break;\n              }\n            }\n            */\n          }\n        }\n        writeln(\"ansBrute = \", ansBrute);\n      }\n      \n      auto A = new int[M];\n      foreach (i; 0 .. M) {\n        A[i] = (S[i] == 'R') ? 0 : 1;\n      }\n      if (A[0] == 1) {\n        foreach (i; 0 .. M) {\n          A[i] ^= 1;\n        }\n      }\n      debug {\n        writeln(\"A = \", A);\n      }\n      int lim = N - 1;\n      if (lim % 2 == 0) {\n        --lim;\n      }\n      for (int i = 0, j = 0; i < M; i = j) {\n        for (; j < M && A[i] == A[j]; ++j) {}\n        if (A[i] == 0) {\n          debug {\n            writeln(\"segment \", i, \" \", j);\n          }\n          if (i == 0) {\n            if (j == M) {\n              // ok\n            } else {\n              chmin(lim, 2 * ((j - i) / 2) + 1);\n            }\n          } else {\n            if (j == M) {\n              // ok\n            } else {\n              if ((j - i) % 2 != 0) {\n                chmin(lim, j - i);\n              }\n            }\n          }\n        }\n      }\n      debug {\n        writeln(\"lim = \", lim);\n      }\n      \n      long ans;\n      if (A.all!\"a == 0\") {\n        // just no 11\n        foreach (s; 0 .. 2) {\n          auto dp = new long[][](N, 2);\n          dp[0][s] = 1;\n          foreach (i; 1 .. N) {\n            dp[i][0] += dp[i - 1][0];\n            dp[i][1] += dp[i - 1][0];\n            dp[i][0] += dp[i - 1][1];\n            dp[i][] %= MO;\n          }\n          foreach (t; 0 .. 2) {\n            if (!(s == 1 && t == 1)) {\n              ans += dp[N - 1][t];\n              ans %= MO;\n            }\n          }\n        }\n      } else {\n        if (N % 2 == 0) {\n          ans += calc(N / 2, (lim + 1) / 2);\n        }\n      }\n      ans = (ans % MO + MO) % MO;\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Nim",
    "code": "import sequtils, strutils\n\nconst\n  mo = 1_000_000_007\nlet\n  nm = stdin.readline.split.map(parseInt)\n  (n, m) = (nm[0], nm[1])\n  s = stdin.readline\n  cs = toSeq(s.items).deduplicate\n\nif len(cs) == 1:\n  var dp = newSeqWith(2, newSeq[int](n))\n  dp[0][0] = 1\n  dp[1][0] = 0\n  for i in 1..<n:\n    dp[0][i] = (dp[0][i-1] + dp[1][i-1]) mod mo\n    dp[1][i] = dp[0][i-1]\n  echo ((dp[0][n-1] + dp[1][n-1] + dp[0][n-2]) mod mo)\n\nelif n mod 2 == 1:\n  echo 0\n\nelse:\n  var\n    s = s.strip(chars={cs[0]}, leading=false)\n    t = s.strip(chars={cs[0]}, trailing=false)\n    k = n-1\n    d = len(s) - len(t)\n  if d mod 2 == 0:\n    k = min(k, d+1)\n  else:\n    k = min(k, d)\n  while len(s)!=0:\n    s = t.strip(chars={cs[1]}, trailing=false)\n    t = s.strip(chars={cs[0]}, trailing=false)\n    d = len(s) - len(t)\n    if d mod 2 == 1:\n      k = min(k, d)\n  var\n    m = n div 2\n    l = k div 2\n    dp = newSeq[int](m + 3)\n  dp[1] = 1\n  for i in 2..(m+1):\n    dp[i] = ((dp[i-1]*2 - dp[max(0, i-l-2)]) mod mo + mo) mod mo\n  var res = 0\n  for j in countdown(l, 0):\n    res = (res + (dp[m-j]-dp[m-j-1])*(j+1) mod mo + mo) mod mo\n\n  echo (res*2 mod mo)\n    "
  },
  {
    "language": "Nim",
    "code": "#{{{ header\n{.hints:off warnings:off optimization:speed.}\nimport algorithm, sequtils, tables, macros, math, sets, strutils\nwhen defined(MYDEBUG):\n  import header\n\nimport streams\nproc scanf(formatstr: cstring){.header: \"<stdio.h>\", varargs.}\n#proc getchar(): char {.header: \"<stdio.h>\", varargs.}\nproc nextInt(): int = scanf(\"%lld\",addr result)\nproc nextFloat(): float = scanf(\"%lf\",addr result)\nproc nextString[F](f:F): string =\n  var get = false\n  result = \"\"\n  while true:\n#    let c = getchar()\n    let c = f.readChar\n    if c.int > ' '.int:\n      get = true\n      result.add(c)\n    elif get: return\nproc nextInt[F](f:F): int = parseInt(f.nextString)\nproc nextFloat[F](f:F): float = parseFloat(f.nextString)\nproc nextString():string = stdin.nextString()\n\ntype SomeSignedInt = int|int8|int16|int32|int64|BiggestInt\ntype SomeUnsignedInt = uint|uint8|uint16|uint32|uint64\ntype SomeInteger = SomeSignedInt|SomeUnsignedInt\ntype SomeFloat = float|float32|float64|BiggestFloat\ntemplate `max=`*(x,y:typed):void = x = max(x,y)\ntemplate `min=`*(x,y:typed):void = x = min(x,y)\ntemplate inf(T): untyped = \n  when T is SomeFloat: T(Inf)\n  elif T is SomeInteger: ((T(1) shl T(sizeof(T)*8-2)) - (T(1) shl T(sizeof(T)*4-1)))\n  else: assert(false)\n\nproc sort[T](v: var seq[T]) = v.sort(cmp[T])\nproc discardableId[T](x: T): T {.discardable.} =\n  return x\nmacro `:=`(x, y: untyped): untyped =\n  if (x.kind == nnkIdent):\n    return quote do:\n      when declaredInScope(`x`):\n        `x` = `y`\n      else:\n        var `x` = `y`\n      discardableId(`x`)\n  else:\n    return quote do:\n      `x` = `y`\n      discardableId(`x`)\nmacro dump*(x: typed): untyped =\n  let s = x.toStrLit\n  let r = quote do:\n    debugEcho `s`, \" = \", `x`\n  return r\n\nproc toStr[T](v:T):string =\n  proc `$`[T](v:seq[T]):string =\n    v.mapIt($it).join(\" \")\n  return $v\n\nproc print0(x: varargs[string, toStr]; sep:string):string{.discardable.} =\n  result = \"\"\n  for i,v in x:\n    if i != 0: addSep(result, sep = sep)\n    add(result, v)\n  result.add(\"\\n\")\n  stdout.write result\n\nvar print:proc(x: varargs[string, toStr])\nprint = proc(x: varargs[string, toStr]) =\n  discard print0(@x, sep = \" \")\n\nproc ndSeqImpl[T](lens: seq[int]; init: T; currentDimension, lensLen: static[int]): auto =\n  when currentDimension == lensLen:\n    newSeqWith(lens[currentDimension - 1], init)\n  else:\n    newSeqWith(lens[currentDimension - 1], ndSeqImpl(lens, init, currentDimension + 1, lensLen))\n\ntemplate ndSeq*[T](lens: varargs[int]; init: T): untyped =\n  ndSeqImpl(@lens, init, 1, lens.len)\n#}}}\n\nconst MOD = 1000000007\nvar N:int\nvar M:int\nvar S:string\n\n#{{{ input part\nproc main()\nblock:\n  N = nextInt()\n  M = nextInt()\n  S = nextString()\n#}}}\n\n#{{{ ModInt[Mod]\nproc getDefault(T:typedesc): T = (var temp:T;temp)\nproc getDefault[T](x:T): T = (var temp:T;temp)\n\ntype ModInt[Mod: static[int]] = object\n  v:int\nproc initModInt[T](a:T, Mod: static[int]):ModInt[Mod] =\n  when T is ModInt[Mod]:\n    return a\n  else:\n    var a = a\n    a = a mod Mod\n    if a < 0: a += Mod\n    result.v = a\nproc initModInt[T](a:T):ModInt[Mod] = initModInt(a, MOD)\nproc init[T](self:ModInt[Mod], a:T):ModInt[Mod] = initModInt(a, Mod)\nproc Identity(self:ModInt[Mod]):ModInt[Mod] = return initModInt(1, Mod)\n\nproc `==`[T](a:ModInt[Mod], b:T):bool = a.v == a.init(b).v\nproc `!=`[T](a:ModInt[Mod], b:T):bool = a.v != a.init(b).v\nproc `-`(self:ModInt[Mod]):ModInt[Mod] =\n  if self.v == 0: return self\n  else: return ModInt[Mod](v:MOD - self.v)\nproc `$`(a:ModInt[Mod]):string = return $(a.v)\n\nproc `+=`[T](self:var ModInt[Mod]; a:T):void =\n  self.v += initModInt(a, Mod).v\n  if self.v >= MOD: self.v -= MOD\nproc `-=`[T](self:var ModInt[Mod],a:T):void =\n  self.v -= initModInt(a, Mod).v\n  if self.v < 0: self.v += MOD\nproc `*=`[T](self:var ModInt[Mod],a:T):void =\n  self.v *= initModInt(a, Mod).v\n  self.v = self.v mod MOD\nproc `^=`(self:var ModInt[Mod], n:int) =\n  var (x,n,a) = (self,n,self.Identity)\n  while n > 0:\n    if (n and 1) > 0: a *= x\n    x *= x\n    n = (n shr 1)\n  swap(self, a)\nproc inverse(x:int):ModInt[Mod] =\n  var (a, b) = (x, MOD)\n  var (u, v) = (1, 0)\n  while b > 0:\n    let t = a div b\n    a -= t * b;swap(a,b)\n    u -= t * v;swap(u,v)\n  return initModInt(u, Mod)\nproc `/=`[T](a:var ModInt[Mod],b:T):void = a *= initModInt(b, Mod).v.inverse()\nproc `+`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result += b\nproc `-`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result -= b\nproc `*`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a;result *= b\nproc `/`[T](a:ModInt[Mod],b:T):ModInt[Mod] = result = a; result /= b\nproc `^`(a:ModInt[Mod],b:int):ModInt[Mod] = result = a; result ^= b\n#}}}\n\ntype Mint = ModInt[Mod]\nproc initMint[T](a:T):ModInt[Mod] = initModInt(a, Mod)\n\n# CumulativeSum {{{\nimport sequtils\n\ntype CumulativeSum[T] = object\n  pos:int\n  data: seq[T]\n\nproc initCumulativeSum[T]():CumulativeSum[T] = CumulativeSum[T](data: newSeqWith(1, T().init(0)), pos:0)\nproc `[]=`[T](self: var CumulativeSum[T], k:int, x:T) =\n  if k < self.pos: doAssert(false)\n  if self.data.len < k + 2:\n    self.data.setlen(k + 2)\n  for i in self.pos+1..<k:\n    self.data[i + 1] = self.data[i]\n  self.data[k + 1] = self.data[k] + x\n  self.pos = k\n\nproc initCumulativeSum[T](data:seq[T]):CumulativeSum[T] =\n  result = initCumulativeSum[T]()\n  for i,d in data: result[i] = d\n\nproc sum[T](self: CumulativeSum[T], k:int):T =\n  if k < 0: return T().init(0)\n  return self.data[min(k, self.data.len - 1)]\nproc `[]`[T](self: CumulativeSum[T], s:Slice[int]):T =\n  if s.a > s.b: return T().init(0)\n  return self.sum(s.b + 1) - self.sum(s.a)\n#}}}\n\nproc runLengthEncoding[T](v:seq[T]):seq[(T,int)] =\n  result = newSeq[(T,int)]()\n  var i = 0\n  while i < v.len:\n    var j = i\n    while j < v.len and v[j] == v[i]: j.inc\n    result.add((v[i], j - i))\n    i = j\n  discard\n\nproc main() =\n  if S[0] == 'B':\n    for s in S.mitems:\n      if s == 'R': s = 'B'\n      elif s == 'B': s = 'R'\n  v := cast[seq[char]](S).runLengthEncoding()\n  if v.len == 1:\n    dp := newSeq[Mint](N + 1)\n    dp[0] = initMint(1)\n    dp[1] = initMint(2)\n    for i in 2..N:\n      dp[i] = dp[i - 1] + dp[i - 2]\n    ans := initMint(1 + N)\n    for d in 1..<N:\n      # RBRBR\n      rest := N - d - 2 - 2\n      if rest == -1: rest = 0\n      if rest >= 0:\n#        echo \"add: \", d, \" \", rest\n        ans += dp[rest] * (d + 1)\n    echo ans\n    return\n  if N mod 2 != 0:\n    echo 0;return\n  var t = if v[0][1] mod 2 == 0: v[0][1] + 1 else: v[0][1]\n  for i in 0..<v.len - 1:\n    let p = v[i]\n    if p[0] == 'R':\n      if p[1] mod 2 == 1: t.min= p[1]\n#  dump(t)\n  t2 := (t + 1) div 2\n  dp := newSeq[Mint](N div 2 + 1)\n  cs := initCumulativeSum[Mint]()\n  dp[0] = initMint(1)\n  cs[0] = dp[0]\n  for i in 1..<dp.len:\n    dp[i] = cs[i-t2..i-1]\n    cs[i] = dp[i]\n  ans := initMint(0)\n  for d in countup(1, t, 2):\n    rest := N - (d + 1)\n    ans += dp[rest div 2] * (d + 1)\n  echo ans\n  return\n\nmain()\n"
  },
  {
    "language": "Nim",
    "code": "import sequtils, strutils\n\nconst\n  mo = 1_000_000_007\nlet\n  nm = stdin.readline.split.map(parseInt)\n  (n, m) = (nm[0], nm[1])\n  s = stdin.readline\n  cs = toSeq(s.items).deduplicate\n\nif len(cs) == 1:\n  var dp = newSeqWith(2, newSeq[int](n))\n  dp[0][0] = 1\n  dp[1][0] = 0\n  for i in 1..<n:\n    dp[0][i] = (dp[0][i-1] + dp[1][i-1]) mod mo\n    dp[1][i] = dp[0][i-1]\n  echo ((dp[0][n-1] + dp[1][n-1] + dp[0][n-2]) mod mo)\n\nelif n mod 2 == 1:\n  echo 0\n\nelse:\n  var\n    s = s.strip(chars={cs[0]}, leading=false)\n    t = s.strip(chars={cs[0]}, trailing=false)\n    k = n\n    d = len(s) - len(t)\n  if d mod 2 == 0:\n    k = min(k, d+1)\n  else:\n    k = min(k, d)\n  s = t.strip(chars={cs[1]}, trailing=false)\n  t = s.strip(chars={cs[0]}, trailing=false)\n  while len(s)!=0:\n    d = len(s) - len(t)\n    if d mod 2 == 1:\n      k = min(k, d)\n    s = t.strip(chars={cs[1]}, trailing=false)\n    t = s.strip(chars={cs[0]}, trailing=false)\n  var\n    m = n div 2\n    l = k div 2\n    dp = newSeq[int](m + 3)\n  dp[1] = 1\n  for i in 2..(m+1):\n    dp[i] = ((dp[i-1]*2 - dp[max(0, i-l-2)]) mod mo + mo) mod mo\n  var res = 0\n  for j in countdown(l, 0):\n    res = (res + (dp[m-j]-dp[m-j-1])*(j+1) mod mo) mod mo\n  echo (res*2 mod mo)\n "
  },
  {
    "language": "Nim",
    "code": "import sequtils, strutils\n\nconst\n  mo = 1_000_000_007\nlet\n  nm = stdin.readline.split.map(parseInt)\n  (n, m) = (nm[0], nm[1])\n  s = stdin.readline\n  cs = toSeq(s.items).deduplicate\n\nif len(cs) == 1:\n  var dp = newSeqWith(2, newSeq[int](n))\n  dp[0][0] = 1\n  dp[1][0] = 0\n  for i in 1..<n:\n    dp[0][i] = (dp[0][i-1] + dp[1][i-1]) mod mo\n    dp[1][i] = dp[0][i-1]\n  echo ((dp[0][n-1] + dp[1][n-1] + dp[0][n-2]) mod mo)\n\nelif n mod 2 == 1:\n  echo 0\n\nelse:\n  var\n    s = s.strip(chars={cs[0]}, leading=false)\n    t = s.strip(chars={cs[0]}, trailing=false)\n    k = n-1\n    d = len(s) - len(t)\n  if d mod 2 == 0:\n    k = min(k, d+1)\n  else:\n    k = min(k, d)\n  while len(s)!=0:\n    s = t.strip(chars={cs[1]}, trailing=false)\n    t = s.strip(chars={cs[0]}, trailing=false)\n    d = len(s) - len(t)\n    if d mod 2 == 1:\n      k = min(k, d)\n  var\n    m = n div 2\n    l = k div 2\n    dp = newSeq[int](m + 3)\n  dp[1] = 1\n  for i in 2..(m+1):\n    dp[i] = ((dp[i-1]*2 - dp[max(0, i-l-2)]) mod mo + mo) mod mo\n  var res = 0\n  for j in countdown(l, 0):\n    res = (res + (dp[m-j]-dp[m-j-1])*(j+1) mod mo) mod mo\n\n  echo (res*2 mod mo)\n    "
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc033/tasks/agc033_e\n\nSの1文字目をRとしてよい\n\nRB  から始まる場合　→ 全部交互以外無理(Nが奇数なら0)\nRRB から始まる場合　→ Rは3連で置けば可能…\n\nR*X + B*Y + R*Z …\nとつながっていく\n\nどこからスタートしても、RだけをX回移動したときにBの隣に来なくてはいけない\nRの長さが1なら可能\n\nR*?,B,R*?,…\nでつながっていく\n\n最初のRがX個連続の時\n片方の端との距離がX-2tでなくてはならない\nXが偶数の時、Rの連続長さはX+1以下の奇数\nXが奇数の時、端からスタートした奴は反対側に抜けなくてはいけないので\nRの連続長さはX以下の奇数？\n結局は奇数個連続でしか置けない\n\n\n●整理(Rから始まり、Bがある場合)：\nRは奇数個連続でしか置けない\nBは1個連続でしか置けない\n→つまり、Nが奇数だとアウト\n\n\nBが来た以降を考えてみる\n奇数だと、各点Rの左右のどちらかにしか抜けられない→対称的な移動になるはず\n→つまり、最初のRを消化した後、全てのBの両端にいる場合が存在する\n\nBは奇数個の時のみ意味がある\n→結局、Bの両端にいた場合が交換されるだけ\n→よって、BはRの区切り以上の意味はない\n\nRが偶数個来るた場合、交互に移動すればおk\nRが奇数個来た場合、反対側に抜ける必要がある\n\n結論：\nRBがどちらも存在する場合、Nが偶数なら0、奇数の場合は\nBでsplitしたRの個数の集合を考え,\nr1,r2…,r? とする\nRは奇数個連続で置けて、その個数の最大は M = min( r1+1 , r? ) #r?が奇数の物\n後は、M+1個以下の偶数個単位で区切る場合の数を調べればいい\ndp→あらかじめ1番目の区間の位置に、ずれた分も考慮して値を入れておけばBITでもらうdpできる\n\nRB片方の場合、Bが連続しないような置き方をすればいい\n1番目がRの場合をdp → N番目までやる\n1番目がBの場合をdp → N-1番目までやる(N番目は赤なので)\n\n最後のRは意味がないので消しておく\n\n\nREの原因究明したい\nK < NNの場合？\n\n\n\"\"\"\n\nfrom sys import stdin\nimport sys\n#0-indexed , 半開区間[a,b)\n#calc変更で演算変更\nclass SegTree:\n\n    def __init__(self,N,first):\n        self.NO = 2**(N-1).bit_length()\n        self.First = first\n        self.data = [first] * (2*self.NO)\n\n    def calc(self,l,r):\n        return (l+r) % mod\n\n    def update(self,ind,x):\n        ind += self.NO - 1\n        self.data[ind] = x\n        while ind >= 0:\n            ind = (ind - 1)//2\n            self.data[ind] = self.calc(self.data[2*ind+1],self.data[2*ind+2])\n\n    def query(self,l,r):\n        L = l + self.NO\n        R = r + self.NO\n        s = self.First\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.calc(s , self.data[R-1])\n            if L & 1:\n                s = self.calc(s , self.data[L-1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\n    def get(self , ind):\n        ind += self.NO - 1\n        return self.data[ind]\n\nN,M = map(int,stdin.readline().split())\nS = list(stdin.readline()[:-1])\nmod = 10**9+7\n\nif \"R\" in S and \"B\" in S:\n\n    if N % 2 == 1:\n        print (0)\n        sys.exit()\n\n    lis = []\n    now = 0\n    while S[-1] == S[0]: #最後のRを消す\n        del S[-1]\n    for i in S:\n        if i == S[0]:\n            now += 1\n        elif now > 0:\n            lis.append(now)\n            now = 0\n    #print (lis)\n\n    nmax = 0\n    for i in range(len(lis)):\n        if i == 0:\n            if lis[i] % 2 == 0:\n                nmax = lis[i] + 1\n            else:\n                nmax = lis[i]\n        elif lis[i] % 2 == 1:\n            nmax = min(nmax , lis[i])\n\n    NN   = N//2\n    K    = (nmax+1)//2\n    #print (NN,K)\n\n    if NN <= K:\n        print (pow(2,NN,mod))\n        sys.exit()\n\n    ST = SegTree(NN,0)\n    for i in range(K):\n        ST.update(i,i+1)\n\n    for i in range(1,NN):\n        now = ST.get(i)\n        plus = ST.query( max(0,i-K),i )\n        ST.update( i , (now+plus) % mod )\n\n    print (ST.get(NN-1) * 2 % mod)\n        \nelse:\n\n    ans = 0\n    #1番目がRの場合\n    dp = [1,0]\n    for i in range(N-1):\n        ndp = [0,0]\n        ndp[0] = (dp[0] + dp[1]) % mod\n        ndp[1] = dp[0]\n        dp = ndp\n\n    ans += sum(dp)\n\n    #1番目がBの場合\n    dp = [0,1]\n    for i in range(N-2):\n        ndp = [0,0]\n        ndp[0] = (dp[0] + dp[1]) % mod\n        ndp[1] = dp[0]\n        dp = ndp\n    ans += sum(dp)\n\n    print (ans % mod)\n"
  },
  {
    "language": "Python",
    "code": "def solve(n, m, s):\n    f = s[0]\n    MOD = 10 ** 9 + 7\n\n    p = None\n    seq = 0\n    min_seq = MOD\n    for c in s:\n        if c == p:\n            seq += 1\n        else:\n            if p == f:\n                min_seq = min(min_seq, seq)\n            seq = 1\n            p = c\n\n    if min_seq == MOD:\n        a, b = 1, 0\n        for _ in range(n - 2):\n            a, b = (a + b) % MOD, a % MOD\n        return (3 * a + b) % MOD\n\n    if n % 2 == 1:\n        return 0\n\n    ms = min_seq // 2 + 1\n\n    dp = [0] * (n // 2 + 1)\n    ap = [0] * (n // 2 + 1)\n    dp[0] = 1\n    ap[0] = 1\n    for i in range(1, n // 2 + 1):\n        j = max(-1, i - ms - 1)\n        dp[i] = (ap[i - 1] - ap[j]) % MOD\n        ap[i] = (ap[i - 1] + dp[i]) % MOD\n\n    # print(ms)\n    # print(dp)\n    # print(ap)\n\n    ans = 0\n    for d in range(2, ms * 2 + 1, 2):\n        ans = (ans + dp[(n - d) // 2] * d) % MOD\n\n    return ans\n\n\nn, m = map(int, input().split())\ns = input()\n\nprint(solve(n, m, s))\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc033/tasks/agc033_e\n\nSの1文字目をRとしてよい\n\nRB  から始まる場合　→ 全部交互以外無理(Nが奇数なら0)\nRRB から始まる場合　→ Rは3連で置けば可能…\n\nR*X + B*Y + R*Z …\nとつながっていく\n\nどこからスタートしても、RだけをX回移動したときにBの隣に来なくてはいけない\nRの長さが1なら可能\n\nR*?,B,R*?,…\nでつながっていく\n\n最初のRがX個連続の時\n片方の端との距離がX-2tでなくてはならない\nXが偶数の時、Rの連続長さはX+1以下の奇数\nXが奇数の時、端からスタートした奴は反対側に抜けなくてはいけないので\nRの連続長さはX以下の奇数？\n結局は奇数個連続でしか置けない\n\n\n●整理(Rから始まり、Bがある場合)：\nRは奇数個連続でしか置けない\nBは1個連続でしか置けない\n→つまり、Nが奇数だとアウト\n\n\nBが来た以降を考えてみる\n奇数だと、各点Rの左右のどちらかにしか抜けられない→対称的な移動になるはず\n→つまり、最初のRを消化した後、全てのBの両端にいる場合が存在する\n\nBは奇数個の時のみ意味がある\n→結局、Bの両端にいた場合が交換されるだけ\n→よって、BはRの区切り以上の意味はない\n\nRが偶数個来るた場合、交互に移動すればおk\nRが奇数個来た場合、反対側に抜ける必要がある\n\n結論：\nRBがどちらも存在する場合、Nが偶数なら0、奇数の場合は\nBでsplitしたRの個数の集合を考え,\nr1,r2…,r? とする\nRは奇数個連続で置けて、その個数の最大は M = min( r1+1 , r? ) #r?が奇数の物\n後は、M+1個以下の偶数個単位で区切る場合の数を調べればいい\ndp→あらかじめ1番目の区間の位置に、ずれた分も考慮して値を入れておけばBITでもらうdpできる\n\nRB片方の場合、Bが連続しないような置き方をすればいい\n1番目がRの場合をdp → N番目までやる\n1番目がBの場合をdp → N-1番目までやる(N番目は赤なので)\n\n最後のRは意味がないので消しておく\n\n\nREの原因究明したい\nK < NNの場合？\n\n\n\"\"\"\n\nfrom sys import stdin\nimport sys\n#0-indexed , 半開区間[a,b)\n#calc変更で演算変更\nclass SegTree:\n\n    def __init__(self,N,first):\n        self.NO = 2**(N-1).bit_length()\n        self.First = first\n        self.data = [first] * (2*self.NO)\n\n    def calc(self,l,r):\n        return (l+r) % mod\n\n    def update(self,ind,x):\n        ind += self.NO - 1\n        self.data[ind] = x\n        while ind >= 0:\n            ind = (ind - 1)//2\n            self.data[ind] = self.calc(self.data[2*ind+1],self.data[2*ind+2])\n\n    def query(self,l,r):\n        L = l + self.NO\n        R = r + self.NO\n        s = self.First\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.calc(s , self.data[R-1])\n            if L & 1:\n                s = self.calc(s , self.data[L-1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\n    def get(self , ind):\n        ind += self.NO - 1\n        return self.data[ind]\n\nN,M = map(int,stdin.readline().split())\nS = list(stdin.readline()[:-1])\nmod = 10**9+7\n\nif \"R\" in S and \"B\" in S:\n\n    if N % 2 == 1:\n        print (0)\n        sys.exit()\n\n    lis = []\n    now = 0\n    while S[-1] == S[0]: #最後のRを消す\n        del S[-1]\n    for i in S:\n        if i == S[0]:\n            now += 1\n        elif now > 0:\n            lis.append(now)\n            now = 0\n    #print (lis)\n\n    nmax = 0\n    for i in range(len(lis)):\n        if i == 0:\n            if lis[i] % 2 == 0:\n                nmax = lis[i] + 1\n            else:\n                nmax = lis[i]\n        elif lis[i] % 2 == 1:\n            nmax = min(nmax , lis[i])\n\n    NN   = N//2\n    K    = (nmax+1)//2\n    print (NN,K)\n\n    if NN <= K:\n        print (pow(2,NN,mod))\n        sys.exit()\n\n    ST = SegTree(NN,0)\n    for i in range(K):\n        ST.update(i,i+1)\n\n    for i in range(1,NN):\n        now = ST.get(i)\n        plus = ST.query( max(0,i-K),i )\n        ST.update( i , (now+plus) % mod )\n\n    print (ST.get(NN-1) * 2 % mod)\n        \nelse:\n\n    ans = 0\n    #1番目がRの場合\n    dp = [1,0]\n    for i in range(N-1):\n        ndp = [0,0]\n        ndp[0] = (dp[0] + dp[1]) % mod\n        ndp[1] = dp[0]\n        dp = ndp\n\n    ans += sum(dp)\n\n    #1番目がBの場合\n    dp = [0,1]\n    for i in range(N-2):\n        ndp = [0,0]\n        ndp[0] = (dp[0] + dp[1]) % mod\n        ndp[1] = dp[0]\n        dp = ndp\n    ans += sum(dp)\n\n    print (ans % mod)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nn,m = map(int,input().split())\ns = input()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = dp[i-1][0]+dp[i-1][1]\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 0\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  elif flg == 1:\n    flg = 0\n    ncnt = cnt\n    cnt = 0\n  else:\n    if cnt%2:\n      flg = -1\n    cnt = 0\nif ncnt%2:\n  flg = -1\nif flg == -1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nif n//2 >= ncnt+1:\n  for j in range(1,y+1):\n    ans -= (dp[n//2-(y+j)-2][0])*(y+1-j)\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 10**18\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  else:\n    if cnt%2:\n      ncnt = min(ncnt,cnt)\n    cnt = 0\nif ncnt == 1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nfor j in range(1,y+1):\n  if n//2-(y+j)-2 >= 0:\n    ans = (ans-(dp[n//2-(y+j)-2][0])*(y+1-j))%mod\n  elif n//2-(y+j) >= 0:\n    ans -= 1\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 0\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  elif flg == 1:\n    flg = 0\n    ncnt = cnt\n    cnt = 0\n  else:\n    if cnt%2:\n      ncnt = min(ncnt,cnt)\n    cnt = 0\nif ncnt == 1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nfor j in range(1,y+1):\n  if n//2-(y+j)-2 >= 0:\n    ans = (ans-(dp[n//2-(y+j)-2][0])*(y+1-j))%mod\n  elif n//2-(y+j) >= 0:\n    ans -= 1\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 0\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  elif flg == 1:\n    flg = 0\n    ncnt = cnt\n    cnt = 0\n  else:\n    if cnt%2:\n      ncnt = min(ncnt,cnt)\n    cnt = 0\nif ncnt == 1:\n  print(2)\n  exit()\ny = (ncnt+1)//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nfor j in range(1,y+1):\n  if n//2-(y+j)-2 >= 0:\n    ans = (ans-(dp[n//2-(y+j)-2][0])*(y+1-j))%mod\n  elif n//2-(y+j) >= 0:\n    ans -= 1\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 0\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  elif flg == 1:\n    flg = 0\n    ncnt = cnt\n    cnt = 0\n  else:\n    if cnt%2:\n      flg = -1\n    cnt = 0\nif flg == -1 or ncnt == 1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nfor j in range(1,y+1):\n  if n//2-(y+j)-2 >= 0:\n    ans = (ans-(dp[n//2-(y+j)-2][0])*(y+1-j))%mod\n  elif n//2-(y+j) >= 0:\n    ans -= 1\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 0\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  elif flg == 1:\n    flg = 0\n    ncnt = cnt\n    cnt = 0\n  else:\n    if cnt%2:\n      ncnt = min(ncnt,cnt)\n    cnt = 0\nif ncnt == 1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nfor j in range(1,y+1):\n  if n//2-(y+j)-2 >= 0:\n    ans = (ans-(dp[n//2-(y+j)-2][0])*(y+1-j))%mod\n  elif n//2-(y+j) == 1:\n    ans -= y+1-j\n  elif n//2-(y+j) == 0:\n    ans -= 1\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 0\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  elif flg == 1:\n    flg = 0\n    ncnt = cnt\n    cnt = 0\n  else:\n    if cnt%2:\n      flg = -1\n    cnt = 0\nif ncnt%2:\n  flg = -1\nif flg == -1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nif n//2 >= ncnt+1:\n  for j in range(1,y+1):\n    ans = (ans-(dp[n//2-(y+j)-2][0])*(y+1-j))%mod\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 10**18\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  else:\n    ncnt = min(ncnt,cnt)\n    cnt = 0\nif ncnt == 1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nfor j in range(1,y+1):\n  if n//2-(y+j)-2 >= 0:\n    ans = (ans-(dp[n//2-(y+j)-2][0])*(y+1-j))%mod\n  elif n//2-(y+j) >= 0:\n    ans -= 1\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc033/tasks/agc033_e\n\nSの1文字目をRとしてよい\n\nRB  から始まる場合　→ 全部交互以外無理(Nが奇数なら0)\nRRB から始まる場合　→ Rは3連で置けば可能…\n\nR*X + B*Y + R*Z …\nとつながっていく\n\nどこからスタートしても、RだけをX回移動したときにBの隣に来なくてはいけない\nRの長さが1なら可能\n\nR*?,B,R*?,…\nでつながっていく\n\n最初のRがX個連続の時\n片方の端との距離がX-2tでなくてはならない\nXが偶数の時、Rの連続長さはX+1以下の奇数\nXが奇数の時、端からスタートした奴は反対側に抜けなくてはいけないので\nRの連続長さはX以下の奇数？\n結局は奇数個連続でしか置けない\n\n\n●整理(Rから始まり、Bがある場合)：\nRは奇数個連続でしか置けない\nBは1個連続でしか置けない\n→つまり、Nが奇数だとアウト\n\n\nBが来た以降を考えてみる\n奇数だと、各点Rの左右のどちらかにしか抜けられない→対称的な移動になるはず\n→つまり、最初のRを消化した後、全てのBの両端にいる場合が存在する\n\nBは奇数個の時のみ意味がある\n→結局、Bの両端にいた場合が交換されるだけ\n→よって、BはRの区切り以上の意味はない\n\nRが偶数個来るた場合、交互に移動すればおk\nRが奇数個来た場合、反対側に抜ける必要がある\n\n結論：\nRBがどちらも存在する場合、Nが偶数なら0、奇数の場合は\nBでsplitしたRの個数の集合を考え,\nr1,r2…,r? とする\nRは奇数個連続で置けて、その個数の最大は M = min( r1+1 , r? ) #r?が奇数の物\n後は、M+1個以下の偶数個単位で区切る場合の数を調べればいい\ndp→あらかじめ1番目の区間の位置に、ずれた分も考慮して値を入れておけばBITでもらうdpできる\n\nRB片方の場合、Bが連続しないような置き方をすればいい\n1番目がRの場合をdp → N番目までやる\n1番目がBの場合をdp → N-1番目までやる(N番目は赤なので)\n\n最後のRは意味がないので消しておく\n\n\nREの原因究明したい\nK < NNの場合？\n\n\n\"\"\"\n\nfrom sys import stdin\nimport sys\n#0-indexed , 半開区間[a,b)\n#calc変更で演算変更\nclass SegTree:\n\n    def __init__(self,N,first):\n        self.NO = 2**(N-1).bit_length()\n        self.First = first\n        self.data = [first] * (2*self.NO)\n\n    def calc(self,l,r):\n        return (l+r) % mod\n\n    def update(self,ind,x):\n        ind += self.NO - 1\n        self.data[ind] = x\n        while ind >= 0:\n            ind = (ind - 1)//2\n            self.data[ind] = self.calc(self.data[2*ind+1],self.data[2*ind+2])\n\n    def query(self,l,r):\n        L = l + self.NO\n        R = r + self.NO\n        s = self.First\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.calc(s , self.data[R-1])\n            if L & 1:\n                s = self.calc(s , self.data[L-1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\n    def get(self , ind):\n        ind += self.NO - 1\n        return self.data[ind]\n\nN,M = map(int,stdin.readline().split())\nS = list(stdin.readline()[:-1])\nmod = 10**9+7\n\nif \"R\" in S and \"B\" in S:\n\n    if N % 2 == 1:\n        print (0)\n        sys.exit()\n\n    lis = []\n    now = 0\n    while S[-1] == S[0]: #最後のRを消す\n        del S[-1]\n    for i in S:\n        if i == S[0]:\n            now += 1\n        elif now > 0:\n            lis.append(now)\n            now = 0\n    #print (lis)\n\n    nmax = 0\n    for i in range(len(lis)):\n        if i == 0:\n            if lis[i] % 2 == 0:\n                nmax = lis[i] + 1\n            else:\n                nmax = lis[i]\n        elif lis[i] % 2 == 1:\n            nmax = min(nmax , lis[i])\n\n    NN   = N//2\n    K    = (nmax+1)//2\n    print (NN,K,file=sys.stderr)\n\n    if NN <= K:\n        print ((pow(2,NN,mod)-1) * 2 % mod)\n        sys.exit()\n\n    ST = SegTree(NN,0)\n    for i in range(K):\n        ST.update(i,i+1)\n\n    for i in range(1,NN):\n        now = ST.get(i)\n        plus = ST.query( max(0,i-K),i )\n        ST.update( i , (now+plus) % mod )\n\n    print (ST.get(NN-1) * 2 % mod)\n        \nelse:\n\n    ans = 0\n    #1番目がRの場合\n    dp = [1,0]\n    for i in range(N-1):\n        ndp = [0,0]\n        ndp[0] = (dp[0] + dp[1]) % mod\n        ndp[1] = dp[0]\n        dp = ndp\n\n    ans += sum(dp)\n\n    #1番目がBの場合\n    dp = [0,1]\n    for i in range(N-2):\n        ndp = [0,0]\n        ndp[0] = (dp[0] + dp[1]) % mod\n        ndp[1] = dp[0]\n        dp = ndp\n    ans += sum(dp)\n\n    print (ans % mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 0\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  elif flg == 1:\n    flg = 0\n    ncnt = cnt\n    cnt = 0\n  else:\n    if cnt%2:\n      flg = -1\n    cnt = 0\nif ncnt%2:\n  flg = -1\nif flg == -1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nfor j in range(1,y+1):\n  if n//2-(y+j)-2 >= 0:\n    ans = (ans-(dp[n//2-(y+j)-2][0])*(y+1-j))%mod\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = dp[i-1][0]+dp[i-1][1]\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 0\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  elif flg == 1:\n    flg = 0\n    ncnt = cnt\n    cnt = 0\n  else:\n    if cnt%2:\n      flg = -1\n    cnt = 0\nif ncnt%2:\n  flg = -1\nif flg == -1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  if i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nfor j in range(1,y+1):\n  ans -= (n//2-(y+j)-1)*(y+1-j)\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 0\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  elif flg == 1:\n    flg = 0\n    ncnt = cnt\n    cnt = 0\n  else:\n    if cnt%2:\n      flg = -1\n    cnt = 0\nif flg == -1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nfor j in range(1,y+1):\n  if n//2-(y+j)-2 >= 0:\n    ans = (ans-(dp[n//2-(y+j)-2][0])*(y+1-j))%mod\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 10**18\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  else:\n    if cnt%2:\n      ncnt = min(ncnt,cnt)\n    cnt = 0\nif ncnt == 1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nfor j in range(1,y+1):\n  if n//2-(y+j)-2 >= 0:\n    ans = (ans-(dp[n//2-(y+j)-2][0])*(y+1-j))%mod\n  elif n//2-(y+j) >= 0:\n    ans -= 1\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\ns += \"K\"\nflg = 1\ncnt = 0\nncnt = 10**18\nfor i in range(m+1):\n  if s[i] == x:\n    cnt += 1\n  else:\n    if cnt%2:\n      ncnt = min(ncnt,cnt)\n    cnt = 0\nif ncnt == 1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nfor j in range(1,y+1):\n  if n//2-(y+j)-2 >= 0:\n    ans = (ans-(dp[n//2-(y+j)-2][0])*(y+1-j))%mod\n  elif n//2-(y+j) >= 0:\n    ans -= 1\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 0\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  elif flg == 1:\n    flg = 0\n    ncnt = cnt\n    cnt = 0\n  else:\n    if cnt%2:\n      ncnt = min(ncnt,cnt)\n    cnt = 0\nif ncnt == 1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nfor j in range(1,y+1):\n  if n//2-(y+j)-2 >= 0:\n    ans = (ans-(dp[n//2-(y+j)-2][0])*(y+1-j))%mod\n  elif n//2-(y+j) >= 0:\n    ans -= y+1-j\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 0\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  elif flg == 1:\n    flg = 0\n    ncnt = cnt\n    cnt = 0\n  else:\n    if cnt%2:\n      flg = -1\n    cnt = 0\nif flg == -1:\n  print(2)\n  exit()\nif ncnt%2 == 0:\n  y = ncnt//2\nelse:\n  y = ncnt-1\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nfor j in range(1,y+1):\n  if n//2-(y+j)-2 >= 0:\n    ans = (ans-(dp[n//2-(y+j)-2][0])*(y+1-j))%mod\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc033/tasks/agc033_e\n\nSの1文字目をRとしてよい\n\nRB  から始まる場合　→ 全部交互以外無理(Nが奇数なら0)\nRRB から始まる場合　→ Rは3連で置けば可能…\n\nR*X + B*Y + R*Z …\nとつながっていく\n\nどこからスタートしても、RだけをX回移動したときにBの隣に来なくてはいけない\nRの長さが1なら可能\n\nR*?,B,R*?,…\nでつながっていく\n\n最初のRがX個連続の時\n片方の端との距離がX-2tでなくてはならない\nXが偶数の時、Rの連続長さはX+1以下の奇数\nXが奇数の時、端からスタートした奴は反対側に抜けなくてはいけないので\nRの連続長さはX以下の奇数？\n結局は奇数個連続でしか置けない\n\n\n●整理(Rから始まり、Bがある場合)：\nRは奇数個連続でしか置けない\nBは1個連続でしか置けない\n→つまり、Nが奇数だとアウト\n\n\nBが来た以降を考えてみる\n奇数だと、各点Rの左右のどちらかにしか抜けられない→対称的な移動になるはず\n→つまり、最初のRを消化した後、全てのBの両端にいる場合が存在する\n\nBは奇数個の時のみ意味がある\n→結局、Bの両端にいた場合が交換されるだけ\n→よって、BはRの区切り以上の意味はない\n\nRが偶数個来るた場合、交互に移動すればおk\nRが奇数個来た場合、反対側に抜ける必要がある\n\n結論：\nRBがどちらも存在する場合、Nが偶数なら0、奇数の場合は\nBでsplitしたRの個数の集合を考え,\nr1,r2…,r? とする\nRは奇数個連続で置けて、その個数の最大は M = min( r1+1 , r? ) #r?が奇数の物\n後は、M+1個以下の偶数個単位で区切る場合の数を調べればいい\ndp→あらかじめ1番目の区間の位置に、ずれた分も考慮して値を入れておけばBITでもらうdpできる\n\nRB片方の場合、Bが連続しないような置き方をすればいい\n1番目がRの場合をdp → N番目までやる\n1番目がBの場合をdp → N-1番目までやる(N番目は赤なので)\n\n最後のRは意味がないので消しておく\n\n\nREの原因究明したい\nK < NNの場合？\n\n\n\"\"\"\n\nfrom sys import stdin\nimport sys\n#0-indexed , 半開区間[a,b)\n#calc変更で演算変更\nclass SegTree:\n\n    def __init__(self,N,first):\n        self.NO = 2**(N-1).bit_length()\n        self.First = first\n        self.data = [first] * (2*self.NO)\n\n    def calc(self,l,r):\n        return (l+r) % mod\n\n    def update(self,ind,x):\n        ind += self.NO - 1\n        self.data[ind] = x\n        while ind >= 0:\n            ind = (ind - 1)//2\n            self.data[ind] = self.calc(self.data[2*ind+1],self.data[2*ind+2])\n\n    def query(self,l,r):\n        L = l + self.NO\n        R = r + self.NO\n        s = self.First\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.calc(s , self.data[R-1])\n            if L & 1:\n                s = self.calc(s , self.data[L-1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\n    def get(self , ind):\n        ind += self.NO - 1\n        return self.data[ind]\n\nN,M = map(int,stdin.readline().split())\nS = list(stdin.readline()[:-1])\nmod = 10**9+7\n\nif \"R\" in S and \"B\" in S:\n\n    if N % 2 == 1:\n        print (0)\n        sys.exit()\n\n    lis = []\n    now = 0\n    while S[-1] == S[0]: #最後のRを消す\n        del S[-1]\n    for i in S:\n        if i == S[0]:\n            now += 1\n        elif now > 0:\n            lis.append(now)\n            now = 0\n    #print (lis)\n\n    nmax = 0\n    for i in range(len(lis)):\n        if i == 0:\n            if lis[i] % 2 == 0:\n                nmax = lis[i] + 1\n            else:\n                nmax = lis[i]\n        elif lis[i] % 2 == 1:\n            nmax = max(nmax , lis[i])\n\n    NN   = N//2\n    K    = (nmax+1)//2\n\n    if NN <= K:\n        print (pow(2,NN,mod))\n        sys.exit()\n\n    ST = SegTree(NN,0)\n    for i in range(K):\n        ST.update(i,i+1)\n\n    for i in range(1,NN):\n        now = ST.get(i)\n        plus = ST.query( max(0,i-K),i )\n        ST.update( i , (now+plus) % mod )\n\n    print (ST.get(NN-1) * 2 % mod)\n        \nelse:\n\n    ans = 0\n    #1番目がRの場合\n    dp = [1,0]\n    for i in range(N-1):\n        ndp = [0,0]\n        ndp[0] = (dp[0] + dp[1]) % mod\n        ndp[1] = dp[0]\n        dp = ndp\n\n    ans += sum(dp)\n\n    #1番目がBの場合\n    dp = [0,1]\n    for i in range(N-2):\n        ndp = [0,0]\n        ndp[0] = (dp[0] + dp[1]) % mod\n        ndp[1] = dp[0]\n        dp = ndp\n    ans += sum(dp)\n\n    print (ans % mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 0\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  else:\n    ncnt = min(ncnt,cnt)\n    cnt = 0\nif ncnt == 1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nfor j in range(1,y+1):\n  if n//2-(y+j)-2 >= 0:\n    ans = (ans-(dp[n//2-(y+j)-2][0])*(y+1-j))%mod\n  elif n//2-(y+j) >= 0:\n    ans -= 1\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "p=int(1e9+7)\ndef calc(n,l,r):\n    f=[0]* (n+1)\n    f[0]=1\n    sum=0\n    for i in range (1,n+1):\n        if i>=l:\n            sum+=f[i-l]\n        f[i]=sum%p\n        if (i>=r):\n            sum-=f[i-r]\n    ans=0\n    for i in range (l,r+1):\n        ans=(ans+f[n-i]*i)%p\n    return ans\n\nn,m=input().split()\nn=int(n)\nm=int(m)\ns=input()\na=s.split(chr(ord('R')+ord('B')-ord(s[0])))\nif len(a)==1:\n    print((calc(n,2,n)+1)%p)\nelif n%2==1:\n    print(0)\nelse:\n    r=len(a[0])+1-len(a[0])%2\n    for i in range(1,len(a)-1):\n        if len(a[i])%2==1 :\n            r=min(r,len(a[i]));\n    n=n//2\n    r=(r+1)//2\n    print(calc(n,1,r)*2%p)\n"
  },
  {
    "language": "Python",
    "code": "def solve(n, m, s):\n    f = s[0]\n    MOD = 10 ** 9 + 7\n\n    p = None\n    seq = 0\n    max_seq = 0\n    for c in s + '*':\n        if c == p:\n            seq += 1\n        else:\n            if p == f:\n                max_seq = max(max_seq, seq)\n            seq = 1\n            p = c\n\n    if max_seq == m:\n        a, b = 1, 0\n        for _ in range(n - 2):\n            a, b = (a + b) % MOD, a % MOD\n        return (3 * a + b) % MOD\n\n    if n % 2 == 1:\n        return 0\n\n    ms = max_seq // 2 + 1\n\n    dp = [0] * (n // 2 + 1)\n    ap = [0] * (n // 2 + 1)\n    dp[1] = 1\n    ap[1] = 1\n    for i in range(2, n // 2 + 1):\n        j = max(0, i - ms - 1)\n        dp[i] = (ap[i - 1] - ap[j]) % MOD\n        ap[i] = (ap[i - 1] + dp[i]) % MOD\n\n    ans = dp[-1] * n // 2 % MOD\n    # print(ans)\n    #\n    # for l in range(2, n // 2 + 1, 2):\n    #     d, o = divmod(n, l)\n    #     if o == 0:\n    #         ans = (ans - d * dp[l // 2]) % MOD\n\n    return ans\n\n\nn, m = map(int, input().split())\ns = input()\n\nprint(solve(n, m, s))\n"
  },
  {
    "language": "Python",
    "code": "def solve(n, m, s):\n    f = s[0]\n    MOD = 10 ** 9 + 7\n\n    p = None\n    seq = 0\n    max_seq = 0\n    for c in s + '*':\n        if c == p:\n            seq += 1\n        else:\n            if p == f:\n                max_seq = max(max_seq, seq)\n            seq = 1\n            p = c\n\n    if max_seq == m:\n        a, b = 1, 0\n        for _ in range(n - 2):\n            a, b = (a + b) % MOD, a % MOD\n        return (3 * a + b) % MOD\n\n    if n % 2 == 1:\n        return 0\n\n    ms = max_seq // 2 + 1\n\n    dp = [0] * (n // 2 + 1)\n    ap = [0] * (n // 2 + 1)\n    dp[0] = 0\n    ap[0] = 1\n    for i in range(1, n // 2 + 1):\n        j = max(-1, i - ms - 1)\n        dp[i] = (ap[i - 1] - ap[j]) % MOD\n        ap[i] = (ap[i - 1] + dp[i]) % MOD\n\n    ans = 0\n    for d in range(2, ms * 2 + 1, 2):\n        ans = (ans + dp[(n - d) // 2] * d) % MOD\n\n    return ans\n\n\nn, m = map(int, input().split())\ns = input()\n\nprint(solve(n, m, s))\n"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = dp[i-1][0]+dp[i-1][1]\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 0\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  elif flg == 1:\n    flg = 0\n    ncnt = cnt\n    cnt = 0\n  else:\n    if cnt%2:\n      flg = -1\n    cnt = 0\nif ncnt%2:\n  flg = -1\nif flg == -1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nif n//2 >= ncnt+1:\n  for j in range(1,y+1):\n    ans -= (dp[n//2-(y+j)-2][0])*(y+1-j)\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "def solve(n, m, s):\n    f = s[0]\n    MOD = 10 ** 9 + 7\n\n    p = None\n    seq = 0\n    min_seq = 10 ** 6\n    for c in s + '*':\n        if c == p:\n            seq += 1\n        else:\n            if p == f:\n                min_seq = min(min_seq, seq)\n            seq = 1\n            p = c\n\n    if min_seq == m:\n        a, b = 1, 0\n        for _ in range(n - 2):\n            a, b = (a + b) % MOD, a % MOD\n        return (3 * a + b) % MOD\n\n    if n % 2 == 1:\n        return 0\n\n    ms = min_seq // 2 + 1\n\n    dp = [0] * (n // 2 + 1)\n    ap = [0] * (n // 2 + 1)\n    dp[0] = 0\n    ap[0] = 1\n    for i in range(1, n // 2 + 1):\n        j = max(-1, i - ms - 1)\n        dp[i] = (ap[i - 1] - ap[j]) % MOD\n        ap[i] = (ap[i - 1] + dp[i]) % MOD\n\n    ans = 0\n    for d in range(2, ms * 2 + 1, 2):\n        ans = (ans + dp[(n - d) // 2] * d) % MOD\n\n    return ans\n\n\nn, m = map(int, input().split())\ns = input()\n\nprint(solve(n, m, s))\n"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = dp[i-1][0]+dp[i-1][1]\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 0\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  elif flg == 1:\n    flg = 0\n    ncnt = cnt\n    cnt = 0\n  else:\n    if cnt%2:\n      flg = -1\n    cnt = 0\nif ncnt%2:\n  flg = -1\nif flg == -1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nif n//2 >= ncnt+1:\n  for j in range(1,y+1):\n    ans -= (dp[n//2-(y+j)-2][0])*(y+1-j)\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 0\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  elif flg == 1:\n    flg = 0\n    ncnt = cnt\n    cnt = 0\n  else:\n    if cnt%2:\n      ncnt = min(ncnt,cnt)\n    cnt = 0\nif ncnt == 1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nprint(dp,ans)\nfor j in range(1,y+1):\n  if n//2-(y+j)-2 >= 0:\n    ans = (ans-(dp[n//2-(y+j)-2][0])*(y+1-j))%mod\n  elif n//2-(y+j) == 1:\n    ans -= y+1-j\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc033/tasks/agc033_e\n\nSの1文字目をRとしてよい\n\nRB  から始まる場合　→ 全部交互以外無理(Nが奇数なら0)\nRRB から始まる場合　→ Rは3連で置けば可能…\n\nR*X + B*Y + R*Z …\nとつながっていく\n\nどこからスタートしても、RだけをX回移動したときにBの隣に来なくてはいけない\nRの長さが1なら可能\n\nR*?,B,R*?,…\nでつながっていく\n\n最初のRがX個連続の時\n片方の端との距離がX-2tでなくてはならない\nXが偶数の時、Rの連続長さはX+1以下の奇数\nXが奇数の時、端からスタートした奴は反対側に抜けなくてはいけないので\nRの連続長さはX以下の奇数？\n結局は奇数個連続でしか置けない\n\n\n●整理(Rから始まり、Bがある場合)：\nRは奇数個連続でしか置けない\nBは1個連続でしか置けない\n→つまり、Nが奇数だとアウト\n\n\nBが来た以降を考えてみる\n奇数だと、各点Rの左右のどちらかにしか抜けられない→対称的な移動になるはず\n→つまり、最初のRを消化した後、全てのBの両端にいる場合が存在する\n\nBは奇数個の時のみ意味がある\n→結局、Bの両端にいた場合が交換されるだけ\n→よって、BはRの区切り以上の意味はない\n\nRが偶数個来るた場合、交互に移動すればおk\nRが奇数個来た場合、反対側に抜ける必要がある\n\n結論：\nRBがどちらも存在する場合、Nが偶数なら0、奇数の場合は\nBでsplitしたRの個数の集合を考え,\nr1,r2…,r? とする\nRは奇数個連続で置けて、その個数の最大は M = min( r1+1 , r? ) #r?が奇数の物\n後は、M+1個以下の偶数個単位で区切る場合の数を調べればいい\ndp→あらかじめ1番目の区間の位置に、ずれた分も考慮して値を入れておけばBITでもらうdpできる\n\nRB片方の場合、Bが連続しないような置き方をすればいい\n1番目がRの場合をdp → N番目までやる\n1番目がBの場合をdp → N-1番目までやる(N番目は赤なので)\n\n最後のRは意味がないので消しておく\n\n\"\"\"\n\nfrom sys import stdin\nimport sys\n#0-indexed , 半開区間[a,b)\n#calc変更で演算変更\nclass SegTree:\n\n    def __init__(self,N,first):\n        self.NO = 2**(N-1).bit_length()\n        self.First = first\n        self.data = [first] * (2*self.NO)\n\n    def calc(self,l,r):\n        return (l+r) % mod\n\n    def update(self,ind,x):\n        ind += self.NO - 1\n        self.data[ind] = x\n        while ind >= 0:\n            ind = (ind - 1)//2\n            self.data[ind] = self.calc(self.data[2*ind+1],self.data[2*ind+2])\n\n    def query(self,l,r):\n        L = l + self.NO\n        R = r + self.NO\n        s = self.First\n        while L < R:\n            if R & 1:\n                R -= 1\n                s = self.calc(s , self.data[R-1])\n            if L & 1:\n                s = self.calc(s , self.data[L-1])\n                L += 1\n            L >>= 1\n            R >>= 1\n        return s\n\n    def get(self , ind):\n        ind += self.NO - 1\n        return self.data[ind]\n\nN,M = map(int,stdin.readline().split())\nS = list(stdin.readline()[:-1])\nmod = 10**9+7\n\nif \"R\" in S and \"B\" in S:\n\n    if N % 2 == 1:\n        print (0)\n        sys.exit()\n\n    lis = []\n    now = 0\n    while S[-1] == S[0]: #最後のRを消す\n        del S[-1]\n    for i in S:\n        if i == S[0]:\n            now += 1\n        elif now > 0:\n            lis.append(now)\n            now = 0\n    #print (lis)\n\n    nmax = 0\n    for i in range(len(lis)):\n        if i == 0:\n            if lis[i] % 2 == 0:\n                nmax = lis[i] + 1\n            else:\n                nmax = lis[i]\n        elif lis[i] % 2 == 1:\n            nmax = max(nmax , lis[i])\n\n    NN   = N//2\n    K    = (nmax+1)//2\n\n    ST = SegTree(NN,0)\n    for i in range(K):\n        ST.update(i,i+1)\n\n    for i in range(1,NN):\n        now = ST.get(i)\n        plus = ST.query( max(0,i-K),i )\n        ST.update( i , (now+plus) % mod )\n\n    print (ST.get(NN-1) * 2 % mod)\n        \nelse:\n\n    ans = 0\n    #1番目がRの場合\n    dp = [1,0]\n    for i in range(N-1):\n        ndp = [0,0]\n        ndp[0] = (dp[0] + dp[1]) % mod\n        ndp[1] = dp[0]\n        dp = ndp\n\n    ans += sum(dp)\n\n    #1番目がBの場合\n    dp = [0,1]\n    for i in range(N-2):\n        ndp = [0,0]\n        ndp[0] = (dp[0] + dp[1]) % mod\n        ndp[1] = dp[0]\n        dp = ndp\n    ans += sum(dp)\n\n    print (ans % mod)"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,input().split())\ns = input().rstrip()\nmod = 10**9+7\nif s.count(\"R\") == 0 or s.count(\"B\") == 0:\n  dp = [[0 for i in range(2)] for j in range(n)]\n  dp[0][0] = 1\n  dp[0][1] = 1\n  for i in range(1,n):\n    dp[i][0] = (dp[i-1][0]+dp[i-1][1])%mod\n    dp[i][1] = dp[i-1][0]\n  print((dp[n-1][0]+dp[n-2][1])%mod)\n  exit()\nif n%2:\n  print(0)\n  exit()\nx = s[0]\nflg = 1\ncnt = 0\nncnt = 0\nfor i in range(m):\n  if s[i] == x:\n    cnt += 1\n  elif flg == 1:\n    flg = 0\n    ncnt = cnt\n    cnt = 0\n  else:\n    if cnt%2:\n      ncnt = min(ncnt,cnt)\n    cnt = 0\nif ncnt == 1:\n  print(2)\n  exit()\ny = ncnt//2\ndp = [[0 for i in range(2)] for j in range(n//2)]\ndp[0][0] = 1\ndp[0][1] = 1\nfor i in range(1,n//2):\n  dp[i][0] = dp[i-1][0]+dp[i-1][1]\n  if i<y:\n    dp[i][1] = dp[i-1][0]+dp[i-1][1]\n  elif i == y:\n    dp[i][1] = sum([dp[j][0] for j in range(y)])\n  else:\n    dp[i][1] = dp[i-1][1]+dp[i-1][0]-dp[i-y-1][0]\n  dp[i][0] %= mod\n  dp[i][1] %= mod\nans = dp[-1][0]+dp[-1][1]\nfor j in range(1,y+1):\n  if n//2-(y+j)-2 >= 0:\n    ans = (ans-(dp[n//2-(y+j)-2][0])*(y+1-j))%mod\n  elif n//2-(y+j) == 1:\n    ans -= y+1-j\nprint(2*ans%mod)"
  },
  {
    "language": "Python",
    "code": "def solve(n, m, s):\n    f = s[0]\n    MOD = 10 ** 9 + 7\n\n    p = None\n    seq = 0\n    min_seq = 0\n    for c in s + '*':\n        if c == p:\n            seq += 1\n        else:\n            if p == f:\n                min_seq = min(min_seq, seq)\n            seq = 1\n            p = c\n\n    if min_seq == m:\n        a, b = 1, 0\n        for _ in range(n - 2):\n            a, b = (a + b) % MOD, a % MOD\n        return (3 * a + b) % MOD\n\n    if n % 2 == 1:\n        return 0\n\n    ms = min_seq // 2 + 1\n\n    dp = [0] * (n // 2 + 1)\n    ap = [0] * (n // 2 + 1)\n    dp[0] = 0\n    ap[0] = 1\n    for i in range(1, n // 2 + 1):\n        j = max(-1, i - ms - 1)\n        dp[i] = (ap[i - 1] - ap[j]) % MOD\n        ap[i] = (ap[i - 1] + dp[i]) % MOD\n\n    ans = 0\n    for d in range(2, ms * 2 + 1, 2):\n        ans = (ans + dp[(n - d) // 2] * d) % MOD\n\n    return ans\n\n\nn, m = map(int, input().split())\ns = input()\n\nprint(solve(n, m, s))\n"
  },
  {
    "language": "Python",
    "code": "def solve(n, m, s):\n    f = s[0]\n    MOD = 10 ** 9 + 7\n    INF = 10 ** 6\n\n    p = None\n    seq = 0\n    min_seq = INF\n    for c in s:\n        if c == p:\n            seq += 1\n        else:\n            if p == f and (min_seq == INF or seq % 2 == 1):\n                min_seq = min(min_seq, seq)\n            seq = 1\n            p = c\n\n    if min_seq == INF:\n        a, b = 1, 0\n        for _ in range(n - 2):\n            a, b = (a + b) % MOD, a\n        return (3 * a + b) % MOD\n\n    if n % 2 == 1:\n        return 0\n\n    n2 = n // 2\n    ms = min(n2, min_seq // 2 + 1)\n\n    dp = [0] * (n2 + 1)\n    dp[0] = 1\n    acc, reject = 1, 0\n    for i in range(1, n2 + 1):\n        dp[i] = (acc - reject) % MOD\n        acc = (acc + dp[i]) % MOD\n        if i >= ms:\n            reject = (reject + dp[i - ms]) % MOD\n\n    ans = 0\n    for d in range(1, ms + 1):\n        ans = (ans + dp[n2 - d] * d * 2) % MOD\n\n    return ans\n\n\nn, m = map(int, input().split())\ns = input()\n\nprint(solve(n, m, s))\n"
  }
]