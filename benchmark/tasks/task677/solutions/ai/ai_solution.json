[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_LEN 50\n#define MAX_QUERIES 50\n\nint edit_distance(const char* s1, const char* s2) {\n    int m = strlen(s1), n = strlen(s2);\n    int dp[MAX_LEN + 1][MAX_LEN + 1];\n\n    for (int i = 0; i <= m; i++) dp[i][0] = i;\n    for (int j = 0; j <= n; j++) dp[0][j] = j;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s1[i-1] == s2[j-1])\n                dp[i][j] = dp[i-1][j-1];\n            else\n                dp[i][j] = 1 + fmin(dp[i-1][j], fmin(dp[i][j-1], dp[i-1][j-1]));\n        }\n    }\n    return dp[m][n];\n}\n\nint main() {\n    char password[MAX_LEN + 1] = {0};\n    char current_guess[MAX_LEN + 1] = {0};\n    char chars[] = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    int query_count = 0;\n\n    // Generate initial guess\n    current_guess[0] = chars[0];\n    current_guess[1] = '\\0';\n    int current_len = 1;\n    int last_distance = edit_distance(current_guess, password);\n\n    while (query_count < MAX_QUERIES) {\n        int best_distance = last_distance;\n        char best_char = '\\0';\n        char best_guess[MAX_LEN + 1];\n\n        // Try adding each character at each possible position\n        for (int pos = 0; pos <= current_len; pos++) {\n            for (int c = 0; chars[c]; c++) {\n                // Create a new guess by inserting char\n                strcpy(best_guess, current_guess);\n                memmove(best_guess + pos + 1, best_guess + pos, current_len - pos + 1);\n                best_guess[pos] = chars[c];\n\n                int dist = edit_distance(best_guess, password);\n                query_count++;\n\n                if (dist < best_distance) {\n                    best_distance = dist;\n                    best_char = chars[c];\n                    strcpy(current_guess, best_guess);\n                    last_distance = dist;\n                    current_len++;\n                    break;\n                }\n            }\n            if (best_char) break;\n        }\n\n        // If no improvement found, try replacing characters\n        if (!best_char) {\n            for (int pos = 0; pos < current_len; pos++) {\n                for (int c = 0; chars[c]; c++) {\n                    if (current_guess[pos] == chars[c]) continue;\n\n                    char replace_guess[MAX_LEN + 1];\n                    strcpy(replace_guess, current_guess);\n                    replace_guess[pos] = chars[c];\n\n                    int dist = edit_distance(replace_guess, password);\n                    query_count++;\n\n                    if (dist < last_distance) {\n                        strcpy(current_guess, replace_guess);\n                        last_distance = dist;\n                        best_char = chars[c];\n                        break;\n                    }\n                }\n                if (best_char) break;\n            }\n        }\n\n        // If no improvement found, exit\n        if (!best_char) break;\n\n        // Success condition\n        if (last_distance == 0) {\n            printf(\"%s\\n\", current_guess);\n            return 0;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:32:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LENGTH 100\n\nint edit_distance(const char *s, const char *t) {\n    int m = strlen(s), n = strlen(t);\n    int dp[m + 1][n + 1];\n    for (int i = 0; i <= m; i++) dp[i][0] = i;\n    for (int j = 0; j <= n; j++) dp[0][j] = j;\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s[i - 1] == t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                int min = dp[i - 1][j] < dp[i][j - 1] ? dp[i - 1][j] : dp[i][j - 1];\n                min = min < dp[i - 1][j - 1] ? min : dp[i - 1][j - 1];\n                dp[i][j] = min + 1;\n            }\n        }\n    }\n    return dp[m][n];\n}\n\nchar* guess_password(int L, int Q) {\n    char *s = (char*)malloc((L + 1) * sizeof(char));\n    memset(s, 'a', L);\n    s[L] = '\\0';\n    int dist = 0;\n    for (int i = 0; i < L; i++) {\n        for (char c = 'a'; c <= 'z'; c++) {\n            s[i] = c;\n            printf(\"%s\\n\", s);\n            fflush(stdout);\n            scanf(\"%d\", &dist);\n            if (dist == 0) {\n                return s;\n            }\n        }\n        for (char c = 'A'; c <= 'Z'; c++) {\n            s[i] = c;\n            printf(\"%s\\n\", s);\n            fflush(stdout);\n            scanf(\"%d\", &dist);\n            if (dist == 0) {\n                return s;\n            }\n        }\n        for (char c = '0'; c <= '9'; c++) {\n            s[i] = c;\n            printf(\"%s\\n\", s);\n            fflush(stdout);\n            scanf(\"%d\", &dist);\n            if (dist == 0) {\n                return s;\n            }\n        }\n        s[i] = 'a';\n    }\n    return s;\n}\n\nint main() {\n    int L, Q;\n    scanf(\"%d %d\", &L, &Q);\n    char *password = guess_password(L, Q);\n    printf(\"%s\\n\", password);\n    fflush(stdout);\n    free(password);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:32:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring guess_password(int L, int Q) {\n    string s;\n    int dist;\n    // Start with an empty string and build up\n    for (int i = 0; i < L; ++i) {\n        char best_char = 'a';\n        int min_dist = INT_MAX;\n        // Try all possible characters at position i\n        for (char c = 'a'; c <= 'z'; ++c) {\n            string t = s + c;\n            cout << t << endl;\n            cin >> dist;\n            if (dist == 0) return t;\n            if (dist < min_dist) {\n                min_dist = dist;\n                best_char = c;\n            }\n        }\n        for (char c = 'A'; c <= 'Z'; ++c) {\n            string t = s + c;\n            cout << t << endl;\n            cin >> dist;\n            if (dist == 0) return t;\n            if (dist < min_dist) {\n                min_dist = dist;\n                best_char = c;\n            }\n        }\n        for (char c = '0'; c <= '9'; ++c) {\n            string t = s + c;\n            cout << t << endl;\n            cin >> dist;\n            if (dist == 0) return t;\n            if (dist < min_dist) {\n                min_dist = dist;\n                best_char = c;\n            }\n        }\n        s += best_char;\n    }\n    return s;\n}\n\nint main() {\n    int L, Q;\n    cin >> L >> Q;\n    string password = guess_password(L, Q);\n    cout << password << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:33:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class PasswordGuesser {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int L = scanner.nextInt();\n        int Q = scanner.nextInt();\n        scanner.nextLine();\n\n        StringBuilder password = new StringBuilder();\n        String chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n        \n        for (int i = 0; i < L; i++) {\n            int minDistance = Integer.MAX_VALUE;\n            char bestChar = 'a';\n            \n            for (char c : chars.toCharArray()) {\n                StringBuilder query = new StringBuilder(password).append(c);\n                while (query.length() < L) {\n                    query.append('a');\n                }\n                System.out.println(query.toString());\n                System.out.flush();\n                \n                int distance = scanner.nextInt();\n                if (distance == 0) {\n                    System.out.println(query.toString());\n                    return;\n                }\n                \n                if (distance < minDistance) {\n                    minDistance = distance;\n                    bestChar = c;\n                }\n            }\n            password.append(bestChar);\n        }\n        \n        System.out.println(password.toString());\n    }\n}",
    "timestamp": "2025-08-05 22:33:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PasswordGuesser {\n    static final int L = 10;  // Maximum password length\n    static final int Q = 100; // Maximum number of queries\n    static Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        String password = findPassword();\n        System.out.println(password);\n    }\n\n    static String findPassword() {\n        for (int len = 1; len <= L; len++) {\n            String guess = generatePassword(len);\n            if (guess != null) {\n                return guess;\n            }\n        }\n        return \"\";\n    }\n\n    static String generatePassword(int length) {\n        char[] chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\".toCharArray();\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(\"\");\n\n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n            if (current.length() == length) {\n                int editDistance = query(current);\n                if (editDistance == 0) {\n                    return current;\n                }\n                continue;\n            }\n\n            for (char c : chars) {\n                String next = current + c;\n                queue.offer(next);\n            }\n        }\n        return null;\n    }\n\n    static int query(String candidate) {\n        System.out.println(candidate);\n        return scanner.nextInt();\n    }\n}",
    "timestamp": "2025-08-05 22:33:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint query(string T) {\n    // Simulated query interface\n    // In real implementation, this would interact with the actual judging system\n    cout << \"? \" << T << endl;\n    int distance;\n    cin >> distance;\n    return distance;\n}\n\nint editDistance(const string& s1, const string& s2) {\n    int m = s1.length(), n = s2.length();\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1, 0));\n    \n    for (int i = 0; i <= m; i++) dp[i][0] = i;\n    for (int j = 0; j <= n; j++) dp[0][j] = j;\n    \n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = min({\n                dp[i-1][j] + 1,\n                dp[i][j-1] + 1,\n                dp[i-1][j-1] + (s1[i-1] != s2[j-1])\n            });\n        }\n    }\n    return dp[m][n];\n}\n\nstring solve(int L, int Q) {\n    string charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n    string current = string(1, charset[0]);\n    \n    while (current.length() <= L) {\n        int currentDist = query(current);\n        \n        if (currentDist == 0) return current;\n        \n        vector<pair<int, char>> candidates;\n        for (char c : charset) {\n            string candidate = current;\n            candidate.back() = c;\n            int dist = query(candidate);\n            \n            if (dist < currentDist) {\n                candidates.push_back({dist, c});\n            }\n        }\n        \n        if (candidates.empty()) {\n            if (current.length() < L) {\n                current += charset[0];\n            } else {\n                break;\n            }\n        } else {\n            sort(candidates.begin(), candidates.end());\n            current.back() = candidates[0].second;\n        }\n    }\n    \n    return current;\n}\n\nint main() {\n    int L, Q;\n    cin >> L >> Q;\n    \n    string password = solve(L, Q);\n    cout << \"! \" << password << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:34:06"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef query(password):\n    print(password)\n    sys.stdout.flush()\n    return int(input().strip())\n\ndef solve():\n    import itertools\n    import string\n    \n    chars = string.ascii_letters + string.digits\n    L = 10  # Assume max length based on task description\n\n    for length in range(1, L + 1):\n        for candidate in itertools.product(chars, repeat=length):\n            candidate_str = ''.join(candidate)\n            result = query(candidate_str)\n            if result == 0:\n                return\n\nif __name__ == \"__main__\":\n    solve()",
    "timestamp": "2025-08-13 11:14:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class PasswordGuesser {\n    \n    private static final int MAX_PASSWORD_LENGTH = 10; // assuming a reasonable max length L\n    private static final int MAX_QUERIES = 1000; // assuming a reasonable max queries Q\n    private static final char[] CHARACTERS = (\"abcdefghijklmnopqrstuvwxyz\" + \n                                              \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" + \n                                              \"0123456789\").toCharArray();\n    private static int L;\n    private static int Q;\n    private static String S;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        // Assume we have some way of obtaining L and Q from the environment\n        L = scanner.nextInt();\n        Q = scanner.nextInt();\n\n        // Initializing variables\n        int currentLength = 1;\n\n        // Find length of the secret password S\n        while (currentLength <= L) {\n            String testPassword = generatePassword(currentLength, CHARACTERS[0]);\n            int distance = askPassword(testPassword);\n            if (distance == -1) { \n                System.exit(1);\n            }\n            if (distance == currentLength) break; // If full length is not matched\n            currentLength++;\n        }\n\n        // Array to store the guessed password characters\n        char[] guessedPassword = new char[currentLength];\n\n        // Guess each character of the secret password S\n        for (int i = 0; i < currentLength; i++) {\n            for (char ch : CHARACTERS) {\n                guessedPassword[i] = ch;\n                String testPassword = new String(guessedPassword);\n                int distance = askPassword(testPassword);\n                if (distance == (currentLength - i - 1)) {\n                    break; // We've found the correct character at position i\n                }\n            }\n        }\n\n        // Print the discovered password and terminate the program\n        System.out.println(new String(guessedPassword));\n        \n        scanner.close();\n    }\n    \n    private static String generatePassword(int length, char ch) {\n        char[] password = new char[length];\n        for (int i = 0; i < length; i++) {\n            password[i] = ch;\n        }\n        return new String(password);\n    }\n\n    // Simulating the interaction by querying for edit distance\n    private static int askPassword(String testPassword) {\n        System.out.println(\"? \" + testPassword);\n        Scanner scanner = new Scanner(System.in);\n        int response = scanner.nextInt();\n        return response;\n    }\n}",
    "timestamp": "2025-08-13 11:14:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n// Function to calculate edit distance\nint editDistance(const char *str1, const char *str2) {\n    int len1 = strlen(str1);\n    int len2 = strlen(str2);\n    int dp[len1 + 1][len2 + 1];\n\n    for (int i = 0; i <= len1; i++) {\n        for (int j = 0; j <= len2; j++) {\n            if (i == 0) {\n                dp[i][j] = j;\n            } else if (j == 0) {\n                dp[i][j] = i;\n            } else if (str1[i - 1] == str2[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                dp[i][j] = 1 + fmin(dp[i - 1][j - 1], fmin(dp[i - 1][j], dp[i][j - 1]));\n            }\n        }\n    }\n\n    return dp[len1][len2];\n}\n\n// Simulated result of guessing mechanism (to be replaced with actual interactive querying)\nint query(const char *T, const char *S) {\n    return editDistance(T, S);\n}\n\n// Function to guess the password (implementation depends on problem constraints)\nvoid guessPassword(int L, int Q) {\n    // Start with guessing some initial valid passwords\n    char guessedPassword[L + 1];\n    strcpy(guessedPassword, \"a\"); // Starting point\n\n    // Iteratively modify guessedPassword and query\n    for (int attempt = 0; attempt < Q; attempt++) {\n        int response = query(guessedPassword, \"Secret123\"); // Simulated call\n        if (response == 0) {\n            printf(\"%s\\n\", guessedPassword);\n            return;\n        }\n\n        // Modify guessedPassword logic (simplified for illustration)\n        int len = strlen(guessedPassword);\n        if (len < L) {\n            guessedPassword[len] = 'a';\n            guessedPassword[len + 1] = '\\0';\n        } else {\n            for (int i = 0; i < len; i++) {\n                guessedPassword[i]++;\n                if (guessedPassword[i] <= 'z') break;\n                if (guessedPassword[i] > 'z') guessedPassword[i] = 'A';\n                if (guessedPassword[i] > 'Z') guessedPassword[i] = '0';\n            }\n        }\n    }\n}\n\nint main() {\n    int L = 10; // Maximum password length\n    int Q = 1000; // Maximum number of queries\n\n    guessPassword(L, Q);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:14:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "async function guessPassword() {\n    const L = 10;  // Assume a reasonable maximum length for the password\n    const Q = 100; // Assume a reasonable maximum number of queries\n    const characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    \n    async function queryPassword(T) {\n        // Replace this function with the actual querying logic in the environment\n        // This should return a promise that resolves to the edit distance\n    }\n\n    function getEditDistance(s1, s2) {\n        let len1 = s1.length;\n        let len2 = s2.length;\n        let dp = Array.from({length: len1 + 1}, () => Array(len2 + 1).fill(0));\n\n        for (let i = 0; i <= len1; i++) dp[i][0] = i;\n        for (let j = 0; j <= len2; j++) dp[0][j] = j;\n\n        for (let i = 1; i <= len1; i++) {\n            for (let j = 1; j <= len2; j++) {\n                if (s1[i - 1] === s2[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i][j - 1], dp[i - 1][j]) + 1;\n                }\n            }\n        }\n\n        return dp[len1][len2];\n    }\n\n    let foundPassword = '';\n    let possiblePasswords = [''];\n\n    for (let i = 0; i < Q; ++i) {\n        let nextPassword = possiblePasswords.shift();\n\n        if (!nextPassword || nextPassword.length > L) break;\n\n        let knownDistance = await queryPassword(nextPassword);\n\n        if (knownDistance === 0) {\n            foundPassword = nextPassword;\n            break;\n        }\n\n        characters.split('').forEach(char => {\n            let newPassword = nextPassword + char;\n            if (getEditDistance(newPassword, foundPassword) === knownDistance - 1) {\n                possiblePasswords.push(newPassword);\n            }\n        });\n    }\n\n    console.log(foundPassword);\n}\n\nguessPassword();",
    "timestamp": "2025-08-13 11:14:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(get_edit_distance):\n    def generate_candidates(current, alphabet):\n        candidates = []\n        # Insert\n        for a in alphabet:\n            candidates.append(current + a)\n        # Replace\n        for i in range(len(current)):\n            for a in alphabet:\n                candidate = current[:i] + a + current[i+1:]\n                candidates.append(candidate)\n        # Delete\n        if len(current) > 1:\n            for i in range(len(current)):\n                candidate = current[:i] + current[i+1:]\n                candidates.append(candidate)\n        return candidates\n\n    alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUV0123456789'\n    max_length = 10\n    max_queries = 100\n\n    # Start with empty string\n    current = ''\n    query_count = 0\n\n    while query_count < max_queries:\n        best_dist = float('inf')\n        best_candidate = None\n\n        candidates = generate_candidates(current, alphabet)\n        \n        for candidate in candidates:\n            if len(candidate) > max_length:\n                continue\n            \n            dist = get_edit_distance(candidate)\n            query_count += 1\n\n            if dist == 0:\n                print(candidate)\n                return\n\n            if dist < best_dist:\n                best_dist = dist\n                best_candidate = candidate\n\n        if best_candidate is None:\n            break\n\n        current = best_candidate\n\n    # Fallback strategy if not found\n    for length in range(1, max_length + 1):\n        for candidate in [''.join(p) for p in __import__('itertools').product(alphabet, repeat=length)]:\n            if get_edit_distance(candidate) == 0:\n                print(candidate)\n                return",
    "timestamp": "2025-08-13 11:15:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(L, Q) {\n    const charset = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    \n    function editDistance(s1, s2) {\n        const m = s1.length, n = s2.length;\n        const dp = Array.from({length: m+1}, () => new Array(n+1).fill(0));\n        \n        for (let i = 0; i <= m; i++) dp[i][0] = i;\n        for (let j = 0; j <= n; j++) dp[0][j] = j;\n        \n        for (let i = 1; i <= m; i++) {\n            for (let j = 1; j <= n; j++) {\n                if (s1[i-1] === s2[j-1]) {\n                    dp[i][j] = dp[i-1][j-1];\n                } else {\n                    dp[i][j] = 1 + Math.min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]);\n                }\n            }\n        }\n        \n        return dp[m][n];\n    }\n    \n    function query(password) {\n        // Simulated query - replace with actual query mechanism\n        return editDistance(password, secretPassword);\n    }\n    \n    let current = '';\n    \n    // Try constructing password character by character\n    while (current.length < L) {\n        let bestDist = Infinity;\n        let bestChar = null;\n        \n        for (let c of charset) {\n            let candidate = current + c;\n            let dist = query(candidate);\n            \n            if (dist < bestDist) {\n                bestDist = dist;\n                bestChar = c;\n            }\n        }\n        \n        current += bestChar;\n    }\n    \n    // Verify and optimize final password\n    for (let i = 0; i < current.length; i++) {\n        let bestDist = query(current);\n        let bestChar = current[i];\n        \n        for (let c of charset) {\n            let candidate = current.slice(0, i) + c + current.slice(i+1);\n            let dist = query(candidate);\n            \n            if (dist < bestDist) {\n                bestDist = dist;\n                bestChar = c;\n            }\n        }\n        \n        current = current.slice(0, i) + bestChar + current.slice(i+1);\n    }\n    \n    return current;\n}\n\n// Example usage\nconst secretPassword = 'abc123'; // This would be hidden in actual implementation\nconst result = solve(6, 100);\nconsole.log(result);",
    "timestamp": "2025-08-13 11:15:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef main():\n    L, Q = map(int, sys.stdin.readline().split())\n    \n    # Start with an empty string\n    current_guess = []\n    \n    # First, determine the length by trying different lengths\n    length = 0\n    for l in range(1, L + 1):\n        query = 'a' * l\n        print(query, flush=True)\n        response = int(sys.stdin.readline())\n        if response == 0:\n            print(query, flush=True)\n            return\n        if response == L - l:\n            length = l\n            break\n    \n    # Now, find each character one by one\n    for i in range(length):\n        for c in 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789':\n            current_guess.append(c)\n            query = ''.join(current_guess) + 'a' * (length - i - 1)\n            print(query, flush=True)\n            response = int(sys.stdin.readline())\n            if response == 0:\n                print(query, flush=True)\n                return\n            if response == length - i - 1:\n                break\n            current_guess.pop()\n    \n    print(''.join(current_guess), flush=True)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 11:18:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const readline = require('readline');\n\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet L, Q;\nlet password = '';\n\nconst askQuery = (query, callback) => {\n    console.log(query);\n    rl.once('line', (line) => {\n        callback(parseInt(line));\n    });\n};\n\nconst findPassword = () => {\n    const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    let current = '';\n    \n    const findNextChar = (index, callback) => {\n        if (index >= L) {\n            callback();\n            return;\n        }\n        \n        let minDist = Infinity;\n        let bestChar = '';\n        \n        const testChar = (i) => {\n            if (i >= chars.length) {\n                current += bestChar;\n                findNextChar(index + 1, callback);\n                return;\n            }\n            \n            const testStr = current + chars[i] + 'a'.repeat(L - current.length - 1);\n            askQuery(testStr, (dist) => {\n                if (dist < minDist) {\n                    minDist = dist;\n                    bestChar = chars[i];\n                }\n                testChar(i + 1);\n            });\n        };\n        \n        testChar(0);\n    };\n    \n    findNextChar(0, () => {\n        console.log(current);\n        rl.close();\n    });\n};\n\nrl.once('line', (line) => {\n    [L, Q] = line.split(' ').map(Number);\n    findPassword();\n});",
    "timestamp": "2025-08-13 11:18:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint query(const string& T) {\n    cout << T << endl;\n    int distance;\n    cin >> distance;\n    if (distance == 0) {\n        exit(0);\n    }\n    return distance;\n}\n\nint main() {\n    int Q = 100; // Sample maximum queries, change according to the problem\n    int L = 10; // Sample maximum password length, change according to the problem\n\n    string charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\n    for (int len = 1; len <= L; ++len) {\n        string current(len, charset[0]);\n\n        while (true) {\n            int dist = query(current);\n            if (dist == 0) return 0;\n\n            for (int i = 0; i < len; ++i) {\n                for (char c : charset) {\n                    if (current[i] == c) continue;\n                    string test = current;\n                    test[i] = c;\n                    int new_dist = query(test);\n                    if (new_dist < dist) {\n                        current = test;\n                        dist = new_dist;\n                        break;\n                    }\n                }\n            }\n\n            if (dist == 0) {\n                query(current);\n                return 0;\n            }\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:03:05"
  }
]