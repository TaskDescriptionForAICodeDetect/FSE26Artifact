[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\ntypedef struct Node {\n    int key;\n    int priority;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* rotateRight(Node* y) {\n    Node* x = y->left;\n    Node* T2 = x->right;\n    x->right = y;\n    y->left = T2;\n    return x;\n}\n\nNode* rotateLeft(Node* x) {\n    Node* y = x->right;\n    Node* T2 = y->left;\n    y->left = x;\n    x->right = T2;\n    return y;\n}\n\nNode* newNode(int key) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->key = key;\n    node->priority = rand() % 100;\n    node->left = node->right = NULL;\n    return node;\n}\n\nNode* insert(Node* root, int key) {\n    if (!root) return newNode(key);\n\n    if (key <= root->key) {\n        root->left = insert(root->left, key);\n        if (root->left->priority > root->priority)\n            root = rotateRight(root);\n    } else {\n        root->right = insert(root->right, key);\n        if (root->right->priority > root->priority)\n            root = rotateLeft(root);\n    }\n    return root;\n}\n\nNode* deleteNode(Node* root, int key) {\n    if (!root) return root;\n\n    if (key < root->key)\n        root->left = deleteNode(root->left, key);\n    else if (key > root->key)\n        root->right = deleteNode(root->right, key);\n    else {\n        if (!root->left) {\n            Node* temp = root->right;\n            free(root);\n            return temp;\n        }\n        else if (!root->right) {\n            Node* temp = root->left;\n            free(root);\n            return temp;\n        }\n\n        if (root->left->priority < root->right->priority) {\n            root = rotateLeft(root);\n            root->left = deleteNode(root->left, key);\n        } else {\n            root = rotateRight(root);\n            root->right = deleteNode(root->right, key);\n        }\n    }\n    return root;\n}\n\nint search(Node* root, int key) {\n    if (!root) return 0;\n    if (root->key == key) return 1;\n    if (key < root->key)\n        return search(root->left, key);\n    return search(root->right, key);\n}\n\nvoid inorderTraversal(Node* root) {\n    if (!root) return;\n    inorderTraversal(root->left);\n    printf(\"%d \", root->key);\n    inorderTraversal(root->right);\n}\n\nvoid preorderTraversal(Node* root) {\n    if (!root) return;\n    printf(\"%d \", root->key);\n    preorderTraversal(root->left);\n    preorderTraversal(root->right);\n}\n\nint main() {\n    srand(time(NULL));\n    Node* root = NULL;\n\n    root = insert(root, 50);\n    root = insert(root, 30);\n    root = insert(root, 70);\n    root = insert(root, 20);\n    root = insert(root, 40);\n\n    printf(\"Inorder traversal: \");\n    inorderTraversal(root);\n    printf(\"\\n\");\n\n    printf(\"Preorder traversal: \");\n    preorderTraversal(root);\n    printf(\"\\n\");\n\n    printf(\"Search 30: %s\\n\", search(root, 30) ? \"Found\" : \"Not Found\");\n\n    root = deleteNode(root, 30);\n\n    printf(\"After deletion Inorder traversal: \");\n    inorderTraversal(root);\n    printf(\"\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:13:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct Node {\n    int key;\n    int priority;\n    struct Node *left;\n    struct Node *right;\n} Node;\n\nNode *createNode(int key, int priority) {\n    Node *newNode = (Node *)malloc(sizeof(Node));\n    newNode->key = key;\n    newNode->priority = priority;\n    newNode->left = newNode->right = NULL;\n    return newNode;\n}\n\nNode *rightRotate(Node *y) {\n    Node *x = y->left;\n    Node *T2 = x->right;\n\n    x->right = y;\n    y->left = T2;\n\n    return x;\n}\n\nNode *leftRotate(Node *x) {\n    Node *y = x->right;\n    Node *T2 = y->left;\n\n    y->left = x;\n    x->right = T2;\n\n    return y;\n}\n\nNode *insert(Node *root, int key, int priority) {\n    if (!root)\n        return createNode(key, priority);\n\n    if (key <= root->key) {\n        root->left = insert(root->left, key, priority);\n        if (root->left->priority > root->priority)\n            root = rightRotate(root);\n    } else {\n        root->right = insert(root->right, key, priority);\n        if (root->right->priority > root->priority)\n            root = leftRotate(root);\n    }\n    return root;\n}\n\nbool search(Node *root, int key) {\n    if (!root)\n        return false;\n    if (root->key == key)\n        return true;\n    if (key < root->key)\n        return search(root->left, key);\n    else\n        return search(root->right, key);\n}\n\nNode *delete(Node *root, int key) {\n    if (!root)\n        return root;\n\n    if (key < root->key)\n        root->left = delete(root->left, key);\n    else if (key > root->key)\n        root->right = delete(root->right, key);\n    else {\n        if (!root->left) {\n            Node *temp = root->right;\n            free(root);\n            root = temp;\n        } else if (!root->right) {\n            Node *temp = root->left;\n            free(root);\n            root = temp;\n        } else if (root->left->priority > root->right->priority) {\n            root = rightRotate(root);\n            root->right = delete(root->right, key);\n        } else {\n            root = leftRotate(root);\n            root->left = delete(root->left, key);\n        }\n    }\n    return root;\n}\n\nvoid inorder(Node *root) {\n    if (root) {\n        inorder(root->left);\n        printf(\"%d \", root->key);\n        inorder(root->right);\n    }\n}\n\nvoid preorder(Node *root) {\n    if (root) {\n        printf(\"%d \", root->key);\n        preorder(root->left);\n        preorder(root->right);\n    }\n}\n\nvoid freeTreap(Node *root) {\n    if (root) {\n        freeTreap(root->left);\n        freeTreap(root->right);\n        free(root);\n    }\n}\n\nint main() {\n    Node *root = NULL;\n    char command[10];\n    int key, priority;\n\n    while (scanf(\"%s\", command) != EOF) {\n        if (command[0] == 'i') {\n            scanf(\"%d %d\", &key, &priority);\n            root = insert(root, key, priority);\n        } else if (command[0] == 'd') {\n            scanf(\"%d\", &key);\n            root = delete(root, key);\n        } else if (command[0] == 's') {\n            scanf(\"%d\", &key);\n            printf(search(root, key) ? \"1\\n\" : \"0\\n\");\n        } else if (command[1] == 'n') {\n            inorder(root);\n            printf(\"\\n\");\n        } else if (command[1] == 'r') {\n            preorder(root);\n            printf(\"\\n\");\n        }\n    }\n\n    freeTreap(root);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:14:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n\nstruct Node {\n    int key;\n    int priority;\n    Node *left, *right;\n    Node(int k) : key(k), priority(rand()), left(nullptr), right(nullptr) {}\n};\n\nclass Treap {\nprivate:\n    Node* root;\n\n    Node* rotateRight(Node* y) {\n        Node* x = y->left;\n        y->left = x->right;\n        x->right = y;\n        return x;\n    }\n\n    Node* rotateLeft(Node* x) {\n        Node* y = x->right;\n        x->right = y->left;\n        y->left = x;\n        return y;\n    }\n\n    Node* insert(Node* root, int key) {\n        if (!root) return new Node(key);\n        if (key < root->key) {\n            root->left = insert(root->left, key);\n            if (root->left->priority > root->priority)\n                root = rotateRight(root);\n        } else {\n            root->right = insert(root->right, key);\n            if (root->right->priority > root->priority)\n                root = rotateLeft(root);\n        }\n        return root;\n    }\n\n    Node* deleteNode(Node* root, int key) {\n        if (!root) return root;\n        if (key < root->key)\n            root->left = deleteNode(root->left, key);\n        else if (key > root->key)\n            root->right = deleteNode(root->right, key);\n        else {\n            if (!root->left) {\n                Node* temp = root->right;\n                delete root;\n                root = temp;\n            } else if (!root->right) {\n                Node* temp = root->left;\n                delete root;\n                root = temp;\n            } else {\n                if (root->left->priority > root->right->priority) {\n                    root = rotateRight(root);\n                    root->right = deleteNode(root->right, key);\n                } else {\n                    root = rotateLeft(root);\n                    root->left = deleteNode(root->left, key);\n                }\n            }\n        }\n        return root;\n    }\n\n    bool search(Node* root, int key) {\n        if (!root) return false;\n        if (root->key == key) return true;\n        if (key < root->key)\n            return search(root->left, key);\n        else\n            return search(root->right, key);\n    }\n\n    void inorder(Node* root) {\n        if (root) {\n            inorder(root->left);\n            cout << root->key << \" \";\n            inorder(root->right);\n        }\n    }\n\n    void preorder(Node* root) {\n        if (root) {\n            cout << root->key << \" \";\n            preorder(root->left);\n            preorder(root->right);\n        }\n    }\n\npublic:\n    Treap() : root(nullptr) { srand(time(0)); }\n\n    void insert(int key) {\n        root = insert(root, key);\n    }\n\n    void deleteNode(int key) {\n        root = deleteNode(root, key);\n    }\n\n    bool search(int key) {\n        return search(root, key);\n    }\n\n    void printInorder() {\n        inorder(root);\n        cout << endl;\n    }\n\n    void printPreorder() {\n        preorder(root);\n        cout << endl;\n    }\n};\n\nint main() {\n    Treap treap;\n    string cmd;\n    int key;\n    while (cin >> cmd) {\n        if (cmd == \"insert\") {\n            cin >> key;\n            treap.insert(key);\n        } else if (cmd == \"delete\") {\n            cin >> key;\n            treap.deleteNode(key);\n        } else if (cmd == \"search\") {\n            cin >> key;\n            cout << (treap.search(key) ? \"true\" : \"false\") << endl;\n        } else if (cmd == \"inorder\") {\n            treap.printInorder();\n        } else if (cmd == \"preorder\") {\n            treap.printPreorder();\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:14:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Random;\n\nclass TreapNode {\n    int key;\n    int priority;\n    TreapNode left, right;\n\n    TreapNode(int key) {\n        this.key = key;\n        this.priority = new Random().nextInt();\n        this.left = this.right = null;\n    }\n}\n\npublic class Treap {\n    private TreapNode root;\n    private Random random = new Random();\n\n    public Treap() {\n        root = null;\n    }\n\n    private TreapNode rotateRight(TreapNode y) {\n        TreapNode x = y.left;\n        TreapNode T2 = x.right;\n\n        x.right = y;\n        y.left = T2;\n\n        return x;\n    }\n\n    private TreapNode rotateLeft(TreapNode x) {\n        TreapNode y = x.right;\n        TreapNode T2 = y.left;\n\n        y.left = x;\n        x.right = T2;\n\n        return y;\n    }\n\n    public void insert(int key) {\n        root = insert(root, key);\n    }\n\n    private TreapNode insert(TreapNode node, int key) {\n        if (node == null) {\n            return new TreapNode(key);\n        }\n\n        if (key <= node.key) {\n            node.left = insert(node.left, key);\n\n            if (node.left.priority > node.priority) {\n                node = rotateRight(node);\n            }\n        } else {\n            node.right = insert(node.right, key);\n\n            if (node.right.priority > node.priority) {\n                node = rotateLeft(node);\n            }\n        }\n        return node;\n    }\n\n    public void delete(int key) {\n        root = delete(root, key);\n    }\n\n    private TreapNode delete(TreapNode node, int key) {\n        if (node == null) {\n            return null;\n        }\n\n        if (key < node.key) {\n            node.left = delete(node.left, key);\n        } else if (key > node.key) {\n            node.right = delete(node.right, key);\n        } else {\n            if (node.left == null) {\n                return node.right;\n            } else if (node.right == null) {\n                return node.left;\n            } else {\n                if (node.left.priority > node.right.priority) {\n                    node = rotateRight(node);\n                    node.right = delete(node.right, key);\n                } else {\n                    node = rotateLeft(node);\n                    node.left = delete(node.left, key);\n                }\n            }\n        }\n        return node;\n    }\n\n    public boolean search(int key) {\n        return search(root, key);\n    }\n\n    private boolean search(TreapNode node, int key) {\n        if (node == null) {\n            return false;\n        }\n        if (node.key == key) {\n            return true;\n        }\n        if (key < node.key) {\n            return search(node.left, key);\n        } else {\n            return search(node.right, key);\n        }\n    }\n\n    public void printInorder() {\n        printInorder(root);\n        System.out.println();\n    }\n\n    private void printInorder(TreapNode node) {\n        if (node != null) {\n            printInorder(node.left);\n            System.out.print(node.key + \" \");\n            printInorder(node.right);\n        }\n    }\n\n    public void printPreorder() {\n        printPreorder(root);\n        System.out.println();\n    }\n\n    private void printPreorder(TreapNode node) {\n        if (node != null) {\n            System.out.print(node.key + \" \");\n            printPreorder(node.left);\n            printPreorder(node.right);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:15:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Random;\n\nclass TreapNode {\n    int key;\n    int priority;\n    TreapNode left;\n    TreapNode right;\n\n    public TreapNode(int key) {\n        this.key = key;\n        this.priority = new Random().nextInt(100);\n        this.left = null;\n        this.right = null;\n    }\n}\n\npublic class Treap {\n    private TreapNode root;\n    private Random random;\n\n    public Treap() {\n        root = null;\n        random = new Random();\n    }\n\n    private TreapNode rotateRight(TreapNode y) {\n        TreapNode x = y.left;\n        TreapNode T2 = x.right;\n\n        x.right = y;\n        y.left = T2;\n\n        return x;\n    }\n\n    private TreapNode rotateLeft(TreapNode x) {\n        TreapNode y = x.right;\n        TreapNode T2 = y.left;\n\n        y.left = x;\n        x.right = T2;\n\n        return y;\n    }\n\n    public void insert(int key) {\n        root = insertNode(root, key);\n    }\n\n    private TreapNode insertNode(TreapNode node, int key) {\n        if (node == null) {\n            return new TreapNode(key);\n        }\n\n        if (key < node.key) {\n            node.left = insertNode(node.left, key);\n\n            if (node.left.priority > node.priority) {\n                node = rotateRight(node);\n            }\n        } else {\n            node.right = insertNode(node.right, key);\n\n            if (node.right.priority > node.priority) {\n                node = rotateLeft(node);\n            }\n        }\n\n        return node;\n    }\n\n    public boolean search(int key) {\n        return searchNode(root, key);\n    }\n\n    private boolean searchNode(TreapNode node, int key) {\n        if (node == null) {\n            return false;\n        }\n\n        if (node.key == key) {\n            return true;\n        }\n\n        if (key < node.key) {\n            return searchNode(node.left, key);\n        } else {\n            return searchNode(node.right, key);\n        }\n    }\n\n    public void delete(int key) {\n        root = deleteNode(root, key);\n    }\n\n    private TreapNode deleteNode(TreapNode node, int key) {\n        if (node == null) {\n            return null;\n        }\n\n        if (key < node.key) {\n            node.left = deleteNode(node.left, key);\n        } else if (key > node.key) {\n            node.right = deleteNode(node.right, key);\n        } else {\n            if (node.left == null && node.right == null) {\n                return null;\n            }\n\n            if (node.left == null) {\n                node = rotateLeft(node);\n            } else if (node.right == null) {\n                node = rotateRight(node);\n            } else {\n                if (node.left.priority < node.right.priority) {\n                    node = rotateLeft(node);\n                    node.left = deleteNode(node.left, key);\n                } else {\n                    node = rotateRight(node);\n                    node.right = deleteNode(node.right, key);\n                }\n            }\n        }\n\n        return node;\n    }\n\n    public void inorderTraversal() {\n        inorderTraversal(root);\n        System.out.println();\n    }\n\n    private void inorderTraversal(TreapNode node) {\n        if (node != null) {\n            inorderTraversal(node.left);\n            System.out.print(node.key + \" \");\n            inorderTraversal(node.right);\n        }\n    }\n\n    public void preorderTraversal() {\n        preorderTraversal(root);\n        System.out.println();\n    }\n\n    private void preorderTraversal(TreapNode node) {\n        if (node != null) {\n            System.out.print(node.key + \" \");\n            preorderTraversal(node.left);\n            preorderTraversal(node.right);\n        }\n    }\n\n    public static void main(String[] args) {\n        Treap treap = new Treap();\n        treap.insert(5);\n        treap.insert(3);\n        treap.insert(7);\n        treap.insert(1);\n        treap.insert(9);\n\n        System.out.println(\"Inorder Traversal:\");\n        treap.inorderTraversal();\n\n        System.out.println(\"Preorder Traversal:\");\n        treap.preorderTraversal();\n\n        System.out.println(\"Search 7: \" + treap.search(7));\n        System.out.println(\"Search 6: \" + treap.search(6));\n\n        treap.delete(5);\n        System.out.println(\"After deleting 5:\");\n        treap.inorderTraversal();\n    }\n}",
    "timestamp": "2025-08-05 22:15:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <random>\n#include <cstdlib>\n\nusing namespace std;\n\nclass TreapNode {\npublic:\n    int key;\n    int priority;\n    TreapNode* left;\n    TreapNode* right;\n\n    TreapNode(int k) {\n        key = k;\n        priority = rand();\n        left = right = nullptr;\n    }\n};\n\nclass Treap {\nprivate:\n    TreapNode* root;\n\n    TreapNode* rotateRight(TreapNode* y) {\n        TreapNode* x = y->left;\n        y->left = x->right;\n        x->right = y;\n        return x;\n    }\n\n    TreapNode* rotateLeft(TreapNode* x) {\n        TreapNode* y = x->right;\n        x->right = y->left;\n        y->left = x;\n        return y;\n    }\n\n    TreapNode* insertNode(TreapNode* node, int key) {\n        if (!node) return new TreapNode(key);\n\n        if (key < node->key) {\n            node->left = insertNode(node->left, key);\n            if (node->left->priority > node->priority)\n                node = rotateRight(node);\n        } else {\n            node->right = insertNode(node->right, key);\n            if (node->right->priority > node->priority)\n                node = rotateLeft(node);\n        }\n        return node;\n    }\n\n    TreapNode* deleteNode(TreapNode* node, int key) {\n        if (!node) return nullptr;\n\n        if (key < node->key)\n            node->left = deleteNode(node->left, key);\n        else if (key > node->key)\n            node->right = deleteNode(node->right, key);\n        else {\n            if (!node->left) {\n                TreapNode* temp = node->right;\n                delete node;\n                return temp;\n            }\n            else if (!node->right) {\n                TreapNode* temp = node->left;\n                delete node;\n                return temp;\n            }\n\n            if (node->left->priority < node->right->priority) {\n                node = rotateLeft(node);\n                node->left = deleteNode(node->left, key);\n            } else {\n                node = rotateRight(node);\n                node->right = deleteNode(node->right, key);\n            }\n        }\n        return node;\n    }\n\n    bool searchNode(TreapNode* node, int key) {\n        if (!node) return false;\n        if (node->key == key) return true;\n        if (key < node->key) return searchNode(node->left, key);\n        return searchNode(node->right, key);\n    }\n\n    void inorderTraversal(TreapNode* node) {\n        if (!node) return;\n        inorderTraversal(node->left);\n        cout << node->key << \" \";\n        inorderTraversal(node->right);\n    }\n\n    void preorderTraversal(TreapNode* node) {\n        if (!node) return;\n        cout << node->key << \" \";\n        preorderTraversal(node->left);\n        preorderTraversal(node->right);\n    }\n\npublic:\n    Treap() {\n        srand(time(nullptr));\n        root = nullptr;\n    }\n\n    void insert(int key) {\n        root = insertNode(root, key);\n    }\n\n    void remove(int key) {\n        root = deleteNode(root, key);\n    }\n\n    bool search(int key) {\n        return searchNode(root, key);\n    }\n\n    void printInorder() {\n        inorderTraversal(root);\n        cout << endl;\n    }\n\n    void printPreorder() {\n        preorderTraversal(root);\n        cout << endl;\n    }\n};\n\nint main() {\n    Treap treap;\n    \n    treap.insert(5);\n    treap.insert(3);\n    treap.insert(7);\n    treap.insert(1);\n    treap.insert(9);\n\n    cout << \"Inorder: \";\n    treap.printInorder();\n\n    cout << \"Preorder: \";\n    treap.printPreorder();\n\n    cout << \"Search 7: \" << (treap.search(7) ? \"Found\" : \"Not Found\") << endl;\n    \n    treap.remove(7);\n\n    cout << \"After removing 7\" << endl;\n    cout << \"Inorder: \";\n    treap.printInorder();\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:15:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import random\n\nclass TreapNode:\n    def __init__(self, key, priority):\n        self.key = key\n        self.priority = priority\n        self.left = None\n        self.right = None\n\nclass Treap:\n    def __init__(self):\n        self.root = None\n\n    def _rotate_right(self, root):\n        new_root = root.left\n        root.left = new_root.right\n        new_root.right = root\n        return new_root\n\n    def _rotate_left(self, root):\n        new_root = root.right\n        root.right = new_root.left\n        new_root.left = root\n        return new_root\n\n    def _insert(self, root, key, priority):\n        if root is None:\n            return TreapNode(key, priority)\n\n        if key < root.key:\n            root.left = self._insert(root.left, key, priority)\n            if root.left.priority > root.priority:\n                root = self._rotate_right(root)\n        else:\n            root.right = self._insert(root.right, key, priority)\n            if root.right.priority > root.priority:\n                root = self._rotate_left(root)\n\n        return root\n\n    def insert(self, key, priority=None):\n        if priority is None:\n            priority = random.randint(1, 100)\n        self.root = self._insert(self.root, key, priority)\n\n    def _find(self, root, key):\n        if root is None:\n            return False\n        if key == root.key:\n            return True\n        if key < root.key:\n            return self._find(root.left, key)\n        else:\n            return self._find(root.right, key)\n\n    def find(self, key):\n        return self._find(self.root, key)\n\n    def _delete(self, root, key):\n        if root is None:\n            return root\n\n        if key < root.key:\n            root.left = self._delete(root.left, key)\n        elif key > root.key:\n            root.right = self._delete(root.right, key)\n        else:\n            if root.left is None:\n                return root.right\n            elif root.right is None:\n                return root.left\n            \n            if root.left.priority > root.right.priority:\n                root = self._rotate_right(root)\n                root.right = self._delete(root.right, key)\n            else:\n                root = self._rotate_left(root)\n                root.left = self._delete(root.left, key)\n            \n        return root\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _inorder(self, root, result):\n        if root is not None:\n            self._inorder(root.left, result)\n            result.append(root.key)\n            self._inorder(root.right, result)\n\n    def inorder(self):\n        result = []\n        self._inorder(self.root, result)\n        return result\n\n    def _preorder(self, root, result):\n        if root is not None:\n            result.append(root.key)\n            self._preorder(root.left, result)\n            self._preorder(root.right, result)\n\n    def preorder(self):\n        result = []\n        self._preorder(self.root, result)\n        return result",
    "timestamp": "2025-08-13 09:33:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Random;\n\nclass TreapNode {\n    int key, priority;\n    TreapNode left, right;\n\n    TreapNode(int key, int priority) {\n        this.key = key;\n        this.priority = priority;\n        this.left = this.right = null;\n    }\n}\n\npublic class Treap {\n    private TreapNode root;\n    private Random random;\n\n    public Treap() {\n        this.root = null;\n        this.random = new Random();\n    }\n\n    // Rotate Right\n    private TreapNode rotateRight(TreapNode y) {\n        TreapNode x = y.left;\n        y.left = x.right;\n        x.right = y;\n        return x;\n    }\n\n    // Rotate Left\n    private TreapNode rotateLeft(TreapNode x) {\n        TreapNode y = x.right;\n        x.right = y.left;\n        y.left = x;\n        return y;\n    }\n\n    // Insert node\n    public void insert(int key) {\n        int priority = random.nextInt(100);\n        root = insert(root, key, priority);\n    }\n\n    private TreapNode insert(TreapNode node, int key, int priority) {\n        if (node == null) return new TreapNode(key, priority);\n\n        if (key < node.key) {\n            node.left = insert(node.left, key, priority);\n            if (node.left.priority > node.priority)\n                node = rotateRight(node);\n        } else if (key > node.key) {\n            node.right = insert(node.right, key, priority);\n            if (node.right.priority > node.priority)\n                node = rotateLeft(node);\n        }\n\n        return node;\n    }\n\n    // Search node\n    public boolean search(int key) {\n        return search(root, key);\n    }\n\n    private boolean search(TreapNode node, int key) {\n        if (node == null) return false;\n        if (node.key == key) return true;\n        return key < node.key ? search(node.left, key) : search(node.right, key);\n    }\n\n    // Delete node\n    public void delete(int key) {\n        root = delete(root, key);\n    }\n\n    private TreapNode delete(TreapNode node, int key) {\n        if (node == null) return null;\n\n        if (key < node.key) {\n            node.left = delete(node.left, key);\n        } else if (key > node.key) {\n            node.right = delete(node.right, key);\n        } else {\n\n            // Node with one child or no child\n            if (node.left == null) {\n                return node.right;\n            } else if (node.right == null) {\n                return node.left;\n            }\n\n            // Node with two children: rotate right or left based on priority and recur\n            if (node.left.priority > node.right.priority) {\n                node = rotateRight(node);\n                node.right = delete(node.right, key);\n            } else {\n                node = rotateLeft(node);\n                node.left = delete(node.left, key);\n            }\n        }\n\n        return node;\n    }\n\n    // Inorder traversal\n    public void inorder() {\n        inorder(root);\n        System.out.println();\n    }\n\n    private void inorder(TreapNode node) {\n        if (node != null) {\n            inorder(node.left);\n            System.out.print(node.key + \" \");\n            inorder(node.right);\n        }\n    }\n\n    // Preorder traversal\n    public void preorder() {\n        preorder(root);\n        System.out.println();\n    }\n\n    private void preorder(TreapNode node) {\n        if (node != null) {\n            System.out.print(node.key + \" \");\n            preorder(node.left);\n            preorder(node.right);\n        }\n    }\n\n    public static void main(String[] args) {\n        Treap treap = new Treap();\n        treap.insert(5);\n        treap.insert(3);\n        treap.insert(8);\n        treap.insert(1);\n        treap.insert(4);\n\n        System.out.println(\"Inorder traversal:\");\n        treap.inorder();\n\n        System.out.println(\"Preorder traversal:\");\n        treap.preorder();\n\n        System.out.println(\"Search 3: \" + treap.search(3));\n        System.out.println(\"Search 10: \" + treap.search(10));\n\n        treap.delete(3);\n        System.out.println(\"After deleting 3:\");\n\n        System.out.println(\"Inorder traversal:\");\n        treap.inorder();\n\n        System.out.println(\"Preorder traversal:\");\n        treap.preorder();\n    }\n}",
    "timestamp": "2025-08-13 09:34:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct TreapNode {\n    int key;\n    int priority;\n    struct TreapNode* left;\n    struct TreapNode* right;\n} TreapNode;\n\nTreapNode* createNode(int key, int priority) {\n    TreapNode* node = (TreapNode*)malloc(sizeof(TreapNode));\n    node->key = key;\n    node->priority = priority;\n    node->left = node->right = NULL;\n    return node;\n}\n\nTreapNode* rotateRight(TreapNode* y) {\n    TreapNode* x = y->left;\n    TreapNode* T2 = x->right;\n\n    x->right = y;\n    y->left = T2;\n\n    return x;\n}\n\nTreapNode* rotateLeft(TreapNode* x) {\n    TreapNode* y = x->right;\n    TreapNode* T2 = y->left;\n    \n    y->left = x;\n    x->right = T2;\n    \n    return y;\n}\n\nTreapNode* insert(TreapNode* root, int key, int priority) {\n    if (!root)\n        return createNode(key, priority);\n\n    if (key < root->key) {\n        root->left = insert(root->left, key, priority);\n\n        if (root->left->priority > root->priority)\n            root = rotateRight(root);\n    } else if (key > root->key) {\n        root->right = insert(root->right, key, priority);\n\n        if (root->right->priority > root->priority)\n            root = rotateLeft(root);\n    }\n    return root;\n}\n\nTreapNode* deleteNode(TreapNode* root, int key) {\n    if (!root)\n        return root;\n\n    if (key < root->key)\n        root->left = deleteNode(root->left, key);\n    else if (key > root->key)\n        root->right = deleteNode(root->right, key);\n    else {\n        if (!root->left) {\n            TreapNode* temp = root->right;\n            free(root);\n            root = temp;\n        } else if (!root->right) {\n            TreapNode* temp = root->left;\n            free(root);\n            root = temp;\n        } else if (root->left->priority < root->right->priority) {\n            root = rotateLeft(root);\n            root->left = deleteNode(root->left, key);\n        } else {\n            root = rotateRight(root);\n            root->right = deleteNode(root->right, key);\n        }\n    }\n    return root;\n}\n\nbool search(TreapNode* root, int key) {\n    if (!root)\n        return false;\n    \n    if (key == root->key)\n        return true;\n    else if (key < root->key)\n        return search(root->left, key);\n    else\n        return search(root->right, key);\n}\n\nvoid inorderTraversal(TreapNode* root) {\n    if (!root)\n        return;\n    inorderTraversal(root->left);\n    printf(\"%d \", root->key);\n    inorderTraversal(root->right);\n}\n\nvoid preorderTraversal(TreapNode* root) {\n    if (!root)\n        return;\n    printf(\"%d \", root->key);\n    preorderTraversal(root->left);\n    preorderTraversal(root->right);\n}\n\nint main() {\n    TreapNode* root = NULL;\n\n    root = insert(root, 50, 3);\n    root = insert(root, 30, 2);\n    root = insert(root, 20, 1);\n    root = insert(root, 40, 4);\n    root = insert(root, 70, 0);\n    root = insert(root, 60, 5);\n    root = insert(root, 80, 10);\n\n    printf(\"Inorder traversal: \");\n    inorderTraversal(root);\n    printf(\"\\nPreorder traversal: \");\n    preorderTraversal(root);\n    \n    root = deleteNode(root, 20);\n    printf(\"\\nAfter deletion of 20\\nInorder traversal: \");\n    inorderTraversal(root);\n\n    int key = 50;\n    printf(\"\\nSearch %d: %s\\n\", key, search(root, key) ? \"Found\" : \"Not Found\");\n\n    return 0;\n}",
    "timestamp": "2025-08-13 09:34:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import random\n\nclass TreapNode:\n    def __init__(self, key):\n        self.key = key\n        self.priority = random.random()\n        self.left = None\n        self.right = None\n\nclass Treap:\n    def __init__(self):\n        self.root = None\n\n    def rotate_right(self, y):\n        x = y.left\n        T2 = x.right\n        x.right = y\n        y.left = T2\n        return x\n\n    def rotate_left(self, x):\n        y = x.right\n        T2 = y.left\n        y.left = x\n        x.right = T2\n        return y\n\n    def insert(self, root, key):\n        if not root:\n            return TreapNode(key)\n\n        if key < root.key:\n            root.left = self.insert(root.left, key)\n            if root.left.priority > root.priority:\n                root = self.rotate_right(root)\n        else:\n            root.right = self.insert(root.right, key)\n            if root.right.priority > root.priority:\n                root = self.rotate_left(root)\n\n        return root\n\n    def delete(self, root, key):\n        if not root:\n            return None\n\n        if key < root.key:\n            root.left = self.delete(root.left, key)\n        elif key > root.key:\n            root.right = self.delete(root.right, key)\n        else:\n            if not root.left:\n                return root.right\n            elif not root.right:\n                return root.left\n            elif root.left.priority < root.right.priority:\n                root = self.rotate_left(root)\n                root.left = self.delete(root.left, key)\n            else:\n                root = self.rotate_right(root)\n                root.right = self.delete(root.right, key)\n\n        return root\n\n    def search(self, root, key):\n        if not root:\n            return False\n        if root.key == key:\n            return True\n        if key < root.key:\n            return self.search(root.left, key)\n        return self.search(root.right, key)\n\n    def inorder(self, root):\n        if root:\n            self.inorder(root.left)\n            print(root.key, end=' ')\n            self.inorder(root.right)\n\n    def preorder(self, root):\n        if root:\n            print(root.key, end=' ')\n            self.preorder(root.left)\n            self.preorder(root.right)\n\n    def add(self, key):\n        self.root = self.insert(self.root, key)\n\n    def remove(self, key):\n        self.root = self.delete(self.root, key)\n\n    def find(self, key):\n        return self.search(self.root, key)\n\n    def print_inorder(self):\n        self.inorder(self.root)\n        print()\n\n    def print_preorder(self):\n        self.preorder(self.root)\n        print()",
    "timestamp": "2025-08-13 09:34:31"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import random\n\nclass TreapNode:\n    def __init__(self, key, priority):\n        self.key = key\n        self.priority = priority\n        self.left = None\n        self.right = None\n\nclass Treap:\n    def __init__(self):\n        self.root = None\n    \n    def _left_rotate(self, node):\n        right_child = node.right\n        node.right = right_child.left\n        right_child.left = node\n        return right_child\n    \n    def _right_rotate(self, node):\n        left_child = node.left\n        node.left = left_child.right\n        left_child.right = node\n        return left_child\n    \n    def _insert(self, node, key, priority):\n        if node is None:\n            return TreapNode(key, priority)\n        if key < node.key:\n            node.left = self._insert(node.left, key, priority)\n            if node.left.priority > node.priority:\n                node = self._right_rotate(node)\n        else:\n            node.right = self._insert(node.right, key, priority)\n            if node.right.priority > node.priority:\n                node = self._left_rotate(node)\n        return node\n    \n    def insert(self, key, priority=None):\n        if priority is None:\n            priority = random.randint(0, 1000000)\n        self.root = self._insert(self.root, key, priority)\n    \n    def _search(self, node, key):\n        if node is None:\n            return False\n        if node.key == key:\n            return True\n        elif key < node.key:\n            return self._search(node.left, key)\n        else:\n            return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n    \n    def _delete(self, node, key):\n        if node is None:\n            return None\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n            else:\n                if node.left.priority > node.right.priority:\n                    node = self._right_rotate(node)\n                    node.right = self._delete(node.right, key)\n                else:\n                    node = self._left_rotate(node)\n                    node.left = self._delete(node.left, key)\n        return node\n    \n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n    \n    def _inorder(self, node, result):\n        if node is not None:\n            self._inorder(node.left, result)\n            result.append(str(node.key))\n            self._inorder(node.right, result)\n    \n    def inorder(self):\n        result = []\n        self._inorder(self.root, result)\n        return ' '.join(result)\n    \n    def _preorder(self, node, result):\n        if node is not None:\n            result.append(str(node.key))\n            self._preorder(node.left, result)\n            self._preorder(node.right, result)\n    \n    def preorder(self):\n        result = []\n        self._preorder(self.root, result)\n        return ' '.join(result)",
    "timestamp": "2025-08-13 09:34:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <cstdlib>\n\nstruct Node {\n    int key, priority;\n    Node* left;\n    Node* right;\n    Node(int k, int p) : key(k), priority(p), left(nullptr), right(nullptr) {}\n};\n\nclass Treap {\nprivate:\n    Node* root;\n\n    Node* rightRotate(Node* y) {\n        Node* x = y->left;\n        Node* T2 = x->right;\n        x->right = y;\n        y->left = T2;\n        return x;\n    }\n\n    Node* leftRotate(Node* x) {\n        Node* y = x->right;\n        Node* T2 = y->left;\n        y->left = x;\n        x->right = T2;\n        return y;\n    }\n\n    Node* insert(Node* node, int key, int priority) {\n        if (!node) return new Node(key, priority);\n\n        if (key < node->key) {\n            node->left = insert(node->left, key, priority);\n            if (node->left->priority > node->priority)\n                node = rightRotate(node);\n        } else {\n            node->right = insert(node->right, key, priority);\n            if (node->right->priority > node->priority)\n                node = leftRotate(node);\n        }\n        return node;\n    }\n\n    Node* deleteNode(Node* node, int key) {\n        if (!node) return node;\n\n        if (key < node->key)\n            node->left = deleteNode(node->left, key);\n        else if (key > node->key)\n            node->right = deleteNode(node->right, key);\n        else {\n            if (!node->left) {\n                Node* temp = node->right;\n                delete node;\n                return temp;\n            } else if (!node->right) {\n                Node* temp = node->left;\n                delete node;\n                return temp;\n            }\n\n            if (node->left->priority > node->right->priority) {\n                node = rightRotate(node);\n                node->right = deleteNode(node->right, key);\n            } else {\n                node = leftRotate(node);\n                node->left = deleteNode(node->left, key);\n            }\n        }\n        return node;\n    }\n\n    bool search(Node* node, int key) {\n        if (!node) return false;\n        if (node->key == key) return true;\n        if (key < node->key) return search(node->left, key);\n        return search(node->right, key);\n    }\n\n    void inorder(Node* node) {\n        if (node) {\n            inorder(node->left);\n            std::cout << node->key << \" \";\n            inorder(node->right);\n        }\n    }\n\n    void preorder(Node* node) {\n        if (node) {\n            std::cout << node->key << \" \";\n            preorder(node->left);\n            preorder(node->right);\n        }\n    }\n\npublic:\n    Treap() : root(nullptr) {}\n\n    void insert(int key, int priority) {\n        root = insert(root, key, priority);\n    }\n\n    void deleteNode(int key) {\n        root = deleteNode(root, key);\n    }\n\n    bool search(int key) {\n        return search(root, key);\n    }\n\n    void printInorder() {\n        inorder(root);\n        std::cout << std::endl;\n    }\n\n    void printPreorder() {\n        preorder(root);\n        std::cout << std::endl;\n    }\n};\n\nint main() {\n    Treap treap;\n    treap.insert(50, 30);\n    treap.insert(20, 40);\n    treap.insert(30, 25);\n    treap.insert(70, 50);\n    treap.insert(90, 35);\n\n    std::cout << \"Inorder Traversal: \";\n    treap.printInorder();\n\n    std::cout << \"Preorder Traversal: \";\n    treap.printPreorder();\n\n    std::cout << \"Search 30: \" << (treap.search(30) ? \"Found\" : \"Not Found\") << std::endl;\n\n    treap.deleteNode(30);\n\n    std::cout << \"Inorder Traversal after Deleting 30: \";\n    treap.printInorder();\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:52:38"
  }
]