[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable.Stack\nimport scala.io.StdIn.{readInt, readLine}\n\nobject Main extends App {\n\n  val treap = new Treap\n  val n = readInt\n  for (i <- 0 until n) {\n    val arr = readLine.split(\" \")\n    val cmd = arr(0)\n    cmd match {\n      case \"insert\" => treap.insert(key=arr(1).toInt, pri=arr(2).toInt)\n      case \"delete\" => treap.delete(key=arr(1).toInt)\n      case \"find\" => println(if (treap.find(key=arr(1).toInt)) \"yes\" else \"no\")\n      case \"print\" => treap.printTree\n    }\n  }\n\n  class Treap {\n\n    class Node(var key: Int, var pri: Int) {\n      var parent: Node = null\n      var left: Node = null\n      var right: Node = null\n      var visited = false\n    }\n\n    var root: Node = null\n\n    def insert(key: Int, pri: Int): Unit = {\n      root = insert(root, key, pri)\n    }\n\n    def insert(node: Node, key: Int, pri: Int): Node = {\n      var t = node\n      if (t == null) {\n        return new Node(key, pri)\n      }\n      if (t.key == key) {\n        return t\n      }\n      if (key < t.key) {\n        t.left = insert(t.left, key, pri)\n        if (t.pri < t.left.pri) {\n          t = rightRotate(t)\n        }\n      } else {\n        t.right = insert(t.right, key, pri)\n        if (t.pri < t.right.pri) {\n          t = leftRotate(t)\n        }\n      }\n      t\n    }\n\n    def rightRotate(t: Node): Node = {\n      val s = t.left\n      t.left = s.right\n      s.right = t\n      s\n    }\n\n    def leftRotate(t: Node): Node = {\n      val s = t.right\n      t.right = s.left\n      s.left = t\n      s\n    }\n\n    def delete(key: Int): Unit = {\n      root = delete(root, key)\n    }\n\n    def delete(node: Node, key: Int): Node = {\n      val t = node\n      if (t == null) {\n        return null\n      }\n      if (key < t.key) {\n        t.left = delete(t.left, key)\n      } else if (key > t.key) {\n        t.right = delete(t.right, key)\n      } else {\n        return _delete(t, key)\n      }\n      t\n    }\n\n    def _delete(node: Node, key: Int): Node = {\n      var t = node\n      if (t.left == null && t.right == null) {\n        return null\n      } else if (t.left == null) {\n        t = leftRotate(t)\n      } else if (t.right == null) {\n        t = rightRotate(t)\n      } else {\n        if (t.left.pri > t.right.pri) {\n          t = rightRotate(t)\n        } else {\n          t = leftRotate(t)\n        }\n      }\n      delete(t, key)\n    }\n\n    def find(key: Int): Boolean = {\n      val node = findNode(root, key)\n      node != null\n    }\n\n    def findNode(node: Node, key: Int): Node = {\n      var t = node\n      if (t == null) {\n        return null\n      }\n      if (key == t.key) {\n        return t\n      }\n      if (key < t.key) {\n        t = findNode(t.left, key)\n      } else {\n        t = findNode(t.right, key)\n      }\n      t\n    }\n\n    def printTree: Unit = {\n      inOrder\n      preOrder\n    }\n\n    def inOrder: Unit = {\n      val stack = new Stack[Node]\n      stack.push(root)\n      while (!stack.isEmpty) {\n        var t = stack.top\n        while (t.left != null && !t.left.visited) {\n          stack.push(t.left)\n          t = t.left\n        }\n        t = stack.pop\n        print(s\" ${t.key}\")\n        t.visited = true\n        if (t.right != null && !t.right.visited) {\n          stack.push(t.right)\n        }\n      }\n      println\n    }\n\n    def preOrder: Unit = {\n      val stack = new Stack[Node]\n      stack.push(root)\n      while (!stack.isEmpty) {\n        val t = stack.pop\n        print(s\" ${t.key}\")\n        t.visited = false\n        if (t.right != null) stack.push(t.right)\n        if (t.left != null) stack.push(t.left)\n      }\n      println\n    }\n\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n  val n: Int = io.StdIn.readInt()\n  val tr: Treap = Empty\n\n  (0 until n).foldLeft[Treap](tr){(t, _) =>\n    val op: Array[String] = io.StdIn.readLine().split(\" \")\n    op(0) match {\n      case \"print\" => t.show; t\n      case \"insert\" => t.insert(op(1).toInt, op(2).toInt)\n      case \"find\" => {\n        val key: Int = op(1).toInt\n        println(if (t.find(key)) \"yes\" else \"no\")\n        t\n      }\n      case \"delete\" => {\n        val key: Int = op(1).toInt\n        t.delete(key)\n      }\n      case _ => throw new Error(\"Unknown operation\")\n    }\n  }\n\n  trait Treap {\n    def priority: Int\n    def leftRotate: Treap\n    def rightRotate: Treap\n    def insert(k: Int, p: Int): Treap\n    def delete(k: Int): Treap\n    def find(k: Int): Boolean\n    def preorder: List[Int]\n    def inorder: List[Int]\n    def show: Unit = {\n      println(\" \" + this.inorder.mkString(\" \"))\n      println(\" \" + this.preorder.mkString(\" \"))\n    }\n  }\n  case object Empty extends Treap {\n    def priority: Int = throw new Error\n    def leftRotate: Treap = throw new Error\n    def rightRotate: Treap = throw new Error\n    def insert(k: Int, p: Int): Node = Node(k, p, Empty, Empty)\n    def delete(k: Int): Treap = this\n    def find(k: Int): Boolean = false\n    def preorder: List[Int] = Nil\n    def inorder: List[Int] = Nil\n  }\n\n  case class Node(key: Int, priority: Int, left: Treap, right: Treap) extends Treap {\n    def leftRotate: Treap = right match {\n      case Empty => throw new Error\n      case Node(k, p, l, r) =>\n        Node(k, p, Node(key, priority, left, l), r)\n    }\n    def rightRotate: Node = left match {\n      case Empty => throw new Error\n      case Node(k, p, l, r) =>\n        Node(k, p, l, Node(key, priority, r, right))\n    }\n    def insert(k: Int, p: Int): Treap = {\n      if (key == k) this\n      else if (k < key) {\n        val l: Treap = left.insert(k, p)\n        val updated: Node = Node(key, priority, l, right)\n        if (priority < l.priority) updated.rightRotate\n        else updated\n      } else {\n        val r: Treap = right.insert(k, p)\n        val updated: Node = Node(key, priority, left, r)\n        if (priority < r.priority) updated.leftRotate\n        else updated\n      }\n    }\n    def delete(k: Int): Treap = {\n      if (k < key) Node(key, priority, left.delete(k), right)\n      else if (k > key) Node(key, priority, left, right.delete(k))\n      else (this match {\n        case Node(_, _, Empty, Empty) => Empty\n        case Node(_, _, Empty, _) => this.leftRotate\n        case Node(_, _, _, Empty) => this.rightRotate\n        case _ =>\n          if (left.priority > right.priority) this.rightRotate\n          else this.leftRotate\n      }).delete(k)\n    }\n    def find(k: Int): Boolean = {\n      if (k == key) true\n      else if (k < key) left.find(k)\n      else right.find(k)\n    }\n    def preorder: List[Int] = key :: (left.preorder ::: right.preorder)\n    def inorder: List[Int]  = left.inorder ::: (key :: right.inorder)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\nstruct node{\n\tstruct node *right;\n\tstruct node *left;\n\tstruct node *parent;\n\tint key;\n\tint priority;\n};\ntypedef struct node * Node;\n#define NIL NULL\n\nNode root;\n\nNode rightRotate(Node t){\n\tNode s = t->left;\n\tif (t == root) root = s;\n\tif (t->parent != NIL){\n\t\tif (t->parent->right == t){\n\t\t\tt->parent->right = s;\n\t\t}\n\t\telse{\n\t\t\tt->parent->left = s;\n\t\t}\n\t}\n\ts->parent = t->parent;\n\tt->parent = s;\n\tif (s->right != NIL) s->right->parent = t;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s; // root of the subtree\n}\n\nNode leftRotate(Node t){\n\tNode s = t->right;\n\tif (t == root) root = s;\n\tif (t->parent != NIL){\n\t\tif (t->parent->right == t){\n\t\t\tt->parent->right = s;\n\t\t}\n\t\telse{\n\t\t\tt->parent->left = s;\n\t\t}\n\t}\n\ts->parent = t->parent;\n\tt->parent = s;\n\tif (s->left != NIL) s->left->parent = t;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s; // root of the subtree\n}\n\nNode treeMinimum(Node x){\n\tNode c = x;\n\twhile (c->left != NIL){\n\t\tc = c->left;\n\t}\n\treturn c;\n}\n\nNode treeMaximum(Node x){\n\tNode c = x;\n\twhile (c->right != NIL){\n\t\tc = c->right;\n\t}\n\treturn c;\n}\n\nNode treeSearch(Node u, int k){\n\tif (u == NIL) return NIL;\n\tif (u->key == k){\n\t\treturn u;\n\t}\n\telse if (u->key > k){\n\t\tNode n = treeSearch(u->left, k);\n\t\tif (n != NIL) return n;\n\t}\n\telse{\n\t\tNode m = treeSearch(u->right, k);\n\t\tif (m != NIL) return m;\n\t}\n\treturn NIL;\n}\n\n\nNode Rec_delete(Node t, int key);\nNode treapDelete(Node t, int key);\nvoid treeDelete(Node t);\nvoid preorder(Node t);\n\nNode Rec_delete(Node t, int key){ // 削除対象の節点の場合\n\tif (t->left == NIL && t->right == NIL){           // 葉の場合\n\t\t//treeDelete(t);\n\t\treturn NIL;\n\t}\n\telse if (t->left == NIL){                        // 右の子のみを持つ場合左回転\n\t\tt = leftRotate(t);\n\t}\n\telse if (t->right == NIL){                       // 左の子のみを持つ場合右回転\n\t\tt = rightRotate(t);\n\t}\n\telse{                                         // 左の子と右の子を両方持つ場合\n\t\tif (t->left->priority > t->right->priority){    // 優先度が高い方を持ち上げる\n\t\t\tt = rightRotate(t);\n\t\t}\n\t\telse{\n\t\t\tt = leftRotate(t);\n\t\t}\n\t}\n\treturn treapDelete(t, key);\n}\n\nNode treapDelete(Node t, int key){\n\tif (t == NIL){\n\t\treturn NIL;\n\t}\n\tif (key < t->key){                                // 削除対象を検索\n\t\tt->left = treapDelete(t->left, key);\n\t}\n\telse if (key > t->key){\n\t\tt->right = treapDelete(t->right, key);\n\t}\n\telse{\n\t\treturn Rec_delete(t, key);\n\t}\n\treturn t;\n}\n\nNode treeSuccessor(Node x){\n\tif (x->right != NIL){\n\t\treturn treeMinimum(x->right);\n\t}\n\telse{\n\t\tNode c = x;\n\t\twhile (c != root){\n\t\t\tif (c->parent->left == c){\n\t\t\t\treturn c->parent;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn NIL;\n\t}\n}\n\nvoid treeDelete(Node z){\n\tif (z->left == NIL && z->right == NIL){\n\t\tif (z->parent->left == z){\n\t\t\tz->parent->left = NIL;\n\t\t}\n\t\telse{\n\t\t\tz->parent->right = NIL;\n\t\t}\n\t\tdelete z;\n\t}\n\telse if (z->left == NIL){\n\t\tif (z->parent->left == z){\n\t\t\tz->parent->left = z->right;\n\t\t}\n\t\telse{\n\t\t\tz->parent->right = z->right;\n\t\t}\n\t\tz->right->parent = z->parent;\n\t\tdelete z;\n\t}\n\telse if (z->right == NIL){\n\t\tif (z->parent->left == z){\n\t\t\tz->parent->left = z->left;\n\t\t}\n\t\telse{\n\t\t\tz->parent->right = z->left;\n\t\t}\n\t\tz->left->parent = z->parent;\n\t\tdelete z;\n\t}\n\telse{\n\t\tNode y = treeSuccessor(z);\n\t\tz->key = y->key;\n\t\ttreeDelete(y);\n\t}\n}\n\nNode insert(Node t, int key, int priority){ // 再帰的に探索\n\tif (t == NIL){\n\t\tNode y = NIL;\n\t\tNode x = root;\n\t\tNode z = new node;\n\n\t\tz->key = key;\n\t\tz->priority = priority;\n\t\tz->left = NIL;\n\t\tz->right = NIL;\n\n\t\twhile (x != NIL){\n\t\t\ty = x;\n\t\t\tif (z->key < x->key){\n\t\t\t\tx = x->left;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tx = x->right;\n\t\t\t}\n\t\t}\n\t\tz->parent = y;\n\t\tif (y == NIL) {\n\t\t\troot = z;\n\t\t}\n\t\telse if (z->key < y->key){\n\t\t\ty->left = z;\n\t\t}\n\t\telse{\n\t\t\ty->right = z;\n\t\t}\n\t\treturn z;               // 葉に到達したら新しい節点を生成して返す\n\t}\n\tif (key == t->key){\n\t\treturn t;                             // 重複したkeyは無視\n\t}\n\n\tif (key < t->key){                             // 左の子へ移動\n\t\tt->left = insert(t->left, key, priority);   // 左の子へのポインタを更新\n\t\tif (t->priority < t->left->priority){     // 左の子の方が優先度が高い場合右回転\n\t\t\tt = rightRotate(t);\n\t\t}\n\t}\n\telse{                  // 右の子へ移動\n\t\tt->right = insert(t->right, key, priority);// 右の子へのポインタを更新\n\t\tif (t->priority < t->right->priority){    // 右の子の方が優先度が高い場合左回転\n\t\t\tt = leftRotate(t);\n\t\t}\n\t}\n\n\treturn t;\n\n\n}\n\nvoid inorder(Node u){\n\tif (u->left != NIL) inorder(u->left);\n\tprintf(\" %d\", u->key);\n\tif (u->right != NIL) inorder(u->right);\n\treturn;\n}\nvoid preorder(Node u){\n\tprintf(\" %d\", u->key);\n\tif (u->left != NIL) preorder(u->left);\n\tif (u->right != NIL) preorder(u->right);\n\treturn;\n}\n\n\nint main(){\n\tint n, i, x, y;\n\tchar com[20];\n\tscanf(\"%d\", &n);\n\n\tfor (i = 0; i < n; i++){\n\t\tscanf(\"%s\", com);\n\t\tif (com[0] == 'f'){\n\t\t\tscanf(\"%d\", &x);\n\t\t\tNode t = treeSearch(root, x);\n\t\t\tif (t != NIL) printf(\"yes\\n\");\n\t\t\telse printf(\"no\\n\");\n\t\t}\n\t\telse if (com[0] == 'i'){\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tinsert(root, x, y);\n\t\t}\n\t\telse if (com[0] == 'p'){\n\t\t\tinorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tpreorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse if (com[0] == 'd'){\n\t\t\tscanf(\"%d\", &x);\n\t\t\ttreapDelete(root, x);\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct Node{\n  int key,priority;\n  Node *right,*left,*parent;\n};\n\nNode *root,*NIL;\n\nNode* rightRotate(Node *t){\n  Node *s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\n\nNode* leftRotate(Node *t){\n  Node *s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\n\nNode* treeMinimum(Node *x){\n    while(x->left != NIL) x = x->left;\n    return x;\n}\n\nNode* find(Node *u,int k){\n    while(u != NIL && k != u->key){\n        if(k < u->key) u = u->left;\n        else u = u->right;\n    }\n    return u;\n}\n\nNode* treeSuccessor(Node *x){\n    if(x->right != NIL) return treeMinimum(x->right);\n    Node *y = x->parent;\n    while(y != NIL && x == y->right){\n        x = y;\n        y = y->parent;\n    }\n}\n\nNode* createNode(int key, int priority) {\n    Node *p;\n    p = (Node *)malloc(sizeof(Node));\n    p->key = key;\n    p->priority = priority;\n    p->left = NULL;\n    p->right = NULL;\n    p->parent = NULL;\n    return p;\n}\n\nNode* insert(Node *t, int key, int priority){\n  if(t == NIL) return createNode(key, priority);\n  if(key == t->key) return t;\n  if(key < t->key){\n    t->left = insert(t->left, key, priority);\n    if(t->priority < t->left->priority) t = rightRotate(t);\n  } else {\n    t->right = insert(t->right, key, priority);\n    if(t->priority < t->right->priority) t = leftRotate(t);\n  }\n  return t;\n}\n\nNode* _treeDelete(Node *t,int key);\nNode* treeDelete(Node *t, int key);\n\nNode* _treeDelete(Node *t,int key){\n  if(t->left == NIL && t->right == NIL) return NIL;\n  else if(t->left == NIL) t = leftRotate(t);\n  else if(t->right == NIL) t = rightRotate(t);\n  else{\n    if(t->left->priority > t->right->priority) t = rightRotate(t);\n    else t = leftRotate(t);\n  }\n  return treeDelete(t, key);\n}\n\nNode* treeDelete(Node *t, int key){\n  if(t == NIL) return NIL;\n  if(key < t->key) t->left = treeDelete(t->left, key);\n  else if(key > t->key) t->right = treeDelete(t->right, key);\n  else return _treeDelete(t, key);\n  return t;\n}\n\nvoid inorder(Node *u){\n    if(u==NIL) return;\n    inorder(u->left);\n    printf(\" %d\",u->key);\n    inorder(u->right);\n}\n\nvoid preorder(Node *u){\n    if(u==NIL) return;\n    printf(\" %d\",u->key);\n    preorder(u->left);\n    preorder(u->right);\n}\n\nint main(){\n  int n,i,x,y;\n    string com;\n    scanf(\"%d\",&n);\n\n    for(i=0;i<n;i++){\n        cin >> com;\n        if(com==\"find\"){\n            scanf(\"%d\",&x);\n            Node *t = find(root,x);\n            if(t!=NIL) printf(\"yes\\n\");\n            else printf(\"no\\n\");\n        } else if(com==\"insert\"){\n\t  scanf(\"%d%d\",&x,&y);\n\t  root=insert(root,x,y);\n        } else if(com==\"print\"){\n            inorder(root);\n            printf(\"\\n\");\n            preorder(root);\n            printf(\"\\n\");\n        } else if(com == \"delete\"){\n            scanf(\"%d\",&x);\n            root=treeDelete(root,x);\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct Node {\n\tint key, pri;\n\tNode *left, *right;\n};\n\nNode *root, *NIL;\n\nNode* rightRotate(Node* t) {\n\tNode* s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\tif (t == root)\n\t  root = s;\n\treturn s;\n}\n\nNode* leftRotate(Node* t) {\n\tNode* s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\tif (t == root)\n\t  root = s;\n\treturn s;\n}\n\nvoid inorder(Node *t) {\n\tif (t == NIL)\n\t\treturn;\n\tinorder(t->left);\n\tcout << \" \" << t->key;\n\tinorder(t->right);\n}\n\nvoid preorder(Node *t) {\n\tif (t == NIL)\n\t\treturn;\n\tcout << \" \" << t->key;\n\tpreorder(t->left);\n\tpreorder(t->right);\n}\n\nvoid status(Node* t) {\n\tcout << \"k:\" << t->key << endl;\n\tcout << \"l:\" << t->left << endl;\n\tcout << \"r:\" << t->right << endl;\n\tcout << endl;\n}\n\nNode* insert(Node *t, int key, int pri) {\n\tif (t == NIL) {\n\t\tNode *u = new Node();\n\t\tu->key = key;\n\t\tu->pri = pri;\n\t\tu->left = u->right = NIL;\n\t\treturn u;\n\t}\n\tif (key == t->key) {\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tt->left = insert(t->left, key, pri);\n\t\tif (t->pri < t->left->pri)\n\t\t\tt = rightRotate(t);\n\t}\n\telse {\n\t\tt->right = insert(t->right, key, pri);\n\t\tif (t->pri < t->right->pri)\n\t\t\tt = leftRotate(t);\n\t}\n\n\treturn t;\n}\n\nNode* find(Node* t, int key) {\n\tif (t == NIL)\n\t\treturn NIL;\n\tif (key == t->key)\n\t\treturn t;\n\n\tNode* u;\n\tif (key < t->key) {\n\t\tif ((u = find(t->left, key)) != NIL)\n\t\t\treturn u;\n\t}\n\telse {\n\t\tif ((u = find(t->right, key)) != NIL)\n\t\t\treturn u;\n\t}\n\treturn NIL;\n}\n\nNode* _delete(Node *t, int key);\n\nNode* nodeDelete(Node *t, int key) {\n\tif (t == NIL)\n\t\treturn NIL;\n\tif (key < t->key)\n\t\tt->left = nodeDelete(t->left, key);\n\telse if (key > t->key)\n\t\tt->right = nodeDelete(t->right, key);\n\telse\n\t\treturn _delete(t, key);\n\treturn t;\n}\n\nNode* _delete(Node *t, int key) {\n\tif (t->left == NIL && t->right == NIL) {\n\t\treturn NIL;\n\t}\n\telse if (t->left == NIL) {\n\t\tt = leftRotate(t);\n\t}\n\telse if (t->right == NIL) {\n\t\tt = rightRotate(t);\n\t}\n\telse {\n\t\tif (t->left->pri > t->right->pri) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t\telse {\n\t\t\tt = leftRotate(t);\n\t\t}\n\t}\n\treturn nodeDelete(t, key);\n}\n\nint main() {\n\tint m, k, p;\n\tstring s;\n\n\tNIL = new Node();\n\tNIL->left = NIL->right = NIL;\n\troot = NIL;\n\n\tcin >> m;\n\twhile (m--) {\n\t\tcin >> s;\n\t\tif (s == \"insert\") {\n\t\t\tcin >> k >> p;\n\t\t\tNode *t = insert(root, k, p);\n\t\t\tif (root == NIL) {\n\t\t\t\troot = t;\n\t\t\t}\n\t\t}\n\t\telse if (s == \"find\") {\n\t\t\tcin >> k;\n\t\t\tcout << ((find(root, k) == NIL) ? \"no\" : \"yes\") << endl;\n\t\t}\n\t\telse if (s == \"delete\") {\n\t\t\tcin >> k;\n\t\t\tnodeDelete(root, k);\n\t\t}\n\t\telse if (s == \"print\") {\n\t\t\tinorder(root);\n\t\t\tcout << endl;\n\t\t\tpreorder(root);\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstruct Node{\n        int key, priority;\n        Node *left, *right;\n};\n\nstatic Node *root;\n\nNode* deletekey(Node* t, int key);\nNode* _deletekey(Node* t, int key);\n\nNode* rightRotate(Node *t){\n        Node *s = t->left;\n        t->left = s->right;\n        s->right = t;\n        return s;\n}\n\nNode* leftRotate(Node *t){\n        Node *s = t->right;\n        t->right = s->left;\n        s->left = t;\n        return s;\n}\n\nNode *insert(int v, int priority, Node *t){\n        if(t==NULL){\n                Node *a = new Node();\n                a->key = v;\n                a->priority = priority;\n                a->left = NULL;\n                a->right = NULL;\n                return a;\n        }\n        if(v==t->key) return t;\n\n        if(v<t->key){\n                t->left = insert(v, priority, t->left);\n                if(t->priority<t->left->priority)\n                        t = rightRotate(t);\n        }else{\n                t->right = insert(v, priority, t->right);\n                if(t->priority<t->right->priority)\n                        t = leftRotate(t);\n        }\n        return t;\n}\n\nbool find(int v){\n        Node *i = root;\n        while(i!=NULL){\n                if(v==i->key) return true;\n                else if(v<i->key) i = i->left;\n                else i = i->right;\n        }\n        return false;\n}\n\n\nNode* deletekey(Node* t, int key){\n        if(!t) return NULL;\n        if(key == t->key) return _deletekey(t, key);\n        if(key < t->key) t->left = deletekey(t->left, key);\n        else t->right = deletekey(t->right, key);\n        return t;\n}\n\nNode* _deletekey(Node* t, int key){\n        if(t->left==NULL&&t->right==NULL){\n                delete t;\n                return NULL;\n        }else if(t->left == NULL)\n                t = leftRotate(t);\n        else if(t->right == NULL)\n                t = rightRotate(t);\n        else{\n                if(t->left->priority > t->right->priority)\n                        t = rightRotate(t);\n                else\n                        t = leftRotate(t);\n        }\n        return deletekey(t, key);\n}\n\nvoid print_preorder(Node *i){\n        if(!i) return;\n        cout<<\" \"<<i->key;\n        print_preorder(i->left);\n        print_preorder(i->right);\n}\n\nvoid print_inorder(Node *i){\n        if(!i) return;\n        print_inorder(i->left);\n        cout<<\" \"<<i->key;\n        print_inorder(i->right);\n}\n\nint main(){\n        int n,v,u;\n        string s;\n        cin>>n;\n        root = NULL;\n        for(int i=0;i<n;i++){\n                cin>>s;\n                if(s==\"insert\") {\n                        cin>>v>>u;\n                        root = insert(v,u,root);\n                }else if(s==\"find\"){\n                        cin>>v;\n                        if(find(v)) cout<<\"yes\"<<endl;\n                        else cout<<\"no\"<<endl;\n                }else if(s==\"delete\"){\n                        cin>>v;\n                        root = deletekey(root, v);\n                }else if(s==\"print\"){\n                        print_inorder(root);\n                        cout<<endl;\n                        print_preorder(root);\n                        cout<<endl;\n                }\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct node{\n  node* l;\n  node* r;\n  int value;\n  int priority;\n  node(int x=0,int y=0){\n    l=NULL;\n    r=NULL;\n    value=x;\n    priority=y;\n  }\n};\n\ntypedef node* Node;\n\nint cc=0;\nnode t[500005];\n\nNode MakeNode(int x=0,int y=0){\n  Node res=&t[cc];\n  cc++;\n  res->value=x;\n  res->priority=y;\n  return res;\n}\n\nNode left_rotate(Node root){\n  Node right=root->r;\n  root->r = right->l;\n  right->l = root;\n  return right;\n}\n\nNode right_rotate(Node root){\n  Node left=root->l;\n  root->l = left->r;\n  left->r = root;\n  return left;\n}\n\nNode insert(Node root,int val,int pri){\n  \n  if(root==NULL){\n    return MakeNode(val,pri);\n  }\n  \n  if( val < root->value ){\n    root->l = insert( root->l , val , pri );\n\n    if( root->l->priority > root->priority ){\n      root = right_rotate(root);\n    }\n    \n  }else if( val > root->value ){\n    root->r = insert( root->r , val , pri );\n    \n    if( root->r->priority > root->priority ){\n      root = left_rotate(root);\n    }\n    \n  }else{\n    \n  }\n  return root;\n}\n\nbool find(Node root,int target){\n  if( root == NULL )return false;\n  if( root->value == target )return true;\n  if( root->value > target )return find(root->l,target);\n  if( root->value < target )return find(root->r,target);\n  return false;\n}\n\nNode erase(Node root,int target){\n  if( root == NULL )return root;\n  if( root->value == target ){\n    \n    if( root->l == NULL ){\n      return root->r;\n    }\n    if( root->r == NULL ){\n      return root->l;\n    }\n\n    if( root->l->priority > root->r->priority ){\n      root = right_rotate(root);\n    } else {\n      root = left_rotate(root);\n    }\n    return erase(root,target);\n  }\n  \n  if( root->value > target ){\n    root->l=erase(root->l,target);\n    return root;\n  }\n  if( root->value < target ){\n    root->r=erase(root->r,target);\n    return root;\n  }\n\n  assert(0);\n}\n\nvoid dfsA(Node root){\n  if(root==NULL)return;\n  printf(\" %d\", root->value);\n  dfsA(root->l);\n  dfsA(root->r);\n}\n\nvoid dfsB(Node root){\n  if(root==NULL)return;\n  dfsB(root->l);\n  printf(\" %d\", root->value);\n  dfsB(root->r);\n}\n\nNode T=NULL;\n\nint main(){\n\n  int m;\n  scanf(\"%d\",&m);\n\n  char str[100];\n  int x,y;\n  \n  for(int i=0;i<m;i++){\n    scanf(\"%s\",str);\n    if(str[0]=='i'){\n      scanf(\"%d %d\",&x,&y);\n      T=insert(T,x,y);\n      \n    }else if(str[0]=='f'){\n      scanf(\"%d\",&x);\n      if( find(T,x) )printf(\"yes\\n\");\n      else printf(\"no\\n\");\n      \n    }else if(str[0]=='d'){\n      scanf(\"%d\",&x);\n      if( find(T,x) ){\n        T=erase(T,x);\n      }\n      \n    }else if(str[0]=='p'){\n      dfsB(T);\n      printf(\"\\n\");\n      dfsA(T);\n      printf(\"\\n\");\n      \n    }else{\n      assert(0);\n    }\n\n  }\n  return 0;\n  /*\n  int tmp[10]={3,1,4,5,2,0,6,9,7,8};\n\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int id;\n    cin>>id;\n    T=insert(T,id, tmp[id] );\n  }\n\n  T=erase(T, 7);\n  \n  dfs(T);\n  cout<<endl;\n  */\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<iostream>\nusing namespace std;\n\nstruct Node{\n    int key;\n    int priority;\n    Node* parent;\n    Node* left;\n    Node* right;\n    Node(){parent=left=right=NULL;}\n    Node(int a, int b) :key(a),priority(b)\n        {parent=left=right=NULL;} \n};\n\nNode *root;\n\nNode* rightRotate(Node* t){\n    Node* s = t->left;\n    t->left = s->right;\n    s->right = t;\n    if(t==root){    //根を更新\n        root = s;\n    }\n    return s;\n}\n\nNode* leftRotate(Node* t){\n    Node* s = t->right;\n    t->right = s->left;\n    s->left = t;\n    if(t==root){    //根を更新\n        root = s;\n    }\n    return s;\n}\n\nNode* insert_2(Node* t, int _key, int _priority){\n\n    //葉に到達したら新しい節点を生成\n    if(t==NULL) return new Node(_key, _priority);    //なるほど！！\n    if(_key==t->key) return t;\n\n    if(_key < t->key){\n        t->left = insert_2(t->left, _key, _priority);\n        if(t->priority < t->left->priority){\n            t = rightRotate(t);\n        }\n    }else{\n        t->right = insert_2(t->right, _key, _priority);\n        if(t->priority < t->right->priority){\n            t = leftRotate(t);\n        }\n    }\n    return t;   //結局自分自身を返すためrootがそのまま帰ってくる\n}\n\nNode* _Delete(Node* t, int key);\n\nNode* Delete(Node* t, int key){\n    if(t==NULL) return NULL;\n\n    //削除対象を検索\n    if(key < t->key){\n        t->left = Delete(t->left, key);\n    }else if(key > t->key){\n        t->right = Delete(t->right, key);\n    }else{\n        return _Delete(t, key);\n    }\n    //一致する節点が見つからまかった\n    return t;\n}\n\n//削除対象の節点の場合\nNode* _Delete(Node* t, int key){\n    if((t->left==NULL)&&(t->right==NULL)) return NULL;  //葉の場合\n    else if(t->left == NULL){   //右の子のみを持つ場合\n        t = leftRotate(t);\n    }else if(t->right == NULL){  //左の子のみを持つ場合\n        t = rightRotate(t);\n    }else{  //右の子と左の子を両方持つ場合\n        if(t->left->priority > t->right->priority){\n            t = rightRotate(t);\n        }else{\n            t = leftRotate(t);\n        }\n    }\n    return Delete(t, key);\n}\n\nNode* find(Node* t, int key){\n    while((t!=NULL)&&(t->key!=key)){    //終了条件\n        if(key < t->key){\n            t = t->left;\n        }else{\n            t = t->right;\n        }\n    }\n    //キーが一致する節点見つけたらループを向けている\n    return t;\n}\n\nvoid preParse(Node* u){\n    if(u==NULL) return;\n    preParse(u->left);\n    printf(\" %d\", u->key);\n    preParse(u->right);\n}\n\nvoid inParse(Node* u){\n    if(u==NULL) return;\n    printf(\" %d\", u->key);\n    inParse(u->left);\n    inParse(u->right);\n}\n\nint main(){\n\n    int n;\n    scanf(\"%d\", &n);\n\n    root = NULL;\n\n    for(int i=0; i<n; i++){\n        string str;\n        cin >> str;\n        if(str == \"insert\"){\n            int key, priority;\n            scanf(\"%d %d\", &key, &priority);\n            root = insert_2(root, key, priority);   //新しい根を返す\n        }else if(str == \"delete\"){\n            int key;\n            scanf(\"%d\", &key);\n            root = Delete(root, key);   //新しい根を返す\n        }else if(str == \"print\"){\n            preParse(root);\n            printf(\"\\n\");\n            inParse(root);\n            printf(\"\\n\");\n        }else if(str == \"find\"){\n            int key;\n            scanf(\"%d\", &key);\n            Node* u = find(root, key);\n            if(u != NULL) printf(\"yes\\n\");\n            else printf(\"no\\n\");\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstruct node{\n  node* right;\n  node* left;\n  int key,pri;\n};\n\nnode* rightRotato(node* t) {\n    node* s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n}\n\nnode* leftRotato(node* t) {\n    node* s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;\n}\n\nnode* insert(node* t, int key, int pri) {\n    if(t == NULL) {\n        node* t = new node;\n        t->left=NULL; t->right = NULL;\n        t->key = key; t->pri = pri;\n        return t;\n    }\n    if(key == t->key) return t;\n\n    if(key < t->key) {\n        t->left = insert(t->left, key, pri);\n        if(t->pri < t->left->pri) t = rightRotato(t);\n    }\n    else {\n        t->right = insert(t->right, key, pri);\n        if(t->pri < t->right->pri) t = leftRotato(t);\n    }\n    return t;\n}\nnode* erase(node* t, int key){\n    if(t == NULL) return NULL;\n\n    if(key == t->key) {\n        if(t->left == NULL && t->right == NULL) return NULL;\n        else if(t->left == NULL) t = leftRotato(t);\n        else if(t->right == NULL) t = rightRotato(t);\n        else {\n            if(t->left->pri > t->right->pri) t = rightRotato(t);\n            else t = leftRotato(t);\n        }\n        return erase(t,key);\n    }\n    if(key < t->key) t->left = erase(t->left, key);\n    else t->right = erase(t->right, key);\n    return t;\n}\n\nvoid find(node* t, int key) {\n    while(t != NULL && key != t->key) {\n        if(key < t->key) t = t->left;\n        else t = t->right;\n    }\n    if(t == NULL) cout << \"no\" << endl;\n    else cout << \"yes\" << endl;\n}\n\nvoid inorder(node* t) {\n    if(t==NULL) return;\n    inorder(t->left);\n    cout << \" \" << t->key;\n    inorder(t->right);\n}\n\nvoid preorder(node* t) {\n    if(t == NULL) return;\n    cout << \" \" << t->key;\n    preorder(t->left);\n    preorder(t->right);\n}\nint main() {\n    node* root=NULL;\n    int n,key,pri;\n    string s;\n\n    cin >> n;\n    for(int i=0; i<n; i++) {\n        cin >> s;\n        if(s == \"insert\") {\n            cin >> key >> pri;\n            root = insert(root, key, pri);\n        }\n        else if(s == \"delete\") {\n            cin >> key;\n            root = erase(root, key);\n        }\n        else if(s == \"find\") {\n            cin >> key;\n            find(root, key);\n        }\n        else {\n            inorder(root);\n            cout << endl;\n            preorder(root);\n            cout << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\nusing namespace std;\n\ntypedef struct Node {\n  int key;\n  int priority;\n  struct Node* right;\n  struct Node* left;\n} Node_t;\n\n//Node_t* Tree;\n\n///////////////////////////////////////////////////////////////////////////////////////////\n\n\nNode_t* rightRotate(Node_t* t)\n{\n  Node_t* s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s; // root of the subtree\n}\n\n\nNode_t* leftRotate(Node_t* t)\n{\n  Node_t* s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s; // root of the subtree\n}\n\nNode_t* Node(int k, int p)\n{\n  Node_t* n;\n  n = new Node_t;\n  n -> key = k;\n  n -> priority = p;\n  n -> left = NULL;\n  n -> right = NULL;\n  return n;\n}\n\n\nNode_t* insert(Node_t* t, int key, int priority)\n{\n  //cout << \"k= \" << key << \" p= \" << priority << endl;\n\n  if (t == NULL)\n    {\n      return Node(key, priority);               // 葉に到達したら新しい節点を生成して返す\n\n      if( key == t -> key)\n\treturn t;  \n    }                               // 重複したkeyは無視\n\n  if (key < t -> key) \n    {                              // 左の子へ移動\n      t->left = insert(t->left, key, priority);   // 左の子へのポインタを更新\n\n      if (t->priority < t->left->priority)          // 左の子の方が優先度が高い場合右回転\n\tt = rightRotate(t);\n    }\n\n  else\n    {                                       // 右の子へ移動\n      t->right = insert(t->right, key, priority); // 右の子へのポインタを更新\n\n      if(t->priority < t->right->priority)         // 右の子の方が優先度が高い場合左回転\n\tt = leftRotate(t);\n    }\n  return t;\n\n\n  \n}\n\n\n\nNode_t* erase(Node_t* t, int key)\n{\n  if(t == NULL)\n    return NULL;\n\n  if(key == t->key)\n    {\n      if(t->left == NULL && t->right == NULL )\n\treturn NULL;\n    \n\n      else if (t->left == NULL)\n\tt = leftRotate(t);\n\n      else if (t->right == NULL)\n\tt = rightRotate(t);\n\n      else\n\t{\n\t  if(t->left->priority > t->right->priority)\n\t    t = rightRotate(t);\n\n\t  else\n\t    t = leftRotate(t);\n\t}\n\n      return erase(t,key);\n\n    }\n\n  if(key < t->key)\n    t->left = erase(t->left,key);\n\n  else\n    t->right = erase(t->right,key);\n\n  return t;\n}\n\n\n\nvoid trace_inorder( Node_t *root ) \n{\n  if (root == NULL)\n    {\n      return;\n    }\n  trace_inorder( root->left ); // 左部分木を探索\n  cout << \" \"<< root -> key; // この部分木の根の記号を出力\n  trace_inorder( root->right ); // 右部分木を探索\n}\n\n\nvoid trace_preorder( Node_t *root ) \n{\n  if (root == NULL)\n    {\n      return;\n    }\n  cout << \" \" << root -> key; // この部分木の根の記号を出力\n  trace_preorder( root->left ); // 左部分木を探索\n  trace_preorder( root->right ); // 右部分木を探索\n} \n\n\nvoid print(Node_t* T)\n{\n  //cout << \"print\" << endl;\n  trace_inorder(T);\n  cout << endl;\n  trace_preorder(T);\n  cout << endl;\n}\n\nvoid find(Node_t* T, int k)\n{\n  //cout << \"find \" << k <<endl;\n  while (T != NULL) \n    {\n\n      if (T -> key == k)\n\t{\n\tcout << \"yes\"<<endl;\n\treturn;\n\t}\n\n      else if (k < T -> key)\n\tT = T -> left;\n      else\n\tT = T -> right;\n    }\n  cout << \"no\" << endl;\n}\n\n\n\nint main()\n{\n  int qnum;\n  cin >> qnum;\n  //cout << \"q= \" << qnum << endl;\n\n  int i, k ,p;\n  string s;\n  Node_t* Tree=NULL;\n  for(i=0; i<qnum; i++)\n    {\n      cin >> s;\n\n      if(s == \"insert\")\n\t{\n\t  cin >> k >> p;\n\t  Tree = insert(Tree,k,p);\n\t  // cout << \"hello\" << endl;\n\t}\n\n      else if(s == \"print\")\n\t{\n\t  print(Tree);\n\t}\n\n      else if(s == \"find\")\n\t{\n\t  cin >> k;\n\t  find(Tree,k);\n\t}\n      else if(s == \"delete\")\n\t{\n\t  cin >> k;\n\t  Tree = erase(Tree,k);\n\t  //print(Tree);\n\t  //cout << k <<endl;\n\t}\n\n      else \n\tcout << \"error\" <<endl;\n    }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\nusing namespace std;\n\ntypedef struct Node {\n  int key,priority;\n  struct Node* right;\n  struct Node* left;\n} Node_t;\n\nNode_t* rightRotate(Node_t* t){\n  Node_t* s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\n\n\nNode_t* leftRotate(Node_t* t){\n  Node_t* s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\n\nNode_t* Node(int k, int p){\n  Node_t* n;\n  n = new Node_t;\n  n -> key = k;\n  n -> priority = p;\n  n -> left = NULL;\n  n -> right = NULL;\n  return n;\n}\n\n\nNode_t* insert(Node_t* t, int key, int priority){\n\n\n  if (t == NULL){\n      return Node(key, priority);\n    }\n  if( key == t -> key)return t;\n  if (key < t -> key){\n      t->left = insert(t->left, key, priority);\n      if (t->priority < t->left->priority)\n\t     t = rightRotate(t);\n     }\n\n  else{\n      t->right = insert(t->right, key, priority);\n      if(t->priority < t->right->priority)\n\t     t = leftRotate(t);\n     }\n  return t;\n}\n\n\n\nNode_t* erase(Node_t* t, int key){\n  if(t == NULL)\n    return NULL;\n\n  if(key == t->key){\n      if(t->left == NULL && t->right == NULL )\n\treturn NULL;\n\n\n      else if (t->left == NULL)\n\tt = leftRotate(t);\n\n      else if (t->right == NULL)\n\tt = rightRotate(t);\n\n      else{\n\t  if(t->left->priority > t->right->priority)\n\t    t = rightRotate(t);\n\n\t  else\n\t    t = leftRotate(t);\n\t}\n\n      return erase(t,key);\n\n    }\n\n  if(key < t->key)\n    t->left = erase(t->left,key);\n\n  else\n    t->right = erase(t->right,key);\n\n  return t;\n}\n\n\n\nvoid traceInOrder( Node_t *root ){\n  if (root == NULL){\n      return;\n    }\n  traceInOrder( root->left );\n  cout << \" \"<< root->key;\n  traceInOrder( root->right );\n}\n\n\nvoid tracePreOrder( Node_t *root ){\n  if (root == NULL){\n      return;\n    }\n  cout << \" \" << root->key;\n  tracePreOrder( root->left );\n  tracePreOrder( root->right );\n}\n\n\nvoid print(Node_t* T){\n  traceInOrder(T);\n  cout << endl;\n  tracePreOrder(T);\n  cout << endl;\n}\n\nvoid find(Node_t* T, int k){\n  while (T != NULL){\n      if (T->key == k){\n\tcout << \"yes\"<<endl;\n\treturn;\n\t}\n\n      else if (k < T -> key)\n\tT = T -> left;\n      else\n\tT = T -> right;\n    }\n  cout << \"no\" << endl;\n}\n\n\n\nint main(){\n  int num;\n  cin >> num;\n  int i, k ,p;\n  string s;\n  Node_t* Tree=NULL;\n  for(i=0; i<num; i++){\n      cin >> s;\n\n      if(s == \"insert\"){\n\t  cin >> k >> p;\n\t  Tree = insert(Tree,k,p);\n\t}\n\n      else if(s == \"print\"){\n\t  print(Tree);\n\t}\n\n      else if(s == \"find\"){\n\t  cin >> k;\n\t  find(Tree,k);\n\t}\n      else if(s == \"delete\"){\n\t  cin >> k;\n\t  Tree = erase(Tree,k);\n\t}\n\n      else\n\tcout << \"error\" <<endl;\n    }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct Node {\n  int key;\n  int pri;\n  Node *r, *l;\n};\n\nNode *rrotate(Node *t) {\n  Node *s = t->l;\n  t->l = s->r;\n  s->r = t;\n  return s;\n}\nNode *lrotate(Node *t) {\n  Node *s = t->r;\n  t->r = s->l;\n  s->l = t;\n  return s;\n}\n\nNode *insert(Node *t, int k, int p) {\n  if (t == NULL) {\n    Node *n = new Node();\n    n->key = k;\n    n->pri = p;\n    n->l = n->r = NULL;\n    return n;\n  }\n  if (t->key == k) return t;\n\n  if (k < t->key) {\n    t->l = insert(t->l, k, p);\n    if (t->pri < t->l->pri) t = rrotate(t);\n  } else {\n    t->r = insert(t->r, k, p);\n    if (t->pri < t->r->pri) t = lrotate(t);\n  }\n  return t;\n}\nNode *find(Node *t, int k) {\n  if (t == NULL) return NULL;\n  if (t->key == k) return t;\n  if (k < t->key)\n    return find(t->l, k);\n  else\n    return find(t->r, k);\n}\nNode *dele(Node *t, int k) {\n  if (t == NULL) return NULL;\n  if (k == t->key) {\n    if (t->l == NULL && t->r == NULL) {\n      return NULL;\n    } else if (t->l == NULL) {\n      t = lrotate(t);\n    } else if (t->r == NULL) {\n      t = rrotate(t);\n\n    } else {\n      if (t->l->pri > t->r->pri)\n        t = rrotate(t);\n      else\n        t = lrotate(t);\n    }\n    return dele(t, k);\n  }\n  if (k < t->key)\n    t->l = dele(t->l, k);\n  else\n    t->r = dele(t->r, k);\n  return t;\n}\nvoid printinorder(Node *t) {\n  if (t == NULL) return;\n  printinorder(t->l);\n  cout << \" \" << t->key;\n  printinorder(t->r);\n}\nvoid printpreorder(Node *t) {\n  if (t == NULL) return;\n  cout << \" \" << t->key;\n  printpreorder(t->l);\n  printpreorder(t->r);\n}\nint main() {\n  int m, k, p;\n  string cmd;\n  Node *root=NULL;\n\n  cin >> m;\n  for (int i = 0; i < m; i++) {\n    cin >> cmd;\n    if (cmd[0] == 'i') {\n      cin >> k >> p;\n      root = insert(root, k, p);\n    } else if (cmd[0] == 'f') {\n      cin >> k;\n      if (find(root, k) != NULL)\n        cout << \"yes\" << endl;\n      else\n        cout << \"no\" << endl;\n    } else if (cmd[0] == 'd') {\n      cin >> k;\n      root = dele(root, k);\n    } else {\n      printinorder(root);\n      cout << endl;\n      printpreorder(root);\n      cout << endl;\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string>\n#include <iostream>\n#include <stdlib.h>\n\nusing namespace std;\n\n/*treap*/\n\n//二叉树结构体，\ntypedef struct node {\n\tlong key;\n\tlong pri;\n\tnode * left = NULL;\n\tnode * right = NULL;\n\tnode * parent = NULL;\n}node;\n\nlong m;\nnode * root = NULL;\n\n\n/*left rotate*/\nnode * leftRotate(node * p) {\n\tnode *p1 = p->right;\n\tnode *p2 = p->parent;\n\tif (p1 != NULL) {\n\t\tp->right = p1->left;\n\t\tif (p1->left != NULL) {\n\t\t\tp1->left->parent = p;\n\t\t}\n\t\tp1->left = p;\n\t\tp->parent = p1;\n\t}\n\tif (p2 != NULL) {\n\t\tif (p2->left == p) {\n\t\t\tp2->left = p1;\n\t\t}\n\t\telse {\n\t\t\tp2->right = p1;\n\t\t}\n\t}\n\telse\n\t\troot = p1;\n\tp1->parent = p2;\n\treturn p1;\n}\n\n/*right rotate*/\nnode * rightRotate(node * p) {\n\tnode *p1 = p->left;\n\tnode *p2 = p->parent;\n\tif (p1 != NULL) {\n\t\tp->left = p1->right;\n\t\tif (p1->right != NULL) {\n\t\t\tp1->right->parent = p;\n\t\t}\n\t\tp1->right = p;\n\t\tp->parent = p1;\n\t}\n\tif (p2 != NULL) {\n\t\tif (p2->left == p) {\n\t\t\tp2->left = p1;\n\t\t}\n\t\telse {\n\t\t\tp2->right = p1;\n\t\t}\n\t}\n\telse\n\t\troot = p1;\n\tp1->parent = p2;\n\treturn p1;\n}\n\n/*插入函数*/\nvoid insert(long key, long pri) {\n\tnode *p1;\n\tp1 = (node *)malloc(sizeof(node));\n\tp1->key = key;\n\tp1->pri = pri;\n\tp1->left = p1->right = p1->parent = NULL;\n\n\tnode *p2 = root;\n\tnode *p3 = p2;\n\tif (p2 == NULL) {\n\t\troot = p1;\n\t\treturn;\n\t}\n\t\n\t/*找到需要插入的位置*/\n\twhile (p2 != NULL) {\n\t\tp3 = p2;\n\t\tif (p1->key < p2->key) {\n\t\t\tp2 = p2->left;\n\t\t}\n\t\telse if (p1->key > p2->key) {\n\t\t\tp2 = p2->right;\n\t\t}\n\t}\n\n\tif (p2 == NULL) {\n\t\tif (p3->key < p1->key) {\n\t\t\tp3->right = p1;\n\t\t}\n\t\telse\n\t\t\tp3->left = p1;\n\t\tp1->parent = p3;\n\t}\n\n\t/*对treap进行旋转处理*/\n\twhile (1) {\n\t\tp3 = p1->parent;\n\t\tif (p3 != NULL&&p1->pri > p3->pri) {\n\t\t\tif (p1 == p3->left) {\n\t\t\t\tp1 = rightRotate(p3);\n\t\t\t}\n\t\t\telse if (p1 == p3->right) {\n\t\t\t\tp1 = leftRotate(p3);\n\t\t\t}\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\telse \n\t\t\tbreak;\n\t}\n\t\n\treturn;\n}\n\nvoid printinorder(node * p) {\n\tif (p == NULL) {\n\t\treturn;\n\t}\n\tif (p->left != NULL) {\n\t\tprintinorder(p->left);\n\t}\n\tcout << ' ' << p->key;\n\tif (p->right != NULL) {\n\t\tprintinorder(p->right);\n\t}\n}\n\nvoid printpreorder(node * p) {\n\tif (p == NULL) {\n\t\treturn;\n\t}\n\tcout << ' '<< p->key ;\n\tif (p->left != NULL) {\n\t\tprintpreorder(p->left);\n\t}\n\tif (p->right != NULL) {\n\t\tprintpreorder(p->right);\n\t}\n}\n\nnode * findnext(node * p) {\n\tnode * p1 = p->right;\n\twhile (p1->left != NULL) {\n\t\tp1 = p1->left;\n\t}\n\treturn p1;\n}\n\nvoid deletes(node * p) {\n\tnode *p1; \n\tif (p == NULL) {\n\t\treturn;\n\t}\n\twhile (p->left != NULL || p->right != NULL) {\n\t\tif (p->left == NULL) {\n\t\t\tp = leftRotate(p);\n\t\t\tp = p->left;\n\t\t}\n\t\telse if (p->right == NULL) {\n\t\t\tp = rightRotate(p);\n\t\t\tp = p->right;\n\t\t}\n\t\telse if (p->left->pri < p->right->pri) {\n\t\t\tp = leftRotate(p);\n\t\t\tp = p->left;\n\t\t}\n\t\telse if (p->left->pri > p->right->pri) {\n\t\t\tp = rightRotate(p);\n\t\t\tp = p->right;\n\t\t}\n\t}\n\tp1 = p->parent;\n\tif (p1 != NULL) {\n\t\tif (p1->left == p)\n\t\t\tp1->left = NULL;\n\t\telse\n\t\t\tp1->right = NULL;\n\t\tfree(p);\n\t\treturn;\n\t}\n\telse {\n\t\troot = NULL;\n\t}\n\treturn;\n}\n\nnode * finds(long k, int ss) {\n\tnode * p = root;\n\twhile (p != NULL && p->key != k) {\n\t\tif (p->key < k) {\n\t\t\tp = p->right;\n\t\t}\n\t\telse {\n\t\t\tp = p->left;\n\t\t}\n\t}\n\tif (p == NULL&&ss==1) {\n\t\tcout << \"no\" << endl;\n\t}\n\telse if(ss == 1){\n\t\tcout << \"yes\" << endl;\n\t}\n\treturn p;\n}\n\nint main() {\n\tcin >> m;\n\tstring com;\n\tlong k, p;\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> com;\n\t\tswitch (com[0]) {\n\t\tcase 'f': cin >> k; finds(k, 1); break;\n\t\tcase 'i': cin >> k >> p; insert(k, p); break;\n\t\tcase 'd': cin >> k; deletes(finds(k, 0)); break;\n\t\tcase 'p': printinorder(root); cout << endl; printpreorder(root); cout << endl; break;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n\ntypedef struct _node {\n\tint key;\n\tint priority;\n\tstruct _node * left;\n\tstruct _node * right;\n\tstruct _node * parent;\n} node;\n\nnode * left_rotate(node * t) {\n\tnode * new_t = t->right;\n\tt->right = new_t->left;\n\tif (t->right != NULL) {\n\t\tt->right->parent = t;\n\t}\n\tnew_t->left = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * right_rotate(node * t) {\n\tnode * new_t = t->left;\n\tt->left = new_t->right;\n\tif (t->left != NULL) {\n\t\tt->left->parent = t;\n\t}\n\tnew_t->right = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * create_node(int key, int priority) {\n\tnode * p;\n\tp = (node *)malloc(sizeof(node));\n\tp->key = key;\n\tp->priority = priority;\n\tp->left = NULL;\n\tp->right = NULL;\n\tp->parent = NULL;\n\treturn p;\n}\n\nnode * insert(node * t, int key, int priority) {\n\tif (t == NULL) {\n\t\tnode * p = create_node(key, priority);\n\t\treturn p;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->left = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->left, key, priority);\n\t\t}\n\t\t\t\t\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\telse if (key > t->key) {\n\t\tif (t->right == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->right = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->right, key, priority);\n\t\t}\n\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\t\n\treturn t;\n}\n\nnode * delete_node(node * t, int key) {\n\tif (key == t->key) {\n\t\tif (t->left == NULL && t->right == NULL) {\n\t\t\tif (t->parent->left == t) {\n\t\t\t\tt->parent->left = NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt->parent->right = NULL;\n\t\t\t}\n\t\t\tfree(t);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (t->left == NULL) {\n\t\t\tt = left_rotate(t);\t\n\t\t}\n\t\telse if (t->right == NULL) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse if (t->left->priority > t->right->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\tt = delete_node(t, key);\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete_node(t->left, key);\n\t\treturn t;\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete_node(t->right, key);\n\t\treturn t;\n\t}\n}\n\nint find(node * t, int key) {\n\tif (key == t->key) {\n\t\treturn 1;\n\t}\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->left, key);\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->right, key);\n\t}\n}\n\nvoid print_preorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->left != NULL) {\n\t\tprint_preorder(t->left);\n\t}\n\tif (t->right != NULL) {\n\t\tprint_preorder(t->right);\n\t}\n}\n\nvoid print_inorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tif (t->left != NULL) {\n\t\tprint_inorder(t->left);\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->right != NULL) {\n\t\tprint_inorder(t->right);\n\t}\n}\n\nint main() {\n\tint m;\n\tstd::string buf;\n\tstd::string str;\n\tint k, p;\n\tnode * root = NULL;\n\n\tstd::getline(std::cin, buf);\n\tstd::stringstream ss0(buf);\n\tss0 >> m;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tstd::getline(std::cin, buf);\n\t\tstd::stringstream ss(buf);\n\t\tstd::getline(ss, str, ' ');\n\t\tif (str == \"insert\") {\n\t\t\tss >> k >> p;\n\t\t\t//printf(\"--insert %d %d\\n\", k, p);\n\t\t\troot = insert(root, k, p);\n\t\t}\n\t\telse if (str == \"find\") {\n\t\t\tss >> k;\n\t\t\t//printf(\"--find %d\\n\", k);\n\t\t\tint result = find(root, k);\n\t\t\tif (result == 1) {\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (str ==\"delete\") {\n\t\t\tss >> k;\n\t\t\t//printf(\"--delete %d\\n\", k);\n\t\t\troot = delete_node(root, k);\n\t\t}\n\t\telse if (str == \"print\") {\n\t\t\t//printf(\"--print\\n\");\n\t\t\tprint_inorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tprint_preorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"error\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BUF_LENGTH 100\n#define OPE_LENGTH 10\n\ntypedef struct _node {\n\tint key;\n\tint priority;\n\tstruct _node * left;\n\tstruct _node * right;\n\tstruct _node * parent;\n} node;\n\nnode * left_rotate(node * t) {\n\tnode * new_t = t->right;\n\tt->right = new_t->left;\n\tnew_t->left = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * right_rotate(node * t) {\n\tnode * new_t = t->left;\n\tt->left = new_t->right;\n\tnew_t->right = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * create_node(int key, int priority) {\n\tnode * p;\n\tp = (node *)malloc(sizeof(node));\n\tp->key = key;\n\tp->priority = priority;\n\tp->left = NULL;\n\tp->right = NULL;\n\tp->parent = NULL;\n\treturn p;\n}\n\nnode * insert(node * t, int key, int priority) {\n\tif (t == NULL) {\n\t\tnode * p = create_node(key, priority);\n\t\treturn p;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->left = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->left, key, priority);\n\t\t}\n\t\t\t\t\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\telse if (key > t->key) {\n\t\tif (t->right == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->right = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->right, key, priority);\n\t\t}\n\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\t\n\treturn t;\n}\n\nnode * delete_node(node * t, int key) {\n\tif (key == t->key) {\n\t\tif (t->left == NULL && t->right == NULL) {\n\t\t\tif (t->parent->left == t) {\n\t\t\t\tt->parent->left = NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt->parent->right = NULL;\n\t\t\t}\n\t\t\tfree(t);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (t->left == NULL) {\n\t\t\tt = left_rotate(t);\t\n\t\t}\n\t\telse if (t->right == NULL) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse if (t->left->priority > t->right->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\tt = delete_node(t, key);\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete_node(t->left, key);\n\t\treturn t;\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete_node(t->right, key);\n\t\treturn t;\n\t}\n}\n\nint find(node * t, int key) {\n\tif (key == t->key) {\n\t\treturn 1;\n\t}\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->left, key);\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->right, key);\n\t}\n}\n\nvoid print_preorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->left != NULL) {\n\t\tprint_preorder(t->left);\n\t}\n\tif (t->right != NULL) {\n\t\tprint_preorder(t->right);\n\t}\n}\n\nvoid print_inorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tif (t->left != NULL) {\n\t\tprint_inorder(t->left);\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->right != NULL) {\n\t\tprint_inorder(t->right);\n\t}\n}\n\nint main() {\n\tint m;\n\tchar buf[BUF_LENGTH];\n\tchar * str;\n\tint k, p;\n\tnode * root = NULL;\n\n\tscanf_s(\"%d \", &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfgets(buf, BUF_LENGTH, stdin);\n\t\tchar * context;\n\t\tstr = strtok_s(buf, \" \\n\", &context);\n\t\tif (strcmp(str, \"insert\") == 0) {\n\t\t\tstr = strtok_s(NULL, \" \\n\", &context);\n\t\t\tk = atoi(str);\n\t\t\tstr = strtok_s(NULL, \" \\n\", &context);\n\t\t\tp = atoi(str);\n\t\t\t//printf(\"--insert %d %d\\n\", k, p);\n\t\t\troot = insert(root, k, p);\n\t\t}\n\t\telse if (strcmp(str, \"find\") == 0) {\n\t\t\tstr = strtok_s(NULL, \" \\n\", &context);\n\t\t\tk = atoi(str);\n\t\t\t//printf(\"--find %d\\n\", k);\n\t\t\tint result = find(root, k);\n\t\t\tif (result == 1) {\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (strcmp(str, \"delete\") == 0) {\n\t\t\tstr = strtok_s(NULL, \" \\n\", &context);\n\t\t\tk = atoi(str);\n\t\t\t//printf(\"--delete %d\\n\", k);\n\t\t\troot = delete_node(root, k);\n\t\t}\n\t\telse if (strcmp(str, \"print\") == 0) {\n\t\t\t//printf(\"--print\\n\");\n\t\t\tprint_inorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tprint_preorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse {\n\t\t\t//printf(\"error\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nusing namespace std;\n\nstruct Node {\n\tint key, priority;\n\tNode *left, *right;\n};\n\nclass Treap {\nprivate:\n\tNode *root = NULL;\n\tNode* rightRotate(Node*);\n\tNode* leftRotate(Node*);\n\tNode* insert_rec(Node*, int, int);\n\tNode* delete_rec(Node*, int);\n\tNode* _delete(Node*, int);\n\tvoid print_in(Node*);\n\tvoid print_pre(Node*);\n\tvoid postorder_delete(Node*);\npublic:\n\t~Treap();\n\tvoid Insert(int, int);\n\tvoid Delete(int);\n\tvoid Find(int);\n\tvoid Print();\n};\n\nNode* Treap::rightRotate(Node* t)\n{\n\tNode *s;\n\ts = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\n\nNode* Treap::leftRotate(Node* t)\n{\n\tNode *s;\n\ts = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\n\nvoid Treap::Insert(int key, int priority)\n{\n\tthis->root = this->insert_rec(this->root, key, priority);\n}\n\nNode* Treap::insert_rec(Node* t, int key, int priority)\n{\n\tif (t == NULL)\n\t\treturn new Node{ key, priority, NULL, NULL};\n\tif (key == t->key)\n\t\treturn t;\n\n\tif (key < t->key)\n\t{\n\t\tt->left = this->insert_rec(t->left, key, priority);\n\t\tif (t->priority < t->left->priority)\n\t\t\tt = this->rightRotate(t);\n\t}\n\telse\n\t{\n\t\tt->right = this->insert_rec(t->right, key, priority);\n\t\tif (t->priority < t->right->priority)\n\t\t\tt = this->leftRotate(t);\n\t}\n\n\treturn t;\n}\n\nvoid Treap::Delete(int key)\n{\n\tthis->root = this->delete_rec(this->root, key);\n}\n\nNode* Treap::delete_rec(Node* t, int key)\n{\n\tif (t == NULL)\n\t\treturn NULL;\n\tif (key < t->key)\n\t\tt->left = this->delete_rec(t->left, key);\n\telse if (key > t->key)\n\t\tt->right = this->delete_rec(t->right, key);\n\telse\n\t\treturn this->_delete(t, key);\n\treturn t;\n}\n\nNode* Treap::_delete(Node* t, int key)\n{\n\tif (t->left == NULL && t->right == NULL)\n\t{\n\t\tdelete t;\n\t\treturn NULL;\n\t}\n\telse if (t->left == NULL)\n\t\tt = this->leftRotate(t);\n\telse if (t->right == NULL)\n\t\tt = this->rightRotate(t);\n\telse\n\t{\n\t\tif (t->left->priority > t->right->priority)\n\t\t\tt = this->rightRotate(t);\n\t\telse\n\t\t\tt = this->leftRotate(t);\n\t}\n\treturn this->delete_rec(t, key);\n}\n\nvoid Treap::Find(int key)\n{\n\tfor (Node* finder = this->root; finder != NULL; \n\t\tkey < finder->key ? finder = finder->left : finder = finder->right)\n\t\tif (finder->key == key)\n\t\t{\n\t\t\tprintf(\"yes\\n\");\n\t\t\treturn;\n\t\t}\n\tprintf(\"no\\n\");\n\treturn;\n}\n\nvoid Treap::Print()\n{\n\tthis->print_in(this->root);\n\tprintf(\"\\n\");\n\tthis->print_pre(this->root);\n\tprintf(\"\\n\");\n}\n\nvoid Treap::print_in(Node* subroot)\n{\n\tif (subroot)\n\t{\n\t\tthis->print_in(subroot->left);\n\t\tprintf(\" %d\", subroot->key);\n\t\tthis->print_in(subroot->right);\n\t}\n}\n\nvoid Treap::print_pre(Node* subroot)\n{\n\tif (subroot)\n\t{\n\t\tprintf(\" %d\", subroot->key);\n\t\tthis->print_pre(subroot->left);\n\t\tthis->print_pre(subroot->right);\n\t}\n}\n\nTreap::~Treap()\n{\n\tthis->postorder_delete(this->root);\n}\n\nvoid Treap::postorder_delete(Node* subroot)\n{\n\tif (subroot)\n\t{\n\t\tthis->postorder_delete(subroot->left);\n\t\tthis->postorder_delete(subroot->right);\n\t\tdelete subroot;\n\t}\n}\n\nint main()\n{\n\tint m, key, priority;\n\tchar command[16];\n\tTreap treap;\n\tscanf(\"%d\", &m);\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tscanf(\"%s\", command);\n\t\tif (command[0] == 'i')\n\t\t{\n\t\t\tscanf(\"%d%d\", &key, &priority);\n\t\t\ttreap.Insert(key, priority);\n\t\t}\n\t\telse if (command[0] == 'f')\n\t\t{\n\t\t\tscanf(\"%d\", &key);\n\t\t\ttreap.Find(key);\n\t\t}\n\t\telse if (command[0] == 'd')\n\t\t{\n\t\t\tscanf(\"%d\", &key);\n\t\t\ttreap.Delete(key);\n\t\t}\n\t\telse\n\t\t\ttreap.Print();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\nstruct TreapNode{\n    unsigned int key, pri; // key, priority\n    TreapNode *left, *right; // left and right children\n    //TreapNode(unsigned int k, unsigned int p) : key(k), pri(p), left(nullptr), right(nullptr) {}\n    TreapNode(){}\n};\n\nTreapNode* newNode(unsigned int k, unsigned int p) {\n    TreapNode* node_ptr = new TreapNode;\n    node_ptr->key = k; node_ptr->pri = p;\n    node_ptr->left = node_ptr->right = nullptr;\n    return node_ptr;\n}\n\nvoid getin(string fn);\nvoid getin();\nTreapNode* lrotate(TreapNode* node);\nTreapNode* rrotate(TreapNode* node);\nTreapNode* insertNode(TreapNode* root, unsigned int k, unsigned int p);\nvoid findNode(TreapNode* node, unsigned int k);\nTreapNode* deleteNode(TreapNode* node, unsigned int k);\nvoid inorder(TreapNode* root);\nvoid preorder(TreapNode* root);\n\nint main()\n{\n    //getin(\"in.txt\");\n    getin();\n    return 0;\n}\n\nvoid getin() {\n    TreapNode* root = new TreapNode;\n    root = nullptr; // null pointer\n    string s;\n    int m;\n    unsigned int k, p;\n    cin >> m;\n    for (int i = 0; i < m; i++) {\n        cin >> s;\n        if (s.compare(\"insert\") == 0){\n            cin >> k >> p;\n            root =  insertNode(root, k,p);\n        } else if (s.compare(\"find\") == 0) {\n            cin >> k;\n            findNode(root, k);\n        } else if (s.compare(\"delete\") == 0) {\n            cin >> k;\n            root = deleteNode(root, k);\n        } else if (s.compare(\"print\") == 0) {\n            inorder(root);\n            cout << endl;\n            preorder(root);\n            cout << endl;\n        }\n    }\n}\n\nvoid getin(string fn) {\n    ifstream infile(fn);\n    TreapNode* root = new TreapNode;\n    root = nullptr; // null pointer\n    string s;\n    int m;\n    unsigned int k, p;\n    infile >> m;\n    for (int i = 0; i < m; i++) {\n        infile >> s;\n        if (s.compare(\"insert\") == 0){\n            infile >> k >> p;\n            root =  insertNode(root, k,p);\n            //printNode(root);\n            //inorder(root);\n        } else if (s.compare(\"find\") == 0) {\n            infile >> k;\n            findNode(root, k);\n        } else if (s.compare(\"delete\") == 0) {\n            infile >> k;\n            root = deleteNode(root, k);\n        } else if (s.compare(\"print\") == 0) {\n            inorder(root);\n            cout << endl;\n            preorder(root);\n            cout << endl;\n        }\n    }\n    infile.close();\n}\n\nTreapNode* lrotate(TreapNode* x){\n    TreapNode* y = x->right;\n    x->right = y->left;\n    y->left = x;\n    return y;\n}\nTreapNode* rrotate(TreapNode* y){\n    TreapNode* x = y->left;\n    y->left = x-> right;\n    x-> right = y;\n    return x;\n}\n\nTreapNode* insertNode(TreapNode* node, unsigned int key, unsigned int pri) {\n    if (node == nullptr) {      // when reach a left node\n        return newNode(key,pri);    // create a new node\n    }\n\n    if (key == node->key) {\n        // ignore duplicated keys\n        return node;\n    }\n\n    if (key < node->key) {\n        // move to the left child\n        // then, update the pointer to the left child\n        node->left = insertNode(node->left, key, pri);\n        // right rotate if the left child has higher priority\n        if (node->pri < node->left->pri) {\n            node = rrotate(node);\n        }\n    } else { // key > node.key\n        // move to the right child\n        // then, update the pointer to the right child\n        node->right = insertNode(node->right, key, pri);\n        // left rotate if the right child has higher priority\n        if (node->pri < node->right->pri) {\n            node = lrotate(node);\n        }\n    }\n    return node;\n}\n\nvoid findNode(TreapNode* node, unsigned int key) {\n    if (node == nullptr) {cout << \"no\\n\"; return;} // already reach a child of a left node but find nothing\n    if (key == node->key) {cout << \"yes\\n\"; return;} // find out!\n    if (key < node->key) {findNode(node->left, key);}\n    else {findNode(node->right, key);}\n}\n\nTreapNode* deleteNode(TreapNode* node, unsigned int key) {\n    if (node == nullptr) { // the treap does not contain the key\n        return nullptr;\n    }\n    if (key == node->key) { // the current node is the target node\n        // the target node is a leaf node\n        if ((node->left == nullptr)&&(node->right==nullptr)) {\n            delete(node);\n            return nullptr;\n        }\n        // the target node has a right child but no left child\n        else if (node->left==nullptr) {\n            node = lrotate(node);\n        }\n        // the target node has a left child but no right child\n        else if (node->right==nullptr) {\n            node = rrotate(node);\n        }\n        else {  // the target node has both left and right children\n            // pull up the child with higher priority\n            if (node->right->pri > node->left->pri) {\n                node = lrotate(node);\n            } else {\n                node = rrotate(node);\n            }\n        }\n        return deleteNode(node,key);\n    }\n    // search the target node recursively\n    if (key < node->key) {\n        node->left = deleteNode(node->left,key);\n    } else {\n        node->right = deleteNode(node->right,key);\n    }\n    return node;\n}\n\nvoid inorder(TreapNode* root) {\n    if (root != nullptr) {\n        inorder(root->left);\n        cout << \" \" << root->key;\n        inorder(root->right);\n    }\n}\n\nvoid preorder(TreapNode* root) {\n    if (root != nullptr) {\n        cout << \" \" << root->key;\n        preorder(root->left);\n        preorder(root->right);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef vector<ld> vd;\ntypedef vector<ll> vll;\ntypedef vector<string> vstr;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<pair<ll, ll>> vpll;\ntypedef priority_queue<ll, vector<ll>, greater<ll>> spqll;  // 小さい順に取り出し\ntypedef priority_queue<ll, vector<ll>, less<ll>> bpqll;     // 大きい順に取り出し\n\n#define REP(i, n) for (ll i = 0; i < (ll)(n); i++)\n#define FOR(i, a, b) for (ll i = (ll)a; i < (ll)b; i++)\n#define IREP(i, v) for (auto i = (v).begin(); i != (v).end(); i++)\n#define FI first\n#define SE second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define TS to_string\n#define NP next_permutation\n#define ALL(v) (v).begin(), (v).end()\n#define SZ(x) (ll) x.size()\n#define SP(x) setprecision((ll)x)\n\n\nll INF = 1e9;\nll MOD = 1000000007;\nll LINF = 1e18;\nld EPS = 1e-9;\nld PI = M_PI;\nvll dx = {1, 0, -1, 0, 1, -1, -1, 1};\nvll dy = {0, 1, 0, -1, 1, 1, -1, -1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a;} //最大公約数\nll lcm(ll a, ll b) { return a / gcd(a, b) * b;}     //最小公倍数\n\nvoid yes(){ cout << \"yes\" << endl;}\nvoid no(){ cout << \"no\" << endl;}\n\n//-----------------------------------------\ntemplate<class T>\nclass Treap{\n  private:\n    struct Node{\n      T key; \n      int pri;\n      Node *lef, *rig;\n    };\n    Node *NIL, *root;\n  public:\n    Treap(){\n      NIL = NULL;\n      root = NULL;\n    }\n\n    Node *create(T key, int pri, Node* l, Node* r){\n      Node *newn = (Node *)malloc(sizeof(Node));\n      newn->key = key;\n      newn->pri = pri;\n      newn->lef = l;\n      newn->rig = r;\n      return newn;\n    }\n\n    Node *right_rotate(Node *t){\n      Node *s = t->lef;\n      t->lef = s->rig;\n      s->rig = t;\n      return s;\n    }\n\n    Node *left_rotate(Node *t){\n      Node *s = t->rig;\n      t->rig = s->lef;\n      s->lef = t;\n      return s;\n    }\n\n    Node *insert_node(Node *t, T key, int pri){\n      if(t == NIL) return create(key, pri, NIL, NIL);\n      if(key == t->key) return t;\n\n      if(key < t->key){\n        t->lef = insert_node(t->lef, key, pri);\n        if(t->pri < t->lef->pri){\n          t = right_rotate(t);\n        }\n      }\n      else{\n        t->rig = insert_node(t->rig, key, pri);\n        if(t->pri < t->rig->pri){\n          t = left_rotate(t);\n        }\n      }\n      return t;\n    }\n\n    void insert(T key, int pri){\n      root = insert_node(root, key, pri);\n    }\n\n    Node *find_node(Node *t, T k){\n      if(t == NIL) return NIL;\n      if(t->key == k) return t;\n      if(k < t->key) return find_node(t->lef,k);\n      else return find_node(t->rig,k);\n    }\n\n    bool find(T k){\n      Node *t = find_node(root,k);\n      if(t == NIL) return false;\n      else return true;\n    }\n\n    Node *remove_node(Node *t, T key){\n      if(t == NIL) return NIL;\n      if(key < t->key){\n        t->lef = remove_node(t->lef,key);\n      }\n      else if(key > t->key){\n        t->rig = remove_node(t->rig,key);\n      }\n      else{\n        return remove_rot(t,key);\n      }\n      return t;\n    }\n\n    Node *remove_rot(Node *t, T key){\n      if(t->lef == NIL && t->rig == NIL){\n        return NIL;\n      }\n      else if(t->lef == NIL){\n        t = left_rotate(t);\n      }\n      else if(t->rig == NIL){\n        t = right_rotate(t);\n      }\n      else{\n        if(t->lef->pri < t->rig->pri){\n          t = left_rotate(t);\n        }\n        else{\n          t = right_rotate(t);\n        }\n      }\n      return remove_node(t,key);\n    }\n\n    void remove(T key){\n      root = remove_node(root,key);\n    }\n\n\n    void pmid(Node *t){\n      if(t == NIL) return;\n      pmid(t->lef);\n      cout << \" \" << t->key;\n      pmid(t->rig);\n    }\n\n    void ppre(Node *t){\n      if(t == NIL) return;\n      cout << \" \" << t->key;\n      ppre(t->lef);\n      ppre(t->rig);\n    }\n\n    void pr(){\n      pmid(root);\n      cout <<endl;\n      ppre(root);\n      cout <<endl;\n    }\n};\n//-----------------------------------------\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  Treap<int> tree;\n  REP(i,n){\n    string s;\n    cin >> s;\n    if(s[0] == 'i'){\n      int a, b;\n      cin >> a >> b;\n      tree.insert(a,b);\n    }\n    else if(s[0] == 'f'){\n      int a;\n      cin >> a;\n      if(tree.find(a)) yes();\n      else no();\n    }\n    else if(s[0] == 'd'){\n      int a;\n      cin >> a;\n      tree.remove(a);\n    }\n    else{\n      tree.pr();\n    }\n  }\n\n\n\n  return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = 1LL<<55;\nconst Int mod = (1e9)+7;\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nclass Treap{\npublic:\n  struct Node{\n    int key;\n    int priority;\n    Node *parent, *left, *right;\n   \n    Node():key(-1), priority(-1), parent(nullptr), left(nullptr), right(nullptr){};\n    Node(int key,int priority,Node *parent):\n      key(key), priority(priority), parent(parent), left(nullptr), right(nullptr){};\n\n    Node(int key,int priority, Node *parent,Node *left,Node *right):\n      key(key), priority(priority), parent(parent), left(left), right(right){}\n  };\n  \n  int n;\n  Node *root;\n  Treap():n(0){}\n  \n  \n  Node* rightRotate(Node *y){\n    Node *x = y->left;\n    y->left = x->right;\n    x->right = y;\n\n    x->parent = y->parent;\n    y->parent = x;\n    \n    return x;\n  }\n\n  Node* leftRotate(Node *x){\n    Node *y = x->right;\n    x->right = y->left;\n    y->left = x;\n    \n    y->parent = x->parent;\n    x->parent = y;\n\n    return y;\n  }\n\n  Node* insert(Node *t,int key,int priority, Node *parent = nullptr){\n    if(t == nullptr){n++; return new Node(key, priority, parent);}\n    \n    if(key == t->key) return t;\n    \n    if(key < t->key){\n      t->left = insert(t->left, key, priority,  t);\n      if( t->priority < t->left->priority ) t = rightRotate(t);\n    }\n    else{\n      t->right = insert(t->right, key, priority, t);\n      if( t->priority < t->right->priority ) t = leftRotate(t);\n    }\n    return t;\n  }\n\n  Node* insert(int key,int priority){\n    if(n == 0){n++; return root = new Node(key, priority, nullptr);}\n    return root = insert(root, key, priority);\n  }\n\n  Node* erase(Node *t,int key){\n    if( t == nullptr) return nullptr;\n    if(key == t->key) return _erase(t, key);\n    \n    if(key < t->key ) t->left = erase(t->left, key);\n    else if(key > t->key ) t->right = erase(t->right, key);\n    return t;\n  }\n  \n  Node* _erase(Node *t,int key){\n    if(t->left == nullptr && t->right == nullptr) {\n      delete t;\n      return nullptr;\n    }\n    \n    if(t->left == nullptr) t = leftRotate(t);\n    else if(t->right == nullptr) t = rightRotate(t);\n    else {\n      if( t->left->priority > t->right->priority ) t = rightRotate(t);\n      else t = leftRotate(t);\n    }\n    \n    return erase(t, key);\n  }\n\n  void erase(int key){\n    root = erase(root, key);\n  }\n\n  Node* find(Node *t,int key){\n    if( t == nullptr) return nullptr;\n    if(key < t->key ) return find(t->left, key);\n    if(key > t->key ) return find(t->right, key);\n    return t;\n  }\n\n  Node* find(int key){return find(root, key);}\n\n  \n  void print(Node* t,int a=0,int b=0,int c=0){\n    if(t == nullptr) return;\n    if(a) cout<<\" \"<<(t->key);\n    if(t->left != nullptr) print(t->left, a, b, c);\n    if(b) cout<<\" \"<<(t->key);\n    \n    if(t->right != nullptr) print(t->right, a, b, c);\n    if(c) cout<<\" \"<<(t->key);\n  }\n  \n  void print(){\n    print(root, 0, 1, 0);cout<<endl;\n    print(root, 1, 0, 0);cout<<endl;\n  }\n    \n};\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  \n  Treap T;\n  \n  int n;\n  cin>>n;\n  while(n--){\n    string str;\n    cin>>str;\n    if(str == \"insert\"){\n      int key, priority;\n      cin>>key>>priority;\n      T.insert(key, priority);\n    }\n    \n    if(str == \"find\"){\n      int key;\n      cin>>key;\n      int ans = T.find(key) != nullptr;\n      cout<<(ans?\"yes\":\"no\")<<endl;\n    }\n    \n    if(str == \"delete\"){\n      int key;\n      cin>>key;\n      T.erase(key);\n    }\n    if(str == \"print\"){\n      T.print();\n    }\n  }\n  \n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\nconst int MAX = 500001;\nconst int NIL = -1;\nstruct Node {\n\tint key, priority;\n\tNode* parent, * left, * right;\n};\nstruct Node T[MAX];\nNode* head = NULL;\nNode* _deleteNode(Node* t, int key);\n\nNode* rightRotate(Node* t)\n{\n\tNode* s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\n\nNode* leftRotate(Node* t)\n{\n\tNode* s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\n\nNode* getMinimun(Node* x)\n{\n\twhile (x->left != NULL)\n\t\tx = x->left;\n\treturn x;\n}\n\nNode* Find(Node* x, int k)\n{\n\twhile (x != NULL && k != x->key) {\n\t\tif (k < x->key)\n\t\t\tx = x->left;\n\t\telse\n\t\t\tx = x->right;\n\t}\n\treturn x;\n}\n\nNode* getSuccessor(Node* x)\n{\n\tif (x->right != NULL)\n\t\treturn getMinimun(x->right);\n\tNode* y = x->parent;\n\twhile (y != NULL && x == y->right) {\n\t\tx = y;\n\t\ty = y->parent;\n\t}\n\treturn y;\n}\n\nvoid preParse(Node* u)\n{\n\tif (u == NULL)\n\t\treturn;\n\tcout << \" \" << u->key;\n\tpreParse(u->left);\n\tpreParse(u->right);\n}\n\nvoid inParse(Node* u)\n{\n\tif (u == NULL)\n\t\treturn;\n\tinParse(u->left);\n\tcout << \" \" << u->key;\n\tinParse(u->right);\n}\n\nNode* insert(Node* t, int key, int priority)\n{\n\tNode* z = new(Node);\n\tz->key = key;\n\tz->priority = priority;\n\tz->left = z->parent = z->right = NULL;\n\tif (t == NULL) {\n\t\treturn z;\n\t}\n\tif (key == t->key)\n\t\treturn t;\n\telse if (key < t->key) {\n\t\tt->left = insert(t->left, key, priority);\n\t\tif (t->priority < t->left->priority)\n\t\t\tt = rightRotate(t);\n\t}\n\telse {\n\t\tt->right = insert(t->right, key, priority);\n\t\tif (t->priority < t->right->priority)\n\t\t\tt = leftRotate(t);\n\t}\n\treturn t;\n}\n\nNode* deleteNode(Node* t, int key)\n{\n\tif (t == NULL)\n\t\treturn NULL;\n\tif (key < t->key)\n\t\tt->left = deleteNode(t->left, key);\n\telse if (key > t->key)\n\t\tt->right = deleteNode(t->right, key);\n\telse\n\t\treturn _deleteNode(t, key);\n\treturn t;\n}\n\nint main(void)\n{\n\tint n, key, priority;\n\tchar ss[10];\n\tcin >> n;\n\tmemset(ss, 0, sizeof(ss));\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%s\", ss);\n\t\tif (ss[0] == 'i') {\n\t\t\tcin >> key >> priority;\n\t\t\thead = insert(head, key, priority);\n\t\t}\n\t\telse if (ss[0] == 'f') {\n\t\t\tcin >> key;\n\t\t\tif (Find(head, key))\n\t\t\t\tcout << \"yes\" << endl;\n\t\t\telse\n\t\t\t\tcout << \"no\" << endl;\n\t\t}\n\t\telse if (ss[0] == 'd') {\n\t\t\tcin >> key;\n\t\t\thead = deleteNode(head, key);\n\t\t}\n\t\telse {\n\t\t\tinParse(head);\n\t\t\tcout << endl;\n\t\t\tpreParse(head);\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\nNode* _deleteNode(Node* t, int key)\n{\n\tif (t->left == NULL && t->right == NULL)\n\t\treturn NULL;\n\telse if (t->left == NULL)\n\t\tt = leftRotate(t);\n\telse if (t->right == NULL)\n\t\tt = rightRotate(t);\n\telse {\n\t\tif (t->left->priority > t->right->priority)\n\t\t\tt = rightRotate(t);\n\t\telse\n\t\t\tt = leftRotate(t);\n\t\treturn deleteNode(t, key);\n\t}\n\treturn deleteNode(t, key);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<queue>\nusing namespace std;\n\nstruct Node\n{\n    int data,priority;\n    Node *l,*r;\n};\n\nvoid rightRotate(Node *&p)\n{\n    Node *s=p->l;\n    p->l=s->r;\n    s->r=p;\n    p=s;\n}\n\nvoid leftRotate(Node *&p)\n{\n    Node *s=p->r;\n    p->r=s->l;\n    s->l=p;\n    p=s;\n}\n\nvoid insert_point(Node *&p,int x,int y)\n{\n    if(p==NULL)\n    {\n        p=(Node *)malloc(sizeof(Node));\n        p->data=x;\n        p->priority=y;\n        p->l=p->r=NULL;\n        return;\n    }\n    if(x < p->data)\n    {\n        insert_point(p->l,x,y);\n        if(p->priority < p->l->priority)\n            rightRotate(p);\n    }\n    else\n    {\n        insert_point(p->r,x,y);\n        if(p->priority < p->r->priority)\n            leftRotate(p);\n    }\n}\n\nbool find_point(const Node *p,int x)\n{\n    if(p==NULL)\n        return false;\n    if(p->data==x)\n        return true;\n    else if(x<=p->data)\n        return find_point(p->l,x);\n    else\n        return find_point(p->r,x);\n}\nvoid delete_assist(Node *&p)\n{\n    if(p->l==NULL &&p->r==NULL)\n        p=NULL;\n    else if(p->l==NULL)\n        leftRotate(p),delete_assist(p->l);\n    else if(p->r==NULL)\n        rightRotate(p),delete_assist(p->r);\n    else\n    {\n        if(p->l->priority > p->r->priority)\n            rightRotate(p),delete_assist(p->r);\n        else\n            leftRotate(p),delete_assist(p->l);\n    }\n}\n\nbool delete_point(Node *&p,int x)\n{\n    if(p==NULL)\n        return false;\n    if(p->data==x)\n    {\n        delete_assist(p);\n        return true;\n    }\n    else if(x<=p->data)\n        return delete_point(p->l,x);\n    else\n        return delete_point(p->r,x);\n}\n\nvoid inorder(Node *p)\n{\n    if(p!=NULL)\n    {\n        inorder(p->l);\n        printf(\" %d\",p->data);\n        //printf(\" %d\",p->priority);\n        inorder(p->r);\n    }\n}\n\nvoid preorder(Node *p)\n{\n    if(p!=NULL)\n    {\n        printf(\" %d\",p->data);\n        //printf(\" %d\",p->priority);\n        preorder(p->l);\n        preorder(p->r);\n    }\n}\n\nint main()\n{\n    int i,m,x,y;\n    char st[20];\n    Node *tree=NULL;\n    cin>>m;\n    for(i=1;i<=m;i++)\n    {\n        scanf(\"%s\",st);\n        switch (st[0])\n        {\n        case 'i' :\n            scanf(\"%d%d\\n\",&x,&y);\n            insert_point(tree,x,y);\n            break;\n        case 'f' :\n            scanf(\"%d\\n\",&x);\n            if(find_point(tree,x))\n                cout<<\"yes\"<<endl;\n            else\n                cout<<\"no\"<<endl;\n            break;\n        case 'd' :\n            scanf(\"%d\\n\",&x);\n            delete_point(tree,x);\n\n            break;\n        default:\n            inorder(tree);\n            cout<<endl;\n            preorder(tree);\n            cout<<endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n \nstruct Node{\n  Node* right;\n  Node* left;\n  int key,priority;\n};\n \nNode* rightRotate(Node* t) {\n    Node* s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n}\n  \nNode* insert(Node* t, int key, int priority) {\n    if(t == NULL) {\n        Node* t = new Node;\n        t->left=NULL; t->right = NULL;\n        t->key = key; t->priority = priority;\n        return t;\n    }\n    if(key == t->key) return t;\n \n    if(key < t->key) {\n        t->left = insert(t->left, key, priority);\n        if(t->priority < t->left->priority) t = rightRotate(t);\n    }\n    else {\n        t->right = insert(t->right, key, priority);\n        if(t->priority < t->right->priority) t = leftRotate(t);\n    }\n    return t;\n}\n \nNode* erase(Node* t, int key){\n    if(t == NULL) \n        return NULL;\n \n    if(key == t->key) {\n        if(t->left == NULL && t->right == NULL) \n            return NULL;\n        else if(t->left == NULL) t = leftRotate(t);\n        else if(t->right == NULL) t = rightRotate(t);\n        else {\n            if(t->left->priority > t->right->priority) t = rightRotate(t);\n            else t = leftRotate(t);\n        }\n        return erase(t,key);\n    }\n    if(key < t->key) t->left = erase(t->left, key);\n    else t->right = erase(t->right, key);\n    return t;\n}\n \nvoid find(Node* t, int key) {\n    while(t != NULL && key != t->key) {\n        if(key < t->key) t = t->left;\n        else t = t->right;\n    }\n    if(t == NULL) cout << \"no\" << endl;\n    else cout << \"yes\" << endl;\n}\n\nvoid ppp(Node* t) {\n    if(t == NULL) return;\n    cout << \" \" << t->key;\n    ppp(t->left);\n    ppp(t->right);\n}\n \n\nvoid iii(Node* t) {\n    if(t==NULL) return;\n    iii(t->left);\n    cout << \" \" << t->key;\n    iii(t->right);\n}\n\nmain() {\n    Node* root=NULL;\n    int n,key,priority;\n    string s;\n \n    cin >> n;\n    for(int i=0; i<n; i++) {\n        cin >> s;\n        if(s == \"insert\") {\n            cin >> key >> priority;\n            root = insert(root, key, priority);\n        }\n        else if(s == \"find\") {\n            cin >> key;\n            find(root, key);\n        }\n        else if(s == \"delete\") {\n            cin >> key;\n            root = erase(root, key);\n        }\n        else {\n            iii(root);\n            cout << endl;\n            ppp(root);\n            cout << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std; \nstruct node {\n\tlong long key;\n\tlong long pri;\n\tnode* left;\n\tnode* right;\n};\n\nnode* root;\nnode* rightRotate(node* t);\nnode* leftRotate(node* t);\nnode* insert(node* t, long long k, long long p);\nnode* delete_node(node* t, long long k);\nnode* _delete(node* t, long long k);\n\nnode* rightRotate(node* t) {\n\tnode* s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\tif (t == root) {\n\t\troot = s;\n\t}\n\treturn s;\n} \n\nnode* leftRotate(node* t) {\n\tnode* s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\tif (t == root) {\n\t\troot = s;\n\t}\n\treturn s;\n}\n\nnode* insert(node* t, long long k, long long p) {\n\tif (t == NULL) {\n\t\tif (root == NULL) {\n\t\t\troot = new node{k,p,NULL,NULL};\n\t\t\treturn root;\n\t\t}\n\t\treturn (new node{k,p});\n\t}\n\tif (k < t->key) {\n\t\tt->left = insert(t->left,k,p);\n\t\tif (t->pri < t->left->pri) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t}\n\telse {\n\t\tt->right = insert(t->right,k,p);\n\t\tif (t->pri < t->right->pri) {\n\t\t\tt = leftRotate(t);\n\t\t}\n\t}\n\treturn t;\n}\n\nnode* delete_node(node* t, long long k) {\n\tif (t == NULL) {\n\t\treturn NULL;\n\t}\n\tif (k < t->key) {\n\t\tt->left = delete_node(t->left,k);\n\t}\n\telse if (k > t->key) {\n\t\tt->right = delete_node(t->right,k);\n\t}\n\telse {\n\t\treturn _delete(t,k);\n\t}\n\treturn t;\n}\n\nnode* _delete(node* t, long long k) {\n\tif (t->left == NULL && t-> right == NULL) {\n\t\tif (t == root) {\n\t\t\troot = NULL;\n\t\t}\n\t\treturn NULL;\n\t}\n\telse if (t->left == NULL) {\n\t\tt = leftRotate(t);\n\t}\n\telse if (t->right == NULL) {\n\t\tt = rightRotate(t);\n\t}\n\telse {\n\t\tif (t->left->pri > t->right->pri) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t\telse {\n\t\t\tt = leftRotate(t);\n\t\t}\n\t}\n\treturn delete_node(t,k);\n}\n\nbool find_node(long long k) {\n\tnode* now = root;\n\twhile (now != NULL) {\n\t\tif (k == now->key) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (k > now->key) {\n\t\t\tnow = now->right;\n\t\t}\n\t\telse {\n\t\t\tnow = now->left;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid inorder_walk(node* t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tinorder_walk(t->left);\n\tcout << \" \" << t->key;\n\tinorder_walk(t->right);\n\treturn;\n}\n\nvoid preorder_walk(node* t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tcout << \" \" << t->key;\n\tpreorder_walk(t->left);\n\tpreorder_walk(t->right);\n\treturn;\n}\n\nint main(void) {\n\tint nop;\n\tcin >> nop;\n\n\troot = NULL;\n\tstring ope;\n\tlong long k,p;\n\tfor (int q = 0; q < nop; ++q) {\n\t\tcin >> ope;\n\t\tif (ope == \"print\") {\n\t\t\tinorder_walk(root);\n\t\t\tcout << endl;\n\t\t\tpreorder_walk(root);\n\t\t\tcout << endl;\n\t\t}\n\t\telse {\n\t\t\tcin >> k;\n\t\t\tif (ope == \"insert\") {\n\t\t\t\tcin >> p;\n\t\t\t\tinsert(root,k,p);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ope == \"find\") {\n\t\t\t\t\tif (find_node(k)) {\n\t\t\t\t\t\tcout << \"yes\" << endl;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcout << \"no\" << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdelete_node(root,k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <clocale>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define IOS ios::sync_with_stdio(false); cin.tie(0);\n#define FOR(i, s, n) for(int i = (s), i##_len=(n); i < i##_len; ++i)\n#define FORS(i, s, n) for(int i = (s), i##_len=(n); i <= i##_len; ++i)\n#define VFOR(i, s, n) for(int i = (s); i < (n); ++i)\n#define VFORS(i, s, n) for(int i = (s); i <= (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPS(i, n) FORS(i, 0, n)\n#define VREP(i, n) VFOR(i, 0, n)\n#define VREPS(i, n) VFORS(i, 0, n)\n#define RFOR(i, s, n) for(int i = (s), i##_len=(n); i >= i##_len; --i)\n#define RFORS(i, s, n) for(int i = (s), i##_len=(n); i > i##_len; --i)\n#define RREP(i, n) RFOR(i, n, 0)\n#define RREPS(i, n) RFORS(i, n, 0)\n#define ALL(v) (v).begin(), (v).end()\n#define SORT(v) sort(ALL(v))\n#define RSORT(v) sort(ALL(v), greater<decltype(v[0])>())\n#define SZ(x) ((int)(x).size())\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n\nusing ll = long long;\nusing Pi_i = pair<int, int>;\nusing VB = vector<bool>;\nusing VC = vector<char>;\nusing VD = vector<double>;\nusing VI = vector<int>;\nusing VLL = vector<ll>;\nusing VS = vector<string>;\nusing VSH = vector<short>;\n\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst int NIL = -1;\n\ntemplate<class T>\nbool chmax(T &a, const T &b){\n    if(a < b){\n        a = b; return true;\n    }\n    return false;\n}\ntemplate<class T>\nbool chmin(T &a, const T &b){\n    if(b < a){\n        a = b; return true;\n    }\n    return false;\n}\n\n\n\n\nclass BinarySearchTree{\n    struct Node{\n        int key, priority;\n        Node *right, *left;\n        Node(): key(NIL), priority(NIL), right(nullptr), left(nullptr){};\n        Node(int k, int p): key(k), priority(p), right(nullptr),  left(nullptr){};\n    };\n    Node *root, *NILL = nullptr;\npublic:\n    BinarySearchTree(): root(nullptr){};\nprivate:\n    Node* rightRotate(Node* v){\n        Node* u = v->left;\n        if(v == root){\n            v->left = u->right;\n            u->right = v;\n            root = u;\n        }else{\n            v->left = u->right;\n            u->right = v;\n        }\n        return u;\n    }\n\n    Node* leftRotate(Node* v){\n        Node* u = v->right;\n        if(v == root){\n            v->right = u->left;\n            u->left = v;\n            root = u;\n        }else{\n            v->right = u->left;\n            u->left = v;\n        }\n        return u;\n    }\n\n    Node* insert(Node *v, int k, int p){\n        if(v == nullptr){\n            if(v == root){\n                v = new Node;\n                v->key = k; v->priority = p;\n                v->left = v->right = nullptr;\n                root = v;\n            }else{\n                v = new Node;\n                v->key = k; v->priority = p;\n                v->left = v->right = nullptr;\n            }\n            return v;\n        }\n        if(k == v->key)\n            return v;\n        if(k < v->key){\n            v->left = insert(v->left, k, p);\n            if(v->priority < v->left->priority)\n                v = rightRotate(v);\n        }else{\n            v->right = insert(v->right, k, p);\n            if(v->priority < v->right->priority)\n                v = leftRotate(v);\n        }\n        return v;\n    }\n\n    Node* find(Node *v, int k){\n        while(v != nullptr && k != v->key){\n            if(k < v->key) v = v->left;\n            else v = v->right;\n        }\n        return v;\n    }\n\n    Node* tDelete(Node *v, int k){\n        if(v == nullptr)\n            return nullptr;\n        if(k < v->key)\n            v->left = tDelete(v->left, k);\n        else if(k > v->key)\n            v->right = tDelete(v->right, k);\n        else{\n            if(v->left == nullptr && v->right == nullptr){\n                // delete(v);\n                v = nullptr;\n                return nullptr;\n            }\n            else if(v->left == nullptr)\n                v = leftRotate(v);\n            else if(v->right == nullptr)\n                v = rightRotate(v);\n            else{\n                if(v->left->priority > v->right->priority)\n                    v = rightRotate(v);\n                else v = leftRotate(v);\n            }\n            return tDelete(v, k);\n        }\n        return v;\n    }\n\n    void inOrder(Node *v){\n        if(v == nullptr) return;\n        inOrder(v->left);\n        cout << \" \" << v->key;\n        inOrder(v->right);\n    }\n\n    void preOrder(Node *v){\n        if(v == nullptr) return;\n        cout << \" \" << v->key;\n        preOrder(v->left);\n        preOrder(v->right);\n    }\npublic:\n    void insert(int k, int p){\n        insert(root, k, p);\n    }\n\n    bool find(int x){\n        Node *t = find(root, x);\n        return t != nullptr;\n    }\n\n    void tDelete(int x){\n        if(!find(x)) return;\n        tDelete(root, x);\n    }\n\n    void outInOrder(){\n        inOrder(root);\n    }\n\n    void outPreOrder(){\n        preOrder(root);\n    }\n};\n\n\nint main(){\n    int n; cin >> n;\n    BinarySearchTree T;\n    REP(i, n){\n        int x, p;\n        string com; cin >> com;\n        if(com == \"insert\"){\n            cin >> x >> p;\n            T.insert(x, p);\n        }\n        else if(com == \"find\"){\n            cin >> x;\n            cout << (T.find(x) ? \"yes\" : \"no\") << endl;\n        }\n        else if(com == \"delete\"){\n            cin >> x;\n            T.tDelete(x);\n        }\n        else{\n            T.outInOrder();\n            cout << \"\\n\";\n            T.outPreOrder();\n            cout << \"\\n\";\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n \nstruct node{\n  node* right;\n  node* left;\n  int key,priority;\n};\n \n \nnode* rightRotate(node* t) {\n    node* s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n}\n \nnode* leftRotate(node* t) {\n    node* s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;\n}\n \nnode* insert(node* t, int key, int priority) {\n    if(t == NULL) {\n        node* t = new node;\n        t->left=NULL; t->right = NULL;\n        t->key = key; t->priority = priority;\n        return t;\n    }\n    if(key == t->key) return t;\n \n    if(key < t->key) {\n        t->left = insert(t->left, key, priority);\n        if(t->priority < t->left->priority) t = rightRotate(t);\n    }\n    else {\n        t->right = insert(t->right, key, priority);\n        if(t->priority < t->right->priority) t = leftRotate(t);\n    }\n    return t;\n}\n \nnode* erase(node* t, int key){\n    if(t == NULL) \n    return NULL;\n \n    if(key == t->key) {\n        if(t->left == NULL && t->right == NULL) return NULL;\n        else if(t->left == NULL) t = leftRotate(t);\n        else if(t->right == NULL) t = rightRotate(t);\n        else {\n            if(t->left->priority > t->right->priority) t = rightRotate(t);\n            else t = leftRotate(t);\n        }\n        return erase(t,key);\n    }\n    if(key < t->key) t->left = erase(t->left, key);\n    else t->right = erase(t->right, key);\n    return t;\n}\n \nvoid find(node* t, int key) {\n    while(t != NULL && key != t->key) {\n        if(key < t->key) t = t->left;\n        else t = t->right;\n    }\n    if(t == NULL) cout << \"no\" << endl;\n    else cout << \"yes\" << endl;\n}\n \nvoid tinorder(node* t) {\n    if(t==NULL) return;\n    tinorder(t->left);\n    cout << \" \" << t->key;\n    tinorder(t->right);\n}\n \nvoid pinorder(node* t) {\n    if(t == NULL) return;\n    cout << \" \" << t->key;\n    pinorder(t->left);\n    pinorder(t->right);\n}\n \nint main() {\n    node* root=NULL;\n    int n,key,priority;\n    string s;\n \n    cin >> n;\n    for(int i=0; i<n; i++) {\n        cin >> s;\n        if(s == \"insert\") {\n            cin >> key >> priority;\n            root = insert(root, key, priority);\n        }\n                else if(s == \"find\") {\n            cin >> key;\n            find(root, key);\n        }\n        else if(s == \"delete\") {\n            cin >> key;\n            root = erase(root, key);\n        }\n        else {\n            tinorder(root);\n            cout << endl;\n            pinorder(root);\n            cout << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n//#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\n//typedef pair<ll, ll> P;\n//const double INF = 1e10;\n//const ll INF = LONG_LONG_MAX / 10;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\nconst int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n\nbool contain(set<char> &s, int a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\n\ntypedef pair<int, int> P;\n\nvoid print_line(vector<int> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n\ntypedef priority_queue<long long, vector<long long>, greater<long long> > PQ_ASK;\nconst int mod = 1000000007;\n\nstruct Node {\n    ll key, priority;\n    Node *left, *right, *parent;\n};\n\nclass Dict {\n\n    Node *begin = NULL;\npublic:\n\n\n    Node *find(ll key) {\n        Node *x = begin;\n        while (x != NULL && key != x->key) {\n            if (key < x->key) {\n                x = x->left;\n            } else {\n                x = x->right;\n            }\n        }\n        return x;\n    }\n\n    void insert(ll key, ll priority) {\n        begin = _insert(begin, key, priority);\n    }\n\n    void del(ll key) {\n        begin = _del(begin, key);\n    }\n\n    void inorder() {\n        _inorder(begin);\n    }\n\n    void preorder() {\n        _preorder(begin);\n    }\n\nprivate:\n    void _inorder(Node *node) {\n        if (node == NULL) return;\n        _inorder(node->left);\n        cout << ' ' << node->key;\n        _inorder(node->right);\n    }\n\n    void _preorder(Node *node) {\n        if (node == NULL) return;\n        cout << ' ' << node->key;\n        _preorder(node->left);\n        _preorder(node->right);\n    }\n\n\n    Node *minimum(Node *node) {\n        while (node->left != NULL) node = node->left;\n        return node;\n    }\n\n    Node *right_rotate(Node *t) {\n        Node *s = t->left;\n        t->left = s->right;\n        s->right = t;\n        return s;\n    }\n\n    Node *left_rotate(Node *t) {\n        Node *s = t->right;\n        t->right = s->left;\n        s->left = t;\n        return s;\n    }\n\n\n    Node *_del(Node *t, ll key) {\n        if (t == NULL) {\n            return NULL;\n        }\n        if (key < t->key) {\n            t->left = _del(t->left, key);\n        } else if (key > t->key) {\n            t->right = _del(t->right, key);\n        } else {\n            return _del_rotate(t, key);\n        }\n        return t;\n    }\n\n    Node *_del_rotate(Node *t, ll key) {\n        if (t->left == NULL && t->right == NULL) {\n            return NULL;\n        } else if (t->left == NULL) {\n            t = left_rotate(t);\n        } else if (t->right == NULL) {\n            t = right_rotate(t);\n        } else {\n            if (t->left->priority > t->right->priority) {\n                t = right_rotate(t);\n            } else {\n                t = left_rotate(t);\n            }\n        }\n        return _del(t, key);\n    }\n\n    Node *_insert(Node *t, ll key, ll priority) {\n        if (t == NULL) {\n            Node *n = new Node();\n            n->key = key;\n            n->priority = priority;\n            return n;\n        }\n        if (key == t->key) {\n            return t;\n        }\n        if (key < t->key) {\n            t->left = _insert(t->left, key, priority);\n            if (t->priority < t->left->priority) {\n                t = right_rotate(t);\n            }\n        } else {\n            t->right = _insert(t->right, key, priority);\n            if (t->priority < t->right->priority) {\n                if (t->priority < t->right->priority) {\n                    t = left_rotate(t);\n                }\n            }\n        }\n        return t;\n    }\n\n\n};\n\nint main() {\n    int n;\n    cin >> n;\n\n    Dict dict;\n\n    rep(i, n) {\n        string command;\n        cin >> command;\n        if (command == \"insert\") {\n            ll k, p;\n            cin >> k >> p;\n            dict.insert(k, p);\n        } else if (command == \"print\") {\n            dict.inorder();\n            cout << endl;\n            dict.preorder();\n            cout << endl;\n        } else if (command == \"find\") {\n            ll k;\n            cin >> k;\n            if (dict.find(k) == NULL) {\n                cout << \"no\" << endl;\n            } else {\n                cout << \"yes\" << endl;\n            }\n        } else if (command == \"delete\") {\n            ll k;\n            cin >> k;\n            dict.del(k);\n        }\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<string>\nusing namespace std;\n\nstruct Node{\n    int key, pri;\n    Node *left,*right;\n} *root,*NIL;\n\nNode* leftRotate(Node *t){\n    Node *s = t->right;\n    t->right = s->left;\n    s->left = t;\n    if( t == root ) root = s;\n    return s;\n}\n\nNode* rightRotate(Node *t){\n    Node *s = t->left;\n    t->left = s->right;\n    s->right = t;\n    if( t == root ) root = s;\n    return s;\n}\n\nvoid inorder(Node *t){\n    if( t == NIL ) return;\n    inorder(t->left);\n    cout << \" \" << t->key;\n    inorder(t->right);\n}\n\nvoid preorder(Node *t){\n    if( t == NIL ) return;\n    cout << \" \" << t->key;\n    preorder(t->left);\n    preorder(t->right);\n}\n\nNode* insert(Node* t, int key, int pri){\n    if( t == NIL ){\n        Node *u = new Node();\n        u->key = key;\n        u->pri = pri;\n        u->left = u->right = NIL;\n        return u;\n    }\n    if( key == t->key ) return t;\n    else if( key < t->key ){\n        t->left = insert(t->left,key,pri);\n        if(t->pri < t->left->pri)\n            t = rightRotate(t);\n    }\n    else if( key > t->key ){\n        t->right = insert(t->right,key,pri);\n        if(t->pri < t->right->pri)\n            t = leftRotate(t);\n    }\n    return t;\n}\n\nNode* find(Node* t,int key){\n    if( t == NIL ) return NIL;\n    if( key == t->key ) return t;\n    else if( key < t->key ) return find(t->left,key);\n    else return find(t->right,key);\n}\n\nNode* _delete(Node *t,int key);\n\nNode* nodeDelete( Node* t,int key){\n    if( t == NIL ) return NIL;\n    if( key < t->key ) t->left = nodeDelete(t->left,key);\n    else if( key > t->key ) t->right = nodeDelete(t->right,key);\n    else return _delete(t,key);\n    return t;\n}\n\nNode* _delete(Node* t,int key){\n    if( t->left == NIL && t->right ==NIL ) return NIL;\n    else if( t->right == NIL ){\n        t = rightRotate(t);\n    }\n    else if( t->left == NIL ){\n        t = leftRotate(t);\n    }\n    else {\n        if( t->left->pri > t->right->pri ){\n            t = rightRotate(t);\n        }\n        else t = leftRotate(t);\n    }\n    return nodeDelete(t,key);\n}\n\nint main(){\n    int i,n,j,k,p;\n    string s;\n\n    NIL = new Node();\n    NIL->left = NIL->right =NIL;\n    root = NIL;\n\n    cin >> n;\n    while(n--){\n        cin >> s;\n        if( s == \"insert\" ){\n            cin >> k >> p;\n            Node* t = insert(root,k,p);\n            if( root == NIL ) root = t;\n        }\n        else if( s == \"find\" ){\n            cin >> k;\n            if( find(root,k) != NIL ) cout << \"yes\" << endl;\n            else cout << \"no\" << endl;\n        }\n        else if( s == \"delete\" ){\n            cin >> k;\n            nodeDelete(root,k);\n        }\n        else if( s == \"print\" ){\n            inorder(root);\n            cout << endl;\n            preorder(root);\n            cout <<endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <vector>\nusing namespace std;\n\n#define si static inline\n#define gcu getchar_unlocked\nsi int in() {\n\tint c, n = 0;\n\tbool minus = false;\n\tif ((c = gcu()) == '-') minus = true;\n\telse ungetc(c, stdin);\n\twhile ((c = gcu()) >= '0' && c <= '9') n = 10 * n + (c - '0');\n\treturn minus ? -n : n; }\nsi void scan(char *s) {while (!isspace(*s++ = gcu()));}\n#define pcu putchar_unlocked\n#define svo si void out\nsvo(int n) {\n\tstatic char buf[20];\n\tchar *p = buf;\n\tif(n < 0) pcu('-'), n *= -1;\n\tif (!n) *p++ = '0';\n\telse while (n) *p++ = n % 10 + '0', n /= 10;\n\twhile (p != buf) pcu(*--p); }\nsvo(const char *s){while(*s)pcu(*s++);}\n//svo(char *s){while(*s)pcu(*s++);}\nsvo(char c){pcu(c);}\ntemplate <typename T>\nsvo(vector<T> v){for(T &x:v)out(' '),out(x);out('\\n');}\n//svo(vector<T> &v){for(int &x:v)out(&x == &v[0]?\"\":\" \",x);out('\\n');}\ntemplate <typename head, typename... tail>\nsvo(head&& h, tail&&... t){out(h);out(move(t)...);}\n\ntypedef vector<int> v;\n\ntemplate <typename T>\nstruct treap {\n\tstruct node {\n\t\tT v;\n\t\tint p;\n\t\tnode *n[2];\n\n\t\tnode(T x, T p) {\n\t\t\tv = x;\n\t\t\tthis->p = p;\n\t\t\tn[0] = n[1] = nullptr;\n\t\t}\n\t};\n\n\ttypedef node N;\n\tN *root = nullptr;\n\n\tN* rotate(N* t, int b) {\n\t\tN *s = t->n[1 - b];\n\t\tt->n[1 - b] = s->n[b];\n\t\ts->n[b] = t;\n\t\treturn s;\n\t}\n\tN* insert(T k, int p, N *t) {\n\t\tif (!t)\n\t\t\treturn new N(k, p);\n\t\tint b = !(k < t->v);\n\t\tt->n[b] = insert(k, p, t->n[b]);\n\t\treturn (t->p < t->n[b]->p) ? rotate(t, 1 - b) : t;\n\t}\n\tvoid insert(T k, int p) {\n\t\troot = insert(k, p, root);\n\t}\n\tN* erace(N *t, T x) {\n\t\tif (!t)\n\t\t\t;\n\t\telse if (t->v > x)\n\t\t\tt->n[0] = erace(t->n[0], x);\n\t\telse if (t->v < x)\n\t\t\tt->n[1] = erace(t->n[1], x);\n\t\telse {\n\t\t\tt = erace(!t->n[0] && !t->n[1] ? nullptr :\n\t\t\t\t\t  !t->n[0] ? rotate(t, 0) :\n\t\t\t\t\t  !t->n[1] ? rotate(t, 1) :\n\t\t\t\t\t  rotate(t, t->n[0]->p > t->n[1]->p), x);\n\t\t}\n\t\treturn t;\n\t}\n\tvoid erace(T x) {\n\t\troot = erace(root, x);\n\t}\n\tbool find(N *t, T x) {\n\t\treturn !t ? false : t->v > x ? find(t->n[0], x) : t->v < x ? find(t->n[1], x) : true;\n\t}\n\tbool find(T x) {\n\t\treturn find(root, x);\n\t}\n\tvoid print(N *r, v &buf) {\n\t\tif (r == nullptr)\n\t\t\treturn;\n\t\tbuf.push_back(r->v);\n\t\tprint(r->n[0], buf);\n\t\tout(' ', r->v);\n\t\tprint(r->n[1], buf);\n\t}\n\tvoid print() {\n\t\tv buf;\n\t\tprint(root, buf);\n\t\tout('\\n', buf);\n\t}\n};\n\nint main() {\n\tint n = in(), x;\n\tchar s[20];\n\ttreap<int> t;\n\n\twhile (n--) {\n\t\tscan(s);\n\t\tswitch(*s) {\n\t\tcase 'i':\n\t\t\tx = in();\n\t\t\tt.insert(x, in()); break;\n\t\tcase 'f':\n\t\t\tout(t.find(in()) ? \"yes\\n\": \"no\\n\"); break;\n\t\tcase 'd':\n\t\t\tt.erace(in()); break;\n\t\tdefault:\n\t\t\tt.print();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef struct Node{\n    int key;\n    int priority;\n    Node *parent;\n    Node *lhs, *rhs;\n} Node;\n\ntypedef struct{\n    Node *root;\n} BinaryTree;\n\nvoid init_node(Node *node, int val, int pri){\n    node->key = val;\n    node->priority = pri;\n    node->parent = nullptr;\n    node->lhs = nullptr;\n    node->rhs = nullptr;\n}\n\nvoid right_rotate(BinaryTree *T, Node *r){\n    Node *l = r->lhs;\n    if(l==nullptr || r==nullptr) return;\n    if(T->root == r) T->root = l;\n    if(r->parent != nullptr){\n        if(r->key < r->parent->key) r->parent->lhs = l;\n        else r->parent->rhs = l;\n    }\n    r->lhs = l->rhs;\n    if(l->rhs != nullptr) l->rhs->parent = r;\n    l->rhs = r;\n    l->parent = r->parent;\n    r->parent = l;\n}\n\nvoid left_rotate(BinaryTree *T, Node *l){\n    Node *r = l->rhs;\n    if(l==nullptr || r==nullptr) return;\n    if(T->root == l) T->root = r;\n    if(l->parent != nullptr){\n        if(l->key < l->parent->key) l->parent->lhs = r;\n        else l->parent->rhs = r;\n    }\n    l->rhs = r->lhs;\n    if(r->lhs != nullptr) r->lhs->parent = l;\n    r->lhs = l;\n    r->parent = l->parent;\n    l->parent = r;    \n}\n\nvoid init_bintree(BinaryTree *T){\n    T->root = nullptr;\n}\n\nvoid insert(BinaryTree *T, Node *node){\n    Node *parent = nullptr;\n    Node *x = T->root;\n    while(x != nullptr){\n        parent = x;\n        if(node->key < x->key) x = x->lhs;\n        else x = x->rhs;\n    }\n    node->parent = parent;\n    if(parent == nullptr) T->root = node;\n    else if(node->key < parent->key) parent->lhs = node;\n    else parent->rhs = node;\n    \n    while(node->parent != nullptr && node->priority > node->parent->priority){\n        if(node->key < node->parent->key) right_rotate(T, node->parent);\n        else left_rotate(T, node->parent);\n    }\n}\n\nvoid print_preorder(Node *n){\n    if(n == nullptr) return;\n    cout << ' ' << n->key;\n    print_preorder(n->lhs);\n    print_preorder(n->rhs);\n}\n\nvoid print_inorder(Node *n){\n    if(n == nullptr) return;\n    print_inorder(n->lhs);\n    cout << ' ' << n->key;\n    print_inorder(n->rhs);\n}\n\nvoid print(BinaryTree *T){\n    print_inorder(T->root);\n    cout << endl;\n    print_preorder(T->root);\n    cout << endl;\n}\n\nvoid find(BinaryTree *T, int val){\n    Node *n = T->root;\n    while(n != nullptr){\n        if(n->key == val){\n            cout << \"yes\" << endl;\n            return;\n        }\n        if(val < n->key) n = n->lhs;\n        else n = n->rhs;\n    }\n    cout << \"no\" << endl;\n    return;\n}\n\nNode *get_node(BinaryTree *T, int val){\n    Node *n = T->root;\n    while(n != nullptr){\n        if(n->key == val) return n;\n        if(val < n->key) n = n->lhs;\n        else n = n->rhs;\n    }\n    return nullptr;\n}\n\nvoid del_node(BinaryTree *T, Node *n){\n    if(n == nullptr) return;\n    if(n->lhs == nullptr && n->rhs == nullptr){\n        if(n->parent == nullptr) T->root = nullptr;\n        else if(n->key < n->parent->key) n->parent->lhs = nullptr;\n        else n->parent->rhs = nullptr;\n        n = nullptr;\n    }else if(n->lhs == nullptr || n->rhs == nullptr){\n        if(n->lhs == nullptr) left_rotate(T, n);\n        else right_rotate(T, n);\n        del_node(T, n);\n    }else{\n        if(n->lhs->priority < n->rhs->priority) left_rotate(T, n);\n        else right_rotate(T, n);\n        del_node(T, n);\n    }\n}\n\nvoid del(BinaryTree *T, int val){\n    del_node(T, get_node(T, val));\n}\n\nBinaryTree T;\nNode n[500000];\n\nint main(){\n    int idx = 0;\n    int m, v, p;\n\n    init_bintree(&T);\n    cin >> m;\n    for(int i=0;i<m;i++){\n        string comm;\n        cin >> comm;\n        if(comm==\"print\") print(&T);\n        else if(comm==\"insert\"){\n            cin >> v >> p;\n            init_node(n+idx, v, p);\n            insert(&T, n+idx);\n            idx++;\n        }else if(comm==\"find\"){\n            cin >> v;\n            find(&T, v);\n        }else if(comm==\"delete\"){\n            cin >> v;\n            del(&T, v);\n        }\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n\ntypedef struct _node {\n\tint key;\n\tint priority;\n\tstruct _node * left;\n\tstruct _node * right;\n\tstruct _node * parent;\n} node;\n\nnode * left_rotate(node * t) {\n\tnode * new_t = t->right;\n\tt->right = new_t->left;\n\tif (t->right != NULL) {\n\t\tt->right->parent = t;\n\t}\n\tnew_t->left = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * right_rotate(node * t) {\n\tnode * new_t = t->left;\n\tt->left = new_t->right;\n\tif (t->left != NULL) {\n\t\tt->left->parent = t;\n\t}\n\tnew_t->right = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * create_node(int key, int priority) {\n\tnode * p;\n\tp = (node *)malloc(sizeof(node));\n\tp->key = key;\n\tp->priority = priority;\n\tp->left = NULL;\n\tp->right = NULL;\n\tp->parent = NULL;\n\treturn p;\n}\n\nnode * insert(node * t, int key, int priority) {\n\tif (t == NULL) {\n\t\tnode * p = create_node(key, priority);\n\t\treturn p;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->left = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->left, key, priority);\n\t\t}\n\t\t\t\t\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\telse if (key > t->key) {\n\t\tif (t->right == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->right = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->right, key, priority);\n\t\t}\n\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\t\n\treturn t;\n}\n\nnode * delete_node(node * t, int key) {\n\tif (key == t->key) {\n\t\tif (t->left == NULL && t->right == NULL) {\n\t\t\tif (t->parent->left == t) {\n\t\t\t\tt->parent->left = NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt->parent->right = NULL;\n\t\t\t}\n\t\t\tfree(t);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (t->left == NULL) {\n\t\t\tt = left_rotate(t);\t\n\t\t}\n\t\telse if (t->right == NULL) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse if (t->left->priority > t->right->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\tt = delete_node(t, key);\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete_node(t->left, key);\n\t\treturn t;\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete_node(t->right, key);\n\t\treturn t;\n\t}\n}\n\nint find(node * t, int key) {\n\tif (key == t->key) {\n\t\treturn 1;\n\t}\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->left, key);\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->right, key);\n\t}\n}\n\nvoid print_preorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->left != NULL) {\n\t\tprint_preorder(t->left);\n\t}\n\tif (t->right != NULL) {\n\t\tprint_preorder(t->right);\n\t}\n}\n\nvoid print_inorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tif (t->left != NULL) {\n\t\tprint_inorder(t->left);\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->right != NULL) {\n\t\tprint_inorder(t->right);\n\t}\n}\n\nint main() {\n\tint m;\n\tstd::string buf;\n\tstd::string str;\n\tint k, p;\n\tnode * root = NULL;\n\n\tstd::getline(std::cin, buf);\n\tstd::stringstream ss0(buf);\n\tss0 >> m;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tstd::getline(std::cin, buf);\n\t\tstd::stringstream ss(buf);\n\t\tstd::getline(ss, str, ' ');\n\t\tif (str == \"insert\") {\n\t\t\tss >> k >> p;\n\t\t\t//printf(\"--insert %d %d\\n\", k, p);\n\t\t\troot = insert(root, k, p);\n\t\t}\n\t\telse if (str == \"find\") {\n\t\t\tss >> k;\n\t\t\t//printf(\"--find %d\\n\", k);\n\t\t\tint result = find(root, k);\n\t\t\tif (result == 1) {\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (str ==\"delete\") {\n\t\t\tss >> k;\n\t\t\t//printf(\"--delete %d\\n\", k);\n\t\t\troot = delete_node(root, k);\n\t\t}\n\t\telse if (str == \"print\") {\n\t\t\t//printf(\"--print\\n\");\n\t\t\tprint_inorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tprint_preorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"error\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <memory>\n#include <chrono>\n\ntemplate <class Key>\nstruct Treap {\n    using Prior = uint64_t;\n\n    struct Node {\n        Key key;\n        Prior prior;\n        std::unique_ptr<Node> lch, rch;\n\n        explicit Node(Key key = 0, Prior prior = 0)\n            : key(key), prior(prior), lch(nullptr), rch(nullptr) {}\n    };\n    using Tree = std::unique_ptr<Node>;\n\n    Tree root;\n\n    explicit Treap() : root(nullptr) {}\n\n    void split(Tree& t, Key key, Tree& lt, Tree& rt) {\n        if (!t) {\n            lt = nullptr;\n            rt = nullptr;\n        } else if (key < t->key) {\n            Tree tmp_rt = nullptr;\n            split(t->lch, key, lt, tmp_rt);\n            t->lch = std::move(tmp_rt);\n            rt = std::move(t);\n        } else {\n            Tree tmp_lt = nullptr;\n            split(t->rch, key, tmp_lt, rt);\n            t->rch = std::move(tmp_lt);\n            lt = std::move(t);\n        }\n    }\n\n    void merge(Tree& lt, Tree& rt, Tree& t) {\n        if (!lt || !rt) {\n            t = std::move(lt ? lt : rt);\n        } else if (lt->prior > rt->prior) {\n            merge(lt->rch, rt, lt->rch);\n            t = std::move(lt);\n        } else {\n            merge(lt, rt->lch, rt->lch);\n            t = std::move(rt);\n        }\n    }\n\n    void insert(Key key, Prior prior) {\n        Tree lt, rt;\n        split(root, key, lt, rt);\n        root = std::make_unique<Node>(key, prior);\n        merge(lt, root, root);\n        merge(root, rt, root);\n    }\n\n    void erase(Key key) {\n        Tree lt, rt;\n        split(root, key - 1, lt, rt);\n\n        Tree tmp_rt;\n        split(rt, key, root, tmp_rt);\n        rt = std::move(tmp_rt);\n\n        merge(lt, rt, root);\n    }\n\n    bool find(Key key) {\n        Tree lt, rt;\n        split(root, key - 1, lt, rt);\n\n        Tree tmp_rt;\n        split(rt, key, root, tmp_rt);\n        rt = std::move(tmp_rt);\n\n        bool result = (root != nullptr);\n        merge(lt, root, root);\n        merge(root, rt, root);\n        return result;\n    }\n\n    void dump_inner(Tree& t) {\n        if (!t) return;\n\n        std::cerr << \"(\" << t->prior << \",\" << t->key << \")\" << std::endl;\n        dump_inner(t->lch);\n        std::cerr << \"(\" << t->prior << \",\" << t->key << \")\" << std::endl;\n\n        dump_inner(t->rch);\n        std::cerr << \"(\" << t->prior << \",\" << t->key << \")\" << std::endl;\n    }\n\n    void dump() {\n        std::cerr << \"----- begin -----\" << std::endl;\n        dump_inner(root);\n        std::cerr << \"------ end ------\" << std::endl;\n    }\n\n    void print_inner(Tree& t) {\n        if (!t) return;\n\n        print_inner(t->lch);\n        std::cout << \" \" << t->key;\n        print_inner(t->rch);\n    }\n\n    void print_first(Tree& t) {\n        if (!t) return;\n\n        std::cout << \" \" << t->key;\n        print_first(t->lch);\n        print_first(t->rch);\n    }\n\n    void print() {\n        print_inner(root);\n        std::cout << std::endl;\n        print_first(root);\n        std::cout << std::endl;\n    }\n};\n\nint main() {\n    int n;\n    std::cin >> n;\n\n    Treap<int> treap;\n    while (n--) {\n        std::string t;\n        std::cin >> t;\n\n        if (t == \"print\") {\n            treap.print();\n        } else if (t == \"insert\") {\n            int key, pri;\n            std::cin >> key >> pri;\n            treap.insert(key, pri);\n        } else if (t == \"find\") {\n            int key;\n            std::cin >> key;\n            std::cout << (treap.find(key) ? \"yes\" : \"no\") << std::endl;\n        } else if (t == \"delete\") {\n            int key;\n            std::cin >> key;\n            treap.erase(key);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef struct node {\n  struct node *r;\n  struct node *l;\n  int key,priotity;\n}Node;\n\nNode* delete1(Node*,int);\nNode* makeNode(int k,int p){\n  Node* tmp=(Node* )malloc(sizeof(Node));\n  tmp->key=k;\n  tmp->priotity=p;\n  tmp->l=tmp->r=NULL;\n  return tmp;\n}\nNode* righRotate(Node* t){\n  Node* s;\n  s=t->l;\n  t->l=s->r;\n  s->r=t;\n  return s;\n}\nnode* leftRotate(Node* t){\n  Node* s;\n  s=t->r;\n  t->r=s->l;\n  s->l=t;\n  return s;\n}\n\nNode* insert(Node *t,int key,int priotity){\n  if(t==NULL){\n    //cout<<key<<endl;\n    return makeNode(key,priotity);\n  }\n  if(key==t->key){\n    //cout<<\"in =\"<<endl;\n    return t;\n  }\n  if(key<t->key){\n    t->l= insert(t->l,key,priotity);\n    //cout<<\"in if\"<<endl;\n    if(t->priotity<t->l->priotity)\n      t=righRotate(t);\n  }\n  else{\n    t->r=insert(t->r,key,priotity);\n    //cout<<\"in else\"<<endl;\n    if(t->priotity<t->r->priotity)\n      t=leftRotate(t);\n  }\n  return t;\n}\nvoid inorder(Node *node){\n  if(node==NULL){\n    return;\n  }\n  inorder(node->l);\n  cout<<\" \"<<node->key;\n  inorder(node->r);\n}\nvoid preorder(Node *node){\n  if(node==NULL){\n    return;\n  }\n    cout<<\" \"<<node->key;\n    preorder(node->l);\n    preorder(node->r);\n}\nNode* find(Node *t,int key){\n  while(t!=NULL&&key!=t->key){\n    if(t->key>key)t=t->l;\n    else t=t->r;\n  }\n  return t;\n}\nNode* delete2(Node* t,int key){\n  if(t->l==NULL&&t->r==NULL)return NULL;\n  else if (t->l==NULL)t=leftRotate(t);\n  else if(t->r==NULL)t=righRotate(t);\n  else {\n    if (t->l->priotity>t->r->priotity)\n      t=righRotate(t);\n    else\n      t=leftRotate(t);\n  }\n  return delete1(t,key);\n}\nNode* delete1(Node* t,int key){\n  if(t==NULL)return NULL;\n  if(key<t->key)t->l=delete1(t->l,key);\n  else if (key>t->key)t->r=delete1(t->r,key);\n  else return delete2(t,key);\n  return t;\n}\n\n\nint main(){\n  int n,i,k,p;\n  Node *tmp;\n  Node* root=NULL;\n  string str;\n  cin>>n;\n  for(i=0;i<n;i++){\n    cin>>str;\n    //cout<<\"i=\"<<i<<endl;\n    if(str==\"insert\"){\n      cin>>k>>p;\n      //if(i>0)cout<<\"rootkeybefor:\"<<root->key<<endl;\n      root=insert(root,k,p);\n      //cout<<\"rootkeyafter:\"<<root->key<<endl;\n    }\n    else if(str==\"find\"){\n      cin>>k;\n      tmp=find(root,k);\n      if(tmp!=NULL)cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n    }\n    else if(str==\"delete\"){\n      cin>>k;\n      root=delete1(root,k);\n    }\n    else{\n      inorder(root);\n      cout<<endl;\n      preorder(root);\n      cout<<endl;\n    }\n  }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   for(int i=0;i<(n);++i)\n#define SORT(c)    sort((c).begin(),(c).end())\n#define CLR(a)     memset((&a), 0 ,sizeof(a))//clear memory\n#define dump(x)    cerr << #x << \" = \" << (x) << endl;//debug\n#define debug(x)   cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#define EPS        1e-10//sample:if((double)>=(double)+EPS)\n//cin,cout release\n//std::cin.tie(0);\n//ios::sync_with_stdio(false);\n\nusing namespace std;\n\nstruct node {\n  int key,priority;\n  node *parent,*right, *left;\n};\ntypedef node* nodep;\nnodep root,NIL;\n\nnodep rightRotate(nodep t){\n  nodep s=t->left;\n  t->left=s->right;\n  s->right=t;\n  return s;\n}\nnodep leftrotate(nodep t){\n  nodep s=t->right;\n  t->right=s->left;\n  s->left=t;\n  return s;\n}\nnodep insert(nodep t,int key,int priority){\n  if(t==NIL){\n    nodep n=(nodep)malloc(sizeof(node));\n    n->key=key;\n    n->priority=priority;\n    n->left=NIL;\n    n->right=NIL;\n    return n;\n  }\n  if(key==t->key)return t;\n  if(key<t->key){\n    t->left=insert(t->left,key,priority);\n    if(t->priority<t->left->priority)t=rightRotate(t);\n  }\n  else{\n    t->right=insert(t->right,key,priority);\n    if(t->priority<t->right->priority)t=leftrotate(t);\n  }\n  return t;\n}\nnodep _delete(nodep,int);\nnodep deletetree(nodep t,int key){\n  if(t==NIL)return NIL;\n  if(key<t->key) t->left=deletetree(t->left,key);\n  else if(key>t->key)t->right=deletetree(t->right,key);\n  else return _delete(t,key);\n  return t;\n}\nnodep _delete(nodep t,int key){\n  if(t->left==NIL&&t->right==NIL)return NIL;\n  else if(t->left==NIL)t=leftrotate(t);\n  else if(t->right==NIL)t=rightRotate(t);\n  else{\n    if(t->left->priority>t->right->priority)t=rightRotate(t);\n    else t=leftrotate(t);\n  }\n  return deletetree(t,key);\n}\nnodep find(nodep d,int key){\n  while(d!=NIL&&d->key!=key){\n    if(key<d->key)d=d->left;\n    else d=d->right;\n  }\n  return d;\n}\nvoid inorder(nodep u){\n  if(u==NIL)return;\n  inorder(u->left);\n  cout<<\" \"<<u->key;\n  inorder(u->right);\n}\nvoid preorder(nodep u){\n  if(u==NIL)return;\n  cout<<\" \"<<u->key;\n  preorder(u->left);\n  preorder(u->right);\n}\nint main(){\n  string buf;\n  int a,n,b;\n  cin>>n;\n  rep(i,n){\n    cin>>buf;\n    if(buf[0]=='i'){\n      cin>>a>>b;\n      root=insert(root,a,b);\n    }\n    else if(buf[0]=='f'){\n      cin>>a;\n      if(find(root,a)==NIL)cout<<\"no\"<<endl;\n      else cout<<\"yes\"<<endl;\n    }\n    else if(buf[0]=='d'){\n      cin>>a;\n      root=deletetree(root,a);\n    }\n    else{\n      inorder(root);\n      cout<<endl;\n      preorder(root);\n      cout<<endl;\n    }\n  }\n\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\ntemplate<typename T>\nstruct Treap{\n  struct Node{\n    Node *l,*r;\n    T key,pri;\n    Node(){}\n    Node(T key,T pri):key(key),pri(pri){l=r=nullptr;}\n  };\n  const size_t LIM = 1e6;\n  vector<Node> pool;\n  size_t ptr;\n\n  Treap():pool(LIM),ptr(0){}\n  \n  inline Node* create(){\n    return &pool[ptr++];\n  }\n  \n  inline Node* create(T key,T pri){\n    return &(pool[ptr++]=Node(key,pri));\n  }\n  \n  Node* rotR(Node* t){\n    Node* s=t->l;\n    t->l=s->r;\n    s->r=t;\n    return s;\n  }\n  \n  Node* rotL(Node* t){\n    Node* s=t->r;\n    t->r=s->l;\n    s->l=t;\n    return s;\n  }\n  \n  Node* insert(Node* t,T key,T pri){\n    if(t==nullptr) return create(key,pri);\n    if(key==t->key) return t;\n    if(key < t->key){\n      t->l=insert(t->l,key,pri);\n      if(t->pri < t->l->pri) t=rotR(t);\n    }else{\n      t->r=insert(t->r,key,pri);\n      if(t->pri < t->r->pri) t=rotL(t);\n    }\n    return t;\n  }\n\n  Node* erase(Node* t,T key){\n    if(t==nullptr) return t;\n    if(key < t->key) t->l=erase(t->l,key);\n    else if(key > t->key) t->r=erase(t->r,key);\n    else return del(t,key);\n    return t;\n  }\n\n  Node* del(Node* t,T key){\n    if(t->l==nullptr&&t->r==nullptr) return nullptr;\n    if(t->l==nullptr) t=rotL(t);\n    else if(t->r==nullptr) t=rotR(t);\n    else if(t->l->pri < t->r->pri) t=rotL(t);\n    else t=rotR(t);\n    return erase(t,key);\n  }\n\n  Node* find(Node* t,T key){\n    if(t==nullptr) return t;\n    if(key < t->key) return find(t->l,key);\n    if(key > t->key) return find(t->r,key);\n    return t;\n  }\n\n  void print1(Node* t){\n    if(t==nullptr) return;\n    print1(t->l);\n    cout<<\" \"<<t->key;\n    print1(t->r);\n  }\n  \n  void print2(Node* t){\n    if(t==nullptr) return;\n    cout<<\" \"<<t->key;\n    print2(t->l);\n    print2(t->r);\n  }\n  \n};\nsigned main(){\n  int q;\n  cin>>q;\n  Treap<int> G;\n  Treap<int>::Node* r=nullptr;\n  for(int i=0;i<q;i++){\n    string s;\n    cin>>s;\n    if(s==\"insert\"){\n      int key,pri;\n      cin>>key>>pri;\n      r=G.insert(r,key,pri);\n    }\n    if(s==\"delete\"){\n      int key;\n      cin>>key;\n      r=G.erase(r,key);\n    }\n    if(s==\"find\"){\n      int key;\n      cin>>key;\n      cout<<(G.find(r,key)!=nullptr?\"yes\":\"no\")<<endl;\n    }\n    if(s==\"print\"){\n      G.print1(r);\n      cout<<endl;\n      G.print2(r);\n      cout<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef struct Node{\n  int value, priority;\n  Node *left, *right;\n} Node;\n\nNode* Delete(Node *, int);\nNode* _delete(Node *, int);\n\nNode *NIL, *root;\n\nNode* rightRotate(Node *t){\n  Node *s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s; // root of the subtree\n}\n\nNode* leftRotate(Node *t){\n  Node *s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s; // root of the subtree\n}\n\nNode* makenode(int key, int priority){\n  Node *node = (Node *)malloc(sizeof(Node));\n  node->value = key;\n  node->priority = priority;\n  node->left = node->right = NIL;\n\n  return node;\n}\n\nNode* insert(Node *t, int key, int priority){    // 再帰的に探索\n  Node *x;\n\n  if(t == NIL) return x = makenode(key, priority); // 葉に到達したら新しい節点を生成して返す\n\n  if(key == t->value) return t;                // 重複したkeyは無視\n\n  if(key < t->value){                          // 左の子へ移動\n      t->left = insert(t->left, key, priority); // 左の子へのポインタを更新\n      if(t->priority < t->left->priority) t = rightRotate(t); // 左の子の方が優先度が高い場合右回転\n  }else{                                       // 右の子へ移動\n      t->right = insert(t->right, key, priority); // 右の子へのポインタを更新\n      if(t->priority < t->right->priority) t = leftRotate(t); // 右の子の方が優先度が高い場合左回転\n  }\n\n  return t;\n}\n\nNode* find(Node *x, int k){\n  if(x == NIL || x->value == k) return x;\n\n  if(k < x->value) return find(x->left, k);\n  else return find(x->right, k);\n}\n\nNode* Delete(Node *t, int key){\n  if(t == NIL) return NIL;\n  if(key < t->value) t->left = Delete(t->left, key); // 削除対象を検索\n  else if(key > t->value) t->right = Delete(t->right, key);\n  else return _delete(t, key);\n  return t;\n}\n\nNode* _delete(Node *t, int key){ // 削除対象の節点の場合\n  if(t->left == NIL && t->right == NIL) return NIL; // 葉の場合\n  else if(t->left == NIL) t = leftRotate(t);   // 右の子のみを持つ場合左回転\n  else if(t->right == NIL) t = rightRotate(t); // 左の子のみを持つ場合右回転\n  else{                                        // 左の子と右の子を両方持つ場合\n    if(t->left->priority > t->right->priority) t = rightRotate(t); // 優先度が高い方を持ち上げる\n    else t = leftRotate(t);\n  }\n  return Delete(t, key);\n}\n\nvoid preParse(Node *node){\n  if(node == NIL) return ;\n\n  cout << \" \" << node->value;\n  if(node->left != NIL) preParse(node->left);\n  if(node->right != NIL) preParse(node->right);\n}\n\nvoid inParse(Node *node){\n  if(node == NIL) return ;\n\n  if(node->left != NIL) inParse(node->left);\n  cout << \" \" << node->value;\n  if(node->right != NIL) inParse(node->right);\n}\n\nint main(){\n\n  int n, key, priority;\n  string command;\n\n  cin >> n;\n  for(int i = 0;i < n;i++){\n    cin >> command;\n    if(command == \"insert\"){\n      cin >> key >> priority;\n      root = insert(root, key, priority);\n    }else if(command == \"print\"){\n      inParse(root);\n      cout << endl;\n      preParse(root);\n      cout << endl;\n    }else if(command == \"find\"){\n      cin >> key;\n      if(find(root, key)) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }else if(command == \"delete\"){\n      cin >> key;\n      root = Delete(root, key);\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = 1LL<<55;\nconst Int mod = (1e9)+7;\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nclass Treap{\npublic:\n  struct Node{\n    int key;\n    int priority;\n    Node *parent, *left, *right;\n   \n    Node():key(-1), priority(-1), parent(nullptr), left(nullptr), right(nullptr){};\n    Node(int key,int priority,Node *parent):\n      key(key), priority(priority), parent(parent), left(nullptr), right(nullptr){};\n\n    Node(int key,int priority, Node *parent,Node *left,Node *right):\n      key(key), priority(priority), parent(parent), left(left), right(right){}\n  };\n  \n  int n;\n  Node *root;\n  Treap():n(0){}\n  \n  \n  Node* rightRotate(Node *y){\n    Node *x = y->left;\n    y->left = x->right;\n    x->right = y;\n\n    x->parent = y->parent;\n    y->parent = x;\n    \n    return x;\n  }\n\n  Node* leftRotate(Node *x){\n    Node *y = x->right;\n    x->right = y->left;\n    y->left = x;\n    \n    y->parent = x->parent;\n    x->parent = y;\n\n    return y;\n  }\n\n  Node* insert(Node *t,int key,int priority, Node *parent = nullptr){\n    if(t == nullptr){n++; return new Node(key, priority, parent);}\n    \n    if(key == t->key) return t;\n    \n    if(key < t->key){\n      t->left = insert(t->left, key, priority,  t);\n      if( t->priority < t->left->priority ) t = rightRotate(t);\n    }\n    else{\n      t->right = insert(t->right, key, priority, t);\n      if( t->priority < t->right->priority ) t = leftRotate(t);\n    }\n    return t;\n  }\n\n  Node* insert(int key,int priority){\n    if(n == 0){n++; return root = new Node(key, priority, nullptr);}\n    return insert(root, key, priority);\n  }\n\n  Node* erase(Node *t,int key){\n    if( t == nullptr) return nullptr;\n    if(key == t->key) return _erase(t, key);\n    \n    if(key < t->key ) t->left = erase(t->left, key);\n    else if(key > t->key ) t->right = erase(t->right, key);\n    return t;\n  }\n  \n  Node* _erase(Node *t,int key){\n    if(t->left == nullptr && t->right == nullptr) {\n      delete t;\n      return nullptr;\n    }\n    \n    if(t->left == nullptr) t = leftRotate(t);\n    else if(t->right == nullptr) t = rightRotate(t);\n    else {\n      if( t->left->priority > t->right->priority ) t = rightRotate(t);\n      else t = leftRotate(t);\n    }\n    \n    return erase(t, key);\n  }\n\n  void erase(int key){\n    root = erase(root, key);\n  }\n\n  Node* find(Node *t,int key){\n    if( t == nullptr) return nullptr;\n    if(key < t->key ) return find(t->left, key);\n    if(key > t->key ) return find(t->right, key);\n    return t;\n  }\n\n  Node* find(int key){return find(root, key);}\n\n  \n  void print(Node* t,int a=0,int b=0,int c=0){\n    if(t == nullptr) return;\n    if(a) cout<<\" \"<<(t->key);\n    if(t->left != nullptr) print(t->left, a, b, c);\n    if(b) cout<<\" \"<<(t->key);\n    \n    if(t->right != nullptr) print(t->right, a, b, c);\n    if(c) cout<<\" \"<<(t->key);\n  }\n  \n  void print(){\n    print(root, 0, 1, 0);cout<<endl;\n    print(root, 1, 0, 0);cout<<endl;\n  }\n    \n};\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  \n  Treap T;\n  \n  int n;\n  cin>>n;\n  while(n--){\n    string str;\n    cin>>str;\n    if(str == \"insert\"){\n      int key, priority;\n      cin>>key>>priority;\n      T.insert(key, priority);\n    }\n    \n    if(str == \"find\"){\n      int key;\n      cin>>key;\n      int ans = T.find(key) != nullptr;\n      cout<<(ans?\"yes\":\"no\")<<endl;\n    }\n    \n    if(str == \"delete\"){\n      int key;\n      cin>>key;\n      T.erase(key);\n    }\n    if(str == \"print\"){\n      T.print();\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n\ntypedef struct _node {\n\tint key;\n\tint priority;\n\tstruct _node * left;\n\tstruct _node * right;\n\tstruct _node * parent;\n} node;\n\nnode * left_rotate(node * t) {\n\tnode * new_t = t->right;\n\tt->right = new_t->left;\n\tnew_t->left = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * right_rotate(node * t) {\n\tnode * new_t = t->left;\n\tt->left = new_t->right;\n\tnew_t->right = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * create_node(int key, int priority) {\n\tnode * p;\n\tp = (node *)malloc(sizeof(node));\n\tp->key = key;\n\tp->priority = priority;\n\tp->left = NULL;\n\tp->right = NULL;\n\tp->parent = NULL;\n\treturn p;\n}\n\nnode * insert(node * t, int key, int priority) {\n\tif (t == NULL) {\n\t\tnode * p = create_node(key, priority);\n\t\treturn p;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->left = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->left, key, priority);\n\t\t}\n\t\t\t\t\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\telse if (key > t->key) {\n\t\tif (t->right == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->right = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->right, key, priority);\n\t\t}\n\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\t\n\treturn t;\n}\n\nnode * delete_node(node * t, int key) {\n\tif (key == t->key) {\n\t\tif (t->left == NULL && t->right == NULL) {\n\t\t\tif (t->parent->left == t) {\n\t\t\t\tt->parent->left = NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt->parent->right = NULL;\n\t\t\t}\n\t\t\tfree(t);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (t->left == NULL) {\n\t\t\tt = left_rotate(t);\t\n\t\t}\n\t\telse if (t->right == NULL) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse if (t->left->priority > t->right->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\tt = delete_node(t, key);\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete_node(t->left, key);\n\t\treturn t;\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete_node(t->right, key);\n\t\treturn t;\n\t}\n}\n\nint find(node * t, int key) {\n\tif (key == t->key) {\n\t\treturn 1;\n\t}\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->left, key);\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->right, key);\n\t}\n}\n\nvoid print_preorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->left != NULL) {\n\t\tprint_preorder(t->left);\n\t}\n\tif (t->right != NULL) {\n\t\tprint_preorder(t->right);\n\t}\n}\n\nvoid print_inorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tif (t->left != NULL) {\n\t\tprint_inorder(t->left);\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->right != NULL) {\n\t\tprint_inorder(t->right);\n\t}\n}\n\nint main() {\n\tint m;\n\tstd::string buf;\n\tstd::string str;\n\tint k, p;\n\tnode * root = NULL;\n\n\tstd::getline(std::cin, buf);\n\tm = std::stoi(buf);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tstd::getline(std::cin, buf);\n\t\tstd::stringstream ss(buf);\n\t\tstd::getline(ss, str, ' ');\n\t\tif (str == \"insert\") {\n\t\t\tstd::getline(ss, str, ' ');\n\t\t\tk = std::stoi(str);\n\t\t\tstd::getline(ss, str, ' ');\n\t\t\tp = std::stoi(str);\n\t\t\t//printf(\"--insert %d %d\\n\", k, p);\n\t\t\troot = insert(root, k, p);\n\t\t}\n\t\telse if (str == \"find\") {\n\t\t\tstd::getline(ss, str, ' '); \n\t\t\tk = std::stoi(str);\n\t\t\t//printf(\"--find %d\\n\", k);\n\t\t\tint result = find(root, k);\n\t\t\tif (result == 1) {\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (str ==\"delete\") {\n\t\t\tstd::getline(ss, str, ' ');\n\t\t\tk = std::stoi(str);\n\t\t\t//printf(\"--delete %d\\n\", k);\n\t\t\troot = delete_node(root, k);\n\t\t}\n\t\telse if (str == \"print\") {\n\t\t\t//printf(\"--print\\n\");\n\t\t\tprint_inorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tprint_preorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"error\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdlib.h>\n#include <iostream>\n\nusing namespace std;\n\nstruct Node{\n    Node(int key,int priority){\n        this->key = key;\n        this->priority = priority;\n        this->parent = NULL;\n        this->left = NULL;\n        this->right = NULL;\n    }\n    int key;\n    int priority;\n    Node *parent,*left,*right;\n};\n\nNode* rightRotate(Node* node);\nNode* leftRotate(Node* node);\nNode* deleteNode2(Node* t,int key);\n\n\nNode *root;\n\nNode* minimumTree(Node* x){\n    while(x->left != NULL){\n        x = x->left;\n    }\n    return x;\n}\n\nNode* treeSuccessor(Node *x){\n    if(x->right != NULL){\n        return minimumTree(x->right);\n    }\n    \n    Node *y = x->parent;\n    \n    while(y != NULL && x == y->right){\n        x = y;\n        y = y->parent;\n    }\n    return y;\n}\n\nNode* deleteNode(Node* t, int key){\n    if(t == NULL){\n        return NULL;\n    }\n    if( key < t->key){                                // 削除対象を検索\n        t->left = deleteNode(t->left, key);\n    }\n    else if( key > t->key){\n        t->right = deleteNode(t->right, key);\n    }\n    else{\n        return deleteNode2(t, key);\n    }\n    return t;\n}\n\nNode* deleteNode2(Node* t,int key){ // 削除対象の節点の場合\n    if( t->left == NULL && t->right == NULL){           // 葉の場合\n        delete t;\n        return NULL;\n    }\n    else if( t->left == NULL){                        // 右の子のみを持つ場合左回転\n        t = leftRotate(t);\n    }\n    else if( t->right == NULL){                       // 左の子のみを持つ場合右回転\n        t = rightRotate(t);\n    }\n    else{                                         // 左の子と右の子を両方持つ場合\n        if( t->left->priority > t->right->priority){    // 優先度が高い方を持ち上げる\n            t = rightRotate(t);\n        }\n        else{\n            t = leftRotate(t);\n        }\n    }\n    return deleteNode(t, key);\n}\n\nNode* insert(Node* t, int key, int priority){\n    if(t == NULL){\n        return new Node(key, priority);              // 葉に到達したら新しい節点を生成して返す\n    }\n    if(key == t->key){\n        return t;                                 // 重複したkeyは無視\n    }\n    \n    if( key < t->key){                               // 左の子へ移動\n        t->left = insert(t->left, key, priority);   // 左の子へのポインタを更新\n        if( t->priority < t->left->priority){          // 左の子の方が優先度が高い場合右回転\n            t = rightRotate(t);\n        }\n    }\n    else{                                         // 右の子へ移動\n        t->right = insert(t->right, key, priority); // 右の子へのポインタを更新\n        if( t->priority < t->right->priority){         // 右の子の方が優先度が高い場合左回転\n            t = leftRotate(t);\n        }\n    }\n    \n    return t;\n}\n\n/**\n 根→左→右の順番で出力する\n */\nvoid preOrder(Node* node){\n    if(node == NULL){\n        return;\n    }\n    // 根である自身を出力する\n    cout << \" \" << node->key;\n    // 左\n    if(node->left != NULL){\n        preOrder(node->left);\n    }\n    // 右\n    if(node->right != NULL){\n        preOrder(node->right);\n    }\n}\n\n/**\n 対象のキーを散策する\n キーを持つノードを返す\n */\nNode* find(int key){\n    Node* x = root;\n    while(x != NULL && key != x->key){\n        if(key < x->key){\n            x = x->left;\n        }\n        else{\n            x = x->right;\n        }\n    }\n    return x;\n}\n\n/**\n 左部分木 → 根節点 → 右部分木の順番で節点をまわること\n */\nvoid inOrder(Node* node){\n    if(node == NULL){\n        return;\n    }\n    // 左を探す\n    if(node->left != NULL){\n        inOrder(node->left);\n    }\n    // 左がなくなったら左を出力する\n    cout << \" \" << node->key;\n    // 右\n    if(node->right != NULL){\n        inOrder(node->right);\n    }\n}\n\n/**\n    右回転\n*/\nNode* rightRotate(Node* node){\n    Node *s = node->left;\n    node->left = s->right;\n    s->right = node;\n    return s; // root of the subtree\n}\n/**\n    左回転\n*/\nNode* leftRotate(Node* node){\n    Node* s = node->right;\n    node->right = s->left;\n    s->left = node;\n    return s; // root of the subtree\n}\n\nint main(void){\n    int n,key,priority;\n    \n    cin >> n;\n    \n    for(int i = 0;i < n;++i){\n        string input;\n        cin >> input;\n        // insert\n        if(input[0] == 'i'){\n            cin >> key >> priority;\n            root = insert(root,key,priority);\n        }\n        else if(input[0] == 'f'){\n            cin >> key;\n            Node* node = find(key);\n            if(node == NULL){\n                cout << \"no\" << endl;\n            }\n            else{\n                cout << \"yes\" << endl;\n            }\n        }\n        else if(input[0] == 'd'){\n            cin >> key;\n            root = deleteNode(root, key);\n        }\n        else{\n            inOrder(root);\n            cout << endl;\n            preOrder(root);\n            cout << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <sstream>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <deque>\n#include <limits>\n#include <iomanip>\n#include <ctype.h>\n#include <unordered_map>\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <math.h>\nusing namespace std;\ntypedef long long ll;\n#include <stdio.h>\n#include <sstream>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <deque>\n#include <limits>\n#include <iomanip>\n#include <ctype.h>\n#include <unordered_map>\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <math.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, char> pic;\n#define bit(x,v) ((ll)x << v)\n\nconst ll INF = 1000000007;\nconst int MAX = 210000;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nint pr[100010];\nvoid uini(int n) {\n\tfor (size_t i = 0; i <= n; i++)\n\t{\n\t\tpr[i] = i;\n\t}\n}\n\nint parent(int x) {\n\tif (x == pr[x]) return x;\n\treturn pr[x] = parent(pr[x]);\n}\n\nbool unit(int x, int y) {\n\tint px = parent(x);\n\tint py = parent(y);\n\n\tif (px == py) return false;\n\tif (px < py) {\n\t\tpr[py] = px;\n\t}\n\telse {\n\t\tpr[px] = py;\n\t}\n\treturn true;\n}\n\nll bit[200010];\nint max_n = 200000;\nint pm = 0;\nvoid add(int x) {\n\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]++;\n\t\tx += x & -x;\n\t}\n}\nvoid sub(int x) {\n\twhile (max_n >= x)\n\t{\n\t\tbit[x]--;\n\t\tx += x & -x;\n\t}\n}\nll merge(ll *a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<int> L(n1 + 1);\n\tvector<int> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = INF;\n\tR[n2] = INF;\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i] <= R[j]) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll merge2(pair<int,char> *a, int left, int mid, int right) {\n\tll n1 = mid - left;\n\tll n2 = right - mid;\n\tvector<pair<int, char>> L(n1 + 1);\n\tvector<pair<int, char>> R(n2 + 1);\n\tfor (size_t i = 0; i < n1; i++)\n\t{\n\t\tL[i] = a[left + i];\n\t}\n\tfor (size_t i = 0; i < n2; i++)\n\t{\n\t\tR[i] = a[mid + i];\n\t}\n\n\tL[n1] = make_pair(INF,' ');\n\tR[n2] = make_pair(INF,' ');\n\tll i = 0;\n\tll j = 0;\n\tll r = 0;\n\tfor (size_t k = left; k < right; k++)\n\t{\n\t\tif (L[i].first <= R[j].first) {\n\t\t\ta[k] = L[i];\n\t\t\ti++;\n\t\t}\n\t\telse {\n\t\t\ta[k] = R[j];\n\t\t\tr += n1 - i;\n\t\t\tj++;\n\t\t}\n\t}\n\treturn r;\n}\nll mergeSort2(pair<int, char> *a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort2(a, left, mid);\n\t\tres += mergeSort2(a, mid, right);\n\t\tres += merge2(a, left, mid, right);\n\t}\n\treturn res;\n}\nll mergeSort(ll *a, int left, int right) {\n\tll res = 0;\n\tif (left + 1 < right) {\n\t\tint mid = (left + right) / 2;\n\t\tres = mergeSort(a, left, mid);\n\t\tres += mergeSort(a, mid, right);\n\t\tres += merge(a, left, mid, right);\n\t}\n\treturn res;\n}\nint partition(pair<int,char> *a, int p, int r) {\n\tpair<int, char> x = a[r];\n\tint i = p - 1;\n\tfor (size_t j = p; j < r; j++)\n\t{\n\t\tif (a[j].first <= x.first) {\n\t\t\ti++;\n\t\t\tswap(a[i], a[j]);\n\t\t}\n\t}\n\tswap(a[i + 1], a[r]);\n\treturn i + 1;\n}\nvoid quick(pair<int, char> *a, int p, int r) {\n\tif (p < r) {\n\t\tint q = partition(a, p, r);\n\t\tquick(a, p, q - 1);\n\t\tquick(a, q + 1, r);\n\t}\n}\n\nint n;\nvector<pii> es[100010];\nint ci = 0;\nll P[1000010];\nstruct Node {\n\tint key;\n\tint priority;\n\tNode *parent, *left, *right;\n\tNode(int key, int priority);\n\tNode() {}\n};\nNode NIL;\nNode::Node(int key, int priority) : key(key), priority(priority) {\n\tleft = &NIL;\n\tright = &NIL;\n}\nNode* root = new Node();\nvoid cenrec(Node* k) {\n\tif (k->key == NIL.key) return;\n\tcenrec(k->left);\n\tcout << \" \" << k->key;\n\tcenrec(k->right);\n}\nvoid fastrec(Node* k)\n{\n\tif (k->key == NIL.key) return;\n\tcout << \" \" << k->key;\n\tfastrec(k->left);\n\tfastrec(k->right);\n}\nvoid insert(Node* v) {\n\tNode* y = &NIL;\n\tNode* x = root;\n\twhile (x->key != NIL.key)\n\t{\n\t\ty = x;\n\t\tif (v->key < x->key) {\n\t\t\tx = x->left;\n\t\t}\n\t\telse {\n\t\t\tx = x->right;\n\t\t}\n\t}\n\tv->parent = y;\n\tif (y->key == NIL.key) {\n\t\troot = v;\n\t}\n\telse if (v->key < y->key) {\n\t\ty->left = v;\n\t}\n\telse {\n\t\ty->right = v;\n\t}\n\n}\n\nNode* find(Node* k,ll v)\n{\n\tif (k->key == NIL.key) return &NIL;\n\tif (k->key == v) return k;\n\tif (v < k->key) return find(k->left, v);\n\treturn find(k->right,v);\n}\nvoid delp12(Node* x) {\n\tif (x->key == NIL.key)  return;\n\tNode* l = x->left;\n\tNode* r = x->right;\n\tNode* pr = x->parent;\n\n\tif (l->key == NIL.key\n\t\t&& r->key == NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = &NIL;\n\t\t}\n\t\telse pr->right = &NIL;\n\t}\n\telse if (l->key != NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = l;\n\t\t}\n\t\telse pr->right = l;\n\t\tl->parent = pr;\n\t}\n\telse if (r->key != NIL.key) {\n\t\tif (pr->left == x) {\n\t\t\tpr->left = r;\n\t\t}\n\t\telse pr->right = r;\n\t\tr->parent = pr;\n\t}\n}\nNode* get_next(Node* k) {\n\tif (k->key == NIL.key) return &NIL;\n\tNode* res = get_next(k->left);\n\tif (res->key != NIL.key) return res;\n\treturn k;\n}\nvoid del(Node* x) {\n\t\n\tif (x->key == NIL.key) return;\n\tNode* l= x->left;\n\tNode* r = x->right;\n\tNode* pr = x->parent;\n\n\tif (l->key != NIL.key && r->key != NIL.key) {\n\t\tNode* nex = get_next(r);\n\t\tx->key = nex->key;\n\t\tdelp12(nex);\n\t}\n\telse {\n\t\tdelp12(x);\n\t}\n}\nNode* rightRotate(Node *t) {\n\tNode* s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\nNode* leftRotate(Node *t) {\n\tNode* s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\nNode* _insert(Node *t, int key, int priority) {\n\tif (t->key == NIL.key) {\n\t\treturn new Node(key, priority);\n\t}\n\tif (key == t->key) {\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tt->left = _insert(t->left, key, priority);\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t}\n\telse {\n\t\tt->right = _insert(t->right, key, priority);\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = leftRotate(t);\n\t\t}\n\t}\n\treturn t;\n}\nNode* delete1(Node* t, int key);\nNode* _delete(Node *t, int key) {\n\tif (t->left->key == NIL.key && t->right->key == NIL.key) {\n\t\treturn &NIL;\n\t}\n\telse if (t->left->key == NIL.key) {\n\t\tt = leftRotate(t);\n\t}\n\telse if (t->right->key == NIL.key) {\n\t\tt = rightRotate(t);\n\t}\n\telse\n\t{\n\t\tif (t->left->priority > t->right->priority) {\n\t\t\tt = rightRotate(t);\n\t\t}\n\t\telse\n\t\t\tt = leftRotate(t);\n\t}\n\treturn delete1(t, key);\n}\nNode* delete1(Node* t, int key) {\n\tif (t->key == NIL.key) {\n\t\treturn &NIL;\n\t}\n\tif (key < t->key) {\n\t\tt->left = delete1(t->left, key);\n\t}\n\telse if (key > t->key) {\n\t\tt->right = delete1(t->right, key);\n\t}\n\telse return _delete(t, key);\n\treturn t;\n}\n\nvoid solv() {\n\n\tint n;\n\tcin >> n;\n\tNIL.key = INF*2;\n\tNIL.left = root;\n\troot->key = INF*2;\n\tfor (size_t i = 0; i < n; i++)\n\t{\n\t\tchar s[256];\n\t\tscanf(\"%s\", s);\n\n\t\tif (strcmp(s,\"insert\") == 0) {\n\t\t\tll v,p;\n\t\t\tcin >> v >> p;\n\t\t\troot = _insert(root,v,p);\n\t\t}\n\t\telse if (strcmp(s, \"find\") == 0) {\n\t\t\tll v;\n\t\t\tcin >> v;\n\t\t\tif (find(root,v)->key != NIL.key) {\n\t\t\t\tcout << \"yes\" << endl;\n\t\t\t}\n\t\t\telse cout << \"no\" << endl;\n\t\t}\n\t\telse if (strcmp(s, \"delete\") == 0) {\n\t\t\tll v;\n\t\t\tcin >> v;\n\t\t\troot = delete1(root,v);\n\t\t}\n\t\telse {\n\t\t\tci = 0;\n\t\t\tcenrec(root);\n\t\t\tcout << endl;\n\t\t\tci = 0;\n\t\t\tfastrec(root);\n\t\t\tcout << endl;\n\t\t}\n\t}\n}\nint main() {\n\t//\tCOMinit();\n\tsolv();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// treap\n\n#include <iostream>\n#include <stdio.h>\n \nusing namespace std;\n \nstruct Node{\n    Node *left;\n    Node *right;\n    int key;\n    int pri;\n \n    Node(int k, int p) : key(k), pri(p){\n        left = right = NULL;\n    }\n};\n \nNode* rightRotate(Node *t){\n    Node* s = t->left;\n    t->left = s->right;\n    s->right = t;\n     \n    return s; \n}\n \nNode* leftRotate(Node *t){\n    Node* s = t->right;\n    t->right = s->left;\n    s->left = t;\n     \n    return s; \n}\n \nvoid find(Node *t, int k){\n  while(t != NULL && k != t->key){\n    if(k < t->key) t = t->left;\n    else t = t->right;\n  }\n \n  if ( t != NULL ) cout << \"yes\" << endl;\n  else cout << \"no\" << endl;\n}\n \nNode* insert(Node *t, int key, int pri){\n    if(t == NULL){ return new Node(key, pri); }\n    if(key == t->key){ return t; }                     \n \n    if(key < t->key){                         \n        t->left = insert(t->left, key, pri);  \n        if(t->pri < t->left->pri){ t = rightRotate(t); }\n    } else{\n        t->right = insert(t->right, key, pri);\n        if(t->pri < t->right->pri){ t = leftRotate(t); }\n    }\n     \n    return t;\n}\n \nNode* erase(Node *t, int key){\n    if(t == NULL){ return NULL; }\n     \n    if(key == t->key){                         \n        if(t->left == NULL && t->right == NULL){ return NULL; }\n        else if(t->left == NULL){ t = leftRotate(t); }\n        else if(t->right == NULL){ t = rightRotate(t); }\n        else{\n            if(t->left->pri > t->right->pri){ t = rightRotate(t); }\n            else{ t = leftRotate(t); }\n        }\n        return erase(t, key);\n    }\n     \n    if(key < t->key){ t->left = erase(t->left, key); }\n    else{ t->right = erase(t->right, key); }\n     \n    return t;\n}\n \n \nvoid Inorder(Node *t){\n  if(t->left != NULL) Inorder(t->left);\n  if(t->key != -1) cout << \" \" << t->key;\n  if(t->right != NULL) Inorder(t->right);\n}\n    \nvoid Preorder(Node *t){\n  if(t->key != -1) cout << \" \" << t->key;\n  if(t->left != NULL) Preorder(t->left);\n  if(t->right != NULL) Preorder(t->right);\n}\n \n \nvoid print(Node *t){\n    if(t != NULL) Inorder(t);\n      cout <<endl;\n      if(t != NULL) Preorder(t);\n      cout <<endl;\n}\n \nint main(){\n    int n;\n    cin >> n;\n    char ope[n];\n    int k, p;\n \n    Node *t=new Node(-1, -1);\n \n    for(int i=0; i<n; i++){\n        scanf(\"%s\", ope);\n        if(ope[0] == 'p'){ print(t); }\n        else if(ope[0] == 'f'){ cin >> k; find(t, k); }\n        else if(ope[0] == 'd'){ cin >> k; t = erase(t, k); }\n        else if(ope[0] == 'i'){ cin >> k >> p; t = insert(t, k, p); }\n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define SIZE 200005\n\nstruct Node{\n\n\tint key,priority;\n\tint left,right;\n};\n\nint num_nodes,root;\nNode nodes[SIZE];\n\nint leftRotate(int node_id){\n\n\tint ret = nodes[node_id].right;\n\tnodes[node_id].right = nodes[ret].left;\n\tnodes[ret].left = node_id;\n\n\treturn ret;\n}\n\nint rightRotate(int node_id){\n\n\tint ret = nodes[node_id].left;\n\tnodes[node_id].left = nodes[ret].right;\n\tnodes[ret].right = node_id;\n\n\treturn ret;\n}\n\nint insert(int node_id,int key,int priority){\n\n\tif(node_id == -1){\n\n\t\tnodes[num_nodes].key = key;\n\t\tnodes[num_nodes].priority = priority;\n\t\tnodes[num_nodes].left = -1;\n\t\tnodes[num_nodes].right = -1;\n\n\t\tnum_nodes++;\n\t\treturn num_nodes-1;\n\t}\n\n\tif(nodes[node_id].key == key){\n\n\t\treturn node_id;\n\t}\n\n\tif(nodes[node_id].key > key){\n\n\t\tnodes[node_id].left = insert(nodes[node_id].left,key,priority);\n\t\tif(nodes[node_id].priority < nodes[nodes[node_id].left].priority){\n\n\t\t\tnode_id = rightRotate(node_id);\n\t\t}\n\t}else{\n\n\t\tnodes[node_id].right = insert(nodes[node_id].right,key,priority);\n\t\tif(nodes[node_id].priority < nodes[nodes[node_id].right].priority){\n\n\t\t\tnode_id = leftRotate(node_id);\n\t\t}\n\t}\n\n\treturn node_id;\n}\n\nint DELETE(int node_id,int key);\n\nint DELETE_2(int node_id,int key){\n\n\tif(nodes[node_id].left == -1 && nodes[node_id].right == -1){\n\n\t\treturn -1;\n\n\t}else if(nodes[node_id].left == -1){\n\n\t\tnode_id = leftRotate(node_id);\n\n\t}else if(nodes[node_id].right == -1){\n\n\t\tnode_id = rightRotate(node_id);\n\n\t}else{\n\n\t\tif(nodes[nodes[node_id].left].priority > nodes[nodes[node_id].right].priority){\n\n\t\t\tnode_id = rightRotate(node_id);\n\n\t\t}else{\n\n\t\t\tnode_id = leftRotate(node_id);\n\t\t}\n\t}\n\treturn DELETE(node_id,key);\n}\n\nint DELETE(int node_id,int key){\n\n\tif(num_nodes == 0 || node_id == -1){\n\n\t\treturn -1;\n\t}\n\n\tif(nodes[node_id].key > key){\n\n\t\tnodes[node_id].left = DELETE(nodes[node_id].left,key);\n\n\t}else if(nodes[node_id].key < key){\n\n\t\tnodes[node_id].right = DELETE(nodes[node_id].right,key);\n\n\t}else{\n\n\t\treturn DELETE_2(node_id,key);\n\t}\n\n\treturn node_id;\n}\n\nvoid find(int key){\n\n\tif(num_nodes == 0){\n\n\t\tprintf(\"no\\n\");\n\t\treturn;\n\t}\n\n\tint current_node = root;\n\n\twhile(true){\n\n\t\tif(nodes[current_node].key == key){\n\n\t\t\tprintf(\"yes\\n\");\n\t\t\treturn;\n\n\t\t}else if(nodes[current_node].key > key){\n\n\t\t\tcurrent_node = nodes[current_node].left;\n\n\t\t}else{ //nodes[current_node].key < key\n\n\t\t\tcurrent_node = nodes[current_node].right;\n\t\t}\n\n\t\tif(current_node == -1){\n\n\t\t\tprintf(\"no\\n\");\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid in_order(int node_id){\n\n\tif(node_id == -1)return;\n\n\tif(nodes[node_id].left != -1){\n\n\t\tin_order(nodes[node_id].left);\n\t}\n\n\tprintf(\" %d\",nodes[node_id].key);\n\n\tif(nodes[node_id].right != -1){\n\n\t\tin_order(nodes[node_id].right);\n\t}\n}\n\nvoid pre_order(int node_id){\n\n\tif(node_id == -1)return;\n\n\tprintf(\" %d\",nodes[node_id].key);\n\tif(nodes[node_id].left != -1){\n\n\t\tpre_order(nodes[node_id].left);\n\t}\n\tif(nodes[node_id].right != -1){\n\n\t\tpre_order(nodes[node_id].right);\n\t}\n}\n\n\nint main(){\n\n\tnum_nodes = 0;\n\n\tint M;\n\tscanf(\"%d\",&M);\n\n\tchar command[10];\n\tint key,priority;\n\n\troot = -1;\n\n\tfor(int loop = 0; loop < M; loop++){\n\n\t\tscanf(\"%s\",command);\n\n\t\tswitch(command[0]){\n\t\tcase 'i':\n\n\t\t\tscanf(\"%d %d\",&key,&priority);\n\t\t\troot = insert(root,key,priority);\n\t\t\tbreak;\n\n\t\tcase 'f':\n\n\t\t\tscanf(\"%d\",&key);\n\t\t\tfind(key);\n\t\t\tbreak;\n\n\t\tcase 'd':\n\n\t\t\tscanf(\"%d\",&key);\n\t\t\troot = DELETE(root,key);\n\t\t\tbreak;\n\n\t\tcase 'p':\n\t\t\tif(num_nodes == 0)break;\n\n\t\t\tin_order(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tpre_order(root);\n\t\t\tprintf(\"\\n\");\n\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n\ntypedef struct _node {\n\tint key;\n\tint priority;\n\tstruct _node * left;\n\tstruct _node * right;\n\tstruct _node * parent;\n} node;\n\nnode * left_rotate(node * t) {\n\tnode * new_t = t->right;\n\tt->right = new_t->left;\n\tnew_t->left = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * right_rotate(node * t) {\n\tnode * new_t = t->left;\n\tt->left = new_t->right;\n\tnew_t->right = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * create_node(int key, int priority) {\n\tnode * p;\n\tp = (node *)malloc(sizeof(node));\n\tp->key = key;\n\tp->priority = priority;\n\tp->left = NULL;\n\tp->right = NULL;\n\tp->parent = NULL;\n\treturn p;\n}\n\nnode * insert(node * t, int key, int priority) {\n\tif (t == NULL) {\n\t\tnode * p = create_node(key, priority);\n\t\treturn p;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->left = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->left, key, priority);\n\t\t}\n\t\t\t\t\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\telse if (key > t->key) {\n\t\tif (t->right == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->right = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->right, key, priority);\n\t\t}\n\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\t\n\treturn t;\n}\n\nnode * delete_node(node * t, int key) {\n\tif (key == t->key) {\n\t\tif (t->left == NULL && t->right == NULL) {\n\t\t\tif (t->parent->left == t) {\n\t\t\t\tt->parent->left = NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt->parent->right = NULL;\n\t\t\t}\n\t\t\tfree(t);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (t->left == NULL) {\n\t\t\tt = left_rotate(t);\t\n\t\t}\n\t\telse if (t->right == NULL) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse if (t->left->priority > t->right->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\tt = delete_node(t, key);\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete_node(t->left, key);\n\t\treturn t;\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete_node(t->right, key);\n\t\treturn t;\n\t}\n}\n\nint find(node * t, int key) {\n\tif (key == t->key) {\n\t\treturn 1;\n\t}\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->left, key);\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->right, key);\n\t}\n}\n\nvoid print_preorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->left != NULL) {\n\t\tprint_preorder(t->left);\n\t}\n\tif (t->right != NULL) {\n\t\tprint_preorder(t->right);\n\t}\n}\n\nvoid print_inorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tif (t->left != NULL) {\n\t\tprint_inorder(t->left);\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->right != NULL) {\n\t\tprint_inorder(t->right);\n\t}\n}\n\nint main() {\n\tint m;\n\tstd::string buf;\n\tstd::string str;\n\tint k, p;\n\tnode * root = NULL;\n\n\tstd::getline(std::cin, buf);\n\tm = stoi(buf);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tstd::getline(std::cin, buf);\n\t\tstd::stringstream ss(buf);\n\t\tstd::getline(ss, str, ' ');\n\t\tif (str == \"insert\") {\n\t\t\tss >> k >> p;\n\t\t\t//printf(\"--insert %d %d\\n\", k, p);\n\t\t\troot = insert(root, k, p);\n\t\t}\n\t\telse if (str == \"find\") {\n\t\t\tss >> k;\n\t\t\t//printf(\"--find %d\\n\", k);\n\t\t\tint result = find(root, k);\n\t\t\tif (result == 1) {\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (str ==\"delete\") {\n\t\t\tss >> k;\n\t\t\t//printf(\"--delete %d\\n\", k);\n\t\t\troot = delete_node(root, k);\n\t\t}\n\t\telse if (str == \"print\") {\n\t\t\t//printf(\"--print\\n\");\n\t\t\tprint_inorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tprint_preorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"error\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n\ntypedef struct _node {\n\tint key;\n\tint priority;\n\tstruct _node * left;\n\tstruct _node * right;\n\tstruct _node * parent;\n} node;\n\nnode * left_rotate(node * t) {\n\tnode * new_t = t->right;\n\tt->right = new_t->left;\n\tnew_t->left = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * right_rotate(node * t) {\n\tnode * new_t = t->left;\n\tt->left = new_t->right;\n\tnew_t->right = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * create_node(int key, int priority) {\n\tnode * p;\n\tp = (node *)malloc(sizeof(node));\n\tp->key = key;\n\tp->priority = priority;\n\tp->left = NULL;\n\tp->right = NULL;\n\tp->parent = NULL;\n\treturn p;\n}\n\nnode * insert(node * t, int key, int priority) {\n\tif (t == NULL) {\n\t\tnode * p = create_node(key, priority);\n\t\treturn p;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->left = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->left, key, priority);\n\t\t}\n\t\t\t\t\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\telse if (key > t->key) {\n\t\tif (t->right == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->right = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->right, key, priority);\n\t\t}\n\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\t\n\treturn t;\n}\n\nnode * delete_node(node * t, int key) {\n\tif (key == t->key) {\n\t\tif (t->left == NULL && t->right == NULL) {\n\t\t\tif (t->parent->left == t) {\n\t\t\t\tt->parent->left = NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt->parent->right = NULL;\n\t\t\t}\n\t\t\tfree(t);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (t->left == NULL) {\n\t\t\tt = left_rotate(t);\t\n\t\t}\n\t\telse if (t->right == NULL) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse if (t->left->priority > t->right->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\tt = delete_node(t, key);\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete_node(t->left, key);\n\t\treturn t;\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete_node(t->right, key);\n\t\treturn t;\n\t}\n}\n\nint find(node * t, int key) {\n\tif (key == t->key) {\n\t\treturn 1;\n\t}\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->left, key);\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->right, key);\n\t}\n}\n\nvoid print_preorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->left != NULL) {\n\t\tprint_preorder(t->left);\n\t}\n\tif (t->right != NULL) {\n\t\tprint_preorder(t->right);\n\t}\n}\n\nvoid print_inorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tif (t->left != NULL) {\n\t\tprint_inorder(t->left);\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->right != NULL) {\n\t\tprint_inorder(t->right);\n\t}\n}\n\nint main() {\n\tint m;\n\tstd::string buf;\n\tstd::string str;\n\tint k, p;\n\tnode * root = NULL;\n\n\tstd::getline(std::cin, buf);\n\tstd::stringstream ss0(buf);\n\tss0 >> m;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tstd::getline(std::cin, buf);\n\t\tstd::stringstream ss(buf);\n\t\tstd::getline(ss, str, ' ');\n\t\tif (str == \"insert\") {\n\t\t\tss >> k >> p;\n\t\t\t//printf(\"--insert %d %d\\n\", k, p);\n\t\t\troot = insert(root, k, p);\n\t\t}\n\t\telse if (str == \"find\") {\n\t\t\tss >> k;\n\t\t\t//printf(\"--find %d\\n\", k);\n\t\t\tint result = find(root, k);\n\t\t\tif (result == 1) {\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (str ==\"delete\") {\n\t\t\tss >> k;\n\t\t\t//printf(\"--delete %d\\n\", k);\n\t\t\troot = delete_node(root, k);\n\t\t}\n\t\telse if (str == \"print\") {\n\t\t\t//printf(\"--print\\n\");\n\t\t\tprint_inorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tprint_preorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"error\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BUF_LENGTH 100\n#define OPE_LENGTH 10\n\ntypedef struct _node {\n\tint key;\n\tint priority;\n\tstruct _node * left;\n\tstruct _node * right;\n\tstruct _node * parent;\n} node;\n\nnode * left_rotate(node * t) {\n\tnode * new_t = t->right;\n\tt->right = new_t->left;\n\tnew_t->left = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * right_rotate(node * t) {\n\tnode * new_t = t->left;\n\tt->left = new_t->right;\n\tnew_t->right = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * create_node(int key, int priority) {\n\tnode * p;\n\tp = (node *)malloc(sizeof(node));\n\tp->key = key;\n\tp->priority = priority;\n\tp->left = NULL;\n\tp->right = NULL;\n\tp->parent = NULL;\n\treturn p;\n}\n\nnode * insert(node * t, int key, int priority) {\n\tif (t == NULL) {\n\t\tnode * p = create_node(key, priority);\n\t\treturn p;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->left = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->left, key, priority);\n\t\t}\n\t\t\t\t\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\telse if (key > t->key) {\n\t\tif (t->right == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->right = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->right, key, priority);\n\t\t}\n\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\t\n\treturn t;\n}\n\nnode * delete(node * t, int key) {\n\tif (key == t->key) {\n\t\tif (t->left == NULL && t->right == NULL) {\n\t\t\tif (t->parent->left == t) {\n\t\t\t\tt->parent->left = NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt->parent->right = NULL;\n\t\t\t}\n\t\t\tfree(t);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (t->left == NULL) {\n\t\t\tt = left_rotate(t);\t\n\t\t}\n\t\telse if (t->right == NULL) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse if (t->left->priority > t->right->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\tt = delete(t, key);\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete(t->left, key);\n\t\treturn t;\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete(t->right, key);\n\t\treturn t;\n\t}\n}\n\nint find(node * t, int key) {\n\tif (key == t->key) {\n\t\treturn 1;\n\t}\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->left, key);\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->right, key);\n\t}\n}\n\nvoid print_preorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->left != NULL) {\n\t\tprint_preorder(t->left);\n\t}\n\tif (t->right != NULL) {\n\t\tprint_preorder(t->right);\n\t}\n}\n\nvoid print_inorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tif (t->left != NULL) {\n\t\tprint_inorder(t->left);\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->right != NULL) {\n\t\tprint_inorder(t->right);\n\t}\n}\n\nint main() {\n\tint m;\n\tchar buf[BUF_LENGTH];\n\tchar * str;\n\tint k, p;\n\tnode * root = NULL;\n\n\tscanf_s(\"%d \", &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfgets(&buf, BUF_LENGTH, stdin);\n\t\tchar * context;\n\t\tstr = strtok_s(buf, \" \\n\", &context);\n\t\tif (strcmp(str, \"insert\") == 0) {\n\t\t\tstr = strtok_s(NULL, \" \\n\", &context);\n\t\t\tk = atoi(str);\n\t\t\tstr = strtok_s(NULL, \" \\n\", &context);\n\t\t\tp = atoi(str);\n\t\t\t//printf(\"--insert %d %d\\n\", k, p);\n\t\t\troot = insert(root, k, p);\n\t\t}\n\t\telse if (strcmp(str, \"find\") == 0) {\n\t\t\tstr = strtok_s(NULL, \" \\n\", &context);\n\t\t\tk = atoi(str);\n\t\t\t//printf(\"--find %d\\n\", k);\n\t\t\tint result = find(root, k);\n\t\t\tif (result == 1) {\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (strcmp(str, \"delete\") == 0) {\n\t\t\tstr = strtok_s(NULL, \" \\n\", &context);\n\t\t\tk = atoi(str);\n\t\t\t//printf(\"--delete %d\\n\", k);\n\t\t\troot = delete(root, k);\n\t\t}\n\t\telse if (strcmp(str, \"print\") == 0) {\n\t\t\t//printf(\"--print\\n\");\n\t\t\tprint_inorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tprint_preorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse {\n\t\t\t//printf(\"error\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nstruct T{\n    int key,priority;\n    T *parent,*left,*right;\n};\n    T *root=NULL;\nT* rightRotate(T *t){\n    T *s=t->left;\n    t->left=s->right;\n    s->right=t;\n    if(t==root){\n        root=s;\n    }\n    return s;\n}\nT* leftRotate(T *t){\n    T *s=t->right;\n    t->right=s->left;\n    s->left=t;\n    if(t==root){\n        root=s;\n    }\n    return s;\n}\nT* insert(T *t,int key,int priority){\n    if(t==NULL){\n        T *r= new T();\n        r->key=key;\n        r->priority=priority;\n        r->left=r->right=NULL;\n        return r;\n    }\n    if(key==t->key){\n        return t;\n    }\n    if(key < t->key){\n        t->left=insert(t->left,key,priority);\n        if(t->priority < t->left->priority){\n            t=rightRotate(t);\n        }\n    }\n    else{\n        t->right=insert(t->right,key,priority);\n        if(t->priority < t->right->priority){\n            t=leftRotate(t);\n        }\n    }\n    return t;\n}\nT* Tfind(T *x,int k){\n    T *z=new T();\n    *z={NULL};\n    z->key=k;\n    while(x!=NULL){\n        if(z->key==x->key){\n            return x;\n        }\n        if(z->key < x->key){\n            x=x->left;\n        }\n        else{\n            x=x->right;\n        }\n    }\n    return NULL;\n}\nT* Tdelete(T *t, int key);\nT* _delete(T *t,int key){\n    if(t==NULL){\n        return NULL;\n    }\n    if(key < t->key){\n        t->left=_delete(t->left,key);\n    }\n    else if(key > t->key){\n        t->right=_delete(t->right,key);\n    }\n    else{\n        return Tdelete(t,key);\n    }\n    return t;\n}\nT* Tdelete(T *t,int key){\n    if(t->left==NULL && t->right==NULL){\n        return NULL;\n    }\n    else if(t->left==NULL){\n        t=leftRotate(t);\n    }\n    else if(t->right==NULL){\n        t=rightRotate(t);\n    }\n    else{\n        if(t->left->priority > t->right->priority){\n            t=rightRotate(t);\n        }\n        else{\n            t=leftRotate(t);\n        }\n    }\n    return _delete(t,key);\n}\nvoid Preorder(T *root){\n    if(root!=NULL){\n        cout<<\" \"<<root->key;\n        Preorder(root->left);\n        Preorder(root->right);\n    }\n}\nvoid Inorder(T *root){\n    if(root!=NULL){\n        Inorder(root->left);\n        cout<<\" \"<<root->key;\n        Inorder(root->right);\n    }\n}\nint main(){\n    int n,key,priority;\n    string s;\n    cin>>n;\n    for(int i=0;i<n;i++){\n        cin>>s;\n        if(s==\"insert\"){\n            cin>>key>>priority;\n            T *t=insert(root,key,priority);\n            if (root == NULL) {\n\t\t\t\troot = t;\n\t\t\t}\n        }\n        else if(s==\"find\"){\n            cin>>key;\n            if(Tfind(root,key)!=NULL){\n                cout<<\"yes\"<<endl;\n            }\n            else{\n                cout<<\"no\"<<endl;\n            }\n        }\n        else if(s==\"delete\"){\n            cin>>key;\n            _delete(root,key);\n        }\n        else{\n            Inorder(root);\n            cout<<endl;\n            Preorder(root);\n            cout<<endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct Node{\n  Node *right, *left;\n  int key, priority;\n};\n\nNode* node(int k, int p){\n  Node *newNode = (Node *)malloc(sizeof(Node));\n  newNode->right = NULL;\n  newNode->left = NULL;\n  newNode->key = k;\n  newNode->priority = p;\n  return newNode;\n}\n\nNode* rightRotate(Node *t){\n  Node *s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s; //the new root of subtree\n}\n\nNode* leftRotate(Node *t){\n  Node *s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s; //the new root of subtree\n}\n\nNode* insertT(Node *t, int k, int p){\n  //when you reach the leaf\n  if(t == NULL) return node(k, p);  //create a new Node\n  //ignore duplicated keys\n  if(k == t->key) return t;\n\n  if(k < t->key){  //move to the left child\n    //update the pointer to the left child\n    t->left = insertT(t->left, k, p);\n    //if the left child has higher priority\n    if(t->priority < t->left->priority) t = rightRotate(t);\n  }else{//move to the right child\n    //update the pointer t the right child\n    t->right = insertT(t->right, k, p);\n    //if the right child has higher priority\n    if(t->priority < t->right->priority) t = leftRotate(t);\n  }\n\n  return t;\n}\n\nNode* find(Node* t, int k){\n  while(t != NULL && k != t->key){//leafじゃない && みつかっていない\n    if(k < t->key) t = t->left;\n    else t = t->right;\n  }\n  return t;\n}\n\n Node* deleteNode(Node *t, int k){\n  if(t == NULL) return NULL;\n  //if t is the targer node\n  if(k == t->key){\n    //if t is a leaf\n    if(t->left == NULL && t->right == NULL) return NULL;\n    //if t has only the right child\n    else if(t->left == NULL) t = leftRotate(t);\n    //if t has only the left child\n    else if(t->right == NULL) t = rightRotate(t);\n    //if t has both the left and right child\n    else{\n      //pull up the child with higher priority\n      if(t->left->priority > t->right->priority) t = rightRotate(t);\n      else t = leftRotate(t);\n    }\n    return deleteNode(t, k);\n  }\n\n  //search the targer recursively\n  if(k < t->key) t->left = deleteNode(t->left, k);\n  else t->right = deleteNode(t->right, k);\n\n  return t;\n}\n\nvoid inorder(Node* t){\n  if(t == NULL) return;\n  inorder(t->left);\n  printf(\" %d\", t->key);\n  inorder(t->right);\n}\n\nvoid preorder(Node* t){\n  if(t == NULL) return;\n  printf(\" %d\", t->key);\n  preorder(t->left);\n  preorder(t->right);\n}\n\nvoid print(Node* t){\n  inorder(t);\n  printf(\"\\n\");\n  preorder(t);\n  printf(\"\\n\");\n}\n\nint main(){\n  int n, k, p;\n  string com;\n  Node *t;//root\n\n  cin >> n;\n  for(int i=0 ; i<n ; ++i){\n    cin >> com;\n    if(com == \"insert\"){\n      cin >> k >> p;\n      t = insertT(t, k, p);\n    }else if(com == \"delete\"){\n      cin >> k;\n      t = deleteNode(t, k);\n    }else if(com == \"print\"){\n      print(t);\n    }else if(com == \"find\"){\n      cin >> k;\n      Node* n = find(t, k);\n      if(n != NULL) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x,y) CPP_CAT_I(x,y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x,y) x ## y\n\n#define SFINAE(pred...) std::enable_if_t<(pred), std::nullptr_t> = nullptr\n\n#define ASSERT(expr...) assert((expr))\n\nusing i8  = int8_t;\nusing u8  = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\n\nusing f32 = float;\nusing f64 = double;\nusing f80 = __float80;\n// }}}\n\nconstexpr i64 INF  = INT64_C(1'010'000'000'000'000'017);\nconstexpr f64 FINF = 1e100;\n\nconstexpr i64 MOD = INT64_C(1'000'000'007);\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// util {{{\n#define FOR(i, start, end) for(i64 i = (start), CPP_CAT(i,xxxx_end)=(end); i < CPP_CAT(i,xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n\n#define LIFT(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\ntemplate<typename C>\nconstexpr i64 SIZE(const C& c) noexcept { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\nconstexpr i64 SIZE(const T (&)[N]) noexcept { return static_cast<i64>(N); }\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmax(T& xmax, const U& x, Comp comp={}) noexcept {\n    if(comp(xmax, x)) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmin(T& xmin, const U& x, Comp comp={}) noexcept {\n    if(comp(x, xmin)) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc&& bf, UnaryFunc&& uf) {\n    return [bf=forward<BinaryFunc>(bf),uf=forward<UnaryFunc>(uf)](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F&& f) {\n    return ON(less<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto GT_ON(F&& f) {\n    return ON(greater<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto EQ_ON(F&& f) {\n    return ON(equal_to<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto NE_ON(F&& f) {\n    return ON(not_equal_to<>{}, forward<F>(f));\n}\n\n// tuple {{{\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(const tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(const tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n// }}}\n\n// container {{{\ntemplate<typename T> struct is_container : false_type {};\ntemplate<typename T, size_t N> struct is_container<array<T,N>> : true_type {};\ntemplate<typename... Args> struct is_container<vector<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<deque<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<forward_list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multimap<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multimap<Args...>> : true_type {};\n\ntemplate<typename T, typename Enable=void>\nstruct ProconHash {\n    size_t operator()(const T& x) const noexcept {\n        return hash<T>{}(x);\n    }\n};\n\ntemplate<typename T>\nsize_t procon_hash_value(const T& x) noexcept {\n    return ProconHash<T>{}(x);\n}\n\nsize_t procon_hash_combine(size_t h1, size_t h2) noexcept {\n    constexpr size_t M = UINT64_C(0xc6a4a7935bd1e995);\n    constexpr int    R = 47;\n\n    h2 *= M;\n    h2 ^= h2 >> R;\n    h2 *= M;\n\n    h1 ^= h2;\n    h1 *= M;\n\n    h1 += 0xe6546b64;\n\n    return h1;\n}\n\ntemplate<typename T1, typename T2>\nstruct ProconHash<pair<T1,T2>> {\n    size_t operator()(const pair<T1,T2>& p) const noexcept {\n        size_t h1 = procon_hash_value(p.first);\n        size_t h2 = procon_hash_value(p.second);\n        return procon_hash_combine(h1, h2);\n    }\n};\n\ntemplate<typename... TS>\nstruct ProconHash<tuple<TS...>> {\n    size_t operator()(const tuple<TS...>& t) const noexcept {\n        size_t h = 0;\n        tuple_enumerate(t, [&h](const auto& e) {\n            h = procon_hash_combine(h, procon_hash_value(e));\n        });\n        return h;\n    }\n};\n\ntemplate<typename C>\nstruct ProconHash<C,enable_if_t<is_container<C>::value>> {\n    size_t operator()(const C& c) const noexcept {\n        size_t h = 0;\n        for(const auto& e : c)\n            h = procon_hash_combine(h, procon_hash_value(e));\n        return h;\n    }\n};\n\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashSet = unordered_set<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMap = unordered_map<K,V,Hash,Eq>;\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashMultiset = unordered_multiset<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMultimap = unordered_multimap<K,V,Hash,Eq>;\n\ntemplate<typename T>\nusing MaxHeap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\ntemplate<typename T>\nauto vec_make(i64 n, T x) {\n    return vector<T>(n, x);\n}\n\ntemplate<typename T, typename... Args, SFINAE(sizeof...(Args) >= 2)>\nauto vec_make(i64 n, Args... args) {\n    auto inner = vec_make<T>(args...);\n    return vector<decltype(inner)>(n, inner);\n}\n\ntemplate<typename T, size_t N, size_t... NS>\nstruct ArrayType {\n    using type = array<typename ArrayType<T,NS...>::type,N>;\n};\n\ntemplate<typename T, size_t N>\nstruct ArrayType<T,N> {\n    using type = array<T,N>;\n};\n\ntemplate<typename T, size_t... NS>\nusing Array = typename ArrayType<T,NS...>::type;\n\ntemplate<typename T, size_t N>\nT& array_at(Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nT& array_at(Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, size_t N>\nconst T& array_at(const Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nconst T& array_at(const Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T>\nauto reserve_vec(i64 cap) {\n    vector<T> res;\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nauto reserve_hash_set(i64 cap, f32 load_max=0.25) {\n    HashSet<T,Hash,Eq> res;\n    res.max_load_factor(load_max);\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nauto reserve_hash_map(i64 cap, f32 load_max=0.25) {\n    HashMap<K,V,Hash,Eq> res;\n    res.max_load_factor(load_max);\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nauto reserve_hash_multiset(i64 cap, f32 load_max=0.25) {\n    HashMultiset<T,Hash,Eq> res;\n    res.max_load_factor(load_max);\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nauto reserve_hash_multimap(i64 cap, f32 load_max=0.25) {\n    HashMultimap<K,V,Hash,Eq> res;\n    res.max_load_factor(load_max);\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename C, typename Comp>\nT POP(priority_queue<T,C,Comp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n// }}}\n\n// fixpoint {{{\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<typename F>\nconstexpr decltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate<typename F, size_t... NS>\nclass FixPointMemo {\npublic:\n    explicit FixPointMemo(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    decltype(auto) operator()(Args... args) const {\n        using R = decltype(f_(*this,args...));\n        static Array<bool,NS...> done {};\n        static Array<R,NS...>    memo;\n\n        if(!array_at<bool,NS...>(done,args...)) {\n            array_at<R,NS...>(memo,args...) = f_(*this,args...);\n            array_at<bool,NS...>(done,args...) = true;\n        }\n        return array_at<R,NS...>(memo,args...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<size_t... NS, typename F>\ndecltype(auto) FIXMEMO(F&& f) {\n    return FixPointMemo<F,NS...>(forward<F>(f));\n}\n// }}}\n\n// input {{{\ntemplate<typename T, typename Enable=void>\nstruct Scan {\n    static T scan(istream& in) {\n        T res;\n        in >> res;\n        return res;\n    }\n};\n\ntemplate<typename T, typename Enable=void>\nstruct Scan1;\n\ntemplate<typename T>\nstruct Scan1<T,enable_if_t<is_integral<T>::value && !is_same<T,bool>::value>> {\n    static T scan1(istream& in) {\n        return Scan<T>::scan(in) - 1;\n    }\n};\n\ntemplate<typename T=i64>\nT RD() {\n    return Scan<T>::scan(cin);\n}\n\ntemplate<typename T=i64>\nT RD1() {\n    return Scan1<T>::scan1(cin);\n}\n\ntemplate<typename T=i64>\nauto RD_VEC(i64 n) {\n    auto res = reserve_vec<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD<T>());\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD1_VEC(i64 n) {\n    auto res = reserve_vec<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD1<T>());\n    }\n    return res;\n}\n// }}}\n\n// output {{{\ntemplate<typename T, typename Enable=void>\nstruct Fmt {\n    static void fmt(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid fmt_write(ostream& out, const T& x) {\n    Fmt<T>::fmt(out, x);\n}\n\ntemplate<typename... TS>\nstruct Fmt<tuple<TS...>> {\n    static void fmt(ostream& out, const tuple<TS...>& t) {\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << ' ';\n            fmt_write(out, e);\n        });\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Fmt<pair<T1,T2>> {\n    static void fmt(ostream& out, const pair<T1,T2>& p) {\n        return fmt_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Fmt<C,enable_if_t<is_container<C>::value>> {\n    static void fmt(ostream& out, const C& c) {\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << ' ';\n            fmt_write(out, *it);\n        }\n    }\n};\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS&... args) {\n    fmt_write(cout, x);\n    if(sizeof...(args) > 0) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS&... args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n// }}}\n\n// debug {{{\ntemplate<typename T, typename Enable=void>\nstruct Dbg {\n    static void dbg(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid dbg_write(ostream& out, const T& x) {\n    return Dbg<T>::dbg(out, x);\n}\n\ntemplate<>\nstruct Dbg<i64> {\n    static void dbg(ostream& out, i64 x) {\n        if(x == INF)\n            out << \"INF\";\n        else if(x == -INF)\n            out << \"-INF\";\n        else\n            out << x;\n    }\n};\n\ntemplate<>\nstruct Dbg<f64> {\n    static void dbg(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF)\n            out << \"FINF\";\n        else if(x == -FINF)\n            out << \"-FINF\";\n        else\n            out << x;\n#pragma GCC diagnostic pop\n    }\n};\n\ntemplate<typename T, size_t N>\nstruct Dbg<T[N]> {\n    static void dbg(ostream& out, const T (&ary)[N]) {\n        out << \"[\";\n        REP(i, N) {\n            if(i != 0) out << \",\";\n            dbg_write(out, ary[i]);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename... TS>\nstruct Dbg<tuple<TS...>> {\n    static void dbg(ostream& out, const tuple<TS...>& t) {\n        out << \"(\";\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << \",\";\n            dbg_write(out, e);\n        });\n        out << \")\";\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Dbg<pair<T1,T2>> {\n    static void dbg(ostream& out, const pair<T1,T2>& p) {\n        return dbg_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Dbg<C,enable_if_t<is_container<C>::value>> {\n    static void dbg(ostream& out, const C& c) {\n        out << \"[\";\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << \",\";\n            dbg_write(out, *it);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    dbg_write(cerr, value);\n    cerr << \"\\n\";\n}\n\ntemplate<typename... TS>\nvoid DBG_IMPL(i64 line, const char* expr, const TS&... value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << \"(\" << expr << \") = \";\n    dbg_write(cerr, make_tuple(value...));\n    cerr << \"\\n\";\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value == 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>&, const array<i64,N>&) {\n    dbg_write(out, x);\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>& sizes, const array<i64,N>& offs) {\n    i64 k   = N - rank<T>::value;\n    i64 off = offs[k];\n    i64 siz = sizes[k];\n    if(siz == 0) siz = extent<T>::value - off;\n\n    out << \"[\";\n    FOR(i, off, off+siz) {\n        if(i != off) out << \",\";\n        DBG_DP_IMPL_HELPER(out, x[i], sizes, offs);\n    }\n    out << \"]\";\n}\n\ntemplate<typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL(i64 line, const char* expr, const T& dp,\n                 const array<i64,rank<T>::value>& sizes={},\n                 const array<i64,rank<T>::value>& offs={})\n{\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    DBG_DP_IMPL_HELPER<rank<T>::value>(cerr, dp, sizes, offs);\n    cerr << \"\\n\";\n}\n\n#ifdef PROCON_LOCAL\n    #define DBG(args...) DBG_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_DP(args...) DBG_DP_IMPL(__LINE__, CPP_STR_I(args), args)\n#else\n    #define DBG(args...)\n    #define DBG_DP(args...)\n#endif\n// }}}\n\n// modint {{{\ntemplate<i64 P>\nstruct ModPT {\n    static_assert(P >= 2, \"P must be a prime\");\n    i64 v_;  // [0,P)\n\n    ModPT() : v_(0) {}\n    ModPT(i64 v) {\n        i64 r = v % P;\n        v_ = r >= 0 ? r : r+P;\n    }\n\n    ModPT operator-() const {\n        return ModPT(-v_);\n    }\n    ModPT& operator+=(ModPT rhs) {\n        v_ += rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n    ModPT& operator-=(ModPT rhs) {\n        v_ += P;\n        v_ -= rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n    ModPT& operator*=(ModPT rhs) {\n        v_ *= rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n\n    ModPT& operator++() {\n        return *this += 1;\n    }\n    ModPT& operator--() {\n        return *this -= 1;\n    }\n    ModPT operator++(int) {\n        return exchange(*this, *this+1);\n    }\n    ModPT operator--(int) {\n        return exchange(*this, *this-1);\n    }\n\n    explicit operator i64() const { return v_; }\n};\n\ntemplate<i64 P>\nModPT<P> operator+(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) += rhs; }\ntemplate<i64 P>\nModPT<P> operator+(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) += rhs; }\ntemplate<i64 P>\nModPT<P> operator+(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) += lhs; }\ntemplate<i64 P>\nModPT<P> operator-(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) -= rhs; }\ntemplate<i64 P>\nModPT<P> operator-(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) -= rhs; }\ntemplate<i64 P>\nModPT<P> operator-(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) -= lhs; }\ntemplate<i64 P>\nModPT<P> operator*(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) *= rhs; }\ntemplate<i64 P>\nModPT<P> operator*(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) *= rhs; }\ntemplate<i64 P>\nModPT<P> operator*(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) *= lhs; }\n\ntemplate<i64 P>\nbool operator==(ModPT<P> lhs, ModPT<P> rhs) { return lhs.v_ == rhs.v_; }\ntemplate<i64 P>\nbool operator==(ModPT<P> lhs, i64 rhs) { return lhs == ModPT<P>(rhs); }\ntemplate<i64 P>\nbool operator==(i64 lhs, ModPT<P> rhs) { return ModPT<P>(lhs) == rhs; }\ntemplate<i64 P>\nbool operator!=(ModPT<P> lhs, ModPT<P> rhs) { return !(lhs == rhs); }\ntemplate<i64 P>\nbool operator!=(ModPT<P> lhs, i64 rhs) { return !(lhs == rhs); }\ntemplate<i64 P>\nbool operator!=(i64 lhs, ModPT<P> rhs) { return !(lhs == rhs); }\n\ntemplate<i64 P>\nstruct Scan<ModPT<P>> {\n    static ModPT<P> scan(istream& in) {\n        return Scan<i64>::scan(in);\n    }\n};\n\ntemplate<i64 P>\nstruct Fmt<ModPT<P>> {\n    static void fmt(ostream& out, ModPT<P> x) {\n        fmt_write(out, x.v_);\n    }\n};\n\ntemplate<i64 P>\nstruct Dbg<ModPT<P>> {\n    static void dbg(ostream& out, ModPT<P> x) {\n        dbg_write(out, x.v_);\n    }\n};\n\nusing ModP = ModPT<MOD>;\n// }}}\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cin.exceptions(ios::failbit | ios::badbit);\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n//--------------------------------------------------------------------\n\nstruct Treap {\n    struct Node {\n        i64 val;\n        i64 pri;\n        Node* l{nullptr};\n        Node* r{nullptr};\n        Node(i64 v, i64 p) : val(v), pri(p) {}\n    };\n\n    Node* root_{nullptr};\n\n    Treap() {}\n\n    Node* find(i64 x) const {\n        for(Node* t = root_; t; ) {\n            if(x == t->val) return t;\n            t = x < t->val ? t->l : t->r;\n        }\n        return nullptr;\n    }\n\n    void insert(i64 x, i64 pri) {\n        root_ = insert_impl(root_, x, pri);\n    }\n\n    void erase(i64 x) {\n        root_ = erase_impl(root_, x);\n    }\n\n    void print() const {\n        print_inorder(root_);\n        PRINTLN();\n        print_preorder(root_);\n        PRINTLN();\n    }\n\nprivate:\n    // 挿入後の部分木(Treap条件を満たす)の根を返す\n    Node* insert_impl(Node* t, i64 x, i64 pri) {\n        if(!t) return new Node(x,pri);  // 単一ノードはTreap条件を満たす\n        if(x == t->val) return t;\n\n        if(x < t->val) {\n            t->l = insert_impl(t->l, x, pri);  // Treap条件を満たした部分木の根\n            if(t->pri < t->l->pri)\n                t = rotate_r(t);\n        }\n        else {\n            t->r = insert_impl(t->r, x, pri);\n            if(t->pri < t->r->pri)\n                t = rotate_l(t);\n        }\n\n        return t;\n    }\n\n    // 消去対象ノードを葉まで移動してから消去\n    // 消去後の部分木(Treap条件を満たす)の根を返す\n    Node* erase_impl(Node* t, i64 x) {\n        if(!t) return nullptr;  // 空の木はTreap条件を満たす\n\n        if(x == t->val) return erase_impl_node(t, x);\n\n        if(x < t->val)\n            t->l = erase_impl(t->l, x);\n        else\n            t->r = erase_impl(t->r, x);\n\n        return t;\n    }\n\n    // t は消去対象ノード\n    // 消去後の部分木(Treap条件を満たす)の根を返す\n    Node* erase_impl_node(Node* t, i64 x) {\n        // 葉まで来たら消去\n        if(!t->l && !t->r) {\n            delete t;\n            return nullptr;\n        }\n\n        if(!t->l)\n            t = rotate_l(t);\n        else if(!t->r)\n            t = rotate_r(t);\n        else\n            t = t->l->pri > t->r->pri ? rotate_r(t) : rotate_l(t);\n\n        return erase_impl(t, x);\n    }\n\n    // 右の子と親子関係を入れ替える\n    Node* rotate_l(Node* t) {\n        Node* s = t->r;\n        t->r = s->l;\n        s->l = t;\n        return s;\n    }\n\n    // 左の子と親子関係を入れ替える\n    Node* rotate_r(Node* t) {\n        Node* s = t->l;\n        t->l = s->r;\n        s->r = t;\n        return s;\n    }\n\n    void print_inorder(Node* t) const {\n        if(!t) return;\n\n        print_inorder(t->l);\n        PRINT(\" \");\n        PRINT(t->val);\n        print_inorder(t->r);\n    }\n\n    void print_preorder(Node* t) const {\n        if(!t) return;\n\n        PRINT(\" \");\n        PRINT(t->val);\n        print_preorder(t->l);\n        print_preorder(t->r);\n    }\n};\n\nvoid solve() {\n    Treap treap;\n\n    i64 Q = RD();\n    REP(_, Q) {\n        auto cmd = RD<string>();\n\n        if(cmd == \"insert\") {\n            i64 x   = RD();\n            i64 pri = RD();\n            treap.insert(x, pri);\n        }\n        else if(cmd == \"find\") {\n            i64 x = RD();\n            Treap::Node* t = treap.find(x);\n            PRINTLN(t ? \"yes\" : \"no\");\n        }\n        else if(cmd == \"delete\") {\n            i64 x = RD();\n            treap.erase(x);\n        }\n        else if(cmd == \"print\") {\n            treap.print();\n        }\n        else {\n            ASSERT(false);\n        }\n    }\n}\n\nsigned main() {\n    \n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\n#define track(); cout<<\"#############\"<<endl;\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\ntypedef struct node{\n  struct node *l=NULL;\n  struct node *r=NULL;\n  int key=0;\n  int pri=0;\n}Node;\n\nNode* RightRotate(Node *t){\n  Node *s=t->l;\n  t->l=s->r;\n  s->r=t;\n  return s;\n}\n\nNode* LeftRotate(Node *t){\n  Node *s=t->r;\n  t->r=s->l;\n  s->l=t;\n  return s;\n}\n\nNode* ins(Node* t,int key,int pri){\n  if(t==NULL){\n    t=(Node*)malloc(sizeof(Node));\n    t->l=NULL;\n    t->r=NULL;\n    t->key=key;\n    t->pri=pri;\n    return t;\n  }\n  if(key==t->key)return t;\n  if(key<t->key){\n    t->l = ins(t->l,key,pri);\n    if(t->pri < t->l->pri)t=RightRotate(t);\n  }\n  else {\n    t->r = ins(t->r,key,pri);\n    if(t->pri < t->r->pri)t=LeftRotate(t);\n  }\n  return t;\n}\n\nbool find(Node *t,int key){\n  if(t==NULL)return false;\n  if(t->key==key)return true;\n  if(key<t->key)return find(t->l,key);\n  return find(t->r,key);\n}\n\nNode* del(Node *t,int key){\n  if(t==NULL)return NULL;\n  if(key==t->key){\n    if(t->l==NULL && t->r==NULL){\n      return NULL;\n    }\n    else if(t->l==NULL){\n      t=LeftRotate(t);\n    }\n    else if(t->r==NULL){\n      t=RightRotate(t);\n    }\n    else {\n      if(t->l->pri >t->r->pri)\n        t=RightRotate(t);\n      else \n        t=LeftRotate(t);\n    }\n    return del(t,key);\n  }\n\n  if(key<t->key)\n    t->l = del(t->l,key);\n  else \n    t->r = del(t->r,key);\n  return t;\n}\n\nvoid inorder(node *t){\n  if(t->l != NULL)inorder(t->l);\n  cout<<\" \"<<t->key;\n  if(t->r != NULL)inorder(t->r);\n}\n\nvoid preorder(node *t){\n  cout<<\" \"<<t->key;\n  if(t->l != NULL)preorder(t->l);\n  if(t->r != NULL)preorder(t->r);\n}\n\nint main()\n{\n  int n,a,b;\n  string s;\n  Node *t=NULL;\n  cin>>n;\n  FOR(i,0,n){\n    cin>>s;\n    if(s==\"insert\"){\n      cin>>a>>b;\n      t=ins(t,a,b);\n    }\n    else if(s==\"find\"){\n      cin>>a;\n      if(find(t,a))cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n    }\n    else if(s==\"delete\"){\n      cin>>a;\n      t=del(t,a);\n    }\n    else {\n      inorder(t);\n      cout<<endl;\n      preorder(t);\n      cout<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nstruct node {\n    int value, priority;\n    node *left = nullptr, *right = nullptr, *parent = nullptr;\n    node(int x, int y) {\n        value = x;\n        priority = y;\n    }\n};\n\nstruct treap {\n    node* root = nullptr;\n    int size = 0;\n    treap() {}\n    void insert(int v, int pri) {\n        size++;\n        node* p = nullptr;\n        node* c = root;\n        while (c != nullptr) {\n            p = c;\n            if (v < c->value) {\n                c = c->left;\n            } else {\n                c = c->right;\n            }\n        }\n        if (p == nullptr) {\n            root = new node(v, pri);\n        } else if (v < p->value) {\n            p->left = new node(v, pri);\n            p->left->parent = p;\n        } else {\n            p->right = new node(v, pri);\n            p->right->parent = p;\n        }\n        while (p != nullptr) {\n            node* l = p->left;\n            node* r = p->right;\n            if (l != nullptr && p->priority < l->priority) {\n                p = right_rotate(p)->parent;\n            } else if (r != nullptr && p->priority < r->priority) {\n                p = left_rotate(p)->parent;\n            } else {\n                break;\n            }\n        }\n        if (p != nullptr && p->parent == nullptr) { root = p; }\n    }\n    node* right_rotate(node* p) {\n        node* c = p->left;\n        if (root == p) { root = c; }\n        p->left = c->right;\n        if (c->right != nullptr) { c->right->parent = p; }\n        if (p->parent != nullptr) {\n            if (p->parent->left == p) {\n                p->parent->left = c;\n            } else {\n                p->parent->right = c;\n            }\n        }\n        c->right = p;\n        c->parent = p->parent;\n        p->parent = c;\n        return c;\n    }\n    node* left_rotate(node* p) {\n        node* c = p->right;\n        if (root == p) { root = c; }\n        p->right = c->left;\n        if (c->left != nullptr) { c->left->parent = p; }\n        if (p->parent != nullptr) {\n            if (p->parent->left == p) {\n                p->parent->left = c;\n            } else {\n                p->parent->right = c;\n            }\n        }\n        c->left = p;\n        c->parent = p->parent;\n        p->parent = c;\n        return c;\n    }\n    node* find(int v) {\n        node* x = root;\n        while (x != nullptr) {\n            if (v < x->value) {\n                x = x->left;\n            } else if (v > x->value) {\n                x = x->right;\n            } else {\n                return x;\n            }\n        }\n        return nullptr;\n    }\n    void print_inorder(node* now) {\n        if (now->left != nullptr) { print_inorder(now->left); }\n        std::cout << \" \" << now->value;\n        if (now->right != nullptr) { print_inorder(now->right); }\n    }\n    void print_preorder(node* now) {\n        std::cout << \" \" << (*now).value;\n        if (now->left != nullptr) { print_preorder(now->left); }\n        if (now->right != nullptr) { print_preorder(now->right); }\n    }\n    void print() {\n        if (root != nullptr) { print_inorder(root); }\n        std::cout << std::endl;\n        if (root != nullptr) { print_preorder(root); }\n        std::cout << std::endl;\n    }\n    void delete_1(node* t, int v) {\n        node* l = t->left;\n        node* r = t->right;\n        if (l == nullptr && r == nullptr) {\n            if (root == t) { root = nullptr; }\n            if (t->parent != nullptr) {\n                if (t->parent->left == t) {\n                    t->parent->left = nullptr;\n                } else {\n                    t->parent->right = nullptr;\n                }\n            }\n            delete t;\n        } else if (l == nullptr) {\n            delete_2(left_rotate(t), v);\n        } else if (r == nullptr) {\n            delete_2(right_rotate(t), v);\n        } else if (l->priority > r->priority) {\n            delete_2(right_rotate(t), v);\n        } else {\n            delete_2(left_rotate(t), v);\n        }\n    }\n    void delete_2(node* t, int v) {\n        if (t == nullptr) {\n            ;\n        } else if (v < t->value) {\n            delete_2(t->left, v);\n        } else if (v > t->value) {\n            delete_2(t->right, v);\n        } else {\n            delete_1(t, v);\n        }\n    }\n    void destruct(node* now) {\n        if ((*now).left != nullptr) { destruct((*now).left); }\n        if ((*now).right != nullptr) { destruct((*now).right); }\n        delete now;\n    }\n    ~treap() {\n        if (root != nullptr) { destruct(root); };\n    }\n};\n\nint main() {\n    int n;\n    treap tr;\n    std::cin >> n;\n    for (int i = 0; i < n; i++) {\n        std::string s;\n        std::cin >> s;\n        if (s == \"insert\") {\n            int x, y;\n            std::cin >> x >> y;\n            tr.insert(x, y);\n        } else if (s == \"find\") {\n            int x;\n            std::cin >> x;\n            if (tr.find(x) == nullptr) {\n                std::cout << \"no\" << std::endl;\n            } else {\n                std::cout << \"yes\" << std::endl;\n            }\n        } else if (s == \"delete\") {\n            int x;\n            std::cin >> x;\n            tr.delete_2(tr.root, x);\n        } else {\n            tr.print();\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n\ntypedef struct _node {\n\tint key;\n\tint priority;\n\tstruct _node * left;\n\tstruct _node * right;\n\tstruct _node * parent;\n} node;\n\nnode * left_rotate(node * t) {\n\tnode * new_t = t->right;\n\tt->right = new_t->left;\n\tnew_t->left = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * right_rotate(node * t) {\n\tnode * new_t = t->left;\n\tt->left = new_t->right;\n\tnew_t->right = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * create_node(int key, int priority) {\n\tnode * p;\n\tp = (node *)malloc(sizeof(node));\n\tp->key = key;\n\tp->priority = priority;\n\tp->left = NULL;\n\tp->right = NULL;\n\tp->parent = NULL;\n\treturn p;\n}\n\nnode * insert(node * t, int key, int priority) {\n\tif (t == NULL) {\n\t\tnode * p = create_node(key, priority);\n\t\treturn p;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->left = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->left, key, priority);\n\t\t}\n\t\t\t\t\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\telse if (key > t->key) {\n\t\tif (t->right == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->right = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->right, key, priority);\n\t\t}\n\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\t\n\treturn t;\n}\n\nnode * delete_node(node * t, int key) {\n\tif (key == t->key) {\n\t\tif (t->left == NULL && t->right == NULL) {\n\t\t\tif (t->parent->left == t) {\n\t\t\t\tt->parent->left = NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt->parent->right = NULL;\n\t\t\t}\n\t\t\tfree(t);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (t->left == NULL) {\n\t\t\tt = left_rotate(t);\t\n\t\t}\n\t\telse if (t->right == NULL) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse if (t->left->priority > t->right->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\tt = delete_node(t, key);\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete_node(t->left, key);\n\t\treturn t;\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete_node(t->right, key);\n\t\treturn t;\n\t}\n}\n\nint find(node * t, int key) {\n\tif (key == t->key) {\n\t\treturn 1;\n\t}\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->left, key);\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->right, key);\n\t}\n}\n\nvoid print_preorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->left != NULL) {\n\t\tprint_preorder(t->left);\n\t}\n\tif (t->right != NULL) {\n\t\tprint_preorder(t->right);\n\t}\n}\n\nvoid print_inorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tif (t->left != NULL) {\n\t\tprint_inorder(t->left);\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->right != NULL) {\n\t\tprint_inorder(t->right);\n\t}\n}\n\nint main() {\n\tint m;\n\tstd::string buf;\n\tstd::string str;\n\tint k, p;\n\tnode * root = NULL;\n\n\tstd::getline(std::cin, buf);\n\tstd::stringstream ss0(buf);\n\tss0 >> m;\n\n\tfor (int i = 0; i < m; i++) {\n\t\tstd::getline(std::cin, buf);\n\t\tstd::stringstream ss(buf);\n\t\tstd::getline(ss, str, ' ');\n\t\tif (str == \"insert\") {\n\t\t\tss >> k >> p;\n\t\t\t//printf(\"--insert %d %d\\n\", k, p);\n\t\t\troot = insert(root, k, p);\n\t\t}\n\t\telse if (str == \"find\") {\n\t\t\tss >> k;\n\t\t\t//printf(\"--find %d\\n\", k);\n\t\t\tint result = find(root, k);\n\t\t\tif (result == 1) {\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (str ==\"delete\") {\n\t\t\tss >> k;\n\t\t\t//printf(\"--delete %d\\n\", k);\n\t\t\troot = delete_node(root, k);\n\t\t}\n\t\telse if (str == \"print\") {\n\t\t\t//printf(\"--print\\n\");\n\t\t\tprint_inorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tprint_preorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"error\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstruct Node{\n    int key, priority;\n    Node *left, *right;\n};\n\nNode *rightRotate(Node *t){\n    Node *s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s; \n}\n\nNode *leftRotate(Node *t){\n    Node *s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s; \n}\n\nNode *insert(Node *t, int key, int priority){\n    if(t==NULL){\n        Node *n = new Node();\n        n->key = key;\n        n->priority = priority;\n        n->left = n->right = NULL;\n        return n;\n    } \n    if(t->key == key) return t; \n    \n    if(t->key > key){\n        t->left = insert(t->left, key, priority);\n        if(t->priority < t->left->priority) t = rightRotate(t);\n    }\n    else{\n        t->right = insert(t->right, key, priority);\n        if(t->priority < t->right->priority) t = leftRotate(t);\n    }\n    return t;\n}\n\nNode *delNode(Node* t, int key);\nNode *delSearch(Node *t, int key){\n    if(t == NULL) return NULL;\n\n    if(t->key > key) t->left = delSearch(t->left, key);\n    else if(t->key < key) t->right = delSearch(t->right, key);\n    else return delNode(t, key);\n    return t;\n}\n\nNode *delNode(Node* t, int key){\n    if(t->left == NULL && t->right == NULL) return NULL;\n    else if(t->left == NULL) t = leftRotate(t);\n    else if(t->right == NULL) t = rightRotate(t);\n    else{\n        if(t->left->priority > t->right->priority)\n            t = rightRotate(t);\n        else\n            t = leftRotate(t);\n    }\n    return delSearch(t, key);\n}\n\n\nNode *find(Node* node, int key){\n    while(node!=NULL && key!=node->key){\n        if(key < node->key) node = node->left;\n        else node = node->right;\n        }\n    return node;\n}\nvoid inorder(Node *u){\n    if(u==NULL) return;\n    inorder(u->left);\n    cout << \" \" << u->key;\n    inorder(u->right);\n}\nvoid preorder(Node *u){\n    if(u==NULL) return;\n    cout << \" \" << u->key;\n    preorder(u->left);\n    preorder(u->right);\n}\nvoid print(Node *root){\n    inorder(root);\n    cout << endl;\n    preorder(root);\n    cout << endl;\n}\n\n\n\nint main(){\n    Node *root=NULL;\n    int n,key,priority;\n    string com;\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n        cin >> com;\n        if(com == \"print\"){\n            print(root);\n        }\n        else{\n            cin >> key;\n            if(com == \"find\"){\n             Node *u = find(root, key);\n             if(u != NULL) cout << \"yes\" << endl;\n            else cout << \"no\" << endl;\n            }  \n            else if(com == \"delete\"){\n            root = delSearch(root, key);\n            }\n            else if(com == \"insert\"){\n            cin >> priority;\n            root = insert(root, key, priority);\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <cstdio>\n#include <cstdint>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <list>\n#include <random>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\n\ntemplate <typename T>\nstruct Treap{\n  random_device rnd;\n  struct Node{\n    T key;\n    int pri;\n    Node *l, *r;\n    Node(T key, int pri): key(key), pri(pri), l(nullptr), r(nullptr){}\n    ~Node(){\n      delete l;\n      delete r;\n    }\n  };\n  using Tree = Node *;\n  Tree root = nullptr;\n  size_t _size = 0;\n\n  Treap(){}\n  size_t size(){\n    return _size;\n  }\n  void split(Tree t, T key, Tree &l, Tree &r){\n    if(!t){\n      l = r = nullptr;\n    }else if(key < t->key){\n      split(t->l, key, l, t->l);\n      r = t;\n    }else{\n      split(t->r, key, t->r, r);\n      l = t;\n    }\n  }\n  void merge(Tree &t, Tree l, Tree r){\n    if(!l || !r){\n      if(!l)t = r;\n      if(!r)t = l;\n      return;\n    }\n    if(l->pri > r->pri){\n      merge(l->r, l->r, r);\n      t = l;\n    }else{\n      merge(r->l, l, r->l);\n      t = r;\n    }\n  }\n  void insert(Tree &t, Tree n){\n    if(!t)t = n;\n    else if(n->pri > t->pri){\n      split(t, n->key, n->l, n->r);\n      t = n;\n    }else{\n      if(n->key < t->key)insert(t->l, n);\n      else insert(t->r, n);\n    }\n  }\n  void insert(T key){\n    insert(root, new Node(key, rnd()));\n    _size++;\n  }\n  void insert(T key, T pri){\n    insert(root, new Node(key, pri));\n    _size++;\n  }\n  void erase(Tree &t, T key){\n    if(t->key == key){\n      merge(t, t->l, t->r);\n      _size--;\n    }else{\n      if(key < t->key)erase(t->l, key);\n      else erase(t->r, key);\n    }\n  }\n  void erase(T key){\n    erase(root, key);\n  }\n  bool find(Tree &t, T key){\n    if(!t)return false;\n    else if(t->key == key)return true;\n    else{\n      if(key < t->key)return find(t->l, key);\n      else return find(t->r, key);\n    }\n  }\n  bool find(T key){\n    return find(root, key);\n  }\n  void dfs_t(){\n    dfs_t(root);\n    cout << endl;\n  }\n  void dfs_s(){\n    dfs_s(root);\n    cout << endl;\n  }\n  void dfs_t(Tree node){\n    if(!node)return;\n    if(node->l){\n      dfs_t(node->l);\n    }\n    cout << \" \" << node->key;\n    if(node->r){\n      dfs_t(node->r);\n    }\n  }\n  void dfs_s(Tree node){\n    if(!node)return;\n    cout << \" \" << node->key;\n    if(node->l){\n      dfs_s(node->l);\n    }\n    if(node->r){\n      dfs_s(node->r);\n    }\n  }\n};\n\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  int m;\n  cin >> m;\n  Treap<ll> tr;\n  rep(i_, m){\n    string s;\n    cin >> s;\n    if(s == \"insert\"){\n      ll k, p;\n      cin >> k >> p;\n      tr.insert(k, p);\n    }else if(s == \"find\"){\n      ll k;\n      cin >> k;\n      if(tr.find(k))cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }else if(s == \"delete\"){\n      ll k;\n      cin >> k;\n      if(tr.find(k))tr.erase(k);\n    }else{\n      tr.dfs_t();\n      tr.dfs_s();\n    }\n  }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <iomanip>\n#include <queue>\n#include <list>\n#include <stack>\n#include <cctype>\n#include <cmath>\n\nusing namespace std;\n\n/* typedef */\n\ntypedef long long ll;\n\n/* constant */\nconst int INF = 1 << 30;\nconst int MAX = 500000;\nconst int mod = 1000000007;\nconst double pi = 3.141592653589;\n/* global variables */\nstruct Node {\n    Node *left, \n         *right;\n    int key,\n        priority;\n};\n\nNode *root, *NIL;\n\n/* function */\n\nNode* rightRotate(Node* t);\nNode* leftRotate(Node* t);\nNode* insert(Node* t, int key, int priority);\nNode* Delete(Node* t, int key);\nNode* _delete(Node* t, int key);\nNode* findNode(int key);\nvoid preorder(Node* v);\nvoid inorder(Node* v);\n\n/* main */\nint main(){\n\n    // main\n    int n, val, pri;\n    cin >> n;\n    string man;\n    for (int i = 0; i < n; i++) {\n        cin >> man;\n        if (man == \"print\") {\n            inorder(root); cout << '\\n';\n            preorder(root); cout << '\\n';\n        }\n        else {\n            cin >> val;\n            if (man == \"insert\") {\n                cin >> pri;\n                root = insert(root, val, pri);\n            }\n            else if (man == \"delete\" ) {\n                Node* target = findNode(val);\n                root = Delete(root, val);\n            }\n            else {\n                Node* ret_node = findNode(val);\n                if (ret_node != NIL)\n                    cout << \"yes\" << '\\n';\n                else\n                    cout << \"no\" << '\\n';\n            }\n        }\n    }\n\n}\n\nNode* rightRotate(Node* t) {\n    Node* s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;  // root of the subtree\n}\n\nNode* leftRotate(Node* t) {\n    Node* s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;  // root of the subtree\n}\n\nNode* insert(Node* t, int key, int priority) {          // 再帰的に探索\n    if (t == NIL){\n        Node* N = new Node();              // 葉に到達したら新しい節点を生成して返す\n        N->left = NIL;\n        N->right = NIL;\n        N->key = key;\n        N->priority = priority;\n        return N;\n    }\n\n    if (key == t->key)\n        return t;                                 // 重複したkeyは無視\n\n    if (key < t->key) {                          // 左の子へ移動\n        t->left = insert(t->left, key, priority);  // 左の子へのポインタを更新\n        if (t->priority < t->left->priority)          // 左の子の方が優先度が高い場合右回転\n            t = rightRotate(t);\n    }\n    else {                                       // 右の子へ移動\n        t->right = insert(t->right, key, priority);  // 右の子へのポインタを更新\n        if (t->priority < t->right->priority)         // 右の子の方が優先度が高い場合左回転\n            t = leftRotate(t);\n    }\n\n  return t;\n}\n\nNode* Delete(Node* t, int key) {\n    if (t == NIL)\n        return NIL;\n    if (key < t->key)                               // 削除対象を検索\n        t->left = Delete(t->left, key);\n    else if (key > t->key)\n        t->right = Delete(t->right, key);\n    else\n        return _delete(t, key);\n    return t;\n}\n\nNode* _delete(Node* t, int key) { // 削除対象の節点の場合\n    if (t->left == NIL && t->right == NIL)          // 葉の場合\n        return NIL;\n    else if (t->left == NIL)                       // 右の子のみを持つ場合左回転\n        t = leftRotate(t);\n    else if (t->right == NIL)                      // 左の子のみを持つ場合右回転\n        t = rightRotate(t);\n    else {                                        // 左の子と右の子を両方持つ場合\n        if (t->left->priority > t->right->priority)    // 優先度が高い方を持ち上げる\n            t = rightRotate(t);\n        else\n            t = leftRotate(t);\n    }\n    return Delete(t, key);\n}\n\nNode* findNode(int key) {\n    Node* x = root;\n    while (x != NIL) {\n        if (key == x->key) \n            return x;\n        else if (key < x->key)                               // 削除対象を検索\n            x = x->left;\n        else if (key > x->key)\n            x = x->right;\n        }\n    return x;\n}\n \nvoid preorder(Node* v) {\n    if (v != NIL) {\n        cout << ' ' << v->key;\n        preorder(v->left);\n        preorder(v->right);\n    }\n\n}\n\nvoid inorder(Node* v) {\n    if (v != NIL) {\n        inorder(v->left);\n        cout << ' ' << v->key;\n        inorder(v->right);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct Node{\n  Node *right, *left;\n  int key, priority;\n};\n\nNode* node(int k, int p){\n  Node *newNode = (Node *)malloc(sizeof(Node));\n  newNode->right = NULL;\n  newNode->left = NULL;\n  newNode->key = k;\n  newNode->priority = p;\n  return newNode;\n}\n\nNode* rightRotate(Node *t){\n  Node *s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s; //the new root of subtree\n}\n\nNode* leftRotate(Node *t){\n  Node *s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s; //the new root of subtree\n}\n\nNode* insertT(Node *t, int k, int p){\n  //when you reach the leaf\n  if(t == NULL) return node(k, p);  //create a new Node\n  //ignore duplicated keys\n  if(k == t->key) return t;\n\n  if(k < t->key){  //move to the left child\n    //update the pointer to the left child\n    t->left = insertT(t->left, k, p);\n    //if the left child has higher priority\n    if(t->priority < t->left->priority) t = rightRotate(t);\n  }else{//move to the right child\n    //update the pointer t the right child\n    t->right = insertT(t->right, k, p);\n    //if the right child has higher priority\n    if(t->priority < t->right->priority) t = leftRotate(t);\n  }\n\n  return t;\n}\n\nNode* find(Node* t, int k){\n  while(t != NULL && k != t->key){//leafじゃない && みつかっていない\n    if(k < t->key) t = t->left;\n    else t = t->right;\n  }\n  return t;\n}\n\n Node* deleteNode(Node *t, int k){\n  if(t == NULL) return NULL;\n  //if t is the targer node\n  if(k == t->key){\n    //if t is a leaf\n    if(t->left == NULL && t->right == NULL) return NULL;\n    //if t has only the right child\n    else if(t->left == NULL) t = leftRotate(t);\n    //if t has only the left child\n    else if(t->right == NULL) t = rightRotate(t);\n    //if t has both the left and right child\n    else{\n      //pull up the child with higher priority\n      if(t->left->priority > t->right->priority) t = rightRotate(t);\n      else t = leftRotate(t);\n    }\n    return deleteNode(t, k);\n  }\n\n  //search the targer recursively\n  if(k < t->key) t->left = deleteNode(t->left, k);\n  else t->right = deleteNode(t->right, k);\n\n  return t;\n}\n\nvoid inorder(Node* t){\n  if(t == NULL) return;\n  inorder(t->left);\n  printf(\" %d\", t->key);\n  inorder(t->right);\n}\n\nvoid preorder(Node* t){\n  if(t == NULL) return;\n  printf(\" %d\", t->key);\n  preorder(t->left);\n  preorder(t->right);\n}\n\nvoid print(Node* t){\n  inorder(t);\n  printf(\"\\n\");\n  preorder(t);\n  printf(\"\\n\");\n}\n\nint main(){\n  int n, k, p;\n  string com;\n  Node *t;//root\n\n  cin >> n;\n  for(int i=0 ; i<n ; ++i){\n    cin >> com;\n\n    if(com == \"insert\"){\n      cin >> k >> p;\n      if(i==0){\n        t = node(k, p);\n        continue;\n      }\n      insertT(t, k, p);\n    }else if(com == \"delete\"){\n      cin >> k;\n      t = deleteNode(t, k);\n    }else if(com == \"print\"){\n      print(t);\n    }else if(com == \"find\"){\n      cin >> k;\n      Node* n = find(t, k);\n      if(n != NULL) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define rep(i, n) for (ll i = 0; i < n; ++i)\nll dx[4] = { 0, 1, 0, -1 };\nll dy[4] = { 1, 0, -1, 0 };\nconst ll INF = LLONG_MAX;\nconst ll MOD = 1e9 + 7;\n\nstruct Node {\n    int key;\n    int priority;\n    Node *left, *right;\n};\n\nNode *root, *NIL;\n\nNode* _delete(Node* t, int key);\n\nNode* rightRorate(Node* t)\n{\n    Node* s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n}\n\nNode* leftRotate(Node* t)\n{\n    Node* s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;\n}\n\nNode* insert(Node* t, int key, int priority) // 再帰的に検索\n{\n    if (t == NIL) { // 葉に到達したら新しい節点を生成して返す\n        Node* ret = (Node*)malloc(sizeof(Node));\n        ret->key = key;\n        ret->priority = priority;\n        ret->left = NIL;\n        ret->right = NIL;\n        return ret;\n    }\n    if (key == t->key) { // 重複したkeyは無視\n        return t;\n    }\n    if (key < t->key) { // 左の子へ移動\n        t->left = insert(t->left, key, priority); // 左の子のポインタを更新\n        if (t->priority < t->left->priority) { // 左の子の優先度が高い場合右回転\n            t = rightRorate(t);\n        }\n    } else { // 右の子へ移動\n        t->right = insert(t->right, key, priority); // 右の子へのポインタを更新\n        if (t->priority < t->right->priority) { // 右の子の方が優先度が高い場合左回転\n            t = leftRotate(t);\n        }\n    }\n    return t;\n}\n\nNode* treeDelete(Node* t, int key)\n{\n    if (t == NIL) {\n        return NIL;\n    }\n    if (key < t->key) { // 削除対象を検索\n        t->left = treeDelete(t->left, key);\n    } else if (key > t->key) {\n        t->right = treeDelete(t->right, key);\n    } else {\n        return _delete(t, key);\n    }\n    return t;\n}\n\nNode* _delete(Node* t, int key)\n{\n    if (t->left == NIL && t->right == NIL) { // 葉の場合\n        return NIL;\n    } else if (t->left == NIL) { // 右の子のみを持つ場合左回転\n        t = leftRotate(t);\n    } else if (t->right == NIL) { // 左の子のみを持つ場合右回転\n        t = rightRorate(t);\n    } else { // 左の子と右の子を両方持つ場合\n        if (t->left->priority > t->right->priority) { // 優先度が高い方を持ち上げる\n            t = rightRorate(t);\n        } else {\n            t = leftRotate(t);\n        }\n    }\n    return treeDelete(t, key);\n}\n\nNode* find(Node* u, int x)\n{\n    while (!(u == NIL || u->key == x)) {\n        if (u->key < x) {\n            u = u->right;\n        } else {\n            u = u->left;\n        }\n    }\n    return u;\n}\n\nvoid inorder(Node* u)\n{\n    if (u == NIL) {\n        return;\n    }\n    inorder(u->left);\n    printf(\" %d\", u->key);\n    inorder(u->right);\n}\n\nvoid preorder(Node* u)\n{\n    if (u == NIL) {\n        return;\n    }\n    printf(\" %d\", u->key);\n    preorder(u->left);\n    preorder(u->right);\n}\n\nvoid print()\n{\n    inorder(root);\n    printf(\"\\n\");\n    preorder(root);\n    printf(\"\\n\");\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int m;\n    cin >> m;\n    rep(i, m)\n    {\n        int k, p;\n        string com;\n        cin >> com;\n        if (com == \"insert\") {\n            cin >> k >> p;\n            root = insert(root, k, p);\n        } else if (com == \"print\") {\n            print();\n        } else if (com == \"find\") {\n            cin >> k;\n            Node* t = find(root, k);\n            if (t != NIL) {\n                puts(\"yes\");\n            } else {\n                puts(\"no\");\n            }\n        } else if (com == \"delete\") {\n            cin >> k;\n            root = treeDelete(root, k);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename Type>\nstruct node_t {\n    Type value, sum;\n    node_t* child[2]; // left, right\n    double priority;\n    int size_st;\n\n    node_t(Type val, double pri)\n    :   value(val), \n        sum(1),\n        priority(pri),\n        size_st(1)\n    {\n        child[0] = child[1] = NULL;\n    }\n};\n\ntemplate<typename Type>\nstruct Treap {\nprivate:\n    node_t<Type>* root;\n    int  size(node_t<Type>* t) {return !t ? 0 : t->size_st;}\n    Type sum (node_t<Type>* t) {return !t ? 0 : t->sum    ;}\n\n    // 部分木に関する情報の再計算 (子が変わった時とかに必要)\n    node_t<Type>* update(node_t<Type>* t) {\n        t->size_st = size(t->child[0]) + size(t->child[1]) + 1       ;\n        t->sum     = sum (t->child[0]) + sum (t->child[1]) + t->value;\n        return t;\n    }\n\n    // t を根とする部分木の回転 (左右どちらも)\n    // 新しく根になるノードを返すとあとあと楽\n    node_t<Type>* rotate(node_t<Type>* t, int b) {\n        node_t<Type>* s = t->child[1 - b];\n        t->child[1 - b] = s->child[b];\n        s->child[b    ] = t;\n        update(t); update(s);\n        return s;\n    }\n\n    // t が根である木に (val, pri) のノードを挿入\n    // k 番目に入れたければ、インデックスを指定可能\n    // 根ノードのポインタを返す\n    node_t<Type>* insert(node_t<Type>* t, Type val, double pri, int k=-1) {\n        if(!t) return new node_t<Type>(val, pri);\n        int b, nk;\n        if(k >= 0) {\n            int c = size(t->child[0]);\n            b = (k > c);\n            nk = k - (b ? (c+1) : 0);\n        }\n        else {\n            b = (t->value) < val;\n            nk = k;\n        }\n\n        t->child[b] = insert(t->child[b], val, pri, nk);\n        update(t);\n\n        if( (t->priority) < (t->child[b]->priority) ) t = rotate(t, 1-b);\n        return t;\n    }\n\n    // val が含まれるかどうか\n    node_t<Type>* find_node(node_t<Type>* t, Type val) {\n        if(!t) return NULL;\n        if( (t->value) == val ) return t;\n\n        int c = (t->value) < val;\n        return find_node(t->child[c], val);\n    }\n\n    // t を根とする部分木に対して、val をキーとするノードを削除\n    // 根ノードのポインタを返す\n    node_t<Type>* erase(node_t<Type>* t, Type val) {\n        if(t == NULL) return NULL;\n        if(val < t->value) {\n            t->child[0] = erase(t->child[0], val);\n        }\n        else if(val > t->value) {\n            t->child[1] = erase(t->child[1], val);\n        }\n        else {\n            return erase_inside(t, val);\n        }\n        update(t);\n        return t;\n    }\n\n    node_t<Type>* erase_inside(node_t<Type>* t, Type val) {\n        if(t->child[0] == NULL && t->child[1] == NULL) {\n            delete t;\n            return NULL;\n        }\n        else if(t->child[0] == NULL) {\n            t = rotate(t, 0);\n        }\n        else if(t->child[1] == NULL) {\n            t = rotate(t, 1);\n        }\n        else {\n            if(t->child[0]->priority > t->child[1]->priority) {\n                t = rotate(t, 1);\n            }\n            else {\n                t = rotate(t, 0);\n            }\n        }\n        return erase(t, val);\n    }\n\npublic:\n    Treap()             {root = NULL;      }\n    int size()          {return size(root);}\n    int sum ()          {return sum (root);}\n    void insert(Type val, double pri) {\n        // 重複を許さない\n        if(find(val)) return;\n        root = insert(root, val, pri);\n    }\n    bool find(Type val) {\n        return (find_node(root, val) != NULL);\n    }\n    void erase(Type val) {\n        root = erase(root, val);\n    }\n\n    void print_preorder(node_t<Type>* cur) {\n        printf(\" %lld\", cur->value);\n        if(cur->child[0] != NULL) print_preorder(cur->child[0]);\n        if(cur->child[1] != NULL) print_preorder(cur->child[1]);\n    }\n\n    void print_inorder(node_t<Type>* cur) {\n        if(cur->child[0] != NULL) print_inorder(cur->child[0]);\n        printf(\" %lld\", cur->value);\n        if(cur->child[1] != NULL) print_inorder(cur->child[1]);\n    }\n\n    void print() {\n        print_inorder(root);\n        printf(\"\\n\");\n        print_preorder(root);\n        printf(\"\\n\");\n    }\n};\n\nint main() {\n    int Q; cin >> Q;\n\n    Treap<long long int> mp;\n    while(Q--) {\n        string s; long long int key, pri;\n        cin >> s;\n\n        if(s == \"insert\") {\n            cin >> key >> pri;\n            mp.insert(key, pri);\n        }\n        if(s == \"find\") {\n            cin >> key;\n            cout << (mp.find(key) ? \"yes\" : \"no\") << endl;\n        }\n        if(s == \"delete\") {\n            cin >> key;\n            mp.erase(key);\n        }\n        if(s == \"print\") {\n            mp.print();\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point{\n\tint a,b;\n\tpoint *l,*r,*pa;\n\tpoint(){l=r=pa=NULL;}\n\tpoint(int aa,int bb):a(aa),b(bb){l=r=pa=NULL;};\n};\npoint *root;\npoint *rightRotate(point *t){\n\tpoint *s=t->l;\n\tt->l=s->r;\n\ts->r=t;\n\treturn s;\n}\npoint *leftRotate(point *t){\n\tpoint *s=t->r;\n\tt->r=s->l;\n\ts->l=t;\n\treturn s;\n}\npoint* insert(point *p,int a,int b){\n\tif(p==NULL)return new point(a,b);\n\tif(a==p->a)return p;\n\tif(a<p->a){\n\t\tp->l=insert(p->l,a,b);\n\t\tif(p->b<p->l->b)\n\t\t\tp=rightRotate(p);\n\t}else{\n\t\tp->r=insert(p->r,a,b);\n\t\tif(p->b<p->r->b)\n\t\t\tp=leftRotate(p);\n\t}return p;\n}\npoint *_del(point *p, int a);\npoint *del(point *p,int a){\n\tif(p==NULL)return NULL;\n\tif(a<p->a)p->l=del(p->l,a);\n\telse if(a>p->a)p->r=del(p->r,a);\n\telse return _del(p,a);\n\treturn p;\n}\npoint *_del(point *p, int a){\n\tif(p->l==NULL&&p->r==NULL)return NULL;\n\telse if(p->l==NULL)p=leftRotate(p);\n\telse if(p->r==NULL)p=rightRotate(p);\n\telse{\n\t\tif(p->l->b>p->r->b)p=rightRotate(p);\n\t\telse p=leftRotate(p);\n\t}return del(p,a);\n}\nbool find(int a){\n\tpoint *p=root;\n\twhile(p){\n\t\tif(a==p->a)return 1;\n\t\tif(a>p->a)p=p->r;\n\t\telse p=p->l;\n\t}\n\treturn 0;\n}\nvoid dfs1(point *p){\n\tif(!p)return;\n\tdfs1(p->l);\n\tprintf(\" %d\",p->a);\n\tdfs1(p->r);\n}\nvoid dfs2(point *p){\n\tif(!p)return;\n\tprintf(\" %d\",p->a);\n\tdfs2(p->l);\n\tdfs2(p->r);\n}\nint main(){\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\tint T;cin>>T;\n\tint ta,tb;\n\tstring s;\n\twhile(cin>>s){\n\t\tif(s==\"insert\"){\n\t\t\tcin>>ta>>tb;\n//\t\t\tif(!root)root=new point(ta,tb);\n//\t\t\telse \n\t\t\troot=insert(root,ta,tb);\n\t\t}else if(s==\"find\"){\n\t\t\tcin>>ta;\n\t\t\tif(find(ta))printf(\"yes\\n\");\n\t\t\telse printf(\"no\\n\");\n\t\t}else if(s==\"print\"){\n\t\t\tdfs1(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tdfs2(root);\n\t\t\tprintf(\"\\n\");\n\t\t}else if(s==\"delete\"){\n\t\t\tcin>>ta;\n\t\t\troot=del(root,ta);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(), (x).end()\n\nusing namespace std;\n\ntemplate <typename T> T &chmin(T &a, const T &b) {return a = min(a, b);}\ntemplate <typename T> T &chmax(T &a, const T &b) {return a = max(a, b);}\n\nusing ll = long long;\nusing ld = long double;\n\nconst int INF = 1e9;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nstruct Node{\n  int k;\n  int p;\n  Node* lc = NULL;\n  Node* rc = NULL;\n  Node(int k, int p) : k(k), p(p){}\n};\n\nNode* rightRotate(Node* n){\n  Node* l = n->lc;\n  if(l!=NULL){\n    n->lc = l->rc;\n    l->rc = n;\n  }\n  return l;\n}\n\nNode* leftRotate(Node* n){\n  Node* r = n->rc;\n  if(r!=NULL){\n    n->rc = r->lc;\n    r->lc = n;\n  }\n  return r;\n}\n\nvoid preorder(Node* n){\n  if(n==NULL) return;\n  cout << \" \" << n->k;\n  preorder(n->lc);\n  preorder(n->rc);\n  return;\n}\n\nvoid inorder(Node* n){\n  if(n==NULL) return;\n  inorder(n->lc);\n  cout << \" \" << n->k;\n  inorder(n->rc);\n  return;\n}\n\nNode* ins(Node* n, int k, int p){\n  if(n==NULL) { return new Node(k, p); }\n  if(k==n->k) return n;\n  if(k<n->k){\n    n->lc = ins(n->lc, k, p);\n    if(n->p<n->lc->p) n = rightRotate(n);\n  } else {\n    n->rc = ins(n->rc, k, p);\n    if(n->p<n->rc->p) n = leftRotate(n);\n  }\n  return n;\n}\n\nbool fnd(Node* n, int k){\n  if(n==NULL) return false;\n  if(n->k==k) return true;\n  return (n->k>k ? fnd(n->lc, k) : fnd(n->rc, k));\n}\n\nNode* del(Node* n, int k);\n\nNode* exec_del(Node* n,int k){\n  if(n->lc==NULL && n->rc==NULL) { delete n; return NULL; }\n  if(n->lc==NULL) n = leftRotate(n);\n  else if(n->rc==NULL) n = rightRotate(n);\n  else{\n    if(n->lc->p > n->rc->p) n = rightRotate(n);\n    else n = leftRotate(n);\n  }\n  return del(n, k);\n}\n\nNode* del(Node* n, int k){\n  if(n==NULL) return NULL;\n  if(k<n->k) n->lc = del(n->lc, k);\n  else if(k>n->k) n->rc = del(n->rc, k);\n  else return exec_del(n, k);\n  return n;\n}\n\nvoid prt(Node* n){\n  inorder(n);\n  cout << endl;\n  preorder(n);\n  cout << endl;\n  return;\n}\n\nint main(){\n  int n;\n  cin >> n;\n  char str[10];\n  int k, p;\n  Node* top = NULL;\n  REP(i, n){\n    scanf(\"%s\", str);\n    if(str[0]=='i'){\n      cin >> k >> p;\n      top = ins(top, k, p);\n    } else if (str[0]=='f'){\n      cin >> k;\n      cout << (fnd(top, k) ? \"yes\" : \"no\") << endl;\n    } else if (str[0]=='d'){\n      cin >> k;\n      top = del(top, k);\n    } else {\n      prt(top);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n\n#define BIG_NUM 200000000\n#define HUGE_NUM 999999999999\n#define MOD 100000007\n#define EPS 0.0000000001\nusing namespace std;\n\n#define SIZE 200005\n\nstruct Node {\n    int key, priority;\n    int left, right;\n};\n\nint num_nodes, root;\nNode nodes[SIZE];\n\nint leftRotate(int node_id) {\n    //node_id番のノードの右側の子valueをretに代入\n    int ret = nodes[node_id].right;\n    \n    //ret番のノードの左側の子valueを右側の子のノードに代入\n    nodes[node_id].right = nodes[ret].left;\n    nodes[ret].left = node_id;\n    \n    return ret;\n}\n\nint rightRotate(int node_id) {\n    int ret = nodes[node_id].left;\n    nodes[node_id].left = nodes[ret].right;\n    nodes[ret].right = node_id;\n    \n    return ret;\n}\n\nint insert(int node_id, int key, int priority) {\n    if(node_id == -1) {\n        //葉に到達したら新しい節点を生成して返す\n        nodes[num_nodes].key      = key;\n        nodes[num_nodes].priority = priority;\n        nodes[num_nodes].left     = -1;\n        nodes[num_nodes].right    = -1;\n        \n        num_nodes++;\n        return num_nodes - 1;\n    }\n    \n    if(nodes[node_id].key == key) {\n        //重複したkeyは無視\n        return node_id;\n    }\n    \n    if(nodes[node_id].key > key) {\n        //左の子のポインタを更新\n        nodes[node_id].left = insert(nodes[node_id].left, key, priority);\n        \n        if(nodes[node_id].priority < nodes[nodes[node_id].left].priority) {\n           //左の子の方がpriority値が高いなら右回転\n            node_id = rightRotate(node_id);\n        }\n    }else {\n        nodes[node_id].right = insert(nodes[node_id].right, key, priority);\n        if(nodes[node_id].priority < nodes[nodes[node_id].right].priority) {\n            node_id = leftRotate(node_id);\n        }\n    }\n    return node_id;\n}\n\nint DELETE(int node_id, int key);\n\nint DELETE_2(int node_id, int key) {\n    //削除対象の節点の場合・・・\n    \n    if(nodes[node_id].left == -1 && nodes[node_id].right == -1) {\n        //葉のとき\n        return -1;\n    }else if(nodes[node_id].left == -1) {\n        //右の子のみを持つ場合は左回転\n        node_id = leftRotate(node_id);\n    }else if(nodes[node_id].right == -1) {\n        //左の子のみを持つ場合は右回転\n        node_id = rightRotate(node_id);\n    }else {\n        //左右の子を持つときはpriorityが高い方を引き上げる\n        if(nodes[nodes[node_id].left].priority > nodes[nodes[node_id].right].priority) {\n            node_id = rightRotate(node_id);\n        }else {\n            node_id = leftRotate(node_id);\n        }\n    }\n    return DELETE(node_id, key);\n}\n\nint DELETE(int node_id, int key) {\n    if(num_nodes == 0 || node_id == -1) {\n        return -1;\n    }\n    //削除対象を検索\n    if(nodes[node_id].key > key) {\n        nodes[node_id].left = DELETE(nodes[node_id].left, key);\n    }else if(nodes[node_id].key < key) {\n        nodes[node_id].right = DELETE(nodes[node_id].right, key);\n    }else {\n        return DELETE_2(node_id, key);\n    }\n    \n    return node_id;\n}\n\nvoid find(int key) {\n    if(num_nodes == 0) {\n        printf(\"no\\n\");\n        return;\n    }\n    \n    int current_node = root;\n    \n    while(true) {\n        if(nodes[current_node].key == key) {\n            printf(\"yes\\n\");\n            return;\n        }else if(nodes[current_node].key > key) {\n            current_node = nodes[current_node].left;\n        }else {\n            current_node = nodes[current_node].right;\n        }\n        \n        if(current_node == -1) {\n            printf(\"no\\n\");\n            return;\n        }\n    }\n}\n\nvoid in_order(int node_id) {\n    if(node_id == -1) return;\n    \n    if(nodes[node_id].left != -1) {\n        in_order(nodes[node_id].left);\n    }\n    \n    printf(\" %d\", nodes[node_id].key);\n    \n    if(nodes[node_id].right != -1) {\n        in_order(nodes[node_id].right);\n    }\n}\n\nvoid pre_order(int node_id) {\n    if(node_id == -1) return;\n    \n    printf(\" %d\", nodes[node_id].key);\n    if(nodes[node_id].left != -1) {\n        pre_order(nodes[node_id].left);\n    }\n    if(nodes[node_id].right != -1) {\n        pre_order(nodes[node_id].right);\n    }\n}\n\nint main() {\n    num_nodes = 0;\n    \n    int M;\n    scanf(\"%d\", &M);\n    \n    char command[10];\n    int key, priority;\n    \n    root = -1;\n    \n    for(int loop = 0; loop < M; loop++) {\n        scanf(\"%s\", command);\n        \n        switch(command[0]) {\n            case 'i':\n                scanf(\"%d %d\", &key, &priority);\n                root = insert(root, key, priority);\n                break;\n            \n            case 'f':\n                scanf(\"%d\", &key);\n                find(key);\n                break;\n                \n            case 'd':\n                scanf(\"%d\", &key);\n                root = DELETE(root, key);\n                break;\n            \n            case 'p':\n            if(num_nodes == 0) break;\n            \n            in_order(root);\n            printf(\"\\n\");\n            pre_order(root);\n            printf(\"\\n\");\n            \n            break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<map>\n#include<set>\n#include<cstring>\n#include<string>\n#include<stack>\n#include<stdlib.h>\n#include<math.h>\nusing namespace std;\n//#define int long long\ntypedef pair<int, int> pii;\ntypedef pair<int, char> pic;\ntypedef priority_queue<pii, vector<pii>, greater<pii> > RPQ;\n#define mk make_pair\n#define INF (1 << 30)\n#define INFL (1ll << 60ll)\n#define mod 1000000007\ntypedef struct node * nodept;\n\nstruct node{\n    int key = -1;\n    int priority = -1;\n    node *right;\n    node *left;\n};\n\nnodept nil, root;\n\nvoid init(){\n    nil = (nodept)malloc(sizeof(node));\n    nil->left = nil;\n    nil->right = nil;\n\n    root = nil;\n}\n\nnodept gennode(int key, int priority, nodept left = nil, nodept right = nil){\n    nodept t = (nodept)malloc(sizeof(node));\n    *t = {key, priority, left, right};\n    return t;\n}\n\nnodept rightRotate(nodept t){\n    nodept s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n}\n\nnodept leftRotate(nodept t){\n    nodept s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;\n}\n\nnodept insert(nodept t, int key, int priority){\n    if(t == nil){\n        return gennode(key, priority);\n    }\n    if(key == t->key)return t;\n\n    if(key < t->key){\n        t->left = insert(t->left, key, priority);\n        if(t->priority < t->left->priority){\n            t = rightRotate(t);\n        }\n    }\n    else {\n        t->right = insert(t->right, key, priority);\n        if(t->priority < t->right->priority){\n            t = leftRotate(t);\n        }\n    }\n    return t;\n}\n\nnodept _Delete(nodept t, int key);\n\nnodept Delete(nodept t, int key){\n    if(t == nil){\n        return nil;\n    }\n    if(key < t->key){\n        t->left = Delete(t->left, key);\n    }\n    else if(key > t->key){\n        t->right = Delete(t->right, key);\n    }\n    else {\n        return _Delete(t, key);\n    }\n    return t;\n}\n\nnodept _Delete(nodept t, int key){\n    if(t->left == nil && t->right == nil){\n        return nil;\n    }\n    else if(t->left == nil){\n        t = leftRotate(t);\n    }\n    else if(t->right == nil){\n        t = rightRotate(t);\n    }\n    else {\n        if(t->left->priority > t->right->priority){\n            t = rightRotate(t);\n        }\n        else {\n            t = leftRotate(t);\n        }\n    }\n    return Delete(t, key);\n}\n\nnodept find(nodept t, int key){\n    if(t == nil)return nil;\n    if(key < t->key){\n        return find(t->left, key);\n    }\n    else if(key > t->key){\n        return find(t->right, key);\n    }\n    else {\n        return t;\n    }\n}\n\nvoid indfs(nodept t){\n    if(t == nil)return;\n    indfs(t->left);\n    printf(\" %d\", t->key);\n    indfs(t->right);\n}\n\nvoid predfs(nodept t){\n    if(t == nil)return;\n    printf(\" %d\", t->key);\n    predfs(t->left);\n    predfs(t->right);\n}\n\nsigned main(){\n    int M;\n    cin >> M;\n    init();\n    for(int i = 0; i < M; i++){\n        char query[10];\n        cin >> query;\n        int key;\n        if(query[0] == 'i'){\n            int priority;\n            cin >> key >> priority;\n            root = insert(root, key, priority);\n        }\n        else if(query[0] == 'f'){\n            cin >> key;\n            if(find(root, key) != nil){\n                printf(\"yes\\n\");\n            }\n            else printf(\"no\\n\");\n        }\n        else if(query[0] == 'd'){\n            cin >> key;\n            root = Delete(root, key);\n        }\n        else {\n            indfs(root);\n            printf(\"\\n\");\n            predfs(root);\n            printf(\"\\n\");\n        }\n    }\n\n\n    return 0;\n}\n\n/*\n\n\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n\ntypedef struct _node {\n\tint key;\n\tint priority;\n\tstruct _node * left;\n\tstruct _node * right;\n\tstruct _node * parent;\n} node;\n\nnode * left_rotate(node * t) {\n\tnode * new_t = t->right;\n\tt->right = new_t->left;\n\tnew_t->left = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * right_rotate(node * t) {\n\tnode * new_t = t->left;\n\tt->left = new_t->right;\n\tnew_t->right = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * create_node(int key, int priority) {\n\tnode * p;\n\tp = (node *)malloc(sizeof(node));\n\tp->key = key;\n\tp->priority = priority;\n\tp->left = NULL;\n\tp->right = NULL;\n\tp->parent = NULL;\n\treturn p;\n}\n\nnode * insert(node * t, int key, int priority) {\n\tif (t == NULL) {\n\t\tnode * p = create_node(key, priority);\n\t\treturn p;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->left = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->left, key, priority);\n\t\t}\n\t\t\t\t\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\telse if (key > t->key) {\n\t\tif (t->right == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->right = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->right, key, priority);\n\t\t}\n\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\t\n\treturn t;\n}\n\nnode * delete_node(node * t, int key) {\n\tif (key == t->key) {\n\t\tif (t->left == NULL && t->right == NULL) {\n\t\t\tif (t->parent->left == t) {\n\t\t\t\tt->parent->left = NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt->parent->right = NULL;\n\t\t\t}\n\t\t\tfree(t);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (t->left == NULL) {\n\t\t\tt = left_rotate(t);\t\n\t\t}\n\t\telse if (t->right == NULL) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse if (t->left->priority > t->right->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\tt = delete_node(t, key);\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete_node(t->left, key);\n\t\treturn t;\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete_node(t->right, key);\n\t\treturn t;\n\t}\n}\n\nint find(node * t, int key) {\n\tif (key == t->key) {\n\t\treturn 1;\n\t}\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->left, key);\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->right, key);\n\t}\n}\n\nvoid print_preorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->left != NULL) {\n\t\tprint_preorder(t->left);\n\t}\n\tif (t->right != NULL) {\n\t\tprint_preorder(t->right);\n\t}\n}\n\nvoid print_inorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tif (t->left != NULL) {\n\t\tprint_inorder(t->left);\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->right != NULL) {\n\t\tprint_inorder(t->right);\n\t}\n}\n\nint main() {\n\tint m;\n\tstd::string buf;\n\tstd::string str;\n\tint k, p;\n\tnode * root = NULL;\n\n\tstd::getline(std::cin, buf);\n\tm = stoi(buf);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tstd::getline(std::cin, buf);\n\t\tstd::stringstream ss(buf);\n\t\tstd::getline(ss, str, ' ');\n\t\tif (str == \"insert\") {\n\t\t\tstd::getline(ss, str, ' ');\n\t\t\tk =\tstoi(str);\n\t\t\tstd::getline(ss, str, ' ');\n\t\t\tp = stoi(str);\n\t\t\t//printf(\"--insert %d %d\\n\", k, p);\n\t\t\troot = insert(root, k, p);\n\t\t}\n\t\telse if (str == \"find\") {\n\t\t\tstd::getline(ss, str, ' '); \n\t\t\tk = stoi(str);\n\t\t\t//printf(\"--find %d\\n\", k);\n\t\t\tint result = find(root, k);\n\t\t\tif (result == 1) {\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (str ==\"delete\") {\n\t\t\tstd::getline(ss, str, ' ');\n\t\t\tk = stoi(str);\n\t\t\t//printf(\"--delete %d\\n\", k);\n\t\t\troot = delete_node(root, k);\n\t\t}\n\t\telse if (str == \"print\") {\n\t\t\t//printf(\"--print\\n\");\n\t\t\tprint_inorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tprint_preorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"error\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\n\n#define MAX 100005\n#define INF INT_MAX\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define NIL NULL\nstruct node{\n    struct node *right;\n    struct node *left;\n    ll key;\n    ll priority;\n    node(ll key, ll priority) {\n        this->key = key;\n        this->priority = priority;\n        this->right = NIL;\n        this->left = NIL;\n    }\n};\ntypedef struct node * Node;\n\nvoid preorder(Node u);\nvoid inorder(Node u);\n\nNode root;\n\nNode treeMinimum(Node x)\n{\n    if (x == NIL) return NIL;\n\n    Node current = x;\n    while (current->left != NIL) current = current->left;\n\n    return current;\n}\nNode treeMaximum(Node x)\n{\n    if (x == NIL) return NIL;\n\n    Node current = x;\n    while (current->right != NIL) current = current->right;\n\n    return current;\n}\nNode treeSearch(Node u, int k)\n{\n    Node ret;\n    if (u == NIL) return NIL;\n\n    if (k < u->key) ret = treeSearch(u->left, k);\n    else if (k > u->key) ret = treeSearch(u->right, k);\n    else ret = u;\n\n    return ret;\n}\nNode treeSuccessor(Node x)\n{\n    if (x == NIL) return NIL;\n\n    return treeMinimum(x->right);\n}\n\nNode treeRotateRight(Node x)\n{\n    Node y = x->left;\n    if (y == NIL) return NIL;\n\n    x->left = y->right;\n    y->right = x;\n\n    return y;\n}\n\nNode treeRotateLeft(Node x)\n{\n    Node y = x->right;\n    if (y == NIL) return NIL;\n\n    x->right = y->left;\n    y->left = x;\n\n    return y;\n}\n\nNode treeDelete(Node x, ll k)\n{\n    if (x == NIL) return NIL;\n    if (k < x->key) {\n        x->left = treeDelete(x->left, k);\n        return x;\n    } else if (k > x->key) {\n        x->right = treeDelete(x->right, k);\n        return x;\n    }\n\n    // 削除対象の節点の場合\n    if (x->left == NIL && x->right == NIL) return NIL;  // 葉の場合\n\n    if (x->left == NIL) x = treeRotateLeft(x);\n    else if (x->right == NIL) x = treeRotateRight(x);\n    else {\n        if (x->left->priority > x->right->priority) {\n            x = treeRotateRight(x);\n        } else {\n            x = treeRotateLeft(x);\n        }\n    }\n    return treeDelete(x, k);\n}\nvoid treeDelete(ll k) { root = treeDelete(root, k); }\n\nNode insert(Node x, ll k, ll p)\n{\n    Node y = new node(k, p);\n\n    if (x == NIL) return y;\n\n    if (k < x->key) {\n        x->left = insert(x->left, k, p);\n        if (x->priority < x->left->priority) {\n            x = treeRotateRight(x);\n        }\n    } else {\n        x->right = insert(x->right, k, p);\n        if (x->priority < x->right->priority) {\n            x = treeRotateLeft(x);\n        }\n    }\n    return x;\n}\nvoid insert(ll k, ll p) { root = insert(root, k, p); }\n\nvoid inorder(Node u)\n{\n    if (u == NIL) return;\n    \n    inorder(u->left);\n    cout << \" \" << u->key;\n    inorder(u->right);    \n}\nvoid preorder(Node u)\n{\n    if (u == NIL) return;\n\n    cout << \" \" << u->key;\n    preorder(u->left);\n    preorder(u->right);\n}\n\nint main(int, char**)\n{\n    ll n, k, p;\n    string com;\n    cin >> n;\n\n    rep(i,n){\n        cin >> com;\n        if ( com[0] == 'f' ){\n            cin >> k;\n            Node t = treeSearch(root, k);\n            if ( t != NIL ) cout << \"yes\" << endl;\n            else cout << \"no\" << endl;\n        } else if ( com[0] == 'i' ){\n            cin >> k >> p;\n            insert(k, p);\n        } else if ( com[0] == 'p' ){\n            inorder(root);\n            cout << endl;\n            preorder(root);\n            cout << endl;\n        } else if ( com[0] == 'd' ){\n            cin >> k;\n            treeDelete(k);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node {\n\tint key;\n\tint priority;\n\n\tNode *left, *right;\n\t\n\tNode(int k, int p) : key(k), priority(p), left(nullptr), right(nullptr) { }\n\n};\n\nNode *insert(Node *node, int key, int priority);\nvoid find(Node *node, int key);\nNode *deleteNode(Node *node, int key);\nNode *_deleteNode(Node *node, int key);\nNode *head = nullptr;\n\nNode *rightRotate(Node *node);\nNode *leftRotate(Node *node);\n\nvoid print();\nvoid printFront(Node *node);\nvoid printCenter(Node *node);\n\nint main() {\n\n\tint m;\n\tint key, priority;\n\tstring cmd;\n\t// 入力の数が入力される\n\tcin >> m;\n\n\tfor (int i = 0; i < m; ++i) {\n\n\t\tcin >> cmd;\n\t\tif (cmd[0] == 'i') {   // insert\n\n\t\t\tcin >> key >> priority;\n\t\t\thead = insert(head, key, priority);\n\n\t\t}\n\t\telse if(cmd[0] == 'f') {   // find\n\n\t\t\tcin >> key;\n\t\t\tfind(head, key);\n\n\t\t}\n\t\telse if (cmd[0] == 'd') {   // delete\n\n\t\t\tcin >> key;\n\t\t\thead = deleteNode(head, key);\n\n\t\t}\n\t\telse {\n\t\t\t\n\t\t\tprint();\n\n\t\t}\n\n\t\t/*\n\t\tcout << endl;\n\t\tcout << \"i = \" << i << endl;\n\t\tprint();\n\t\tcout << endl;\n\t\t*/\n\t}\n\n\treturn 0;\n\n}\n\nNode *insert(Node *node, int key, int priority) {\n\n\t// cout << \"insert\" << endl;\n\n\tif (node == nullptr)\n\t\treturn new Node(key, priority);\n\tif (key == node->key)\n\t\treturn node;\n\n\tif (key < node->key) {\n\t\tnode->left = insert(node->left, key, priority);\n\t\tif (node->priority < node->left->priority)\n\t\t\tnode = rightRotate(node);\n\t}\n\telse {\n\t\tnode->right = insert(node->right, key, priority);\n\t\tif (node->priority < node->right->priority)\n\t\t\tnode = leftRotate(node);\n\t}\n\n\treturn node;\n}\n\nvoid find(Node *node, int key) {\n\n\tif (node == nullptr) {\n\t\tcout << \"no\" << endl;\n\t\treturn;\n\t}\n\n\tif (node->key == key) {\n\t\tcout << \"yes\" << endl;\n\t\treturn;\n\t}\n\telse if (node->key > key) {\n\t\tfind(node->left, key);\n\t}\n\telse\n\t\tfind(node->right, key);\n\n}\n\nNode *rightRotate(Node *node) {\n\n//\tcout << \"rightRotate\" << endl;\n\n\tNode *s = node->left;\n\tnode->left = s->right;\n\ts->right = node;\n\treturn s;\n}\n\nNode *leftRotate(Node *node) {\n\n//\tcout << \"leftRotate\" << endl;\n\n\tNode *s = node->right;\n\tnode->right = s->left;\n\ts->left = node;\n\treturn s;\n}\n\nNode *deleteNode(Node *node, int key) {\n\n\tif (node == nullptr) {\n\t\tdelete node;\n\t\treturn nullptr;\n\t}\n\n\tif (key < node->key)\n\t\tnode->left = deleteNode(node->left, key);\n\telse if (key > node->key)\n\t\tnode->right = deleteNode(node->right, key);\n\telse\n\t\treturn _deleteNode(node, key);\n\n\treturn node;\n\n}\n\nNode *_deleteNode(Node *node, int key) {\n\n\tif (node->left == nullptr && node->right == nullptr)\n\t\treturn nullptr;\n\telse if (node->left == nullptr)\n\t\tnode = leftRotate(node);\n\telse if (node->right == nullptr)\n\t\tnode = rightRotate(node);\n\telse {\n\t\tif (node->left->priority > node->right->priority)\n\t\t\tnode = rightRotate(node);\n\t\telse\n\t\t\tnode = leftRotate(node);\n\t}\n\n\treturn deleteNode(node, key);\n\n}\n\nvoid printFront(Node *node) {\n\n\tif (node == nullptr)\n\t\treturn;\n\n\tcout << \" \" << node->key;\n\tprintFront(node->left);\n\tprintFront(node->right);\n\n}\n\nvoid printCenter(Node *node) {\n\n\tif (node == nullptr)\n\t\treturn;\n\n\tprintCenter(node->left);\n\tcout << \" \" << node->key;\n\tprintCenter(node->right);\n\n}\n\nvoid print() {\n\n\tprintCenter(head);\n\tcout << endl;\n\tprintFront(head);\n\tcout << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) cerr<< GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\nusing namespace std;\nusing Int = long long;\nusing ll = long long;\nusing Double = long double;\nconst Int INF = 1LL<<55;\nconst Int mod = (1e9)+7;\nusing P = pair<Int,Int>;\nusing T = tuple<Int,Int,Int>;\nconst Double EPS = 1e-8;\nconst Double PI = 6.0 * asin((Double)0.5);\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nostream& operator<<(ostream& o,T t){return o<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){Int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){Int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\nclass Treap{\npublic:\n  struct Node{\n    int key;\n    int priority;\n    Node *parent, *left, *right;\n   \n    Node():key(-1), priority(-1), parent(nullptr), left(nullptr), right(nullptr){};\n    Node(int key,int priority,Node *parent):\n      key(key), priority(priority), parent(parent), left(nullptr), right(nullptr){};\n\n    Node(int key,int priority, Node *parent,Node *left,Node *right):\n      key(key), priority(priority), parent(parent), left(left), right(right){}\n  };\n  \n  int n;\n  Node *root;\n  Treap():n(0){}\n  \n  \n  Node* rightRotate(Node *y){\n    Node *x = y->left;\n    y->left = x->right;\n    x->right = y;\n\n    x->parent = y->parent;\n    y->parent = x;\n    \n    return x;\n  }\n\n  Node* leftRotate(Node *x){\n    Node *y = x->right;\n    x->right = y->left;\n    y->left = x;\n    \n    y->parent = x->parent;\n    x->parent = y;\n\n    return y;\n  }\n\n  Node* insert(Node *t,int key,int priority, Node *parent = nullptr){\n    if(t == nullptr){n++; return new Node(key, priority, parent);}\n    \n    if(key == t->key) return t;\n    \n    if(key < t->key){\n      t->left = insert(t->left, key, priority,  t);\n      if( t->priority < t->left->priority ) t = rightRotate(t);\n    }\n    else{\n      t->right = insert(t->right, key, priority, t);\n      if( t->priority < t->right->priority ) t = leftRotate(t);\n    }\n    return t;\n  }\n\n  Node* insert(int key,int priority){\n    if(n == 0){n++; return root = new Node(key, priority, nullptr);}\n    return root = insert(root, key, priority);\n  }\n\n  Node* erase(Node *t,int key){\n    if( t == nullptr) return nullptr;\n    if(key == t->key) return _erase(t, key);\n    \n    if(key < t->key ) t->left = erase(t->left, key);\n    else if(key > t->key ) t->right = erase(t->right, key);\n    return t;\n  }\n  \n  Node* _erase(Node *t,int key){\n    if(t->left == nullptr && t->right == nullptr) {\n      delete t;\n      return nullptr;\n    }\n    \n    if(t->left == nullptr) t = leftRotate(t);\n    else if(t->right == nullptr) t = rightRotate(t);\n    else {\n      if( t->left->priority > t->right->priority ) t = rightRotate(t);\n      else t = leftRotate(t);\n    }\n    \n    return erase(t, key);\n  }\n\n  void erase(int key){\n    root = erase(root, key);\n  }\n\n  Node* find(Node *t,int key){\n    if( t == nullptr) return nullptr;\n    if(key < t->key ) return find(t->left, key);\n    if(key > t->key ) return find(t->right, key);\n    return t;\n  }\n\n  Node* find(int key){return find(root, key);}\n\n  \n  void print(Node* t,int a=0,int b=0,int c=0){\n    if(t == nullptr) return;\n    if(a) cout<<\" \"<<(t->key);\n    if(t->left != nullptr) print(t->left, a, b, c);\n    if(b) cout<<\" \"<<(t->key);\n    \n    if(t->right != nullptr) print(t->right, a, b, c);\n    if(c) cout<<\" \"<<(t->key);\n  }\n  \n  void print(){\n    print(root, 0, 1, 0);cout<<endl;\n    print(root, 1, 0, 0);cout<<endl;\n  }\n    \n};\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  \n  Treap T;\n  \n  int n;\n  cin>>n;\n  while(n--){\n    string str;\n    cin>>str;\n    if(str == \"insert\"){\n      int key, priority;\n      cin>>key>>priority;\n      T.insert(key, priority);\n    }\n    \n    if(str == \"find\"){\n      int key;\n      cin>>key;\n      int ans = T.find(key) != nullptr;\n      cout<<(ans?\"yes\":\"no\")<<endl;\n    }\n    \n    if(str == \"delete\"){\n      int key;\n      cin>>key;\n      T.erase(key);\n    }\n    if(str == \"print\"){\n      T.print();\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef _DEBUG\n#define ASSERT(x) assert(x)\n#define DLOG(x) cout << \"L\" << __LINE__ << \": \" << x << endl;\n#else\n#define ASSERT(x)\n#define DLOG(x)\n#endif\n#define DLOG_V(x) DLOG(#x << \": \" << x)\n\nusing namespace std;\n\nstruct Node;\nusing NodePtr = unique_ptr<Node>;\n\nstruct Node {\n  explicit Node(int value, int prio, NodePtr* parent)\n      : value{value}, prio{prio}, parent{parent} {}\n  int value;\n  int prio;\n  NodePtr left;\n  NodePtr right;\n  NodePtr* parent;\n\n  bool isLeaf() const { return !left && !right; }\n\n  bool isLeft() const { return parent && (*parent)->left.get() == this; }\n\n  void dump(ostream& s) {\n    s << \"value: \" << value << \" prio: \" << prio;\n    if (parent && *parent) {\n      s << \" p.value: \" << (*parent)->value;\n    }\n  }\n};\n\nstruct Tree {\n  void print(ostream& os) const {\n    doInOrder(root, 0,\n              [&os](auto&& node, auto&&) { os << \" \" << node->value; });\n    os << endl;\n    doPreOrder(root, [&os](auto&& i) { os << \" \" << i; });\n    os << endl;\n  }\n  void insert(int val, int prio) {\n    DLOG(\"insert \" << val << \" \" << prio);\n    auto current = &root;\n    decltype(current) parent{nullptr};\n    while (*current) {\n      parent = current;\n      current =\n          val < (*current)->value ? &(*current)->left : &(*current)->right;\n    }\n    *current = make_unique<Node>(val, prio, parent);\n    promote(*current);\n    debugPrint(cerr);\n  }\n\n  bool find(int val) { return static_cast<bool>(*findNode(val)); }\n\n  void delete_(int val) {\n    DLOG(\"delete \" << val);\n    deleteNode(*findNode(val));\n    debugPrint(cerr);\n  }\n\n private:\n  void debugPrint(ostream& os) const {\n#ifdef _DEBUG\n    doInOrder(root, 0, [&os](auto&& node, auto&& depth) {\n      for (int i = 0; i < depth; ++i) {\n        os << \"  \";\n      }\n      // os << setw(2) << setfill('0') << node->value << \" \" << node->prio <<\n      // endl;\n      os << setw(2) << setfill('0');\n      node->dump(os);\n      os << endl;\n    });\n    os << endl;\n#else\n    (void)os;\n#endif\n  }\n\n  NodePtr* findNode(int val) {\n    auto current = &root;\n    while (*current && (*current)->value != val) {\n      current =\n          val < (*current)->value ? &(*current)->left : &(*current)->right;\n    }\n    return current;\n  }\n\n  void deleteNode(NodePtr& node) {\n    if (node) {\n      auto p = &node;\n      while ((*p)->left || (*p)->right) {\n        p = &promoteChild(*p);\n      }\n      p->reset();\n    }\n  }\n\n  NodePtr& promoteChild(NodePtr& node) {\n    if (!node->left || (node->right && node->left->prio < node->right->prio)) {\n      return promoteRight(node);\n    } else {\n      return promoteLeft(node);\n    }\n  }\n\n  void promote(NodePtr& node) {\n    auto c = &node;\n    while (true) {\n      if (!c || !*c || !(*c)->parent) {\n        DLOG_V((bool)c);\n        DLOG_V((bool)*c);\n        DLOG_V((*c)->parent);\n        return;\n      }\n      auto& p = (*c)->parent;\n      if (!*p || (*c)->prio < (*p)->prio) {\n        DLOG(\"(*c)->prio < p->prio\");\n        return;\n      }\n      if ((*c)->isLeft()) {\n        debugPrint(cout);\n        c = promoteLeft(*p)->parent;\n        debugPrint(cout);\n      } else {\n        debugPrint(cout);\n        c = promoteRight(*p)->parent;\n        debugPrint(cout);\n      }\n    }\n  }\n\n  void fixChildren(NodePtr& node) {\n    if (node) {\n      if (node->left) node->left->parent = &node;\n      if (node->right) node->right->parent = &node;\n    }\n  }\n\n  void ptrSwap(NodePtr& lhs, NodePtr& rhs) {\n    lhs.swap(rhs);\n    fixChildren(lhs);\n    fixChildren(rhs);\n  }\n\n  NodePtr& promoteLeft(NodePtr& node) {\n    ASSERT(node);\n    DLOG(\"promoteLeft \" << node->value);\n    auto& src = node->left;\n    ASSERT(src);\n    auto& srcRight = src->right;\n    auto parent = node->parent;\n    swap(node, src);\n    swap(src, srcRight);\n    node->parent = parent;\n    fixChildren(node);\n    fixChildren(src);\n    fixChildren(srcRight);\n    return node->right;\n  }\n\n  NodePtr& promoteRight(NodePtr& node) {\n    ASSERT(node);\n    DLOG(\"promoteRight \" << node->value);\n    auto& src = node->right;\n    ASSERT(src);\n    auto& srcLeft = src->left;\n    auto parent = node->parent;\n    swap(node, src);\n    swap(src, srcLeft);\n    node->parent = parent;\n    fixChildren(node);\n    fixChildren(src);\n    fixChildren(srcLeft);\n    return node->left;\n  }\n\n  void doInOrder(const NodePtr& node, int depth,\n                 const function<void(Node*, int)>& f) const {\n    if (!node) {\n      return;\n    }\n    doInOrder(node->left, depth + 1, f);\n    f(node.get(), depth);\n    doInOrder(node->right, depth + 1, f);\n  }\n\n  void doPreOrder(const NodePtr& node, const function<void(int)>& f) const {\n    if (!node) {\n      return;\n    }\n    f(node->value);\n    doPreOrder(node->left, f);\n    doPreOrder(node->right, f);\n  }\n\n  NodePtr root;\n};\n\nint main() {\n  int num;\n  cin >> num;\n  Tree tree;\n  ostringstream ss;\n  for (int i = 0; i < num; ++i) {\n    string cmd;\n    cin >> cmd;\n    if (cmd == \"insert\") {\n      int val, prio;\n      cin >> val >> prio;\n      tree.insert(val, prio);\n    } else if (cmd == \"find\") {\n      int val;\n      cin >> val;\n      ss << (tree.find(val) ? \"yes\" : \"no\") << endl;\n    } else if (cmd == \"delete\") {\n      int val;\n      cin >> val;\n      tree.delete_(val);\n    } else if (cmd == \"print\") {\n      tree.print(ss);\n    }\n  }\n  cout << ss.str();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\ntemplate <typename T>\nstruct Node\n{\n    T val;\n    T sum; // sum of subtree's values\n    Node<T> *left;\n    Node<T> *right;\n    double pri;\n    int cnt; // size of subtree\n\n    Node(T v, double p) : val(v), pri(p), cnt(1), sum(v)\n    {\n        left = right = NULL;\n    }\n};\n\ntemplate <typename T>\nclass Treap\n{\n    Node<T> *root;\n    int count(Node<T> *t) { return !t ? 0 : t->cnt; }\n    T sum(Node<T> *t) { return !t ? 0 : t->sum; }\n\n    Node<T> *update(Node<T> *t)\n    {\n        t->cnt = count(t->left) + count(t->right) + 1;\n        t->sum = sum(t->left) + sum(t->right) + t->val;\n        return t;\n    }\n\n    Node<T> *rightRotate(Node<T> *t)\n    {\n        Node<T> *s = t->left;\n        t->left = s->right;\n        s->right = t;\n        update(s);\n        update(t);\n        return s;\n    }\n\n    Node<T> *leftRotate(Node<T> *t)\n    {\n        Node<T> *s = t->right;\n        t->right = s->left;\n        s->left = t;\n        update(s);\n        update(t);\n        return s;\n    }\n\n    Node<T> *find(Node<T> *t, T v)\n    {\n        if (!t)\n            return NULL;\n        if (t->val == v)\n            return t;\n        if (t->val > v)\n            return find(t->left, v);\n        else\n            return find(t->right, v);\n    }\n\n    Node<T> *merge(Node<T> *l, Node<T> *r)\n    {\n        if (!l || !r)\n            return l ? l : r;\n\n        if (l->pri > r->pri)\n        {\n            l->right = merge(l->right, r);\n            return update(l);\n        }\n        else\n        {\n            r->left = merge(l, r->left);\n            return update(r);\n        }\n    }\n\n    // [0,k), [k,n)\n    pair<Node<T> *, Node<T> *> split(Node<T> *t, int k)\n    {\n        if (!t)\n            return make_pair(NULL, NULL);\n\n        if (k <= count(t->left))\n        {\n            pair<Node<T> *, Node<T> *> s = split(t->left, k);\n            t->left = s.second;\n            return pair<Node<T> *, Node<T> *>(s.first, update(t));\n        }\n        else\n        {\n            pair<Node<T> *, Node<T> *> s = split(t->right, k - count(t->left) - 1);\n            t->right = s.first;\n            return pair<Node<T> *, Node<T> *>(update(t), s.second);\n        }\n    }\n\n    // 木 t に (v, p) ノードを挿入\n    // 挿入位置を k で指定可能\n    Node<T> *insert(Node<T> *t, T v, double p, int k = -1)\n    {\n        if (!t)\n        {\n            return t = new Node<T>(v, p);\n        }\n        if (t->val == v)\n        {\n            return t;\n        }\n        if (v < t->val)\n        {\n            t->left = insert(t->left, v, p);\n            if (t->pri < t->left->pri)\n            {\n                t = rightRotate(t);\n            }\n        }\n        else\n        {\n            t->right = insert(t->right, v, p);\n            if (t->pri < t->right->pri)\n            {\n                t = leftRotate(t);\n            }\n        }\n        update(t);\n        return t;\n    }\n\n    Node<T> *erase(Node<T> *t, T v)\n    {\n        if (t == NULL)\n        {\n            return NULL;\n        }\n        if (v < t->val)\n        {\n            t->left = erase(t->left, v);\n        }\n        else if (v > t->val)\n        {\n            t->right = erase(t->right, v);\n        }\n        else\n        {\n            return _erase(t, v);\n        }\n        update(t);\n        return t;\n    }\n\n    Node<T> *_erase(Node<T> *t, T v)\n    {\n        if (t->left == NULL && t->right == NULL)\n        {\n            return NULL;\n        }\n        else if (t->left == NULL)\n        {\n            t = leftRotate(t);\n        }\n        else if (t->right == NULL)\n        {\n            t = rightRotate(t);\n        }\n        else\n        {\n            if (t->left->pri > t->right->pri)\n            {\n                t = rightRotate(t);\n            }\n            else\n            {\n                t = leftRotate(t);\n            }\n        }\n        update(t);\n        return erase(t, v);\n    }\n\n  public:\n    Treap() { root = NULL; }\n    T count() { return count(root); }\n    T sum() { return sum(root); }\n    void insert(T v, double p)\n    {\n        root = insert(root, v, p);\n    }\n    bool find(T v)\n    {\n        return find(root, v);\n    }\n    void erase(T v)\n    {\n        root = erase(root, v);\n    }\n    void preorder(Node<T> *cur)\n    {\n        if (cur == NULL)\n            return;\n        cout << \" \" << cur->val;\n        preorder(cur->left);\n        preorder(cur->right);\n    }\n    void inorder(Node<T> *cur)\n    {\n        if (cur == NULL)\n            return;\n        inorder(cur->left);\n        cout << \" \" << cur->val;\n        inorder(cur->right);\n    }\n    void print()\n    {\n        inorder(root);\n        cout << endl;\n        preorder(root);\n        cout << endl;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int Q;\n    cin >> Q;\n    Treap<ll> tr;\n    while (Q--)\n    {\n        string s;\n        cin >> s;\n        if (s == \"insert\")\n        {\n            ll key;\n            double p;\n            cin >> key >> p;\n            tr.insert(key, p);\n        }\n        else if (s == \"find\")\n        {\n            ll key;\n            cin >> key;\n            cout << (tr.find(key) ? \"yes\" : \"no\") << endl;\n        }\n        else if (s == \"delete\")\n        {\n            ll key;\n            cin >> key;\n            tr.erase(key);\n        }\n        else\n        {\n            tr.print();\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<string>\n\nusing namespace std;\n\nstruct node{\n  int priority,key;\n  node *right, *left;\n};\n\n\nnode* rightRotate(node* t) {\n  node* s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\n\nnode* leftRotate(node* t) {\n  node* s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\n\nnode* MakeNode(int key, int priority){\n  node* t = new node;\n  t->left=NULL;\n  t->right = NULL;\n  t->key = key;\n  t->priority = priority;\n  return t;\n}\n\nnode* insert(node* t, int key, int priority) {\n\n  if(t == NULL) { return MakeNode(key,priority);}\n  if(key == t->key) {return t;}\n\n  if(key < t->key) {\n    t->left = insert(t->left, key, priority);\n    if( (t->priority) < (t->left->priority) ){ t = rightRotate(t); }\n  }\n  else{\n    t->right = insert(t->right, key, priority);\n    if(( t->priority) < (t->right->priority) ){ t = leftRotate(t); }\n  }\n  return t;\n}\n\nnode* _delete(node* t, int key); //プロトタイプ宣言\nnode* node_delete(node* t, int key){\n  if( t == NULL ) {return NULL;}\n  if(  (t->key) > key ) { t->left = node_delete(t->left, key); }\n  else if( (t->key) < key ) { t->right = node_delete(t->right, key); }\n  else { return _delete(t, key);}\n  return t;\n}\n\nnode* _delete(node* t, int key){\n\n  if( t->left == NULL && t->right == NULL) { return NULL; }\n  else if( t->left == NULL ) { t = leftRotate(t); }\n  else if(t->right == NULL) { t = rightRotate(t); }\n  else {\n    if( (t->left->priority) > (t->right->priority) ) {t = rightRotate(t);}\n    else t = leftRotate(t);\n  }\n  return node_delete(t,key);\n}\n\n\nvoid find(node* t, int key) {\n\n  while(t != NULL && key != t->key) {\n    if(key < t->key) { t = t->left; }\n    else {t = t->right;}\n  }\n\n  if(t == NULL) cout << \"no\" << endl;\n  else cout << \"yes\" << endl;\n\n}\n\nvoid order (node *t, int op){\n\n  if(op==1){\n    if(t==NULL) return;\n    order(t->left,1);\n    cout << \" \" << t->key;\n    order(t->right,1);\n  }else if(op==2){\n    if(t == NULL) return;\n    cout << \" \" << t->key;\n    order(t->left,2);\n    order(t->right,2);\n  }\n\n}\n\nint main() {\n\n  string op;\n  node* root=NULL;\n  int m,key,priority;\n\n  cin >> m;\n  for(int i=0; i<m; i++) {\n\n    cin >> op;\n\n    if(op == \"insert\") {\n      cin >> key >> priority;\n      root = insert(root, key, priority);\n    }\n\n    else if(op == \"find\") {\n      cin >> key;\n      find(root, key);\n    }\n\n    else if(op == \"delete\") {\n      cin >> key;\n      root = node_delete(root, key);\n    }\n\n    else {\n      order(root,1);\n      cout << endl;\n      order(root,2);\n      cout << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <limits>\n#include <functional>\n\nnamespace structure {\n  template<typename T, size_t dcap = 16ULL>\n  class vec {\n    size_t sz;\n    size_t cap;\n    T* a;\n    void extend() {\n      size_t ncap = cap << 1;\n      T* b = new T[ncap];\n      for (int i = 0; i < cap; i++) b[i] = a[i];\n      delete[] a;\n      a = b;\n      cap = ncap;\n    }\n  public:\n    vec() : sz(0), cap(dcap) {\n      a = new T[cap];\n    }\n    vec(size_t n) : sz(n), cap(dcap) {\n      while (cap < sz) cap <<= 1;\n      a = new T[cap];\n    }\n    vec(size_t n, T v) : sz(n), cap(dcap) {\n      while (cap < sz) cap <<= 1;\n      a = new T[cap];\n      for (size_t i = 0; i < sz; i++) {\n        a[i] = v;\n      }\n    }\n    vec(const vec<T>& v) {\n      sz = v.sz;\n      cap = v.cap;\n      a = new T[cap];\n      std::memcpy(a, v.a, sizeof(T) * sz);\n    }\n    vec<T>& operator=(const vec<T>& v) {\n      sz = v.sz;\n      cap = v.cap;\n      delete[] a;\n      a = new T[cap];\n      std::memcpy(a, v.a, sizeof(T) * sz);\n      return *this;\n    }\n    T& operator[](size_t i) {\n      return a[i];\n    }\n    T front() const {\n      return a[0];\n    }\n    T back() const {\n      return a[sz - 1];\n    }\n    void push_back(const T& x) {\n      if (sz == cap) extend();\n      a[sz++] = x;\n    }\n    void pop_back() {\n      sz--;\n    }\n    size_t size() const {\n      return sz;\n    }\n    bool empty() const {\n      return !sz;\n    }\n    void output(std::ostream& out, char delim = ' ') const {\n      for (size_t i = 0; i < sz; i++) {\n        if (i) out << delim;\n        out << a[i];\n      }\n    }\n    friend std::ostream& operator<<(std::ostream& out, const vec& v) {\n      v.output(out);\n      return out;\n    }\n    void input(std::istream& in) {\n      for (size_t i = 0; i < sz; i++) {\n        in >> a[i];\n      }\n    }\n    friend std::istream& operator>>(std::istream& in, vec& v) {\n      v.input(in);\n      return in;\n    }\n    ~vec() {\n      delete[] a;\n    }\n  };\n  template<typename T, size_t dcap = 16ULL>\n  class que {\n    size_t begin, end;\n    size_t sz;\n    size_t cap;\n    T* a;\n    void extend() {\n      size_t ncap = cap << 1;\n      T* b = new T[ncap];\n      for (int i = begin; i < begin + cap; i++) b[i] = a[i & (cap - 1)];\n      end += cap;\n      delete[] a;\n      a = b;\n      cap = ncap;\n    }\n  public:\n    que() : begin(0), end(0), sz(0), cap(dcap) {\n      a = new T[cap];\n    }\n    T front() const {\n      return a[begin];\n    }\n    void push(const T& x) {\n      if (sz == cap) extend();\n      a[end++] = x;\n      sz++;\n      end &= cap - 1;\n    }\n    void pop() {\n      begin = (begin + 1) & (cap - 1);\n      sz--;\n    }\n\n    size_t size() const {\n      return sz;\n    }\n    bool empty() const {\n      return !sz;\n    }\n    void output(std::ostream& out, char delim = ' ') const {\n      if (sz == cap) {\n        for (size_t i = begin; i != (cap + end - 1) & (cap - 1); i = (i + 1) & (cap - 1)) {\n          if (i != begin) out << delim;\n          out << a[i];\n        }\n        out << delim << a[(cap + end - 1) & (cap - 1)];\n      }\n      else {\n        for (size_t i = begin; i != end; i = (i + 1) & (cap - 1)) {\n          if (i != begin) out << delim;\n          out << a[i];\n        }\n      }\n    }\n    friend std::ostream& operator<<(std::ostream& out, const que& v) {\n      v.output(out);\n      return out;\n    }\n    ~que() {\n      delete[] a;\n    }\n  };\n  template<typename S, typename T>\n  struct pair {\n    S first;\n    T second;\n    pair() {}\n    pair(S first, T second) : first(first), second(second) {}\n    void output(std::ostream& out, char delim = ' ') const {\n      out << first << delim << second;\n    }\n    friend std::ostream& operator<<(std::ostream& out, const pair& p) {\n      p.output(out);\n      return out;\n    }\n    void input(std::istream& in) {\n      in >> first >> second;\n    }\n    friend std::istream& operator>>(std::istream& in, pair& p) {\n      p.input(in);\n      return in;\n    }\n  };\n  template<typename T>\n  class list {\n    struct node {\n      T val;\n      node* prev;\n      node* next;\n      node() : prev(nullptr), next(nullptr) {}\n      node(node* prev, node* next) : prev(prev), next(next) {}\n      node(const T& val, node* prev, node* next) : val(val), prev(prev), next(next) {}\n    };\n    node* head;\n    size_t sz;\n  public:\n    list() {\n      head = new node;\n      head->next = head->prev = head;\n    }\n    void push_front(const T& val) {\n      node* n = new node(val, head, head->next);\n      n->prev->next = n;\n      n->next->prev = n;\n      sz++;\n    }\n    void erase(node* n) {\n      n->prev->next = n->next;\n      n->next->prev = n->prev;\n      delete n;\n      sz--;\n    }\n    void pop_front() {\n      erase(head->next);\n    }\n    void pop_back() {\n      erase(head->prev);\n    }\n    bool erase(const T& val) {\n      for (node* n = head->next; n != head; n = n->next) {\n        if (n->val == val) {\n          erase(n);\n          return true;\n        }\n      }\n      return false;\n    }\n    size_t size() const {\n      return sz;\n    }\n    void output(std::ostream& out, char delim = ' ') const {\n      for (node* n = head->next; n != head; n = n->next) {\n        if (n != head->next) out << delim;\n        out << n->val;\n      }\n    }\n    friend std::ostream& operator<<(std::ostream& out, const list& l) {\n      l.output(out);\n      return out;\n    }\n  };\n  // T have +-*/ and 0\n  template<class T> class BIT {\n  public:\n    vec<T> dat;\n    int N;\n    BIT() {}\n    BIT(int N) : N(N), dat(N, 0) {}\n    // sum [0,c)\n    T sum(int i) {\n      T ret = 0;\n      for (--i; i >= 0; i = (i & (i + 1)) - 1) ret += dat[i];\n      return ret;\n    }\n    // sum [c,j1)\n    T sum(int i1, int i2) { return sum(i2) - sum(i1); }\n    T at(int i) { return sum(i, i + 1); }\n    // add x to c\n    void add(int i, T x) { for (; i < N; i |= i + 1) dat[i] += x; }\n  };\n}\n\nnamespace algorithm {\n  template<typename T>\n  void insertion_sort(structure::vec<T>& v, bool verbose = false) {\n    for (int i = 0, n = v.size(); i < n; i++) {\n      int x = v[i], j;\n      for (j = i - 1; j >= 0 && v[j] > x; j--) {\n        v[j + 1] = v[j];\n      }\n      v[j + 1] = x;\n      if (verbose) std::cout << v << std::endl;\n    }\n  }\n  template<typename T>\n  size_t bubble_sort(structure::vec<T>& v) {\n    size_t cnt = 0;\n    int n = v.size();\n    for (int i = 0; i < n - 1; i++) {\n      for (int j = n - 1; j > i; j--) {\n        if (v[j] < v[j - 1]) {\n          T t = v[j - 1];\n          v[j - 1] = v[j];\n          v[j] = t;\n          cnt++;\n        }\n      }\n    }\n    return cnt;\n  }\n  template<typename T>\n  size_t selection_sort(structure::vec<T>& v) {\n    size_t cnt = 0;\n    int n = v.size();\n    for (int i = 0; i < n; i++) {\n      int minj = i;\n      for (int j = i; j < n; j++) {\n        if (v[j] < v[minj]) minj = j;\n      }\n      T t = v[i];\n      v[i] = v[minj];\n      v[minj] = t;\n      cnt += (v[i] != v[minj]);\n    }\n    return cnt;\n  }\n  template<typename T>\n  size_t upper_bound(structure::vec<T>& v, const T& x) {\n    // x より大きい最初の要素の添字を返す\n    if (x < v[0]) return 0;\n    if (v.back() <= x) return v.size();\n    int ng = 0, ok = v.size() - 1;\n    while (abs(ok - ng) > 1) {\n      int mid = (ng + ok) / 2;\n      (v[mid] > x ? ok : ng) = mid;\n    }\n    return ok;\n  }\n  template<typename T>\n  size_t count(structure::vec<T>& v, const T& x) {\n    return upper_bound(v, x) - upper_bound(v, x - 1);\n  }\n  namespace impl {}\n  namespace {\n    namespace impl {\n      template<typename T>\n      void merge(structure::vec<T>& v, int l, int m, int r) {\n        T inf = std::numeric_limits<T>::max();\n        int i = l, j = 0, k = 0, n1 = m - l, n2 = r - m;\n        int* L = new int[n1 + 1];\n        int* R = new int[n2 + 1];\n        std::memcpy(L, &v[l], sizeof(T) * n1);\n        std::memcpy(R, &v[m], sizeof(T) * n2);\n        L[n1] = R[n2] = inf;\n        while (i < r) {\n          L[j] <= R[k] ? v[i] = L[j++] : v[i] = R[k++];\n          i++;\n        }\n        delete[] L;\n        delete[] R;\n      }\n      template<typename T>\n      void align(structure::vec<T>& v, int l, int r) {\n        if (l + 1 < r) {\n          int m = (l + r) / 2;\n          align(v, l, m);\n          align(v, m, r);\n          merge(v, l, m, r);\n        }\n      }\n    }\n    template<typename T>\n    void merge_sort(structure::vec<T>& v) {\n      impl::align(v, 0, v.size());\n    }\n  }\n  template<typename T>\n  struct MergeSorter {\n    using F = std::function<bool(T, T)>;\n    const F cmp;\n    const T inf;\n    structure::vec<T> v;\n    MergeSorter(const structure::vec<T>& v, const T& inf, const F cmp) : v(v), inf(inf), cmp(cmp) {}\n    void merge(int l, int m, int r) {\n      int i = l, j = 0, k = 0, n1 = m - l, n2 = r - m;\n      T* L = new T[n1 + 1];\n      T* R = new T[n2 + 1];\n      std::memcpy(L, &v[l], sizeof(T) * n1);\n      std::memcpy(R, &v[m], sizeof(T) * n2);\n      L[n1] = R[n2] = inf;\n      while (i < r) {\n        cmp(L[j], R[k]) ? v[i] = L[j++] : v[i] = R[k++];\n        i++;\n      }\n      delete[] L;\n      delete[] R;\n    }\n    void align(int l, int r) {\n      if (l + 1 < r) {\n        int m = (l + r) / 2;\n        align(l, m);\n        align(m, r);\n        merge(l, m, r);\n      }\n    }\n    void sort() {\n      align(0, v.size());\n    }\n  };\n  template<typename T>\n  struct QuickSorter {\n    using F = std::function<bool(T, T)>;\n    const F cmp;\n    structure::vec<T> v;\n    QuickSorter(const structure::vec<T>& v, const F cmp) : v(v), cmp(cmp) {}\n    int partition(int p, int r) {\n      T x = v[r], tmp;\n      int i = p - 1;\n      for (int j = p; j < r; j++) {\n        if (cmp(v[j], x)) {\n          i++; tmp = v[i]; v[i] = v[j]; v[j] = tmp;\n        }\n      }\n      i++; tmp = v[i]; v[i] = v[r]; v[r] = tmp;\n      return i;\n    }\n    void align(int p, int r) {\n      if (p < r) {\n        int q = partition(p, r);\n        align(p, q - 1);\n        align(q + 1, r);\n      }\n    }\n    void sort() {\n      align(0, v.size() - 1);\n    }\n  };\n}\n\nnamespace graph {\n\n  template<typename T>\n  class BinarySearchTree {\n    uint64_t _r = 88172645463325252LL;\n    unsigned rnd() {\n      _r = _r ^ (_r << 7);\n      return _r = _r ^ (_r >> 9);\n    }\n    struct Node {\n      T key;\n      unsigned priority;\n      Node* parent;\n      Node* left;\n      Node* right;\n      Node() {}\n      Node(const T& key) : key(key), priority(rnd()), parent(nullptr), left(nullptr), right(nullptr) {}\n      Node(const T& key, unsigned priority) : key(key), priority(priority), parent(nullptr), left(nullptr), right(nullptr) {}\n    };\n    Node* minimum(Node* x) {\n      while (x->left) x = x->left;\n      return x;\n    }\n    Node* successor(Node* x) {\n      if (x->right) return minimum(x->right);\n      Node* y = x->parent;\n      while (y && x == y->right) {\n        x = y;\n        y = y->parent;\n      }\n      return y;\n    }\n    Node* right_rotate(Node* t) {\n      Node* s = t->left;\n      t->left = s->right;\n      s->right = t;\n      return s;\n    }\n    Node* left_rotate(Node* t) {\n      Node* s = t->right;\n      t->right = s->left;\n      s->left = t;\n      return s;\n    }\n    Node* insert(Node* t, const T& key, unsigned priority) {\n      if (!t) return new Node(key, priority);\n      if (key == t->key) return t;\n      if (key < t->key) {\n        t->left = insert(t->left, key, priority);\n        if (t->priority < t->left->priority) t = right_rotate(t);\n      }\n      else {\n        t->right = insert(t->right, key, priority);\n        if (t->priority < t->right->priority) t = left_rotate(t);\n      }\n      return t;\n    }\n    Node* erase(Node* t, const T& key) {\n      if (!t) return t;\n      if (key < t->key) t->left = erase(t->left, key);\n      else if (key > t->key) t->right = erase(t->right, key);\n      else return _erase(t, key);\n      return t;\n    }\n    Node* _erase(Node* t, const T& key) {\n      if (!t->left && !t->right) {\n        delete t;\n        return nullptr;\n      }\n      else if (!t->left) t = left_rotate(t);\n      else if (!t->right) t = right_rotate(t);\n      else t = t->left->priority > t->right->priority ? right_rotate(t) : left_rotate(t);\n      return erase(t, key);\n    }\n    Node* root;\n  public:\n    BinarySearchTree() : root(nullptr) {}\n    void insert(const T& key) {\n      insert(root, key, rnd());\n    }\n    void insert(const T& key, unsigned priority) {\n      root = insert(root, key, priority);\n    }\n    Node* find(const T& key) const {\n      Node* x = root;\n      while (x && key != x->key) x = key < x->key ? x->left : x->right;\n      return x;\n    }\n    void erase(const T& key) {\n      root = erase(root, key);\n    }\n    void free(Node* x) {\n      if (!x) return;\n      if (x->left) free(x->left);\n      if (x->right) free(x->right);\n      delete x;\n    }\n    void print_preorder(const Node* n) const {\n      if (!n) return;\n      std::cout << ' ' << n->key;\n      print_preorder(n->left);\n      print_preorder(n->right);\n    }\n    void print_preorder() const {\n      print_preorder(root);\n    }\n    void print_inorder(const Node* n) const {\n      if (!n) return;\n      print_inorder(n->left);\n      std::cout << ' ' << n->key;\n      print_inorder(n->right);\n    }\n    void print_inorder() const {\n      print_inorder(root);\n    }\n    void print_postorder(const Node* n) const {\n      if (!n) return;\n      print_postorder(n->left);\n      print_postorder(n->right);\n      std::cout << ' ' << n->key;\n    }\n    void print_postorder() const {\n      print_postorder(root);\n    }\n    ~BinarySearchTree() {\n      free(root);\n    }\n  };\n}\n\nint main() {\n  using namespace structure;\n  using namespace algorithm;\n  using namespace graph;\n  using std::cin;\n  using std::cout;\n  using std::cerr;\n  using std::endl;\n  using std::string;\n\n  std::ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  BinarySearchTree<int> bst;\n\n  int m;\n  cin >> m;\n\n  for (int i = 0; i < m; i++) {\n    string op;\n    int k, p;\n    cin >> op;\n    switch (op[0]) {\n    case 'i':\n      cin >> k >> p;\n      bst.insert(k, p);\n      break;\n    case 'f':\n      cin >> k;\n      cout << (bst.find(k) ? \"yes\" : \"no\") << endl;\n      break;\n    case 'p':\n      bst.print_inorder();\n      cout << endl;\n      bst.print_preorder();\n      cout << endl;\n      break;\n    case 'd':\n      cin >> k;\n      bst.erase(k);\n      break;\n    default:\n      exit(1);\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Node{\n  Node *parent, *left, *right;\n  int key, priority;\n};\n\nNode *deleteN(Node*,int);\n\nNode *root, *NIL;\n\n\nNode *rightRotate(Node *t){\n  Node *s=t->left;\n  t->left=s->right;\n  s->right=t;\n  return s;\n}\n\nNode *leftRotate(Node *t){\n  Node *s=t->right;\n  t->right=s->left;\n  s->left=t;\n  return s;\n}\n\nNode *insert(Node *t,int key,int priority){\n  if(t==NIL){\n    Node *temp;\n    temp=new Node;\n    temp->key=key;\n    temp->priority=priority;\n    temp->left=NIL;\n    temp->right=NIL;\n    return temp;\n  }\n  if(key==t->key){\n    return t;\n  }\n  \n  if(key<t->key){\n    t->left=insert(t->left,key,priority);\n    if(t->priority<t->left->priority)\n      t=rightRotate(t);\n  }else{\n    t->right=insert(t->right,key,priority);\n    if(t->priority<t->right->priority)\n      t=leftRotate(t);\n  }\n  return t;\n}\n\nbool find(Node *t,int key){\n  while(t!=NIL && key!=t->key){\n    if(key<t->key) t=t->left;\n    else t=t->right;\n  }\n  return t!=NIL;\n}\n\nvoid inorder(Node *t){\n  if(t==NIL) return;\n  cout<<\" \"<<t->key;\n  inorder(t->left);\n  inorder(t->right);\n}\n\nvoid preorder(Node *t){\n  if(t==NIL)return;\n  preorder(t->left);\n  cout<<\" \"<<t->key;\n  preorder(t->right);\n}\n\nvoid print(Node *t){\n  preorder(t);\n  cout<<endl;\n  inorder(t);\n  cout<<endl;\n}\n\nNode *_delete(Node *t, int key){\n  if(t->left==NIL && t->right==NIL){\n    if(t->parent!=NIL){\n      if(t->parent->left->key==key) t->parent->left=NIL;\n      else t->parent->right=NIL;\n    }\n    return NIL;\n  }else if(t->left==NIL)\n    t=leftRotate(t);\n  else if(t->right==NIL)\n    t=rightRotate(t);\n  else {\n    if(t->left->priority > t->right->priority)\n      t=rightRotate(t);\n    else\n      t=leftRotate(t);\n  }\n  return deleteN(t,key);\n}\n\nNode *deleteN(Node *t,int key){\n  if(t==NIL) return NIL;\n  if(key<t->key) t->left=deleteN(t->left,key);\n  else if(key>t->key) t->right=deleteN(t->right,key);\n  else return _delete(t,key);\n  return t;\n}\n\nint main(){\n  int m,k,p;\n  string s;\n  cin>>m;\n  for(int i=0;i<m;i++){\n    cin>>s;\n    if(s==\"insert\"){\n      cin>>k>>p;\n      root=insert(root,k,p);\n    }else if(s==\"find\"){\n      cin>>k;\n      if(find(root,k)) cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n    }else if(s==\"delete\"){\n      cin>>k;\n      root=deleteN(root,k);\n    }else if(s==\"print\"){\n      print(root);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point {\n    int    a, b;\n    point *l, *r, *pa;\n    point() { l = r = pa = NULL; }\n    point(int aa, int bb) : a(aa), b(bb) { l = r = pa = NULL; };\n};\npoint *root;\npoint *rightRotate(point *t) {\n    point *s = t->l;\n    t->l     = s->r;\n    s->r     = t;\n    return s;\n}\npoint *leftRotate(point *t) {\n    point *s = t->r;\n    t->r     = s->l;\n    s->l     = t;\n    return s;\n}\npoint *insert(point *p, int a, int b) {\n    if (p == NULL) return new point(a, b);\n    if (a == p->a) return p;\n    if (a < p->a) {\n        p->l = insert(p->l, a, b);\n        if (p->b < p->l->b) p = rightRotate(p);\n    } else {\n        p->r = insert(p->r, a, b);\n        if (p->b < p->r->b) p = leftRotate(p);\n    }\n    return p;\n}\npoint *_del(point *p, int a);\npoint *del(point *p, int a) {\n    if (p == NULL) return NULL;\n    if (a < p->a)\n        p->l = del(p->l, a);\n    else if (a > p->a)\n        p->r = del(p->r, a);\n    else\n        return _del(p, a);\n    return p;\n}\npoint *_del(point *p, int a) {\n    if (p->l == NULL && p->r == NULL)\n        return NULL;\n    else if (p->l == NULL)\n        p = leftRotate(p);\n    else if (p->r == NULL)\n        p = rightRotate(p);\n    else {\n        if (p->l->b > p->r->b)\n            p = rightRotate(p);\n        else\n            p = leftRotate(p);\n    }\n    return del(p, a);\n}\nbool find(int a) {\n    point *p = root;\n    while (p) {\n        if (a == p->a) return 1;\n        if (a > p->a)\n            p = p->r;\n        else\n            p = p->l;\n    }\n    return 0;\n}\nvoid dfs1(point *p) {\n    if (!p) return;\n    dfs1(p->l);\n    printf(\" %d\", p->a);\n    dfs1(p->r);\n}\nvoid dfs2(point *p) {\n    if (!p) return;\n    printf(\" %d\", p->a);\n    dfs2(p->l);\n    dfs2(p->r);\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int T;\n    cin >> T;\n    int    ta, tb;\n    string s;\n    while (cin >> s) {\n        if (s == \"insert\") {\n            cin >> ta >> tb;\n            //      if(!root)root=new point(ta,tb);\n            //      else\n            root = insert(root, ta, tb);\n        } else if (s == \"find\") {\n            cin >> ta;\n            if (find(ta))\n                printf(\"yes\\n\");\n            else\n                printf(\"no\\n\");\n        } else if (s == \"print\") {\n            dfs1(root);\n            printf(\"\\n\");\n            dfs2(root);\n            printf(\"\\n\");\n        } else if (s == \"delete\") {\n            cin >> ta;\n            root = del(root, ta);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<typeinfo>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\nstruct tree{\n\n    struct node{\n        ll a;\n        ll p;\n        node* l;\n        node* r;\n    };\n    \n    node NIL={-1,-1,NULL,NULL};\n    node* root=&NIL;\n    \n    tree(){\n        NIL.r=NIL.l=&NIL;\n    }\n\n    /*\n     rightRotate(Node t)\n     Node s = t.left\n     t.left = s.right\n     s.right = t\n     return s // root of the subtree\n     leftRotate(Node t)\n     Node s = t.right\n     t.right = s.left\n     s.left = t\n     return s // root of the subtree\n     */\n    \n    \n    node & Rrotate(node &t){\n        node &s=*t.l;\n        t.l=s.r;\n        s.r=&t;\n        return s;\n    }\n\n    node & Lrotate(node &t){\n        node &s=*t.r;\n        t.r=s.l;\n        s.l=&t;\n        return s;\n    }\n\n    /*\n     insert(Node t, int key, int priority)            // 再帰的に探索\n     if t == NIL\n     return Node(key, priority)               // 葉に到達したら新しい節点を生成して返す\n     if key == t.key\n     return t                                 // 重複したkeyは無視\n     \n     if key < t.key                               // 左の子へ移動\n     t.left = insert(t.left, key, priority)   // 左の子へのポインタを更新\n     if t.priority < t.left.priority          // 左の子の方が優先度が高い場合右回転\n     t = rightRotate(t)\n     else                                         // 右の子へ移動\n     t.right = insert(t.right, key, priority) // 右の子へのポインタを更新\n     if t.priority < t.right.priority         // 右の子の方が優先度が高い場合左回転\n     t = leftRotate(t)\n     \n     return t\n     */\n    \n    node & insert(ll k,ll p){\n        if(root==&NIL){\n            root=(node*)malloc(sizeof(node));\n            root->p=p;\n            root->a=k;\n            root->r=root->l=&NIL;\n            return *root;\n        }\n        return *(root=&insert(*root,k,p));\n    }\n\n    node & insert(node &t,ll k,ll p){\n        if(&t==&NIL){\n            node &a=*(node*)malloc(sizeof(node));\n            a.a=k;\n            a.p=p;\n            a.r=a.l=&NIL;\n            return a;\n        }\n        if(k==t.a){return t;}\n        if(k<t.a){\n            t.l=&insert(*t.l,k,p);\n            if(t.p<t.l->p){\n                return Rrotate(t);\n            }\n        }\n        else{\n            t.r=&insert(*t.r,k,p);\n            if(t.p<t.r->p){\n                return Lrotate(t);\n            }\n        }\n        return t;\n    }\n\n    /*\n     delete(Node t, int key)\n     if t == NIL\n     return NIL\n     if key < t.key                                // 削除対象を検索\n     t.left = delete(t.left, key)\n     else if key > t.key\n     \n     \n     t.right = delete(t.right, key)\n     else\n     return _delete(t, key)\n     return t\n     \n     _delete(Node t, key) // 削除対象の節点の場合\n     if t.left == NIL && t.right == NIL           // 葉の場合\n     return NIL\n     else if t.left == NIL                        // 右の子のみを持つ場合左回転\n     t = leftRotate(t)\n     else if t.right == NIL                       // 左の子のみを持つ場合右回転\n     t = rightRotate(t)\n     else                                         // 左の子と右の子を両方持つ場合\n     if t.left.priority > t.right.priority    // 優先度が高い方を持ち上げる\n     t = rightRotate(t)\n     else\n     t = leftRotate(t)\n     return delete(t, key)\n     */\n\n    node & _delete(node &t,ll k){\n        if(t.l==&NIL && t.r==&NIL){return NIL;}\n        else if(t.l==&NIL){\n            return erase(Lrotate(t),k);\n        }\n        else if(t.l==&NIL){return erase(Rrotate(t),k);}\n        else if(t.r==&NIL){return erase(Rrotate(t),k);}\n        else{\n            if(t.l->p>t.r->p){\n                return erase(Rrotate(t),k);\n            }\n            else{\n                return erase(Lrotate(t),k);\n            }\n        }\n        return t;\n    }\n\n    node & erase(node &t,ll k){\n        if(&t==&NIL){\n            return NIL;\n        }\n        if(k<t.a){t.l=&erase(*t.l,k);}\n        else if(k>t.a){\n            t.r=&erase(*t.r,k);\n        }\n        else{\n            return _delete(t,k);\n        }\n        return t;\n    }\n\n    node & erase(ll k){\n        if(root==&NIL){return NIL;}\n        return *(root=&erase(*root,k));\n    }\n    \n    void test(){\n        dfs_m(*root);\n        cout<<endl;\n        dfs_f(*root);\n        cout<<endl;\n    }\n    \n    void dfs_f(node &w){\n        cout<<\" \"<<w.a;\n        if(w.l!=&NIL){dfs_f(*w.l);}\n        if(w.r!=&NIL){dfs_f(*w.r);}\n    }\n    \n    void dfs_m(node &w){\n        if(w.l!=&NIL){dfs_m(*w.l);}\n        cout<<\" \"<<w.a;\n        if(w.r!=&NIL){dfs_m(*w.r);}\n    }\n    \n    bool find(ll a){\n        if(root==&NIL){return false;}\n        node* w=root;\n        while(1){\n            if(w->a==a){return true;}\n            if(w->a<a && w->r==&NIL){return false;}\n            if(w->a<a){w=w->r;}\n            if(w->a>a && w->l==&NIL){return false;}\n            if(w->a>a){w=w->l;}\n        }\n        return false;\n    }\n};\n\n\n\nint main(){\n    tree B;\n    ll q;\n    cin>>q;\n    while(q--){\n        string s;\n        cin>>s;\n        if(s==\"insert\"){\n            ll b,p;\n            cin>>b>>p;\n            B.insert(b,p);\n        }\n        else if(s==\"find\"){\n            ll b;\n            cin>>b;\n            if(B.find(b)){cout<<\"yes\"<<endl;}\n            else{cout<<\"no\"<<endl;}\n        }\n        else if(s==\"print\"){\n            B.test();\n        }\n        else{\n            ll b;\n            cin>>b;\n            B.erase(b);\n        }\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<string>\n\nusing namespace std;\n\nconstexpr int INFI = 2000000001;\n\nclass node{\npublic:\n\tint id;\n\tint value;\n\tnode* left, * right;\n\tnode*  parent;\n\tint sibling;\n\tint depth;\n\tint height;\n};\n\nbool operator<=(node a, node b) {\n\treturn a.id <= b.id;\n}\nbool operator<(node a, node b) {\n\treturn a.id < b.id;\n}\n\nbool operator==(node a, node b) {\n\treturn a.id == b.id;\n}\n\nbool operator!=(node a, node b) {\n\treturn a.id != b.id;\n}\n\nvoid add(node* root,int a,int v) {\n\tnode *newnode = new node;\n\tnode* now = root->left;\n\tnewnode->id = a;\n\tnewnode->value = v;\n\tnewnode->left = NULL;\n\tnewnode->right = NULL;\n\tif (now == NULL) {\n\t\tnewnode->parent = root;\n\t\troot->left = newnode;\n\t\treturn;\n\t}\n\twhile (1) {\n\t\tif (now->id > a) {\n\t\t\tif (now->left == NULL) {\n\t\t\t\tnow->left = newnode;\n\t\t\t\tnewnode->parent = now;\n\t\t\t\tnow = now->left;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnow = now->left;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (now->right == NULL) {\n\t\t\t\tnow->right = newnode;\n\t\t\t\tnewnode->parent = now;\n\t\t\t\tnow = now->right;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnow = now->right;\n\t\t\t}\n\t\t}\n\t}\n\twhile (now->value > now->parent->value) {\n\t\tif (now->id > now->parent->id) {\n\t\t\tnow->parent->right = now->left;\n\t\t\tif(now->left !=NULL)now->left->parent = now->parent;\n\t\t\tnow->left = now->parent;\n\t\t\tnow->parent = now->parent->parent;\n\t\t\tif (now->parent->id > now->id) {\n\t\t\t\tnow->parent->left = now;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnow->parent->right = now;\n\t\t\t}\n\t\t\tnow->left->parent = now;\n\t\t}\n\t\telse {\n\t\t\tnow->parent->left = now->right;\n\t\t\tif(now->right!=NULL)now->right->parent = now->parent;\n\t\t\tnow->right = now->parent;\n\t\t\tnow->parent = now->parent->parent;\n\t\t\tif (now->parent->id > now->id) {\n\t\t\t\tnow->parent->left = now;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnow->parent->right = now;\n\t\t\t}\n\t\t\tnow->right->parent = now;\n\n\t\t}\n\t\t\n\t}\n}\n\n\nstring postorder(node* nod) {\n\tstring msg=\"\";\n\tif (nod->left->id != -1) {\n\t\tmsg += postorder(nod->left);\t\n\t}\n\tif (nod->right->id != -1) {\n\t\tmsg += postorder(nod->right);\t\n\t}\n\tmsg += to_string(nod->id) + \" \";\n\treturn msg;\n}\n\nvoid preorder(node* root) {\n\tif (root == NULL)return;\n\tcout << \" \"<<root->id;\n\tpreorder(root->left);\n\tpreorder(root->right);\n}\n\nvoid inorder(node* root) {\n\tif (root == NULL)return;\n\tinorder(root->left);\n\tcout <<\" \"<< root->id;\n\tinorder(root->right);\n}\n\nbool find(node* root,int a) {\n\tif (root == NULL)return false;\n\tif (root->id == a)return true;\n\tif (root->id > a)return find(root->left, a);\n\tif (root->id < a)return find(root->right, a);\n}\n\nvoid del(node* root, int a) {\n\troot = root->left;\n\twhile (1) {\n\t\tif (root == NULL)return;\n\t\tif (root->id == a) {\n\t\t\tbreak;\n\t\t}\n\t\telse if (root->id > a) {\n\t\t\troot = root->left;\n\t\t}\n\t\telse {\n\t\t\troot = root->right;\n\t\t}\n\t}\n\twhile (root->left!=NULL || root->right!=NULL){\n\t\tif (root->left == NULL) {\n\t\t\tif (root->id < root->parent->id) {\n\t\t\t\troot->parent->left = root->right;\n\t\t\t}\n\t\t\telse {\n\t\t\t\troot->parent->right = root->right;\n\t\t\t}\n\t\t\troot->right->parent = root->parent;\n\t\t\troot->parent = root->right;\n\t\t\troot->right = root->parent->left;\n\t\t\tif(root->right!=NULL)root->right->parent = root;\n\t\t\troot->parent->left = root;\n\t\t}\n\t\telse if (root->right == NULL) {\n\t\t\tif (root->id < root->parent->id) {\n\t\t\t\troot->parent->left = root->left;\n\t\t\t}\n\t\t\telse {\n\t\t\t\troot->parent->right = root->left;\n\t\t\t}\n\t\t\troot->left->parent = root->parent;\n\t\t\troot->parent = root->left;\n\t\t\troot->left = root->parent->right;\n\t\t\tif(root->left!=NULL)root->left->parent = root;\n\t\t\troot->parent->right = root;\n\t\t}\n\t\telse {\n\t\t\tif (root->left->value > root->right->value) {\n\t\t\t\tif (root->id < root->parent->id) {\n\t\t\t\t\troot->parent->left = root->left;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\troot->parent->right = root->left;\n\t\t\t\t}\n\t\t\t\troot->left->parent = root->parent;\n\t\t\t\troot->parent = root->left;\n\t\t\t\troot->left = root->parent->right;\n\t\t\t\tif(root->left!=NULL)root->left->parent = root;\n\t\t\t\troot->parent->right = root;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (root->id < root->parent->id) {\n\t\t\t\t\troot->parent->left = root->right;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\troot->parent->right = root->right;\n\t\t\t\t}\n\t\t\t\troot->right->parent = root->parent;\n\t\t\t\troot->parent = root->right;\n\t\t\t\troot->right = root->parent->left;\n\t\t\t\tif(root->right!=NULL)root->right->parent = root;\n\t\t\t\troot->parent->left = root;\n\t\t\t}\n\t\t}\n\t}\n\tif (root->id < root->parent->id) {\n\t\troot->parent->left = NULL;\n\t}\n\telse {\n\t\troot->parent->right = NULL;\n\t}\n\tfree(root);\n}\n\n\n\nint main() {\n\tint n,tmp,tmp2;\n\tstring msg;\n\tcin >> n;\n\tnode* root = new node;\n\troot->left = root->right = NULL;\n\troot->id = INFI;\n\troot->value = INFI;\n\tfor (int i = 0;i < n;i++) {\n\t\tcin >> msg;\n\t\tif (msg == \"insert\") {\n\t\t\tcin >> tmp>>tmp2;\n\t\t\tadd(root, tmp,tmp2);\n\t\t}\n\t\telse if (msg == \"print\") {\n\t\t\tinorder(root->left);\n\t\t\tcout << endl;\n\t\t\tpreorder(root->left);\n\t\t\tcout << endl;\n\t\t}\n\t\telse if(msg == \"find\"){\n\t\t\tcin >> tmp;\n\t\t\tif (find(root->left, tmp))cout << \"yes\\n\";\n\t\t\telse cout << \"no\\n\";\n\t\t}\n\t\telse {\n\t\t\tcin >> tmp;\n\t\t\tdel(root, tmp);\n\t\t}\n\t}\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cassert>\n\n//INSERT ABOVE HERE\ntemplate<typename T>\nstruct Treap{\n  struct Node{\n    Node *l,*r;\n    T key,pri;\n    Node(){}\n    Node(T key,T pri):key(key),pri(pri){l=r=nullptr;}\n  };\n  \n  inline Node* create(){\n    return new Node();\n  }\n  \n  inline Node* create(T key,T pri){\n    return new Node(key,pri);\n  }\n  \n  Node* rotR(Node* t){\n    Node* s=t->l;\n    t->l=s->r;\n    s->r=t;\n    return s;\n  }\n  \n  Node* rotL(Node* t){\n    Node* s=t->r;\n    t->r=s->l;\n    s->l=t;\n    return s;\n  }\n  \n  Node* insert(Node* t,T key,T pri){\n    if(t==nullptr) return create(key,pri);\n    if(key==t->key) return t;\n    if(key < t->key){\n      t->l=insert(t->l,key,pri);\n      if(t->pri < t->l->pri) t=rotR(t);\n    }else{\n      t->r=insert(t->r,key,pri);\n      if(t->pri < t->r->pri) t=rotL(t);\n    }\n    return t;\n  }\n\n  Node* erase(Node* t,T key){\n    if(t==nullptr) return t;\n    if(key < t->key) t->l=erase(t->l,key);\n    else if(key > t->key) t->r=erase(t->r,key);\n    else return del(t,key);\n    return t;\n  }\n\n  Node* del(Node* t,T key){\n    if(t->l==nullptr&&t->r==nullptr) return nullptr;\n    if(t->l==nullptr) t=rotL(t);\n    else if(t->r==nullptr) t=rotR(t);\n    else if(t->l->pri < t->r->pri) t=rotL(t);\n    else t=rotR(t);\n    return erase(t,key);\n  }\n\n  Node* find(Node* t,T key){\n    if(t==nullptr) return t;\n    if(key < t->key) return find(t->l,key);\n    if(key > t->key) return find(t->r,key);\n    return t;\n  }\n\n  void print1(Node* t){\n    if(t==nullptr) return;\n    print1(t->l);\n    printf(\" %d\",t->key);\n    print1(t->r);\n  }\n  \n  void print2(Node* t){\n    if(t==nullptr) return;\n    printf(\" %d\",t->key);\n    print2(t->l);\n    print2(t->r);\n  }  \n};\n\nchar s[10];\nint main(){\n  int q;  \n  scanf(\"%d\",&q);\n  Treap<int> G;\n  Treap<int>::Node* r=nullptr;\n  \n  for(int i=0;i<q;i++){    \n    scanf(\"%s\",s);\n    if(s[0]=='i'){\n      int key,pri;\n      scanf(\"%d %d\",&key,&pri);\n      r=G.insert(r,key,pri);\n    }\n    if(s[0]=='d'){\n      int key;\n      scanf(\"%d\",&key);\n      r=G.erase(r,key);\n    }\n    if(s[0]=='f'){\n      int key;\n      scanf(\"%d\",&key);\n      puts((G.find(r,key)!=nullptr?\"yes\":\"no\"));\n    }\n    if(s[0]=='p'){\n      G.print1(r);\n      puts(\"\");\n      G.print2(r);\n      puts(\"\");\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nclass Node {\npublic:\n    int key;\n    int pri;\n    Node* left;\n    Node* right;\n    \n    Node() : key(-1), pri(-1), left(NULL), right(NULL) {}\n    Node( int k, int p ) : key(k), pri(p), left(NULL), right(NULL) {}    \n\n    friend std::ostream& operator << ( std::ostream& os, Node& node ) {\n\tos << \" \" << node.key;\n\treturn os;\n    }\n};\n\nNode* RightRotate( Node* t ) {\n    Node* s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n}\n\nNode* LeftRotate( Node* t ) {\n    Node* s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;\n}\n\nNode* Insert( Node* t, int key, int pri ) {\n\n    if ( t == NULL ) return new Node( key, pri );\n\n    if ( key == t->key ) return t;\n\n    if ( key < t->key ) {\n\n\tt->left = Insert( t->left, key, pri );\n\t\n\tif ( t->pri < t->left->pri ) t = RightRotate( t );\n    }\n    else {\n\n\tt->right = Insert( t->right, key, pri );\n\n\tif ( t->pri < t->right->pri ) t = LeftRotate( t );\n    }\n    \n    return t;\n}\n\nNode* Erase( Node* t, int key ) {\n\n    if ( t == NULL ) return NULL;\n\n    if ( key == t->key ) {\n\t\n\tif      ( t->left == NULL && t->right == NULL ) return NULL;\n\telse if ( t->left == NULL ) t = LeftRotate( t );\n\telse if ( t->right == NULL ) t = RightRotate( t );\n\telse {\n\t    if ( t->left->pri > t->right->pri ) t = RightRotate( t );\n\t    else t = LeftRotate( t );\n\t}\n\t\n\treturn Erase( t, key );\n    }\n\n    if ( key < t->key ) t->left = Erase( t->left, key );\n    else t->right = Erase( t->right, key );\n\n    return t;\n}\n\nbool Find( Node* t, int key ) {\n\n    if ( t == NULL ) return false;\n\n    if ( key == t->key ) return true;\n\n    if ( key < t->key ) return Find( t->left, key );\n    return Find( t->right, key );\n\n}\n\nvoid PrintInOrder( Node* t ) {\n    if ( !t ) return;\n    if ( t->left ) PrintInOrder( t->left );\n    cout << *t;\n    if ( t->right ) PrintInOrder( t->right );\n}\n\nvoid PrintPreOrder( Node* t ) {\n    if ( !t ) return;\n    cout << *t;\n    if ( t->left ) PrintPreOrder( t->left );\n    if ( t->right ) PrintPreOrder( t->right );\n}\n\nint main() {\n\n    Node* root = NULL;\n\n    int n;\n    cin >> n;\n\n    int k, p;\n    string s;\n    for ( int i=0; i<n; ++i ) {\n\n\tcin >> s;\n\n\tif ( s == \"insert\" ) {\n\t    cin >> k >> p;\n\t    root = Insert( root, k, p );\n\t}\n\telse if ( s == \"find\" ) {\n\t    cin >> k;\n\t    if ( Find( root, k ) ) cout << \"yes\\n\";\n\t    else cout << \"no\\n\";\n\t}\n\telse if ( s == \"delete\" ) {\n\t    cin >> k;\n\t    root = Erase( root, k );\n\t}\n\telse if ( s == \"print\" ) {\n\t    PrintInOrder( root );\n\t    cout << endl;\n\t    PrintPreOrder( root );\n\t    cout << endl;\n\t}\n\t\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define fordebug int hoge;cin>>hoge;\n#define DEKAI 1000000007\n#define INF (1<<28)\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,j,n) for(int i=j;i<n;i++)\n#define floot10 cout<<fixed<<setprecision(10);\n\n//from ok 2018-12-02 must retry\n//condate=18-12-5\nstruct Node{\n\tNode *parent, *left, *right;\n\tint key, priority;\n};\n\nNode *deleteN(Node*,int);\n\nNode *root, *NIL;\n\n\nNode *rightRotate(Node *t){\n\tNode *s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\n\nNode *leftRotate(Node *t){\n\tNode *s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\n\nNode *insert(Node *t,int key, int priority){\n\tif(t == NIL){//cout<<key<<\" \"<<priority<<endl;\n\t\tNode *temp;\n\t\ttemp = new Node;\n\t\ttemp->key = key;\n\t\ttemp->priority = priority;\n\t\ttemp->left = NIL;\n\t\ttemp->right = NIL;\n\t\treturn temp;\n\t}\n\tif(key == t->key){\n\t\treturn t;\n\t}\n\t\n\tif(key < t->key){\n\t\tt->left = insert(t->left, key, priority);\n\t\tif(t->priority < t->left->priority)\n\t\t\tt = rightRotate(t);\n\t} else {\n\t\tt->right = insert(t->right, key, priority);\n\t\tif(t->priority < t->right->priority)\n\t\t\tt = leftRotate(t);\n\t}\n\treturn t;\n}\n\nbool find(Node *t, int key){\n\twhile(t != NIL && key != t->key){\n\t\tif(key < t->key) t = t->left;\n\t\telse t = t->right;\n\t}\n\treturn t!=NIL;\n}\n\nvoid inorder(Node *t){\n\tif(t == NIL) return;\n\tcout<<\" \"<<t->key;\n\tinorder(t->left);\n\tinorder(t->right);\n}\n\nvoid preorder(Node *t){\n\tif(t == NIL)return;\n\tpreorder(t->left);\n\tcout<<\" \"<<t->key;\n\tpreorder(t->right);\n}\n\nvoid print(Node *t){\n\tpreorder(t);\n\tcout<<endl;\n\tinorder(t);\n\tcout<<endl;\n}\n\nNode *_delete(Node *t, int key){\n\tif(t->left == NIL && t->right == NIL){\n\t\tif(t->parent != NIL){\n\t\t\tif(t->parent->left->key == key) t->parent->left = NIL;\n\t\t\telse t->parent->right = NIL;\n\t\t}\n\t\t//delete t;\n\t\treturn NIL;\n\t}else if(t->left == NIL)\n\t\tt = leftRotate(t);\n\telse if(t->right == NIL)\n\t\tt = rightRotate(t);\n\telse {\n\t\tif(t->left->priority > t->right->priority)\n\t\t\tt = rightRotate(t);\n\t\telse\n\t\t\tt = leftRotate(t);\n\t}\n\treturn deleteN(t,key);\n}\n\nNode *deleteN(Node *t, int key){\n\tif(t == NIL)\n\t\treturn NIL;\n\tif(key < t->key)\n\t\tt->left = deleteN(t->left, key);\n\telse if(key > t->key)\n\t\tt->right = deleteN(t->right, key);\n\telse \n\t\treturn _delete(t,key);\n\treturn t;\n}\n\nint main(){\n\tint n, k, p;\n\tstring order;\n\t\n\tcin>>n;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin>>order;\n\t\t\n\t\tif(order == \"insert\"){\n\t\t\tcin>>k>>p;\n\t\t\troot = insert(root,k,p);\n\t\t} else if(order == \"find\"){\n\t\t\tcin>>k;\n\t\t\tcout<<(find(root,k)?\"yes\":\"no\")<<endl;\n\t\t} else if(order == \"delete\"){\n\t\t\tcin>>k;\n\t\t\troot = deleteN(root,k);\n\t\t} else if(order == \"print\"){\n\t\t\tprint(root);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nclass Node {\npublic:\n\tint key;\n\tNode* left;\n\tNode* right;\n\tint priority;\n\tNode(int key, int priority) { this->key = key; left = right = NULL; this->priority = priority; }\n\t~Node(){}\n};\n\nNode* deleteKey(Node* t, int key);\n\nNode* rightRotate(Node* t)\n{\n\tNode* s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\n\nNode* leftRotate(Node* t)\n{\n\tNode* s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\n\nNode* insert(Node* t, int key, int priority)\n{\t\n\tif (t == NULL) return new Node(key, priority);\n\tif (key == t->key) return t;\n\t\n\tif (key < t->key) {\n\t\tt->left = insert(t->left, key, priority);\n\t\tif (t->priority < t->left->priority) t = rightRotate(t);\n\t}\n\telse {\n\t\tt->right = insert(t->right, key, priority);\n\t\tif (t->priority < t->right->priority) t = leftRotate(t);\n\t}\n\treturn t;\n}\n\nNode* _deleteKey(Node* t, int key)\n{\n\tif (t->left == NULL && t->right == NULL) {\n\t\tdelete t;\n\t\treturn NULL;\n\t}\n\telse if (t->left == NULL) t = leftRotate(t);\n\telse if (t->right == NULL) t = rightRotate(t);\n\telse {\n\t\tif (t->left->priority > t->right->priority) t = rightRotate(t);\n\t\telse t = leftRotate(t);\n\t}\n\treturn deleteKey(t, key);\n}\n\nNode* deleteKey(Node* t, int key)\n{\n\tif (t == NULL) return NULL;\n\tif (key < t->key) t->left = deleteKey(t->left, key);\n\telse if (key > t->key) t->right = deleteKey(t->right, key);\n\telse return _deleteKey(t, key);\n\treturn t;\n}\n\nbool find(Node* z, int key)\n{\n\tif (z == NULL) return false;\n\t\n\tif (key == z->key) return true;\n\tif (key < z->key) return find(z->left, key);\n\telse return find(z->right, key);\n}\n\nvoid walk_preorder(Node* x)\n{\n\tstd::cout << \" \" << x->key;\n\tif (x->left != NULL) walk_preorder(x->left);\n\tif (x->right != NULL) walk_preorder(x->right);\n}\n\nvoid walk_inorder(Node* x)\n{\n\tif (x->left != NULL) walk_inorder(x->left);\n\tstd::cout << \" \" << x->key;\n\tif (x->right != NULL) walk_inorder(x->right);\n}\n\nvoid deleteTree(Node* x)\n{\n\tif (x->left != NULL) deleteTree(x->left);\n\tif (x->right != NULL) deleteTree(x->right);\n\tdelete x;\n}\n\t\nint main()\n{\n\tstd::string strn;\n\tgetline(std::cin, strn);\n\t\n\tint n = std::stoi(strn);\n\t\n\tNode* Treap = NULL;\n\t\n\tfor (int i=0; i<n; i++) {\n\t\tstd::string buf;\n\t\tgetline(std::cin, buf);\n\t\tint sp_pos1 = buf.find(' ', 0);\n\t\tif (sp_pos1 == std::string::npos) {\n\t\t\t// print\n\t\t\twalk_inorder(Treap); std::cout << std::endl;\n\t\t\twalk_preorder(Treap); std::cout << std::endl;\n\t\t}\n\t\telse {\n\t\t\tint sp_pos2 = buf.find(' ', sp_pos1+1);\n\t\t\tif (sp_pos2 == std::string::npos) { // find or delete\n\t\t\t\tstd::string op = buf.substr(0, sp_pos1);\n\t\t\t\tint key = std::stoi(buf.substr(sp_pos1+1));\n\t\t\t\tif (op == \"find\") {\n\t\t\t\t\tif (find(Treap, key)) std::cout << \"yes\" << std::endl;\n\t\t\t\t\telse std::cout << \"no\" << std::endl;\n\t\t\t\t}\n\t\t\t\telse { // delete\n\t\t\t\t\tTreap = deleteKey(Treap, key);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint key = std::stoi(buf.substr(sp_pos1 + 1, sp_pos2 - sp_pos1 - 1));\n\t\t\t\tint priority = std::stoi(buf.substr(sp_pos2+1)); \n\t\t\t\tTreap = insert(Treap, key, priority);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tdeleteTree(Treap);\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i,n) for(UL i=0; i<(n); i++)\n\nstruct Tree{\n struct Node{ int l=-1,r=-1,p=-1; int v; int w; };\n vector<Node> V;\n int R=-1;\n\n int& parentchild(int v){\n  if(v==R) return R;\n  if(V[V[v].p].l==v) return V[V[v].p].l;\n  else return V[V[v].p].r;\n }\n void swapidx(int a,int b){\n  swap(parentchild(a), parentchild(b));\n  swap(V[a], V[b]);\n  if (V[a].l != -1) V[V[a].l].p = a;\n  if (V[a].r != -1) V[V[a].r].p = a;\n  if (V[b].l != -1) V[V[b].l].p = b;\n  if (V[b].r != -1) V[V[b].r].p = b;\n }\n void rotL(int v){\n  int w=V[v].r;\n  parentchild(v)=w; V[w].p=V[v].p;\n  V[v].r=V[w].l; if(V[v].r!=-1) V[V[v].r].p=v;\n  V[v].p=w; V[w].l=v;\n }\n void rotR(int v){\n  int w=V[v].l;\n  parentchild(v)=w; V[w].p=V[v].p;\n  V[v].l=V[w].r; if(V[v].l!=-1) V[V[v].l].p=v;\n  V[v].p=w; V[w].r=v;\n }\n\n void fix(int v){\n  while(true){\n   int p=V[v].p;\n   if(p==-1) return;\n   if(V[p].w>=V[v].w) return;\n   if(V[p].l==v) rotR(p); else rotL(p);\n  }\n }\n\n void insert(int v, int w){\n  int p=-1; int* pp=&R;\n  while(*pp!=-1){\n   p=*pp;\n   if(v<V[p].v) pp=&V[p].l;\n   else if(v>V[p].v) pp=&V[p].r;\n   else return;\n  }\n  *pp=V.size();\n  V.push_back({-1,-1,p,v,w});\n  fix(V.size()-1);\n }\n int find(int v){\n  int p=R;\n  while(p!=-1){\n   if(v==V[p].v) return p;\n   if(v<V[p].v) p=V[p].l; else p=V[p].r;\n  }\n  return -1;\n }\n void erase(int v){\n  if(v==-1) return;\n  while(true){\n   if(V[v].l!=-1 && V[v].r!=-1){\n    if(V[V[v].l].w<V[V[v].r].w) rotL(v);\n    else rotR(v);\n   }\n   else if(V[v].l!=-1) rotR(v);\n   else if(V[v].r!=-1) rotL(v);\n   else break;\n  }\n  swapidx(v,V.size()-1);\n  parentchild(V.size()-1)=-1;\n  V.pop_back();\n }\n\n void printPreorder(int p=-2){\n  if(p==-2) p=R;\n  if(p==-1) return;\n  printf(\" %d\",V[p].v);\n  printPreorder(V[p].l);\n  printPreorder(V[p].r);\n }\n void printInorder(int p=-2){\n  if(p==-2) p=R;\n  if(p==-1) return;\n  printInorder(V[p].l);\n  printf(\" %d\",V[p].v);\n  printInorder(V[p].r);\n }\n};\n\nTree T;\nint Q;\n\nint main() {\n scanf(\"%d\",&Q);\n rep(i,Q){\n  string c;\n  { char buf[10]; scanf(\"%s\",buf); c=buf; }\n  if(c==\"insert\"){\n   int v,w; scanf(\"%d%d\",&v,&w);\n   T.insert(v,w);\n  }\n  else if(c==\"find\"){\n   int v; scanf(\"%d\",&v);\n   if(T.find(v)==-1) printf(\"no\\n\"); else printf(\"yes\\n\"); fflush(stdout);\n  }\n  else if(c==\"delete\"){\n   int v; scanf(\"%d\",&v);\n   T.erase(T.find(v));\n  }\n  else if(c==\"print\"){\n   T.printInorder(); printf(\"\\n\");\n   T.printPreorder(); printf(\"\\n\"); fflush(stdout);\n  }\n }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\n#define track(); cout<<\"#############\"<<endl;\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\ntypedef struct node{\n  struct node *l=NULL;\n  struct node *r=NULL;\n  int key=0;\n  int pri=0;\n}Node;\n\nNode* RightRotate(Node *t){\n  Node *s=t->l;\n  t->l=s->r;\n  s->r=t;\n  return s;\n}\n\nNode* LeftRotate(Node *t){\n  Node *s=t->r;\n  t->r=s->l;\n  s->l=t;\n  return s;\n}\n\nNode* ins(Node* t,int key,int pri){\n  if(t==NULL){\n    t=(Node*)malloc(sizeof(Node));\n    t->l=NULL;\n    t->r=NULL;\n    t->key=key;\n    t->pri=pri;\n    return t;\n  }\n  if(key==t->key)return t;\n  if(key<t->key){\n    t->l = ins(t->l,key,pri);\n    if(t->pri < t->l->pri)t=RightRotate(t);\n  }\n  else {\n    t->r = ins(t->r,key,pri);\n    if(t->pri < t->r->pri)t=LeftRotate(t);\n  }\n  return t;\n}\n\nbool find(Node *t,int key){\n  if(t==NULL)return false;\n  if(t->key==key)return true;\n  if(key<t->key)return find(t->l,key);\n  return find(t->r,key);\n}\n\nNode* del(Node *t,int key){\n  if(t==NULL)return NULL;\n  if(key==t->key){\n    if(t->l==NULL && t->r==NULL){\n      return NULL;\n    }\n    else if(t->l==NULL){\n      t=LeftRotate(t);\n    }\n    else if(t->r==NULL){\n      t=RightRotate(t);\n    }\n    else {\n      if(t->l->pri >t->r->pri)\n        t=RightRotate(t);\n      else \n        t=LeftRotate(t);\n    }\n    return del(t,key);\n  }\n\n  if(key<t->key)\n    t->l = del(t->l,key);\n  else \n    t->r = del(t->r,key);\n  return t;\n}\n\nvoid inorder(node *t){\n  if(t->l != NULL)inorder(t->l);\n//  cout<<\" \"<<t->key;\n  printf(\" %d\",t->key);\n  if(t->r != NULL)inorder(t->r);\n}\n\nvoid preorder(node *t){\n  printf(\" %d\",t->key);\n  //cout<<\" \"<<t->key;\n  if(t->l != NULL)preorder(t->l);\n  if(t->r != NULL)preorder(t->r);\n}\n\nint main()\n{\n  int n,a,b;\n  string s;\n  Node *t=NULL;\n  cin>>n;\n  FOR(i,0,n){\n    cin>>s;\n    if(s==\"insert\"){\n      cin>>a>>b;\n      t=ins(t,a,b);\n    }\n    else if(s==\"find\"){\n      cin>>a;\n      if(find(t,a))cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n    }\n    else if(s==\"delete\"){\n      cin>>a;\n      t=del(t,a);\n    }\n    else {\n      inorder(t);\n      cout<<endl;\n      preorder(t);\n      cout<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\n#define USE_LLONG_AS_INT\n#ifdef USE_LLONG_AS_INT\n#define int long long\n#define inf (1ll<<60)\n#else\n#define inf (1<<30)\n#endif\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define Rep(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a,b) for(int i=(a);i<=(b);i++)\n#define rev(i,n) for(int i=(n)-1;i>=0;i--)\n#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define eb emplace_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n#define SORT(v) sort(all(v))\n#define RSORT(v) sort(all(v), greater<int>())\n\nusing namespace std;\n\nconst int mod=1e9+7;\nconst string sp=\" \";\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\nstruct Node{\n    int k,p;\n    Node *l,*r;\n};\n\nNode *root;\n\nNode *rightRotate(Node *t){\n    Node *s=t->l;\n    t->l=s->r;\n    s->r=t;\n    return s;\n}\n\nNode *leftRotate(Node *t){\n    Node *s=t->r;\n    t->r=s->l;\n    s->l=t;\n    return s;\n}\n\nNode *insert(Node *t,int k,int p){\n    if(t==NULL){\n        t=(Node *)malloc(sizeof(Node));\n        t->k=k;\n        t->p=p;\n        t->l=t->r=NULL;\n        return t;\n    }\n    if(k==t->k)return t;\n    if(k<t->k){\n        t->l=insert(t->l,k,p);\n        if(t->p<t->l->p)t=rightRotate(t);\n    }\n    else{\n        t->r=insert(t->r,k,p);\n        if(t->p<t->r->p)t=leftRotate(t);\n    }\n    return t;\n}\n\nNode *find(Node *v,int k){\n    while(v!=NULL&&k!=v->k){\n        if(k<v->k)v=v->l;\n        else v=v->r;\n    }\n    return v;\n}\n\nNode *del(Node *t,int k){\n    if(t==NULL)return NULL;\n    if(k<t->k)t->l=del(t->l,k);\n    else if(k>t->k)t->r=del(t->r,k);\n    else{\n        if(t->l==NULL&&t->r==NULL)return NULL;\n        else if(t->l==NULL)t=leftRotate(t);\n        else if(t->r==NULL)t=rightRotate(t);\n        else{\n            if(t->l->p>t->r->p)t=rightRotate(t);\n            else t=leftRotate(t);\n        }\n        return del(t,k);\n    }\n    return t;\n}\n\nvoid inorder(Node* v){\n    if(v==NULL)return;\n    inorder(v->l);\n    cout<<\" \"<<v->k;\n    inorder(v->r);\n}\n\nvoid preorder(Node* v){\n    if(v==NULL)return;\n    cout<<\" \"<<v->k;\n    preorder(v->l);\n    preorder(v->r);\n}\n\nvoid run(){\n    int n;\n    cin>>n;\n    rep(i,n){\n       string s;\n       cin>>s;\n       if(s==\"insert\"){\n           int k,p;\n           cin>>k>>p;\n           root=insert(root,k,p);\n       }\n       else if(s==\"find\"){\n           int k;\n           cin>>k;\n           cout<<(find(root,k)!=NULL?\"yes\":\"no\")<<endl;\n       }\n       else if(s==\"print\"){\n           inorder(root);\n           cout<<endl;\n           preorder(root);\n           cout<<endl;\n       }\n       else{\n           int k;\n           cin>>k;\n           root=del(root, k);\n       }\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nstruct Node{\n    int key, pri;\n    Node* left;\n    Node* right;\n};\n\nNode* _del(Node* t, int key);\n\nNode* newNode(int k, int p){\n    Node* ret = (Node*)(malloc(sizeof(Node)));\n    ret->key = k;\n    ret->pri = p;\n    ret->left = NULL;\n    ret->right = NULL;\n    return ret;\n}\n\nNode* rightRotate(Node* t){\n    Node* s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n}\n\nNode* leftRotate(Node* t){\n    Node* s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;\n}\n\nNode* insert(Node* t, int key, int pri){\n    if(t == NULL){\n        return newNode(key, pri);\n    }\n    if(key == t->key){\n        return t;\n    }\n    if(key < t->key){\n        t->left = insert(t->left, key, pri);\n        if(t->pri < t->left->pri)   t = rightRotate(t);\n    }else{\n        t->right = insert(t->right, key, pri);\n        if(t->pri < t->right->pri)   t = leftRotate(t);\n    }\n    return t;\n}\n\n// 削除対象となるNodeを検索\nNode* del(Node* t, int key){\n    if(t == NULL){\n        return NULL;\n    }\n    if(key < t->key){\n        t->left = del(t->left, key);\n    }else if(key > t->key){\n        t->right = del(t->right, key);\n    }else{\n        return _del(t, key);\n    }\n    return t;\n}\n\n// 削除対象の節点\nNode* _del(Node* t, int key){\n    if(t->left == NULL && t->right == NULL){\n        return NULL;\n    }else if(t->left == NULL){\n        t = leftRotate(t);\n    }else if(t->right == NULL){\n        t = rightRotate(t);\n    }else{\n        if(t->left->pri < t->right->pri){\n            t = leftRotate(t);\n        }else{\n            t = rightRotate(t);\n        }\n    }\n    return del(t, key);\n}\n\nvoid in(Node* t){\n    if(t->left != NULL) in(t->left);\n    cout << \" \" << t->key;\n    if(t->right != NULL) in(t->right);\n}\n\nvoid pre(Node* t){\n    cout << \" \" << t->key;\n    if(t->left != NULL) pre(t->left);\n    if(t->right != NULL) pre(t->right);\n}\n\nbool find(Node* t, int key){\n    if(t == NULL)   return false;\n    if(t->key == key)   return true;\n    if(key < t->key)    return find(t->left, key);\n    else                return find(t->right, key);\n}\n\nint main(){\n    Node* root = NULL;\n    int m;\n    cin >> m;\n    while(m-- > 0){\n        string s;\n        cin >> s;\n        if(s == \"insert\"){\n            int key, pri;\n            cin >> key >> pri;\n            root = insert(root, key, pri);\n        }else if(s == \"print\"){\n            in(root);   cout << endl;\n            pre(root);  cout << endl;\n        }else if(s == \"delete\"){\n            int key;    cin >> key;\n            root = del(root, key);\n        }else if(s == \"find\"){\n            int key;    cin >> key;\n            cout << (find(root, key) ? \"yes\" : \"no\") << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct node_t{\n\tint key;\n\tint priority;\n\tnode_t *left;\n\tnode_t *right;\n\tnode_t(int key, int priority): key(key), priority(priority), left(NULL), right(NULL) {}\n};\n\nnode_t* left_rotate(node_t *t){\n\tnode_t *right_child = t->right;\n\tt->right = right_child->left;\n\tright_child->left = t;\n\treturn right_child;\n}\n\nnode_t* right_rotate(node_t *t){\n\tnode_t *left_child = t->left;\n\tt->left = left_child->right;\n\tleft_child->right = t;\n\treturn left_child;\n}\n\nnode_t* insert(node_t *t, int key, int priority){\n\tif(t == NULL) return new node_t(key, priority);\n\tif(key == t->key) return t;\n\tif(key < t->key){\n\t\tt->left = insert(t->left, key, priority);\n\t\tif(t->priority < t->left->priority) t = right_rotate(t);\n\t}else{\n\t\tt->right = insert(t->right, key, priority);\n\t\tif(t->priority < t->right->priority) t = left_rotate(t);\n\t}\n\treturn t;\n}\n\nnode_t* delete_node(node_t *t, int key){\n\tif(t == NULL) return NULL;\n\tif(key == t->key){\n\t\t// move the node to the leaf\n\t\tif(t->left == NULL && t->right == NULL) {\n\t\t\tdelete t;\n\t\t\treturn NULL;\n\t\t}else if(t->left == NULL){\n\t\t\tt = left_rotate(t);\n\t\t}else if(t->right == NULL){\n\t\t\tt = right_rotate(t);\n\t\t}else{\n\t\t\tif(t->left->priority > t->right->priority){\n\t\t\t\tt = right_rotate(t);\n\t\t\t}else{\n\t\t\t\tt = left_rotate(t);\n\t\t\t}\n\t\t}\n\t\treturn delete_node(t, key); // do this again until we move t into the leaf\n\t}\n\n\t// search the node to delete\n\tif(key < t->key){\n\t\tt->left = delete_node(t->left, key);\n\t}else{\n\t\tt->right = delete_node(t->right, key);\n\t}\n\treturn t;\n}\n\nvoid find_node(node_t *t, int key){\n\tif(t == NULL) {\n\t\tcout << \"no\" << endl;\n\t\treturn;\n\t}\n\tif(key == t->key){\n\t\tcout << \"yes\" << endl;\n\t}else if(key < t->key){\n\t\tfind_node(t->left, key);\n\t}else{\n\t\tfind_node(t->right, key);\n\t}\n}\n\nvoid inorder(node_t *t){\n\tif(t == NULL){\n\t\treturn;\n\t}\n\tinorder(t->left);\n\tcout << \" \" << t->key;\n\tinorder(t->right);\n}\n\nvoid preorder(node_t *t){\n\tif(t == NULL) {\n\t\treturn;\n\t}\n\tcout << \" \" << t->key;\n\tpreorder(t->left);\n\tpreorder(t->right);\n}\n\nvoid print_tree(node_t *t){\n\tinorder(t);\n\tcout << endl;\n\tpreorder(t);\n\tcout << endl;\n}\n\nint main(){\n\tint q;\n\tcin >> q;\n\tnode_t *t = NULL;\n\tfor(auto i = 0; i < q; ++i){\n\t\tstring cmd;\n\t\tcin >> cmd;\n\t\tif(cmd == \"insert\"){\n\t\t\tint k, p;\n\t\t\tcin >> k >> p;\n\t\t\tt = insert(t, k, p);\n\t\t}else if(cmd == \"find\"){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tfind_node(t, k);\n\t\t}else if(cmd == \"delete\"){\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tt = delete_node(t, k);\n\t\t}else if(cmd == \"print\"){\n\t\t\tprint_tree(t);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\ntypedef struct node{\n  int key;\n  int priority;\n  struct node *left;\n  struct node *right;\n}node;\n\nnode * Delete(node **, int);\nnode * _delete(node **, int);\n\nint find(node *p, int x){\n  while(p != NULL){\n    if(p->key == x) return 1;\n    else if(p->key > x) p = p->left;\n    else p = p->right;\n  }\n  return 0;\n}\n\nvoid inorder(node *p){\n  if(p->left != NULL) inorder(p->left);\n\n  cout  << \" \" << p->key;\n\n  if(p->right != NULL) inorder(p->right);\n\n  return;\n}\n\nvoid preorder(node *p){\n  cout << \" \" << p->key;\n\n  if(p->left != NULL) preorder(p->left);\n\n  if(p->right != NULL) preorder(p->right);\n\n  return;\n}\n\nvoid print(node *p){\n  inorder(p);\n  cout << endl;\n\n  preorder(p);\n  cout << endl;\n\n  return;\n}\n\nnode * makenode(int x, int y){\n  node *n = new node;\n  n->key = x;\n  n->priority = y;\n  n->left = NULL;\n  n->right = NULL;\n  return n;\n}\n\nnode *rightRotate(node *p){\n  node *q = p->left;\n  p->left = q->right;\n  q->right = p;\n  return q;\n}\n\nnode *leftRotate(node *p){\n  node *q = p->right;\n  p->right = q->left;\n  q->left = p;\n  return q;\n}\n\nnode *insert(node **t, int key, int priority){\n  node *n;\n\n  if((*t) == NULL) return n = makenode(key, priority);\n\n  if((*t)->key == key) return *t;\n\n  if(key < (*t)->key){\n    (*t)->left = insert(&(*t)->left, key, priority);\n    if((*t)->priority < (*t)->left->priority)\n      (*t) = rightRotate((*t));\n  }\n\n  else {\n    (*t)->right = insert(&(*t)->right, key, priority);\n    if((*t)->priority < (*t)->right->priority)\n      (*t) = leftRotate((*t));\n  }\n\n  return *t;\n}\n\nnode * Delete(node **t, int key){\n  if((*t) == NULL) return NULL;\n\n  if(key < (*t)->key)\n    (*t)->left = Delete(&((*t)->left), key);\n\n  else if(key > (*t)->key)\n    (*t)->right = Delete(&((*t)->right), key);\n\n  else return _delete(t, key);\n\n  return *t;\n}\n\nnode * _delete(node **t, int key){\n  if((*t)->left == NULL && (*t)->right == NULL)\n    return NULL;\n\n  else if((*t)->left == NULL)\n    (*t)=leftRotate(*t);\n\n  else if((*t)->right == NULL)\n    (*t)=rightRotate(*t);\n\n  else {\n    if((*t)->left->priority > (*t)->right->priority)\n      (*t) = rightRotate(*t);\n    else\n      (*t) = leftRotate(*t);\n  }\n  return Delete(t, key);\n}\n\nint main(){\n  int n, x, y;\n  char com[8];\n  node *root = NULL;\n\n  cin >> n;\n\n  for(int i = 0; i < n; ++i){\n    cin >> com;\n\n    switch(com[0]){\n\n      case 'i': cin >> x >> y;\n        root = insert(&root, x, y);\n        break;\n\n      case 'd': cin >> x;\n        root = Delete(&root, x);\n        break;\n\n      case 'f': cin >> x;\n        if(find(root, x)) cout << \"yes\" << endl;\n        else cout << \"no\" << endl;\n        break;\n\n      case 'p': print(root);\n        break;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<stdio.h>\n#include<fstream>\n#include<stdlib.h>\n#include<math.h>\n#include<queue>\n#include<string.h>\n#include<stack>\n\nusing namespace std;\nstruct point{\n  int a,b;\n  point *l,*r,*pa;\n  point(){l=r=pa=NULL;}\n  point(int sa,int sb):a(sa),b(sb){l=r=pa=NULL;};\n};\npoint *root;\npoint *rightRotate(point *t){\n  point *s=t->l;\n  t->l=s->r;\n  s->r=t;\n  return s;\n}\npoint *leftRotate(point *t){\n  point *s=t->r;\n  t->r=s->l;\n  s->l=t;\n  return s;\n}\npoint* insert(point *p,int a,int b){\n  if(p==NULL)return new point(a,b);\n  if(a==p->a)return p;\n  if(a<p->a){\n    p->l=insert(p->l,a,b);\n    if(p->b<p->l->b)\n      p=rightRotate(p);\n  }else{\n    p->r=insert(p->r,a,b);\n    if(p->b<p->r->b)\n      p=leftRotate(p);\n  }return p;\n}\npoint *_del(point *p, int a);\npoint *del(point *p,int a){\n  if(p==NULL)return NULL;\n  if(a<p->a)p->l=del(p->l,a);\n  else if(a>p->a)p->r=del(p->r,a);\n  else return _del(p,a);\n  return p;\n}\npoint *_del(point *p, int a){\n  if(p->l==NULL&&p->r==NULL)return NULL;\n  else if(p->l==NULL)p=leftRotate(p);\n  else if(p->r==NULL)p=rightRotate(p);\n  else{\n    if(p->l->b>p->r->b)p=rightRotate(p);\n    else p=leftRotate(p);\n  }return del(p,a);\n}\nbool find(int a){\n  point *p=root;\n  while(p){\n    if(a==p->a)return 1;\n    if(a>p->a)p=p->r;\n    else p=p->l;\n  }\n  return 0;\n}\nvoid dfs1(point *p){\n  if(!p)return;\n  dfs1(p->l);\n  printf(\" %d\",p->a);\n  dfs1(p->r);\n}\nvoid dfs2(point *p){\n  if(!p)return;\n  printf(\" %d\",p->a);\n  dfs2(p->l);\n  dfs2(p->r);\n}\nint main(){\n  ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n  int T;cin>>T;\n  int ta,tb;\n  string s;\n  while(cin>>s){\n    if(s==\"insert\"){\n      cin>>ta>>tb;\n      //if(!root)root=new point(ta,tb);\n      //else\n      root=insert(root,ta,tb);\n    }else if(s==\"find\"){\n      cin>>ta;\n      if(find(ta))printf(\"yes\\n\");\n      else printf(\"no\\n\");\n    }else if(s==\"print\"){\n      dfs1(root);\n      printf(\"\\n\");\n      dfs2(root);\n      printf(\"\\n\");\n    }else if(s==\"delete\"){\n      cin>>ta;\n      root=del(root,ta);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nusing namespace std;\n#define _overload3(_1, _2, _3, name, ...) name\n#define _rep(i, n) repi(i, 0, n)\n#define repi(i, a, b) for(int i = int(a); i < int(b); ++i)\n#define rep(...) _overload3(__VA_ARGS__, repi, _rep, )(__VA_ARGS__)\nconst long long INFLL = 1LL << 60;\nconst int INFINT = 1 << 30;\nconst long long MOD = 1e9 + 7;\n\ntemplate <class T> void vecout(T V) {\n    auto t = V.begin();\n    while(t != V.end()) {\n        cout << *t++;\n        if(t != V.end()) cout << \" \";\n    }\n    cout << endl;\n};\n\nclass node {\n  public:\n    int key;\n    int pri;\n    node *p;\n    node *l;\n    node *r;\n};\nnode *NIL, *root;\n\nnode *rightRotate(node *t) {\n    node *s;\n    s = t->l;\n    t->l = s->r;\n    s->r = t;\n    return s;\n}\n\nnode *leftRotate(node *t) {\n    node *s;\n    s = t->r;\n    t->r = s->l;\n    s->l = t;\n    return s;\n}\n\nnode *insert(node *t, int k, int p) {\n    if(t == NIL) {\n        node *z = new node;\n        z->key = k;\n        z->pri = p;\n        z->l = NIL;\n        z->r = NIL;\n        return z;\n    }\n    if(k == t->key) {\n        return t;\n    }\n    if(k < t->key) {\n        t->l = insert(t->l, k, p);\n        if(t->pri < t->l->pri) t = rightRotate(t);\n    } else {\n        t->r = insert(t->r, k, p);\n        if(t->pri < t->r->pri) t = leftRotate(t);\n    }\n    return t;\n}\n\nvoid traverse(node *now, int order) {\n    if(order == 0) cout << \" \" << now->key; // preorder\n    if(now->l != NIL) traverse(now->l, order);\n    if(order == 1) cout << \" \" << now->key; // inorder\n    if(now->r != NIL) traverse(now->r, order);\n    if(order == 2) cout << \" \" << now->key; // postorder\n}\n\nnode *find(int k) {\n    node *x = root;\n    while(x != NIL && x->key != k) {\n        x = x->key > k ? x->l : x->r;\n    }\n    return x;\n}\n\nvoid print() {\n    traverse(root, 1);\n    cout << endl;\n    traverse(root, 0);\n    cout << endl;\n}\n\nnode *next(node *k) {\n    node *x;\n    if(k->r != NIL) {\n        x = k->r;\n        while(x->l != NIL)\n            x = x->l;\n        return x;\n    } else {\n        cout << \"error\";\n        return NIL; // error..\n    }\n}\n\nnode *dele(node *t, int key);\nnode *_dele(node *t, int key) {\n    if(t->l == NIL && t->r == NIL)\n        return NIL;\n    else if(t->l == NIL)\n        t = leftRotate(t);\n    else if(t->r == NIL)\n        t = rightRotate(t);\n    else {\n        if(t->l->pri > t->r->pri)\n            t = rightRotate(t);\n        else\n            t = leftRotate(t);\n    }\n    return dele(t, key);\n}\n\nnode *dele(node *t, int key) {\n    if(t == NIL) return NIL;\n\n    if(key < t->key)\n        t->l = dele(t->l, key);\n    else if(key > t->key)\n        t->r = dele(t->r, key);\n    else\n        return _dele(t, key);\n    return t;\n}\n\nint main() {\n    int n, k, p;\n    string o;\n    cin >> n;\n    node *a;\n\n    rep(i, n) {\n        cin >> o;\n        if(o == \"insert\") {\n            cin >> k >> p;\n            root = insert(root, k, p);\n        } else if(o == \"find\") {\n            cin >> k;\n            a = find(k);\n            cout << (a != NIL ? \"yes\\n\" : \"no\\n\");\n        } else if(o == \"print\") {\n            print();\n        } else if(o == \"delete\") {\n            cin >> k;\n            root = dele(root, k);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <string>\nusing namespace std;\nstruct node{\n    int key;\n    int priority;\n    struct node *parent;\n    struct node *left;\n    struct node *right;\n};\ntypedef struct node * Node;\n#define NIL NULL\n\nNode root;\nNode removeNode(Node t, int key);\nNode deleteNode(Node t, int key);\n\nNode rightRotate(Node t){\n    Node l = t->left;\n    t->left = l->right;\n    l->right = t;\n    \n    return l;\n}\n\nNode leftRotate(Node t){\n    Node r = t->right;\n    t->right = r->left;\n    r->left = t;\n    \n    return r;\n}\n\nNode insertNode(Node t, int key, int priority){\n    if(t == NIL){\n        Node n = (node *)malloc(sizeof(struct node));\n        n->key = key;\n        n->priority = priority;\n        n->left = NIL;\n        n->right = NIL;\n        return n;\n    }\n    if(t->key == key) return t;\n    \n    if(t->key > key){\n        t->left = insertNode(t->left, key, priority);\n        if(t->priority < t->left->priority) t = rightRotate(t); \n    }\n    else{\n        t->right = insertNode(t->right, key, priority);\n        if(t->priority < t->right->priority) t = leftRotate(t);\n    }\n    \n    return t;\n}\n\nNode findNode(Node tree, int key){\n    while(tree != NIL){\n        if(tree-> key == key) return tree;\n        else if(tree->key >= key) tree = tree->left;\n        else tree = tree->right;\n    }\n    \n    return tree;\n}\n\nNode treeMinimum(Node x){\n    while(x->left != NIL) x = x->left;\n    \n    return x;\n}\n\nNode treeSuccessor(Node x){\n    if(x->right != NIL) return treeMinimum(x->right);\n    \n    Node y = x->parent;\n    while(y != NIL && x == y->right){\n        x = y;\n        y = y->parent;\n    }\n    return y;\n}\n\nNode deleteNode(Node t, int key){\n    if(t == NIL) return NIL;\n    \n    if(key < t->key) t->left = deleteNode(t->left, key);\n    else if(key > t->key) t->right = deleteNode(t->right, key);\n    else return removeNode(t, key);\n    \n    return t;\n}\n\nNode removeNode(Node t, int key){\n    if(t->left == NIL && t->right == NIL){\n        return NIL;\n    }\n    else if(t->left == NIL) t = leftRotate(t);\n    else if(t->right == NIL) t = rightRotate(t);\n    else{\n        if(t->left->priority > t->right->priority) t = rightRotate(t);\n        else t = leftRotate(t);\n    }\n    \n    return deleteNode(t, key);\n}\n\nvoid inorederNode(Node tree){\n    if(tree->left != NIL) inorederNode(tree->left);\n    cout << \" \" << tree->key;\n    if(tree->right != NIL) inorederNode(tree->right);\n}\n\nvoid preorederNode(Node tree){\n    cout << \" \" << tree->key;\n    if(tree->left != NIL) preorederNode(tree->left);\n    if(tree->right != NIL) preorederNode(tree->right);\n}\n\nint main(void){\n    int n, key, priority;\n    string command;\n    Node t;\n    \n    cin >> n;\n    for(int i = 0; i < n; i++){\n        cin >> command;\n        \n        if(command[0] == 'p'){\n            inorederNode(root);\n            cout << endl;\n            preorederNode(root);\n            cout << endl;\n        }\n        else if(command[0] == 'i'){\n            cin >> key >> priority;\n            root = insertNode(root, key, priority);\n        }\n        else if(command[0] == 'f'){\n            cin >> key;\n            t = findNode(root, key);\n            if(t != NIL) cout << \"yes\" << endl;\n            else cout << \"no\" << endl;\n        }\n        else if(command[0] == 'd'){\n            cin >> key;\n            root = deleteNode(root, key);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n\nusing namespace std;\n\nclass Node {\npublic:\n    Node(int key, int priority) \n        : key_(key), priority_(priority), leftChild_(nullptr), rightChild_(nullptr) {}\n\n    static Node* rightRotate(Node* t) {\n        Node* s = t->leftChild_;\n        t->leftChild_ = s->rightChild_;\n        s->rightChild_ = t;\n        return s;\n    }\n    static Node* leftRotate(Node* t) {\n        Node* s = t->rightChild_;\n        t->rightChild_ = s->leftChild_;\n        s->leftChild_ = t;\n        return s;\n    }\n    static Node* insert(Node* t, int key, int priority) {\n        if (t == nullptr) {\n            return new Node(key, priority); // 葉に到達したら新しい節点を生成して返す\n        }\n        if (key == t->key_) {\n            return t;   // 重複したkeyは無視\n        }\n        if (key < t->key_) {    // 左の子へ移動\n            t->leftChild_ = insert(t->leftChild_, key, priority);   // 左の子へのポインタを更新\n            if (t->priority_ < t->leftChild_->priority_) {  // 左の子の方が優先度が高い場合右回転\n                t = rightRotate(t);\n            }\n        }\n        else {  // 右の子へ移動\n            t->rightChild_ = insert(t->rightChild_, key, priority); // 右の子へのポインタを更新\n            if (t->priority_ < t->rightChild_->priority_) { // 右の子の方が優先度が高い場合左回転\n                t = leftRotate(t);\n            }\n        }\n        return t;\n    }\n    static Node* erase_(Node* t, int key) { // 葉の場合\n        if ((t->leftChild_ == nullptr) && (t->rightChild_ == nullptr)) {\n            return nullptr;\n        }\n        else if (t->leftChild_ == nullptr) {    // 右の子のみを持つ場合左回転\n            t = leftRotate(t);\n        }\n        else if (t->rightChild_ == nullptr) {   // 左の子のみを持つ場合右回転\n            t = rightRotate(t);\n        }\n        else {  // 左の子と右の子を両方持つ場合\n            if (t->leftChild_->priority_ > t->rightChild_->priority_) {\n                t = rightRotate(t);\n            }\n            else {\n                t = leftRotate(t);\n            }\n        }\n        return erase(t, key);\n    }\n    static Node* erase(Node* t, int key) {\n        if (t == nullptr) {\n            return nullptr;\n        }\n        if (key < t->key_) {\n            t->leftChild_ = erase(t->leftChild_, key);\n        }\n        else if (key > t->key_) {\n            t->rightChild_ = erase(t->rightChild_, key);\n        }\n        else {\n            return erase_(t, key);\n        }\n        return t;\n    }\n    bool find(int key) {\n        Node* x = this;\n        while (x != nullptr) {\n            if (key == x->key_) {\n                return true;\n            }\n            else if (key < x->key_) {\n                x = x->leftChild_;  // 左の子へ移動\n            }\n            else {\n                x = x->rightChild_; // 右の子へ移動\n            }\n        }\n        return false;\n    }\n    void printInorder() {\n        if (leftChild_ != nullptr) {\n            leftChild_->printInorder();\n        }\n        cout << \" \" << key_;\n        if (rightChild_ != nullptr) {\n            rightChild_->printInorder();\n        }\n    }\n    void printPreorder() {\n        cout << \" \" << key_;\n        if (leftChild_ != nullptr) {\n            leftChild_->printPreorder();\n        }\n        if (rightChild_ != nullptr) {\n            rightChild_->printPreorder();\n        }\n    }\nprivate:\n    int key_;\n    int priority_;\n    Node* leftChild_;\n    Node* rightChild_;\n};\n\nclass Tree {\npublic:\n    Tree() : root_(nullptr) {}\n    void insert(int key, int priority) {\n        root_ = Node::insert(root_, key, priority);\n    }\n    bool find(int key) {\n        if (root_ == nullptr) {\n            return false;\n        }\n        return root_->find(key);\n    }\n    void erase(int key) {\n        root_ = Node::erase(root_, key);\n    }\n    void print() {\n        if (root_ == nullptr) {\n            return;\n        }\n        root_->printInorder();\n        cout << endl;\n        root_->printPreorder();\n        cout << endl;\n    }\nprivate:\n    Node* root_;\n};\n\nint main()\n{\n    int n;\n    cin >> n;\n    string operation;\n    Tree tree;\n    for (int i = 0; i < n; ++i) {\n        cin >> operation;\n        if (operation == \"insert\") {\n            int k, p;\n            cin >> k >> p;\n            tree.insert(k, p);\n        }\n        else if (operation == \"find\") {\n            int k;\n            cin >> k;\n            if (tree.find(k)) {\n                cout << \"yes\" << endl;\n            }\n            else {\n                cout << \"no\" << endl;\n            }\n        }\n        else if (operation == \"delete\") {\n            int k;\n            cin >> k;\n            tree.erase(k);\n        }\n        else {\n            tree.print();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nclass node\n{\npublic:\n    int key,p;\n    node *L,*R;\n    node(int K=0,int P=0)\n    {\n        key=K;p=P;\n        L=R=NULL;\n    }\n};\n\nnode *root=NULL;\n\nnode* RR(node *t)\n{\n    node *s=t->L;\n    t->L=s->R;\n    s->R=t;\n    return s;\n}\n\nnode* LR(node *t)\n{\n    node *s=t->R;\n    t->R=s->L;\n    s->L=t;\n    return s;\n}\n\nnode* Insert(node *t,int K,int P)\n{\n    if(t==NULL)\n    {\n        node *p=new node(K,P);\n        return p;\n    }else if(K==t->key)\n    {\n        return t;\n    }\n\n    if(K<t->key)\n    {\n        t->L=Insert(t->L,K,P);\n        if(t->p<t->L->p)\n        {\n            t=RR(t);\n        }\n    }else\n    {\n        t->R=Insert(t->R,K,P);\n        if(t->p<t->R->p)\n        {\n            t=LR(t);\n        }\n    }\n\n    return t;\n}\n\nnode* _Delete(node *,int);\nnode* Delete(node *t,int K)\n{\n    if(t==NULL)\n    {\n        return NULL;\n    }else if(K<t->key)\n    {\n        t->L=Delete(t->L,K);\n    }else if(K>t->key)\n    {\n        t->R=Delete(t->R,K);\n    }else\n    {\n        return _Delete(t,K);\n    }\n    return t;\n}\n\nnode* _Delete(node *t,int K)\n{\n    if(t->L==NULL&&t->R==NULL)\n    {\n        return NULL;\n    }else if(t->L==NULL)\n    {\n        t=LR(t);\n    }else if(t->R==NULL)\n    {\n        t=RR(t);\n    }else\n    {\n        if(t->L->p>t->R->p)\n        {\n            t=RR(t);\n        }else\n        {\n            t=LR(t);\n        }\n    }\n    return Delete(t,K);\n}\n\nvoid pre(node *t)\n{\n    if(t==NULL)\n    {\n        return;\n    }\n    printf(\" %d\",t->key);\n    pre(t->L);\n    pre(t->R);\n}\n\nvoid in(node *t)\n{\n    if(t==NULL)\n    {\n        return;\n    }\n    in(t->L);\n    printf(\" %d\",t->key);\n    in(t->R);\n}\n\nnode* Find(node *t,int K)\n{\n    if(t==NULL)\n    {\n        return NULL;\n    }else if(K<t->key)\n    {\n        return Find(t->L,K);\n    }else if(K>t->key)\n    {\n        return Find(t->R,K);\n    }else\n    {\n        return t;\n    }\n}\n\nvoid ins()\n{\n    int a,b;\n    cin>>a>>b;\n    root=Insert(root,a,b);\n}\n\nvoid fnd()\n{\n    int a;\n    cin>>a;\n    if(Find(root,a))\n    {\n        cout<<\"yes\"<<endl;\n    }else\n    {\n        cout<<\"no\"<<endl;\n    }\n}\n\nvoid del()\n{\n    int a;\n    cin>>a;\n    root=Delete(root,a);\n}\n\nvoid print()\n{\n    in(root);cout<<endl;\n    pre(root);cout<<endl;\n}\n\nint main()\n{\n    int n;\n\n    cin>>n;\n\n    map<string,int> mp;\n    mp[\"insert\"]=1;\n    mp[\"find\"]=2;\n    mp[\"delete\"]=3;\n\n    while(n--)\n    {\n        string s;\n        cin>>s;\n\n        switch(mp[s])\n        {\n            case 1:ins();break;\n            case 2:fnd();break;\n            case 3:del();break;\n            default:print();\n        }\n    }\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<string>\n#include<iostream>\nusing namespace std;\n\nstruct Node{\n  int key,priority;\n  Node *right,*left;\n};\n\nNode *root, *NIL;\n\nNode * find(Node *u,int k){\n  while(u!=NIL && k!=u->key){\n    if(k<u->key) u = u->left;\n    else u=u->right;\n  }\n  return u;\n}\n\nvoid inorder(Node *u){\n  if(u==NIL) return;\n  inorder(u->left);\n  printf(\" %d\",u->key);\n  inorder(u->right);\n}\n\nvoid preorder(Node *u){\n  if(u==NIL) return;\n  printf(\" %d\",u->key);\n  preorder(u->left);\n  preorder(u->right);\n}\n\nNode *rightRotate(Node *u){\n  Node *k=u->left;\n  u->left=k->right;\n  k->right=u;\n  return k;\n}\n\nNode *leftRotate(Node *u){\n  Node *k=u->right;\n  u->right=k->left;\n  k->left=u;\n  return k;\n}\n\nNode* insert(Node *t,int key,int priority){\n  Node *new;\n\t\n  if(t==NIL)\n    return new(key,priority);\n  if (t->key==key)\n    return t;\n\t\n  if(key < t->key){\n    t->left=insert(t->left,key,priority);\n    if(t->priority < t->left->priority)\n      t=rightRotate(t);\n  }\n  else {\n    t->right=insert(t->right,key,priority);\n    if(t->priority < t->right->priority)\n      t=leftRotate(t);\n  }\n\t\n  return t;\n}\n\n\nNode * Delete(Node *t,int key){\n  if(t==NIL)\n    return NIL;\n\t\t\n  if(key < t->key)\n    t->left=Delete(t->left,key);\n\t\t\n  else if(key > t->key)\n    t->right=Delete(t->right,key);\n\t\t\n  else return _delete(t,key);\n\t\n  return t;\n}\n\nNode * _delete(Node *t,int key){\n  if(t->left==NIL && t->right==NIL)\n    return NIL;\n  else if(t->left==NIL)\n    t=leftRotate(t);\n  else if(t->right==NIL)\n    t=rightRotate(t);\n  else {\n    if(t->left->priority > t->right->priority)\n      t=rightRotate(t);\n    else\n      t=leftRotate(t);\n  }\n  return Delete(t,key);\n}\n\nint main(){\n  int n,i,x;\n  string com;\n\n  scanf(\"%d\",&n);\n\n  for(i = 0;i < n; i++){\n    cin >> com;\n\n    if(com[0] == 'f'){\n      scanf(\"%d\",&x);\n      Node *t = find(root,x);\n      if(t!=NIL) printf(\"yes\\n\");\n      else printf(\"no\\n\");\n    }else if(com == \"insert\"){\n      scanf(\"%d\",&x);\n      insert(x);\n    }else if(com == \"print\"){\n      inorder(root);\n      printf(\"\\n\");\n      preorder(root);\n      printf(\"\\n\");\n    }else if(com == \"delete\"){\n      scanf(\"%d\",&x);\n      Delete(root,x);\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define STOPIT\n#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_a_genius = 0; ngtkana_is_a_genius < int(n); ngtkana_is_a_genius++)\n#define rep(i, begin, end) for (int i = int(begin); (i) < int(end); i++)\n#define all(v) v.begin(), v.end()\n#define rand(l, r) std::uniform_int_distribution<>(l, r)(mt)\nusing lint = long long;\nauto mt = std::mt19937_64(std::random_device{}());\nauto cmn = [](auto& a, auto b){ if (a > b) {a = b; return true;} return false; };\nauto cmx = [](auto& a, auto b){ if (a < b) {a = b; return true;} return false; };\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head; debug_impl(tail...); }\n#ifndef STOPIT\n#define debug(...)\\\n  do {\\\n    std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n    debug_impl(__VA_ARGS__);\\\n    std::cerr << std::noboolalpha;\\\n  } while (false)\n#else\n#define debug(...) {};\n#endif\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr>\nstd::istream& operator>> (std::istream& is, Container& v)\n  { for (auto & x : v) { is >> x; } return is; }\n\ntemplate < typename Container, typename Value = typename Container::value_type, std::enable_if_t<!std::is_same< Container, std::string >::value, std::nullptr_t> = nullptr >\nstd::ostream& operator<< (std::ostream& os, Container const& v) {\n os << \"{\";\n  for (auto it = v.begin(); it != v.end(); it++)\n    {os << (it != v.begin() ? \",\" : \"\") << *it;}\n  return os << \"}\";\n}\n\nunsigned long xor128() {\n  static unsigned long x=123456789, y=362436069, z=521288629, w=88675123;\n  unsigned long t=(x^(x<<11));\n  x=y; y=z; z=w;\n  return ( w=(w^(w>>19))^(t^(t>>8)) );\n}\n\nusing key_type = std::int32_t;\nusing result_type = std::int32_t;\nusing priority_type = std::int32_t;\n\nstruct node_type {\n  key_type key;\n  priority_type p;\n  node_type * ch[2];\n  node_type(key_type key, priority_type p)\n    : key(key), p(p)\n    {\n      ch[0] = ch[1] = nullptr;\n    }\n};\n\nvoid validate(node_type * t) {\n  if (!t) return;\n  if (t->ch[0]) {\n    assert(t->ch[0]->key < t->key);\n    assert(t->ch[0]->p < t->p);\n  }\n  if (t->ch[1]) {\n    assert(t->ch[1]->key > t->key);\n    assert(t->ch[1]->p < t->p);\n  }\n}\n\nnode_type * top = nullptr;\n\nnode_type * rotate(node_type * t, bool b) {\n  node_type * s = t->ch[1-b];\n  t->ch[1-b] = s->ch[b];\n  s->ch[b] = t;\n  return s;\n}\n\nbool find(node_type * t, key_type key) {\n  return t && (key == t->key || find(t->ch[!(key < t->key)], key));\n}\n\nnode_type * insert(node_type * t, key_type key, priority_type p) {\n  validate(t);\n  if (!t) return ::new node_type(key, p);\n  else if (key == t->key) return t;\n  bool b = !(key < t->key);\n  t->ch[b] = insert(t->ch[b], key, p);\n  if (t->p < t->ch[b]->p) t = rotate(t, 1-b);\n  return t;\n}\n\nnode_type * erase(node_type * t, key_type key) {\n  if (!t) return nullptr;\n  if (key == t->key) {\n    if (!t->ch[0] && !t->ch[1]) {\n      delete t;\n      return nullptr;\n    }\n    t = rotate(t, !t->ch[1] || (t->ch[0] && t->ch[0]->p > t->ch[1]->p));\n    t = erase(t, key);\n  } else {\n    bool b = !(key < t->key);\n    t->ch[b] = erase(t->ch[b], key);\n  }\n  return t;\n}\n\nvoid print() {\n  std::vector< key_type > mid;\n  std::vector< key_type > pre;\n  auto dfs = [&] (auto&& dfs, node_type * t) -> void {\n    if (!t) return;\n    pre.emplace_back(t->key);\n    dfs(dfs, t->ch[0]);\n    mid.emplace_back(t->key);\n    dfs(dfs, t->ch[1]);\n  };\n  dfs(dfs, top);\n  for (auto x : mid) std::cout << \" \" << x;\n  std::cout << std::endl;\n  for (auto x : pre) std::cout << \" \" << x;\n  std::cout << std::endl;\n}\n\nauto collect() {\n  std::vector< key_type > mid;\n  auto dfs = [&] (auto&& dfs, node_type * t) -> void {\n    validate(t);\n    if (!t) return;\n    dfs(dfs, t->ch[0]);\n    mid.emplace_back(t->key);\n    dfs(dfs, t->ch[1]);\n  };\n  dfs(dfs, top);\n  return mid;\n}\n\nint main() {\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int q; std::cin >> q;\n  loop(q) {\n    std::string s; std::cin >> s;\n    debug(s);\n    switch(s.front()) {\n      case 'i': {\n        int x, p; std::cin >> x >> p;\n        debug(s,x,p);\n        top = insert(top, x, p);\n        break;\n      }\n      case 'f': {\n        int x; std::cin >> x;\n        bool ans = find(top, x);\n        std::cout << (ans ? \"yes\" : \"no\") << std::endl;\n        break;\n      }\n      case 'd': {\n        int x; std::cin >> x;\n        top = erase(top, x);\n        break;\n      }\n      case 'p': {\n        print();\n        break;\n      }\n    }\n    debug(collect());\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <list>\n#include <map>\n#include <array>\n#include <memory>\n#include <string>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <unordered_map>\n#include <stdexcept>\n\n\nusing std::string;\nusing std::vector;\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// util\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nstd::vector<std::string> split(const std::string& input, char delimiter)\n{\n    std::istringstream stream(input);\n\n    std::string field;\n    std::vector<std::string> result;\n    while (std::getline(stream, field, delimiter)) {\n        result.push_back(field);\n    }\n    return result;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// user func\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvoid printList(const vector<int>& list) {\n    // print\n    for(int i = 0; i < list.size(); i++){\n        printf(\" %d\", list[i]);\n    }\n    printf(\"\\n\");\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// logic\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nclass Node;\n\nclass Node{\npublic:\n    Node(int value, int priority)\n        :value(value)\n        ,priority(priority)\n    {\n    }\n    void Value(int value) {\n        this->value = value;\n    }\n    int Value(){\n        return this->value;\n    }\n    int Priority(){\n        return this->priority;\n    }\n    void Priority(int priority){\n        this->priority = priority;\n    }\n    std::shared_ptr<Node> Left(){\n        return this->left;\n    }\n    void Left(std::shared_ptr<Node> left){\n        this->left = left;\n        if (left) this->left->Parent(this);\n    }\n    std::shared_ptr<Node> Right(){\n        return this->right;\n    }\n    void Right(std::shared_ptr<Node> right){\n        this->right = right;\n        if (right) this->right->Parent(this);\n    }\n    bool HasLeft(){\n        return this->left ? true : false;\n    }\n    bool HasRight(){\n        return this->right ? true : false;\n    }\n    Node* Parent(){\n        return this->parent;\n    }\n    void Parent(Node* parent){\n        this->parent = parent;\n    }\n    int CountChild(){\n        int count = 0;\n        if (this->HasLeft()) count++;\n        if (this->HasRight()) count++;\n        return count;\n    }\n\n    std::shared_ptr<Node> FirstChild() {\n        if(this->HasLeft()) return this->Left();\n        if(this->HasRight()) return this->Right();\n        return nullptr;\n    }\n\n    bool IsEqualLeft(int val){\n        if (!this->HasLeft()) return false;\n        return this->Left()->Value() == val;\n    }\n\nprivate:\n    int value;\n    int priority;\n    std::shared_ptr<Node> left = nullptr ;\n    std::shared_ptr<Node> right = nullptr;\n    Node* parent = nullptr;\n};\n\nusing NodePtr = std::shared_ptr<Node>;\n\nclass BinarySearchTree{\npublic:\n    void Insert(int value, int priority){\n        if(!this->root){\n            root = std::make_shared<Node>(value, priority);\n            return;\n        }\n        InsertProc(this->root, value, priority);\n    }\n    \n    bool Find(int value){\n        if(!this->root) return false;\n        return this->FindProc(this->root, value);\n    }\n    void Delete(int value){\n        this->FindAndDelete(this->root, value);\n    }\n    vector<int> Preorder(){\n        vector<int> result;\n        this->PreorderProc(this->root, result);\n        return result;\n    }\n    vector<int> Inorder(){\n        vector<int> result;\n        this->InorderProc(this->root, result);\n        return result;\n    }\n\nprivate:\n    NodePtr root = nullptr;\n\n    NodePtr InsertProc(NodePtr node, int value, int priority){\n        if (!node) return std::make_shared<Node>(value, priority);\n        if (value == node->Value()) return node;\n        \n        if (value < node->Value()){\n            NodePtr t = InsertProc(node->Left(), value, priority);\n            node->Left(t);\n            if (node->Priority() < node->Left()->Priority()){\n                node = RightLotate(node);\n            }\n        } else {\n            NodePtr t = InsertProc(node->Right(), value, priority);\n            node->Right(t);\n            if (node->Priority() < node->Right()->Priority()){\n                node = LeftLotate(node);\n            }\n        }\n        return node;\n    }\n\n    NodePtr RightLotate(NodePtr node){\n        // printf(\"RL\\n\");\n        auto s = node->Left();\n        node->Left(s->Right());\n        // if (s) {\n            s->Parent(node->Parent());\n            s->Right(node);\n        // }\n        if (!s->Parent()) this->root = s;\n        return s;\n    }\n\n    NodePtr LeftLotate(NodePtr node){\n        // printf(\"LL\\n\");\n        auto s = node->Right();\n        node->Right(s->Left());\n        // if (s) {\n            s->Parent(node->Parent());\n            s->Left(node);\n        // }\n        if (!s->Parent()) this->root = s;\n        return s;\n    }\n\n\n    void PreorderProc(NodePtr current, vector<int>& list){\n        list.push_back(current->Value());\n        if (current->HasLeft()) PreorderProc(current->Left(), list);\n        if (current->HasRight()) PreorderProc(current->Right(), list);\n    }\n    \n    void InorderProc(NodePtr current, vector<int>& list){\n        if (current->HasLeft()){\n            InorderProc(current->Left(), list);\n        }\n        list.push_back(current->Value());\n        if (current->HasRight()) {\n            InorderProc(current->Right(), list);\n        }\n    }\n\n    bool FindProc(NodePtr current, int value){\n        if (current->Value() == value){\n            return true;\n        } else if (value < current->Value()) {\n            if(!current->HasLeft()) return false;\n            return this->FindProc(current->Left(), value);\n        } else {\n        // if (current->Value() < value) {\n            if(!current->HasRight()) return false;\n            return this->FindProc(current->Right(), value);\n        }\n    }\n\n    NodePtr FindNode(NodePtr current, int value){\n        if (current->Value() == value){\n            return current;\n        } else if (value < current->Value()) {\n            if(!current->HasLeft()) return nullptr;\n            return this->FindNode(current->Left(), value);\n        } else {\n        // if (current->Value() < value) {\n            if(!current->HasRight()) return nullptr;\n            return this->FindNode(current->Right(), value);\n        }\n    }\n\n    // inorder s next\n    NodePtr FindNext(NodePtr node){\n        if (node->HasLeft()) return FindNext(node->Left());\n        return node;\n    }\n\n    void dump(NodePtr node){\n        printf(\"%d %d(%d, %d)\\n\", \n            node->Value(),\n            node->Parent() ? node->Parent()->Value() : - 1, \n            node->Left() ? node->Left()->Value() : -1,\n            node->Right() ? node->Right()->Value() : -1);\n        if (node->HasLeft()) dump(node->Left());\n        if (node->HasRight()) dump(node->Right());\n    }\n\n    NodePtr FindAndDelete(NodePtr node, int value) {\n        if (!node) return nullptr;\n        if (value < node->Value()) {\n            node->Left(FindAndDelete(node->Left(), value));\n        } else if( node->Value() < value ) {\n            node->Right(FindAndDelete(node->Right(), value));\n        } else {\n            return DeleteProc(node, value);\n        }\n        return node;\n    }\n\n    NodePtr DeleteProc(NodePtr current, int value){\n        // dump(current);\n        // remove current\n        if (current->CountChild() == 0) {\n            if (current->Parent()->IsEqualLeft(current->Value())){\n                current->Parent()->Left(nullptr);\n            }else{\n                current->Parent()->Right(nullptr);\n            }\n            return nullptr;\n        } else if (current->CountChild() == 1) {\n            if (current->Right()) {\n                current = LeftLotate(current);\n            } else {\n                current = RightLotate(current);\n            }\n        } else {\n            if (current->Right()->Priority() <= current->Left()->Priority()) {\n                current = RightLotate(current);\n            } else {\n                current = LeftLotate(current);\n            }\n        }\n        return FindAndDelete(current, value);\n    }\n};\n\nvoid solve() {\n    // Treap\n    int n;\n    scanf(\"%d\", &n);\n    BinarySearchTree tree;\n    for(int i = 0; i < n; i++){\n        char buffer[127];\n        scanf(\"%s\", buffer);\n        string command(buffer);\n        if(command == \"insert\"){\n            int v;\n            int priority;\n            scanf(\" %d %d\", &v, &priority);\n            tree.Insert(v, priority);\n        } else if(command == \"find\" ){\n            int v;\n            scanf(\" %d\", &v);\n            printf(\"%s\\n\", tree.Find(v) ? \"yes\" : \"no\");\n        } else if(command == \"delete\") {\n            int v;\n            scanf(\" %d\", &v);\n            tree.Delete(v);\n        \n        } else if(command == \"print\"){\n            auto in = tree.Inorder();\n            printList(in);\n            auto pre = tree.Preorder();\n            printList(pre);\n        }\n\n    }\n        \n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// main\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nint main() {\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nstruct Node\n{\n    int key;\n    int priority;\n    Node *left;\n    Node *right;\n};\nNode *root, *NIL;\n\nNode* rightRotate(Node *t)\n{\n    Node *s = t -> left;\n    t -> left = s -> right;\n    s -> right = t;\n    if (root == t) root = s;\n    return s;\n}\n\nNode* leftRotate(Node *t)\n{\n    Node *s = t -> right;\n    t -> right = s -> left;\n    s -> left = t;\n    if (root == t) root = s;\n    return s;\n}\n\nNode* insert(Node *t, int key, int priority)\n{\n    if (t == NIL)\n    {\n        t = (Node*)malloc(sizeof(Node));\n        t -> key = key;\n        t -> priority = priority;\n        t -> left = NIL;\n        t -> right = NIL;\n        return t;\n    }\n    if (t -> key == key)\n    {\n        return t;\n    }\n    if (key < t -> key)\n    {\n        t -> left = insert(t -> left, key, priority);\n        if (t -> priority < t -> left -> priority)\n        {\n            t = rightRotate(t);\n        }\n    }\n    else\n    {\n        t -> right = insert(t -> right, key, priority);\n        if (t -> priority < t -> right -> priority)\n        {\n            t = leftRotate(t);\n        }\n    }\n    return t;\n}\n\nNode* _delete(Node *t, int key);\n\nNode* deleteNode(Node *t, int key)\n{\n    if (t == NIL)\n    {\n        return NIL;\n    }\n    if (key < t -> key)\n    {\n        t -> left = deleteNode(t -> left, key);\n    }\n    else if (key > t -> key)\n    {\n        t -> right = deleteNode(t -> right, key);\n    }\n    else\n    {\n        return _delete(t, key);\n    }\n    return t;\n}\n\nNode* _delete(Node *t, int key)\n{\n    if (t -> left == NIL && t -> right == NIL)\n    {\n        return NIL;\n    }\n    else if (t -> left == NIL)\n    {\n        t = leftRotate(t);\n    }\n    else if (t -> right == NIL)\n    {\n        t = rightRotate(t);\n    }\n    else\n    {\n        if (t -> left -> priority > t -> right -> priority)\n        {\n            t = rightRotate(t);\n        }\n        else\n        {\n            t = leftRotate(t);\n        }\n    }\n    return deleteNode(t, key);\n}\n\nNode* search(Node* t, int key)\n{\n    if (t == NIL)\n    {\n        return NIL;\n    }\n    if (t -> key > key)\n    {\n        return search(t -> left, key);\n    }\n    else if (t -> key < key)\n    {\n        return search(t -> right, key);\n    }\n    return t;\n}\n\nvoid inParse(Node *t)\n{\n    if (t == NIL)\n    {\n        return;\n    }\n    inParse(t -> left);\n    cout << \" \" << t -> key;\n    inParse(t -> right);\n}\n\nvoid preParse(Node *t)\n{\n    if (t == NIL)\n    {\n        return;\n    }\n    cout << \" \" << t -> key;\n    preParse(t -> left);\n    preParse(t -> right);\n}\n\nvoid print(Node *t)\n{\n    inParse(t);\n    cout << endl;\n    preParse(t);\n    cout << endl;\n}\n\nint main()\n{\n    int m, key, pri;\n    string cmd;\n    cin >> m;\n    for (int i = 0; i != m; ++i)\n    {\n        cin >> cmd;\n        if (cmd == \"print\")\n        {\n            print(root);\n        }\n        else if (cmd == \"insert\")\n        {\n            cin >> key >> pri;\n            root = insert(root, key, pri);\n        }\n        else if (cmd == \"delete\")\n        {\n            cin >> key;\n            deleteNode(root, key);\n        }\n        else if (cmd == \"find\")\n        {\n            cin >> key;\n            if (search(root, key) != NIL)\n            {\n                cout << \"yes\" << endl;\n            }\n            else\n            {\n                cout << \"no\" << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct Node{\n  Node *right, *left;\n  int key, priority;\n};\n\nNode* node(int k, int p){\n  Node *newNode = (Node *)malloc(sizeof(Node));\n  newNode->right = NULL;\n  newNode->left = NULL;\n  newNode->key = k;\n  newNode->priority = p;\n  return newNode;\n}\n\nNode* rightRotate(Node *t){\n  Node *s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s; //the new root of subtree\n}\n\nNode* leftRotate(Node *t){\n  Node *s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s; //the new root of subtree\n}\n\nNode* insertT(Node *t, int k, int p){\n  //when you reach the leaf\n  if(t == NULL) return node(k, p);  //create a new Node\n  //ignore duplicated keys\n  if(k == t->key) return t;\n\n  if(k < t->key){  //move to the left child\n    //update the pointer to the left child\n    t->left = insertT(t->left, k, p);\n    //if the left child has higher priority\n    if(t->priority < t->left->priority) t = rightRotate(t);\n  }else{//move to the right child\n    //update the pointer t the right child\n    t->right = insertT(t->right, k, p);\n    //if the right child has higher priority\n    if(t->priority < t->right->priority) t = leftRotate(t);\n  }\n\n  return t;\n}\n\nNode* find(Node* t, int k){\n  while(t != NULL && k != t->key){//leafじゃない && みつかっていない\n    if(k < t->key) t = t->left;\n    else t = t->right;\n  }\n  return t;\n}\n\n Node* deleteNode(Node *t, int k){\n  if(t == NULL) return NULL;\n  //if t is the targer node\n  if(k == t->key){\n    //if t is a leaf\n    if(t->left == NULL && t->right == NULL) return NULL;\n    //if t has only the right child\n    else if(t->left == NULL) t = leftRotate(t);\n    //if t has only the left child\n    else if(t->right == NULL) t = rightRotate(t);\n    //if t has both the left and right child\n    else{\n      //pull up the child with higher priority\n      if(t->left->priority > t->right->priority) t = rightRotate(t);\n      else t = leftRotate(t);\n    }\n    return deleteNode(t, k);\n  }\n\n  //search the targer recursively\n  if(k < t->key) t->left = deleteNode(t->left, k);\n  else t->right = deleteNode(t->right, k);\n\n  return t;\n}\n\nvoid inorder(Node* t){\n  if(t == NULL) return;\n  inorder(t->left);\n  printf(\" %d\", t->key);\n  inorder(t->right);\n}\n\nvoid preorder(Node* t){\n  if(t == NULL) return;\n  printf(\" %d\", t->key);\n  preorder(t->left);\n  preorder(t->right);\n}\n\nvoid print(Node* t){\n  inorder(t);\n  printf(\"\\n\");\n  preorder(t);\n  printf(\"\\n\");\n}\n\nint main(){\n  int n, k, p;\n  string com;\n  Node *t;//root\n\n  cin >> n;\n  for(int i=0 ; i<n ; ++i){\n    cin >> com;\n    if(com == \"insert\"){\n      cin >> k >> p;\n      t = insertT(t, k, p);\n    }else if(com == \"delete\"){\n      cin >> k;\n      t = deleteNode(t, k);\n    }else if(com == \"print\"){\n      print(t);\n    }else if(com == \"find\"){\n      cin >> k;\n      Node* n = find(t, k);\n      if(n != NULL) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n \nusing namespace std;\n \nstruct Node {\n    int key, pri;\n    Node *left, *right;\n};\n \nNode *root, *NIL;\n \nNode* rightRotate(Node* t) {\n    Node* s = t->left;\n    t->left = s->right;\n    s->right = t;\n    if (t == root)\n      root = s;\n    return s;\n}\n \nNode* leftRotate(Node* t) {\n    Node* s = t->right;\n    t->right = s->left;\n    s->left = t;\n    if (t == root)\n      root = s;\n    return s;\n}\n \nvoid inorder(Node *t) {\n    if (t == NIL)\n        return;\n    inorder(t->left);\n    cout << \" \" << t->key;\n    inorder(t->right);\n}\n \nvoid preorder(Node *t) {\n    if (t == NIL)\n        return;\n    cout << \" \" << t->key;\n    preorder(t->left);\n    preorder(t->right);\n}\n \nvoid status(Node* t) {\n    cout << \"k:\" << t->key << endl;\n    cout << \"l:\" << t->left << endl;\n    cout << \"r:\" << t->right << endl;\n    cout << endl;\n}\n \nNode* insert(Node *t, int key, int pri) {\n    if (t == NIL) {\n        Node *u = new Node();\n        u->key = key;\n        u->pri = pri;\n        u->left = u->right = NIL;\n        return u;\n    }\n    if (key == t->key) {\n        return t;\n    }\n \n    if (key < t->key) {\n        t->left = insert(t->left, key, pri);\n        if (t->pri < t->left->pri)\n            t = rightRotate(t);\n    }\n    else{\n        t->right = insert(t->right, key, pri);\n        if (t->pri < t->right->pri)\n            t = leftRotate(t);\n    }\n \n    return t;\n}\n \nNode* find(Node* t, int key){\n    if(t == NIL)\n        return NIL;\n    if(key == t->key)\n        return t;\n \n    Node* u;\n    if (key < t->key) {\n        if((u = find(t->left, key)) != NIL)\n            return u;\n    }\n    else {\n        if((u = find(t->right, key)) != NIL)\n            return u;\n    }\n    return NIL;\n}\n \nNode* _delete(Node *t, int key);\n \nNode* nodeDelete(Node *t, int key){\n    if(t == NIL)\n        return NIL;\n    if(key < t->key)\n        t->left = nodeDelete(t->left, key);\n    else if(key > t->key)\n        t->right = nodeDelete(t->right, key);\n    else\n        return _delete(t, key);\n    return t;\n}\n \nNode* _delete(Node *t, int key){\n    if (t->left == NIL && t->right == NIL) {\n        return NIL;\n    }\n    else if(t->left == NIL){\n        t = leftRotate(t);\n    }\n    else if(t->right == NIL){\n        t = rightRotate(t);\n    }\n    else {\n        if(t->left->pri > t->right->pri){\n            t = rightRotate(t);\n        }\n        else {\n            t = leftRotate(t);\n        }\n    }\n    return nodeDelete(t, key);\n}\n \nint main() {\n    int m, k, p;\n    string s;\n \n    NIL = new Node();\n    NIL->left = NIL->right = NIL;\n    root = NIL;\n \n    cin >> m;\n    while (m--) {\n        cin >> s;\n        if (s == \"insert\") {\n            cin >> k >> p;\n            Node *t = insert(root, k, p);\n            if (root == NIL) {\n                root = t;\n            }\n        }\n        else if (s == \"find\") {\n            cin >> k;\n            cout << ((find(root, k) == NIL) ? \"no\" : \"yes\") << endl;\n        }\n        else if (s == \"delete\") {\n            cin >> k;\n            nodeDelete(root, k);\n        }\n        else if (s == \"print\") {\n            inorder(root);\n            cout << endl;\n            preorder(root);\n            cout << endl;\n        }\n    }\n \n}\n"
  },
  {
    "language": "C++",
    "code": "//============================================================================\n// Name        : BinarySearchTree.cpp\n// Author      : Ken\n// Version     :\n// Copyright   : Your copyright notice\n// Description : Hello World in C++, Ansi-style\n//============================================================================\n\n#include <iostream>\n#include <map>\nusing namespace std;\n\nclass Node{\npublic:\n\tint id;\n\tNode* p_parent;\n\tNode* p_left_child;\n\tNode* p_right_child;\n\tint priority;\n\n\tNode(): id(-1), p_parent(NULL), p_left_child(NULL), p_right_child(NULL), priority(0){};\n\tNode(const int n):id(n), p_parent(NULL), p_left_child(NULL), p_right_child(NULL), priority(0){}\n\tNode(const int n, const int priority):id(n), p_parent(NULL), p_left_child(NULL), p_right_child(NULL), priority(priority){}\n};\n\nclass BinarySearchTree{\npublic:\n\tmap<int, Node> node_map;\n\tint root_id;\n\n\tBinarySearchTree(): node_map(), root_id(){};\n\n\n\tvoid insert(int input, int priority){\n\t\tnode_map[input] = Node(input, priority); // THIS IS **PASS-BY-VALUE** !!!\n\t\tNode* y = NULL; //parent of x\n\n\n\t\tif(node_map.size()>=2){\n\t\t    Node* x = &node_map[root_id];\n\t\t    //cout << \"x->id: \" << x->id << \"\\n\";\n\n\t    \twhile(x != NULL){\n\t    \t\ty = x;\n\n\t\t    \tif(node_map[input].id < x->id){\n\t\t\t    \tx = x->p_left_child; // move to the left child\n\t    \t\t}else{\n\t\t    \t\tx = x->p_right_child; // move to the right child\n\t\t    \t}\n\t\t    }\n\t    \t//cout << \"end of while loop\\n\";\n\n\t    \t//if(x != NULL){\n\t    \t//    cout << \"x->id: \" << x->id;}\n\n\t    \t//if(y != NULL){\n\t\t\t//    cout << \", y->id: \" << y->id;}\n\n\t\t\t//cout << \", z->id: \" << node_map[z.id].id;\n\n\t\t\t//cout << \"\\n\";\n\n\t\t\tnode_map[input].p_parent = y;\n\t\t}\n\n\t\tif(y == NULL){ // T is empty\n\t\t\troot_id = node_map[input].id;\n\t\t}else if(input < y->id){\n\t\t\ty->p_left_child = &node_map[input];\n\t\t}else{\n\t\t\ty->p_right_child = &node_map[input];\n\t\t}\n\t}\n\n\tvoid printInorder(int node_id){\n\t\tNode& p_node = node_map[node_id];\n\n\t\tif(p_node.p_left_child != NULL){\n\t\t\t//cout << \"print left branch\\n\";\n\t\t    printInorder(p_node.p_left_child->id);\n\t\t}\n\n\t\tcout << \" \" << node_id;\n\n\t\tif(p_node.p_right_child != NULL){\n\t\t\t//cout << \"print right branch\\n\";\n\t\t\tprintInorder(p_node.p_right_child->id);\n\t\t}\n\t}\n\n\tvoid printInorderTree(){\n\t\tprintInorder(root_id);\n\t}\n\n\tvoid printPreorder(int node_id){\n\t\tNode& p_node = node_map[node_id];\n\t\tcout << \" \" << node_id;\n\n\t\tif(p_node.p_left_child != NULL){\n\t\t    printPreorder(p_node.p_left_child->id);\n\t\t}\n\n\t\tif(p_node.p_right_child != NULL){\n\t\t\tprintPreorder(p_node.p_right_child->id);\n\t\t}\n\t}\n\n\tvoid printPreorderTree(){\n\t\tprintPreorder(root_id);\n\t}\n\n\tvoid writeMap(){\n\t\tcout << \"root id: \" << root_id << \", root node: \" << node_map[root_id].id << \"\\n\";\n\n\t\tmap<int, Node>::iterator p;\n\t\tfor(p = node_map.begin(); p != node_map.end(); p++){\n\t\t\tcout << \"No:\" << p->first << \", id:\" << p->second.id << \", priority:\" << p->second.priority << \"\\n\";\n\t\t\tNode& p_node = p->second;\n\t\t\tif(p_node.p_parent != NULL){\n\t\t\t\tcout << \" parent: \" << p_node.p_parent->id;\n\t\t\t}\n\t\t\tif(p_node.p_left_child != NULL){\n\t\t\t\tcout << \" left_child: \" << p_node.p_left_child->id;\n\t\t\t}\n\t\t\tif(p_node.p_right_child != NULL){\n\t\t\t\tcout << \" right_child: \" << p_node.p_right_child->id;\n\t\t\t}\n\t\t\tcout << \"\\n\";\n\t\t}\n\t}\n\n\tbool find(int input){\n\t\tbool isFound = false;\n\t\tNode* x = &node_map[root_id];\n\t\twhile(x != NULL){\n\t\t\tif(x->id == input){\n\t\t\t\tisFound = true;\n\t\t\t\tbreak;\n\t\t\t}else if(x->id > input){\n\t\t\t\tx = x->p_left_child;\n\t\t\t}else{\n\t\t\t\tx = x->p_right_child;\n\t\t\t}\n\t\t}\n\n\t\treturn isFound;\n\t}\n\n\tvoid delete_node(int input){\n\t\tif(node_map.count(input)==0){\n\t\t\treturn;\n\t\t}\n\n\t\tNode& z = node_map[input];\n\t\tif(z.p_left_child == NULL and z.p_right_child == NULL){\n\t\t\tif(z.id == root_id){// z is root\n\t\t\t\troot_id = -1;\n\t\t\t}\n\n\t\t\tif(z.p_parent->id < z.id){ // z is right child of z's parent\n\t\t\t\tz.p_parent->p_right_child = NULL;\n\t\t\t}else{ // z is left child of z's parent\n\t\t\t\tz.p_parent->p_left_child = NULL;\n\t\t\t}\n\t\t\tnode_map.erase(input);\n\t\t}else if(z.p_left_child != NULL and z.p_right_child == NULL){\n\t\t\tif(z.id == root_id){\n\t\t\t\tz.p_left_child->p_parent = NULL;\n\t\t\t\troot_id = z.p_left_child->id;\n\t\t\t\tnode_map.erase(input);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tz.p_left_child->p_parent = z.p_parent;\n\t\t\tif(z.p_parent->id < z.id){ // z is right child of z's parent\n\t\t\t\tz.p_parent->p_right_child = z.p_left_child;\n\t\t\t}else{\n\t\t\t\tz.p_parent->p_left_child = z.p_left_child;\n\t\t\t}\n\t\t\tnode_map.erase(input);\n\t\t}else if(z.p_left_child == NULL and z.p_right_child != NULL){\n\t\t\tif(z.id == root_id){\n\t\t\t\tz.p_right_child->p_parent = NULL;\n\t\t\t\troot_id = z.p_right_child->id;\n\t\t\t\tnode_map.erase(input);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tz.p_right_child->p_parent = z.p_parent;\n\t\t\tif(z.p_parent->id < z.id){ // z is right child of z's parent\n\t\t\t\tz.p_parent->p_right_child = z.p_right_child;\n\t\t\t}else{\n\t\t\t\tz.p_parent->p_left_child = z.p_right_child;\n\t\t\t}\n\t\t\tnode_map.erase(input);\n\t\t}else{ // z has left and right child\n\t\t\tNode* x = z.p_right_child;\n\t\t\tNode* y = NULL; //x's parent\n\t\t\twhile(x != NULL){\n\t\t\t\ty = x;\n\t\t\t\tx = x->p_left_child;\n\t\t\t}\n\t\t\tint old_z_id = z.id;\n\n\t\t\tif(z.id == root_id){\n\t\t\t\troot_id = y->id;\n\t\t\t}\n\n\t\t\tif(y->p_left_child == NULL and y->p_right_child == NULL){\n\t\t\t\tif(y->id == y->p_parent->p_left_child->id){\n\t\t\t\t    y->p_parent->p_left_child = NULL;\n\t\t\t\t}else if(y->id == y->p_parent->p_right_child->id){\n\t\t\t\t\ty->p_parent->p_right_child = NULL;\n\t\t\t\t}\n\n\t\t\t}else if(y->p_left_child == NULL and y->p_right_child != NULL){\n\t\t\t\ty->p_right_child->p_parent = y->p_parent;\n\t\t\t\ty->p_parent->p_left_child = y->p_right_child;\n\t\t\t}\n\n\t\t\tz.id = y->id;\n\t\t\tnode_map[y->id] = z;\n\n\t\t\tnode_map.erase(old_z_id);\n\t\t}\n\t}\n\n\tNode* rightRotate(int node_id){\n\t\tNode& t = node_map[node_id];\n\t\tNode* s = t.p_left_child;\n\t\tt.p_left_child = s->p_right_child;\n\t\tif(s->p_right_child != NULL){\n\t\t    s->p_right_child->p_parent = &t;\n\t\t}\n\t\ts->p_right_child = &t;\n\n\t\tif(t.id == root_id){\n\t\t\troot_id = s->id;\n\t\t}\n\t\telse if(t.p_parent->p_left_child == &t){\n\t\t\tt.p_parent->p_left_child = s;\n\t\t}else if(t.p_parent->p_right_child == &t){\n\t\t\tt.p_parent->p_right_child = s;\n\t\t}\n\n\t\ts->p_parent = t.p_parent;\n\t\tt.p_parent = s;\n\t\treturn s;\n\t}\n\n\tNode* leftRotate(int node_id){\n\t\tNode& t = node_map[node_id];\n\t\tNode* s = t.p_right_child;\n\t\tt.p_right_child = s->p_left_child;\n\t\tif(s->p_left_child != NULL){\n\t\t    s->p_left_child->p_parent = &t;\n\t\t}\n\t\ts->p_left_child = &t;\n\n\t\tif(t.id == root_id){\n\t\t\troot_id = s->id;\n\t\t}\n\t\telse if(t.p_parent->p_left_child == &t){\n\t\t\tt.p_parent->p_left_child = s;\n\t\t}else if(t.p_parent->p_right_child == &t){\n\t\t\tt.p_parent->p_right_child = s;\n\t\t}\n\n\t\ts->p_parent = t.p_parent;\n\t\tt.p_parent = s;\n\t\treturn s;\n\t}\n\n\tNode* insert(Node* p_node, int key, int priority){\n\t\tif(p_node == NULL){\n\t\t\tnode_map[key] = Node(key, priority);\n\t\t\tif(node_map.size()==1){\n\t\t\t\troot_id = key;\n\t\t\t}\n\n\t\t\treturn &node_map[key];\n\t\t}\n\t\tif(key == p_node->id){\n\t\t\treturn p_node;\n\t\t}\n\n\t\tif(key < p_node->id){\n\t\t\tp_node->p_left_child = insert(p_node->p_left_child, key, priority);\n\t\t\tp_node->p_left_child->p_parent = p_node;\n\t\t\tif(p_node->priority < p_node->p_left_child->priority){\n\t\t\t\tp_node = rightRotate(p_node->id);\n\t\t\t}\n\t\t}else{ // key >= p_node->id\n\t\t\tp_node->p_right_child = insert(p_node->p_right_child, key, priority);\n\t\t\tp_node->p_right_child->p_parent = p_node;\n\t\t\tif(p_node->priority < p_node->p_right_child->priority){\n\t\t\t\tp_node = leftRotate(p_node->id);\n\t\t\t}\n\t\t}\n\n\t\treturn p_node;\n\t}\n\n\tNode* delete_node(Node* p_node, int key){\n\t\tif(p_node == NULL){\n\t\t\t//cout << \"delete_node(p_node: NULL, key:\" << key << \"\\n\";\n\t\t\treturn NULL;\n\t\t}\n\n\t\t//cout << \"detele_node(p_node:\" << p_node->id << \", key:\" << key << \")\\n\";\n\n\t\tif(key < p_node->id){\n\t\t\tp_node->p_left_child = delete_node(p_node->p_left_child, key);\n\t\t}else if(key > p_node->id){\n\t\t\tp_node->p_right_child = delete_node(p_node->p_right_child, key);\n\t\t}else{\n\t\t\treturn _delete(p_node, key);\n\t\t}\n\n\t\treturn p_node;\n\t}\n\n\tNode* _delete(Node* p_node, int key){\n\t\t//cout << \"_delete(p_node:\" << p_node->id << \", key:\" << key << \")\\n\";\n\n\t\tif(p_node->p_left_child == NULL and p_node->p_right_child == NULL){\n\t\t\treturn NULL;\n\t\t}else if(p_node->p_left_child == NULL){\n\t\t\tp_node = leftRotate(p_node->id);\n\t\t}else if(p_node->p_right_child == NULL){\n\t\t\tp_node = rightRotate(p_node->id);\n\t\t}else{\n\t\t\tif(p_node->p_left_child->priority > p_node->p_right_child->priority){\n\t\t\t\t//cout << \"_delete(p_node:\" << p_node->id << \", key:\" << key << \"), \" << \"rigthRotate(\" << p_node->id << \")\\n\";\n\t\t\t\tp_node = rightRotate(p_node->id);\n\t\t\t\t//cout << \"rightRoate done\\n\";\n\t\t\t}else{\n\t\t\t\t//cout << \"_delete(p_node:\" << p_node->id << \", key:\" << key << \"), \" << \"leftRotate(\" << p_node->id << \")\\n\";\n\t\t\t\tp_node = leftRotate(p_node->id);\n\t\t\t}\n\t\t}\n\n\t\treturn delete_node(p_node, key);\n\t}\n};\n\n\nint main() {\n\tBinarySearchTree tree;\n\n\tint n, input, priority;\n\tstring command;\n\tcin >> n;\n\n\tfor(int i=0; i<n; i++){\n\t\tcin >> command;\n\t\tif(command == \"insert\"){\n\t\t\tcin >> input >> priority;\n\t\t\t//cout << \"insert(\" << input << \")\\n\";\n\t\t\t//tree.insert(input, priority);\n\t\t\tif(tree.node_map.size()==0){\n\t\t\t\ttree.insert(NULL, input, priority);\n\t\t\t}else{\n\t\t\t\ttree.insert(&tree.node_map[tree.root_id], input, priority);\n\t\t\t}\n\t\t\t//tree.writeMap();\n\t\t\t//cout << \"\\n\\n\\n\";\n\t\t}\n\t\tif(command == \"print\"){\n\t\t\t//cout << \"printInorderTree()\\n\";\n\t\t\ttree.printInorderTree();\n\t\t\tcout << \"\\n\";\n\t\t\t//cout << \"printPreorderTree()\\n\";\n\t\t\ttree.printPreorderTree();\n\t\t\tcout << \"\\n\";\n\t\t}\n\t\tif(command == \"find\"){\n\t\t\tcin >> input;\n\t\t\tbool isFound = tree.find(input);\n\t\t\tif(isFound){\n\t\t\t\tcout << \"yes\\n\";\n\t\t\t}else{\n\t\t\t\tcout << \"no\\n\";\n\t\t\t}\n\t\t}\n\t\tif(command == \"delete\"){\n\t\t\tcin >> input;\n\t\t\ttree.delete_node(&tree.node_map[tree.root_id], input);\n\t\t\t//cout << \"delete: \" << input << \"\\n\";\n\t\t\t//tree.writeMap();\n\t\t\t//cout << \"\\n\\n\\n\";\n\t\t}\n\t\tif(command == \"right_rotate\"){\n\t\t\tcin >> input;\n\t\t\ttree.rightRotate(input);\n\t\t\t//cout << \"right_rotate: \" << input << \"\\n\";\n\t\t\t//tree.writeMap();\n\t\t\t//cout << \"\\n\\n\\n\";\n\t\t}\n\t\tif(command == \"left_rotate\"){\n\t\t\tcin >> input;\n\t\t\ttree.leftRotate(input);\n\t\t\t//cout << \"left_rotate: \" << input << \"\\n\";\n\t\t\t//tree.writeMap();\n\t\t\t//cout << \"\\n\\n\\n\";\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nclass Node{\npublic:\n\tint key;\n\tint priority;\n\tlist<Node>::iterator left,right;\n};\n\nclass Tree{\npublic:\n\tlist<Node> node_list;\n\tlist<Node>::iterator root;\n\tvector<int> preorder,inorder;\n\n\tTree(){\n\t\troot = node_list.end();\n\t}\n\tlist<Node>::iterator NIL(){\n\t\treturn node_list.end();\n\t}\n\tlist<Node>::iterator rightRotate(list<Node>::iterator t){\n\t\tlist<Node>::iterator s=t->left;\n\t\tt->left = s->right;\n\t\ts->right = t;\n\t\treturn s;\n\t}\n\tlist<Node>::iterator leftRotate(list<Node>::iterator t){\n\t\tlist<Node>::iterator s=t->right;\n\t\tt->right = s->left;\n\t\ts->left = t;\n\t\treturn s;\n\t}\n\tlist<Node>::iterator insert(list<Node>::iterator t,list<Node>::iterator z){\n\t\tif(t==NIL()){\n\t\t\treturn z;\n\t\t}\n\t\tif(z->key==t->key){\n\t\t\treturn t;\n\t\t}\n\n\t\tif(z->key<t->key){\n\t\t\tt->left = insert(t->left,z);\n\t\t\tif(t->priority<t->left->priority){\n\t\t\t\tt = rightRotate(t);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tt->right = insert(t->right,z);\n\t\t\tif(t->priority<t->right->priority){\n\t\t\t\tt = leftRotate(t);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\tvoid insert(list<Node>::iterator z){\n\t\troot = insert(root,z);\n\t}\n\tlist<Node>::iterator find(int key,list<Node>::iterator z){\n\t\tif(z->key==key) return z;\n\n\t\tif(z->key>key && z->left!=NIL()){\n\t\t\treturn find(key,z->left);\n\t\t}\n\t\telse if(z->key<key && z->right!=NIL()){\n\t\t\treturn find(key,z->right);\n\t\t}\n\t\treturn node_list.end();\n\t}\n\tbool find(int key){\n\t\tauto res = find(key,root);\n\t\treturn res!=node_list.end();\n\t}\n\n\tlist<Node>::iterator Delete2(int key,list<Node>::iterator z){\n\t\tif(z->left==NIL() && z->right==NIL()){\n\t\t\tnode_list.erase(z);\n\t\t\treturn NIL();\n\t\t}\n\t\telse if(z->left==NIL()){\n\t\t\tz = leftRotate(z);\n\t\t}\n\t\telse if(z->right==NIL()){\n\t\t\tz = rightRotate(z);\n\t\t}\n\t\telse{\n\t\t\tif(z->left->priority>z->right->priority){\n\t\t\t\tz = rightRotate(z);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tz = leftRotate(z); \n\t\t\t}\n\t\t}\n\t\treturn Delete(key,z);\n\t}\n\tlist<Node>::iterator Delete(int key,list<Node>::iterator z){\n\t\tif(z==NIL()) return z;\n\n\t\tif(key<z->key){\n\t\t\tz->left = Delete(key,z->left);\n\t\t}\n\t\telse if(key>z->key){\n\t\t\tz->right = Delete(key,z->right);\n\t\t}\n\t\telse{\n\t\t\treturn Delete2(key,z);\n\t\t}\n\t\treturn z;\n\t}\n\tvoid Delete(int key){\n\t\troot = Delete(key,root);\n\t}\n\tvoid DFS(list<Node>::iterator parent){\n\t\tpreorder.push_back(parent->key);\n\t\t\n\t\tif(parent->left==NIL()){\n\t\t\tinorder.push_back(parent->key);\n\t\t}\n\t\telse{\n\t\t\tDFS(parent->left);\n\t\t\tinorder.push_back(parent->key);\n\t\t}\n\n\t\tif(parent->right!=NIL()){\n\t\t\tDFS(parent->right);\n\t\t}\n\t}\n\tvoid DFS(){\n\t\tpreorder.clear();\n\t\tinorder.clear();\n\t\tDFS(root);\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N=in();\n\tTree tree;\n\tREP(i,N){\n\t\tstring S=in<string>();\n\t\tif(S==\"insert\"){\n\t\t\tNode n;\n\t\t\tn.key = in(),n.priority = in();\n\t\t\tn.left=n.right=tree.NIL();\n\t\t\tauto z = tree.node_list.insert(tree.NIL(),n);\n\t\t\ttree.insert(z);\n\t\t}\n\t\telse if(S==\"find\"){\n\t\t\tint key = in();\n\t\t\tout(tree.find(key)?\"yes\":\"no\");\n\t\t}\n\t\telse if(S==\"delete\"){\n\t\t\tint key = in();\n\t\t\ttree.Delete(key);\n\t\t}\n\t\telse{\n\t\t\ttree.DFS();\n\t\t\tint num = tree.preorder.size();\n\t\t\tREP(j,num){\n\t\t\t\tcout << ' ' << tree.inorder[j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tREP(j,num){\n\t\t\t\tcout << ' ' << tree.preorder[j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef struct Node{\n  int value, priority;\n  Node *left, *right;\n} Node;\n\nNode* Delete(Node *, int);\nNode* _delete(Node *, int);\n\nNode *NIL,*root;\n\nNode* rightRotate(Node *t){\n  Node *s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\nNode* leftRotate(Node *t){\n  Node *s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s; \n}\nNode* makenode(int key, int priority){\n  Node *node = (Node *)malloc(sizeof(Node));\n  node->value = key;\n  node->priority = priority;\n  node->left = node->right = NIL;\n  return node;\n}\n\nNode* insert(Node *t, int key, int priority){    \n  Node *x;\n\n  if(t == NIL) return x = makenode(key, priority); \n\n  if(key == t->value) return t;                \n\n  if(key < t->value){                          \n    t->left = insert(t->left, key, priority); \n    if(t->priority < t->left->priority) t = rightRotate(t); \n  }else{                                      \n    t->right = insert(t->right, key, priority); \n    if(t->priority < t->right->priority) t = leftRotate(t); \n  }\n\n  return t;\n}\nNode* find(Node *x, int k){\n  if(x == NIL || x->value == k) return x;\n\n  if(k < x->value) return find(x->left, k);\n  else return find(x->right, k);\n}\nNode* Delete(Node *t, int key){\n  if(t == NIL) return NIL;\n  if(key < t->value) t->left = Delete(t->left, key); \n  else if(key > t->value) t->right = Delete(t->right, key);\n  else return _delete(t, key);\n  return t;\n}\n\nNode* _delete(Node *t, int key){ \n  if(t->left == NIL && t->right == NIL) return NIL; \n  else if(t->left == NIL) t = leftRotate(t);   \n  else if(t->right == NIL) t = rightRotate(t); \n  else{                                     \n    if(t->left->priority > t->right->priority) t = rightRotate(t); \n    else t = leftRotate(t);\n  }\n  return Delete(t, key);\n}\n\nvoid preParse(Node *node){\n  if(node == NIL) return ;\n\n  cout<<\" \"<< node->value;\n  if(node->left != NIL) preParse(node->left);\n  if(node->right != NIL) preParse(node->right);\n}\n\nvoid inParse(Node *node){\n  if(node == NIL) return ;\n\n  if(node->left != NIL) inParse(node->left);\n  cout<<\" \"<<node->value;\n  if(node->right != NIL) inParse(node->right);\n}\n\nint main(){\n  int n,key,priority;\n  string command;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>command;\n    if(command==\"insert\"){\n      cin>>key>>priority;\n      root=insert(root,key,priority);\n    }else if(command==\"print\"){\n      inParse(root);\n      cout<<endl;\n      preParse(root);\n      cout<<endl;\n    }else if(command==\"find\"){\n      cin>>key;\n      if(find(root,key)) cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n    }else if(command==\"delete\"){\n      cin>>key;\n      root=Delete(root,key);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nclass Treap{\npublic:\n  \n  struct Node{\n    int key, pri;\n    Node *left, *right;\n    Node():left(nullptr),right(nullptr){}\n    Node(int k, int p):key(k),pri(p),left(nullptr),right(nullptr){}\n  };\n  \n  Node *root;\n  \n  Treap(){ root = nullptr; }\n  \n  Node* rightRotate(Node *t){\n    \n    Node* s = (*t).left;\n    \n    (*t).left = (*s).right;\n    \n    (*s).right = t;\n    \n    return s;\n  }\n  \n  Node* leftRotate(Node *t){\n    \n    Node* s = (*t).right;\n    \n    (*t).right = (*s).left;\n    \n    (*s).left = t;\n    \n    return s;\n  }\n  \n  Node* insert(Node *t, int key, int pri){\n    \n    if( t == nullptr ) return new Node( key, pri );\n    \n    if( (*t).key == key ) return t;\n    \n    if( key < (*t).key  ){\n      \n      (*t).left = insert( (*t).left, key, pri );\n      \n      if( (*t).pri < (*(*t).left).pri ) t = rightRotate( t );\n      \n    }\n    else{\n      \n      (*t).right = insert( (*t).right, key, pri );\n      \n      if( (*t).pri < (*(*t).right).pri ) t = leftRotate( t );\n      \n    }\n    \n    return t;\n  }\n  \n  void insert(int key, int pri){ root = insert( root, key, pri ); }\n  \n  Node* erase(Node *t, int key){\n    \n    if( t == nullptr ) return nullptr;\n    \n    if( (*t).key == key ){\n      \n      if( (*t).left == nullptr && (*t).right == nullptr ) return nullptr;\n      else if( (*t).left == nullptr ) t = leftRotate( t );\n      else if( (*t).right == nullptr ) t = rightRotate( t );\n      else{\n\t\n\tif( (*(*t).left).pri > (*(*t).right).pri ) t = rightRotate( t );\n\telse t = leftRotate( t );\n\t\n      }\n      \n      return erase( t, key );\n    }\n    \n    if( key < (*t).key ) (*t).left = erase( (*t).left, key );\n    else (*t).right = erase( (*t).right, key );\n    \n    return t;\n  }\n  \n  void erase(int key){ root = erase( root, key ); }\n      \n  bool find(Node *t, int key){\n    \n    if( t == nullptr ) return false;\n    \n    if( (*t).key == key ) return true;\n    \n    if( (*t).left == nullptr && (*t).right == nullptr ) return false;\n    else if( (*t).left == nullptr ) return find( (*t).right, key );\n    else if( (*t).right == nullptr ) return find( (*t).left, key );\n    else{\n      \n      if( key < (*t).key ) return find( (*t).left, key );\n      else return find( (*t).right, key );\n      \n    }\n    \n  }\n  \n  bool find(int key){ return find( root, key ); }\n  \n  void print_inorder(Node *x){\n  \n    if( (*x).left != nullptr ) print_inorder( (*x).left );\n  \n    if( x != nullptr ) cout << ' ' << (*x).key;\n  \n    if( (*x).right != nullptr ) print_inorder( (*x).right );\n  \n  }\n  \n  void print_inorder(){ print_inorder( root ), cout << endl; }\n  \n  void print_preorder(Node *x){\n  \n    if( x != nullptr ) cout << ' ' << (*x).key;\n  \n    if( (*x).left != nullptr ) print_preorder( (*x).left );\n  \n    if( (*x).right != nullptr ) print_preorder( (*x).right );\n  \n  }\n  \n  void print_preorder(){ print_preorder( root ), cout << endl; }\n  \n};\n\nsigned main(){\n  \n  int N;\n  cin >> N;\n  \n  Treap treap = Treap();\n  \n  while( N-- ){\n    \n    string s;\n    cin >> s;\n    \n    if( s == \"insert\" ){\n      \n      int key, pri;\n      cin >> key >> pri;\n      \n      treap.insert( key, pri );\n      \n    }\n    \n    if( s == \"find\" ){\n      \n      int key;\n      cin>>key;\n      \n      if( treap.find( key ) == true ) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n      \n    }\n    \n    if( s == \"delete\" ){\n      \n      int key;\n      cin>>key;\n      \n      treap.erase( key );\n      \n    }\n    \n    if( s == \"print\" ){\n      \n      treap.print_inorder();\n      \n      treap.print_preorder();\n      \n    }\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for (int i = (a); i < (int)(b); i++)\n#define rrep(i, a, b) for (int i = (a); i >= (int)(b); i--)\n#define all(x) (x).begin(), (x).end()\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing f32 = float;\nusing f64 = double;\nusing P   = pair<int, int>;\n\ntemplate <class T>\nbool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    } else {\n        return false;\n    }\n}\ntemplate <class T>\nbool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    } else {\n        return false;\n    }\n}\n\ntemplate <class T>\nvoid dump_vec(const vector<T>& v) {\n    auto len = v.size();\n    rep(i, 0, len) {\n        cout << v[i] << (i == (int)len - 1 ? \"\\n\" : \" \");\n    }\n}\n\nstruct FastIO {\n    FastIO() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(20);\n    }\n} FASTIO;\n\n//---------------------------------------------------------------------------------------------------\n\n/// 乱数を用いる平衡二分探索木\n/// https://www.slideshare.net/iwiwi/2-12188757\n/// キーをみると二分探索木、優先度をみると二分ヒープ\ntemplate <class Key>\nstruct Treap {\n    struct Node {\n        Key key;\n        int priority;\n        Node *left, *right;\n        Node(Key k, int p) : key(k), priority(p), left(nullptr), right(nullptr) {}\n    };\n\n    using Tree = Node*;\n    Tree _root = nullptr;\n\n    void split(Tree t, Key key, Tree& l, Tree& r) {\n        if (!t) {\n            l = r = nullptr;\n        } else if (key < t->key) {\n            split(t->left, key, l, t->left);\n            r = t;\n        } else {\n            split(t->right, key, t->right, r);\n            l = t;\n        }\n    }\n\n    void merge(Tree& t, Tree l, Tree r) {\n        if (!l || !r) {\n            t = l ? l : r;\n        } else if (l->priority > r->priority) {\n            merge(l->right, l->right, r);\n            t = l;\n        } else {\n            merge(r->left, l, r->left);\n            t = r;\n        }\n    }\n\n    void insert(Tree& t, Tree x) {\n        if (!t) {\n            t = x;\n        } else if (x->priority > t->priority) {\n            split(t, x->key, x->left, x->right);\n            t = x;\n        } else {\n            insert(x->key < t->key ? t->left : t->right, x);\n        }\n    }\n\n    void erase(Tree& t, Key key) {\n        if (!t) return;\n        if (t->key == key) {\n            merge(t, t->left, t->right);\n        } else {\n            erase(key < t->key ? t->left : t->right, key);\n        }\n    }\n\n    bool find(Tree& t, Key key) {\n        if (!t) {\n            return false;\n        } else if (t->key == key) {\n            return true;\n        } else {\n            return find(key < t->key ? t->left : t->right, key);\n        }\n    }\n\n    static i32 xor128() {\n        static uint32_t x = 123456789, y = 362436069, z = 521288629, w = time(0);\n        uint32_t t = x ^ (x << 11);\n        x          = y;\n        y          = z;\n        z          = w;\n        w          = (w ^ (w >> 19)) ^ (t ^ (t >> 8));\n        return w & 0x3FFFFFFF;\n    }\n\n    void insert(Key k) {\n        insert(_root, new Node(k, xor128()));\n    }\n\n    void insert(Key k, i32 p) {\n        insert(_root, new Node(k, p));\n    }\n\n    void erase(Key k) {\n        erase(_root, k);\n    }\n\n    bool find(Key k) {\n        return find(_root, k);\n    }\n\n    void dump_preorder(const Tree cur) {\n        if (!cur) {\n            return;\n        }\n        cout << \" \" << cur->key;   // 自身\n        dump_preorder(cur->left);  // 左\n        dump_preorder(cur->right); // 右\n    }\n\n    void dump_inorder(const Tree cur) {\n        if (!cur) {\n            return;\n        }\n        dump_inorder(cur->left);  // 左\n        cout << \" \" << cur->key;  // 自身\n        dump_inorder(cur->right); // 右\n    }\n};\n\n//---------------------------------------------------------------------------------------------------\n\nsigned main() {\n    int N;\n    cin >> N;\n    Treap<i32> tree;\n    rep(i, 0, N) {\n        string s;\n        cin >> s;\n        if (s == \"insert\") {\n            i32 v, p;\n            cin >> v >> p;\n            tree.insert(v, p);\n            // cout << \"in\\n\";\n            // tree.dump_inorder(tree._root);\n            // cout << \"\\n\";\n        } else if (s == \"find\") {\n            i32 v;\n            cin >> v;\n            cout << (tree.find(v) ? \"yes\" : \"no\") << \"\\n\";\n            // cout << \"in\\n\";\n            // tree.dump_inorder(tree._root);\n            // cout << \"\\n\";\n        } else if (s == \"delete\") {\n            i32 v;\n            cin >> v;\n            tree.erase(v);\n            // cout << \"in\\n\";\n            // tree.dump_inorder(tree._root);\n            // cout << \"\\n\";\n        } else {\n            tree.dump_inorder(tree._root);\n            cout << \"\\n\";\n            tree.dump_preorder(tree._root);\n            cout << \"\\n\";\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\ntemplate<class Type> class Treap\n{\n   public:\n       struct Node\n       {\n           Type key, pri;\n           Node *left, *right;\n       };\n       Node *rightRotate(Node *u)\n       {\n           Node *q = u->left;\n           u->left = q->right;\n           q->right = u;\n           return q;\n       }\n       Node *leftRotate(Node *u)\n       {\n           Node *q = u->right;\n           u->right = q->left;\n           q->left = u;\n           return q;\n       }\n       Node *insert(Node *u, Type key, Type p)\n       {\n           if(u == nullptr)\n           {\n               Node *q = new Node;\n               q->key = key;\n               q->pri = p;\n               q->left = nullptr, q->right = nullptr;\n               return q;\n           }\n           else\n           {\n               if(key < u->key)\n               {\n                   u->left = insert(u->left, key, p);\n                   if(u->left->pri > u->pri) u = rightRotate(u);\n               }\n               else \n               {\n                   u->right = insert(u->right, key, p);\n                   if(u->right->pri > u->pri) u = leftRotate(u);\n               }\n               return u;\n           }\n       }\n       bool find(Node *u, Type key)\n       {\n           if(u == nullptr) return false;\n           else if(key == u->key) return true;\n           else if(key < u->key) return find(u->left, key);\n           else return find(u->right, key); \n       }\n       Node *remove(Node *u, Type key)\n       {\n           if(u == nullptr) return nullptr;\n           if(key < u->key) u->left = remove(u->left, key);\n           else if(key > u->key) u->right = remove(u->right, key);\n           else return _remove(u, key);\n           return u;\n       }\n       Node *_remove(Node *u, Type key)\n       {\n           if(u->left == nullptr && u->right == nullptr) return nullptr;\n           else if(u->left == nullptr) u = leftRotate(u);\n           else if(u->right == nullptr) u = rightRotate(u);\n           else if(u->left->pri > u->right->pri) u = rightRotate(u);\n           else u = leftRotate(u);\n           return remove(u, key);\n       }\n       void print(Node *u)\n       {\n           inorder(u); cout << endl;\n           preorder(u); cout << endl;\n       }\n       void inorder(Node *u)\n       {\n           if(u->left != nullptr) inorder(u->left);\n           cout << \" \" << u->key;\n           if(u->right != nullptr) inorder(u->right);\n       }\n       void preorder(Node *u)\n       {\n           cout << \" \" << u->key; \n           if(u->left != nullptr) preorder(u->left);\n           if(u->right != nullptr) preorder(u->right);\n       }\n};\nint main()\n{\n    int n; cin >> n;\n    Treap<int> T;\n    Treap<int>::Node *root = nullptr;\n    for(int i = 0; i < n; i++)\n    {\n        string s; cin >> s;\n        if(s == \"insert\")\n        {\n            int key, pri; cin >> key >> pri;\n            root = T.insert(root, key, pri);\n        }\n        if(s == \"find\")\n        {\n            int key; cin >> key;\n            cout << (T.find(root, key) ? \"yes\" : \"no\") << endl;\n        }\n        if(s == \"delete\")\n        {\n            int key, pri; cin >> key;\n            root = T.remove(root, key);\n        }\n        if(s == \"print\") T.print(root);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef struct Node{\n  int value, priority;\n  Node *left, *right;\n} Node;\n\nNode* Delete(Node *, int);\nNode* _delete(Node *, int);\n\nNode *NIL, *root;\n\nNode* rightRotate(Node *t){\n  Node *s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s; // root of the subtree\n}\n\nNode* leftRotate(Node *t){\n  Node *s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s; // root of the subtree\n}\n\nNode* makenode(int key, int priority){\n  Node *node = (Node *)malloc(sizeof(Node));\n  node->value = key;\n  node->priority = priority;\n  node->left = node->right = NIL;\n\n  return node;\n}\n\nNode* insert(Node *t, int key, int priority){    //search recursively\n  Node *x;\n\n  if(t == NIL) return x = makenode(key, priority); //reach a leaf, make new node and return that\n\n  if(key == t->value) return t;                //ignore duplicative key\n\n  if(key < t->value){                          //move the left child\n      t->left = insert(t->left, key, priority); //update the pointer to left child\n      if(t->priority < t->left->priority) t = rightRotate(t); //when left child's priority is larger, right rotate\n  }else{                                       //move the right child\n      t->right = insert(t->right, key, priority); //update the pointer to right child\n      if(t->priority < t->right->priority) t = leftRotate(t); //when right chil's priority is larger, left rotate\n  }\n\n  return t;\n}\n\nNode* find(Node *x, int k){\n  if(x == NIL || x->value == k) return x;\n\n  if(k < x->value) return find(x->left, k);\n  else return find(x->right, k);\n}\n\nNode* Delete(Node *t, int key){\n  if(t == NIL) return NIL;\n  if(key < t->value) t->left = Delete(t->left, key); //search the node that should be deleted\n  else if(key > t->value) t->right = Delete(t->right, key);\n  else return _delete(t, key);\n  return t;\n}\n\nNode* _delete(Node *t, int key){ //case of the node should be deleted\n  if(t->left == NIL && t->right == NIL) return NIL; //case of leaf\n  else if(t->left == NIL) t = leftRotate(t);   //if have only right child, left rotate\n  else if(t->right == NIL) t = rightRotate(t); //if have only left child, right rotate\n  else{                                        //if have two children, lift a node have larger priority up\n    if(t->left->priority > t->right->priority) t = rightRotate(t);\n    else t = leftRotate(t);\n  }\n  return Delete(t, key);\n}\n\nvoid preParse(Node *node){\n  if(node == NIL) return ;\n\n  cout << \" \" << node->value;\n  if(node->left != NIL) preParse(node->left);\n  if(node->right != NIL) preParse(node->right);\n}\n\nvoid inParse(Node *node){\n  if(node == NIL) return ;\n\n  if(node->left != NIL) inParse(node->left);\n  cout << \" \" << node->value;\n  if(node->right != NIL) inParse(node->right);\n}\n\nint main(){\n\n  int n, key, priority;\n  string command;\n\n  //input\n  cin >> n;\n  for(int i = 0;i < n;i++){\n    cin >> command;\n    if(command == \"insert\"){\n      cin >> key >> priority;\n      root = insert(root, key, priority);\n    }else if(command == \"print\"){\n      inParse(root);\n      cout << endl;\n      preParse(root);\n      cout << endl;\n    }else if(command == \"find\"){\n      cin >> key;\n      if(find(root, key)) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }else if(command == \"delete\"){\n      cin >> key;\n      root = Delete(root, key);\n    }\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate <class T, class U> using Pa = pair<T, U>;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\n\n\ntemplate<class T>\nclass Treap{\nprivate:\n    struct Node{\n        T val;\n        int priority;\n        Node* par;\n        Node* left;\n        Node* right;\n        Node(){}\n        Node(T val,int p):val(val),priority(p){}\n    };\n    Node *root;\n\n    Node* rightRotate(Node* t){\n        Node* s = t->left;\n        t->left = s->right;\n        s->right = t;\n        return s;\n    }\n\n    Node* leftRotate(Node* t){\n        Node* s = t->right;\n        t->right = s->left;\n        s->left = t;\n        return s;\n    }\n\n    Node* insert(Node* t,T val,int priority){\n        if(t == nullptr){\n            t = new Node;\n            t->left = nullptr;\n            t->right = nullptr;\n            t->val = val;\n            t->priority = priority;\n            return t;\n        }\n        /*\n        if(val == t->val){\n            return t;\n        }\n        */\n        if(val < t->val){\n            t->left = insert(t->left,val,priority);\n            if(t->priority < t->left->priority){\n                t = rightRotate(t);\n            }\n        }else{\n            t->right = insert(t->right,val,priority);\n            if(t->priority < t->right->priority){\n                t = leftRotate(t);\n            }\n        }\n        return t;\n    }\n\n    Node* erase(Node* t,T val){\n        if(t == nullptr){\n            return nullptr;\n        }\n        if(val < t->val){\n            t->left = erase(t->left,val);\n        }else if(val > t->val){\n            t->right = erase(t->right,val);\n        }else{\n            return _erase(t,val);\n        }\n        return t;\n    }\n\n    Node* _erase(Node* t,T val){\n        if(t->left == nullptr && t->right == nullptr){\n            return nullptr;\n        }else if(t->left == nullptr){\n            t = leftRotate(t);\n        }else if(t->right == nullptr){\n            t = rightRotate(t);\n        }else{\n            if(t->left->priority > t->right->priority){\n                t = rightRotate(t);\n            }else{\n                t = leftRotate(t);\n            }\n        }\n        return erase(t,val);\n    }\n\n    bool find(Node* now,T x){\n        if(now==nullptr) return false;\n        if(now->val == x) return true;\n        if(x < now->val){\n            if(now->left != nullptr) return find(now->left,x);\n        }else{\n            if(now->right != nullptr) return find(now->right,x);\n        }\n        return false;\n    }\n\n    void inorder_walk(Node* now,vec<T>& v){\n        if(now==nullptr) return ;\n        if(now->left!=nullptr) inorder_walk(now->left,v);\n        v.push_back(now->val);\n        if(now->right!=nullptr) inorder_walk(now->right,v);\n    }\n    void preorder_walk(Node* now,vec<T>& v){\n        if(now==nullptr) return ;\n        v.push_back(now->val);\n        if(now->left!=nullptr) preorder_walk(now->left,v);\n        if(now->right!=nullptr) preorder_walk(now->right,v);\n    }\n\npublic:\n    Treap():root(nullptr){}\n    \n    void insert(T val,int priority){\n        if(root == nullptr){\n            root = new Node;\n            root->left = nullptr;\n            root->right = nullptr;\n            root->val = val;\n            root->priority = priority;\n            return ;\n        }\n        root = insert(root,val,priority);\n    }\n\n    void erase(T val){\n        root = erase(root,val);\n    }\n\n    bool find(T val){\n        return find(root,val);\n    }\n\n    vec<T> inorder_walk(){\n        if(root==nullptr) return {};\n        vec<T> res;\n        inorder_walk(root,res);\n        return res;\n    }\n    vec<T> preorder_walk(){\n        if(root==nullptr) return {};\n        vec<T> res;\n        preorder_walk(root,res);\n        return res;\n    }\n\n};\n\nint main(){\n    int N;\n    cin >> N;\n    Treap<int> treap;\n    for(int _=0;_<N;_++){\n        string S;\n        cin >> S;\n        if(S==\"print\"){\n            auto res = treap.inorder_walk();\n            int n = res.size();\n            for(int i=0;i<n;i++) cout << \" \" << res[i];\n            cout << \"\\n\";\n            res = treap.preorder_walk();\n            n = res.size();\n            for(int i=0;i<n;i++) cout << \" \" << res[i];\n            cout << \"\\n\";\n        }\n        if(S==\"insert\"){\n            int x,p;\n            cin >> x >> p;\n            treap.insert(x,p);\n        }\n        if(S==\"find\"){\n            int x;\n            cin >> x;\n            cout << (treap.find(x)? \"yes\\n\":\"no\\n\");\n        }\n        if(S==\"delete\"){\n            int x;\n            cin >> x;\n            treap.erase(x);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n\nusing namespace std;\n\n\nstruct Node{\n  int key, pri;\n  Node* right;\n  Node* left;\n};\n\n\nNode* RightRotate(Node* t){\n  Node* s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\n\nNode* LeftRotate(Node* t){\n  Node* s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\n\nNode* Insert(Node* t, int key, int pri){\n\n  if(t == NULL){\n    Node* t = new Node;\n    t->left=NULL;\n    t->right=NULL;\n    t->key=key;\n    t->pri=pri;\n    return t;\n  }\n  if(key == t->key) return t;\n\n  if(key < t->key){\n    t->left = Insert(t->left, key, pri);\n    if(t->pri < t->left->pri) t = RightRotate(t);\n  }\n  else{\n    t->right = Insert(t->right, key, pri);\n    if(t->pri < t->right->pri) t = LeftRotate(t);\n  }\n  return t;\n}\n\nNode* Erase(Node* t, int key){\n  if(t == NULL) return NULL;\n\n  if(key == t->key){\n    if(t->left  == NULL && t->right == NULL) return NULL;\n    else if(t->left == NULL) t = LeftRotate(t);\n    else if(t->right == NULL) t = RightRotate(t);\n    else{\n      if(t->left->pri > t->right->pri) t = RightRotate(t);\n      else t = LeftRotate(t);\n    }\n    return Erase(t, key);\n  }\n  if(key < t->key) t->left = Erase(t->left, key);\n  else t->right = Erase(t->right, key);\n  return t;\n}\n\nvoid Find(Node* t, int key){\n  while(t != NULL && key != t->key){\n    if(key < t->key) t = t->left;\n    else t = t->right;\n  }\n  if(t == NULL) cout << \"no\" << endl;\n  else cout << \"yes\" << endl;\n}\n\nvoid Inorder(Node* t){\n  if(t == NULL) return;\n  Inorder(t->left);\n  cout << \" \" << t->key;\n  Inorder(t->right);\n}\n\nvoid Preorder(Node* t){\n  if(t == NULL) return;\n  cout << \" \" << t->key;\n  Preorder(t->left);\n  Preorder(t->right);\n}\n\nint main(){\n  Node* root=NULL;\n  int n, key, pri;\n  string s;\n\n  cin >> n;\n\n  for(int i=0;i<n;i++){\n    cin >> s;\n    if(s == \"insert\"){\n      cin >> key >> pri;\n      root = Insert(root, key, pri);\n    }\n    else if(s == \"delete\"){\n      cin >> key;\n     root = Erase(root, key);\n    }\n    else if(s == \"find\"){\n      cin >> key;\n      Find(root, key);\n    }\n    else {\n      Inorder(root);\n      cout << endl;\n      Preorder(root);\n      cout << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int MAX = 500010;\n\nstruct Node{\n  int key;\n  int priority;\n  Node* left;\n  Node* right;\n  Node* p;\n};\n\nNode gT[MAX];\nNode* gRoot = nullptr;\n\nNode* Delete( Node* t, int key );\nNode* _Delete( Node* t, int key );\n\nNode* RotateRight( Node* t ){\n  Node* s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\n\nNode* RotateLeft( Node* t ){\n  Node* s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\n\nNode* MakeNode( int k, int p ){\n  Node* x = new Node;\n  x->key = k;\n  x->priority = p;\n  x->left = x->right = x->p = nullptr;\n  return x;\n}\n\nNode* Insert( Node* t, int key, int priority ){\n  if( t == nullptr ){\n    Node* x;\n    return x = MakeNode( key, priority );\n  }\n  if( key == t->key ){\n    return t;\n  }\n\n  if( key < t->key ){\n    t->left = Insert( t->left, key, priority );\n    if( t->priority < t->left->priority ){\n      t = RotateRight( t );\n    }\n  }else{\n    t->right = Insert( t->right, key, priority );\n    if( t->priority < t->right->priority ){\n      t = RotateLeft( t );\n    }\n  }\n  return t;\n}\n\nNode* Find( int k ){\n  Node* x = gRoot;\n  while( x != nullptr ){\n    if( k == x->key ) return x;\n    if( k < x->key ) x = x->left;\n    else x = x->right;\n  }\n  return nullptr;\n}\n\nNode* Delete( Node* t, int key ){\n  if( t == nullptr ) return nullptr;\n  if( key < t->key ) t->left = Delete( t->left, key );\n  else if( key > t->key ) t->right = Delete( t->right, key );\n  else return _Delete( t, key );\n  return t;\n}\n\nNode* _Delete( Node* t, int key ){\n  if( t->left == nullptr && t->right == nullptr ) return nullptr;\n  else if( t->left == nullptr ) t = RotateLeft( t );\n  else if( t->right == nullptr ) t = RotateRight( t );\n  else{\n    if( t->left->priority > t->right->priority ){\n      t = RotateRight( t );\n    }else{\n      t = RotateLeft( t );\n    }\n  }\n  return Delete( t, key );\n}\n\n\nvoid Inorder( Node* s ){\n  if( s == nullptr ) return;\n\n  Inorder( s->left );\n  cout << \" \" << s->key;\n  Inorder( s->right );\n}\n\nvoid Preorder( Node* s ){\n  if( s == nullptr ) return;\n\n  cout << \" \" << s->key;\n  Preorder( s->left );\n  Preorder( s->right );\n}\n\nint main(){\n  for( int i = 0; i < MAX; i++ ){\n    gT[i].left = gT[i].right = gT[i].p = nullptr;\n  }\n  \n  int m; cin >> m;\n  for( int i = 0; i < m; i++ ){\n    char cmd[10]; cin >> cmd;\n    if( cmd[0] == 'i' ){\n      int key, p; cin >> key >> p;\n      gRoot = Insert( gRoot, key, p );\n    }else if( cmd[0] == 'p' ){\n      Inorder( gRoot ); cout << endl;\n      Preorder( gRoot ); cout << endl;\n    }else if( cmd[0] == 'f' ){\n      int key; cin >> key;\n      if( Find( key ) != nullptr ) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }else if( cmd[0] == 'd' ){\n      int key; cin >> key;\n      gRoot = Delete( gRoot, key );\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nstruct Node{\n    Node *left;\n    Node *right;\n\tint key;\n\tint pri;\n\n\tNode(int k, int p) : key(k), pri(p){\n\t\tleft = right = NULL;\n\t}\n};\n\nNode* rightRotate(Node *t){\n    Node* s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\t\n\treturn s; \n}\n\nNode* leftRotate(Node *t){\n    Node* s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\t\n\treturn s; \n}\n\nvoid find(Node *t, int k){\n  while(t != NULL && k != t->key){\n    if(k < t->key) t = t->left;\n    else t = t->right;\n  }\n\n  if ( t != NULL ) cout << \"yes\" << endl;\n  else cout << \"no\" << endl;\n}\n\nNode* insert(Node *t, int key, int pri){\n    if(t == NULL){ return new Node(key, pri); }\n    if(key == t->key){ return t; }                     \n\n    if(key < t->key){                         \n        t->left = insert(t->left, key, pri);  \n\t\tif(t->pri < t->left->pri){ t = rightRotate(t); }\n\t} else{\n        t->right = insert(t->right, key, pri);\n\t\tif(t->pri < t->right->pri){ t = leftRotate(t); }\n\t}\n\t\n\treturn t;\n}\n\nNode* erase(Node *t, int key){\n    if(t == NULL){ return NULL; }\n\t\n\tif(key == t->key){                         \n\t\tif(t->left == NULL && t->right == NULL){ return NULL; }\n        else if(t->left == NULL){ t = leftRotate(t); }\n        else if(t->right == NULL){ t = rightRotate(t); }\n        else{\n            if(t->left->pri > t->right->pri){ t = rightRotate(t); }\n            else{ t = leftRotate(t); }\n\t\t}\n\t\treturn erase(t, key);\n\t}\n\t\n\tif(key < t->key){ t->left = erase(t->left, key); }\n\telse{ t->right = erase(t->right, key); }\n\t\n\treturn t;\n}\n\n\nvoid Inorder(Node *t){\n  if(t->left != NULL) Inorder(t->left);\n  if(t->key != -1) cout << \" \" << t->key;\n  if(t->right != NULL) Inorder(t->right);\n}\n   \nvoid Preorder(Node *t){\n  if(t->key != -1) cout << \" \" << t->key;\n  if(t->left != NULL) Preorder(t->left);\n  if(t->right != NULL) Preorder(t->right);\n}\n\n\nvoid print(Node *t){\n\tif(t != NULL) Inorder(t);\n\t  cout <<endl;\n      if(t != NULL) Preorder(t);\n\t  cout <<endl;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n    char ope[n];\n\tint k, p;\n\n\tNode *t=new Node(-1, -1);\n\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%s\", ope);\n\t\tif(ope[0] == 'p'){ print(t); }\n\t\telse if(ope[0] == 'f'){ cin >> k; find(t, k); }\n\t\telse if(ope[0] == 'd'){ cin >> k; t = erase(t, k); }\n\t\telse if(ope[0] == 'i'){ cin >> k >> p; t = insert(t, k, p); }\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\nusing std::cout;\nusing std::cin;\nusing std::endl;\nusing ll = long long;\n\ntemplate <typename T, typename S> struct Node {\n  T key;\n  S pri;\n  Node *p;\n  Node *left;\n  Node *right;\n  Node(): p(nullptr), left(nullptr), right(nullptr) {}\n  Node(T key) : key(key), p(nullptr), left(nullptr), right(nullptr) {}\n  Node(T key, S pri): key(key), pri(pri), p(nullptr), left(nullptr), right(nullptr) {}\n  Node(T key, S pri, Node* p): key(key), pri(pri), p(p), left(nullptr), right(nullptr) {}\n};\n\ntemplate <typename T, typename S> struct Treap {\n  Node<T, S> *root;\n  Treap() : root(nullptr) {}\n\n  void inorder(){\n    inorder(root);\n  }\n  void inorder(Node<T, S> *n) {\n    if (n == nullptr) {\n      return;\n    }\n    inorder(n->left);\n    cout << \" \" << n->key;\n    inorder(n->right);\n    return;\n  }\n\n  void preorder(){\n    preorder(root);\n  }\n  void preorder(Node<T, S> *n) {\n    if (n == nullptr) {\n      return;\n    }\n    cout << \" \" << n->key;\n    preorder(n->left);\n    preorder(n->right);\n    return;\n  }\n\n  Node<T, S>*  insert(T key, T pri){\n    return root = insert(root, nullptr, key, pri);\n  }\n  Node<T, S> *insert(Node<T, S> *t, Node<T, S> *par, T key, S pri){\n    if(t == nullptr){\n      return new Node<T, S>(key, pri, par);\n    }\n    if(key == t->key){\n      return t;\n    }\n\n    if(key < t->key){\n      t->left = insert(t->left, t, key, pri);\n      if(t->pri < t->left->pri){\n        t = rightRotate(t);\n      }\n    }else{\n      t->right = insert(t->right, t, key, pri);\n      if(t->pri < t->right->pri){\n        t = leftRotate(t);\n      }\n    }\n    return t;\n  }\n\n  Node<T, S>* erase(T key){\n    return root = erase(root, key);\n  }\n  Node<T, S> *erase(Node<T, S> *t, T key){\n    if(t == nullptr){\n      return nullptr;\n    }\n\n    if(key == t->key){\n      if(t->left == nullptr && t->right == nullptr){\n        return nullptr;\n      }\n      else if(t->left == nullptr){\n        t = leftRotate(t);\n      }else if(t->right == nullptr){\n        t = rightRotate(t);\n      }else{\n        if(t->left->pri > t->right->pri){\n          t = rightRotate(t);\n        }else{\n          t = leftRotate(t);\n        }\n      }\n    }\n    if(key < t->key){\n      t->left = erase(t->left, key);\n    }else{\n      t->right = erase(t->right, key);\n    }\n    return t;\n  }\n\n  Node<T, S>* find(T key){\n    return find(root, key);\n  }\n  Node<T, S>* find(Node<T, S> *t, T key){\n    if(t == nullptr){\n      return nullptr;\n    }\n    if(t->key == key){\n      return t;\n    }\n    if(key < t->key){\n      return find(t->left, key);\n    }else{\n      return find(t->right, key);\n    }\n  }\n\n  Node<T, S> *rightRotate(Node<T, S> *t) {\n    Node<T, S> *s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n  }\n\n  Node<T, S> *leftRotate(Node<T, S> *t) {\n    Node<T, S> *s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;\n  }\n};\n\nint main() {\n  std::ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int N; cin >> N;\n  Treap<ll, ll> treap;\n  for(int loop = 0; loop < N; loop++){\n    char op[16];\n    cin >> op;\n    if(op[0] == 'i'){\n      int key, pri;\n      cin >> key >> pri;\n      treap.insert(key, pri);\n    }else if(op[0] == 'p'){\n      treap.inorder();\n      cout << '\\n';\n      treap.preorder();\n      cout << '\\n';\n    }else if(op[0] == 'f'){\n      int key; cin >> key;\n      if(treap.find(key) == nullptr){\n        cout << \"no\" << '\\n';\n      }else{\n        cout << \"yes\" << '\\n';\n      }\n    }else if(op[0] == 'd'){\n      int key; cin >> key;\n      treap.erase(key);\n    }else{\n      cout << \"Invalid Operation\" << endl;\n      assert(false);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point{\n\tint a,b;\n\tpoint *l,*r,*pa;\n\tpoint(){l=r=pa=NULL;}\n\tpoint(int aa,int bb):a(aa),b(bb){l=r=pa=NULL;};\n};\npoint *root;\npoint *rightRotate(point *t){\n\tpoint *s=t->l;\n\tt->l=s->r;\n\ts->r=t;\n\treturn s;\n}\npoint *leftRotate(point *t){\n\tpoint *s=t->r;\n\tt->r=s->l;\n\ts->l=t;\n\treturn s;\n}\npoint* insert(point *p,int a,int b){\n\tif(p==NULL)return new point(a,b);\n\tif(a==p->a)return p;\n\tif(a<p->a){\n\t\tp->l=insert(p->l,a,b);\n\t\tif(p->b<p->l->b)\n\t\t\tp=rightRotate(p);\n\t}else{\n\t\tp->r=insert(p->r,a,b);\n\t\tif(p->b<p->r->b)\n\t\t\tp=leftRotate(p);\n\t}return p;\n}\npoint *_del(point *p, int a);\npoint *del(point *p,int a){\n\tif(p==NULL)return NULL;\n\tif(a<p->a)p->l=del(p->l,a);\n\telse if(a>p->a)p->r=del(p->r,a);\n\telse return _del(p,a);\n\treturn p;\n}\npoint *_del(point *p, int a){\n\tif(p->l==NULL&&p->r==NULL)return NULL;\n\telse if(p->l==NULL)p=leftRotate(p);\n\telse if(p->r==NULL)p=rightRotate(p);\n\telse{\n\t\tif(p->l->b>p->r->b)p=rightRotate(p);\n\t\telse p=leftRotate(p);\n\t}return del(p,a);\n}\nbool find(int a){\n\tpoint *p=root;\n\twhile(p){\n\t\tif(a==p->a)return 1;\n\t\tif(a>p->a)p=p->r;\n\t\telse p=p->l;\n\t}\n\treturn 0;\n}\nvoid dfs1(point *p){\n\tif(!p)return;\n\tdfs1(p->l);\n\tprintf(\" %d\",p->a);\n\tdfs1(p->r);\n}\nvoid dfs2(point *p){\n\tif(!p)return;\n\tprintf(\" %d\",p->a);\n\tdfs2(p->l);\n\tdfs2(p->r);\n}\nint main(){\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\tint T;cin>>T;\n\tint ta,tb;\n\tstring s;\n\twhile(cin>>s){\n\t\tif(s==\"insert\"){\n\t\t\tcin>>ta>>tb;\n//\t\t\tif(!root)root=new point(ta,tb);\n//\t\t\telse \n\t\t\troot=insert(root,ta,tb);\n\t\t}else if(s==\"find\"){\n\t\t\tcin>>ta;\n\t\t\tif(find(ta))printf(\"yes\\n\");\n\t\t\telse printf(\"no\\n\");\n\t\t}else if(s==\"print\"){\n\t\t\tdfs1(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tdfs2(root);\n\t\t\tprintf(\"\\n\");\n\t\t}else if(s==\"delete\"){\n\t\t\tcin>>ta;\n\t\t\troot=del(root,ta);\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\ntypedef struct Node {\n    int k;\n    int p;\n    struct Node *left;\n    struct Node *right;\n} Node;\n\nNode *getNewNode(int k, int p){\n    static int i = 0;\n    static Node node[200000];\n    node[i].k = k;\n    node[i].p = p;\n    node[i].left = nullptr;\n    node[i].right = nullptr;\n    return &node[i++];\n}\n\nNode *rightRotate(Node *t){\n    Node *s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n}\n\nNode *leftRotate(Node *t){\n    Node *s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;\n}\n\nNode *insert(Node *t, int k, int p){\n    if(t == nullptr){\n        return getNewNode(k, p);\n    } else if(k < t->k){\n        t->left = insert(t->left, k, p);\n        if(t->p < t->left->p){\n            t = rightRotate(t);\n        }\n    } else if(k > t->k){\n        t->right = insert(t->right, k, p);\n        if(t->p < t->right->p){\n            t = leftRotate(t);\n        }\n    }\n    return t;\n}\nNode *delete_(Node *t, int k);\nNode *_delete(Node *t, int k){\n    if(t->left == nullptr && t->right == nullptr){\n        return nullptr;\n    } else if(t->left == nullptr){\n        t = leftRotate(t);\n    } else if(t->right == nullptr){\n\tt = rightRotate(t);\n    } else {\n        if(t->left->p > t->right->p){\n            t = rightRotate(t);\n        } else {\n            t = leftRotate(t);\n        }\n    }\n    return delete_(t, k);\n}\n\nNode *delete_(Node *t, int k){\n    if(t == nullptr){\n        return nullptr;\n    }\n    if(k < t->k){\n        t->left = delete_(t->left, k);\n    } else if(k > t->k){\n        t->right = delete_(t->right, k);\n    } else {\n        return _delete(t, k);\n    }\n    return t;\n}\nNode *find(Node *t, int k){\n    if(t == nullptr){\n        return nullptr;\n    }\n    if(k < t->k) return find(t->left, k);\n    else if(k > t->k) return find(t->right, k);\n    else return t;\n}\n\nvoid print_inorder(Node *t){\n    if(t == nullptr) return;\n    print_inorder(t->left);\n    std::printf(\" %d\", t->k);\n    print_inorder(t->right);\n}\n\nvoid print_preorder(Node *t){\n    if(t == nullptr) return;\n    std::printf(\" %d\", t->k);\n    print_preorder(t->left);\n    print_preorder(t->right);\n}\n\nint main(){\n    int n;\n    std::scanf(\"%d\", &n);\n    Node *root = nullptr;\n\n    for(int i = 0; i < n; ++i){\n\tchar op[8];\n\tstd::scanf(\"%s\", op);\n\tif(std::strncmp(op, \"insert\", 6) == 0){\n            int k;\n            std::scanf(\"%d\", &k);\n            int p;\n            std::scanf(\"%d\", &p);\n            root = insert(root, k, p);\n\t} else if(std::strncmp(op, \"delete\", 6) == 0){\n            int k;\n            std::scanf(\"%d\", &k);\n            root = delete_(root, k);\n\t} else if(std::strncmp(op, \"find\", 4) == 0){\n            int k;\n            std::scanf(\"%d\", &k);\n            if(find(root, k) != nullptr){\n\t\tstd::printf(\"yes\\n\");\n            } else {\n\t\tstd::printf(\"no\\n\");\n            }\n\t} else if(std::strncmp(op, \"print\", 5) == 0){\n            print_inorder(root);\n            std::printf(\"\\n\");\n            print_preorder(root);\n            std::printf(\"\\n\");\n\t}\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstruct Node{\n\tNode *parent, *left, *right;\n\tint key, priority;\n};\n\nNode *deleteN(Node*,int);\n\nNode *root, *NIL;\n\n\nNode *rightRotate(Node *t){\n\tNode *s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\n\nNode *leftRotate(Node *t){\n\tNode *s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\n\nNode *insert(Node *t,int key, int priority){\n\tif(t == NIL){//cout<<key<<\" \"<<priority<<endl;\n\t\tNode *temp;\n\t\ttemp = new Node;\n\t\ttemp->key = key;\n\t\ttemp->priority = priority;\n\t\ttemp->left = NIL;\n\t\ttemp->right = NIL;\n\t\treturn temp;\n\t}\n\tif(key == t->key){\n\t\treturn t;\n\t}\n\t\n\tif(key < t->key){\n\t\tt->left = insert(t->left, key, priority);\n\t\tif(t->priority < t->left->priority)\n\t\t\tt = rightRotate(t);\n\t} else {\n\t\tt->right = insert(t->right, key, priority);\n\t\tif(t->priority < t->right->priority)\n\t\t\tt = leftRotate(t);\n\t}\n\treturn t;\n}\n\nbool find(Node *t, int key){\n\twhile(t != NIL && key != t->key){\n\t\tif(key < t->key) t = t->left;\n\t\telse t = t->right;\n\t}\n\treturn t!=NIL;\n}\n\nvoid inorder(Node *t){\n\tif(t == NIL) return;\n\tcout<<\" \"<<t->key;\n\tinorder(t->left);\n\tinorder(t->right);\n}\n\nvoid preorder(Node *t){\n\tif(t == NIL)return;\n\tpreorder(t->left);\n\tcout<<\" \"<<t->key;\n\tpreorder(t->right);\n}\n\nvoid print(Node *t){\n\tpreorder(t);\n\tcout<<endl;\n\tinorder(t);\n\tcout<<endl;\n}\n\nNode *_delete(Node *t, int key){\n\tif(t->left == NIL && t->right == NIL){\n\t\tif(t->parent != NIL){\n\t\t\tif(t->parent->left->key == key) t->parent->left = NIL;\n\t\t\telse t->parent->right = NIL;\n\t\t}\n\t\t//delete t;\n\t\treturn NIL;\n\t}else if(t->left == NIL)\n\t\tt = leftRotate(t);\n\telse if(t->right == NIL)\n\t\tt = rightRotate(t);\n\telse {\n\t\tif(t->left->priority > t->right->priority)\n\t\t\tt = rightRotate(t);\n\t\telse\n\t\t\tt = leftRotate(t);\n\t}\n\treturn deleteN(t,key);\n}\n\nNode *deleteN(Node *t, int key){\n\tif(t == NIL)\n\t\treturn NIL;\n\tif(key < t->key)\n\t\tt->left = deleteN(t->left, key);\n\telse if(key > t->key)\n\t\tt->right = deleteN(t->right, key);\n\telse \n\t\treturn _delete(t,key);\n\treturn t;\n}\n\nint main(){\n\tint n, k, p;\n\tstring order;\n\t\n\tcin>>n;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin>>order;\n\t\t\n\t\tif(order == \"insert\"){\n\t\t\tcin>>k>>p;\n\t\t\troot = insert(root,k,p);\n\t\t} else if(order == \"find\"){\n\t\t\tcin>>k;\n\t\t\tcout<<(find(root,k)?\"yes\":\"no\")<<endl;\n\t\t} else if(order == \"delete\"){\n\t\t\tcin>>k;\n\t\t\troot = deleteN(root,k);\n\t\t} else if(order == \"print\"){\n\t\t\tprint(root);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define NIL NULL\n#define INF 1000000001\n\nusing namespace std;\n\nstruct node {\n    int key,priority;\n    struct node *right;\n    struct node *left;\n};\n\ntypedef node * Node;\n\n\nNode delete_(Node t,int key);\nNode _delete(Node t,int key);\n\nNode rightRotate(Node t){\n    Node s = t->left;\n    t->left  = s->right;\n    s->right = t;\n    return s;\n}\n\nNode leftRotate(Node t){\n    Node s = t->right;\n    t->right = s->left;\n    s->left  = t;\n    return s;\n}\n\nNode insert(Node t,int key,int priority){\n    if(t == NIL){\n        t = (Node)malloc(sizeof(struct node));\n        t->key = key;\n        t->priority = priority;\n        t->left = NIL;t->right = NIL;\n    }else if(t->key == key) return NIL; \n\n    if(key < t->key){\n        t->left = insert(t->left,key,priority);\n        if(t->priority < t->left->priority) t = rightRotate(t);\n    }else if(key > t->key){\n        t->right = insert(t->right,key,priority);\n        if(t->priority < t->right->priority)t = leftRotate(t);\n    }\n    return t;\n}\n\nNode delete_(Node t,int key){\n    if(t == NIL) return NIL;\n    if(key < t->key) t->left = delete_(t->left,key);\n    else if(key > t->key) t->right = delete_(t->right,key);\n    else return _delete(t,key);\n    return t;\n}\n\nNode _delete(Node t,int key){\n    if(t->left ==NIL && t->right == NIL) return NIL;\n    else if(t->left == NIL) t  = leftRotate(t);\n    else if(t->right== NIL) t  = rightRotate(t);\n    else{\n        if(t->left->priority < t->right->priority) t = leftRotate(t);\n        else t = rightRotate(t);\n    }\n    return delete_(t,key);\n}\n\nNode findElement(Node current_node,int v){\n    if(current_node == NIL) return NIL;\n    else if(current_node->key == v) return current_node;\n    else if(current_node->key > v) return findElement(current_node->left, v);\n    else if(current_node->key < v) return findElement(current_node->right,v);\n}\n\n\nvoid inOrder(Node current_node){\n    if(current_node == NIL) return;\n    inOrder(current_node->left);\n    printf(\" %d\",current_node->key);\n    inOrder(current_node->right);\n}\n\nvoid preOrder(Node current_node){\n    printf(\" %d\",current_node->key);\n    if(current_node->left != NIL)        preOrder(current_node->left);\n    if (current_node->right != NIL) preOrder(current_node->right);\n}\n\n\nint main(){\n    int num_query;\n    char command[20];\n    Node root = NIL;\n    \n    int key,priority;\n    scanf(\"%d\",&num_query);\n    for(int i = 0;i < num_query;i++){\n        scanf(\"%s\",command);\n        if(command[0] == 'i'){\n            scanf(\"%d %d\",&key,&priority);\n            root = insert(root,key,priority);\n        }else if(command[0] == 'f'){\n            scanf(\"%d\",&key);\n            if(findElement(root,key)!=NIL) printf(\"yes\\n\");\n            else printf(\"no\\n\");\n        }else if(command[0] == 'p'){\n            inOrder(root);printf(\"\\n\");\n            preOrder(root);printf(\"\\n\");\n        }else if(command[0] == 'd'){\n            scanf(\"%d\",&key);\n            root = delete_(root,key);\n        }\n    }\n    return 0;   \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstruct node{\n  node* right;\n  node* left;\n  int key,priority;\n};\n\n  \nnode* rightRotate(node* t) {\n  node* s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\n\nnode* leftRotate(node* t) {\n  node* s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\nnode* newNode(int key, int priority){\n  node* t = new node;\n  t->left=NULL; t->right = NULL;\n  t->key = key; t->priority = priority;\n  return t;\n}\n\nnode* insert(node* t, int key, int priority) {\n  if(t == NULL) return newNode(key,priority);\n\n  if(key == t->key) return t;\n\n  if(key < t->key) {\n    t->left = insert(t->left, key, priority);\n    if(t->priority < t->left->priority) t = rightRotate(t);\n  }else{\n    t->right = insert(t->right, key, priority);\n    if(t->priority < t->right->priority) t = leftRotate(t);\n  }\n  return t;\n}\nnode* _delete(node*,int);\nnode* mydelete(node* t, int key){\n  if(t == NULL) return NULL;\n  if(key < t->key) t->left = mydelete(t->left, key);\n  else if(key > t->key) t->right = mydelete(t->right, key);\n  else return _delete(t, key);\n  return t;\n}\n\nnode* _delete(node* t, int key){\n  if(t->left == NULL && t->right == NULL) return NULL;\n  else if(t->left == NULL) t = leftRotate(t);\n    else if(t->right == NULL) t = rightRotate(t);\n    else {\n      if(t->left->priority > t->right->priority) t = rightRotate(t);\n      else t = leftRotate(t);\n    }\n    return mydelete(t,key);\n}\n\n\nvoid find(node* t, int key) {\n  while(t != NULL && key != t->key) {\n    if(key < t->key) t = t->left;\n    else t = t->right;\n  }\n  if(t == NULL) cout << \"no\" << endl;\n  else cout << \"yes\" << endl;\n}\n\nvoid inorder(node* t) {\n  if(t==NULL) return;\n  inorder(t->left);\n  cout << \" \" << t->key;\n  inorder(t->right);\n}\n\nvoid preorder(node* t) {\n  if(t == NULL) return;\n  cout << \" \" << t->key;\n  preorder(t->left);\n  preorder(t->right);\n}\n\nint main() {\n  node* root=NULL;\n  int n,key,priority;\n  string s;\n  \n  cin >> n;\n  for(int i=0; i<n; i++) {\n    cin >> s;\n    if(s == \"insert\") {\n      cin >> key >> priority;\n      root = insert(root, key, priority);\n    }\n    else if(s == \"find\") {\n      cin >> key;\n      find(root, key);\n    }\n    else if(s == \"delete\") {\n      cin >> key;\n      root = mydelete(root, key);\n    }\n    else if(s == \"print\"){\n      inorder(root);\n      cout << endl;\n      preorder(root);\n      cout << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\n#define track(); cout<<\"#############\"<<endl;\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\ntypedef struct node{\n  struct node *l=NULL;\n  struct node *r=NULL;\n  int key=0;\n  int pri=0;\n}Node;\n\nNode* RightRotate(Node *t){\n  Node *s=t->l;\n  t->l=s->r;\n  s->r=t;\n  return s;\n}\n\nNode* LeftRotate(Node *t){\n  Node *s=t->r;\n  t->r=s->l;\n  s->l=t;\n  return s;\n}\n\nNode* ins(Node* t,int key,int pri){\n  if(t==NULL){\n    t=(Node*)malloc(sizeof(Node));\n    t->l=NULL;\n    t->r=NULL;\n    t->key=key;\n    t->pri=pri;\n    return t;\n  }\n  if(key==t->key)return t;\n  if(key<t->key){\n    t->l = ins(t->l,key,pri);\n    if(t->pri < t->l->pri)t=RightRotate(t);\n  }\n  else {\n    t->r = ins(t->r,key,pri);\n    if(t->pri < t->r->pri)t=LeftRotate(t);\n  }\n  return t;\n}\n\nbool find(Node *t,int key){\n  if(t==NULL)return false;\n  if(t->key==key)return true;\n  if(key<t->key)return find(t->l,key);\n  return find(t->r,key);\n}\n\nNode* del(Node *t,int key){\n  if(t==NULL)return NULL;\n  if(key==t->key){\n    if(t->l==NULL && t->r==NULL){\n      return NULL;\n    }\n    else if(t->l==NULL){\n      t=LeftRotate(t);\n    }\n    else if(t->r==NULL){\n      t=RightRotate(t);\n    }\n    else {\n      if(t->l->pri >t->r->pri)\n        t=RightRotate(t);\n      else \n        t=LeftRotate(t);\n    }\n    return del(t,key);\n  }\n\n  if(key<t->key)\n    t->l = del(t->l,key);\n  else \n    t->r = del(t->r,key);\n  return t;\n}\n\nvoid inorder(node *t){\n  if(t->l != NULL)inorder(t->l);\n//  cout<<\" \"<<t->key;\n  printf(\" %d\",t->key);\n  if(t->r != NULL)inorder(t->r);\n}\n\nvoid preorder(node *t){\n  printf(\" %d\",t->key);\n  //cout<<\" \"<<t->key;\n  if(t->l != NULL)preorder(t->l);\n  if(t->r != NULL)preorder(t->r);\n}\n\nint main()\n{\n  int n,a,b;\n  string s;\n  Node *t=NULL;\n  cin>>n;\n  FOR(i,0,n){\n    cin>>s;\n    if(s==\"insert\"){\n      cin>>a>>b;\n      t=ins(t,a,b);\n    }\n    else if(s==\"find\"){\n      cin>>a;\n      if(find(t,a))cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n    }\n    else if(s==\"delete\"){\n      cin>>a;\n      t=del(t,a);\n    }\n    else {\n      inorder(t);\n      cout<<endl;\n      preorder(t);\n      cout<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cstdio>\n\nclass Treap{\npublic:\n  struct Node{\n    int key;\n    int priority;\n    int size;\n    Node *parent, *left, *right;\n\n    void refresh(){\n      size = 1;\n      if(left != nullptr) size += left->size;\n      if(right != nullptr) size += right->size;\n    }\n    \n    Node():key(-1), priority(-1), parent(nullptr), left(nullptr), right(nullptr){refresh();};\n    Node(int key,int priority,Node *parent):\n      key(key), priority(priority), parent(parent), left(nullptr), right(nullptr){refresh();};\n\n    Node(int key,int priority, Node *parent,Node *left,Node *right):\n      key(key), priority(priority), parent(parent), left(left), right(right){refresh();};\n  };\n  \n  int n;\n  Node *root;\n  Treap():n(0){}\n  int size(){return n;}\n  int size(Node *t){return t == nullptr? 0:t->size;}\n  int empty(){return n == 0;}\n  \n  Node* rightRotate(Node *y){\n    Node *x = y->left;\n    y->left = x->right;\n    x->right = y;\n\n    x->parent = y->parent;\n    y->parent = x;\n\n    y->refresh(), x->refresh();\n    return x;\n  }\n\n  Node* leftRotate(Node *x){\n    Node *y = x->right;\n    x->right = y->left;\n    y->left = x;\n    \n    y->parent = x->parent;\n    x->parent = y;\n\n    x->refresh(), y->refresh();\n    return y;\n  }\n\n  Node* insert(Node *t,int key,int priority, Node *parent = nullptr){\n    if(t == nullptr){n++; return new Node(key, priority, parent);}\n    \n    if(key == t->key) return t;\n    \n    if(key < t->key){\n      t->left = insert(t->left, key, priority,  t);\n      if( t->priority < t->left->priority ) t = rightRotate(t);\n    }\n    else{\n      t->right = insert(t->right, key, priority, t);\n      if( t->priority < t->right->priority ) t = leftRotate(t);\n    }\n    return t;\n  }\n\n  Node* insert(int key,int priority){\n    if(n == 0){n++; return root = new Node(key, priority, nullptr);}\n    return root = insert(root, key, priority);\n  }\n\n  Node* erase(Node *t,int key){\n    if( t == nullptr) return nullptr;\n    if(key == t->key) return _erase(t, key);\n    \n    if(key < t->key ) t->left = erase(t->left, key);\n    else if(key > t->key ) t->right = erase(t->right, key);\n    return t;\n  }\n  \n  Node* _erase(Node *t,int key){\n    if(t->left == nullptr && t->right == nullptr) {\n      n--;\n      delete t;\n      return nullptr;\n    }\n    \n    if(t->left == nullptr) t = leftRotate(t);\n    else if(t->right == nullptr) t = rightRotate(t);\n    else {\n      if( t->left->priority > t->right->priority ) t = rightRotate(t);\n      else t = leftRotate(t);\n    }\n    \n    return erase(t, key);\n  }\n\n  void erase(int key){root = erase(root, key);}\n\n  Node* find(Node *t,int key){\n    if( t == nullptr) return nullptr;\n    if(key < t->key ) return find(t->left, key);\n    if(key > t->key ) return find(t->right, key);\n    return t;\n  }\n\n  Node* find(int key){return find(root, key);}\n\n  Node* getKthNode(Node *t, int K){\n    if(K == 0) return t;\n    if(size(t->left) <= K) return getKthNode(t->left, K);\n    return getKthNode(t->right, K - size(t->left)+1);\n  }\n\n  Node* getKthNode(int K){\n    assert(K < n);\n    return getKthNode(root, K);\n  }\n  \n  void print(Node* t,int a=0,int b=0,int c=0){\n    if(t == nullptr) return;\n    if(a) printf(\" %d\", t->key);\n    if(t->left != nullptr) print(t->left, a, b, c);\n    if(b) printf(\" %d\", t->key);\n    if(t->right != nullptr) print(t->right, a, b, c);\n    if(c) printf(\" %d\", t->key);\n  }\n  \n  void print(){\n    print(root, 0, 1, 0);printf(\"\\n\");\n    print(root, 1, 0, 0);printf(\"\\n\");\n  }\n    \n};\n\nsigned main(){\n  Treap T;\n  \n  int n;\n  scanf(\"%d\", &n);\n  while(n--){\n    char str[100];\n    scanf(\"%s\", str);\n    \n    if(str[0] == 'i'){\n      int key, priority;\n      scanf(\"%d%d\", &key, &priority);\n      T.insert(key, priority);\n    }\n    \n    if(str[0] == 'f'){\n      int key;\n      scanf(\"%d\", &key);\n      int ans = T.find(key) != nullptr;\n      printf(\"%s\\n\", (ans?\"yes\":\"no\"));\n    }\n    \n    if(str[0] == 'd'){\n      int key;\n      scanf(\"%d\", &key);\n      T.erase(key);\n    }\n    if(str[0] == 'p'){\n      T.print();\n    }\n  }\n  \n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nstruct node{\n  node* right;\n  node* left;\n  int key,pri;\n};\n\nnode* rightRotato(node* t) {\n    node* s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n}\n\nnode* leftRotato(node* t) {\n    node* s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;\n}\n\nnode* insert(node* t, int key, int pri) {\n    if(t == NULL) {\n        node* t = new node;\n        t->left=NULL; t->right = NULL;\n        t->key = key; t->pri = pri;\n        return t;\n    }\n    if(key == t->key) return t;\n\n    if(key < t->key) {\n        t->left = insert(t->left, key, pri);\n        if(t->pri < t->left->pri) t = rightRotato(t);\n    }\n    else {\n        t->right = insert(t->right, key, pri);\n        if(t->pri < t->right->pri) t = leftRotato(t);\n    }\n    return t;\n}\n\nnode* erase(node* t, int key){\n    if(t == NULL) return NULL;\n\n    if(key == t->key) {\n        if(t->left == NULL && t->right == NULL) return NULL;\n        else if(t->left == NULL) t = leftRotato(t);\n        else if(t->right == NULL) t = rightRotato(t);\n        else {\n            if(t->left->pri > t->right->pri) t = rightRotato(t);\n            else t = leftRotato(t);\n        }\n        return erase(t,key);\n    }\n    if(key < t->key) t->left = erase(t->left, key);\n    else t->right = erase(t->right, key);\n    return t;\n}\n\nvoid find(node* t, int key) {\n    while(t != NULL && key != t->key) {\n        if(key < t->key) t = t->left;\n        else t = t->right;\n    }\n    if(t == NULL) cout << \"no\" << endl;\n    else cout << \"yes\" << endl;\n}\n\nvoid inorder(node* t) {\n    if(t==NULL) return;\n    inorder(t->left);\n    cout << \" \" << t->key;\n    inorder(t->right);\n}\n\nvoid preorder(node* t) {\n    if(t == NULL) return;\n    cout << \" \" << t->key;\n    preorder(t->left);\n    preorder(t->right);\n}\n\nint main() {\n    node* root=NULL;\n    int n,key,pri;\n    string s;\n\n    cin >> n;\n    for(int i=0; i<n; i++) {\n        cin >> s;\n        if(s == \"insert\") {\n            cin >> key >> pri;\n            root = insert(root, key, pri);\n        }\n        else if(s == \"delete\") {\n            cin >> key;\n            root = erase(root, key);\n        }\n        else if(s == \"find\") {\n            cin >> key;\n            find(root, key);\n        }\n        else {\n            inorder(root);\n            cout << endl;\n            preorder(root);\n            cout << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef struct Node{\n  int value, priority;\n  Node *left, *right;\n} Node;\n\nNode* Delete(Node *, int);\nNode* _delete(Node *, int);\n\nNode *NIL,*root;\n\nNode* rightRotate(Node *t){\n  Node *s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\nNode* makenode(int key, int priority){\n  Node *node = (Node *)malloc(sizeof(Node));\n  node->value = key;\n  node->priority = priority;\n  node->left = node->right = NIL;\n  return node;\n}\nNode* leftRotate(Node *t){\n  Node *s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s; \n}\n\nNode* insert(Node *t, int key, int priority){    \n  Node *x;\n\n  if(t == NIL) return x = makenode(key, priority); \n\n  if(key == t->value) return t;                \n\n  if(key < t->value){                          \n    t->left = insert(t->left, key, priority); \n    if(t->priority < t->left->priority) t = rightRotate(t); \n  }else{                                      \n    t->right = insert(t->right, key, priority); \n    if(t->priority < t->right->priority) {\n        t = leftRotate(t); \n    }\n  }\n\n  return t;\n}\nNode* find(Node *x, int k){\n  if(x == NIL || x->value == k) return x;\n\n  if(k < x->value) return find(x->left, k);\n  else return find(x->right, k);\n}\nNode* Delete(Node *t, int key){\n  if(t == NIL) return NIL;\n  if(key < t->value) t->left = Delete(t->left, key); \n  else if(key > t->value) t->right = Delete(t->right, key);\n  else return _delete(t, key);\n  return t;\n}\n\nNode* _delete(Node *t, int key){ \n  if(t->left == NIL && t->right == NIL) return NIL; \n  else if(t->left == NIL) t = leftRotate(t);   \n  else if(t->right == NIL) t = rightRotate(t); \n  else{                                     \n    if(t->left->priority > t->right->priority) \n    t = rightRotate(t); \n    else\n    t = leftRotate(t);\n  }\n  return Delete(t, key);\n}\n\nvoid preParse(Node *node){\n  if(node == NIL) return ;\n\n  cout<<\" \"<< node->value;\n  if(node->left != NIL) preParse(node->left);\n  if(node->right != NIL) preParse(node->right);\n}\n\nvoid inParse(Node *node){\n  if(node == NIL) return ;\n\n  if(node->left != NIL) {\n      inParse(node->left);\n  }\n  cout<<\" \"<<node->value;\n  if(node->right != NIL) {\n      inParse(node->right);\n  }\n}\n\nint main(){\n  int n,key,priority;\n  string command;\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>command;\n    if(command==\"insert\"){\n      cin>>key>>priority;\n      root=insert(root,key,priority);\n    }else if(command==\"print\"){\n      inParse(root);\n      cout<<endl;\n      preParse(root);\n      cout<<endl;\n    }else if(command==\"find\"){\n      cin>>key;\n      if(find(root,key)) cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n    }else if(command==\"delete\"){\n      cin>>key;\n      root=Delete(root,key);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\ntypedef struct Node{\n  Node* right;\n  Node* left;\n  int key, priority;\n}Node;\n\n\n\nNode* rightRotate(Node* t){\n  Node* s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\n\nNode* leftRotate(Node* t){\n  Node* s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\n\nNode* insert(Node* t, int key, int priority){\n  if(t == nullptr){\n    Node* s = new Node;\n    s -> key = key;\n    s -> priority = priority;\n    s -> left = s->right = nullptr;\n    \n    return s;\n  }\n  if(key == t->key){\n    return t;\n  }\n\n\n  if( key < t->key){\n    t->left = insert( t->left , key , priority);\n    if( t->priority < t->left->priority )\n      t = rightRotate(t);\n  }\n  else{\n    t->right = insert(t->right , key, priority);\n    if( t->priority < t->right->priority )\n      t = leftRotate(t);\n  }\n  return t;\n}\n\nNode* _deleteNode(Node* t, int key);\n\nNode* deleteNode(Node* t, int key){\n  if( t == nullptr )\n    return nullptr;\n  if(key < t->key)\n    t->left = deleteNode(t->left , key);\n  else if(key > t->key)\n    t->right = deleteNode(t->right , key);\n  else\n    return _deleteNode(t,key);\n\n  return t;\n}\n\nNode* _deleteNode(Node* t, int key){\n\n  if(t->left == nullptr && t->right == nullptr )\n    return nullptr;\n\n  else if( t->left == nullptr )\n    t = leftRotate(t);\n\n  else if( t->right == nullptr )\n    t = rightRotate(t);\n\n  else{\n    if( t->left->priority > t->right->priority )\n      t = rightRotate(t);\n    else\n      t = leftRotate(t);\n  }\n  return deleteNode(t,key);\n}\n\n\n\nNode* find(Node* t, int key){\n  if(t==nullptr)return t;\n  if(t->key == key)return t;\n  if(t->key <  key)return find(t->right , key);\n  else return find(t->left , key);\n}\n\n\nvoid inorder_print(Node* t){\n  if(t == nullptr)return;\n  inorder_print(t->left);\n  cout << \" \" << t->key;\n  inorder_print(t->right);\n}\n\n\nvoid preorder_print(Node* t){\n  if(t == nullptr)return;\n  cout << \" \" << t->key;\n  preorder_print(t->left);\n  preorder_print(t->right);\n}\n\n\n//===  For Test ====\nbool bintree_check(Node* t){\n  if(t == nullptr)return true;\n  if(t->left != nullptr){\n    if( t->left->key >= t->key )return false;\n    if( ! bintree_check(t->left) ) return false;\n  }\n  if(t->right != nullptr){\n    if( t->right->key <= t->key )return false;\n    if( ! bintree_check(t->right) ) return false;\n  }\n  return true;\n}\n\nbool heap_check(Node* t){\n  if(t == nullptr)return true;\n\n  if(t->left != nullptr){\n    if( t->left->priority >= t->priority )return false;\n    if( ! heap_check(t->left) ) return false;\n  }\n\n  if(t->right != nullptr){\n    if( t->right->priority >= t->priority )return false;\n    if( ! heap_check(t->right) ) return false;\n  }\n\n  return true;\n}\n\n\n//============================================\n\n\nint main(){\n\n  string com;\n  int k,p;\n  int n;\n\n  Node* root = nullptr;\n\n  \n  cin >> n;\n\n  for(int i=0; i<n; i++){\n    cin >> com;\n\n    if(com == \"insert\"){\n      cin >> k >> p;\n      root = insert(root, k, p);\n    }\n\n    else if(com == \"delete\"){\n      cin >> k;\n      root = deleteNode(root, k);\n    }\n\n    else if(com == \"find\"){\n      cin >> k;\n      if( find(root, k) == nullptr ) cout << \"no\" << endl;\n      else cout << \"yes\" << endl;\n    }\n\n    else if(com == \"print\"){\n      inorder_print(root); cout << endl;\n      preorder_print(root); cout << endl;\n    }\n\n    //if( !bintree_check(root) )cout << \"BST Error\" << endl;\n    //if( !heap_check(root) )cout << \"Heap Error\" << endl;\n  }\n\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct point{\n\tint a,b;\n\tpoint *l,*r,*pa;\n\tpoint(){l=r=pa=NULL;}\n\tpoint(int aa,int bb):a(aa),b(bb){l=r=pa=NULL;};\n};\npoint *root;\npoint *rightRotate(point *t){\n\tpoint *s=t->l;\n\tt->l=s->r;\n\ts->r=t;\n\treturn s;\n}\npoint *leftRotate(point *t){\n\tpoint *s=t->r;\n\tt->r=s->l;\n\ts->l=t;\n\treturn s;\n}\npoint* insert(point *p,int a,int b){\n\tif(p==NULL)return new point(a,b);\n\tif(a==p->a)return p;\n\tif(a<p->a){\n\t\tp->l=insert(p->l,a,b);\n\t\tif(p->b<p->l->b)\n\t\t\tp=rightRotate(p);\n\t}else{\n\t\tp->r=insert(p->r,a,b);\n\t\tif(p->b<p->r->b)\n\t\t\tp=leftRotate(p);\n\t}return p;\n}\npoint *_del(point *p, int a);\npoint *del(point *p,int a){\n\tif(p==NULL)return NULL;\n\tif(a<p->a)p->l=del(p->l,a);\n\telse if(a>p->a)p->r=del(p->r,a);\n\telse return _del(p,a);\n\treturn p;\n}\npoint *_del(point *p, int a){\n\tif(p->l==NULL&&p->r==NULL)return NULL;\n\telse if(p->l==NULL)p=leftRotate(p);\n\telse if(p->r==NULL)p=rightRotate(p);\n\telse{\n\t\tif(p->l->b>p->r->b)p=rightRotate(p);\n\t\telse p=leftRotate(p);\n\t}return del(p,a);\n}\nbool find(int a){\n\tpoint *p=root;\n\twhile(p){\n\t\tif(a==p->a)return 1;\n\t\tif(a>p->a)p=p->r;\n\t\telse p=p->l;\n\t}\n\treturn 0;\n}\nvoid dfs1(point *p){\n\tif(!p)return;\n\tdfs1(p->l);\n\tprintf(\" %d\",p->a);\n\tdfs1(p->r);\n}\nvoid dfs2(point *p){\n\tif(!p)return;\n\tprintf(\" %d\",p->a);\n\tdfs2(p->l);\n\tdfs2(p->r);\n}\nint main(){\n\tint T,ta,tb;\n\tcin>>T;\n\tstring s;\n\twhile(cin>>s){\n\t\tif(s==\"insert\"){\n\t\t\tcin>>ta>>tb;\n\t\t\troot=insert(root,ta,tb);\n\t\t}else if(s==\"find\"){\n\t\t\tcin>>ta;\n\t\t\tprintf(find(ta)?\"yes\\n\":\"no\\n\");\n\t\t}else if(s==\"print\"){\n\t\t\tdfs1(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tdfs2(root);\n\t\t\tprintf(\"\\n\");\n\t\t}else if(s==\"delete\"){\n\t\t\tcin>>ta;\n\t\t\troot=del(root,ta);\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nstruct Node {\n  ll value;\n  ll priority;\n  Node *left = nullptr,\n       *right = nullptr,\n       *parent = nullptr;\n\n  Node(ll value = 0, ll priority = 0): value(value), priority(priority) {}\n};\n\nclass BST {\n  Node *root = nullptr;\n\n  string tos_pre(Node *nd) {\n    string s = \"\";\n\n    s += \" \" + to_string(nd->value);\n    if (nd->left) s += tos_pre(nd->left);\n    if (nd->right) s += tos_pre(nd->right);\n\n    return s;\n  }\n\n  string tos_in(Node *nd) {\n    string s = \"\";\n\n    if (nd->left) s += tos_in(nd->left);\n    s += \" \" + to_string(nd->value);\n    if (nd->right) s += tos_in(nd->right);\n\n    return s;\n  }\n  \n  Node *find_partial(ll value, Node *nd) {\n    if (!nd) return nullptr;\n    if (nd->value == value) return nd;\n    \n    return nd->value > value\n      ? find_partial(value, nd->left)\n      : find_partial(value, nd->right);\n  }\n  \n  Node *get_min(Node *x) {\n    while (x->left) x = x->left;\n    return x;\n  }\n\n  Node *get_successor(Node *x) {\n    if (x->right) return get_min(x->right);\n\n    auto y = x->parent;\n    while (y && x == y->right) {\n      x = y;\n      y = y->parent;\n    }\n\n    return y;\n  }\n\n  Node *rotate_right(Node *t) {\n    auto s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n  }\n\n  Node *rotate_left(Node *t) {\n    auto s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;\n  }\n  \n  Node *del_inner(Node *t, ll value) {\n    if (!t->left && !t->right) return nullptr;\n    else if (!t->left) t = rotate_left(t);\n    else if (!t->right) t = rotate_right(t);\n    else {\n      if (t->left->priority > t->right->priority) t = rotate_right(t);\n      else t = rotate_left(t);\n    }\n\n    return del(t, value);\n  }\n\npublic:\n  void insert(ll value, ll priority) {\n    auto t = insert(root, value, priority);\n    if (!root || root->priority < priority) root = t; \n  }\n\n  Node *insert(Node *t, ll value, ll priority) {\n    if (!t) return new Node(value, priority);\n    if (t->value == value) return t;\n    \n    if (t->value > value) {\n      t->left = insert(t->left, value, priority);\n      if (t->priority < t->left->priority) t = rotate_right(t);\n    } else {\n      t->right = insert(t->right, value, priority);\n      if (t->priority < t->right->priority) t = rotate_left(t);\n    }\n      \n    return t;\n  }\n\n  Node *find(ll value) {\n    return find_partial(value, root); \n  }\n  \n  void del(ll value) {\n    root = del(root, value);\n  }\n\n  Node *del(Node *t, ll value) {\n    if (!t) return nullptr; \n    if (t->value > value) t->left = del(t->left, value);\n    else if (t->value < value) t->right = del(t->right, value);\n    else return del_inner(t, value);\n    return t;\n  }\n  \n  string print_pre() {\n    return tos_pre(root);\n  }\n\n  string print_in() {\n    return tos_in(root);\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  \n  auto bst = BST();\n  rep(i, n) {\n    string cmd;\n    cin >> cmd;\n    \n    if (cmd == \"print\") {\n      cout << bst.print_in() << endl;\n      cout << bst.print_pre() << endl;\n    } else {\n      ll value;\n      cin >> value;\n      \n      if (cmd == \"find\" || cmd == \"delete\") {\n        if (cmd == \"find\")\n          cout << (bst.find(value) ? \"yes\" : \"no\") << endl;\n        else bst.del(value);\n      } else {\n        ll priority;\n        cin >> priority;\n\n        bst.insert(value, priority);\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<typeinfo>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\n\nstruct tree{\n\n    struct node{\n        ll a;\n        ll p;\n        node* l;\n        node* r;\n    };\n    \n    node NIL={-1,-1,NULL,NULL};\n    node* root=&NIL;\n    \n    tree(){\n        NIL.r=NIL.l=&NIL;\n    }\n\n    /*\n     rightRotate(Node t)\n     Node s = t.left\n     t.left = s.right\n     s.right = t\n     return s // root of the subtree\n     leftRotate(Node t)\n     Node s = t.right\n     t.right = s.left\n     s.left = t\n     return s // root of the subtree\n     */\n    \n    \n    node & Rrotate(node &t){\n        node &s=*t.l;\n        t.l=s.r;\n        s.r=&t;\n        return s;\n    }\n\n    node & Lrotate(node &t){\n        node &s=*t.r;\n        t.r=s.l;\n        s.l=&t;\n        return s;\n    }\n\n    /*\n     insert(Node t, int key, int priority)            // 再帰的に探索\n     if t == NIL\n     return Node(key, priority)               // 葉に到達したら新しい節点を生成して返す\n     if key == t.key\n     return t                                 // 重複したkeyは無視\n     \n     if key < t.key                               // 左の子へ移動\n     t.left = insert(t.left, key, priority)   // 左の子へのポインタを更新\n     if t.priority < t.left.priority          // 左の子の方が優先度が高い場合右回転\n     t = rightRotate(t)\n     else                                         // 右の子へ移動\n     t.right = insert(t.right, key, priority) // 右の子へのポインタを更新\n     if t.priority < t.right.priority         // 右の子の方が優先度が高い場合左回転\n     t = leftRotate(t)\n     \n     return t\n     */\n    \n    node & insert(ll k,ll p){\n        if(root==&NIL){\n            root=(node*)malloc(sizeof(node));\n            root->p=p;\n            root->a=k;\n            root->r=root->l=&NIL;\n            return *root;\n        }\n        return *(root=&insert(*root,k,p));\n    }\n\n    node & insert(node &t,ll k,ll p){\n        if(&t==&NIL){\n            node &a=*(node*)malloc(sizeof(node));\n            a.a=k;\n            a.p=p;\n            a.r=a.l=&NIL;\n            return a;\n        }\n        if(k==t.a){return t;}\n        if(k<t.a){\n            t.l=&insert(*t.l,k,p);\n            if(t.p<t.l->p){\n                return Rrotate(t);\n            }\n        }\n        else{\n            t.r=&insert(*t.r,k,p);\n            if(t.p<t.r->p){\n                return Lrotate(t);\n            }\n        }\n        return t;\n    }\n\n    /*\n     delete(Node t, int key)\n     if t == NIL\n     return NIL\n     if key < t.key                                // 削除対象を検索\n     t.left = delete(t.left, key)\n     else if key > t.key\n     \n     \n     t.right = delete(t.right, key)\n     else\n     return _delete(t, key)\n     return t\n     \n     _delete(Node t, key) // 削除対象の節点の場合\n     if t.left == NIL && t.right == NIL           // 葉の場合\n     return NIL\n     else if t.left == NIL                        // 右の子のみを持つ場合左回転\n     t = leftRotate(t)\n     else if t.right == NIL                       // 左の子のみを持つ場合右回転\n     t = rightRotate(t)\n     else                                         // 左の子と右の子を両方持つ場合\n     if t.left.priority > t.right.priority    // 優先度が高い方を持ち上げる\n     t = rightRotate(t)\n     else\n     t = leftRotate(t)\n     return delete(t, key)\n     */\n\n    node & _delete(node &t,ll k){\n        if(t.l==&NIL && t.r==&NIL){return NIL;}\n        else if(t.l==&NIL){\n            return erase(Lrotate(t),k);\n        }\n        else if(t.l==&NIL){return erase(Rrotate(t),k);}\n        else if(t.r==&NIL){return erase(Rrotate(t),k);}\n        else{\n            if(t.l->p>t.r->p){\n                return erase(Rrotate(t),k);\n            }\n            else{\n                return erase(Lrotate(t),k);\n            }\n        }\n        return t;\n    }\n\n    node & erase(node &t,ll k){\n        if(&t==&NIL){\n            return NIL;\n        }\n        if(k<t.a){t.l=&erase(*t.l,k);}\n        else if(k>t.a){\n            t.r=&erase(*t.r,k);\n        }\n        else{\n            return _delete(t,k);\n        }\n        return t;\n    }\n\n    node & erase(ll k){\n        if(root==&NIL){return NIL;}\n        return *(root=&erase(*root,k));\n    }\n    \n    void test(){\n        dfs_m(*root);\n        cout<<endl;\n        dfs_f(*root);\n        cout<<endl;\n    }\n    \n    void dfs_f(node &w){\n        cout<<\" \"<<w.a;\n        if(w.l!=&NIL){dfs_f(*w.l);}\n        if(w.r!=&NIL){dfs_f(*w.r);}\n    }\n    \n    void dfs_m(node &w){\n        if(w.l!=&NIL){dfs_m(*w.l);}\n        cout<<\" \"<<w.a;\n        if(w.r!=&NIL){dfs_m(*w.r);}\n    }\n    \n    bool find(ll a){\n        if(root==&NIL){return false;}\n        node* w=root;\n        while(1){\n            if(w->a==a){return true;}\n            if(w->a<a && w->r==&NIL){return false;}\n            if(w->a<a){w=w->r;}\n            if(w->a>a && w->l==&NIL){return false;}\n            if(w->a>a){w=w->l;}\n        }\n        return false;\n    }\n};\n\n\n\nint main(){\n    tree B;\n    ll q;\n    cin>>q;\n    while(q--){\n        string s;\n        cin>>s;\n        if(s==\"insert\"){\n            ll b,p;\n            cin>>b>>p;\n            B.insert(b,p);\n        }\n        else if(s==\"find\"){\n            ll b;\n            cin>>b;\n            if(B.find(b)){cout<<\"yes\"<<endl;}\n            else{cout<<\"no\"<<endl;}\n        }\n        else if(s==\"print\"){\n            B.test();\n        }\n        else{\n            ll b;\n            cin>>b;\n            B.erase(b);\n        }\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\nusing namespace std;\n\nstruct Node{\n    int key, pri;\n    Node *left, *right;\n    Node(const int& k, const int& p): key(k), pri(p), left(NULL), right(NULL) {}\n};\n\nNode* rightRotate(Node* n){\n    Node* t = n->left;\n    n->left = t->right;\n    t->right = n;\n    return t;\n}\n\nNode* leftRotate(Node* n){\n    Node* t = n->right;\n    n->right = t->left;\n    t->left = n;\n    return t;\n}\n\nNode* insert(Node* n, const int& k, const int& p){\n    if(!n)\n        return new Node(k, p);\n    if(k == n->key) return n;\n    if(k < n->key){\n        n->left = insert(n->left, k, p);\n        if(n->left->pri > n->pri)\n            n = rightRotate(n);\n    }\n    if(k > n->key){\n        n->right = insert(n->right, k, p);\n        if(n->right->pri > n->pri)\n            n = leftRotate(n);\n    }\n    return n;\n}\n\nNode* _del(Node* n, const int& k);\n\nNode* del(Node* n, const int& k){\n    if(!n) return NULL;\n    if(k < n->key)\n        n->left = del(n->left, k);\n    else if(k > n->key)\n        n->right = del(n->right, k);\n    else{\n        return _del(n, k); \n    }\n    return n;\n}\n\nNode* _del(Node* n, const int& k){\n    if(!(n->left) && !(n->right))\n        return NULL;\n    else if(!(n->left))\n        n = leftRotate(n);\n    else if(!(n->right))\n        n = rightRotate(n);\n    else if(n->left->pri > n->right->pri)\n        n = rightRotate(n);\n    else n = leftRotate(n);\n    return del(n, k);\n}\n\nbool find(Node *n, const int& k){\n    if(!n) return false;\n    if(k == n->key) return true;\n    if(k < n->key) return find(n->left, k);\n    else return find(n->right, k);\n}\n\nvoid inOrder(Node* n){\n    if(!n) return;\n    inOrder(n->left);\n    printf(\" %d\", n->key);\n    inOrder(n->right);\n}\n\nvoid preOrder(Node* n){\n    if(!n) return;\n    printf(\" %d\", n->key);\n    preOrder(n->left);\n    preOrder(n->right);\n}\n\nvoid print(Node* n){\n    inOrder(n);\n    printf(\"\\n\");\n    preOrder(n);\n    printf(\"\\n\");\n}\n\nint main(){\n    int n, x, y;\n    char cmd[10];\n    Node* root = NULL;\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%9s\", cmd);\n        if(strcmp(cmd, \"insert\") == 0){\n            scanf(\"%d %d\", &x, &y);\n            root = insert(root, x, y);\n        }\n        else if(strcmp(cmd, \"delete\") == 0){\n            scanf(\"%d\", &x);\n            root = del(root, x);\n        }\n        else if(strcmp(cmd, \"print\") == 0){\n            print(root);            \n        }\n        else if(strcmp(cmd, \"find\") == 0){\n            scanf(\"%d\", &x);\n            printf(find(root, x)? \"yes\\n\" : \"no\\n\");\n        }\n        else{\n            printf(\"Invalid cmd\\n\");\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nstruct Node{\n  int key, priority;\n  Node* right;\n  Node* left;\n};\n\nNode* right_rotate(Node* t){\n    Node* s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n}\n\nNode* left_rotate(Node* t){\n    Node* s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;\n}\n\nNode* insert(Node* t, int key, int priority){\n\n    if(t == NULL){\n        Node* t = new Node;\n        t->left = NULL;\n        t->right = NULL;\n        t->key = key;\n        t->priority = priority;\n        return t;\n    }\n    if(key == t->key){\n        return t;\n    }\n    if(key < t->key){\n        t->left = insert(t->left, key, priority);\n        if(t->priority < t->left->priority){\n            t = right_rotate(t);\n        } \n    }\n    else{\n        t->right = insert(t->right, key, priority);\n        if(t->priority < t->right->priority){\n            t = left_rotate(t);\n        }\n    }\n    return t;\n}\n\nNode* delete_key(Node* t, int key){\n    if(t == NULL){\n        return NULL;\n    }\n    if(key == t->key){\n        if(t->left  == NULL && t->right == NULL){\n            return NULL;\n        }\n        else if(t->left == NULL){\n            t = left_rotate(t);\n        } \n        else if(t->right == NULL){\n            t = right_rotate(t);\n        } \n        else{\n            if(t->left->priority > t->right->priority){\n                t = right_rotate(t);\n            }\n            else{\n                t = left_rotate(t);\n            } \n        }\n        return delete_key(t, key);\n    }\n    if(key < t->key){\n        t->left = delete_key(t->left, key);\n    }\n    else{\n        t->right = delete_key(t->right, key);\n    } \n    return t;\n}\n\nvoid find(Node* t, int key){\n    while(t != NULL && key != t->key){\n        if(key < t->key){\n            t = t->left;\n        }\n        else{\n            t = t->right;\n        } \n    }\n    if(t == NULL){\n        cout << \"no\" << endl;\n    }\n    else{\n        cout << \"yes\" << endl;\n    } \n}\n\n// 中間順巡回\nvoid inorder(Node* t){\n    if(t == NULL){\n        return;\n    }\n    inorder(t->left);\n    cout << \" \" << t->key;\n    inorder(t->right);\n}\n\n// 先行順巡回\nvoid preorder(Node* t){\n    if(t == NULL){\n        return;\n    }\n    cout << \" \" << t->key;\n    preorder(t->left);\n    preorder(t->right);\n}\n\nint main(){\n    Node* root = NULL;\n    \n    int n;\n    cin >> n;\n\n    string s;\n    int key, priority;\n    for(int i=0;i<n;i++){\n        cin >> s;\n        if(s == \"insert\"){\n            cin >> key >> priority;\n            root = insert(root, key, priority);\n        }\n        else if(s == \"delete\"){\n            cin >> key;\n            root = delete_key(root, key);\n        }\n        else if(s == \"find\"){\n            cin >> key;\n            find(root, key);\n        }\n        else {\n            inorder(root);\n            cout << endl;\n            preorder(root);\n            cout << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass Treap {\npublic:\n  Treap *left = nullptr;\n  Treap *right = nullptr;\n  int key;\n  int pri;\n  Treap(int k, int p) : key(k), pri(p) {}\n  Treap *Insert(int k, int p) {\n    if (k < key) {\n      if (!left) {\n        left = new Treap(k, p);\n      } else {\n        left = left->Insert(k, p);\n      }\n      if (left->pri > pri) {\n        //        cout << \"Debug: At \" << key << \", left node \" << left->key\n        //             << \" has lower priority \" << left->pri << \" (vs. \" << pri\n        //             << \"); rotating right\\n\";\n        return RotateRight();\n      }\n    } else if (k > key) {\n      if (!right) {\n        right = new Treap(k, p);\n      } else {\n        right = right->Insert(k, p);\n      }\n      if (right->pri > pri) {\n        //        cout << \"Debug: At \" << key << \", right node \" << right->key\n        //             << \" has lower priority \" << right->pri << \" (vs. \" <<\n        //             pri\n        //             << \"); rotating left\\n\";\n        return RotateLeft();\n      }\n    }\n    return this;\n  }\n  // pre: right != null\n  Treap *RotateLeft() {\n    Treap *s = right;\n    right = s->left;\n    s->left = this;\n    return s;\n  }\n  // pre: left != null\n  Treap *RotateRight() {\n    Treap *s = left;\n    left = s->right;\n    s->right = this;\n    return s;\n  }\n  bool Find(int k) {\n    if (k == key) {\n      return true;\n    } else if (k > key) {\n      return (right and right->Find(k));\n    } else if (k < key) {\n      return (left and left->Find(k));\n    }\n  }\n  // pre: k is in the treap\n  Treap *Remove(int k) {\n    if (k == key) {\n      if (not left and not right) {\n        delete this;\n        return nullptr;\n      } else if (left and not right) {\n        return RotateRight()->Remove(k);\n      } else if (right and not left) {\n        return RotateLeft()->Remove(k);\n      } else {\n        if (right->pri > left->pri) {\n          return RotateLeft()->Remove(k);\n        } else {\n          return RotateRight()->Remove(k);\n        }\n      }\n    } else {\n      if (k > key and right) {\n        right = right->Remove(k);\n      } else if (k < key and left) {\n        left = left->Remove(k);\n      }\n      return this;\n    }\n  }\n};\n\nvoid PrintInorder(Treap *t) {\n  if (!t)\n    return;\n  PrintInorder(t->left);\n  cout << ' ' << t->key;\n  PrintInorder(t->right);\n}\n\nvoid PrintPreorder(Treap *t) {\n  if (!t)\n    return;\n  cout << ' ' << t->key;\n  PrintPreorder(t->left);\n  PrintPreorder(t->right);\n}\n\nint main() {\n  int n;\n  cin >> n;\n  string cmd;\n  Treap *root = nullptr;\n  int k, p;\n  while (cin >> cmd) {\n    if (cmd == \"insert\") {\n      cin >> k >> p;\n      if (!root) {\n        root = new Treap(k, p);\n      } else {\n        root = root->Insert(k, p);\n      }\n    } else if (cmd == \"find\") {\n      cin >> k;\n      if (root and root->Find(k)) {\n        cout << \"yes\\n\";\n      } else {\n        cout << \"no\\n\";\n      }\n    } else if (cmd == \"print\") {\n      PrintInorder(root);\n      cout << endl;\n      PrintPreorder(root);\n      cout << endl;\n    } else if (cmd == \"delete\") {\n      cin >> k;\n      // root will always be non-null when deleting\n      root = root->Remove(k);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct node{\n  int key ;\n  int priority;\n  int right;\n  int left;\n  long unsigned int p;\n};\nnode nullNode{-1,-1,0,0,0};\nint _nodeDelete(node,int);\nint nodeDelete(node,int);\nvector <node> treap;\nbool isNull(node t){\n  //if(&t ==nullptr) return true;\n  if(t.key ==-1 && t.priority == -1)return true;\n  return false;\n}\nint rightRotate(node t){\n  long unsigned int s = t.left;\n  treap[t.p].left = treap[s].right;\n  treap[s].right = t.p;\n  return s;\n}\nint leftRotate(node t){\n  long unsigned int s = t.right;\n  treap[t.p].right = treap[s].left;\n  treap[s].left = t.p;\n  return s;\n}\nint mkNode(int key,int priority){\n  node s = {key,priority,0,0,treap.size()};\n  treap.push_back(s);\n  return s.p;\n}\nint insert(node t,int key, int priority){\n  int tmp;\n  if(isNull(t))return mkNode(key,priority);\n  if(key == t.key)return t.p;\n  if(key < t.key){\n    tmp = insert(treap[t.left],key,priority);\n     treap[t.p].left =tmp;\n     if(t.priority < treap[tmp].priority)\n      t = treap[rightRotate(treap[t.p])];\n  }\n  else {\n    tmp= insert(treap[t.right],key,priority);\n    treap[t.p].right = tmp;\n    if(t.priority < treap[tmp].priority)\n      t = treap[leftRotate(treap[t.p])];\n  }\n  return t.p;\n}\nint nodeDelete(node t,int key){\n  int tmp;\n  if(isNull(t))return 0;\n  if(key < t.key){\n    tmp = nodeDelete(treap[t.left],key);\n    treap[t.p].left = tmp;\n  }\n  else if (key > t.key){\n    tmp = nodeDelete(treap[t.right], key);\n    treap[t.p].right = tmp;\n  }\n  else\n    return _nodeDelete(t, key);\n  return t.p;\n}\nint _nodeDelete(node t,int key){ // 削除対象の節点の場合\n  int tmp;\n  if (isNull(treap[t.left]) && isNull(treap[t.right]))           // 葉の場合\n        return 0;\n  else if (isNull(treap[t.left])){\n    tmp = leftRotate(t);\n      t = treap[tmp];\n    }                       // 右の子のみを持つ場合左回転\n    else if (isNull(treap[t.right])){                      // 左の子のみを持つ場合右回転\n      tmp =rightRotate(t);\n      t = treap[tmp];\n    }\n    else{                                         // 左の子と右の子を両方持つ場合\n        if (treap[t.left].priority > treap[t.right].priority ){\n          tmp = rightRotate(t);\n          t = treap[tmp];\n        }   // 優先度が高い方を持ち上げる\n\n        else{\n          tmp =leftRotate(t);\n          t = treap[tmp];\n        }\n    }\n  return nodeDelete(t, key);\n}\nvoid preorder_print(node t){\n  if(isNull(t))return;\n  cout<<\" \"<<t.key;\n  preorder_print(treap[t.left]);\n  preorder_print(treap[t.right]);\n}\nvoid inorder_print(node t){\n  if(isNull(t))return;\n  inorder_print(treap[t.left]);\n  cout<<\" \"<<t.key;\n  inorder_print(treap[t.right]);\n}\nbool find(node t, int key){\n  bool flag = false;\n  if(t.key ==-1);\n  else if(key==t.key) flag = true;\n  else if(key>(t.key))flag = find(treap[t.right],key);\n  else if(key<(t.key)) flag = find(treap[t.left],key);\n  return flag;\n}\nint main(){\n  int n,key,p;\n  bool flag=false;\n  string str;\n  int root;\n  cin>>n;\n  treap.push_back(nullNode);\n  for(int i=0;i<n;i++){\n    cin>>str;\n    if(str==\"insert\"){\n      cin>>key>>p;\n      if(flag)\n        root = insert(treap[root],key,p);\n      else{\n        root = mkNode(key,p);\n        flag = true;\n      }\n    }\n    else if (str==\"print\"){\n      //for(int j=0;j<treap.size();j++)cout<<\"p: \"<<treap[j].p<<\" key: \"<<treap[j].key<<\" r: \"<<treap[j].right<<\" l: \"<<treap[j].left<<endl;\n      //cout<<\"isPrint\"<<endl;\n      inorder_print(treap[root]);\n      cout<<endl;\n      preorder_print(treap[root]);\n      cout<<endl;\n    }\n    else if (str == \"delete\"){\n      cin >> key;\n      root = nodeDelete(treap[root],key);\n    }\n    else if (str == \"find\"){\n      cin>>key;\n      if(find(treap[root],key))cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n    }\n   }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//lec05\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<stdio.h>\n#include<fstream>\n#include<stdlib.h>\n#include<math.h> \n#include<queue>\n#include<string.h>\n#include<stack>\n\n\nusing namespace std;\nstruct Node {\n  Node* r;\n  Node* l;\n  int key,priotity;\n};\n\nNode* rightRotate(Node* t){\n\tNode* s=t->l;\n\tt->l=s->r;\n\ts->r=t;\n\treturn s;\n}\n\nNode* leftRotate(Node* t){\n\tNode* s=t->r;\n\tt->r=s->l;\n\ts->l=t;\n\treturn s;\n}\n\nNode* insert(Node *t,int key,int priotity){\n\tif(t==NULL){\n\t\tNode* t=new Node;\n\t\tt->l=NULL;\n\t\tt->r=NULL;\n\t\tt->key=key;\n\t\tt->priotity=priotity;\n\t\treturn t;\n\t}\n\n\tif(key==t->key){\n\t\treturn t;\n\t}\n\tif(key < t->key){\n\t\tt->l=insert(t->l,key,priotity);\n\t\tif(t->priotity < t->l->priotity){\n\t\t\tt=rightRotate(t);\n\t\t}\n\t}\n\telse{\n\t\tt->r=insert(t->r,key,priotity);\n\t\tif(t->priotity < t->r->priotity){\n\t\t\tt=leftRotate(t);\n\t\t}\n\t}\n\treturn t;\n}\n\n\nNode* del(Node* t,int key){\n\tif(t==NULL){\n\t\treturn NULL;\n\t}\n\tif(key==t->key){\n\t\tif(t->l==NULL&&t->r==NULL)return NULL;\n\t\telse if(t->l==NULL)t=leftRotate(t);\n\t\telse if(t->r==NULL)t=rightRotate(t);\n\t\telse{\n\t\t\tif(t->l->priotity > t->r->priotity)t=rightRotate(t);\n\t\t\telse t=leftRotate(t);\n\t\t}\n\t\treturn del(t,key);\n\t}\n \tif(key < t->key){\n \t\tt->l=del(t->l,key);\n \t}\n  \telse {\n  \t\tt->r=del(t->r,key);\n  \t}\n  \treturn t;\n}\n\nvoid find(Node* t,int key){\n\twhile(t!=NULL&&key!=t->key){\n\t\tif(key < t->key){\n\t\t\tt=t->l;\n\t\t}\n\t\telse{\n\t\t\tt=t->r;\n\t\t}\n\t}\n\tif(t==NULL){\n\t\tcout<<\"no\"<<endl;\n\t}\n\telse{\n\t\tcout<<\"yes\"<<endl;\n\t}\n}\n\n\nvoid inorder(Node* t){\n\tif(t==NULL)return;\n\tinorder(t->l);\n\tcout<<\" \"<<t->key;\n\tinorder(t->r);\n}\n\nvoid preorder(Node* t){\n\tif(t==NULL)return;\n\tcout<<\" \"<<t->key;\n\tpreorder(t->l);\n\tpreorder(t->r);\n}\n\n\nint main(){\n\tint n;\n\tcin>>n;\n\tstring in;\n\tint k,p;\n\tNode* root=NULL;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>in;\n\t\tif(in==\"insert\"){\n\t\t\tcin>>k>>p;\n\t\t\troot=insert(root,k,p);\n\t\t}\n\t\telse if(in==\"find\"){\n\t\t\tcin>>k;\n\t\t\tfind(root,k);\n\t\t}\n\t\telse if(in==\"delete\"){\n\t\t\tcin>>k;\n\t\t\troot=del(root,k);\n\t\t}\n\t\telse{\n\t\t\tinorder(root);\n\t\t\tcout<<endl;\n\t\t\tpreorder(root);\n\t\t\tcout<<endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef struct Node{\n  int value, priority;\n  Node *left, *right;\n} Node;\n\nNode* Delete(Node *, int);\nNode* _delete(Node *, int);\n\nNode *NIL, *root;\n\nNode* rightRotate(Node *t){\n  Node *s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s; // root of the subtree\n}\n\nNode* leftRotate(Node *t){\n  Node *s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s; // root of the subtree\n}\n\nNode* makenode(int key, int priority){\n  Node *node = (Node *)malloc(sizeof(Node));\n  node->value = key;\n  node->priority = priority;\n  node->left = node->right = NIL;\n\n  return node;\n}\n\nNode* insert(Node *t, int key, int priority){    // 再帰的に探索\n  Node *x;\n\n  if(t == NIL) return x = makenode(key, priority); // 葉に到達したら新しい節点を生成して返す\n\n  if(key == t->value) return t;                // 重複したkeyは無視\n\n  if(key < t->value){                          // 左の子へ移動\n      t->left = insert(t->left, key, priority); // 左の子へのポインタを更新\n      if(t->priority < t->left->priority) t = rightRotate(t); // 左の子の方が優先度が高い場合右回転\n  }else{                                       // 右の子へ移動\n      t->right = insert(t->right, key, priority); // 右の子へのポインタを更新\n      if(t->priority < t->right->priority) t = leftRotate(t); // 右の子の方が優先度が高い場合左回転\n  }\n\n  return t;\n}\n\nNode* find(Node *x, int k){\n  if(x == NIL || x->value == k) return x;\n\n  if(k < x->value) return find(x->left, k);\n  else return find(x->right, k);\n}\n\nNode* Delete(Node *t, int key){\n  if(t == NIL) return NIL;\n  if(key < t->value) t->left = Delete(t->left, key); // 削除対象を検索\n  else if(key > t->value) t->right = Delete(t->right, key);\n  else return _delete(t, key);\n  return t;\n}\n\nNode* _delete(Node *t, int key){ // 削除対象の節点の場合\n  if(t->left == NIL && t->right == NIL) return NIL; // 葉の場合\n  else if(t->left == NIL) t = leftRotate(t);   // 右の子のみを持つ場合左回転\n  else if(t->right == NIL) t = rightRotate(t); // 左の子のみを持つ場合右回転\n  else{                                        // 左の子と右の子を両方持つ場合\n    if(t->left->priority > t->right->priority) t = rightRotate(t); // 優先度が高い方を持ち上げる\n    else t = leftRotate(t);\n  }\n  return Delete(t, key);\n}\n\nvoid preParse(Node *node){\n  if(node == NIL) return ;\n\n  cout << \" \" << node->value;\n  if(node->left != NIL) preParse(node->left);\n  if(node->right != NIL) preParse(node->right);\n}\n\nvoid inParse(Node *node){\n  if(node == NIL) return ;\n\n  if(node->left != NIL) inParse(node->left);\n  cout << \" \" << node->value;\n  if(node->right != NIL) inParse(node->right);\n}\n\nint main(){\n\n  int n, key, priority;\n  string command;\n\n  cin >> n;\n  for(int i = 0;i < n;i++){\n    cin >> command;\n    if(command == \"insert\"){\n      cin >> key >> priority;\n      root = insert(root, key, priority);\n    }else if(command == \"print\"){\n      inParse(root);\n      cout << endl;\n      preParse(root);\n      cout << endl;\n    }else if(command == \"find\"){\n      cin >> key;\n      if(find(root, key)) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }else if(command == \"delete\"){\n      cin >> key;\n      root = Delete(root, key);\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point{\n\tint a,b;\n\tpoint *l,*r,*pa;\n\tpoint(){l=r=pa=NULL;}\n\tpoint(int aa,int bb):a(aa),b(bb){l=r=pa=NULL;};\n};\npoint *root;\npoint *rightRotate(point *t){\n\tpoint *s=t->l;\n\tt->l=s->r;\n\ts->r=t;\n\treturn s;\n}\npoint *leftRotate(point *t){\n\tpoint *s=t->r;\n\tt->r=s->l;\n\ts->l=t;\n\treturn s;\n}\npoint* insert(point *p,int a,int b){\n\tif(p==NULL)return new point(a,b);\n\tif(a==p->a)return p;\n\tif(a<p->a){\n\t\tp->l=insert(p->l,a,b);\n\t\tif(p->b<p->l->b)\n\t\t\tp=rightRotate(p);\n\t}else{\n\t\tp->r=insert(p->r,a,b);\n\t\tif(p->b<p->r->b)\n\t\t\tp=leftRotate(p);\n\t}return p;\n}\npoint *_del(point *p, int a);\npoint *del(point *p,int a){\n\tif(p==NULL)return NULL;\n\tif(a<p->a)p->l=del(p->l,a);\n\telse if(a>p->a)p->r=del(p->r,a);\n\telse return _del(p,a);\n\treturn p;\n}\npoint *_del(point *p, int a){\n\tif(p->l==NULL&&p->r==NULL)return NULL;\n\telse if(p->l==NULL)p=leftRotate(p);\n\telse if(p->r==NULL)p=rightRotate(p);\n\telse{\n\t\tif(p->l->b>p->r->b)p=rightRotate(p);\n\t\telse p=leftRotate(p);\n\t}return del(p,a);\n}\nbool find(int a){\n\tpoint *p=root;\n\twhile(p){\n\t\tif(a==p->a)return 1;\n\t\tif(a>p->a)p=p->r;\n\t\telse p=p->l;\n\t}\n\treturn 0;\n}\nvoid dfs1(point *p){\n\tif(!p)return;\n\tdfs1(p->l);\n\tprintf(\" %d\",p->a);\n\tdfs1(p->r);\n}\nvoid dfs2(point *p){\n\tif(!p)return;\n\tprintf(\" %d\",p->a);\n\tdfs2(p->l);\n\tdfs2(p->r);\n}\nint main(){\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\tint T;cin>>T;\n\tint ta,tb;\n\tstring s;\n\twhile(cin>>s){\n\t\tif(s==\"insert\"){\n\t\t\tcin>>ta>>tb;\n//\t\t\tif(!root)root=new point(ta,tb);\n//\t\t\telse \n\t\t\troot=insert(root,ta,tb);\n\t\t}else if(s==\"find\"){\n\t\t\tcin>>ta;\n\t\t\tif(find(ta))printf(\"yes\\n\");\n\t\t\telse printf(\"no\\n\");\n\t\t}else if(s==\"print\"){\n\t\t\tdfs1(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tdfs2(root);\n\t\t\tprintf(\"\\n\");\n\t\t}else if(s==\"delete\"){\n\t\t\tcin>>ta;\n\t\t\troot=del(root,ta);\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define NIL (Node *)-1\n\nstruct Node {\n\tint key, priority;\n\tNode *p, *left, *right;\n\tNode( int k, int pr ) { key = k; priority = pr; p = left = right = NIL; }\n};\nNode *root = NIL;\n\nNode *rightRotate( Node *t )\n{\n\tNode *s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\n\nNode *leftRotate( Node *t )\n{\n\tNode *s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\n\nNode *insert( Node *t, int k, int pr, int f )\n{\n\tif( t == NIL ) {\n\t\tNode *n = new Node( k, pr );\n\t\tif( f ) {\n\t\t\troot = n;\n\t\t}\n\t\treturn n;\n\t}\n\tif( k == t->key ) return t;\n\tif( k < t->key ) {\n\t\tt->left = insert( t->left, k, pr, 0 );\n\t\tif( t->priority < t->left->priority ) {\n\t\t\tt = rightRotate( t );\n\t\t\tif( f ) root = t;\n\t\t}\n\n\t}\n\telse {\n\t\tt->right = insert( t->right, k, pr, 0 );\n\t\tif( t->priority < t->right->priority ) {\n\t\t\tt = leftRotate( t );\n\t\t\tif( f ) root = t;\n\t\t}\n\t}\n\treturn t;\n}\n\nNode *find( int k )\n{\n\tNode *t = root;\n\twhile( t != NIL ) {\n\t\tif( t->key == k ) {\n\t\t\treturn t;\n\t\t}\n\t\tif( k < t->key ) {\n\t\t\tt = t->left;\n\t\t}\n\t\telse {\n\t\t\tt = t->right;\n\t\t}\n\t}\n\treturn NIL;\n}\n\nNode *_del( Node *t, int k );\nNode *del( Node *t, int k, int f )\n{\n\tif( t == NIL ) return NIL;\n\tif( k < t->key ) t->left = del( t->left, k, 0 );\n\telse if( k > t->key ) t->right = del( t->right, k, 0 );\n\telse {\n\t\tNode *n = _del( t, k );\n\t\tif( f ) root = n;\n\t\tt = n;\n\t}\n\treturn t;\n}\n\nNode *_del( Node *t, int k )\n{\n\tif( t->left == NIL && t->right == NIL ) return NIL;\n\tif( t->left == NIL ) {\n\t\tt = leftRotate( t );\n\t}\n\telse if( t->right == NIL ) {\n\t\tt = rightRotate( t );\n\t}\n\telse {\n\t\tif( t->left->priority > t->right->priority ) {\n\t\t\tt = rightRotate( t );\n\t\t}\n\t\telse {\n\t\t\tt = leftRotate( t );\n\t\t}\n\t}\n\treturn del( t, k, 0 );\n}\n\nvoid printp( Node *u )\n{\n\tif( u == NIL ) return;\n\tcout << \" \" << u->key;\n\tprintp( u->left );\n\tprintp( u->right );\n}\n\nvoid printm( Node *u )\n{\n\tif( u == NIL ) return;\n\tprintm( u->left );\n\tcout << \" \" << u->key;\n\tprintm( u->right );\n}\n\nint main()\n{\n\tint m;\n\tcin >> m;\n\tfor( int i = 0; i < m; i++ ) {\n\t\tstring com;\n\t\tcin >> com;\n\t\tif( com == \"insert\" ) {\n\t\t\tint k, pr;\n\t\t\tcin >> k >> pr;\n\t\t\tinsert( root, k, pr, 1 );\n\t\t}\n\t\telse if( com == \"print\" ) {\n\t\t\tprintm( root );\n\t\t\tcout << endl;\n\t\t\tprintp( root );\n\t\t\tcout << endl;\n\t\t}\n\t\telse if( com == \"find\" ) {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tstring ans = \"no\";\n\t\t\tif( find( k ) != NIL ) ans = \"yes\";\n\t\t\tcout << ans << endl;\n\t\t}\n\t\telse {\n\t\t\tint k;\n\t\t\tcin >> k;\n\t\t\tdel( root, k, 1 );\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n\ntypedef struct node_{\n    int key;\n    int priority;\n    struct node_* left;\n    struct node_* right;\n    struct node_* parent;\n}node;\n\nnode* rightRotate(node* t){\n    node* s = t->left;\n    if(s->right!=NULL)s->right->parent = t;\n    t->left = s->right;\n    s->parent = t->parent;\n    s->right = t;\n    t->parent = s;\n    return s;\n}\n\nnode* leftRotate(node* t){\n    node* s = t->right;\n    if(s->left!=NULL)s->left->parent = t;\n    t->right = s->left;\n    s->parent = t->parent;\n    s->left = t;\n    t->parent = s;\n    return s;\n}\n\nnode* insert(node* nd, node* parent, int k, int p){\n    if(nd==NULL){\n        nd = (node *)malloc(sizeof(node));\n        nd->key = k;\n        nd->priority = p;\n        nd->left = NULL;\n        nd->right = NULL;\n        nd->parent = parent;\n    }else if(k<nd->key){\n        nd->left = insert(nd->left,nd,k,p);\n        if(p>nd->priority)nd = rightRotate(nd);\n    }else if(k>nd->key){\n        nd->right = insert(nd->right,nd,k,p);\n        if(p>nd->priority)nd = leftRotate(nd);\n    }\n    return nd;\n}\n\nnode* find(node* nd, int k){\n    if(nd==NULL)return nd;\n    else if(k < nd->key)return find(nd->left,k);\n    else if(k > nd->key)return find(nd->right,k);\n    else return nd;\n}\n\nnode* _del(node* nd){\n    if(nd==NULL)return NULL;\n    node* tmp;\n    if(nd->left==NULL){\n        if(nd->right==NULL){\n            tmp = NULL;\n            free(nd);\n        }else{\n            tmp = leftRotate(nd);\n            tmp->left = _del(tmp->left);\n        }\n    }else{\n        if(nd->right==NULL){\n            tmp = rightRotate(nd);\n            tmp->right = _del(tmp->right);\n        }else{\n            if(nd->left->priority<nd->right->priority){\n                tmp = leftRotate(nd);\n                tmp->left = _del(tmp->left);\n            }else{\n                tmp = rightRotate(nd);\n                tmp->right = _del(tmp->right);\n            }\n        }\n    }\n    return tmp;\n}\n\nnode* del(node* nd, int k){\n    if(nd==NULL)return nd;\n    else if(k < nd->key)nd->left = del(nd->left,k);\n    else if(k > nd->key)nd->right = del(nd->right,k);\n    else nd = _del(nd);\n    return nd;\n}\n\nvoid preorder(node* nd){\n    if(nd==NULL)return;\n    printf(\" %d\",nd->key);\n    preorder(nd->left);\n    preorder(nd->right);\n}\n\nvoid inorder(node* nd){\n    if(nd==NULL)return;\n    inorder(nd->left);\n    printf(\" %d\",nd->key);\n    inorder(nd->right);\n}\n\nint main(){\n    int i, m, k, p;\n    char command[7];\n    node* tmp;\n    node* root = NULL;\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n        scanf(\"%s\",command);\n        switch(command[0]){\n        case 'i'://insert\n            scanf(\"%d %d\",&k,&p);\n            root = insert(root, NULL, k, p);\n            break;\n        case 'f'://find\n            scanf(\"%d\",&k);\n            if(find(root, k)!=NULL)printf(\"yes\\n\");\n            else printf(\"no\\n\");\n            break;\n        case 'd'://del\n            scanf(\"%d\",&k);\n            root = del(root, k);\n            break;\n        case 'p'://pirnt\n            inorder(root);\n            printf(\"\\n\");\n            preorder(root);\n            printf(\"\\n\");\n            break;\n        default:\n            perror(\"error\\n\");\n            return 1;\n            break;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct node{\n  node* l;\n  node* r;\n  int value;\n  int priority;\n  node(int x=0,int y=0){\n    l=NULL;\n    r=NULL;\n    value=x;\n    priority=y;\n  }\n};\n\ntypedef node* Node;\n\nint cc=0;\nnode t[500005];\n\nNode MakeNode(int x=0,int y=0){\n  Node res=&t[cc];\n  cc++;\n  res->value=x;\n  res->priority=y;\n  return res;\n}\n\nNode left_rotate(Node root){\n  Node right=root->r;\n  root->r = right->l;\n  right->l = root;\n  return right;\n}\n\nNode right_rotate(Node root){\n  Node left=root->l;\n  root->l = left->r;\n  left->r = root;\n  return left;\n}\n\nNode insert(Node root,int val,int pri){\n  \n  if(root==NULL){\n    return MakeNode(val,pri);\n  }\n  \n  if( val < root->value ){\n    root->l = insert( root->l , val , pri );\n\n    if( root->l->priority > root->priority ){\n      root = right_rotate(root);\n    }\n    \n  }else if( val > root->value ){\n    root->r = insert( root->r , val , pri );\n    \n    if( root->r->priority > root->priority ){\n      root = left_rotate(root);\n    }\n    \n  }else{\n    \n  }\n  return root;\n}\n\nbool find(Node root,int target){\n  if( root == NULL )return false;\n  if( root->value == target )return true;\n  if( root->value > target )return find(root->l,target);\n  if( root->value < target )return find(root->r,target);\n  return false;\n}\n\nNode erase(Node root,int target){\n  if( root == NULL )return root;\n  if( root->value == target ){\n    \n    if( root->l == NULL ){\n      return root->r;\n    }\n    if( root->r == NULL ){\n      return root->l;\n    }\n\n    if( root->l->priority > root->r->priority ){\n      root = right_rotate(root);\n    } else {\n      root = left_rotate(root);\n    }\n    return erase(root,target);\n  }\n  \n  if( root->value > target ){\n    root->l=erase(root->l,target);\n    return root;\n  }\n  if( root->value < target ){\n    root->r=erase(root->r,target);\n    return root;\n  }\n\n  assert(0);\n}\n\nvoid dfsA(Node root){\n  if(root==NULL)return;\n  printf(\" %d\", root->value);\n  dfsA(root->l);\n  dfsA(root->r);\n}\n\nvoid dfsB(Node root){\n  if(root==NULL)return;\n  dfsB(root->l);\n  printf(\" %d\", root->value);\n  dfsB(root->r);\n}\n\nNode T=NULL;\n\nint main(){\n\n  int m;\n  scanf(\"%d\",&m);\n\n  char str[100];\n  int x,y;\n  \n  for(int i=0;i<m;i++){\n    scanf(\"%s\",str);\n    if(str[0]=='i'){\n      scanf(\"%d %d\",&x,&y);\n      T=insert(T,x,y);\n      \n    }else if(str[0]=='f'){\n      scanf(\"%d\",&x);\n      if( find(T,x) )printf(\"yes\\n\");\n      else printf(\"no\\n\");\n      \n    }else if(str[0]=='d'){\n      scanf(\"%d\",&x);\n      if( find(T,x) ){\n        T=erase(T,x);\n      }\n      \n    }else if(str[0]=='p'){\n      dfsB(T);\n      printf(\"\\n\");\n      dfsA(T);\n      printf(\"\\n\");\n      \n    }else{\n      assert(0);\n    }\n\n  }\n  return 0;\n  /*\n  int tmp[10]={3,1,4,5,2,0,6,9,7,8};\n\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int id;\n    cin>>id;\n    T=insert(T,id, tmp[id] );\n  }\n\n  T=erase(T, 7);\n  \n  dfs(T);\n  cout<<endl;\n  */\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\nusing namespace std;\nstruct node {\n  int key, pri;\n  node *left, *right;\n};\ntypedef struct node* Node;\nNode NIL,root;\nNode _deletekey(Node, int);\nNode rightRotate(Node t) {\n  Node s = t->left;\n  t->left = s->right;\n  s->right = t;\n  if (root == t) root = s;\n  return s;\n}\nNode leftRotate(Node t) {\n  Node s = t->right;\n  t->right = s->left;\n  s->left = t;\n  if (root == t) root = s;\n  return s;\n}\nNode newnode(int key, int pri) {\n  Node newNode = (Node)malloc(sizeof(struct node));\n  newNode->key = key;\n  newNode->pri = pri;\n  newNode->right = newNode->left = NIL;\n  if (root == NIL) root = newNode;\n  return newNode;\n}\nNode insert(Node t, int key, int pri) {\n  if (t == NIL) return newnode(key,pri);\n  if (key == t->key) return t;\n  if (key < t->key) {\n    t->left = insert(t->left, key, pri);\n    if (t->pri < t->left->pri) t = rightRotate(t);\n  }\n  else {\n    t->right = insert(t->right, key, pri);\n    if (t->pri < t->right->pri) t = leftRotate(t);\n  }\n  return t;\n}\nNode deletekey(Node t,int key) {\n  if (t == NIL) return NIL;\n  if (key < t->key) t->left = deletekey(t->left, key);\n  else if (key > t->key) t->right = deletekey(t->right, key);\n  else return _deletekey(t, key);\n  return t;\n}\nNode _deletekey(Node t, int key) {\n  if (t->left == NIL && t->right == NIL) return NIL;\n  if (t->left == NIL) t = leftRotate(t);\n  else if (t->right == NIL) t = rightRotate(t);\n  else {\n    if (t->left->pri > t->right->pri) t = rightRotate(t);\n    else t = leftRotate(t);\n  }\n  return deletekey(t,key);\n}\nvoid inorder(Node p) {\n  if (p != NIL) {\n    inorder(p->left);\n    cout << \" \" << p->key;\n    inorder(p->right);\n  }\n}\nvoid preorder(Node p) {\n  if (p != NIL) {\n    cout << \" \" << p->key;\n    preorder(p->left);\n    preorder(p->right);\n  }\n}\nNode find(int x) {\n  Node r = root;\n  while (r != NIL) {\n    if (r->key == x) return r;\n    if (r->key<x) r = r->right;\n    else r = r->left;\n  }\n  return r;\n}\nint main() {\n  int n, x,y;\n  char s[7]; cin >> n;\n  for (int i = 0; i<n; ++i) {\n    cin >> s;\n    if (s[0] == 'i') {\n      cin >> x >> y;\n      insert(root,x,y);\n    }\n    else if (s[0] == 'p') {\n      inorder(root);\n      cout << endl;\n      preorder(root);\n      cout << endl;\n    }\n    else if (s[0] == 'f') {\n      cin >> x;\n      if (find(x) != NIL) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }\n    else {\n      cin >> x;\n      deletekey(root,x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nstruct node {\n\tnode* right, * left;\n\tint key, priority;\n};\n\nnode* root;\n\nnode* rightRotate(node* t) {\n\tnode* s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\n\nnode* leftRotate(node* t) {\n\tnode* s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\n\nnode* insert(node* t, int key, int priority) {\n\tif (t == NULL) {\n\t\tnode* add;\n\t\tadd = (node*)malloc(sizeof(node));\n\t\tadd->key = key;\n\t\tadd->priority = priority;\n\t\tadd->left = NULL; add->right = NULL;\n\t\treturn add;\n\t}\n\tif (key == t->key) return t;\n\n\tif (key < t->key) {\n\t\tt->left = insert(t->left, key, priority);\n\t\tif (t->priority < t->left->priority) t = rightRotate(t);\n\t} else {\n\t\tt->right = insert(t->right, key, priority);\n\t\tif (t->priority < t->right->priority) t = leftRotate(t);\n\t}\n\treturn t;\n}\n\nnode* find(int k) {\n\tnode* x = root;\n\twhile (x != NULL) {\n\t\tif (x->key == k) return x;\n\t\telse if (x->key > k) x = x->left;\n\t\telse x = x->right;\n\t}\n\treturn NULL;\n}\n\nnode* _delete(node*, int);\nnode* treeDelete(node* t, int key) {\n\tif (t == NULL) return NULL;\n\tif (key < t->key) t->left = treeDelete(t->left, key);\n\telse if (key > t->key) t->right = treeDelete(t->right, key);\n\telse return _delete(t, key);\n\treturn t;\n}\n\nnode* _delete(node* t, int key) {\n\tif (t->left == NULL && t->right == NULL) return NULL;\n\tif (t->left == NULL) t = leftRotate(t);\n\telse if (t->right == NULL) t = rightRotate(t);\n\telse {\n\t\tif (t->left->priority > t->right->priority) t = rightRotate(t);\n\t\telse t = leftRotate(t);\n\t}\n\treturn treeDelete(t, key);\n}\n\nvoid preorder(node* u) {\n\tif (u == NULL) return;\n\tcout << \" \" << u->key;\n\tpreorder(u->left);\n\tpreorder(u->right);\n}\n\nvoid inorder(node* u) {\n\tif (u == NULL) return;\n\tinorder(u->left);\n\tcout << \" \" << u->key;\n\tinorder(u->right);\n}\n\nint main() {\n\tint n; cin >> n;\n\twhile (n--) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tif (s == \"insert\") {\n\t\t\tint k, p; cin >> k >> p;;\n\t\t\troot = insert(root, k, p);\n\t\t} else if (s == \"find\") {\n\t\t\tint k; cin >> k;\n\t\t\tcout << (find(k) != NULL ? \"yes\" : \"no\") << endl;\n\t\t} else if (s == \"delete\") {\n\t\t\tint k; cin >> k;\n\t\t\troot = treeDelete(root, k);\n\t\t} else {\n\t\t\tinorder(root);\n\t\t\tcout << endl;\n\t\t\tpreorder(root);\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <string>\nusing namespace std;\n\nstruct Node {\n\tNode *parent, *right, *left;\n\tint key;\n\tint priority;\n};\n\nNode *root, *NIL;\n\nNode * deleteN(Node *, int);\nNode * _delete(Node *, int);\n\n\nNode * createNode(int key,int priority){\n\tNode *n = new Node;\n\tn->key = key;\n\tn->priority = priority;\n\tn->left = NIL;\n\tn->right = NIL;\n\treturn n;\n}\n\nNode * rightRotate(Node *t){\n\tNode *s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\n\n/*\nrightRotate(Node t)\n    Node s = t.left\n    t.left = s.right\n    s.right = t\n    return s // root of the subtree\n*/\n\nNode * leftRotate(Node *t){\n\tNode *s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\n\n/*\nleftRotate(Node t)\n    Node s = t.right\n    t.right = s.left\n    s.left = t\n    return s // root of the subtree\n*/\n\nNode * insert(Node *t, int key, int priority){\n\t//cout << \"insertはいってる\" << endl;\n\tif(t == NIL){\n\t\treturn createNode(key, priority);\n\t}\n\tif(key < t->key){\n\t\tt->left = insert(t->left, key, priority);\n\t\tif(t->priority < t->left->priority){\n\t\t\tt = rightRotate(t);\n\t\t}\n\t}\n\telse{\n\t\tt->right = insert(t->right, key, priority);\n\t\tif(t->priority < t->right->priority){\n\t\t\tt = leftRotate(t);\n\t\t}\n\t}\n\treturn t;\n}\n\n/*\ninsert(Node t, int key, int priority){}           // 再帰的に探索\n    if t == NIL\n        return Node(key, priority)               // 葉に到達したら新しい節点を生成して返す\n    if key == t.key\n        return t;                               // 重複したkeyは無視\n\n    if key < t.key                               // 左の子へ移動\n        t.left = insert(t.left, key, priority)   // 左の子へのポインタを更新\n        if t.priority < t.left.priority          // 左の子の方が優先度が高い場合右回転\n            t = rightRotate(t)\n    else                                         // 右の子へ移動\n        t.right = insert(t.right, key, priority) // 右の子へのポインタを更新\n        if t.priority < t.right.priority         // 右の子の方が優先度が高い場合左回転\n            t = leftRotate(t)\n\n  return t;\n*/\n\nNode * deleteN(Node *t, int key){\n\tif(t == NIL){\n\t\treturn NIL;\n\t}\n\tif(key < t->key){\n\t\tt->left = deleteN(t->left, key);\n\t}\n\telse if(key > t->key){\n\t\tt->right = deleteN(t->right, key);\n\t}\n\telse{\n\t\treturn _delete(t, key);\n\t}\n\treturn t;\n}\n\n/*\ndelete(Node t, int key)\n    if t == NIL\n        return NIL\n    if key < t.key                                // 削除対象を検索\n        t.left = delete(t.left, key)\n    else if key > t.key\n        t.right = delete(t.right, key)\n    else\n        return _delete(t, key)\n    return t\n*/\n\nNode * _delete(Node *t, int key){\n\tif(t->left == NIL && t->right == NIL){\n\t\treturn NIL;\n\t}\n\telse if(t->left == NIL){\n\t\tt = leftRotate(t);\n\t}\n\telse if(t->right == NIL){\n\t\tt = rightRotate(t);\n\t}\n\telse{\n\t\tif(t->left->priority > t->right->priority){\n\t\t\tt = rightRotate(t);\n\t\t}\n\t\telse{\n\t\t\tt = leftRotate(t);\n\t\t}\n\t}\n\treturn deleteN(t,key);\n}\n\n/*\n_delete(Node t, key) // 削除対象の節点の場合\n    if t.left == NIL && t.right == NIL           // 葉の場合\n        return NIL\n    else if t.left == NIL                        // 右の子のみを持つ場合左回転\n        t = leftRotate(t)\n    else if t.right == NIL                       // 左の子のみを持つ場合右回転\n        t = rightRotate(t)\n    else                                         // 左の子と右の子を両方持つ場合\n        if t.left.priority > t.right.priority    // 優先度が高い方を持ち上げる\n            t = rightRotate(t)\n        else\n            t = leftRotate(t)\n    return delete(t, key)\n*/\n\n\nNode * find(Node *t,int key){\n\twhile(t != NIL && key != t->key){\n\t\tif(key < t->key){\n\t\t\tt = t->left;\n\t\t}\n\t\telse{\n\t\t\tt = t->right;\n\t\t}\n\t}\n\n\treturn t;\n}\n\n/*\nint maxValue(Node *t){\n\tif(t->right != NIL) maxValue(t->right);\n\telse{\n\t\treturn t->key;\n\t}\n}\n*/\n\nvoid inorder(Node *t){\n\tif(t == NIL)return;\n\tinorder(t->left);\n\tcout << \" \" << t->key;\n\tinorder(t->right);\n}\n\nvoid preorder(Node *t){\n\tif(t == NIL)return;\n\tcout << \" \" << t->key;\n\tpreorder(t->left);\n\tpreorder(t->right);\n}\n\nint main(){\n\troot = NIL;\n\tint n,x,y;\n\tstring s;\n\tcin >> n;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> s;\n\n\t\tif(s == \"insert\"){\n\t\t\tcin >> x >> y;\n\t\t\troot = insert(root, x, y);\n\t\t}\n\n\t\tif(s == \"delete\"){\n\t\t\tcin >> x;\n\t\t\troot = deleteN(root, x);\n\t\t}\n\n\t\tif(s == \"find\"){\n\t\t\tcin >> x;\n\t\t\tNode *t = find(root, x);\n\t\t\tif(t != NIL){\n\t\t\t\tcout << \"yes\" << endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout << \"no\" << endl;\n\t\t\t}\n\t\t}\n\n\t\tif(s == \"print\"){\n\t\t\tinorder(root);\n\t\t\tcout << endl;\n\t\t\tpreorder(root);\n\t\t\tcout << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\n#define ORDER_MAX 200000\n#define DATA_MAX 2000000000\n\nclass Treap{\n    struct Node{\n        int key;\n        int value;\n        Node *left;\n        Node *right;\n        \n        Node(){\n            key = 0;\n            value = 0;\n            left = NULL;\n            right = NULL;\n        }\n        \n        Node(int k, int v){\n            key = k;\n            value = v;\n            left = NULL;\n            right = NULL;\n        }\n        \n        ~Node(){\n            key = -1;\n            value = -1;\n            left = NULL;\n            right = NULL;\n        }\n    };\n    \nprivate:\n    Node *tree;\n    \n    Node* insert(Node *target, int key, int value){\n        if(target == NULL)\n            return new Node(key, value);\n        if(key == target->key)\n            return target;\n        \n        if(key < target->key){\n            target->left = insert(target->left, key, value);\n            if(target->value < target->left->value)\n                target = Righting(target);\n        }\n        else{\n            target->right = insert(target->right, key, value);\n            if(target->value < target->right->value)\n                target = Lefting(target);\n        }\n        \n        return target;\n    }\n    \n    Node* Lefting(Node *target){\n        Node *tmp = target->right;\n        target->right = tmp->left;\n        tmp->left = target;\n        return tmp;\n    }\n    \n    Node* Righting(Node *target){\n        Node *tmp = target->left;\n        target->left = tmp->right;\n        tmp->right = target;\n        return tmp;\n    }\n    \n    \n    \n    void in_order(Node *n){\n        if(n == NULL)\n            return;\n        \n        in_order(n->left);\n        cout << \" \" << n->key;\n        in_order(n->right);\n    }\n    \n    void pre_order(Node *n){\n        if(n == NULL)\n            return;\n        \n        cout << \" \" << n->key;\n        pre_order(n->left);\n        pre_order(n->right);\n    }\n    \n    Node* erase(Node *target, int key){\n        if(target == NULL)\n            return NULL;\n        \n        if(key == target->key){\n            if(target->right == NULL && target->left == NULL){\n                delete target;\n                return NULL;\n            }\n            else if(target->left == NULL)\n                target = Lefting(target);\n            else if(target->right == NULL)\n                target = Righting(target);\n            else\n                target = target->left->value > target->right->value ? Righting(target) : Lefting(target);\n        }\n        \n        if(key < target->key)\n            target->left = erase(target->left, key);\n        else\n            target->right = erase(target->right, key);\n        \n        return target;\n    }\n    \npublic:\n    Treap(){\n        tree = NULL;\n    }\n    \n    Node* find(int k){\n        for(Node *target = tree; target != NULL; target = k < target->key ? target->left : target->right)\n            if(k == target->key)\n                return target;\n        \n        return NULL;\n    }\n    \n    void insert(int k, int v){\n        tree = insert(tree, k, v);\n    }\n    \n    void erase(int k){\n        tree = erase(tree, k);\n    }\n    \n    void print(){\n        in_order(tree);\n        cout << endl;\n        pre_order(tree);\n        cout << endl;\n    }\n};\n\nint main(){\n    Treap th;\n    int n;\n    string op;\n    int k ,v;\n    \n    cin >> n;\n    if(!(0 <= n && n <= ORDER_MAX))\n        return -1;\n    \n    for(int i = 0; i < n; i++){\n        cin >> op;\n        if(op == \"print\")\n            th.print();\n        else if(op == \"insert\"){\n            cin >> k >> v;\n            if(!(0 <= k && k <= DATA_MAX) || !(0 <= v && v <= DATA_MAX))\n                return -1;\n            th.insert(k, v);\n        }\n        else if(op == \"find\"){\n            cin >> k;\n            if(!(0 <= k && k <= DATA_MAX))\n                return -1;\n            cout << (th.find(k) == NULL ? \"no\" : \"yes\") << endl;\n        }\n        else if(op == \"delete\"){\n            cin >> k;\n            if(!(0 <= k && k <= DATA_MAX))\n                return -1;\n            th.erase(k);\n        }\n        else\n            return -1;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef struct Node\n{\n    int key, priority;\n    struct Node *left, *right;\n} Node;\n\nclass Treap\n{\nprivate:\n    Node *root;\n\n    void setNode(Node *node, int key, int priority, Node *left, Node *right)\n    {\n        node->key = key;\n        node->priority = priority;\n        node->left = left;\n        node->right = right;\n    };\n\n    Node *allocNode()\n    {\n        return (Node *)malloc(sizeof(Node));\n    };\n\n    Node *allocNode(int key, int priority, Node *left, Node *right)\n    {\n        Node *node = allocNode();\n        setNode(node, key, priority, left, right);\n        return node;\n    };\n\n    void preorder(Node *node)\n    {\n        if (node == NULL)\n            return;\n        printf(\" %d\", node->key);\n        preorder(node->left);\n        preorder(node->right);\n    };\n\n    void inorder(Node *node)\n    {\n        if (node == NULL)\n            return;\n        inorder(node->left);\n        printf(\" %d\", node->key);\n        inorder(node->right);\n    };\n\n    bool findNode(int key, Node *node)\n    {\n        if (node == NULL)\n            return false;\n        if (key == node->key)\n            return true;\n        if (key < node->key)\n            return findNode(key, node->left);\n        return findNode(key, node->right);\n    }\n\n    Node *rightRotate(Node *node)\n    {\n        Node *tmp = node->left;\n        node->left = tmp->right;\n        tmp->right = node;\n        return tmp;\n    };\n\n    Node *leftRotate(Node *node)\n    {\n        Node *tmp = node->right;\n        node->right = tmp->left;\n        tmp->left = node;\n        return tmp;\n    };\n\n    Node *insertNode(Node *node, int key, int priority)\n    {\n        if (node == NULL)\n            return allocNode(key, priority, NULL, NULL);\n        if (key == node->key)\n            return node;\n        if (key < node->key)\n        {\n            node->left = insertNode(node->left, key, priority);\n            if (node->priority < node->left->priority)\n                node = rightRotate(node);\n        }\n        else\n        {\n            node->right = insertNode(node->right, key, priority);\n            if (node->priority < node->right->priority)\n                node = leftRotate(node);\n        }\n        return node;\n    };\n\n    Node *deleteNode(Node *node, int key)\n    {\n        if (node->left == NULL && node->right == NULL)\n            return NULL;\n        else if (node->left == NULL)\n            node = leftRotate(node);\n        else if (node->right == NULL)\n            node = rightRotate(node);\n        else\n        {\n            if (node->left->priority > node->right->priority)\n                node = rightRotate(node);\n            else\n                node = leftRotate(node);\n        }\n        return _deleteNode(node, key);\n    }\n\n    Node *_deleteNode(Node *node, int key)\n    {\n        if (node == NULL)\n            return NULL;\n        if (key < node->key)\n            node->left = _deleteNode(node->left, key);\n        else if (key > node->key)\n            node->right = _deleteNode(node->right, key);\n        else\n            return deleteNode(node, key);\n        return node;\n    }\n\npublic:\n    Treap()\n    {\n        root = NULL;\n    };\n\n    void insert(int key, int priority)\n    {\n        root = insertNode(root, key, priority);\n    };\n\n    void printPreorder()\n    {\n        preorder(root);\n    };\n\n    void printInorder()\n    {\n        inorder(root);\n    };\n\n    bool find(int key)\n    {\n        if (findNode(key, root))\n        {\n            cout << \"yes\" << endl;\n            return true;\n        }\n\n        cout << \"no\" << endl;\n        return false;\n    };\n\n    void deleteKey(int key)\n    {\n        root = _deleteNode(root, key);\n    };\n};\n\nint main()\n{\n    int n;\n    Treap tree;\n    cin >> n;\n    string s;\n    while (n--)\n    {\n        cin >> s;\n        if (s == \"insert\")\n        {\n            int a, b;\n            cin >> a >> b;\n            tree.insert(a, b);\n        }\n        else if (s == \"find\")\n        {\n            int a;\n            cin >> a;\n            tree.find(a);\n        }\n        else if (s == \"delete\")\n        {\n            int a;\n            cin >> a;\n            tree.deleteKey(a);\n        }\n        else if (s == \"print\")\n        {\n            tree.printInorder();\n            cout << endl;\n            tree.printPreorder();\n            cout << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\ntypedef struct node* Node;\nstruct node{\n  Node right;\n  Node left;\n  int key,pri;\n};\n\nNode rightRotato(Node t) {\n    Node s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n}\n\nNode leftRotato(Node t) {\n    Node s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;\n}\n\nNode insert(Node t, int key, int pri) {\n    if(t == NULL) {\n        Node t = new struct node;\n        t->left=NULL; t->right = NULL;\n        t->key = key; t->pri = pri;\n        return t;\n    }\n    if(key == t->key) return t;\n\n    if(key < t->key) {\n        t->left = insert(t->left, key, pri);\n        if(t->pri < t->left->pri) t = rightRotato(t);\n    }\n    else {\n        t->right = insert(t->right, key, pri);\n        if(t->pri < t->right->pri) t = leftRotato(t);\n    }\n    return t;\n}\n\nNode erase(Node t, int key){\n    if(t == NULL) return NULL;\n\n    if(key == t->key) {\n        if(t->left == NULL && t->right == NULL) return NULL;\n        else if(t->left == NULL) t = leftRotato(t);\n        else if(t->right == NULL) t = rightRotato(t);\n        else {\n            if(t->left->pri > t->right->pri) t = rightRotato(t);\n            else t = leftRotato(t);\n        }\n        return erase(t,key);\n    }\n    if(key < t->key) t->left = erase(t->left, key);\n    else t->right = erase(t->right, key);\n    return t;\n}\n\nvoid find(Node t, int key) {\n    while(t != NULL && key != t->key) {\n        if(key < t->key) t = t->left;\n        else t = t->right;\n    }\n    if(t == NULL) cout << \"no\" << endl;\n    else cout << \"yes\" << endl;\n}\n\nvoid inorder(Node t) {\n    if(t==NULL) return;\n    inorder(t->left);\n    cout << \" \" << t->key;\n    inorder(t->right);\n}\n\nvoid preorder(Node t) {\n    if(t == NULL) return;\n    cout << \" \" << t->key;\n    preorder(t->left);\n    preorder(t->right);\n}\n\nint main() {\n    Node root;\n    int n,key,pri;\n    string s;\n\n    cin >> n;\n    for(int i=0; i<n; i++) {\n        cin >> s;\n        if(s == \"insert\") {\n            cin >> key >> pri;\n            root = insert(root, key, pri);\n        }\n        else if(s == \"delete\") {\n            cin >> key;\n            root = erase(root, key);\n        }\n        else if(s == \"find\") {\n            cin >> key;\n            find(root, key);\n        }\n        else {\n            inorder(root);\n            cout << endl;\n            preorder(root);\n            cout << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nstruct Node{\n  struct Node* left;\n  struct Node* right;\n  int key, pri;\n};\n\nNode* create(int key, int pri){\n  Node* t = new Node;\n  t->key = key;\n  t->pri = pri;\n  t->left = t->right = NULL;\n  return t;\n}\n\nNode* rightRotate(Node* t){\n  Node* s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\n\nNode* leftRotate(Node* t){\n  Node* s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\n\nNode* insert(Node* t, int key, int pri){\n  if(t == NULL) return create(key, pri);\n  if(key == t->key) return t;\n\n  if(key < t->key){\n    t->left = insert(t->left,key,pri);\n    if(t->pri < t->left->pri) t = rightRotate(t);\n  }\n  else{\n    t->right = insert(t->right,key,pri);\n    if(t->pri < t->right->pri) t = leftRotate(t);\n  }\n  return t;\n}\n\nNode* erase(Node* t, int key){\n  if(t == NULL) return NULL;\n\n  if(key == t->key){\n    if(t->left == NULL && t->right == NULL) return NULL;\n    else if(t->left == NULL) t = leftRotate(t);\n    else if(t->right == NULL) t = rightRotate(t);\n    else{\n      if(t->left->pri > t->right->pri) t = rightRotate(t);\n      else t = leftRotate(t);\n    }\n    return erase(t,key);\n  }\n  if(key < t->key) t->left = erase(t->left,key);\n  else t->right = erase(t->right,key);\n\n  return t;\n}\n\nvoid inorder(Node* t){\n  if(t == NULL) return;\n  inorder(t->left);\n  cout << \" \" << t->key;\n  inorder(t->right);\n}\n\nvoid preorder(Node* t){\n  if(t == NULL) return;\n  cout << \" \" << t->key;\n  preorder(t->left);\n  preorder(t->right);\n}\n\nvoid print(Node* t){\n  inorder(t);\n  cout << endl;\n  preorder(t);\n  cout << endl;\n}\n\nvoid find(Node* t, int key){\n  if(t == NULL){\n    cout << \"no\" << endl;\n    return;\n  }\n  if(t->key == key){\n    cout << \"yes\" << endl;\n    return;\n  }\n  if(t->key > key) find(t->left,key);\n  else find(t->right,key);\n}\n\nint main(){\n  Node* t = NULL;\n  int m, key, pri;\n  string str;\n  cin >> m;\n  for(int i = 0; i < m; i++){\n    cin >> str;\n    if(str == \"insert\"){\n      cin >> key >> pri;\n      t = insert(t,key,pri);\n    }\n    else if(str == \"find\"){\n      cin >> key;\n      find(t,key);\n    }\n    else if(str == \"delete\"){\n      cin >> key;\n      t = erase(t,key);\n    }\n    else print(t);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\nusing namespace std;\n#define MAX 100000\n\nint parent(int i){return i/2;}\nint left(int i){return 2*i;}\nint right(int i){return 2*i+1;}\n\nint main(int argc, char const *argv[])\n{\n    int H, *A;\n    A = (int *)malloc(sizeof(int)*MAX);\n\n    cin >> H;\n    for(int i=1; i<=H; i++) cin >> A[i];\n    \n    for(int i=1; i<=H; i++){\n        cout << \"node \" << i <<\": key = \" << A[i] << \", \";\n        if(parent(i) >= 1) cout << \"parent key = \" << A[parent(i)] << \", \";\n        if(left(i) <= H) cout << \"left key = \" << A[left(i)] << \", \";\n        if(right(i) <= H) cout << \"right key = \" << A[right(i)] << \", \";\n        cout << endl;\n    }\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Node {\npublic:\n    int key, priority;\n    Node *left, *right;\n    Node(int key, int priority)\n    {\n        this->key = key;\n        this->priority = priority;\n        this->left = NULL;\n        this->right = NULL;\n    }\n};\n\nNode *leftRotate(Node *t)\n{\n    Node *s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;\n}\n\nNode *rightRotate(Node *t)\n{\n    Node *s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n}\n\nNode *insert(Node *t, int key, int priority)\n{\n    if (t == NULL)\n        return new Node(key, priority);\n    if (key == t->key)\n        return t;\n    if (key < t->key)\n    {\n        t->left = insert(t->left, key, priority);\n        if (t->priority < t->left->priority)\n            t = rightRotate(t);\n    }\n    else\n    {\n        t->right = insert(t->right, key, priority);\n        if (t->priority < t->right->priority)\n            t = leftRotate(t);\n    }\n    return t;\n}\n\nNode *deletHelper(Node *, int);\n\nNode *delet(Node *t, int key)\n{\n    if (t == NULL)\n        return NULL;\n    if (key < t->key)\n        t->left = delet(t->left, key);\n    else if (key > t->key)\n        t->right = delet(t->right, key);\n    else\n        return deletHelper(t, key);\n    return t;\n}\n\nNode *deletHelper(Node *t, int key)\n{\n    if (t->left == NULL && t->right == NULL)\n    {\n        delete t;\n        return NULL;\n    }\n    else if (t->left == NULL)\n        t = leftRotate(t);\n    else if (t->right == NULL)\n        t = rightRotate(t);\n    else\n    {\n        if (t->left->priority > t->right->priority)\n            t = rightRotate(t);\n        else\n            t = leftRotate(t);\n    }\n    return delet(t, key);\n}\n\nvoid find(Node *t, int key)\n{\n    if (t == NULL)\n    {\n        cout << \"no\" << endl;\n        return;\n    }\n    else if (key == t->key)\n    {\n        cout << \"yes\" << endl;\n        return;\n    }\n    else if (key < t->key)\n        find(t->left, key);\n    else\n        find(t->right, key);\n    return;\n}\n\nvoid printInorder(Node *t)\n{\n    if (t == NULL)\n        return;\n    printInorder(t->left);\n    cout << ' ' << t->key;\n    printInorder(t->right);\n    return;\n}\n\nvoid printPreorder(Node *t)\n{\n    if (t == NULL)\n        return;\n    cout << ' ' << t->key;\n    printPreorder(t->left);\n    printPreorder(t->right);\n    return;\n}\n\nint main(int argc, char const *argv[])\n{\n    int n;\n    cin >> n;\n    Node *root = NULL;\n    for (int i = 0; i < n; i++)\n    {\n        string operation;\n        cin >> operation;\n        if (operation == \"insert\")\n        {\n            int k, p;\n            cin >> k >> p;\n            root = insert(root, k, p);\n        }\n        else if (operation == \"find\")\n        {\n            int k;\n            cin >> k;\n            find(root, k);\n        }\n        else if (operation == \"delete\")\n        {\n            int k;\n            cin >> k;\n            root = delet(root, k);\n        }\n        else\n        {\n            printInorder(root);\n            cout << endl;\n            printPreorder(root);\n            cout << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\ntypedef struct Node{\n  int value, priority;\n  Node *left, *right;\n} Node;\n\nNode* Delete(Node *, int);\nNode* _delete(Node *, int);\n\nNode *NIL, *root;\n\nNode* rightRotate(Node *t){\n  Node *s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s; // root of the subtree\n}\n\nNode* leftRotate(Node *t){\n  Node *s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s; // root of the subtree\n}\n\nNode* makenode(int key, int priority){\n  Node *node = (Node *)malloc(sizeof(Node));\n  node->value = key;\n  node->priority = priority;\n  node->left = node->right = NIL;\n\n  return node;\n}\n\nNode* insert(Node *t, int key, int priority){    //search recursively\n  Node *x;\n\n  if(t == NIL) return x = makenode(key, priority); //reach a leaf, make new node and return that\n\n  if(key == t->value) return t;                //ignore duplicative key\n\n  if(key < t->value){                          //move the left child\n      t->left = insert(t->left, key, priority); //update the pointer to left child\n      if(t->priority < t->left->priority) t = rightRotate(t); //when left child's priority is larger, right rotate\n  }else{                                       //move the right child\n      t->right = insert(t->right, key, priority); //update the pointer to right child\n      if(t->priority < t->right->priority) t = leftRotate(t); //when right chil's priority is larger, left rotate\n  }\n\n  return t;\n}\n\nNode* find(Node *x, int k){\n  if(x == NIL || x->value == k) return x;\n\n  if(k < x->value) return find(x->left, k);\n  else return find(x->right, k);\n}\n\nNode* Delete(Node *t, int key){\n  if(t == NIL) return NIL;\n  if(key < t->value) t->left = Delete(t->left, key); //search the node that should be deleted\n  else if(key > t->value) t->right = Delete(t->right, key);\n  else return _delete(t, key);\n  return t;\n}\n\nNode* _delete(Node *t, int key){ //case of the node should be deleted\n  if(t->left == NIL && t->right == NIL) return NIL; //case of leaf\n  else if(t->left == NIL) t = leftRotate(t);   //if have only right child, left rotate\n  else if(t->right == NIL) t = rightRotate(t); //if have only left child, right rotate\n  else{                                        //if have two children, lift a node have larger priority up\n    if(t->left->priority > t->right->priority) t = rightRotate(t);\n    else t = leftRotate(t);\n  }\n  return Delete(t, key);\n}\n\nvoid preParse(Node *node){\n  if(node == NIL) return ;\n\n  cout << \" \" << node->value;\n  if(node->left != NIL) preParse(node->left);\n  if(node->right != NIL) preParse(node->right);\n}\n\nvoid inParse(Node *node){\n  if(node == NIL) return ;\n\n  if(node->left != NIL) inParse(node->left);\n  cout << \" \" << node->value;\n  if(node->right != NIL) inParse(node->right);\n}\n\nint main(){\n\n  int n, key, priority;\n  string command;\n\n  //input\n  cin >> n;\n  for(int i = 0;i < n;i++){\n    cin >> command;\n    if(command == \"insert\"){\n      cin >> key >> priority;\n      root = insert(root, key, priority);\n    }else if(command == \"print\"){\n      inParse(root);\n      cout << endl;\n      preParse(root);\n      cout << endl;\n    }else if(command == \"find\"){\n      cin >> key;\n      if(find(root, key)) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }else if(command == \"delete\"){\n      cin >> key;\n      root = Delete(root, key);\n    }\n  }\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <limits>\n#include <functional>\n\nnamespace structure {\n  template<typename T, size_t dcap = 16ULL>\n  class vec {\n    size_t sz;\n    size_t cap;\n    T* a;\n    void extend() {\n      size_t ncap = cap << 1;\n      T* b = new T[ncap];\n      for (int i = 0; i < cap; i++) b[i] = a[i];\n      delete[] a;\n      a = b;\n      cap = ncap;\n    }\n  public:\n    vec() : sz(0), cap(dcap) {\n      a = new T[cap];\n    }\n    vec(size_t n) : sz(n), cap(dcap) {\n      while (cap < sz) cap <<= 1;\n      a = new T[cap];\n    }\n    vec(size_t n, T v) : sz(n), cap(dcap) {\n      while (cap < sz) cap <<= 1;\n      a = new T[cap];\n      for (size_t i = 0; i < sz; i++) {\n        a[i] = v;\n      }\n    }\n    vec(const vec<T>& v) {\n      sz = v.sz;\n      cap = v.cap;\n      a = new T[cap];\n      std::memcpy(a, v.a, sizeof(T) * sz);\n    }\n    vec<T>& operator=(const vec<T>& v) {\n      sz = v.sz;\n      cap = v.cap;\n      delete[] a;\n      a = new T[cap];\n      std::memcpy(a, v.a, sizeof(T) * sz);\n      return *this;\n    }\n    T& operator[](size_t i) {\n      return a[i];\n    }\n    T front() const {\n      return a[0];\n    }\n    T back() const {\n      return a[sz - 1];\n    }\n    void push_back(const T& x) {\n      if (sz == cap) extend();\n      a[sz++] = x;\n    }\n    void pop_back() {\n      sz--;\n    }\n    size_t size() const {\n      return sz;\n    }\n    bool empty() const {\n      return !sz;\n    }\n    void output(std::ostream& out, char delim = ' ') const {\n      for (size_t i = 0; i < sz; i++) {\n        if (i) out << delim;\n        out << a[i];\n      }\n    }\n    friend std::ostream& operator<<(std::ostream& out, const vec& v) {\n      v.output(out);\n      return out;\n    }\n    void input(std::istream& in) {\n      for (size_t i = 0; i < sz; i++) {\n        in >> a[i];\n      }\n    }\n    friend std::istream& operator>>(std::istream& in, vec& v) {\n      v.input(in);\n      return in;\n    }\n    ~vec() {\n      delete[] a;\n    }\n  };\n  template<typename T, size_t dcap = 16ULL>\n  class que {\n    size_t begin, end;\n    size_t sz;\n    size_t cap;\n    T* a;\n    void extend() {\n      size_t ncap = cap << 1;\n      T* b = new T[ncap];\n      for (int i = begin; i < begin + cap; i++) b[i] = a[i & (cap - 1)];\n      end += cap;\n      delete[] a;\n      a = b;\n      cap = ncap;\n    }\n  public:\n    que() : begin(0), end(0), sz(0), cap(dcap) {\n      a = new T[cap];\n    }\n    T front() const {\n      return a[begin];\n    }\n    void push(const T& x) {\n      if (sz == cap) extend();\n      a[end++] = x;\n      sz++;\n      end &= cap - 1;\n    }\n    void pop() {\n      begin = (begin + 1) & (cap - 1);\n      sz--;\n    }\n\n    size_t size() const {\n      return sz;\n    }\n    bool empty() const {\n      return !sz;\n    }\n    void output(std::ostream& out, char delim = ' ') const {\n      if (sz == cap) {\n        for (size_t i = begin; i != (cap + end - 1) & (cap - 1); i = (i + 1) & (cap - 1)) {\n          if (i != begin) out << delim;\n          out << a[i];\n        }\n        out << delim << a[(cap + end - 1) & (cap - 1)];\n      }\n      else {\n        for (size_t i = begin; i != end; i = (i + 1) & (cap - 1)) {\n          if (i != begin) out << delim;\n          out << a[i];\n        }\n      }\n    }\n    friend std::ostream& operator<<(std::ostream& out, const que& v) {\n      v.output(out);\n      return out;\n    }\n    ~que() {\n      delete[] a;\n    }\n  };\n  template<typename S, typename T>\n  struct pair {\n    S first;\n    T second;\n    pair() {}\n    pair(S first, T second) : first(first), second(second) {}\n    void output(std::ostream& out, char delim = ' ') const {\n      out << first << delim << second;\n    }\n    friend std::ostream& operator<<(std::ostream& out, const pair& p) {\n      p.output(out);\n      return out;\n    }\n    void input(std::istream& in) {\n      in >> first >> second;\n    }\n    friend std::istream& operator>>(std::istream& in, pair& p) {\n      p.input(in);\n      return in;\n    }\n  };\n  template<typename T>\n  class list {\n    struct node {\n      T val;\n      node* prev;\n      node* next;\n      node() : prev(nullptr), next(nullptr) {}\n      node(node* prev, node* next) : prev(prev), next(next) {}\n      node(const T& val, node* prev, node* next) : val(val), prev(prev), next(next) {}\n    };\n    node* head;\n    size_t sz;\n  public:\n    list() {\n      head = new node;\n      head->next = head->prev = head;\n    }\n    void push_front(const T& val) {\n      node* n = new node(val, head, head->next);\n      n->prev->next = n;\n      n->next->prev = n;\n      sz++;\n    }\n    void erase(node* n) {\n      n->prev->next = n->next;\n      n->next->prev = n->prev;\n      delete n;\n      sz--;\n    }\n    void pop_front() {\n      erase(head->next);\n    }\n    void pop_back() {\n      erase(head->prev);\n    }\n    bool erase(const T& val) {\n      for (node* n = head->next; n != head; n = n->next) {\n        if (n->val == val) {\n          erase(n);\n          return true;\n        }\n      }\n      return false;\n    }\n    size_t size() const {\n      return sz;\n    }\n    void output(std::ostream& out, char delim = ' ') const {\n      for (node* n = head->next; n != head; n = n->next) {\n        if (n != head->next) out << delim;\n        out << n->val;\n      }\n    }\n    friend std::ostream& operator<<(std::ostream& out, const list& l) {\n      l.output(out);\n      return out;\n    }\n  };\n  // T have +-*/ and 0\n  template<class T> class BIT {\n  public:\n    vec<T> dat;\n    int N;\n    BIT() {}\n    BIT(int N) : N(N), dat(N, 0) {}\n    // sum [0,c)\n    T sum(int i) {\n      T ret = 0;\n      for (--i; i >= 0; i = (i & (i + 1)) - 1) ret += dat[i];\n      return ret;\n    }\n    // sum [c,j1)\n    T sum(int i1, int i2) { return sum(i2) - sum(i1); }\n    T at(int i) { return sum(i, i + 1); }\n    // add x to c\n    void add(int i, T x) { for (; i < N; i |= i + 1) dat[i] += x; }\n  };\n}\n\nnamespace algorithm {\n  template<typename T>\n  void insertion_sort(structure::vec<T>& v, bool verbose = false) {\n    for (int i = 0, n = v.size(); i < n; i++) {\n      int x = v[i], j;\n      for (j = i - 1; j >= 0 && v[j] > x; j--) {\n        v[j + 1] = v[j];\n      }\n      v[j + 1] = x;\n      if (verbose) std::cout << v << std::endl;\n    }\n  }\n  template<typename T>\n  size_t bubble_sort(structure::vec<T>& v) {\n    size_t cnt = 0;\n    int n = v.size();\n    for (int i = 0; i < n - 1; i++) {\n      for (int j = n - 1; j > i; j--) {\n        if (v[j] < v[j - 1]) {\n          T t = v[j - 1];\n          v[j - 1] = v[j];\n          v[j] = t;\n          cnt++;\n        }\n      }\n    }\n    return cnt;\n  }\n  template<typename T>\n  size_t selection_sort(structure::vec<T>& v) {\n    size_t cnt = 0;\n    int n = v.size();\n    for (int i = 0; i < n; i++) {\n      int minj = i;\n      for (int j = i; j < n; j++) {\n        if (v[j] < v[minj]) minj = j;\n      }\n      T t = v[i];\n      v[i] = v[minj];\n      v[minj] = t;\n      cnt += (v[i] != v[minj]);\n    }\n    return cnt;\n  }\n  template<typename T>\n  size_t upper_bound(structure::vec<T>& v, const T& x) {\n    // x より大きい最初の要素の添字を返す\n    if (x < v[0]) return 0;\n    if (v.back() <= x) return v.size();\n    int ng = 0, ok = v.size() - 1;\n    while (abs(ok - ng) > 1) {\n      int mid = (ng + ok) / 2;\n      (v[mid] > x ? ok : ng) = mid;\n    }\n    return ok;\n  }\n  template<typename T>\n  size_t count(structure::vec<T>& v, const T& x) {\n    return upper_bound(v, x) - upper_bound(v, x - 1);\n  }\n  namespace impl {}\n  namespace {\n    namespace impl {\n      template<typename T>\n      void merge(structure::vec<T>& v, int l, int m, int r) {\n        T inf = std::numeric_limits<T>::max();\n        int i = l, j = 0, k = 0, n1 = m - l, n2 = r - m;\n        int* L = new int[n1 + 1];\n        int* R = new int[n2 + 1];\n        std::memcpy(L, &v[l], sizeof(T) * n1);\n        std::memcpy(R, &v[m], sizeof(T) * n2);\n        L[n1] = R[n2] = inf;\n        while (i < r) {\n          L[j] <= R[k] ? v[i] = L[j++] : v[i] = R[k++];\n          i++;\n        }\n        delete[] L;\n        delete[] R;\n      }\n      template<typename T>\n      void align(structure::vec<T>& v, int l, int r) {\n        if (l + 1 < r) {\n          int m = (l + r) / 2;\n          align(v, l, m);\n          align(v, m, r);\n          merge(v, l, m, r);\n        }\n      }\n    }\n    template<typename T>\n    void merge_sort(structure::vec<T>& v) {\n      impl::align(v, 0, v.size());\n    }\n  }\n  template<typename T>\n  struct MergeSorter {\n    using F = std::function<bool(T, T)>;\n    const F cmp;\n    const T inf;\n    structure::vec<T> v;\n    MergeSorter(const structure::vec<T>& v, const T& inf, const F cmp) : v(v), inf(inf), cmp(cmp) {}\n    void merge(int l, int m, int r) {\n      int i = l, j = 0, k = 0, n1 = m - l, n2 = r - m;\n      T* L = new T[n1 + 1];\n      T* R = new T[n2 + 1];\n      std::memcpy(L, &v[l], sizeof(T) * n1);\n      std::memcpy(R, &v[m], sizeof(T) * n2);\n      L[n1] = R[n2] = inf;\n      while (i < r) {\n        cmp(L[j], R[k]) ? v[i] = L[j++] : v[i] = R[k++];\n        i++;\n      }\n      delete[] L;\n      delete[] R;\n    }\n    void align(int l, int r) {\n      if (l + 1 < r) {\n        int m = (l + r) / 2;\n        align(l, m);\n        align(m, r);\n        merge(l, m, r);\n      }\n    }\n    void sort() {\n      align(0, v.size());\n    }\n  };\n  template<typename T>\n  struct QuickSorter {\n    using F = std::function<bool(T, T)>;\n    const F cmp;\n    structure::vec<T> v;\n    QuickSorter(const structure::vec<T>& v, const F cmp) : v(v), cmp(cmp) {}\n    int partition(int p, int r) {\n      T x = v[r], tmp;\n      int i = p - 1;\n      for (int j = p; j < r; j++) {\n        if (cmp(v[j], x)) {\n          i++; tmp = v[i]; v[i] = v[j]; v[j] = tmp;\n        }\n      }\n      i++; tmp = v[i]; v[i] = v[r]; v[r] = tmp;\n      return i;\n    }\n    void align(int p, int r) {\n      if (p < r) {\n        int q = partition(p, r);\n        align(p, q - 1);\n        align(q + 1, r);\n      }\n    }\n    void sort() {\n      align(0, v.size() - 1);\n    }\n  };\n}\n\nnamespace graph {\n\n  template<typename T>\n  class BinarySearchTree {\n    uint64_t _r = 88172645463325252LL;\n    unsigned rnd() {\n      _r = _r ^ (_r << 7);\n      return _r = _r ^ (_r >> 9);\n    }\n    struct Node {\n      T key;\n      unsigned priority;\n      Node* parent;\n      Node* left;\n      Node* right;\n      Node() {}\n      Node(const T& key) : key(key), priority(rnd()), parent(nullptr), left(nullptr), right(nullptr) {}\n      Node(const T& key, unsigned priority) : key(key), priority(priority), parent(nullptr), left(nullptr), right(nullptr) {}\n    };\n    Node* minimum(Node* x) {\n      while (x->left) x = x->left;\n      return x;\n    }\n    Node* successor(Node* x) {\n      if (x->right) return minimum(x->right);\n      Node* y = x->parent;\n      while (y && x == y->right) {\n        x = y;\n        y = y->parent;\n      }\n      return y;\n    }\n    Node* right_rotate(Node* t) {\n      Node* s = t->left;\n      t->left = s->right;\n      s->right = t;\n      return s;\n    }\n    Node* left_rotate(Node* t) {\n      Node* s = t->right;\n      t->right = s->left;\n      s->left = t;\n      return s;\n    }\n    Node* insert(Node* t, const T& key, unsigned priority) {\n      if (!t) return new Node(key, priority);\n      if (key == t->key) return t;\n      if (key < t->key) {\n        t->left = insert(t->left, key, priority);\n        if (t->priority < t->left->priority) t = right_rotate(t);\n      }\n      else {\n        t->right = insert(t->right, key, priority);\n        if (t->priority < t->right->priority) t = left_rotate(t);\n      }\n      return t;\n    }\n    Node* erase(Node* t, const T& key) {\n      if (!t) return t;\n      if (key < t->key) t->left = erase(t->left, key);\n      else if (key > t->key) t->right = erase(t->right, key);\n      else return _erase(t, key);\n      return t;\n    }\n    Node* _erase(Node* t, const T& key) {\n      if (!t->left && !t->right) {\n        delete t;\n        return nullptr;\n      }\n      else if (!t->left) t = left_rotate(t);\n      else if (!t->right) t = right_rotate(t);\n      else t = t->left->priority > t->right->priority ? right_rotate(t) : left_rotate(t);\n      return erase(t, key);\n    }\n    Node* root;\n  public:\n    BinarySearchTree() : root(nullptr) {}\n    void insert(const T& key) {\n      insert(root, key, rnd());\n    }\n    void insert(const T& key, unsigned priority) {\n      root = insert(root, key, priority);\n    }\n    Node* find(const T& key) const {\n      Node* x = root;\n      while (x && key != x->key) x = key < x->key ? x->left : x->right;\n      return x;\n    }\n    void erase(const T& key) {\n      root = erase(root, key);\n    }\n    void free(Node* x) {\n      if (!x) return;\n      if (x->left) free(x->left);\n      if (x->right) free(x->right);\n      delete x;\n    }\n    void print_preorder(const Node* n) const {\n      if (!n) return;\n      std::cout << ' ' << n->key;\n      print_preorder(n->left);\n      print_preorder(n->right);\n    }\n    void print_preorder() const {\n      print_preorder(root);\n    }\n    void print_inorder(const Node* n) const {\n      if (!n) return;\n      print_inorder(n->left);\n      std::cout << ' ' << n->key;\n      print_inorder(n->right);\n    }\n    void print_inorder() const {\n      print_inorder(root);\n    }\n    void print_postorder(const Node* n) const {\n      if (!n) return;\n      print_postorder(n->left);\n      print_postorder(n->right);\n      std::cout << ' ' << n->key;\n    }\n    void print_postorder() const {\n      print_postorder(root);\n    }\n    ~BinarySearchTree() {\n      free(root);\n    }\n  };\n}\n\nint main() {\n  using namespace structure;\n  using namespace algorithm;\n  using namespace graph;\n  using std::cin;\n  using std::cout;\n  using std::cerr;\n  using std::endl;\n  using std::string;\n\n  std::ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  BinarySearchTree<int> bst;\n\n  int m;\n  cin >> m;\n\n  for (int i = 0; i < m; i++) {\n    string op;\n    int k, p;\n    cin >> op;\n    switch (op[0]) {\n    case 'i':\n      cin >> k >> p;\n      bst.insert(k, p);\n      break;\n    case 'f':\n      cin >> k;\n      cout << (bst.find(k) ? \"yes\" : \"no\") << endl;\n      break;\n    case 'p':\n      bst.print_inorder();\n      cout << endl;\n      bst.print_preorder();\n      cout << endl;\n      break;\n    case 'd':\n      cin >> k;\n      bst.erase(k);\n      break;\n    default:\n      exit(1);\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define rep(i, n) for(int i=0;i<(n);++i)\n#define per(i, n) for(int i=(n)-1;i>=0;--i)\n#define repa(i, n) for(int i=1;i<(n);++i)\n#define foreach(i, n) for(auto &i:(n))\n#define pii pair<int, int>\n#define pll pair<long long, long long>\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\nconst ll MOD = (ll)1e9+7;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\nusing namespace std;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n\nll modpow(ll x, ll b){\n\tll res = 1;\n\twhile(b){\n\t\tif(b&1)res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nll modinv(ll x){\n\treturn modpow(x, MOD-2);\n}\n\n\nclass treap{\npublic:\n\tclass node{\n\tpublic:\n\t\tint key;\n\t\tint priority;\n\t\tnode *right;\n\t\tnode *left;\n\t\tnode():right(NULL), left(NULL){}\n\t\tnode(int k, int p):key(k), priority(p), right(NULL), left(NULL){}\n\t};\n\n\n\tnode *root;\n\n\ttreap():root(NULL){}\n\n\tnode* insert(int key, int priority){\n\t\treturn root = insert(root, key, priority);\n\t}\n\n\tnode* insert(node* t, int key, int priority){\n\t\tif(t == NULL){\n\t\t\treturn new node(key, priority);\n\t\t}\n\t\tif(key == t->key){\n\t\t\treturn t;\n\t\t}\n\t\tif(key < t->key){\n\t\t\tt->left = insert(t->left, key, priority);\n\t\t\tif(t->priority < t->left->priority){\n\t\t\t\tt = right_rotate(t);\n\t\t\t}\n\t\t}else{\n\t\t\tt->right = insert(t->right, key, priority);\n\t\t\tif(t->priority < t->right->priority){\n\t\t\t\tt = left_rotate(t);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\n\tnode* right_rotate(node *t){\n\t\tnode *s = t->left;\n\t\tt->left = s->right;\n\t\ts->right = t;\n\t\treturn s;\n\t}\n\n\tnode* left_rotate(node *t){\n\t\tnode *s = t->right;\n\t\tt->right = s->left;\n\t\ts->left = t;\n\t\treturn s;\n\t}\n\n\tnode* erase(int key){\n\t\troot = erase(root, key);\n\t}\n\n\tnode* erase(node *t, int key){\n\t\tif(t == NULL){\n\t\t\treturn NULL;\n\t\t}\n\t\tif(key < t->key){\n\t\t\tt->left = erase(t->left, key);\n\t\t}else if(key > t->key){\n\t\t\tt->right = erase(t->right, key);\n\t\t}else{\n\t\t\treturn _erase(t, key);\n\t\t}\n\t\treturn t;\n\t}\n\n\tnode* _erase(node* t, int key){\n\t\tif(t->left == NULL && t->right == NULL){\n\t\t\tdelete t;\n\t\t\treturn NULL;\n\t\t}else if(t->left == NULL){\n\t\t\tt = left_rotate(t);\n\t\t}else if(t->right == NULL){\n\t\t\tt = right_rotate(t);\n\t\t}else{\n\t\t\tif(t->left->priority > t->right->priority){\n\t\t\t\tt = right_rotate(t);\n\t\t\t}else{\n\t\t\t\tt = left_rotate(t);\n\t\t\t}\n\t\t}\n\t\treturn erase(t, key);\n\t}\n\n\tbool find(int key){\n\t\treturn find(root, key);\n\t}\n\n\tbool find(node *t, int key){\n\t\tif(t==NULL){\n\t\t\treturn false;\n\t\t}\n\t\tif(t->key==key){\n\t\t\treturn true;\n\t\t}\n\t\tif(key < t->key){\n\t\t\treturn find(t->left, key);\n\t\t}else{\n\t\t\treturn find(t->right, key);\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid print_inorder(){\n\t\tprint_inorder(root);\n\t}\n\n\tvoid print_inorder(node *t){\n\t\tif(t==NULL){\n\t\t\treturn;\n\t\t}\n\t\tprint_inorder(t->left);\n\t\tcout << \" \" << t->key;\n\t\tprint_inorder(t->right);\n\t}\n\n\tvoid print_preorder(){\n\t\tprint_preorder(root);\n\t}\n\n\tvoid print_preorder(node *t){\n\t\tif(t==NULL){\n\t\t\treturn;\n\t\t}\n\t\tcout << \" \" << t->key;\n\t\tprint_preorder(t->left);\n\t\tprint_preorder(t->right);\n\t}\n\n};\n\n\nint main(){\n\tint time;\n\tcin >> time;\n\ttreap tr;\n\trep(i, time){\n\t\tstring op;\n\t\tcin >> op;\n\t\tif(op==\"insert\"){\n\t\t\tint key, priority;\n\t\t\tcin >> key >> priority;\n\t\t\ttr.insert(key, priority);\n\t\t}else if(op==\"print\"){\n\t\t\ttr.print_inorder();\n\t\t\tcout << endl;\n\t\t\ttr.print_preorder();\n\t\t\tcout << endl;\n\t\t}else if(op==\"delete\"){\n\t\t\tint key;\n\t\t\tcin >> key;\n\t\t\ttr.erase(key);\n\t\t}else{\n\t\t\tint key;\n\t\t\tcin >> key;\n\t\t\tbool flag = tr.find(key);\n\t\t\tcout << (flag?\"yes\":\"no\") << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct point{\n\tint a,b;\n\tpoint *l,*r,*pa;\n\tpoint(){l=r=pa=NULL;}\n\tpoint(int aa,int bb):a(aa),b(bb){l=r=pa=NULL;};\n};\npoint *root;\npoint *rightRotate(point *t){\n\tpoint *s=t->l;\n\tt->l=s->r;\n\ts->r=t;\n\treturn s;\n}\npoint *leftRotate(point *t){\n\tpoint *s=t->r;\n\tt->r=s->l;\n\ts->l=t;\n\treturn s;\n}\npoint* insert(point *p,int a,int b){\n\tif(p==NULL)return new point(a,b);\n\tif(a==p->a)return p;\n\tif(a<p->a){\n\t\tp->l=insert(p->l,a,b);\n\t\tif(p->b<p->l->b)\n\t\t\tp=rightRotate(p);\n\t}else{\n\t\tp->r=insert(p->r,a,b);\n\t\tif(p->b<p->r->b)\n\t\t\tp=leftRotate(p);\n\t}return p;\n}\npoint *_del(point *p, int a);\npoint *del(point *p,int a){\n\tif(p==NULL)return NULL;\n\tif(a<p->a)p->l=del(p->l,a);\n\telse if(a>p->a)p->r=del(p->r,a);\n\telse return _del(p,a);\n\treturn p;\n}\npoint *_del(point *p, int a){\n\tif(p->l==NULL&&p->r==NULL)return NULL;\n\telse if(p->l==NULL)p=leftRotate(p);\n\telse if(p->r==NULL)p=rightRotate(p);\n\telse{\n\t\tif(p->l->b>p->r->b)p=rightRotate(p);\n\t\telse p=leftRotate(p);\n\t}return del(p,a);\n}\nbool find(int a){\n\tpoint *p=root;\n\twhile(p){\n\t\tif(a==p->a)return 1;\n\t\tif(a>p->a)p=p->r;\n\t\telse p=p->l;\n\t}\n\treturn 0;\n}\nvoid dfs1(point *p){\n\tif(!p)return;\n\tdfs1(p->l);\n\tprintf(\" %d\",p->a);\n\tdfs1(p->r);\n}\nvoid dfs2(point *p){\n\tif(!p)return;\n\tprintf(\" %d\",p->a);\n\tdfs2(p->l);\n\tdfs2(p->r);\n}\nint main(){\n\tios::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\tint T;cin>>T;\n\tint ta,tb;\n\tstring s;\n\twhile(cin>>s){\n\t\tif(s==\"insert\"){\n\t\t\tcin>>ta>>tb;\n//\t\t\tif(!root)root=new point(ta,tb);\n//\t\t\telse \n\t\t\troot=insert(root,ta,tb);\n\t\t}else if(s==\"find\"){\n\t\t\tcin>>ta;\n\t\t\tif(find(ta))printf(\"yes\\n\");\n\t\t\telse printf(\"no\\n\");\n\t\t}else if(s==\"print\"){\n\t\t\tdfs1(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tdfs2(root);\n\t\t\tprintf(\"\\n\");\n\t\t}else if(s==\"delete\"){\n\t\t\tcin>>ta;\n\t\t\troot=del(root,ta);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<string>\n#include<iostream>\nusing namespace std;\n\nstruct Node{\n  int key,priority;\n  Node *right,*left;\n};\n\nNode *root, *NIL;\n\nNode * find(Node *u,int k){\n  while(u!=NIL && k!=u->key){\n    if(k<u->key) u = u->left;\n    else u=u->right;\n  }\n  return u;\n}\n\nvoid inorder(Node *u){\n  if(u==NIL) return;\n  inorder(u->left);\n  printf(\" %d\",u->key);\n  inorder(u->right);\n}\n\nvoid preorder(Node *u){\n  if(u==NIL) return;\n  printf(\" %d\",u->key);\n  preorder(u->left);\n  preorder(u->right);\n}\n\nNode *rightRotate(Node *u){\n  Node *k=u->left;\n  u->left=k->right;\n  k->right=u;\n  return k;\n}\n\nNode *leftRotate(Node *u){\n  Node *k=u->right;\n  u->right=k->left;\n  k->left=u;\n  return k;\n}\n\nNode* insert(Node *t,int key,int priority){\n\t\n  if(t==NIL)\n    return Node(key,priority);\n  if (t->key==key)\n    return t;\n\t\n  if(key < t->key){\n    t->left=insert(t->left,key,priority);\n    if(t->priority < t->left->priority)\n      t=rightRotate(t);\n  }\n  else {\n    t->right=insert(t->right,key,priority);\n    if(t->priority < t->right->priority)\n      t=leftRotate(t);\n  }\n\t\n  return t;\n}\n\n\nNode * Delete(Node *t,int key){\n  if(t==NIL)\n    return NIL;\n\t\t\n  if(key < t->key)\n    t->left=Delete(t->left,key);\n\t\t\n  else if(key > t->key)\n    t->right=Delete(t->right,key);\n\t\t\n  else return _delete(t,key);\n\t\n  return t;\n}\n\nNode * _delete(Node *t,int key){\n  if(t->left==NIL && t->right==NIL)\n    return NIL;\n  else if(t->left==NIL)\n    t=leftRotate(t);\n  else if(t->right==NIL)\n    t=rightRotate(t);\n  else {\n    if(t->left->priority > t->right->priority)\n      t=rightRotate(t);\n    else\n      t=leftRotate(t);\n  }\n  return Delete(t,key);\n}\n\nint main(){\n  int n,i,x;\n  string com;\n\n  scanf(\"%d\",&n);\n\n  for(i = 0;i < n; i++){\n    cin >> com;\n\n    if(com[0] == 'f'){\n      scanf(\"%d\",&x);\n      Node *t = find(root,x);\n      if(t!=NIL) printf(\"yes\\n\");\n      else printf(\"no\\n\");\n    }else if(com == \"insert\"){\n      scanf(\"%d\",&x);\n      insert(x);\n    }else if(com == \"print\"){\n      inorder(root);\n      printf(\"\\n\");\n      preorder(root);\n      printf(\"\\n\");\n    }else if(com == \"delete\"){\n      scanf(\"%d\",&x);\n      Delete(root,x);\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n/*\nstruct Node{\n  Node *right, *left;\n  int key, priority;\n};\n\nNode* node(int k, int p){\n  Node *newNode = new Node();//(Node *)malloc(sizeof(Node));\n  newNode->right = NULL;\n  newNode->left = NULL;\n  newNode->key = k;\n  newNode->priority = p;\n  return newNode;\n}\n*/\n\nclass Node{\npublic:\n  Node *right, *left;\n  int key, priority;\n  Node( int k, int p ) {\n    right = NULL;\n    left = NULL;\n    key = k;\n    priority = p;\n  }\n};\n\nNode* rightRotate(Node *t){\n  Node *s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s; //the new root of subtree\n}\n\nNode* leftRotate(Node *t){\n  Node *s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s; //the new root of subtree\n}\n\nNode* insertT(Node *t, int k, int p){\n  //when you reach the leaf\n  // if(t == NULL) return node(k, p);  //create a new Node\n  if(t == NULL) return new Node(k, p);  //create a new Node\n\n  //ignore duplicated keys\n  if(k == t->key) return t;\n\n  if(k < t->key){  //move to the left child\n    //update the pointer to the left child\n    t->left = insertT(t->left, k, p);\n    //if the left child has higher priority\n    if(t->priority < t->left->priority) t = rightRotate(t);\n  }else{//move to the right child\n    //update the pointer t the right child\n    t->right = insertT(t->right, k, p);\n    //if the right child has higher priority\n    if(t->priority < t->right->priority) t = leftRotate(t);\n  }\n\n  return t;\n}\n\nNode* find(Node* t, int k){\n  while(t != NULL && k != t->key){//leafじゃない && みつかっていない\n    if(k < t->key) t = t->left;\n    else t = t->right;\n  }\n  return t;\n}\n\n Node* deleteNode(Node *t, int k){\n  if(t == NULL) return NULL;\n  //if t is the targer node\n  if(k == t->key){\n    //if t is a leaf\n    if(t->left == NULL && t->right == NULL) return NULL;\n    //if t has only the right child\n    else if(t->left == NULL) t = leftRotate(t);\n    //if t has only the left child\n    else if(t->right == NULL) t = rightRotate(t);\n    //if t has both the left and right child\n    else{\n      //pull up the child with higher priority\n      if(t->left->priority > t->right->priority) t = rightRotate(t);\n      else t = leftRotate(t);\n    }\n    return deleteNode(t, k);\n  }\n\n  //search the targer recursively\n  if(k < t->key) t->left = deleteNode(t->left, k);\n  else t->right = deleteNode(t->right, k);\n\n  return t;\n}\n\nvoid inorder(Node* t){\n  if(t == NULL) return;\n  inorder(t->left);\n  printf(\" %d\", t->key);\n  inorder(t->right);\n}\n\nvoid preorder(Node* t){\n  if(t == NULL) return;\n  printf(\" %d\", t->key);\n  preorder(t->left);\n  preorder(t->right);\n}\n\nvoid print(Node* t){\n  inorder(t);\n  printf(\"\\n\");\n  preorder(t);\n  printf(\"\\n\");\n}\n\nint main(){\n  int n, k, p;\n  string com;\n  Node *t = NULL;//root\n\n  cin >> n;\n  for(int i=0 ; i<n ; ++i){\n    cin >> com;\n    if(com == \"insert\"){\n      cin >> k >> p;\n      t = insertT(t, k, p);\n    }else if(com == \"delete\"){\n      cin >> k;\n      t = deleteNode(t, k);\n    }else if(com == \"print\"){\n      print(t);\n    }else if(com == \"find\"){\n      cin >> k;\n      Node* n = find(t, k);\n      if(n != NULL) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct node{\n  int key ;\n  int priority;\n  int right;\n  int left;\n  long unsigned int p;\n};\nnode nullNode{-1,-1,0,0,0};\nint _nodeDelete(node,int);\nint nodeDelete(node,int);\nvector <node> treap;\nbool isNull(node t){\n  //if(&t ==nullptr) return true;\n  if(t.key ==-1 && t.priority == -1)return true;\n  return false;\n}\nint rightRotate(node t){\n  long unsigned int s = t.left;\n  treap[t.p].left = treap[s].right;\n  treap[s].right = t.p;\n  return s;\n}\nint leftRotate(node t){\n  long unsigned int s = t.right;\n  treap[t.p].right = treap[s].left;\n  treap[s].left = t.p;\n  return s;\n}\nint mkNode(int key,int priority){\n  node s = {key,priority,0,0,treap.size()};\n  treap.push_back(s);\n  return s.p;\n}\nint insert(node t,int key, int priority){\n  int tmp;\n  if(isNull(t))return mkNode(key,priority);\n  if(key == t.key)return t.p;\n  if(key < t.key){\n    tmp = insert(treap[t.left],key,priority);\n     treap[t.p].left =tmp;\n     if(t.priority < treap[tmp].priority)\n      t = treap[rightRotate(treap[t.p])];\n  }\n  else {\n    tmp= insert(treap[t.right],key,priority);\n    treap[t.p].right = tmp;\n    if(t.priority < treap[tmp].priority)\n      t = treap[leftRotate(treap[t.p])];\n  }\n  return t.p;\n}\nint nodeDelete(node t,int key){\n  int tmp;\n  if(isNull(t))return 0;\n  if(key < t.key){\n    tmp = nodeDelete(treap[t.left],key);\n    treap[t.p].left = tmp;\n  }\n  else if (key > t.key){\n    tmp = nodeDelete(treap[t.right], key);\n    treap[t.p].right = tmp;\n  }\n  else\n    return _nodeDelete(t, key);\n  return t.p;\n}\nint _nodeDelete(node t,int key){\n  int tmp;\n  if (isNull(treap[t.left]) && isNull(treap[t.right]))        \n        return 0;\n  else if (isNull(treap[t.left])){\n    tmp = leftRotate(t);\n      t = treap[tmp];\n    }                       \n    else if (isNull(treap[t.right])){                   \n      tmp =rightRotate(t);\n      t = treap[tmp];\n    }\n    else{                                       \n        if (treap[t.left].priority > treap[t.right].priority ){\n          tmp = rightRotate(t);\n          t = treap[tmp];\n        } \n\n        else{\n          tmp =leftRotate(t);\n          t = treap[tmp];\n        }\n    }\n  return nodeDelete(t, key);\n}\nvoid preorder_print(node t){\n  if(isNull(t))return;\n  cout<<\" \"<<t.key;\n  preorder_print(treap[t.left]);\n  preorder_print(treap[t.right]);\n}\nvoid inorder_print(node t){\n  if(isNull(t))return;\n  inorder_print(treap[t.left]);\n  cout<<\" \"<<t.key;\n  inorder_print(treap[t.right]);\n}\nbool find(node t, int key){\n  bool flag = false;\n  if(t.key ==-1);\n  else if(key==t.key) flag = true;\n  else if(key>(t.key))flag = find(treap[t.right],key);\n  else if(key<(t.key)) flag = find(treap[t.left],key);\n  return flag;\n}\nint main(){\n  int n,key,p;\n  bool flag=false;\n  string str;\n  int root;\n  cin>>n;\n  treap.push_back(nullNode);\n  for(int i=0;i<n;i++){\n    cin>>str;\n    if(str==\"insert\"){\n      cin>>key>>p;\n      if(flag)\n        root = insert(treap[root],key,p);\n      else{\n        root = mkNode(key,p);\n        flag = true;\n      }\n    }\n    else if (str==\"print\"){\n\n      inorder_print(treap[root]);\n      cout<<endl;\n      preorder_print(treap[root]);\n      cout<<endl;\n    }\n    else if (str == \"delete\"){\n      cin >> key;\n      root = nodeDelete(treap[root],key);\n    }\n    else if (str == \"find\"){\n      cin>>key;\n      if(find(treap[root],key))cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n    }\n   }\n\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n\nusing namespace std;\n/*\nstruct Node{\n  Node *right, *left;\n  int key, priority;\n};\n\nNode* node(int k, int p){\n  Node *newNode = new Node();//(Node *)malloc(sizeof(Node));\n  newNode->right = NULL;\n  newNode->left = NULL;\n  newNode->key = k;\n  newNode->priority = p;\n  return newNode;\n}\n*/\n\nclass Node{\npublic:\n  Node *right, *left;\n  int key, priority;\n  Node( int k, int p ) {\n    right = NULL;\n    left = NULL;\n    key = k;\n    priority = p;\n  }\n};\n\nNode* rightRotate(Node *t){\n  Node *s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s; //the new root of subtree\n}\n\nNode* leftRotate(Node *t){\n  Node *s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s; //the new root of subtree\n}\n\nNode* insertT(Node *t, int k, int p){\n  //when you reach the leaf\n  // if(t == NULL) return node(k, p);  //create a new Node\n  if(t == NULL) return new Node(k, p);  //create a new Node\n\n  //ignore duplicated keys\n  if(k == t->key) return t;\n\n  if(k < t->key){  //move to the left child\n    //update the pointer to the left child\n    t->left = insertT(t->left, k, p);\n    //if the left child has higher priority\n    if(t->priority < t->left->priority) t = rightRotate(t);\n  }else{//move to the right child\n    //update the pointer t the right child\n    t->right = insertT(t->right, k, p);\n    //if the right child has higher priority\n    if(t->priority < t->right->priority) t = leftRotate(t);\n  }\n\n  return t;\n}\n\nNode* find(Node* t, int k){\n  while(t != NULL && k != t->key){//leafじゃない && みつかっていない\n    if(k < t->key) t = t->left;\n    else t = t->right;\n  }\n  return t;\n}\n\n Node* deleteNode(Node *t, int k){\n  if(t == NULL) return NULL;\n  //if t is the targer node\n  if(k == t->key){\n    //if t is a leaf\n    if(t->left == NULL && t->right == NULL) return NULL;\n    //if t has only the right child\n    else if(t->left == NULL) t = leftRotate(t);\n    //if t has only the left child\n    else if(t->right == NULL) t = rightRotate(t);\n    //if t has both the left and right child\n    else{\n      //pull up the child with higher priority\n      if(t->left->priority > t->right->priority) t = rightRotate(t);\n      else t = leftRotate(t);\n    }\n    return deleteNode(t, k);\n  }\n\n  //search the targer recursively\n  if(k < t->key) t->left = deleteNode(t->left, k);\n  else t->right = deleteNode(t->right, k);\n\n  return t;\n}\n\nvoid inorder(Node* t){\n  if(t == NULL) return;\n  inorder(t->left);\n  printf(\" %d\", t->key);\n  inorder(t->right);\n}\n\nvoid preorder(Node* t){\n  if(t == NULL) return;\n  printf(\" %d\", t->key);\n  preorder(t->left);\n  preorder(t->right);\n}\n\nvoid print(Node* t){\n  inorder(t);\n  printf(\"\\n\");\n  preorder(t);\n  printf(\"\\n\");\n}\n\nint main(){\n  int n, k, p;\n  string com;\n  Node *t;//root\n\n  cin >> n;\n  for(int i=0 ; i<n ; ++i){\n    cin >> com;\n    if(com == \"insert\"){\n      cin >> k >> p;\n      t = insertT(t, k, p);\n    }else if(com == \"delete\"){\n      cin >> k;\n      t = deleteNode(t, k);\n    }else if(com == \"print\"){\n      print(t);\n    }else if(com == \"find\"){\n      cin >> k;\n      Node* n = find(t, k);\n      if(n != NULL) cout << \"yes\" << endl;\n      else cout << \"no\" << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\n#define linf (1e16)\n#define eps (1e-8)\n#define Eps (1e-12)\n#define mod 1000000007\n#define pi acos(-1.0)\n#define phi (1.0+sqrt(5.0))/2.0\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define pld(a) printf(\"%.10Lf\\n\",(ld)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define Unique(v) v.erase(unique(all(v)),v.end())\n#define equals(a,b) (fabs((a)-(b))<eps)\n#define track(); cout<<\"#############\"<<endl;\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef pair<double,double> pdd;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\n\ntypedef struct node{\n  struct node *l=NULL;\n  struct node *r=NULL;\n  int key=0;\n  int pri=0;\n}Node;\n\nNode* RightRotate(Node *t){\n  Node *s=t->l;\n  t->l=s->r;\n  s->r=t;\n  return s;\n}\n\nNode* LeftRotate(Node *t){\n  Node *s=t->r;\n  t->r=s->l;\n  s->l=t;\n  return s;\n}\n\nNode* ins(Node* t,int key,int pri){\n  if(t==NULL){\n    t=(Node*)malloc(sizeof(Node));\n    t->l=NULL;\n    t->r=NULL;\n    t->key=key;\n    t->pri=pri;\n    return t;\n  }\n  if(key==t->key)return t;\n  if(key<t->key){\n    t->l = ins(t->l,key,pri);\n    if(t->pri < t->l->pri)t=RightRotate(t);\n  }\n  else {\n    t->r = ins(t->r,key,pri);\n    if(t->pri < t->r->pri)t=LeftRotate(t);\n  }\n  return t;\n}\n\nbool find(Node *t,int key){\n  if(t==NULL)return false;\n  if(t->key==key)return true;\n  if(key<t->key)return find(t->l,key);\n  return find(t->r,key);\n}\n\nNode* del(Node *t,int key){\n  if(t==NULL)return NULL;\n  if(key==t->key){\n    if(t->l==NULL && t->r==NULL){\n      return NULL;\n    }\n    else if(t->l==NULL){\n      t=LeftRotate(t);\n    }\n    else if(t->r==NULL){\n      t=RightRotate(t);\n    }\n    else {\n      if(t->l->pri >t->r->pri)\n        t=RightRotate(t);\n      else \n        t=LeftRotate(t);\n    }\n    return del(t,key);\n  }\n\n  if(key<t->key)\n    t->l = del(t->l,key);\n  else \n    t->r = del(t->r,key);\n  return t;\n}\n\nvoid inorder(node *t){\n  if(t->l != NULL)inorder(t->l);\n//  cout<<\" \"<<t->key;\n  printf(\" %d\",t->key);\n  if(t->r != NULL)inorder(t->r);\n}\n\nvoid preorder(node *t){\n  printf(\" %d\",t->key);\n  //cout<<\" \"<<t->key;\n  if(t->l != NULL)preorder(t->l);\n  if(t->r != NULL)preorder(t->r);\n}\n\nint main()\n{\n  int n,a,b;\n  string s;\n  Node *t=NULL;\n  cin>>n;\n  FOR(i,0,n){\n    cin>>s;\n    if(s==\"insert\"){\n      cin>>a>>b;\n      t=ins(t,a,b);\n    }\n    else if(s==\"find\"){\n      cin>>a;\n      if(find(t,a))cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n    }\n    else if(s==\"delete\"){\n      cin>>a;\n      t=del(t,a);\n    }\n    else {\n      inorder(t);\n      cout<<endl;\n      preorder(t);\n      cout<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BUF_LENGTH 100\n#define OPE_LENGTH 10\n\ntypedef struct _node {\n\tint key;\n\tint priority;\n\tstruct _node * left;\n\tstruct _node * right;\n\tstruct _node * parent;\n} node;\n\nnode * left_rotate(node * t) {\n\tnode * new_t = t->right;\n\tt->right = new_t->left;\n\tnew_t->left = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * right_rotate(node * t) {\n\tnode * new_t = t->left;\n\tt->left = new_t->right;\n\tnew_t->right = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * create_node(int key, int priority) {\n\tnode * p;\n\tp = (node *)malloc(sizeof(node));\n\tp->key = key;\n\tp->priority = priority;\n\tp->left = NULL;\n\tp->right = NULL;\n\tp->parent = NULL;\n\treturn p;\n}\n\nnode * insert(node * t, int key, int priority) {\n\tif (t == NULL) {\n\t\tnode * p = create_node(key, priority);\n\t\treturn p;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->left = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->left, key, priority);\n\t\t}\n\t\t\t\t\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\telse if (key > t->key) {\n\t\tif (t->right == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->right = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->right, key, priority);\n\t\t}\n\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\t\n\treturn t;\n}\n\nnode * delete(node * t, int key) {\n\tif (key == t->key) {\n\t\tif (t->left == NULL && t->right == NULL) {\n\t\t\tif (t->parent->left == t) {\n\t\t\t\tt->parent->left = NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt->parent->right = NULL;\n\t\t\t}\n\t\t\tfree(t);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (t->left == NULL) {\n\t\t\tt = left_rotate(t);\t\n\t\t}\n\t\telse if (t->right == NULL) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse if (t->left->priority > t->right->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\tt = delete(t, key);\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete(t->left, key);\n\t\treturn t;\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete(t->right, key);\n\t\treturn t;\n\t}\n}\n\nint find(node * t, int key) {\n\tif (key == t->key) {\n\t\treturn 1;\n\t}\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->left, key);\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->right, key);\n\t}\n}\n\nvoid print_preorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->left != NULL) {\n\t\tprint_preorder(t->left);\n\t}\n\tif (t->right != NULL) {\n\t\tprint_preorder(t->right);\n\t}\n}\n\nvoid print_inorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tif (t->left != NULL) {\n\t\tprint_inorder(t->left);\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->right != NULL) {\n\t\tprint_inorder(t->right);\n\t}\n}\n\nint main() {\n\tint m;\n\tchar buf[BUF_LENGTH];\n\tchar * str;\n\tint k, p;\n\tnode * root = NULL;\n\n\tscanf_s(\"%d \", &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfgets(&buf, BUF_LENGTH, stdin);\n\t\tchar * context;\n\t\tstr = strtok_s(buf, \" \\n\", &context);\n\t\tif (strcmp(str, \"insert\") == 0) {\n\t\t\tstr = strtok_s(NULL, \" \\n\", &context);\n\t\t\tk = atoi(str);\n\t\t\tstr = strtok_s(NULL, \" \\n\", &context);\n\t\t\tp = atoi(str);\n\t\t\t//printf(\"--insert %d %d\\n\", k, p);\n\t\t\troot = insert(root, k, p);\n\t\t}\n\t\telse if (strcmp(str, \"find\") == 0) {\n\t\t\tstr = strtok_s(NULL, \" \\n\", &context);\n\t\t\tk = atoi(str);\n\t\t\t//printf(\"--find %d\\n\", k);\n\t\t\tint result = find(root, k);\n\t\t\tif (result == 1) {\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (strcmp(str, \"delete\") == 0) {\n\t\t\tstr = strtok_s(NULL, \" \\n\", &context);\n\t\t\tk = atoi(str);\n\t\t\t//printf(\"--delete %d\\n\", k);\n\t\t\troot = delete(root, k);\n\t\t}\n\t\telse if (strcmp(str, \"print\") == 0) {\n\t\t\t//printf(\"--print\\n\");\n\t\t\tprint_inorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tprint_preorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse {\n\t\t\t//printf(\"error\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct node{\n\tint val,pri;\n\tnode *l,*r;\n\tnode():l(nullptr),r(nullptr){}\n\tnode(int a,int b):val(a),pri(b),l(nullptr),r(nullptr){}\n};\n\nstruct treap{\n\tnode *root;\n\ttreap(){ root=nullptr; }\n\n\tnode* right(node *t){\n\t\tnode* s = t->l;\n\t\tt->l = s->r;\n\t\ts->r = t;\n\t\treturn s;\n\t}\n\tnode* left(node *t){\n\t\tnode* s = t->r;\n\t\tt->r = s->l;\n\t\ts->l = t;\n\t\treturn s;\n\t}\n\tnode* insert(node *t,int key,int priority){\n\t\tif(t==nullptr) return new node(key,priority);\n\t\tif(t->val==key) return t;\n\t\tif(key<t->val){\n\t\t\tt->l = insert(t->l,key,priority);\n\t\t\tif(t->pri < t->l->pri)t = right(t);\n\t\t}\n\t\telse{\n\t\t\tt->r=insert(t->r,key,priority);\n\t\t\tif(t->pri < t->r->pri)t = left(t);\n\t\t}\n\t\treturn t;\n\t}\n\tvoid insert(int key,int priority){\n\t\troot = insert(root,key,priority);\n\t}\n\tnode* delet(node *t,int key){\n\t\tif(t==nullptr)return nullptr;\n\t\tif(key<t->val)t->l=delet(t->l,key);\n\t\telse if(key>t->val)t->r=delet(t->r,key);\n\t\telse return _delet(t,key);\n\t\treturn t;\n\t}\n\tnode* _delet(node *t,int key){\n\t\tif(t->l==nullptr && t->r==nullptr) return nullptr;\n\t\telse if(t->l==nullptr)t=left(t);\n\t\telse if(t->r==nullptr)t=right(t);\n\t\telse{\n\t\t\tif(t->l->pri > t->r->pri) t= right(t);\n\t\t\telse t= left(t);\n\t\t}\n\t\treturn delet(t,key);\n\t}\n\tvoid delet(int key){\n\t\troot=delet(root,key);\n\t}\n\tnode* find(node *t,int key){\n\t\tif(t==nullptr)return nullptr;\n\t\tif(key < t->val)return find(t->l,key);\n\t\tif(key > t->val)return find(t->r,key);\n\t\treturn t;\n\t}\n\tvoid print(node *t,int x=1){\n\t\tif(t==nullptr)return;\n\t\tif(x==1)cout<<' '<<(t->val);\n\t\tif(t->l!=nullptr)print(t->l,x);\n\t\tif(x==2)cout<<' '<<(t->val);\n\t\tif(t->r!=nullptr)print(t->r,x);\n\t\tif(x==3)cout<<' '<<(t->val);\n\t\tif(t==root)cout<<endl;\n\t}\n};\n\nint main(){\n\ttreap T;\n\tint n,a,b;\n\tcin>>n;\n\twhile(n--){\n\t\tstring s;\n\t\tcin>>s;\n\t\tif(s==\"insert\"){\n\t\t\tcin>>a>>b;\n\t\t\tT.insert(a,b);\n\t\t}\n\t\tif(s==\"find\"){\n\t\t\tcin>>a;\n\t\t\tcout<<(T.find(T.root,a)==nullptr?\"no\":\"yes\")<<endl;\n\t\t}\n\t\tif(s==\"delete\"){\n\t\t\tcin>>a;\n\t\t\tT.delet(a);\n\t\t}\n\t\tif(s==\"print\"){\n\t\t\tT.print(T.root,2);\n\t\t\tT.print(T.root,1);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Haskell",
    "code": "module Main where\n\nimport Debug.Trace\nimport Data.List\nimport qualified Data.Sequence as S\nimport qualified Data.ByteString.Char8 as B\nimport Data.Int\nimport Data.Char\nimport Data.Array\nimport Data.Maybe\nimport qualified Data.Map as M\nimport Data.Ord\nimport Data.Functor\nimport Control.Applicative\nimport Control.Monad\nimport Text.Printf\n\ndata Tree a = Nil | Node a a (Tree a) (Tree a) deriving (Show)\ndata Command = Print | Delete Int | Find Int | Insert Int Int deriving (Show)\ndata Order = Preorder | Inorder deriving (Eq, Show)\n\nsDelete = B.pack \"delete\"\nsFind   = B.pack \"find\"\nsInsert = B.pack \"insert\"\nsPrint  = B.pack \"print\"\n\nsolve :: [Command] -> [String]\nsolve = iter Nil where\n    iter :: Tree Int-> [Command] -> [String]\n    iter _ [] = []\n    iter rt (c:cs) = case c of\n        Print    -> (inorder rt):(preorder rt):(iter rt cs)\n        Delete x -> iter (delete x rt) cs\n        Find x   -> (find x rt):(iter rt cs)\n        Insert x p -> iter (insert x p rt) cs\n\n    delete x = iter where\n        iter Nil = Nil \n        iter t@(Node y q l r)             \n            | x < y  = Node y q (iter l) r\n            | x > y  = Node y q l (iter r)\n            | x == y = case (l, r) of\n                (Nil, Nil) -> Nil\n                (Nil, r)   -> iter $ leftRotate t \n                (l, Nil)   -> iter $ rightRotate t\n                (Node _ lq _ _, Node _ rq _ _) -> iter $ if lq > rq then rightRotate t else leftRotate t\n\n    leftRotate  (Node x p a (Node y q b c)) = Node y q (Node x p a b) c\n\n    rightRotate (Node y q (Node x p a b) c) = Node x p a (Node y q b c)\n\n    find x = iter where\n        iter (Node y q l r)\n            | x == y = \"yes\"\n            | x <  y = iter l\n            | x >  y = iter r \n        iter Nil = \"no\"\n\n    insert x p = iter where\n        iter (Node y q l r)\n            | x < y     = case iter l of\n                t@(Node _ q' _ _)\n                    | q < q'    -> rightRotate (Node y q t r)\n                    | otherwise -> Node y q t r\n            | otherwise = case iter r of\n                t@(Node _ q' _ _)\n                    | q < q'    -> leftRotate (Node y q l t)\n                    | otherwise -> Node y q l t\n        iter Nil = Node x p Nil Nil \n\n    preorder = toString . (toList Preorder)\n    inorder  = toString . (toList Inorder)\n\ntoList :: Order -> Tree a -> [a]\ntoList ord = iter where\n    iter Nil = []\n    iter (Node id p l r)\n        | ord == Preorder = id:(iter l) ++ iter r\n        | ord == Inorder  = (iter l) ++ id:iter r\n\ntoString:: [Int] -> String\ntoString [] = []\ntoString (x:xs) = ' ':(show x)++ toString xs\n\ntoInt :: B.ByteString -> Int\ntoInt = fst . fromJust . B.readInt\n                    \nreadIntLn:: IO Int\nreadIntLn = toInt <$> B.getLine\n\nreadCommand:: IO Command\nreadCommand = do\n    l <- B.words <$> B.getLine\n    return $ case l of\n        [cmd, n, m]\n            | cmd == sInsert -> Insert (toInt n) (toInt m)\n        [cmd, n]\n            | cmd == sDelete -> Delete (toInt n)\n            | cmd == sFind   -> Find   (toInt n)\n        [sPrint]     -> Print\n\nmain :: IO() \nmain = do\n    n <- readIntLn\n    l <- replicateM n readCommand\n    mapM_ putStrLn $ solve l\n\n"
  },
  {
    "language": "Haskell",
    "code": "{-# LANGUAGE BangPatterns #-}\nimport Control.Monad\nimport Data.Maybe\nimport Debug.Trace\n-- import Data.List\nimport qualified Data.Map.Strict as Map\nimport qualified Data.IntMap.Strict as IntMap\nimport qualified Data.Set as Set\nimport qualified Data.IntSet as IntSet\nimport Data.Functor\nimport Data.Array\n-- import Data.Array.Unboxed\nimport Control.Monad.ST\nimport Data.Array.ST\nimport qualified Data.ByteString.Char8 as B\nimport Data.Maybe (fromJust)\nreadInt = fst . fromJust . B.readInt\nreadInts = map (fst . fromJust . B.readInt) . B.words <$> B.getLine :: IO [Int]\nreadIntegers = map (fst . fromJust . B.readInteger) . B.words <$> B.getLine :: IO [Integer]\nread2dInts = map (map (fst . fromJust . B.readInt) . B.words) . B.lines <$> B.getContents\n\ndata Treap k a = Empty | Node k a (Treap k a) (Treap k a)\n  deriving (Show)\n\nkey :: Treap k a -> k\nkey (Node k _ _ _) = k\n\npriority :: Treap k a -> a\npriority (Node _ a _ _) = a\n\ninsert :: (Ord k, Ord a) => k -> a -> Treap k a -> Treap k a\ninsert k p Empty = Node k p Empty Empty\ninsert k p org@(Node key pri left right)\n  | k == key = org\n  | k < key = rightRotate $ Node key pri (insert k p left) right\n  | otherwise = leftRotate $ Node key pri left (insert k p right)\n\nrightRotate :: (Ord a) => Treap k a -> Treap k a\nrightRotate Empty = Empty\nrightRotate org@(Node _ p left _) \n  | p < priority left = _rightRotate org\n  | otherwise = org\n\n_rightRotate (Node k p left right) = Node lk lp lleft (Node k p lright right)\n  where\n    (Node lk lp lleft lright) = left\n\nleftRotate :: (Ord a) => Treap k a -> Treap k a\nleftRotate Empty = Empty\nleftRotate org@(Node _ p _ right) \n  | p < priority right = _leftRotate org\n  | otherwise = org\n  \n_leftRotate (Node k p left right) = Node rk rp (Node k p left rleft) rright\n  where\n    (Node rk rp rleft rright) = right\n\ndelete :: (Ord k, Ord a) => k -> Treap k a -> Treap k a\ndelete _ Empty = Empty\ndelete k org@(Node key pri left right) \n  | k < key = Node key pri (delete k left) right\n  | k > key = Node key pri left (delete k right)\n  | otherwise = _delete k org\n\n_delete :: (Ord k, Ord a) => k -> Treap k a -> Treap k a\n_delete _ (Node _ _ Empty Empty) = Empty\n_delete k org@(Node _ _ Empty _) = delete k $ _leftRotate org\n_delete k org@(Node _ _ _ Empty) = delete k $ _rightRotate org\n_delete k org@(Node key pri left right) = \n  if priority left > priority right\n    then delete k $ _rightRotate org\n    else delete k $ _leftRotate org\n\nfind :: (Ord k) => k -> Treap k a -> Bool\nfind k Empty = False\nfind k (Node key _ left right)\n  | k == key = True\n  | k < key = find k left\n  | otherwise = find k right\n\nprintTreap :: (Show k) => Treap k a -> IO (Treap k a)\nprintTreap treap = do\n  putStr \" \"\n  putStrLn . unwords . map show $ inorder treap\n  putStr \" \"\n  putStrLn . unwords . map show $ preorder treap\n  return treap\n\ninorder :: Treap k a -> [k]\ninorder Empty = []\ninorder (Node k _ left right) = (inorder left) ++ [k] ++ (inorder right)\n\npreorder :: Treap k a -> [k]\npreorder Empty = []\npreorder (Node k a left right) = k:(preorder left) ++ (preorder right)\n  \n\nmain :: IO ()\nmain = do\n  n <- readLn :: IO Int\n  am <- B.lines <$> B.getContents :: IO [B.ByteString]\n  solve am\n\nsolve = foldM_ f Empty \n  where\n    f :: Treap Int Int -> B.ByteString -> IO (Treap Int Int)\n    f treap b\n      | order == bInsert =\n        let [k, p] = bs\n        in do\n          return $ insert k p treap\n      | order == bFind = \n        let k = head bs\n        in do \n          putStrLn $ if find k treap then \"yes\" else \"no\"\n          return treap\n      | order == bDelete = return $ delete (head bs) treap\n      | order == bPrint = printTreap treap\n      | otherwise = return treap\n        where\n          order = head (B.words b) \n          bs = map readInt . tail $ B.words b\n\n\ntoInts = map readInt . B.words\nbInsert = B.pack \"insert\"\nbPrint = B.pack \"print\"\nbFind = B.pack \"find\"\nbDelete = B.pack \"delete\"\n    \n    \n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>))\nimport Control.Monad (foldM)\nimport Data.ByteString.Char8 (ByteString)\nimport qualified Data.ByteString.Char8 as B\nimport Data.Bool (bool)\n\nmain :: IO ()\nmain = do\n  B.getLine\n  B.lines <$> B.getContents >>= solve\n\nsolve :: [ByteString] -> IO ()\nsolve bs = foldM f Leaf bs >> return ()\n  where f :: Treap Int -> ByteString -> IO (Treap Int)\n        f tr bs = case B.words bs of\n                   [_, bk, bp] -> do\n                     return (trpInsert (readi B.readInt bk) (readi B.readInt bp) tr)\n                   [com, bk] | com == sfind -> do\n                                 putStrLn $ bool \"no\" \"yes\" $ trpFind (readi B.readInt bk) tr\n                                 return tr\n                             | otherwise -> do\n                                 return (trpDelete (readi B.readInt bk) tr)\n                   _ -> do\n                     printList $ inOrder tr\n                     printList $ preOrder tr\n                     return tr\n        sfind = B.pack \"find\"\n        \ndata Treap a = Leaf | Node Int a (Treap a) (Treap a) deriving Show\n\ntrpRightRotate :: Treap a -> Treap a\ntrpRightRotate Leaf = Leaf\ntrpRightRotate (Node yp yv Leaf yrt) = Node yp yv Leaf yrt\ntrpRightRotate (Node yp yv (Node xp xv xlt xrt) yrt) = Node xp xv xlt (Node yp yv xrt yrt)\n\ntrpLeftRotate :: Treap a -> Treap a\ntrpLeftRotate Leaf = Leaf\ntrpLeftRotate (Node xp xv xlt Leaf) = Node xp xv xlt Leaf\ntrpLeftRotate (Node xp xv xlt (Node yp yv ylt yrt)) = Node yp yv (Node xp xv xlt ylt) yrt\n\ntrpNormalize :: Treap a -> Treap a\ntrpNormalize Leaf = Leaf\ntrpNormalize (Node xp xv Leaf Leaf) = (Node xp xv Leaf Leaf)\ntrpNormalize xtr@(Node yp _ (Node xp _ _ _) Leaf) | xp > yp =  trpRightRotate xtr\n                                                  | otherwise = xtr\ntrpNormalize ytr@(Node xp _ Leaf (Node yp _ _ _)) | yp > xp = trpLeftRotate ytr\n                                                  | otherwise = ytr\ntrpNormalize xtr@(Node xp _ (Node yp _ _ _) (Node zp _ _ _)) | yp > xp = trpRightRotate xtr\n                                                             | zp > xp = trpLeftRotate xtr\n                                                             | otherwise = xtr\n\ntrpInsert :: (Ord a) => a -> Int -> Treap a -> Treap a\ntrpInsert xv xp (Node yp yv lt rt) | xv > yv = trpNormalize (Node yp yv lt (trpInsert xv xp rt))\n                                   | xv < yv = trpNormalize (Node yp yv (trpInsert xv xp lt) rt)\n                                   | otherwise = Node yp yv lt rt\ntrpInsert xv xp Leaf = Node xp xv Leaf Leaf\n\ntrpFind :: (Ord a) => a -> Treap a -> Bool\ntrpFind _ Leaf = False\ntrpFind x (Node _ y lt rt) | x == y = True\n                           | x > y = trpFind x rt\n                           | otherwise = trpFind x lt\n\ntrpDelete :: (Ord a) => a -> Treap a -> Treap a\ntrpDelete x Leaf = Leaf\ntrpDelete x (Node yp yv lt rt) | x < yv = Node yp yv (trpDelete x lt) rt\n                               | x > yv = Node yp yv lt (trpDelete x rt)\n                               | otherwise = case (lt, rt) of\n                                              (Leaf, Leaf) -> Leaf\n                                              (Leaf, rt) -> let (Node tp tv tlt trt) = trpLeftRotate (Node yp yv lt rt)\n                                                            in Node tp tv (trpDelete x tlt) trt\n                                              (lt, Leaf) -> let (Node tp tv tlt trt) = trpRightRotate (Node yp yv lt rt)\n                                                            in Node tp tv tlt (trpDelete x trt)\n                                              (Node lp _ _ _, Node rp _ _ _) | lp > rp -> let (Node tp tv tlt trt) = trpRightRotate (Node yp yv lt rt)\n                                                                                          in Node tp tv tlt (trpDelete x trt)\n                                                                             | otherwise -> let (Node tp tv tlt trt) = trpLeftRotate (Node yp yv lt rt)\n                                                                                            in Node tp tv (trpDelete x tlt) trt\n\nfoldPre :: (a -> b -> b) -> b -> Treap a -> b\nfoldPre f z Leaf = z\nfoldPre f z (Node _ x l r) = f x y2\n  where y1 = foldPre f z r\n        y2 = foldPre f y1 l\n\nfoldIn :: (a -> b -> b) -> b -> Treap a -> b\nfoldIn f z Leaf = z\nfoldIn f z (Node _ x l r) = foldIn f y2 l\n  where y1 = foldIn f z r\n        y2 = f x y1\n\npreOrder :: Treap a -> [a]\npreOrder = foldPre (:) []\n\ninOrder :: Treap a -> [a]\ninOrder = foldIn (:) []\n\nprintList :: (Show a) => [a] -> IO ()\nprintList = putStrLn . (' ':) . unwords . map show\n\nreadi :: Integral a =>  (ByteString -> Maybe (a, ByteString)) -> ByteString -> a\nreadi f s = let Just (n, _) = f s in n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct node{\n  int key;\n  int priority;\n  struct node *left;\n  struct node *right;\n}node;\n\n\nnode * Delete(node **,int);\nnode * _delete(node **,int);\n\nint find(node *p,int x){\n\n  while(p!=NULL){\n    if(p->key == x)return 1;\n    else if(p->key > x)p=p->left;\n    else p=p->right;\n  }\n\n  return 0;\n\n}\n\nvoid inorder(node *p){\n\n  if(p->left!=NULL)inorder(p->left);\n\n  printf(\" %d\",p->key);\n\n  if(p->right!=NULL)inorder(p->right);\n\n  return;\n\n}\n\nvoid preorder(node *p){\n\n  printf(\" %d\",p->key);\n\n  if(p->left!=NULL)preorder(p->left);\n\n  if(p->right!=NULL)preorder(p->right);\n\n  return;\n\n}\n\nvoid print(node *p){\n\n  inorder(p);\n  printf(\"\\n\");\n\n  preorder(p);\n  printf(\"\\n\");\n\n  return;\n\n}\n\nnode * makenode(int x,int y){\n  node *new=malloc(sizeof(node));\n  new->key=x;\n  new->priority=y;\n  new->left=NULL;\n  new->right=NULL;\n  return new;\n}\n\nnode *rightRotate(node *p){\n  node *q=p->left;\n  p->left=q->right;\n  q->right=p;\n  return q;\n}\n\nnode *leftRotate(node *p){\n  node *q=p->right;\n  p->right=q->left;\n  q->left=p;\n  return q;\n}\n\n\nnode* insert(node **t,int key,int priority){\n  node *new;\n\n  if((*t)==NULL)\n  return new=makenode(key,priority);\n  if ((*t)->key==key)\n  return *t;\n\n  if(key < (*t)->key){\n    (*t)->left=insert(&(*t)->left,key,priority);\n    if((*t)->priority < (*t)->left->priority)\n    (*t)=rightRotate((*t));\n  }\n  else {\n    (*t)->right=insert(&(*t)->right,key,priority);\n    if((*t)->priority < (*t)->right->priority)\n    (*t)=leftRotate((*t));\n  }\n\n  return *t;\n}\n\n\nnode * Delete(node **t,int key){\n  if((*t)==NULL)\n  return NULL;\n\n  if(key < (*t)->key)\n  (*t)->left=Delete(&((*t)->left),key);\n\n  else if(key > (*t)->key)\n  (*t)->right=Delete(&((*t)->right),key);\n\n  else return _delete(t,key);\n\n  return *t;\n}\n\nnode * _delete(node **t,int key){\n  if((*t)->left==NULL && (*t)->right==NULL)\n  return NULL;\n  else if((*t)->left==NULL)\n  (*t)=leftRotate(*t);\n  else if((*t)->right==NULL)\n  (*t)=rightRotate(*t);\n  else {\n    if((*t)->left->priority > (*t)->right->priority)\n    (*t)=rightRotate(*t);\n    else\n    (*t)=leftRotate(*t);\n  }\n  return Delete(t,key);\n}\n\n\nint main(){\n  int n,x,y;\n  char com[8];\n  node *root=NULL;\n\n  scanf(\"%d\",&n);\n\n  for(int i=0;i<n;i++){\n    scanf(\"%s\",com);\n\n    switch(com[0]){\n\n      case 'i':scanf(\"%d %d\",&x,&y);\n      root=insert(&root,x,y);\n      break;\n\n      case 'd':scanf(\"%d\",&x);\n      root=Delete(&root,x);\n      break;\n\n\n      case 'f':scanf(\"%d\",&x);\n      if(find(root,x))printf(\"yes\\n\");\n      else printf(\"no\\n\");\n      break;\n\n      case 'p':print(root);\n      break;\n\n    }\n\n  }\n\n  return 0;\n\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct node{\n    int key;\n    int priority;\n    struct node *left;\n    struct node *right;\n}node;\n\n\nnode * Delete(node **,int);\nnode * _delete(node **,int);\n\nint find(node *p,int x){\n    \n    while(p!=NULL){\n        if(p->key == x)return 1;\n        else if(p->key > x)p=p->left;\n        else p=p->right;\n    }\n    \n    return 0;\n    \n}\n\nvoid inorder(node *p){\n    \n    if(p->left!=NULL)inorder(p->left);\n    \n    printf(\" %d\",p->key);\n    \n    if(p->right!=NULL)inorder(p->right);\n    \n    return;\n    \n}\n\nvoid preorder(node *p){\n    \n    printf(\" %d\",p->key);\n    \n    if(p->left!=NULL)preorder(p->left);\n    \n    if(p->right!=NULL)preorder(p->right);\n    \n    return;\n    \n}\n\nvoid print(node *p){\n    \n    inorder(p);\n    printf(\"\\n\");\n    \n    preorder(p);\n    printf(\"\\n\");\n    \n    return;\n    \n}\n\nnode * makenode(int x,int y){\n    node *new=malloc(sizeof(node));\n    new->key=x;\n    new->priority=y;\n    new->left=NULL;\n    new->right=NULL;\n    return new;\n}\n\nnode *rightRotate(node *p){\n    node *q=p->left;\n    p->left=q->right;\n    q->right=p;\n    return q;\n}\n\nnode *leftRotate(node *p){\n    node *q=p->right;\n    p->right=q->left;\n    q->left=p;\n    return q;\n}\n\n\nnode* insert(node **t,int key,int priority){\n    node *new;\n    \n    if((*t)==NULL)\n        return new=makenode(key,priority);\n    if ((*t)->key==key)\n        return *t;\n    \n    if(key < (*t)->key){\n        (*t)->left=insert(&(*t)->left,key,priority);\n        if((*t)->priority < (*t)->left->priority)\n            (*t)=rightRotate((*t));\n    }\n    else {\n        (*t)->right=insert(&(*t)->right,key,priority);\n        if((*t)->priority < (*t)->right->priority)\n            (*t)=leftRotate((*t));\n    }\n    \n    return *t;\n}\n\n\nnode * Delete(node **t,int key){\n    if((*t)==NULL)\n        return NULL;\n    \n    if(key < (*t)->key)\n        (*t)->left=Delete(&((*t)->left),key);\n    \n    else if(key > (*t)->key)\n        (*t)->right=Delete(&((*t)->right),key);\n    \n    else return _delete(t,key);\n    \n    return *t;\n}\n\nnode * _delete(node **t,int key){\n    if((*t)->left==NULL && (*t)->right==NULL)\n        return NULL;\n    else if((*t)->left==NULL)\n        (*t)=leftRotate(*t);\n    else if((*t)->right==NULL)\n        (*t)=rightRotate(*t);\n    else {\n        if((*t)->left->priority > (*t)->right->priority)\n            (*t)=rightRotate(*t);\n        else\n            (*t)=leftRotate(*t);\n    }\n    return Delete(t,key);\n}\n\n\nint main(){\n    int n,x,y;\n    char com[8];\n    node *root=NULL;\n    \n    scanf(\"%d\",&n);\n    \n    for(int i=0;i<n;i++){\n        scanf(\"%s\",com);\n        \n        switch(com[0]){\n                \n            case 'i':scanf(\"%d %d\",&x,&y);\n                root=insert(&root,x,y);\n                break;\n                \n            case 'd':scanf(\"%d\",&x);\n                root=Delete(&root,x);\n                break;\n                \n                \n            case 'f':scanf(\"%d\",&x);\n                if(find(root,x))printf(\"yes\\n\");\n                else printf(\"no\\n\");\n                break;\n                \n            case 'p':print(root);\n                break;\n                \n        }\n        \n    }\n    \n    return 0;\n    \n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) {\n        n = 10 * n + (c & 0xf);\n        c = getchar_unlocked();\n    }\n    return n;\n}\nint get_str(char *str) {\n    int c;\n    while((c = getchar_unlocked()) > 32) *str++ = (char)c;\n    *str = 0;\n    return c;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\nvoid put_str(char *str) { while(*str) putchar_unlocked(*str++); }\n\ntypedef struct Node {\n    int key;\n    int priority;\n    struct Node *left, *right;\n} Node;\ntypedef struct BST {\n    Node *root;\n    size_t size;\n} BST;\nvoid bst_init(BST *BST) {\n    BST->root = NULL;\n    BST->size = 0;\n}\nNode *bst_rotate_right(Node *root) {\n    Node *tmp = root->left;\n    root->left = tmp->right;\n    tmp->right = root;\n    return tmp;\n}\nNode *bst_rotate_left(Node *root) {\n    Node *tmp = root->right;\n    root->right = tmp->left;\n    tmp->left = root;\n    return tmp;\n}\nNode *bst__insert(Node *root, int key, int priority) {\n    if(root == NULL) {\n        Node *new_node = malloc(sizeof(Node));\n        new_node->key = key;\n        new_node->priority = priority;\n        new_node->left = new_node->right = NULL;\n        return new_node;\n    }\n    if(key == root->key) return root;\n    if(key < root->key) {\n        root->left = bst__insert(root->left, key, priority);\n        if(root->priority < root->left->priority) root = bst_rotate_right(root);\n    } else {\n        root->right = bst__insert(root->right, key, priority);\n        if(root->priority < root->right->priority) root = bst_rotate_left(root);\n    }\n    return root;\n}\nvoid bst_insert(BST *BST, int key, int priority) {\n    BST->root = bst__insert(BST->root, key, priority);\n    BST->size++;\n}\nNode *bst_find(const Node *root, const int key) {\n    while(root != NULL && root->key != key) {\n        if(key < root->key) root = root->left;\n        else root = root->right;\n    }\n    return root;\n}\nNode *bst_get_min(Node *root) {\n    while(root->left != NULL) root = root->left;\n    return root;\n}\nNode *bst__delete(Node *root, int key) {\n    if(root == NULL) return NULL;\n    if(key < root->key) root->left = bst__delete(root->left, key);\n    else if(key > root->key) root->right = bst__delete(root->right, key);\n    else if(root->left && root->right) {\n        if(root->left->priority > root->right->priority) root = bst_rotate_right(root);\n        else root = bst_rotate_left(root);\n        root = bst__delete(root, key);\n    } else {\n        Node *tmp = root;\n        if(root->left) {\n            root = bst_rotate_right(root);\n            root->right = NULL;\n        }\n        else if(root->right) {\n            root = bst_rotate_left(root);\n            root->left = NULL;\n        }\n        else root = NULL;\n        free(tmp);\n    }\n    return root;\n}\nvoid bst_delete(BST *BST, int key) {\n    BST->root = bst__delete(BST->root, key);\n    BST->size--;\n}\nvoid bst_inorder(Node *root) {\n    if(root == NULL) return;\n    bst_inorder(root->left);\n    putchar_unlocked(' '), put_uint(root->key);\n    bst_inorder(root->right);\n}\nvoid bst_preorder(Node *root) {\n    if(root == NULL) return;\n    putchar_unlocked(' '), put_uint(root->key);\n    bst_preorder(root->left);\n    bst_preorder(root->right);\n}\nint main(int argc, char **argv) {\n    BST BST;\n    bst_init(&BST);\n    int m = get_uint();\n    int key, priority;\n    char c[8];\n    for(int i = 0; i < m; ++i) {\n        get_str(c);\n        switch(*c) {\n        case 'i':\n            key = get_uint();\n            priority = get_uint();\n            bst_insert(&BST, key, priority);\n            break;\n        case 'f':\n            key = get_uint();\n            put_str(bst_find(BST.root, key) ? \"yes\\n\" : \"no\\n\");\n            break;\n        case 'd':\n            key = get_uint();\n            bst_delete(&BST, key);\n            break;\n        default:\n            bst_inorder(BST.root);\n            putchar_unlocked('\\n');\n            bst_preorder(BST.root);\n            putchar_unlocked('\\n');\n            break;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define NIL NULL\ntypedef struct node{\n\tint key;\n\tint pri;\n\tstruct node *right , *left;\n}Node;\n\nNode * Delete(Node **,int);\nNode * del(Node **,int);\n\nint find(Node *p,int x)\n{\n\twhile(p!=NIL)\n\t{\n\t\tif(p->key==x)return 1;\n\t\telse if(p->key > x)p = p->left;\n\t\telse p = p->right;\n\t}\n\treturn 0;\n}\n\nvoid inorder(Node *a)\n{\n\tif(a->left!=NIL) inorder(a->left);\n\tprintf(\" %d\",a->key);\n\tif(a->right!=NIL) inorder(a->right);\n\treturn;\n}\n\nvoid preorder(Node *p)\n{\n\tprintf(\" %d\",p->key);\n\tif(p->left!=NIL) preorder(p->left);\n\tif(p->right!=NIL) preorder(p->right);\n\treturn;\n}\n\nvoid print(Node *p)\n{\n\tinorder(p);\n\tprintf(\"\\n\");\n\tpreorder(p);\n\tprintf(\"\\n\");\n\treturn;\n}\n\nNode * makenode(int x , int y)\n{\n\tNode *new = malloc(sizeof(Node));\n\tnew->key = x;\n\tnew->pri = y;\n\tnew->left = NIL;\n\tnew->right = NIL;\n\treturn new;\n}\n\nNode *rightRotate(Node *p)\n{\n\tNode *q = p->left;\n\tp->left = q->right;\n\tq->right = p;\n\treturn q;\n}\n\nNode *leftRotate(Node *p)\n{\n\tNode *q = p->right;\n\tp->right = q->left;\n\tq->left = p;\n\treturn q;\n}\n\nNode* insert(Node **t , int key, int pri)\n{\n\tNode *new;\n\tif((*t)==NIL)\n\treturn new = makenode(key,pri);\n\tif((*t)->key == key)\n\treturn *t;\n\t\n\tif(key < (*t)->key)\n\t{\n\t\t(*t)->left = insert(&(*t)->left,key,pri);\n\t\tif((*t)->pri < (*t)->left->pri)\n\t\t(*t) = rightRotate(*t);\n\t}\n\telse\n\t{\n\t\t(*t)->right = insert(&(*t)->right,key,pri);\n\t\tif((*t)->pri < (*t)->right->pri)\n\t\t(*t) = leftRotate((*t));\n\t}\n\treturn *t;\n}\n\nNode * Delete(Node **t , int key)\n{\n\tif((*t)==NIL)\n\treturn NIL;\n\t\n\tif(key < (*t)->key)\n\t(*t)->left = Delete(&((*t)->left),key);\n\t\n\telse if(key > (*t)->key)\n\t(*t)->right = Delete(&((*t)->right),key);\n\n\telse return del(t,key);\n\treturn *t;\n}\n\nNode * del(Node **t , int key)\n{\n\tif((*t)->left == NIL && (*t)->right == NIL)\n\t{\n\t\treturn NIL;\n\t}\n\telse if((*t)->left == NIL)\n\t{\n\t\t(*t) = leftRotate(*t);\n\t}\n\telse if((*t)->right ==NIL)\n\t{\n\t\t(*t) = rightRotate(*t);\n\t}\n\telse\n\t{\n\t\tif((*t)->left->pri > (*t)->right->pri)\n\t\t(*t) = rightRotate(*t);\n\t\telse\n\t\t(*t) = leftRotate(*t);\n\t}\n\treturn Delete(t,key);\n}\n\nint main(void)\n{\n\tint num ,  x, y;\n\tchar com[8];\n\tNode *root = NIL;\n\tscanf(\"%d\",&num);\n\t\n\tfor(int i = 0; i < num; i++)\n\t{\n\t\tscanf(\"%s\",com);\n\t\tswitch(com[0])\n\t\t{\n\t\t\tcase 'i':scanf(\"%d %d\",&x,&y);\n\t\t\troot = insert(&root,x,y);\n\t\t\tbreak;\n\t\t\tcase 'd':scanf(\"%d\",&x);\n\t\t\troot = Delete(&root,x);\n\t\t\tbreak;\n\t\t\tcase 'f':scanf(\"%d\",&x);\n\t\t\tif(find(root,x))printf(\"yes\\n\");\n\t\t\telse printf(\"no\\n\");\n\t\t\tbreak;\n\t\t\tcase 'p':print(root);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\ntypedef struct gNode{\n  int key, priority;\n  struct gNode *left;\n  struct gNode *right;\n}gNode;\ngNode * del(gNode **,int);\ngNode * _delete(gNode **,int);\nint find(gNode *p,int x){\n  while(p != NULL){\n    if(p->key == x) return 1;\n    else if(p->key > x) p = p->left;\n    else p = p->right;\n  }\n  return 0;\n}\nvoid Inorder(gNode *p){\n  if(p->left != NULL) Inorder(p->left);\n  printf(\" %d\", p->key);\n  if(p->right != NULL) Inorder(p->right);\n  return;\n}\nvoid Preorder(gNode *p){\n  printf(\" %d\", p->key);\n  if(p->left != NULL) Preorder(p->left);\n  if(p->right != NULL) Preorder(p->right);\n  return;\n}\nvoid print(gNode *p){\n  Inorder(p);\n  printf(\"\\n\");\n  Preorder(p);\n  printf(\"\\n\");\n  return;\n}\ngNode * Make_node(int x,int y){\n  gNode *new = malloc(sizeof(gNode));\n  new->key = x;\n  new->priority = y;\n  new->left = NULL;\n  new->right = NULL;\n  return new;\n}\ngNode *R_R(gNode *p){\n  gNode *q = p->left;\n  p->left = q->right;\n  q->right = p;\n  return q;\n}\ngNode *L_R(gNode *p){\n  gNode *q = p->right;\n  p->right = q->left;\n  q->left = p;\n  return q;\n}\ngNode* Ins(gNode **t, int key, int priority){\n  gNode *new;\n  if((*t) == NULL)\n    return new = Make_node(key,priority);\n  if ((*t)->key == key)\n    return *t;\n  if(key < (*t)->key){\n    (*t)->left = Ins(&(*t)->left, key, priority);\n    if((*t)->priority < (*t)->left->priority)\n      (*t) = R_R((*t));\n  }\n  else {\n    (*t)->right = Ins(&(*t)->right, key, priority);\n    if((*t)->priority < (*t)->right->priority)\n      (*t) = L_R((*t));\n  }\n  return *t;\n}\ngNode * del(gNode **t, int key){\n  if((*t) == NULL)\n    return NULL;\n  if(key < (*t)->key)\n    (*t)->left = del(&((*t)->left),key);\n  else if(key > (*t)->key)\n    (*t)->right = del(&((*t)->right),key);\n  else return _delete(t,key);\n  return *t;\n}\ngNode * _delete(gNode **t,int key){\n  if((*t)->left == NULL && (*t)->right == NULL)\n    return NULL;\n  else if((*t)->left == NULL)\n    (*t) = L_R(*t);\n  else if((*t)->right == NULL)\n    (*t) = R_R(*t);\n  else {\n    if((*t)->left->priority > (*t)->right->priority)\n      (*t) = R_R(*t);\n    else\n      (*t) = L_R(*t);\n  }\n  return del(t,key);\n}\nint main(){\n  int i;\n\tint n, x, y;\n  char com[8];\n  gNode *r = NULL;\n  scanf(\"%d\", &n);\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%s\", com);\n    switch(com[0]){\n    case 'i':scanf(\"%d %d\", &x, &y);\n      r = Ins(&r, x, y);\n      break;\n    case 'd':scanf(\"%d\", &x);\n      r = del(&r, x);\n      break;\n    case 'f':scanf(\"%d\", &x);\n      if(find(r,x)) printf(\"yes\\n\");\n      else printf(\"no\\n\");\n      break;\n    case 'p':print(r);\n      break;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 41\n\ntypedef struct node{\n  int l, r;\n}node;\n\nnode c[N];\nint a[N];\nint b[N];\nint cnt=0;\n\nvoid postorder(int root,int n){\n\n        if(c[root].l != -1) postorder(c[root].l, n);\n\n        if(c[root].r != -1) postorder(c[root].r, n);\n\n        if(cnt < n-1) printf(\"%d \", root);\n        else printf(\"%d\\n\", root);\n\n        cnt++;\n\n        return;\n}\n\nint reconst(int start,int last,int n){\n  int i, j;\n\n  if(start==last) return b[start];\n  else if(start > last) return -1;\n\n  else{\n    for(i = 1 ; i <= n ; i++){\n      for(j = start ; j <= last ; j++){\n        if(a[i] == b[j]){\n          c[a[i]].l = reconst(start, j - 1, n);\n          c[a[i]].r = reconst(j + 1, last, n);\n          return a[i];\n        }\n      }\n    }\n  }\n}\n\n\nint main(){\n  int n, i, root;\n\n  scanf(\"%d\", &n);\n\n  for(i = 1 ; i <= n ; i++) scanf(\"%d\",&a[i]);\n\n  for(i = 1 ; i <= n ; i++) scanf(\"%d\",&b[i]);\n\n  for(i = 1 ; i <= n ; i++){\n    c[i].l = -1;\n    c[i].r = -1;\n  }\n\n  root = reconst(1,n,n);\n  postorder(root,n);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define NIL NULL\ntypedef struct node{\n\tint key;\n\tint pri;\n\tstruct node *right , *left;\n}Node;\n\nNode * Delete(Node **,int);\nNode * del(Node **,int);\n\nint find(Node *p,int x)\n{\n\twhile(p!=NIL)\n\t{\n\t\tif(p->key==x)return 1;\n\t\telse if(p->key > x)p = p->left;\n\t\telse p = p->right;\n\t}\n\treturn 0;\n}\n\nvoid inorder(Node *a)\n{\n\tif(a->left!=NIL) inorder(a->left);\n\tprintf(\" %d\",a->key);\n\tif(a->right!=NIL) inorder(a->right);\n\treturn;\n}\n\nvoid preorder(Node *p)\n{\n\tprintf(\" %d\",p->key);\n\tif(p->left!=NIL) preorder(p->left);\n\tif(p->right!=NIL) preorder(p->right);\n\treturn;\n}\n\nvoid print(Node *p)\n{\n\tinorder(p);\n\tprintf(\"\\n\");\n\tpreorder(p);\n\tprintf(\"\\n\");\n\treturn;\n}\n\nNode * makenode(int x , int y)\n{\n\tNode *new = malloc(sizeof(Node));\n\tnew->key = x;\n\tnew->pri = y;\n\tnew->left = NIL;\n\tnew->right = NIL;\n\treturn new;\n}\n\nNode *rightRotate(Node *p)\n{\n\tNode *q = p->left;\n\tp->left = q->right;\n\tq->right = p;\n\treturn q;\n}\n\nNode *leftRotate(Node *p)\n{\n\tNode *q = p->right;\n\tp->right = q->left;\n\tq->left = p;\n\treturn q;\n}\n\nNode* insert(Node **t , int key, int pri)\n{\n\tNode *new;\n\tif((*t)==NIL)\n\treturn new = makenode(key,pri);\n\tif((*t)->key == key)\n\treturn *t;\n\t\n\tif(key < (*t)->key)\n\t{\n\t\t(*t)->left = insert(&(*t)->left,key,pri);\n\t\tif((*t)->pri < (*t)->left->pri)\n\t\t(*t) = rightRotate(*t);\n\t}\n\telse{\n\t\t(*t)->right = insert(&(*t)->right,key,pri);\n\t\tif((*t)->pri < (*t)->right->pri)\n\t\t(*t) = leftRotate((*t));\n\t}\n\treturn *t;\n}\n\nNode * Delete(Node **t , int key)\n{\n\tif((*t)==NIL)\n\treturn NIL;\n\t\n\tif(key < (*t)->key)\n\t(*t)->left = Delete(&((*t)->left),key);\n\t\n\telse if(key > (*t)->key)\n\t(*t)->right = Delete(&((*t)->right),key);\n\n\telse return del(t,key);\n\treturn *t;\n}\n\nNode * del(Node **t , int key)\n{\n\tif((*t)->left == NIL && (*t)->right == NIL)\n\t{\n\t\treturn NIL;\n\t}\n\telse if((*t)->left == NIL)\n\t{\n\t\t(*t) = leftRotate(*t);\n\t}\n\telse if((*t)->right ==NIL)\n\t{\n\t\t(*t) = rightRotate(*t);\n\t}\n\telse{\n\t\tif((*t)->left->pri > (*t)->right->pri)\n\t\t(*t) = rightRotate(*t);\n\t\telse\n\t\t(*t) = leftRotate(*t);\n\t}\n\treturn Delete(t,key);\n}\n\nint main(void)\n{\n\tint num ,  x, y;\n\tchar com[8];\n\tNode *root = NIL;\n\tscanf(\"%d\",&num);\n\t\n\tfor(int i = 0; i < num; i++)\n\t{\n\t\tscanf(\"%s\",com);\n\t\tswitch(com[0])\n\t\t{\n\t\t\tcase 'i':scanf(\"%d %d\",&x,&y);\n\t\t\troot = insert(&root,x,y);\n\t\t\tbreak;\n\t\t\tcase 'd':scanf(\"%d\",&x);\n\t\t\troot = Delete(&root,x);\n\t\t\tbreak;\n\t\t\tcase 'f':scanf(\"%d\",&x);\n\t\t\tif(find(root,x))printf(\"yes\\n\");\n\t\t\telse printf(\"no\\n\");\n\t\t\tbreak;\n\t\t\tcase 'p':print(root);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node{\n\tint key;\n\tint priority;\n\tstruct node *left;\n\tstruct node *right;\n}Node;\n\nNode * makeNode(int,int);\nNode * rightRotate(Node *);\nNode * leftRotate(Node *);\nNode * insert(Node **, int, int);\nNode * delete(Node **,int);\nNode * KeyDelete(Node **,int);\nint find(Node *, int);\nvoid inorder(Node *);\nvoid preorder(Node *);\nvoid print(Node *);\n\nint main(){\n    int m, k, p;\n    char com[8];\n    int i;\n    Node *root=NULL;\n\n    scanf(\"%d\",&m);\n\n    for(i=0;i<m;i++){\n        scanf(\"%s\", com);\n\n        switch(com[0]){\n            case 'i':\n                scanf(\"%d %d\", &k,&p);\n                root=insert(&root,k,p);\n                break;\n            case 'd':\n                scanf(\"%d\", &k);\n                root=delete(&root,k);\n                break;\n            case 'f':\n                scanf(\"%d\", &k);\n                if(find(root,k)==1) printf(\"yes\\n\");\n                else printf(\"no\\n\");\n                break;\n            case 'p':\n                print(root);\n                break;\n        }\n    }\n}\n\nNode * makeNode(int k, int p){\n    Node *new=malloc(sizeof(Node));\n    new->key=k;\n    new->priority=p;\n    new->left=NULL;\n    new->right=NULL;\n    return new;\n}\n\nNode * rightRotate(Node *t){\n    Node *s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s; // root of the subtree\n}\n\nNode * leftRotate(Node *t){\n    Node *s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s; // root of the subtree\n}\n\nNode * insert(Node **t, int key, int priority){          // 再帰的に探索\n    Node *new;\n\n    if((*t) == NULL) return new= makeNode(key, priority);    // 葉に到達したら新しい節点を生成して返す\n    if(key == (*t)->key) return *t;                   // 重複したkeyは無視\n\n    if(key < (*t)->key){                            // 左の子へ移動\n        (*t)->left = insert(&((*t)->left), key, priority);  // 左の子へのポインタを更新\n        if ((*t)->priority < (*t)->left->priority)  (*t) = rightRotate((*t));      // 左の子の方が優先度が高い場合右回転\n    }\n    else {                                                         // 右の子へ移動\n        (*t)->right = insert(&((*t)->right), key, priority);          // 右の子へのポインタを更新\n        if((*t)->priority < (*t)->right->priority) (*t) = leftRotate((*t));        // 右の子の方が優先度が高い場合左回転\n    }\n    return *t;\n}\n\nNode * delete(Node **t, int key){\n    if((*t) == NULL) return NULL;\n    if(key < (*t)->key)  (*t)->left = delete(&((*t)->left), key);         // 削除対象を検索\n    else if(key > (*t)->key) (*t)->right = delete(&((*t)->right), key);\n    else return KeyDelete(t, key);\n    return *t;\n}\n\nNode * KeyDelete(Node **t, int key){ // 削除対象の節点の場合\n    if((*t)->left == NULL && (*t)->right == NULL)  return NULL;      // 葉の場合\n    else if((*t)->left == NULL)   (*t) = leftRotate(*t);      // 右の子のみを持つ場合左回転\n    else if((*t)->right == NULL) (*t) = rightRotate(*t);      // 左の子のみを持つ場合右回転\n    else{                                         // 左の子と右の子を両方持つ場合\n        if((*t)->left->priority > (*t)->right->priority){    // 優先度が高い方を持ち上げる\n            (*t) = rightRotate(*t);\n        }\n        else  (*t) = leftRotate(*t);\n    }\n    return delete(t, key);\n}\n\nint find(Node *t, int key){\n    while(t!=NULL){\n        if(t->key == key) return 1; // yes\n        else if(t->key > key) t=t->left;\n        else t=t->right;\n    }\n    return 0; // no\n}\n\nvoid inorder(Node *t){\n    if(t->left!=NULL) inorder(t->left);\n    printf(\" %d\", t->key);\n    if(t->right!=NULL) inorder(t->right);\n}\n\nvoid preorder(Node *t){\n    printf(\" %d\", t->key);\n    if(t->left!=NULL) preorder(t->left);\n    if(t->right!=NULL) preorder(t->right);\n}\n\nvoid print(Node *t){\n    inorder(t);\n    printf(\"\\n\");\n\n    preorder(t);\n    printf(\"\\n\");\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nstruct tree {\n  int key;\n  int priority;\n  struct tree *left;\n  struct tree *right;\n};\nstruct tree *root = NULL;\nint Search(struct tree *p, int key);\nstruct tree *Lrotation(struct tree *p);\nstruct tree *Rrotation(struct tree *p);\nstruct tree *Insert(struct tree **p, int key, int priority);\nstruct tree *Delete(struct tree **p, int key);\nstruct tree *delete(struct tree **p, int key);\nvoid Dispm(struct tree *p);\nvoid Dispp(struct tree *p);\nint main(void)\n{\n  int i, count, key, priority;\n  char command[7];\n  scanf(\"%d\", &count);\n  for (i = 0; i < count; i++) {\n    scanf(\"%*c%s\", command);\n    switch (command[0]) {\n    case 'f':\n      scanf(\"%d\", &key);\n      if (Search(root, key)) {\n        printf(\"yes\\n\");\n      } else {\n        printf(\"no\\n\");\n      }\n      break;\n    case 'i':\n      scanf(\"%d %d\", &key, &priority);\n      root = Insert(&root, key, priority);\n      break;\n    case 'd':\n      scanf(\"%d\", &key);\n      Delete(&root, key);\n      break;\n    case 'p':\n      Dispm(root);\n      putchar('\\n');\n      Dispp(root);\n      putchar('\\n');\n      break;\n    }\n  }\n  return 0;\n}\nint Search(struct tree *p, int key)\n{\n  if (p == NULL) {\n    return 0;\n  } else if (p->key == key) {\n    return 1;\n  } else if (p->key > key) {\n    return Search(p->left, key);\n  } else {\n    return Search(p->right, key);\n  }\n}\nstruct tree *Lrotation(struct tree *p)\n{\n  struct tree *q = p->right;\n  p->right = q->left;\n  q->left = p;\n  return q;\n}\nstruct tree *Rrotation(struct tree *p)\n{\n  struct tree *q = p->left;\n  p->left = q->right;\n  q->right = p;\n  return q;\n}\nstruct tree *Insert(struct tree **p, int key, int priority)\n{\n  if (*p == NULL) {\n    *p = (struct tree*)malloc(sizeof(struct tree));\n    (*p)->key = key;\n    (*p)->priority = priority;\n    (*p)->left = NULL;\n    (*p)->right = NULL;\n  } else if ((*p)->key > key) {\n    (*p)->left = Insert(&(*p)->left, key, priority);\n    if ((*p)->priority <  (*p)->left->priority) *p = Rrotation(*p);\n  } else if ((*p)->key < key) {\n    (*p)->right = Insert(&(*p)->right, key, priority);\n    if ((*p)->priority <  (*p)->right->priority) *p = Lrotation(*p);\n  }\n  return *p;\n}\nstruct tree *Delete(struct tree **p, int key)\n{\n  if ((*p) == NULL) return NULL;\n  if ((*p)->key > key) (*p)->left = Delete(&(*p)->left, key);\n  else if ((*p)->key < key) (*p)->right = Delete(&(*p)->right, key);\n  else delete(p, key);\n  return *p;\n}\nstruct tree *delete(struct tree **p, int key)\n{\n  if ((*p)->left == NULL && (*p)->right == NULL) return *p = NULL;\n  else if ((*p)->left == NULL) *p = Lrotation(*p);\n  else if ((*p)->right == NULL) *p = Rrotation(*p);\n  else {\n    if ((*p)->left->priority > (*p)->right->priority) *p = Rrotation(*p);\n    else *p = Lrotation(*p);\n  }\n  return Delete(p, key);\n}\nvoid Dispm(struct tree *p)\n{\n  if (p != NULL) {\n    Dispm(p->left);\n    printf(\" %d\", p->key);\n    Dispm(p->right);\n  }\n}\nvoid Dispp(struct tree *p)\n{\n  if (p != NULL) {\n    printf(\" %d\", p->key);\n    Dispp(p->left);\n    Dispp(p->right);\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct node{\n\tint key;\n\tint priority;\n\tstruct node *left;\n\tstruct node *right;\n}node;\n\n\nnode * Delete(node **,int);\nnode * _delete(node **,int);\n\nint find(node *t,int x){\n\n\twhile(t!=NULL){\n\t\tif(t->key == x) return 1;\n\t\telse if(t->key > x) t=t->left;\n\t\telse t=t->right;\n\t}\n\n\treturn 0;\n\n}\n\nvoid inorder(node *t){\n\n\tif(t->left!=NULL)inorder(t->left);\n\n\tprintf(\" %d\",t->key);\n\n\tif(t->right!=NULL)inorder(t->right);\n\n\treturn;\n\n}\n\nvoid preorder(node *t){\n\n\tprintf(\" %d\",t->key);\n\n\tif(t->left!=NULL)preorder(t->left);\n\n\tif(t->right!=NULL)preorder(t->right);\n\n\treturn;\n\n}\n\nvoid print(node *t){\n\n\tinorder(t);\n\tprintf(\"\\n\");\n\n\tpreorder(t);\n\tprintf(\"\\n\");\n\n\treturn;\n\n}\n\nnode * Node(int x,int y){\n\tnode *n=malloc(sizeof(node));\n\tn->key=x;\n\tn->priority=y;\n\tn->left=NULL;\n\tn->right=NULL;\n\treturn n;\n}\n\nnode *rightRotate(node *t){\n\tnode *s=t->left;\n\tt->left=s->right;\n\ts->right=t;\n\treturn s;\n}\n\nnode *leftRotate(node *t){\n\tnode *s=t->right;\n\tt->right=s->left;\n\ts->left=t;\n\treturn s;\n}\n\n\nnode* insert(node **t,int key,int priority){\n\tnode *n;\n\n\tif((*t)==NULL)\n\t\treturn n=Node(key,priority);\n\tif ((*t)->key==key)\n\t\treturn *t;\n\n\tif(key < (*t)->key){\n\t\t(*t)->left=insert(&(*t)->left,key,priority);\n\t\tif((*t)->priority < (*t)->left->priority)\n\t\t\t(*t)=rightRotate((*t));\n\t}\n\telse {\n\t\t(*t)->right=insert(&(*t)->right,key,priority);\n\t\tif((*t)->priority < (*t)->right->priority)\n\t\t\t(*t)=leftRotate((*t));\n\t}\n\n\treturn *t;\n}\n\n\nnode * Delete(node **t,int key){\n\tif((*t)==NULL)\n\t\treturn NULL;\n\n\tif(key < (*t)->key)\n\t\t(*t)->left=Delete(&((*t)->left),key);\n\n\telse if(key > (*t)->key)\n\t\t(*t)->right=Delete(&((*t)->right),key);\n\n\telse return _delete(t,key);\n\n\treturn *t;\n}\n\nnode * _delete(node **t,int key){\n\tif((*t)->left==NULL && (*t)->right==NULL)\n\t\treturn NULL;\n\telse if((*t)->left==NULL)\n\t\t(*t)=leftRotate(*t);\n\telse if((*t)->right==NULL)\n\t\t(*t)=rightRotate(*t);\n\telse {\n\t\tif((*t)->left->priority > (*t)->right->priority)\n\t\t\t(*t)=rightRotate(*t);\n\t\telse\n\t\t\t(*t)=leftRotate(*t);\n\t}\n\treturn Delete(t,key);\n}\n\n\nint main(){\n\tint n,x,y;\n\tchar c[8];\n\tnode *t=NULL;\n\n\tscanf(\"%d\",&n);\n\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%s\",c);\n\n\t\tswitch(c[0]){\n\n\t\t\tcase 'i':scanf(\"%d %d\",&x,&y);\n\t\t\t\t\t t=insert(&t,x,y);\n\t\t\t\t\t break;\n\n\t\t\tcase 'd':scanf(\"%d\",&x);\n\t\t\t\t\t t=Delete(&t,x);\n\t\t\t\t\t break;\n\n\n\t\t\tcase 'f':scanf(\"%d\",&x);\n\t\t\t\t\t if(find(t,x))printf(\"yes\\n\");\n\t\t\t\t\t else printf(\"no\\n\");\n\t\t\t\t\t break;\n\n\t\t\tcase 'p':print(t);\n\t\t\t\t\t break;\n\n\t\t}\n\n\t}\n\n\treturn 0;\n\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct P{\n    int key,pri;\n    struct P *left,*right,*parent;\n}Node;\n\nNode *root,*NIL;\n\nvoid pre(Node *node){\n    if(node==NIL){return;}\n    printf(\" %d\",node->key);\n    pre(node->left);\n    pre(node->right);\n}\n\nvoid ino(Node *node){\n    if(node==NIL){return;}\n    ino(node->left);\n    printf(\" %d\",node->key);\n    ino(node->right);\n}\n\nNode* rightRotate(Node* t){\n    Node* s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n}\n\nNode* leftRotate(Node* t){\n    Node* s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;\n}\n\nNode* insert(Node* t, int key, int pri){\n    Node *z;\n    if(t == NIL){\n        z = (Node*)malloc(sizeof(Node));\n        z->key=key; z->pri=pri; z->left = NIL; z->right=NIL;\n        return z;\n    }\n    if( key < t->key){\n        t->left = insert(t->left, key, pri);\n        if(t->pri < t->left->pri){\n            t = rightRotate(t);\n        }\n    }else{\n        t->right = insert(t->right, key, pri);\n        if(t->pri < t->right->pri){\n            t = leftRotate(t);\n        }\n    }\n    return t;\n}\n\nNode* find(Node *node,int k){\n    while(node!=NIL){\n        if(k < node->key){node = node->left;}\n        else if(k>node->key){node = node->right;}\n        else{return node;}\n    }\n    return NIL;\n}\n\nNode* Sdelete(Node*,int);\n\nNode* delete(Node* t, int key){\n    if(t == NIL){\n        return NIL;\n    }\n    if(key < t->key){\n        t->left = delete(t->left, key);\n    }else if(key > t->key){\n        t->right = delete(t->right, key);\n    }else{\n        return Sdelete(t, key);\n    }\n    return t;\n}\n\nNode* Sdelete(Node* t,int key){\n    if(t->left == NIL && t->right == NIL){\n        free(t);\n        return NIL;\n    }else if(t->left == NIL){\n        t = leftRotate(t);\n    }else if(t->right == NIL){\n        t = rightRotate(t);\n    }else{\n        if(t->left->pri > t->right->pri){\n            t = rightRotate(t);\n        }else{\n            t = leftRotate(t);\n        }\n    }\n    return delete(t, key);\n}\n\nint main(void){\n    int n,i,j,x,y;\n    char str[7];\n    Node *node;\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n        scanf(\"%s\",str);\n        if(str[0]=='i'){\n            scanf(\"%d %d\",&x,&y);\n            root=insert(root,x,y);\n            x++;\n        }else if(str[0]=='f'){\n            scanf(\"%d\",&y);\n            node = find(root,y);\n            if(node!=NIL){printf(\"yes\\n\");}\n            else{printf(\"no\\n\");}\n        }else if(str[0]=='d'){\n            scanf(\"%d\",&y);\n            root=delete(root,y);\n        }else{\n            ino(root);\n            printf(\"\\n\");\n            pre(root);\n            printf(\"\\n\");\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node{\n\tstruct node*oya,*ko[2];\n\tint val,p;\n}node;\n\nvoid rot(node*v,int d){\n\tnode*nnn=v->ko[d];\n\t \n\tv->ko[d]=nnn->ko[d^1];\n\tif(v->ko[d])v->ko[d]->oya=v;\n\t \n\tv->oya->ko[v->oya->ko[1]==v]=nnn;\n\tnnn->oya=v->oya;\n\t \n\tnnn->ko[d^1]=v;\n\tv->oya=nnn;  \n}\nvoid ins(node*v,node*oya,int dir,int val,int p){\n\tif(!v){\n\t\tv=calloc(1,sizeof(node));\n\t\tv->oya=oya;\n\t\tv->val=val;\n\t\tv->p=p;\n\t\toya->ko[dir]=v;\n\t}else{\n\t\tint d=v->val<val;\n\t\tins(v->ko[d],v,d,val,p);\n\t\tif(v->ko[d]->p > v->p)rot(v,d);\n\t}\n}\nnode*find(node*v,int val){\n\tif(!v)return 0;\n\tif(v->val==val)return v;\n\treturn find(v->ko[v->val<val],val);\n}\nvoid del(node*v){\n\twhile(v){\n\t\tif(v->ko[0]){\n\t\t\tif(v->ko[1])rot(v,v->ko[1]->p > v->ko[0]->p);\n\t\t\telse rot(v,0);\n\t\t}else{\n\t\t\tif(v->ko[1])rot(v,1);\n\t\t\telse v=v->oya->ko[v->oya->ko[1]==v]=0;\n\t\t}\n\t}\n}\n\nvoid f(node*v,int mode){\n\tif(!v)return;\n\tif(!mode)printf(\" %d\",v->val);\n\tf(v->ko[0],mode);\n\tif(mode)printf(\" %d\",v->val);\n\tf(v->ko[1],mode);\n}\n\nnode root;\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\t \n\twhile(n--){\n\t\tint t,p;\n\t\tchar s[10];\n\t\tscanf(\"%s\",s);\n\t\tif(s[0]=='p'){\n\t\t\tf(root.ko[0],1);puts(\"\");\n\t\t\tf(root.ko[0],0);puts(\"\");\n\t\t}else if(s[0]=='i'){\n\t\t\tscanf(\"%d%d\",&t,&p);\n\t\t\tins(root.ko[0],&root,0,t,p);\n\t\t}else if(s[0]=='f'){\n\t\t\tscanf(\"%d\",&t);\n\t\t\tputs(find(root.ko[0],t)?\"yes\":\"no\");\n\t\t}else{\n\t\t\tscanf(\"%d\",&t);\n\t\t\tdel(find(root.ko[0],t));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct node{\n  struct node *right;\n  struct node *left;\n  struct node *parent;\n  int key;\n};\ntypedef struct node * Node;\n#define NIL NULL\n\nNode root;\n\nNode treeMinimum(Node x){\n  while(x->left!=NIL)\n    x =x->left;\n    return x;\n}\n\nNode treeMaximum(Node x){\n  while(x->right != NIL)\n    x = x->right;\n    return x;\n}\n\nNode treeSearch(Node u, int k){\n  while(u!=NIL && k!=u->key){\n\n  if(k < u->key) u=u->left;\n\n  else u=u->right;\n  }\n  return u;\n  \n}\n\nNode treeSuccessor(Node x){\n  Node y;\n  if(x->right != NIL) return treeMinimum(x->right);\n  y = x->parent;\n  while(y != NIL && x == y->right){\n    x = y;\n    y = y->parent;\n  }\n  return y;\n\n}\n\nvoid treeDelete(Node z){\n  Node y; // node to be deleted\n  Node x; // child of y\n  if(z->left==NIL || z->right==NIL) y = z;\n  else y = treeSuccessor(z);\n\n  if(y->left != NIL) x=y->left;\n  else x = y->right;\n\n  if(x!=NIL) x->parent = y->parent;\n  if(y->parent==NIL) root = x;\n  else if(y == y->parent->left) y->parent->left = x;\n  else y->parent->right =x;\n  \n  if(y!= z) z->key = y->key;\n  free(y);\n}\n\nvoid insert(int k){\n  Node y = NIL;\n  Node x = root;\n  Node z;\n\n  z = malloc(sizeof(struct node));\n  z->key = k;\n  z->left = NIL;\n  z->right = NIL;\n\n  while(x!=NIL){\n    y = x;\n    if(z->key < x->key) x = x->left;\n    else x = x->right;\n  }\n  z->parent = y;\n  if(y==NIL) root = z;\n  else if(z->key < y->key) y->left = z;\n  else y->right = z;\n}\n\nvoid inorder(Node u){\n  if(u == NIL)return;\n    inorder(u->left);\n    printf(\" %d\",u->key);\n    inorder(u->right);\n  \n}\nvoid preorder(Node u){\n  if(u ==NIL)return;\n    printf(\" %d\",u->key);\n    preorder(u->left);\n    preorder(u->right);\n  \n}\n\n\nint main(){\n  int n, i, x;\n  char com[20];\n  scanf(\"%d\", &n);\n\n  for ( i = 0; i < n; i++ ){\n    scanf(\"%s\", com);\n    if ( com[0] == 'f' ){\n      scanf(\"%d\", &x);\n      Node t = treeSearch(root, x);\n      if ( t != NIL ) printf(\"yes\\n\");\n      else printf(\"no\\n\");\n    } else if ( com[0] == 'i' ){\n      scanf(\"%d\", &x);\n      insert(x);\n    } else if ( com[0] == 'p' ){\n      inorder(root);\n      printf(\"\\n\");\n      preorder(root);\n      printf(\"\\n\");\n    } else if ( com[0] == 'd' ){\n      scanf(\"%d\", &x);\n      treeDelete(treeSearch(root, x));\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nstruct node {\n  int key;\n  int priority;\n  struct node *right;\n  struct node *left;\n};\n\ntypedef struct node* Nodepointer;\nNodepointer nil=NULL, root;\n\nNodepointer delete(Nodepointer*, int);\nNodepointer _delete(Nodepointer*, int);\n\nNodepointer Node(int key, int priority){\n Nodepointer z;\n  z = (Nodepointer)malloc(sizeof(struct node));\n  z->key = key;\n  z->priority = priority;\n  z->left = nil;\n  z->right = nil;\n  return z;\n}\n\nNodepointer rightRotate(Nodepointer t){\n  Nodepointer s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\n\nNodepointer leftRotate(Nodepointer t){\n  Nodepointer s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\n\nNodepointer insert(Nodepointer *t, int key, int priority){\n  if( (*t) == nil ) return Node(key, priority);\n  if( key == (*t)->key ) return *t;\n\n  if( key < (*t)->key ){\n    (*t)->left = insert(&(*t)->left, key, priority);\n    if( (*t)->priority < (*t)->left->priority ) (*t) = rightRotate((*t));\n  }\n  else{\n    (*t)->right = insert(&(*t)->right, key, priority);\n    if( (*t)->priority < (*t)->right->priority ) (*t) = leftRotate((*t));\n  }\n  return *t;\n}\n\n\nNodepointer delete(Nodepointer *t, int key){\n  if( (*t) == nil ) return nil;\n  if( key < (*t)->key ) (*t)->left = delete(&(*t)->left, key);\n  else if( key > (*t)->key ) (*t)->right = delete(&(*t)->right, key);\n  else {\n    return _delete(t, key);\n  }\n  return *t;\n}\n\nNodepointer _delete(Nodepointer *t, int key){\n  if( (*t)->left == nil && (*t)->right == nil ) return nil;\n  else if( (*t)->left == nil ) (*t) = leftRotate(*t);\n  else if( (*t)->right == nil ) (*t) = rightRotate(*t);\n  else {\n    if( (*t)->left->priority > (*t)->right->priority ) (*t) = rightRotate(*t);\n    else (*t) = leftRotate(*t);\n  }\n  return delete(t, key);\n}\n\n\nNodepointer find(Nodepointer u, int k){\n  while( u != nil && k != u->key ){\n    if( k < u->key ) u = u->left;\n    else u = u->right;\n  }\n  return u;\n}\n\nvoid inorder(Nodepointer u){\n  if( u->left != nil ) inorder(u->left);\n  printf(\" %d\", u->key);\n  if( u->right != nil ) inorder(u->right);\n  return;\n}\n\nvoid preorder(Nodepointer u){\n  printf(\" %d\", u->key);\n  if( u->left != nil ) preorder(u->left);\n  if( u->right != nil ) preorder(u->right);\n  return;\n}\n\nvoid print(Nodepointer u){\n  inorder(u);\n  printf(\"\\n\");\n  preorder(u);\n  printf(\"\\n\");\n  return;\n}\n\nint main(){\n  int m, i, x, y;\n  char com[8];\n  Nodepointer t=nil;\n\n  scanf(\"%d\", &m);\n\n  for( i = 0 ; i < m ; i++ ){\n    scanf(\"%s\",com);\n    if( com[0] == 'f' ){\n      scanf(\"%d\", &x);\n      t = find(root, x);\n      if( t != nil ) printf(\"yes\\n\");\n      else printf(\"no\\n\");\n    }\n    else if( strcmp(\"insert\",com) == 0 ){\n      scanf(\"%d%d\", &x, &y);\n      insert(&root,x,y);\n    }\n    else if( strcmp(\"print\",com) == 0 ){\n      print(root);\n    }\n    else if( strcmp(\"delete\", com) == 0 ){\n      scanf(\"%d\", &x);\n      root = delete(&root, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nstruct node {\n  int key;\n  int priority;\n  struct node *right;\n  struct node *left;\n};\n\ntypedef struct node* Nodepointer;\nNodepointer nil=NULL, root=NULL;\n\nNodepointer delete(Nodepointer*, int);\nNodepointer _delete(Nodepointer*, int);\n\nNodepointer Node(int key, int priority){\n Nodepointer z;\n  z = (Nodepointer)malloc(sizeof(struct node));\n  z->key = key;\n  z->priority = priority;\n  z->left = nil;\n  z->right = nil;\n  return z;\n}\n\nNodepointer rightRotate(Nodepointer t){\n  Nodepointer s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\n\nNodepointer leftRotate(Nodepointer t){\n  Nodepointer s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\n\nNodepointer insert(Nodepointer *t, int key, int priority){\n  Nodepointer new;\n  if( (*t) == nil ) return new = Node(key, priority);\n  if( key == (*t)->key ) return *t;\n\n  if( key < (*t)->key ){\n    (*t)->left = insert(&(*t)->left, key, priority);\n    if( (*t)->priority < (*t)->left->priority ) (*t) = rightRotate((*t));\n  }\n  else{\n    (*t)->right = insert(&(*t)->right, key, priority);\n    if( (*t)->priority < (*t)->right->priority ) (*t) = leftRotate((*t));\n  }\n  return *t;\n}\n\n\nNodepointer delete(Nodepointer *t, int key){\n  if( (*t) == nil ) return nil;\n  if( key < (*t)->key ) (*t)->left = delete(&((*t)->left), key);\n  else if( key > (*t)->key ) (*t)->right = delete(&((*t)->right), key);\n  else {\n    return _delete(t, key);\n  }\n  return *t;\n}\n\nNodepointer _delete(Nodepointer *t, int key){\n  if( (*t)->left == nil && (*t)->right == nil ) return nil;\n  else if( (*t)->left == nil ) (*t) = leftRotate(*t);\n  else if( (*t)->right == nil ) (*t) = rightRotate(*t);\n  else {\n    if( (*t)->left->priority > (*t)->right->priority ) (*t) = rightRotate(*t);\n    else (*t) = leftRotate(*t);\n  }\n  return delete(t, key);\n}\n\n\nint find(Nodepointer u, int k){\n  while( u != nil && k != u->key ){\n    if( u->key == k ) return 1;\n    else if( k < u->key ) u = u->left;\n    else u = u->right;\n  }\n  return 0;\n}\n\nvoid inorder(Nodepointer u){\n  if( u->left != nil ) inorder(u->left);\n  printf(\" %d\", u->key);\n  if( u->right != nil ) inorder(u->right);\n  return;\n}\n\nvoid preorder(Nodepointer u){\n  printf(\" %d\", u->key);\n  if( u->left != nil ) preorder(u->left);\n  if( u->right != nil ) preorder(u->right);\n  return;\n}\n\nvoid print(Nodepointer u){\n  inorder(u);\n  printf(\"\\n\");\n  preorder(u);\n  printf(\"\\n\");\n  return;\n}\n\nint main(){\n  int m, i, x, y;\n  char com[8];\n  Nodepointer t=nil;\n\n  scanf(\"%d\", &m);\n\n  for( i = 0 ; i < m ; i++ ){\n    scanf(\"%s\",com);\n\n    switch(com[0]){\n    case 'f': scanf(\"%d\", &x);\n      if( find(root, x)) printf(\"yes\\n\");\n      else printf(\"no\\n\");\n      break;\n\n    case 'i':  scanf(\"%d%d\", &x, &y);\n      root = insert(&root,x,y);\n      break;\n\n    case 'p':  print(root);\n      break;\n\n    case 'd': scanf(\"%d\", &x);\n      root = delete(&root, x);\n      break;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct Node{\n    int key;\n    int priority;\n    struct Node *parent;\n    struct Node *lhs, *rhs;\n} Node;\n\ntypedef struct{\n    Node *root;\n} BinaryTree;\n\nvoid init_node(Node *node, int val, int pri){\n    node->key = val;\n    node->priority = pri;\n    node->parent = NULL;\n    node->lhs = NULL;\n    node->rhs = NULL;\n}\n\nvoid right_rotate(BinaryTree *T, Node *r){\n    Node *l = r->lhs;\n    if(l==NULL || r==NULL) return;\n    if(T->root == r) T->root = l;\n    if(r->parent != NULL){\n        if(r->key < r->parent->key) r->parent->lhs = l;\n        else r->parent->rhs = l;\n    }\n    r->lhs = l->rhs;\n    if(l->rhs != NULL) l->rhs->parent = r;\n    l->rhs = r;\n    l->parent = r->parent;\n    r->parent = l;\n}\n\nvoid left_rotate(BinaryTree *T, Node *l){\n    Node *r = l->rhs;\n    if(l==NULL || r==NULL) return;\n    if(T->root == l) T->root = r;\n    if(l->parent != NULL){\n        if(l->key < l->parent->key) l->parent->lhs = r;\n        else l->parent->rhs = r;\n    }\n    l->rhs = r->lhs;\n    if(r->lhs != NULL) r->lhs->parent = l;\n    r->lhs = l;\n    r->parent = l->parent;\n    l->parent = r;    \n}\n\nvoid init_bintree(BinaryTree *T){\n    T->root = NULL;\n}\n\nvoid insert(BinaryTree *T, Node *node){\n    Node *parent = NULL;\n    Node *x = T->root;\n    while(x != NULL){\n        parent = x;\n        if(node->key < x->key) x = x->lhs;\n        else x = x->rhs;\n    }\n    node->parent = parent;\n    if(parent == NULL) T->root = node;\n    else if(node->key < parent->key) parent->lhs = node;\n    else parent->rhs = node;\n    \n    while(node->parent != NULL && node->priority > node->parent->priority){\n        if(node->key < node->parent->key) right_rotate(T, node->parent);\n        else left_rotate(T, node->parent);\n    }\n}\n\nvoid print_preorder(Node *n){\n    if(n == NULL) return;\n    printf(\" %d\", n->key);\n    print_preorder(n->lhs);\n    print_preorder(n->rhs);\n}\n\nvoid print_inorder(Node *n){\n    if(n == NULL) return;\n    print_inorder(n->lhs);\n    printf(\" %d\", n->key);\n    print_inorder(n->rhs);\n}\n\nvoid print(BinaryTree *T){\n    print_inorder(T->root);\n    printf(\"\\n\");\n    print_preorder(T->root);\n    printf(\"\\n\");\n}\n\nvoid find(BinaryTree *T, int val){\n    Node *n = T->root;\n    while(n != NULL){\n        if(n->key == val){\n            printf(\"yes\\n\");\n            return;\n        }\n        if(val < n->key) n = n->lhs;\n        else n = n->rhs;\n    }\n    printf(\"no\\n\");\n    return;\n}\n\n\nNode *get_node(BinaryTree *T, int val){\n    Node *n = T->root;\n    while(n != NULL){\n        if(n->key == val) return n;\n        if(val < n->key) n = n->lhs;\n        else n = n->rhs;\n    }\n    return NULL;\n}\n\nvoid del_node(BinaryTree *T, Node *n){\n    if(n == NULL) return;\n    if(n->lhs == NULL && n->rhs == NULL){\n        if(n->parent == NULL) T->root = NULL;\n        else if(n->key < n->parent->key) n->parent->lhs = NULL;\n        else n->parent->rhs = NULL;\n        n = NULL;\n    }else if(n->lhs == NULL || n->rhs == NULL){\n        if(n->lhs == NULL) left_rotate(T, n);\n        else right_rotate(T, n);\n        del_node(T, n);\n    }else{\n        if(n->lhs->priority < n->rhs->priority) left_rotate(T, n);\n        else right_rotate(T, n);\n        del_node(T, n);\n    }\n}\n\nvoid del(BinaryTree *T, int val){\n    del_node(T, get_node(T, val));\n}\n\nBinaryTree T;\nNode n[500000];\n\n\n\nint main(){\n    int idx = 0;\n    int m, v, p;\n    char comm[10];\n\n    init_bintree(&T);\n    scanf(\"%d\", &m);\n    for(int i=0;i<m;i++){\n        scanf(\"%s\", comm);\n        if(comm[0]=='p') print(&T);\n        else if(comm[0]=='i'){\n            scanf(\"%d%d\", &v, &p);\n            init_node(n+idx, v, p);\n            insert(&T, n+idx);\n            idx++;\n        }else if(comm[0]=='f'){\n            scanf(\"%d\", &v);\n            find(&T, v);\n        }else if(comm[0]=='d'){\n            scanf(\"%d\", &v);\n            del(&T, v);\n        }\n    }\n    \n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef struct _node {\n  unsigned int key;\n  unsigned int priority;\n  struct _node* left;\n  struct _node* right;\n} Node;\n\ntypedef Node* NodePointer;\n\nNodePointer insert (NodePointer, unsigned int, unsigned int);\nbool find (NodePointer, unsigned int);\nNodePointer delete (NodePointer, unsigned int);\nvoid print (NodePointer);\n\nNodePointer makeNode (unsigned int, unsigned int);\nNodePointer leftRotate (NodePointer);\nNodePointer rightRotate (NodePointer);\nvoid traverse (NodePointer, char);\nNodePointer deleteNode (NodePointer, unsigned int);\n\nint main () {\n  Node* treap = NULL;\n  unsigned int key, priority;\n  \n  int n;\n  char command[10];\n  \n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%s\", command);\n    switch(command[0]) {\n    case 'i':\n      scanf(\"%d %d\", &key, &priority);\n      treap = insert(treap, key, priority);\n      break;\n    case 'f':\n      scanf(\"%d\", &key);\n      printf(\"%s\\n\", find(treap, key) ? \"yes\" : \"no\");\n      break;\n    case 'd':\n      scanf(\"%d\", &key);\n      treap = delete(treap, key);\n      break;\n    case 'p':\n      print(treap);\n      break;\n    }\n  }\n  \n  return 0;\n}\n\nNodePointer insert(NodePointer node, unsigned int key, unsigned int priority) {\n  if (node == NULL) {\n    return makeNode(key, priority);\n  }\n  \n  if (node->key == key) {\n    return node;\n  }\n\n  if (node->key > key) {\n    node->left = insert(node->left, key, priority);\n    if (node->priority < node->left->priority) {\n      node = rightRotate(node);\n    }\n  } else {\n    node->right = insert(node->right, key, priority);\n    if (node->priority < node->right->priority) {\n      node = leftRotate(node);\n    }\n  }\n\n  return node;\n}\n\nNodePointer makeNode(unsigned int key, unsigned int priority) {\n  NodePointer node;\n\n  node = (NodePointer)malloc(sizeof(Node));\n  node->key = key;\n  node->priority = priority;\n  node->left  = NULL;\n  node->right = NULL;\n\n  return node;\n}\n\nNodePointer leftRotate (NodePointer node) {\n  NodePointer child = node->right;\n  node->right = child->left;\n  child->left = node;\n  return child; // root of the subtree\n}\n\nNodePointer rightRotate (NodePointer node) {\n  NodePointer child = node->left;\n  node->left = child->right;\n  child->right = node;\n  return child; // root of the subtree\n}\n\nbool find(NodePointer node, unsigned int key) {\n  while (node != NULL) {\n    if (node->key == key) {\n      return true;\n    } else if (node->key > key) {\n      node = node->left;\n    } else {\n      node = node->right;\n    }\n  }\n  return false;\n}\n\nNodePointer delete(NodePointer node, unsigned int key) {\n  if (node == NULL) {\n    return NULL;\n  }\n\n  if (key < node->key) {\n    node->left  = delete(node->left , key);\n  } else if (key > node->key) {\n    node->right = delete(node->right, key);\n  } else {\n    return deleteNode(node, key);\n  }\n\n  return node;\n}\n\nNodePointer deleteNode (NodePointer node, unsigned int key) {\n  if (node->left == NULL && node->right == NULL) {\n    free(node);\n    return NULL;\n  } else if (node->left  == NULL) {\n    node = leftRotate(node);\n  } else if (node->right == NULL) {\n    node = rightRotate(node);\n  } else {\n    if (node->left->priority > node->right->priority) {\n      node = rightRotate(node);\n    } else {\n      node = leftRotate(node);\n    }\n  }\n\n  return delete(node, key);\n}\n\nvoid print(NodePointer root) {\n  traverse(root, 'i');\n  printf(\"\\n\");\n  traverse(root, 'p');\n  printf(\"\\n\");\n}\n\nvoid traverse(NodePointer node, char type) {\n  if (node == NULL) {\n    return;\n  }\n\n  if (type == 'p') printf(\" %d\", node->key);\n  traverse(node->left , type);\n  if (type == 'i') printf(\" %d\", node->key);\n  traverse(node->right, type);\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\ntypedef struct node{\n\tint key;\n\tint priority;\n\tstruct node *left, *right;\n}NODE;\n\n\nNODE *ROOT;\n\n\nNODE *Find(int key)\n{\n\tNODE *p = ROOT;\n\n\twhile(p != NULL){\n\t\tif(key == p->key)\n\t\t\treturn p;\n\n\t\tif(key < p->key)\n\t\t\tp = p->left;\n\t\telse\n\t\t\tp = p->right;\n\t}\n\n\treturn NULL;\n}\n\n\nNODE *RightRotate(NODE *t)\n{\n\tNODE *s = t->left;\n\tt->left = s->right;\n\ts->right = t;\n\n\treturn s;\t// ROOT of the subtree\n}\n\n\nNODE *LeftRotate(NODE *t)\n{\n\tNODE *s = t->right;\n\tt->right = s->left;\n\ts->left = t;\n\nreturn s;\t// ROOT of the subtree\n}\n\n\nNODE *Make_node(int key, int priority)\n{\n\tNODE *p;\n\n\tif( (p = (NODE *)malloc(sizeof(NODE))) == NULL)\n\t\treturn NULL;\n\tp->key = key;\n\tp->priority = priority;\n\tp->left = NULL;\n\tp->right = NULL;\n\n\treturn p;\n}\n\n\nNODE *Insert(NODE *t, int key, int priority)\t// 再帰的に探索\n{\n\t// 葉に到達したら新しい節点を生成して返す\n\tif(t == NULL)\n\t\treturn Make_node(key, priority);\n\n\t// 重複したkeyは無視\n\tif(key == t->key)\n\t\treturn t;\n\n\t// 左の子へ移動\n\tif(key < t->key){\n\t\tt->left = Insert(t->left, key, priority);\t// 左の子へのポインタを更新\n\t\tif(t->priority < t->left->priority)\t// 左の子の方が優先度が高い場合右回転\n\t\t\tt = RightRotate(t);\n\t}else{\n\t// 右の子へ移動\n\t\tt->right = Insert(t->right, key, priority);\t// 右の子へのポインタを更新\n\t\tif(t->priority < t->right->priority)\t// 右の子の方が優先度が高い場合左回転\n\t\t\tt = LeftRotate(t);\n\t}\n\n\treturn t;\n}\n\n\nNODE *_Delete(NODE*, int);\n\nNODE *Delete(NODE *t, int key)\n{\n\tif(t == NULL)\n\t\treturn NULL;\n\tif(key < t->key)                                // 削除対象を検索\n\t\tt->left = Delete(t->left, key);\n\telse if(t->key < key)\n\t\tt->right = Delete(t->right, key);\n\telse\n\t\treturn _Delete(t, key);\n\n\treturn t;\n}\n\nNODE *_Delete(NODE *t, int key) // 削除対象の節点の場合\n{\n\tif(t->left == NULL && t->right == NULL){\n\t// 葉の場合\n\t\tfree(t);\n\t\treturn NULL;\n\t}else if(t->left == NULL)\t// 右の子のみを持つ場合左回転\n\t\tt = LeftRotate(t);\n\telse if(t->right == NULL)\t// 左の子のみを持つ場合右回転\n\t\tt = RightRotate(t);\n\telse{\n\t// 左の子と右の子を両方持つ場合\n\t\tif(t->left->priority > t->right->priority)\t// 優先度が高い方を持ち上げる\n\t\t\tt = RightRotate(t);\n\t\telse\n\t\t\tt = LeftRotate(t);\n\t}\n\n\treturn Delete(t, key);\n}\n\n\nvoid Walk_tree(NODE *p, int kind)\n{\n\tif(p == NULL)\n\t\treturn;\n\n\tif(kind == 0)\n\t\tprintf(\" %d\", p->key);\n\n\tWalk_tree(p->left, kind);\n\n\tif(kind == 1)\n\t\tprintf(\" %d\", p->key);\n\n\tWalk_tree(p->right, kind);\n}\n\n\nint main()\n{\n\tint n;\n\tchar command[10];\n\tint key, priority;\n\tint i;\n\n\tROOT = NULL;\n\n\tscanf(\"%d\", &n);\n\n\tfor(i = 0; i < n; i++){\n\t\tscanf(\"%s\", command);\n\n\t\tif(!strcmp(command, \"find\")){\n\t\t\tscanf(\"%d\", &key);\n\t\t\tif(Find(key))\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\telse\n\t\t\t\tprintf(\"no\\n\");\n\t\t}else if(!strcmp(command, \"print\")){\n\t\t\tWalk_tree(ROOT, 1);\n\t\t\tprintf(\"\\n\");\n\t\t\tWalk_tree(ROOT, 0);\n\t\t\tprintf(\"\\n\");\n\t\t}else if(!strcmp(command, \"insert\")){\n\t\t\tscanf(\"%d %d\", &key, &priority);\n\t\t\tROOT = Insert(ROOT, key, priority);\n\t\t}else if(!strcmp(command, \"delete\")){\n\t\t\tscanf(\"%d\", &key);\n\t\t\tROOT = Delete(ROOT, key);\n\t\t}\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct node{\n  struct node *right;\n  struct node *left;\n  struct node *parent;\n  int key;\n};\ntypedef struct node * Node;\n#define NIL NULL\nNode root;\nNode treeMinimum(Node x){\n  while(x->left != NIL)   \n    x = x->left;\n  return x;\n}\n\nNode treeMaximum(Node x){\n  while(x->right != NIL)\n    x = x->right;\n  return x;\n}\n\nNode treeSearch(Node u, int k){\n  while(u != NIL && k != u->key)\n    {\n      if(k < u->key) u = u->left;\n      else u = u->right;\n    }\n  return u;\n}\n\nNode treeSuccessor(Node x){\n  Node y;\n  if(x->right != NIL) return treeMinimum(x->right);\n  y = x->parent;\n  while(y != NIL && x == y->right){\n    x = y;\n    y = y->parent;\n  }\n  return y;\n}\n\nvoid treeDelete(Node z){\n  Node y; // node to be deleted\n  Node x; // child of y\n  if(z->left == NIL || z->right == NIL) y = z;\n  else y = treeSuccessor(z);\n  \n  if(y->left != NIL)\n    {\n      x = y->left;\n    }else{\n    x = y->right;\n  }\n  \n  if(x != NIL) x->parent = y->parent;\n  \n  if(y->parent == NIL)\n    {\n      root = x;\n    }else{\n    if(y == y->parent->left)\n      {\n\ty->parent->left = x;\n      }else{\n      y->parent->right = x;\n    }\n  \n    if(y != z)\n      {\n\tz->key = y->key;\n      }\n    free(y);\n  }\n}\n\n  void insert(int k)\n  {\n    Node y = NIL;\n    Node x = root;\n    Node z;\n    z = malloc(sizeof(struct node));\n    z->key = k;\n    z->left = NIL;\n    z->right = NIL;\n    while(x != NIL){\n      y = x;\n      if(z->key < x->key){\n\tx = x->left;\n      }else{\n\tx = x->right;\n      }\n      z->parent = y;\n    }\n    if(y == NIL)\n      {\n\troot = z;\n      }\n    else if(z->key < y->key)\n      {\n\ty->left = z;\n      }\n    else\n      {\n\ty->right = z;\n      }\n  }\n\n  void inorder(Node u)\n  {\n    if(u == NIL)\n      {\n\treturn;\n      }\n    inorder(u->left);\n    printf(\" %d\", u->key);\n    inorder(u->right);\n  }\n  void preorder(Node u)\n  {\n    if(u == NIL)\n      {\n\treturn;\n      }\n    printf(\" %d\", u->key);\n    preorder(u->left);\n    preorder(u->right);\n  }\n\n\n  int main()\n  {\n    int n, i, x;\n    char com[20];\n    scanf(\"%d\", &n);\n\n    for ( i = 0; i < n; i++ )\n      {\n\tscanf(\"%s\", com);\n\tif ( com[0] == 'f' )\n\t  {\n\t    scanf(\"%d\", &x);\n\t    Node t = treeSearch(root, x);\n\t    if ( t != NIL ) printf(\"yes\\n\");\n\t    else printf(\"no\\n\");\n\t  }\n\telse if ( com[0] == 'i' )\n\t  {\n\t    scanf(\"%d\", &x);\n\t    insert(x);\n\t  }\n\telse if ( com[0] == 'p' )\n\t  {\n\t    inorder(root);\n\t    printf(\"\\n\");\n\t    preorder(root);\n\t    printf(\"\\n\");\n\t  }\n\telse if ( com[0] == 'd' )\n\t  {\n\t    scanf(\"%d\", &x);\n\t    treeDelete(treeSearch(root, x));\n\t  }\n      }\n    return 0;\n  }\n  \n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct node{\n  struct node *right;\n  struct node *left;\n  int key;\n  int priority;\n};\n\ntypedef struct node * Node;\n\n#define NIL NULL\n\nNode root;\n\nNode treeMinimum(Node x){\n  while (x->left!=NIL) x=x->left;\n  return x;\n}\n\nNode treeMaximum(Node x){\n  while (x->right!=NIL) x=x->right;\n  return x;\n}\n\nNode treeSearch(Node u, int k){\n  Node ret = NIL;\n  if (u->key==k) return u;\n  else if (u->key>k) {\n    if (u->left!=NIL)\n      return treeSearch(u->left, k);\n  } else if (u->right!=NIL)\n    return treeSearch(u->right, k);\n  return ret;\n}\n\nNode rightRotate(Node t)\n{\n  Node s = t->left;\n  if (t==root) root=s;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\n\nNode leftRotate(Node t)\n{\n  Node s = t->right;\n  if (t==root) root=s;\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\n\nNode _delete(Node, int);\n\nNode delete(Node t, int key)\n{\n  if (t==NIL)\n    return NIL;\n  if (key < t->key)\n    t->left = delete(t->left,key);\n  else if (key > t->key)\n    t->right = delete(t->right, key);\n  else\n    return _delete(t, key);\n  return t;\n}\n\nNode _delete(Node t, int key)\n{\n  if (t->left == NIL && t->right==NIL) // has no child\n    return NIL;\n  if (t->left == NIL)\n    t=leftRotate(t);\n  else if (t->right == NIL)\n    t=rightRotate(t);\n  else {\n    if (t->left->priority > t->right->priority)\n      t = rightRotate(t);\n    else\n      t = leftRotate(t);\n  }\n  return delete(t, key);\n}\n\nNode insert(Node t, int key, int priority)\n{\n  if (t==NIL) {\n    Node z = malloc(sizeof(struct node));\n    z->key = key;\n    z->priority = priority;\n    z->left = NIL;\n    z->right=NIL;\n    if (root==NIL) {\n      root = z;\n    }\n    return z;\n  }\n  if (key==t->key) return t;\n  if (key<t->key) {\n    t->left = insert(t->left, key, priority);\n    if (t->priority < t->left->priority)\n      t = rightRotate(t);\n  } else {\n    t->right = insert(t->right, key, priority);\n    if (t->priority < t->right->priority)\n      t = leftRotate(t);\n  }\n  return t;\n}\n\nvoid inorder(Node u){\n  if (u->left!=NIL) inorder(u->left);\n  printf(\" %d\", u->key);\n  if (u->right!=NIL) inorder(u->right);\n}\nvoid preorder(Node u){\n  printf(\" %d\", u->key);\n  if (u->left!=NIL) preorder(u->left);\n  if (u->right!=NIL) preorder(u->right);\n}\n\nvoid print()\n{\n  if (root==NIL) return;\n  preorder(root);\n  printf(\"\\n\");\n  inorder(root);\n  printf(\"\\n\");\n}\n\nint main(){\n  int n, i, x, y;\n  Node t;\n  char com[20];\n  root = NIL;\n  scanf(\"%d\", &n);\n  \n  for (i = 0; i < n; i++){\n    scanf(\"%s\", com);\n    switch (com[0]) {\n    case 'f':\n      scanf(\"%d\", &x);\n      t = treeSearch(root, x);\n      if (t != NIL) printf(\"yes\\n\");\n      else printf(\"no\\n\");\n      break;\n    case 'i':\n      scanf(\"%d %d\", &x, &y);\n      insert(root, x, y);\n\n      break;\n    case 'p':\n      inorder(root);\n      printf(\"\\n\");\n      preorder(root);\n      printf(\"\\n\");\n      break;\n    case 'd':\n      scanf(\"%d\", &x);\n      t = treeSearch(root, x);\n      if (t!=NIL)  delete(root, x);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define O 0\n#define I 1\n#define E 8\n\ntypedef struct node{\n  int key;\n  int priority;\n  struct node *left;\n  struct node *right;\n}node;\n\n\nnode * Delete(node **,int);\nnode * _delete(node **,int);\n\nint find(node *p,int x){\n  while(p!=NULL){\n    if(p->key==x){\n      return I;\n    }\n    else if(p->key > x){\n      p=p->left;\n    }\n    else{\n      p=p->right;\n    }\n  }\n  return O;\n}\n\nvoid inorder(node *p){\n\n  if(p->left!=NULL){\n    inorder(p->left);\n  }\n  printf(\" %d\",p->key);\n  if(p->right!=NULL){\n    inorder(p->right);\n  }\n  return;\n}\n\nvoid preorder(node *p){\n  printf(\" %d\",p->key);\n  if(p->left!=NULL){\n    preorder(p->left);\n  }\n  if(p->right!=NULL){\n    preorder(p->right);\n  }\n  return;\n}\n\nvoid print(node *p){\n  inorder(p);\n  printf(\"\\n\");\n  preorder(p);\n  printf(\"\\n\");\n  return;\n}\n\nnode * makenode(int x,int y){\n  node *new=malloc(sizeof(node));\n  new->key=x;\n  new->priority=y;\n  new->left=NULL;\n  new->right=NULL;\n  return new;\n}\n\nnode *rightRotate(node *p){\n  node *q=p->left;\n  p->left=q->right;\n  q->right=p;\n  return q;\n}\n\nnode *leftRotate(node *p){\n  node *q=p->right;\n  p->right=q->left;\n  q->left=p;\n  return q;\n}\n\nnode* insert(node **t,int key,int priority){\n  node *new;\n  if((*t)==NULL){\n  return new=makenode(key,priority);\n  }\n  if((*t)->key==key){\n  return *t;\n  }\n  if(key < (*t)->key){\n    (*t)->left=insert(&(*t)->left,key,priority);\n    if((*t)->priority < (*t)->left->priority){\n    (*t)=rightRotate((*t));\n    }\n  }\n  else{\n    (*t)->right=insert(&(*t)->right,key,priority);\n    if((*t)->priority < (*t)->right->priority){\n    (*t)=leftRotate((*t));\n    }\n  }\n  return *t;\n}\n\nnode * Delete(node **t,int key){\n  if((*t)==NULL)\n  return NULL;\n  if(key < (*t)->key){\n  (*t)->left=Delete(&((*t)->left),key);\n  }\n  else if(key > (*t)->key){\n  (*t)->right=Delete(&((*t)->right),key);\n  }\n  else{\n    return _delete(t,key);\n  }\n  return *t;\n}\n\nnode * _delete(node **t,int key){\n  if((*t)->left==NULL && (*t)->right==NULL){\n  return NULL;\n  }\n  else if((*t)->left==NULL){\n  (*t)=leftRotate(*t);\n  }\n  else if((*t)->right==NULL){\n  (*t)=rightRotate(*t);\n  }\n  else{\n    if((*t)->left->priority > (*t)->right->priority){\n    (*t)=rightRotate(*t);\n    }\n    else{\n    (*t)=leftRotate(*t);\n    }\n  }\n  return Delete(t,key);\n}\n\nint main(){\n  int i,n,x,y;\n  char com[E];\n  node *root=NULL;\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n    scanf(\"%s\",com);\n    switch(com[O]){\n      case 'i':scanf(\"%d %d\",&x,&y);\n      root=insert(&root,x,y);\n      break;\n      case 'd':scanf(\"%d\",&x);\n      root=Delete(&root,x);\n      break;\n      case 'f':scanf(\"%d\",&x);\n\tif(find(root,x)){\n\t  printf(\"yes\\n\");\n\t}\n\telse{\n\t  printf(\"no\\n\");\n\t}\n      break;\n      case 'p':print(root);\n      break;\n    }\n  }\n  return O;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nstruct tree {\n  int key;\n  int priority;\n  struct tree *left;\n  struct tree *right;\n};\nstruct tree *root = NULL;\nint Search(struct tree *p, int key);\nstruct tree *Lrotation(struct tree *p);\nstruct tree *Rrotation(struct tree *p);\nstruct tree *Insert(struct tree **p, int key, int priority);\nstruct tree *Delete(struct tree **p, int key);\nstruct tree *delete(struct tree **p, int key);\nvoid Dispm(struct tree *p);\nvoid Dispp(struct tree *p);\nint main(void)\n{\n  int i, count, key, priority;\n  char command[7];\n  scanf(\"%d\", &count);\n  for (i = 0; i < count; i++) {\n    scanf(\"%*c%s\", command);\n    switch (command[0]) {\n    case 'f':\n      scanf(\"%d\", &key);\n      if (Search(root, key)) {\n        printf(\"yes\\n\");\n      } else {\n        printf(\"no\\n\");\n      }\n      break;\n    case 'i':\n      scanf(\"%d %d\", &key, &priority);\n      root = Insert(&root, key, priority);\n      break;\n    case 'd':\n      scanf(\"%d\", &key);\n      Delete(&root, key);\n      break;\n    case 'p':\n      Dispm(root);\n      putchar('\\n');\n      Dispp(root);\n      putchar('\\n');\n      break;\n    }\n  }\n  return 0;\n}\nint Search(struct tree *p, int key)\n{\n  if (p == NULL) {\n    return 0;\n  } else if (p->key == key) {\n    return 1;\n  } else if (p->key > key) {\n    return Search(p->left, key);\n  } else {\n    return Search(p->right, key);\n  }\n}\nstruct tree *Lrotation(struct tree *p)\n{\n  struct tree *q = p->right;\n  p->right = q->left;\n  q->left = p;\n  return q;\n}\nstruct tree *Rrotation(struct tree *p)\n{\n  struct tree *q = p->left;\n  p->left = q->right;\n  q->right = p;\n  return q;\n}\nstruct tree *Insert(struct tree **p, int key, int priority)\n{\n  if (*p == NULL) {\n    *p = (struct tree*)malloc(sizeof(struct tree));\n    (*p)->key = key;\n    (*p)->priority = priority;\n    (*p)->left = NULL;\n    (*p)->right = NULL;\n  } else if ((*p)->key > key) {\n    (*p)->left = Insert(&(*p)->left, key, priority);\n    if ((*p)->priority <  (*p)->left->priority) *p = Rrotation(*p);\n  } else if ((*p)->key < key) {\n    (*p)->right = Insert(&(*p)->right, key, priority);\n    if ((*p)->priority <  (*p)->right->priority) *p = Lrotation(*p);\n  }\n  return *p;\n}\nstruct tree *Delete(struct tree **p, int key)\n{\n  if ((*p) == NULL) return NULL;\n  if ((*p)->key > key) (*p)->left = Delete(&(*p)->left, key);\n  else if ((*p)->key < key) (*p)->right = Delete(&(*p)->right, key);\n  else delete(p, key);\n  return *p;\n}\nstruct tree *delete(struct tree **p, int key)\n{\n  if ((*p)->left == NULL && (*p)->right == NULL) return *p = NULL;\n  else if ((*p)->left == NULL) *p = Lrotation(*p);\n  else if ((*p)->right == NULL) *p = Rrotation(*p);\n  else {\n    if ((*p)->left->priority > (*p)->right->priority) *p = Rrotation(*p);\n    else *p = Lrotation(*p);\n  }\n  return Delete(p, key);\n}\nvoid Dispm(struct tree *p)\n{\n  if (p != NULL) {\n    Dispm(p->left);\n    printf(\" %d\", p->key);\n    Dispm(p->right);\n  }\n}\nvoid Dispp(struct tree *p)\n{\n  if (p != NULL) {\n    printf(\" %d\", p->key);\n    Dispp(p->left);\n    Dispp(p->right);\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <stdlib.h>\n#define N 200001\n#define NI NULL\n\ntypedef struct node{\n\tint key;\n\tint pri;\n\tstruct node *right , *left;\n}Node;\n\nNode * Delete(Node **,int);\nNode * del(Node **,int);\n\nint find(Node *p,int x)\n{\n\twhile(p!=NI)\n\t{\n\t\tif(p->key==x)return 1;\n\t\telse if(p->key > x)p = p->left;\n\t\telse p = p->right;\n\t}\n\treturn 0;\n}\n\nvoid inorder(Node *a)\n{\n\tif(a->left!=NI) inorder(a->left);\n\tprintf(\" %d\",a->key);\n\tif(a->right!=NI) inorder(a->right);\n\treturn;\n}\n\nvoid preorder(Node *p)\n{\n\tprintf(\" %d\",p->key);\n\tif(p->left!=NI) preorder(p->left);\n\tif(p->right!=NI) preorder(p->right);\n\treturn;\n}\n\nvoid print(Node *p)\n{\n\tinorder(p);\n\tprintf(\"\\n\");\n\tpreorder(p);\n\tprintf(\"\\n\");\n\treturn;\n}\n\nNode * makenode(int x , int y)\n{\n\tNode *new = malloc(sizeof(Node));\n\tnew->key = x;\n\tnew->pri = y;\n\tnew->left = NI;\n\tnew->right = NI;\n\treturn new;\n}\n\nNode *rightRotate(Node *p)\n{\n\tNode *q = p->left;\n\tp->left = q->right;\n\tq->right = p;\n\treturn q;\n}\n\nNode *leftRotate(Node *p)\n{\n\tNode *q = p->right;\n\tp->right = q->left;\n\tq->left = p;\n\treturn q;\n}\n\nNode* insert(Node **t , int key, int pri)\n{\n\tNode *new;\n\tif((*t)==NI)\n\treturn new = makenode(key,pri);\n\tif((*t)->key == key)\n\treturn *t;\n\n\tif(key < (*t)->key)\n\t{\n\t\t(*t)->left = insert(&(*t)->left,key,pri);\n\t\tif((*t)->pri < (*t)->left->pri)\n\t\t(*t) = rightRotate(*t);\n\t}\n\telse{\n\t\t(*t)->right = insert(&(*t)->right,key,pri);\n\t\tif((*t)->pri < (*t)->right->pri)\n\t\t(*t) = leftRotate((*t));\n\t}\n\treturn *t;\n}\n\nNode * Delete(Node **t , int key)\n{\n\tif((*t)==NI){return NI;}\n\tif(key < (*t)->key){(*t)->left = Delete(&((*t)->left),key);}\n\telse if(key > (*t)->key){(*t)->right = Delete(&((*t)->right),key);}\n\telse{ return del(t,key);}\n\treturn *t;\n}\n\nNode * del(Node **t , int key)\n{\n\tif((*t)->left == NI && (*t)->right == NI){return NI;}\n\telse if((*t)->left == NI){(*t) = leftRotate(*t);}\n\telse if((*t)->right ==NI){(*t) = rightRotate(*t);}\n\telse{\n\t\tif((*t)->left->pri > (*t)->right->pri){(*t) = rightRotate(*t);}\n\t\telse{(*t) = leftRotate(*t);}\n\t}\n\treturn Delete(t,key);\n}\n\nint main(void)\n{\n\tint n,x,y;\n\tchar c[8];\n\tNode *root = NI;\n\tscanf(\"%d\",&n);\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%s\",c);\n\t\tswitch(c[0])\n\t\t{\n\t\t\tcase 'i':scanf(\"%d %d\",&x,&y);\n\t\t\troot = insert(&root,x,y);\n\t\t\tbreak;\n\t\t\tcase 'd':scanf(\"%d\",&x);\n\t\t\troot = Delete(&root,x);\n\t\t\tbreak;\n\t\t\tcase 'f':scanf(\"%d\",&x);\n\t\t\tif(find(root,x))printf(\"yes\\n\");\n\t\t\telse printf(\"no\\n\");\n\t\t\tbreak;\n\t\t\tcase 'p':print(root);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 41\n\ntypedef struct node{\n  int l, r;\n}node;\n\nnode c[N];\nint a[N];\nint b[N];\nint cnt=0;\n\nvoid postorder(int root,int n){\n\n        if(c[root].l != -1) postorder(c[root].l, n);\n\n        if(c[root].r != -1) postorder(c[root].r, n);\n\n        if(cnt < n-1) printf(\"%d \", root);\n        else printf(\"%d\\n\", root);\n\n        cnt++;\n\n        return;\n}\n\nint reconst(int start,int last,int n){\n  int i, j;\n\n  if(start==last) return b[start];\n  else if(start > last) return -1;\n\n  else{\n    for(i = 1 ; i <= n ; i++){\n      for(j = start ; j <= last ; j++){\n        if(a[i] == b[j]){\n          c[a[i]].l = reconst(start, j - 1, n);\n          c[a[i]].r = reconst(j + 1, last, n);\n          return a[i];\n        }\n      }\n    }\n  }\n}\n\n\nint main(){\n  int n, i, root;\n\n  scanf(\"%d\", &n);\n\n  for(i = 1 ; i <= n ; i++){\n    scanf(\"%d\",&a[i]);\n    scanf(\"%d\",&b[i]);\n    c[i].l = -1;\n    c[i].r = -1;\n  }\n\n  root = reconst(1,n,n);\n  postorder(root,n);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\ntypedef int Key;\ntypedef int Value;\ntypedef int Result;\nstruct Treap {\n  Key key;\n  Value value;\n  int p;\n  bool cached;\n  Result cache;\n  Treap *ch[2]; // LEFT = ch[0], RIGHT = ch[1]\n  Treap(const Key &key, const Value &value) : key(key), value(value),\n    p(rand()), cached(0) { ch[0] = ch[1] = 0; }\n};\nTreap *rotate(Treap *t, int b) {\n  Treap *s = t->ch[1-b]; t->ch[1-b] = s->ch[b]; s->ch[b] = t;\n  s->cached = t->cached = false;\n  return s;\n}\nTreap *find(Treap *t, const Key &key) {\n  return !t || key == t->key ? t : find(t->ch[key<t->key], key);\n}\nTreap *insert(Treap *t, const Key &key, const Value &value) {\n  if (!t) return new Treap(key, value);\n  else if (key == t->key) return t;\n  int b = !(key < t->key);\n  t->ch[b] = insert(t->ch[b], key, value);\n  if (t->p > t->ch[b]->p) t = rotate(t, 1-b);\n  t->cached = false;\n  return t;\n}\nTreap *erase(Treap *t, const Key &key) {\n  if (!t) return NULL;\n  if (key == t->key) {\n    if (!t->ch[0] && !t->ch[1]) return NULL;\n    else if (!t->ch[0]) t = rotate(t, 0);\n    else if (!t->ch[1]) t = rotate(t, 1);\n    else t = rotate(t, t->ch[0]->p<t->ch[1]->p);\n    t = erase(t, key);\n  } else {\n    int b = !(key < t->key);\n    t->ch[b] = erase(t->ch[b], key);\n  }\n  t->cached = false;\n  return t;\n}\nResult eval(Treap *t) {\n  if (!t) return 0;\n  if (!t->cached)\n    t->cache = eval(t->ch[0]) + eval(t->ch[1]) + 1; // CHANGE IT FLEXIBLE\n  t->cached = true;\n  return t->cache;\n}\nTreap *nth(Treap *t, int n) { // NTH ELEMENT\n  int l = eval(t->ch[0]);\n  if (n < l) return nth(t->ch[0], n);\n  if (n > l) return nth(t->ch[1], n-l-1);\n  return t;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct Node{\n    int key;\n    int priority;\n    struct Node *parent;\n    struct Node *lhs, *rhs;\n} Node;\n\ntypedef struct{\n    Node *root;\n} BinaryTree;\n\nvoid init_node(Node *node, int val, int pri){\n    node->key = val;\n    node->priority = pri;\n    node->parent = NULL;\n    node->lhs = NULL;\n    node->rhs = NULL;\n}\n\nvoid right_rotate(BinaryTree *T, Node *r){\n    Node *l = r->lhs;\n    if(l==NULL || r==NULL) return;\n    if(T->root == r) T->root = l;\n    if(r->parent != NULL){\n        if(r->key < r->parent->key) r->parent->lhs = l;\n        else r->parent->rhs = l;\n    }\n    r->lhs = l->rhs;\n    if(l->rhs != NULL) l->rhs->parent = r;\n    l->rhs = r;\n    l->parent = r->parent;\n    r->parent = l;\n}\n\nvoid left_rotate(BinaryTree *T, Node *l){\n    Node *r = l->rhs;\n    if(l==NULL || r==NULL) return;\n    if(T->root == l) T->root = r;\n    if(l->parent != NULL){\n        if(l->key < l->parent->key) l->parent->lhs = r;\n        else l->parent->rhs = r;\n    }\n    l->rhs = r->lhs;\n    if(r->lhs != NULL) r->lhs->parent = l;\n    r->lhs = l;\n    r->parent = l->parent;\n    l->parent = r;    \n}\n\nvoid init_bintree(BinaryTree *T){\n    T->root = NULL;\n}\n\nvoid insert(BinaryTree *T, Node *node){\n    Node *parent = NULL;\n    Node *x = T->root;\n    while(x != NULL){\n        parent = x;\n        if(node->key < x->key) x = x->lhs;\n        else x = x->rhs;\n    }\n    node->parent = parent;\n    if(parent == NULL) T->root = node;\n    else if(node->key < parent->key) parent->lhs = node;\n    else parent->rhs = node;\n    \n    while(node->parent != NULL && node->priority > node->parent->priority){\n        if(node->key < node->parent->key) right_rotate(T, node->parent);\n        else left_rotate(T, node->parent);\n    }\n}\n\nvoid print_preorder(Node *n){\n    if(n == NULL) return;\n    printf(\" %d\", n->key);\n    print_preorder(n->lhs);\n    print_preorder(n->rhs);\n}\n\nvoid print_inorder(Node *n){\n    if(n == NULL) return;\n    print_inorder(n->lhs);\n    printf(\" %d\", n->key);\n    print_inorder(n->rhs);\n}\n\nvoid print(BinaryTree *T){\n    print_inorder(T->root);\n    printf(\"\\n\");\n    print_preorder(T->root);\n    printf(\"\\n\");\n}\n\nvoid find(BinaryTree *T, int val){\n    Node *n = T->root;\n    while(n != NULL){\n        if(n->key == val){\n            printf(\"yes\\n\");\n            return;\n        }\n        if(val < n->key) n = n->lhs;\n        else n = n->rhs;\n    }\n    printf(\"no\\n\");\n    return;\n}\n\nNode *get_node(BinaryTree *T, int val){\n    Node *n = T->root;\n    while(n != NULL){\n        if(n->key == val) return n;\n        if(val < n->key) n = n->lhs;\n        else n = n->rhs;\n    }\n    return NULL;\n}\n\nvoid del_node(BinaryTree *T, Node *n){\n    if(n == NULL) return;\n    if(n->lhs == NULL && n->rhs == NULL){\n        if(n->parent == NULL) T->root = NULL;\n        else if(n->key < n->parent->key) n->parent->lhs = NULL;\n        else n->parent->rhs = NULL;\n        n = NULL;\n    }else if(n->lhs == NULL || n->rhs == NULL){\n        if(n->lhs == NULL) left_rotate(T, n);\n        else right_rotate(T, n);\n        del_node(T, n);\n    }else{\n        if(n->lhs->priority < n->rhs->priority) left_rotate(T, n);\n        else right_rotate(T, n);\n        del_node(T, n);\n    }\n}\n\nvoid del(BinaryTree *T, int val){\n    del_node(T, get_node(T, val));\n}\n\nBinaryTree T;\nNode n[500000];\n\nint main(){\n    int idx = 0;\n    int m, v, p;\n    char comm[10];\n\n    init_bintree(&T);\n    scanf(\"%d\", &m);\n    for(int i=0;i<m;i++){\n        scanf(\"%s\", comm);\n        if(comm[0]=='p') print(&T);\n        else if(comm[0]=='i'){\n            scanf(\"%d%d\", &v, &p);\n            init_node(n+idx, v, p);\n            insert(&T, n+idx);\n            idx++;\n        }else if(comm[0]=='f'){\n            scanf(\"%d\", &v);\n            find(&T, v);\n        }else if(comm[0]=='d'){\n            scanf(\"%d\", &v);\n            del(&T, v);\n        }\n    }\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 41\n\ntypedef struct node{\n  int l, r;\n}node;\n\nnode c[N];\nint a[N];\nint b[N];\nint cnt=0;\n\nvoid postorder(int root,int n){\n\n        if(c[root].l != -1) postorder(c[root].l, n);\n\n        if(c[root].r != -1) postorder(c[root].r, n);\n\n        if(cnt < n-1) printf(\"%d \", root);\n        else printf(\"%d\\n\", root);\n\n        cnt++;\n\n        return;\n}\n\nint reconst(int start,int last,int n){\n  int i, j;\n\n  if(start==last) return b[start];\n  else if(start > last) return -1;\n\n  else{\n    for(i = 1 ; i <= n ; i++){\n      for(j = start ; j <= last ; j++){\n        if(a[i] == b[j]){\n          c[a[i]].l = reconst(start, j - 1, n);\n          c[a[i]].r = reconst(j + 1, last, n);\n          return a[i];\n        }\n      }\n    }\n  }\n}\n\n\nint main(){\n  int n, i, root;\n\n  scanf(\"%d\", &n);\n\n  for(i = 1 ; i <= n ; i++) scanf(\"%d\",&a[i]);\n\n  for(i = 1 ; i <= n ; i++) scanf(\"%d\",&b[i]);\n\n  for(i = 1 ; i <= n ; i++){\n    c[i].l = -1;\n    c[i].r = -1;\n  }\n\n  root = reconst(1,n,n);\n  postorder(root,n);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \nstruct node{\n\tint key;\n\tint priority;\n\tstruct node *right;\n\tstruct node *left;\n};\n\ntypedef struct node * Node;\n#define NIL NULL\n\nNode delete(Node, int); \nNode root;\n\nNode treeMinimum(Node x){\n\twhile ( x->left != NIL ){ x = x->left; }\n\treturn x;\n}\n \nNode treeMaximum(Node x){\n\twhile ( x->right != NIL ){ x = x->right; }\n\treturn x;\n}\n \nNode Search(Node u, int k){\n\tNode ret = NIL;\n\tif ( u->key == k ){ return u; }\n\telse if ( u->key > k ){\n\t\tif ( u->left != NIL ){ return Search(u->left, k); }\n\t}\n\telse if (u->right!=NIL){ return Search(u->right, k); }\n\treturn ret;\n}\n\nNode rightRotate(Node t){\n\tNode s = t->left;\n\tif ( t == root ){ root = s; }\n\tt->left = s->right;\n\ts->right = t;\n\treturn s;\n}\n \nNode leftRotate(Node t){\n\tNode s = t->right;\n\tif ( t == root ){ root=s; }\n\tt->right = s->left;\n\ts->left = t;\n\treturn s;\n}\n \nNode _delete(Node t, int key){\n\tif (t->left == NIL && t->right==NIL){ return NIL; }\n\t\n\tif (t->left == NIL){ t=leftRotate(t); }\n\telse if (t->right == NIL){ t=rightRotate(t); }\n\telse{\n\t\tif (t->left->priority > t->right->priority){\n\t\t\tt = rightRotate(t);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tt = leftRotate(t);\n\t\t}\n\t}\n\treturn delete(t, key);\n}\n\nNode delete(Node t, int key){\n\tif (key < t->key){ \n\t\tt->left = delete(t->left,key); }\n\telse if (key > t->key){\n\t\tt->right = delete(t->right, key);\n\t}\n\telse{\n\t\treturn _delete(t, key);\n\t}\n\treturn t;\n}\n\nNode insert(Node t, int key, int priority){\n\tif (t == NIL)\n\t{\n\t\tNode z = malloc(sizeof(struct node));\n\t\tz->key = key;\n\t\tz->priority = priority;\n\t\tz->left = NIL;\n\t\tz->right=NIL;\n\t\tif (root==NIL) root = z;\n\t\treturn z;\n\t}\n\n\tif (key == t->key){ return t; }\n\t\n\tif (key < t->key)\n\t{\n\t\tt->left = insert(t->left, key, priority);\n\t\tif (t->priority < t->left->priority){ t = rightRotate(t); }\n\t}\n\telse \n\t{\n\t\tt->right = insert(t->right, key, priority);\n\t\tif (t->priority < t->right->priority){ t = leftRotate(t); }\n\t}\n\n\treturn t;\n}\n \nvoid inorder(Node u){\n\tif (u->left != NIL){ inorder(u->left); }\n\tprintf(\" %d\", u->key);\n\tif (u->right != NIL){ inorder(u->right); }\n}\n \nvoid preorder(Node u){\n\tprintf(\" %d\", u->key);\n\tif (u->left != NIL){ preorder(u->left); }\n\tif (u->right != NIL){ preorder(u->right); }\n}\n \nvoid print(){\n\tif (root == NIL){ return; }\n\tpreorder(root);\n\tprintf(\"\\n\");\n\tinorder(root);\n\tprintf(\"\\n\");\n}\n \nint main(){\n\tint n, i, x, y;\n\tNode t;\n\tchar tmp[10];\n\troot = NIL;\n\tscanf(\"%d\", &n);\n\n\tfor (i=0; i<n; i++)\n\t{\n\t\tscanf(\"%s\", tmp);\n\t\tif(tmp[0] == 'f')\n\t\t{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tt = Search(root, x);\n\t\t\tif (t != NIL){ printf(\"yes\\n\"); }\n\t\t\telse{ printf(\"no\\n\"); }\n\t\t}\n\t\telse if(tmp[0] == 'i')\n\t\t{\n\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\tinsert(root, x, y);\n\t\t}\n\t\telse if(tmp[0] == 'p')\n\t\t{\n\t\t\tinorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tpreorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse if(tmp[0] == 'd')\n\t\t{\n\t\t\tscanf(\"%d\", &x);\n\t\t\tt = Search(root, x);\n\t\t\tif (t != NIL){ delete(root, x); }\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define NIL 0\n#define MAX 200000\nstruct tree {\n  int key;\n  int priority;\n  int left;\n  int right;\n};\nint count = 1, root = NIL;\nvoid Search(struct tree *p, int key);\nint Lrotation(struct tree *table, int p);\nint Rrotation(struct tree *table, int p);\nvoid Insert(struct tree *p, int key, int priority);\nvoid Delete(struct tree *p, int key);\nvoid Dispm(struct tree *table, int p);\nvoid Dispp(struct tree *table, int p);\nint main(void)\n{\n  int i, n, key, priority;\n  char command[7];\n  struct tree table[MAX+1];\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    scanf(\"%*c%s\", command);\n    switch (command[0]) {\n    case 'f':\n      scanf(\"%d\", &key);\n      Search(table, key);\n      break;\n    case 'i':\n      scanf(\"%d %d\", &key, &priority);\n      Insert(table, key, priority);\n      break;\n    case 'd':\n      scanf(\"%d\", &key);\n      Delete(table, key);\n      break;\n    case 'p':\n      Dispp(table, root);\n      putchar('\\n');\n      Dispm(table, root);\n      putchar('\\n');\n      break;\n    }\n  }\n  return 0;\n}\nvoid Search(struct tree *p, int key)\n{\n  int u = root;\n  while (u != NIL) {\n    if (p[u].key == key) {\n      printf(\"yes\\n\");\n      return;\n    } else if (p[u].key > key) {\n      u = p[u].left;\n    } else {\n      u = p[u].right;\n    }\n  }\n  printf(\"no\\n\");\n}\nint Lrotation(struct tree *table, int p)\n{\n  int q = table[p].right;\n  table[p].right = table[q].left;\n  table[q].left = p;\n  return q;\n}\nint Rrotation(struct tree *table, int p)\n{\n  int q = table[p].left;\n  table[p].left = table[q].right;\n  table[q].right = p;\n  return q;\n}\nvoid Insert(struct tree *p, int key, int priority)\n{\n  int parent = NIL, child, u = root, sp = 0, stack[MAX];\n  while (u != NIL){\n    parent = stack[sp++] = u;\n    if (p[u].key == key) return;\n    else if (p[u].key > key) u = p[u].left;\n    else u = p[u].right;\n  }\n  p[count].key = key;\n  p[count].priority = priority;\n  p[count].left = p[count].right = NIL;\n  child = u = count;\n  if (parent == NIL) root = count++;\n  else {\n    if (p[parent].key > key) p[parent].left = count++;\n    else p[parent].right = count++;\n    while (sp > 1) {\n      parent = stack[--sp];\n      if (p[parent].left == child) {\n        p[parent].left = u;\n        if (p[u].priority > p[parent].priority) u = Rrotation(p, parent);\n        else return;\n      } else {\n        p[parent].right = u;\n        if (p[u].priority > p[parent].priority) u = Lrotation(p, parent);\n        else return;\n      }\n      child = parent;\n    }\n    parent = stack[--sp];\n    if (p[parent].left == child) {\n      p[parent].left = u;\n      if (p[u].priority > p[parent].priority) root = u = Rrotation(p, parent);\n      else return;\n    } else {\n      p[parent].right = u;\n      if (p[u].priority > p[parent].priority) root = u = Lrotation(p, parent);\n      else return;\n    }\n  }\n}\nvoid Delete(struct tree *p, int key)\n{\n  int parent = NIL, u = root;\n  while (u != NIL && p[u].key != key) {\n    parent = u;\n    if (p[u].key > key) {\n      u = p[u].left;\n    } else {\n      u = p[u].right;\n    }\n  }\n  if (u == NIL) return;\n  if (parent == NIL && p[u].left != NIL && p[u].right != NIL) {\n    if (p[p[u].left].priority > p[p[u].right].priority) {\n      parent = root = Rrotation(p, u);\n    } else {\n      parent = root = Lrotation(p, u);\n    }\n  }\n  while (1){\n    if (p[u].left == NIL) {\n      if (p[parent].left == u) {\n        p[parent].left = p[u].right;\n        if (parent == NIL) root = p[u].right;\n      }\n      else {\n        p[parent].right = p[u].right;\n        if (parent == NIL) root = p[u].right;\n      }\n      return;\n    } else if (p[u].right == NIL) {\n      if (p[parent].left == u) {\n        p[parent].left = p[u].left;\n        if (parent == NIL) root = p[u].left;\n      }\n      else {\n        p[parent].right = p[u].left;\n        if (parent == NIL) root = p[u].left;\n      }\n      return;\n    } else {\n      if (p[p[u].left].priority > p[p[u].right].priority) {\n        if (u == p[parent].left) parent = p[parent].left = Rrotation(p, u);\n        else parent = p[parent].right = Rrotation(p, u);\n      } else {\n        if (u == p[parent].left) parent = p[parent].left = Lrotation(p, u);\n        else parent = p[parent].right = Lrotation(p, u);\n      }\n    }\n  }\n}\nvoid Dispm(struct tree *table, int p)\n{\n  if (p == NIL) return;\n  printf(\" %d\", table[p].key);\n  Dispm(table, table[p].left);\n  Dispm(table, table[p].right);\n}\nvoid Dispp(struct tree *table, int p)\n{\n  if (p == NIL) return;\n  Dispp(table, table[p].left);\n  printf(\" %d\", table[p].key);\n  Dispp(table, table[p].right);\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define NIL NULL\ntypedef struct node{\n\tint key;\n\tint pri;\n\tstruct node *right , *left;\n}Node;\n\nNode * Delete(Node **,int);\nNode * del(Node **,int);\n\nint find(Node *p,int x)\n{\n\twhile(p!=NIL)\n\t{\n\t\tif(p->key==x)return 1;\n\t\telse if(p->key > x)p = p->left;\n\t\telse p = p->right;\n\t}\n\treturn 0;\n}\n\nvoid inorder(Node *a)\n{\n\tif(a->left!=NIL) inorder(a->left);\n\tprintf(\" %d\",a->key);\n\tif(a->right!=NIL) inorder(a->right);\n\treturn;\n}\n\nvoid preorder(Node *p)\n{\n\tprintf(\" %d\",p->key);\n\tif(p->left!=NIL) preorder(p->left);\n\tif(p->right!=NIL) preorder(p->right);\n\treturn;\n}\n\nvoid print(Node *p)\n{\n\tinorder(p);\n\tprintf(\"\\n\");\n\tpreorder(p);\n\tprintf(\"\\n\");\n\treturn;\n}\n\nNode * makenode(int x , int y)\n{\n\tNode *new = malloc(sizeof(Node));\n\tnew->key = x;\n\tnew->pri = y;\n\tnew->left = NIL;\n\tnew->right = NIL;\n\treturn new;\n}\n\nNode *rightRotate(Node *p)\n{\n\tNode *q = p->left;\n\tp->left = q->right;\n\tq->right = p;\n\treturn q;\n}\n\nNode *leftRotate(Node *p)\n{\n\tNode *q = p->right;\n\tp->right = q->left;\n\tq->left = p;\n\treturn q;\n}\n\nNode* insert(Node **t , int key, int pri)\n{\n\tNode *new;\n\tif((*t)==NIL)\n\treturn new = makenode(key,pri);\n\tif((*t)->key == key)\n\treturn *t;\n\t\n\tif(key < (*t)->key)\n\t{\n\t\t(*t)->left = insert(&(*t)->left,key,pri);\n\t\tif((*t)->pri < (*t)->left->pri)\n\t\t(*t) = rightRotate(*t);\n\t}\n\telse{\n\t\t(*t)->right = insert(&(*t)->right,key,pri);\n\t\tif((*t)->pri < (*t)->right->pri)\n\t\t(*t) = leftRotate((*t));\n\t}\n\treturn *t;\n}\n\nNode * Delete(Node **t , int key)\n{\n\tif((*t)==NIL)\n\treturn NIL;\n\t\n\tif(key < (*t)->key)\n\t(*t)->left = Delete(&((*t)->left),key);\n\t\n\telse if(key > (*t)->key)\n\t(*t)->right = Delete(&((*t)->right),key);\n\n\telse return del(t,key);\n\treturn *t;\n}\n\nNode * del(Node **t , int key)\n{\n\tif((*t)->left == NIL && (*t)->right == NIL)\n\t{\n\t\treturn NIL;\n\t}\n\telse if((*t)->left == NIL)\n\t{\n\t\t(*t) = leftRotate(*t);\n\t}\n\telse if((*t)->right ==NIL)\n\t{\n\t\t(*t) = rightRotate(*t);\n\t}\n\telse{\n\t\tif((*t)->left->pri > (*t)->right->pri)\n\t\t(*t) = rightRotate(*t);\n\t\telse\n\t\t(*t) = leftRotate(*t);\n\t}\n\treturn Delete(t,key);\n}\n\nint main(void)\n{\n\tint num ,  x, y;\n\tchar com[8];\n\tNode *root = NIL;\n\tscanf(\"%d\",&num);\n\t\n\tfor(int i = 0; i < num; i++)\n\t{\n\t\tscanf(\"%s\",com);\n\t\tswitch(com[0])\n\t\t{\n\t\t\tcase 'i':scanf(\"%d %d\",&x,&y);\n\t\t\troot = insert(&root,x,y);\n\t\t\tbreak;\n\t\t\tcase 'd':scanf(\"%d\",&x);\n\t\t\troot = Delete(&root,x);\n\t\t\tbreak;\n\t\t\tcase 'f':scanf(\"%d\",&x);\n\t\t\tif(find(root,x))printf(\"yes\\n\");\n\t\t\telse printf(\"no\\n\");\n\t\t\tbreak;\n\t\t\tcase 'p':print(root);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nstruct Node{\n\tint key,priority;\n\tstruct Node *right, *left;\n};\n\nstruct Node *root,*nil;\n\nstruct Node *treeMinimum(struct Node *x){\n\twhile(x->left!=nil){\n\t\tx=x->left;\n\t}\n\treturn x;\n}\n\nstruct Node *treeMaximum(struct Node *x){\n\twhile(x->right!=nil){\n\t\tx=x->right;\n\t}\n\treturn x;\n}\n\nstruct Node *find(struct Node *u,int k){\n\tstruct Node *ret=nil;\n\tif(u->key==k){\n\t\treturn u;\n\t}\n\telse if(u->key>k){\n\t\tif(u->left!=nil){\n\t\t\treturn  find(u->left,k);\n\t\t}\n\t}\n\telse if(u->right!=nil){\n\t\treturn  find(u->right,k);\n\t}\n\treturn ret;\n}\n\nstruct Node *rightRotate(struct Node *t)\n{\n struct Node *s=t->left;\n  if(t==root){\n  root=s;\n  }\n  t->left=s->right;\n  s->right=t;\n  return s;\n}\n\nstruct Node *leftRotate(struct Node *t)\n{\n  struct Node *s=t->right;\n  if (t==root){\n  root=s;\n  }\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\nstruct Node *treeDelete2(struct Node *t, int key);\n\nstruct Node *treeDelete(struct Node *t,int key){\nif (t==nil){\n    return nil;\n    }\n  if (key <t->key){\n    t->left=treeDelete(t->left,key);\n    }\n  else if (key > t->key){\n    t->right=treeDelete(t->right, key);\n    }\n  else{\n    return treeDelete2(t, key);\n    }\n  return t;\n}\n\nstruct Node *treeDelete2(struct Node *t, int key)\n{\n  if (t->left==nil && t->right==nil){\n    return nil;\n    }\n  if (t->left == nil){\n    t=leftRotate(t);\n    }\n  else if (t->right == nil){\n    t=rightRotate(t);\n    }\n  else {\n    if (t->left->priority > t->right->priority)\n      t = rightRotate(t);\n    else\n      t = leftRotate(t);\n  }\n  return treeDelete(t, key);\n}\nstruct Node *insert(struct Node *t,int key,int priority){\n\tif (t==nil) {\n    struct Node *z;\n    z=(struct Node*)malloc(sizeof(struct Node));\n    z->key=key;\n    z->priority=priority;\n    z->left = nil;\n    z->right=nil;\n    if (root==nil) {\n      root = z;\n    }\n    return z;\n  }\n  if (key==t->key){\n  return t;\n  }\n  if (key<t->key){\n    t->left=insert(t->left, key, priority);\n    if (t->priority < t->left->priority)\n      t=rightRotate(t);\n  } else {\n    t->right=insert(t->right,key,priority);\n    if (t->priority<t->right->priority)\n      t=leftRotate(t);\n  }\n  return t;\n\t\n}\n\nvoid inorder(struct Node *u){\n if (u->left!=nil){\n inorder(u->left);\n }\n  printf(\" %d\", u->key);\n  if (u->right!=nil){\n  inorder(u->right);\n  }\n}\n\nvoid preorder(struct Node *u){\n printf(\" %d\", u->key);\n  if(u->left!=nil){\n  preorder(u->left);\n  }\n  if(u->right!=nil){\n  preorder(u->right);\n  }\n}\n\nvoid print(){\n  if (root==nil){\n  return;\n  }\n  preorder(root);\n  printf(\"\\n\");\n  inorder(root);\n  printf(\"\\n\");\n}\n\nint main(void){\n\tint n,i,y;\n\tscanf(\"%d\",&n);\n\tint d;\n\tstruct Node *t;\n\troot=nil;\n\tchar string[10];\n\t\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%s %d\",string,&d);\n\t\tif(string[0]=='i'){\n\t\t\tscanf(\" %d\",&y);\n\t\t\tinsert(root,d,y);\n\t\t}\n\t\telse if(string[0]=='p'){\n\t\t\tinorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tpreorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse if(string[0]=='f'){\n\t\t\tt=find(root,d);\n\t\t\tif(t!=nil){\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t} \n\t\t\telse{\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t}\n\t\t}\n\t\telse if(string[0]=='d'){\n\t\t\tt=find(root,d);\n\t\t\tif(t!=nil){\n\t\t\t\ttreeDelete(root,d);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 41\n\ntypedef struct node{\n  int l, r;\n}node;\n\nnode c[N];\nint a[N];\nint b[N];\nint cnt=0;\n\nvoid postorder(int root,int n){\n\n        if(c[root].l != -1) postorder(c[root].l, n);\n\n        if(c[root].r != -1) postorder(c[root].r, n);\n\n        if(cnt < n-1) printf(\"%d \", root);\n        else printf(\"%d\\n\", root);\n\n        cnt++;\n\n        return;\n}\n\nint reconst(int start,int last,int n){\n  int i, j;\n\n  if(start==last) return b[start];\n  else if(start > last) return -1;\n\n  else{\n    for(i = 1 ; i <= n ; i++){\n      for(j = start ; j <= last ; j++){\n        if(a[i] == b[j]){\n          c[a[i]].l = reconst(start, j - 1, n);\n          c[a[i]].r = reconst(j + 1, last, n);\n          return a[i];\n        }\n      }\n    }\n  }\n}\n\n\nint main(){\n  int n, i, root;\n\n  scanf(\"%d\", &n);\n\n  for(i = 1 ; i <= n ; i++) scanf(\"%d\",&a[i]);\n\n  for(i = 1 ; i <= n ; i++){\n    scanf(\"%d\",&b[i]);\n    c[i].l = -1;\n    c[i].r = -1;\n  }\n\n  root = reconst(1,n,n);\n  postorder(root,n);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DEBUG 0\n#define true 1\n#define false 0\n\nstruct Node;\ntypedef struct Node Node;\n\nstruct Node{\n    int key;\n    int priority;\n    Node *root;\n    Node *left;\n    Node *right;\n};\n\n\nNode* rightRotate(Node* t);\nNode* leftRotate(Node* t);\nNode* crNode(int key,int priority);\nNode* insert(Node* t, int key, int priority);\nNode* delete(Node* t, int key);\nNode* _delete(Node* t, int key);\nvoid print(Node* t);\nvoid _print_in(Node* t);\nvoid _print_pre(Node* t);\nvoid seek(Node* t, int key);\nint _seek(Node* t, int key);\n\nint main (){\n    int m;\n    Node* root = NULL;\n    char cmd[32];\n    char* ins=\"insert\";\n    char* del=\"delete\";\n    char* pri=\"print\";\n    char* fin=\"find\";\n    int a;\n    int b;\n    int c = 10;\n    int d = 20;\n    memset(cmd,0,strlen(cmd));\n    scanf(\"%d\",&m);\n    while(m>0){\n        scanf(\"%s\",cmd);\n        if(!strcmp(cmd,ins)){\n            scanf(\"%d %d\",&a,&b);\n            if(DEBUG)printf(\"%s %d %d\\n\",cmd,a,b);\n            root =insert(root,a,b);\n        }else if(!strcmp(cmd,del)){\n            scanf(\"%d\",&a);\n            if(DEBUG)printf(\"%s %d\\n\",cmd,a);\n            root = delete(root,a);\n        }else if(!strcmp(cmd,pri)){\n            if(DEBUG)printf(\"%s\\n\",cmd);\n            print(root);\n        }else if(!strcmp(cmd,fin)){\n            scanf(\"%d\",&a);\n            if(DEBUG)printf(\"%s %d\\n\",cmd,a);\n            seek(root,a);\n        }\n        m--;\n    }\n\n    return 0;\n}\n\nNode* rightRotate(Node* t){\n    Node* s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n}\n\nNode* leftRotate(Node* t){\n    Node* s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;\n}\n\nNode* crNode(int key, int priority){\n    Node *s = malloc(sizeof(Node));\n    if(s){\n        s->key = key;\n        s->priority = priority;\n        s->root = NULL;\n        s->left = NULL;\n        s->right = NULL;\n    }\n    return s;\n}\n\nNode* insert(Node* t, int key, int priority){\n    if(t == NULL)\n        return crNode(key, priority);\n    if(key == t->key)\n        return t;\n    \n    if(key < t->key){\n        t->left = insert(t->left, key, priority);\n        if(t->priority < t->left->priority){\n            t = rightRotate(t);\n        }\n    }else{\n        t->right = insert(t->right, key, priority);\n        if(t->priority < t->right->priority){\n            t = leftRotate(t);\n        }\n    }\n\n    return t;\n}\n\nNode* delete(Node* t, int key){\n    if(t == NULL)\n        return NULL;\n    if(key< t->key){\n        t->left = delete(t->left, key);\n    }else{\n        if( key > t->key){\n            t->right= delete(t->right, key);\n        }else{\n            return _delete(t,key);\n        }\n    }\n    return t;\n}\n\nNode* _delete (Node* t, int key){\n    if(t->left == NULL && t->right == NULL)\n        return NULL;\n    else if (t-> left == NULL)\n        t = leftRotate(t);\n    else if (t->right == NULL)\n        t = rightRotate(t);\n    else{\n        if(t->left->priority > t->right->priority)\n            t = rightRotate(t);\n        else\n        {\n            t = leftRotate(t);\n        }\n    }\n    return delete(t,key);\n}\n\nvoid print(Node* t){\n    _print_in(t);\n    printf(\"\\n\");\n    _print_pre(t);\n    printf(\"\\n\");\n}\n\nvoid _print_in(Node* t){\n    if(t->left == NULL && t->right == NULL){\n        printf(\" %d\",t->key);\n        return;\n    }\n    \n    if(t->left != NULL){\n        _print_in(t->left);\n    }\n    printf(\" %d\",t->key);\n    if(t->right != NULL){\n        _print_in(t->right);\n    }\n\n    return;\n}\n\nvoid _print_pre(Node* t){\n    if(t->left == NULL && t->right == NULL){\n        printf(\" %d\",t->key);\n        return;\n    }\n    \n    printf(\" %d\",t->key);\n    if(t->left != NULL){\n        _print_pre(t->left);\n    }\n    if(t->right != NULL){\n        _print_pre(t->right);\n    }\n    return;\n}\n\nvoid seek(Node* t, int key){\n    if(t == NULL){\n        printf(\"no\\n\");\n        return;\n    }else{\n        if(_seek(t,key)){\n            printf(\"yes\\n\");\n            return;\n        }else{\n            printf(\"no\\n\");\n            return;\n        }\n    }\n}\n\nint _seek(Node* t, int key){\n    if(t == NULL){\n        return false;\n    }\n    if(t->key == key){\n        return true;\n    }\n    if(key < t->key){\n        return _seek(t->left,key);\n    }else{\n        return _seek(t->right,key);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BUF_LENGTH 100\n#define OPE_LENGTH 10\n\ntypedef struct _node {\n\tint key;\n\tint priority;\n\tstruct _node * left;\n\tstruct _node * right;\n\tstruct _node * parent;\n} node;\n\nnode * left_rotate(node * t) {\n\tnode * new_t = t->right;\n\tt->right = new_t->left;\n\tnew_t->left = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * right_rotate(node * t) {\n\tnode * new_t = t->left;\n\tt->left = new_t->right;\n\tnew_t->right = t;\n\tnew_t->parent = t->parent;\n\tt->parent = new_t;\n\n\tif (new_t->parent == NULL) {\n\t\treturn new_t;\n\t}\n\n\tnode * parent = new_t->parent;\n\tif (parent->left == t) {\n\t\tparent->left = new_t;\n\t}\n\telse {\n\t\tparent->right = new_t;\n\t}\n\treturn new_t;\n}\n\nnode * create_node(int key, int priority) {\n\tnode * p;\n\tp = (node *)malloc(sizeof(node));\n\tp->key = key;\n\tp->priority = priority;\n\tp->left = NULL;\n\tp->right = NULL;\n\tp->parent = NULL;\n\treturn p;\n}\n\nnode * insert(node * t, int key, int priority) {\n\tif (t == NULL) {\n\t\tnode * p = create_node(key, priority);\n\t\treturn p;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->left = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->left, key, priority);\n\t\t}\n\t\t\t\t\n\t\tif (t->priority < t->left->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\telse if (key > t->key) {\n\t\tif (t->right == NULL) {\n\t\t\tnode * p = create_node(key, priority);\n\t\t\tt->right = p;\n\t\t\tp->parent = t;\n\t\t}\n\t\telse {\n\t\t\tinsert(t->right, key, priority);\n\t\t}\n\n\t\tif (t->priority < t->right->priority) {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\t\n\treturn t;\n}\n\nnode * delete(node * t, int key) {\n\tif (key == t->key) {\n\t\tif (t->left == NULL && t->right == NULL) {\n\t\t\tif (t->parent->left == t) {\n\t\t\t\tt->parent->left = NULL;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt->parent->right = NULL;\n\t\t\t}\n\t\t\tfree(t);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif (t->left == NULL) {\n\t\t\tt = left_rotate(t);\t\n\t\t}\n\t\telse if (t->right == NULL) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse if (t->left->priority > t->right->priority) {\n\t\t\tt = right_rotate(t);\n\t\t}\n\t\telse {\n\t\t\tt = left_rotate(t);\n\t\t}\n\t\tt = delete(t, key);\n\t\treturn t;\n\t}\n\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete(t->left, key);\n\t\treturn t;\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn NULL;\n\t\t}\n\t\tdelete(t->right, key);\n\t\treturn t;\n\t}\n}\n\nint find(node * t, int key) {\n\tif (key == t->key) {\n\t\treturn 1;\n\t}\n\tif (key < t->key) {\n\t\tif (t->left == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->left, key);\n\t}\n\telse {\n\t\tif (t->right == NULL) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn find(t->right, key);\n\t}\n}\n\nvoid print_preorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->left != NULL) {\n\t\tprint_preorder(t->left);\n\t}\n\tif (t->right != NULL) {\n\t\tprint_preorder(t->right);\n\t}\n}\n\nvoid print_inorder(node * t) {\n\tif (t == NULL) {\n\t\treturn;\n\t}\n\tif (t->left != NULL) {\n\t\tprint_inorder(t->left);\n\t}\n\tprintf(\" %d\", t->key);\n\tif (t->right != NULL) {\n\t\tprint_inorder(t->right);\n\t}\n}\n\nint main() {\n\tint m;\n\tchar buf[BUF_LENGTH];\n\tchar * str;\n\tint k, p;\n\tnode * root = NULL;\n\n\tscanf_s(\"%d \", &m);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tfgets(&buf, BUF_LENGTH, stdin);\n\t\tchar * context;\n\t\tstr = strtok_s(buf, \" \\n\", &context);\n\t\tif (strcmp(str, \"insert\") == 0) {\n\t\t\tstr = strtok_s(NULL, \" \\n\", &context);\n\t\t\tk = atoi(str);\n\t\t\tstr = strtok_s(NULL, \" \\n\", &context);\n\t\t\tp = atoi(str);\n\t\t\t//printf(\"--insert %d %d\\n\", k, p);\n\t\t\troot = insert(root, k, p);\n\t\t}\n\t\telse if (strcmp(str, \"find\") == 0) {\n\t\t\tstr = strtok_s(NULL, \" \\n\", &context);\n\t\t\tk = atoi(str);\n\t\t\t//printf(\"--find %d\\n\", k);\n\t\t\tint result = find(root, k);\n\t\t\tif (result == 1) {\n\t\t\t\tprintf(\"yes\\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t}\n\t\t}\n\t\telse if (strcmp(str, \"delete\") == 0) {\n\t\t\tstr = strtok_s(NULL, \" \\n\", &context);\n\t\t\tk = atoi(str);\n\t\t\t//printf(\"--delete %d\\n\", k);\n\t\t\troot = delete(root, k);\n\t\t}\n\t\telse if (strcmp(str, \"print\") == 0) {\n\t\t\t//printf(\"--print\\n\");\n\t\t\tprint_inorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tprint_preorder(root);\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse {\n\t\t\t//printf(\"error\\n\");\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nstruct Node{\n  int key, priority;\n  struct Node *right, *left;\n};\n\nstruct Node *root, *NIL;\n\nstruct Node *rightRotate(struct Node *t){\n  struct Node *s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s; // root of the subtree\n}\n\nstruct Node *leftRotate(struct Node *t){\n  struct Node *s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s; // root of the subtree\n}\n\nstruct Node *find(struct Node *u, int k){\n  while(u != NIL && k != u->key){\n    if(k < u->key)  u = u->left;\n    else  u = u->right;\n  }\n  return u;\n}\n\n\nstruct Node *insert(struct Node *t, int key, int priority){           // 再帰的に探索\n  struct Node *z;\n  if(t == NIL){\n    z = malloc(sizeof(struct Node));\n    z->key = key;\n    z->priority = priority;\n    z->left = NIL;\n    z->right=NIL;\n    return z;\n  }\n\n  if(key < t->key){                               // 左の子へ移動\n    t->left = insert(t->left, key, priority);   // 左の子へのポインタを更新\n    if(t->priority < t->left->priority)          // 左の子の方が優先度が高い場合右回転\n      t = rightRotate(t);\n  }\n  else{                                         // 右の子へ移動\n    t->right = insert(t->right, key, priority); // 右の子へのポインタを更新\n    if(t->priority < t->right->priority)         // 右の子の方が優先度が高い場合左回転\n      t = leftRotate(t);\n    }\n\n    return t;\n}\n\nstruct Node *_delete(struct Node*, int);\n\nstruct Node *delete(struct Node *t, int key){\n  if(t == NIL)\n    return NIL;\n  if(key < t->key)                                // 削除対象を検索\n    t->left = delete(t->left, key);\n  else if(key > t->key)\n    t->right = delete(t->right, key);\n  else\n    return _delete(t, key);\n  return t;\n}\n\nstruct Node *_delete(struct Node *t, int key){ // 削除対象の節点の場合\n    if(t->left == NIL && t->right == NIL)           // 葉の場合\n      return NIL;\n    else if(t->left == NIL)                        // 右の子のみを持つ場合左回転\n      t = leftRotate(t);\n    else if(t->right == NIL)                       // 左の子のみを持つ場合右回転\n      t = rightRotate(t);\n    else{                                         // 左の子と右の子を両方持つ場合\n      if(t->left->priority > t->right->priority)    // 優先度が高い方を持ち上げる\n        t = rightRotate(t);\n      else\n        t = leftRotate(t);\n    }\n    return delete(t, key);\n}\n\nvoid inorder(struct Node *u){\n  if(u == NIL)  return;\n  inorder(u->left);\n  printf(\" %d\", u->key);\n  inorder(u->right);\n}\n\nvoid preorder(struct Node *u){\n  if(u == NIL)  return;\n  printf(\" %d\", u->key);\n  preorder(u->left);\n  preorder(u->right);\n}\n\nint main(void){\n  int n, i, x, y;\n  char s[20];\n\n  scanf(\"%d\", &n);\n\n  for(i = 0; i < n; i++){\n    scanf(\"%s\", s);\n    if(s[0] == 'i'){\n      scanf(\"%d %d\", &x, &y);\n      root = insert(root, x, y);\n      x++;\n    }\n    else if(s[0] == 'f'){\n      scanf(\"%d\", &y);\n      struct Node *t = find(root, y);\n      if(t != NIL)  printf(\"yes\\n\");\n      else  printf(\"no\\n\");\n    }\n    else if(s[0] == 'd'){\n      scanf(\"%d\", &y);\n      root = delete(root, y);\n    }\n    else if(strcmp(s ,\"print\")==0){\n      inorder(root);\n      printf(\"\\n\");\n      preorder(root);\n      printf(\"\\n\");\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint FUNC00 ( ) {\n    int VAR00 = 0 ;\n    int VAR01 = getchar_unlocked ( ) ;\n    if ( VAR01 < 48 || 57 < VAR01 ) return VAR01 ;\n    while ( 47 < VAR01 && VAR01 < 58 ) {\n        VAR00 = 10 * VAR00 + ( VAR01 & 0xf ) ;\n        VAR01 = getchar_unlocked ( ) ;\n    }\n    return VAR00 ;\n}\nint FUNC01 ( char * ARG00 ) {\n    int VAR02 ;\n    while ( ( VAR02 = getchar_unlocked ( ) ) > 32 ) * ARG00 ++ = ( char ) VAR02 ;\n    * ARG00 = 0 ;\n    return VAR02 ;\n}\nvoid FUNC02 ( int ARG01 ) {\n    if ( ! ARG01 ) {\n        putchar_unlocked ( '0' ) ;\n        return ;\n    }\n    char VAR03 [ 11 ] ;\n    int VAR04 = 0 ;\n    while ( ARG01 ) VAR03 [ VAR04 ++ ] = ( char ) ( ARG01 % 10 + '0' ) , ARG01 /= 10 ;\n    while ( VAR04 -- ) putchar_unlocked ( VAR03 [ VAR04 ] ) ;\n}\nvoid FUNC03 ( char * ARG02 ) { while ( * ARG02 ) putchar_unlocked ( * ARG02 ++ ) ; }\n\ntypedef struct STRUCT00 {\n    int MEMBER00 ;\n    int MEMBER01 ;\n    struct STRUCT00 * MEMBER02 , * MEMBER03 ;\n} STRUCT00 ;\ntypedef struct STRUCT01 {\n    STRUCT00 * MEMBER04 ;\n    size_t MEMBER05 ;\n} STRUCT01 ;\nvoid FUNC04 ( STRUCT01 * ARG03 ) {\n    ARG03 -> MEMBER04 = NULL ;\n    ARG03 -> MEMBER05 = 0 ;\n}\nSTRUCT00 * FUNC05 ( STRUCT00 * ARG04 ) {\n    STRUCT00 * VAR05 = ARG04 -> MEMBER02 ;\n    ARG04 -> MEMBER02 = VAR05 -> MEMBER03 ;\n    VAR05 -> MEMBER03 = ARG04 ;\n    return VAR05 ;\n}\nSTRUCT00 * FUNC06 ( STRUCT00 * ARG05 ) {\n    STRUCT00 * VAR06 = ARG05 -> MEMBER03 ;\n    ARG05 -> MEMBER03 = VAR06 -> MEMBER02 ;\n    VAR06 -> MEMBER02 = ARG05 ;\n    return VAR06 ;\n}\nSTRUCT00 * FUNC07 ( STRUCT00 * ARG06 , int ARG07 , int ARG08 ) {\n    if ( ARG06 == NULL ) {\n        STRUCT00 * VAR07 = malloc ( sizeof ( STRUCT00 ) ) ;\n        VAR07 -> MEMBER00 = ARG07 ;\n        VAR07 -> MEMBER01 = ARG08 ;\n        VAR07 -> MEMBER02 = VAR07 -> MEMBER03 = NULL ;\n        return VAR07 ;\n    }\n    if ( ARG07 == ARG06 -> MEMBER00 ) return ARG06 ;\n    if ( ARG07 < ARG06 -> MEMBER00 ) {\n        ARG06 -> MEMBER02 = FUNC07 ( ARG06 -> MEMBER02 , ARG07 , ARG08 ) ;\n        if ( ARG06 -> MEMBER01 < ARG06 -> MEMBER02 -> MEMBER01 ) ARG06 = FUNC05 ( ARG06 ) ;\n    } else {\n        ARG06 -> MEMBER03 = FUNC07 ( ARG06 -> MEMBER03 , ARG07 , ARG08 ) ;\n        if ( ARG06 -> MEMBER01 < ARG06 -> MEMBER03 -> MEMBER01 ) ARG06 = FUNC06 ( ARG06 ) ;\n    }\n    return ARG06 ;\n}\nvoid FUNC08 ( STRUCT01 * ARG09 , int ARG10 , int ARG11 ) {\n    ARG09 -> MEMBER04 = FUNC07 ( ARG09 -> MEMBER04 , ARG10 , ARG11 ) ;\n    ARG09 -> MEMBER05 ++ ;\n}\nSTRUCT00 * FUNC09 ( const STRUCT00 * ARG12 , const int ARG13 ) {\n    while ( ARG12 != NULL && ARG12 -> MEMBER00 != ARG13 ) {\n        if ( ARG13 < ARG12 -> MEMBER00 ) ARG12 = ARG12 -> MEMBER02 ;\n        else ARG12 = ARG12 -> MEMBER03 ;\n    }\n    return ARG12 ;\n}\nSTRUCT00 * FUNC10 ( STRUCT00 * ARG14 ) {\n    while ( ARG14 -> MEMBER02 != NULL ) ARG14 = ARG14 -> MEMBER02 ;\n    return ARG14 ;\n}\nSTRUCT00 * FUNC11 ( STRUCT00 * ARG15 , int ARG16 ) {\n    if ( ARG15 == NULL ) return NULL ;\n    if ( ARG16 < ARG15 -> MEMBER00 ) ARG15 -> MEMBER02 = FUNC11 ( ARG15 -> MEMBER02 , ARG16 ) ;\n    else if ( ARG16 > ARG15 -> MEMBER00 ) ARG15 -> MEMBER03 = FUNC11 ( ARG15 -> MEMBER03 , ARG16 ) ;\n    else if ( ARG15 -> MEMBER02 && ARG15 -> MEMBER03 ) {\n        if ( ARG15 -> MEMBER02 -> MEMBER01 > ARG15 -> MEMBER03 -> MEMBER01 ) ARG15 = FUNC05 ( ARG15 ) ;\n        else ARG15 = FUNC06 ( ARG15 ) ;\n        ARG15 = FUNC11 ( ARG15 , ARG16 ) ;\n    } else {\n        STRUCT00 * VAR08 = ARG15 ;\n        if ( ARG15 -> MEMBER02 ) {\n            ARG15 = FUNC05 ( ARG15 ) ;\n            ARG15 -> MEMBER03 = FUNC11 ( ARG15 -> MEMBER03 , ARG16 ) ;\n        }\n        else if ( ARG15 -> MEMBER03 ) {\n            ARG15 = FUNC06 ( ARG15 ) ;\n            ARG15 -> MEMBER02 = FUNC11 ( ARG15 -> MEMBER02 , ARG16 ) ;\n        }\n        else {\n            ARG15 = NULL ;\n            free ( VAR08 ) ;\n        }\n    }\n    return ARG15 ;\n}\nvoid FUNC12 ( STRUCT01 * ARG17 , int ARG18 ) {\n    ARG17 -> MEMBER04 = FUNC11 ( ARG17 -> MEMBER04 , ARG18 ) ;\n    ARG17 -> MEMBER05 -- ;\n}\nvoid FUNC13 ( STRUCT00 * ARG19 ) {\n    if ( ARG19 == NULL ) return ;\n    FUNC13 ( ARG19 -> MEMBER02 ) ;\n    putchar_unlocked ( ' ' ) , FUNC02 ( ARG19 -> MEMBER00 ) ;\n    FUNC13 ( ARG19 -> MEMBER03 ) ;\n}\nvoid FUNC14 ( STRUCT00 * ARG20 ) {\n    if ( ARG20 == NULL ) return ;\n    putchar_unlocked ( ' ' ) , FUNC02 ( ARG20 -> MEMBER00 ) ;\n    FUNC14 ( ARG20 -> MEMBER02 ) ;\n    FUNC14 ( ARG20 -> MEMBER03 ) ;\n}\nint main ( int ARG21 , char * * ARG22 ) {\n    STRUCT01 VAR09 ;\n    FUNC04 ( & VAR09 ) ;\n    int VAR10 = FUNC00 ( ) ;\n    int VAR11 , VAR12 ;\n    char VAR13 [ 8 ] ;\n    for ( int VAR14 = 0 ; VAR14 < VAR10 ; ++ VAR14 ) {\n        FUNC01 ( VAR13 ) ;\n        switch ( * VAR13 ) {\n        case 'i' :\n            VAR11 = FUNC00 ( ) ;\n            VAR12 = FUNC00 ( ) ;\n            FUNC08 ( & VAR09 , VAR11 , VAR12 ) ;\n            break ;\n        case 'f' :\n            VAR11 = FUNC00 ( ) ;\n            FUNC03 ( FUNC09 ( VAR09 . MEMBER04 , VAR11 ) ? \"yes\\n\" : \"no\\n\" ) ;\n            break ;\n        case 'd' :\n            VAR11 = FUNC00 ( ) ;\n            FUNC12 ( & VAR09 , VAR11 ) ;\n            break ;\n        default :\n            FUNC13 ( VAR09 . MEMBER04 ) ;\n            putchar_unlocked ( '\\n' ) ;\n            FUNC14 ( VAR09 . MEMBER04 ) ;\n            putchar_unlocked ( '\\n' ) ;\n            break ;\n        }\n    }\n    return 0 ;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define NIL NULL\ntypedef struct node{\n\tint key;\n\tint pri;\n\tstruct node *right , *left;\n}Node;\n\nNode * Delete(Node **,int);\nNode * del(Node **,int);\n\nint find(Node *p,int x)\n{\n\twhile(p!=NIL)\n\t{\n\t\tif(p->key==x)return 1;\n\t\telse if(p->key > x)p = p->left;\n\t\telse p = p->right;\n\t}\n\treturn 0;\n}\n\nvoid inorder(Node *a)\n{\n\tif(a->left!=NIL) inorder(a->left);\n\tprintf(\" %d\",a->key);\n\tif(a->right!=NIL) inorder(a->right);\n\treturn;\n}\n\nvoid preorder(Node *p)\n{\n\tprintf(\" %d\",p->key);\n\tif(p->left!=NIL) preorder(p->left);\n\tif(p->right!=NIL) preorder(p->right);\n\treturn;\n}\n\nvoid print(Node *p)\n{\n\tinorder(p);\n\tprintf(\"\\n\");\n\tpreorder(p);\n\tprintf(\"\\n\");\n\treturn;\n}\n\nNode * makenode(int x , int y)\n{\n\tNode *new = malloc(sizeof(Node));\n\tnew->key = x;\n\tnew->pri = y;\n\tnew->left = NIL;\n\tnew->right = NIL;\n\treturn new;\n}\n\nNode *rightRotate(Node *p)\n{\n\tNode *q = p->left;\n\tp->left = q->right;\n\tq->right = p;\n\treturn q;\n}\n\nNode *leftRotate(Node *p)\n{\n\tNode *q = p->right;\n\tp->right = q->left;\n\tq->left = p;\n\treturn q;\n}\n\nNode* insert(Node **t , int key, int pri)\n{\n\tNode *new;\n\tif((*t)==NIL)\n\treturn new = makenode(key,pri);\n\tif((*t)->key == key)\n\treturn *t;\n\t\n\tif(key < (*t)->key)\n\t{\n\t\t(*t)->left = insert(&(*t)->left,key,pri);\n\t\tif((*t)->pri < (*t)->left->pri)\n\t\t(*t) = rightRotate(*t);\n\t}\n\telse{\n\t\t(*t)->right = insert(&(*t)->right,key,pri);\n\t\tif((*t)->pri < (*t)->right->pri)\n\t\t(*t) = leftRotate((*t));\n\t}\n\treturn *t;\n}\n\nNode * Delete(Node **t , int key)\n{\n\tif((*t)==NIL)\n\treturn NIL;\n\t\n\tif(key < (*t)->key)\n\t(*t)->left = Delete(&((*t)->left),key);\n\t\n\telse if(key > (*t)->key)\n\t(*t)->right = Delete(&((*t)->right),key);\n\n\telse return del(t,key);\n\treturn *t;\n}\n\nNode * del(Node **t , int key)\n{\n\tif((*t)->left == NIL && (*t)->right == NIL)\n\t{\n\t\treturn NIL;\n\t}\n\telse if((*t)->left == NIL)\n\t{\n\t\t(*t) = leftRotate(*t);\n\t}\n\telse if((*t)->right ==NIL)\n\t{\n\t\t(*t) = rightRotate(*t);\n\t}\n\telse{\n\t\tif((*t)->left->pri > (*t)->right->pri)\n\t\t(*t) = rightRotate(*t);\n\t\telse\n\t\t(*t) = leftRotate(*t);\n\t}\n\treturn Delete(t,key);\n}\n\nint main(void)\n{\n\tint num ,  x, y;\n\tchar com[8];\n\tNode *root = NIL;\n\tscanf(\"%d\",&num);\n\t\n\tfor(int i = 0; i < num; i++)\n\t{\n\t\tscanf(\"%s\",com);\n\t\tswitch(com[0])\n\t\t{\n\t\t\tcase 'i':scanf(\"%d %d\",&x,&y);\n\t\t\troot = insert(&root,x,y);\n\t\t\tbreak;\n\t\t\tcase 'd':scanf(\"%d\",&x);\n\t\t\troot = Delete(&root,x);\n\t\t\tbreak;\n\t\t\tcase 'f':scanf(\"%d\",&x);\n\t\t\tif(find(root,x))printf(\"yes\\n\");\n\t\t\telse printf(\"no\\n\");\n\t\t\tbreak;\n\t\t\tcase 'p':print(root);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define NIL NULL\n#define MAX 500001\nstruct node{\n  struct node *right;\n  struct node *left;\n  struct node *parent;\n  int key;\n};\ntypedef struct node * Node;\n\nNode root;\n\nNode treeMinimum(Node x){\nwhile(x->left!=NIL){\n  x=x->left;\n}\nreturn x;\n}\n\nNode treeMaximum(Node x){\nwhile(x->right!=NIL){\n  x=x->right;\n}\nreturn x;\n}\n\nNode treeSearch(Node x, int k){\nwhile ( x!=NIL && k!=x->key){\n  if(k<x->key) x=x->left;\n  else x=x->right;\n}\nreturn x;\n}\n\nNode treeSuccessor(Node x){\nNode y;\nif(x->right !=NIL) return treeMinimum(x->right);\n\ny=x->parent;\nwhile ( y !=NIL && x == y->right) {\n  x=y;\n  y=y->parent;\n}\nreturn y;\n\n}\n\nvoid treeDelete(Node z){\n  Node y; // node to be deleted\n  Node x; // child of y\nif(z->left == NIL || z->right ==NIL){\n  y=z;\n}\nelse y= treeSuccessor(z);\n\nif(y->left != NIL) x=y->left;\nelse x=y->right;\n\nif(x !=NIL) x->parent=y->parent;\nif(y->parent==NIL) root=x;\nelse if(y==y->parent->left) y->parent->left=x;\nelse y->parent->right=x;\n\nif(y!=z) z->key=y->key;\n}\n\nvoid insert(int k){\n  Node y = NIL;\n  Node x = root;\n  Node z;\n\n  z = malloc(sizeof(struct node));\n  z->key = k;\n  z->left = NIL;\n  z->right = NIL;\n\nwhile( x!=NIL){\n  y=x;\n  if(z->key<x->key) x=x->left;\n  else x=x->right;\n}\nz->parent=y;\nif(y==NIL)root=z;\nelse{\n  if(z->key<y->key) y->left=z;\n  else y->right=z;\n}\n}\n\nvoid inorder(Node u){\nif(u==NIL) return;\ninorder(u->left);\nprintf(\" %d\",u->key);\ninorder(u->right);\n}\nvoid preorder(Node u){\n  if(u==NIL) return;\n  printf(\" %d\",u->key);\n  preorder(u->left);\n  preorder(u->right);\n}\n\n\nint main(){\n  int n, i, x;\n  char com[20];\n  scanf(\"%d\", &n);\n\n  for ( i = 0; i < n; i++ ){\n    scanf(\"%s\", com);\n    if ( com[0] == 'f' ){\n      scanf(\"%d\", &x);\n      Node t = treeSearch(root, x);\n      if ( t != NIL ) printf(\"yes\\n\");\n      else printf(\"no\\n\");\n    } else if ( com[0] == 'i' ){\n      scanf(\"%d\", &x);\n      insert(x);\n    } else if ( com[0] == 'p' ){\n      inorder(root);\n      printf(\"\\n\");\n      preorder(root);\n      printf(\"\\n\");\n    } else if ( com[0] == 'd' ){\n      scanf(\"%d\", &x);\n      treeDelete(treeSearch(root, x));\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nstruct node {\n  int key;\n  int priority;\n  struct node *right;\n  struct node *left;\n};\n\ntypedef struct node* Nodepointer;\nNodepointer nil=NULL, root=NULL;\n\nNodepointer delete(Nodepointer*, int);\nNodepointer _delete(Nodepointer*, int);\n\nNodepointer Node(int key, int priority){\n Nodepointer z;\n  z = (Nodepointer)malloc(sizeof(struct node));\n  z->key = key;\n  z->priority = priority;\n  z->left = nil;\n  z->right = nil;\n  return z;\n}\n\nNodepointer rightRotate(Nodepointer t){\n  Nodepointer s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\n\nNodepointer leftRotate(Nodepointer t){\n  Nodepointer s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\n\nNodepointer insert(Nodepointer *t, int key, int priority){\n  Nodepointer new;\n  if( (*t) == nil ) return new = Node(key, priority);\n  if( key == (*t)->key ) return *t;\n\n  if( key < (*t)->key ){\n    (*t)->left = insert(&(*t)->left, key, priority);\n    if( (*t)->priority < (*t)->left->priority ) (*t) = rightRotate((*t));\n  }\n  else{\n    (*t)->right = insert(&(*t)->right, key, priority);\n    if( (*t)->priority < (*t)->right->priority ) (*t) = leftRotate((*t));\n  }\n  return *t;\n}\n\n\nNodepointer delete(Nodepointer *t, int key){\n  if( (*t) == nil ) return nil;\n  if( key < (*t)->key ) (*t)->left = delete(&((*t)->left), key);\n  else if( key > (*t)->key ) (*t)->right = delete(&((*t)->right), key);\n  else {\n    return _delete(t, key);\n  }\n  return *t;\n}\n\nNodepointer _delete(Nodepointer *t, int key){\n  if( (*t)->left == nil && (*t)->right == nil ) return nil;\n  else if( (*t)->left == nil ) (*t) = leftRotate(*t);\n  else if( (*t)->right == nil ) (*t) = rightRotate(*t);\n  else {\n    if( (*t)->left->priority > (*t)->right->priority ) (*t) = rightRotate(*t);\n    else (*t) = leftRotate(*t);\n  }\n  return delete(t, key);\n}\n\n\nint find(Nodepointer u, int k){\n  while( u != nil ){\n    if( u->key == k ) return 1;\n    else if( k < u->key ) u = u->left;\n    else u = u->right;\n  }\n  return 0;\n}\n\nvoid inorder(Nodepointer u){\n  if( u->left != nil ) inorder(u->left);\n  printf(\" %d\", u->key);\n  if( u->right != nil ) inorder(u->right);\n  return;\n}\n\nvoid preorder(Nodepointer u){\n  printf(\" %d\", u->key);\n  if( u->left != nil ) preorder(u->left);\n  if( u->right != nil ) preorder(u->right);\n  return;\n}\n\nvoid print(Nodepointer u){\n  inorder(u);\n  printf(\"\\n\");\n  preorder(u);\n  printf(\"\\n\");\n  return;\n}\n\nint main(){\n  int m, i, x, y;\n  char com[8];\n  Nodepointer t=nil;\n\n  scanf(\"%d\", &m);\n\n  for( i = 0 ; i < m ; i++ ){\n    scanf(\"%s\",com);\n\n    switch(com[0]){\n    case 'f': scanf(\"%d\", &x);\n      if( find(root, x)) printf(\"yes\\n\");\n      else printf(\"no\\n\");\n      break;\n\n    case 'i':  scanf(\"%d%d\", &x, &y);\n      root = insert(&root,x,y);\n      break;\n\n    case 'p':  print(root);\n      break;\n\n    case 'd': scanf(\"%d\", &x);\n      root = delete(&root, x);\n      break;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "          #include<stdio.h>\n          #include<stdlib.h>\n\n          #define NIL NULL\n\n          typedef struct node{\n            int key;\n            int priority;\n            struct node *left;\n            struct node *right;\n          }node;\n\n\n          node * Delete(node **,int);\n          node * _delete(node **,int);\n\n          int find(node *p,int x){\n\n            while(p!=NIL){\n              if(p->key == x)return 1;\n              else if(p->key > x)p=p->left;\n              else p=p->right;\n            }\n\n            return 0;\n\n          }\n\n          void inorder(node *a){\n\n            if(a->left!=NIL)inorder(a->left);\n\n            printf(\" %d\",a->key);\n\n            if(a->right!=NIL)inorder(a->right);\n\n            return;\n\n          }\n\n          void preorder(node *p){\n\n            printf(\" %d\",p->key);\n\n            if(p->left!=NIL)preorder(p->left);\n\n            if(p->right!=NIL)preorder(p->right);\n\n            return;\n\n          }\n\n          void print(node *p){\n\n            inorder(p);\n            printf(\"\\n\");\n\n            preorder(p);\n            printf(\"\\n\");\n\n            return;\n\n          }\n\n          node * makenode(int x,int y){\n            node *new=malloc(sizeof(node));\n            new->key=x;\n            new->priority=y;\n            new->left=NIL;\n            new->right=NIL;\n            return new;\n          }\n\n          node *rightRotate(node *p){\n            node *q=p->left;\n            p->left=q->right;\n            q->right=p;\n            return q;\n          }\n\n          node *leftRotate(node *p){\n            node *q=p->right;\n            p->right=q->left;\n            q->left=p;\n            return q;\n          }\n\n\n          node* insert(node **t,int key,int priority){\n            node *new;\n\n            if((*t)==NIL)\n            return new=makenode(key,priority);\n            if ((*t)->key==key)\n            return *t;\n\n            if(key < (*t)->key){\n              (*t)->left=insert(&(*t)->left,key,priority);\n              if((*t)->priority < (*t)->left->priority)\n              (*t)=rightRotate((*t));\n            }\n            else {\n              (*t)->right=insert(&(*t)->right,key,priority);\n              if((*t)->priority < (*t)->right->priority)\n              (*t)=leftRotate((*t));\n            }\n\n            return *t;\n          }\n\n\n          node * Delete(node **t,int key){\n            if((*t)==NIL)\n            return NIL;\n\n            if(key < (*t)->key)\n            (*t)->left=Delete(&((*t)->left),key);\n\n            else if(key > (*t)->key)\n            (*t)->right=Delete(&((*t)->right),key);\n\n            else return _delete(t,key);\n\n            return *t;\n          }\n\n          node * _delete(node **t,int key){\n            if((*t)->left==NIL && (*t)->right==NIL)\n            return NIL;\n            else if((*t)->left==NIL)\n            (*t)=leftRotate(*t);\n            else if((*t)->right==NIL)\n            (*t)=rightRotate(*t);\n            else {\n              if((*t)->left->priority > (*t)->right->priority)\n              (*t)=rightRotate(*t);\n              else\n              (*t)=leftRotate(*t);\n            }\n            return Delete(t,key);\n          }\n\n\n          int main(){\n            int num,x,y;\n            char com[8];\n\n            node *root=NIL;\n\n            scanf(\"%d\",&num);\n\n            for(int i=0;i<num;i++){\n              scanf(\"%s\",com);\n\n              switch(com[0]){\n\n                case 'i':scanf(\"%d %d\",&x,&y);\n                root=insert(&root,x,y);\n                break;\n\n                case 'd':scanf(\"%d\",&x);\n                root=Delete(&root,x);\n                break;\n\n\n                case 'f':scanf(\"%d\",&x);\n                if(find(root,x))printf(\"yes\\n\");\n                else printf(\"no\\n\");\n                break;\n\n                case 'p':print(root);\n                break;\n\n              }\n\n            }\n\n            return 0;\n\n          }\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#define NIL NULL\n\nstruct Node{\n\tint key;\n\tint priority;\n\tstruct Node *r,*l,*p;\n}Node;\n\nstruct Node *Delete(struct Node **t, int key);\nstruct Node *_delete(struct Node **t, int key);\n\nvoid preorder( struct Node *u ){\n\t\n\tprintf(\" %d\",u->key);\n\tif(u->l!=NIL){\n\t\tpreorder(u->l);\n\t}\n\tif(u->r!=NIL){\n\t\tpreorder(u->r);\n\t}\n\treturn;\n}\n\nvoid inorder( struct Node *u ){\n\t\n\tif(u->l!=NIL){\n\t\tinorder(u->l);\n\t}\n\tprintf(\" %d\",u->key);\n\tif(u->r!=NIL){\n\t\tinorder(u->r);\n\t}\n\treturn;\n\t\n}\n\nint find( struct Node *u , int k ){\n\twhile( u != NIL ){\n\t\tif( u->key == k ){\n\t\t\treturn 1;\n\t\t}else if( k < u->key ){\n\t\t\tu = u->l;\n\t\t}else{\n\t\t\tu = u->r;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstruct Node *rightRotate(struct Node *t){\n    struct Node *s = t->l;\n    t->l = s->r;\n    s->r = t;\n    return s;\n}\n\nstruct Node *leftRotate(struct Node *t){\n    struct Node *s = t->r;\n    t->r = s->l;\n    s->l = t;\n    return s;\n}\n\nstruct Node* node( int x , int y ){\n\t\n\tstruct Node *new = malloc(sizeof(Node));\n\tnew->key = x;\n\tnew->priority = y;\n\tnew->l = NIL;\n\tnew->r = NIL;\n\t\n\treturn new;\n}\n\nstruct Node* insert(struct Node **t, int key, int priority){\n\t\n\tstruct Node *new;\n\tif( *t == NIL ){\n        return new = node(key, priority);\n\t}\n\tif( key == (*t)->key ){\n        return *t;\n\t}\n\n\tif( key < (*t)->key ){\n\t\t(*t)->l = insert(&(*t)->l, key, priority);\n\t\tif ( (*t)->priority < (*t)->l->priority ){\n            *t = rightRotate(*t);\n\t\t}\n\t}else{\n\t\t(*t)->r = insert(&(*t)->r, key, priority);\n\t\tif( (*t)->priority < (*t)->r->priority ){\n            *t = leftRotate(*t);\n\t\t}\n\t}\n\treturn *t;\n}\n\nstruct Node *Delete(struct Node **t, int key){\n\t\n\tif ((*t) == NIL){\n\t\treturn NIL;\n\t}\n\tif ( key < (*t)->key ){\n\t\t(*t)->l = Delete(&((*t)->l), key);\n\t}else if ( key > (*t)->key ){\n\t\t(*t)->r = Delete(&((*t)->r), key);\n\t}else{\n        return _delete(t, key);\n\t}\n    return *t;\n}\n\nstruct Node *_delete(struct Node **t, int key){                \n\t\tif ((*t)->l == NIL && (*t)->r == NIL ){               \n        \treturn NIL;\n\t\t}else if ( (*t)->l == NIL ){\n        \t*t = leftRotate(*t);\n\t\t}else if ((*t)->r == NIL){\n        \t*t = rightRotate(*t);\n\t\t}else{\n\t\t\tif ((*t)->l->priority > (*t)->r->priority ){\n            \t*t = rightRotate(*t);\n\t\t\t}\n\t\t\telse{\n            \t*t = leftRotate(*t);\n\t\t\t}\n\t\t}\n    return Delete(t, key);\n}\n\nint main( void ){\n\tint n , i , x , y;\n\tchar com[10];\n\tstruct Node *root = NIL;\n\t\n\tscanf( \"%d\", &n );\n\t\n\tfor( i=0;i<n;i++ ){\n\t\t\n\t\tscanf(\"%s\",com );\n\t\tif( strcmp(com ,\"find\") == 0 ) {\n\t\t\tscanf( \"%d\",&x );\n\t\t\tif( find(root,x) ){\n\t\t\t\tprintf( \"yes\\n\" );\n\t\t\t}else{\n\t\t\t\tprintf(\"no\\n\");\n\t\t\t}\n\t\t}else if( strcmp(com ,\"delete\") == 0 ){\n\t\t\tscanf( \"%d\" , &x );\n\t\t\troot = Delete(&root,x);\n\t\t}else if( strcmp(com,\"insert\") == 0 ){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\troot = insert(&root,x,y);\n\t\t}else if( strcmp(com ,\"print\") == 0 ){\n\t\t\tinorder(root);\n\t\t\tprintf( \"\\n\" );\n\t\t\tpreorder(root);\n\t\t\tprintf( \"\\n\" );\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DEBUG 0\n#define true 1\n#define false 0\n\n//typedef struct Node Node;\nstruct Node;\ntypedef struct Node Node;\n\nstruct Node{\n    int key;\n    int priority;\n    Node *root;\n    Node *left;\n    Node *right;\n};\n\n\nNode* rightRotate(Node* t);\nNode* leftRotate(Node* t);\nNode* mkNode(int key,int priority);\nNode* insert(Node* t, int key, int priority);\nNode* delete(Node* t, int key);\nNode* _delete(Node* t, int key);\nvoid print(Node* t);\nvoid _print_in(Node* t);\nvoid _print_pre(Node* t);\nvoid search(Node* t, int key);\nint _search(Node* t, int key);\n\nint main (){\n    //printf(\"hellocatcat\\n\");\n    int m;\n    Node* root = NULL;\n    char cmd[32];\n    char* ins=\"insert\";\n    char* del=\"delete\";\n    char* pri=\"print\";\n    char* fin=\"find\";\n    int a;\n    int b;\n    memset(cmd,0,strlen(cmd));\n    scanf(\"%d\",&m);\n    while(m>0){\n        scanf(\"%s\",cmd);\n        if(!strcmp(cmd,ins)){\n            scanf(\"%d %d\",&a,&b);\n            if(DEBUG)printf(\"%s %d %d\\n\",cmd,a,b);\n            root =insert(root,a,b);\n        }else if(!strcmp(cmd,del)){\n            scanf(\"%d\",&a);\n            if(DEBUG)printf(\"%s %d\\n\",cmd,a);\n            root = delete(root,a);\n        }else if(!strcmp(cmd,pri)){\n            if(DEBUG)printf(\"%s\\n\",cmd);\n            print(root);\n        }else if(!strcmp(cmd,fin)){\n            scanf(\"%d\",&a);\n            if(DEBUG)printf(\"%s %d\\n\",cmd,a);\n            search(root,a);\n        }\n        m--;\n    }\n\n    return 0;\n}\n\nNode* rightRotate(Node* t){\n    Node* s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s; //the new root of subtree\n}\n\nNode* leftRotate(Node* t){\n    Node* s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s; //the new root of subtree\n}\n\nNode* mkNode(int key, int priority){\n    Node *s = malloc(sizeof(Node));\n    if(s){\n        s->key = key;\n        s->priority = priority;\n        s->root = NULL;\n        s->left = NULL;\n        s->right = NULL;\n    }\n    return s;\n}\n\nNode* insert(Node* t, int key, int priority){\n    if(t == NULL)\n        return mkNode(key, priority);\n    if(key == t->key)\n        return t;\n    \n    if(key < t->key){\n        t->left = insert(t->left, key, priority);\n        if(t->priority < t->left->priority){\n            t = rightRotate(t);\n        }\n    }else{\n        t->right = insert(t->right, key, priority);\n        if(t->priority < t->right->priority){\n            t = leftRotate(t);\n        }\n    }\n\n    return t;\n}\n\nNode* delete(Node* t, int key){\n    if(t == NULL)\n        return NULL;\n    if(key< t->key){\n        t->left = delete(t->left, key);\n    }else{\n        if( key > t->key){\n            t->right= delete(t->right, key);\n        }else{\n            return _delete(t,key);\n        }\n    }\n    return t;\n}\n\nNode* _delete (Node* t, int key){\n    if(t->left == NULL && t->right == NULL)\n        return NULL;\n    else if (t-> left == NULL)\n        t = leftRotate(t);\n    else if (t->right == NULL)\n        t = rightRotate(t);\n    else{\n        if(t->left->priority > t->right->priority)\n            t = rightRotate(t);\n        else\n        {\n            t = leftRotate(t);\n        }\n    }\n    return delete(t,key);\n}\n\nvoid print(Node* t){\n    _print_in(t);\n    printf(\"\\n\");\n    _print_pre(t);\n    printf(\"\\n\");\n}\n\nvoid _print_in(Node* t){\n    if(t->left == NULL && t->right == NULL){\n        printf(\" %d\",t->key);\n        return;\n    }\n    \n    if(t->left != NULL){\n        _print_in(t->left);\n    }\n    printf(\" %d\",t->key);\n    if(t->right != NULL){\n        _print_in(t->right);\n    }\n\n    return;\n}\n\nvoid _print_pre(Node* t){\n    if(t->left == NULL && t->right == NULL){\n        printf(\" %d\",t->key);\n        return;\n    }\n    \n    printf(\" %d\",t->key);\n    if(t->left != NULL){\n        _print_pre(t->left);\n    }\n    if(t->right != NULL){\n        _print_pre(t->right);\n    }\n    return;\n}\n\nvoid search(Node* t, int key){\n    if(t == NULL){\n        printf(\"no\\n\");\n        return;\n    }else{\n        if(_search(t,key)){\n            printf(\"yes\\n\");\n            return;\n        }else{\n            printf(\"no\\n\");\n            return;\n        }\n    }\n}\n\nint _search(Node* t, int key){\n    if(t == NULL){\n        return false;\n    }\n    if(t->key == key){\n        return true;\n    }\n    if(key < t->key){\n        return _search(t->left,key);\n    }else{\n        return _search(t->right,key);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 41\n\ntypedef struct node{\n  int l, r;\n}node;\n\nnode c[N];\nint a[N];\nint b[N];\nint cnt=0;\n\nvoid postorder(int root,int n){\n\n        if(c[root].l != -1) postorder(c[root].l, n);\n\n        if(c[root].r != -1) postorder(c[root].r, n);\n\n        if(cnt < n-1) printf(\"%d \", root);\n        else printf(\"%d\\n\", root);\n\n        cnt++;\n\n        return;\n}\n\nint reconst(int start,int last,int n){\n  int i, j;\n\n  if(start==last) return b[start];\n  else if(start > last) return -1;\n\n  else{\n    for(i = 1 ; i <= n ; i++){\n      for(j = start ; j <= last ; j++){\n        if(a[i] == b[j]){\n          c[a[i]].l = reconst(start, j - 1, n);\n          c[a[i]].r = reconst(j + 1, last, n);\n          return a[i];\n        }\n      }\n    }\n  }\n}\n\n\nint main(){\n  int n, i, root;\n\n  scanf(\"%d\", &n);\n\n  for(i = 1 ; i <= n ; i++) scanf(\"%d\",&a[i]);\n\n  for(i = 1 ; i <= n ; i++) scanf(\"%d\",&b[i]);\n\n  for(i = 1 ; i <= n ; i++){\n    c[i].l = -1;\n    c[i].r = -1;\n  }\n\n  root = reconst(1,n,n);\n  postorder(root,n);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\nstruct tree {\n  int key;\n  int priority;\n  struct tree *left;\n  struct tree *right;\n};\nstruct tree *root = NULL;\nint Search(struct tree *p, int key);\nstruct tree *Lrotation(struct tree *p);\nstruct tree *Rrotation(struct tree *p);\nstruct tree *Insert(struct tree **p, int key, int priority);\nstruct tree *Delete(struct tree **p, int key);\nstruct tree *delete(struct tree **p, int key);\nvoid Dispm(struct tree *p);\nvoid Dispp(struct tree *p);\nint main(void)\n{\n  int i, count, key, priority;\n  char command[7];\n  scanf(\"%d\", &count);\n  for (i = 0; i < count; i++) {\n    scanf(\"%*c%s\", command);\n    switch (command[0]) {\n    case 'f':\n      scanf(\"%d\", &key);\n      if (Search(root, key)) {\n        printf(\"yes\\n\");\n      } else {\n        printf(\"no\\n\");\n      }\n      break;\n    case 'i':\n      scanf(\"%d %d\", &key, &priority);\n      root = Insert(&root, key, priority);\n      break;\n    case 'd':\n      scanf(\"%d\", &key);\n      Delete(&root, key);\n      break;\n    case 'p':\n      Dispm(root);\n      putchar('\\n');\n      Dispp(root);\n      putchar('\\n');\n      break;\n    }\n  }\n  return 0;\n}\nint Search(struct tree *p, int key)\n{\n  if (p == NULL) {\n    return 0;\n  } else if (p->key == key) {\n    return 1;\n  } else if (p->key > key) {\n    return Search(p->left, key);\n  } else {\n    return Search(p->right, key);\n  }\n}\nstruct tree *Lrotation(struct tree *p)\n{\n  struct tree *q = p->right;\n  p->right = q->left;\n  q->left = p;\n  return q;\n}\nstruct tree *Rrotation(struct tree *p)\n{\n  struct tree *q = p->left;\n  p->left = q->right;\n  q->right = p;\n  return q;\n}\nstruct tree *Insert(struct tree **p, int key, int priority)\n{\n  if (*p == NULL) {\n    *p = (struct tree*)malloc(sizeof(struct tree));\n    (*p)->key = key;\n    (*p)->priority = priority;\n    (*p)->left = NULL;\n    (*p)->right = NULL;\n  } else if ((*p)->key > key) {\n    (*p)->left = Insert(&(*p)->left, key, priority);\n    if ((*p)->priority <  (*p)->left->priority) *p = Rrotation(*p);\n  } else if ((*p)->key < key) {\n    (*p)->right = Insert(&(*p)->right, key, priority);\n    if ((*p)->priority <  (*p)->right->priority) *p = Lrotation(*p);\n  }\n  return *p;\n}\nstruct tree *Delete(struct tree **p, int key)\n{\n  if ((*p) == NULL) return NULL;\n  if ((*p)->key > key) (*p)->left = Delete(&(*p)->left, key);\n  else if ((*p)->key < key) (*p)->right = Delete(&(*p)->right, key);\n  else delete(p, key);\n  return *p;\n}\nstruct tree *delete(struct tree **p, int key)\n{\n  if ((*p)->left == NULL && (*p)->right == NULL) return *p = NULL;\n  else if ((*p)->left == NULL) *p = Lrotation(*p);\n  else if ((*p)->right == NULL) *p = Rrotation(*p);\n  else {\n    if ((*p)->left->priority > (*p)->right->priority) *p = Rrotation(*p);\n    else *p = Lrotation(*p);\n  }\n  return Delete(p, key);\n}\nvoid Dispm(struct tree *p)\n{\n  if (p != NULL) {\n    Dispm(p->left);\n    printf(\" %d\", p->key);\n    Dispm(p->right);\n  }\n}\nvoid Dispp(struct tree *p)\n{\n  if (p != NULL) {\n    printf(\" %d\", p->key);\n    Dispp(p->left);\n    Dispp(p->right);\n  }\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 41\n\ntypedef struct node{\n  int l, r;\n}node;\n\nnode c[N];\nint a[N];\nint b[N];\nint cnt=0;\n\nvoid postorder(int root,int n){\n\n        if(c[root].l != -1) postorder(c[root].l, n);\n\n        if(c[root].r != -1) postorder(c[root].r, n);\n\n        if(cnt < n-1) printf(\"%d \", root);\n        else printf(\"%d\\n\", root);\n\n        cnt++;\n\n        return;\n}\n\nint reconst(int start,int last,int n){\n  int i, j;\n\n  if(start==last) return b[start];\n  else if(start > last) return -1;\n\n  else{\n    for(i = 1 ; i <= n ; i++){\n      for(j = start ; j <= last ; j++){\n        if(a[i] == b[j]){\n          c[a[i]].l = reconst(start, j - 1, n);\n          c[a[i]].r = reconst(j + 1, last, n);\n          return a[i];\n        }\n      }\n    }\n  }\n}\n\n\nint main(){\n  int n, i, root;\n\n  scanf(\"%d\", &n);\n\n  for(i = 1 ; i <= n ; i++){\n    scanf(\"%d\",&a[i]);\n    scanf(\"%d\",&b[i]);\n    c[i].l = -1;\n    c[i].r = -1;\n  }\n\n  root = reconst(1, n, n);\n  postorder(root, n);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct node{\n\tint key;\n\tint priority;\n\tstruct node *left;\n\tstruct node *right;\n}Node;\n\nNode * makeNode(int,int);\nNode * rightRotate(Node *);\nNode * leftRotate(Node *);\nNode * insert(Node **, int, int);\nNode * delete(Node **,int);\nNode * KeyDelete(Node **,int);\nint find(Node *, int);\nvoid inorder(Node *);\nvoid preorder(Node *);\nvoid print(Node *);\n\nint main(){\n    int m, k, p;\n    char com[8];\n    int i;\n    Node *root=NULL;\n\n    scanf(\"%d\",&m);\n\n    for(i=0;i<m;i++){\n        scanf(\"%s\", com);\n\n        switch(com[0]){\n            case 'i':\n                scanf(\"%d %d\", &k,&p);\n                root=insert(&root,k,p);\n                break;\n            case 'd':\n                scanf(\"%d\", &k);\n                root=delete(&root,k);\n                break;\n            case 'f':\n                scanf(\"%d\", &k);\n                if(find(root,k)==1) printf(\"yes\\n\");\n                else printf(\"no\\n\");\n                break;\n            case 'p':\n                print(root);\n                break;\n        }\n    }\n}\n\nNode * makeNode(int k, int p){\n    Node *new=malloc(sizeof(Node));\n    new->key=k;\n    new->priority=p;\n    new->left=NULL;\n    new->right=NULL;\n    return new;\n}\n\nNode * rightRotate(Node *t){\n    Node *s = t->left;\n    t->left = s->right;\n    s->right = t;\n    return s; // root of the subtree\n}\n\nNode * leftRotate(Node *t){\n    Node *s = t->right;\n    t->right = s->left;\n    s->left = t;\n    return s; // root of the subtree\n}\n\nNode * insert(Node **t, int key, int priority){          // 再帰的に探索\n    Node *new;\n\n    if((*t) == NULL) return new= makeNode(key, priority);    // 葉に到達したら新しい節点を生成して返す\n    if(key == (*t)->key) return *t;                   // 重複したkeyは無視\n\n    if(key < (*t)->key){                            // 左の子へ移動\n        (*t)->left = insert(&((*t)->left), key, priority);  // 左の子へのポインタを更新\n        if ((*t)->priority < (*t)->left->priority)  (*t) = rightRotate((*t));      // 左の子の方が優先度が高い場合右回転\n    }\n    else {                                                         // 右の子へ移動\n        (*t)->right = insert(&((*t)->right), key, priority);          // 右の子へのポインタを更新\n        if((*t)->priority < (*t)->right->priority) (*t) = leftRotate((*t));        // 右の子の方が優先度が高い場合左回転\n    }\n    return *t;\n}\n\nNode * delete(Node **t, int key){\n    if((*t) == NULL) return NULL;\n    if(key < (*t)->key)  (*t)->left = delete(&((*t)->left), key);         // 削除対象を検索\n    else if(key > (*t)->key) (*t)->right = delete(&((*t)->right), key);\n    else return KeyDelete(t, key);\n    return *t;\n}\n\nNode * KeyDelete(Node **t, int key){ // 削除対象の節点の場合\n    if((*t)->left == NULL && (*t)->right == NULL)  return NULL;      // 葉の場合\n    else if((*t)->left == NULL)   (*t) = leftRotate(*t);      // 右の子のみを持つ場合左回転\n    else if((*t)->right == NULL) (*t) = rightRotate(*t);      // 左の子のみを持つ場合右回転\n    else{                                         // 左の子と右の子を両方持つ場合\n        if((*t)->left->priority > (*t)->right->priority){    // 優先度が高い方を持ち上げる\n            (*t) = rightRotate(*t);\n        }\n        else  (*t) = leftRotate(*t);\n    }\n    return delete(t, key);\n}\n\nint find(Node *t, int key){\n    while(t!=NULL){\n        if(t->key == key) return 1; // yes\n        else if(t->key > key) t=t->left;\n        else t=t->right;\n    }\n    return 0; // no\n}\n\nvoid inorder(Node *t){\n    if(t->left!=NULL) inorder(t->left);\n    printf(\" %d\", t->key);\n    if(t->right!=NULL) inorder(t->right);\n}\n\nvoid preorder(Node *t){\n    printf(\" %d\", t->key);\n    if(t->left!=NULL) inorder(t->left);\n    if(t->right!=NULL) inorder(t->right);\n}\n\nvoid print(Node *t){\n    inorder(t);\n    printf(\"\\n\");\n\n    preorder(t);\n    printf(\"\\n\");\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nstruct node {\n  int key;\n  int priority;\n  struct node *right;\n  struct node *left;\n  struct node *parent;\n};\n\ntypedef struct node* Nodepointer;\nNodepointer nil, root;\n\nNodepointer delete(Nodepointer*, int);\nNodepointer _delete(Nodepointer*, int);\n\nNodepointer Node(int key, int priority){\n Nodepointer z;\n  z = (Nodepointer)malloc(sizeof(struct node));\n  z->key = key;\n  z->priority = priority;\n  z->left = nil;\n  z->right = nil;\n  return z;\n}\n\nNodepointer rightRotate(Nodepointer t){\n  Nodepointer s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\n\nNodepointer leftRotate(Nodepointer t){\n  Nodepointer s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\n\nNodepointer insert(Nodepointer *t, int key, int priority){\n  if( (*t) == nil ) return Node(key, priority);\n  if( key == (*t)->key ) return *t;\n\n  if( key < (*t)->key ){\n    (*t)->left = insert(&(*t)->left, key, priority);\n    if( (*t)->priority < (*t)->left->priority ) (*t) = rightRotate((*t));\n  }\n  else{\n    (*t)->right = insert(&(*t)->right, key, priority);\n    if( (*t)->priority < (*t)->right->priority ) (*t) = leftRotate((*t));\n  }\n  return *t;\n}\n\n\nNodepointer delete(Nodepointer *t, int key){\n  if( (*t) == nil ) return nil;\n  if( key < (*t)->key ) (*t)->left = delete(&(*t)->left, key);\n  else if( key > (*t)->key ) (*t)->right = delete(&(*t)->right, key);\n  else {\n    return _delete(t, key);\n  }\n  return *t;\n}\n\nNodepointer _delete(Nodepointer *t, int key){\n  if( (*t)->left == nil && (*t)->right == nil ) return nil;\n  else if( (*t)->left == nil ) (*t) = leftRotate(*t);\n  else if( (*t)->right == nil ) (*t) = rightRotate(*t);\n  else {\n    if( (*t)->left->priority > (*t)->right->priority ) (*t) = rightRotate(*t);\n    else (*t) = leftRotate(*t);\n  }\n  return delete(t, key);\n}\n\n\nNodepointer find(Nodepointer u, int k){\n  while( u != nil && k != u->key ){\n    if( k < u->key ) u = u->left;\n    else u = u->right;\n  }\n  return u;\n}\n\nvoid inorder(Nodepointer u){\n  if( u->left != nil ) inorder(u->left);\n  printf(\" %d\", u->key);\n  if( u->right != nil ) inorder(u->right);\n  return;\n}\n\nvoid preorder(Nodepointer u){\n  printf(\" %d\", u->key);\n  if( u->left != nil ) preorder(u->left);\n  if( u->right != nil ) preorder(u->right);\n  return;\n}\n\nvoid print(Nodepointer u){\n  inorder(u);\n  printf(\"\\n\");\n  preorder(u);\n  printf(\"\\n\");\n  return;\n}\n\nint main(){\n  int m, i, x, y;\n  char com[8];\n  Nodepointer t=nil;\n\n  scanf(\"%d\", &m);\n\n  for( i = 0 ; i < m ; i++ ){\n    scanf(\"%s\",com);\n    if( com[0] == 'f' ){\n      scanf(\"%d\", &x);\n      t = find(root, x);\n      if( t != nil ) printf(\"yes\\n\");\n      else printf(\"no\\n\");\n    }\n    else if( strcmp(\"insert\",com) == 0 ){\n      scanf(\"%d%d\", &x, &y);\n      insert(&root,x,y);\n    }\n    else if( strcmp(\"print\",com) == 0 ){\n      print(root);\n    }\n    else if( strcmp(\"delete\", com) == 0 ){\n      scanf(\"%d\", &x);\n      root = delete(&root, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "typedef int Key;\ntypedef int Value;\ntypedef int Result;\nstruct Treap {\n  Key key;\n  Value value;\n  int p;\n  bool cached;\n  Result cache;\n  Treap *ch[2]; // LEFT = ch[0], RIGHT = ch[1]\n  Treap(const Key &key, const Value &value) : key(key), value(value),\n    p(rand()), cached(0) { ch[0] = ch[1] = 0; }\n};\nTreap *rotate(Treap *t, int b) {\n  Treap *s = t->ch[1-b]; t->ch[1-b] = s->ch[b]; s->ch[b] = t;\n  s->cached = t->cached = false;\n  return s;\n}\nTreap *find(Treap *t, const Key &key) {\n  return !t || key == t->key ? t : find(t->ch[key<t->key], key);\n}\nTreap *insert(Treap *t, const Key &key, const Value &value) {\n  if (!t) return new Treap(key, value);\n  else if (key == t->key) return t;\n  int b = !(key < t->key);\n  t->ch[b] = insert(t->ch[b], key, value);\n  if (t->p > t->ch[b]->p) t = rotate(t, 1-b);\n  t->cached = false;\n  return t;\n}\nTreap *erase(Treap *t, const Key &key) {\n  if (!t) return NULL;\n  if (key == t->key) {\n    if (!t->ch[0] && !t->ch[1]) return NULL;\n    else if (!t->ch[0]) t = rotate(t, 0);\n    else if (!t->ch[1]) t = rotate(t, 1);\n    else t = rotate(t, t->ch[0]->p<t->ch[1]->p);\n    t = erase(t, key);\n  } else {\n    int b = !(key < t->key);\n    t->ch[b] = erase(t->ch[b], key);\n  }\n  t->cached = false;\n  return t;\n}\nResult eval(Treap *t) {\n  if (!t) return 0;\n  if (!t->cached)\n    t->cache = eval(t->ch[0]) + eval(t->ch[1]) + 1; // CHANGE IT FLEXIBLE\n  t->cached = true;\n  return t->cache;\n}\nTreap *nth(Treap *t, int n) { // NTH ELEMENT\n  int l = eval(t->ch[0]);\n  if (n < l) return nth(t->ch[0], n);\n  if (n > l) return nth(t->ch[1], n-l-1);\n  return t;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct node{\n\tint key;\n\tint priority;\n\tstruct node *left;\n\tstruct node *right;\n}node;\n\n\nnode * Delete(node **,int);\nnode * _delete(node **,int);\n\nint find(node *p,int x){\n\n\twhile(p!=NULL){\n\t\tif(p->key == x)return 1;\n\t\telse if(p->key > x)p=p->left;\n\t\telse p=p->right;\n\t}\n\t\n\treturn 0;\n\t\n}\n\nvoid inorder(node *p){\n\n\tif(p->left!=NULL)inorder(p->left);\n\t\n\tprintf(\" %d\",p->key);\n\t\n\tif(p->right!=NULL)inorder(p->right);\n\t\n\treturn;\n\t\n}\n\nvoid preorder(node *p){\n\t\n\tprintf(\" %d\",p->key);\n\t\n\tif(p->left!=NULL)preorder(p->left);\n\t\n\tif(p->right!=NULL)preorder(p->right);\n\t\n\treturn;\n\t\n}\n\nvoid print(node *p){\n\n\tinorder(p);\n\tprintf(\"\\n\");\n\t\n\tpreorder(p);\n\tprintf(\"\\n\");\n\t\n\treturn;\n\t\n}\n\nnode * makenode(int x,int y){\n\tnode *new=malloc(sizeof(node));\n\tnew->key=x;\n\tnew->priority=y;\n\tnew->left=NULL;\n\tnew->right=NULL;\n\treturn new;\n}\n\nnode *rightRotate(node *p){\n\tnode *q=p->left;\n\tp->left=q->right;\n\tq->right=p;\n\treturn q;\n}\n\nnode *leftRotate(node *p){\n\tnode *q=p->right;\n\tp->right=q->left;\n\tq->left=p;\n\treturn q;\n}\n\n\nnode* insert(node **t,int key,int priority){\n\tnode *new;\n\t\n\tif((*t)==NULL)\n\t\treturn new=makenode(key,priority);\n\tif ((*t)->key==key)\n\t\treturn *t;\n\t\n\tif(key < (*t)->key){\n\t\t(*t)->left=insert(&(*t)->left,key,priority);\n\t\tif((*t)->priority < (*t)->left->priority)\n\t\t\t(*t)=rightRotate((*t));\n\t}\n\telse {\n\t\t(*t)->right=insert(&(*t)->right,key,priority);\n\t\tif((*t)->priority < (*t)->right->priority)\n\t\t\t(*t)=leftRotate((*t));\n\t}\n\t\n\treturn *t;\n}\n\n\nnode * Delete(node **t,int key){\n\tif((*t)==NULL)\n\t\treturn NULL;\n\t\t\n\tif(key < (*t)->key)\n\t\t(*t)->left=Delete(&((*t)->left),key);\n\t\t\n\telse if(key > (*t)->key)\n\t\t(*t)->right=Delete(&((*t)->right),key);\n\t\t\n\telse return _delete(t,key);\n\t\n\treturn *t;\n}\n\nnode * _delete(node **t,int key){\n\tif((*t)->left==NULL && (*t)->right==NULL)\n\t\treturn NULL;\n\telse if((*t)->left==NULL)\n\t\t(*t)=leftRotate(*t);\n\telse if((*t)->right==NULL)\n\t\t(*t)=rightRotate(*t);\n\telse {\n\t\tif((*t)->left->priority > (*t)->right->priority)\n\t\t\t(*t)=rightRotate(*t);\n\t\telse\n\t\t\t(*t)=leftRotate(*t);\n\t}\n\treturn Delete(t,key);\n}\n\n\nint main(){\n\tint n,x,y;\n\tchar com[8];\n\tnode *root=NULL;\n\t\n\tscanf(\"%d\",&n);\n\t\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%s\",com);\n\t\t\n\t\tswitch(com[0]){\n\t\t\n\t\t\tcase 'i':scanf(\"%d %d\",&x,&y);\n\t\t\t\t\t root=insert(&root,x,y);\n\t\t\t\t\t break;\n\t\t\t\n\t\t\tcase 'd':scanf(\"%d\",&x);\n\t\t\t\t\t root=Delete(&root,x);\n\t\t\t\t\t break;\n\t\t\t\n\t\t\t\n\t\t\tcase 'f':scanf(\"%d\",&x);\n\t\t\t\t\t if(find(root,x))printf(\"yes\\n\");\n\t\t\t\t\t else printf(\"no\\n\");\n\t\t\t\t\t break;\n\n\t\t\tcase 'p':print(root);\n\t\t\t\t\t break;\n\t\t\t\t\t \n\t\t}\n\t\t\n\t}\n\t\n\treturn 0;\n\t\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n \ntypedef struct node{\n    int key;\n    int priority;\n    struct node *left;\n    struct node *right;\n}node;\n \nint find(node *p,int x);\nnode * Delete(node **,int);\nnode * _delete(node **,int);\nvoid inorder(node *p);\nvoid print(node *p);\nnode * makenode(int x,int y);\nnode *rights(node *p);\nnode *lefts(node *p);\nnode* insert(node **t,int key,int priority);\n\nint main()\n{\n  int i,n,p,q;\n    char A[8];\n    node *M=NULL;\n     \n    scanf(\"%d\",&n);\n     \n    for(i=0;i<n;i++){\n        scanf(\"%s\",A);\n         \n        switch(A[0]){\n         \n            case 'i':scanf(\"%d %d\",&p,&q);\n                     M=insert(&M,p,q);\n                     break;\n             \n            case 'd':scanf(\"%d\",&p);\n                     M=Delete(&M,p);\n                     break;\n             \n             \n            case 'f':scanf(\"%d\",&p);\n                     if(find(M,p))printf(\"yes\\n\");\n                     else printf(\"no\\n\");\n                     break;\n \n            case 'p':print(M);\n                     break;\n                      \n        }\n    }\n     \n    return 0;\n     \n}\nint find(node *p,int x)\n{\n \n    while(p!=NULL){\n        if(p->key == x)return 1;\n        else if(p->key > x)p=p->left;\n        else p=p->right;\n    }\n     \n    return 0;\n     \n}\n\nnode* insert(node **t,int key,int priority)\n{\n  \n    node *new;\n     \n    if((*t)==NULL)\n        return new=makenode(key,priority);\n    if ((*t)->key==key)\n        return *t;\n     \n    if(key < (*t)->key){\n        (*t)->left=insert(&(*t)->left,key,priority);\n        if((*t)->priority < (*t)->left->priority)\n            (*t)=rights(*t);\n    }\n    \n    else {\n        (*t)->right=insert(&(*t)->right,key,priority);\n        if((*t)->priority < (*t)->right->priority)\n            (*t)=lefts(*t);\n    }\n     \n    return *t;\n}\n\nvoid preorder(node *p)\n{    \n    printf(\" %d\",p->key);\n    \n    if(p->left!=NULL)preorder(p->left);\n    \n    if(p->right!=NULL)preorder(p->right);     \n    return;\n     \n}\n \nvoid print(node *p)\n{\n    inorder(p);\n    printf(\"\\n\");\n\n    preorder(p);\n    printf(\"\\n\");\n     \n    return;\n     \n}\n \nnode * makenode(int x,int y)\n{ \n  node *new=malloc(sizeof(node));\n\n    new->key=x;\n    new->priority=y;\n    new->left=NULL;\n    new->right=NULL;\n    return new;\n}\n \nnode *rights(node *p)\n{ \n    node *q=p->left;\n    p->left=q->right;\n    q->right=p;\n    return q;\n}\n \nnode *lefts(node *p)\n{  \n    node *q=p->right;\n    p->right=q->left;\n    q->left=p;\n    return q;\n}\n \n \n\nnode * _delete(node **a,int key)\n{\n    if((*a)->left==NULL && (*a)->right==NULL)\n        return NULL;\n    \n    else if((*a)->left==NULL)\n        (*a)=lefts(*a);\n    \n    else if((*a)->right==NULL)\n        (*a)=rights(*a);\n    \n    else {\n        if((*a)->left->priority > (*a)->right->priority)\n            (*a)=rights(*a);\n        else\n            (*a)=lefts(*a);\n    }\n    \n    return Delete(a,key);\n}\n \n \nnode * Delete(node **a,int key)\n{\n    if((*a)==NULL)\n        return NULL;\n         \n    if(key < (*a)->key)\n        (*a)->left=Delete(&((*a)->left),key);\n         \n    else if(key > (*a)->key)\n        (*a)->right=Delete(&((*a)->right),key);\n         \n    else return _delete(a,key);\n     \n    return *a;\n}\n \nvoid inorder(node *p)\n{\n \n    if(p->left!=NULL)inorder(p->left);     \n    printf(\" %d\",p->key);\n    \n    if(p->right!=NULL)inorder(p->right);     \n    return;\n     \n}\n\n"
  },
  {
    "language": "C",
    "code": "//2020.1.9\n//s1270188 xxxmk2\n//alds1_08d\n\n#include<stdio.h>\n#include<stdlib.h>\n\n//struct\nstruct node{\n  int k, p;\n  struct node *l, *r;\n};\ntypedef struct node *Node;\n\n//global\nNode root=NULL;\n\n//prototype\nNode mk_Node(int, int);\nNode r_rotate(Node);\nNode l_rotate(Node);\nNode insert(Node,int, int);\nNode find(int,Node);\nvoid pr_pre(Node);\nvoid pr_in(Node);\nvoid del_all(Node);\nNode del(Node,int);\nNode ddel(Node,int);\n\n//main\nint main(){\n  int num, i, a, b;\n  char com[10];\n  \n  scanf(\"%d\",&num);\n  for(i=0;i<num;i++){\n    scanf(\"%s\",com);\n\n    if(com[0]=='i'){\n      scanf(\"%d %d\",&a,&b);\n      insert(root,a,b);\n    }\n\n    else if(com[0]=='p') {\n      pr_in(root);\n      printf(\"\\n\");\n      pr_pre(root);\n      printf(\"\\n\");\n    }\n\n    else if(com[0]=='f'){\n      scanf(\"%d\",&a);\n      if(find(a,root)==NULL) printf(\"no\\n\");\n      else printf(\"yes\\n\");\n    }\n\n    else if(com[0]=='d'){\n      scanf(\"%d\",&a);\n      del(root,a);\n    }\n  }\n\n  \n  del_all(root);\n  return 0;\n}\n\n\n//function\nNode mk_Node(int k, int p){\n  Node d;\n  d=malloc(sizeof(struct node));\n  d->k=k;\n  d->p=p;\n  return d;\n}\n\nNode r_rotate(Node t){\n  Node s=t->l;\n  t->l=s->r;\n  s->r=t;\n  if(root==t) root=s;\n  return s;\n}\n\nNode l_rotate(Node t){\n  Node s=t->r;\n  t->r=s->l;\n  s->l=t;\n  if(root==t) root=s;\n  return s;\n}\n\nNode insert(Node t,int k, int p){\n  if(t==NULL){\n    t=mk_Node(k,p);\n    if(root==NULL) root=t;\n    return t;\n  } \n  if(k==t->k) return t;\n\n  if(k < t->k){\n    t->l=insert(t->l,k,p);\n    if(t->p < t->l->p) t=r_rotate(t);\n  }\n  else{\n    t->r=insert(t->r,k,p);\n    if(t->p < t->r->p) t=l_rotate(t);\n  }\n\n  return t;\n}\n\nNode find(int n,Node d){\n  if(d->k==n) return d;\n  if(d->k>n){\n    if(d->l==NULL) return NULL;\n    else return find(n,d->l);\n  }\n  else {\n    if(d->r==NULL) return NULL;\n    else return find(n,d->r);\n  }\n}\n\nvoid pr_pre(Node data){\n  printf(\" %d\",data->k);\n  if(data->l!=NULL) pr_pre(data->l);\n  if(data->r!=NULL) pr_pre(data->r);\n}\n\nvoid pr_in(Node data){\n  if(data->l!=NULL) pr_in(data->l);\n  printf(\" %d\",data->k);\n  if(data->r!=NULL) pr_in(data->r);\n}\n\nvoid del_all(Node data){\n  if(data->l!=NULL) del_all(data->l);\n  if(data->r!=NULL) del_all(data->r);\n  free(data);\n}\n\nNode del(Node t,int n){\n  if(t==NULL) return NULL;\n  if(n<t->k) t->l=del(t->l,n);\n  else if(n>t->k) t->r=del(t->r,n);\n  else return ddel(t,n);\n  return t;\n}\n\nNode ddel(Node t,int n){\n  if(t->l==NULL && t->r==NULL) return NULL;\n  else if(t->l==NULL) t=l_rotate(t);\n  else if(t->r==NULL) t=r_rotate(t);\n  else {\n    if(t->l->p > t->r->p) t=r_rotate(t);\n    else t=l_rotate(t);\n  }\n  return del(t,n);\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\ntypedef struct node\n{\n  int key;\n  int priority;\n  struct node *parent;\n  struct node *child[2];\n} *nodePointer;\nnodePointer init(int,int);\nnodePointer insert(nodePointer,int,int);\nnodePointer find(nodePointer,int);\nnodePointer delete(nodePointer,int);\nnodePointer _delete(nodePointer,int);\nvoid preorderWalk(nodePointer);\nvoid inorderWalk(nodePointer);\nnodePointer rightRotate(nodePointer);\nnodePointer leftRotate(nodePointer);\nnodePointer root=NULL;\nint main(void)\n{\n  int i;//counter\n  int n;//the number of operation\n  int key,priority;\n  char op[10];//operation\n  nodePointer p;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%s\",op);\n      if(strcmp(op,\"insert\")==0)\n\t{\n\t  scanf(\"%d%d\",&key,&priority);\n\t  root=insert(root,key,priority);\n\t}\n      else if(strcmp(op,\"find\")==0)\n\t{\n\t  scanf(\"%d\",&key);\n\t  if(find(root,key)!=NULL) printf(\"yes\\n\");\n\t  else printf(\"no\\n\");\n\t}\n      else if(strcmp(op,\"delete\")==0)\n\t{\n\t  scanf(\"%d\",&key);\n\t  root=delete(root,key);\n\t}\n      else if(strcmp(op,\"print\")==0)\n\t{\n\t  inorderWalk(root);\n\t  printf(\"\\n\");\n\t  preorderWalk(root);\n\t  printf(\"\\n\");\n\t}\n      else\n\t{\n\t  fprintf(stderr,\"undefined operation\\n\");\n\t  exit(1);\n\t}\n    }\n  return 0;\n}\nnodePointer init(int key,int priority)\n{\n  nodePointer p=(nodePointer)malloc(sizeof(struct node));\n  p->key=key;\n  p->priority=priority;\n  p->parent=NULL;\n  p->child[0]=NULL;\n  p->child[1]=NULL;\n  return p;\n}\nnodePointer insert(nodePointer p,int key,int priority)\n{\n  if(p==NULL) return init(key,priority);\n  if(key == p->key) return p;\n  if(key < p->key)\n    {\n      p->child[0]=insert(p->child[0],key,priority);\n      if(p->priority < p->child[0]->priority) p=rightRotate(p);\n    }\n  if(key > p->key)\n    {\n      p->child[1]=insert(p->child[1],key,priority);\n      if(p->priority < p->child[1]->priority) p=leftRotate(p);\n    }\n  return p;\n}\nnodePointer find(nodePointer p,int key)\n{\n  if(p==NULL) return NULL;\n  if(p->key < key) return find(p->child[1],key);\n  if(p->key == key) return p;\n  if(p->key > key) return find(p->child[0],key);\n}\nnodePointer delete(nodePointer p,int key)\n{\n  if(p==NULL) return NULL;\n  if(key < p->key) p->child[0]=delete(p->child[0],key);\n  else if(key > p->key) p->child[1]=delete(p->child[1],key);\n  else return _delete(p,key);\n  return p;\n}\nnodePointer _delete(nodePointer p,int key)\n{\n  if(p->child[0]==NULL&&p->child[1]==NULL) return NULL;\n  else if(p->child[0]==NULL) p=leftRotate(p);\n  else if(p->child[1]==NULL) p=rightRotate(p);\n  else\n    {\n      if(p->child[0]->priority > p->child[1]->priority) p=rightRotate(p);\n      else p=leftRotate(p);\n    }\n  return delete(p,key);\n}\nvoid preorderWalk(nodePointer p)\n{\n  if(p==NULL) return;\n  printf(\" %d\",p->key);\n  preorderWalk(p->child[0]);\n  preorderWalk(p->child[1]);\n}\nvoid inorderWalk(nodePointer p)\n{\n  if(p==NULL) return;\n  inorderWalk(p->child[0]);\n  printf(\" %d\",p->key);\n  inorderWalk(p->child[1]);\n}\nnodePointer rightRotate(nodePointer p)\n{\n  nodePointer s=p->child[0];\n  p->child[0]=s->child[1];\n  s->child[1]=p;\n  return s;\n}\nnodePointer leftRotate(nodePointer p)\n{\n  nodePointer s=p->child[1];\n  p->child[1]=s->child[0];\n  s->child[0]=p;\n  return s;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#define NIL NULL\n\nstruct Node{\n\tint key;\n\tint priority;\n\tstruct Node *r,*l,*p;\n}Node;\n\nstruct Node *Delete(struct Node **t, int key);\nstruct Node *_delete(struct Node **t, int key);\n\n\n\n/*\nvoid insert( int k ){\n\tstruct Node *y = NIL;\n\tstruct Node *x = root;\n\tstruct Node *z;\n\t\n\tz = ( struct Node *)malloc( sizeof(struct Node) );\n\tz->key = k;\n\tz->l = NIL;\n\tz->r = NIL;\n\t\n\twhile( x != NIL ){\n\t\ty = x;\n\t\tif( z->key < x->key ){\n\t\t\tx = x->l;\n\t\t}else{\n\t\t\tx = x->r;\n\t\t}\n\t}\n\tz->p = y;\n\t\n\tif( y == NIL ){\n\t\troot = z;\n\t}else{\n\t\tif( z->key < y->key ){\n\t\t\ty->l = z;\n\t\t}else{\n\t\t\ty->r = z;\n\t\t}\n\t}\n}\n*/\n\nvoid preorder( struct Node *u ){\n\t\n\tprintf(\" %d\",u->key);\n\tif(u->l!=NIL){\n\t\tpreorder(u->l);\n\t}\n\tif(u->r!=NIL){\n\t\tpreorder(u->r);\n\t}\n\treturn;\n}\n\nvoid inorder( struct Node *u ){\n\t\n\tif(u->l!=NIL){\n\t\tinorder(u->l);\n\t}\n\tprintf(\" %d\",u->key);\n\tif(u->r!=NIL){\n\t\tinorder(u->r);\n\t}\n\treturn;\n\t\n}\n\nint find( struct Node *u , int k ){\n\twhile( u != NIL ){\n\t\tif( u->key == k ){\n\t\t\treturn 1;\n\t\t}else if( k < u->key ){\n\t\t\tu = u->l;\n\t\t}else{\n\t\t\tu = u->r;\n\t\t}\n\t}\n\treturn 0;\n}\n/*\nstruct Node * treeMinimum( struct Node *x ){\n\twhile( x->l != NIL ){\n\t\tx = x-> l;\n\t}\n\treturn x;\n}\n\nstruct Node * treeSuccessor( struct Node *x ){\n\tif( x->r != NIL ){\n\t\treturn treeMinimum( x->r );\n\t}\n\tstruct Node *y = x->p;\n\t\n\twhile( y != NIL && x == y->r ){\n\t\tx = y;\n\t\ty = y->p;\n\t}\n\treturn y;\n}\n\nvoid treeDelete(struct Node *z ){\n\tstruct Node *y;\n\tstruct Node *x;\n\t\n\tif( z->l == NIL || z->r == NIL ){\n\t\ty = z;\n\t}else{\n\t\ty = treeSuccessor(z);\n\t}\n\t\n\tif( y->l != NIL ){\n\t\tx = y->l;\n\t}else{\n\t\tx = y->r;\n\t}\n\t\n\tif( x != NIL ){\n\t\tx->p = y->p;\n\t}\n\t\n\tif( y->p == NIL ){\n\t\troot = x;\n\t}else{\n\t\tif( y == y->p->l ){\n\t\t\ty->p->l = x;\n\t\t}else{\n\t\t\ty->p->r = x;\n\t\t}\n\t}\n\t\n\tif( y != z ){\n\t\tz->key = y->key;\n\t}\n\t\n\tfree(y);\n}\n*/\n\nstruct Node *rightRotate(struct Node *t){\n    struct Node *s = t->l;\n    t->l = s->r;\n    s->r = t;\n    return s;\n}\n\nstruct Node *leftRotate(struct Node *t){\n    struct Node *s = t->r;\n    t->r = s->l;\n    s->l = t;\n    return s;\n}\n\nstruct Node* node( int x , int y ){\n\t\n\tstruct Node *new = malloc(sizeof(Node));\n\tnew->key = x;\n\tnew->priority = y;\n\tnew->l = NIL;\n\tnew->r = NIL;\n\t\n\treturn new;\n}\n\nstruct Node* insert(struct Node **t, int key, int priority){   // 再帰的に探索\n\t\n\tstruct Node *new;\n\tif( *t == NIL ){\n        return new = node(key, priority);                      // 葉に到達したら新しい節点を生成して返す\n\t}\n\tif( key == (*t)->key ){\n        return *t;                                             // 重複したkeyは無視\n\t}\n\n\tif( key < (*t)->key ){                                     // 左の子へ移動\n\t\t(*t)->l = insert(&(*t)->l, key, priority);             // 左の子へのポインタを更新\n\t\tif ( (*t)->priority < (*t)->l->priority ){             // 左の子の方が優先度が高い場合右回転\n            *t = rightRotate(*t);\n\t\t}\n\t}else{                                                     // 右の子へ移動\n\t\t(*t)->r = insert(&(*t)->r, key, priority);             // 右の子へのポインタを更新\n\t\tif( (*t)->priority < (*t)->r->priority ){              // 右の子の方が優先度が高い場合左回転\n            *t = leftRotate(*t);\n\t\t}\n\t}\n\treturn *t;\n}\n\nstruct Node *Delete(struct Node **t, int key){\n\t\n\tif ((*t) == NIL){\n\t\treturn NIL;\n\t}\n\tif ( key < (*t)->key ){                                    // 削除対象を検索\n\t\t(*t)->l = Delete(&((*t)->l), key);\n\t}else if ( key > (*t)->key ){\n\t\t(*t)->r = Delete(&((*t)->r), key);\n\t}else{\n        return _delete(t, key);\n\t}\n    return *t;\n}\n\nstruct Node *_delete(struct Node **t, int key){                // 削除対象の節点の場合\n\t\tif ((*t)->l == NIL && (*t)->r == NIL ){                // 葉の場合\n        \treturn NIL;\n\t\t}else if ( (*t)->l == NIL ){                           // 右の子のみを持つ場合左回転\n        \t*t = leftRotate(*t);\n\t\t}else if ((*t)->r == NIL){                             // 左の子のみを持つ場合右回転\n        \t*t = rightRotate(*t);\n\t\t}else{                                                 // 左の子と右の子を両方持つ場合\n\t\t\tif ((*t)->l->priority > (*t)->r->priority ){       // 優先度が高い方を持ち上げる\n            \t*t = rightRotate(*t);\n\t\t\t}\n\t\t\telse{\n            \t*t = leftRotate(*t);\n\t\t\t}\n\t\t}\n    return Delete(t, key);\n}\n\nint main( void ){\n\t\n\tint n , i , x , y;\n\tchar com[10];\n\tstruct Node *root = NIL;\n\t\n\tscanf( \"%d\" , &n );\n\t\n\tfor( i = 0; i < n; i++ ){\n\t\t\n\t\tscanf( \"%s\" , com );\n\t\tif( strcmp(com , \"find\") == 0 ) {\n\t\t\tscanf( \"%d\" , &x );\n\t\t\tif( find(root,x) ){\n\t\t\t\tprintf( \"yes\\n\" );\n\t\t\t}else{\n\t\t\t\tprintf( \"no\\n\" );\n\t\t\t}\n\t\t}else if( strcmp(com ,\"insert\") == 0 ){\n\t\t\tscanf(\"%d %d\",&x,&y);\n\t\t\troot = insert(&root,x,y);\n\t\t}else if( strcmp(com ,\"print\") == 0 ){\n\t\t\tinorder(root);\n\t\t\tprintf( \"\\n\" );\n\t\t\tpreorder(root);\n\t\t\tprintf( \"\\n\" );\n\t\t}else if( strcmp(com ,\"delete\") == 0 ){\n\t\t\tscanf( \"%d\" , &x );\n\t\t\troot = Delete(&root,x);\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\t\t\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) {\n        n = 10 * n + (c & 0xf);\n        c = getchar_unlocked();\n    }\n    return n;\n}\nint get_str(char *str) {\n    int c;\n    while((c = getchar_unlocked()) > 32) *str++ = (char)c;\n    *str = 0;\n    return c;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\nvoid put_str(char *str) { while(*str) putchar_unlocked(*str++); }\n\ntypedef struct Node {\n    int key;\n    int priority;\n    struct Node *left, *right;\n} Node;\ntypedef struct BST {\n    Node *root;\n    size_t size;\n} BST;\nvoid bst_init(BST *BST) {\n    BST->root = NULL;\n    BST->size = 0;\n}\nNode *bst_rotate_right(Node *root) {\n    Node *tmp = root->left;\n    root->left = tmp->right;\n    tmp->right = root;\n    return tmp;\n}\nNode *bst_rotate_left(Node *root) {\n    Node *tmp = root->right;\n    root->right = tmp->left;\n    tmp->left = root;\n    return tmp;\n}\nNode *bst__insert(Node *root, int key, int priority) {\n    if(root == NULL) {\n        Node *new_node = malloc(sizeof(Node));\n        new_node->key = key;\n        new_node->priority = priority;\n        new_node->left = new_node->right = NULL;\n        return new_node;\n    }\n    if(key == root->key) return root;\n    if(key < root->key) {\n        root->left = bst__insert(root->left, key, priority);\n        if(root->priority < root->left->priority) root = bst_rotate_right(root);\n    } else {\n        root->right = bst__insert(root->right, key, priority);\n        if(root->priority < root->right->priority) root = bst_rotate_left(root);\n    }\n    return root;\n}\nvoid bst_insert(BST *BST, int key, int priority) {\n    Node *node = bst__insert(BST->root, key, priority);\n    if(BST->size == 0) BST->root = node;\n    BST->size++;\n}\nNode *bst_find(const Node *root, const int key) {\n    while(root != NULL && root->key != key) {\n        if(key < root->key) root = root->left;\n        else root = root->right;\n    }\n    return root;\n}\nNode *bst_get_min(Node *root) {\n    while(root->left != NULL) root = root->left;\n    return root;\n}\nNode *bst__delete(Node *root, int key) {\n    if(root == NULL) return NULL;\n    if(key < root->key) root->left = bst__delete(root->left, key);\n    else if(key > root->key) root->right = bst__delete(root->right, key);\n    else if(root->left && root->right) {\n        if(root->left->priority > root->right->priority) root = bst_rotate_right(root);\n        else root = bst_rotate_left(root);\n        root = bst__delete(root, key);\n    } else {\n        Node *tmp = root;\n        if(root->left) {\n            root = bst_rotate_right(root);\n            root->right = NULL;\n        }\n        else if(root->right) {\n            root = bst_rotate_left(root);\n            root->left = NULL;\n        }\n        else root = NULL;\n        free(tmp);\n    }\n    return root;\n}\nvoid bst_delete(BST *BST, int key) {\n    BST->root = bst__delete(BST->root, key);\n    BST->size--;\n}\nvoid bst_inorder(Node *root) {\n    if(root == NULL) return;\n    bst_inorder(root->left);\n    putchar_unlocked(' '), put_uint(root->key);\n    bst_inorder(root->right);\n}\nvoid bst_preorder(Node *root) {\n    if(root == NULL) return;\n    putchar_unlocked(' '), put_uint(root->key);\n    bst_preorder(root->left);\n    bst_preorder(root->right);\n}\nint main(int argc, char **argv) {\n    BST BST;\n    bst_init(&BST);\n    int m = get_uint();\n    int key, priority;\n    char c[8];\n    for(int i = 0; i < m; ++i) {\n        get_str(c);\n        switch(*c) {\n        case 'i':\n            key = get_uint();\n            priority = get_uint();\n            bst_insert(&BST, key, priority);\n            break;\n        case 'f':\n            key = get_uint();\n            put_str(bst_find(BST.root, key) ? \"yes\\n\" : \"no\\n\");\n            break;\n        case 'd':\n            key = get_uint();\n            bst_delete(&BST, key);\n            break;\n        default:\n            bst_inorder(BST.root);\n            putchar_unlocked('\\n');\n            bst_preorder(BST.root);\n            putchar_unlocked('\\n');\n            break;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct node{\n  int key, priority;\n  struct node *left;\n  struct node *right;\n}node;\n\nint find(node *p, int x){\n  while(p != NULL){\n    if(p->key == x)     return 1;\n    else if(p->key > x) p = p->left;\n    else                p = p->right;\n  }\n  return 0;\n}\n\nvoid inorder(node *p){\n  if(p->left != NULL)   inorder(p->left);\t\n  printf(\" %d\", p->key);\t\n  if(p->right != NULL)  inorder(p->right);\t \n  return;\t\n}\n\nvoid preorder(node *p){\n  printf(\" %d\", p->key);\n  if(p->left != NULL)   preorder(p->left);\n  if(p->right != NULL)  preorder(p->right);\n  return;\n\t\n}\n\nvoid print(node *p){\n  inorder(p);\n  printf(\"\\n\");\n  preorder(p);\n  printf(\"\\n\");\n  return;\n}\n\nnode * makenode(int x,int y){\n  node *new = malloc(sizeof(node));\n  new->key = x;\n  new->priority = y;\n  new->left = NULL;\n  new->right = NULL;\n  return new;\n}\n\nnode *rightRotate(node *p){\n  node *q  = p->left;\n  p->left  = q->right;\n  q->right = p;\n  return q;\n}\n\nnode *leftRotate(node *p){\n  node *q  = p->right;\n  p->right = q->left;\n  q->left  = p;\n  return q;\n}\n\n\nnode* insert(node **t, int key, int priority){\n  node *new;\n\t\n  if((*t) == NULL)\n    return new = makenode(key, priority);\n  if ((*t)->key == key)\n    return *t;\n\t\n  if(key < (*t)->key){\n    (*t)->left = insert(&(*t)->left, key, priority);\n    if((*t)->priority < (*t)->left->priority)\n      (*t) = rightRotate((*t));\n  }\n  else{\n    (*t)->right = insert(&(*t)->right, key, priority);\n    if((*t)->priority < (*t)->right->priority)\n      (*t) = leftRotate((*t));\n  }\n\t\n  return *t;\n}\n\nnode *Delete(node **,int);\nnode *_delete(node **,int);\n\nnode * Delete(node **t, int key){\n  if((*t) == NULL)\n    return NULL;\n\t\t\n  if(key < (*t)->key)       (*t)->left = Delete(&((*t)->left),key);\n  else if(key > (*t)->key)  (*t)->right = Delete(&((*t)->right),key);\t\n  else                      return _delete(t,key);\n  return *t;\n}\n\nnode * _delete(node **t,int key){\n  if((*t)->left == NULL && (*t)->right == NULL) return NULL;\n  else if((*t)->left == NULL)                   (*t) = leftRotate(*t);\n  else if((*t)->right == NULL)                  (*t) = rightRotate(*t);\n  else{\n    if((*t)->left->priority > (*t)->right->priority)    (*t) = rightRotate(*t);\n    else                                                (*t) = leftRotate(*t);\n  }\n  return Delete(t,key);\n}\n\n\nint main(){\n  int n, x, y;\n  char com[8];\n  node *root = NULL;\n\t\n  scanf(\"%d\", &n);\n\t\n  for(int i=0 ; i<n ; i++){\n    scanf(\"%s\", com);\n\t\t\n    switch(com[0]){\n\t\t\n    case 'i' : scanf(\"%d %d\", &x, &y);\n      root = insert(&root, x, y);\n      break;\n\t\t\t\n    case 'd' : scanf(\"%d\", &x);\n      root = Delete(&root, x);\n      break;\n\t\t\t\t\t\n    case 'f' : scanf(\"%d\", &x);\n      if(find(root,x)) printf(\"yes\\n\");\n      else printf(\"no\\n\");\n      break;\n\n    case 'p' : print(root);\n      break;\n    }\t\n  }\n\t\n  return 0;\t\n}\n\n"
  },
  {
    "language": "C",
    "code": "/* BinaryTree + Heap */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\nstruct node\n{\n    struct node *left;\n    struct node *right;\n    int key;\n    int priority;\n};\n\nstruct node *delete(struct node *T, int key);\nstruct node *_delete(struct node *T, int key);\n\nstruct node *rightRotate(struct node *T)\n{\n    struct node *s = T->left;\n    T->left = s->right;\n    s->right = T;\n    return s;\n}\n\nstruct node *leftRotate(struct node *T)\n{\n    struct node *s = T->right;\n    T->right = s->left;\n    s->left = T;\n    return s;\n}\n\nstruct node *makenode(int key, int priority)\n{\n    struct node *new = (struct node *)malloc(sizeof(struct node));\n    new->key = key;\n    new->priority = priority;\n    new->left = NULL;\n    new->right = NULL;\n\n    return new;\n}\n\n/* 再帰的に探索 */\nstruct node *insert(struct node *T, int key, int priority)\n{\n    if (T == NULL)\n    {\n        return makenode(key, priority);\n    }\n    if (key == T->key) // 重複したkeyは無視\n    {\n        return T;\n    }\n    if (key < T->key)\n    {\n        T->left = insert(T->left, key, priority);\n        if (T->priority < (T->left)->priority) // 左の子の方が優先度が高い場合右回転\n        {\n            T = rightRotate(T);\n        }\n    }\n    else\n    {\n        T->right = insert(T->right, key, priority);\n        if (T->priority < (T->right)->priority) // 右の子の方が優先度が高い場合左回転\n        {\n            T = leftRotate(T);\n        }\n    }\n    return T;\n}\n\n/* 削除対象の接点を探索 */\nstruct node *delete(struct node *T, int key)\n{\n    if (T == NULL)\n    {\n        return NULL;\n    }\n    if (key < T->key)\n    {\n        T->left = delete(T->left, key);\n    }\n    else if (key > T->key)\n    {\n        T->right = delete(T->right, key);\n    }\n    else\n    {\n        return _delete(T, key);\n    }\n    return T;\n}\n\n/* 削除対象の接点の場合 */\nstruct node *_delete(struct node *T, int key)\n{\n\n    if (T->left == NULL && T->right == NULL) // 葉の場合\n    {\n        return NULL;\n    }\n    else if (T->left == NULL) // 右の子のみを持つ場合\n    {\n        T = leftRotate(T);\n    }\n    else if (T->right == NULL) // 左の子のみを持つ場合\n    {\n        T = rightRotate(T);\n    }\n    else // 両方の子を持つ場合\n    {\n        if ((T->left)->priority > (T->right)->priority) // 優先度が高い方を持ち上げる\n        {\n            T = rightRotate(T);\n        }\n        else\n        {\n            T = leftRotate(T);\n        }\n    }\n    return delete(T, key);\n}\n\nint find(struct node *T, int key)\n{\n    struct node *x = T;\n    while (x != NULL)\n    {\n        if (key == x->key)\n        {\n            return 1;\n        }\n        else if (key < x->key)\n        {\n            x = x->left;\n        }\n        else\n        {\n            x = x->right;\n        }\n    }\n    return 0;\n}\n\nvoid inorder_tree_work(struct node *T)\n{\n    if (T != NULL)\n    {\n        inorder_tree_work(T->left);\n        printf(\" %d\", T->key);\n        inorder_tree_work(T->right);\n    }\n}\n\nvoid preorder_tree_work(struct node *T)\n{\n    if (T != NULL)\n    {\n        printf(\" %d\", T->key);\n        preorder_tree_work(T->left);\n        preorder_tree_work(T->right);\n    }\n}\n\nint main(void)\n{\n    struct node *Tree = NULL;\n    int n;\n    int k, p; // key, priority\n    char command[10];\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%s\", command);\n        if (command[0] == 'p')\n        {\n            inorder_tree_work(Tree);\n            printf(\"\\n\");\n            preorder_tree_work(Tree);\n            printf(\"\\n\");\n        }\n        else if (command[0] == 'd')\n        {\n            scanf(\"%d\", &k);\n            Tree = delete(Tree, k);\n        }\n        else if (command[0] == 'i')\n        {\n            scanf(\"%d%d\", &k, &p);\n            Tree = insert(Tree, k, p);\n        }\n        else if (command[0] == 'f')\n        {\n            scanf(\"%d\", &k);\n            if (find(Tree, k))\n            {\n                printf(\"yes\\n\");\n            }\n            else\n            {\n                printf(\"no\\n\");\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nstruct node {\n  int key;\n  int priority;\n  struct node *right;\n  struct node *left;\n  struct node *parent;\n};\n\ntypedef struct node* Nodepointer;\nNodepointer nil, root;\n\nNodepointer delete(Nodepointer*, int);\nNodepointer _delete(Nodepointer*, int);\n\nNodepointer Node(int key, int priority){\n Nodepointer z;\n  z = (Nodepointer)malloc(sizeof(struct node));\n  z->key = key;\n  z->priority = priority;\n  z->left = nil;\n  z->right = nil;\n  return z;\n}\n\nNodepointer rightRotate(Nodepointer t){\n  Nodepointer s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\n\nNodepointer leftRotate(Nodepointer t){\n  Nodepointer s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\n\nNodepointer insert(Nodepointer *t, int key, int priority){\n  if( (*t) == nil ) return Node(key, priority);\n  if( key == (*t)->key ) return *t;\n\n  if( key < (*t)->key ){\n    (*t)->left = insert(&(*t)->left, key, priority);\n    if( (*t)->priority < (*t)->left->priority ) (*t) = rightRotate((*t));\n  }\n  else{\n    (*t)->right = insert(&(*t)->right, key, priority);\n    if( (*t)->priority < (*t)->right->priority ) (*t) = leftRotate((*t));\n  }\n  return *t;\n}\n\n\nNodepointer delete(Nodepointer *t, int key){\n  if( (*t) == nil ) return nil;\n  if( key < (*t)->key ) (*t)->left = delete(&(*t)->left, key);\n  else if( key > (*t)->key ) (*t)->right = delete(&(*t)->right, key);\n  else {\n    return _delete(t, key);\n  }\n  return *t;\n}\n\nNodepointer _delete(Nodepointer *t, int key){\n  if( (*t)->left == nil && (*t)->right == nil ) return nil;\n  else if( (*t)->left == nil ) (*t) = leftRotate(*t);\n  else if( (*t)->right == nil ) (*t) = rightRotate(*t);\n  else {\n    if( (*t)->left->priority > (*t)->right->priority ) (*t) = rightRotate(*t);\n    else (*t) = leftRotate(*t);\n  }\n  return delelte(t, key);\n}\n\n\nNodepointer find(Nodepointer u, int k){\n  while( u != nil && k != u->key ){\n    if( k < u->key ) u = u->left;\n    else u = u->right;\n  }\n  return u;\n}\n\nvoid inorder(Nodepointer u){\n  if( u->left != nil ) inorder(u->left);\n  printf(\" %d\", u->key);\n  if( u->right != nil ) inorder(u->right);\n  return;\n}\n\nvoid preorder(Nodepointer u){\n  printf(\" %d\", u->key);\n  if( p->left != nil ) preorder(u->left);\n  if( p->right != nil ) preorder(u->right);\n  return;\n}\n\nvoid print(Nodepointer u){\n  inorder(u);\n  printf(\"\\n\");\n  preorder(u);\n  printf(\"\\n\");\n  return;\n}\n\nint main(){\n  int m, i, x, y;\n  char com[8];\n  Nodepointer t=nil;\n\n  scanf(\"%d\", &m);\n\n  for( i = 0 ; i < m ; i++ ){\n    scanf(\"%s\",com);\n    if( com[0] == 'f' ){\n      scanf(\"%d\", &x);\n      t = find(root, x);\n      if( t != nil ) printf(\"yes\\n\");\n      else printf(\"no\\n\");\n    }\n    else if( strcmp(\"insert\",com) == 0 ){\n      scanf(\"%d%d\", &x, &y);\n      insert(&root,x,y);\n    }\n    else if( strcmp(\"print\",com) == 0 ){\n      print(root);\n    }\n    else if( strcmp(\"delete\", com) == 0 ){\n      scanf(\"%d\", &x);\n      root = delete(&root, x);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct node{\n  int key, priority;\n  struct node *left;\n  struct node *right;\n}node;\n\n\nnode * Delete(node **,int);\nnode * _delete(node **,int);\n\nint find(node *p,int x){\n\n  while(p != NULL){\n    if(p->key == x) return 1;\n    else if(p->key > x) p = p->left;\n    else p = p->right;\n  }\n\t\n  return 0;\n\t\n}\n\nvoid inorder(node *p){\n\n  if(p->left != NULL) inorder(p->left);\n\t\n  printf(\" %d\", p->key);\n\t\n  if(p->right != NULL) inorder(p->right);\n\t \n  return;\n\t\n}\n\nvoid preorder(node *p){\n\t\n  printf(\" %d\", p->key);\n\t\n  if(p->left != NULL) preorder(p->left);\n\t\n  if(p->right != NULL) preorder(p->right);\n\t\n  return;\n\t\n}\n\nvoid print(node *p){\n\n  inorder(p);\n  printf(\"\\n\");\n\t\n  preorder(p);\n  printf(\"\\n\");\n\t\n  return;\n\t\n}\n\nnode * makenode(int x,int y){\n  node *new = malloc(sizeof(node));\n  new->key = x;\n  new->priority = y;\n  new->left = NULL;\n  new->right = NULL;\n  return new;\n}\n\nnode *rightRotate(node *p){\n  node *q = p->left;\n  p->left = q->right;\n  q->right = p;\n  return q;\n}\n\nnode *leftRotate(node *p){\n  node *q = p->right;\n  p->right = q->left;\n  q->left = p;\n  return q;\n}\n\n\nnode* insert(node **t, int key, int priority){\n  node *new;\n\t\n  if((*t) == NULL)\n    return new = makenode(key,priority);\n  if ((*t)->key == key)\n    return *t;\n\t\n  if(key < (*t)->key){\n    (*t)->left = insert(&(*t)->left, key, priority);\n    if((*t)->priority < (*t)->left->priority)\n      (*t) = rightRotate((*t));\n  }\n  else {\n    (*t)->right = insert(&(*t)->right, key, priority);\n    if((*t)->priority < (*t)->right->priority)\n      (*t) = leftRotate((*t));\n  }\n\t\n  return *t;\n}\n\n\nnode * Delete(node **t, int key){\n  if((*t) == NULL)\n    return NULL;\n\t\t\n  if(key < (*t)->key)\n    (*t)->left = Delete(&((*t)->left),key);\n\t\t\n  else if(key > (*t)->key)\n    (*t)->right = Delete(&((*t)->right),key);\n\t\t\n  else return _delete(t,key);\n\t\n  return *t;\n}\n\nnode * _delete(node **t,int key){\n  if((*t)->left == NULL && (*t)->right == NULL)\n    return NULL;\n  else if((*t)->left == NULL)\n    (*t) = leftRotate(*t);\n  else if((*t)->right == NULL)\n    (*t) = rightRotate(*t);\n  else {\n    if((*t)->left->priority > (*t)->right->priority)\n      (*t) = rightRotate(*t);\n    else\n      (*t) = leftRotate(*t);\n  }\n  return Delete(t,key);\n}\n\n\nint main(){\n  int i, n, x, y;\n  char com[8];\n  node *root = NULL;\n\t\n  scanf(\"%d\", &n);\n\t\n  for(i = 0 ; i < n ; i++){\n    scanf(\"%s\", com);\n\t\t\n    switch(com[0]){\n\t\t\n    case 'i':scanf(\"%d %d\", &x, &y);\n      root = insert(&root, x, y);\n      break;\n\t\t\t\n    case 'd':scanf(\"%d\", &x);\n      root = Delete(&root, x);\n      break;\n\t\t\t\n\t\t\t\n    case 'f':scanf(\"%d\", &x);\n      if(find(root,x)) printf(\"yes\\n\");\n      else printf(\"no\\n\");\n      break;\n\n    case 'p':print(root);\n      break;\n    }\t\n  }\n\t\n  return 0;\t\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 41\n\ntypedef struct node{\n  int l, r;\n}node;\n\nnode c[N];\nint a[N];\nint b[N];\nint cnt=0;\n\nvoid postorder(int root,int n){\n\n        if(c[root].l != -1) postorder(c[root].l, n);\n\n        if(c[root].r != -1) postorder(c[root].r, n);\n\n        if(cnt < n-1) printf(\"%d \", root);\n        else printf(\"%d\\n\", root);\n\n        cnt++;\n\n        return;\n}\n\nint reconst(int start,int last,int n){\n  int i, j;\n\n  if(start==last) return b[start];\n  else if(start > last) return -1;\n\n  else{\n    for(i = 1 ; i <= n ; i++){\n      for(j = start ; j <= last ; j++){\n        if(a[i] == b[j]){\n          c[a[i]].l = reconst(start, j - 1, n);\n          c[a[i]].r = reconst(j + 1, last, n);\n          return a[i];\n        }\n      }\n    }\n  }\n}\n\n\nint main(){\n  int n, i, root;\n\n  scanf(\"%d\", &n);\n\n  for(i = 1 ; i <= n ; i++){\n    scanf(\"%d\",&a[i]);\n    scanf(\"%d\",&b[i]);\n    c[i].l = -1;\n    c[i].r = -1;\n  }\n\n  root = reconst(1, n, n);\n  postorder(root, n);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n\n// I/O\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) {\n        n = 10 * n + (c & 0xf);\n        c = getchar_unlocked();\n    }\n    return n;\n}\nint get_str(char *str) {\n    int c;\n    while((c = getchar_unlocked()) > 32) *str++ = (char)c;\n    *str = 0;\n    return c;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\nvoid put_str(char *str) { while(*str) putchar_unlocked(*str++); }\n//\n\n\n// Treap\ntypedef struct Node {\n    int key;\n    int priority;\n    struct Node *left, *right;\n} Node;\ntypedef struct BST {\n    Node *root;\n    size_t size;\n} BST;\nvoid bst_init(BST *BST) {\n    BST->root = NULL;\n    BST->size = 0;\n}\nNode *bst_rotate_right(Node *root) {\n    Node *tmp = root->left;\n    root->left = tmp->right;\n    tmp->right = root;\n    return tmp;\n}\nNode *bst_rotate_left(Node *root) {\n    Node *tmp = root->right;\n    root->right = tmp->left;\n    tmp->left = root;\n    return tmp;\n}\nNode *bst__insert(Node *root, int key, int priority) {\n    if(root == NULL) {\n        Node *new_node = malloc(sizeof(Node));\n        new_node->key = key;\n        new_node->priority = priority;\n        new_node->left = new_node->right = NULL;\n        return new_node;\n    }\n    if(key == root->key) return root;\n    if(key < root->key) {\n        root->left = bst__insert(root->left, key, priority);\n        if(root->priority < root->left->priority) root = bst_rotate_right(root);\n    } else {\n        root->right = bst__insert(root->right, key, priority);\n        if(root->priority < root->right->priority) root = bst_rotate_left(root);\n    }\n    return root;\n}\nvoid bst_insert(BST *BST, int key, int priority) {\n    BST->root = bst__insert(BST->root, key, priority);\n    BST->size++;\n}\nNode *bst_find(const Node *root, const int key) {\n    while(root != NULL && root->key != key) {\n        if(key < root->key) root = root->left;\n        else root = root->right;\n    }\n    return root;\n}\nNode *bst_get_min(Node *root) {\n    while(root->left != NULL) root = root->left;\n    return root;\n}\nNode *bst__delete(Node *root, int key) {\n    if(root == NULL) return NULL;\n    if(key < root->key) root->left = bst__delete(root->left, key);\n    else if(key > root->key) root->right = bst__delete(root->right, key);\n    else if(root->left && root->right) {\n        if(root->left->priority > root->right->priority) root = bst_rotate_right(root);\n        else root = bst_rotate_left(root);\n        root = bst__delete(root, key);\n    } else {\n        Node *tmp = root;\n        if(root->left) {\n            root = bst_rotate_right(root);\n            root->right = bst__delete(root->right, key);\n        }\n        else if(root->right) {\n            root = bst_rotate_left(root);\n            root->left = bst__delete(root->left, key);\n        }\n        else {\n            root = NULL;\n            free(tmp);\n        }\n    }\n    return root;\n}\nvoid bst_delete(BST *BST, int key) {\n    BST->root = bst__delete(BST->root, key);\n    BST->size--;\n}\nvoid bst_inorder(Node *root) {\n    if(root == NULL) return;\n    bst_inorder(root->left);\n    putchar_unlocked(' '), put_uint(root->key);\n    bst_inorder(root->right);\n}\nvoid bst_preorder(Node *root) {\n    if(root == NULL) return;\n    putchar_unlocked(' '), put_uint(root->key);\n    bst_preorder(root->left);\n    bst_preorder(root->right);\n}\n//\n\n\nint main(int argc, char **argv) {\n    BST BST;\n    bst_init(&BST);\n    int m = get_uint();\n    int key, priority;\n    char c[8];\n    for(int i = 0; i < m; ++i) {\n        get_str(c);\n        switch(*c) {\n        case 'i':\n            key = get_uint();\n            priority = get_uint();\n            bst_insert(&BST, key, priority);\n            break;\n        case 'f':\n            key = get_uint();\n            put_str(bst_find(BST.root, key) ? \"yes\\n\" : \"no\\n\");\n            break;\n        case 'd':\n            key = get_uint();\n            bst_delete(&BST, key);\n            break;\n        default:\n            bst_inorder(BST.root);\n            putchar_unlocked('\\n');\n            bst_preorder(BST.root);\n            putchar_unlocked('\\n');\n            break;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n \ntypedef struct node{\n    int key;\n    int priority;\n    struct node *left;\n    struct node *right;\n}node;\n \n \nnode * Delete(node **,int);\nnode * _delete(node **,int);\n \nint find(node *p,int x){\n \n    while(p!=NULL){\n        if(p->key == x)return 1;\n        else if(p->key > x)p=p->left;\n        else p=p->right;\n    }\n     \n    return 0;\n     \n}\n \nvoid inorder(node *p){\n \n    if(p->left!=NULL)inorder(p->left);\n     \n    printf(\" %d\",p->key);\n     \n    if(p->right!=NULL)inorder(p->right);\n     \n    return;\n     \n}\n \nvoid preorder(node *p){\n     \n    printf(\" %d\",p->key);\n     \n    if(p->left!=NULL)preorder(p->left);\n     \n    if(p->right!=NULL)preorder(p->right);\n     \n    return;\n     \n}\n \nvoid print(node *p){\n \n    inorder(p);\n    printf(\"\\n\");\n     \n    preorder(p);\n    printf(\"\\n\");\n     \n    return;\n     \n}\n \nnode * makenode(int x,int y){\n    node *new=malloc(sizeof(node));\n    new->key=x;\n    new->priority=y;\n    new->left=NULL;\n    new->right=NULL;\n    return new;\n}\n \nnode *rightRotate(node *p){\n    node *q=p->left;\n    p->left=q->right;\n    q->right=p;\n    return q;\n}\n \nnode *leftRotate(node *p){\n    node *q=p->right;\n    p->right=q->left;\n    q->left=p;\n    return q;\n}\n \n \nnode* insert(node **t,int key,int priority){\n    node *new;\n     \n    if((*t)==NULL)\n        return new=makenode(key,priority);\n    if ((*t)->key==key)\n        return *t;\n     \n    if(key < (*t)->key){\n        (*t)->left=insert(&(*t)->left,key,priority);\n        if((*t)->priority < (*t)->left->priority)\n            (*t)=rightRotate((*t));\n    }\n    else {\n        (*t)->right=insert(&(*t)->right,key,priority);\n        if((*t)->priority < (*t)->right->priority)\n            (*t)=leftRotate((*t));\n    }\n     \n    return *t;\n}\n \n \nnode * Delete(node **t,int key){\n    if((*t)==NULL)\n        return NULL;\n         \n    if(key < (*t)->key)\n        (*t)->left=Delete(&((*t)->left),key);\n         \n    else if(key > (*t)->key)\n        (*t)->right=Delete(&((*t)->right),key);\n         \n    else return _delete(t,key);\n     \n    return *t;\n}\n \nnode * _delete(node **t,int key){\n    if((*t)->left==NULL && (*t)->right==NULL)\n        return NULL;\n    else if((*t)->left==NULL)\n        (*t)=leftRotate(*t);\n    else if((*t)->right==NULL)\n        (*t)=rightRotate(*t);\n    else {\n        if((*t)->left->priority > (*t)->right->priority)\n            (*t)=rightRotate(*t);\n        else\n            (*t)=leftRotate(*t);\n    }\n    return Delete(t,key);\n}\n \n \nint main(){\n    int n,x,y;\n    char com[8];\n    node *root=NULL;\n     \n    scanf(\"%d\",&n);\n     \n    for(int i=0;i<n;i++){\n        scanf(\"%s\",com);\n         \n        switch(com[0]){\n         \n            case 'i':scanf(\"%d %d\",&x,&y);\n                     root=insert(&root,x,y);\n                     break;\n             \n            case 'd':scanf(\"%d\",&x);\n                     root=Delete(&root,x);\n                     break;\n             \n             \n            case 'f':scanf(\"%d\",&x);\n                     if(find(root,x))printf(\"yes\\n\");\n                     else printf(\"no\\n\");\n                     break;\n \n            case 'p':print(root);\n                     break;\n                      \n        }\n         \n    }\n     \n    return 0;\n     \n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define NIL NULL\n \nstruct node{\n    int key;\n    int priority;\n    struct node *right;\n    struct node *left;\n};\n \ntypedef struct node * Node;\n\nNode delete(Node, int); \nNode root;\n\nNode treeMinimum(Node x){\n    while (x->left!=NIL)\n    {\n        x=x->left;\n    }\n    return x;\n}\n \nNode treeMaximum(Node x){\n    while (x->right!=NIL)\n    {\n        x=x->right;\n    }\n    return x;\n}\n \nNode Search(Node u, int k){\n    Node ret = NIL;\n    if (u->key==k)\n    {\n        return u;\n    }\n    else if (u->key>k)\n    {\n        if (u->left!=NIL)\n        {\n            return Search(u->left, k);\n        }\n    }\n    else if (u->right!=NIL)\n    {\n        return Search(u->right, k);\n    }\n    return ret;\n}\n\nNode rightRotate(Node t){\n    Node s = t->left;\n    if (t==root)\n    {\n        root=s;\n    }\n    t->left = s->right;\n    s->right = t;\n    return s;\n}\n \nNode leftRotate(Node t){\n    Node s = t->right;\n    if (t==root)\n    {\n        root=s;\n    }\n    t->right = s->left;\n    s->left = t;\n    return s;\n}\n \nNode _delete(Node t, int key){\n    if (t->left == NIL && t->right==NIL)\n    {\n        return NIL;\n    }\n    if (t->left == NIL)\n    {\n        t=leftRotate(t);\n    }\n    else if (t->right == NIL)\n    {\n        t=rightRotate(t);\n    }\n    else \n    {\n        if (t->left->priority > t->right->priority)\n        {\n            t = rightRotate(t);\n        }\n        else\n        {\n            t = leftRotate(t);\n        }\n    }\n    return delete(t, key);\n}\n\nNode delete(Node t, int key){\n    if (t==NIL)\n    {\n        return NIL;\n    }\n    if (key < t->key)\n    {\n        t->left = delete(t->left,key);\n    }\n    else if (key > t->key)\n    {\n        t->right = delete(t->right, key);\n    }\n    else\n    {\n        return _delete(t, key);\n    }\n    return t;\n}\n\nNode insert(Node t, int key, int priority){\n    if (t==NIL)\n    {\n        Node z = malloc(sizeof(struct node));\n        z->key = key;\n        z->priority = priority;\n        z->left = NIL;\n        z->right=NIL;\n        if (root==NIL) root = z;\n        return z;\n    }\n\n    if (key==t->key)\n    {\n        return t;\n    }\n    if (key<t->key)\n    {\n        t->left = insert(t->left, key, priority);\n        if (t->priority < t->left->priority)\n        {\n            t = rightRotate(t);\n        }\n    }\n    else \n    {\n        t->right = insert(t->right, key, priority);\n        if (t->priority < t->right->priority)\n        {\n            t = leftRotate(t);\n        }\n    }\n\n    return t;\n}\n \nvoid inorder(Node u){\n    if (u->left!=NIL)\n    {  \n        inorder(u->left);\n    }\n    printf(\" %d\", u->key);\n    if (u->right!=NIL)\n    {\n        inorder(u->right);\n    }\n}\n \nvoid preorder(Node u){\n    printf(\" %d\", u->key);\n    if (u->left!=NIL)\n    {\n        preorder(u->left);\n    }\n    if (u->right!=NIL)\n    {\n        preorder(u->right);\n    }\n}\n \nvoid print(){\n    if (root==NIL)\n    {\n        return;\n    }\n    preorder(root);\n    printf(\"\\n\");\n    inorder(root);\n    printf(\"\\n\");\n}\n \nint main(){\n    int n, i, x, y;\n    Node t;\n    char tmp[10];\n    root = NIL;\n    scanf(\"%d\", &n);\n\n    for (i = 0; i < n; i++)\n    {\n        scanf(\"%s\", tmp);\n        if(tmp[0] == 'f')\n        {\n            scanf(\"%d\", &x);\n            t = Search(root, x);\n            if (t != NIL)\n            {\n                printf(\"yes\\n\");\n            }\n            else\n            {\n                printf(\"no\\n\");\n            }\n        }\n        else if(tmp[0] == 'i')\n        {\n            scanf(\"%d %d\", &x, &y);\n            insert(root, x, y);\n        }\n        else if(tmp[0] == 'p')\n        {\n            inorder(root);\n            printf(\"\\n\");\n            preorder(root);\n            printf(\"\\n\");\n        }\n        else if(tmp[0] == 'd')\n        {\n            scanf(\"%d\", &x);\n            t = Search(root, x);\n            if (t!=NIL)\n            {\n                delete(root, x);\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ ALDS1_8_D Binary search trees - Treap\n// 2019.3.30 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n\n//// 高速入出力\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\nint in()  // 非負整数の入力\n{\n\tint n = 0, c = gc();\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nvoid ins(char *s)  // 文字列の入力　スペース以下の文字で入力終了\n{\n\tdo *s = gc();\n\twhile (*s++ > ' ');\n\t*(s - 1) = 0;\n}\n\nvoid out(int n)  // 非負整数の表示（出力）\n{\n\tint i;\n\tchar ob[20];\n\n\tif (!n) pc('0');\n\telse {\n\t\ti = 0; while (n) ob[i++] = n % 10 + '0', n /= 10;\n\t\twhile (i--) pc(ob[i]);\n\t}\n}\n\nvoid outs(char *s) { while (*s) pc(*s++); }  // 文字列の出力\n\n\n//// 本問題関連\n#define MAX 300000\n\ntypedef struct { int key, pri, left, right; } BST;\nBST bst[MAX]; int sz = 1;\nint root;\n\nvoid inorder(int node)\n{\n\tif (node == 0) return;\n\tinorder(bst[node].left);\n\tpc(' '), out(bst[node].key);\n\tinorder(bst[node].right);\n}\n\nvoid preorder(int node)\n{\n\tif (node == 0) return;\n\tpc(' '), out(bst[node].key);\n\tpreorder(bst[node].left);\n\tpreorder(bst[node].right);\n}\n\nint leftRotate(int node)\n{\n\tint t = bst[node].right;\n\tbst[node].right = bst[t].left;\n\tbst[t].left = node;\n\treturn t;\n}\n\nint rightRotate(int node)\n{\n\tint t = bst[node].left;\n\tbst[node].left = bst[t].right;\n\tbst[t].right = node;\n\treturn t;\n}\n\nint insert(int node, int key, int pri)\n{\n\tint new;\n\n\tif (node == 0) {\n\t\tnew = sz++;\n\t\tbst[new].key = key, bst[new].pri = pri;\n\t\tbst[new].left = bst[new].right = 0;\n\t\treturn new;\n\t}\n\tif (key == bst[node].key) return node;\n\tif (key < bst[node].key) {\n\t\tbst[node].left = insert(bst[node].left, key, pri);\n\t\tif (bst[node].pri < bst[bst[node].left].pri) node = rightRotate(node);\n\t}\n\telse {\n\t\tbst[node].right = insert(bst[node].right, key, pri);\n\t\tif (bst[node].pri < bst[bst[node].right].pri) node = leftRotate(node);\n\t}\n\treturn node;\n}\n\nint find(int node, int key)\n{\n\twhile (node && bst[node].key != key) {\n\t\tif (key < bst[node].key) node = bst[node].left;\n\t\telse node = bst[node].right;\n\t}\n\treturn node;\n}\n\nint delete(int node, int key)\n{\n\tif (node == 0) return 0;\n\tif (key < bst[node].key) bst[node].left = delete(bst[node].left, key);\n\telse if (key > bst[node].key) bst[node].right = delete(bst[node].right, key);\n\telse if (bst[node].left && bst[node].right) {\n\t\tif (bst[bst[node].left].pri > bst[bst[node].right].pri)\n\t\t\tnode = rightRotate(node);\n\t\telse node = leftRotate(node);\n\t\tnode = delete(node, key);\n\t}\n\telse {\n\t\tif (bst[node].left) {\n\t\t\tnode = rightRotate(node);\n\t\t\tbst[node].right = delete(bst[node].right, key);\n\t\t}\n\t\telse if (bst[node].right) {\n\t\t\tnode = leftRotate(node);\n\t\t\tbst[node].left = delete(bst[node].left, key);\n\t\t}\n\t\telse node = 0;\n\t}\n\treturn node;\n}\n\nint main()\n{\n\tint M, key, pri;\n\tchar cmd[20];\n\tstatic char *msg[2] = { \"no\", \"yes\" };\n\n\tM = in();\n\twhile (M--) {\n\t\tins(cmd);\n\t\tif (*cmd == 'i') {\n\t\t\tkey = in(), pri = in();\n\t\t\troot = insert(root, key, pri);\n\t\t}\n\t\telse if (*cmd == 'f') {\n\t\t\tkey = in();\n\t\t\touts(msg[find(root, key) > 0]), pc('\\n');\n\t\t}\n\t\telse if (*cmd == 'd') {\n\t\t\tkey = in();\n\t\t\troot = delete(root, key);\n\t\t}\n\t\telse if (*cmd == 'p') {\n\t\t\tinorder(root), pc('\\n');\n\t\t\tpreorder(root), pc('\\n');\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\ntypedef int Key;\ntypedef int Value;\ntypedef int Result;\nstruct Treap {\n  Key key;\n  Value value;\n  int p;\n  bool cached;\n  Result cache;\n  Treap *ch[2]; // LEFT = ch[0], RIGHT = ch[1]\n  Treap(const Key &key, const Value &value) : key(key), value(value),\n    p(rand()), cached(0) { ch[0] = ch[1] = 0; }\n};\nTreap *rotate(Treap *t, int b) {\n  Treap *s = t->ch[1-b]; t->ch[1-b] = s->ch[b]; s->ch[b] = t;\n  s->cached = t->cached = false;\n  return s;\n}\nTreap *find(Treap *t, const Key &key) {\n  return !t || key == t->key ? t : find(t->ch[key<t->key], key);\n}\nTreap *insert(Treap *t, const Key &key, const Value &value) {\n  if (!t) return new Treap(key, value);\n  else if (key == t->key) return t;\n  int b = !(key < t->key);\n  t->ch[b] = insert(t->ch[b], key, value);\n  if (t->p > t->ch[b]->p) t = rotate(t, 1-b);\n  t->cached = false;\n  return t;\n}\nTreap *erase(Treap *t, const Key &key) {\n  if (!t) return NULL;\n  if (key == t->key) {\n    if (!t->ch[0] && !t->ch[1]) return NULL;\n    else if (!t->ch[0]) t = rotate(t, 0);\n    else if (!t->ch[1]) t = rotate(t, 1);\n    else t = rotate(t, t->ch[0]->p<t->ch[1]->p);\n    t = erase(t, key);\n  } else {\n    int b = !(key < t->key);\n    t->ch[b] = erase(t->ch[b], key);\n  }\n  t->cached = false;\n  return t;\n}\nResult eval(Treap *t) {\n  if (!t) return 0;\n  if (!t->cached)\n    t->cache = eval(t->ch[0]) + eval(t->ch[1]) + 1; // CHANGE IT FLEXIBLE\n  t->cached = true;\n  return t->cache;\n}\nTreap *nth(Treap *t, int n) { // NTH ELEMENT\n  int l = eval(t->ch[0]);\n  if (n < l) return nth(t->ch[0], n);\n  if (n > l) return nth(t->ch[1], n-l-1);\n  return t;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nstruct node {\n  int key;\n  int priority;\n  struct node *right;\n  struct node *left;\n};\n\ntypedef struct node* Nodepointer;\nNodepointer nil=NULL, root=NULL;\n\nNodepointer delete(Nodepointer*, int);\nNodepointer _delete(Nodepointer*, int);\n\nNodepointer Node(int key, int priority){\n Nodepointer z;\n  z = (Nodepointer)malloc(sizeof(struct node));\n  z->key = key;\n  z->priority = priority;\n  z->left = nil;\n  z->right = nil;\n  return z;\n}\n\nNodepointer rightRotate(Nodepointer t){\n  Nodepointer s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\n\nNodepointer leftRotate(Nodepointer t){\n  Nodepointer s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\n\nNodepointer insert(Nodepointer *t, int key, int priority){\n  Nodepointer new;\n  if( (*t) == nil ) return new = Node(key, priority);\n  if( key == (*t)->key ) return *t;\n\n  if( key < (*t)->key ){\n    (*t)->left = insert(&(*t)->left, key, priority);\n    if( (*t)->priority < (*t)->left->priority ) (*t) = rightRotate((*t));\n  }\n  else{\n    (*t)->right = insert(&(*t)->right, key, priority);\n    if( (*t)->priority < (*t)->right->priority ) (*t) = leftRotate((*t));\n  }\n  return *t;\n}\n\n\nNodepointer delete(Nodepointer *t, int key){\n  if( (*t) == nil ) return nil;\n  if( key < (*t)->key ) (*t)->left = delete(&((*t)->left), key);\n  else if( key > (*t)->key ) (*t)->right = delete(&((*t)->right), key);\n  else {\n    return _delete(t, key);\n  }\n  return *t;\n}\n\nNodepointer _delete(Nodepointer *t, int key){\n  if( (*t)->left == nil && (*t)->right == nil ) return nil;\n  else if( (*t)->left == nil ) (*t) = leftRotate(*t);\n  else if( (*t)->right == nil ) (*t) = rightRotate(*t);\n  else {\n    if( (*t)->left->priority > (*t)->right->priority ) (*t) = rightRotate(*t);\n    else (*t) = leftRotate(*t);\n  }\n  return delete(t, key);\n}\n\n\nint find(Nodepointer u, int k){\n  while( u != nil ){\n    if( u->key == k ) return 1;\n    else if( k < u->key ) u = u->left;\n    else u = u->right;\n  }\n  return 0;\n}\n\nvoid inorder(Nodepointer u){\n  if( u->left != nil ) inorder(u->left);\n  printf(\" %d\", u->key);\n  if( u->right != nil ) inorder(u->right);\n  return;\n}\n\nvoid preorder(Nodepointer u){\n  printf(\" %d\", u->key);\n  if( u->left != nil ) preorder(u->left);\n  if( u->right != nil ) preorder(u->right);\n  return;\n}\n\nvoid print(Nodepointer u){\n  inorder(u);\n  printf(\"\\n\");\n  preorder(u);\n  printf(\"\\n\");\n  return;\n}\n\nint main(){\n  int m, i, x, y;\n  char com[8];\n  Nodepointer t=nil;\n\n  scanf(\"%d\", &m);\n\n  for( i = 0 ; i < m ; i++ ){\n    scanf(\"%s\",com);\n\n    switch(com[0]){\n    case 'f': scanf(\"%d\", &x);\n      if( find(root, x)) printf(\"yes\\n\");\n      else printf(\"no\\n\");\n      break;\n\n    case 'i':  scanf(\"%d%d\", &x, &y);\n      root = insert(&root,x,y);\n      break;\n\n    case 'p':  print(root);\n      break;\n\n    case 'd': scanf(\"%d\", &x);\n      root = delete(&root, x);\n      break;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct node{\n  struct node *right;\n  struct node *left;\n  struct node *parent;\n  int priority;\n  int key;\n};\ntypedef struct node * Node;\n\n#define NIL NULL\nNode _delete(Node,int);\nNode root;\n\nNode treeMinimum(Node x){\n  while(x->left!=NIL)x=x->left;\n  return x;\n}\n\nNode treeMaximum(Node x){\n  while(x->right!=NIL)x=x->right;\n  return x;\n}\n\nNode treeSearch(Node u, int k){\n  if(u==NIL||k==u->key)return u;\n  if(k<u->key)\n    return treeSearch(u->left,k);\n  else\n    return treeSearch(u->right,k);\n\n}\n\nNode treeSuccessor(Node x){\n  Node y=x->parent;\n  if(x->right!=NIL)\n    return treeMinimum(x->right);\n  while(y!= NIL&&x==y->right){\n    x=y;\n    y=y->parent;\n  }\n  return y;\n\n}\n\nvoid treeDelete(Node z){\n  Node y; // node to be deleted\n  Node x; // child of y\n\n  if(z->left==NIL || z->right==NIL)y=z;\n  else y=treeSuccessor(z);\n\n  if(y->left!=NIL)x=y->left;\n  else x=y->right;\n\n  if(x!=NIL)x->parent=y->parent;\n\n  if(y->parent==NIL)root=x;\n  else if(y==y->parent->left)y->parent->left=x;\n  else y->parent->right=x;\n\n  if(y!=z)z->key=y->key;\n\n}\n\nNode insertA(int k,int priority){\n  Node y = NIL;\n  Node x = root;\n  Node z;\n\n  z = malloc(sizeof(struct node));\n  z->key = k;\n  z->priority=priority;\n  z->left = NIL;\n  z->right = NIL;\n\n  while(x!=NIL){\n    y=x;\n    if(z->key<x->key)x=x->left;\n    else x=x->right;\n  }\n  z->parent=y;\n  if(y==NIL)root=z;\n  else if(z->key<y->key)y->left=z;\n  else y->right=z;\n  return z;\n}\n\n\nNode rightRotate(Node t){\n  Node s;\n  if(root==t)root=t->left;\n  s= t->left;\n  t->left = s->right;\n  s->right = t;\n  return s; // root of the subtree\n}\n\t\n\nNode leftRotate(Node t){\n  Node s;\n  if(t==root)root=t->right;\n  s= t->right;\n  t->right = s->left;\n  s->left = t;\n  return s; // root of the subtree\n}\n\n\n\n\n\nvoid inorder(Node u){\n  if(u==NIL)return;\n  inorder(u->left);\n  printf(\" %d\",u->key);\n  inorder(u->right);\n}\nvoid preorder(Node u){\n  if(u==NIL)return;\n  printf(\" %d\",u->key);\n  preorder(u->left);\n  preorder(u->right);\n}\nNode insert(Node t, int key, int priority){            // 再帰的に探索\n  if (t == NIL)\n    return insertA(key,priority);               // 葉に到達したら新しい節点を生成して返す\n  if (key == t->key)\n    return t;                              // 重複したkeyは無視\n\n  if (key < t->key){                               // 左の子へ移動\n    t->left = insert(t->left, key, priority);   // 左の子へのポインタを更新\n    if (t->priority < t->left->priority)          // 左の子の方が優先度が高い場合右回転\n      t = rightRotate(t);\n  }else{                                         // 右の子へ移動\n    t->right = insert(t->right, key, priority); // 右の子へのポインタを更新\n    if (t->priority < t->right->priority)         // 右の子の方が優先度が高い場合左回転\n      t = leftRotate(t);\n  }\n  return t;\n}\n\n\n\n\nNode delete(Node t, int key){\n  if (t == NIL)\n    return NIL;\n  if (key < t->key)                                // 削除対象を検索\n    t->left = delete(t->left, key);\n  else if (key > t->key)\n    t->right = delete(t->right, key);\n    else\n      return _delete(t, key);\n  return t;\n}\n\nNode _delete(Node t,int key){ // 削除対象の節点の場合\n  if (t->left == NIL && t->right == NIL)           // 葉の場合\n    return NIL;\n  else if (t->left == NIL)                        // 右の子のみを持つ場合左回転\n    t = leftRotate(t);\n  else if (t->right == NIL)                       // 左の子のみを持つ場合右回転\n    t = rightRotate(t);\n  else {                                       // 左の子と右の子を両方持つ場合\n    if (t->left->priority > t->right->priority)    // 優先度が高い方を持ち上げる\n      t = rightRotate(t);\n    else\n      t = leftRotate(t);\n  }\n  return delete(t, key);\n}\n\n\n\n\nint main(){\n  int n, i, x,y;\n  char com[20];\n  scanf(\"%d\", &n);\n\n  for ( i = 0; i < n; i++ ){\n    scanf(\"%s\", com);\n    if ( com[0] == 'f' ){\n      scanf(\"%d\", &x);\n      Node t = treeSearch(root, x);\n      if ( t != NIL ) printf(\"yes\\n\");\n      else printf(\"no\\n\");\n    } else if ( com[0] == 'i' ){\n      scanf(\"%d%d\", &x,&y);\n      insert(root,x,y);\n    } else if ( com[0] == 'p' ){\n      inorder(root);\n      printf(\"\\n\");\n      preorder(root);\n      printf(\"\\n\");\n    } else if ( com[0] == 'd' ){\n      scanf(\"%d\", &x);\n      delete(root,x);\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define NIL NULL\n\ntypedef struct node{\n\tint key;\n\tint priority;\n\tstruct node *right , *left;\n}Node;\n\nNode * Delete(Node **,int);\nNode * delete(Node **,int);\n\nint find(Node *p,int x)\n{\n\twhile(p!=NIL)\n\t{\n\t\tif(p->key==x)return 1;\n\t\telse if(p->key > x)p = p->left;\n\t\telse p = p->right;\n\t}\n\treturn 0;\n}\n\nvoid inorder(Node *a)\n{\n\tif(a->left!=NIL) inorder(a->left);\n\tprintf(\" %d\",a->key);\n\tif(a->right!=NIL) inorder(a->right);\n\treturn;\n}\n\nvoid preorder(Node *p)\n{\n\tprintf(\" %d\",p->key);\n\tif(p->left!=NIL) preorder(p->left);\n\tif(p->right!=NIL) preorder(p->right);\n\treturn;\n}\n\nvoid print(Node *p)\n{\n\tinorder(p);\n\tprintf(\"\\n\");\n\tpreorder(p);\n\tprintf(\"\\n\");\n\treturn;\n}\n\nNode * makenode(int x , int y)\n{\n\tNode *new = malloc(sizeof(Node));\n\tnew->key = x;\n\tnew->priority = y;\n\tnew->left = NIL;\n\tnew->right = NIL;\n\treturn new;\n}\n\nNode *rightRotate(Node *p)\n{\n\tNode *q = p->left;\n\tp->left = q->right;\n\tq->right = p;\n\treturn q;\n}\n\nNode *leftRotate(Node *p)\n{\n\tNode *q = p->right;\n\tp->right = q->left;\n\tq->left = p;\n\treturn q;\n}\n\nNode* insert(Node **t , int key, int priority)  // 再帰的に探索\n{\n\tNode *new;\n\tif((*t)==NIL)\n\treturn new = makenode(key,priority); // 葉に到達したら新しい節点を生成して返す\n\tif((*t)->key == key)\n\treturn *t;  // 重複したkeyは無視\n\t\n\tif(key < (*t)->key) // 左の子へ移動\n\t{\n\t\t(*t)->left = insert(&(*t)->left,key,priority); // 左の子へのポインタを更新\n\t\tif((*t)->priority < (*t)->left->priority) // 左の子の方が優先度が高い場合右回転\n\t\t(*t) = rightRotate(*t);\n\t}\n\telse{ // 右の子へ移動\n\t\t(*t)->right = insert(&(*t)->right,key,priority); // 右の子へのポインタを更新\n\t\tif((*t)->priority < (*t)->right->priority) // 右の子の方が優先度が高い場合左回転\n\t\t(*t) = leftRotate((*t));\n\t}\n\treturn *t;\n}\n\nNode * Delete(Node **t , int key)\n{\n\tif((*t)==NIL)\n\treturn NIL;\n\t\n\tif(key < (*t)->key) // 削除対象を検索\n\t(*t)->left = Delete(&((*t)->left),key);\n\t\n\telse if(key > (*t)->key)\n\t(*t)->right = Delete(&((*t)->right),key);\n\t\n\telse return delete(t,key);\n\treturn *t;\n}\n\nNode * delete(Node **t , int key)\n{\n\tif((*t)->left == NIL && (*t)->right == NIL)  // 葉の場合\n\t{\n\t\treturn NIL;\n\t}\n\telse if((*t)->left == NIL) // 右の子のみを持つ場合左回転\n\t{\n\t\t(*t) = leftRotate(*t);\n\t}\n\telse if((*t)->right ==NIL) // 左の子のみを持つ場合右回転\n\t{\n\t\t(*t) = rightRotate(*t);\n\t}\n\telse{ // 左の子と右の子を両方持つ場合\n\t\tif((*t)->left->priority > (*t)->right->priority) // 優先度が高い方を持ち上げる\n\t\t(*t) = rightRotate(*t);\n\t\telse\n\t\t(*t) = leftRotate(*t);\n\t}\n\treturn Delete(t,key);\n}\n\nint main(void)\n{\n\tint num ,  x, y;\n\tchar com[8];\n\tNode *root = NIL;\n\tscanf(\"%d\",&num);\n\t\n\tfor(int i = 0; i < num; i++)\n\t{\n\t\tscanf(\"%s\",com);\n\t\tswitch(com[0])\n\t\t{\n\t\t  case 'i':scanf(\"%d %d\",&x,&y);\n\t\t\troot = insert(&root,x,y);\n\t\t\tbreak;\n\t\t  case 'd':scanf(\"%d\",&x);\n\t\t\troot = Delete(&root,x);\n\t\t\tbreak;\n\t\t  case 'f':scanf(\"%d\",&x);\n\t\t\tif(find(root,x))printf(\"yes\\n\");\n\t\t\telse printf(\"no\\n\");\n\t\t\tbreak;\n\t\t  case 'p':print(root);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct node{\n\tint key,priority;\n\tstruct node *left,*right;\n};\ntypedef struct node* Node;\n\nNode NIL,root;\n\nNode rightRotate(Node);\nNode leftRotate(Node);\nNode insert(Node,int,int);\nNode delete(Node,int);\nNode _delete(Node,int);\nvoid inOrder(Node);\nvoid preOrder(Node);\nNode find(int);\n\nint main(){\n\troot=NIL;\n\tint i,n,k,p;\tscanf(\"%d\",&n);\n\tchar com[10];\n\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%s\",com);\n\t\tif(com[0]=='i'){\n\t\t\tscanf(\"%d%d\",&k,&p);\n\t\t\tinsert(root,k,p);\n\n\t\t}else if(com[0]=='p'){\n\t\t\tinOrder(root);\n\t\t\tprintf(\"\\n\");\n\t\t\tpreOrder(root);\n\t\t\tprintf(\"\\n\");\n\t\t}else if(com[0]=='f'){\n\t\t\tscanf(\"%d\",&k);\n\t\t\tif(find(k)!=NIL)printf(\"yes\\n\");\n\t\t\telse printf(\"no\\n\");\n\t\t}else{\n\t\t\tscanf(\"%d\",&k);\n\t\t\tdelete(root,k);\n\t\t}\n\t\t//printf(\"\\n\");\n\t}\n\n\treturn 0;\n}\n\nNode rightRotate(Node t){\n\t//printf(\" rR\\n\");\n\tNode s = t->left;\n\tif(t==root)root=s;\n\tt->left = s->right;\n\ts->right = t;\n\n\treturn s; // root of the subtree\n}\nNode leftRotate(Node t){\n\t//printf(\" lR\\n\");\n\tNode s = t->right;\n\tif(t==root)root=s;\n\tt->right = s->left;\n\ts->left = t;\n\treturn s; // root of the subtree\n}\nNode insert(Node t, int k, int p){\n\t//printf(\"i \");\n\tNode x;\n\tif (t == NIL){\n\t\tx=(Node)malloc(sizeof(struct node));\n\t\tx->key=k;\tx->priority=p;\n\t\tx->left=x->right=NIL;\n\n\t\tif(root==NIL)root=x;\n\n\t\treturn x;\n\t}\n\tif (k == t->key)\n\t\treturn t;                            // 重複したkeyは無視\n\n\tif (k < t->key){                               // 左の子へ移動\n\t\tt->left = insert(t->left, k, p);   // 左の子へのポインタを更新\n\t\tif (t->priority < t->left->priority)          // 左の子の方が優先度が高い場合右回転\n\t\t\tt = rightRotate(t);\n\t}else{                                         // 右の子へ移動\n\t\tt->right = insert(t->right, k, p); // 右の子へのポインタを更新\n\t\tif (t->priority < t->right->priority)         // 右の子の方が優先度が高い場合左回転\n\t\t\tt = leftRotate(t);\n\t}\n\n\treturn t;\n}\n\nNode delete(Node t, int key){\n\tif (t == NIL)return NIL;\n\n\tif (key < t->key)                                // 削除対象を検索\n\t\tt->left = delete(t->left, key);\n\telse if (key > t->key)\n\t\tt->right = delete(t->right, key);\n\telse\n\t\treturn _delete(t, key);\n\treturn t;\n}\n\nNode _delete(Node t, int key){ // 削除対象の節点の場合\n\tif (t->left == NIL && t->right == NIL)           // 葉の場合\n\t\treturn NIL;\n\telse if (t->left == NIL)                        // 右の子のみを持つ場合左回転\n\t\tt = leftRotate(t);\n\telse if (t->right == NIL)                       // 左の子のみを持つ場合右回転\n\t\tt = rightRotate(t);\n\telse{                                         // 左の子と右の子を両方持つ場合\n\t\tif (t->left->priority > t->right->priority)    // 優先度が高い方を持ち上げる\n\t\t\tt = rightRotate(t);\n\t\telse\n\t\t\tt = leftRotate(t);\n\t}\n\treturn delete(t, key);\n\n}void inOrder(Node x){\n\tif(x==NIL)return;\n\tinOrder(x->left);\n\tprintf(\" %d\",x->key);\n\tinOrder(x->right);\n}\nvoid preOrder(Node x){\n\tif(x==NIL)return;\n\tprintf(\" %d\",x->key);\n\tpreOrder(x->left);\n\tpreOrder(x->right);\n}\nNode find(int k){\n\tNode p=root;\n\n\twhile(p!=NIL){\n\t\tif(p->key==k){\n\t\t\treturn p;\n\t\t}\n\n\t\tif(k < p->key)p=p->left;\n\t\telse p=p->right;\n\t}\n\n\treturn NIL;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint get_uint() {\n    int n = 0;\n    int c = getchar_unlocked();\n    if(c < 48 || 57 < c) return c;\n    while(47 < c && c < 58) {\n        n = 10 * n + (c & 0xf);\n        c = getchar_unlocked();\n    }\n    return n;\n}\nint get_str(char *str) {\n    int c;\n    while((c = getchar_unlocked()) > 32) *str++ = (char)c;\n    *str = 0;\n    return c;\n}\nvoid put_uint(int n) {\n    if(!n) {\n        putchar_unlocked('0');\n        return;\n    }\n    char buf[11];\n    int i = 0;\n    while(n) buf[i++] = (char)(n % 10 + '0'), n /= 10;\n    while(i--)putchar_unlocked(buf[i]);\n}\nvoid put_str(char *str) { while(*str) putchar_unlocked(*str++); }\n\ntypedef struct Node {\n    int key;\n    int priority;\n    struct Node *left, *right;\n} Node;\ntypedef struct BST {\n    Node *root;\n    size_t size;\n} BST;\nvoid bst_init(BST *BST) {\n    BST->root = NULL;\n    BST->size = 0;\n}\nNode *bst_rotate_right(Node *root) {\n    Node *tmp = root->left;\n    root->left = tmp->right;\n    tmp->right = root;\n    return tmp;\n}\nNode *bst_rotate_left(Node *root) {\n    Node *tmp = root->right;\n    root->right = tmp->left;\n    tmp->left = root;\n    return tmp;\n}\nNode *bst__insert(Node *root, int key, int priority) {\n    if(root == NULL) {\n        Node *new_node = malloc(sizeof(Node));\n        new_node->key = key;\n        new_node->priority = priority;\n        new_node->left = new_node->right = NULL;\n        return new_node;\n    }\n    if(key == root->key) return root;\n    if(key < root->key) {\n        root->left = bst__insert(root->left, key, priority);\n        if(root->priority < root->left->priority) root = bst_rotate_right(root);\n    } else {\n        root->right = bst__insert(root->right, key, priority);\n        if(root->priority < root->right->priority) root = bst_rotate_left(root);\n    }\n    return root;\n}\nvoid bst_insert(BST *BST, int key, int priority) {\n    BST->root = bst__insert(BST->root, key, priority);\n    BST->size++;\n}\nNode *bst_find(const Node *root, const int key) {\n    while(root != NULL && root->key != key) {\n        if(key < root->key) root = root->left;\n        else root = root->right;\n    }\n    return root;\n}\nNode *bst_get_min(Node *root) {\n    while(root->left != NULL) root = root->left;\n    return root;\n}\nNode *bst__delete(Node *root, int key) {\n    if(root == NULL) return NULL;\n    if(key < root->key) root->left = bst__delete(root->left, key);\n    else if(key > root->key) root->right = bst__delete(root->right, key);\n    else if(root->left && root->right) {\n        if(root->left->priority > root->right->priority) root = bst_rotate_right(root);\n        else root = bst_rotate_left(root);\n        root = bst__delete(root, key);\n    } else {\n        Node *tmp = root;\n        if(root->left) {\n            root = bst_rotate_right(root);\n            root->right = bst__delete(root->right, key);\n        }\n        else if(root->right) {\n            root = bst_rotate_left(root);\n            root->left = bst__delete(root->left, key);\n        }\n        else {\n            root = NULL;\n            free(tmp);\n        }\n    }\n    return root;\n}\nvoid bst_delete(BST *BST, int key) {\n    BST->root = bst__delete(BST->root, key);\n    BST->size--;\n}\nvoid bst_inorder(Node *root) {\n    if(root == NULL) return;\n    bst_inorder(root->left);\n    putchar_unlocked(' '), put_uint(root->key);\n    bst_inorder(root->right);\n}\nvoid bst_preorder(Node *root) {\n    if(root == NULL) return;\n    putchar_unlocked(' '), put_uint(root->key);\n    bst_preorder(root->left);\n    bst_preorder(root->right);\n}\nint main(int argc, char **argv) {\n    BST BST;\n    bst_init(&BST);\n    int m = get_uint();\n    int key, priority;\n    char c[8];\n    for(int i = 0; i < m; ++i) {\n        get_str(c);\n        switch(*c) {\n        case 'i':\n            key = get_uint();\n            priority = get_uint();\n            bst_insert(&BST, key, priority);\n            break;\n        case 'f':\n            key = get_uint();\n            put_str(bst_find(BST.root, key) ? \"yes\\n\" : \"no\\n\");\n            break;\n        case 'd':\n            key = get_uint();\n            bst_delete(&BST, key);\n            break;\n        default:\n            bst_inorder(BST.root);\n            putchar_unlocked('\\n');\n            bst_preorder(BST.root);\n            putchar_unlocked('\\n');\n            break;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nstruct node{\n    int key;\n    int priority;\n    struct node *right, *left, *parent;\n};\n\nstruct node *root, *NIL;\n\nstruct node * _delete(struct node*, int);\n\nstruct node * rightRotate(struct node *t){\n    struct node *s =t->left;\n    t->left = s->right;\n    s->right = t;\n    return s;\n\n}\n\nstruct node * leftRotate(struct node *t){\n    struct node *s =t->right;\n    t->right = s->left;\n    s->left = t;\n    return s;\n}\n\n\n\nstruct node * find(struct node *u, int k){\n    while(u != NIL && k != u->key){\n        if(k < u->key){\n            u=u->left;\n        }\n        else{\n            u=u->right;\n        }\n    }\n\n    return u;\n}\n\n\n\nstruct node *  delete(struct node *t, int key){\n    if(t==NIL){\n       return NIL;\n    }\n    if(key < t->key){\n        t->left=delete(t->left, key);\n    }else if(key > t->key){\n        t->right=delete(t->right, key);\n    } else{\n        return _delete(t, key);\n    }   \n\n    return t;\n\n}\n\nstruct node * _delete(struct node *t, int key){\n    if(t->left==NIL && t->right==NIL){\n        return NIL;\n    }else if(t->left==NIL){\n        t=leftRotate(t);\n    }else if(t->right==NIL){\n        t=rightRotate(t);\n    }else{\n        if(t->left->priority > t->right->priority){\n            t=rightRotate(t);\n        }\n        else{\n            t=leftRotate(t);\n        }\n    }\n\n    return delete(t, key);\n}\n\nstruct node * insert(struct node *t, int key, int priority){\n    if(t==NIL){\n        struct node *z;\n        z = (struct node *)malloc(sizeof(struct node));\n        z->key=key;\n        z->priority=priority;\n        z->left=NIL;\n        z->right=NIL;\n        return z;\n    }\n\n    if(key==t->key){\n        return t;\n    }\n\n    if(key < t->key){\n        t->left=insert(t->left, key, priority);\n        if(t->priority < t->left->priority){\n            t=rightRotate(t);\n        }\n    }\n    else{\n        t->right=insert(t->right, key, priority);\n        if(t->priority < t->right->priority){\n            t=leftRotate(t);\n        }\n    }\n\n    return t;\n    \n}\n\nvoid inorder(struct node *u){\n    if(u==NIL){\n        return;\n    }\n    inorder(u->left);\n    printf(\" %d\", u->key);\n    inorder(u->right);\n}\n\nvoid preorder(struct node *u){\n    if(u==NIL){\n        return;\n    }\n    printf(\" %d\", u->key);\n    preorder(u->left);\n    preorder(u->right);\n}\n\nint main(void){\n    int n, i, x, y;\n    char com[10];\n    scanf(\"%d\", &n);\n\n    for(int i=0; i<n; i++){\n        scanf(\"%s\", com);\n        if(com[0]=='i'){\n            scanf(\"%d %d\", &x, &y);\n            root=insert(root, x, y);\n            x++;\n        }else if(com[0]=='f'){\n            scanf(\"%d\", &y);\n            struct node *t = find(root, y);\n            if(t!=NIL){\n                \n                printf(\"yes\\n\");\n            }\n            else{\n                printf(\"no\\n\");\n            }\n        }\n         else if(com[0]=='d'){\n            scanf(\"%d\", &y);\n            root=delete(root, y);\n        }else if(com[0]=='p'){\n            inorder(root);\n            printf(\"\\n\");\n            preorder(root);\n            printf(\"\\n\");\n        }\n       \n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 41\n\ntypedef struct node{\n  int l, r;\n}node;\n\nnode c[N];\nint a[N];\nint b[N];\nint cnt=0;\n\nvoid postorder(int root,int n){\n\n        if(c[root].l != -1) postorder(c[root].l, n);\n\n        if(c[root].r != -1) postorder(c[root].r, n);\n\n        if(cnt < n-1) printf(\"%d \", root);\n        else printf(\"%d\\n\", root);\n\n        cnt++;\n\n        return;\n}\n\nint reconst(int start,int last,int n){\n  int i, j;\n\n  if(start==last) return b[start];\n  else if(start > last) return -1;\n\n  else{\n    for(i = 1 ; i <= n ; i++){\n      for(j = start ; j <= last ; j++){\n        if(a[i] == b[j]){\n          c[a[i]].l = reconst(start, j - 1, n);\n          c[a[i]].r = reconst(j + 1, last, n);\n          return a[i];\n        }\n      }\n    }\n  }\n}\n\n\nint main(){\n  int n, i, root;\n\n  scanf(\"%d\", &n);\n\n  for(i = 1 ; i <= n ; i++){\n    scanf(\"%d\",&a[i]);\n    scanf(\"%d\",&b[i]);\n    c[i].l = -1;\n    c[i].r = -1;\n  }\n\n  root = reconst(1,n,n);\n  postorder(root,n);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 41\n\ntypedef struct node{\n  int l, r;\n}node;\n\nnode c[N];\nint a[N];\nint b[N];\nint cnt=0;\n\nvoid postorder(int root,int n){\n\n        if(c[root].l != -1) postorder(c[root].l, n);\n\n        if(c[root].r != -1) postorder(c[root].r, n);\n\n        if(cnt < n-1) printf(\"%d \", root);\n        else printf(\"%d\\n\", root);\n\n        cnt++;\n\n        return;\n}\n\nint reconst(int start,int last,int n){\n  int i, j;\n\n  if(start==last) return b[start];\n  else if(start > last) return -1;\n\n  else{\n    for(i = 1 ; i <= n ; i++){\n      for(j = start ; j <= last ; j++){\n        if(a[i] == b[j]){\n          c[a[i]].l = reconst(start, j - 1, n);\n          c[a[i]].r = reconst(j + 1, last, n);\n          return a[i];\n        }\n      }\n    }\n  }\n}\n\n\nint main(){\n  int n, i, root;\n\n  scanf(\"%d\", &n);\n\n  for(i = 1 ; i <= n ; i++){\n    scanf(\"%d\",&a[i]);\n    scanf(\"%d\",&b[i]);\n    c[i].l = -1;\n    c[i].r = -1;\n  }\n\n  root = reconst(1,n,n);\n  postorder(root,n);\n\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\ntypedef struct node\n{\n  int key;\n  int priority;\n  struct node *parent;\n  struct node *child[2];\n} *nodePointer;\nnodePointer init(int,int);\nnodePointer insert(nodePointer,int,int);\nnodePointer find(nodePointer,int);\nnodePointer delete(nodePointer,int);\nnodePointer _delete(nodePointer,int);\nvoid preorderWalk(nodePointer);\nvoid inorderWalk(nodePointer);\nnodePointer rightRotate(nodePointer);\nnodePointer leftRotate(nodePointer);\nnodePointer root=NULL;\nint main(void)\n{\n  int i;//counter\n  int n;//the number of operation\n  int key,priority;\n  char op[10];//operation\n  nodePointer p;\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    {\n      scanf(\"%s\",op);\n      if(strcmp(op,\"insert\")==0)\n        {\n          scanf(\"%d%d\",&key,&priority);\n          root=insert(root,key,priority);\n        }\n      else if(strcmp(op,\"find\")==0)\n        {\n          scanf(\"%d\",&key);\n          if(find(root,key)!=NULL) printf(\"yes\\n\");\n          else printf(\"no\\n\");\n        }\n      else if(strcmp(op,\"delete\")==0)\n        {\n          scanf(\"%d\",&key);\n          root=delete(root,key);\n        }\n      else if(strcmp(op,\"print\")==0)\n        {\n          inorderWalk(root);\n          printf(\"\\n\");\n          preorderWalk(root);\n          printf(\"\\n\");\n        }\n      else\n        {\n          fprintf(stderr,\"undefined operation\\n\");\n          exit(1);\n        }\n    }\n  return 0;\n}\nnodePointer init(int key,int priority)\n{\n  nodePointer p=(nodePointer)malloc(sizeof(struct node));\n  p->key=key;\n  p->priority=priority;\n  p->parent=NULL;\n  p->child[0]=NULL;\n  p->child[1]=NULL;\n  return p;\n}\nnodePointer insert(nodePointer p,int key,int priority)\n{\n  if(p==NULL) return init(key,priority);\n  if(key == p->key) return p;\n  if(key < p->key)\n    {\n      p->child[0]=insert(p->child[0],key,priority);\n      if(p->priority < p->child[0]->priority) p=rightRotate(p);\n    }\n  if(key > p->key)\n    {\n      p->child[1]=insert(p->child[1],key,priority);\n      if(p->priority < p->child[1]->priority) p=leftRotate(p);\n    }\n  return p;\n}\nnodePointer find(nodePointer p,int key)\n{\n  if(p==NULL) return NULL;\n  if(p->key < key) return find(p->child[1],key);\n  if(p->key == key) return p;\n  if(p->key > key) return find(p->child[0],key);\n}\nnodePointer delete(nodePointer p,int key)\n{\n  if(p==NULL) return NULL;\n  if(key < p->key) p->child[0]=delete(p->child[0],key);\n  else if(key > p->key) p->child[1]=delete(p->child[1],key);\n  else return _delete(p,key);\n  return p;\n}\nnodePointer _delete(nodePointer p,int key)\n{\n  if(p->child[0]==NULL&&p->child[1]==NULL) return NULL;\n  else if(p->child[0]==NULL) p=leftRotate(p);\n  else if(p->child[1]==NULL) p=rightRotate(p);\n  else\n    {\n      if(p->child[0]->priority > p->child[1]->priority) p=rightRotate(p);\n      else p=leftRotate(p);\n    }\n  return delete(p,key);\n}\nvoid preorderWalk(nodePointer p)\n{\n  if(p==NULL) return;\n  printf(\" %d\",p->key);\n  preorderWalk(p->child[0]);\n  preorderWalk(p->child[1]);\n}\nvoid inorderWalk(nodePointer p)\n{\n  if(p==NULL) return;\n  inorderWalk(p->child[0]);\n  printf(\" %d\",p->key);\n  inorderWalk(p->child[1]);\n}\nnodePointer rightRotate(nodePointer p)\n{\n  nodePointer s=p->child[0];\n  p->child[0]=s->child[1];\n  s->child[1]=p;\n  return s;\n}\nnodePointer leftRotate(nodePointer p)\n{\n  nodePointer s=p->child[1];\n  p->child[1]=s->child[0];\n  s->child[0]=p;\n  return s;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n \ntypedef struct node{\n  int key;\n  int priority;\n  struct node *left;\n  struct node *right;\n}node;\n \n \nnode * Delete(node **,int);\nnode * _delete(node **,int);\n \nint find(node *p,int x){\n \n  while(p!=NULL){\n    if(p->key == x)return 1;\n    else if(p->key > x)p=p->left;\n    else p=p->right;\n  }\n \n  return 0;\n \n}\n \nvoid inorder(node *p){\n \n  if(p->left!=NULL)inorder(p->left);\n \n  printf(\" %d\",p->key);\n \n  if(p->right!=NULL)inorder(p->right);\n \n  return;\n \n}\n \nvoid preorder(node *p){\n \n  printf(\" %d\",p->key);\n \n  if(p->left!=NULL)preorder(p->left);\n \n  if(p->right!=NULL)preorder(p->right);\n \n  return;\n \n}\n \nvoid print(node *p){\n \n  inorder(p);\n  printf(\"\\n\");\n \n  preorder(p);\n  printf(\"\\n\");\n \n  return;\n \n}\n \nnode * makenode(int x,int y){\n  node *new=malloc(sizeof(node));\n  new->key=x;\n  new->priority=y;\n  new->left=NULL;\n  new->right=NULL;\n  return new;\n}\n \nnode *rightRotate(node *p){\n  node *q=p->left;\n  p->left=q->right;\n  q->right=p;\n  return q;\n}\n \nnode *leftRotate(node *p){\n  node *q=p->right;\n  p->right=q->left;\n  q->left=p;\n  return q;\n}\n \n \nnode* insert(node **t,int key,int priority){\n  node *new;\n \n  if((*t)==NULL)\n  return new=makenode(key,priority);\n  if ((*t)->key==key)\n  return *t;\n \n  if(key < (*t)->key){\n    (*t)->left=insert(&(*t)->left,key,priority);\n    if((*t)->priority < (*t)->left->priority)\n    (*t)=rightRotate((*t));\n  }\n  else {\n    (*t)->right=insert(&(*t)->right,key,priority);\n    if((*t)->priority < (*t)->right->priority)\n    (*t)=leftRotate((*t));\n  }\n \n  return *t;\n}\n \n \nnode * Delete(node **t,int key){\n  if((*t)==NULL)\n  return NULL;\n \n  if(key < (*t)->key)\n  (*t)->left=Delete(&((*t)->left),key);\n \n  else if(key > (*t)->key)\n  (*t)->right=Delete(&((*t)->right),key);\n \n  else return _delete(t,key);\n \n  return *t;\n}\n \nnode * _delete(node **t,int key){\n  if((*t)->left==NULL && (*t)->right==NULL)\n  return NULL;\n  else if((*t)->left==NULL)\n  (*t)=leftRotate(*t);\n  else if((*t)->right==NULL)\n  (*t)=rightRotate(*t);\n  else {\n    if((*t)->left->priority > (*t)->right->priority)\n    (*t)=rightRotate(*t);\n    else\n    (*t)=leftRotate(*t);\n  }\n  return Delete(t,key);\n}\n \n \nint main(){\n  int n,x,y;\n  char com[8];\n  node *root=NULL;\n \n  scanf(\"%d\",&n);\n \n  for(int i=0;i<n;i++){\n    scanf(\"%s\",com);\n \n    switch(com[0]){\n \n      case 'i':scanf(\"%d %d\",&x,&y);\n      root=insert(&root,x,y);\n      break;\n \n      case 'd':scanf(\"%d\",&x);\n      root=Delete(&root,x);\n      break;\n \n \n      case 'f':scanf(\"%d\",&x);\n      if(find(root,x))printf(\"yes\\n\");\n      else printf(\"no\\n\");\n      break;\n \n      case 'p':print(root);\n      break;\n \n    }\n \n  }\n \n  return 0;\n \n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\nstruct node {\n  int key;\n  int priority;\n  struct node *right;\n  struct node *left;\n};\n\ntypedef struct node* Nodepointer;\nNodepointer nil=NULL, root=NULL;\n\nNodepointer delete(Nodepointer*, int);\nNodepointer _delete(Nodepointer*, int);\n\nNodepointer Node(int key, int priority){\n Nodepointer z;\n  z = (Nodepointer)malloc(sizeof(struct node));\n  z->key = key;\n  z->priority = priority;\n  z->left = nil;\n  z->right = nil;\n  return z;\n}\n\nNodepointer rightRotate(Nodepointer t){\n  Nodepointer s = t->left;\n  t->left = s->right;\n  s->right = t;\n  return s;\n}\n\nNodepointer leftRotate(Nodepointer t){\n  Nodepointer s = t->right;\n  t->right = s->left;\n  s->left = t;\n  return s;\n}\n\nNodepointer insert(Nodepointer *t, int key, int priority){\n  Nodepointer new;\n  if( (*t) == nil ) return new = Node(key, priority);\n  if( key == (*t)->key ) return *t;\n\n  if( key < (*t)->key ){\n    (*t)->left = insert(&(*t)->left, key, priority);\n    if( (*t)->priority < (*t)->left->priority ) (*t) = rightRotate((*t));\n  }\n  else{\n    (*t)->right = insert(&(*t)->right, key, priority);\n    if( (*t)->priority < (*t)->right->priority ) (*t) = leftRotate((*t));\n  }\n  return *t;\n}\n\n\nNodepointer delete(Nodepointer *t, int key){\n  if( (*t) == nil ) return nil;\n  if( key < (*t)->key ) (*t)->left = delete(&((*t)->left), key);\n  else if( key > (*t)->key ) (*t)->right = delete(&((*t)->right), key);\n  else {\n    return _delete(t, key);\n  }\n  return *t;\n}\n\nNodepointer _delete(Nodepointer *t, int key){\n  if( (*t)->left == nil && (*t)->right == nil ) return nil;\n  else if( (*t)->left == nil ) (*t) = leftRotate(*t);\n  else if( (*t)->right == nil ) (*t) = rightRotate(*t);\n  else {\n    if( (*t)->left->priority > (*t)->right->priority ) (*t) = rightRotate(*t);\n    else (*t) = leftRotate(*t);\n  }\n  return delete(t, key);\n}\n\n\nint find(Nodepointer u, int k){\n  while( u != nil ){\n    if( u->key == k ) return 1;\n    else if( k < u->key ) u = u->left;\n    else u = u->right;\n  }\n  return 0;\n}\n\nvoid inorder(Nodepointer u){\n  if( u->left != nil ) inorder(u->left);\n  printf(\" %d\", u->key);\n  if( u->right != nil ) inorder(u->right);\n  return;\n}\n\nvoid preorder(Nodepointer u){\n  printf(\" %d\", u->key);\n  if( u->left != nil ) preorder(u->left);\n  if( u->right != nil ) preorder(u->right);\n  return;\n}\n\nvoid print(Nodepointer u){\n  inorder(u);\n  printf(\"\\n\");\n  preorder(u);\n  printf(\"\\n\");\n  return;\n}\n\nint main(){\n  int m, i, x, y;\n  char com[8];\n  Nodepointer t=nil;\n\n  scanf(\"%d\", &m);\n\n  for( i = 0 ; i < m ; i++ ){\n    scanf(\"%s\",com);\n\n    switch(com[0]){\n    case 'f': scanf(\"%d\", &x);\n      if( find(root, x)) printf(\"yes\\n\");\n      else printf(\"no\\n\");\n      break;\n\n    case 'i':  scanf(\"%d%d\", &x, &y);\n      root = insert(&root,x,y);\n      break;\n\n    case 'p':  print(root);\n      break;\n\n    case 'd': scanf(\"%d\", &x);\n      root = delete(&root, x);\n      break;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "class Node\n  def initialize(key, priority)\n    @key = key\n    @priority = priority\n    @parent = nil\n    @left = nil\n    @right = nil\n  end\n  attr_accessor :key, :priority, :parent, :left, :right\nend\n\ndef right_rotate(node_t)\n  node_s = node_t.left\n  node_t.left = node_s.right\n  node_s.right = node_t\n  return node_s\nend\n\ndef left_rotate(node_t)\n  node_s = node_t.right\n  node_t.right = node_s.left\n  node_s.left = node_t\n  return node_s\nend\n\ndef insert(node_t, key, priority)\n  if node_t == nil\n    return Node.new(key,priority)\n  end\n  if key == node_t.key\n    return node_t\n  end\n\n  if key < node_t.key\n    node_t.left = insert(node_t.left, key, priority)\n    if node_t.priority < node_t.left.priority\n      node_t = right_rotate(node_t)\n    end\n  else\n    node_t.right = insert(node_t.right, key, priority)\n    if node_t.priority < node_t.right.priority\n      node_t = left_rotate(node_t)\n    end\n  end\n  return node_t\nend\n\ndef find?(key)\n  node_x = @root\n  loop do\n    if node_x == nil\n      return false\n    elsif node_x.key == key\n      return node_x\n    elsif key < node_x.key\n      node_x = node_x.left\n    else\n      node_x = node_x.right\n    end\n  end\nend\n\ndef delete(node_t, key)\n  if node_t == nil\n    return nil\n  end\n  if key < node_t.key\n    node_t.left = delete(node_t.left, key)\n  elsif key > node_t.key\n    node_t.right = delete(node_t.right, key)\n  else\n    return _delete(node_t, key)\n  end\n  return node_t\nend\n\ndef _delete(node_t, key)\n  if node_t.left == nil && node_t.right ==nil\n    return nil\n  elsif node_t.left == nil\n    node_t = left_rotate(node_t)\n  elsif node_t.right == nil\n    node_t = right_rotate(node_t)\n  else\n    if node_t.left.priority > node_t.right.priority\n      node_t = right_rotate(node_t)\n    else\n      node_t = left_rotate(node_t)\n    end\n  end\n  return delete(node_t, key)\nend\n\n\ndef inorder_tree_walk(node)\n  if node != nil\n    inorder_tree_walk(node.left)\n    print \" \"\n    print node.key\n    inorder_tree_walk(node.right)\n  end\nend\n\ndef preorder_tree_walk(node)\n  if node != nil\n    print \" \"\n    print node.key\n    preorder_tree_walk(node.left)\n    preorder_tree_walk(node.right)\n  end\nend\n\ndef print_tree\n  inorder_tree_walk(@root)\n  puts\n  preorder_tree_walk(@root)\n  puts\nend\n\n\n@root = nil\n\nm = gets.to_i\nm.times do |t|\n  input = gets.split(\" \")\n  command = input.shift\n  input.map!{|x| x.to_i}\n  if command == \"insert\"\n    @root = insert(@root, input[0], input[1])\n  elsif command == \"find\"\n    if find?(input[0])\n      puts \"yes\"\n    else\n      puts \"no\"\n    end\n  elsif command == \"delete\"\n    @root = delete(@root, input[0])\n  else\n    print_tree\n  end\nend\n\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.io.PrintWriter\n\nfun main(args: Array<String>) = with(PrintWriter(System.out)) {\n    var root: Node? = null\n\n    val n = readLine()!!.toInt()\n    for (i in 1..n) {\n        val cmds = readLine()!!.split(' ')\n        when (cmds[0]) {\n            \"insert\" -> {\n                val t = Treep.insert(root, cmds[1].toInt(), cmds[2].toInt())\n                root ?: run { root = t}\n            }\n            \"print\" -> {\n                Treep.printInorder(root, this); println()\n                Treep.printPreorder(root, this); println()\n            }\n            \"find\" -> {\n                println(if (Treep.find(root, cmds[1].toInt())) \"yes\" else \"no\" )\n            }\n            \"delete\" -> {\n                root = Treep.delete(root, cmds[1].toInt())\n            }\n        }\n    }\n\n\n    flush()\n}\n\nobject Treep {\n    private fun rightRotate(t: Node): Node {\n        val s = t.left!!\n        t.left = s.right\n        s.right = t\n        return s\n    }\n\n    private fun leftRotate(t: Node): Node {\n        val s = t.right!!\n        t.right = s.left\n        s.left = t\n        return s\n    }\n\n\n    fun insert(t: Node?, key: Int, priority: Int): Node {\n        t ?: return Node(key, priority)\n        if (key == t.key) return t\n        else if (key < t.key) {\n            t.left = insert(t.left, key, priority)\n            return if (t.priority < t.left!!.priority)\n                rightRotate(t)\n            else t\n        } else {\n            t.right = insert(t.right, key, priority)\n            return if (t.priority < t.right!!.priority)\n                leftRotate(t)\n            else t\n        }\n    }\n\n    fun delete(t: Node?, key: Int): Node? {\n        t ?: return null\n//        printDebug(t); println()\n        if (key == t.key)\n            return _delete(t, key)\n        if (key < t.key)\n            t.left  = delete(t.left,  key)\n        else\n            t.right = delete(t.right, key)\n        return t\n    }\n\n    fun _delete(t: Node, key: Int): Node? {\n        if (t.left == null && t.right == null)\n            return null\n        val t = if (t.left == null)\n            leftRotate(t)\n        else if (t.right == null)\n            rightRotate(t)\n        else if (t.left!!.priority > t.right!!.priority)\n            rightRotate(t)\n        else\n            leftRotate(t)\n        return delete(t, key)\n    }\n\n    fun find(t: Node?, key: Int): Boolean {\n        t ?: return false\n        if (t.key == key)\n            return true\n        return if (t.key < key)\n            find(t.right, key)\n        else\n            find(t.left, key)\n    }\n\n    fun printInorder(t: Node?, writer: PrintWriter) {\n        t ?: return\n        printInorder(t.left, writer)\n        writer.print(' ')\n        writer.print(t.key)\n        printInorder(t.right, writer)\n    }\n\n    fun printPreorder(t: Node?, writer: PrintWriter) {\n        t ?: return\n        writer.print(' ')\n        writer.print(t.key)\n        printPreorder(t.left, writer)\n        printPreorder(t.right, writer)\n    }\n\n    fun printDebug(t: Node?) {\n        t ?: return\n        print('(')\n        printDebug(t.left)\n        print(t.key)\n        printDebug(t.right)\n        print(')')\n    }\n}\n\ndata class Node(\n    val key: Int,\n    val priority: Int,\n    var left: Node? = null,\n    var right: Node? = null\n)\n"
  },
  {
    "language": "Kotlin",
    "code": "\n\nsealed class Treap<out V, out H>{\n    abstract fun inOrderWalk(separator: String = \" \", prefix: String = \"\", suffix: String = \"\"): String\n    abstract fun preOrderWalk(separator: String = \" \", prefix: String = \"\", suffix: String = \"\"): String\n    data class Node<V: Comparable<V>, H: Comparable<H>> constructor (val value:V, val heap:H, val left: Treap<V, H> = Nil, val right: Treap<V, H> = Nil): Treap<V, H>() {\n        override fun preOrderWalk(separator: String, prefix: String, suffix: String): String {\n            return \"$prefix$value${left.preOrderWalk(separator, separator,\"\")}${right.preOrderWalk(separator,separator, \"\")}$suffix\"\n        }\n\n        override fun inOrderWalk(separator: String, prefix: String, suffix: String): String {\n            return \"$prefix${left.inOrderWalk(separator, \"\", separator)}$value${right.inOrderWalk(separator, separator, \"\")}$suffix\"\n        }\n\n    }\n\n    object Nil: Treap<Nothing, Nothing>() {\n        override fun inOrderWalk(separator: String, prefix: String, suffix: String): String {\n            return \"\"\n        }\n\n        override fun preOrderWalk(separator: String, prefix: String, suffix: String): String {\n            return \"\"\n        }\n    }\n\n    companion object {\n        operator fun <V: Comparable<V>, H: Comparable<H>>invoke(): Treap<V, H> = Nil\n        operator fun <V: Comparable<V>, H: Comparable<H>>invoke(value: V, heap: H): Treap<V, H> {\n            return Node(value, heap)\n        }\n        fun <V: Comparable<V>, H: Comparable<H>> insert(treap: Treap<V, H>, value: V, heap: H): Node<V, H> {\n            return when(treap){\n                is Nil -> Node(value, heap)\n                is Node<V, H> -> if (treap.value > value){\n                    val newLeft = insert(treap.left, value, heap)\n                    if (heap > treap.heap) Node(value, heap, newLeft.left, Node(treap.value, treap.heap, newLeft.right, treap.right))\n                    else Node(treap.value, treap.heap, newLeft, treap.right)\n                }else {\n                    val newRight = insert(treap.right, value, heap)\n                    if (heap > treap.heap) Node(value, heap, Node(treap.value, treap.heap, treap.left, newRight.left), newRight.right)\n                    else Node(treap.value, treap.heap, treap.left, newRight)\n                }\n            }\n        }\n        fun <V: Comparable<V>, H: Comparable<H>> deleteNode(treap: Treap<V, H>, value:V): Treap<V, H> {\n            return when(treap){\n                is Nil -> treap\n                is Node<V, H> ->\n                    when{\n                        treap.value < value -> Node(treap.value, treap.heap, treap.left, deleteNode(treap.right, value))\n                        treap.value > value -> Node(treap.value, treap.heap, deleteNode(treap.left, value), treap.right)\n                        else -> deleteThis(treap)\n                    }\n            }\n        }\n        private fun <V: Comparable<V>, H: Comparable<H>> deleteThis(treap: Treap<V, H>): Treap<V, H> {\n            return when(treap) {\n                is Nil -> treap\n                is Node<V, H> -> {\n                    when{\n                        treap.left is Node<V, H> && treap.right is Node<V, H> ->\n                            if (treap.left.heap > treap.right.heap) Node(treap.left.value, treap.left.heap, treap.left.left, deleteThis(Node(treap.value, treap.heap, treap.left.right, treap.right)))\n                            else Node(treap.right.value, treap.right.heap, deleteThis(Node(treap.value, treap.heap, treap.left, treap.right.left)), treap.right.right)\n                        treap.left is Nil -> treap.right\n                        else -> treap.left\n                    }\n                }\n            }\n        }\n    }\n}\nfun <V: Comparable<V>> Treap<V, *>.find(value:V): Boolean {\n    return when(this){\n        is Treap.Nil -> false\n        is Treap.Node<V, *> -> when{\n            this.value < value -> right.find(value)\n            this.value > value -> left.find(value)\n            else -> true\n        }\n    }\n}\nfun <V: Comparable<V>, H: Comparable<H>> Treap<V, H>.insert(value: V, heap: H): Treap<V, H> {\n    return Treap.insert(this, value, heap)\n}\nfun <V: Comparable<V>, H: Comparable<H>> Treap<V, H>.delete(value: V): Treap<V, H> {\n    return Treap.deleteNode(this, value)\n}\n\nfun main(args:Array<String>): Unit {\n    var treap = Treap<Int, Int>()\n    repeat(readLine()!!.toInt()){\n        val order = readLine()!!.trim().split(' ')\n        when(order.first()){\n            \"insert\" -> treap = treap.insert(order[1].toInt(), order[2].toInt())\n            \"delete\" -> treap = treap.delete(order[1].toInt())\n            \"find\" -> println(if (treap.find(order[1].toInt())) \"yes\" else \"no\")\n            else -> {\n                println(treap.inOrderWalk())\n                println(treap.preOrderWalk())\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import Treap.Companion.deleteNode\nimport Treap.Companion.insert\nimport sun.plugin.com.event.COMEventHandler\n\n\nsealed class Treap<out V, out H>{\n    abstract fun inOrderWalk(separator: String = \" \", prefix: String = \"\", suffix: String = \"\"): String\n    abstract fun preOrderWalk(separator: String = \" \", prefix: String = \"\", suffix: String = \"\"): String\n    data class Node<V: Comparable<V>, H: Comparable<H>> constructor (val value:V, val heap:H, val left: Treap<V, H> = Nil, val right: Treap<V, H> = Nil): Treap<V, H>() {\n        override fun preOrderWalk(separator: String, prefix: String, suffix: String): String {\n            return \"$prefix$value${left.preOrderWalk(separator, separator,\"\")}${right.preOrderWalk(separator,separator, \"\")}$suffix\"\n        }\n\n        override fun inOrderWalk(separator: String, prefix: String, suffix: String): String {\n            return \"$prefix${left.inOrderWalk(separator, \"\", separator)}$value${right.inOrderWalk(separator, separator, \"\")}$suffix\"\n        }\n\n    }\n\n    object Nil: Treap<Nothing, Nothing>() {\n        override fun inOrderWalk(separator: String, prefix: String, suffix: String): String {\n            return \"\"\n        }\n\n        override fun preOrderWalk(separator: String, prefix: String, suffix: String): String {\n            return \"\"\n        }\n    }\n\n    companion object {\n        operator fun <V: Comparable<V>, H: Comparable<H>>invoke(): Treap<V, H> = Nil\n        operator fun <V: Comparable<V>, H: Comparable<H>>invoke(value: V, heap: H): Treap<V, H> {\n            return Node(value, heap)\n        }\n        fun <V: Comparable<V>, H: Comparable<H>> insert(treap: Treap<V, H>, value: V, heap: H): Node<V, H> {\n            return when(treap){\n                is Nil -> Node(value, heap)\n                is Node<V, H> -> if (treap.value > value){\n                    val newLeft = insert(treap.left, value, heap)\n                    if (heap > treap.heap) Node(value, heap, newLeft.left, Node(treap.value, treap.heap, newLeft.right, treap.right))\n                    else Node(treap.value, treap.heap, newLeft, treap.right)\n                }else {\n                    val newRight = insert(treap.right, value, heap)\n                    if (heap > treap.heap) Node(value, heap, Node(treap.value, treap.heap, treap.left, newRight.left), newRight.right)\n                    else Node(treap.value, treap.heap, treap.left, newRight)\n                }\n            }\n        }\n        fun <V: Comparable<V>, H: Comparable<H>> deleteNode(treap: Treap<V, H>, value:V): Treap<V, H> {\n            return when(treap){\n                is Nil -> treap\n                is Node<V, H> ->\n                    when{\n                        treap.value < value -> Node(treap.value, treap.heap, treap.left, deleteNode(treap.right, value))\n                        treap.value > value -> Node(treap.value, treap.heap, deleteNode(treap.left, value), treap.right)\n                        else -> deleteThis(treap)\n                    }\n            }\n        }\n        private fun <V: Comparable<V>, H: Comparable<H>> deleteThis(treap: Treap<V, H>): Treap<V, H> {\n            return when(treap) {\n                is Nil -> treap\n                is Node<V, H> -> {\n                    when{\n                        treap.left is Node<V, H> && treap.right is Node<V, H> ->\n                            if (treap.left.heap > treap.right.heap) Node(treap.left.value, treap.left.heap, treap.left.left, deleteThis(Node(treap.value, treap.heap, treap.left.right, treap.right)))\n                            else Node(treap.right.value, treap.right.heap, deleteThis(Node(treap.value, treap.heap, treap.left, treap.right.left)), treap.right.right)\n                        treap.left is Nil -> treap.right\n                        else -> treap.left\n                    }\n                }\n            }\n        }\n    }\n}\nfun <V: Comparable<V>> Treap<V, *>.find(value:V): Boolean {\n    return when(this){\n        is Treap.Nil -> false\n        is Treap.Node<V, *> -> when{\n            this.value < value -> right.find(value)\n            this.value > value -> left.find(value)\n            else -> true\n        }\n    }\n}\nfun <V: Comparable<V>, H: Comparable<H>> Treap<V, H>.insert(value: V, heap: H): Treap<V, H> {\n    return Treap.insert(this, value, heap)\n}\nfun <V: Comparable<V>, H: Comparable<H>> Treap<V, H>.delete(value: V): Treap<V, H> {\n    return deleteNode(this, value)\n}\n\nfun main(args:Array<String>): Unit {\n    var treap = Treap<Int, Int>()\n    repeat(readLine()!!.toInt()){\n        val order = readLine()!!.trim().split(' ')\n        when(order.first()){\n            \"insert\" -> treap = treap.insert(order[1].toInt(), order[2].toInt())\n            \"delete\" -> treap = treap.delete(order[1].toInt())\n            \"find\" -> println(if (treap.find(order[1].toInt())) \"yes\" else \"no\")\n            else -> {\n                println(treap.inOrderWalk())\n                println(treap.preOrderWalk())\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.io.PrintWriter\n\nfun main(args: Array<String>) = with(PrintWriter(System.out)) {\n    var root: Node? = null\n\n    val n = readLine()!!.toInt()\n    for (i in 1..n) {\n        val cmds = readLine()!!.split(' ')\n        when (cmds[0]) {\n            \"insert\" -> {\n                val t = Treep.insert(root, cmds[1].toInt(), cmds[2].toInt())\n                root ?: run { root = t}\n            }\n            \"print\" -> {\n                Treep.printInorder(root, this); println()\n                Treep.printPreorder(root, this); println()\n            }\n            \"find\" -> {\n                println(if (Treep.find(root, cmds[1].toInt())) \"yes\" else \"no\" )\n            }\n            \"delete\" -> {\n                root = Treep.delete(root, cmds[1].toInt())\n            }\n        }\n    }\n\n\n    flush()\n}\n\nobject Treep {\n    private fun rightRotate(t: Node): Node {\n        val s = t.left!!\n        t.left = s.right\n        s.right = t\n        return s\n    }\n\n    private fun leftRotate(t: Node): Node {\n        val s = t.right!!\n        t.right = s.left\n        s.left = t\n        return s\n    }\n\n\n    fun insert(t: Node?, key: Int, priority: Int): Node {\n        t ?: return Node(key, priority)\n        if (key == t.key) return t\n        else if (key < t.key) {\n            t.left = insert(t.left, key, priority)\n            return if (t.priority < t.left!!.priority)\n                rightRotate(t)\n            else t\n        } else {\n            t.right = insert(t.right, key, priority)\n            return if (t.priority < t.right!!.priority)\n                leftRotate(t)\n            else t\n        }\n    }\n\n    fun delete(t: Node?, key: Int): Node? {\n        t ?: return null\n//        printDebug(t); println()\n        if (key == t.key)\n            return _delete(t, key)\n        if (key < t.key)\n            t.left  = delete(t.left,  key)\n        else\n            t.right = delete(t.right, key)\n        return t\n    }\n\n    fun _delete(t: Node, key: Int): Node? {\n        if (t.left == null && t.right == null)\n            return null\n        val s = if (t.left == null)\n            leftRotate(t)\n        else if (t.right == null)\n            rightRotate(t)\n        else if (t.left!!.priority > t.right!!.priority)\n            rightRotate(t)\n        else\n            leftRotate(t)\n        return delete(s, key)\n    }\n\n    fun find(t: Node?, key: Int): Boolean {\n        t ?: return false\n        if (t.key == key)\n            return true\n        return if (t.key < key)\n            find(t.right, key)\n        else\n            find(t.left, key)\n    }\n\n    fun printInorder(t: Node?, writer: PrintWriter) {\n        t ?: return\n        printInorder(t.left, writer)\n        writer.print(' ')\n        writer.print(t.key)\n        printInorder(t.right, writer)\n    }\n\n    fun printPreorder(t: Node?, writer: PrintWriter) {\n        t ?: return\n        writer.print(' ')\n        writer.print(t.key)\n        printPreorder(t.left, writer)\n        printPreorder(t.right, writer)\n    }\n\n    fun printDebug(t: Node?) {\n        t ?: return\n        print('(')\n        printDebug(t.left)\n        print(t.key)\n        printDebug(t.right)\n        print(')')\n    }\n}\n\ndata class Node(\n    val key: Int,\n    val priority: Int,\n    var left: Node? = null,\n    var right: Node? = null\n)\n"
  },
  {
    "language": "Kotlin",
    "code": "\n\nsealed class Treap<out V, out H>{\n    abstract fun inOrderWalk(separator: String = \" \", prefix: String = \"\", suffix: String = \"\"): String\n    abstract fun preOrderWalk(separator: String = \" \", prefix: String = \"\", suffix: String = \"\"): String\n    data class Node<V: Comparable<V>, H: Comparable<H>> constructor (val value:V, val heap:H, val left: Treap<V, H> = Nil, val right: Treap<V, H> = Nil): Treap<V, H>() {\n        override fun preOrderWalk(separator: String, prefix: String, suffix: String): String {\n            return \"$prefix$value${left.preOrderWalk(separator, separator,\"\")}${right.preOrderWalk(separator,separator, \"\")}$suffix\"\n        }\n\n        override fun inOrderWalk(separator: String, prefix: String, suffix: String): String {\n            return \"$prefix${left.inOrderWalk(separator, \"\", separator)}$value${right.inOrderWalk(separator, separator, \"\")}$suffix\"\n        }\n\n    }\n\n    object Nil: Treap<Nothing, Nothing>() {\n        override fun inOrderWalk(separator: String, prefix: String, suffix: String): String {\n            return \"\"\n        }\n\n        override fun preOrderWalk(separator: String, prefix: String, suffix: String): String {\n            return \"\"\n        }\n    }\n\n    companion object {\n        operator fun <V: Comparable<V>, H: Comparable<H>>invoke(): Treap<V, H> = Nil\n        operator fun <V: Comparable<V>, H: Comparable<H>>invoke(value: V, heap: H): Treap<V, H> {\n            return Node(value, heap)\n        }\n        fun <V: Comparable<V>, H: Comparable<H>> insert(treap: Treap<V, H>, value: V, heap: H): Node<V, H> {\n            return when(treap){\n                is Nil -> Node(value, heap)\n                is Node<V, H> -> if (treap.value > value){\n                    val newLeft = insert(treap.left, value, heap)\n                    if (heap > treap.heap) Node(value, heap, newLeft.left, Node(treap.value, treap.heap, newLeft.right, treap.right))\n                    else Node(treap.value, treap.heap, newLeft, treap.right)\n                }else {\n                    val newRight = insert(treap.right, value, heap)\n                    if (heap > treap.heap) Node(value, heap, Node(treap.value, treap.heap, treap.left, newRight.left), newRight.right)\n                    else Node(treap.value, treap.heap, treap.left, newRight)\n                }\n            }\n        }\n        fun <V: Comparable<V>, H: Comparable<H>> deleteNode(treap: Treap<V, H>, value:V): Treap<V, H> {\n            return when(treap){\n                is Nil -> treap\n                is Node<V, H> ->\n                    when{\n                        treap.value < value -> Node(treap.value, treap.heap, treap.left, deleteNode(treap.right, value))\n                        treap.value > value -> Node(treap.value, treap.heap, deleteNode(treap.left, value), treap.right)\n                        else -> deleteThis(treap)\n                    }\n            }\n        }\n        private fun <V: Comparable<V>, H: Comparable<H>> deleteThis(treap: Treap<V, H>): Treap<V, H> {\n            return when(treap) {\n                is Nil -> treap\n                is Node<V, H> -> {\n                    when{\n                        treap.left is Node<V, H> && treap.right is Node<V, H> ->\n                            if (treap.left.heap > treap.right.heap) Node(treap.left.value, treap.left.heap, treap.left.left, deleteThis(Node(treap.value, treap.heap, treap.left.right, treap.right)))\n                            else Node(treap.right.value, treap.right.heap, deleteThis(Node(treap.value, treap.heap, treap.left, treap.right.left)), treap.right.right)\n                        treap.left is Nil -> treap.right\n                        else -> treap.left\n                    }\n                }\n            }\n        }\n    }\n}\nfun <V: Comparable<V>> Treap<V, *>.find(value:V): Boolean {\n    return when(this){\n        is Treap.Nil -> false\n        is Treap.Node<V, *> -> when{\n            this.value < value -> right.find(value)\n            this.value > value -> left.find(value)\n            else -> true\n        }\n    }\n}\nfun <V: Comparable<V>, H: Comparable<H>> Treap<V, H>.insert(value: V, heap: H): Treap<V, H> {\n    return Treap.insert(this, value, heap)\n}\nfun <V: Comparable<V>, H: Comparable<H>> Treap<V, H>.delete(value: V): Treap<V, H> {\n    return Treap.deleteNode(this, value)\n}\n\nfun main(args:Array<String>): Unit {\n    var treap = Treap<Int, Int>()\n    repeat(readLine()!!.toInt()){\n        val order = readLine()!!.trim().split(' ')\n        when(order.first()){\n            \"insert\" -> treap = treap.insert(order[1].toInt(), order[2].toInt())\n            \"delete\" -> treap = treap.delete(order[1].toInt())\n            \"find\" -> println(if (treap.find(order[1].toInt())) \"yes\" else \"no\")\n            else -> {\n                println(treap.inOrderWalk(\" \", \" \"))\n                println(treap.preOrderWalk(\" \", \" \"))\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.io.PrintWriter\n\nfun main(args: Array<String>) = with(PrintWriter(System.out)) {\n    var root: Node? = null\n\n    val n = readLine()!!.toInt()\n    for (i in 1..n) {\n        val cmds = readLine()!!.split(' ')\n        when (cmds[0]) {\n            \"insert\" -> {\n                root = Treep.insert(root, cmds[1].toInt(), cmds[2].toInt())\n            }\n            \"print\" -> {\n                Treep.printInorder(root, this); println()\n                Treep.printPreorder(root, this); println()\n            }\n            \"find\" -> {\n                println(if (Treep.find(root, cmds[1].toInt())) \"yes\" else \"no\" )\n            }\n            \"delete\" -> {\n                root = Treep.delete(root, cmds[1].toInt())\n            }\n        }\n    }\n\n\n    flush()\n}\n\nobject Treep {\n    private fun rightRotate(t: Node): Node {\n        val s = t.left!!\n        t.left = s.right\n        s.right = t\n        return s\n    }\n\n    private fun leftRotate(t: Node): Node {\n        val s = t.right!!\n        t.right = s.left\n        s.left = t\n        return s\n    }\n\n\n    fun insert(t: Node?, key: Int, priority: Int): Node {\n        t ?: return Node(key, priority)\n        if (key == t.key) return t\n        else if (key < t.key) {\n            t.left = insert(t.left, key, priority)\n            return if (t.priority < t.left!!.priority)\n                rightRotate(t)\n            else t\n        } else {\n            t.right = insert(t.right, key, priority)\n            return if (t.priority < t.right!!.priority)\n                leftRotate(t)\n            else t\n        }\n    }\n\n    fun delete(t: Node?, key: Int): Node? {\n        t ?: return null\n//        printDebug(t); println()\n        if (key == t.key)\n            return _delete(t, key)\n        if (key < t.key)\n            t.left  = delete(t.left,  key)\n        else\n            t.right = delete(t.right, key)\n        return t\n    }\n\n    fun _delete(t: Node, key: Int): Node? {\n        if (t.left == null && t.right == null)\n            return null\n        val s = if (t.left == null)\n            leftRotate(t)\n        else if (t.right == null)\n            rightRotate(t)\n        else if (t.left!!.priority > t.right!!.priority)\n            rightRotate(t)\n        else\n            leftRotate(t)\n        return delete(s, key)\n    }\n\n    fun find(t: Node?, key: Int): Boolean {\n        t ?: return false\n        if (t.key == key)\n            return true\n        return if (t.key < key)\n            find(t.right, key)\n        else\n            find(t.left, key)\n    }\n\n    fun printInorder(t: Node?, writer: PrintWriter) {\n        t ?: return\n        printInorder(t.left, writer)\n        writer.print(' ')\n        writer.print(t.key)\n        printInorder(t.right, writer)\n    }\n\n    fun printPreorder(t: Node?, writer: PrintWriter) {\n        t ?: return\n        writer.print(' ')\n        writer.print(t.key)\n        printPreorder(t.left, writer)\n        printPreorder(t.right, writer)\n    }\n\n    fun printDebug(t: Node?) {\n        t ?: return\n        print('(')\n        printDebug(t.left)\n        print(t.key)\n        printDebug(t.right)\n        print(')')\n    }\n}\n\ndata class Node(\n    val key: Int,\n    val priority: Int,\n    var left: Node? = null,\n    var right: Node? = null\n)\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    class Node {\n        int key, priority;\n        Node left = null, right = null, parent = null;\n        Node(int key) {\n            this.key = key;\n        }\n        Node(int key, int priority) {\n            this.key = key;\n            this.priority = priority;\n        }\n    }\n\n    Node tree;\n\n    boolean needPrefix = true;\n    void inorder(Node t) {\n        needPrefix = false;\n        inorder_(t);\n    }\n    void inorder_(Node t) {\n        if (t == null) {\n            return;\n        }\n        if (t.left != null) {\n            inorder_(t.left);\n        }\n        if (needPrefix) {\n            System.out.print(\" \");\n        }\n        System.out.print(t.key);\n        needPrefix = true;\n        if (t.right != null) {\n            inorder_(t.right);\n        }\n    }\nvoid preorder(Node t) {\n        needPrefix = false;\n        preorder_(t);\n    }\n    void preorder_(Node t) {\n        if (t == null) {\n            return;\n        }\n        if (needPrefix) {\n            System.out.print(\" \");\n        }\n        System.out.print(t.key);\n        needPrefix = true;\n        if (t.left != null) {\n            preorder_(t.left);\n        }\n        if (t.right != null) {\n            preorder_(t.right);\n        }\n    }\n\n    Node rightRotate(Node t) {\n        Node s = t.left;\n        t.left = s.right;\n        s.right = t;\n        return s;\n    }\n    Node leftRotate(Node t) {\n        Node s = t.right;\n        t.right = s.left;\n        s.left = t;\n        return s;\n    }\nvoid insert(int key) {\n       Node y = null;\n       Node x = tree;\n       while (x != null) {\n           y = x;\n           if (key < x.key) {\n               x = x.left;\n           } else {\n               x = x.right;\n           }\n       }\n       Node z = new Node(key);\n       z.parent = y;\n       if (y == null) {\n           this.tree = z;\n       } else if (z.key < y.key) {\n           y.left = z;\n       } else {\n           y.right = z;\n       }\n    }\n\n    Node insertTreap(Node t, int key, int priority) {\n        if (t == null) return new Node(key, priority);\n        if (key == t.key) return t;\n        if (key < t.key) {\n            t.left = insertTreap(t.left, key, priority);\n            if (t.priority < t.left.priority)\n                t = rightRotate(t);\n        } else {\n            t.right = insertTreap(t.right, key, priority);\n            if (t.priority < t.right.priority)\n                t = leftRotate(t);\n        }\n        return t;\n    }\nNode deleteTreap_(Node t, int key) {\n        if (t.left == null && t.right == null) return null;\n        else if (t.left == null) t = leftRotate(t);\n        else if (t.right == null) t = rightRotate(t);\n        else {\n            if (t.left.priority > t.right.priority)\n                t = rightRotate(t);\n            else\n                t = leftRotate(t);\n        }\n        return deleteTreap(t, key);\n    }\n    Node deleteTreap(Node t, int key) {\n        if (t == null) return null;\n        if (key < t.key) t.left = deleteTreap(t.left, key);\n        else if (key > t.key) t.right = deleteTreap(t.right, key);\n        else return deleteTreap_(t, key);\n        return t;\n    }\n\n    Node find(Node t, int k) {\n        if (t == null) return null;\n        if (t.key == k) return t;\n        if (t.key > k) return find(t.left, k);\n        else return find(t.right, k);\n    }\n    void delete1(Node t, Node c) {\n        Node p = t.parent;\n        if (p == null) {\n            this.tree = c;\n        } else if (p.left == t) {\n            p.left = c;\n        } else if (p.right == t) {\n            p.right = c;\n        } else {\n            System.out.println(\"ERROR delete1\");\n        }\n        if (c != null) {\n            c.parent = p;\n        }\n    }\nNode getNextNode(Node t) {\n        if (t.left != null) {\n            return getNextNode(t.left);\n        } else if (t.right != null) {\n            return getNextNode(t.right);\n        } else return t;\n    }\n    Node getNextNodeInorder(Node t) {\n        Node subt = null;\n        if (t.right != null) {\n            subt = t.right;\n        } else {\n            Node p = t.parent;\n            while (p != null) {\n                if (p.right != t) {\n                    subt = p.right;\n                    break;\n                }\n            }\n        }\n        if (subt == null) {\n            System.out.println(\"ERROR\");\n        }\n        return getNextNode(subt);\n    }\nvoid delete(int k) {\n        Node t = find(this.tree, k);\n        if (t == null) return;\n        if (t.left == null && t.right == null) {\n            delete1(t, null);\n            return;\n        } else if (t.left == null) {\n            delete1(t, t.right);\n            return;\n        } else if (t.right == null) {\n            delete1(t, t.left);\n            return;\n        }\n        Node y = getNextNodeInorder(t);\n        t.key = y.key;\n        if (y.left == null && y.right == null) {\n            delete1(y, null);\n            return;\n        } else if (y.left == null) {\n            delete1(y, y.right);\n            return;\n        } else if (y.right == null) {\n            delete1(y, y.left);\n            return;\n        }\n    }\nvoid run() {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        for (int i = 0; i < n; i++) {\n            String inst = sc.next();\n            if (\"insert\".equals(inst)) {\n                int key = sc.nextInt();\n                int priority = sc.nextInt();\n                this.tree = insertTreap(this.tree, key, priority);\n            } else if (\"find\".equals(inst)) {\n                if (find(tree, sc.nextInt()) != null) {\n                    System.out.println(\"yes\");\n                } else {\n                    System.out.println(\"no\");\n                }\n            } else if (\"delete\".equals(inst)) {\n                this.tree = deleteTreap(this.tree, sc.nextInt());\n            } else {\n                inorder_(tree);\n                System.out.println();\n                preorder_(tree);\n                System.out.println();\n            }\n        }\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solve();\n\t}\n\n\tpublic void solve() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint numOps = scanner.nextInt();\n\t\tint key, pri;\n\t\tNode root = null;\n\n\t\tfor(int i = 0; i < numOps; i++) {\n\t\t\tString op = scanner.next();\n\n\t\t\tif(op.equals(\"insert\")) {\n\t\t\t\tkey = scanner.nextInt();\n\t\t\t\tpri = scanner.nextInt();\n\t\t\t\troot = insert(root, key, pri);\n\t\t\t} else if(op.equals(\"find\")) {\n\t\t\t\tkey = scanner.nextInt();\n\t\t\t\tSystem.out.println(find(root, key) ? \"yes\" : \"no\");\n\t\t\t} else if(op.equals(\"delete\")) {\n\t\t\t\tkey = scanner.nextInt();\n\t\t\t\troot = erase(root, key);\n\t\t\t} else if(op.equals(\"print\")) {\n\t\t\t\tprintTreap(root);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Node rightRotate(Node t) {\n\t\tNode s = t.left;\n\t\tt.left = s.right;\n\t\ts.right = t;\n\t\treturn s;\n\t}\n\n\tpublic Node leftRotate(Node t) {\n\t\tNode s = t.right;\n\t\tt.right = s.left;\n\t\ts.left = t;\n\t\treturn s;\n\t}\n\n\tpublic Node insert(Node t, int key, int pri) {\n\t\tif(t == null)\n\t\t\treturn new Node(key, pri);\n\n\t\tif(key == t.key)\n\t\t\treturn t;\n\n\t\tif(key < t.key) {\n\t\t\tt.left = insert(t.left, key, pri);\n\t\t\tif(t.pri < t.left.pri)\n\t\t\t\tt = rightRotate(t);\n\t\t} else {\n\t\t\tt.right = insert(t.right, key, pri);\n\t\t\tif(t.pri < t.right.pri)\n\t\t\t\tt = leftRotate(t);\n\t\t}\n\n\t\treturn t;\n\t}\n\n\tpublic Node erase(Node t, int key) {\n\t\tif(t == null)\n\t\t\treturn null;\n\n\t\tif(key == t.key) {\n\t\t\tif(t.left == null && t.right == null)\n\t\t\t\treturn null;\n\t\t\telse if(t.left == null)\n\t\t\t\tt = leftRotate(t);\n\t\t\telse if(t.right == null)\n\t\t\t\tt = rightRotate(t);\n\t\t\telse {\n\t\t\t\tif(t.left.pri > t.right.pri)\n\t\t\t\t\tt = rightRotate(t);\n\t\t\t\telse \n\t\t\t\t\tt = leftRotate(t);\n\t\t\t}\n\n\t\t\treturn erase(t, key);\n\t\t}\n\n\t\tif(key < t.key)\n\t\t\tt.left = erase(t.left, key);\n\t\telse\n\t\t\tt.right = erase(t.right, key);\n\n\t\treturn t;\n\t}\n\n\tpublic boolean find(Node root, int target) {\n\t\tif(root == null)\n\t\t\treturn false;\n\n\t\tif(root.key == target)\n\t\t\treturn true;\n\t\telse if(root.key < target)\n\t\t\treturn find(root.right, target);\n\t\telse\n\t\t\treturn find(root.left, target);\n\t}\n\n\tpublic void printTreap(Node root) {\n\t\tinorderTraverse(root);\n\t\tSystem.out.println();\n\t\tpreorderTraverse(root);\n\t\tSystem.out.println();\n\t}\n\n\tprivate void inorderTraverse(Node root) {\n\t\tif(root != null) {\n\t\t\tinorderTraverse(root.left);\n\t\t\tSystem.out.print(\" \" + root.key);\n\t\t\tinorderTraverse(root.right);\n\t\t}\n\t}\n\n\tprivate void preorderTraverse(Node root) {\n\t\tif(root != null) {\n\t\t\tSystem.out.print(\" \" + root.key);\n\t\t\tpreorderTraverse(root.left);\n\t\t\tpreorderTraverse(root.right);\n\t\t}\n\t}\n\n\tclass Node {\n\t\tint key;\n\t\tint pri;\n\t\tNode left;\n\t\tNode right;\n\n\t\tpublic Node(int k, int p) {\n\t\t\tkey = k;\n\t\t\tpri = p;\n\t\t\tleft = null;\n\t\t\tright = null;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Node {\n\tint key, priority;\n\tNode parent, left, right;\n\n\tpublic Node(int key, int priority) {\n\t\tsuper();\n\t\tthis.key = key;\n\t\tthis.priority = priority;\n\t}\n\n}\n\nclass Tree {\n\tNode root;\n\n\tNode rightRotate(Node t) {\n\t\tNode s = t.left;\n\t\tt.left = s.right;\n\t\ts.right = t;\n\t\tif (t == this.root) {\n\t\t\tthis.root = s;\n\t\t}\n\t\treturn s;\n\t}\n\n\tNode leftRotate(Node t) {\n\t\tNode s = t.right;\n\t\tt.right = s.left;\n\t\ts.left = t;\n\t\tif (t == this.root) {\n\t\t\tthis.root = s;\n\t\t}\n\t\treturn s;\n\t}\n\n\tNode insert(Node t, int key, int priority) {\n\t\tif (this.root == null) {\n\t\t\tthis.root = new Node(key, priority);\n\t\t\treturn t;\n\t\t}\n\t\tif (t == null) {\n\t\t\treturn new Node(key, priority);\n\t\t}\n\t\tif (key == t.key) {\n\t\t\treturn t;\n\t\t}\n\n\t\tif (key < t.key) {\n\t\t\tt.left = insert(t.left, key, priority);\n\t\t\tif (t.priority < t.left.priority) {\n\t\t\t\tt = rightRotate(t);\n\t\t\t}\n\t\t} else {\n\t\t\tt.right = insert(t.right, key, priority);\n\t\t\tif (t.priority < t.right.priority) {\n\t\t\t\tt = leftRotate(t);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\n\t}\n\n\n\tNode delete(Node t, int key) {\n\t\tif (t == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (key < t.key) {\n\t\t\tt.left = delete(t.left, key);\n\t\t} else if(key > t.key) {\n\t\t\t t.right = delete(t.right, key);\n\t\t} else {\n\t\t\treturn _delete(t, key);\n\t\t}\n\n\t\treturn t;\n\t}\n\n\tNode _delete(Node t, int key) {\n\t\tif (t.left == null && t.right == null) {\n\t\t\treturn null;\n\t\t} else if (t.left == null) {\n\t\t\tt = leftRotate(t);\n\t\t} else if (t.right == null) {\n\t\t\tt = rightRotate(t);\n\t\t} else {\n\t\t\tif (t.left.priority > t.right.priority) {\n\t\t\t\tt = rightRotate(t);\n\t\t\t} else {\n\t\t\t\tt = leftRotate(t);\n\t\t\t}\n\t\t}\n\n\t\treturn delete(t, key);\n\t}\n\n\tboolean find(Node t, int key) {\n\t\tif (t == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (key < t.key) {\n\t\t\treturn find(t.left, key);\n\t\t} else if (key > t.key) {\n\t\t\treturn find(t.right, key);\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\n\n}\n\npublic class Main {\n\n\tstatic StringBuilder sb;\n\n\tpublic static void printPreOrder(Node node) {\n\t\tif (node == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tsb.append(\" \" + node.key);\n\t\tprintPreOrder(node.left);\n\t\tprintPreOrder(node.right);\n\t}\n\n\tpublic static void printInOrder(Node node) {\n\t\tif (node == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tprintInOrder(node.left);\n\t\tsb.append(\" \" + node.key);\n\t\tprintInOrder(node.right);\n\t}\n\n\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint m = Integer.parseInt(br.readLine());\n\t\tString[] operation;\n\t\tint key, priority;\n\t\tTree tree = new Tree();\n\t\tsb = new StringBuilder();\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\toperation = br.readLine().split(\" \");\n\t\t\tif (operation[0].equals(\"insert\")) {\n\t\t\t\tkey = Integer.parseInt(operation[1]);\n\t\t\t\tpriority = Integer.parseInt(operation[2]);\n\t\t\t\ttree.insert(tree.root, key, priority);\n\t\t\t} else if (operation[0].equals(\"find\")) {\n\t\t\t\tkey = Integer.parseInt(operation[1]);\n\t\t\t\tif (tree.find(tree.root, key)) {\n\t\t\t\t\tSystem.out.println(\"yes\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"no\");\n\t\t\t\t}\n\t\t\t} else if (operation[0].equals(\"delete\")) {\n\t\t\t\tkey = Integer.parseInt(operation[1]);\n\t\t\t\ttree.delete(tree.root, key);\n\t\t\t} else {\n\t\t\t\tprintInOrder(tree.root);\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t\tprintPreOrder(tree.root);\n\t\t\t\tSystem.out.println(sb.toString());\n\t\t\t\tsb.setLength(0);\n\t\t\t}\n\t\t}\n\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main {\n\tstatic Node r;\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint x;\n\t\tint y;\n\t\tString com;\n\t\tint cnt=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcom = sc.next();\n\t\t\tif(com.equals(\"insert\")){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\ty = sc.nextInt();\n\t\t\t\tr = insert(r, x, y);\n\t\t\t\t\n\t\t\t} else if (com.equals(\"find\")){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tif(find(r, x) != null) System.out.println(\"yes\");\n\t\t\t\telse System.out.println(\"no\");\n\t\t\t\t\n\t\t\t} else if (com.equals(\"delete\")){\n\t\t\t\tx = sc.nextInt();\n\t\t\t\tr = delete(r, x);\n\t\t\t\t\n\t\t\t} else if (com.equals(\"print\")){\n\t\t\t\tinorder(r);\n\t\t\t\tSystem.out.println();\n\t\t\t\tpreorder(r);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic Node delete(Node t, int key){\n\t\tif (t == null) return null;\n\t\tif (key < t.key) t.l = delete(t.l, key);\n\t\telse if (key > t.key) t.r = delete(t.r, key);\n\t\telse return _delete(t, key);\n\t\treturn t;\n\t}\n\t\n\tstatic Node _delete(Node t, int key){\n\t\tif (t.l == null && t.r == null) return null;\n\t\telse if (t.l == null) t = leftRotate(t);\n\t\telse if (t.r == null) t = rightRotate(t);\n\t\telse {\n\t\t\tif (t.l.priority > t.r.priority) t = rightRotate(t);\n\t\t\telse t = leftRotate(t);\n\t\t}\n\t\treturn delete(t, key);\n\t}\n\t\n\t\n\tstatic Node find(Node u, int k){\n\t\twhile (u != null && k != u.key){\n\t\t\tif(k < u.key) u = u.l;\n\t\t\telse u = u.r;\n\t\t}\n\t\treturn u;\n\t}\n\t\n\tstatic Node insert(Node t, int key, int priority){\n\t\tif (t == null) return new Node(key, null, null ,null, priority);\n\t\tif (key == t.key) return t;\n\t\tif (key < t.key){\n\t\t\tt.l = insert(t.l, key, priority);\n\t\t\tif (t.priority < t.l.priority) t = rightRotate(t);\n\t\t} else {\n\t\t\tt.r = insert(t.r, key, priority);\n\t\t\tif (t.priority < t.r.priority) t = leftRotate(t);\n\t\t}\n\t\treturn t;\n\t}\n\t\n\tstatic Node rightRotate(Node t){\n\t\tNode s = t.l;\n\t\tt.l = s.r;\n\t\ts.r = t;\n\t\treturn s;\n\t}\n\t\n\tstatic Node leftRotate(Node t){\n\t\tNode s = t.r;\n\t\tt.r = s.l;\n\t\ts.l = t;\n\t\treturn s;\n\t}\n\n\tstatic void inorder(Node u){\n\t\tif (u == null) return;\n\t\tinorder(u.l);\n\t\tSystem.out.print(\" \" + u.key);\n\t\tinorder(u.r);\n\t}\n\tstatic void preorder(Node u) {\n\t\tif (u == null) return;\n\t\tSystem.out.print(\" \" + u.key);\n\t\tpreorder(u.l);\n\t\tpreorder(u.r);\n\t}\n}\n\n\nclass Node {\n    int key;\n    Node p = null;\n\tNode l = null;\n\tNode r = null;\n\tint priority;\n    public Node(int key, Node p, Node l, Node r, int priority) {\n    \tthis.key = key;\n        this.l = l;\n        this.r = r;\n        this.p = p;\n        this.priority = priority;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.ArrayList;\npublic class Main {\n\n  public static class Node {\n    int key;\n    int priority;\n    Node left;\n    Node right;\n    Node p;\n    public Node(int key, int priority) {\n      this.key = key;\n      this.priority = priority;\n      this.left = null;\n      this.right = null;\n      this.p = null;\n    }\n  }\n\n  public static class Tree {\n    Node root;\n    public Tree() {\n      this.root = null;\n    }\n  }\n\n  public static Node rightRotate(Node t) {\n    Node s = t.left;\n    t.left = s.right;\n    s.right = t;\n    return s;\n  }\n\n  public static Node leftRotate(Node t) {\n    Node s = t.right;\n    t.right = s.left;\n    s.left = t;\n    return s;\n  }\n\n  public static Node insert(Node t, int key, int priority) {\n    if (t == null)\n      return new Node(key, priority);\n    if (key == t.key)\n      return t;\n    if (key < t.key) {\n      t.left = insert(t.left, key, priority);\n      if (t.priority < t.left.priority)\n        t = rightRotate(t);\n    } else {\n      t.right = insert(t.right, key, priority);\n      if (t.priority < t.right.priority)\n        t = leftRotate(t);\n    }\n    return t;\n  }\n\n  public static boolean find_helper(Node x, int k) {\n    if (x == null)\n      return false;\n    if (x.key == k)\n      return true;\n    if (k <= x.key)\n      return find_helper(x.left, k);\n    else\n      return find_helper(x.right, k);\n  }\n\n  public static String find(Node x, int k) {\n    if (find_helper(x, k))\n      return \"yes\";\n    return \"no\";\n  }\n\n  public static Node delete(Node t, int key) {\n    if (t == null)\n      return null;\n    if (key < t.key)\n      t.left = delete(t.left, key);\n    else if (key > t.key)\n      t.right = delete(t.right, key);\n    else\n      return deleteHelper(t, key);\n    return t;\n  }\n\n  public static Node deleteHelper(Node t, int key) {\n    if (t.left == null && t.right == null)\n      return null;\n    else if (t.left == null)\n      t = leftRotate(t);\n    else if (t.right == null)\n      t = rightRotate(t);\n    else {\n      if (t.left.priority > t.right.priority)\n        t = rightRotate(t);\n      else\n        t = leftRotate(t);\n    }\n    return delete(t, key);\n  }\n\n  public static String print_inorder(Node x) {\n    String a = \"\";\n    if (x != null) {\n      a = a + print_inorder(x.left);\n      a = a + \" \" + x.key;\n      a = a + print_inorder(x.right);\n    }\n    return a;\n  }\n\n  public static String print_preorder(Node x) {\n    String a = \"\";\n    if (x != null) {\n      a = a + \" \" + x.key;\n      a = a + print_preorder(x.left);\n      a = a + print_preorder(x.right);\n    }\n    return a;\n  }\n\n  public static void main(String[] args) {\n    Scanner s = new Scanner(System.in);\n    int m = s.nextInt();\n    ArrayList<String> results = new ArrayList<String>();\n    Tree T = new Tree();\n    for (int i = 0; i < m; i++) {\n      String cmd = s.next();\n      switch(cmd) {\n        case \"insert\":\n          int key = s.nextInt();\n          int priority = s.nextInt();\n          T.root = insert(T.root, key, priority);\n          break;\n        case \"find\":\n          int k = s.nextInt();\n          results.add(find(T.root, k));\n          break;\n        case \"delete\":\n          k = s.nextInt();\n          T.root = delete(T.root, k);\n          break;\n        case \"print\":\n          results.add(print_inorder(T.root));\n          results.add(print_preorder(T.root));\n          break;\n        default:\n          break;\n      }\n    }\n    s.close();\n    for (String result : results) {\n      System.out.println(result);\n    }\n  }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    final static int NIL = -1;\n    public static TNode root = new TNode(NIL, NIL);\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt();\n        for(int i = 0; i < n; i++) {\n            String cmd = input.next();\n            if (cmd.equals(\"insert\")) {\n                int key = Integer.parseInt(input.next());\n                int pri = Integer.parseInt(input.next());\n                TNode z = new TNode(key, pri);\n                insert(root, z);\n            } else if (cmd.equals(\"find\")) {\n                int key = Integer.parseInt(input.next());\n                System.out.println(find(root, key).key != NIL? \"yes\":\"no\");\n            } else if (cmd.equals(\"delete\")) {\n                int key = Integer.parseInt(input.next());\n                delete(root, key);\n            } else if (cmd.equals(\"print\")) {\n                inOrder(root);\n                System.out.println();\n                preOrder(root);\n                System.out.println();\n            }\n        }\n    }\n    public static TNode insert(TNode t, TNode z) {\n        if(t.key == NIL) {\n            z.left = new TNode(NIL, NIL);\n            z.right = new TNode(NIL, NIL);\n            if(t.parent == null) { // 如果为空树，修改 root\n                z.parent = new TNode(NIL, NIL);\n                root = z;\n            }\n            return z; // 达到叶子节点时创建新节点\n        }\n        if(z.key == t.key) {\n            return t; // 忽略重复 key\n        } else if(z.key < t.key) {\n            t.left.parent = t;\n            t.left = insert(t.left, z);\n            if(t.pri < t.left.pri) {\n                t = rightRotate(t);\n            }\n        } else {\n            t.right.parent = t;\n            t.right = insert(t.right, z);\n            if (t.pri< t.right.pri) {\n                t = leftRotate(t);\n            }\n        }\n        return t;\n    }\n    public static TNode rightRotate(TNode t) {\n        TNode s = t.left;\n        s.parent = t.parent;\n        if(t.parent.key == NIL) {\n            root = s;\n        }\n        t.parent = s;\n        t.left = s.right;\n        s.right = t;\n        return s;\n    }\n    public static TNode leftRotate(TNode t) {\n        TNode s = t.right;\n        s.parent = t.parent;\n        if(t.parent.key == NIL) {\n            root = s;\n        }\n        t.parent = s;\n        t.right = s.left;\n        s.left = t;\n        return s;\n    }\n    public static TNode find(TNode root, int key) {\n        TNode x = root;\n        TNode y = new TNode(NIL, NIL);\n        while( x.key != NIL) {\n            if (key == x.key) {\n                y = x;\n                break;\n            } else if(key < x.key) {\n                x = x.left;\n            } else {\n                x = x.right;\n            }\n        }\n        return y;\n    }\n    public static TNode delete(TNode t, int key) { // 递归寻找目标\n        if(t.key == NIL) { // 找不到目标\n            return new TNode(NIL, NIL);\n        }\n        if(key < t.key) {\n            t.left = delete(t.left, key);\n        } else if(key > t.key) {\n            t.right = delete(t.right, key);\n        } else { // 找到目标\n            return _delete(t, key);\n        }\n        return t;\n    }\n    public static TNode _delete(TNode t, int key) {\n        if(t.left.key == NIL && t.right.key == NIL) { // 如果是叶子节点\n            return new TNode(NIL, NIL); // 目标节点在通过旋转操作称为叶子节点后才移除\n        } else if(t.left.key == NIL) { // 如果只有右子树，则左旋转\n            t = leftRotate(t);\n        } else if(t.right.key == NIL) { // 如果只有左子树，则右旋转\n            t = rightRotate(t);\n        } else { // 如果左右子树都有\n            if(t.left.pri > t.right.pri) {\n                t = rightRotate(t);\n            } else {\n                t = leftRotate(t);\n            }\n        }\n        return delete(t, key);\n    }\n    public static TNode getSuccessor(TNode x) {\n        if(x.right.key != NIL) {\n            return getMinium(x.right);\n        }\n        TNode y = x.parent;\n        while(y.key != NIL && x == y.right) { // 寻找中序遍历后一个节点\n            x = y;\n            y = y.parent;\n        }\n        return y;\n    }\n    public static TNode getMinium(TNode x) {\n        while (x.left.key != NIL) {\n            x = x.left;\n        }\n        return x;\n    }\n    public static void preOrder(TNode node) {\n        if(node.key == NIL) {\n            return;\n        }\n        System.out.print(\" \" + node.key);\n        preOrder(node.left);\n        preOrder(node.right);\n    }\n    public static void inOrder(TNode node) {\n        if(node.key == NIL) {\n            return;\n        }\n        inOrder(node.left);\n        System.out.print(\" \" + node.key);\n        inOrder(node.right);\n    }\n}\n\nclass TNode {\n    int key;\n    int pri;\n    TNode left, right ,parent;\n    TNode(int key, int pri) {\n        this.key = key;\n        this.pri = pri;\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().surprise();\n\t}\n\n\tpublic void surprise() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint numOps = scanner.nextInt();\n\t\tint key, pri;\n\t\tNode root = null;\n\n\t\tfor(int i = 0; i < numOps; i++) {\n\t\t\tString op = scanner.next();\n\n\t\t\tif(op.equals(\"insert\")) {\n\t\t\t\tkey = scanner.nextInt();\n\t\t\t\tpri = scanner.nextInt();\n\t\t\t\troot = insert(root, key, pri);\n\t\t\t} else if(op.equals(\"find\")) {\n\t\t\t\tkey = scanner.nextInt();\n\t\t\t\tSystem.out.println(find(root, key) ? \"yes\" : \"no\");\n\t\t\t} else if(op.equals(\"delete\")) {\n\t\t\t\tkey = scanner.nextInt();\n\t\t\t\troot = erase(root, key);\n\t\t\t} else if(op.equals(\"print\")) {\n\t\t\t\tprintTreap(root);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Node rightRotate(Node t) {\n\t\tNode s = t.left;\n\t\tt.left = s.right;\n\t\ts.right = t;\n\t\treturn s;\n\t}\n\n\tpublic Node leftRotate(Node t) {\n\t\tNode s = t.right;\n\t\tt.right = s.left;\n\t\ts.left = t;\n\t\treturn s;\n\t}\n\n\tpublic Node insert(Node t, int key, int pri) {\n\t\tif(t == null)\n\t\t\treturn new Node(key, pri);\n\n\t\tif(key == t.key)\n\t\t\treturn t;\n\n\t\tif(key < t.key) {\n\t\t\tt.left = insert(t.left, key, pri);\n\t\t\tif(t.pri < t.left.pri)\n\t\t\t\tt = rightRotate(t);\n\t\t} else {\n\t\t\tt.right = insert(t.right, key, pri);\n\t\t\tif(t.pri < t.right.pri)\n\t\t\t\tt = leftRotate(t);\n\t\t}\n\n\t\treturn t;\n\t}\n\n\tpublic Node erase(Node t, int key) {\n\t\tif(t == null)\n\t\t\treturn null;\n\n\t\tif(key == t.key) {\n\t\t\tif(t.left == null && t.right == null)\n\t\t\t\treturn null;\n\t\t\telse if(t.left == null)\n\t\t\t\tt = leftRotate(t);\n\t\t\telse if(t.right == null)\n\t\t\t\tt = rightRotate(t);\n\t\t\telse {\n\t\t\t\tif(t.left.pri > t.right.pri)\n\t\t\t\t\tt = rightRotate(t);\n\t\t\t\telse \n\t\t\t\t\tt = leftRotate(t);\n\t\t\t}\n\n\t\t\treturn erase(t, key);\n\t\t}\n\n\t\tif(key < t.key)\n\t\t\tt.left = erase(t.left, key);\n\t\telse\n\t\t\tt.right = erase(t.right, key);\n\n\t\treturn t;\n\t}\n\n\tpublic boolean find(Node root, int target) {\n\t\tif(root == null)\n\t\t\treturn false;\n\n\t\tif(root.key == target)\n\t\t\treturn true;\n\t\telse if(root.key < target)\n\t\t\treturn find(root.right, target);\n\t\telse\n\t\t\treturn find(root.left, target);\n\t}\n\n\tpublic void printTreap(Node root) {\n\t\tinorderTraverse(root);\n\t\tSystem.out.println();\n\t\tpreorderTraverse(root);\n\t\tSystem.out.println();\n\t}\n\n\tprivate void inorderTraverse(Node root) {\n\t\tif(root != null) {\n\t\t\tinorderTraverse(root.left);\n\t\t\tSystem.out.print(\" \" + root.key);\n\t\t\tinorderTraverse(root.right);\n\t\t}\n\t}\n\n\tprivate void preorderTraverse(Node root) {\n\t\tif(root != null) {\n\t\t\tSystem.out.print(\" \" + root.key);\n\t\t\tpreorderTraverse(root.left);\n\t\t\tpreorderTraverse(root.right);\n\t\t}\n\t}\n\n\tclass Node {\n\t\tint key;\n\t\tint pri;\n\t\tNode left;\n\t\tNode right;\n\n\t\tpublic Node(int k, int p) {\n\t\t\tkey = k;\n\t\t\tpri = p;\n\t\t\tleft = null;\n\t\t\tright = null;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass Node {\n\tint key, priority;\n\tNode parent, left, right;\n\n\tpublic Node(int key, int priority) {\n\t\tsuper();\n\t\tthis.key = key;\n\t\tthis.priority = priority;\n\t}\n\n}\n\nclass Tree {\n\tNode root;\n\n\tNode rightRotate(Node t) {\n\t\tNode s = t.left;\n\t\tt.left = s.right;\n\t\ts.right = t;\n\t\tif (t == this.root) {\n\t\t\tthis.root = s;\n\t\t}\n\t\treturn s;\n\t}\n\n\tNode leftRotate(Node t) {\n\t\tNode s = t.right;\n\t\tt.right = s.left;\n\t\ts.left = t;\n\t\tif (t == this.root) {\n\t\t\tthis.root = s;\n\t\t}\n\t\treturn s;\n\t}\n\n//\tvoid insert(Node z) {\n//\t\tNode y = null;\n//\t\tNode x = this.root;\n//\t\twhile (x != null) {\n//\t\t\ty = x;\n//\t\t\tif (z.key < x.key) {\n//\t\t\t\tx = y.left;\n//\t\t\t} else {\n//\t\t\t\tx = y.right;\n//\t\t\t}\n//\t\t}\n//\t\tz.parent = y;\n//\n//\t\tif (y == null) {\n//\t\t\tthis.root = z;\n//\t\t} else if (z.key < y.key) {\n//\t\t\ty.left = z;\n//\t\t} else {\n//\t\t\ty.right = z;\n//\t\t}\n//\t}\n\n\tNode insert(Node t, int key, int priority) {\n\t\tif (this.root == null) {\n\t\t\tthis.root = new Node(key, priority);\n\t\t\treturn t;\n\t\t}\n\t\tif (t == null) {\n\t\t\treturn new Node(key, priority);\n\t\t}\n\t\tif (key == t.key) {\n\t\t\treturn t;\n\t\t}\n\n\t\tif (key < t.key) {\n\t\t\tt.left = insert(t.left, key, priority);\n\t\t\tif (t.priority < t.left.priority) {\n\t\t\t\tt = rightRotate(t);\n\t\t\t}\n\t\t} else {\n\t\t\tt.right = insert(t.right, key, priority);\n\t\t\tif (t.priority < t.right.priority) {\n\t\t\t\tt = leftRotate(t);\n\t\t\t}\n\t\t}\n\t\treturn t;\n\n\t}\n\n\n\tNode delete(Node t, int key) {\n\t\tif (t == null) {\n\t\t\treturn null;\n\t\t}\n\t\tif (key < t.key) {\n\t\t\tt.left = delete(t.left, key);\n\t\t} else if(key > t.key) {\n\t\t\t t.right = delete(t.right, key);\n\t\t} else {\n\t\t\treturn _delete(t, key);\n\t\t}\n\n\t\treturn t;\n\t}\n\n\tNode _delete(Node t, int key) {\n\t\tif (t.left == null && t.right == null) {\n\t\t\treturn null;\n\t\t} else if (t.left == null) {\n\t\t\tt = leftRotate(t);\n\t\t} else if (t.right == null) {\n\t\t\tt = rightRotate(t);\n\t\t} else {\n\t\t\tif (t.left.priority > t.right.priority) {\n\t\t\t\tt = rightRotate(t);\n\t\t\t} else {\n\t\t\t\tt = leftRotate(t);\n\t\t\t}\n\t\t}\n\n\t\treturn delete(t, key);\n\t}\n\n\tboolean find(Node t, int key) {\n\t\tif (t == null) {\n\t\t\treturn false;\n\t\t}\n\t\tif (key < t.key) {\n\t\t\treturn find(t.left, key);\n\t\t} else if (key > t.key) {\n\t\t\treturn find(t.right, key);\n\t\t} else {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\n\n}\n\npublic class Main {\n\n\tstatic StringBuilder sb;\n\n\tpublic static void printPreOrder(Node node) {\n\t\tif (node == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tsb.append(\" \" + node.key);\n\t\tprintPreOrder(node.left);\n\t\tprintPreOrder(node.right);\n\t}\n\n\tpublic static void printInOrder(Node node) {\n\t\tif (node == null) {\n\t\t\treturn;\n\t\t}\n\n\t\tprintInOrder(node.left);\n\t\tsb.append(\" \" + node.key);\n\t\tprintInOrder(node.right);\n\t}\n\n\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint m = Integer.parseInt(br.readLine());\n\t\tString[] operation;\n\t\tint key, priority;\n\t\tTree tree = new Tree();\n\t\tsb = new StringBuilder();\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\toperation = br.readLine().split(\" \");\n\t\t\tif (operation[0].equals(\"insert\")) {\n\t\t\t\tkey = Integer.parseInt(operation[1]);\n\t\t\t\tpriority = Integer.parseInt(operation[2]);\n\t\t\t\ttree.insert(tree.root, key, priority);\n\t\t\t} else if (operation[0].equals(\"find\")) {\n\t\t\t\tkey = Integer.parseInt(operation[1]);\n\t\t\t\tif (tree.find(tree.root, key)) {\n\t\t\t\t\tSystem.out.println(\"yes\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"no\");\n\t\t\t\t}\n\t\t\t} else if (operation[0].equals(\"delete\")) {\n\t\t\t\tkey = Integer.parseInt(operation[1]);\n\t\t\t\ttree.delete(tree.root, key);\n\t\t\t} else {\n\t\t\t\tprintInOrder(tree.root);\n\t\t\t\tsb.append(\"\\n\");\n\t\t\t\tprintPreOrder(tree.root);\n\t\t\t\tSystem.out.println(sb.toString());\n\t\t\t\tsb.setLength(0);\n\t\t\t}\n\t\t}\n\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().surprise();\n\t}\n\n\tpublic void surprise() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint numOps = scanner.nextInt();\n\t\tint key, pri;\n\t\tNode root = null;\n\n\t\tfor(int i = 0; i < numOps; i++) {\n\t\t\tString op = scanner.next();\n\n\t\t\tif(op.equals(\"insert\")) {\n\t\t\t\tkey = scanner.nextInt();\n\t\t\t\tpri = scanner.nextInt();\n\t\t\t\troot = insert(root, key, pri);\n\t\t\t} else if(op.equals(\"find\")) {\n\t\t\t\tkey = scanner.nextInt();\n\t\t\t\tSystem.out.println(find(root, key) ? \"yes\" : \"no\");\n\t\t\t} else if(op.equals(\"delete\")) {\n\t\t\t\tkey = scanner.nextInt();\n\t\t\t\troot = erase(root, key);\n\t\t\t} else if(op.equals(\"print\")) {\n\t\t\t\tprintTreap(root);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Node rightRotate(Node t) {\n\t\tNode s = t.left;\n\t\tt.left = s.right;\n\t\ts.right = t;\n\t\treturn s;\n\t}\n\n\tpublic Node leftRotate(Node t) {\n\t\tNode s = t.right;\n\t\tt.right = s.left;\n\t\ts.left = t;\n\t\treturn s;\n\t}\n\n\tpublic Node insert(Node t, int key, int pri) {\n\t\tif(t == null)\n\t\t\treturn new Node(key, pri);\n\n\t\tif(key == t.key)\n\t\t\treturn t;\n\n\t\tif(key < t.key) {\n\t\t\tt.left = insert(t.left, key, pri);\n\t\t\tif(t.pri < t.left.pri)\n\t\t\t\tt = rightRotate(t);\n\t\t} else {\n\t\t\tt.right = insert(t.right, key, pri);\n\t\t\tif(t.pri < t.right.pri)\n\t\t\t\tt = leftRotate(t);\n\t\t}\n\n\t\treturn t;\n\t}\n\n\tpublic Node erase(Node t, int key) {\n\t\tif(t == null)\n\t\t\treturn null;\n\n\t\tif(key == t.key) {\n\t\t\tif(t.left == null && t.right == null)\n\t\t\t\treturn null;\n\t\t\telse if(t.left == null)\n\t\t\t\tt = leftRotate(t);\n\t\t\telse if(t.right == null)\n\t\t\t\tt = rightRotate(t);\n\t\t\telse {\n\t\t\t\tif(t.left.pri > t.right.pri)\n\t\t\t\t\tt = rightRotate(t);\n\t\t\t\telse \n\t\t\t\t\tt = leftRotate(t);\n\t\t\t}\n\n\t\t\treturn erase(t, key);\n\t\t}\n\n\t\tif(key < t.key)\n\t\t\tt.left = erase(t.left, key);\n\t\telse\n\t\t\tt.right = erase(t.right, key);\n\n\t\treturn t;\n\t}\n\n\tpublic boolean find(Node root, int target) {\n\t\tif(root == null)\n\t\t\treturn false;\n\n\t\tif(root.key == target)\n\t\t\treturn true;\n\t\telse if(root.key < target)\n\t\t\treturn find(root.right, target);\n\t\telse\n\t\t\treturn find(root.left, target);\n\t}\n\n\tpublic void printTreap(Node root) {\n\t\tinorderTraverse(root);\n\t\tSystem.out.println();\n\t\tpreorderTraverse(root);\n\t\tSystem.out.println();\n\t}\n\n\tprivate void inorderTraverse(Node root) {\n\t\tif(root != null) {\n\t\t\tinorderTraverse(root.left);\n\t\t\tSystem.out.print(\" \" + root.key);\n\t\t\tinorderTraverse(root.right);\n\t\t}\n\t}\n\n\tprivate void preorderTraverse(Node root) {\n\t\tif(root != null) {\n\t\t\tSystem.out.print(\" \" + root.key);\n\t\t\tpreorderTraverse(root.left);\n\t\t\tpreorderTraverse(root.right);\n\t\t}\n\t}\n\n\tclass Node {\n\t\tint key;\n\t\tint pri;\n\t\tNode left;\n\t\tNode right;\n\n\t\tpublic Node(int k, int p) {\n\t\t\tkey = k;\n\t\t\tpri = p;\n\t\t\tleft = null;\n\t\t\tright = null;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n    static int root_value = 0;\n    public static void main(String [] args){\n        Scanner sc = new Scanner(System.in);\n        int n  = sc.nextInt();\n        ArrayList<Node> T = new ArrayList<>();\n        Map<Integer,Integer> L = new HashMap<>();\n        for(int i=0;i<n;i++) {\n            String command = sc.next();\n            if (command.charAt(0) == 'i') {\n                Node v = new Node();\n                int value = sc.nextInt();\n                int priority = sc.nextInt();\n                if (T.size() == 0) {\n                    root_value = value;\n                    v.element(value, priority, -1, -1, -1);\n                    L.put(v.value, T.size());\n                    T.add(v);\n                } else insert(T, L, value, priority, root_value);\n            } else if (command.charAt(0) == 'f') {\n                int value = sc.nextInt();\n                boolean check = false;\n                check = find(T, L, value, root_value, check);\n                if (check) System.out.println(\"yes\");\n                else System.out.println(\"no\");\n            } else if (command.charAt(0) == 'd') {\n                int value = sc.nextInt();\n                delete(T,L,value,root_value);\n            } else {\n                StringBuilder P = new StringBuilder();\n                StringBuilder I = new StringBuilder();\n                //for(Node v:T) System.out.println(v.value+\":\"+v.parent+\"-\"+v.left+\"-\"+v.right);\n                print(T, L, root_value, P, I);\n                System.out.println(I);\n                System.out.println(P);\n            }\n        }\n    }\n    public static void print(ArrayList<Node>T,Map<Integer,Integer>L,int value,StringBuilder P,StringBuilder I){\n        P.append(\" \"+value);\n        if(T.get(L.get(value)).left!=-1)print(T,L,T.get(L.get(value)).left,P,I);\n        I.append(\" \"+value);\n        if(T.get(L.get(value)).right!=-1)print(T,L,T.get(L.get(value)).right,P,I);\n    }\n    public static void insert(ArrayList<Node>T,Map<Integer,Integer> L,int value,int priority,int now_value){\n        if(T.get(L.get(now_value)).value>value){\n            if(T.get(L.get(now_value)).left==-1){\n                Node v = new Node();\n                v.element(value,priority,now_value,-1,-1);\n                L.put(value,T.size());\n                T.add(v);\n                T.get(L.get(now_value)).left=value;\n            }\n            else insert(T,L,value,priority,T.get(L.get(now_value)).left);\n            int left_value = T.get(L.get(now_value)).left;\n           if(T.get(L.get(now_value)).priority<T.get(L.get(left_value)).priority) right_rotate(T,L,now_value);\n        }\n        else if(T.get(L.get(now_value)).value<value){\n            if(T.get(L.get(now_value)).right==-1){\n                Node v = new Node();\n                v.element(value,priority,now_value,-1,-1);\n                L.put(value,T.size());\n                T.add(v);\n                T.get(L.get(now_value)).right=value;\n            }\n            else insert(T,L,value,priority,T.get(L.get(now_value)).right);\n            int right_value = T.get(L.get(now_value)).right;\n           if(T.get(L.get(now_value)).priority< T.get(L.get(right_value)).priority) left_rotate(T,L,now_value);\n        }\n    }\n    public static boolean find(ArrayList<Node> T,Map<Integer,Integer>L,int value,int now_value,boolean check){\n        if(now_value==value) check =true;\n        else if(T.get(L.get(now_value)).left!=-1&&value<now_value)check = find(T,L,value,T.get(L.get(now_value)).left,check);\n        else if(T.get(L.get(now_value)).right!=-1&&value>now_value)check = find(T,L,value,T.get(L.get(now_value)).right,check);\n        return check;\n    }\n    public static void delete(ArrayList<Node> T,Map<Integer,Integer>L,int value,int now_value){\n        if(value<now_value&&T.get(L.get(now_value)).left!=-1) delete(T,L,value,T.get(L.get(now_value)).left);\n        else if(value>now_value&&T.get(L.get(now_value)).right!=-1)delete(T,L,value,T.get(L.get(now_value)).right);\n        else if(value==now_value){\n            if(T.get(L.get(value)).left==-1&&T.get(L.get(value)).right==-1) delete_node(T,L,value);\n            else if(T.get(L.get(value)).left==-1) {\n                if(root_value==value)root_value = T.get(L.get(value)).right;\n                left_rotate(T,L,value);\n                delete(T,L,value,value);\n            }\n            else if(T.get(L.get(value)).right==-1){\n                if(root_value==value)root_value = T.get(L.get(value)).left;\n                right_rotate(T,L,value);\n                delete(T,L,value,value);\n            }\n            else{\n                int l = T.get(L.get(value)).left;\n                int r = T.get(L.get(value)).right;\n                if(T.get(L.get(l)).priority<T.get(L.get(r)).priority){\n                    if(root_value==value)root_value = T.get(L.get(value)).right;\n                    left_rotate(T,L,value);\n                    delete(T,L,value,value);\n                }\n                else {\n                    if(root_value==value)root_value = T.get(L.get(value)).left;\n                    right_rotate(T,L,value);\n                    delete(T,L,value,value);\n                }\n\n            }\n        }\n    }\n    public static void delete_node(ArrayList<Node> T,Map<Integer,Integer> L,int value){\n        int p = T.get(L.get(value)).parent;\n        if(p!=-1) {\n            if (T.get(L.get(p)).left == value) T.get(L.get(p)).left = -1;\n            else T.get(L.get(p)).right = -1;\n        }\n        if(T.get(L.get(value)).left!=-1){\n\n        }\n        T.get(L.get(value)).parent = -1;\n        T.get(L.get(value)).left = -1;\n        T.get(L.get(value)).right = -1;\n    }\n    public static void right_rotate(ArrayList<Node> T,Map<Integer,Integer> L,int p){\n        int c = T.get(L.get(p)).left;\n        int gc = T.get(L.get(c)).right;\n        int pp = T.get(L.get(p)).parent;\n        if(pp!=-1) {\n            if (T.get(L.get(pp)).left == p) T.get(L.get(pp)).left = c;\n            else T.get(L.get(pp)).right = c;\n        }\n        T.get(L.get(c)).parent = T.get(L.get(p)).parent;\n        T.get(L.get(c)).right = p;\n        T.get(L.get(p)).parent = c;\n        T.get(L.get(p)).left = gc;\n        if(gc!=-1) T.get(L.get(gc)).parent = p;\n        if(root_value==p) root_value=c;\n    }\n    public static void left_rotate(ArrayList<Node> T,Map<Integer,Integer> L,int p){\n        int c = T.get(L.get(p)).right;\n        int gc = T.get(L.get(c)).left;\n        int pp = T.get(L.get(p)).parent;\n        if(pp!=-1) {\n            if (T.get(L.get(pp)).left == p) T.get(L.get(pp)).left = c;\n            else T.get(L.get(pp)).right = c;\n        }\n        T.get(L.get(c)).parent = T.get(L.get(p)).parent;\n        T.get(L.get(c)).left = p;\n        T.get(L.get(p)).right = gc;\n        T.get(L.get(p)).parent = c;\n        if(gc!=-1) T.get(L.get(gc)).parent = p;\n        if(root_value==p) root_value=c;\n    }\n    public static class Node{\n        int value,priority,parent,left,right;\n        private void element(int value,int priority,int parent,int left,int right){\n            this.value = value;\n            this.priority = priority;\n            this.parent = parent;\n            this.left = left;\n            this.right = right;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n \nclass Node {\n    static Node root;\n \n    int key;\n    int priority;\n    Node left;\n    Node right;\n \n    Node(int key, int priority) {\n        this.key = key;\n        this.priority = priority;\n    }\n \n    private Node rightRotate() {\n        Node s = left;\n        left = s.right;\n        s.right = this;\n        return s;\n    }\n \n    private Node leftRotate() {\n        Node s = right;\n        right = s.left;\n        s.left = this;\n        return s;\n    }\n \n    Node insert(Node t) {\n        if(t == null) return this;\n        if(key == t.key) return t;\n \n        if(key < t.key) {\n            t.left = insert(t.left);\n            if(t.priority < t.left.priority) t = t.rightRotate();\n        }else {\n            t.right = insert(t.right);\n            if(t.priority < t.right.priority) t = t.leftRotate();\n        }\n \n        return t;\n    }\n \n    static Node find(int key) {\n        Node x = root;\n        while(x != null) {\n            if(key < x.key) x = x.left;\n            else if(x.key < key) x = x.right;\n            else return x;\n        }\n        return null;\n    }\n \n    static Node delete(Node t, int key) {\n        if(t == null) return null;\n        if(key < t.key) t.left = delete(t.left, key);\n        else if(key > t.key) t.right = delete(t.right, key);\n        else return _delete(t, key);\n        return t;\n    }\n \n    static Node _delete(Node t, int key) {\n        if(t.left == null && t.right == null) return null;\n        else if(t.left == null) t = t.leftRotate();\n        else if(t.right == null) t = t.rightRotate();\n        else {\n            if(t.left.priority > t.right.priority) t = t.rightRotate();\n            else t = t.leftRotate();\n        }\n        return delete(t, key);\n    }\n \n    static String inorder(Node x) {\n        String str = \"\";\n        if(x == null) return str;\n \n        if(x.left != null) str += inorder(x.left);\n        str += \" \" + x.key;\n        if(x.right != null)str += inorder(x.right);\n \n        return str;\n    }\n \n    static String preorder(Node x) {\n        String str = \"\";\n        if(x == null) return str;\n \n        str += \" \" + x.key;\n        if(x.left != null) str += preorder(x.left);\n        if(x.right != null) str += preorder(x.right);\n \n        return str;\n    }\n}\n \npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n  \n        Node.root = null;\n        int m = sc.nextInt();\n        for(int i = 0; i < m; i++) {\n            String cmd = sc.next();\n            if(cmd.equals(\"insert\")) {\n                Node.root = new Node(sc.nextInt(), sc.nextInt()).insert(Node.root);\n            }else if(cmd.equals(\"find\")) {\n                System.out.println(Node.find(sc.nextInt()) != null? \"yes\" : \"no\");\n            }else if(cmd.equals(\"delete\")) {\n                Node.root = Node.delete(Node.root, sc.nextInt());\n            }else {\n                System.out.println(Node.inorder(Node.root));\n                System.out.println(Node.preorder(Node.root));\n            }\n        }\n \n        sc.close();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t * @throws NumberFormatException \n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tint n = Integer.parseInt(br.readLine());\n\n\t\tNode head = null;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tString[] tmpArray = br.readLine().split(\" \");\n\t\t\tString op = tmpArray[0];\n\n\t\t\tif(op.equals(\"insert\")){\n\t\t\t\tint k = Integer.parseInt(tmpArray[1]);\n\t\t\t\tint p = Integer.parseInt(tmpArray[2]);\n\n\t\t\t\thead = insert(head, k, p);\n//\t\t\t\tSystem.out.println(\"insert\");\n\t\t\t\t\n//\t\t\t\tSystem.out.println(head);\n\t\t\t}\n\t\t\telse if(op.equals(\"find\")){\n\t\t\t\tint k = Integer.parseInt(tmpArray[1]);\n\n\t\t\t\tif(find(head, k)){\n\t\t\t\t\tSystem.out.println(\"yes\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.println(\"no\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(op.equals(\"delete\")){\n\t\t\t\tint k = Integer.parseInt(tmpArray[1]);\n\n\t\t\t\thead = delete(head, k);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tinorder(head);\n\t\t\t\tSystem.out.println();\n\t\t\t\tpreorder(head);\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic Node rightRotate(Node t){\n\t\tNode s = t.left;\n\t\tt.left = s.right;\n\t\ts.right = t;\n\t\treturn s;\n\t}\n\n\tstatic Node leftRotate(Node t){\n\t\tNode s = t.right;\n\t\tt.right = s.left;\n\t\ts.left = t;\n\t\treturn s;\n\t}\n\n\tstatic Node insert(Node t, int key, int priority){\n\t\tif(t == null){\n\t\t\treturn new Node(key, priority);\n\t\t}\n\n\t\tif(key == t.key){\n\t\t\treturn t;\n\t\t}\n\n\t\tif(key < t.key){\n\t\t\tt.left = insert(t.left, key, priority);\n\n\t\t\tif(t.priority < t.left.priority){\n\t\t\t\tt = rightRotate(t);\n\t\t\t}\n\t\t}\n\n\t\telse {\n\t\t\tt.right = insert(t.right, key, priority);\n\t\t\tif(t.priority < t.right.priority){\n\t\t\t\tt = leftRotate(t);\n\t\t\t}\n\t\t}\n\n\t\treturn t;\n\t}\n\n\tstatic boolean find(Node head, int key){\n\t\tNode node = head;\n\n\t\twhile(node != null){\n\t\t\tif(node.key == key){\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\telse if(node.key > key){\n\t\t\t\tnode = node.left;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnode = node.right;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tstatic void preorder(Node node){\n\t\tSystem.out.print(\" \"+node.key);\n\t\tif(node.left != null){\n\t\t\tpreorder(node.left);\n\t\t}\n\t\tif(node.right != null){\n\t\t\tpreorder(node.right);\n\t\t}\n\t}\n\n\tstatic void inorder(Node node){\n\t\tif(node.left != null){\n\t\t\tinorder(node.left);\n\t\t}\n\t\tSystem.out.print(\" \"+node.key);\n\t\tif(node.right != null){\n\t\t\tinorder(node.right);\n\t\t}\n\t}\n\n\n\tstatic Node delete(Node t, int key){\n\t\tif(t == null){\n\t\t\treturn null;\n\t\t}\n\n\t\tif(key < t.key){\n\t\t\tt.left = delete(t.left, key);\n\t\t}\n\t\telse if(key > t.key){\n\t\t\tt.right = delete(t.right, key);\n\t\t}\n\t\telse {\n\t\t\treturn delete2(t, key);\n\t\t}\n\n\t\treturn t;\n\t}\n\n\tstatic Node delete2(Node t, int key){\n\t\tif(t.left == null && t.right == null){\n\t\t\treturn null;\n\t\t}\n\n\t\telse if(t.left == null){\n\t\t\tt = leftRotate(t);\n\t\t}\n\t\telse if(t.right == null){\n\t\t\tt = rightRotate(t);\n\t\t}\n\t\telse {\n\t\t\tif(t.left.priority > t.right.priority){\n\t\t\t\tt = rightRotate(t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tt = leftRotate(t);\n\t\t\t}\n\t\t}\n\t\treturn delete(t, key);\n\t}\n}\n\nclass Node {\n\tNode left;\n\tNode right;\n\tint key;\n\tint priority;\n\n\tNode(int key, int priority){\n\t\tthis.key = key;\n\t\tthis.priority = priority;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n  public static void main(String[] args) {\n    \n    new Main().run();\n  }\n\n  public void run() {\n\n    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n      final int n = Integer.parseInt(br.readLine());\n      String op;\n      String[] words;\n      Treap tree = new Treap();\n      int key,p,t;\n\n      for(int i=0,k=0; i<n; i++,k=0){\n        words = br.readLine().split(\" \");\n        op  = words[k++];\n\n        switch( op ) {\n          case \"insert\" :\n            key = Integer.parseInt(words[k++]);\n            p   = Integer.parseInt(words[k]);\n            tree.insert(key,p);\n            break;\n          case \"find\" :\n            t = Integer.parseInt(words[k]);\n            System.out.println( tree.find(t) ? \"yes\" : \"no\" );\n            break;\n          case \"delete\" :\n            tree.delete(Integer.parseInt(words[k]));\n            break;\n          default :\n            tree.dispRoundPath();\n        }\n      }\n\n    }\n    catch(IOException e) {\n      System.out.println(\"IOException!\");\n    }\n  }\n}\n\nclass Treap {\n\n  static final int min = Integer.MIN_VALUE;\n  static final TreapNode NIL = new TreapNode(min,min);\n  TreapNode root;\n  StringBuilder buf;\n\n  public Treap() {\n    root = NIL;\n    buf = new StringBuilder();\n  }\n\n  public void insert(int key, int p) {\n    TreapNode y = NIL;\n    TreapNode x = root;\n    // TreapNode z = new TreapNode(key,p);\n    root = insertTreap(root, key, p);\n  }\n  private TreapNode insertTreap(TreapNode node, int key, int priority) {\n    if( node.equals(NIL) ) return new TreapNode(key, priority);\n    if( key == node.key ) return node;\n    if( key < node.key ) {\n      node.left = insertTreap(node.left, key, priority);\n      if( node.priority < node.left.priority ) node = rightRotate(node);\n    }\n    else {\n      node.right = insertTreap(node.right, key, priority);\n      if( node.priority < node.right.priority ) node = leftRotate(node);\n    }\n\n    return node;\n  }\n  private TreapNode rightRotate(TreapNode node) {\n    TreapNode t = node.left;\n    node.left = t.right;\n    t.right = node;\n    return t;\n  }\n  private TreapNode leftRotate(TreapNode node) {\n    TreapNode t = node.right;\n    node.right = t.left;\n    t.left = node;\n    return t;\n  }\n  public boolean find(int target) {\n    TreapNode x = root;\n\n    while( !x.equals(NIL) ) {\n      if( target == x.key )\n        return true;\n      else\n        x = target < x.key ? x.left : x.right;\n    }\n\n    return false;\n  }\n  public void delete(int target) {\n    root = deleteNode(root,target);\n  }\n  private TreapNode deleteNode(TreapNode node, int key) {\n    if( node.equals(NIL) ) return NIL;\n    if( key < node.key ) node.left = deleteNode(node.left, key);\n    else if( key > node.key ) node.right = deleteNode(node.right, key);\n    else return deleteNodeTP(node, key);\n\n    return node;\n  }\n  private TreapNode deleteNodeTP(TreapNode node, int key) {\n    if(node.left.equals(NIL) && node.right.equals(NIL)) return NIL;\n    else if(node.left.equals(NIL) ) node = leftRotate(node);\n    else if(node.right.equals(NIL)) node = rightRotate(node);\n    else node = node.left.priority > node.right.priority ?\n      rightRotate(node) : leftRotate(node);\n    \n    return deleteNode(node, key);\n  }\n  private void preParse(TreapNode u) {\n    if( !u.equals(NIL) ) {\n      buf.append(\" \").append(u.key);\n      preParse(u.left);\n      preParse(u.right);\n    }\n  }\n  private void inParse(TreapNode u) {\n    if( !u.equals(NIL) ) {\n      inParse(u.left);\n      buf.append(\" \").append(u.key);\n      inParse(u.right);\n    }\n  }\n\n  public void dispRoundPath() {\n\n    inParse(root);\n    buf.append(\"\\n\");\n    preParse(root);\n    buf.append(\"\\n\");\n\n    System.out.print(buf);\n    buf.setLength(0);\n  }\n}\n\nclass TreapNode {\n  int key,priority;\n  TreapNode parent,left,right;\n\n  public TreapNode(int key, int priority) {\n    this.key = key;\n    this.priority = priority;\n    this.parent =\n    this.left =\n    this.right = Treap.NIL;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if(o == this) return true;\n    if(o == null) return false;\n    if(!(o instanceof TreapNode)) return false;\n\n    TreapNode node = (TreapNode)o;\n    if(!(this.key == node.key)) return false;\n\n    return true;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nclass Node {\n    long key, priority;\n    Node left, right;\n\n    Node(long key, long priority) {\n        this.key = key;\n        this.priority = priority;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Node node = (Node) o;\n        return key == node.key &&\n                priority == node.priority &&\n                Objects.equals(left, node.left) &&\n                Objects.equals(right, node.right);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(key, priority, left, right);\n    }\n\n    @Override\n    public String toString() {\n        return \"Node{\" +\n                \"key=\" + key +\n                \", priority=\" + priority +\n                \", left=\" + left +\n                \", right=\" + right +\n                '}';\n    }\n}\n\nclass Treap {\n    Node root = null;\n\n    Node rightRotate(Node t) {\n        Node s = t.left;\n        t.left = s.right;\n        s.right = t;\n        return s;\n    }\n\n    Node leftRotate(Node t) {\n        Node s = t.right;\n        t.right = s.left;\n        s.left = t;\n        return s;\n    }\n\n    private Node insert(Node t, Node node) {\n        if (t == null) return node;\n        if (node.key == t.key) return t;\n\n        if (node.key < t.key) {\n            t.left = insert(t.left, node);\n            if (t.priority < t.left.priority)\n                t = rightRotate(t);\n        } else {\n            t.right = insert(t.right, node);\n            if (t.priority < t.right.priority)\n                t = leftRotate(t);\n        }\n\n        return t;\n    }\n\n    void insert(Node node) {\n        root = insert(root, node);\n    }\n\n    Optional<Node> find(long key) {\n        Node curr = root;\n        while (curr != null && curr.key != key) {\n            if (key < curr.key)\n                curr = curr.left;\n            else\n                curr = curr.right;\n        }\n        return Optional.ofNullable(curr);\n    }\n\n    private Node _delete(Node t, long key) {\n        if (t.left == null && t.right == null) {\n            return null;\n        } else if (t.left == null)\n            t = leftRotate(t);\n        else if (t.right == null)\n            t = rightRotate(t);\n        else {\n            if (t.left.priority > t.right.priority)\n                t = rightRotate(t);\n            else\n                t = leftRotate(t);\n        }\n        return delete(t, key);\n    }\n\n    private Node delete(Node t, long key) {\n        if (t == null)\n            return null;\n        if (key < t.key)\n            t.left = delete(t.left, key);\n        else if (key > t.key)\n            t.right = delete(t.right, key);\n        else\n            return _delete(t, key);\n\n        return t;\n    }\n\n    void delete(long key) {\n        root = delete(root, key);\n    }\n\n    private void inorderTreeWalk(List<Long> ret, Node curr) {\n        if (curr == null) return;\n        inorderTreeWalk(ret, curr.left);\n        ret.add(curr.key);\n        inorderTreeWalk(ret, curr.right);\n    }\n\n    private void preorderTreeWalk(List<Long> ret, Node curr) {\n        if (curr == null) return;\n        ret.add(curr.key);\n        preorderTreeWalk(ret, curr.left);\n        preorderTreeWalk(ret, curr.right);\n    }\n\n    void print() {\n        List<Long> arr = new ArrayList<>();\n        inorderTreeWalk(arr, root);\n        System.out.println(\" \" + arr.stream().map(String::valueOf).collect(Collectors.joining(\" \")));\n\n        arr.clear();\n        preorderTreeWalk(arr, root);\n        System.out.println(\" \" + arr.stream().map(String::valueOf).collect(Collectors.joining(\" \")));\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        try (BufferedReader in = new BufferedReader(new InputStreamReader(System.in))) {\n            final int n = Integer.parseInt(in.readLine());\n            Treap treap = new Treap();\n\n            for (int i = 0; i < n; i++) {\n                String[] line = in.readLine().split(\" \");\n                if (line[0].charAt(0) == 'i') {\n                    Node node = new Node(Long.parseLong(line[1]), Long.parseLong(line[2]));\n                    treap.insert(node);\n                } else if (line[0].charAt(0) == 'f') {\n                    if (treap.find(Long.parseLong(line[1])).isPresent())\n                        System.out.println(\"yes\");\n                    else\n                        System.out.println(\"no\");\n                } else if (line[0].charAt(0) == 'd') {\n                    treap.delete(Long.parseLong(line[1]));\n                } else {\n                    treap.print();\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tprivate class Node {\n\t\tint key, pri;\n\t\tNode left, right;\n\t\tpublic Node(int key, int pri) {\n\t\t\tthis.key = key;\n\t\t\tthis.pri = pri;\n\t\t\tleft = right = null;\n\t\t}\n\t\tpublic String toString() {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.append(\"key=\" + key);\n\t\t\tsb.append(\",pri=\" + pri);\n\t\t\tsb.append(\",left=\");\n\t\t\tif (left != null) sb.append(left.key);\n\t\t\tsb.append(\",right=\");\n\t\t\tif (right != null) sb.append(right.key);\n\t\t\treturn sb.toString();\n\t\t}\n\t}\n\n\tprivate class Treap {\n\t\tNode root;\n\t\tpublic Treap() {\n\t\t\troot = null;\n\t\t}\n\t\t\n\t\tpublic void print() {\n\t\t\tprintInOrder();\n\t\t\tprintPreOrder();\n\t\t}\n\t\t\n\t\tprivate void printInOrder() {\n\t\t\tStack<Node> st = new Stack<Node>();\n\t\t\tNode cur = root;\n\t\t\twhile (cur != null || !st.isEmpty()) {\n\t\t\t\tif (cur != null) {\n\t\t\t\t\tst.push(cur);\n\t\t\t\t\tcur = cur.left;\n\t\t\t\t} else {\n\t\t\t\t\tcur = st.pop();\n\t\t\t\t\tSystem.out.print(\" \" + cur.key);\n\t\t\t\t\tcur = cur.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"\");\n\t\t}\n\t\t\n\t\tprivate void printPreOrder() {\n\t\t\tStack<Node> st = new Stack<Node>();\n\t\t\tst.push(root);\n\t\t\twhile (!st.isEmpty()) {\n\t\t\t\tNode cur = st.pop();\n\t\t\t\tSystem.out.print(\" \" + cur.key);\n\t\t\t\tif (cur.right != null) st.push(cur.right);\n\t\t\t\tif (cur.left != null) st.push(cur.left);\n\t\t\t}\n\t\t\tSystem.out.println(\"\");\n\t\t}\n\t\t\n\t\tpublic Node find(int key) {\n\t\t\tNode cur = root;\n\t\t\twhile (cur != null) {\n\t\t\t\tif (key == cur.key) return cur;\n\t\t\t\tif (key < cur.key) cur = cur.left;\n\t\t\t\telse cur = cur.right;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tpublic void insert(int key, int pri) {\t\t\t\n\t\t\troot = insert(root, key, pri);\n\t\t}\t\t\n\t\t\n\t\tprivate Node insert(Node node, int key, int pri) {\n\t\t\tif (node == null) {\n\t\t\t\tnode = new Node(key, pri);\n\t\t\t} else if (key < node.key) {\n\t\t\t\tnode.left = insert(node.left, key, pri);\n\t\t\t\tif (node.pri < node.left.pri) {\n\t\t\t\t\tnode = rightRotate(node);\n\t\t\t\t}\n\t\t\t} else if (key > node.key) {\n\t\t\t\tnode.right = insert(node.right, key, pri);\t\t\t\t\n\t\t\t\tif (node.pri < node.right.pri) {\n\t\t\t\t\tnode = leftRotate(node);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\n\t\tprivate Node leftRotate(Node node) {\n\t\t\tNode tmp = node.right;\n\t\t\tnode.right = tmp.left;\n\t\t\ttmp.left = node;\n\t\t\treturn tmp;\n\t\t}\n\n\t\tprivate Node rightRotate(Node node) {\n\t\t\tNode tmp = node.left;\n\t\t\tnode.left = tmp.right;\n\t\t\ttmp.right = node;\n\t\t\treturn tmp;\n\t\t}\n\n\t\tpublic void delete(int key) {\n\t\t\troot = delete(root, key);\n\t\t}\n\n\t\tprivate Node delete(Node node, int key) {\n\t\t\tif (node != null) {\n\t\t\t\tif (key < node.key) {\n\t\t\t\t\tnode.left = delete(node.left, key);\n\t\t\t\t} else if (key > node.key) {\n\t\t\t\t\tnode.right = delete(node.right, key);\n\t\t\t\t} else {\n\t\t\t\t\treturn delete_(node, key);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn node;\n\t\t}\n\n\t\tprivate Node delete_(Node node, int key) {\n\t\t\tif (node.left == null && node.right == null) {\n\t\t\t\treturn null;\n\t\t\t} else if (node.left == null) {\n\t\t\t\tnode = node.right;\n\t\t\t} else if (node.right == null) {\n\t\t\t\tnode = node.left;\n\t\t\t} else {\n\t\t\t\tif (node.left.pri > node.right.pri) {\n\t\t\t\t\tnode = rightRotate(node);\n\t\t\t\t} else {\n\t\t\t\t\tnode = leftRotate(node);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn delete(node, key);\n\t\t}\n\t}\n\t\n\tprivate void run() throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(reader.readLine());\n\t\tTreap treap = new Treap();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tStringTokenizer st = new StringTokenizer(reader.readLine());\n\t\t\tString cmd = st.nextToken();\n\t\t\tif (cmd.equals(\"print\")) {\n\t\t\t\ttreap.print();\n\t\t\t} else {\n\t\t\t\tint key = Integer.parseInt(st.nextToken());\n\t\t\t\tif (cmd.equals(\"insert\")) {\n\t\t\t\t\ttreap.insert(key, Integer.parseInt(st.nextToken()));\n\t\t\t\t} else if (cmd.equals(\"find\")) {\n\t\t\t\t\tif (treap.find(key) != null) {\n\t\t\t\t\t\tSystem.out.println(\"yes\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSystem.out.println(\"no\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttreap.delete(key);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treader.close();\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(in.readLine());\n        Treap treap = new Treap();\n        for (int i = 0; i < n; i++) {\n            String line = in.readLine();\n            String[] split = line.split(\" \");\n            switch (split[0]) {\n                case \"insert\":\n                    treap.insert(Integer.parseInt(split[1]), Integer.parseInt(split[2]));\n                    break;\n                case \"find\":\n                    if (treap.find(Integer.parseInt(split[1]))) {\n                        System.out.println(\"yes\");\n                    } else {\n                        System.out.println(\"no\");\n                    }\n                    break;\n                case \"delete\":\n                    treap.delete(Integer.parseInt(split[1]));\n                    break;\n                default:\n                    System.out.println(treap.print());\n                    break;\n            }\n        }\n    }\n}\n\nclass Treap {\n    private Treap.Node root;\n\n    static class Node {\n        Node parent;\n        Node left;\n        Node right;\n        int data;\n        int priority;\n\n        private Node(int data, int priority) {\n            this.data = data;\n            this.priority = priority;\n            parent = null;\n            left = null;\n            right = null;\n        }\n\n        boolean isLeaf() {\n            return left == null && right == null;\n        }\n\n        String preorder() {\n            if (isLeaf()) {\n                return \" \" + data;\n            } else if (left == null) {\n                return \" \" + data + right.preorder();\n            } else if (right == null) {\n                return \" \" + data + left.preorder();\n            } else {\n                return \" \" + data + left.preorder() + right.preorder();\n            }\n        }\n\n        String inorder() {\n            if (isLeaf()) {\n                return \" \" + data;\n            } else if (left == null) {\n                return \" \" + data + right.inorder();\n            } else if (right == null) {\n                return left.inorder() + \" \" + data;\n            } else {\n                return left.inorder() + \" \" + data + right.inorder();\n            }\n        }\n    }\n\n    Treap() {\n        root = null;\n    }\n\n    void insert(int data, int priority) {\n        root = insertHelper(root, data, priority);\n    }\n\n    private Node insertHelper(Node node, int data, int priority) {\n        if (node == null) {\n            return new Node(data, priority);\n        }\n\n        if (data == node.data) {\n            return node;\n        }\n\n        if (data < node.data) {\n            node.left = insertHelper(node.left, data, priority);\n            if (node.priority < node.left.priority) {\n                node = rotateRight(node);\n            }\n        }\n        else {\n            node.right = insertHelper(node.right, data, priority);\n            if (node.priority < node.right.priority) {\n                node = rotateLeft(node);\n            }\n        }\n        return node;\n    }\n\n    private Node rotateLeft(Node node) {\n        Node s = node.right;\n        node.right = s.left;\n        s.left = node;\n        return s;\n    }\n\n    private Node rotateRight(Node node) {\n        Node s = node.left;\n        node.left = s.right;\n        s.right = node;\n        return s;\n    }\n\n    boolean find(int data) {\n        Node node = root;\n        while (node != null) {\n            if (node.data == data) {\n                return true;\n            }\n\n            if (data < node.data) {\n                node = node.left;\n            } else {\n                node = node.right;\n            }\n        }\n        return false;\n    }\n\n    void delete(int data) {\n        root = deleteHelper1(root, data);\n    }\n\n    private Node deleteHelper1(Node node, int data) {\n        if (node == null) {\n            return null;\n        }\n\n        if (data < node.data) {\n            node.left = deleteHelper1(node.left, data);\n        } else if (data > node.data) {\n            node.right = deleteHelper1(node.right, data);\n        } else {\n            return deleteHelper2(node, data);\n        }\n\n        return node;\n    }\n\n    private Node deleteHelper2(Node node, int data) {\n        if (node.isLeaf()) {\n            return null;\n        } else if (node.left == null) {\n            node = rotateLeft(node);\n        } else if (node.right == null) {\n            node = rotateRight(node);\n        } else {\n            if (node.left.priority > node.right.priority) {\n                node = rotateRight(node);\n            } else {\n                node = rotateLeft(node);\n            }\n        }\n\n        return deleteHelper1(node, data);\n    }\n\n    String print() {\n        return inorder() + \"\\n\" + preorder();\n    }\n\n    private String preorder() {\n        return root.preorder();\n    }\n\n    private String inorder() {\n        return root.inorder();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\n\nclass Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().solution();\n\t}\n\n\tpublic void solution() {\n\t\tScanner sc= new Scanner(System.in);\n\t\tint op_num= sc.nextInt();\n\t\tNode root = null;\n\t\tint k, p;\n\t\t\n\n\t\tfor(int i = 0; i < op_num; i++) {\n\t\t\tString op = sc.next();\n\n\t\t\tif(op.equals(\"insert\")) {\n\t\t\t\tk = sc.nextInt();\n\t\t\t\tp = sc.nextInt();\n\t\t\t\troot = insert(root, k, p);\n\t\t\t} else if(op.equals(\"find\")) {\n\t\t\t\tk = sc.nextInt();\n\t\t\t\tSystem.out.println(find(root, k) ? \"yes\" : \"no\");\n\t\t\t} else if(op.equals(\"delete\")) {\n\t\t\t\tk = sc.nextInt();\n\t\t\t\troot = Delete(root, k);\n\t\t\t} else if(op.equals(\"print\")) {\n\t\t\t\tPrint(root);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic Node right_rotate(Node t) {\n\t\tNode s = t.left;\n\t\tt.left = s.right;\n\t\ts.right = t;\n\t\treturn s;\n\t}\n\n\tpublic Node left_rotate(Node t) {\n\t\tNode s = t.right;\n\t\tt.right = s.left;\n\t\ts.left = t;\n\t\treturn s;\n\t}\n\n\tpublic Node insert(Node t, int key, int pri) {\n\t\tif(t == null)\n\t\t\treturn new Node(key, pri);\n\n\t\tif(key == t.key)\n\t\t\treturn t;\n\n\t\tif(key < t.key) {\n\t\t\tt.left = insert(t.left, key, pri);\n\t\t\tif(t.pri < t.left.pri)\n\t\t\t\tt = right_rotate(t);\n\t\t} else {\n\t\t\tt.right = insert(t.right, key, pri);\n\t\t\tif(t.pri < t.right.pri)\n\t\t\t\tt = left_rotate(t);\n\t\t}\n\n\t\treturn t;\n\t}\n\n\tpublic Node Delete(Node t, int key) {\n\t\tif(t == null)\n\t\t\treturn null;\n\n\t\tif(key == t.key) {\n\t\t\tif(t.left == null && t.right == null)\n\t\t\t\treturn null;\n\t\t\telse if(t.left == null)\n\t\t\t\tt = left_rotate(t);\n\t\t\telse if(t.right == null)\n\t\t\t\tt = right_rotate(t);\n\t\t\telse {\n\t\t\t\tif(t.left.pri > t.right.pri)\n\t\t\t\t\tt = right_rotate(t);\n\t\t\t\telse \n\t\t\t\t\tt = left_rotate(t);\n\t\t\t}\n\n\t\t\treturn Delete(t, key);\n\t\t}\n\n\t\tif(key < t.key)\n\t\t\tt.left = Delete(t.left, key);\n\t\telse\n\t\t\tt.right = Delete(t.right, key);\n\n\t\treturn t;\n\t}\n\n\tpublic boolean find(Node root, int target) {\n\t\tif(root == null)\n\t\t\treturn false;\n\n\t\tif(root.key == target)\n\t\t\treturn true;\n\t\telse if(root.key < target)\n\t\t\treturn find(root.right, target);\n\t\telse\n\t\t\treturn find(root.left, target);\n\t}\n\n\tpublic void Print(Node root) {\n\t\tinorder(root);\n\t\tSystem.out.println();\n\t\tpreorder(root);\n\t\tSystem.out.println();\n\t}\n\n\tprivate void inorder(Node root) {\n\t\tif(root != null) {\n\t\t\tinorder(root.left);\n\t\t\tSystem.out.print(\" \" + root.key);\n\t\t\tinorder(root.right);\n\t\t}\n\t}\n\n\tprivate void preorder(Node root) {\n\t\tif(root != null) {\n\t\t\tSystem.out.print(\" \" + root.key);\n\t\t\tpreorder(root.left);\n\t\t\tpreorder(root.right);\n\t\t}\n\t}\n\n\tclass Node {\n\t\tint key;\n\t\tint pri;\n\t\tNode left;\n\t\tNode right;\n\n\t\tpublic Node(int k, int p) {\n\t\t\tkey = k;\n\t\t\tpri = p;\n\t\t\tleft = null;\n\t\t\tright = null;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal boolean DEBUG = false;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tTree treap = new Tree();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString inst = scan.next();\n\t\t\tint key;\n\n\t\t\tswitch(inst) {\n\t\t\tcase \"insert\":\n\t\t\t\tkey = scan.nextInt();\n\t\t\t\tint priority = scan.nextInt();\n\t\t\t\tif (DEBUG)\n\t\t\t\t\tSystem.out.println(\"insert: \" + key);\n\t\t\t\ttreap.insert(key, priority);\n\t\t\t\tbreak;\n\t\t\tcase \"find\":\n\t\t\t\tkey = scan.nextInt();\n\t\t\t\tif (DEBUG)\n\t\t\t\t\tSystem.out.println(\"insert: \" + key);\n\t\t\t\tSystem.out.println(treap.find(key) ? \"yes\" : \"no\");\n\t\t\t\tbreak;\n\t\t\tcase \"delete\":\n\t\t\t\tkey = scan.nextInt();\n\t\t\t\tif (DEBUG)\n\t\t\t\t\tSystem.out.println(\"find: \" + key);\n\t\t\t\ttreap.delete(key);\n\t\t\t\tbreak;\n\t\t\tcase \"print\":\n\t\t\t\tif (DEBUG)\n\t\t\t\t\tSystem.out.println(\"print\");\n\t\t\t\ttreap.print();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\nclass Tree {\n\tfinal boolean DEBUG = false;\n\tNode root;\n\n\tvoid insert(int key, int priority) {\n\t\tthis.root = this.insertNode(this.root, key, priority);\n\t}\n\n\tvoid delete(int key) {\n\t\tthis.root = this.deleteNode(this.root, key);\n\t}\n\n\tboolean find(int key) {\n\t\tNode node = this.root;\n\t\twhile (node != null) {\n\t\t\tif (key == node.key) return true;\n\t\t\tif (key < node.key) node = node.left;\n\t\t\telse \t\t\t\tnode = node.right;\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid print() {\n\t\tthis.inorder(this.root);\n\t\tSystem.out.println();\n\t\tthis.preorder(this.root);\n\t\tSystem.out.println();\n\t}\n\n\tvoid preorder(Node node) {\n\t\tif (node == null) return;\n\t\tSystem.out.print(\" \" + node.key);\n\t\tthis.preorder(node.left);\n\t\tthis.preorder(node.right);\n\t}\n\tvoid inorder(Node node) {\n\t\tif (node == null) return;\n\t\tthis.inorder(node.left);\n\t\tSystem.out.print(\" \" + node.key);\n\t\tthis.inorder(node.right);\n\t}\n\tNode insertNode(Node node, int key, int priority) {\n\t\tif (node == null)\n\t\t\treturn new Node(key, priority);\n\t\tif (key == node.key)\n\t\t\treturn node;\n\t\tif (key < node.key) {\n\t\t\tnode.left = insertNode(node.left, key, priority);\n\t\t\tif (node.priority < node.left.priority)\n\t\t\t\tnode = rightRotate(node);\n\t\t} else {\n\t\t\tnode.right = insertNode(node.right, key, priority);\n\t\t\tif (node.priority < node.right.priority)\n\t\t\t\tnode = leftRotate(node);\n\t\t}\n\t\treturn node;\n\t}\n\tNode deleteNode(Node node, int key) {\n\t\tif (node == null)\n\t\t\treturn null;\n\t\tif (key < node.key)\n\t\t\tnode.left = deleteNode(node.left, key);\n\t\telse if (key > node.key)\n\t\t\tnode.right = deleteNode(node.right, key);\n\t\telse\n\t\t\treturn _delete(node, key);\n\t\treturn node;\n\t}\n\tNode leftRotate(Node node) {\n\t\tNode right = node.right;\n\t\tnode.right = right.left;\n\t\tright.left = node;\n\t\treturn right;\n\t}\n\tNode rightRotate(Node node) {\n\t\tNode left = node.left;\n\t\tnode.left = left.right;\n\t\tleft.right = node;\n\t\treturn left;\n\t}\n\tNode _delete(Node node, int key) {\n\t\tif (node.left == null && node.right == null)\n\t\t\treturn null;\n\t\telse if (node.left == null)\n\t\t\tnode = leftRotate(node);\n\t\telse if (node.right == null)\n\t\t\tnode = rightRotate(node);\n\t\telse {\n\t\t\tif (node.left.priority > node.right.priority)\n\t\t\t\tnode = rightRotate(node);\n\t\t\telse\n\t\t\t\tnode = leftRotate(node);\n\t\t}\n\t\treturn deleteNode(node, key);\n\t}\n}\n\nclass Node {\n\tint key, priority;\n\tNode parent, left, right;\n\tNode(int key, int priority) {\n\t\tthis.key = key;\n\t\tthis.priority = priority;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\n// ALDS1_8_D\npublic class Main {\n\tNode root = null;\n    \tNode rightRotate(Node t) {\n\t\tNode s = t.left;\n\t\tt.left = s.right;\n\t\ts.right = t;\n\t\treturn s;\n\t}\n    \t\n    \tNode leftRotate(Node t) {\n    \t\tNode s = t.right;\n    \t\tt.right = s.left;\n    \t\ts.left = t;\n    \t\treturn s;\n    \t}\n    \t\n\tvoid preParse(Node node) {\n\t\tif (node == null) return;\n\t\tSystem.out.print(\" \" + node.key);\n\t\tpreParse(node.left);\n\t\tpreParse(node.right);\n\t}\n\t\n\tvoid inParse(Node node) {\n\t\tif (node == null) return;\n\t\tinParse(node.left);\n\t\tSystem.out.print(\" \" + node.key);\n\t\tinParse(node.right);\n\t}\n\t\n\tvoid postParse(Node node) {\n\t\tif (node == null) return;\n\t\tpostParse(node.left);\n\t\tpostParse(node.right);\n\t\tSystem.out.print(\" \" + node.key);\n\t}\n\n    \tNode delete(Node t, int key) {\n    \t\tif (t == null) return null;\n    \t\tif (key < t.key) t.left = delete(t.left, key);\n    \t\telse if (key > t.key) t.right = delete(t.right, key);\n    \t\telse return _delete(t, key);\n    \t\treturn t;\n    }\n        \t\t\n    \tNode _delete(Node t, int key) {\n    \t\tif (t.left == null && t.right == null) return null;\n    \t\telse if (t.left== null) t = leftRotate(t);\n    \t\telse if (t.right == null) t = rightRotate(t);\n    \t\telse {\n    \t\t\tif (t.left.priority > t.right.priority) t = rightRotate(t);\n    \t\t\telse t = leftRotate(t);\n    \t\t}\n    \t\treturn delete(t, key);\n    \t}\n\t\n\tNode findCheck(Node node, int n) {\n\t\tif (node == null) return null;\n\t\tif (node.key == n) return node;\n\t\telse if (node.key > n) return findCheck(node.left, n);\n\t\telse return findCheck(node.right, n);\n\t}\n\t\n\tNode insert(Node t, int key, int priority) {\n        \tif (t == null) return new Node(key, priority);\n        \tif (key == t.key) return t;\n        \tif (key < t.key) {\n        \t\tt.left = insert(t.left, key, priority);\n        \t\tif (t.priority < t.left.priority) t = rightRotate(t);\n        \t} else {\n        \t\t\tt.right = insert(t.right, key, priority);\n        \t\t\tif (t.priority < t.right.priority) t = leftRotate(t);\n        \t}\n        \treturn t;\n\t}\n\t\n\tvoid run() throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tString str = br.readLine();\n\t\t\tswitch(str.charAt(0)) {\n\t\t\tcase 'd':\n\t\t\t\troot = delete(root, Integer.parseInt(str.split(\" \")[1]));\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tif (findCheck(root, Integer.parseInt(str.split(\" \")[1])) != null) System.out.println(\"yes\");\n\t\t\t\telse System.out.println(\"no\");\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tint key = Integer.parseInt(str.split(\" \")[1]);\n\t\t\t\tint priority = Integer.parseInt(str.split(\" \")[2]);\n\t\t\t\troot = insert(root, key, priority);\n\t\t\t\tbreak;\n\t\t\tcase 'p':\n\t\t\t\tinParse(root);\n\t\t\t\tSystem.out.println();\n\t\t\t\tpreParse(root);\n\t\t\t\tSystem.out.println();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n}\n\nclass Node {\n\tint key;\n\tint priority;\n\tNode parent = null;\n\tNode left = null;\n\tNode right = null;\n\tNode(int key, int priority) {\n\t\tthis.key = key;\n\t\tthis.priority = priority;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\n  public static void main(String[] args) {\n    \n    new Main().run();\n  }\n\n  public void run() {\n\n    try(BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n      final int n = Integer.parseInt(br.readLine());\n      String op;\n      String[] words;\n      Treap treap = new Treap();\n      int key,p,t;\n\n      for(int i=0,k=0; i<n; i++,k=0){\n        words = br.readLine().split(\" \");\n        op  = words[k++];\n\n        switch( op ) {\n          case \"insert\" :\n            key = Integer.parseInt(words[k++]);\n            p   = Integer.parseInt(words[k]);\n            treap.insert(key,p);\n            break;\n          case \"find\" :\n            t = Integer.parseInt(words[k]);\n            System.out.println( treap.find(t) ? \"yes\" : \"no\" );\n            break;\n          case \"delete\" :\n            treap.delete(Integer.parseInt(words[k]));\n            break;\n          default :\n            treap.dispRoundPath();\n        }\n      }\n\n    }\n    catch(IOException e) {\n      System.out.println(\"IOException!\");\n    }\n  }\n}\n\nclass Treap {\n\n  static final int min = Integer.MIN_VALUE;\n  static final TreapNode NIL = new TreapNode(min,min);\n  TreapNode root;\n  StringBuilder buf;\n\n  public Treap() {\n    root = NIL;\n    buf = new StringBuilder();\n  }\n\n  public void insert(int key, int priority) {\n    root = insertTreap(root, key, priority);\n  }\n  public boolean find(int target) {\n    TreapNode x = root;\n\n    while( !x.equals(NIL) ) {\n      if( target == x.key )\n        return true;\n      else\n        x = target < x.key ? x.left : x.right;\n    }\n\n    return false;\n  }\n  public void delete(int target) {\n    root = deleteNode(root,target);\n  }\n  public void dispRoundPath() {\n\n    inParse(root);\n    buf.append(\"\\n\");\n    preParse(root);\n    buf.append(\"\\n\");\n\n    System.out.print(buf);\n    buf.setLength(0);\n  }\n  private TreapNode insertTreap(TreapNode node, int key, int priority) {\n    if( node.equals(NIL) ) return new TreapNode(key, priority);\n    if( key == node.key ) return node;\n    if( key < node.key ) {\n      node.left = insertTreap(node.left, key, priority);\n      if( node.priority < node.left.priority ) node = rightRotate(node);\n    }\n    else {\n      node.right = insertTreap(node.right, key, priority);\n      if( node.priority < node.right.priority ) node = leftRotate(node);\n    }\n\n    return node;\n  }\n  private TreapNode rightRotate(TreapNode node) {\n    TreapNode t = node.left;\n    node.left = t.right;\n    t.right = node;\n    return t;\n  }\n  private TreapNode leftRotate(TreapNode node) {\n    TreapNode t = node.right;\n    node.right = t.left;\n    t.left = node;\n    return t;\n  }\n  private TreapNode deleteNode(TreapNode node, int key) {\n    if( node.equals(NIL) ) return NIL;\n    if( key < node.key ) node.left = deleteNode(node.left, key);\n    else if( key > node.key ) node.right = deleteNode(node.right, key);\n    else return deleteNodeTP(node, key);\n\n    return node;\n  }\n  private TreapNode deleteNodeTP(TreapNode node, int key) {\n    if(node.left.equals(NIL) && node.right.equals(NIL)) return NIL;\n    else if(node.left.equals(NIL) ) node = leftRotate(node);\n    else if(node.right.equals(NIL)) node = rightRotate(node);\n    else node = node.left.priority > node.right.priority ?\n      rightRotate(node) : leftRotate(node);\n    \n    return deleteNode(node, key);\n  }\n  private void preParse(TreapNode u) {\n    if( !u.equals(NIL) ) {\n      buf.append(\" \").append(u.key);\n      preParse(u.left);\n      preParse(u.right);\n    }\n  }\n  private void inParse(TreapNode u) {\n    if( !u.equals(NIL) ) {\n      inParse(u.left);\n      buf.append(\" \").append(u.key);\n      inParse(u.right);\n    }\n  }\n}\n\nclass TreapNode {\n  int key,priority;\n  TreapNode parent,left,right;\n\n  public TreapNode(int key, int priority) {\n    this.key = key;\n    this.priority = priority;\n    this.parent =\n    this.left =\n    this.right = Treap.NIL;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if(o == this) return true;\n    if(o == null) return false;\n    if(!(o instanceof TreapNode)) return false;\n\n    TreapNode node = (TreapNode)o;\n    if(!(this.key == node.key)) return false;\n\n    return true;\n  }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _20190108_AOJ\n{\n    class ALDS1_8D\n    {\n        static void Main(string[] args)\n        {\n            for (;;)\n            {\n                string line = Console.ReadLine();\n                if (string.IsNullOrEmpty(line))\n                {\n                    break;\n                }\n\n                Treap bt = new Treap();\n                int n = int.Parse(line);\n                for (int i = 0; i < n; i++)\n                {\n                    string[] command = Console.ReadLine().Split(' ');\n                    int key;\n                    int priority;\n                    switch (command[0])\n                    {\n                        case \"delete\":\n                            key = int.Parse(command[1]);\n                            bt.Delete(key);\n                            break;\n                        case \"find\":\n                            key = int.Parse(command[1]);\n                            TreeNode tn = bt.Find(key);\n                            if (tn != null)\n                            {\n                                Console.WriteLine(\"yes\");\n                            }\n                            else\n                            {\n                                Console.WriteLine(\"no\");\n                            }\n                            break;\n                        case \"insert\":\n                            key = int.Parse(command[1]);\n                            priority = int.Parse(command[2]);\n                            bt.Insert(key, priority);\n                            break;\n                        case \"print\":\n                            Console.Write(\" \");\n                            Console.WriteLine(string.Join(\" \", bt.InOrder().Select(x => x.Key.ToString()).ToArray()));\n                            Console.Write(\" \");\n                            Console.WriteLine(string.Join(\" \", bt.PreOrder().Select(x => x.Key.ToString()).ToArray()));\n                            break;\n                    }\n                }\n            }\n        }\n    }\n\n    class Treap\n    {\n        List<TreeNode> list;\n        public TreeNode Root { get { return GetRoot(); } }\n        public Treap()\n        {\n            list = new List<TreeNode>();\n        }\n\n        private TreeNode GetRoot()\n        {\n            if (list.Count == 0) return null;\n\n            TreeNode temp = list[0];\n            while (temp.Parent != null)\n            {\n                temp = temp.Parent;\n            }\n\n            return temp;\n        }\n\n        public TreeNode RightRotate(TreeNode t)\n        {\n            TreeNode s = t.Left;\n            t.Left = s.Right;\n            s.Right = t;\n            s.Parent = t.Parent;\n            t.Parent = s;\n\n            return s;   // root of the subtree\n        }\n\n        public TreeNode LeftRotate(TreeNode t)\n        {\n            TreeNode s = t.Right;\n            t.Right = s.Left;\n            s.Left = t;\n            s.Parent = t.Parent;\n            t.Parent = s;\n\n            return s;   // root of the subtree\n        }\n\n        public TreeNode Insert(int key, int priority)\n        {\n            return Insert(Root, key, priority);\n        }\n\n        public TreeNode Insert(TreeNode t, int key, int priority)\n        {\n            if (t == null)\n            {\n                TreeNode tn = new TreeNode(key, priority);\n                list.Add(tn);\n                return tn;\n            }\n\n            if (key == t.Key)\n            {\n                return t;\n            }\n\n            if (key < t.Key)\n            {\n                t.Left = Insert(t.Left, key, priority);\n                t.Left.Parent = t;\n                if (t.Priority < t.Left.Priority)\n                {\n                    t = RightRotate(t);\n                }\n            }\n            else\n            {\n                t.Right = Insert(t.Right, key, priority);\n                t.Right.Parent = t;\n                if (t.Priority < t.Right.Priority)\n                {\n                    t = LeftRotate(t);\n                }\n            }\n\n            return t;\n        }\n\n        public TreeNode Delete(int key)\n        {\n            return Delete(Root, key);\n        }\n\n        public TreeNode Delete(TreeNode t, int key)\n        {\n            if (t == null)\n            {\n                return null;\n            }\n\n            if (key < t.Key)\n            {\n                t.Left = Delete(t.Left, key);\n            }\n            else if (key > t.Key)\n            {\n                t.Right = Delete(t.Right, key);\n            }\n            else\n            {\n                return _Delete(t, key);\n            }\n\n            return t;\n        }\n\n        private TreeNode _Delete(TreeNode t, int key)\n        {\n            if(t.Left == null && t.Right == null)\n            {\n                list.Remove(t);\n                return null;\n            }\n            else if(t.Left == null)\n            {\n                t = LeftRotate(t);\n            }\n            else if(t.Right == null)\n            {\n                t = RightRotate(t);\n            }\n            else\n            {\n                if (t.Left.Priority > t.Right.Priority)\n                {\n                    t = RightRotate(t);\n                }\n                else\n                {\n                    t = LeftRotate(t);\n                }\n            }\n\n            return Delete(t, key);\n        }\n\n        public TreeNode Find(int key)\n        {\n            return Find(Root, key);\n        }\n\n        static TreeNode Find(TreeNode tn, int key)\n        {\n            TreeNode rv = null;\n            if (tn != null)\n            {\n                if (key < tn.Key)\n                {\n                    rv = Find(tn.Left, key);\n                }\n                else if (key > tn.Key)\n                {\n                    rv = Find(tn.Right, key);\n                }\n                else\n                {\n                    rv = tn;\n                }\n            }\n\n            return rv;\n        }\n\n        public TreeNode[] PreOrder()\n        {\n            List<TreeNode> list = new List<TreeNode>();\n            PreOrder(list, Root);\n            return list.ToArray();\n        }\n\n        static void PreOrder(List<TreeNode> list, TreeNode tn)\n        {\n            list.Add(tn);\n\n            if (tn.Left != null)\n            {\n                PreOrder(list, tn.Left);\n            }\n\n            if (tn.Right != null)\n            {\n                PreOrder(list, tn.Right);\n            }\n        }\n\n        public TreeNode[] InOrder()\n        {\n            List<TreeNode> list = new List<TreeNode>();\n            InOrder(list, Root);\n            return list.ToArray();\n        }\n\n        static void InOrder(List<TreeNode> list, TreeNode tn)\n        {\n            if (tn.Left != null)\n            {\n                InOrder(list, tn.Left);\n            }\n\n            list.Add(tn);\n\n            if (tn.Right != null)\n            {\n                InOrder(list, tn.Right);\n            }\n        }\n\n        static void PostOrder(List<TreeNode> list, TreeNode tn)\n        {\n            if (tn.Left != null)\n            {\n                PostOrder(list, tn.Left);\n            }\n\n            if (tn.Right != null)\n            {\n                PostOrder(list, tn.Right);\n            }\n\n            list.Add(tn);\n        }\n    }\n\n    class TreeNode\n    {\n        public int Key { get; set; }\n        public int Priority { get; set; }\n        public TreeNode Parent { get; set; }\n        public TreeNode Left { get; set; }\n        public TreeNode Right { get; set; }\n        public TreeNode()\n        {\n        }\n\n        public TreeNode(int key, int priority)\n        {\n            this.Key = key;\n            this.Priority = priority;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\n\n\nnamespace CSharpSample01\n{\n\n    class Node\n    {\n        public int key;\n        public int pri;  //priority\n        public Node par;  //parent\n        public Node left;\n        public Node right;\n        public Node(int k, int p)\n        {\n            key = k;\n            pri = p;\n            par = null;\n            left = null;\n            right = null;\n        }\n    }\n\n    class Treap\n    {\n        Node root;  //根のノード\n        int size;  //ノードの個数\n        Node obj;\n        int min;  //keyの最小値\n\n        public Treap()\n        {\n            root = null;\n            size = 0;\n            min = 0;\n        }\n\n        public void Insert(int key, int priority)\n        {\n            if (size == 0) min = key;\n            else min = Math.Min(min, key);\n\n            //根がない場合、新しいノードを根とする\n            if (root == null)\n            {\n                root = new Node(key, priority);\n            }\n            else\n            {\n                //まずは、二分木に従って挿入\n                Node new_node = new Node(key, priority);\n                Insert_Binary(new_node);\n\n                //次に優先度に従って回転\n                Insert_Prioriry(new_node);\n            }\n            size++;\n        }\n\n        //二分木に従ってnodeを挿入する\n        //最終的にnodeは必ず葉として挿入される\n        private void Insert_Binary(Node node)\n        {\n            //最初の探索対象ノードは根ノード\n            Node cur = root;\n            Node before = root;  //curノードの親ノードを一時的に保存\n\n            //curにより挿入する葉の位置まで移動\n            while (cur != null)\n            {\n                if (cur != root) before = cur.par.left == cur ? cur.par.left : cur.par.right;\n                if (cur.key == node.key) return;  //keyの重複は認めない\n                else if (cur.key > node.key) cur = cur.left;\n                else cur = cur.right;\n            }\n\n            //nodeと親のbeforeの関係を設定\n            node.par = before;\n\n            if (node.key < before.key) before.left = node;\n            else before.right = node;\n            /*\n            Console.WriteLine($\"before:{before.key}\");\n            Console.WriteLine($\"before.left:{(before.left != null ? before.left.key : -1)} \" +\n                $\"before.right:{(before.right != null ? before.right.key : -1)}\");\n                */\n        }\n\n        //ヒープに従い、二分探索木の関係を壊さないまま回転し続ける\n        //右回転または左回転を順次行う\n        public void Insert_Prioriry(Node node)\n        {\n            Node parent = node.par;\n            //Show2();\n            while (true)\n            {\n                if (node.par == null) { root = node; break; }\n                if (parent.pri > node.pri) break;\n                //回転\n                else if (parent.pri < node.pri)\n                {                   \n                    //Console.WriteLine($\"node({node.key}, {node.pri}) p({parent.key}, {parent.pri})\");\n                    if (node == node.par.left) RightRotate(node);\n                    else if (node == node.par.right) LeftRotate(node);\n                    parent = node.par;\n                    //Show2();\n                }\n\n            }\n        }\n\n        //右回転(nodeに関して右回転)\n        private void RightRotate(Node node)\n        {\n            //Console.WriteLine(\"R\");\n            Node p = node.par;\n            Node pp = node.par.par;\n            Node r = node.right;\n\n            //pとnode\n            p.par = node;\n            node.right = p;\n\n            //rがnullの時を考慮\n            if (r != null) r.par = p;\n            p.left = r;\n\n            //nodeとpp\n            if (pp != null)\n            {\n                if (pp.left == p) pp.left = node;\n                else pp.right = node;\n            }\n            else\n            {\n                //pp = nullの時、pは根だったので今度はnodeが根になる\n                root = node;\n            }\n            node.par = pp;\n        }\n\n        //左回転(nodeに関して左回転)\n        private void LeftRotate(Node node)\n        {\n            //Console.WriteLine(\"L\");\n            Node p = node.par;\n            Node pp = node.par.par;\n            Node l = node.left;\n\n            //pとnode\n            p.par = node;\n            node.left = p;\n\n            //lとp\n            //lがnullの時を考慮\n            if (l != null) l.par = p;\n            p.right = l;\n\n            //ppとnode\n            if (pp != null)\n            {\n                if (pp.left == p) pp.left = node;\n                else pp.right = node;\n            }\n            else\n            {\n                root = node;\n            }\n            node.par = pp;\n        }\n\n        //keyをもつノードを削除\n        public void Erase(int key)\n        {\n            //Console.WriteLine(\"Start Erase\");\n            if (!Find(key)) return;         \n\n            Node cur = obj;\n            //Console.WriteLine($\"Erase key:{cur.key}\");\n        \n            while (cur.right != null || cur.left != null)\n            {\n                //Console.WriteLine($\"cur.par key:{(cur.par != null ? cur.par.key : -1)}\");\n                if(cur.left != null && cur.right != null)\n                {\n                    if(cur.left.pri > cur.right.pri) RightRotate(cur.left);\n                    else LeftRotate(cur.right);\n                }\n                else if (cur.left != null) RightRotate(cur.left);\n                else LeftRotate(cur.right);              \n            }\n\n            if(key == min)\n            {\n                if (size >= 2) min = cur.par.key;\n                else if (size == 1) min = 0;\n            }\n            \n            //Console.WriteLine($\"cur.par key:{(cur.par != null ? cur.par.key : -1)}\");\n            if (cur.par == null) root = null;\n            else if (cur.par.left == cur) cur.par.left = null;\n            else if (cur.par.right == cur) cur.par.right = null;\n            size--;         \n        }\n\n        //keyの値を持つノードを二分木の探索方に従い再帰的に探す\n        public bool Find(int key)\n        {\n            Node cur = root;\n            obj = null;\n\n            while (cur != null)\n            {\n                if (cur.key == key) { obj = cur; return true; }  //発見\n                else if (cur.key > key) cur = cur.left;  //左の子へ\n                else cur = cur.right;  //右の子へ\n            }\n            \n            return false;\n        }\n\n        \n        //表示\n        public void Show()\n        {\n            if (size == 0)\n            {\n                Console.WriteLine(\"要素がありません\");\n                return;\n            }\n            Inorder(root);\n            Console.WriteLine();\n        }\n\n        //表示2\n        public void Show2()\n        {\n            if (size == 0)\n            {\n                Console.WriteLine(\"要素がありません\");\n                return;\n            }\n            Preorder(root);\n            Console.WriteLine();\n        }\n\n        //中順で表示(二分探索目であるので昇順であるはず)\n        public void Inorder(Node node)\n        {\n            if (node == null) return;\n\n            Inorder(node.left);\n            Console.Write($\" {node.key}\");\n            Inorder(node.right);\n        }\n\n        //行きがけ順で表示\n        public void Preorder(Node node)\n        {\n            if (node == null) return;\n\n            Console.Write($\" {node.key}\");\n            Preorder(node.left);\n            Preorder(node.right);\n        }\n\n        //Treapのサイズを返す\n        public int Size()\n        {\n            return size;\n        }\n\n        public void RootInfo()\n        {\n            if (root != null) Console.WriteLine($\"key:{root.key} pri:{root.pri} \" +\n                 $\"left:{(root.left != null ? root.left.key : -1)} \" +\n                 $\"right:{(root.right != null ? root.right.key : -1)}\");\n        }\n\n        public int GetMin()\n        {\n            return min;\n        }\n        \n    }\n    \n    class Program\n    {\n        \n        static void Main(string[] args)\n        {\n            \n            int N = int.Parse(Console.ReadLine());\n            Treap tp = new Treap();\n\n            for (int i = 0; i < N; i++)\n            {\n                string[] input = Console.ReadLine().Split(' ');\n                string order = input[0];\n\n                int key = 0;\n                int pri = 0;\n\n                if (input.Count() == 2)\n                {\n                    key = int.Parse(input[1]);\n                }\n                if (input.Count() == 3)\n                {\n                    key = int.Parse(input[1]);\n                    pri = int.Parse(input[2]);\n                }\n\n                if (order == \"print\") {tp.Show(); tp.Show2(); }\n                else if (order == \"size\") Console.WriteLine($\"size:{tp.Size()}\");\n                else if (order == \"insert\") tp.Insert(key, pri);\n                else if (order == \"find\") Console.WriteLine(tp.Find(key) ? \"yes\" : \"no\");\n                else if (order == \"root\") tp.RootInfo();\n                else if (order == \"show2\") tp.Show2();\n                else if (order == \"delete\") tp.Erase(key);\n                else if (order == \"end\") break;\n                else Console.WriteLine(\"no comand\");\n            }\n\n\n        }\n    }\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        var S = new TreapSet<int>();\n        int Q = cin.nextint;\n        for (int i = 0; i < Q; i++)\n        {\n            var s = cin.next[0];\n            if (s == 'i')\n            {\n                S.Add(cin.nextint, cin.nextint);\n            }\n            else if (s == 'f')\n            {\n                int k = cin.nextint;\n                if (S.UpperBound(k) - S.LowerBound(k) > 0)\n                {\n                    WriteLine(\"yes\");\n                }\n                else\n                {\n                    WriteLine(\"no\");\n                }\n            }\n            else if (s == 'd')\n            {\n                S.Remove(cin.nextint);\n            }\n            else if (s == 'p')\n            {\n                Write(\" \"); S.Items(0).join();\n                Write(\" \"); S.Items(1).join();\n            }\n        }\n    }\n\n}\n\nclass TreapSet<T>\n{\n    Node root;\n    readonly IComparer<T> comparer;\n    readonly Node nil;\n    public bool IsMultiSet { get; set; }\n    public TreapSet(IComparer<T> comparer)\n    {\n        nil = new Node(default(T), int.MinValue);\n        root = nil;\n        this.comparer = comparer;\n    }\n    public TreapSet(Comparison<T> comaprison) : this(Comparer<T>.Create(comaprison)) { }\n    public TreapSet() : this(Comparer<T>.Default) { }\n    public bool Add(T v, int u)\n    {\n        key = v;\n        priority = u;\n        return insert(ref root);\n    }\n    public bool Remove(T v)\n    {\n        key = v;\n        return remove(ref root);\n    }\n    public T this[int index] { get { return find(root, index); } }\n    public int Count { get { return root.Count; } }\n    public void RemoveAt(int k)\n    {\n        if (k < 0 || k >= root.Count) throw new ArgumentOutOfRangeException();\n        removeAt(ref root, k);\n    }\n    public T[] Items(int x)\n    {\n        var ret = new T[root.Count];\n        var k = 0;\n        if (x == 0) inorder_walk(root, ret, ref k);\n        else if (x == 1) preorder_walk(root, ret, ref k);\n        return ret;\n    }\n    void inorder_walk(Node t, T[] a, ref int k)\n    {\n        if (t.Count == 0) return;\n        inorder_walk(t.lst, a, ref k);\n        a[k++] = t.Key;\n        inorder_walk(t.rst, a, ref k);\n    }\n    void preorder_walk(Node t, T[] a, ref int k)\n    {\n        if (t.Count == 0) return;\n        a[k++] = t.Key;\n        preorder_walk(t.lst, a, ref k);\n        preorder_walk(t.rst, a, ref k);\n    }\n\n    T key; int priority;\n    bool insert(ref Node t)\n    {\n        if (t.Count == 0) { t = new Node(key, priority); t.lst = t.rst = nil; t.Update(); return true; }\n        var cmp = comparer.Compare(t.Key, key);\n        bool res;\n        if (cmp > 0) // key < t.Key\n        {\n            res = insert(ref t.lst);\n            if(t.Priority < t.lst.Priority) rotR(ref t);\n        }\n        else if (cmp == 0) // key == t.Key\n        {\n            if (IsMultiSet) res = insert(ref t.lst);\n            else return false;\n        }\n        else // key > t.key\n        {\n            res = insert(ref t.rst);\n            if (t.Priority < t.rst.Priority) rotL(ref t);\n        }\n\n        //balance(ref t);\n        t.Update();\n        return res;\n    }\n    bool remove(ref Node t)\n    {\n        if (t.Count == 0) return false; //該当ノードなし\n        var cmp = comparer.Compare(key, t.Key);\n        bool ret;\n        if (cmp < 0) ret = remove(ref t.lst);\n        else if (cmp > 0) ret = remove(ref t.rst);\n        else // 削除対象ノード\n        {\n            if (t.lst.Count == 0 && t.rst.Count == 0)\n            {\n                t = nil;\n                return true;\n            }\n            else if (t.lst.Count == 0)\n            {\n                rotL(ref t);\n            }\n            else if (t.rst.Count == 0)\n            {\n                rotR(ref t);\n            }\n            else\n            {\n                if (t.lst.Priority > t.rst.Priority)\n                {\n                    rotR(ref t);\n                }\n                else\n                {\n                    rotL(ref t);\n                }\n            }\n            ret = remove(ref t);\n            //var k = t.lst.Count;\n            //if (k == 0)\n            //{\n            //    t = t.rst;\n            //    return true;\n            //}\n            //if (t.rst.Count == 0) { t = t.lst; return true; }\n\n\n            //t.Key = find(t.lst, k - 1);\n            //removeAt(ref t.lst, k - 1);\n        }\n        //balance(ref t);\n        t.Update();\n        return ret;\n    }\n    void removeAt(ref Node t, int k)\n    {\n        var cnt = t.lst.Count;\n        if (cnt < k) removeAt(ref t.rst, k - cnt - 1);\n        else if (cnt > k) removeAt(ref t.lst, k);\n        else\n        {\n            if (cnt == 0) { t = t.rst; return; }\n            if (t.rst.Count == 0) { t = t.lst; return; }\n\n            t.Key = find(t.lst, k - 1);\n            removeAt(ref t.lst, k - 1);\n        }\n        //balance(ref t);\n    }\n    //void balance(ref Node t)\n    //{\n    //    var balance = t.lst.Height - t.rst.Height;\n    //    if (balance == -2)\n    //    {\n    //        if (t.rst.lst.Height - t.rst.rst.Height > 0) { rotR(ref t.rst); }\n    //        rotL(ref t);\n    //    }\n    //    else if (balance == 2)\n    //    {\n    //        if (t.lst.lst.Height - t.lst.rst.Height < 0) rotL(ref t.lst);\n    //        rotR(ref t);\n    //    }\n    //    else t.Update();\n    //}\n\n    T find(Node t, int k)\n    {\n        if (k < 0 || k > root.Count) throw new ArgumentOutOfRangeException();\n        for (; ; )\n        {\n            if (k == t.lst.Count) return t.Key;\n            else if (k < t.lst.Count) t = t.lst;\n            else { k -= t.lst.Count + 1; t = t.rst; }\n        }\n    }\n    public int LowerBound(T v)\n    {\n        var k = 0;\n        var t = root;\n        for (; ; )\n        {\n            if (t.Count == 0) return k;\n            if (comparer.Compare(v, t.Key) <= 0) t = t.lst;\n            else { k += t.lst.Count + 1; t = t.rst; }\n        }\n    }\n    public int UpperBound(T v)\n    {\n        var k = 0;\n        var t = root;\n        for (; ; )\n        {\n            if (t.Count == 0) return k;\n            if (comparer.Compare(t.Key, v) <= 0) { k += t.lst.Count + 1; t = t.rst; }\n            else t = t.lst;\n        }\n    }\n    void rotR(ref Node t)\n    {\n        var l = t.lst;\n        t.lst = l.rst;\n        l.rst = t;\n        t.Update();\n        l.Update();\n        t = l;\n    }\n    void rotL(ref Node t)\n    {\n        var r = t.rst;\n        t.rst = r.lst;\n        r.lst = t;\n        t.Update();\n        r.Update();\n        t = r;\n    }\n\n    class Node\n    {\n        public Node(T key, int priority)\n        {\n            Key = key;\n            Priority = priority;\n        }\n        public int Count { get; private set; }\n        //public sbyte Height { get; private set; }\n        public int Priority { get; set; }\n        public T Key { get; set; }\n        public Node lst, rst;\n        public void Update()\n        {\n            Count = 1 + lst.Count + rst.Count;\n            //Height = (sbyte)(1 + Math.Max(lst.Height, rst.Height));\n        }\n        public override string ToString()\n        {\n            return string.Format(\"Count = {0}, Key = {1}\", Count, Key);\n        }\n    }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\nnamespace ConsoleApp1\n{\n    public class Node {\n        public int Parent { get; set; } = -1;\n        public Node(int value, int priority) { this.Value = value; this.Priority = priority; }\n        public int Value { get; set; } = 0;\n        public int Priority { get; set; } = 0;\n        public Node Left { get; set; } = null;\n        public Node Right { get; set; } = null;\n    }\n\n    class Program\n    {\n        public static Node root;\n        static void Main()\n        {\n            int n = int.Parse(Console.ReadLine());\n            for (int i = 0; i < n; i++)\n            {\n                string[] currentString = Console.ReadLine().Split(' ');\n\n                if (currentString[0].Equals(\"insert\"))\n                { root = Insert(root, int.Parse(currentString[1]), int.Parse(currentString[2])); }\n                else if (currentString[0].Equals(\"find\"))\n                { Console.WriteLine(Find(root, int.Parse(currentString[1]))); }\n                else if (currentString[0].Equals(\"delete\"))\n                { root = Delete(root , int.Parse(currentString[1])); }\n                else if (currentString[0].Equals(\"print\"))\n                { InOrder(root); Console.WriteLine(); PreOrder(root); Console.WriteLine(); }\n                else { throw new ArgumentException(\"currentString must be insert, find, delete, print but is \" + currentString); }\n\n            }\n        }\n\n        private static String Find(Node node, int value)\n        {\n            if (node == null) { return \"no\"; }\n            else if (node.Value == value) { return \"yes\"; }\n            else if (value < node.Value) { return Find(node.Left, value); }\n            else { return Find(node.Right, value); }\n        }\n        private static Node RightRotate(Node t)\n        {\n            Node s = t.Left;\n            t.Left = s.Right;\n            s.Right = t;\n            return s;\n        }\n        private static Node LeftRotate(Node t)\n        {\n            Node s = t.Right;\n            t.Right = s.Left;\n            s.Left = t;\n            return s;\n        }\n        private static Node Insert(Node t, int key, int priority)            // search the corresponding place recursively\n        {\n            if (t == null)\n                return new Node(key, priority);               // create a new node when you reach a leaf\n            if (key == t.Value)\n                return t;                                 // ignore duplicated keys\n\n            if (key < t.Value) {                               // move to the left child\n                t.Left = Insert(t.Left, key, priority);  // update the pointer to the left child\n                if (t.Priority < t.Left.Priority)       // rotate right if the left child has higher priority\n                    t = RightRotate(t);\n            }\n            else {                      // move to the right child\n                t.Right = Insert(t.Right, key, priority); // update the pointer to the right child\n                if (t.Priority < t.Right.Priority)         // rotate left if the right child has higher priority\n                    t = LeftRotate(t);\n            }\n            return t; \n        }\n\n        private static Node Delete(Node t, int key) {                       // seach the target recursively\n            if (t == null)\n                return null;\n            if (key < t.Value)                             // search the target recursively\n                t.Left = Delete(t.Left, key);\n            else if (key > t.Value)\n                t.Right = Delete(t.Right, key);\n            else\n                return _delete(t, key);\n            return t;\n        }\n        private static Node _delete(Node t, int key) {              // if t is the target node\n            if (t.Left == null && t.Right == null)        // if t is a leaf\n                return null;\n            else if (t.Left == null)                      // if t has only the right child, then perform left rotate\n                t = LeftRotate(t);\n            else if (t.Right == null)                     // if t has only the left child, then perform right rotate\n                t = RightRotate(t);\n            else                                         // if t has both the left and right child\n                if (t.Left.Priority > t.Right.Priority)  // pull up the child with higher priority\n                    t = RightRotate(t);\n                else\n                    t = LeftRotate(t);\n            return Delete(t, key);\n        }\n\n        private static void PostOrder(Node node) \n        {\n            if (node.Left != null){ PostOrder(node.Left); }\n            if (node.Right != null) { PostOrder(node.Right); }\n            Console.Write(\" \" + node.Value);\n        }\n        private static void InOrder(Node node)\n        {\n            if (node.Left != null) { InOrder(node.Left); }\n            Console.Write(\" \" + node.Value);\n            if (node.Right != null) { InOrder(node.Right); }\n        }\n        private static void PreOrder(Node node)\n        {\n            Console.Write(\" \" + node.Value);\n            if (node.Left != null) { PreOrder(node.Left); }\n            if (node.Right != null) { PreOrder(node.Right); }\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing SB = System.Text.StringBuilder;\n//using System.Text.RegularExpressions;\n//using System.Globalization;\n//using System.Diagnostics;\nusing static System.Console;\nusing System.Numerics;\nusing static System.Math;\nusing pair = Pair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        SetOut(new StreamWriter(OpenStandardOutput()) { AutoFlush = false });\n        new Program().solve();\n        Out.Flush();\n    }\n    readonly Scanner cin = new Scanner();\n    readonly int[] dd = { 0, 1, 0, -1, 0 }; //→↓←↑\n    readonly int mod = 1000000007;\n    readonly int dom = 998244353;\n    bool chmax<T>(ref T a, T b) where T : IComparable<T> { if (a.CompareTo(b) < 0) { a = b; return true; } return false; }\n    bool chmin<T>(ref T a, T b) where T : IComparable<T> { if (b.CompareTo(a) < 0) { a = b; return true; } return false; }\n\n    void solve()\n    {\n        var S = new TreapSet<int>();\n        int Q = cin.nextint;\n        for (int i = 0; i < Q; i++)\n        {\n            var s = cin.next[0];\n            if (s == 'i')\n            {\n                S.Add(cin.nextint, cin.nextint);\n            }\n            else if (s == 'f')\n            {\n                int k = cin.nextint;\n                if (S.UpperBound(k) - S.LowerBound(k) > 0)\n                {\n                    WriteLine(\"yes\");\n                }\n                else\n                {\n                    WriteLine(\"no\");\n                }\n            }\n            else if (s == 'd')\n            {\n                S.Remove(cin.nextint);\n            }\n            else if (s == 'p')\n            {\n                Write(\" \"); S.Items(0).join();\n                Write(\" \"); S.Items(1).join();\n            }\n        }\n    }\n\n}\n\nclass TreapSet<T>\n{\n    Node root;\n    readonly IComparer<T> comparer;\n    readonly Node nil;\n    public bool IsMultiSet { get; set; }\n    public TreapSet(IComparer<T> comparer)\n    {\n        nil = new Node(default(T), int.MinValue);\n        root = nil;\n        this.comparer = comparer;\n    }\n    public TreapSet(Comparison<T> comaprison) : this(Comparer<T>.Create(comaprison)) { }\n    public TreapSet() : this(Comparer<T>.Default) { }\n    public bool Add(T v, int u)\n    {\n        key = v;\n        priority = u;\n        return insert(ref root);\n    }\n    public bool Remove(T v)\n    {\n        key = v;\n        return remove(ref root);\n    }\n    public T this[int index] { get { return find(root, index); } }\n    public int Count { get { return root.Count; } }\n    public void RemoveAt(int k)\n    {\n        if (k < 0 || k >= root.Count) throw new ArgumentOutOfRangeException();\n        removeAt(ref root, k);\n    }\n    public T[] Items(int x)\n    {\n        var ret = new T[root.Count];\n        var k = 0;\n        if (x == 0) inorder_walk(root, ret, ref k);\n        else if (x == 1) preorder_walk(root, ret, ref k);\n        return ret;\n    }\n    void inorder_walk(Node t, T[] a, ref int k)\n    {\n        if (t.Count == 0) return;\n        inorder_walk(t.lst, a, ref k);\n        a[k++] = t.Key;\n        inorder_walk(t.rst, a, ref k);\n    }\n    void preorder_walk(Node t, T[] a, ref int k)\n    {\n        if (t.Count == 0) return;\n        a[k++] = t.Key;\n        preorder_walk(t.lst, a, ref k);\n        inorder_walk(t.rst, a, ref k);\n    }\n\n    T key; int priority;\n    bool insert(ref Node t)\n    {\n        if (t.Count == 0) { t = new Node(key, priority); t.lst = t.rst = nil; t.Update(); return true; }\n        var cmp = comparer.Compare(t.Key, key);\n        bool res;\n        if (cmp > 0) // key < t.Key\n        {\n            res = insert(ref t.lst);\n            if(t.Priority < t.lst.Priority) rotR(ref t);\n        }\n        else if (cmp == 0) // key == t.Key\n        {\n            if (IsMultiSet) res = insert(ref t.lst);\n            else return false;\n        }\n        else // key > t.key\n        {\n            res = insert(ref t.rst);\n            if (t.Priority < t.rst.Priority) rotL(ref t);\n        }\n\n        //balance(ref t);\n        t.Update();\n        return res;\n    }\n    bool remove(ref Node t)\n    {\n        if (t.Count == 0) return false; //該当ノードなし\n        var cmp = comparer.Compare(key, t.Key);\n        bool ret;\n        if (cmp < 0) ret = remove(ref t.lst);\n        else if (cmp > 0) ret = remove(ref t.rst);\n        else // 削除対象ノード\n        {\n            if (t.lst.Count == 0 && t.rst.Count == 0)\n            {\n                t = nil;\n                return true;\n            }\n            else if (t.lst.Count == 0)\n            {\n                rotL(ref t);\n            }\n            else if (t.rst.Count == 0)\n            {\n                rotR(ref t);\n            }\n            else\n            {\n                if (t.lst.Priority > t.rst.Priority)\n                {\n                    rotR(ref t);\n                }\n                else\n                {\n                    rotL(ref t);\n                }\n            }\n            ret = remove(ref t);\n            //var k = t.lst.Count;\n            //if (k == 0)\n            //{\n            //    t = t.rst;\n            //    return true;\n            //}\n            //if (t.rst.Count == 0) { t = t.lst; return true; }\n\n\n            //t.Key = find(t.lst, k - 1);\n            //removeAt(ref t.lst, k - 1);\n        }\n        //balance(ref t);\n        return ret;\n    }\n    void removeAt(ref Node t, int k)\n    {\n        var cnt = t.lst.Count;\n        if (cnt < k) removeAt(ref t.rst, k - cnt - 1);\n        else if (cnt > k) removeAt(ref t.lst, k);\n        else\n        {\n            if (cnt == 0) { t = t.rst; return; }\n            if (t.rst.Count == 0) { t = t.lst; return; }\n\n            t.Key = find(t.lst, k - 1);\n            removeAt(ref t.lst, k - 1);\n        }\n        //balance(ref t);\n    }\n    //void balance(ref Node t)\n    //{\n    //    var balance = t.lst.Height - t.rst.Height;\n    //    if (balance == -2)\n    //    {\n    //        if (t.rst.lst.Height - t.rst.rst.Height > 0) { rotR(ref t.rst); }\n    //        rotL(ref t);\n    //    }\n    //    else if (balance == 2)\n    //    {\n    //        if (t.lst.lst.Height - t.lst.rst.Height < 0) rotL(ref t.lst);\n    //        rotR(ref t);\n    //    }\n    //    else t.Update();\n    //}\n\n    T find(Node t, int k)\n    {\n        if (k < 0 || k > root.Count) throw new ArgumentOutOfRangeException();\n        for (; ; )\n        {\n            if (k == t.lst.Count) return t.Key;\n            else if (k < t.lst.Count) t = t.lst;\n            else { k -= t.lst.Count + 1; t = t.rst; }\n        }\n    }\n    public int LowerBound(T v)\n    {\n        var k = 0;\n        var t = root;\n        for (; ; )\n        {\n            if (t.Count == 0) return k;\n            if (comparer.Compare(v, t.Key) <= 0) t = t.lst;\n            else { k += t.lst.Count + 1; t = t.rst; }\n        }\n    }\n    public int UpperBound(T v)\n    {\n        var k = 0;\n        var t = root;\n        for (; ; )\n        {\n            if (t.Count == 0) return k;\n            if (comparer.Compare(t.Key, v) <= 0) { k += t.lst.Count + 1; t = t.rst; }\n            else t = t.lst;\n        }\n    }\n    void rotR(ref Node t)\n    {\n        var l = t.lst;\n        t.lst = l.rst;\n        l.rst = t;\n        t.Update();\n        l.Update();\n        t = l;\n    }\n    void rotL(ref Node t)\n    {\n        var r = t.rst;\n        t.rst = r.lst;\n        r.lst = t;\n        t.Update();\n        r.Update();\n        t = r;\n    }\n\n    class Node\n    {\n        public Node(T key, int priority)\n        {\n            Key = key;\n            Priority = priority;\n        }\n        public int Count { get; private set; }\n        //public sbyte Height { get; private set; }\n        public int Priority { get; set; }\n        public T Key { get; set; }\n        public Node lst, rst;\n        public void Update()\n        {\n            Count = 1 + lst.Count + rst.Count;\n            //Height = (sbyte)(1 + Math.Max(lst.Height, rst.Height));\n        }\n        public override string ToString()\n        {\n            return string.Format(\"Count = {0}, Key = {1}\", Count, Key);\n        }\n    }\n}\n\nstatic class Ex\n{\n    public static void join<T>(this IEnumerable<T> values, string sep = \" \") => WriteLine(string.Join(sep, values));\n    public static string concat<T>(this IEnumerable<T> values) => string.Concat(values);\n    public static string reverse(this string s) { var t = s.ToCharArray(); Array.Reverse(t); return t.concat(); }\n\n    public static int lower_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) < 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n    public static int upper_bound<T>(this IList<T> arr, T val) where T : IComparable<T>\n    {\n        int low = 0, high = arr.Count;\n        int mid;\n        while (low < high)\n        {\n            mid = ((high - low) >> 1) + low;\n            if (arr[mid].CompareTo(val) <= 0) low = mid + 1;\n            else high = mid;\n        }\n        return low;\n    }\n}\n\nclass Pair<T, U> : IComparable<Pair<T, U>> where T : IComparable<T> where U : IComparable<U>\n{\n    public T f; public U s;\n    public Pair(T f, U s) { this.f = f; this.s = s; }\n    public int CompareTo(Pair<T, U> a) => f.CompareTo(a.f) != 0 ? f.CompareTo(a.f) : s.CompareTo(a.s);\n    public override string ToString() => $\"{f} {s}\";\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    readonly char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] scan => ReadLine().Split();\n    public int[] scanint => Array.ConvertAll(scan, int.Parse);\n    public long[] scanlong => Array.ConvertAll(scan, long.Parse);\n    public double[] scandouble => Array.ConvertAll(scan, double.Parse);\n    public string next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = ReadLine();\n            while (st == \"\") st = ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return next;\n        }\n    }\n    public int nextint => int.Parse(next);\n    public long nextlong => long.Parse(next);\n    public double nextdouble => double.Parse(next);\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\nnamespace AOJ\n{\n  public class Program\n  {\n    class Node\n    {\n      public int Key;\n      public int Priority;\n      public Node Left;\n      public Node Right;\n      public Node(int key, int priority)\n      {\n        Key = key;\n        Priority = priority;\n        Left = Right = null;\n      }\n    }\n    static Node RightRotate(Node t)\n    {\n      Node s = t.Left;\n      t.Left = s.Right;\n      s.Right = t;\n      return s;\n    }\n    static Node LeftRotate(Node t)\n    {\n      Node s = t.Right;\n      t.Right = s.Left;\n      s.Left = t;\n      return s;\n    }\n    static Node Insert(Node t, int key, int priority)\n    {\n      if (t == null) return new Node(key, priority);\n      if (t.Key == key) return t;\n\n      if (key < t.Key)\n      {\n        t.Left = Insert(t.Left, key, priority);\n        if (t.Priority < t.Left.Priority)\n        {\n          t = RightRotate(t);\n        }\n      }\n      else\n      {\n        t.Right = Insert(t.Right, key, priority);\n        if (t.Priority < t.Right.Priority)\n        {\n          t = LeftRotate(t);\n        }\n      }\n\n      return t;\n    }\n    static Node Delete(Node t, int key)\n    {\n      if (t == null) return null;\n      if (key < t.Key)\n      {\n        t.Left = Delete(t.Left, key);\n      }\n      else if (key > t.Key)\n      {\n        t.Right = Delete(t.Right, key);\n      }\n      else\n      {\n        return _Delete(t, key);\n      }\n      return t;\n    }\n    static Node _Delete(Node t, int key)\n    {\n      if (t.Left == null && t.Right == null) return null;\n      else if (t.Left == null) t = LeftRotate(t);\n      else if (t.Right == null) t = RightRotate(t);\n      else\n      {\n        if (t.Left.Priority > t.Right.Priority)\n        {\n          t = RightRotate(t);\n        }\n        else\n        {\n          t = LeftRotate(t);\n        }\n      }\n      return Delete(t, key);\n    }\n    static bool Find(Node t, int key)\n    {\n      if (t == null) return false;\n      if (t.Key == key) return true;\n\n      if (key < t.Key)\n      {\n        return Find(t.Left, key);\n      }\n      else\n      {\n        return Find(t.Right, key);\n      }\n    }\n    static void PrintInOrder(Node t)\n    {\n      if (t == null) return;\n      PrintInOrder(t.Left);\n      Console.Write(\" \" + t.Key);\n      PrintInOrder(t.Right);\n    }\n    static void PrintPreOrder(Node t)\n    {\n      if (t == null) return;\n      Console.Write(\" \" + t.Key);\n      PrintPreOrder(t.Left);\n      PrintPreOrder(t.Right);\n    }\n    public static void Main()\n    {\n      int n, i, key, priority;\n      string[] order;\n      Node top = null;\n\n      n = int.Parse(Console.ReadLine());\n\n      for (i = 0; i < n; i++)\n      {\n        order = Console.ReadLine().Split(' ');\n        switch (order[0][0])\n        {\n          case 'f':\n            key = int.Parse(order[1]);\n            if (Find(top, key)) Console.WriteLine(\"yes\");\n            else Console.WriteLine(\"no\");\n            break;\n          case 'i':\n            key = int.Parse(order[1]);\n            priority = int.Parse(order[2]);\n            top = Insert(top, key, priority);\n            break;\n          case 'd':\n            key = int.Parse(order[1]);\n            top = Delete(top, key);\n            break;\n          case 'p':\n            PrintInOrder(top);\n            Console.WriteLine();\n            PrintPreOrder(top);\n            Console.WriteLine();\n            break;\n        }\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace lec8D\n{\n\n    class Node\n    {\n        public int key;\n        public int pri;\n        public Node left;\n        public Node right;\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n            Node root = new Node();\n\n            for (int i = 0; i < n; i++)\n            {\n                string input = Console.ReadLine();\n                string[] split = input.Split(' ');\n\n                if (split[0] == \"insert\")\n                {\n                    if ( i == 0) {\n                        root.key = int.Parse(split[1]);\n                        root.pri = int.Parse(split[2]);\n                    }\n                    else\n                    {\n                        root = Insert(root , int.Parse(split[1]) , int.Parse(split[2]));\n                    }\n                }\n                else if (split[0] == \"delete\")\n                {\n                    root = Delete(root ,int.Parse(split[1]));\n                }\n                else if (split[0] == \"find\")\n                {\n                    bool flag = Sreach(root,int.Parse(split[1]));\n                    if (flag == true)\n                    {\n                        Console.WriteLine(\"yes\");\n                    }\n                    else if (flag == false)\n                    {\n                        Console.WriteLine(\"no\");\n                    }\n                }\n\n                else if (split[0] == \"print\")\n                {\n                    InorderPrint(root);\n                    Console.WriteLine();\n                    PreorderPrint(root);\n                    Console.WriteLine();\n                }\n\n            }\n\n\n            Console.ReadLine();\n\n        }\n\n        static bool Sreach(Node t , int key)\n        {\n            if (t == null)\n            {\n                return false;\n            }\n            else if (t.key == key)\n            {\n                return true;\n            }\n            else if (t.key > key)\n            {\n                return Sreach(t.left, key);\n            }\n            else if (t.key < key)\n            {\n                return Sreach(t.right, key);\n            }\n\n            return false;\n        }\n\n        static void InorderPrint(Node t)\n        {\n            if (t == null)\n            {\n                return;\n            }\n            InorderPrint(t.left);\n            Console.Write(\" {0}\", t.key);\n            InorderPrint(t.right);\n        }\n\n        static void PreorderPrint(Node t)\n        {\n            if (t == null)\n            {\n                return;\n            }\n            Console.Write(\" {0}\",t.key);\n            PreorderPrint(t.left);\n            PreorderPrint(t.right);\n        }\n\n        static  Node RightRotate(Node t)\n        {\n            Node s = t.left;\n            t.left = s.right;\n            s.right = t;\n            return s;\n        }\n\n        static Node LeftRotate(Node t) {\n            Node s = t.right;\n            t.right = s.left;\n            s.left = t;\n            return s;\n        }\n\n        static Node Insert(Node t, int key, int priority) {      \n            if (t == null) {\n                Node r = new Node();\n                r.key = key;\n                r.pri = priority;\n                return r;\n            }\n            if (key == t.key) {\n                return t;                                \n            }\n            if (key < t.key) {                            \n                t.left = Insert(t.left, key, priority);   \n                if (t.pri < t.left.pri) {          \n                    t = RightRotate(t);\n                }\n            } else {                                        \n                t.right = Insert(t.right, key, priority); \n                if (t.pri < t.right.pri) {         \n                    t = LeftRotate(t);\n                }\n            }\n            return t;\n        }\n\n        static Node Delete(Node t, int key) {\n            if (t == null) { \n                return null;\n             }if (key < t.key)\n            {                               \n                t.left = Delete(t.left, key);\n            }\n            else if (key > t.key) { \n                t.right = Delete(t.right, key);\n            }else {\n                return _Delete(t, key);\n            }\n            return t;\n        }\n\n        static Node _Delete(Node t, int key) { \n            if (t.left == null && t.right == null) {           \n                return null;\n            } else if (t.left == null) {                       \n                t = LeftRotate(t);\n            } else if (t.right == null) {                       \n                t = RightRotate(t);\n            } else {                                        \n                if (t.left.pri > t.right.pri)\n                {    \n                    t = RightRotate(t);\n                }\n                else\n                {\n                    t = LeftRotate(t);\n                }\n            }\n        return Delete(t, key);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing CompProgLib.Tree.BinaryTree;\n\nnamespace ALDS1_8_D\n{\n    public class Program\n\n    {\n        public static void Main(string[] args)\n        {\n            int n = ReadInt();\n            Treap<int> tr = new Treap<int>();\n            for (int i = 0 ; i < n ; i++)\n            {\n                string[] line = ReadStAr();\n                switch (line[0])\n                {\n                    case \"insert\":\n                        tr.Add(int.Parse(line[1]),int.Parse(line[2]));\n                        break;\n                    case \"delete\":\n                        tr.Remove(int.Parse(line[1]));\n                        break;\n                    case \"find\":\n                        Console.WriteLine(tr.Contains(int.Parse(line[1])) ? \"yes\" : \"no\");\n                        break;\n                    case \"print\":\n                        Console.WriteLine(\" \" + string.Join(\" \", tr.InorderTraversal(tr.Root).Select(x => x.ToString()).ToArray()));\n                        Console.WriteLine(\" \" + string.Join(\" \", tr.PreorderTraversal(tr.Root).Select(x => x.ToString()).ToArray()));\n                        break;\n                }\n            }\n        }\n\n        static string ReadSt() { return Console.ReadLine(); }\n        static int ReadInt() { return int.Parse(Console.ReadLine()); }\n        static long ReadLong() { return long.Parse(Console.ReadLine()); }\n        static double ReadDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] ReadStAr(char sep = ' ') { return Console.ReadLine().Split(sep); }\n        static int[] ReadIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => int.Parse(e)); }\n        static long[] ReadLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => long.Parse(e)); }\n        static double[] ReadDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Split(sep), e => double.Parse(e)); }\n\n    }\n\n}\n\nnamespace CompProgLib.Tree.BinaryTree\n\n{\n\n    public class TreapNode<T> : BinaryTreeNode<T>\n    {\n        public int Priority { get; set; }\n        public TreapNode() : base() { }\n        public TreapNode(T data) : base(data)\n        {\n            Random cRandom = new Random(123456789);\n            Priority = cRandom.Next(int.MaxValue);\n        }\n        public TreapNode(T data, int priority) : base(data)\n        {\n            Priority = priority;\n        }\n    }\n\n    public class Treap<T> : BinaryTree<T>\n    {\n\n        public virtual void Add(T data, int priority)\n        {\n            TreapNode<T> n = new TreapNode<T>(data, priority);\n            base.Add(n);\n\n            TreapNode<T> current = n;\n            while (current.Parent != null && current.Priority > ((TreapNode<T>)current.Parent).Priority)\n            {\n                if (current.Parent.Left == current)\n                {\n                    RightRotate((TreapNode<T>)current.Parent);\n                }\n                else\n                {\n                    LeftRotate((TreapNode<T>)current.Parent);\n                }\n            }\n        }\n\n        public void RightRotate(TreapNode<T> current)\n        {\n            int result;\n            System.Collections.Comparer comparer = new System.Collections.Comparer(System.Globalization.CultureInfo.CurrentCulture);\n\n            var parent = current.Parent;\n            var newRoot = current.Left;\n            current.Left = newRoot.Right;\n            newRoot.Right = current;\n\n            if (parent == null)\n            {\n                Root = newRoot;\n                Root.Parent = null;\n            }\n            else\n            {\n                result = comparer.Compare(parent.Value, newRoot.Value);\n                if (result > 0)\n                    parent.Left = newRoot;\n                else\n                    parent.Right = newRoot;\n            }\n        }\n\n        public void LeftRotate(TreapNode<T> current)\n        {\n            int result;\n            System.Collections.Comparer comparer = new System.Collections.Comparer(System.Globalization.CultureInfo.CurrentCulture);\n\n            var parent = current.Parent;\n            var newRoot = current.Right;\n            current.Right = newRoot.Left;\n            newRoot.Left = current;\n\n            if (parent == null)\n            {\n                Root = newRoot;\n                Root.Parent = null;\n            }\n            else\n            {\n                result = comparer.Compare(parent.Value, newRoot.Value);\n                if (result > 0)\n                    parent.Left = newRoot;\n                else\n                    parent.Right = newRoot;\n            }\n        }\n\n        public new bool Remove(T data)\n        {\n\n            System.Collections.Comparer comparer = new System.Collections.Comparer(System.Globalization.CultureInfo.CurrentCulture);\n            if (Root == null) return false;\n\n            BinaryTreeNode<T> current = Root;\n            int result = comparer.Compare(current.Value, data);\n            while (result != 0)\n            {\n                if (result > 0)\n                {\n                    current = current.Left;\n                }\n                else if (result < 0)\n                {\n                    current = current.Right;\n                }\n                if (current == null)\n                    return false;\n                else\n                    result = comparer.Compare(current.Value, data);\n            }\n\n            Count--;\n\n            DeleteNode(current);\n            return true;\n\n        }\n\n        private void DeleteNode(BinaryTreeNode<T> current)\n        {\n            int result;\n            System.Collections.Comparer comparer = new System.Collections.Comparer(System.Globalization.CultureInfo.CurrentCulture);\n\n            if (current.Left == null && current.Right == null)\n            {\n                if (current.Parent == null) Root = null;\n                else\n                {\n                    result = comparer.Compare(current.Parent.Value, current.Value);\n                    if (result > 0)\n                        current.Parent.Left = null;\n                    else if (result < 0)\n                        current.Parent.Right = null;\n                }\n            }\n            else if (current.Left == null && current.Right != null)\n            {\n                LeftRotate((TreapNode<T>)current);\n                DeleteNode(current);\n\n            }\n            else if (current.Left != null && current.Right == null)\n            {\n                RightRotate((TreapNode<T>)current);\n                DeleteNode(current);\n            }\n            else\n            {\n                if (((TreapNode<T>)current.Left).Priority > ((TreapNode<T>)current.Right).Priority)\n                {\n                    RightRotate((TreapNode<T>)current);\n                }\n                else\n                {\n                    LeftRotate((TreapNode<T>)current);\n                }\n                DeleteNode(current);\n            }\n        }\n    }\n    \n        public class BinaryTreeNode<T> : Node<T>\n    {\n        public BinaryTreeNode() : base() { }\n        public BinaryTreeNode(T data) : base(data, null) { }\n        public BinaryTreeNode(T data, BinaryTreeNode<T> left, BinaryTreeNode<T> right)\n        {\n            Value = data;\n            Neighbors = new NodeList<T> { left, right };\n        }\n\n        public new virtual BinaryTreeNode<T> Parent { set; get; }\n        public virtual BinaryTreeNode<T> Left\n        {\n            get\n            {\n                if (base.Neighbors == null) return null;\n                else return (BinaryTreeNode<T>)Neighbors[0];\n            }\n            set\n            {\n                if (base.Neighbors == null) base.Neighbors = new NodeList<T>(2);\n                base.Neighbors[0] = value;\n                if (value != null) value.Parent = this;\n            }\n        }\n\n        public virtual BinaryTreeNode<T> Right\n        {\n            get\n            {\n                if (base.Neighbors == null) return null;\n                else return (BinaryTreeNode<T>)Neighbors[1];\n            }\n            set\n            {\n                if (base.Neighbors == null) Neighbors = new NodeList<T>(2);\n                base.Neighbors[1] = value;\n                if (value != null) value.Parent = this;\n            }\n        }\n    }\n\n    public class BinaryTreeNodeList<T> : NodeList<T>\n    {\n        public BinaryTreeNodeList() : base() { }\n        public BinaryTreeNodeList(int initialSize)\n        { for (int i = 0 ; i < initialSize ; i++) Add(default(BinaryTreeNode<T>)); }\n\n        public new BinaryTreeNode<T> FindByValue(T value)\n        {\n            foreach (BinaryTreeNode<T> node in this) if (node.Value.Equals(value)) return node;\n            return null;\n        }\n    }\n\n    public class BinaryTree<T>\n    {\n\n        public BinaryTreeNode<T> Root { get; protected set; }\n        public int Count { get;  set; }\n\n        public BinaryTree() { Root = null; }\n        public virtual void Clear() { Root = null; }\n\n        public List<T> PreorderTraversal(BinaryTreeNode<T> current)\n        {\n            List<T> res = new List<T>();\n            PreorderTraversal(current, res);\n            return res;\n        }\n        private void PreorderTraversal(BinaryTreeNode<T> current, List<T> res)\n        {\n            if (current != null)\n            {\n                res.Add(current.Value);\n                PreorderTraversal(current.Left, res);\n                PreorderTraversal(current.Right, res);\n            }\n        }\n\n        public List<T> InorderTraversal(BinaryTreeNode<T> current)\n        {\n            List<T> res = new List<T>();\n            InorderTraversal(current, res);\n            return res;\n        }\n        private void InorderTraversal(BinaryTreeNode<T> current, List<T> res)\n        {\n            if (current != null)\n            {\n                InorderTraversal(current.Left, res);\n                res.Add(current.Value);\n                InorderTraversal(current.Right, res);\n            }\n        }\n\n        public List<T> PostorderTraversal(BinaryTreeNode<T> current)\n        {\n            List<T> res = new List<T>();\n            PostorderTraversal(current, res);\n            return res;\n        }\n        private void PostorderTraversal(BinaryTreeNode<T> current, List<T> res)\n        {\n            if (current != null)\n            {\n                PostorderTraversal(current.Left, res);\n                PostorderTraversal(current.Right, res);\n                res.Add(current.Value);\n            }\n        }\n\n        public virtual void Add(T data)\n        {\n            BinaryTreeNode<T> n = new BinaryTreeNode<T>(data);\n            Add(n);\n        }\n\n        public virtual void Add(BinaryTreeNode<T> n)\n        {\n\n            int result;\n            System.Collections.Comparer comparer = new System.Collections.Comparer(System.Globalization.CultureInfo.CurrentCulture);\n\n            BinaryTreeNode<T> current = Root, parent = null;\n            while (current != null)\n            {\n                result = comparer.Compare(current.Value, n.Value);\n                if (result == 0)\n                    return;\n                else if (result > 0)\n                {\n                    parent = current;\n                    current = current.Left;\n                }\n                else if (result < 0)\n                {\n                    parent = current;\n                    current = current.Right;\n                }\n            }\n\n            Count++;\n            if (parent == null)\n                Root = n;\n            else\n            {\n                result = comparer.Compare(parent.Value, n.Value);\n                if (result > 0)\n                    parent.Left = n;\n                else\n                    parent.Right = n;\n            }\n        }\n\n        public bool Remove(T data)\n        {\n\n            System.Collections.Comparer comparer = new System.Collections.Comparer(System.Globalization.CultureInfo.CurrentCulture);\n            if (Root == null) return false;\n\n            BinaryTreeNode<T> current = Root;\n            int result = comparer.Compare(current.Value, data);\n            while (result != 0)\n            {\n                if (result > 0)\n                {\n                    current = current.Left;\n                }\n                else if (result < 0)\n                {\n                    current = current.Right;\n                }\n                if (current == null)\n                    return false;\n                else\n                    result = comparer.Compare(current.Value, data);\n            }\n\n            Count--;\n\n            DeleteNode(current);\n            return true;\n        }\n\n        private void DeleteNode(BinaryTreeNode<T> current)\n        {\n            int result;\n            System.Collections.Comparer comparer = new System.Collections.Comparer(System.Globalization.CultureInfo.CurrentCulture);\n\n            if (current.Left == null && current.Right == null)\n            {\n                if (current.Parent == null) Root = null;\n                else\n                {\n                    result = comparer.Compare(current.Parent.Value, current.Value);\n                    if (result > 0)\n                        current.Parent.Left = null;\n                    else if (result < 0)\n                        current.Parent.Right = null;\n                }\n            }\n            else if (current.Left == null && current.Right != null)\n            {\n                if (current.Parent == null)\n                {\n                    Root = current.Right;\n                    Root.Parent = null;\n                }\n                else\n                {\n                    result = comparer.Compare(current.Parent.Value, current.Value);\n                    if (result > 0)\n                        current.Parent.Left = current.Right;\n                    else if (result < 0)\n                        current.Parent.Right = current.Right;\n                }\n            }\n            else if (current.Left != null && current.Right == null)\n            {\n                if (current.Parent == null)\n                {\n                    Root = current.Left;\n                    Root.Parent = null;\n                }\n                else\n                {\n                    result = comparer.Compare(current.Parent.Value, current.Value);\n                    if (result > 0)\n                        current.Parent.Left = current.Left;\n                    else if (result < 0)\n                        current.Parent.Right = current.Left;\n                }\n            }\n            else\n            {\n                BinaryTreeNode<T> nextnode = current.Right, nextnodeParent = current;\n                while (nextnode != null)\n                {\n                    nextnodeParent = nextnode;\n                    nextnode = nextnode.Left;\n                }\n\n                T tmp = nextnodeParent.Value;\n                DeleteNode(nextnodeParent);\n                current.Value = tmp;\n\n            }\n        }\n\n        public bool Contains(T data)\n        {\n            BinaryTreeNode<T> current = Root;\n            int result;\n\n            System.Collections.Comparer comparer = new System.Collections.Comparer(System.Globalization.CultureInfo.CurrentCulture);\n            while (current != null)\n            {\n                result = comparer.Compare(current.Value, data);\n                if (result == 0)\n                    return true;\n                else if (result > 0)\n                    current = current.Left;\n                else if (result < 0)\n                    current = current.Right;\n            }\n\n            return false;\n        }\n\n    }\n}\n\n\n\nnamespace CompProgLib.Tree\n{\n    public class Node<T>\n    {\n        public T Value { get; set; }\n        public virtual Node<T> Parent { get; set; }\n        protected NodeList<T> Neighbors { get; set; }\n\n        public Node() { }\n        public Node(T data) : this(data, null) { }\n        public Node(T data, NodeList<T> neighbors)\n        {\n            Value = data;\n            Neighbors = neighbors;\n        }\n    }\n\n    public class NodeList<T> : List<Node<T>>\n    {\n        public NodeList() : base() { }\n        public NodeList(int initialSize)\n        { for (int i = 0 ; i < initialSize ; i++) Add(default(Node<T>)); }\n\n        public Node<T> FindByValue(T value)\n        {\n            foreach (Node<T> node in this) if (node.Value.Equals(value)) return node;\n            return null;\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing static System.Math;\n\nnamespace CsharpSpiral {\n    partial class Program {\n        static void Main(string[] args) {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n            new Program().Solve(new ConsoleInput(Console.In, ' '));\n            Console.Out.Flush();\n        }\n        public void Solve(ConsoleInput cin) {\n            var m = cin.ReadInt;\n            var G = new Treap<int, int>();\n            for(int i = 0; i < m; i++) {\n                var s = cin.Read;\n                int k, p;\n                switch(s) {\n                    case \"insert\":\n                        k = cin.ReadInt;\n                        p = cin.ReadInt;\n                        G.Insert(k, p);\n                        break;\n                    case \"find\":\n                        k = cin.ReadInt;\n                        Console.WriteLine(G.Find(k) ? \"yes\" : \"no\");\n                        break;\n                    case \"delete\":\n                        k=cin.ReadInt;\n                        G.Delete(k);\n                        break;\n                    case \"print\":\n                        G.MidEmit();\n                        G.FrontEmit();\n                        break;\n                }\n            }\n        }\n        \n    }\n\n    static class ExtendClass {\n        public static string Join<T>(this IEnumerable<T> X, string separator = \" \") => string.Join(separator, X);\n    }\n\n    class ConsoleInput {\n        private readonly TextReader _stream;\n        private readonly char _separator = ' ';\n        private readonly Queue<string> inputStream;\n        public ConsoleInput(TextReader stream, char separator = ' ') {\n            this._separator = separator;\n            this._stream = stream;\n            inputStream = new Queue<string>();\n        }\n        public string Read {\n            get {\n                if(inputStream.Count != 0) return inputStream.Dequeue();\n                string[] tmp = _stream.ReadLine().Split(_separator);\n                for(int i = 0; i < tmp.Length; ++i)\n                    inputStream.Enqueue(tmp[i]);\n                return inputStream.Dequeue();\n            }\n        }\n        public string ReadLine { get { return _stream.ReadLine(); } }\n        public int ReadInt { get { return int.Parse(Read); } }\n        public long ReadLong { get { return long.Parse(Read); } }\n        public double ReadDouble { get { return double.Parse(Read); } }\n        public string[] ReadStrArray(long N) {\n            var ret = new string[N];\n            for(long i = 0; i < N; ++i)\n                ret[i] = Read;\n            return ret;\n        }\n        public int[] ReadIntArray(long N) { var ret = new int[N]; for(long i = 0; i < N; ++i) ret[i] = ReadInt; return ret; }\n        public long[] ReadLongArray(long N) { var ret = new long[N]; for(long i = 0; i < N; ++i) ret[i] = ReadLong; return ret; }\n        public double[] ReadDoubleArray(long N) { var ret = new double[N]; for(long i = 0; i < N; ++i) ret[i] = ReadDouble; return ret; }\n    }\n\n\tclass Treap<V, P> where P : IComparable<P> where V : IComparable<V> {\n\t\tpublic class PriorityNode {\n\t\t\tinternal V value { get; set; }\n\t\t\tinternal P priority { get; set; }\n\t\t\tinternal PriorityNode Left { get; set; }\n\t\t\tinternal PriorityNode Right { get; set; }\n\t\t\tpublic PriorityNode RightRotate() {\n\t\t\t\tvar leftNode = Left;\n\t\t\t\tLeft = leftNode.Right;\n\t\t\t\tleftNode.Right = this;\n\t\t\t\treturn leftNode;\n\t\t\t}\n\t\t\tpublic PriorityNode LeftRotate() {\n\t\t\t\tvar rightNode = Right;\n\t\t\t\tRight = rightNode.Left;\n\t\t\t\trightNode.Left = this;\n\t\t\t\treturn rightNode;\n\t\t\t}\n\t\t}\n\t\tpublic PriorityNode top { get; set; } = null;\n\t\tprivate static PriorityNode InsertFrom(PriorityNode now, V newValue, P newPriority) {\n\t\t\tif(now == null) return new PriorityNode { value = newValue, priority = newPriority };\n\t\t\tswitch(newValue.CompareTo(now.value)) {\n\t\t\t\tcase -1:\n\t\t\t\t\tnow.Left = InsertFrom(now.Left, newValue, newPriority);\n\t\t\t\t\tif(now.priority.CompareTo(now.Left.priority) < 0)\n\t\t\t\t\t\tnow = now.RightRotate();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tnow.Right = InsertFrom(now.Right, newValue, newPriority);\n\t\t\t\t\tif(now.priority.CompareTo(now.Right.priority) < 0)\n\t\t\t\t\t\tnow = now.LeftRotate();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn now;\n\t\t}\n\t\tprivate static PriorityNode DeleteSearch(PriorityNode now, V key) {\n\t\t\tif(now == null)\n\t\t\t\treturn null;\n\t\t\tswitch(key.CompareTo(now.value)) {\n\t\t\t\tcase -1:\n\t\t\t\t\tnow.Left = DeleteSearch(now.Left, key);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tnow.Right = DeleteSearch(now.Right, key);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn DeleteLift(now, key);\n\t\t\t}\n\t\t\treturn now;\n\t\t}\n\t\tprivate static PriorityNode DeleteLift(PriorityNode now, V key) {\n\t\t\tif(now.Left == null && now.Right == null)\n\t\t\t\treturn null;    //execute delete\n\t\t\telse if(now.Left == null)\n\t\t\t\tnow = now.LeftRotate();\n\t\t\telse if(now.Right == null)\n\t\t\t\tnow = now.RightRotate();\n\t\t\telse {\n\t\t\t\tif(now.Left.priority.CompareTo(now.Right.priority) > 0)\n\t\t\t\t\tnow = now.RightRotate();\n\t\t\t\telse\n\t\t\t\t\tnow = now.LeftRotate();\n\t\t\t}\n\t\t\treturn DeleteSearch(now, key);\n\t\t}\n\t\tpublic void Insert(V value, P priority) {\n\t\t\ttop = InsertFrom(top, value, priority);\n\t\t}\n\t\tpublic bool Find(V key) {\n\t\t\tvar now = top;\n\t\t\twhile(now != null) {\n\t\t\t\tswitch(key.CompareTo(now.value)) {\n\t\t\t\t\tcase -1:\n\t\t\t\t\t\tnow = now.Left;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\tnow = now.Right;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic void Delete(V key) {\n\t\t\ttop = DeleteSearch(top, key);\n\t\t}\n\t\tprivate static void MidEmit(PriorityNode now) {\n\t\t\tif(now == null) return;\n\t\t\tMidEmit(now.Left);\n\t\t\tConsole.Write($\" {now.value}\");\n\t\t\tMidEmit(now.Right);\n\t\t}\n\t\tpublic void MidEmit() { MidEmit(top); Console.Write(\"\\n\"); }\n\t\tprivate static void FrontEmit(PriorityNode now) {\n\t\t\tif(now == null) return;\n\t\t\tConsole.Write($\" {now.value}\");\n\t\t\tFrontEmit(now.Left);\n\t\t\tFrontEmit(now.Right);\n\t\t}\n\t\tpublic void FrontEmit() { FrontEmit(top); Console.Write(\"\\n\"); }\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\n\nnamespace Binary_search_trees\n{\n    class Program\n    {\n\n        class Treap\n        {\n            public class Node\n            {\n                internal int val;\n                internal int priority;\n                internal Node left, right;\n                internal Node parent;\n\n                internal Node(int val, int priority)\n                {\n                    this.val = val;\n                    this.priority = priority;\n                    left = right = parent = null;\n                }\n            }\n\n            Node root;\n\n            public Treap()\n            {\n                root = null;\n            }\n\n            internal Node RightRotate(Node t)\n            {\n                Node s = t.left;\n                s.parent = t.parent;\n                if (t.parent == null)\n                    root = s;\n\n                t.left = s.right;\n                if (s.right != null) s.right.parent = t;\n\n                s.right = t;\n                t.parent = s;\n\n                return s;\n            }\n            internal Node LeftRotate(Node t)\n            {\n                Node s = t.right;\n                s.parent = t.parent;\n                if (t.parent == null)\n                    root = s;\n\n                t.right = s.left;\n                if (s.left != null) s.left.parent = t;\n\n                s.left = t;\n                t.parent = s;\n\n                return s;\n            }\n\n            public Node Insert(Node t, int key, int priority)\n            {\n                if (t == null)\n                    return new Node(key, priority);\n\n                if (key == t.val)\n                    return t;\n\n                if (key < t.val)\n                {\n                    t.left = Insert(t.left, key, priority);\n                    t.left.parent = t;\n                    if (t.priority < t.left.priority)\n                        t = RightRotate(t);\n                }\n                else\n                {\n                    t.right = Insert(t.right, key, priority);\n                    t.right.parent = t;\n                    if (t.priority < t.right.priority)\n                        t = LeftRotate(t);\n                }\n                return t;\n            }\n\n            public void Insert(int key, int priority)\n            {\n                if (root == null) root = new Node(key, priority);\n                else Insert(root, key, priority);\n            }\n\n            public void Erase(int key)\n            {\n                Delete(root, key);\n            }\n\n            public Node Delete(Node t, int key)\n            {\n                if (t == null)\n                    return null;\n\n                if (key < t.val)\n                    t.left = Delete(t.left, key);\n                else if (key > t.val)\n                    t.right = Delete(t.right, key);\n                else\n                    return _Delete(t, key);\n\n                return t;\n            }\n\n            private Node _Delete(Node t, int key)\n            {\n                if (t.left == null && t.right == null)\n                    return null;\n\n                else if (t.left == null)\n                    t = LeftRotate(t);\n                else if (t.right == null)\n                    t = RightRotate(t);\n                else\n                {\n                    if (t.left.priority > t.right.priority)\n                        t = RightRotate(t);\n                    else\n                        t = LeftRotate(t);\n                }\n                return Delete(t, key);\n            }\n\n            public Node Find(int elem)\n            {\n                Node n = root;\n                while (n != null)\n                {\n                    if (n.val > elem) n = n.left;\n                    else if (n.val < elem) n = n.right;\n                    else break;\n                }\n                return n;\n            }\n\n            public bool Contains(int elem)\n            {\n                return Find(elem) != null;\n            }\n\n            public void PrintPreorder(Node n)\n            {\n                if (n == null) return;\n                Console.Write(\" \" + n.val);\n                PrintPreorder(n.left);\n                PrintPreorder(n.right);\n            }\n\n            public void PrintPreorder()\n            {\n                PrintPreorder(root);\n                Console.WriteLine();\n            }\n\n            public void PrintInorder(Node n)\n            {\n                if (n == null) return;\n                PrintInorder(n.left);\n                Console.Write(\" \" + n.val);\n                PrintInorder(n.right);\n            }\n\n            public void PrintInorder()\n            {\n                PrintInorder(root);\n                Console.WriteLine();\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            var n = int.Parse(Console.ReadLine());\n            var treap = new Treap();\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n            for (int i = 0; i < n; i++)\n            {\n                var line = Console.ReadLine();\n                switch (line[0])\n                {\n                    case 'i':\n                        var kp = line.Substring(7).Split(' ').Select(s => int.Parse(s)).ToArray();\n                        treap.Insert(kp[0], kp[1]);\n                        break;\n                    case 'f':\n                        if (treap.Contains(int.Parse(line.Substring(5)))) Console.WriteLine(\"yes\");\n                        else Console.WriteLine(\"no\");\n                        break;\n                    case 'd':\n                        treap.Erase(int.Parse(line.Substring(7)));\n                        break;\n                    case 'p':\n                        treap.PrintInorder();\n                        treap.PrintPreorder();\n                        break;\n                }\n            }\n            Console.Out.Flush();\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_accessor :priority, :key, :left, :right\n  def initialize(key, pri)\n    @key = key\n    @priority = pri\n  end\nend\n\ndef find(node, key)\n  return node if node.nil? || node.key == key\n  if key < node.key\n    find(node.left, key)\n  else\n    find(node.right, key)\n  end\nend\ndef in_order(node, arr = [])\n  return if node.nil?\n  in_order(node.left, arr)\n  arr << node.key\n  in_order(node.right, arr)\n  arr\nend\n\ndef pre_order(node, arr = [])\n  return if node.nil?\n  arr << node.key\n  pre_order(node.left, arr)\n  pre_order(node.right, arr)\n  arr\nend\ndef rightRotate(t)\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s #root of the subtree\nend\ndef leftRotate(t)\n    s = t.right\n    t.right = s.left\n    s.left = t\n    return s # root of the subtre\nend\ndef insert(t,key, priority)    # 再帰的に探索\n  if t == nil\n    return Node.new(key, priority)               # 葉に到達したら新しい節点を生成して返す\n  end\n  if key == t.key\n    return t                                 # 重複したkeyは無視\n  end\n\n  if key < t.key                             # 左の子へ移動\n    t.left = insert(t.left, key, priority)   # 左の子へのポインタを更新\n    if t.priority < t.left.priority          # 左の子の方が優先度が高い場合右回転\n      t = rightRotate(t)\n    end\n  else                                       # 右の子へ移動\n    t.right = insert(t.right, key, priority) # 右の子へのポインタを更新\n    if t.priority < t.right.priority         # 右の子の方が優先度が高い場合左回転\n      t = leftRotate(t)\n    end\n  end\n\n  return t\nend\n\ndef delete(t, key)\n    if t == nil\n        return nil\n    end\n    if key < t.key                                # 削除対象を検索\n        t.left = delete(t.left, key)\n    elsif key > t.key\n        t.right = delete(t.right, key)\n    else\n        return _delete(t, key)\n    end\n    return t\nend\n\ndef _delete(t, key) # 削除対象の節点の場合\n    if t.left == nil && t.right == nil           # 葉の場合\n        return nil\n    elsif t.left == nil                        # 右の子のみを持つ場合左回転\n        t = leftRotate(t)\n    elsif t.right == nil                       # 左の子のみを持つ場合右回転\n        t = rightRotate(t)\n    else                                       # 左の子と右の子を両方持つ場合\n        if t.left.priority > t.right.priority  # 優先度が高い方を持ち上げる\n            t = rightRotate(t)\n        else\n            t = leftRotate(t)\n        end\n    end\n    return delete(t, key)\nend\n\nnode = nil\n$n=gets.to_i\n$n.times{|i|\n  cmd, key, priority = gets.split\n  case cmd\n  when 'insert'\n    node = insert(node, key.to_i, priority.to_i)\n  when 'find'\n    puts find(node, key.to_i) ? 'yes' : 'no'\n  when 'delete'\n    node = delete(node, key.to_i)\n  when 'print'\n    puts \"\\s\" + in_order(node).join(\"\\s\")\n    puts \"\\s\" + pre_order(node).join(\"\\s\")\n  end\n}\n"
  },
  {
    "language": "Ruby",
    "code": "Node = Struct.new(:key, :priority, :left, :right)\n\nclass Tree\n  def initialize\n    @root = nil\n  end\n  \n  def insert(key, priority)\n    unless @root\n      @root = Node.new(key, priority)\n      return\n    end\n    insert = ->(node) {\n      return Node.new(key, priority) unless node\n      return node if key == node.key\n      if key < node.key\n        node.left  = insert.(node.left)\n        node = right_rotate(node) if node.priority < node.left.priority\n      else\n        node.right = insert.(node.right)\n        node = left_rotate(node)  if node.priority < node.right.priority\n      end\n      node\n    }\n    @root = insert.(@root)\n  end\n  \n  def search(key)\n    node = @root\n    while node\n      if key < node.key\n        node = node.left\n      elsif key > node.key\n        node = node.right\n      else\n        return node\n      end\n    end\n    nil\n  end\n  \n  def delete(key)\n    delete1 = nil\n    \n    delete = ->(node) {\n      return nil unless node\n      if key < node.key\n        node.left  = delete.(node.left)\n      elsif key > node.key\n        node.right = delete.(node.right)\n      else\n        return delete1.(node)\n      end\n      node\n    }\n    delete1 = ->(node) {\n      return nil if !node.left and !node.right\n      node = if node.left.nil?\n        left_rotate(node)\n      elsif node.right.nil?\n        right_rotate(node)\n      else\n        if node.left.priority > node.right.priority\n          right_rotate(node)\n        else\n          left_rotate(node)\n        end\n      end\n      delete.(node)\n    }\n    @root = delete.(@root)\n  end\n  \n  def right_rotate(node)\n    tmp = node.left\n    node.left = tmp.right\n    tmp.right = node\n    tmp\n  end\n  \n  def left_rotate(node)\n    tmp = node.right\n    node.right = tmp.left\n    tmp.left = node\n    tmp\n  end\n  \n  def preorder\n    traverse = ->(node) {\n      if node\n        yield(node.key)\n        traverse.(node.left)\n        traverse.(node.right)\n      end\n    }\n    traverse.(@root)\n  end\n  \n  def inorder\n    traverse = ->(node) {\n      if node\n        traverse.(node.left)\n        yield(node.key)\n        traverse.(node.right)\n      end\n    }\n    traverse.(@root)\n  end\nend\n\nt = Tree.new\n\n$<.gets.to_i.times do\n  com, key, priority = $<.gets.split\n  key = key.to_i\n  priority = priority.to_i\n  case com\n  when \"insert\" then t.insert(key, priority)\n  when \"print\"\n    t.inorder  {|key| print \" #{key}\"}\n    puts\n    t.preorder {|key| print \" #{key}\"}\n    puts\n  when \"find\"\n    puts t.search(key) ? \"yes\" : \"no\"\n  when \"delete\" then t.delete(key)\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_accessor :left, :right, :key, :priority\n\n  def initialize(key:, priority:)\n    @key = key\n    @priority = priority\n  end\nend\n\ndef find(node, key)\n  return node if node.nil? || node.key == key\n  if key < node.key\n    find(node.left, key)\n  else\n    find(node.right, key)\n  end\nend\n\ndef in_order(node, arr = [])\n  return if node.nil?\n  in_order(node.left, arr)\n  arr << node.key\n  in_order(node.right, arr)\n  arr\nend\n\ndef pre_order(node, arr = [])\n  return if node.nil?\n  arr << node.key\n  pre_order(node.left, arr)\n  pre_order(node.right, arr)\n  arr\nend\n\n\ndef right_rotate(t)\n  s = t.left\n  t.left = s.right\n  s.right = t\n  s\nend\n\ndef left_rotate(t)\n  s = t.right\n  t.right = s.left\n  s.left = t\n  s\nend\n\ndef insert(t, key, priority)\n  return Node.new(key: key, priority: priority) if t.nil?\n  return t if t.key == key\n\n  if key < t.key\n    t.left = insert(t.left, key, priority)\n    t = right_rotate(t) if t.priority < t.left.priority\n  else\n    t.right = insert(t.right, key, priority)\n    t = left_rotate(t) if t.priority < t.right.priority\n  end\n  t\nend\n\ndef delete(t, key)\n  return if t.nil?\n  if key < t.key\n    t.left = delete(t.left, key)\n  elsif key > t.key\n    t.right = delete(t.right, key)\n  else\n    return _delete(t, key)\n  end\n  t\nend\n\ndef _delete(t, key)\n  return nil if t.left.nil? && t.right.nil?\n\n  if t.left.nil?\n    t = left_rotate(t)\n  elsif t.right.nil?\n    t = right_rotate(t)\n  else\n    if t.left.priority > t.right.priority\n      t = right_rotate(t)\n    else\n      t = left_rotate(t)\n    end\n  end\n  delete(t, key)\nend\n\n\nnode = nil\ngets.to_i.times do\n  command, key, priority = gets.split\n\n  case command\n  when 'insert'\n    node = insert(node, key.to_i, priority.to_i)\n  when 'find'\n    puts find(node, key.to_i) ? 'yes' : 'no'\n  when 'delete'\n    node = delete(node, key.to_i)\n  when 'print'\n    puts \"\\s\" + in_order(node).join(\"\\s\")\n    puts \"\\s\" + pre_order(node).join(\"\\s\")\n  end\nend\n\n\n"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  def initialize(key, priority)\n    @key = key\n    @priority = priority\n    @parent = nil\n    @left = nil\n    @right = nil\n  end\n  attr_accessor :key, :priority, :parent, :left, :right\nend\n\ndef right_rotate(node_t)\n  node_s = node_t.left\n  node_t.left = node_s.right\n  node_s.right = node_t\n  return node_s\nend\n\ndef left_rotate(node_t)\n  node_s = node_t.right\n  node_t.right = node_s.left\n  node_s.left = node_t\n  return node_s\nend\n\ndef insert(node_t, key, priority)\n  if node_t == nil\n    return Node.new(key,priority)\n  end\n  if key == node_t.key\n    return node_t\n  end\n\n  if key < node_t.key\n    node_t.left = insert(node_t.left, key, priority)\n    if node_t.priority < node_t.left.priority\n      node_t = right_rotate(node_t)\n    end\n  else\n    node_t.right = insert(node_t.right, key, priority)\n    if node_t.priority < node_t.right.priority\n      node_t = left_rotate(node_t)\n    end\n  end\n  return node_t\nend\n\ndef find?(key)\n  node_x = @root\n  loop do\n    if node_x == nil\n      return false\n    elsif node_x.key == key\n      return node_x\n    elsif key < node_x.key\n      node_x = node_x.left\n    else\n      node_x = node_x.right\n    end\n  end\nend\n\ndef delete(node_t, key)\n  if node_t == nil\n    return nil\n  end\n  if key < node_t.key\n    node_t.left = delete(node_t.left, key)\n  elsif key > node_t.key\n    node_t.right = delete(node_t.right, key)\n  else\n    return _delete(node_t, key)\n  end\n  return node_t\nend\n\ndef _delete(node_t, key)\n  if node_t.left == nil && node_t.right ==nil\n    return nil\n  elsif node_t.left == nil\n    node_t = left_rotate(node_t)\n  elsif node_t.right == nil\n    node_t = right_rotate(node_t)\n  else\n    if node_t.left.priority > node_t.right.priority\n      node_t = right_rotate(node_t)\n    else\n      node_t = left_rotate(node_t)\n    end\n  end\n  return delete(node_t, key)\nend\n\n\ndef inorder_tree_walk(node)\n  if node != nil\n    inorder_tree_walk(node.left)\n    print \" \"\n    print node.key\n    inorder_tree_walk(node.right)\n  end\nend\n\ndef preorder_tree_walk(node)\n  if node != nil\n    print \" \"\n    print node.key\n    preorder_tree_walk(node.left)\n    preorder_tree_walk(node.right)\n  end\nend\n\ndef print_tree\n  inorder_tree_walk(@root)\n  puts\n  preorder_tree_walk(@root)\n  puts\nend\n\n\n@root = nil\n\nm = gets.to_i\nm.times do |t|\n  input = gets.split(\" \")\n  command = input.shift\n  input.map!{|x| x.to_i}\n  if command == \"insert\"\n    @root = insert(@root, input[0], input[1])\n  elsif command == \"find\"\n    if find?(input[0])\n      puts \"yes\"\n    else\n      puts \"no\"\n    end\n  elsif command == \"delete\"\n    @root = delete(@root, input[0])\n  else\n    print_tree\n  end\nend\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"fmt\"\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n)\n\ntype Node struct {\n\tKey int\n\tPriority int\n\tLeft *Node\n\tRight *Node\n}\n\nfunc main() {\n\tvar n int\n\tfmt.Scan(&n)\n\n\tvar root *Node\n\t\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\twr := bufio.NewWriter(os.Stdout)\n\tfor i := 0; i < n; i++ {\n\t\tsc.Scan()\n\t\tcom := sc.Text()\n\t\tif com == \"print\" {\n\t\t\tprintInorder(root, wr)\n\t\t\twr.WriteString(\"\\n\")\n\t\t\tprintPreorder(root, wr)\n\t\t\twr.WriteString(\"\\n\")\n\t\t\tcontinue\n\t\t}\n\n\t\tsc.Scan()\n\t\tk, _ := strconv.Atoi(sc.Text())\n\t\t\n\t\tswitch com {\n\t\tcase \"insert\":\n\t\t\tsc.Scan()\n\t\t\tp, _ := strconv.Atoi(sc.Text())\n\t\t\troot = insert(root, k, p)\n\t\tcase \"find\":\n\t\t\tif find(root, k) == nil {\n\t\t\t\twr.WriteString(\"no\\n\")\n\t\t\t} else {\n\t\t\t\twr.WriteString(\"yes\\n\")\n\t\t\t}\n\t\tcase \"delete\":\n\t\t\troot = delete(root, k)\n\t\tdefault:\n\t\t\tpanic(\"invalid command\")\n\t\t}\n\t}\n\twr.Flush()\n}\n\nfunc insert(t *Node, k int, p int) *Node {\n\tif t == nil {\n\t\treturn &Node{k, p, nil, nil}\n\t}\n\tif k == t.Key {\n\t\treturn t\n\t}\n\n\tif k < t.Key {\n\t\tt.Left = insert(t.Left, k, p)\n\t\tif t.Priority < t.Left.Priority {\n\t\t\tt = rotateRight(t)\n\t\t}\n\t} else {\n\t\tt.Right = insert(t.Right, k, p)\n\t\tif t.Priority < t.Right.Priority {\n\t\t\tt = rotateLeft(t)\n\t\t}\n\t}\n\treturn t\n}\n\nfunc rotateLeft(t *Node) *Node {\n\ts := t.Right\n\tt.Right = s.Left\n\ts.Left = t\n\treturn s\n}\n\nfunc rotateRight(t *Node) *Node {\n\ts := t.Left\n\tt.Left = s.Right\n\ts.Right = t\n\treturn s\n}\n\nfunc find(t *Node, k int) *Node {\n\tif t == nil {\n\t\treturn nil\n\t} else if t.Key == k {\n\t\treturn t\n\t} else if k < t.Key {\n\t\treturn find(t.Left, k)\n\t} else {\n\t\treturn find(t.Right, k)\n\t}\n}\n\nfunc delete(t *Node, k int) *Node {\n\tif t == nil {\n\t\treturn nil\n\t}\n\n\tif k < t.Key {\n\t\tt.Left = delete(t.Left, k)\n\t} else if k > t.Key {\n\t\tt.Right = delete(t.Right, k)\n\t} else {\n\t\t// 実際の削除\n\t\tif t.Left == nil && t.Right == nil {\n\t\t\treturn nil\n\t\t}\n\t\tif t.Left == nil {\n\t\t\tt = rotateLeft(t)\n\t\t} else if t.Right == nil {\n\t\t\tt = rotateRight(t)\n\t\t} else {\n\t\t\tif t.Left.Priority < t.Right.Priority {\n\t\t\t\tt = rotateLeft(t)\n\t\t\t} else {\n\t\t\t\tt = rotateRight(t)\n\t\t\t}\n\t\t}\n\t\treturn delete(t, k)\n\t}\n\treturn t\n}\n\nfunc printInorder(t *Node, wr *bufio.Writer) {\n\tif t == nil {\n\t\treturn\n\t}\n\tprintInorder(t.Left, wr)\n\twr.WriteString(\" \")\n\twr.WriteString(strconv.Itoa(t.Key))\n\tprintInorder(t.Right, wr)\n}\n\nfunc printPreorder(t *Node, wr *bufio.Writer) {\n\tif t == nil {\n\t\treturn\n\t}\n\twr.WriteString(\" \")\n\twr.WriteString(strconv.Itoa(t.Key))\n\tprintPreorder(t.Left, wr)\n\tprintPreorder(t.Right, wr)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\ntype Node struct {\n\tkey      int\n\tpriority int\n\tleft     *Node\n\tright    *Node\n}\n\nfunc rightRotate(node *Node) *Node {\n\tnewRoot := node.left\n\tnode.left = newRoot.right\n\tnewRoot.right = node\n\treturn newRoot\n}\n\nfunc leftRotate(node *Node) *Node {\n\tnewRoot := node.right\n\tnode.right = newRoot.left\n\tnewRoot.left = node\n\treturn newRoot\n}\n\nfunc insert(key int, priority int, rootNode *Node) (*Node, error) {\n\tif rootNode == nil {\n\t\treturn &Node{key, priority, nil, nil}, nil\n\t} else if rootNode.key == key {\n\t\treturn nil, fmt.Errorf(\"Same key already exists: %d\\n\", key)\n\t} else if rootNode.key < key {\n\t\tif rootNode.right == nil {\n\t\t\tnewNode := &Node{key, priority, nil, nil}\n\t\t\trootNode.right = newNode\n\t\t} else {\n\t\t\trootNode.right, _ = insert(key, priority, rootNode.right)\n\t\t}\n\t\tif rootNode.priority < rootNode.right.priority {\n\t\t\trootNode = leftRotate(rootNode)\n\t\t}\n\t} else {\n\t\tif rootNode.left == nil {\n\t\t\tnewNode := &Node{key, priority, nil, nil}\n\t\t\trootNode.left = newNode\n\t\t} else {\n\t\t\trootNode.left, _ = insert(key, priority, rootNode.left)\n\t\t}\n\t\tif rootNode.priority < rootNode.left.priority {\n\t\t\trootNode = rightRotate(rootNode)\n\t\t}\n\t}\n\treturn rootNode, nil\n}\n\nfunc delete(key int, rootNode *Node) (*Node, error) {\n\tif rootNode == nil {\n\t\treturn nil, fmt.Errorf(\"not found: %d\\n\", key)\n\t} else if rootNode.key == key {\n\t\treturn _delete(key, rootNode)\n\t} else if rootNode.key < key {\n\t\trootNode.right, _ = delete(key, rootNode.right)\n\t\treturn rootNode, nil\n\t} else {\n\t\trootNode.left, _ = delete(key, rootNode.left)\n\t\treturn rootNode, nil\n\t}\n}\n\nfunc _delete(key int, node *Node) (*Node, error) {\n\tif node.left == nil && node.right == nil {\n\t\treturn nil, nil\n\t} else if node.left == nil {\n\t\tnode = leftRotate(node)\n\t} else if node.right == nil {\n\t\tnode = rightRotate(node)\n\t} else {\n\t\tif node.left.priority < node.right.priority {\n\t\t\tnode = leftRotate(node)\n\t\t} else {\n\t\t\tnode = rightRotate(node)\n\t\t}\n\t}\n\treturn delete(key, node)\n}\n\nfunc find(key int, rootNode *Node) bool {\n\tif rootNode == nil {\n\t\treturn false\n\t} else if rootNode.key == key {\n\t\treturn true\n\t} else if rootNode.key < key {\n\t\treturn find(key, rootNode.right)\n\t} else {\n\t\treturn find(key, rootNode.left)\n\t}\n}\n\nfunc inorder(root *Node) []int {\n\tis := []int{}\n\treturn _inorder(root, is)\n}\n\nfunc _inorder(root *Node, is []int) []int {\n\tif root == nil {\n\t\treturn is\n\t}\n\tis = _inorder(root.left, is)\n\tis = append(is, root.key)\n\tis = _inorder(root.right, is)\n\treturn is\n}\n\nfunc preorder(root *Node) []int {\n\tis := []int{}\n\treturn _preorder(root, is)\n}\n\nfunc _preorder(root *Node, is []int) []int {\n\tif root == nil {\n\t\treturn is\n\t}\n\tis = append(is, root.key)\n\tis = _preorder(root.left, is)\n\tis = _preorder(root.right, is)\n\treturn is\n}\n\nfunc isToAs(is []int) []string {\n\tas := make([]string, len(is))\n\tfor i := 0; i < len(as); i++ {\n\t\tas[i] = \" \" + strconv.Itoa(is[i])\n\t}\n\treturn as\n}\n\nfunc CmdInsert(key int, priority int, rootNode *Node) *Node {\n\tx, _ := insert(key, priority, rootNode)\n\treturn x\n}\n\nfunc CmdDelete(key int, rootNode *Node) *Node {\n\tx, _ := delete(key, rootNode)\n\treturn x\n}\n\nfunc CmdPrint(node *Node) {\n\tfmt.Println(strings.Join(isToAs(inorder(node)), \"\"))\n\tfmt.Println(strings.Join(isToAs(preorder(node)), \"\"))\n}\n\nfunc CmdFind(key int, rootNode *Node) {\n\tif find(key, rootNode) {\n\t\tfmt.Println(\"yes\")\n\t} else {\n\t\tfmt.Println(\"no\")\n\t}\n}\n\nfunc main() {\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\n\tn, _ := nextInt(sc)\n\tvar node *Node\n\tfor i := 0; i < n; i++ {\n\t\tcommand := nextText(sc)\n\t\tswitch command {\n\t\tcase \"insert\":\n\t\t\tkey, _ := nextInt(sc)\n\t\t\tpriority, _ := nextInt(sc)\n\t\t\tnode = CmdInsert(key, priority, node)\n\t\tcase \"delete\":\n\t\t\tkey, _ := nextInt(sc)\n\t\t\tnode = CmdDelete(key, node)\n\t\tcase \"print\":\n\t\t\tCmdPrint(node)\n\t\tcase \"find\":\n\t\t\tkey, _ := nextInt(sc)\n\t\t\tCmdFind(key, node)\n\t\tdefault:\n\t\t\tpanic(fmt.Sprintf(\"unknown command: %s\\n\", command))\n\t\t}\n\t}\n}\n\nfunc nextText(sc *bufio.Scanner) string {\n\tsc.Scan()\n\treturn sc.Text()\n}\n\nfunc nextInt(sc *bufio.Scanner) (int, error) {\n\tsc.Scan()\n\treturn strconv.Atoi(sc.Text())\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\ntype Node struct {\n\tvalue    int\n\tpriority int\n\tleft     *Node\n\tright    *Node\n}\n\ntype Tree struct {\n\troot *Node\n}\n\nfunc main() {\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\tn, err := nextInt(sc)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\ttree := &Tree{}\n\tfor i := 0; i < n; i++ {\n\t\tcommand := nextText(sc)\n\t\tif command == \"insert\" {\n\t\t\tvalue, err := nextInt(sc)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tpriority, err := nextInt(sc)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tinsertTree(value, priority, tree)\n\t\t} else if command == \"print\" {\n\t\t\tprintTree(tree)\n\t\t} else if command == \"find\" {\n\t\t\tx, err := nextInt(sc)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tif findTree(x, tree) != nil {\n\t\t\t\tfmt.Println(\"yes\")\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"no\")\n\t\t\t}\n\t\t} else if command == \"delete\" {\n\t\t\tx, err := nextInt(sc)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tdeleteTree(x, tree)\n\t\t} else {\n\t\t\tpanic(fmt.Errorf(\"unknown command: %s\\n\", command))\n\t\t}\n\t}\n}\n\nfunc insertTree(value int, priority int, tree *Tree) {\n\ttree.root = insertNode(value, priority, tree.root)\n}\n\nfunc insertNode(value int, priority int, node *Node) *Node {\n\tif node == nil {\n\t\treturn &Node{value, priority, nil, nil}\n\t}\n\tif node.value < value {\n\t\tnode.right = insertNode(value, priority, node.right)\n\t\tif node.priority < node.right.priority {\n\t\t\tnode = leftRotate(node)\n\t\t}\n\t} else {\n\t\tnode.left = insertNode(value, priority, node.left)\n\t\tif node.priority < node.left.priority {\n\t\t\tnode = rightRotate(node)\n\t\t}\n\t}\n\treturn node\n}\n\nfunc leftRotate(node *Node) *Node {\n\ts := node.right\n\tnode.right = s.left\n\ts.left = node\n\treturn s\n}\n\nfunc rightRotate(node *Node) *Node {\n\ts := node.left\n\tnode.left = s.right\n\ts.right = node\n\treturn s\n}\n\nfunc printTree(tree *Tree) {\n\tif tree.root == nil {\n\t\tfmt.Println(\"\")\n\t\tfmt.Println(\"\")\n\t} else {\n\t\tprintResult(inorder(tree.root, []int{}))\n\t\tprintResult(preorder(tree.root, []int{}))\n\t}\n}\n\nfunc findTree(x int, tree *Tree) *Node {\n\treturn findNode(x, tree.root)\n}\n\nfunc findNode(x int, node *Node) *Node {\n\tfor node != nil {\n\t\tif node.value == x {\n\t\t\treturn node\n\t\t} else if node.value < x {\n\t\t\tnode = node.right\n\t\t} else {\n\t\t\tnode = node.left\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc deleteTree(x int, tree *Tree) {\n\ttree.root = deleteNode(x, tree.root)\n}\n\nfunc deleteNode(x int, node *Node) *Node {\n\tif node == nil {\n\t\treturn nil\n\t}\n\tif x < node.value {\n\t\tnode.left = deleteNode(x, node.left)\n\t} else if x > node.value {\n\t\tnode.right = deleteNode(x, node.right)\n\t} else {\n\t\treturn _deleteNode(x, node)\n\t}\n\treturn node\n}\n\nfunc _deleteNode(x int, node *Node) *Node {\n\tif node.left != nil && node.right != nil {\n\t\tif node.left.priority < node.right.priority {\n\t\t\tnode = leftRotate(node)\n\t\t} else {\n\t\t\tnode = rightRotate(node)\n\t\t}\n\t} else if node.left != nil {\n\t\tnode = rightRotate(node)\n\t} else if node.right != nil {\n\t\tnode = leftRotate(node)\n\t} else {\n\t\treturn nil\n\t}\n\treturn deleteNode(x, node)\n}\n\nfunc preorder(top *Node, vs []int) []int {\n\tvs = append(vs, top.value)\n\tif top.left != nil {\n\t\tvs = preorder(top.left, vs)\n\t}\n\tif top.right != nil {\n\t\tvs = preorder(top.right, vs)\n\t}\n\treturn vs\n}\n\nfunc inorder(top *Node, vs []int) []int {\n\tif top.left != nil {\n\t\tvs = inorder(top.left, vs)\n\t}\n\tvs = append(vs, top.value)\n\tif top.right != nil {\n\t\tvs = inorder(top.right, vs)\n\t}\n\treturn vs\n}\n\nfunc nextText(sc *bufio.Scanner) string {\n\tsc.Scan()\n\treturn sc.Text()\n}\n\nfunc nextInt(sc *bufio.Scanner) (int, error) {\n\tsc.Scan()\n\treturn strconv.Atoi(sc.Text())\n}\n\nfunc printResult(result []int) {\n\twriter := bufio.NewWriter(os.Stdout)\n\tfor i := 0; i < len(result); i++ {\n\t\twriter.Write([]byte(fmt.Sprintf(\" %d\", result[i])))\n\t}\n\twriter.Write([]byte(\"\\n\"))\n\twriter.Flush()\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nconst (\n\tMAX_KEY = 2000000000\n\tMAX_PRIORITY = 2000000000\n)\n\ntype node struct {\n\tkey int\n\tpriority int\n\tparent *node\n\tleft *node\n\tright *node\n}\n\ntype treap struct {\n\troot *node\n}\n\nfunc newTreap() *treap {\n\ttreap := treap{}\n\tdummy := node{key: MAX_KEY + 1, priority: MAX_PRIORITY + 1}\n\ttreap.root = &dummy\n\treturn &treap\n}\n\n// return new root after rotation\nfunc (nd *node) rightRotate() *node {\n\tnewRoot := nd.left\n\tif newRoot == nil {\n\t\tpanic(fmt.Errorf(\"expect left of node %d is not null\", nd.key))\n\t}\n\n\tnd.left = newRoot.right\n\tif nd.left != nil {\n\t\tnd.left.parent = nd\n\t}\n\n\tnewRoot.parent = nd.parent\n\tif newRoot.parent != nil {\n\t\tif newRoot.parent.left == nd {\n\t\t\tnewRoot.parent.left = newRoot\n\t\t} else {\n\t\t\tnewRoot.parent.right = newRoot\n\t\t}\n\t}\n\tnd.parent = newRoot\n\n\tnewRoot.right = nd\n\treturn newRoot\n}\n\n// return new root after rotation\nfunc (nd *node) leftRotate() *node {\n\tnewRoot := nd.right\n\tif newRoot == nil {\n\t\tpanic(fmt.Errorf(\"expect right of node %d is not null\", nd.key))\n\t}\n\n\tnd.right = newRoot.left\n\tif nd.right != nil {\n\t\tnd.right.parent = nd\n\t}\n\n\tnewRoot.parent = nd.parent\n\tif newRoot.parent != nil {\n\t\tif newRoot.parent.left == nd {\n\t\t\tnewRoot.parent.left = newRoot\n\t\t} else {\n\t\t\tnewRoot.parent.right = newRoot\n\t\t}\n\t}\n\tnd.parent = newRoot\n\n\tnewRoot.left = nd\n\treturn newRoot\n}\n\nfunc (currentNode *node) insert(key int, priority int) *node {\n\tvar prevNode *node\n\tfor currentNode != nil {\n\t\tprevNode = currentNode\n\t\tif currentNode.key < key {\n\t\t\tcurrentNode = currentNode.right\n\t\t} else {\n\t\t\tcurrentNode = currentNode.left\n\t\t}\n\t}\n\n\tnewNode := &node{key: key, priority: priority}\n\tnewNode.parent = prevNode\n\tif prevNode.key < key {\n\t\tprevNode.right = newNode\n\t} else {\n\t\tprevNode.left = newNode\n\t}\n\treturn newNode\n}\n\nfunc (nd *node) delete() {\n\tcurrentNode := nd\n\tprevNode := currentNode.parent\n\tif currentNode.left == nil && currentNode.right == nil {\n\t\t// no child exist\n\t\tif prevNode.left == currentNode {\n\t\t\tprevNode.left = nil\n\t\t} else {\n\t\t\tprevNode.right = nil\n\t\t}\n\t} else if currentNode.left != nil && currentNode.right != nil {\n\t\t// both child exist\n\t\tvar child *node\n\t\tchild = currentNode.right\n\t\tfor child.left != nil {\n\t\t\tchild = child.left\n\t\t}\n\t\tcurrentNode.key = child.key\n\t\tchild.delete()\n\t} else {\n\t\t// the either of left or right child exist\n\t\tvar child *node\n\t\tif currentNode.left != nil {\n\t\t\tchild = currentNode.left\n\t\t} else {\n\t\t\tchild = currentNode.right\n\t\t}\n\t\tif prevNode.left == currentNode {\n\t\t\tprevNode.left = child\n\t\t\tchild.parent = prevNode\n\t\t} else {\n\t\t\tprevNode.right = child\n\t\t\tchild.parent = prevNode\n\t\t}\n\t}\n}\n\nfunc visitPreorder(node *node, acc []int) []int {\n\tif node == nil {\n\t\treturn acc\n\t}\n\tacc = append(acc, int(node.key))\n\tif node.left != nil {\n\t\tacc = visitPreorder(node.left, acc)\n\t}\n\tif node.right != nil {\n\t\tacc = visitPreorder(node.right, acc)\n\t}\n\treturn acc\n}\n\nfunc visitInorder(node *node, acc []int) []int {\n\tif node == nil {\n\t\treturn acc\n\t}\n\tif node.left != nil {\n\t\tacc = visitInorder(node.left, acc)\n\t}\n\tacc = append(acc, int(node.key))\n\tif node.right != nil {\n\t\tacc = visitInorder(node.right, acc)\n\t}\n\treturn acc\n}\n\n// ------\n// treap\n// ------\n\nfunc (tree *treap) insert(key int, priority int) {\n\tif tree.root == nil {\n\t\ttree.root = &node{key: key, priority: priority}\n\t\treturn\n\t}\n\n\tinserted := tree.root.insert(key, priority)\n\tparent := inserted.parent\n\tfor parent != nil && parent.priority < inserted.priority {\n\t\tif parent.left == inserted {\n\t\t\tinserted = parent.rightRotate()\n\t\t} else {\n\t\t\tinserted = parent.leftRotate()\n\t\t}\n\t\tparent = inserted.parent\n\t}\n\t// tree.print()\n}\n\nfunc (tree *treap) find(key int) bool {\n\tnode := tree.root\n\tfor node != nil {\n\t\tif node.key == key {\n\t\t\treturn true\n\t\t} else if node.key < key {\n\t\t\tnode = node.right\n\t\t} else {\n\t\t\tnode = node.left\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (tree *treap) delete(key int) {\n\tvar currentNode *node\n\tcurrentNode = tree.root\n\tfor currentNode != nil && currentNode.key != key {\n\t\tif currentNode.key < key {\n\t\t\tcurrentNode = currentNode.right\n\t\t} else {\n\t\t\tcurrentNode = currentNode.left\n\t\t}\n\t}\n\tif currentNode == nil {\n\t\treturn\n\t}\n\n\tfor {\n\t\tif currentNode.left == nil && currentNode.right == nil {\n\t\t\t// no child\n\t\t\tbreak\n\n\t\t} else if currentNode.left != nil && currentNode.right != nil {\n\t\t\t// both left and right child exist\n\t\t\tif currentNode.left.priority < currentNode.right.priority {\n\t\t\t\t_ = currentNode.leftRotate()\n\t\t\t} else {\n\t\t\t\t_ = currentNode.rightRotate()\n\t\t\t}\n\n\t\t} else {\n\t\t\t// either of left or child exist\n\t\t\tif currentNode.left != nil {\n\t\t\t\t_ = currentNode.rightRotate()\n\t\t\t} else {\n\t\t\t\t_ = currentNode.leftRotate()\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t}\n\n\tcurrentNode.delete()\n}\n\nfunc (tree *treap) print() {\n\tvar acc []int\n\tif tree.root.left == nil {\n\t\tfmt.Println(\"\")\n\t\tfmt.Println(\"\")\n\t} else {\n\t\tfmt.Println(\" \" + strings.Join(isToAs(visitInorder(tree.root.left, acc)), \" \"))\n\t\tfmt.Println(\" \" + strings.Join(isToAs(visitPreorder(tree.root.left, acc)), \" \"))\n\t}\n}\n\nfunc main() {\n\tsc := bufio.NewScanner(os.Stdin)\n\tsc.Split(bufio.ScanWords)\n\n\tn, err := nextInt(sc)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\ttree := newTreap()\n\tfor i := 0; i < n; i++ {\n\t\tcommand := nextText(sc)\n\t\tswitch command {\n\t\tcase \"insert\":\n\t\t\tkey, err := nextInt(sc)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tpriority, err := nextInt(sc)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\ttree.insert(key, priority)\n\t\tcase \"find\":\n\t\t\tkey, err := nextInt(sc)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\tif tree.find(key) {\n\t\t\t\tfmt.Println(\"yes\")\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"no\")\n\t\t\t}\n\t\tcase \"delete\":\n\t\t\tkey, err := nextInt(sc)\n\t\t\tif err != nil {\n\t\t\t\tpanic(err)\n\t\t\t}\n\t\t\ttree.delete(key)\n\t\tcase \"print\":\n\t\t\ttree.print()\n\t\tdefault:\n\t\t\tpanic(\"unknown command: \" + command)\n\t\t}\n\t}\n}\n\nfunc nextText(sc *bufio.Scanner) string {\n\tsc.Scan()\n\treturn sc.Text()\n}\n\nfunc nextInt(sc *bufio.Scanner) (int, error) {\n\treturn strconv.Atoi(nextText(sc))\n}\n\nfunc isToAs(is []int) []string {\n\tn := len(is)\n\tas := make([]string, n)\n\tfor i := 0; i < n; i++ {\n\t\tas[i] = strconv.Itoa(is[i])\n\t}\n\treturn as\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\n\nfunc nextString() string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc nextInt() int {\n\tn, err := strconv.Atoi(nextString())\n\tif err != nil {\n\t\tfmt.Printf(\"strconv.Atoi failed: %v\\n\", err)\n\t}\n\treturn n\n}\n\n// NewTreapNode is a constructor of TreapNode\nfunc NewTreapNode(key int, priority int) *TreapNode {\n\ttp := TreapNode{}\n\ttp.key = key\n\ttp.priority = priority\n\treturn &tp\n}\n\n// TreapNode contains integer\ntype TreapNode struct {\n\tkey      int\n\tpriority int\n\tleft     *TreapNode\n\tright    *TreapNode\n}\n\nfunc (node *TreapNode) setLeftChild(key int, priority int) {\n\tchild := NewTreapNode(key, priority)\n\tnode.left = child\n}\n\nfunc (node *TreapNode) setRightChild(key int, priority int) {\n\tchild := NewTreapNode(key, priority)\n\tnode.right = child\n}\n\n// NewTreap is a constructor of Treap\nfunc NewTreap() *Treap {\n\ttreap := Treap{}\n\treturn &treap\n}\n\n// Treap described at\n//  https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_D\ntype Treap struct {\n\troot *TreapNode\n}\n\nfunc (t *Treap) insert(key int, priority int) {\n\tif t.root == nil {\n\t\tnode := NewTreapNode(key, priority)\n\t\tt.root = node\n\t} else {\n\t\tt.root = t.insertLoop(t.root, key, priority)\n\t}\n}\n\nfunc (t *Treap) insertLoop(current *TreapNode, key int, priority int) *TreapNode {\n\tif current == nil {\n\t\tnewNode := NewTreapNode(key, priority)\n\t\treturn newNode\n\t}\n\n\tif key == current.key {\n\t\treturn current\n\t}\n\n\tif key < current.key {\n\t\tcurrent.left = t.insertLoop(current.left, key, priority)\n\t\tif current.priority < current.left.priority {\n\t\t\tcurrent = t.rightRotate(current)\n\t\t}\n\t} else {\n\t\tcurrent.right = t.insertLoop(current.right, key, priority)\n\t\tif current.priority < current.right.priority {\n\t\t\tcurrent = t.leftRotate(current)\n\t\t}\n\t}\n\n\treturn current\n}\n\nfunc (t *Treap) leftRotate(x *TreapNode) *TreapNode {\n\ty := x.right\n\tx.right = y.left\n\ty.left = x\n\treturn y\n}\n\nfunc (t *Treap) rightRotate(y *TreapNode) *TreapNode {\n\tx := y.left\n\ty.left = x.right\n\tx.right = y\n\treturn x\n}\n\nfunc (t *Treap) find(key int) *TreapNode {\n\treturn t.findLoop(t.root, key)\n}\n\nfunc (t *Treap) findLoop(current *TreapNode, key int) *TreapNode {\n\tif current == nil {\n\t\treturn nil\n\t}\n\n\tif key < current.key {\n\t\treturn t.findLoop(current.left, key)\n\t} else if current.key == key {\n\t\treturn current\n\t}\n\treturn t.findLoop(current.right, key)\n}\n\nfunc (t *Treap) delete(key int) {\n\tt.root = t.deleteLoop(t.root, key)\n}\n\nfunc (t *Treap) deleteLoop(current *TreapNode, key int) *TreapNode {\n\tif current == nil {\n\t\treturn nil\n\t}\n\tif key < current.key {\n\t\tcurrent.left = t.deleteLoop(current.left, key)\n\t} else if key > current.key {\n\t\tcurrent.right = t.deleteLoop(current.right, key)\n\t} else {\n\t\treturn t.deleteNode(current, key)\n\t}\n\treturn current\n}\n\nfunc (t *Treap) deleteNode(node *TreapNode, key int) *TreapNode {\n\tif node.left == nil && node.right == nil {\n\t\treturn nil\n\t} else if node.left == nil {\n\t\tnode = t.leftRotate(node)\n\t} else if node.right == nil {\n\t\tnode = t.rightRotate(node)\n\t} else {\n\t\tif node.left.priority > node.right.priority {\n\t\t\tnode = t.rightRotate(node)\n\t\t} else {\n\t\t\tnode = t.leftRotate(node)\n\t\t}\n\t}\n\treturn t.deleteLoop(node, key)\n}\n\nfunc (t *Treap) printInorderWalk() {\n\tfmt.Println(t.printInorderWalkRoop(t.root))\n}\n\nfunc (t *Treap) printInorderWalkRoop(mid *TreapNode) string {\n\tif mid == nil {\n\t\treturn \"\"\n\t}\n\n\treturn t.printInorderWalkRoop(mid.left) + \" \" + strconv.Itoa(mid.key) + t.printInorderWalkRoop(mid.right)\n}\n\nfunc (t *Treap) printPreorderWalk() {\n\tfmt.Println(t.printPreorderWalkRoop(t.root))\n}\n\nfunc (t *Treap) printPreorderWalkRoop(mid *TreapNode) string {\n\tif mid == nil {\n\t\treturn \"\"\n\t}\n\n\treturn \" \" + strconv.Itoa(mid.key) + t.printPreorderWalkRoop(mid.left) + t.printPreorderWalkRoop(mid.right)\n}\n\nfunc main() {\n\tscanner.Split(bufio.ScanWords)\n\n\ttreap := NewTreap()\n\n\tnQueries := nextInt()\n\tfor iQuery := 0; iQuery < nQueries; iQuery++ {\n\t\tqueryType := nextString()\n\t\tif queryType == \"insert\" {\n\t\t\tkey := nextInt()\n\t\t\tpriority := nextInt()\n\t\t\ttreap.insert(key, priority)\n\t\t} else if queryType == \"find\" {\n\t\t\tkey := nextInt()\n\t\t\tif treap.find(key) != nil {\n\t\t\t\tfmt.Println(\"yes\")\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"no\")\n\t\t\t}\n\t\t} else if queryType == \"delete\" {\n\t\t\tkey := nextInt()\n\t\t\ttreap.delete(key)\n\t\t} else if queryType == \"print\" {\n\t\t\ttreap.printInorderWalk()\n\t\t\ttreap.printPreorderWalk()\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar MIN int = 0\n\nvar sc = bufio.NewScanner(os.Stdin)\n\ntype Node struct {\n\tkey, pri    int\n\tleft, rigth *Node\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\nfunc nextString() string {\n\tsc.Scan()\n\treturn sc.Text()\n\n}\n\nfunc rigthRotate(t *Node) *Node {\n\ts := t.left\n\tt.left = s.rigth\n\ts.rigth = t\n\treturn s\n}\n\nfunc leftRotate(t *Node) *Node {\n\ts := t.rigth\n\tt.rigth = s.left\n\ts.left = t\n\treturn s\n}\n\nfunc insert(t *Node, key int, pri int) *Node {\n\tif t == nil {\n\t\treturn &Node{key: key, pri: pri}\n\t}\n\tif key == t.key {\n\t\treturn t\n\t}\n\tif key < t.key {\n\n\t\tt.left = insert(t.left, key, pri)\n\t\tif t.pri < t.left.pri {\n\t\t\tt = rigthRotate(t)\n\t\t}\n\t} else {\n\t\tt.rigth = insert(t.rigth, key, pri)\n\t\tif t.pri < t.rigth.pri {\n\t\t\tt = leftRotate(t)\n\t\t}\n\n\t}\n\treturn t\n}\n\nfunc find(t *Node, key int) bool {\n\tif t == nil {\n\t\treturn false\n\t}\n\n\tif t.key == key {\n\t\treturn true\n\t}\n\n\tif t.key > key {\n\t\treturn find(t.left, key)\n\n\t} else if t.key < key {\n\t\treturn find(t.rigth, key)\n\n\t}\n\tpanic(\"error\")\n}\n\nfunc erase(t *Node, key int) *Node {\n\tif t == nil {\n\t\treturn nil\n\t}\n\tif key == t.key {\n\t\tif t.left == nil && t.rigth == nil {\n\t\t\treturn nil\n\n\t\t} else if t.left == nil {\n\t\t\tt = leftRotate(t)\n\t\t} else if t.rigth == nil {\n\t\t\tt = rigthRotate(t)\n\n\t\t} else {\n\t\t\tif t.left.pri > t.rigth.pri {\n\t\t\t\tt = rigthRotate(t)\n\n\t\t\t} else {\n\n\t\t\t\tt = leftRotate(t)\n\n\t\t\t}\n\n\t\t}\n\t\treturn erase(t, key)\n\n\t}\n\tif key < t.key {\n\t\tt.left = erase(t.left, key)\n\n\t} else {\n\t\tt.rigth = erase(t.rigth, key)\n\n\t}\n\treturn t\n}\n\nfunc printInOrder(t *Node) {\n\tif t == nil {\n\t\treturn\n\t}\n\n\tprintInOrder(t.left)\n\tfmt.Printf(\" %d\", t.key)\n\tprintInOrder(t.rigth)\n\n}\n\nfunc printPreOrder(t *Node) {\n\tif t == nil {\n\t\treturn\n\t}\n\n\tfmt.Printf(\" %d\", t.key)\n\tprintPreOrder(t.left)\n\tprintPreOrder(t.rigth)\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\n\tvar head *Node\n\n\tm := next()\n\tfor i := 0; i < m; i++ {\n\n\t\tswitch nextString() {\n\n\t\tcase \"insert\":\n\t\t\tk, p := next(), next()\n\t\t\thead = insert(head, k, p)\n\n\t\tcase \"print\":\n\t\t\tprintInOrder(head)\n\t\t\tfmt.Println()\n\t\t\tprintPreOrder(head)\n\t\t\tfmt.Println()\n\t\tcase \"find\":\n\t\t\tk := next()\n\t\t\tif find(head, k) {\n\t\t\t\tfmt.Println(\"yes\")\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"no\")\n\t\t\t}\n\t\tcase \"delete\":\n\t\t\tk := next()\n\t\t\thead = erase(head, k)\n\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n)\n\nvar MIN int = 0\n\nvar sc = bufio.NewScanner(os.Stdin)\n\ntype Node struct {\n    key, pri    int\n    left, rigth *Node\n}\n\nfunc next() int {\n    sc.Scan()\n    i, _ := strconv.Atoi(sc.Text())\n    return i\n\n}\n\nfunc nextString() string {\n    sc.Scan()\n    return sc.Text()\n\n}\n\nfunc rightRotate(t *Node) *Node {\n    s := t.left\n    t.left = s.rigth\n    s.rigth = t\n    return s\n}\n\nfunc leftRotate(t *Node) *Node {\n    s := t.rigth\n    t.rigth = s.left\n    s.left = t\n    return s\n}\n\nfunc insert(t *Node, key int, pri int) *Node {\n    if t == nil {\n        return &Node{key: key, pri: pri}\n    }\n    if key == t.key {\n        return t\n    }\n    if key < t.key {\n\n        t.left = insert(t.left, key, pri)\n        if t.pri < t.left.pri {\n            t = rightRotate(t)\n        }\n    } else {\n        t.rigth = insert(t.rigth, key, pri)\n        if t.pri < t.rigth.pri {\n            t = leftRotate(t)\n        }\n\n    }\n    return t\n}\n\nfunc find(t *Node, key int) bool {\n    if t == nil {\n        return false\n    }\n\n    if t.key == key {\n        return true\n    }\n\n    if t.key > key {\n        return find(t.left, key)\n\n    } else if t.key < key {\n        return find(t.rigth, key)\n\n    }\n    panic(\"error\")\n}\n\nfunc erase(t *Node, key int) *Node {\n    if t == nil {\n        return nil\n    }\n    if key == t.key {\n        if t.left == nil && t.rigth == nil {\n            return nil\n\n        } else if t.left == nil {\n            t = leftRotate(t)\n        } else if t.rigth == nil {\n            t = rightRotate(t)\n\n        } else {\n            if t.left.pri > t.rigth.pri {\n                t = rightRotate(t)\n\n            } else {\n\n                t = leftRotate(t)\n\n            }\n\n        }\n        return erase(t, key)\n\n    }\n    if key < t.key {\n        t.left = erase(t.left, key)\n\n    } else {\n        t.rigth = erase(t.rigth, key)\n\n    }\n    return t\n}\n\nfunc printInOrder(t *Node) {\n    if t == nil {\n        return\n    }\n\n    printInOrder(t.left)\n    fmt.Printf(\" %d\", t.key)\n    printInOrder(t.rigth)\n\n}\n\nfunc printPreOrder(t *Node) {\n    if t == nil {\n        return\n    }\n\n    fmt.Printf(\" %d\", t.key)\n    printPreOrder(t.left)\n    printPreOrder(t.rigth)\n\n}\n\nfunc main() {\n    sc.Split(bufio.ScanWords)\n\n    var head *Node\n\n    m := next()\n    for i := 0; i < m; i++ {\n\n        switch nextString() {\n\n        case \"insert\":\n            k, p := next(), next()\n            head = insert(head, k, p)\n\n        case \"print\":\n            printInOrder(head)\n            fmt.Println()\n            printPreOrder(head)\n            fmt.Println()\n        case \"find\":\n            k := next()\n            if find(head, k) {\n                fmt.Println(\"yes\")\n            } else {\n                fmt.Println(\"no\")\n            }\n        case \"delete\":\n            k := next()\n            head = erase(head, k)\n\n        }\n\n    }\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\n/*********** I/O ***********/\n\nvar (\n\t// ReadString returns a WORD string.\n\tReadString func() string\n\tstdout     *bufio.Writer\n)\n\nfunc init() {\n\tReadString = newReadString(os.Stdin)\n\tstdout = bufio.NewWriter(os.Stdout)\n}\n\nfunc newReadString(ior io.Reader) func() string {\n\tr := bufio.NewScanner(ior)\n\tr.Buffer(make([]byte, 1024), int(1e+11))\n\t// Split sets the split function for the Scanner. The default split function is ScanLines.\n\t// Split panics if it is called after scanning has started.\n\tr.Split(bufio.ScanWords)\n\n\treturn func() string {\n\t\tif !r.Scan() {\n\t\t\tpanic(\"Scan failed\")\n\t\t}\n\t\treturn r.Text()\n\t}\n}\n\n// ReadInt returns an integer.\nfunc ReadInt() int {\n\treturn int(readInt64())\n}\nfunc ReadInt2() (int, int) {\n\treturn int(readInt64()), int(readInt64())\n}\nfunc ReadInt3() (int, int, int) {\n\treturn int(readInt64()), int(readInt64()), int(readInt64())\n}\nfunc ReadInt4() (int, int, int, int) {\n\treturn int(readInt64()), int(readInt64()), int(readInt64()), int(readInt64())\n}\n\nfunc readInt64() int64 {\n\ti, err := strconv.ParseInt(ReadString(), 0, 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn i\n}\n\n// ReadIntSlice returns an integer slice that has n integers.\nfunc ReadIntSlice(n int) []int {\n\tb := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadInt()\n\t}\n\treturn b\n}\n\n// ReadFloat64 returns an float64.\nfunc ReadFloat64() float64 {\n\treturn float64(readFloat64())\n}\n\nfunc readFloat64() float64 {\n\tf, err := strconv.ParseFloat(ReadString(), 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn f\n}\n\n// ReadFloatSlice returns an float64 slice that has n float64.\nfunc ReadFloat64Slice(n int) []float64 {\n\tb := make([]float64, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadFloat64()\n\t}\n\treturn b\n}\n\n// ReadRuneSlice returns a rune slice.\nfunc ReadRuneSlice() []rune {\n\treturn []rune(ReadString())\n}\n\n/*********** Debugging ***********/\n\n// ZeroPaddingRuneSlice returns binary expressions of integer n with zero padding.\n// For debugging use.\nfunc ZeroPaddingRuneSlice(n, digitsNum int) []rune {\n\tsn := fmt.Sprintf(\"%b\", n)\n\n\tresidualLength := digitsNum - len(sn)\n\tif residualLength <= 0 {\n\t\treturn []rune(sn)\n\t}\n\n\tzeros := make([]rune, residualLength)\n\tfor i := 0; i < len(zeros); i++ {\n\t\tzeros[i] = '0'\n\t}\n\n\tres := []rune{}\n\tres = append(res, zeros...)\n\tres = append(res, []rune(sn)...)\n\n\treturn res\n}\n\n/*********** DP sub-functions ***********/\n\n// ChMin accepts a pointer of integer and a target value.\n// If target value is SMALLER than the first argument,\n//\tthen the first argument will be updated by the second argument.\nfunc ChMin(updatedValue *int, target int) bool {\n\tif *updatedValue > target {\n\t\t*updatedValue = target\n\t\treturn true\n\t}\n\treturn false\n}\n\n// ChMax accepts a pointer of integer and a target value.\n// If target value is LARGER than the first argument,\n//\tthen the first argument will be updated by the second argument.\nfunc ChMax(updatedValue *int, target int) bool {\n\tif *updatedValue < target {\n\t\t*updatedValue = target\n\t\treturn true\n\t}\n\treturn false\n}\n\n// NthBit returns nth bit value of an argument.\n// n starts from 0.\nfunc NthBit(num, nth int) int {\n\treturn num >> uint(nth) & 1\n}\n\n// OnBit returns the integer that has nth ON bit.\n// If an argument has nth ON bit, OnBit returns the argument.\nfunc OnBit(num, nth int) int {\n\treturn num | (1 << uint(nth))\n}\n\n// OffBit returns the integer that has nth OFF bit.\n// If an argument has nth OFF bit, OffBit returns the argument.\nfunc OffBit(num, nth int) int {\n\treturn num & ^(1 << uint(nth))\n}\n\n// PopCount returns the number of ON bit of an argument.\nfunc PopCount(num int) int {\n\tres := 0\n\n\tfor i := 0; i < 70; i++ {\n\t\tif ((num >> uint(i)) & 1) == 1 {\n\t\t\tres++\n\t\t}\n\t}\n\n\treturn res\n}\n\n/*********** Arithmetic ***********/\n\n// Max returns the max integer among input set.\n// This function needs at least 1 argument (no argument causes panic).\nfunc Max(integers ...int) int {\n\tm := integers[0]\n\tfor i, integer := range integers {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif m < integer {\n\t\t\tm = integer\n\t\t}\n\t}\n\treturn m\n}\n\n// Min returns the min integer among input set.\n// This function needs at least 1 argument (no argument causes panic).\nfunc Min(integers ...int) int {\n\tm := integers[0]\n\tfor i, integer := range integers {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif m > integer {\n\t\t\tm = integer\n\t\t}\n\t}\n\treturn m\n}\n\n// DigitSum returns digit sum of a decimal number.\n// DigitSum only accept a positive integer.\nfunc DigitSum(n int) int {\n\tif n < 0 {\n\t\treturn -1\n\t}\n\n\tres := 0\n\n\tfor n > 0 {\n\t\tres += n % 10\n\t\tn /= 10\n\t}\n\n\treturn res\n}\n\n// DigitNumOfDecimal returns digits number of n.\n// n is non negative number.\nfunc DigitNumOfDecimal(n int) int {\n\tres := 0\n\n\tfor n > 0 {\n\t\tn /= 10\n\t\tres++\n\t}\n\n\treturn res\n}\n\n// Sum returns multiple integers sum.\nfunc Sum(integers ...int) int {\n\ts := 0\n\n\tfor _, i := range integers {\n\t\ts += i\n\t}\n\n\treturn s\n}\n\n// Kiriage returns Ceil(a/b)\n// a >= 0, b > 0\nfunc Kiriage(a, b int) int {\n\treturn (a + (b - 1)) / b\n}\n\n// PowInt is integer version of math.Pow\n// PowInt calculate a power by Binary Power (二分累乗法(O(log e))).\nfunc PowInt(a, e int) int {\n\tif a < 0 || e < 0 {\n\t\tpanic(errors.New(\"[argument error]: PowInt does not accept negative integers\"))\n\t}\n\n\tif e == 0 {\n\t\treturn 1\n\t}\n\n\tif e%2 == 0 {\n\t\thalfE := e / 2\n\t\thalf := PowInt(a, halfE)\n\t\treturn half * half\n\t}\n\n\treturn a * PowInt(a, e-1)\n}\n\n// AbsInt is integer version of math.Abs\nfunc AbsInt(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\n// Gcd returns the Greatest Common Divisor of two natural numbers.\n// Gcd only accepts two natural numbers (a, b >= 1).\n// 0 or negative number causes panic.\n// Gcd uses the Euclidean Algorithm.\nfunc Gcd(a, b int) int {\n\tif a <= 0 || b <= 0 {\n\t\tpanic(errors.New(\"[argument error]: Gcd only accepts two NATURAL numbers\"))\n\t}\n\tif a < b {\n\t\ta, b = b, a\n\t}\n\n\t// Euclidean Algorithm\n\tfor b > 0 {\n\t\tdiv := a % b\n\t\ta, b = b, div\n\t}\n\n\treturn a\n}\n\n// Lcm returns the Least Common Multiple of two natural numbers.\n// Lcd only accepts two natural numbers (a, b >= 1).\n// 0 or negative number causes panic.\n// Lcd uses the Euclidean Algorithm indirectly.\nfunc Lcm(a, b int) int {\n\tif a <= 0 || b <= 0 {\n\t\tpanic(errors.New(\"[argument error]: Gcd only accepts two NATURAL numbers\"))\n\t}\n\n\t// a = a'*gcd, b = b'*gcd, a*b = a'*b'*gcd^2\n\t// a' and b' are relatively prime numbers\n\t// gcd consists of prime numbers, that are included in a and b\n\tgcd := Gcd(a, b)\n\n\t// not (a * b / gcd), because of reducing a probability of overflow\n\treturn (a / gcd) * b\n}\n\n// Strtoi is a wrapper of `strconv.Atoi()`.\n// If `strconv.Atoi()` returns an error, Strtoi calls panic.\nfunc Strtoi(s string) int {\n\tif i, err := strconv.Atoi(s); err != nil {\n\t\tpanic(errors.New(\"[argument error]: Strtoi only accepts integer string\"))\n\t} else {\n\t\treturn i\n\t}\n}\n\n// PrintIntsLine returns integers string delimited by a space.\nfunc PrintIntsLine(A ...int) string {\n\tres := []rune{}\n\n\tfor i := 0; i < len(A); i++ {\n\t\tstr := strconv.Itoa(A[i])\n\t\tres = append(res, []rune(str)...)\n\n\t\tif i != len(A)-1 {\n\t\t\tres = append(res, ' ')\n\t\t}\n\t}\n\n\treturn string(res)\n}\n\n/********** I/O usage **********/\n\n//str := ReadString()\n//i := ReadInt()\n//X := ReadIntSlice(n)\n//S := ReadRuneSlice()\n//a := ReadFloat64()\n//A := ReadFloat64Slice(n)\n\n//str := ZeroPaddingRuneSlice(num, 32)\n//str := PrintIntsLine(X...)\n\n/*******************************************************************/\n\nconst MOD = 1000000000 + 7\nconst ALPHABET_NUM = 26\nconst INF_INT64 = math.MaxInt64\nconst INF_BIT60 = 1 << 60\n\n// https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/all/ALDS1_8_D\n/*\ninput:\n\n16\ninsert 35 99\ninsert 3 80\ninsert 1 53\ninsert 14 25\ninsert 80 76\ninsert 42 3\ninsert 86 47\ninsert 21 12\ninsert 7 10\ninsert 6 90\nprint\nfind 21\nfind 22\ndelete 35\ndelete 99\nprint\n*/\nfunc main() {\n\tn := ReadInt()\n\n\ttr := NewTreap()\n\tfor i := 0; i < n; i++ {\n\t\ts := ReadString()\n\t\tif s == \"insert\" {\n\t\t\tk, p := ReadInt2()\n\t\t\ttr.InsertBySettingPri(k, p)\n\t\t} else if s == \"print\" {\n\t\t\tfmt.Printf(\" \")\n\t\t\tfmt.Println(PrintIntsLine(tr.Inorder()...))\n\t\t\tfmt.Printf(\" \")\n\t\t\tfmt.Println(PrintIntsLine(tr.Preorder()...))\n\t\t} else if s == \"find\" {\n\t\t\tk := ReadInt()\n\t\t\tn := tr.Find(k)\n\t\t\tif n != nil {\n\t\t\t\tfmt.Println(\"yes\")\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"no\")\n\t\t\t}\n\t\t} else if s == \"delete\" {\n\t\t\tk := ReadInt()\n\t\t\ttr.Delete(k)\n\t\t}\n\t}\n\n\t// fmt.Println(\"Verification of tr.BiggerLowerBound\")\n\t// for _, x := range tr.Inorder() {\n\t// \tnode := tr.BiggerLowerBound(x)\n\t// \tif node != nil {\n\t// \t\tfmt.Printf(\"x: %d, blbx: %d\\n\", x, node.key)\n\t// \t} else {\n\t// \t\tfmt.Printf(\"x: %d, blbx: nil\\n\", x)\n\t// \t}\n\t// }\n\t// fmt.Println(\"Verification of tr.BiggerUpperBound\")\n\t// for _, x := range tr.Inorder() {\n\t// \tnode := tr.BiggerUpperBound(x)\n\t// \tif node != nil {\n\t// \t\tfmt.Printf(\"x: %d, bubx: %d\\n\", x, node.key)\n\t// \t} else {\n\t// \t\tfmt.Printf(\"x: %d, bubx: nil\\n\", x)\n\t// \t}\n\t// }\n\t// fmt.Println(\"Verification of tr.SmallerUpperBound\")\n\t// for _, x := range tr.Inorder() {\n\t// \tnode := tr.SmallerUpperBound(x)\n\t// \tif node != nil {\n\t// \t\tfmt.Printf(\"x: %d, subx: %d\\n\", x, node.key)\n\t// \t} else {\n\t// \t\tfmt.Printf(\"x: %d, subx: nil\\n\", x)\n\t// \t}\n\t// }\n\t// fmt.Println(\"Verification of tr.SmallerLowerBound\")\n\t// for _, x := range tr.Inorder() {\n\t// \tnode := tr.SmallerLowerBound(x)\n\t// \tif node != nil {\n\t// \t\tfmt.Printf(\"x: %d, slbx: %d\\n\", x, node.key)\n\t// \t} else {\n\t// \t\tfmt.Printf(\"x: %d, slbx: nil\\n\", x)\n\t// \t}\n\t// }\n\n\t// fmt.Println(\"Verification of tr.FindMinimum, tr.FindMaximum\")\n\t// fmt.Printf(\"Min: %d\\n\", tr.FindMinimum().key)\n\t// fmt.Printf(\"Max: %d\\n\", tr.FindMaximum().key)\n}\n\n// Treap usage\n// tr := NewTreap()\n// tr.Insert(k)\n// node := tr.Find(k)\n// min := tr.FindMinimum()\n// max := tr.FindMaximum()\n// tr.Delete(k)\n// node := tr.BigggerLowerBound(x)\n// node := tr.BiggerUpperBound(x)\n// node := tr.SmallerUpperBound(x)\n// node := tr.SmallerLowerBound(x)\n// fmt.Println(PrintIntsLine(tr.Inorder()...))\n// fmt.Println(PrintIntsLine(tr.Preorder()...))\n// tr.InsertBySettingPri(k, p)\n\ntype Node struct {\n\tkey, priority int\n\tright, left   *Node\n}\n\ntype Treap struct {\n\troot *Node\n}\n\n/*************************************/\n// Public method\n/*************************************/\n\n// NewTreap returns a pointer of a Treap instance.\nfunc NewTreap() *Treap {\n\ttr := new(Treap)\n\ttr.root = nil\n\treturn tr\n}\n\n// InsertBySettingPri method inserts a new node consisting of new key and priority.\n// A duplicate key is ignored and nothing happens.\nfunc (tr *Treap) InsertBySettingPri(key, priority int) {\n\ttr.root = tr.insert(tr.root, key, priority)\n}\n\n// for XorShift\nvar _gtx, _gty, _gtz, _gtw = 123456789, 362436069, 521288629, 88675123\n\n// Insert method inserts a new node consisting o new key.\n// The priority is automatically set by random value.\n// A duplicate key is ignored and nothing happens.\nfunc (tr *Treap) Insert(key int) {\n\t// XorShiftによる乱数生成\n\t// 下記URLを参考\n\t// https://qiita.com/tubo28/items/f058582e457f6870a800#lower_bound-upper_bound\n\trandInt := func() int {\n\t\ttt := (_gtx ^ (_gtx << 11))\n\t\t_gtx = _gty\n\t\t_gty = _gtz\n\t\t_gtz = _gtw\n\t\t_gtw = (_gtw ^ (_gtw >> 19)) ^ (tt ^ (tt >> 8))\n\t\treturn _gtw\n\t}\n\n\ttr.root = tr.insert(tr.root, key, randInt())\n}\n\n// Find returns a node that has an argument key value.\n// Find returns nil when there is no node that has an argument key value.\nfunc (tr *Treap) Find(k int) *Node {\n\tu := tr.root\n\tfor u != nil && k != u.key {\n\t\tif k < u.key {\n\t\t\tu = u.left\n\t\t} else {\n\t\t\tu = u.right\n\t\t}\n\t}\n\treturn u\n}\n\n// FindMinimum returns a node that has the minimum key in the treap.\n// FindMinimum returns nil when there is no nodes.\nfunc (tr *Treap) FindMinimum() *Node {\n\tu := tr.root\n\tfor u != nil && u.left != nil {\n\t\tu = u.left\n\t}\n\treturn u\n}\n\n// FindMaximum returns a node that has the maximum key in the treap.\n// FindMaximum returns nil when there is no nodes.\nfunc (tr *Treap) FindMaximum() *Node {\n\tu := tr.root\n\tfor u != nil && u.right != nil {\n\t\tu = u.right\n\t}\n\treturn u\n}\n\n// Delete method deletes a node that has an argument key value.\n// A duplicate key is ignored and nothing happens.\nfunc (tr *Treap) Delete(key int) {\n\ttr.root = tr.delete(tr.root, key)\n}\n\n// Inorder returns a slice consisting of treap nodes in order of INORDER.\n// The nodes are sorted by key values.\nfunc (tr *Treap) Inorder() []int {\n\tres := make([]int, 0, 200000+5)\n\ttr.inorder(tr.root, &res)\n\treturn res\n}\n\n// Preorder returns a slice consisting of treap nodes in order of PREORDER.\nfunc (tr *Treap) Preorder() []int {\n\tres := make([]int, 0, 200000+5)\n\ttr.preorder(tr.root, &res)\n\treturn res\n}\n\n// BiggerLowerBound returns a node that has MINIMUM KEY MEETING key >= x.\n// https://qiita.com/tubo28/items/f058582e457f6870a800#lower_bound-upper_bound\nfunc (tr *Treap) BiggerLowerBound(x int) *Node {\n\treturn tr.biggerLowerBound(tr.root, x)\n}\n\n// BiggerUpperBound returns a node that has MINIMUM KEY MEETING key > x.\n// https://qiita.com/tubo28/items/f058582e457f6870a800#lower_bound-upper_bound\nfunc (tr *Treap) BiggerUpperBound(x int) *Node {\n\treturn tr.biggerUpperBound(tr.root, x)\n}\n\n// SmallerUpperBound returns a node that has MAXIMUM KEY MEETING key <= x.\n// for AGC005-B\nfunc (tr *Treap) SmallerUpperBound(x int) *Node {\n\treturn tr.smallerUpperBound(tr.root, x)\n}\n\n// SmallerLowerBound returns a node that has MAXIMUM KEY MEETING key < x.\n// for AGC005-B\nfunc (tr *Treap) SmallerLowerBound(x int) *Node {\n\treturn tr.smallerLowerBound(tr.root, x)\n}\n\n/*************************************/\n// Private method\n/*************************************/\n\nfunc (tr *Treap) insert(t *Node, key, priority int) *Node {\n\t// 葉に到達したら新しい節点を生成して返す\n\tif t == nil {\n\t\tnode := new(Node)\n\t\tnode.key, node.priority = key, priority\n\t\treturn node\n\t}\n\n\t// 重複したkeyは無視\n\tif key == t.key {\n\t\treturn t\n\t}\n\n\tif key < t.key {\n\t\t// 左の子へ移動\n\t\tt.left = tr.insert(t.left, key, priority) // 左の子へのポインタを更新\n\t\t// 左の子の方が優先度が高い場合右回転\n\t\tif t.priority < t.left.priority {\n\t\t\tt = tr.rightRotate(t)\n\t\t}\n\t} else {\n\t\t// 右の子へ移動\n\t\tt.right = tr.insert(t.right, key, priority) // 右の子へのポインタを更新\n\t\tif t.priority < t.right.priority {\n\t\t\t// 右の子の方が優先度が高い場合左回転\n\t\t\tt = tr.leftRotate(t)\n\t\t}\n\t}\n\n\treturn t\n}\n\n// 削除対象の節点を回転によって葉まで移動させた後に削除する\nfunc (tr *Treap) delete(t *Node, key int) *Node {\n\tif t == nil {\n\t\treturn nil\n\t}\n\n\t// 削除対象を検索\n\tif key < t.key {\n\t\tt.left = tr.delete(t.left, key)\n\t} else if key > t.key {\n\t\tt.right = tr.delete(t.right, key)\n\t} else {\n\t\t// 削除対象を発見、葉ノードとなるように回転を繰り返す\n\t\treturn tr._delete(t, key)\n\t}\n\n\treturn t\n}\n\n// 削除対象の節点の場合\nfunc (tr *Treap) _delete(t *Node, key int) *Node {\n\tif t.left == nil && t.right == nil {\n\t\t// 葉の場合\n\t\treturn nil\n\t} else if t.left == nil {\n\t\t// 右の子のみを持つ場合は左回転\n\t\tt = tr.leftRotate(t)\n\t} else if t.right == nil {\n\t\t// 左の子のみを持つ場合は右回転\n\t\tt = tr.rightRotate(t)\n\t} else {\n\t\t// 優先度が高い方を持ち上げる\n\t\tif t.left.priority > t.right.priority {\n\t\t\tt = tr.rightRotate(t)\n\t\t} else {\n\t\t\tt = tr.leftRotate(t)\n\t\t}\n\t}\n\n\treturn tr.delete(t, key)\n}\n\nfunc (tr *Treap) rightRotate(t *Node) *Node {\n\ts := t.left\n\tt.left = s.right\n\ts.right = t\n\treturn s\n}\n\nfunc (tr *Treap) leftRotate(t *Node) *Node {\n\ts := t.right\n\tt.right = s.left\n\ts.left = t\n\treturn s\n}\n\n// rootからスタートする\nfunc (tr *Treap) biggerLowerBound(t *Node, x int) *Node {\n\tif t == nil {\n\t\treturn nil\n\t} else if t.key >= x {\n\t\t// 探索キーxが現在のノードキー以下の場合、左を探索する\n\t\tnode := tr.biggerLowerBound(t.left, x)\n\t\tif node != nil {\n\t\t\treturn node\n\t\t} else {\n\t\t\treturn t\n\t\t}\n\t} else {\n\t\t// 探索キーxが現在のノードキーより大きい場合、右を探索する\n\t\treturn tr.biggerLowerBound(t.right, x)\n\t}\n}\n\n// rootからスタートする\nfunc (tr *Treap) biggerUpperBound(t *Node, x int) *Node {\n\tif t == nil {\n\t\treturn nil\n\t} else if t.key > x {\n\t\t// 探索キーxが現在のノードキーより小さい場合、左を探索する\n\t\tnode := tr.biggerUpperBound(t.left, x)\n\t\tif node != nil {\n\t\t\treturn node\n\t\t} else {\n\t\t\treturn t\n\t\t}\n\t} else {\n\t\t// 探索キーxが現在のノードキー以上の場合、右を探索する\n\t\treturn tr.biggerUpperBound(t.right, x)\n\t}\n}\n\n// rootからスタートする\nfunc (tr *Treap) smallerUpperBound(t *Node, x int) *Node {\n\tif t == nil {\n\t\treturn nil\n\t} else if t.key <= x {\n\t\tnode := tr.smallerUpperBound(t.right, x)\n\t\tif node != nil {\n\t\t\treturn node\n\t\t} else {\n\t\t\treturn t\n\t\t}\n\t} else {\n\t\treturn tr.smallerUpperBound(t.left, x)\n\t}\n}\n\n// rootからスタートする\nfunc (tr *Treap) smallerLowerBound(t *Node, x int) *Node {\n\tif t == nil {\n\t\treturn nil\n\t} else if t.key < x {\n\t\tnode := tr.smallerLowerBound(t.right, x)\n\t\tif node != nil {\n\t\t\treturn node\n\t\t} else {\n\t\t\treturn t\n\t\t}\n\t} else {\n\t\treturn tr.smallerLowerBound(t.left, x)\n\t}\n}\n\nfunc (tr *Treap) inorder(u *Node, res *[]int) {\n\tif u == nil {\n\t\treturn\n\t}\n\ttr.inorder(u.left, res)\n\t*res = append(*res, u.key)\n\ttr.inorder(u.right, res)\n}\n\nfunc (tr *Treap) preorder(u *Node, res *[]int) {\n\tif u == nil {\n\t\treturn\n\t}\n\t*res = append(*res, u.key)\n\ttr.preorder(u.left, res)\n\ttr.preorder(u.right, res)\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\n/*\nTreap\n*/\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\n// Node ノード\ntype Node struct {\n\tkey         int\n\tpri         int\n\tleft, right *Node\n}\n\nfunc (n *Node) String() string {\n\t//デバッグ用\n\tvar left, right string\n\tif n.left == nil {\n\t\tleft = \"nil\"\n\t} else {\n\t\tleft = fmt.Sprintf(\"%d\", n.left.key)\n\t}\n\tif n.right == nil {\n\t\tright = \"nil\"\n\t} else {\n\t\tright = fmt.Sprintf(\"%d\", n.right.key)\n\t}\n\treturn fmt.Sprintf(\"[key:%d pri:%d left:%s right:%s]\", n.key, n.pri, left, right)\n}\n\nfunc rightRotate(t *Node) *Node {\n\ts := t.left\n\tt.left = s.right\n\ts.right = t\n\treturn s\n}\nfunc leftRotate(t *Node) *Node {\n\ts := t.right\n\tt.right = s.left\n\ts.left = t\n\treturn s\n}\n\nfunc printNode(t *Node) {\n\tif t != nil {\n\t\tfmt.Println(t)\n\t\tprintNode(t.left)\n\t\tprintNode(t.right)\n\t}\n}\n\nfunc insert(t *Node, key, pri int) *Node {\n\tif t == nil {\n\t\treturn &Node{key: key, pri: pri, left: nil, right: nil}\n\t}\n\tif key == t.key {\n\t\t// 無視する\n\t\treturn t\n\t}\n\tif key < t.key {\n\t\t// 左に移動\n\t\tt.left = insert(t.left, key, pri)\n\t\tif t.pri < t.left.pri {\n\t\t\tt = rightRotate(t)\n\t\t}\n\t} else {\n\t\t// 右に移動\n\t\tt.right = insert(t.right, key, pri)\n\t\tif t.pri < t.right.pri {\n\t\t\tt = leftRotate(t)\n\t\t}\n\t}\n\treturn t\n}\nfunc delete(t *Node, key int) *Node {\n\tif t == nil {\n\t\treturn nil\n\t}\n\tif key < t.key {\n\t\t// 左に移動\n\t\tt.left = delete(t.left, key)\n\t\treturn t\n\t}\n\tif key > t.key {\n\t\t// 右に移動\n\t\tt.right = delete(t.right, key)\n\t\treturn t\n\t}\n\t//  key == t.key\n\tif t.left == nil && t.right == nil {\n\t\treturn nil\n\t}\n\tif t.right == nil {\n\t\tt = rightRotate(t)\n\t} else if t.left == nil {\n\t\tt = leftRotate(t)\n\t} else { // どちらも子がいる．\n\t\tif t.left.pri > t.right.pri {\n\t\t\tt = rightRotate(t)\n\t\t} else {\n\t\t\tt = leftRotate(t)\n\t\t}\n\t}\n\treturn delete(t, key)\n}\nfunc findKey(t *Node, key int) bool {\n\tif t == nil {\n\t\treturn false\n\t}\n\tif key < t.key {\n\t\t// 左に移動\n\t\treturn findKey(t.left, key)\n\t}\n\tif key > t.key {\n\t\t// 右に移動\n\t\treturn findKey(t.right, key)\n\t}\n\treturn true\n}\n\nfunc inOrder(t *Node, result *bytes.Buffer) {\n\tif t == nil {\n\t\treturn\n\t}\n\tinOrder(t.left, result)\n\tresult.WriteString(fmt.Sprint(\" \", t.key))\n\tinOrder(t.right, result)\n\treturn\n}\nfunc preOrder(t *Node, result *bytes.Buffer) {\n\tif t == nil {\n\t\treturn\n\t}\n\tresult.WriteString(fmt.Sprint(\" \", t.key))\n\tpreOrder(t.left, result)\n\tpreOrder(t.right, result)\n\treturn\n}\nfunc printInOrder(t *Node) {\n\tvar buf bytes.Buffer\n\tinOrder(t, &buf)\n\n\tfmt.Println(buf.String())\n}\nfunc printPreOrder(t *Node) {\n\tvar buf bytes.Buffer\n\tpreOrder(t, &buf)\n\n\tfmt.Println(buf.String())\n}\n\nfunc main() {\n\tscanner := makeScanner(8192)\n\tn := eGetInt(scanner)\n\tvar root *Node\n\tfor i := 0; i < n; i++ {\n\t\tinfo := eGetFields(scanner)\n\t\tcmd := info[0]\n\t\tswitch cmd {\n\t\tcase \"insert\":\n\t\t\tk, p := eAtoi(info[1]), eAtoi(info[2])\n\t\t\troot = insert(root, k, p)\n\t\tcase \"print\":\n\t\t\tprintInOrder(root)\n\t\t\tprintPreOrder(root)\n\t\tcase \"delete\":\n\t\t\tk := eAtoi(info[1])\n\t\t\troot = delete(root, k)\n\t\tcase \"find\":\n\t\t\tk := eAtoi(info[1])\n\t\t\tif findKey(root, k) {\n\t\t\t\tfmt.Println(\"yes\")\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"no\")\n\t\t\t}\n\t\t}\n\t}\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// ライブラリ\n////////////////////////////////////////////////////////////////////////////////\nfunc makeScanner(maxByte int) *bufio.Scanner {\n\tscanner := bufio.NewScanner(os.Stdin)\n\tscanner.Buffer(make([]uint8, 0, 8192), maxByte)\n\treturn scanner\n}\nfunc eGetLine(r *bufio.Scanner) string {\n\tif r.Scan() {\n\t\treturn r.Text()\n\t}\n\terr := r.Err()\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\t// EOF\n\treturn \"\"\n}\nfunc eGetInt(r *bufio.Scanner) int {\n\tline := eGetLine(r)\n\treturn eAtoi(line)\n}\nfunc eGetFields(r *bufio.Scanner) []string {\n\tline := eGetLine(r)\n\treturn strings.Fields(line)\n}\nfunc eGetInts(r *bufio.Scanner) []int {\n\tfields := eGetFields(r)\n\tints := make([]int, len(fields))\n\tfor i := 0; i < len(ints); i++ {\n\t\tints[i] = eAtoi(fields[i])\n\t}\n\treturn ints\n}\nfunc eGetChars(r *bufio.Scanner) []string {\n\tline := eGetLine(r)\n\treturn strings.Split(line, \"\")\n}\nfunc eAtoi(s string) int {\n\tn, err := strconv.Atoi(s)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\treturn n\n}\n\ntype ints []int\n\nfunc (s ints) String() string {\n\tvar buf bytes.Buffer\n\tbuf.WriteString(\"[\")\n\tsep := \"\"\n\tfor _, v := range s {\n\t\tbuf.WriteString(fmt.Sprintf(\"%s%d\", sep, v))\n\t\tsep = \", \"\n\t}\n\tbuf.WriteString(\"]\")\n\treturn buf.String()\n}\n\nfunc reverse(a ints) ints {\n\tr := make(ints, len(a))\n\tfor i := 0; i < len(a); i++ {\n\t\tr[i] = a[len(a)-1-i]\n\t}\n\treturn r\n}\nfunc max(a ints) (int, bool) {\n\tif len(a) == 0 {\n\t\treturn 0, false\n\t}\n\tm := a[0]\n\tfor _, e := range a {\n\t\tif e > m {\n\t\t\tm = e\n\t\t}\n\t}\n\treturn m, true\n}\nfunc min(a []int) int {\n\tm := a[0]\n\tfor _, v := range a {\n\t\tif v < m {\n\t\t\tm = v\n\t\t}\n\t}\n\treturn m\n}\n\nfunc sum(a ints) int {\n\tif len(a) == 0 {\n\t\treturn 0\n\t}\n\tsum := 0\n\tfor _, e := range a {\n\t\tsum += e\n\t}\n\treturn sum\n}\nfunc find(n int, a ints) int {\n\tfor i, v := range a {\n\t\tif n == v {\n\t\t\treturn i\n\t\t}\n\t}\n\treturn -1\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar MIN int = 0\n\nvar sc = bufio.NewScanner(os.Stdin)\n\ntype Node struct {\n\tkey, pri    int\n\tleft, rigth *Node\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\nfunc nextString() string {\n\tsc.Scan()\n\treturn sc.Text()\n\n}\n\nfunc rigthRotate(t *Node) *Node {\n\ts := t.left\n\tt.left = s.rigth\n\ts.rigth = t\n\treturn s\n}\n\nfunc leftRotate(t *Node) *Node {\n\ts := t.rigth\n\tt.rigth = s.left\n\ts.left = t\n\treturn s\n}\n\nfunc insert(t *Node, key int, pri int) *Node {\n\tif t == nil {\n\t\treturn &Node{key: key, pri: pri}\n\t}\n\tif key == t.key {\n\t\treturn t\n\t}\n\tif key < t.key {\n\n\t\tt.left = insert(t.left, key, pri)\n\t\tif t.pri < t.left.pri {\n\t\t\tt = rigthRotate(t)\n\t\t}\n\t} else {\n\t\tt.rigth = insert(t.rigth, key, pri)\n\t\tif t.pri < t.rigth.pri {\n\t\t\tt = leftRotate(t)\n\t\t}\n\n\t}\n\treturn t\n}\n\nfunc find(t *Node, key int) bool {\n\tif t == nil {\n\t\treturn false\n\t}\n\n\tif t.key == key {\n\t\treturn true\n\t}\n\n\tif t.key > key {\n\t\treturn find(t.left, key)\n\n\t} else if t.key < key {\n\t\treturn find(t.rigth, key)\n\n\t}\n\tpanic(\"error\")\n}\n\nfunc erase(t *Node, key int) *Node {\n\tif t == nil {\n\t\treturn nil\n\t}\n\tif key == t.key {\n\t\tif t.left == nil && t.rigth == nil {\n\t\t\treturn nil\n\n\t\t} else if t.left == nil {\n\t\t\tt = leftRotate(t)\n\t\t} else if t.rigth == nil {\n\t\t\tt = rigthRotate(t)\n\n\t\t} else {\n\t\t\tif t.left.pri > t.rigth.pri {\n\t\t\t\tt = rigthRotate(t)\n\n\t\t\t} else {\n\n\t\t\t\tt = leftRotate(t)\n\n\t\t\t}\n\n\t\t}\n\t\treturn erase(t, key)\n\n\t}\n\tif key < t.key {\n\t\tt.left = erase(t.left, key)\n\n\t} else {\n\t\tt.rigth = erase(t.rigth, key)\n\n\t}\n\treturn t\n}\n\nfunc printInOrder(t *Node) {\n\tif t == nil {\n\t\treturn\n\t}\n\n\tprintInOrder(t.left)\n\tfmt.Printf(\" %d\", t.key)\n\tprintInOrder(t.rigth)\n\n}\n\nfunc printPreOrder(t *Node) {\n\tif t == nil {\n\t\treturn\n\t}\n\n\tfmt.Printf(\" %d\", t.key)\n\tprintPreOrder(t.left)\n\tprintPreOrder(t.rigth)\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\n\tvar head *Node\n\n\tm := next()\n\tfor i := 0; i < m; i++ {\n\n\t\tswitch nextString() {\n\n\t\tcase \"insert\":\n\t\t\tk, p := next(), next()\n\t\t\thead = insert(head, k, p)\n\n\t\tcase \"print\":\n\t\t\tprintInOrder(head)\n\t\t\tfmt.Println()\n\t\t\tprintPreOrder(head)\n\t\t\tfmt.Println()\n\t\tcase \"find\":\n\t\t\tk := next()\n\t\t\tif find(head, k) {\n\t\t\t\tfmt.Println(\"yes\")\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"no\")\n\t\t\t}\n\t\tcase \"delete\":\n\t\t\tk := next()\n\t\t\thead = erase(head, k)\n\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nvar MIN int = 0\n\nvar sc = bufio.NewScanner(os.Stdin)\n\ntype Node struct {\n\tkey, pri    int\n\tleft, rigth *Node\n}\n\nfunc next() int {\n\tsc.Scan()\n\ti, _ := strconv.Atoi(sc.Text())\n\treturn i\n\n}\n\nfunc nextString() string {\n\tsc.Scan()\n\treturn sc.Text()\n\n}\n\nfunc rigthRotate(t *Node) *Node {\n\ts := t.left\n\tt.left = s.rigth\n\ts.rigth = t\n\treturn s\n}\n\nfunc leftRotate(t *Node) *Node {\n\ts := t.rigth\n\tt.rigth = s.left\n\ts.left = t\n\treturn s\n}\n\nfunc insert(t *Node, key int, pri int) *Node {\n\tif t == nil {\n\t\treturn &Node{key: key, pri: pri}\n\t}\n\tif key == t.key {\n\t\treturn t\n\t}\n\tif key < t.key {\n\n\t\tt.left = insert(t.left, key, pri)\n\t\tif t.pri < t.left.pri {\n\t\t\tt = rigthRotate(t)\n\t\t}\n\t} else {\n\t\tt.rigth = insert(t.rigth, key, pri)\n\t\tif t.pri < t.rigth.pri {\n\t\t\tt = leftRotate(t)\n\t\t}\n\n\t}\n\treturn t\n}\n\nfunc find(t *Node, key int) bool {\n\tif t == nil {\n\t\treturn false\n\t}\n\n\tif t.key == key {\n\t\treturn true\n\t}\n\n\tif t.key > key {\n\t\treturn find(t.left, key)\n\n\t} else if t.key < key {\n\t\treturn find(t.rigth, key)\n\n\t}\n\tpanic(\"error\")\n}\n\nfunc erase(t *Node, key int) *Node {\n\tif t == nil {\n\t\treturn nil\n\t}\n\tif key == t.key {\n\t\tif t.left == nil && t.rigth == nil {\n\t\t\treturn nil\n\n\t\t} else if t.left == nil {\n\t\t\tt = leftRotate(t)\n\t\t} else if t.rigth == nil {\n\t\t\tt = rigthRotate(t)\n\n\t\t} else {\n\t\t\tif t.left.pri > t.rigth.pri {\n\t\t\t\tt = rigthRotate(t)\n\n\t\t\t} else {\n\n\t\t\t\tt = leftRotate(t)\n\n\t\t\t}\n\n\t\t}\n\t\treturn erase(t, key)\n\n\t}\n\tif key < t.key {\n\t\tt.left = erase(t.left, key)\n\n\t} else {\n\t\tt.rigth = erase(t.rigth, key)\n\n\t}\n\treturn t\n}\n\nfunc printInOrder(t *Node) {\n\tif t == nil {\n\t\treturn\n\t}\n\n\tprintInOrder(t.left)\n\tfmt.Printf(\" %d\", t.key)\n\tprintInOrder(t.rigth)\n\n}\n\nfunc printPreOrder(t *Node) {\n\tif t == nil {\n\t\treturn\n\t}\n\n\tfmt.Printf(\" %d\", t.key)\n\tprintPreOrder(t.left)\n\tprintPreOrder(t.rigth)\n\n}\n\nfunc main() {\n\tsc.Split(bufio.ScanWords)\n\n\tvar head *Node\n\n\tm := next()\n\tfor i := 0; i < m; i++ {\n\n\t\tswitch nextString() {\n\n\t\tcase \"insert\":\n\t\t\tk, p := next(), next()\n\t\t\thead = insert(head, k, p)\n\n\t\tcase \"print\":\n\t\t\tprintInOrder(head)\n\t\t\tfmt.Println()\n\t\t\tprintPreOrder(head)\n\t\t\tfmt.Println()\n\t\tcase \"find\":\n\t\t\tk := next()\n\t\t\tif find(head, k) {\n\t\t\t\tfmt.Println(\"yes\")\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"no\")\n\t\t\t}\n\t\tcase \"delete\":\n\t\t\tk := next()\n\t\t\thead = erase(head, k)\n\n\t\t}\n\n\t}\n}\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strconv\"\n)\n\n// -----------------------------------------------------------------------------\n\n// IO helper functions\n\n// Returns next token from input.  It must be initialized by SetInput()\n// before the first call.\nvar nextToken func() ([]byte, error)\nvar nextLine func() ([]byte, error)\n\n// Holds a buffer for output.  It must be initialized by SetOutput().\n// All IO fucntions (read*() and [e]print*()) should write to OutputWriter\n// instead of this.\nvar OutputBuffer *bufio.Writer\n\n// Holds an io.Writer.  It must be initialized by SetOutput()\nvar OutputWriter io.Writer\n\n// Set IO functions for interactive input/output.\nfunc SetInteractive(w io.Writer, r io.Reader) {\n\tSetUnbefferedInput(r)\n\tOutputBuffer = nil\n\tOutputWriter = w\n}\n\n// Setup OutputBuffer and OutputWriter.\nfunc SetOutput(w io.Writer) {\n\tOutputBuffer = bufio.NewWriter(w)\n\tOutputWriter = OutputBuffer\n}\n\n// Flushes OutputBuffer\nfunc Flush() {\n\tif OutputBuffer != nil {\n\t\tOutputBuffer.Flush()\n\t}\n}\n\n// Returns true if c is a white space\nfunc IsSpace(c byte) bool {\n\tswitch c {\n\tcase '\\t', '\\n', '\\v', '\\f', '\\r', ' ':\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc IsNewLine(c byte) bool {\n\tswitch c {\n\tcase '\\n', '\\r':\n\t\treturn true\n\t}\n\treturn false\n}\n\n// Setup nextToken with input buffer.\nfunc SetInput(r io.Reader) {\n\tbuf := new(bytes.Buffer)\n\tvar b []byte\n\n\tvar i int\n\trest := func() ([]byte, error) {\n\t\tfor i < len(b) && IsSpace(b[i]) {\n\t\t\ti++\n\t\t}\n\t\tif i == len(b) {\n\t\t\treturn nil, io.ErrUnexpectedEOF\n\t\t}\n\t\tj := i\n\t\tfor i < len(b) && !IsSpace(b[i]) {\n\t\t\ti++\n\t\t}\n\t\treturn b[j:i], nil\n\t}\n\tinitial := func() ([]byte, error) {\n\t\tio.Copy(buf, r)\n\t\tb = buf.Bytes()\n\t\tnextToken = rest\n\t\treturn rest()\n\t}\n\tnextToken = initial\n\n\trestLn := func() ([]byte, error) {\n\t\tfor i < len(b) && IsNewLine(b[i]) {\n\t\t\ti++\n\t\t}\n\t\tif i == len(b) {\n\t\t\treturn nil, io.ErrUnexpectedEOF\n\t\t}\n\t\tj := i\n\t\tfor i < len(b) && !IsNewLine(b[i]) {\n\t\t\ti++\n\t\t}\n\t\treturn b[j:i], nil\n\t}\n\n\tinitialLn := func() ([]byte, error) {\n\t\tio.Copy(buf, r)\n\t\tb = buf.Bytes()\n\t\tnextLine = restLn\n\t\treturn restLn()\n\t}\n\tnextLine = initialLn\n}\n\n// Setup nextToken without input buffer.\nfunc SetUnbefferedInput(r io.Reader) {\n\tbuf := bufio.NewReader(r)\n\tvar b []byte\n\n\tvar i int\n\tnextToken = func() ([]byte, error) {\n\t\tvar err error\n\t\tif i == len(b) {\n\t\t\tb, err = buf.ReadBytes('\\n')\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\ti = 0\n\t\t\tj := len(b) - 1\n\t\t\tfor 0 <= j && IsSpace(b[j]) {\n\t\t\t\tj--\n\t\t\t}\n\t\t\tb = b[0 : j+1]\n\t\t}\n\t\tfor i < len(b) && IsSpace(b[i]) {\n\t\t\ti++\n\t\t}\n\t\tj := i\n\t\tfor i < len(b) && !IsSpace(b[i]) {\n\t\t\ti++\n\t\t}\n\t\tif i == j {\n\t\t\treturn nil, io.ErrUnexpectedEOF\n\t\t}\n\t\treturn b[j:i], nil\n\t}\n}\n\n// -----------------------------------------------------------------------------\n\n// IO functions\n\n// Reads next token and return it as []byte\nfunc readb() []byte {\n\tb, err := nextToken()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn b\n}\n\n// Reads next token and return it as string\nfunc reads() string {\n\treturn string(readb())\n}\n\n// Read next line as []byte\nfunc readbln() []byte {\n\tb, err := nextLine()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn b\n}\n\n// Read next line as string\nfunc readsln() string {\n\treturn string(readbln())\n}\n\n// Reads next token and return it as int64\nfunc readll() int64 {\n\ti, err := strconv.ParseInt(reads(), 10, 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn i\n}\n\n// Reads next token and return it as int\nfunc readi() int {\n\treturn int(readll())\n}\n\n// Reads next token and return it as float64\nfunc readf() float64 {\n\tf, err := strconv.ParseFloat(reads(), 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn f\n}\n\n// Write args to OutputWriter with the format f\nfunc printf(f string, args ...interface{}) (int, error) {\n\treturn fmt.Fprintf(OutputWriter, f, args...)\n}\n\n// Write args to OutputWriter without format\nfunc println(args ...interface{}) (int, error) {\n\treturn fmt.Fprintln(OutputWriter, args...)\n}\n\n// Write args to stderr with the format f\nfunc eprintf(f string, args ...interface{}) (int, error) {\n\treturn fmt.Fprintf(os.Stderr, f, args...)\n}\n\n// Write args to stderr without format\nfunc eprintln(args ...interface{}) (int, error) {\n\treturn fmt.Fprintln(os.Stderr, args...)\n}\n\n// -----------------------------------------------------------------------------\n\n// Simple math functions\n\nconst (\n\t// big prime\n\tINF  = 1000000007\n\tINF2 = 1000000009\n\tINF3 = 998244353\n)\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc minll(a, b int64) int64 {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc max(a, b int) int {\n\tif a < b {\n\t\treturn b\n\t}\n\treturn a\n}\n\nfunc maxll(a, b int64) int64 {\n\tif a < b {\n\t\treturn b\n\t}\n\treturn a\n}\n\nfunc abs(a int) int {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\nfunc absll(a int64) int64 {\n\tif a < 0 {\n\t\treturn -a\n\t}\n\treturn a\n}\n\n// egcd(a, b) returns d, x, y:\n//   d is gcd(a,b)\n//   x, y are  integers that satisfy ax + by = d\nfunc egcd(a, b int) (int, int, int) {\n\tif b == 0 {\n\t\treturn a, 1, 0\n\t}\n\td, x, y := egcd(b, a%b)\n\treturn d, y, x - a/b*y\n}\n\nfunc egcdll(a, b int64) (int64, int64, int64) {\n\tif b == 0 {\n\t\treturn a, 1, 0\n\t}\n\td, x, y := egcdll(b, a%b)\n\treturn d, y, x - a/b*y\n}\n\nfunc gcd(a, b int) int {\n\td, _, _ := egcd(a, b)\n\treturn d\n}\n\nfunc gcdll(a, b int64) int64 {\n\td, _, _ := egcdll(a, b)\n\treturn d\n}\n\n// set up IO functions\nfunc init() {\n\t// for non-interactive\n\tSetInput(os.Stdin)\n\tSetOutput(os.Stdout)\n\n\t// Enable below when interactive.  Its ok to leave above intact.\n\t// SetInteractive(os.Stdout, os.Stdin)\n}\n\nfunc main() {\n\tdefer Flush()\n\n\tm := readi()\n\tvar t *TreapNode\n\tfor i := 0; i < m; i++ {\n\t\tvar k, p int\n\t\tcmd := reads()\n\t\tswitch cmd {\n\t\tcase \"insert\":\n\t\t\tk = readi()\n\t\t\tp = readi()\n\t\t\tt = t.Insert(k, p)\n\t\tcase \"find\":\n\t\t\tk = readi()\n\t\t\tif t.Find(k) {\n\t\t\t\tprintln(\"yes\")\n\t\t\t} else {\n\t\t\t\tprintln(\"no\")\n\t\t\t}\n\t\tcase \"delete\":\n\t\t\tk = readi()\n\t\t\tt = t.Delete(k)\n\t\tcase \"print\":\n\t\t\tfor _, v := range t.KeysInorder() {\n\t\t\t\tprintf(\" %d\", v)\n\t\t\t}\n\t\t\tprintln()\n\t\t\tfor _, v := range t.KeysPreorder() {\n\t\t\t\tprintf(\" %d\", v)\n\t\t\t}\n\t\t\tprintln()\n\t\t}\n\t}\n\n}\n\ntype Treap struct {\n\t*TreapNode\n}\n\ntype TreapNode struct {\n\tkey, priority int\n\tright, left   *TreapNode\n}\n\nfunc (t *TreapNode) Insert(key, prio int) *TreapNode {\n\tif t == nil {\n\t\tt = new(TreapNode)\n\t\tt.key = key\n\t\tt.priority = prio\n\t\treturn t\n\t}\n\n\tif key < t.key {\n\t\tt.left = t.left.Insert(key, prio)\n\t\tif t.priority < t.left.priority {\n\t\t\treturn t.RotateRight()\n\t\t}\n\t} else if t.key < key {\n\t\tt.right = t.right.Insert(key, prio)\n\t\tif t.priority < t.right.priority {\n\t\t\treturn t.RotateLeft()\n\t\t}\n\t}\n\treturn t\n}\n\nfunc (t *TreapNode) RotateLeft() *TreapNode {\n\tif t.right == nil {\n\t\treturn t\n\t}\n\tnt := t.right\n\tol := nt.left\n\tnt.left = t\n\tt.right = ol\n\treturn nt\n}\n\nfunc (t *TreapNode) RotateRight() *TreapNode {\n\tif t.left == nil {\n\t\treturn t\n\t}\n\tnt := t.left\n\tor := nt.right\n\tnt.right = t\n\tt.left = or\n\treturn nt\n}\n\nfunc (t *TreapNode) Find(key int) bool {\n\tif t == nil {\n\t\treturn false\n\t}\n\n\tif t.key == key {\n\t\treturn true\n\t} else if key < t.key {\n\t\treturn t.left.Find(key)\n\t}\n\treturn t.right.Find(key)\n}\n\nfunc (t *TreapNode) Delete(key int) *TreapNode {\n\tif t == nil {\n\t\treturn nil\n\t}\n\tif t.key == key {\n\t\tif t.left == nil && t.right == nil {\n\t\t\treturn nil\n\t\t}\n\t\tif t.left == nil {\n\t\t\treturn t.RotateLeft().Delete(key)\n\t\t}\n\t\tif t.right == nil {\n\t\t\treturn t.RotateRight().Delete(key)\n\t\t}\n\t\tif t.left.priority < t.right.priority {\n\t\t\treturn t.RotateLeft().Delete(key)\n\t\t} else {\n\t\t\treturn t.RotateRight().Delete(key)\n\t\t}\n\t} else if key < t.key {\n\t\tt.left = t.left.Delete(key)\n\t} else if t.key < key {\n\t\tt.right = t.right.Delete(key)\n\t}\n\treturn t\n}\n\nfunc (t *TreapNode) KeysPreorder() []int {\n\tif t == nil {\n\t\treturn nil\n\t}\n\tres := append([]int{t.key}, t.left.KeysPreorder()...)\n\tres = append(res, t.right.KeysPreorder()...)\n\treturn res\n}\n\nfunc (t *TreapNode) KeysInorder() []int {\n\tif t == nil {\n\t\treturn nil\n\t}\n\tres := t.left.KeysInorder()\n\tres = append(res, t.key)\n\tres = append(res, t.right.KeysInorder()...)\n\treturn res\n}\n\nfunc (t *TreapNode) String() string {\n\tif t == nil {\n\t\treturn \"(nil)\"\n\t}\n\treturn fmt.Sprintf(\"%d/%d\", t.key, t.priority)\n}\n\n"
  },
  {
    "language": "Python",
    "code": "class Node():\n    def __init__(self, key, priority, parent, left, right):\n        self.key = key\n        self.priority = priority\n        self.parent = None\n        self.left = None\n        self.right = None\n\ndef RightRotate(t):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s\n\ndef LeftRotate(t):\n    s = t.right\n    t.right = s.left\n    s.left = t\n    return s\n\ndef insert(t, key, priority):\n    if t == None:\n        return Node(key, priority, None, None, None)\n    \n    if key == t.key:\n        return t\n    \n    if key < t.key:\n        t.left = insert(t.left, key, priority)\n        if t.priority < t.left.priority :\n            t = RightRotate(t)\n    \n    if key > t.key:\n        t.right = insert(t.right, key, priority)\n        if t.priority < t.right.priority:\n            t = LeftRotate(t)\n\n    return t\n\ndef delete(t, key):\n    if t == None:\n        return None\n    if key < t.key:\n        t.left = delete(t.left, key)\n    elif key > t.key:\n        t.right = delete(t.right, key)\n    else:\n        return _delete(t, key)\n    \n    return t\n\ndef _delete(t, key):\n    if t.left == None and t.right == None:\n        return None\n    elif t.left == None:\n        t = LeftRotate(t)\n    elif t.right == None:\n        t = RightRotate(t)\n    else:\n        if t.left.priority > t.right.priority:\n            t = RightRotate(t)\n        else:\n            t = LeftRotate(t)\n    return delete(t, key)\n\ndef find(t, key):\n    if t == None:\n        print(\"no\")\n        return \n\n    if key == t.key:\n        print(\"yes\")\n    elif key < t.key:\n        find(t.left, key)\n    elif key > t.key:\n        find(t.right, key)\n\ndef print_inorder(t):\n    if t == None:\n        return\n    \n    print_inorder(t.left)\n    print(\" \"+str(t.key), end = \"\")\n    print_inorder(t.right)\n\ndef print_preorder(t):\n    if t == None:\n        return \n    print(\" \"+str(t.key), end = \"\")\n    print_preorder(t.left)\n    print_preorder(t.right)\n\ndef Main():\n    N = int(input())\n    t = None\n\n    for i in range(N):\n        ope, *arg = input().split()\n\n        if ope == \"insert\":\n            key, priority = map(int, arg)\n            t = insert(t, key, priority)\n\n        elif ope == \"delete\":\n            key = int(arg[0])\n            t = delete(t, key)\n\n        elif ope == \"find\":\n            key = int(arg[0])\n            find(t, key)\n\n        elif ope == \"print\":\n            print_inorder(t)\n            print()\n            print_preorder(t)\n            print()\n\nMain()\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nclass Node:\n  def __init__(self, key, priority, left=None, right=None):\n    self.key = key\n    self.priority = priority\n    self.left = left\n    self.right = right\n  \ndef rightRotate(t):\n  s = t.left\n  t.left = s.right\n  s.right = t\n  return s\n\ndef leftRotate(t):\n  s = t.right\n  t.right = s.left\n  s.left = t\n  return s\n\ndef insert(t, key, priority):\n  \n  if not t: return Node(key, priority)\n  if key == t.key: return t\n  \n  if key < t.key: \n    t.left = insert(t.left, key, priority)\n    if t.priority < t.left.priority:\n      t = rightRotate(t)\n  else:\n    t.right = insert(t.right, key, priority)\n    if t.priority < t.right.priority:\n      t = leftRotate(t)\n  \n  return t\n\ndef erase(t, key):\n  \n  if not t: return None\n  \n  if key == t.key:\n    if (not t.left) and (not t.right): return None\n    elif not t.left: \n      t = leftRotate(t)\n    elif not t.right:\n      t = rightRotate(t)\n    else:\n      if t.left.priority > t.right.priority:\n        t = rightRotate(t)\n      else:\n        t = leftRotate(t)\n    return erase(t, key)\n  elif key > t.key:\n    t.right = erase(t.right, key)\n  else:\n    t.left = erase(t.left, key)\n  return t\n\n\ndef find(t, key):\n  if t.key == key:\n    print(\"yes\")\n  elif t.key < key and t.right != None:\n    find(t.right, key)\n  elif t.key > key and t.left != None:\n    find(t.left, key)\n  else:\n    print(\"no\")\n  return 0\n\ndef in_print(t):\n  if t.left != None:\n    in_print(t.left)\n  print(\" \" + str(t), end='')\n  if t.right != None:\n    in_print(t.right)\n\ndef pre_print(t):\n  print(\" \" + str(t), end='')\n  if t.left != None:\n    pre_print(t.left)\n  if t.right != None:\n    pre_print(t.right)\n  \nTreap = None\nnum = int(input())\nfor i in range(num):\n  string = list(input().split())\n  if string[0] == \"insert\":\n    key = int(string[1])\n    priority = int(string[2])\n    Treap = insert(Treap, key, priority)\n  elif string[0] == \"find\":\n    key = int(string[1])\n    find(Treap, key)\n  elif string[0] == \"delete\":\n    key = int(string[1])\n    Treap = erase(Treap, key)\n  else:\n    in_print(Treap)\n    print()\n    pre_print(Treap)\n    print()\n    \n\n  \n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nclass Node:\n  def __init__(self, key, priority):\n    self.key = key\n    self.priority = priority\n    self.left = None\n    self.right = None\n  \ndef rightRotate(t):\n  s = t.left\n  t.left = s.right\n  s.right = t\n  return s\n\ndef leftRotate(t):\n  s = t.right\n  t.right = s.left\n  s.left = t\n  return s\n\ndef insert(t, key, priority):\n  \n  if not t: return Node(key, priority)\n  if key == t.key: return t\n  \n  if key < t.key: \n    t.left = insert(t.left, key, priority)\n    if t.priority < t.left.priority:\n      t = rightRotate(t)\n  else:\n    t.right = insert(t.right, key, priority)\n    if t.priority < t.right.priority:\n      t = leftRotate(t)\n  \n  return t\n\ndef erase(t, key):\n  \n  if not t: return None\n  \n  if key == t.key:\n    if (not t.left) and (not t.right): return None\n  elif not t.left: \n    t = leftRotate(t)\n  elif not t.right:\n    t = rightRotate(t)\n  else:\n    if t.left.priority > t.right.priority:\n      t = rightRotate(t)\n    else:\n      t = leftRotate(t)\n  return erase(t, key)\n\n  if key < t.key:\n    t.left = erase(t.left, key)\n  else:\n    t.right = erase(t.right, key)\n  return t\n\ndef find(t, key):\n  if t.key == key:\n    print(\"yes\")\n    return 0\n  elif t.key < key and (not t.right):\n    find(t.right, key)\n  elif t.key > key and (not t.left):\n    find(t.left, key)\n  else:\n    print(\"no\")\n  return 0\n\ndef in_print(t):\n  if not t.left:\n    in_print(t.left)\n  print(\" \" + str(t), end='')\n  if not t.right:\n    in_print(t.right)\n\ndef pre_print(t):\n  print(\" \" + str(t), end='')\n  if not t.left:\n    pre_print(t.left)\n  if not t.right:\n    pre_print(t.right)\n  \nTreap = None\nnum = int(input())\nfor i in range(num):\n  string = list(input().split())\n  if string[0] == \"insert\":\n    key = int(string[1])\n    priority = int(string[2])\n    insert(Treap, key, priority)\n  elif string[0] == \"find\":\n    key = int(string[1])\n    find(Treap, key)\n  elif string[0] == \"delete\":\n    key = int(string[1])\n    erase(Treap, key)\n  else:\n    in_print(Treap)\n    print()\n    pre_print(Treap)\n    print()\n    \n\n  \n"
  },
  {
    "language": "Python",
    "code": "import sys, os\nfrom io import StringIO\n\nclass BinaryTree:\n\n    class Node:\n        def __init__(self, key, priority = 0):\n            self.key = key\n            self.left = None\n            self.right = None\n            self.parent = None\n            self.priority = priority\n\n    def __init__(self):\n        self.root = None\n        self.output = StringIO()\n\n\n    def insert(self, key, priority):\n        self.root = self._insert_main(key, self.root, priority)\n\n    def _insert_main(self, key, node, priority):\n        if node is None:\n            return self.Node(key, priority)\n        else:\n            if key > node.key:\n                node.right = self._insert_main(key, node.right, priority)\n                if node.priority < node.right.priority:\n                    node = self.rotate_left(node)\n            else:\n                node.left = self._insert_main(key, node.left, priority)\n                if node.priority < node.left.priority:\n                    node = self.rotate_right(node)\n            return node\n\n\n    def rotate_right(self, base):\n        left_node = base.left\n        # left.right = base\n        # base.left = replace\n        base.left = left_node.right\n        left_node.right = base\n        return left_node\n\n    def rotate_left(self, base):\n        right_node = base.right\n        # replace = right.left\n        # right.left = base\n        # base.right = replace\n        base.right = right_node.left\n        right_node.left = base\n        return right_node\n\n    def ini_print_inorder(self):\n        self.output = StringIO()\n        self._print_inorder(self.root)\n        return self.output.getvalue()\n\n    def ini_print_preorder(self):\n        self.output = StringIO()\n        self._print_preorder(self.root)\n        return self.output.getvalue()\n\n    def ini_print_postorder(self):\n        self.output = StringIO()\n        self._print_postorder(self.root)\n        return self.output.getvalue()\n\n    def _print_inorder(self, node):\n        if node is not None:\n            self._print_inorder(node.left)\n            print(node.key, end = \" \", file = self.output)\n            self._print_inorder(node.right)\n\n    def _print_preorder(self, node):\n        if node is not None:\n            print(node.key, end = \" \", file = self.output)\n            self._print_preorder(node.left)\n            self._print_preorder(node.right)\n\n    def _print_postorder(self, node):\n        if node is not None:\n            self._print_preorder(node.left)\n            self._print_preorder(node.right)\n            print(node.key, end = \" \", file = self.output)\n\n    def test_insert(self, keys):\n        for k in keys:\n            self.insert(k)\n\n    def ini_find(self, key):\n        print(self.find(key))\n\n    def find(self, key):\n        root = self.root\n        while root is not None:\n            if key == root.key:\n                return \"yes\"\n            elif key < root.key:\n                root = root.left\n            else:\n                root = root.right\n        return \"no\"\n\n    def get_successor(self, node):\n        parent = node\n        while True:\n            node = node.left\n            if node is None:\n                return parent, parent.parent\n            parent = node\n        return None\n\n    def delete(self, key):\n        self.root = self._delete_main(key, self.root)\n\n    def _delete_main(self, key, node):\n        if node:\n            if key > node.key:\n                node.right = self._delete_main(key, node.right)\n            elif key < node.key:\n                node.left = self._delete_main(key, node.left)\n            else:\n                if node.right is None and node.left is None:\n                    return None\n                elif node.right is None:\n                    node = self.rotate_right(node)\n                elif node.left is None:\n                    node = self.rotate_left(node)\n                else:\n                    if node.left.priority > node.right.priority:\n                        node = self.rotate_right(node)\n                    else:\n                        node = self.rotate_left(node)\n                node = self._delete_main(key, node)\n        return node\n\n    def _search_min(self, node):\n        if node.left is None:\n            return node.key\n        return self._search_min(node.left)\n\n    def _delete_min(self, node):\n        if node.left is None:\n            return node.right\n        node.left = self._delete_min(node.left)\n        return node\n\n\n\nb = BinaryTree()\nlength = int(input())\nfor _ in range(length):\n    comm = input()\n    if comm[0] == \"i\":\n        com, num, pri = comm.split(\" \")\n        b.insert(int(num), int(pri))\n    elif comm[0] == \"p\":\n        print(\" \", end = \"\")\n        print(b.ini_print_inorder()[:-1])\n        print(\" \", end = \"\")\n        print(b.ini_print_preorder()[:-1])\n\n    elif comm[0] == \"f\":\n        com, num = comm.split(\" \")\n        b.ini_find(int(num))\n    else:\n        com, num = comm.split(\" \")\n        b.delete(int(num))\n\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, key, pri):\n        self.key = key\n        self.pri = pri\n        self.left  = None\n        self.right = None\n\n\ndef rRotate(t):\n    s       = t.left\n    t.left  = s.right\n    s.right = t\n\n    return s\n\n\ndef lRotate(t):\n    s       = t.right\n    t.right = s.left\n    s.left  = t\n\n    return s\n\n\ndef insert(t, key, pri):\n    if t == None: return Node(key, pri)\n\n    if key == t.key: return t\n\n    if key < t.key:\n        t.left = insert(t.left , key, pri)\n        if t.pri < t.left.pri : t = rRotate(t)\n\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.pri < t.right.pri: t = lRotate(t)\n\n    return t\n\n\ndef delete(t, key):\n    if t == None: return None\n\n    if key == t.key:\n        if   t.left  == None and\\\n             t.right == None: return None\n\n        elif t.left  == None: t = lRotate(t)\n        elif t.right == None: t = rRotate(t)\n\n        else:\n            if t.left.pri > t.right.pri: t = rRotate(t)\n            else                       : t = lRotate(t)\n\n        return delete(t, key)\n\n    if key < t.key: t.left  = delete(t.left , key)\n    else          : t.right = delete(t.right, key)\n\n    return t\n\n\ndef find(t, key):\n    if(t == None): return False\n    if(t.key == key ): return True\n\n    return any([find(t.left, key), find(t.right, key)])\n\n\ndef preorder(t):\n    if(t == None): return\n\n    print('', t.key, end = '')\n    preorder(t.left )\n    preorder(t.right)\n\n\ndef inorder(t):\n    if(t == None): return\n\n    inorder(t.left )\n    print('', t.key, end='')\n    inorder(t.right)\n\n\nif __name__ == '__main__':\n    n = int(input())\n    top = None\n\n    for _ in range(n):\n        strs = input().split()\n\n        op  = strs[0]\n        if op != 'print':\n            key = int(strs[1])\n            if op == 'insert':\n                pri = int(strs[2])\n\n\n\n        if op == 'insert': top = insert(top, key, pri)\n        if op == 'delete': top = delete(top, key)\n        if op == 'find'  :\n            if find(top, key): print('yes')\n            else           : print('no' )\n        if op == 'print' :\n            inorder(top)\n            print()\n            preorder(top)\n            print()\n\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, x, priority):\n        self.data = x\n        self.priority = priority\n        self.left = None\n        self.right = None\n\ndef rightRotate(node):\n    leftNode = node.left\n    node.left = leftNode.right\n    leftNode.right = node\n    return leftNode\n\ndef leftRotate(node):\n    rightNode = node.right\n    node.right = rightNode.left\n    rightNode.left = node\n    return rightNode\n\ndef find(node, x):\n    while node is not None:\n        if x == node.data:\n            return True\n        elif x < node.data:\n            node = node.left\n        else:\n            node = node.right\n    return False\n\ndef insert(node, x, priority):\n    if node is None:\n        return Node(x, priority)\n\n    if x == node.data:\n        return node\n\n    if x < node.data:\n        node.left = insert(node.left, x, priority)\n        if node.priority < node.left.priority:\n            node = rightRotate(node)\n\n    else:\n        node.right = insert(node.right, x, priority)\n        if node.priority < node.right.priority:\n            node = leftRotate(node)\n    return node\n\ndef inorder_print(node, x = 0):\n    if node is not None:\n        print('',node.data, end = '')\n        inorder_print(node.left, x + 1)\n        inorder_print(node.right, x + 1)\n\ndef preorder_print(node, x = 0):\n    if node is not None:\n        preorder_print(node.left, x + 1)\n        print('',node.data, end = '')\n        preorder_print(node.right, x + 1)\n\n\ndef delete(node, x):\n    if node == None:\n        return None\n    if x < node.data:\n        node.left = delete(node.left, x)\n    elif x > node.data:\n        node.right = delete(node.right, x)\n    else:\n        return _delete(node, x)\n\n    return node\n\ndef _delete(node, x):\n    if node.left == None and node.right == None:\n        return None\n    elif node.left == None:\n        node = leftRotate(node)\n    elif node.right == None:\n        node = rightRotate(node)\n    else:\n        if node.left.priority > node.right.priority:\n            node = rightRotate(node)\n        else:\n            node = leftRotate(node)\n    return delete(node, x)\n\nclass Treap:\n    def __init__(self):\n        self.root = None\n\n    def find_(self, x):\n        return find(self.root, x)\n\n    def insert_(self, x, pri):\n        self.root = insert(self.root, x, pri)\n\n    def delete_(self, x):\n        self.root = delete(self.root, x)\n\n    def traverse_(self):\n        for x in traverse(self.root):\n            yield x\n\n    def print_treap_(self):\n        preorder_print(self.root)\n        print('')\n        inorder_print(self.root)\n        print('')\n\nif __name__ == '__main__':\n\n    n = int(input())\n    treap = Treap()\n    for i in range(n):\n        _input = input()\n        if _input == 'print':\n            #print operation\n            treap.print_treap_()\n\n        else:\n            operate, nums = _input.split(' ', 1)\n            if operate == 'insert':\n                #insert operation\n                k, p = (int(z) for z in nums.split())\n                treap.insert_(k, p)\n\n            elif operate == 'find':\n                k = int(nums)\n                res = treap.find_(k)\n                if res:\n                    print(\"yes\")\n                else:\n                    print(\"no\")\n\n            elif operate == 'delete':\n                k = int(nums)\n                treap.delete_(k)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef rotate(nd, d):\n    c = nd[d]\n    if d:\n        nd[1] = c[0]\n        c[0] = nd\n    else:\n        nd[0] = c[1]\n        c[1] = nd\n    return c\n\n\nroot = None\ndef insert(val, pri):\n    global root\n    st = []\n    dr = []\n    x = root\n    while x:\n        st.append(x)\n        if x[2] == val:\n            return\n        d = (x[2] < val)\n        dr.append(d)\n        x = x[d]\n    nd = [None, None, val, pri]\n    while st:\n        x = st.pop(); d = dr.pop()\n        c = x[d] = nd\n        if x[3] >= c[3]:\n            break\n        rotate(x, d)\n    else:\n        root = nd\n\ndef __delete(nd):\n    st = []; dr = []\n    while nd[0] or nd[1]:\n        l = nd[0]; r = nd[1]\n        d = (l[3] <= r[3]) if l and r else (l is None)\n        st.append(rotate(nd, d))\n        dr.append(d ^ 1)\n    nd = x = None\n    while st:\n        nd = x; x = st.pop(); d = dr.pop()\n        x[d] = nd\n    return x\n\ndef delete(val):\n    global root\n    x = root\n\n    y = None\n    while x:\n        if val == x[2]:\n            break\n        y = x; d = (x[2] < val)\n        x = x[d]\n    else:\n        return\n\n    if y:\n        y[d] = __delete(x)\n    else:\n        root = __delete(x)\n\ndef find(val):\n    x = root\n    while x:\n        if val == x[2]:\n            return 1\n        x = x[x[2] < val]\n    return 0\n\ndef debug():\n    s0 = [\"\"]\n    s1 = [\"\"]\n\n    def dfs(nd):\n        v = str(nd[2])\n        s0.append(v)\n        if nd[0]:\n            dfs(nd[0])\n        s1.append(v)\n        if nd[1]:\n            dfs(nd[1])\n    dfs(root)\n    return \" \".join(s1), \" \".join(s0)\n\n\nM = int(readline())\nans = []\nfor m in range(M):\n    cmd, *V, = readline().split()\n    if cmd == \"print\":\n        ans.extend(debug())\n    elif cmd == \"find\":\n        ans.append(\"yes\" if find(int(V[0])) else \"no\")\n    elif cmd == \"delete\":\n        delete(int(V[0]))\n    else:\n        val, pri = map(int, V)\n        insert(val, pri)\nwrite(\"\\n\".join(ans))\nwrite(\"\\n\")\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n\nclass Node:\n    def __init__(self, key=None, pri=None):\n        self.left = None\n        self.right = None\n        self.key = key\n        self.pri = pri\n\n\ndef right_rotate(t: Node):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s\n\n\ndef left_rotate(t: Node):\n    s = t.right\n    t.right = s.left\n    s.left = t\n    return s\n\n\ndef insert(t: Node, key: int, pri: int):\n    if t is None:\n        return Node(key, pri)\n    if key == t.key:\n        return t\n    if key < t.key:\n        t.left = insert(t.left, key, pri)\n        if t.pri < t.left.pri:\n            t = right_rotate(t)\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.pri < t.right.pri:\n            t = left_rotate(t)\n    return t\n\n\ndef erase(t: Node, key: int):\n    if t is None:\n        return None\n    if key == t.key:\n        if t.left is None and t.right is None:\n            return None\n        elif t.left is None:\n            t = left_rotate(t)\n        elif t.right is None:\n            t = right_rotate(t)\n        else:\n            if t.left.pri > t.right.pri:\n                t = right_rotate(t)\n            else:\n                t = left_rotate(t)\n        return erase(t, key)\n    if key < t.key:\n        t.left = erase(t.left, key)\n    else:\n        t.right = erase(t.right, key)\n    return t\n\n\ndef find(t: Node, x: int):\n    while t is not None:\n        if t.key == x:\n            return 1\n        elif t.key > x:\n            t = t.left\n        else:\n            t = t.right\n    return 0\n\n\ndef inorder(t: Node):\n    if t.left is not None:\n        inorder(t.left)\n    print(\" {}\".format(t.key), end='')\n\n    if t.right is not None:\n        inorder(t.right)\n    return\n\n\ndef preorder(t: Node):\n    print(\" {}\".format(t.key), end='')\n\n    if t.left is not None:\n        preorder(t.left)\n    if t.right is not None:\n        preorder(t.right)\n    return\n\n\ndef print_key(t: Node):\n    inorder(t)\n    print(\"\\n\", end='')\n    preorder(t)\n    print(\"\\n\", end='')\n    return\n\n\nline = sys.stdin.readline()\nn = int(line)\nroot = None\nfor i in range(n):\n    line = sys.stdin.readline().split()\n    if line[0] == 'insert':\n        k, p = int(line[1]), int(line[2])\n        root = insert(root, k, p)\n    elif line[0] == 'delete':\n        k = int(line[1])\n        root = erase(root, k)\n    elif line[0] == 'find':\n        k = int(line[1])\n        if find(root, k):\n            print(\"yes\")\n        else:\n            print(\"no\")\n    else:\n        print_key(root)\n\n"
  },
  {
    "language": "Python",
    "code": "class Treap:\n    class TreapNode:\n        def __init__(self, key, priority, leftchild=None, rightchild=None):\n            self.key = key\n            self.priority = priority\n            self.leftchild = leftchild\n            self.rightchild = rightchild\n\n        def __repr__(self):\n            return f'({self.key}, {self.priority})'\n\n    def __init__(self):\n        self.root = None\n        self.inorder = []\n        self.preorder = []\n\n    def rotateR(self, t):\n        s = t.leftchild\n        t.leftchild = s.rightchild\n        s.rightchild = t\n        return s\n\n    def rotateL(self, t):\n        s = t.rightchild\n        t.rightchild = s.leftchild\n        s.leftchild = t\n        return s\n\n    def _insert(self, t, key, priority):\n        if t is None:\n            return self.TreapNode(key, priority)\n        if key == t.key:\n            return t\n        if key < t.key:\n            t.leftchild = self._insert(t.leftchild, key, priority)\n            if t.priority < t.leftchild.priority:\n                t = self.rotateR(t)\n        else:\n            t.rightchild = self._insert(t.rightchild, key, priority)\n            if t.priority < t.rightchild.priority:\n                t = self.rotateL(t)\n        return t\n\n    def insert(self, key, priority):\n        self.root = self._insert(self.root, key, priority)\n\n    def _delete_rotate(self, t, key):\n        if t.leftchild is None and t.rightchild is None:\n            return None\n        elif t.leftchild is None:\n            t = self.rotateL(t)\n        elif t.rightchild is None:\n            t = self.rotateR(t)\n        else:\n            if t.leftchild.priority > t.rightchild.priority:\n                t = self.rotateR(t)\n            else:\n                t = self.rotateL(t)\n        return self._delete(t, key)\n\n    def _delete(self, t, key):\n        if t is None:\n            return None\n        if key < t.key:\n            t.leftchild = self._delete(t.leftchild, key)\n        elif key > t.key:\n            t.rightchild = self._delete(t.rightchild, key)\n        else:\n            return self._delete_rotate(t, key)\n        return t\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _find(self, t, key):\n        if t is None:\n            return False\n        elif key < t.key:\n            return self._find(t.leftchild, key)\n        elif key > t.key:\n            return self._find(t.rightchild, key)\n        else:\n            return True\n\n    def find(self, key):\n        return self._find(self.root, key)\n\n    def _walk(self, t):\n        if t is None:\n            return\n        self.preorder.append(t.key)\n        self._walk(t.leftchild)\n        self.inorder.append(t.key)\n        self._walk(t.rightchild)\n\n    def walk(self):\n        self.inorder.clear()\n        self.preorder.clear()\n        self._walk(self.root)\n\n    def print(self):\n        self.walk()\n        print(' ' + ' '.join(map(str, self.inorder)))\n        print(' ' + ' '.join(map(str, self.preorder)))\n\n\nT = Treap()\nN = int(input())\nfor _ in range(N):\n    s = input().split()\n    s[1:] = map(int, s[1:])\n    if s[0] == 'insert':\n        T.insert(s[1], s[2])\n    if s[0] == 'find':\n        print('yes' if T.find(s[1]) else 'no')\n    if s[0] == 'delete':\n        T.delete(s[1])\n    if s[0] == 'print':\n        T.print()\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef rotate(nd, d):\n    c = nd[d]\n    if d:\n        nd[1] = c[0]\n        c[0] = nd\n    else:\n        nd[0] = c[1]\n        c[1] = nd\n    return c\n\n\nroot = None\ndef insert(val, pri):\n    global root\n    st = []\n    dr = []\n    x = root\n    while x:\n        st.append(x)\n        if x[2] == val:\n            return\n        d = (x[2] < val)\n        dr.append(d)\n        x = x[d]\n    nd = [None, None, val, pri]\n    while st:\n        x = st.pop(); d = dr.pop()\n        c = x[d] = nd\n        if x[3] >= c[3]:\n            break\n        rotate(x, d)\n    else:\n        root = nd\n\ndef __delete(nd):\n    st = []; dr = []\n    while nd[0] or nd[1]:\n        l = nd[0]; r = nd[1]\n        d = (l[3] <= r[3]) if l and r else (l is None)\n        st.append(rotate(nd, d))\n        dr.append(d ^ 1)\n    nd = x = None\n    while st:\n        nd = x; x = st.pop(); d = dr.pop()\n        x[d] = nd\n    return x\n\ndef delete(val):\n    global root\n    x = root\n\n    y = None\n    while x:\n        if val == x[2]:\n            break\n        y = x; d = (x[2] < val)\n        x = x[d]\n    else:\n        return\n\n    if y:\n        y[d] = __delete(x)\n    else:\n        root = __delete(x)\n\ndef find(val):\n    x = root\n    while x:\n        if val == x[2]:\n            return 1\n        x = x[x[2] < val]\n    return 0\n\ndef debug():\n    s0 = [\"\"]\n    s1 = [\"\"]\n\n    def dfs(nd):\n        v = str(nd[2])\n        s0.append(v)\n        if nd[0]:\n            dfs(nd[0])\n        s1.append(v)\n        if nd[1]:\n            dfs(nd[1])\n    dfs(root)\n    return \" \".join(s1), \" \".join(s0)\n\n\nM = int(readline())\nans = []\nfor m in range(M):\n    cmd, *V, = readline().split()\n    if cmd == \"print\":\n        ans.extend(debug())\n    elif cmd == \"find\":\n        ans.append(\"yes\" if find(int(V[0])) else \"no\")\n    elif cmd == \"delete\":\n        delete(int(V[0]))\n    else:\n        val, pri = map(int, V)\n        insert(val, pri)\nwrite(\"\\n\".join(ans))\nwrite(\"\\n\")\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nclass Node:\n  def __init__(self, key, priority, left=None, right=None):\n    self.key = key\n    self.priority = priority\n    self.left = left\n    self.right = right\n  \ndef rightRotate(t):\n  s = t.left\n  t.left = s.right\n  s.right = t\n  return s\n\ndef leftRotate(t):\n  s = t.right\n  t.right = s.left\n  s.left = t\n  return s\n\ndef insert(t, key, priority):\n  \n  if not t: return Node(key, priority)\n  if key == t.key: return t\n  \n  if key < t.key: \n    t.left = insert(t.left, key, priority)\n    if t.priority < t.left.priority:\n      t = rightRotate(t)\n  else:\n    t.right = insert(t.right, key, priority)\n    if t.priority < t.right.priority:\n      t = leftRotate(t)\n  \n  return t\n\ndef erase(t, key):\n  \n  if not t: return None\n  \n  if key == t.key:\n    if (not t.left) and (not t.right): return None\n  elif not t.left: \n    t = leftRotate(t)\n  elif not t.right:\n    t = rightRotate(t)\n  else:\n    if t.left.priority > t.right.priority:\n      t = rightRotate(t)\n    else:\n      t = leftRotate(t)\n  return erase(t, key)\n\n  if key < t.key:\n    t.left = erase(t.left, key)\n  else:\n    t.right = erase(t.right, key)\n  return t\n\ndef find(t, key):\n  if t.key == key:\n    print(\"yes\")\n    return 0\n  elif t.key < key and (not t.right):\n    find(t.right, key)\n  elif t.key > key and (not t.left):\n    find(t.left, key)\n  else:\n    print(\"no\")\n  return 0\n\ndef in_print(t):\n  if t.left != None:\n    in_print(t.left)\n  print(\" \" + str(t), end='')\n  if t.right != None:\n    in_print(t.right)\n\ndef pre_print(t):\n  print(\" \" + str(t), end='')\n  if t.left != None:\n    pre_print(t.left)\n  if t.right != None:\n    pre_print(t.right)\n  \nTreap = None\nnum = int(input())\nfor i in range(num):\n  string = list(input().split())\n  if string[0] == \"insert\":\n    key = int(string[1])\n    priority = int(string[2])\n    insert(Treap, key, priority)\n  elif string[0] == \"find\":\n    key = int(string[1])\n    find(Treap, key)\n  elif string[0] == \"delete\":\n    key = int(string[1])\n    erase(Treap, key)\n  else:\n    in_print(Treap)\n    print()\n    pre_print(Treap)\n    print()\n    \n\n  \n"
  },
  {
    "language": "Python",
    "code": "# Treap\nclass Node():\n    def __init__(self, k, p):\n        self.k = k\n        self.p = p\n        self.left = None\n        self.right = None\n\ndef rightRotate(t):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s\n\ndef leftRotate(t):\n    s = t.right\n    t.right = s.left\n    s.left = t\n    return s\n\ndef insert(t, key, pri):\n    if t == None:\n        return Node(key, pri)\n    if key == t.k:\n        return t\n\n    if key < t.k:\n        t.left = insert(t.left, key, pri)\n        if t.p < t.left.p:\n            t = rightRotate(t)\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.p < t.right.p:\n            t = leftRotate(t)\n    return t\n\ndef erase(t, key):\n    if t == None:\n        return None\n\n    if key == t.k:\n        if t.left == None and t.right == None:\n            return None\n        elif t.left == None:\n            t = leftRotate(t)\n        elif t.right == None:\n            t = rightRotate(t)\n        else:\n            if t.left.p > t.right.p:\n                t = rightRotate(t)\n            else:\n                t = leftRotate(t)\n        return erase(t, key)\n\n    if key < t.k:\n        t.left = erase(t.left, key)\n    else:\n        t.right = erase(t.right, key)\n    return t\n\"\"\"\ndef find(t, k):\n    if t == None:\n        return -1\n    if t.k == k:\n        return 1\n    if find(t.left, k) == 1:\n        return 1\n    if find(t.right, k) == 1:\n        return 1\n\"\"\"\ndef inorder(t):\n    if t == None:\n        return \n    inorder(t.left)\n    print(\" \" + str(t.k), end=\"\")\n    inorder(t.right)\n\ndef preorder(t):\n    if t == None:\n        return\n    print(\" \" + str(t.k), end=\"\")\n    preorder(t.left)\n    preorder(t.right)\n\ndef output(t):\n    inorder(t)\n    print()\n    preorder(t)\n    print()\n\n\nt = None\ndata = []\ndict = {}\nm = int(input())\nfor i in range(m):\n    data.append(list(input().split()))\n\nfor i in range(m):\n    if data[i][0] == \"insert\":\n        if (data[i][1] in dict) == False:\n            t = insert(t, int(data[i][1]), int(data[i][2]))\n            dict[data[i][1]] = True\n    elif data[i][0] == \"print\":\n        output(t)\n    elif data[i][0] == \"find\":\n        #result = find(t, int(data[i][1]))\n        #if result == 1:\n        #print(dict)\n        #result = data[i][1] in dict\n        #print(\"result\", result)\n        #print(\"2\", result == True)\n        #print(data[i][1] in dict, data[i][1])\n        if (data[i][1] in dict) == True:\n            #print(\"12345\")\n            print(\"yes\")\n        else:\n            print(\"no\")\n    else:\n        t = erase(t, int(data[i][1]))\n        del dict[data[i][1]]\n"
  },
  {
    "language": "Python",
    "code": "\nclass Node:\n    def __init__(self, key, priority):\n        self.key = key\n        self.priority = priority\n        self.parent = None\n        self.left = None\n        self.right = None\n\n\ndef rightRotate(t):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s\n\n\ndef leftRotate(t):\n    s = t.right\n    t.right = s.left\n    s.left = t\n    return s\n\n\ndef insert(t, key, priority):\n    if t is None:\n        return Node(key, priority)\n    if key == t.key:\n        return t\n\n    if key < t.key:\n        t.left = insert(t.left, key, priority)\n        if t.priority < t.left.priority:\n            t = rightRotate(t)\n    else:\n        t.right = insert(t.right, key, priority)\n        if t.priority < t.right.priority:\n            t = leftRotate(t)\n\n    return t\n\n\ndef delete(t, key):\n    if t is None:\n        return None\n    if key < t.key:\n        t.left = delete(t.left, key)\n    elif key > t.key:\n        t.right = delete(t.right, key)\n    else:\n        return _delete(t, key)\n    return t\n\n\ndef _delete(t, key):\n    if t.left is None and t.right is None:\n        return None\n    elif t.left is None:\n        t = leftRotate(t)\n    elif t.right is None:\n        t = rightRotate(t)\n    else:\n        if t.left.priority > t.right.priority:\n            t = rightRotate(t)\n        else:\n            t = leftRotate(t)\n    return delete(t, key)\n\n\ndef find(t, key):\n    if key == t.key:\n        return t\n\n    elif key < t.key:\n        if t.left is not None:\n            ret = find(t.left, key)\n            if ret is not None:\n                return ret\n    else:\n        if t.right is not None:\n            ret = find(t.right, key)\n            if ret is not None:\n                return ret\n\n    return None\n\n\ndef preorder(t, ret):\n    ret.append(t.key)\n\n    if t.left is not None:\n        preorder(t.left, ret)\n\n    if t.right is not None:\n        preorder(t.right, ret)\n\n\ndef inorder(t, ret):\n    if t.left is not None:\n        inorder(t.left, ret)\n\n    ret.append(t.key)\n\n    if t.right is not None:\n        inorder(t.right, ret)\n\n\ndef main():\n    m = int(input())\n    Treap = None\n    for i in range(m):\n        cmd, *v = input().split()\n        if cmd == \"print\":\n            print(\" \", end=\"\")\n            inans = []\n            inorder(Treap, inans)\n            print(*inans)\n            print(\" \", end=\"\")\n            preans = []\n            preorder(Treap, preans)\n            print(*preans)\n        elif cmd == \"insert\":\n            k = int(v[0])\n            p = int(v[1])\n            Treap = insert(Treap, k, p)\n        elif cmd == \"find\":\n            z = int(v[0])\n            if find(Treap, z) == None:\n                print(\"no\")\n            else:\n                print(\"yes\")\n        else:\n            z = int(v[0])\n            Treap = delete(Treap, z)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, key, pri):\n        self.key = key\n        self.pri = pri\n        self.left  = None\n        self.right = None\n\n\ndef rRotate(t):\n    s       = t.left\n    t.left  = s.right\n    s.right = t\n\n    return s\n\n\ndef lRotate(t):\n    s       = t.right\n    t.right = s.left\n    s.left  = t\n\n    return s\n\n\ndef insert(t, key, pri):\n    if t == None: return Node(key, pri)\n\n    if key == t.key: return t\n\n    if key < t.key:\n        t.left = insert(t.left , key, pri)\n        if t.pri < t.left.pri : t = rRotate(t)\n\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.pri < t.right.pri: t = lRotate(t)\n\n    return t\n\n\ndef delete(t, key):\n    if   t == None:\n        return None\n    if   key < t.key:\n        t.left  = delete(t.left , key)\n    elif key > t.key:\n        t.right = delete(t.right, key)\n    else:\n        return _delete(t, key)\n    return t\n\n\ndef _delete(t, key):\n    if t.left == None and t.right == None:\n        return None\n    elif t.left  == None:\n        t = lRotate(t)\n    elif t.right == None:\n        t = rRotate(t)\n    else:\n        if t.left.pri > t.right.pri:\n            t = rRotate(t)\n        else:\n            t = lRotate(t)\n    return delete(t, key)\n\n\ndef find(t, key):\n    if(t == None): return False\n    if(t.key == key ): return True\n\n    return any([find(t.left, key), find(t.right, key)])\n\n\ndef preorder(t):\n    if(t == None): return\n\n    print('', t.key, end = '')\n    preorder(t.left )\n    preorder(t.right)\n\n\ndef inorder(t):\n    if(t == None): return\n\n    inorder(t.left )\n    print('', t.key, end='')\n    inorder(t.right)\n\n\nif __name__ == '__main__':\n    n = int(input())\n    top = None\n\n    for _ in range(n):\n        strs = input().split()\n\n        op  = strs[0]\n        if op != 'print':\n            key = int(strs[1])\n            if op == 'insert':\n                pri = int(strs[2])\n\n\n\n        if op == 'insert': top = insert(top, key, pri)\n        if op == 'delete': top = delete(top, key)\n        if op == 'find'  :\n            if find(top, key): print('yes')\n            else           : print('no' )\n        if op == 'print' :\n            inorder(top)\n            print()\n            preorder(top)\n            print()\n\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self,key,priority,left=None,right=None):\n        self.left = left\n        self.right = right\n        self.key = key\n        self.priority = priority\n\ndef insert(t,key,priority):\n    if t == None :\n        return Node(key,priority)\n    if key == t.key :\n        return t\n    if key < t.key :\n        t.left = insert(t.left, key, priority)\n        if t.priority < t.left.priority :\n            t = rightRotate(t)\n    else:\n        t.right = insert(t.right, key, priority)\n        if t.priority < t.right.priority :\n            t = leftRotate(t)\n    return t\n\n\ndef rightRotate(t):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s\n\n\ndef leftRotate(t):\n    s= t.right\n    t.right = s.left\n    s.left = t\n    return s\n\n\ndef find(t,key):\n    if t == None: return None\n    elif t.key == key:return t\n    elif t.key > key :return find(t.left,key)\n    else: return find(t.right,key)\n\ndef erase(t, key):\n    if t == None : return None\n    if key == t.key:\n        if t.left == None and t.right == None:return None\n        elif t.left == None : t = leftRotate(t)\n        elif t.right == None : t = rightRotate(t)\n        else:\n            if t.left.priority > t.right.priority:t = rightRotate(t)\n            else: t = leftRotate(t)\n        return erase(t, key)\n    elif key < t.key : t.left = erase(t.left, key)\n    else : t.right = erase(t.right, key)\n    return t\n\ndef inorder(t):\n    if t.left != None:inorder(t.left)\n    print(\" \"+str(t.key), end='')\n    if t.right != None: inorder(t.right)\n\ndef preorder(t):\n    print(\" \"+str(t.key), end='')\n    if t.left != None :preorder(t.left)\n    if t.right != None : preorder(t.right)\n\nif __name__==\"__main__\":\n        m=(int)(input())\n        root = None\n        for i in range(m):\n            order = input().split()\n            if order[0] == \"insert\" :root = insert(root,(int)(order[1]),(int)(order[2]))\n            elif order[0] == \"delete\" :root = erase(root,(int)(order[1]))\n            elif order[0] == \"find\" :\n                res = find(root,(int)(order[1]))\n                if res == None :print(\"no\")\n                else:print(\"yes\")\n            else:\n                inorder(root)\n                print()\n                preorder(root)\n                print()\n\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self,key,priority):\n        self.key=key\n        self.parent=None\n        self.left=None\n        self.right=None\n        self.priority=priority\n        self.rightflag=-1\n\n\ndef insert(root,node):#rootを根に持つ２分探索木にnodeを追加する\n    if(root.key <= node.key):\n        if(root.right is None):\n            root.right=node\n            node.parent=root\n            node.rightflag=1\n        else:\n            insert(root.right,node)\n    \n    else:\n        if(root.left is None):\n            root.left=node\n            node.parent=root\n            node.rightflag=0\n        else:\n            insert(root.left,node)\n\n\ndef find(root,key):\n    if(root.key==key):\n        return root\n\n    elif(root.key < key):\n        if(root.right is not None):\n            return find(root.right,key)\n        else:\n            return None\n\n    else:\n        if(root.left is not None):\n            return find(root.left,key)\n        else:\n            return None\n\n\n\n\n\n\n\n                   \n            \n        \n\n\n\n    \n\ndef Preorder(root,order):\n    order.append(root.key)\n    if(root.left is not None):\n        Preorder(root.left,order)\n    \n    if(root.right is not None):\n        Preorder(root.right,order)\n\n\n\n\ndef Inorder(root,order):\n    if(root.left is not None):\n        Inorder(root.left,order)\n    \n    order.append(root.key)\n\n\n    if(root.right is not None):\n        Inorder(root.right,order)\n\n\n\ndef right_rotate(node,Root):#nodeのparentの場所にnodeを移動させる(二分木の条件を保ちつつ)\n    if(node.parent==None):#与えられたnodeがrootだった場合0を返す\n        return 0\n    \n    node.parent.left=node.right#NoneでもこれでOk\n    if(node.right is not None):\n        node.right.parent=node.parent\n        node.right.rightflag=0\n    \n\n    if(node.parent.parent is not None):\n        tmp_parent=node.parent.parent\n        node.parent.parent=node\n        node.rightflag=node.parent.rightflag\n        node.parent.rightflag=1\n        node.right=node.parent\n        node.parent=tmp_parent\n        if(node.rightflag):\n            tmp_parent.right=node\n        else:\n            tmp_parent.left=node\n    else:\n        node.parent.parent=node\n        node.rightflag=-1\n        node.parent.rightflag=1\n        node.right=node.parent\n        node.parent=None\n        Root[0]=node\n    \n    return 1\n\n\ndef left_rotate(node,Root):#nodeのparentの場所にnodeを移動させる(二分木の条件を保ちつつ)\n    if(node.parent==None):#与えられたnodeがrootだった場合0を返す\n        return 0\n    \n    node.parent.right=node.left#NoneでもこれでOk\n    if(node.left is not None):\n        node.left.parent=node.parent\n        node.left.rightflag=1\n    \n\n    if(node.parent.parent is not None):\n        tmp_parent=node.parent.parent\n        node.parent.parent=node\n        node.rightflag=node.parent.rightflag\n        node.parent.rightflag=0\n        node.left=node.parent\n        node.parent=tmp_parent\n        if(node.rightflag):\n            tmp_parent.right=node\n        else:\n            tmp_parent.left=node\n    else:\n        node.parent.parent=node\n        node.rightflag=-1\n        node.parent.rightflag=0\n        node.left=node.parent\n        node.parent=None\n        Root[0]=node\n    \n    return 1\n\n\ndef delete(Root,key):\n    if(Root[0] is None):\n        pass\n    else:\n        target=find(Root[0],key)\n        if(target is None):\n            pass\n        else:\n            while( target.left is not None or target.right is not None):\n                if(target.left is not None and target.right is not None):\n                    if(target.left.priority <= target.right.priority):\n                        left_rotate(target.right,Root)\n                    else:\n                        right_rotate(target.left,Root)\n                \n                \n                elif(target.left is not None):\n                    right_rotate(target.left,Root)\n                elif(target.right is not None):\n                    left_rotate(target.right,Root)        \n            \n            if(target.rightflag==1):\n                target.parent.right=None\n            elif(target.rightflag==0):\n                target.parent.left=None\n            else:\n                Root[0]=None\n\n\nn=int(input())\nroot=None\n\nfor loop in range(n):\n    ope=input().split()\n\n    if(ope[0]==\"insert\"):\n        tmp_node=Node(int(ope[1]),int(ope[2]))\n        try:\n            insert(root,tmp_node)\n            Root=[root]\n            while(tmp_node.parent.priority <tmp_node.priority):\n                if(tmp_node.rightflag):\n                    left_rotate(tmp_node,Root)\n                else:\n                    right_rotate(tmp_node,Root)\n            root=Root[0]\n        except:\n            root=tmp_node\n\n    elif(ope[0]==\"rotate\"):\n        if(root is not None):\n            target=find(root,int(ope[1]))\n            if(target is not None):\n                Root=[root]\n                left_rotate(target,Root)\n                root=Root[0]\n    \n    elif(ope[0]==\"find\"):\n        try:\n            if(find(root,int(ope[1])) is not None):\n                print(\"yes\")\n\n            else:\n                print(\"no\")\n        except:\n            print(\"no\")\n    \n    elif(ope[0]==\"delete\"):\n        Root=[root]\n        delete(Root,int(ope[1]))\n        root=Root[0]\n\n    else:\n        in_order=[]\n        p_order=[]\n\n        \n        Inorder(root,in_order)\n        Preorder(root,p_order)\n\n        for x in in_order:\n            print(f\" {x}\",end=\"\")\n            \n        print()\n        for x in p_order:\n            print(f\" {x}\",end=\"\")\n        print()\n\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, key, priority):\n        self.key = key\n        self.priority = priority\n        self.left = None\n        self.right = None\nclass Treap:\n    def __init__(self):\n        self.root = None\n        self.order_list = []\n    def right_rotate(self, t):\n        s = t.left\n        t.left = s.right\n        s.right = t\n        return s\n    def left_rotate(self, t):\n        s = t.right\n        t.right = s.left\n        s.left = t\n        return s\n    def find(self, key):\n        x = self.root\n        while x != None:\n            if key == x.key:\n                return x\n            elif key < x.key:\n                x = x.left\n            else:\n                x = x.right\n        return None\n    def insert(self, t, key, priority):\n        if t == None:\n            return Node(key, priority)\n        if key == t.key:\n            return t\n        if key < t.key:\n            t.left = self.insert(t.left, key, priority)\n            if priority > t.priority:\n                t = self.right_rotate(t)\n        else:\n            t.right = self.insert(t.right, key, priority)\n            if priority > t.priority:\n                t = self.left_rotate(t)\n        return t\n    def delete(self, t, key):\n        if t == None:\n            return None\n        if key < t.key:\n            t.left = self.delete(t.left, key)\n        elif key > t.key:\n            t.right = self.delete(t.right, key)\n        else:\n            return self.__delete(t, key)\n        return t\n    def __delete(self, t, key):\n        if t.left == None and t.right == None:\n            return None\n        elif t.left == None:\n            t = self.left_rotate(t)\n        elif t.right == None:\n            t = self.right_rotate(t)\n        else:\n            if t.left.priority < t.right.priority:\n                t = self.left_rotate(t)\n            else:\n                t = self.right_rotate(t)\n        return self.delete(t, key)\n    def walk_preorder(self, node):\n        if node == None:\n            return None\n        self.order_list.append(node.key)\n        self.walk_preorder(node.left)\n        self.walk_preorder(node.right)\n    def walk_inorder(self, node):\n        if node == None:\n            return None\n        self.walk_inorder(node.left)\n        self.order_list.append(node.key)\n        self.walk_inorder(node.right)\n    def print_nodes(self):\n        self.order_list = []\n        self.walk_inorder(self.root)\n        inorder_str = ' '.join(map(str, self.order_list))\n        print(' {}'.format(inorder_str))\n        self.order_list = []\n        self.walk_preorder(self.root)\n        preorder_str = ' '.join(map(str, self.order_list))\n        print(' {}'.format(preorder_str))\nn = int(input())\ntree = Treap()\nfor _ in range(n):\n    command = input().split(' ')\n    if len(command) == 1:\n        tree.print_nodes()\n    elif len(command) == 2:\n        opecode, key = command[0], int(command[1])\n        if opecode == 'delete':\n            tree.root = tree.delete(tree.root, key)\n        elif opecode == 'find':\n            if tree.find(key) != None:\n                print('yes')\n            else:\n                print('no')\n    else:\n        opecode, key, priority = command[0], int(command[1]), int(command[2])\n        tree.root = tree.insert(tree.root, key, priority)\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, key:int, priority:int):\n        self.key = key\n        self.priority = priority\n        self.left = None\n        self.right = None\n\nclass Tree:\n    def __init__(self):\n        self.root = None\n\n    def leftRotate(self, t:Node):\n        s:Node = t.right\n        t.right = s.left\n        s.left = t\n        if t.key == self.root.key:\n            self.root = s\n        return s\n\n    def rightRotate(self, t:Node):\n        s:Node = t.left\n        t.left = s.right\n        s.right = t\n        if t.key == self.root.key:\n            self.root = s        \n        return s\n\n    def insert(self, t:Node, key:int, priority:int):\n        if not self.root:\n            self.root = Node(key, priority)\n            return self.root\n        if not t:\n            return Node(key, priority)\n        if key == t.key:\n            return t\n        if key < t.key:\n            t.left = self.insert(t.left, key, priority)\n            if t.priority < t.left.priority:\n                t = self.rightRotate(t)\n        else:\n            t.right = self.insert(t.right, key, priority)\n            if t.priority < t.right.priority:\n                t = self.leftRotate(t)\n        return t\n\n    def delete(self, t:Node, key:int):\n        if not t:\n            return None\n        if key < t.key:\n            t.left = self.delete(t.left, key)\n        elif key > t.key:\n            t.right = self.delete(t.right, key)\n        else:\n            return self._delete(t, key)\n        return t\n\n    def _delete(self, t:Node, key:int):\n        if not t.left and not t.right:\n            return None\n        elif not t.left:\n            t = self.leftRotate(t)\n        elif not t.right:\n            t = self.rightRotate(t)\n        else:\n            if t.left.priority > t.right.priority:\n                t = self.rightRotate(t)\n            else:\n                t = self.leftRotate(t)\n        return self.delete(t, key)\n\n\ndef Preorder(target:Node):\n    yield target.key\n    if target.left != None:\n        yield from Preorder(target.left)\n    if target.right != None:\n        yield from Preorder(target.right)\n\ndef Inorder(target:Node):\n    if target.left != None:\n        yield from Inorder(target.left)\n    yield target.key\n    if target.right != None:\n        yield from Inorder(target.right)\n\ndef find(target:Node,findkey:int):\n    return node_of_key(target, findkey) != None\n\ndef node_of_key(target:Node,findkey:int):\n    if target.key == findkey:\n        return target\n    elif target.key > findkey:\n        if target.left:\n            return node_of_key(target.left, findkey)\n    else:\n        if target.right:\n            return node_of_key(target.right, findkey)\n    return None\n\ndef min_value_node_of_tree(root:Node):\n    if root.left == None:\n        return root\n    else:\n        return min_value_node_of_tree(root.left)\n\n\nfrom sys import stdin\ntree = Tree()\nn = int(input())\nlines = stdin.readlines()\nfor line in lines:\n    proc,*param = line.split()\n    if proc == \"insert\":\n        if not tree.root:\n            tree.root = Node(int(param[0]), int(param[1]))\n        else:\n            tree.insert(tree.root, int(param[0]), int(param[1]))\n    elif proc == \"find\":\n        print(\"yes\" if find(tree.root, int(param[0])) else \"no\")\n    elif proc == \"delete\":\n        tree.delete(tree.root, int(param[0]))\n    else:\n        print(\" \",end=\"\")\n        print(*Inorder(tree.root))\n        print(\" \",end=\"\")\n        print(*Preorder(tree.root))\n"
  },
  {
    "language": "Python",
    "code": "# Treap\nclass Node():\n    def __init__(self, k, p):\n        self.k = k\n        self.p = p\n        self.left = None\n        self.right = None\n\ndef rightRotate(t):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s\n\ndef leftRotate(t):\n    s = t.right\n    t.right = s.left\n    s.left = t\n    return s\n\ndef insert(t, key, pri):\n    if t == None:\n        return Node(key, pri)\n    if key == t.k:\n        return t\n\n    if key < t.k:\n        t.left = insert(t.left, key, pri)\n        if t.p < t.left.p:\n            t = rightRotate(t)\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.p < t.right.p:\n            t = leftRotate(t)\n    return t\n\ndef erase(t, key):\n    if t == None:\n        return None\n\n    if key == t.k:\n        if t.left == None and t.right == None:\n            return None\n        elif t.left == None:\n            t = leftRotate(t)\n        elif t.right == None:\n            t = rightRotate(t)\n        else:\n            if t.left.p > t.right.p:\n                t = rightRotate(t)\n            else:\n                t = leftRotate(t)\n        return erase(t, key)\n\n    if key < t.k:\n        t.left = erase(t.left, key)\n    else:\n        t.right = erase(t.right, key)\n    return t\n\ndef inorder(t):\n    if t == None:\n        return \n    inorder(t.left)\n    print(\" \" + str(t.k), end=\"\")\n    inorder(t.right)\n\ndef preorder(t):\n    if t == None:\n        return\n    print(\" \" + str(t.k), end=\"\")\n    preorder(t.left)\n    preorder(t.right)\n\ndef output(t):\n    inorder(t)\n    print()\n    preorder(t)\n    print()\n\n\nt = None\ndata = []\ndict = {}\nm = int(input())\nfor i in range(m):\n    data.append(list(input().split()))\n\nfor i in range(m):\n    if data[i][0] == \"insert\":\n        if (data[i][1] in dict) == False:\n            t = insert(t, int(data[i][1]), int(data[i][2]))\n            dict[data[i][1]] = True\n    elif data[i][0] == \"print\":\n        output(t)\n    elif data[i][0] == \"find\":\n        if (data[i][1] in dict) == True:\n            print(\"yes\")\n        else:\n            print(\"no\")\n    else:\n        t = erase(t, int(data[i][1]))\n        if (data[i][1] in dict) == True:\n            del dict[data[i][1]]\n"
  },
  {
    "language": "Python",
    "code": "import sys, collections\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = 10**10\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\nclass Node():\n    key = None\n    priority = None\n    p = None\n    left = None\n    right = None\n\n    def __init__(self, key, priority):\n        self.key = key\n        self.priority = priority\n\nclass BinarySearchTree():\n    root = None\n\n    def rightRotate(self, t):\n        s = t.left\n        t.left = s.right\n        s.right = t\n        return s\n\n    def leftRotate(self, t):\n        s = t.right\n        t.right = s.left\n        s.left = t\n        return s\n\n    def insert(self, t, key, priority):\n        if t is None:\n            return Node(key, priority)\n        if key==t.key:\n            return t\n\n        if key < t.key:\n            t.left = self.insert(t.left, key, priority)\n            if t.priority < t.left.priority:\n                t = self.rightRotate(t)\n        else:\n            t.right = self.insert(t.right, key, priority)\n            if t.priority < t.right.priority:\n                t = self.leftRotate(t)\n        \n        return t\n\n    def find(self, k):\n        x = self.root\n        while x is not None:\n            if x.key==k:\n                return x\n            elif x.key>k:\n                x = x.left\n            else:\n                x = x.right\n        return None\n\n    def next_node(self, z):\n        if z.right is None:\n            x = z\n            y = z.p\n            while y is not None and y.left!=x:\n                x = y\n                y = y.p\n            return y\n        else:\n            x = z.right\n            while x is not None:\n                y = x\n                x = x.left\n            return y\n\n    def delete(self, t, key):\n        if t is None:\n            return None\n        if key < t.key:\n            t.left = self.delete(t.left, key)\n        elif key > t.key:\n            t.right = self.delete(t.right, key)\n        else:\n            return self._delete(t, key)\n        return t\n\n    def _delete(self, t, key):\n        if t.left is None and t.right is None:\n            return None\n        elif t.left is None:\n            t = self.leftRotate(t)\n        elif t.right is None:\n            t = self.rightRotate(t)\n        else:\n            if t.left.priority > t.right.priority:\n                t = self.rightRotate(t)\n            else:\n                t = self.leftRotate(t)\n        return self.delete(t, key)\n            \n    def print_nodes(self):\n        inorder = []\n        preorder = []\n\n        def dfs(v):\n            v_key = v.key\n            preorder.append(v_key)\n            if v.left is not None:\n                dfs(v.left)\n            inorder.append(v_key)\n            if v.right is not None:\n                dfs(v.right)\n\n        dfs(self.root)\n\n        print('', *inorder)\n        print('', *preorder)\n\ndef resolve():\n    m = I()\n    T = BinarySearchTree()\n    for _ in range(m):\n        q = LSS()\n        if q[0]=='insert':\n            k = int(q[1])\n            p = int(q[2])\n            T.root = T.insert(T.root, k, p)\n        elif q[0]=='find':\n            k = int(q[1])\n            if T.find(k):\n                print('yes')\n            else:\n                print('no')\n        elif q[0]=='delete':\n            k = int(q[1])\n            T.root = T.delete(T.root, k)\n        else:\n            T.print_nodes()\n\nif __name__ == '__main__':\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "def lrotate(t):\n    s = t.right\n    t.right = s.left\n    s.left = t\n    return s\n\ndef rrotate(t):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s\n\ndef insert(t, key, pri):\n    if t == None:\n        return Treap(key, pri)\n    if key == t.key:\n        return t\n\n    if key < t.key:\n        t.left = insert(t.left, key, pri)\n        if t.pri < t.left.pri:\n            t = rrotate(t)\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.pri < t.right.pri:\n            t = lrotate(t)\n    return t\n\ndef delete(t, key):\n    if t == None:\n        return None\n\n    if key == t.key:\n        if t.left == None and t.right == None:\n            return None\n        elif t.left == None:\n            t = lrotate(t)\n        elif t.right == None:\n            t = rrotate(t)\n        else:\n            if t.left.pri > t.right.pri:\n                t = rrotate(t)\n            else:\n                t = lrotate(t)\n        return delete(t, key)\n\n    if key < t.key:\n        t.left = delete(t.left, key)\n    else:\n        t.right = delete(t.right, key)\n    return t\n\ndef find(t, key):\n    if t == None:\n        return -1\n    if t.key == key:\n        return 1\n    if key < t.key:\n        return find(t.left, key)\n    else:\n        return find(t.right, key)\n    \ndef inorder(t):\n    if t == None:\n        return \n    inorder(t.left)\n    print(\" \" + str(t.key), end=\"\")\n    inorder(t.right)\n\ndef preorder(t):\n    if t == None:\n        return\n    print(\" \" + str(t.key), end=\"\")\n    preorder(t.left)\n    preorder(t.right)\n\n\n\nclass Treap():\n    def __init__(self, key, pri):\n        self.key = key\n        self.pri = pri\n        self.left = None\n        self.right = None\n        \nt = None\ndata = []\nm = int(input())\nfor i in range(m):\n    data.append(list(input().split()))\n\nfor i in range(m):\n    if data[i][0] == \"insert\":\n        t = insert(t, int(data[i][1]), int(data[i][2]))\n    elif data[i][0] == \"delete\":\n        t = delete(t, int(data[i][1]))\n    elif data[i][0] == \"find\":\n        result = find(t, int(data[i][1]))\n        if result == 1:\n            print(\"yes\")\n        else:\n            print(\"no\")\n    else:\n        inorder(t)\n        print()\n        preorder(t)\n        print()\n\n\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, key, pri):\n        self.key = key\n        self.pri = pri\n        self.left  = None\n        self.right = None\n\n\ndef rightRotate(t):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s\n\ndef leftRotate(t):\n    s = t.right\n    t.right = s.left\n    s.left = t\n    return s\n\ndef insert(t, key, pri):\n    if t == None:\n        return Node(key, pri)\n\n    if key == t.key:\n        return t\n\n    if key < t.key:\n        t.left = insert(t.left, key, pri)\n        if t.pri < t.left.pri:\n            t = rightRotate(t)\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.pri < t.right.pri:\n            t = leftRotate(t)\n\n    return t\n\n\ndef delete(t, key):\n    if   t == None:\n        return None\n\n    if   key < t.key:\n        t.left  = delete(t.left , key)\n    elif key > t.key:\n        t.right = delete(t.right, key)\n    else:\n        return _delete(t, key)\n    return t\n\n\ndef _delete(t, key):\n    if t.left == None and t.right == None:\n        return None\n    elif t.left  == None:\n        t = leftRotate(t)\n    elif t.right == None:\n        t = rightRotate(t)\n    else:\n        if t.left.pri > t.right.pri:\n            t = rightRotate(t)\n        else:\n            t = leftRotate(t)\n    return delete(t, key)\n\n\ndef find(t, key):\n    if t == None:\n        return False\n\n    if key == t.key:\n        return True\n\n    if key < t.key:\n        return find(t.left, key)\n    else:\n        return find(t.right, key)\n\ndef priorder(t):\n    if t == None:\n        return\n\n    print(' ' + str(t.key), end='')\n    priorder(t.left)\n    priorder(t.right)\n\ndef inorder(t):\n    if t == None:\n        return\n\n    inorder(t.left)\n    print(' ' + str(t.key), end='')\n    inorder(t.right)\n\n\nm = int(input())\nt = None\n\nfor _ in range(m):\n    com = input().split()\n\n    if com[0] == 'insert':\n        t = insert(t, int(com[1]), int(com[2]))\n    elif com[0] == 'find':\n        if find(t, int(com[1])):\n            print('yes')\n        else :\n            print('no')\n    elif com[0] == 'delete':\n        t = delete(t, int(com[1]))\n    elif com[0] == 'print':\n        inorder(t)\n        print()\n        priorder(t)\n        print()\n\n"
  },
  {
    "language": "Python",
    "code": "# Treap\nclass Node():\n    def __init__(self, k, p):\n        self.k = k\n        self.p = p\n        self.left = None\n        self.right = None\n\ndef rightRotate(t):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s\n\ndef leftRotate(t):\n    s = t.right\n    t.right = s.left\n    s.left = t\n    return s\n\ndef insert(t, key, pri):\n    if t == None:\n        return Node(key, pri)\n    if key == t.k:\n        return t\n\n    if key < t.k:\n        t.left = insert(t.left, key, pri)\n        if t.p < t.left.p:\n            t = rightRotate(t)\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.p < t.right.p:\n            t = leftRotate(t)\n    return t\n\ndef erase(t, key):\n    if t == None:\n        return None\n\n    if key == t.k:\n        if t.left == None and t.right == None:\n            return None\n        elif t.left == None:\n            t = leftRotate(t)\n        elif t.right == None:\n            t = rightRotate(t)\n        else:\n            if t.left.p > t.right.p:\n                t = rightRotate(t)\n            else:\n                t = leftRotate(t)\n        return erase(t, key)\n\n    if key < t.k:\n        t.left = erase(t.left, key)\n    else:\n        t.right = erase(t.right, key)\n    return t\n\ndef find(t, k):\n    if t == None:\n        return -1\n    if t.k == k:\n        return 1\n    if k < t.k:\n        return find(t.left, k)\n    else:\n        return find(t.right, k)\n\ndef inorder(t):\n    if t == None:\n        return \n    inorder(t.left)\n    print(\" \" + str(t.k), end=\"\")\n    inorder(t.right)\n\ndef preorder(t):\n    if t == None:\n        return\n    print(\" \" + str(t.k), end=\"\")\n    preorder(t.left)\n    preorder(t.right)\n\ndef output(t):\n    inorder(t)\n    print()\n    preorder(t)\n    print()\n\n\nt = None\ndata = []\nm = int(input())\nfor i in range(m):\n    data.append(list(input().split()))\n\nfor i in range(m):\n    if data[i][0] == \"insert\":\n        t = insert(t, int(data[i][1]), int(data[i][2]))\n    elif data[i][0] == \"print\":\n        output(t)\n    elif data[i][0] == \"find\":\n        result = find(t, int(data[i][1]))\n        if result == 1:\n            print(\"yes\")\n        else:\n            print(\"no\")\n    else:\n        t = erase(t, int(data[i][1]))\n"
  },
  {
    "language": "Python",
    "code": "class node:\n    def __init__(self,key,pri,left=None,right=None):\n        self.left = left\n        self.right = right\n        self.key = key\n        self.pri = pri\n\ndef insert(n,key,pri):\n    if(n == None):\n        return node(key,pri)\n    if(key == n.key):\n        return n\n    if(key < n.key):\n        n.left = insert(n.left, key, pri)\n        if(n.pri < n.left.pri):\n            n = rightRotate(n)\n    else:\n        n.right = insert(n.right, key, pri)\n        if(n.pri < n.right.pri):\n            n = leftRotate(n)\n    return n\n\ndef rightRotate(n):\n    swapL,swapK,swapP = n.left.left,n.left.key,n.left.pri\n    n.left = None\n    n = node(swapK,swapP,swapL,n)\n    return n\n\ndef leftRotate(n):\n    swapR,swapK,swapP = n.right.right,n.right.key,n.right.pri\n    n.right = None\n    n = node(swapK,swapP,n,swapR)\n    return n\n\ndef find(n,key):\n    if(n == None):\n        return None\n    elif(n.key == key):\n        return n\n    elif(n.key > key):\n        return find(n.left,key)\n    else:\n        return find(n.right,key)\n\ndef delete(n, key):\n    if(n == None):\n        return None\n    if(key < n.key):\n        n.left = delete(n.left, key)\n    elif(key > n.key):\n        n.right = delete(n.right, key)\n    else:\n        return _delete(n, key)\n    return n\n\ndef _delete(n, key):\n    if(n.left == None and n.right == None):\n        return None\n    elif(n.left == None):\n        n = leftRotate(n)\n    elif(n.right == None):\n        n = rightRotate(n)\n    else:\n        if(n.left.pri > n.right.pri):\n            n = rightRotate(n)\n        else:\n            n = leftRotate(n)\n    return delete(n, key)\n\ndef inorder(n):\n    if(n==None):\n        return\n    if(n.left != None):\n        inorder(n.left)\n    print(\" \"+str(n.key), end='')\n    if(n.right != None):\n        inorder(n.right)\n\ndef preorder(n):\n    if(n==None):\n        return\n    print(\" \"+str(n.key), end='')\n    if(n.left != None):\n        preorder(n.left)\n    if(n.right != None):\n        preorder(n.right)\n\nop_num=(int)(input())\nroot = None\nfor i in range(op_num):\n    items = input().split()\n    if(items[0] == \"insert\"):\n        root = insert(root,(int)(items[1]),(int)(items[2]))\n    elif(items[0] == \"delete\"):\n        root = delete(root,(int)(items[1]))\n    elif(items[0] == \"find\"):\n        res = find(root,(int)(items[1]))\n        if(res == None):\n            print(\"no\")\n        else:\n            print(\"yes\")\n    else:\n        inorder(root)\n        print(\"\")\n        preorder(root)\n        print(\"\")\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef rotate(nd, d):\n    c = nd[d]\n    if d:\n        nd[1] = c[0]\n        c[0] = nd\n    else:\n        nd[0] = c[1]\n        c[1] = nd\n    return c\n\n\nroot = None\ndef insert(val, pri):\n    global root\n    st = []\n    dr = []\n    x = root\n    while x:\n        st.append(x)\n        if x[2] == val:\n            return\n        d = (x[2] < val)\n        dr.append(d)\n        x = x[d]\n    nd = [None, None, val, pri]\n    while st:\n        x = st.pop(); d = dr.pop()\n        c = x[d] = nd\n        if x[3] >= c[3]:\n            break\n        rotate(x, d)\n    else:\n        root = nd\n\ndef __delete(nd):\n    st = []; dr = []\n    while nd[0] or nd[1]:\n        l = nd[0]; r = nd[1]\n        d = (l[3] <= r[3]) if l and r else (l is None)\n        st.append(rotate(nd, d))\n        dr.append(d ^ 1)\n    nd = x = None\n    while st:\n        nd = x; x = st.pop(); d = dr.pop()\n        x[d] = nd\n    return x\n\ndef delete(val):\n    global root\n    x = root\n\n    y = None\n    while x:\n        if val == x[2]:\n            break\n        y = x; d = (x[2] < val)\n        x = x[d]\n    else:\n        return\n\n    if y:\n        y[d] = __delete(x)\n    else:\n        root = __delete(x)\n\ndef find(val):\n    x = root\n    while x:\n        if val == x[2]:\n            return 1\n        x = x[x[2] < val]\n    return 0\n\ndef debug():\n    s0 = [\"\"]\n    s1 = [\"\"]\n\n    def dfs(nd):\n        v = str(nd[2])\n        s0.append(v)\n        if nd[0]:\n            dfs(nd[0])\n        s1.append(v)\n        if nd[1]:\n            dfs(nd[1])\n    dfs(root)\n    return \" \".join(s1), \" \".join(s0)\n\n\nM = int(readline())\nans = []\nfor m in range(M):\n    cmd, *V, = readline().split()\n    if cmd == \"print\":\n        ans.extend(debug())\n    elif cmd == \"find\":\n        ans.append(\"yes\" if find(int(V[0])) else \"no\")\n    elif cmd == \"delete\":\n        delete(int(V[0]))\n    else:\n        val, pri = map(int, V)\n        insert(val, pri)\nwrite(\"\\n\".join(ans))\nwrite(\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "NIL = -1\n\n\nclass Node():\n    __slots__ = [\"key\", \"parent\", \"left\", \"right\"]\n\n    def __init__(self, key=NIL):\n        self.key = key\n        self.parent = NIL\n        self.left = NIL\n        self.right = NIL\n\nclass NodeHeap(Node):\n    __slots__ = [\"priority\"]\n\n    def __init__(self,key=NIL, priority=NIL):\n        super().__init__(key)\n        self.priority = priority\n\nclass BinaryTree():\n    def __init__(self):\n        self.root = NIL\n\n    def _isnil(self, x):\n        if isinstance(x, int):\n            return True\n        else:\n            return False\n\n    def insert(self, key):\n        if self.root == NIL:\n            self.root = Node(key)\n            return\n\n        now = self.root\n        while now != NIL:\n            parent = now\n            if   key < now.key:\n                now = now.left\n            elif key > now.key:\n                now = now.right\n            else:\n                raise\n\n        insert = self.get_newnode(key)\n        insert.parent = parent\n\n        if   insert.key < parent.key:\n            parent.left = insert\n        elif insert.key > parent.key:\n            parent.right = insert\n        else:\n            raise\n\n    def find(self, key):\n        now = self.root\n        while now != NIL and now.key != key:\n            if   key < now.key:\n                now = now.left\n            elif key > now.key:\n                now = now.right\n            else:\n                raise\n\n        return now\n\n    def delete(self, key):\n        z = self.find(key)\n        if self._isnil(z):\n            return\n\n        if z.left == NIL or z.right == NIL:\n            y = z\n        else:\n            y = self.get_successor(z)\n\n        if y.left != NIL:\n            x = y.left\n        else:\n            x = y.right\n\n        if x != NIL:\n            x.parent = y.parent\n\n        if y.parent == NIL:\n            # delete:root\n            self.root = x\n        elif y == y.parent.left:\n            y.parent.left = x\n        else:\n            y.parent.right = x\n\n        if y != z:\n            z.key = y.key\n\n    def get_successor(self, z):\n        if z.right != NIL:\n            return self.get_minimum(z.right)\n\n        y = z.parent\n        while y != NIL and z == y.right:\n            z = y\n            y = y.parent\n\n        return y\n\n    def get_minimum(self, x):\n        while x.left != NIL:\n            x = x.left\n\n        return x\n\n    def print_inorder(self):\n        self._treewalk_inorder(self.root)\n        print()\n\n    def _treewalk_inorder(self, node):\n        if self._isnil(node):\n            return\n\n        self._treewalk_inorder(node.left)\n        print(f\" {node.key}\", end=\"\")\n        self._treewalk_inorder(node.right)\n\n    def print_preorder(self):\n        self._treewalk_preorder(self.root)\n        print()\n\n    def _treewalk_preorder(self, node):\n        if self._isnil(node):\n            return\n\n        print(f\" {node.key}\", end=\"\")\n        self._treewalk_preorder(node.left)\n        self._treewalk_preorder(node.right)\n\nclass Treap(BinaryTree):\n    def __init__(self):\n        self.root = NIL\n\n    def _right_rotate(self, t):\n        s = t.left\n        t.left = s.right\n        s.right = t\n        return s\n\n    def _left_rotate(self, t):\n        s = t.right\n        t.right = s.left\n        s.left = t\n        return s\n\n    def insert(self, key, priority):\n        self.root = self._insert_main(self.root, key, priority)\n\n    def _insert_main(self, node, key, priority):\n        if node == NIL:\n            return NodeHeap(key, priority)\n\n        if   key > node.key:\n            node.right = self._insert_main(node.right, key, priority)\n            if node.priority < node.right.priority:\n                node = self._left_rotate(node)\n        elif key < node.key:\n            node.left = self._insert_main(node.left, key, priority)\n            if node.priority < node.left.priority:\n                node = self._right_rotate(node)\n        else:\n            raise\n\n        return node\n\n    def delete(self, key):\n        self.root = self._delete_main(self.root, key)\n\n    def _delete_main(self, node, key):\n        if node == NIL:\n            return node\n\n        if key < node.key:\n            node.left = self._delete_main(node.left, key)\n        elif key > node.key:\n            node.right = self._delete_main(node.right, key)\n        else:\n            return self._delete_rotate(node, key)\n\n        return node\n\n    def _delete_rotate(self, node, key):\n        if node.left == NIL and node.right == NIL:\n            return NIL\n        elif node.left == NIL:\n            node = self._left_rotate(node)\n        elif node.right == NIL:\n            node = self._right_rotate(node)\n        else:\n            if node.left.priority > node.right.priority:\n                node = self._right_rotate(node)\n            else:\n                node = self._left_rotate(node)\n\n        return self._delete_main(node, key)\n\n\nm = int(input())\n\ntreap = Treap()\n\nfor _ in range(m):\n\n    command, *list_num = input().split()\n\n    if   command == \"insert\":\n        k = int(list_num[0])\n        p = int(list_num[1])\n        treap.insert(k, p)\n    elif command == \"find\":\n        k = int(list_num[0])\n        if isinstance(treap.find(k), int):\n            print(\"no\")\n        else:\n            print(\"yes\")\n    elif command == \"delete\":\n        k = int(list_num[0])\n        treap.delete(k)\n    elif command == \"print\":\n        treap.print_inorder()\n        treap.print_preorder()\n    else:\n        raise\n\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, key, pri):\n        self.key = key\n        self.pri = pri\n        self.left  = None\n        self.right = None\n\n\ndef rRotate(t):\n    s       = t.left\n    t.left  = s.right\n    s.right = t\n\n    return s\n\n\ndef lRotate(t):\n    s       = t.right\n    t.right = s.left\n    s.left  = t\n\n    return s\n\n\ndef insert(t, key, pri):\n    if t == None: return Node(key, pri)\n\n    if key == t.key: return t\n\n    if key < t.key:\n        t.left = insert(t.left , key, pri)\n        if t.pri < t.left.pri : t = rRotate(t)\n\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.pri < t.right.pri: t = lRotate(t)\n\n    return t\n\n\ndef delete(t, key):\n    if   t == None:\n        return None\n    if   key < t.key:\n        t.left  = delete(t.left , key)\n    elif key > t.key:\n        t.right = delete(t.right, key)\n    else:\n        return _delete(t, key)\n    return t\n\n\ndef _delete(t, key):\n    if t.left == None and t.right == None:\n        return None\n    elif t.left  == None:\n        t = lRotate(t)\n    elif t.right == None:\n        t = rRotate(t)\n    else:\n        if t.left.pri > t.right.pri:\n            t = rRotate(t)\n        else:\n            t = lRotate(t)\n    return delete(t, key)\n\n\ndef find(t, key):\n    if(t == None): return False\n    if(t.key == key): return True\n    if(t.key >  key): return find(t.left , key)\n    else            : return find(t.right, key)\n\ndef preorder(t):\n    if(t == None): return\n\n    print('', t.key, end='')\n    preorder(t.left )\n    preorder(t.right)\n\n\ndef inorder(t):\n    if(t == None): return\n\n    inorder(t.left )\n    print('', t.key, end='')\n    inorder(t.right)\n\n\nif __name__ == '__main__':\n    n = int(input())\n    top = None\n\n    for _ in range(n):\n        strs = input().split()\n\n        op  = strs[0]\n        if op != 'print':\n            key = int(strs[1])\n            if op == 'insert':\n                pri = int(strs[2])\n\n        if op == 'insert': top = insert(top, key, pri)\n        if op == 'delete': top = delete(top, key)\n        if op == 'find'  :\n            if find(top, key): print('yes')\n            else           : print('no' )\n        if op == 'print' :\n            inorder(top)\n            print()\n            preorder(top)\n            print()\n\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, key, priority):\n        self.key = key\n        self.priority = priority\n        self.parent = None\n        self.left = self.right = None\n    def preorder(self):\n        L = [self.key]\n        if self.left: L += self.left.preorder()\n        if self.right: L += self.right.preorder()\n        return L\n    def inorder(self):\n        L = []\n        if self.left: L += self.left.inorder()\n        L.append(self.key)\n        if self.right: L += self.right.inorder()\n        return L\n\ndef rightRotate(t):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s # root of the subtree\ndef leftRotate(t):\n    s = t.right\n    t.right = s.left\n    s.left = t\n    return s # root of the subtree\n\ndef insert(t, key, priority):\n    if not t:\n        return Node(key, priority) # 葉に到達したら新しい節点を生成して返す\n    if key == t.key:\n        return t # 重複したkeyは無視\n    if key < t.key: # 左の子に移動\n        t.left = insert(t.left, key, priority) # 左の子へのポインタを更新\n        if t.priority < t.left.priority: # 左の子の方が優先度が高い場合右回転\n            t = rightRotate(t)\n    else: # 右の子へ移動\n        t.right = insert(t.right, key, priority) # 右の子へのポインタを更新\n        if t.priority < t.right.priority: # 右の子の方が優先度が高い場合左回転\n            t = leftRotate(t)\n    return t\n\ndef delete(t, key):\n    if not t:\n        return None\n    if key < t.key: # 削除対象を検索\n        t.left = delete(t.left, key)\n    elif key > t.key:\n        t.right = delete(t.right, key)\n    else:\n        return _delete(t, key)\n    return t\ndef _delete(t, key):\n    if not t.left and not t.right: # 葉の場合\n        return None\n    if not t.left: # 右の子のみを持つ場合左回転\n        t = leftRotate(t)\n    elif not t.right: # 左の子のみを持つ場合右回転\n        t = rightRotate(t)\n    else: # 左の子と右の子を両方持つ場合、優先度が高い方を持ち上げる\n        if t.left.priority > t.right.priority:\n            t = rightRotate(t)\n        else:\n            t = leftRotate(t)\n    return delete(t, key)\n\ndef find(t, k):\n    x = t\n    while x:\n        if x.key == k:\n            return x\n        x = x.left if k < x.key else x.right\n    return None\n\nt = None\nm = int(input())\nfor _ in range(m):\n    cmd = list(input().split())\n    if cmd[0] == 'insert':\n        t = insert(t, int(cmd[1]), int(cmd[2]))\n    if cmd[0] == 'find':\n        print('yes' if find(t, int(cmd[1])) else 'no')\n    if cmd[0] == 'delete':\n        t = delete(t, int(cmd[1]))\n    if cmd[0] == 'print':\n        print('', *t.inorder())\n        print('', *t.preorder())\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nprint = sys.stdout.write\n\nclass Node:\n    __slots__ = [\"key\", \"priority\", \"left\", \"right\"]\n    def __init__(self, key, priority):\n        self.key = key\n        self.priority = priority\n        self.left = None\n        self.right = None\n        \nclass Treap:\n    def insert(self, node, key, priority):\n        if node is None:\n            return Node(key, priority)\n        if key == node.key:\n            return node\n        if key < node.key:\n            node.left = self.insert(node.left, key, priority)\n            if node.priority < node.left.priority:\n                node = right_rotate(node)\n        else:\n            node.right = self.insert(node.right, key, priority)\n            if node.priority < node.right.priority:\n                node = left_rotate(node)\n        return node\n\n    def delete(self, node, key):\n        if node is None:\n            return None\n        if key < node.key:\n            node.left = self.delete(node.left, key)\n        elif key > node.key:\n            node.right = self.delete(node.right, key)\n        else:\n            return self._delete(node, key)\n        return node\n    \n    def _delete(self, node, key):\n        if node.left is None and node.right is None:\n            return None\n        if node.left is None:\n            node = left_rotate(node)\n        elif node.right is None:\n            node = right_rotate(node)\n        else:\n            if node.left.priority > node.right.priority:\n                node = right_rotate(node)\n            else:\n                node = left_rotate(node)\n        return self.delete(node, key)\n    \n    def find(self, node, key):\n        if node is None:\n            print(\"no\\n\")\n            return\n        while node:\n            if node.key == key:\n                print(\"yes\\n\")\n                return\n            node = node.left if key < node.key else node.right\n        print(\"no\\n\")\n        return\n            \n\ndef right_rotate(node):\n    child = node.left\n    node.left, child.right = child.right, node\n    return child\n\ndef left_rotate(node):\n    child = node.right\n    node.right, child.left = child.left, node\n    return child\n\ndef print_preorder(node):\n    print(\" {}\".format(node.key))\n    if node.left:\n        print_preorder(node.left)\n    if node.right:\n        print_preorder(node.right)\n\ndef print_inorder(node):\n    if node.left:\n        print_inorder(node.left)\n    print(\" {}\".format(node.key))\n    if node.right:\n        print_inorder(node.right)\n\nif __name__ == \"__main__\":\n    n = int(input())\n    treap = Treap()\n    root = None\n    for _ in range(n):\n        operation, *num = input().split()\n        if operation[0] == \"i\":\n            root = treap.insert(root, int(num[0]), int(num[1]))\n        elif operation[0] == \"f\":\n            treap.find(root, int(num[0]))\n        elif operation[0] == \"d\":\n            root = treap.delete(root, int(num[0]))\n        elif root is not None:\n            print_inorder(root)\n            print(\"\\n\")\n            print_preorder(root)\n            print(\"\\n\")\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, key, priority):\n        self.key = key\n        self.priority = priority\n        self.parent = None\n        self.left = None\n        self.right = None\n\n# 根\nparent_node = None    \n    \n# カウンター\ncounter = 0\n        \ndef getRoot(u):\n    while u.parent != None:\n        u = u.parent\n    return u\n\n\ndef printPreorder(u):\n    if u == None:\n        return\n    print(\" \", u.key, sep=\"\", end=\"\")\n    printPreorder(u.left)\n    printPreorder(u.right)\n\n    \ndef printInorder(u):\n    if u == None:\n        return\n    printInorder(u.left)\n    print(\" \", u.key, sep=\"\", end=\"\")\n    printInorder(u.right)\n\n    \ndef find(u, num):\n    while u != None and u.key != num:\n        if num < u.key:\n            u = u.left\n        else:\n            u = u.right\n    if u != None:\n        print(\"yes\")\n    else:\n        print(\"no\")\n\n\ndef rightRotate(u):\n    # print(\"right\")\n    s = u.left\n    u.left = s.right\n    # 親の更新\n    if u.left != None:\n        u.left.parent = u\n    \n    s.right = u \n    # 親の更新\n    s.parent = u.parent\n    u.parent = s\n    return s\n\ndef leftRotate(u):\n    # print(\"left\")\n    s = u.right\n    u.right = s.left\n    # 親の更新\n    if u.right != None:\n        u.right.parent = u\n    \n    s.left = u\n    # 親の更新\n    s.parent = u.parent\n    u.parent = s\n    return s\n\n        \ndef insert(u, key, priority):\n    # print(\"insert 1\")\n    global parent_node\n    global counter\n    if u == None:\n        s = Nodes[counter]\n        # カウンターの増加\n        counter += 1\n        s.key = key\n        s.priority = priority\n        # 根のノードの更新\n        if parent_node == None:\n            parent_node = s\n        return s\n    \n    if key == u.key:\n        return u\n    \n    if key < u.key:\n        u.left = insert(u.left, key, priority)\n        # 親の更新\n        u.left.parent = u\n        if u.priority < u.left.priority:\n            u = rightRotate(u)\n    else:\n        u.right = insert(u.right, key, priority)\n        # 親の更新\n        u.right.parent = u\n        if u.priority < u.right.priority:\n            u = leftRotate(u)\n    \n    return u\n    \n\ndef delete(u, key):\n    # print(\"delete\")\n    if u == None:\n        return None\n    if key < u.key:\n        u.left = delete(u.left, key)\n    elif key > u.key:\n        u.right = delete(u.right, key)\n    else:\n        return _delete(u, key)\n    return u\n\n\ndef _delete(u, key):\n    # print(\"_delete\")\n    if u.left == None and u.right == None:\n        return None\n    elif u.left == None:\n        u = leftRotate(u)\n    elif u.right == None:\n        u = rightRotate(u)\n    else:\n        if u.left.priority > u.right.priority:\n            u = rightRotate(u)\n        else:\n            u = leftRotate(u)\n    return delete(u, key)\n    \n    \nn = int(input())\n\n# メモリの確保\nNodes = []\nfor i in range(n):\n    tmp_node = Node(0, 0)\n    Nodes.append(tmp_node)\n\n\n\nfor i in range(n):\n    cmd = input().split()\n    if cmd[0] == 'insert':\n        key = int(cmd[1])\n        priority = int(cmd[2])\n        insert(parent_node, key, priority)\n        # print(\"test in\")\n        # 根が変わる場合を考慮する。\n        parent_node = getRoot(parent_node)\n        # print(\"test out\")\n    # プリント\n    elif cmd[0] == 'print':\n        printInorder(parent_node)\n        print(\"\")\n        printPreorder(parent_node)\n        print(\"\")\n    # サーチ\n    elif cmd[0] == 'find':\n        key = int(cmd[1])\n        find(parent_node, key)\n    # 削除\n    else:\n        key = int(cmd[1])\n        \n        # 根が変わる場合を考慮する。\n        if parent_node.key != key:\n            delete(parent_node, key)\n            parent_node = getRoot(parent_node)\n        elif parent_node.left != None:\n            tmp_node = parent_node.left\n            delete(parent_node, key)\n            parent_node = getRoot(tmp_node)\n        elif parent_node.right != None:\n            tmp_node = parent_node.right\n            delete(parent_node, key)\n            parent_node = getRoot(tmp_node)\n        else:\n            delete(parent_node, key)\n            parent_node = None\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\nclass TreapNode:\n    def __init__(self, id, priority):\n        self.id = id\n        self.priority = priority\n        self.left = None\n        self.right = None\n    \n    def __str__(self):\n        return 'id={}, priority={}'.format(self.id, self.priority)\n\n\n    def _rotate_left(self):\n        r = self.right\n        self.right = r.left\n        r.left = self\n        return r\n    \n    def _rotate_right(self):\n        l = self.left\n        self.left = l.right\n        l.right = self\n        return l\n    \n    \n    def _delete_node(self):\n        if self.left is None and self.right is None:\n            return None\n        elif self.left is None:\n            node = self._rotate_left()\n        elif self.right is None:\n            node = self._rotate_right()\n        else:\n            if self.left.priority < self.right.priority:\n                node = self._rotate_left()\n            else:\n                node = self._rotate_right()\n                \n        return node.delete(self.id)\n\n        \n    def insert(self, id, priority):\n        if self.id == id:\n            return self\n            \n        if id < self.id:\n            if self.left:\n                self.left = self.left.insert(id, priority)\n            else:\n                self.left = TreapNode(id, priority)\n            \n            if self.priority < self.left.priority:\n                return self._rotate_right()\n        else:\n            if self.right:\n                self.right = self.right.insert(id, priority)\n            else:\n                self.right = TreapNode(id, priority)\n                \n            if self.priority < self.right.priority:\n                return self._rotate_left()\n                \n        return self\n\n    def delete(self, id):\n        if id < self.id:\n            if self.left:\n                self.left = self.left.delete(id)\n        elif id > self.id:\n            if self.right:\n                self.right = self.right.delete(id)\n        else:\n            return self._delete_node()\n            \n        return self\n    \n                \n    def inorder(self, result):\n        if self.left:\n            self.left.inorder(result)\n            \n        result.append(self.id)\n        \n        if self.right:\n            self.right.inorder(result)\n    \n    \n    def preorder(self, result):\n        result.append(self.id)\n        \n        if self.left:\n            self.left.preorder(result)\n            \n        if self.right:\n            self.right.preorder(result)\n\n    def find(self, id):\n        if self.id == id:\n            return True\n        if id < self.id:\n            if self.left and self.left.find(id):\n                return True\n        else:\n            if self.right and self.right.find(id):\n                return True\n        return False\n\nclass Treap:\n    def __init__(self):\n        self.root = None\n    \n    def insert_node(self, id, priority):\n        if self.root:\n            self.root = self.root.insert(id, priority)\n        else:\n            self.root = TreapNode(id, priority)\n    \n    def delete_node(self, id):\n        if self.root:\n            self.root = self.root.delete(id)\n    \n    def find_node(self, id):\n        if self.root:\n            return self.root.find(id)\n        else:\n            return False\n            \n    def walk_inorder(self):\n        result = []\n        if self.root:\n            self.root.inorder(result)\n        return result\n    \n    def walk_preorder(self):\n        result = []\n        if self.root:\n            self.root.preorder(result)\n        return result\n    \n\ndef main():\n    n = int(input())\n    treap = Treap()\n    \n    for _ in range(n):\n        cmd = input()\n        if cmd[0] == 'p':\n            result = treap.walk_inorder()\n            print('', *result)\n            \n            result = treap.walk_preorder()\n            print('', *result)\n\n        elif cmd[0] == 'i':\n            id, priority = [int(i) for i in cmd.split()[1:3]]\n            treap.insert_node(id, priority)\n            \n        elif cmd[0] == 'd':\n            id = int(cmd.split()[1])\n            treap.delete_node(id)\n            \n        elif cmd[0] == 'f':\n            id = int(cmd.split()[1])\n            if treap.find_node(id):\n                print('yes')\n            else:\n                print('no')\n\nif __name__=='__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, key, priority):\n        self.key = key\n        self.pri = priority\n        self.parent = None\n        self.left = None\n        self.right = None\n        \n    def insert(self, z):\n        if z.key < self.key:\n            if self.left:\n                self.left.insert(z)\n            else:\n                self.left = z\n                z.parent = self\n            if self.pri < self.left.pri:\n                self.rightR()\n        elif self.key < z.key:\n            if self.right:\n                self.right.insert(z)\n            else:\n                self.right = z\n                z.parent = self\n            if self.pri < self.right.pri:\n                self.leftR()\n    \n    def find(self, key):\n        if self.key == key:\n            return True\n        elif not self.left and not self.right:\n            return False\n        else:\n            if key < self.key:\n                return self.left.find(key)\n            else:\n                return self.right.find(key)\n            \n    def delete(self, key):\n        if key < self.key:\n            self.left.delete(key)\n        elif key > self.key:\n            self.right.delete(key)\n        else:\n            self._delete()\n    \n    def _delete(self):\n        if not self.left and not self.right:\n            if self.parent.left == self:\n                self.parent.left = None\n            else:\n                self.parent.right = None\n            del self\n            return None\n        elif self.left and self.right:\n            if self.left.pri > self.right.pri:\n                self.rightR()\n            else:\n                self.leftR()\n        elif self.right:\n            self.leftR()\n        else:\n            self.rightR()\n        self._delete()\n        \n    def rightR(self):\n        tmp = self.left\n        if self.parent:\n            if self.key < self.parent.key:\n                self.parent.left = tmp\n            else:\n                self.parent.right = tmp\n        self.left = tmp.right\n        if self.left:\n            self.left.parent = self\n        tmp.right = self\n        tmp.parent = self.parent\n        self.parent = tmp\n        \n    def leftR(self):\n        tmp = self.right\n        if self.parent:\n            if self.key < self.parent.key:\n                self.parent.left = tmp\n            else:\n                self.parent.right = tmp\n        self.right = tmp.left\n        if self.right:\n            self.right.parent = self\n        tmp.left = self\n        tmp.parent = self.parent\n        self.parent = tmp\n    \n    def preo(self):\n        tmp = \"\"\n        tmp += \" \" + str(self.key)\n        if self.left:\n            tmp += self.left.preo()\n        if self.right:\n            tmp += self.right.preo()\n        return tmp\n    \n    def ino(self):\n        tmp = \"\"\n        if self.left:\n            tmp += self.left.ino()\n        tmp += \" \" + str(self.key)\n        if self.right:\n            tmp += self.right.ino()\n        return tmp\n\nm = int(input())\nroot = None\nfor i in range(m):\n    com = input().split()\n    if com[0] == \"insert\":\n        node = Node(int(com[1]), int(com[2]))\n        try:\n            root.insert(node)\n        except AttributeError :\n            root = node\n    elif com[0] == \"find\":\n        try:\n            if root.find(int(com[1])):\n                print(\"yes\")\n            else:\n                print(\"no\")\n        except AttributeError:\n            print(\"no\")\n    elif com[0] == \"delete\":\n        try:\n            root.delete(int(com[1]))\n        except AttributeError:\n            pass\n    else:\n        try:\n            print(root.ino())\n            print(root.preo())\n        except AttributeError:\n            print(\"None\")\n    c = 0\n    while(True):\n        if root.parent:\n            root = root.parent\n        else:\n            break\n"
  },
  {
    "language": "Python",
    "code": "class node:\n    def __init__(self,key,pri,left=None,right=None):\n        self.left = left\n        self.right = right\n        self.key = key\n        self.pri = pri\n\ndef insert(n,key,pri):\n    if(n == None):\n        return node(key,pri)\n    if(key == n.key):\n        return n\n    if(key < n.key):\n        n.left = insert(n.left, key, pri)\n        if(n.pri < n.left.pri):\n            n = rightRotate(n)\n    else:\n        n.right = insert(n.right, key, pri)\n        if(n.pri < n.right.pri):\n            n = leftRotate(n)\n    return n\n\ndef rightRotate(n):\n    swapL,swapK,swapP = n.left.left,n.left.key,n.left.pri\n    n.left = None\n    n = node(swapK,swapP,swapL,n)\n    return n\n\ndef leftRotate(n):\n    swapR,swapK,swapP = n.right.right,n.right.key,n.right.pri\n    n.right = None\n    n = node(swapK,swapP,n,swapR)\n    return n\n\ndef find(n,key):\n    if(n == None):\n        return None\n    elif(n.key == key):\n        return n\n    elif(n.key > key):\n        return find(n.left,key)\n    else:\n        return find(n.right,key)\n\ndef delete(n, key):\n    if(n == None):\n        return None\n    if(key < n.key):\n        n.left = delete(n.left, key)\n    elif(key > n.key):\n        n.right = delete(n.right, key)\n    else:\n        return _delete(n, key)\n    return n\n\ndef _delete(n, key):\n    if(n.left == None and n.right == None):\n        return None\n    elif(n.left == None):\n        n = leftRotate(n)\n    elif(n.right == None):\n        n = rightRotate(n)\n    else:\n        if(n.left.pri > n.right.pri):\n            n = rightRotate(n)\n        else:\n            n = leftRotate(n)\n    return delete(n, key)\n\ndef inorder(n):\n    if(n==None):\n        return\n    if(n.left != None):\n        inorder(n.left)\n    print(\" \"+str(n.key), end='')\n    if(n.right != None):\n        inorder(n.right)\n\ndef preorder(n):\n    if(n==None):\n        return\n    print(\" \"+str(n.key), end='')\n    if(n.left != None):\n        preorder(n.left)\n    if(n.right != None):\n        preorder(n.right)\n\nop_num=(int)(input())\nroot = None\nfor i in range(op_num):\n    items = input().split()\n    if(items[0] == \"insert\"):\n        root = insert(root,(int)(items[1]),(int)(items[2]))\n    elif(items[0] == \"delete\"):\n        root = delete(root,(int)(items[1]))\n    elif(items[0] == \"find\"):\n        res = find(root,(int)(items[1]))\n        if(res == None):\n            print(\"no\")\n        else:\n            print(\"yes\")\n    else:\n        inorder(root)\n        print(\"\")\n        preorder(root)\n        print(\"\")\n\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, key, priority):\n        self.right = None\n        self.left = None\n        self.parent = None\n        self.key = key\n        self.priority = priority\n\n    def preorder(self):\n        ret = [self.key]\n        if self.left:\n            ret += self.left.preorder()\n        if self.right:\n            ret += self.right.preorder()\n        return ret\n\n    def inorder(self):\n        ret = []\n        if self.left:\n            ret += self.left.inorder()\n        ret += [self.key]\n        if self.right:\n            ret += self.right.inorder()\n        return ret\n\n    def find(self, k):\n        if self.key == k:\n            return self\n        elif self.key < k:\n            if self.right:\n                return self.right.find(k)\n            else:\n                return None\n        else:\n            if self.left:\n                return self.left.find(k)\n            else:\n                return None\n\n\nclass Treap:\n    def __init__(self):\n        self.root = None\n\n    def right_rotate(self, t):\n        s = t.left\n        t.left = s.right\n        s.right = t\n        return s\n\n    def left_rotate(self, t):\n        s = t.right\n        t.right = s.left\n        s.left = t\n        return s\n\n    def insert(self, k, p):\n        self.root = self._insert(self.root, k, p)\n\n    def _insert(self, t, k, p):\n        if t is None:\n            return Node(k, p)\n        if k == t.key:\n            return t\n        if k < t.key:\n            t.left = self._insert(t.left, k, p)\n            if t.priority < t.left.priority:\n                t = self.right_rotate(t)\n        else:\n            t.right = self._insert(t.right, k, p)\n            if t.priority < t.right.priority:\n                t = self.left_rotate(t)\n        return t\n\n    def print(self):\n        if self.root is None:\n            print()\n        else:\n            print('', ' '.join(map(str, self.root.inorder())))\n            print('', ' '.join(map(str, self.root.preorder())))\n\n    def find(self, k):\n        if self.root is None:\n            return None\n        else:\n            return self.root.find(k)\n\n    def delete(self, k):\n        self.root = self._delete(self.root, k)\n\n    def _delete(self, t, k):\n        if t is None:\n            return None\n        if k < t.key:\n            t.left = self._delete(t.left, k)\n        elif k > t.key:\n            t.right = self._delete(t.right, k)\n        else:\n            return self._else_delete(t, k)\n        return t\n\n    def _else_delete(self, t, k):\n        if t.left is None and t.right is None:\n            return None\n        elif t.left is None:\n            t = self.left_rotate(t)\n        elif t.right is None:\n            t = self.right_rotate(t)\n        else:\n            if t.left.priority > t.right.priority:\n                t = self.right_rotate(t)\n            else:\n                t = self.left_rotate(t)\n        return self._delete(t, k)\n\n\nm = int(input())\ntreap = Treap()\nfor _ in range(m):\n    s = input().split()\n    if s[0] == \"insert\":\n        treap.insert(int(s[1]), int(s[2]))\n    elif s[0] == \"find\":\n        if treap.find(int(s[1])):\n            print(\"yes\")\n        else:\n            print(\"no\")\n    elif s[0] == \"delete\":\n        treap.delete(int(s[1]))\n    else:\n        treap.print()\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nclass Node:\n  def __init__(self, key, priority):\n    self.key = key\n    self.priority = priority\n    self.left = None\n    self.right = None\n  \ndef rightRotate(t):\n  s = t.left\n  t.left = s.right\n  s.right = t\n  return s\n\ndef leftRotate(t):\n  s = t.right\n  t.right = s.left\n  s.left = t\n  return s\n\ndef insert(t, key, priority):\n  \n  if not t: return Node(key, priority)\n  if key == t.key: return t\n  \n  if key < t.key: \n    t.left = insert(t.left, key, priority)\n    if t.priority < t.left.priority:\n      t = rightRotate(t)\n  else:\n    t.right = insert(t.right, key, priority)\n    if t.priority < t.right.priority:\n      t = leftRotate(t)\n  \n  return t\n\ndef erase(t, key):\n  \n  if not t: return None\n  \n  if key == t.key:\n    if (not t.left) and (not t.right): return None\n  elif not t.left: \n    t = leftRotate(t)\n  elif not t.right:\n    t = rightRotate(t)\n  else:\n    if t.left.priority > t.right.priority:\n      t = rightRotate(t)\n    else:\n      t = leftRotate(t)\n  return erase(t, key)\n\n  if key < t.key:\n    t.left = erase(t.left, key)\n  else:\n    t.right = erase(t.right, key)\n  return t\n\ndef find(t, key):\n  if t.key == key:\n    print(\"yes\")\n    return 0\n  elif t.key < key and (not t.right):\n    find(t.right, key)\n  elif t.key > key and (not t.left):\n    find(t.left, key)\n  else:\n    print(\"no\")\n  return 0\n\ndef in_print(t):\n  if t.left != None:\n    in_print(t.left)\n  print(\" \" + str(t), end='')\n  if t.right != None:\n    in_print(t.right)\n\ndef pre_print(t):\n  print(\" \" + str(t), end='')\n  if t.left != None:\n    pre_print(t.left)\n  if t.right != None:\n    pre_print(t.right)\n  \nTreap = None\nnum = int(input())\nfor i in range(num):\n  string = list(input().split())\n  if string[0] == \"insert\":\n    key = int(string[1])\n    priority = int(string[2])\n    insert(Treap, key, priority)\n  elif string[0] == \"find\":\n    key = int(string[1])\n    find(Treap, key)\n  elif string[0] == \"delete\":\n    key = int(string[1])\n    erase(Treap, key)\n  else:\n    in_print(Treap)\n    print()\n    pre_print(Treap)\n    print()\n    \n\n  \n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nclass Node:\n  def __init__(self, key, priority):\n    self.key = key\n    self.priority = priority\n    self.left = None\n    self.right = None\n  \ndef rightRotate(t):\n  s = t.left\n  t.left = s.right\n  s.right = t\n  return s\n\ndef leftRotate(t):\n  s = t.right\n  t.right = s.left\n  s.left = t\n  return s\n\ndef insert(t, key, priority):\n  \n  if not t: return Node(key, priority)\n  if key == t.key: return t\n  \n  if key < t.key: \n    t.left = insert(t.left, key, priority)\n    if t.priority < t.left.priority:\n      t = rightRotate(t)\n  else:\n    t.right = insert(t.right, key, priority)\n    if t.priority < t.right.priority:\n      t = leftRotate(t)\n  \n  return t\n\ndef erase(t, key):\n  \n  if not t: return None\n  \n  if key == t.key:\n    if (not t.left) and (not t.right): return None\n  elif not t.left: \n    t = leftRotate(t)\n  elif not t.right:\n    t = rightRotate(t)\n  else:\n    if t.left.priority > t.right.priority:\n      t = rightRotate(t)\n    else:\n      t = leftRotate(t)\n  return erase(t, key)\n\n  if key < t.key:\n    t.left = erase(t.left, key)\n  else:\n    t.right = erase(t.right, key)\n  return t\n\ndef find(t, key):\n  if t.key == key:\n    print(\"yes\")\n    return 0\n  elif t.key < key and (not t.right):\n    find(t.right, key)\n  elif t.key > key and (not t.left):\n    find(t.left, key)\n  else:\n    print(\"no\")\n  return 0\n\ndef in_print(t):\n  if not t.left:\n    in_print(t.left)\n  print(\" \" + str(t), end='')\n  if not t.right:\n    in_print(t.right)\n\ndef pre_print(t):\n  print(\" \" + str(t), end='')\n  if not t.left:\n    pre_print(t.left)\n  if not t.right:\n    pre_print(t.right)\n  \nTreap = None\nnum = int(input())\nfor i in range(num):\n  string = list(input().split())\n  if string[0] == \"insert\":\n    key = int(string[1])\n    priority = int(string[2])\n    insert(Treap, key, priority)\n  elif string[0] == \"find\":\n    key = int(string[1])\n    find(key)\n  elif string[0] == \"delete\":\n    key = int(string[1])\n    erase(Treap, key)\n  else:\n    in_print(Treap)\n    print()\n    pre_print(Treap)\n    print()\n    \n\n  \n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nclass Node:\n  def __init__(self, key, priority, left=None, right=None):\n    self.key = key\n    self.priority = priority\n    self.left = left\n    self.right = right\n  \ndef rightRotate(t):\n  s = t.left\n  t.left = s.right\n  s.right = t\n  return s\n\ndef leftRotate(t):\n  s = t.right\n  t.right = s.left\n  s.left = t\n  return s\n\ndef insert(t, key, priority):\n  \n  if not t: return Node(key, priority)\n  if key == t.key: return t\n  \n  if key < t.key: \n    t.left = insert(t.left, key, priority)\n    if t.priority < t.left.priority:\n      t = rightRotate(t)\n  else:\n    t.right = insert(t.right, key, priority)\n    if t.priority < t.right.priority:\n      t = leftRotate(t)\n  \n  return t\n\ndef erase(t, key):\n  \n  if not t: return None\n  \n  if key == t.key:\n    if (not t.left) and (not t.right): return None\n    elif not t.left: \n      t = leftRotate(t)\n    elif not t.right:\n      t = rightRotate(t)\n    else:\n      if t.left.priority > t.right.priority:\n        t = rightRotate(t)\n      else:\n        t = leftRotate(t)\n  return erase(t, key)\n\n\ndef find(t, key):\n  if t.key == key:\n    print(\"yes\")\n  elif t.key < key and t.right != None:\n    find(t.right, key)\n  elif t.key > key and t.left != None:\n    find(t.left, key)\n  else:\n    print(\"no\")\n  return 0\n\ndef in_print(t):\n  if t.left != None:\n    in_print(t.left)\n  print(\" \" + str(t), end='')\n  if t.right != None:\n    in_print(t.right)\n\ndef pre_print(t):\n  print(\" \" + str(t), end='')\n  if t.left != None:\n    pre_print(t.left)\n  if t.right != None:\n    pre_print(t.right)\n  \nTreap = None\nnum = int(input())\nfor i in range(num):\n  string = list(input().split())\n  if string[0] == \"insert\":\n    key = int(string[1])\n    priority = int(string[2])\n    Treap = insert(Treap, key, priority)\n  elif string[0] == \"find\":\n    key = int(string[1])\n    find(Treap, key)\n  elif string[0] == \"delete\":\n    key = int(string[1])\n    Treap = erase(Treap, key)\n  else:\n    in_print(Treap)\n    print()\n    pre_print(Treap)\n    print()\n    \n\n  \n"
  },
  {
    "language": "Python",
    "code": "from typing import Optional, List\n\n\nclass Node():\n    def __init__(self, key: int, priority: int) -> None:\n        self.key = key\n        self.priority = priority\n        self.parent: Optional[Node] = None\n        self.left: Optional[Node] = None\n        self.right: Optional[Node] = None\n\n    def prewalk(self) -> List[int]:\n        ret = [self.key]\n        if self.left:\n            ret += self.left.prewalk()\n        if self.right:\n            ret += self.right.prewalk()\n        return ret\n\n    def inwalk(self) -> List[int]:\n        ret: List[int] = []\n        if self.left:\n            ret += self.left.inwalk()\n        ret += [self.key]\n        if self.right:\n            ret += self.right.inwalk()\n        return ret\n\n\nclass Tree():\n    def __init__(self) -> None:\n        self.root: Optional[Node] = None\n\n    def insert(self, node: Optional[Node], key: int, priority: int) -> Node:\n        if self.root is None:\n            self.root = Node(key, priority)\n            return self.root\n        if node is None:\n            return Node(key, priority)\n        if key == node.key:\n            # Duplicated key case (No insertion).\n            return node\n\n        if key < node.key:\n            node.left = self.insert(node.left, key, priority)\n            if node.priority < node.left.priority:\n                node = self._right_rotate(node)\n        else:\n            node.right = self.insert(node.right, key, priority)\n            if node.priority < node.right.priority:\n                node = self._left_rotate(node)\n\n        return node\n\n    def _right_rotate(self, t: Node) -> Node:\n        assert t.left is not None\n        s: Node = t.left\n        t.left = s.right\n        s.right = t\n        return s  # The new root of the subtree.\n\n    def _left_rotate(self, t: Node) -> Node:\n        assert t.right is not None\n        s: Node = t.right\n        t.right = s.left\n        s.left = t\n        return s  # The new root of the subtree.\n\n    def find(self, key: int) -> Optional[Node]:\n        x = self.root\n        while x and x.key != key:\n            if x.key < key:\n                x = x.right\n            else:\n                x = x.left\n        return x\n\n    def delete(self, node: Optional[Node], key: int) -> Optional[Node]:\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self.delete(node.left, key)\n        elif key > node.key:\n            node.right = self.delete(node.right, key)\n        else:\n            return self._delete(node, key)\n        return node\n\n    def _delete(self, node: Node, key: int) -> Optional[Node]:\n        if (node.left is None) and (node.right is None):\n            return None\n        elif node.left is None:\n            node = self._left_rotate(node)\n        elif node.right is None:\n            node = self._right_rotate(node)\n        else:\n            assert node.left is not None  # Though this is not needed in principle...\n            if node.left.priority > node.right.priority:\n                node = self._right_rotate(node)\n            else:\n                node = self._left_rotate(node)\n        return self.delete(node, key)\n\n    def _successor(self, x: Node) -> Node:\n        assert x is not None\n        if x.right:\n            return self._minimum(x.right)\n        y = x.parent\n        while y and x == y.right:\n            x = y\n            y = y.parent\n        assert y is not None\n        return y\n\n    def _minimum(self, x: Node) -> Node:\n        while x.left:\n            x = x.left\n        return x\n\n    def print(self) -> None:\n        assert self.root is not None\n        print('', ' '.join(map(str, self.root.inwalk())))\n        print('', ' '.join(map(str, self.root.prewalk())))\n\n\nif __name__ == \"__main__\":\n    tree = Tree()\n    node_num = int(input())\n    for _ in range(node_num):\n        command, *value = input().split()\n        if \"insert\" == command:\n            tree.root = tree.insert(tree.root, int(value[0]), int(value[1]))\n        elif \"find\" == command:\n            print('yes' if tree.find(int(value[0])) else 'no')\n        elif \"delete\" == command:\n            tree.root = tree.delete(tree.root, int(value[0]))\n        elif \"print\" == command:\n            tree.print()\n        else:\n            pass\n\n"
  },
  {
    "language": "Python",
    "code": "# coding:utf-8\n\nNIL =  None\n\nclass Node():\n\tdef __init__(self, key, pri):\n\t\tself.key = key\n\t\tself.pri = pri\n\t\tself.right = NIL\n\t\tself.left = NIL\n\n\ndef rightRotate(t):\n\ts = t.left\n\tt.left = s.right\n\ts.right = t\n\treturn s\n\ndef leftRotate(t):\n\ts = t.right\n\tt.right = s.left\n\ts.left = t\n\treturn s\n\ndef insert(t, key, pri):\n\tif t == NIL:\n\t\treturn Node(key, pri)\n\tif key == t.key:\n\t\treturn t\n\n\tif key < t.key:\n\t\tt.left = insert(t.left, key, pri)\n\t\tif t.pri < t.left.pri:\n\t\t\tt = rightRotate(t)\n\telse :\n\t\tt.right = insert(t.right, key, pri)\n\t\tif t.pri < t.right.pri:\n\t\t\tt = leftRotate(t)\n\n\treturn t\n\ndef erase(t, key):\n\tif t == NIL:\n\t\treturn NIL\n\tif key == t.key:\n\t\tif t.right == NIL and t.left == NIL:\n\t\t\treturn NIL\n\t\telif t.left == NIL:\n\t\t\tt = leftRotate(t)\n\t\telif t.right == NIL:\n\t\t\tt = rightRotate(t)\n\t\telse :\n\t\t\tif t.left.pri > t.right.pri:\n\t\t\t\tt = rightRotate(t)\n\t\t\telse :\n\t\t\t\tt = leftRotate(t)\n\t\treturn erase(t, key)\n\n\tif key < t.key:\n\t\tt.left = erase(t.left, key)\n\telse:\n\t\tt.right = erase(t.right, key)\n\n\treturn t\n\ndef find(t, key):\n\tif t == NIL:\n\t\treturn False\n\tif key == t.key:\n\t\treturn True\n\n\tif key < t.key:\n\t\treturn find(t.left, key)\n\telse:\n\t\treturn find(t.right, key)\n\n\nhead = Node(-1, 2000000001)\n\ndef print_priorder(t):\n\tif t == NIL:\n\t\treturn\n\n\tif t != head:\n\t\tprint(\" \" + str(t.key), end='')\n\n\tprint_priorder(t.left)\n\tprint_priorder(t.right)\n\ndef print_inorder(t):\n\tif t == NIL:\n\t\treturn\n\n\tprint_inorder(t.left)\n\tif t != head:\n\t\tprint(\" \" + str(t.key), end='')\n\tprint_inorder(t.right)\n\n\nn = int(input()) # 命令の数\n\nfor i in range(n):\n\tinst = input().split()\n\n\tif inst[0] == \"insert\":\n\t\tinsert(head, int(inst[1]), int(inst[2]))\n\n\telif inst[0] == \"find\":\n\t\tif find(head, int(inst[1])):\n\t\t\tprint(\"yes\")\n\t\telse :\n\t\t\tprint(\"no\")\n\n\telif inst[0] == \"delete\":\n\t\terase(head, int(inst[1]))\n\n\telif inst[0] == \"print\":\n\t\tprint_inorder(head)\n\t\tprint()\n\t\tprint_priorder(head)\n\t\tprint()\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, key, priority, left=None, right=None):\n        self.key = key\n        self.priority = priority\n        self.left = left\n        self.right = right\n\n\ndef rightRotate(t):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s # 部分木の新しい根を返す\n\n\ndef leftRotate(t):\n    s = t.right\n    t.right = s.left\n    s.left = t\n    return s # 部分木の新しい根を返す\n\n\ndef insert(t, key, priority):\n    # 葉に到達したらノードを生成して返す\n    if t == None:\n        return Node(key, priority)\n    # 重複するキーを無視する\n    if key == t.key:\n        return t\n\n    if key < t.key: # 左の子に移動\n        # 帰ってきたノードを左の子にする\n        t.left = insert(t.left, key, priority)\n        # その子に優先度が高ければ、右回転で持ち上げる\n        if t.priority < t.left.priority:\n            t = rightRotate(t)\n    else: # 右の子に移動\n        # 帰ってきたノードを右の子にする\n        t.right = insert(t.right, key, priority)\n        # その子の優先度が高ければ左回転で持ち上げる\n        if t.priority < t.right.priority:\n            t = leftRotate(t)\n\n    return t\n\n\ndef erase(t, key):\n    if t == None:\n        return None\n\n    if key == t.key: # tが削除対象\n        if (t.left == None) and (t.right == None): # tが葉\n            return None\n        elif t.left == None: # tがただ一つの右の子を持つ\n            t = leftRotate(t)\n        elif t.right == None:\n            t = rightRotate(t) # tがただ一つの左の子を持つ\n        else: # tが二つの子を持つ\n            # 優先度が高い子を持ち上げる\n            if t.left.priority > t.right.priority:\n                t = rightRotate(t)\n            else:\n                t = leftRotate(t)\n        return erase(t, key)\n\n    # 対象を再帰的に探索\n    elif key > t.key:\n        t.right = erase(t.right, key)\n    else:\n        t.left = erase(t.left, key)\n    return t\n\n\n# 引数のkeyを持つノードの有無を探索\ndef find(t, key):\n    if t.key == key:\n        print(\"yes\")\n    elif t.key < key and t.right != None:\n        find(t.right, key)\n    elif t.key > key and t.left != None:\n        find(t.left, key)\n    else:\n        print(\"no\")\n    return 0\n\n\ndef in_print(t):\n    if t.left != None:\n        in_print(t.left)\n    print(\" \" + str(t.key), end='')\n    if t.right != None:\n        in_print(t.right)\n\n# 中間巡回アルゴリズム\ndef pre_print(t):\n    print(\" \" + str(t.key), end='')\n    if t.left != None:\n        pre_print(t.left)\n    if t.right != None:\n        pre_print(t.right)\n\n\ndef main():\n    Treap = None\n    p = []\n    k = int(input())\n    i = 0\n    while i < k:\n        try:\n            p.append(list(map(str, input().split())))\n            i = i + 1\n        except:\n            break;\n    \n    i = 0\n    while i < k:\n        if p[i][0] == 'insert':\n            key = int(p[i][1])\n            priority = int(p[i][2])\n            Treap = insert(Treap, key, priority)\n        elif p[i][0] == 'find':\n            key = int(p[i][1])\n            find(Treap, key)\n        elif p[i][0] == 'delete':\n            key = int(p[i][1])\n            Treap = erase(Treap, key)\n        else:\n            in_print(Treap)\n            print()\n            pre_print(Treap)\n            print()\n        i = i + 1\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self,key,pri,left=None,right=None):\n        self.left = left\n        self.right = right\n        self.key = key\n        self.pri = pri\n \ndef insert(t,key,pri):\n    if t == None :\n        return Node(key,pri)\n    if key == t.key :\n        return t\n    if key < t.key :\n        t.left = insert(t.left, key, pri)\n        if t.pri < t.left.pri :\n            t = rrotate(t)\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.pri < t.right.pri :\n            t = lrotate(t)\n    return t\n \n \ndef rrotate(t):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s\n\n \ndef lrotate(t):\n    s= t.right\n    t.right = s.left\n    s.left = t\n    return s\n\n \ndef find(t,key):\n    if t == None: return None\n    elif t.key == key:return t\n    elif t.key > key :return find(t.left,key)\n    else: return find(t.right,key)\n \ndef erase(t, key):\n    if t == None : return None\n    if key == t.key: \n        if t.left == None and t.right == None:return None\n        elif t.left == None : t = lrotate(t)\n        elif t.right == None : t = rrotate(t)\n        else:\n            if t.left.pri > t.right.pri:t = rrotate(t)\n            else: t = lrotate(t)\n        return erase(t, key)\n    elif key < t.key : t.left = erase(t.left, key)\n    else : t.right = erase(t.right, key)\n    return t\n \ndef inorder(t):\n    if t.left != None:inorder(t.left)\n    print(\" \"+str(t.key), end='')\n    if t.right != None: inorder(t.right)\n \ndef preorder(t):\n    print(\" \"+str(t.key), end='')\n    if t.left != None :preorder(t.left)\n    if t.right != None : preorder(t.right)\n\nif __name__==\"__main__\": \n        m=(int)(input())\n        root = None\n        for i in range(m):\n            order = input().split()\n            if order[0] == \"insert\" :root = insert(root,(int)(order[1]),(int)(order[2]))\n            elif order[0] == \"delete\" :root = erase(root,(int)(order[1]))\n            elif order[0] == \"find\" :\n                res = find(root,(int)(order[1]))\n                if res == None :print(\"no\")\n                else:print(\"yes\")\n            else:\n                inorder(root)\n                print()\n                preorder(root)\n                print()\n\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, k, p):\n        self.k, self.p = k, p\n        self.left, self.right = None, None\n\nclass Treap:\n    def __init__(self):\n        self.root = None\n    \n    def insert(self, k, p):\n        self.root = self.__insert(self.root, k, p)\n\n    def rightRotate(self, t):\n        s = t.left\n        t.left = s.right\n        s.right = t\n        return s\n    \n    def leftRotate(self, t):\n        s = t.right\n        t.right = s.left\n        s.left = t\n        return s\n\n    def __insert(self, t, k , p):\n        if t == None:\n            return Node(k, p)\n        if k == t.k:\n            return t\n        \n        if k < t.k:\n            t.left = self.__insert(t.left, k, p)\n            if t.p < t.left.p:\n                t = self.rightRotate(t)\n        else:\n            t.right = self.__insert(t.right, k, p)\n            if t.p < t.right.p:\n                t = self.leftRotate(t)\n        return t\n    \n    def delete(self, k):\n        self.root = self._delete(k)\n        \n    def _delete(self, k, t = -1):\n        if t == -1:\n            t = self.root\n        \n        if t == None:\n            return None\n        if k < t.k:\n            t.left = self._delete(k, t.left)\n        elif k > t.k:\n            t.right = self._delete(k, t.right)\n        else:\n            return self.__delete(t, k)\n        return t\n    \n    def __delete(self, t, k):\n        if t.left == None and t.right == None:\n            return None\n        elif t.left == None:\n            t = self.leftRotate(t)\n        elif t.right == None:\n            t = self.rightRotate(t)\n        else:\n            if t.left.p > t.right.p:\n                t = self.rightRotate(t)\n            else:\n                t = self.leftRotate(t)\n        return self._delete(k, t)\n\n    def find(self, k, t = -1):\n        if t == -1:\n            t = self.root\n        if t == None:\n            return None\n        if k < t.k:\n            return self.find(k, t.left)\n        elif k > t.k:\n            return self.find(k, t.right)\n        else:\n            return t\n    \n    def preOrder(self, r = -1):\n        if r == -1: r = self.root\n        if r == None:   return\n        print(\"\", r.k, end = '')\n        self.preOrder(r.left)\n        self.preOrder(r.right)\n    \n    def inOrder(self, r = -1):\n        if r == -1: r = self.root\n        if r == None:   return\n        self.inOrder(r.left)\n        print(\"\", r.k, end = '')\n        self.inOrder(r.right)\n    \n    def print(self):\n        self.inOrder()\n        print()\n        self.preOrder()\n        print()\n\ntree = Treap()\nfor _ in range(int(input())):\n    In = input().split()\n    if In[0][0] == 'i':\n        tree.insert(int(In[1]), int(In[2]))\n    elif In[0][0] == 'p':\n        tree.print()\n    elif In[0][0] == 'f':\n        print(['no', 'yes'][tree.find(int(In[1])) != None])\n    elif In[0][0] == 'd':\n        tree.delete(int(In[1]))\n\n"
  },
  {
    "language": "Python",
    "code": "class Node():\n    def __init__(self, key, pri):\n        self.key = key\n        self.pri = pri\n        self.left = self.right = None\n         \n \ndef insert(t, key, pri):\n    if t == None:\n        return Node(key, pri) \n    if key == t.key:\n        return t                             \n \n    if key < t.key:\n        t.left = insert(t.left, key, pri)\n        if t.pri < t.left.pri:\n            t = rightRotate(t)\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.pri < t.right.pri:\n            t = leftRotate(t)\n \n    return t\n         \ndef rightRotate(node):\n    global root\n    a = node.left\n    node.left = a.right\n    a.right = node\n    if node == root:\n        root = a\n    return a\n \ndef leftRotate(node):\n    global root\n    a = node.right\n    node.right = a.left\n    a.left = node\n    if node == root:\n        root = a\n    return a\n     \n         \ndef pre(node):\n    if node == None:return\n    print('',node.key, end = '');pre(node.left);pre(node.right)\n     \ndef ino(node):\n    if node == None:return\n    ino(node.left);print('',node.key,end='');ino(node.right)\n \ndef find(node, key):\n    if node == None:\n        print('no');return\n    if node.key == key:\n        print('yes');return\n    elif node.key > key:\n        find(node.left, key)\n    else:\n        find(node.right, key)\n \ndef delete(t, key):\n    global root\n    if t == None:\n        return None\n    if key < t.key:\n        t.left = delete(t.left, key)\n    elif key > t.key:\n        t.right = delete(t.right, key)\n    elif key == t.key:\n        if t.left == None and t.right == None:\n            return None\n        elif t.left == None:\n            t = leftRotate(t)\n        elif t.right == None:\n            t = rightRotate(t)\n        else:\n            if t.left.pri > t.right.pri:\n                t = rightRotate(t)\n            else:\n                t = leftRotate(t)\n        return delete(t, key)\n    return t\n \n     \n \nn = int(input())\n\n\nroot = None\n\n\nfor j in range(n):\n    s, *i = input().split()\n    if s[0] == 'i':root = insert(root,int(i[0]), int(i[1]))\n    elif s[0] == 'f':\n        find(root, int(i[0]))\n    elif s[0] == 'd':\n        delete(root, int(i[0]))\n    else:\n        ino(root);print();pre(root);print()\n         \n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nclass Node:\n  def __init__(self, key, priority, left=None, right=None):\n    self.key = key\n    self.priority = priority\n    self.left = left\n    self.right = right\n  \ndef rightRotate(t):\n  s = t.left\n  t.left = s.right\n  s.right = t\n  return s\n\ndef leftRotate(t):\n  s = t.right\n  t.right = s.left\n  s.left = t\n  return s\n\ndef insert(t, key, priority):\n  \n  if not t: return Node(key, priority)\n  if key == t.key: return t\n  \n  if key < t.key: \n    t.left = insert(t.left, key, priority)\n    if t.priority < t.left.priority:\n      t = rightRotate(t)\n  else:\n    t.right = insert(t.right, key, priority)\n    if t.priority < t.right.priority:\n      t = leftRotate(t)\n  \n  return t\n\ndef erase(t, key):\n  \n  if not t: return None\n  \n  if key == t.key:\n    if (not t.left) and (not t.right): return None\n  elif not t.left: \n    t = leftRotate(t)\n  elif not t.right:\n    t = rightRotate(t)\n  else:\n    if t.left.priority > t.right.priority:\n      t = rightRotate(t)\n    else:\n      t = leftRotate(t)\n  return erase(t, key)\n\n  if key < t.key:\n    t.left = erase(t.left, key)\n  else:\n    t.right = erase(t.right, key)\n  return t\n\ndef find(t, key):\n  if t.key == key:\n    print(\"yes\")\n  elif t.key < key and t.right != None:\n    find(t.right, key)\n  elif t.key > key and t.left != None:\n    find(t.left, key)\n  else:\n    print(\"no\")\n  return 0\n\ndef in_print(t):\n  if t.left != None:\n    in_print(t.left)\n  print(\" \" + str(t), end='')\n  if t.right != None:\n    in_print(t.right)\n\ndef pre_print(t):\n  print(\" \" + str(t), end='')\n  if t.left != None:\n    pre_print(t.left)\n  if t.right != None:\n    pre_print(t.right)\n  \nTreap = None\nnum = int(input())\nfor i in range(num):\n  string = list(input().split())\n  if string[0] == \"insert\":\n    key = int(string[1])\n    priority = int(string[2])\n    insert(Treap, key, priority)\n  elif string[0] == \"find\":\n    key = int(string[1])\n    find(Treap, key)\n  elif string[0] == \"delete\":\n    key = int(string[1])\n    erase(Treap, key)\n  else:\n    in_print(Treap)\n    print()\n    pre_print(Treap)\n    print()\n    \n\n  \n"
  },
  {
    "language": "Python",
    "code": "class node:\n    def __init__(self,key,pri,left=None,right=None):\n        self.left = left\n        self.right = right\n        self.key = key\n        self.pri = pri\n\ndef insert(n,key,pri):\n    if(n == None):\n        return node(key,pri)\n    if(key == n.key):\n        return n\n    if(key < n.key):\n        n.left = insert(n.left, key, pri)\n        if(n.pri < n.left.pri):\n            n = rightRotate(n)\n    else:\n        n.right = insert(n.right, key, pri)\n        if(n.pri < n.right.pri):\n            n = leftRotate(n)\n    return n\n\ndef rightRotate(n):\n    child = n.left\n    swapL,swapR,swapK,swapP = child.left,child.right,child.key,child.pri\n    n.left = swapR\n    n = node(swapK,swapP,swapL,n)\n    return n\n\ndef leftRotate(n):\n    child = n.right\n    swapL,swapR,swapK,swapP = child.left,child.right,child.key,child.pri\n    n.right = swapL\n    n = node(swapK,swapP,n,swapR)\n    return n\n\ndef find(n,key):\n    if(n == None):\n        return None\n    elif(n.key == key):\n        return n\n    elif(n.key > key):\n        return find(n.left,key)\n    else:\n        return find(n.right,key)\n\ndef delete(n, key):\n    if(n == None):\n        return None\n    if(key < n.key):\n        n.left = delete(n.left, key)\n    elif(key > n.key):\n        n.right = delete(n.right, key)\n    else:\n        return _delete(n, key)\n    return n\n\ndef _delete(n, key):\n    if(n.left == None and n.right == None):\n        return None\n    elif(n.left == None):\n        n = leftRotate(n)\n    elif(n.right == None):\n        n = rightRotate(n)\n    else:\n        if(n.left.pri > n.right.pri):\n            n = rightRotate(n)\n        else:\n            n = leftRotate(n)\n    return delete(n, key)\n\ndef inorder(n):\n    if(n==None):\n        return\n    if(n.left != None):\n        inorder(n.left)\n    print(\" \"+str(n.key), end='')\n    if(n.right != None):\n        inorder(n.right)\n\ndef preorder(n):\n    if(n==None):\n        return\n    print(\" \"+str(n.key), end='')\n    if(n.left != None):\n        preorder(n.left)\n    if(n.right != None):\n        preorder(n.right)\n\nop_num=(int)(input())\nroot = None\nfor i in range(op_num):\n    items = input().split()\n    if(items[0] == \"insert\"):\n        root = insert(root,(int)(items[1]),(int)(items[2]))\n    elif(items[0] == \"delete\"):\n        root = delete(root,(int)(items[1]))\n    elif(items[0] == \"find\"):\n        res = find(root,(int)(items[1]))\n        if(res == None):\n            print(\"no\")\n        else:\n            print(\"yes\")\n    else:\n        inorder(root)\n        print(\"\")\n        preorder(root)\n        print(\"\")\n\n"
  },
  {
    "language": "Python",
    "code": "\nclass Node:\n\tdef __init__(self, key, pri):\n\t\tself.key = key\n\t\tself.pri = pri\n\t\tself.left = self.right = None\n\tdef __str__(self):\n\t\tret = ''\n\t\tret += 'key=' + str(self.key)\n\t\tret += ',pri=' + str(self.pri)\n\t\tret += ',left='\n\t\tif self.left != None: ret += str(self.left.key)\n\t\tret += ',right='\n\t\tif self.right != None: ret += str(self.right.key)\n\t\treturn ret\n\nclass Treap:\n\tdef __init__(self):\n\t\tself.root = None\n\n\tdef print(self):\n\t\tself.print_in_order()\n\t\tself.print_pre_order()\n\n\tdef print_in_order(self):\n\t\tst = []\n\t\tcur = self.root\n\t\twhile cur != None or len(st) != 0:\n\t\t\tif cur != None:\n\t\t\t\tst.append(cur)\n\t\t\t\tcur = cur.left\n\t\t\telse:\n\t\t\t\tcur = st.pop()\n\t\t\t\tprint(' ' + str(cur.key), end='')\n\t\t\t\tcur = cur.right\n\t\tprint()\n\n\tdef print_pre_order(self):\n\t\tst = []\n\t\tst.append(self.root)\n\t\twhile len(st) != 0:\n\t\t\tcur = st.pop()\n\t\t\tprint(' ' + str(cur.key), end='')\n\t\t\tif cur.right != None:\n\t\t\t\tst.append(cur.right)\n\t\t\tif cur.left != None:\n\t\t\t\tst.append(cur.left)\n\t\tprint()\n\n\tdef find(self, key):\n\t\tcur = self.root\n\t\twhile cur != None:\n\t\t\tif key == cur.key:\n\t\t\t\treturn cur\n\t\t\tif key < cur.key:\n\t\t\t\tcur = cur.left\n\t\t\telse:\n\t\t\t\tcur = cur.right\n\t\treturn None\n\n\tdef insert(self, key, pri):\n\t\tself.root = self.insert_(self.root, key, pri)\n\n\tdef insert_(self, node, key, pri):\n\t\tif node == None:\n\t\t\treturn Node(key, pri)\n\t\tif key == node.key:\n\t\t\treturn node\n\n\t\tif key < node.key:\n\t\t\tnode.left = self.insert_(node.left, key, pri)\n\t\t\tif node.pri < node.left.pri:\n\t\t\t\tnode = self.right_rotate(node)\n\t\telse:\n\t\t\tnode.right = self.insert_(node.right, key, pri)\n\t\t\tif node.pri < node.right.pri:\n\t\t\t\tnode = self.left_rotate(node)\n\t\treturn node\n\n\tdef right_rotate(self, node):\n\t\ttmp = node.left\n\t\tnode.left = tmp.right\n\t\ttmp.right = node\n\t\treturn tmp\n\n\tdef left_rotate(self, node):\n\t\ttmp = node.right\n\t\tnode.right = tmp.left\n\t\ttmp.left = node\n\t\treturn tmp\n\n\tdef delete(self, key):\n\t\tself.root = self.delete_(self.root, key)\n\n\tdef delete_(self, node, key):\n\t\tif node == None:\n\t\t\treturn node\n\t\tif key < node.key:\n\t\t\tnode.left = self.delete_(node.left, key)\n\t\telif key > node.key:\n\t\t\tnode.right = self.delete_(node.right, key)\n\t\telse:\n\t\t\treturn self.delete__(node, key)\n\t\treturn node\n\n\tdef delete__(self, node, key):\n\t\tif (node.left == None and node.right == None):\n\t\t\treturn None\n\t\telif node.left == None:\n\t\t\tnode = self.left_rotate(node)\n\t\telif node.right == None:\n\t\t\tnode = self.right_rotate(node)\n\t\telse:\n\t\t\tif node.left.pri > node.right.pri:\n\t\t\t\tnode = self.right_rotate(node)\n\t\t\telse:\n\t\t\t\tnode = self.left_rotate(node)\n\t\treturn self.delete_(node, key)\n\nn = int(input())\ntreap = Treap()\nfor i in range(n):\n\tcmd = list(map(str, input().split()))\n\tif cmd[0] == 'print':\n\t\ttreap.print()\n\telse:\n\t\tkey = int(cmd[1])\n\t\tif cmd[0] == 'insert':\n\t\t\ttreap.insert(key, int(cmd[2]))\n\t\telif cmd[0] == 'find':\n\t\t\tif treap.find(key) != None:\n\t\t\t\tprint('yes')\n\t\t\telse:\n\t\t\t\tprint('no')\n\t\telse:\n\t\t\ttreap.delete(key)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import namedtuple\n\n\nNode = namedtuple('Node', ['key', 'priority', 'left', 'right'])\n\n\nclass Treap:\n    MAX_KEY = 2000000000\n    MAX_PRIORITY = 2000000000\n\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key, priority):\n        def _insert(node):\n            if node is None:\n                return Node(key, priority, None, None)\n            k, p, left, right = node\n            if key < k:\n                node = Node(k, p, _insert(left), right)\n                if p < node.left.priority:\n                    node = self._rotate_right(node)\n            elif key > k:\n                node = Node(k, p, left, _insert(right))\n                if p < node.right.priority:\n                    node = self._rotate_left(node)\n            else:  # node.key == key\n                pass\n            # assert(self._bst_invariant(node))\n            # assert(self._heap_invariant(node))\n            return node\n\n        self.root = _insert(self.root)\n\n    def delete(self, key):\n        def _delete(node):\n            if node is None:\n                return None\n            k, p, left, right = node\n            if key < k:\n                node = node._replace(left=_delete(left))\n            elif key > k:\n                node = node._replace(right=_delete(right))\n            else:  # key == k\n                if left is None:\n                    node = right\n                elif right is None:\n                    node = left\n                else:\n                    if left.priority > right.priority:\n                        node = _delete(self._rotate_right(node))\n                    else:\n                        node = _delete(self._rotate_left(node))\n            # assert(self._bst_invariant(node))\n            # assert(self._heap_invariant(node))\n            return node\n\n        self.root = _delete(self.root)\n\n    def find(self, key):\n        def _find(node):\n            if node is None:\n                return False\n            if key < node.key:\n                return _find(node.left)\n            elif key > node.key:\n                return _find(node.right)\n            else:\n                return True\n\n        return _find(self.root)\n\n    def inorder(self):\n        def _inorder(node):\n            if node is not None:\n                yield from _inorder(node.left)\n                yield node\n                yield from _inorder(node.right)\n        return _inorder(self.root)\n\n    def preorder(self):\n        def _preorder(node):\n            if node is not None:\n                yield node\n                yield from _preorder(node.left)\n                yield from _preorder(node.right)\n        return _preorder(self.root)\n\n    def postorder(self):\n        def _postorder(node):\n            if node is not None:\n                yield from _postorder(node.left)\n                yield from _postorder(node.right)\n                yield node\n        return _postorder(self.root)\n\n    def _rotate_left(self, node):\n        # assert node.right is not None\n        top = node.right\n        node = node._replace(right=top.left)\n        top = top._replace(left=node)\n        return top\n\n    def _rotate_right(self, node):\n        # assert node.left is not None\n        top = node.left\n        node = node._replace(left=top.right)\n        top = top._replace(right=node)\n        return top\n\n    def _heap_invariant(self, node):\n        if node is None:\n            return True\n        key, priority, left, right = node\n        return ((left is None or priority > left.priority)\n                and (right is None or priority > right.priority))\n\n    def _bst_invariant(self, node):\n        if node is None:\n            return True\n        key, priority, left, right = node\n        return ((left is None or key > left.key)\n                and (right is None or key < right.key))\n\n    def __str__(self):\n        def _str(node):\n            if node is None:\n                return ''\n            else:\n                k, p, l, r = node\n                return '({}[{}/{}]{})'.format(_str(l), k, p, _str(r))\n        return _str(self.root)\n\n\ndef run():\n    input()\n    tree = Treap()\n\n    for line in sys.stdin:\n        if line.startswith('insert'):\n            key, priority = [int(i) for i in line[7:].split()]\n            tree.insert(key, priority)\n        elif line.startswith('find'):\n            if tree.find(int(line[5:])):\n                print(\"yes\")\n            else:\n                print(\"no\")\n        elif line.startswith('delete'):\n            tree.delete(int(line[7:]))\n        elif line.startswith('print'):\n            print('', ' '.join([str(n.key) for n in tree.inorder()]))\n            print('', ' '.join([str(n.key) for n in tree.preorder()]))\n        else:\n            raise ValueError('invalid command')\n        # print(tree)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n\nclass Node:\n    def __init__(self, key, priority, left=None, right=None):\n        self.key = key\n        self.priority = priority\n        self.left = left\n        self.right = right\n        self.parent = None\n        self.ans = []\n\nclass Treap:\n    def __init__(self, root=None):\n        self.root = root\n    \n    def insert(self, node, key, priority):\n        if node == None:\n            return Node(key, priority)\n        if key == node.key:\n            return node\n        \n        if key < node.key:\n            node.left = self.insert(node.left, key, priority)\n            if node.priority < node.left.priority:\n                node = self.rightRotate(node)\n        else:\n            node.right = self.insert(node.right, key, priority)\n            if node.priority < node.right.priority:\n                node = self.leftRotate(node)\n        return node\n            \n        \n    def rightRotate(self, node):\n        tmp = node.left\n        node.left = tmp.right\n        tmp.right = node\n        return tmp\n        \n    def leftRotate(self, node):\n        tmp = node.right\n        node.right = tmp.left\n        tmp.left = node\n        return tmp\n    \n    def delete(self, node, key):\n        if node == None:\n            return None\n        if key < node.key:\n            node.left = self.delete(node.left, key)\n        elif key > node.key:\n            node.right = self.delete(node.right, key)\n        else:\n            return self._delete(node, key)\n        return node\n    \n    def _delete(self, node, key):\n        if node.left == None and node.right == None:\n            return None\n        elif node.left == None:\n            node = self.leftRotate(node)\n        elif node.right == None:\n            node = self.rightRotate(node)\n        else:\n            if node.left.priority > node.right.priority:\n                node = self.rightRotate(node)\n            else:\n                node = self.leftRotate(node)\n        return self.delete(node, key)\n        \n    def find(self, node, key):\n        if key == node.key:\n            return node\n        if key < node.key:\n            if node.left != None:\n                return self.find(node.left, key)\n            else:\n                return None\n        if key > node.key:\n            if node.right != None:\n                return self.find(node.right, key)\n            else:\n                return None\n    \n    def resetAns(self):\n        self.ans = []\n    \n    def getPreorder(self, node):\n        self.ans.append(node)\n        if node.left != None:\n            self.getPreorder(node.left)\n        if node.right != None:\n            self.getPreorder(node.right)\n    \n    def getInorder(self, node):\n        if node.left != None:\n            self.getInorder(node.left)\n        self.ans.append(node)\n        if node.right != None:\n            self.getInorder(node.right)\n            \n    def printAns(self):\n        for nd in self.ans:\n            print(\" \" + str(nd.key),end=\"\")\n        print()\n\nm = int(input().rstrip())\ntr = Treap()\nfor i in range(m):\n    line = input().rstrip().split()\n    if line[0] == \"insert\":\n        tr.root = tr.insert(tr.root, int(line[1]), int(line[2]))\n    elif line[0] == \"find\":\n        if tr.find(tr.root, int(line[1])) != None:\n            print(\"yes\")\n        else:\n            print(\"no\")\n    elif line[0] == \"delete\":\n        tr.root = tr.delete(tr.root, int(line[1]))\n    else:\n        tr.resetAns()\n        tr.getInorder(tr.root)\n        tr.printAns()\n        tr.resetAns()\n        tr.getPreorder(tr.root)\n        tr.printAns()\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, key, pri):\n        self.key = key\n        self.pri = pri\n        self.left  = None\n        self.right = None\n\n\ndef rRotate(t):\n    s       = t.left\n    t.left  = s.right\n    s.right = t\n\n    return s\n\n\ndef lRotate(t):\n    s       = t.right\n    t.right = s.left\n    s.left  = t\n\n    return s\n\n\ndef insert(t, key, pri):\n    if t == None: return Node(key, pri)\n\n    if key == t.key: return t\n\n    if key < t.key:\n        t.left = insert(t.left , key, pri)\n        if t.pri < t.left.pri : t = rRotate(t)\n\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.pri < t.right.pri: t = lRotate(t)\n\n    return t\n\n\ndef delete(t, key):\n    if   t == None:\n        return None\n    if   key < t.key:\n        t.left  = delete(t.left , key)\n    elif key > t.key:\n        t.right = delete(t.right, key)\n    else:\n        return _delete(t, key)\n    return t\n\n\ndef _delete(t, key):\n    if t.left == None and t.right == None:\n        return None\n    elif t.left  == None:\n        t = lRotate(t)\n    elif t.right == None:\n        t = rRotate(t)\n    else:\n        if t.left.pri > t.right.pri:\n            t = rRotate(t)\n        else:\n            t = lRotate(t)\n    return delete(t, key)\n\n\ndef find(t, key):\n    if(t == None): return False\n    if(t.key == key ): return True\n\n    return any([find(t.left, key), find(t.right, key)])\n\n\ndef preorder(t):\n    if(t == None): return\n\n    print('', t.key, end = '')\n    preorder(t.left )\n    preorder(t.right)\n\n\ndef inorder(t):\n    if(t == None): return\n\n    inorder(t.left )\n    print('', t.key, end='')\n    inorder(t.right)\n\n\nif __name__ == '__main__':\n    n = int(input())\n    top = None\n\n    for _ in range(n):\n        strs = input().split()\n\n        op  = strs[0]\n        if op != 'print':\n            key = int(strs[1])\n            if op == 'insert':\n                pri = int(strs[2])\n\n\n\n        if op == 'insert': top = insert(top, key, pri)\n        if op == 'delete': top = delete(top, key)\n        if op == 'find'  :\n            if find(top, key): print('yes')\n            else           : print('no' )\n        if op == 'print' :\n            inorder(top)\n            print()\n            preorder(top)\n            print()\n\n"
  },
  {
    "language": "Python",
    "code": "import random\nfrom collections import deque\n\n\nclass TreapNode():\n    \"\"\"節クラス: valは節の値, priorityは節の優先度を表す\n    parent/left/rightはそれぞれ親/左側の子/右側の子へのポインタを表す\n    \"\"\"\n    def __init__(self, val, priority):\n        self.val = val\n        self.priority = priority # random.random()\n        self.parent = None\n        self.right = None\n        self.left = None\n\n\nclass Treap():\n    \"\"\"SSet(Sorted Set)をサポートする\"\"\"\n    def __init__(self):\n        self.root = None\n\n    def search(self, val: int) -> bool:\n        \"\"\"二分木に値valを持つ節が存在するかどうか判定する\n        valと一致する節が存在する場合はTrue、存在しない場合はFalseを返す\n        \"\"\"\n        ptr = self.root\n        while ptr is not None:\n            if ptr.val == val:\n                return True\n            if val < ptr.val:\n                ptr = ptr.left\n            else:\n                ptr = ptr.right\n        return False \n\n    def insert(self, val: int, priority):\n        \"\"\"二分木に値valを持つ節が存在しない場合、追加する\"\"\"\n        if self.root is None:\n            self.root = TreapNode(val, priority)\n            return\n\n        ptr = self.root \n        while True:\n            if val == ptr.val:\n                return\n            elif val < ptr.val:\n                if ptr.left is None:\n                    # ポインタの示す先に節が存在しない場合はNode(val)を追加する\n                    ptr.left = TreapNode(val, priority)\n                    ptr.left.parent = ptr\n                    ptr = ptr.left\n                    break\n                ptr = ptr.left\n            else:\n                if ptr.right is None:\n                    # ポインタの示す先に節が存在しない場合はNode(val)を追加する\n                    ptr.right = TreapNode(val, priority)\n                    ptr.right.parent = ptr\n                    ptr = ptr.right\n                    break\n                ptr = ptr.right\n       \n        while (ptr.parent is not None) and (ptr.parent.priority < ptr.priority):\n            if ptr.parent.right == ptr:\n                self.rotate_left(ptr.parent)\n            else:\n                self.rotate_right(ptr.parent)\n        if ptr.parent is None:\n            self.root = ptr \n          \n          \n    def delete(self, val: int):\n        \"\"\"二分木から値valを持つ節を削除する\"\"\"        \n        ptr = self.root             \n        while True: \n            if ptr is None:\n                return\n            elif val == ptr.val:\n                break\n            elif val < ptr.val:\n                ptr = ptr.left\n            else:\n                ptr = ptr.right\n       \n        while (ptr.left is not None) or (ptr.right is not None):\n            if ptr.left is None:\n                self.rotate_left(ptr)\n            elif ptr.right is None:\n                self.rotate_right(ptr)\n            elif ptr.left.priority > ptr.right.priority:\n                self.rotate_right(ptr)\n            else:\n                self.rotate_left(ptr)\n            if self.root == ptr:\n                self.root = ptr.parent\n       \n        if ptr.parent.left == ptr:\n            ptr.parent.left = None\n        else:\n            ptr.parent.right = None         \n   \n    def rotate_left(self, ptr):\n        \"\"\"木を左回転する\"\"\"\n        w = ptr.right\n        w.parent = ptr.parent\n        if w.parent is not None:\n            if w.parent.left == ptr:\n                w.parent.left = w\n            else:\n                w.parent.right = w\n        ptr.right = w.left\n        if ptr.right is not None:\n            ptr.right.parent = ptr\n        ptr.parent = w\n        w.left = ptr\n        if ptr == self.root:\n            self.root = w\n            self.root.parent = None\n     \n    def rotate_right(self, ptr):\n        \"\"\"木を右回転する\"\"\"\n        w = ptr.left\n        w.parent = ptr.parent\n        if w.parent is not None:\n            if w.parent.right == ptr:\n                w.parent.right = w\n            else:\n                w.parent.left = w\n        ptr.left = w.right\n        if ptr.left is not None:\n            ptr.left.parent = ptr\n        ptr.parent = w\n        w.right = ptr\n        if ptr == self.root:\n            self.root = w\n            self.root.parent = None\n\n    def preorder_tree_walk(self):\n        \"\"\"先行順巡回(preorder tree walk)\"\"\"\n        res = []\n        q = deque([])\n        ptr = self.root\n        while True:\n            if ptr is not None:\n                q.append(ptr) \n                res.append(ptr.val)\n                ptr = ptr.left\n            elif q: \n                ptr = q.pop() \n                ptr = ptr.right\n            else:\n                return res\n \n    def inorder_tree_walk(self):\n        \"\"\"中間順巡回(inorder tree walk)\"\"\"\n        res = []\n        q = deque([])\n        ptr = self.root\n        while True:\n            if ptr is not None:\n                q.append(ptr) \n                ptr = ptr.left\n            elif q: \n                ptr = q.pop() \n                res.append(ptr.val)\n                ptr = ptr.right\n            else:\n                return res\n \n    def postorder_tree_walk(self):\n        \"\"\"後行順巡回(postorder tree walk)\"\"\"\n        res = []\n        q = deque([self.root])\n        ptr = self.root\n        while q:\n            ptr = q.pop()\n            res.append(ptr.val)\n            if ptr.left is not None:\n                q.append(ptr.left)\n            if ptr.right is not None:\n                q.append(ptr.right)\n        return reversed(res)\n\nn = int(input())\ninfo = [list(input().split()) for i in range(n)]\ntp = Treap()\n\nfor i in range(n):\n    if info[i][0] == \"insert\":\n        tp.insert(int(info[i][1]), int(info[i][2]))\n    elif info[i][0] == \"find\":\n        if tp.search(int(info[i][1])):\n            print(\"yes\")\n        else:\n            print(\"no\")\n    elif info[i][0] == \"delete\":\n        tp.delete(int(info[i][1]))\n    else:\n        print(\" \", end=\"\")\n        print(*tp.inorder_tree_walk())\n        print(\" \", end=\"\")\n        print(*tp.preorder_tree_walk())\n"
  },
  {
    "language": "Python",
    "code": "class Node():\n    def __init__(self, key, pri):\n        self.key = key\n        self.pri = pri\n        self.left = self.right = None\n        \n\ndef insert(t, key, pri):\n    if t == None:\n        return Node(key, pri) \n    if key == t.key:\n        return t                             \n\n    if key < t.key:\n        t.left = insert(t.left, key, pri)\n        if t.pri < t.left.pri:\n            t = rightRotate(t)\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.pri < t.right.pri:\n            t = leftRotate(t)\n\n    return t\n        \ndef rightRotate(node):\n    global root\n    a = node.left\n    node.left = a.right\n    a.right = node\n    if node == root:\n        root = a\n    return a\n\ndef leftRotate(node):\n    global root\n    a = node.right\n    node.right = a.left\n    a.left = node\n    if node == root:\n        root = a\n    return a\n    \n        \ndef pre(node):\n    if node == None:return\n    print('',node.key, end = '');pre(node.left);pre(node.right)\n    \ndef ino(node):\n    if node == None:return\n    ino(node.left);print('',node.key,end='');ino(node.right)\n\ndef find(node, key):\n    if node == None:\n        print('no');return\n    if node.key == key:\n        print('yes');return\n    elif node.key > key:\n        find(node.left, key)\n    else:\n        find(node.right, key)\n\ndef delete(t, key):\n    global root\n    if t == None:\n        return None\n    if key < t.key:\n        t.left = delete(t.left, key)\n    elif key > t.key:\n        t.right = delete(t.right, key)\n    elif key == t.key:\n        if t.left == None and t.right == None:\n            return None\n        elif t.left == None:\n            t = leftRotate(t)\n        elif t.right == None:\n            t = rightRotate(t)\n        else:\n            if t.left.pri > t.right.pri:\n                t = rightRotate(t)\n            else:\n                t = leftRotate(t)\n        return delete(t, key)\n    return t\n\n    \n\nn = int(input())\nroot = None\nfor j in range(n):\n    s, *i = input().split()\n    if s[0] == 'i':root = insert(root,int(i[0]), int(i[1]))\n    elif s[0] == 'f':\n        find(root, int(i[0]))\n    elif s[0] == 'd':\n        delete(root, int(i[0]))\n    else:\n        ino(root);print();pre(root);print()\n        \n    \n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nclass Node:\n  def __init__(self, key, priority, left=None, right=None):\n    self.key = key\n    self.priority = priority\n    self.left = left\n    self.right = right\n  \ndef rightRotate(t):\n  s = t.left\n  t.left = s.right\n  s.right = t\n  return s\n\ndef leftRotate(t):\n  s = t.right\n  t.right = s.left\n  s.left = t\n  return s\n\ndef insert(t, key, priority):\n  \n  if not t: return Node(key, priority)\n  if key == t.key: return t\n  \n  if key < t.key: \n    t.left = insert(t.left, key, priority)\n    if t.priority < t.left.priority:\n      t = rightRotate(t)\n  else:\n    t.right = insert(t.right, key, priority)\n    if t.priority < t.right.priority:\n      t = leftRotate(t)\n  \n  return t\n\ndef erase(t, key):\n  \n  if not t: return None\n  \n  if key == t.key:\n    if (not t.left) and (not t.right): return None\n    elif not t.left: \n      t = leftRotate(t)\n    elif not t.right:\n      t = rightRotate(t)\n    else:\n      if t.left.priority > t.right.priority:\n        t = rightRotate(t)\n      else:\n        t = leftRotate(t)\n    return erase(t, key)\n  elif key > t.key:\n    t.right = erase(t.right, key)\n  else:\n    t.left = erase(t.left, key)\n  return t\n\n\ndef find(t, key):\n  if t.key == key:\n    print(\"yes\")\n  elif t.key < key and t.right != None:\n    find(t.right, key)\n  elif t.key > key and t.left != None:\n    find(t.left, key)\n  else:\n    print(\"no\")\n  return 0\n\ndef in_print(t):\n  if t.left != None:\n    in_print(t.left)\n  print(\" \" + str(t.key), end='')\n  if t.right != None:\n    in_print(t.right)\n\ndef pre_print(t):\n  print(\" \" + str(t.key), end='')\n  if t.left != None:\n    pre_print(t.left)\n  if t.right != None:\n    pre_print(t.right)\n  \nTreap = None\nnum = int(input())\nfor i in range(num):\n  string = list(input().split())\n  if string[0] == \"insert\":\n    key = int(string[1])\n    priority = int(string[2])\n    Treap = insert(Treap, key, priority)\n  elif string[0] == \"find\":\n    key = int(string[1])\n    find(Treap, key)\n  elif string[0] == \"delete\":\n    key = int(string[1])\n    Treap = erase(Treap, key)\n  else:\n    in_print(Treap)\n    print()\n    pre_print(Treap)\n    print()\n    \n\n  \n"
  },
  {
    "language": "Python",
    "code": "import sys\nimport time\ninput = sys.stdin.readline\n\ndef left_rot(node):\n    s = node['right'].copy()\n    node['right'] = s['left']#.copy()\n    s['left'] = node\n    return s\n\ndef right_rot(node):\n    s = node['left'].copy()\n    node['left'] = s['right']#.copy()\n    s['right'] = node\n    return s\n\ndef insert(node,k,p):\n    if(node is None):\n        child = {\n            'left' : None,\n            'right' : None,\n            'key' : k,\n            'priority' : p}\n        return child\n    if(k == node['key']):\n        return node\n    # Left side\n    if(k < node['key']):\n        node['left'] = insert(node['left'],k,p)\n        #追加したらあとは優先度による回転を行う\n        if(node['priority'] < node['left']['priority']):\n            node = right_rot(node)\n    # Right side\n    else:\n        node['right'] = insert(node['right'],k,p)\n        #追加したらあとは以下略\n        if(node['priority'] < node['right']['priority']):\n            node = left_rot(node)\n\n    return node\n\ndef find(node, k):\n    if(node is None):\n        return 'no'\n    if(node['key'] == k):\n        return 'yes'\n    if(k < node['key']):\n        return find(node['left'],k)\n    else:\n        return find(node['right'],k)\n\ndef delete(node, k):\n    if(node is None):\n        return None\n\n    if(node['key'] == k):\n        if(node['left'] is None and node['right'] is None):\n            return None\n        elif(node['left'] is None):\n            node = left_rot(node)\n        elif(node['right'] is None):\n            node = right_rot(node)\n        else:\n            if(node['left']['priority'] > node['right']['priority']):\n                node = right_rot(node)\n            else:\n                node = left_rot(node)\n        return delete(node, k)\n    if(k < node['key']):\n        node['left'] = delete(node['left'], k)\n    else:\n        node['right'] = delete(node['right'], k)\n\n    return node\n\ndef print_treap(node,values):\n    if(node is None):\n        return values\n    values.append(node['key'])\n    values = print_treap(node['left'],values)\n    values = print_treap(node['right'],values)\n    return values\n\nnum = int(input())\nreq = [input().split() for _ in range(num)]\nnode = None\nvalues = []\nfor q in req:\n    if(q[0] == 'insert'):\n        node = insert(node, int(q[1]),int(q[2]))\n    elif(q[0] == 'find'):\n        print(find(node,int(q[1])))\n    elif(q[0] == 'delete'):\n        node = delete(node, int(q[1]))\n    else:\n        print_treap(node, values)\n        print(\" \"+\" \".join(map(str, sorted(values))))\n        print(\" \"+\" \".join(map(str, values)))\n        values.clear()\n\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, key, pri):\n        self.key = key\n        self.pri = pri\n        self.left  = None\n        self.right = None\n\n\ndef rightRotate(t):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s\n\ndef leftRotate(t):\n    s = t.right\n    t.right = s.left\n    s.left = t\n    return s\n\ndef insert(t, key, pri):\n    if t == None:\n        return Node(key, pri)\n\n    if key == t.key:\n        return t\n\n    if key < t.key:\n        t.left = insert(t.left, key, pri)\n        if t.pri < t.left.pri:\n            t = rightRotate(t)\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.pri < t.right.pri:\n            t = leftRotate(t)\n\n    return t\n\n\ndef delete(t, key):\n    if t == None:\n        return None\n\n    if key == t.key:\n        if t.right == None and t.left == None:\n            return None\n        elif t.left == None:\n            t = leftRotate(t)\n        elif t.right == None:\n            t = rightRotate(t)\n        else :\n            if t.left.pri > t.right.pri:\n                t = rightRotate(t)\n            else :\n                t = leftRotate(t)\n        return delete(t, key)\n\n    if key < t.key:\n        t.left = delete(t.left, key)\n    else:\n        t.right = delete(t.right, key)\n\n    return t\n\n\ndef find(t, key):\n    if t == None:\n        return False\n\n    if key == t.key:\n        return True\n\n    if key < t.key:\n        return find(t.left, key)\n    else:\n        return find(t.right, key)\n\ndef priorder(t):\n    if t == None:\n        return\n\n    print('' + str(t.key), end='')\n    priorder(t.left)\n    priorder(t.right)\n\ndef inorder(t):\n    if t == None:\n        return\n\n    inorder(t.left)\n    print('' + str(t.key), end='')\n    inorder(t.right)\n\n\nm = int(input())\nt = None\n\nfor _ in range(m):\n    com = input().split()\n\n    if com[0] == 'insert':\n        t = insert(t, int(com[1]), int(com[2]))\n    elif com[0] == 'find':\n        if find(t, int(com[1])):\n            print('yes')\n        else :\n            print('no')\n    elif com[0] == 'delete':\n        delete(t, int(com[1]))\n    elif com[0] == 'print':\n        inorder(t)\n        print()\n        priorder(t)\n        print()\n\n"
  },
  {
    "language": "Python",
    "code": "# Treap\nclass Node():\n    def __init__(self, k, p):\n        self.k = k\n        self.p = p\n        self.left = None\n        self.right = None\n\ndef rightRotate(t):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s\n\ndef leftRotate(t):\n    s = t.right\n    t.right = s.left\n    s.left = t\n    return s\n\ndef insert(t, key, pri):\n    if t == None:\n        return Node(key, pri)\n    if key == t.k:\n        return t\n\n    if key < t.k:\n        t.left = insert(t.left, key, pri)\n        if t.p < t.left.p:\n            t = rightRotate(t)\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.p < t.right.p:\n            t = leftRotate(t)\n    return t\n\ndef erase(t, key):\n    if t == None:\n        return None\n\n    if key == t.k:\n        if t.left == None and t.right == None:\n            return None\n        elif t.left == None:\n            t = leftRotate(t)\n        elif t.right == None:\n            t = rightRotate(t)\n        else:\n            if t.left.p > t.right.p:\n                t = rightRotate(t)\n            else:\n                t = leftRotate(t)\n        return erase(t, key)\n\n    if key < t.k:\n        t.left = erase(t.left, key)\n    else:\n        t.right = erase(t.right, key)\n    return t\n\"\"\"\ndef find(t, k):\n    if t == None:\n        return -1\n    if t.k == k:\n        return 1\n    if find(t.left, k) == 1:\n        return 1\n    if find(t.right, k) == 1:\n        return 1\n\"\"\"\ndef inorder(t):\n    if t == None:\n        return \n    inorder(t.left)\n    print(\" \" + str(t.k), end=\"\")\n    inorder(t.right)\n\ndef preorder(t):\n    if t == None:\n        return\n    print(\" \" + str(t.k), end=\"\")\n    preorder(t.left)\n    preorder(t.right)\n\ndef output(t):\n    inorder(t)\n    print()\n    preorder(t)\n    print()\n\n\nt = None\ndata = []\ndict = {}\nm = int(input())\nfor i in range(m):\n    data.append(list(input().split()))\n\nfor i in range(m):\n    if data[i][0] == \"insert\":\n        if (data[i][1] in dict) == False:\n            t = insert(t, int(data[i][1]), int(data[i][2]))\n            dict[data[i][1]] = True\n    elif data[i][0] == \"print\":\n        output(t)\n    elif data[i][0] == \"find\":\n        #result = find(t, int(data[i][1]))\n        #if result == 1:\n        #print(dict)\n        #result = data[i][1] in dict\n        #print(\"result\", result)\n        #print(\"2\", result == True)\n        #print(data[i][1] in dict, data[i][1])\n        if (data[i][1] in dict) == True:\n            #print(\"12345\")\n            print(\"yes\")\n        else:\n            print(\"no\")\n    else:\n        t = erase(t, int(data[i][1]))\n        if (data[i][1] in dict) == True:\n            del dict[data[i][1]]\n        #print(dict)\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, key=None, pri=None, left=None, right=None):\n        self.key = key\n        self.pri = pri\n        self.left = left\n        self.right = right\n        self.parent = None\n\ndef rRotate(t):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s\n\ndef lRotate(t):\n    s = t.right\n    t.right = s.left\n    s.left = t\n    return s\n\ndef insert(t, key, pri):\n    if t == None:\n        return Node(key, pri)\n    if key == t.key:\n        return t\n\n    if key < t.key:\n        t.left = insert(t.left, key, pri)\n        if t.pri < t.left.pri:\n            t = rRotate(t)\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.pri < t.right.pri:\n            t = lRotate(t)\n\n    return t\n\ndef find(x, k):\n    while x != None and k != x.key:\n        if x.key != None:\n            if k < x.key:\n                x = x.left\n            else:\n                x = x.right\n    return x\n\ndef delete(t, key):\n    if t == None:\n        return None\n    if key < t.key:\n        t.left = delete(t.left, key)\n    elif key > t.key:\n        t.right = delete(t.right, key)\n    else:\n        if t.left == None and t.right == None:\n            return None\n        elif t.left == None:\n            t = lRotate(t)\n        elif t.right == None:\n            t = rRotate(t)\n        else:\n            if t.left.pri > t.right.pri:\n                t = rRotate(t)\n            else:\n                t = lRotate(t)\n        return delete(t, key)\n    return t\n\ndef inorder(u):\n    if u == None:\n        return\n    inorder(u.left)\n    print(' ' + str(u.key), end=\"\")\n    inorder(u.right)\n\ndef preorder(u):\n    if u == None:\n        return\n    print(' ' + str(u.key), end=\"\")\n    preorder(u.left)\n    preorder(u.right)\n\ncount = int(input())\nt = None\nfor i in range(count):\n    a = input().split()\n    if a[0] == 'insert':\n        t = insert(t, int(a[1]), int(a[2]))\n    elif a[0] == 'find':\n        if find(t, int(a[1])) == None:\n            print('no')\n        else:\n            print('yes')\n    elif a[0] == 'delete':\n        t = delete(t, int(a[1]))\n    else:\n        inorder(t)\n        print('\\n', end=\"\")\n        preorder(t)\n        print('\\n', end=\"\")\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import namedtuple\n\n\nNode = namedtuple('Node', ['key', 'priority', 'left', 'right'])\n\n\nclass Treap:\n    MAX_KEY = 2000000000\n    MAX_PRIORITY = 2000000000\n\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key, priority):\n        def _insert(node):\n            if node is None:\n                return Node(key, priority, None, None)\n            if key < node.key:\n                node = node._replace(left=_insert(node.left))\n                if node.priority < node.left.priority:\n                    node = self._rotate_right(node)\n            elif key > node.key:\n                node = node._replace(right=_insert(node.right))\n                if node.priority < node.right.priority:\n                    node = self._rotate_left(node)\n            else:  # node.key == key\n                pass\n            assert(self._bst_invariant(node))\n            assert(self._heap_invariant(node))\n            return node\n\n        self.root = _insert(self.root)\n\n    def delete(self, key):\n        def _delete(node):\n            if node is None:\n                return None\n            if key < node.key:\n                node = node._replace(left=_delete(node.left))\n            elif key > node.key:\n                node = node._replace(right=_delete(node.right))\n            else:  # node.key == key\n                if node.left is None:\n                    node = node.right\n                elif node.right is None:\n                    node = node.left\n                else:\n                    if node.left.priority > node.right.priority:\n                        node = _delete(self._rotate_right(node))\n                    else:\n                        node = _delete(self._rotate_left(node))\n            assert(self._bst_invariant(node))\n            assert(self._heap_invariant(node))\n            return node\n\n        self.root = _delete(self.root)\n\n    def find(self, key):\n        def _find(node):\n            if node is None:\n                return False\n            if key < node.key:\n                return _find(node.left)\n            elif key > node.key:\n                return _find(node.right)\n            else:\n                return True\n\n        return _find(self.root)\n\n    def inorder(self):\n        def _inorder(node):\n            if node is not None:\n                yield from _inorder(node.left)\n                yield node\n                yield from _inorder(node.right)\n        return _inorder(self.root)\n\n    def preorder(self):\n        def _preorder(node):\n            if node is not None:\n                yield node\n                yield from _preorder(node.left)\n                yield from _preorder(node.right)\n        return _preorder(self.root)\n\n    def postorder(self):\n        def _postorder(node):\n            if node is not None:\n                yield from _postorder(node.left)\n                yield from _postorder(node.right)\n                yield node\n        return _postorder(self.root)\n\n    def _rotate_left(self, node):\n        assert node.right is not None\n        top = node.right\n        node = node._replace(right=top.left)\n        top = top._replace(left=node)\n        return top\n\n    def _rotate_right(self, node):\n        assert node.left is not None\n        top = node.left\n        node = node._replace(left=top.right)\n        top = top._replace(right=node)\n        return top\n\n    def _heap_invariant(self, node):\n        if node is None:\n            return True\n        key, priority, left, right = node\n        return ((left is None or priority > left.priority)\n                and (right is None or priority > right.priority))\n\n    def _bst_invariant(self, node):\n        if node is None:\n            return True\n        key, priority, left, right = node\n        return ((left is None or key > left.key)\n                and (right is None or key < right.key))\n\n    def __str__(self):\n        def _str(node):\n            if node is None:\n                return ''\n            else:\n                k, p, l, r = node\n                return '({}[{}/{}]{})'.format(_str(l), k, p, _str(r))\n        return _str(self.root)\n\n\ndef run():\n    input()\n    tree = Treap()\n\n    for line in sys.stdin:\n        if line.startswith('insert'):\n            key, priority = [int(i) for i in line[7:].split()]\n            tree.insert(key, priority)\n        elif line.startswith('find'):\n            if tree.find(int(line[5:])):\n                print(\"yes\")\n            else:\n                print(\"no\")\n        elif line.startswith('delete'):\n            tree.delete(int(line[7:]))\n        elif line.startswith('print'):\n            print(' {}'.format(' '.join([str(n.key) for n\n                                         in tree.inorder()])))\n            print(' {}'.format(' '.join([str(n.key) for n\n                                         in tree.preorder()])))\n        else:\n            raise ValueError('invalid command')\n        # print(tree)\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "class node:\n    def __init__(self,key,pri,left=None,right=None):\n        self.left = left\n        self.right = right\n        self.key = key\n        self.pri = pri\n\ndef insert(n,key,pri):\n    if(n == None):\n        return node(key,pri)\n    if(key == n.key):\n        return n\n    if(key < n.key):\n        n.left = insert(n.left, key, pri)\n        if(n.pri < n.left.pri):\n            n = rightRotate(n)\n    else:\n        n.right = insert(n.right, key, pri)\n        if(n.pri < n.right.pri):\n            n = leftRotate(n)\n    return n\n\n\ndef rightRotate(n):\n    child = n.left\n    swapL,swapR,swapK,swapP = child.left,child.right,child.key,child.pri\n    n.left = swapR\n    n = node(swapK,swapP,swapL,n)\n    return n\n\ndef leftRotate(n):\n    child = n.right\n    swapL,swapR,swapK,swapP = child.left,child.right,child.key,child.pri\n    n.right = swapL\n    n = node(swapK,swapP,n,swapR)\n    return n\n\ndef find(n,key):\n    if(n == None):\n        return None\n    elif(n.key == key):\n        return n\n    elif(n.key > key):\n        return find(n.left,key)\n    else:\n        return find(n.right,key)\n\ndef delete(n, key):\n    if(n == None):\n        return None\n    if(key < n.key):\n        n.left = delete(n.left, key)\n    elif(key > n.key):\n        n.right = delete(n.right, key)\n    else:\n        return _delete(n, key)\n    return n\n\ndef _delete(n, key):\n    if(n.left == None and n.right == None):\n        return None\n    elif(n.left == None):\n        n = leftRotate(n)\n    elif(n.right == None):\n        n = rightRotate(n)\n    else:\n        if(n.left.pri > n.right.pri):\n            n = rightRotate(n)\n        else:\n            n = leftRotate(n)\n    return delete(n, key)\n\ndef inorder(n):\n    if(n==None):\n        return\n    if(n.left != None):\n        inorder(n.left)\n    print(\" \"+str(n.key), end='')\n    if(n.right != None):\n        inorder(n.right)\n\ndef preorder(n):\n    if(n==None):\n        return\n    print(\" \"+str(n.key), end='')\n    if(n.left != None):\n        preorder(n.left)\n    if(n.right != None):\n        preorder(n.right)\n\nop_num=(int)(input())\nroot = None\nfor i in range(op_num):\n    items = input().split()\n    if(items[0] == \"insert\"):\n        root = insert(root,(int)(items[1]),(int)(items[2]))\n    elif(items[0] == \"delete\"):\n        root = delete(root,(int)(items[1]))\n    elif(items[0] == \"find\"):\n        res = find(root,(int)(items[1]))\n        if(res == None):\n            print(\"no\")\n        else:\n            print(\"yes\")\n    else:\n        inorder(root)\n        print(\"\")\n        preorder(root)\n        print(\"\")\n\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, key, pri):\n        self.left = None\n        self.right = None\n        self.key = key\n        self.pri = pri\n\n    def print_pre(self):\n        yield self.key\n        if self.left:\n            for k in self.left.print_pre(): yield k\n        if self.right:\n            for k in self.right.print_pre(): yield k\n\n    def print_in(self):\n        if self.left:\n            for k in self.left.print_in(): yield k\n        yield self.key\n        if self.right:\n            for k in self.right.print_in(): yield k\n\nclass Tree:\n  root = None\n\n  def rightRotate(self, node):\n    s = node.left\n    node.left = s.right\n    s.right = node\n    if self.root == node:\n      self.root = s\n    return s\n\n  def leftRotate(self, node):\n    s = node.right\n    node.right = s.left\n    s.left = node\n    if self.root == node:\n      self.root = s\n    return s\n\n  def insert1(self, node, key, pri):\n    if node == None:\n      return Node(key, pri)\n    elif key == node.key:\n      return node\n\n    elif key < node.key:\n      node.left = self.insert1(node.left, key, pri)\n      if node.pri < node.left.pri:\n        node = self.rightRotate(node)\n    else:\n      node.right = self.insert1(node.right, key, pri)\n      if node.pri < node.right.pri:\n        node = self.leftRotate(node)\n    return node\n\n  def insert(self, key, pri):\n    self.insert1(self.root, key, pri)\n    if self.root == None:\n      self.root = Node(key, pri)\n\n  def delete(self, node, key):\n    if node == None:\n      return None\n    if key < node.key:\n      node.left = self.delete(node.left, key)\n    elif key > node.key:\n      node.right = self.delete(node.right, key)\n    else:\n      return self.delete1(node, key)\n    return node\n\n  def delete1(self, node, key):\n    if node.left == None and node.right == None:\n      return None\n    elif node.left == None:\n      node = self.leftRotate(node)\n    elif node.right == None:\n      node = self.rightRotate(node)\n    else:\n      if node.left.pri > node.right.pri:\n        node = self.rightRotate(node)\n      else:\n        node = self.leftRotate(node)\n    return self.delete(node, key)\n\n  def find(self, key):\n        y = None\n        x = self.root\n        while x:\n            y = x\n            if key == x.key:\n              break\n            elif key < x.key:\n              x = x.left\n            else:\n              x = x.right\n            \n        if key == y.key:\n            return y\n\n  def print(self):\n        print(' ', end='')\n        print(*self.root.print_in())\n        print(' ', end='')\n        print(*self.root.print_pre())\n\ntree = Tree()\nm = int(input())\n\nwhile m:\n  l = input().split()\n  if len(l) == 3:\n    tree.insert(int(l[1]), int(l[2]))\n  elif len(l) == 2 and l[0] == \"find\":\n    y = tree.find(int(l[1]))\n    if y:\n      print(\"yes\")\n    else:\n      print(\"no\")\n  elif len(l) == 2 and l[0] == \"delete\":\n    tree.delete(tree.root, int(l[1]))\n  else:\n    tree.print()\n  m -= 1\n"
  },
  {
    "language": "Python",
    "code": "from random import random\nfrom collections import deque\nfrom copy import deepcopy\nimport sys\ninput = sys.stdin.readline\n\nclass Treap:\n    def __init__(self, iterable=None):\n        # vertex = [left, right, key, priority, #descendants, sum of descendants]\n        self.root = None\n        if iterable: self._construct(iterable)\n    \n    def _construct(self, iterable):\n        for it in iterable: self.insert(it)\n    \n    def __len__(self): return self._count(self.root)\n    \n    @staticmethod\n    def _count(v): return v[4] if v is not None else 0\n\n    def _rotate(self, v, direction): # rotate the vertex v to the given direction\n        c = v[1 - direction] # direction == 1: right rotation\n        v[1 - direction], t = c[direction], c[1 - direction]\n        c[direction] = v\n        # update vertex's information\n        n_desc, sum_desc = c[4:] = v[4:]\n        v[4:] = n_desc - 1 - self._count(t), sum_desc - (c[2] if c[2] else 0) - (t[5] if t else 0)\n        return c # new parent\n    \n    def __contains__(self, key): # check whether the given key is in the treap\n        if self.root is None: return False\n        v = self.root\n        while v:\n            k = v[2]\n            if k == key: return True\n            v = v[key > k] # key > v[2] -> v = v[1] (right child)\n        return False\n    \n    def __getitem__(self, i): # get the i-th smallest element in the treap\n        count = self._count\n        if i < 0: i = count(self.root) + i\n        if i >= count(self.root) or i < 0: raise IndexError\n        v = self.root\n        while True:\n            n_left = count(v[0])\n            if i == n_left: return v[2]\n            elif i > n_left: i -= n_left + 1; v = v[1]\n            else: v = v[0]\n    \n    def __repr__(self): # visualize the treap\n        if not self.root: return 'Treap([])'\n        elements = []\n        q = deque([self.root])\n        while q:\n            v = q.popleft()\n            if v is None: elements.append(v); continue\n            elements.append((v[2], v[3]))\n            q.append(v[0]); q.append(v[1])\n        return 'Treap({})'.format(str(elements))\n    \n    @classmethod\n    def _treap(cls, treapnode):\n        tp = cls(); tp.root = deepcopy(treapnode)\n        return tp\n            \n    def sort(self):\n        if not self.root: return []\n        elements = []\n        stack = [(self.root, 0)]\n        while stack:\n            v, st = stack.pop()\n            [left, right, k, _, _, _] = v\n            if st == 0:\n                if right: stack.append((right, 0))\n                stack.append((v, 1))\n                if left: stack.append((left, 0))\n            if st == 1: elements.append(k)\n        return elements\n    \n    def bisect(self, key): # bisect_right\n        if self.root is None: return 0\n        v = self.root; idx = 0\n        count = self._count\n        while v:\n            left, right, k, _, _, _ = v\n            if key >= k: idx += count(left) + 1; v = right\n            else: v = left\n        return idx\n    \n    def insert(self, key, priority=None):\n        if priority is None: priority = random()\n        rotate = self._rotate\n        v = self.root; p = None; direction = None\n        stack = []\n        while v:\n            direction = (key >= v[2])\n            stack.append((v, direction))\n            v, p = v[direction], v\n        v = [None, None, key, priority, 1, key]\n        while stack:\n            p, direction = stack.pop()\n            p[direction] = v\n            p[4] += 1; p[5] += key # update vertex's information\n            if p[3] >= v[3]: break\n            v = rotate(p, 1 - direction)\n        else: self.root = v\n        for p, _ in stack: p[4] += 1; p[5] += key # update vertex's information\n        return self.root\n    \n    def delete(self, key):\n        v = self.root; p = None; direction = None\n        stack = []\n        while v:\n            if key == v[2]: break # vertex to be deleted has been found\n            direction = (key > v[2])\n            stack.append((v, direction))\n            v, p = v[direction], v\n        else: return self.root # the given key is not in the treap\n        rotate = self._rotate\n        while v[0] or v[1]: # while v is not a leaf\n            left, right, _, _, _, _ = v\n            direction = (left[3] > right[3]) if left and right else (right is None)\n            p = rotate(v, direction)\n            stack.append((p, direction)); v = p[direction]\n        v = None # delete\n        while stack:\n            p, direction = stack.pop()\n            p[direction] = v\n            p[4] -= 1; p[5] -= (key if key else 0) # update vertex's information\n            v = p\n        self.root = v\n        return self.root\n    \n    def merge(self, other):\n        r, o = self.root, other.root\n        temp_v = [r, o, None, float('inf'), 1 + r[4] + o[4], r[5] + o[5]]\n        virtual = self._treap(temp_v)\n        self.root = virtual.delete(None)\n        return self.root\n    \n    def split(self, i):\n        count = self._count\n        if i < 0: i = count(self.root) + i\n        if i >= count(self.root) or i < 0: raise IndexError\n        rotate = self._rotate\n        v = self.root; p = None; direction = None\n        stack = []\n        while v:\n            n_left = count(v[0])\n            direction = (i > n_left)\n            stack.append((v, direction))\n            if direction: i -= n_left + 1\n            v, p = v[direction], v\n        v = [None, None, None, float('inf'), 1, 0]\n        while stack:\n            p, direction = stack.pop()\n            p[direction] = v\n            p[4] += 1; p[5] += 0 # update vertex's information\n            v = rotate(p, 1 - direction)\n        l, r = v[:2]\n        self.root = l\n        return self._treap(r)\n\ndef print_treap(tr):\n    preorder = ['']\n    inorder = ['']\n    def dfs(vtx):\n        v = str(vtx[2])\n        preorder.append(v)\n        if vtx[0]: dfs(vtx[0])\n        inorder.append(v)\n        if vtx[1]: dfs(vtx[1])\n    dfs(tr.root)\n    print(' '.join(inorder))\n    print(' '.join(preorder))\n    return\n    \nm = int(input())\ntr = Treap()\nfor _ in range(m):\n    query, *args, = input().split()\n    if query == 'insert':\n        k, p = map(int, args)\n        tr.insert(k, p)\n    elif query == 'find':\n        k = int(args[0])\n        print('yes' if k in tr else 'no')\n    elif query == 'delete':\n        k = int(args[0])\n        tr.delete(k)\n    else:\n        print_treap(tr)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef rotate(nd, d):\n    c = nd[d]\n    if d:\n        nd[1] = c[0]\n        c[0] = nd\n    else:\n        nd[0] = c[1]\n        c[1] = nd\n    return c\n\n\nroot = None\ndef insert(val, pri):\n    global root\n    st = []\n    dr = []\n    x = root\n    while x:\n        st.append(x)\n        if x[2] == val:\n            return\n        d = (x[2] < val)\n        dr.append(d)\n        x = x[d]\n    nd = [None, None, val, pri]\n    while st:\n        x = st.pop(); d = dr.pop()\n        c = x[d] = nd\n        if x[3] >= c[3]:\n            break\n        rotate(x, d)\n    else:\n        root = nd\n\ndef __delete(nd):\n    st = []; dr = []\n    while nd[0] or nd[1]:\n        l = nd[0]; r = nd[1]\n        d = (l[3] <= r[3]) if l and r else (l is None)\n        st.append(rotate(nd, d))\n        dr.append(d ^ 1)\n    nd = x = None\n    while st:\n        nd = x; x = st.pop(); d = dr.pop()\n        x[d] = nd\n    return x\n\ndef delete(val):\n    global root\n    x = root\n\n    y = None\n    while x:\n        if val == x[2]:\n            break\n        y = x; d = (x[2] < val)\n        x = x[d]\n    else:\n        return\n\n    if y:\n        y[d] = __delete(x)\n    else:\n        root = __delete(x)\n\ndef find(val):\n    x = root\n    while x:\n        if val == x[2]:\n            return 1\n        x = x[x[2] < val]\n    return 0\n\ndef debug():\n    s0 = [\"\"]\n    s1 = [\"\"]\n\n    def dfs(nd):\n        v = str(nd[2])\n        s0.append(v)\n        if nd[0]:\n            dfs(nd[0])\n        s1.append(v)\n        if nd[1]:\n            dfs(nd[1])\n    dfs(root)\n    return \" \".join(s1), \" \".join(s0)\n\n\nM = int(readline())\nans = []\nfor m in range(M):\n    cmd, *V, = readline().split()\n    if cmd == \"print\":\n        ans.extend(debug())\n    elif cmd == \"find\":\n        ans.append(\"yes\" if find(int(V[0])) else \"no\")\n    elif cmd == \"delete\":\n        delete(int(V[0]))\n    else:\n        val, pri = map(int, V)\n        insert(val, pri)\nwrite(\"\\n\".join(ans))\nwrite(\"\\n\")\n\n\n"
  },
  {
    "language": "Python",
    "code": "# Treap\nclass Node():\n    def __init__(self, k, p):\n        self.k = k\n        self.p = p\n        self.left = None\n        self.right = None\n\ndef rightRotate(t):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s\n\ndef leftRotate(t):\n    s = t.right\n    t.right = s.left\n    s.left = t\n    return s\n\ndef insert(t, key, pri):\n    if t == None:\n        return Node(key, pri)\n    if key == t.k:\n        return t\n\n    if key < t.k:\n        t.left = insert(t.left, key, pri)\n        if t.p < t.left.p:\n            t = rightRotate(t)\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.p < t.right.p:\n            t = leftRotate(t)\n    return t\n\ndef erase(t, key):\n    if t == None:\n        return None\n\n    if key == t.k:\n        if t.left == None and t.right == None:\n            return None\n        elif t.left == None:\n            t = leftRotate(t)\n        elif t.right == None:\n            t = rightRotate(t)\n        else:\n            if t.left.p > t.right.p:\n                t = rightRotate(t)\n            else:\n                t = leftRotate(t)\n        return erase(t, key)\n\n    if key < t.k:\n        t.left = erase(t.left, key)\n    else:\n        t.right = erase(t.right, key)\n    return t\n\ndef find(t, k):\n    if t == None:\n        return -1\n    if t.k == k:\n        return 1\n    if find(t.left, k) == 1:\n        return 1\n    if find(t.right, k) == 1:\n        return 1\n\ndef inorder(t):\n    if t == None:\n        return \n    inorder(t.left)\n    print(\" \" + str(t.k), end=\"\")\n    inorder(t.right)\n\ndef preorder(t):\n    if t == None:\n        return\n    print(\" \" + str(t.k), end=\"\")\n    preorder(t.left)\n    preorder(t.right)\n\ndef output(t):\n    inorder(t)\n    print()\n    preorder(t)\n    print()\n\n\nt = None\ndata = []\nm = int(input())\nfor i in range(m):\n    data.append(list(input().split()))\n\nfor i in range(m):\n    if data[i][0] == \"insert\":\n        t = insert(t, int(data[i][1]), int(data[i][2]))\n    elif data[i][0] == \"print\":\n        output(t)\n    elif data[i][0] == \"find\":\n        result = find(t, int(data[i][1]))\n        if result == 1:\n            print(\"yes\")\n        else:\n            print(\"no\")\n    else:\n        t = erase(t, int(data[i][1]))\n"
  },
  {
    "language": "Python",
    "code": "class Node:\n    def __init__(self, key, pri):\n        self.key = key\n        self.pri = pri\n        self.left  = None\n        self.right = None\n\n\ndef rightRotate(t):\n    s = t.left\n    t.left = s.right\n    s.right = t\n    return s\n\ndef leftRotate(t):\n    s = t.right\n    t.right = s.left\n    s.left = t\n    return s\n\ndef insert(t, key, pri):\n    if t == None:\n        return Node(key, pri)\n\n    if key == t.key:\n        return t\n\n    if key < t.key:\n        t.left = insert(t.left, key, pri)\n        if t.pri < t.left.pri:\n            t = rightRotate(t)\n    else:\n        t.right = insert(t.right, key, pri)\n        if t.pri < t.right.pri:\n            t = leftRotate(t)\n\n    return t\n\n\ndef delete(t, key):\n    if t == None:\n        return None\n\n    if key == t.key:\n        if t.right == None and t.left == None:\n            return None\n        elif t.left == None:\n            t = leftRotate(t)\n        elif t.right == None:\n            t = rightRotate(t)\n        else :\n            if t.left.pri > t.right.pri:\n                t = rightRotate(t)\n            else :\n                t = leftRotate(t)\n        return delete(t, key)\n\n    if key < t.key:\n        t.left = delete(t.left, key)\n    else:\n        t.right = delete(t.right, key)\n\n    return t\n\n\ndef find(t, key):\n    if t == None:\n        return False\n        \n    if key == t.key:\n        return True\n\n    if key < t.key:\n        return find(t.left, key)\n    else:\n        return find(t.right, key)\n\ndef priorder(t):\n    if t == None:\n        return\n\n    print(\" \" + str(t.key), end='')\n    priorder(t.left)\n    priorder(t.right)\n\ndef inorder(t):\n    if t == None:\n        return\n\n    inorder(t.left)\n    print(\" \" + str(t.key), end='')\n    inorder(t.right)\n\n\nm = int(input())\nt = None\n\nfor i in range(m):\n    com = input().split()\n\n    if com[0] == \"insert\":\n        t = insert(t, int(com[1]), int(com[2]))\n    elif com[0] == \"find\":\n        if find(t, int(com[1])):\n            print(\"yes\")\n        else :\n            print(\"no\")\n    elif com[0] == \"delete\":\n        delete(t, int(com[1]))\n    elif com[0] == \"print\":\n        inorder(t)\n        print()\n        priorder(t)\n        print()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nclass Node:\n  def __init__(self, key, priority, left=None, right=None):\n    self.key = key\n    self.priority = priority\n    self.left = left\n    self.right = right\n  \ndef rightRotate(t):\n  s = t.left\n  t.left = s.right\n  s.right = t\n  return s\n\ndef leftRotate(t):\n  s = t.right\n  t.right = s.left\n  s.left = t\n  return s\n\ndef insert(t, key, priority):\n  \n  if not t: return Node(key, priority)\n  if key == t.key: return t\n  \n  if key < t.key: \n    t.left = insert(t.left, key, priority)\n    if t.priority < t.left.priority:\n      t = rightRotate(t)\n  else:\n    t.right = insert(t.right, key, priority)\n    if t.priority < t.right.priority:\n      t = leftRotate(t)\n  \n  return t\n\ndef erase(t, key):\n  \n  if not t: return None\n  \n  if key == t.key:\n    if (not t.left) and (not t.right): return None\n  elif not t.left: \n    t = leftRotate(t)\n  elif not t.right:\n    t = rightRotate(t)\n  else:\n    if t.left.priority > t.right.priority:\n      t = rightRotate(t)\n    else:\n      t = leftRotate(t)\n  return erase(t, key)\n\n  if key < t.key:\n    t.left = erase(t.left, key)\n  else:\n    t.right = erase(t.right, key)\n  return t\n\ndef find(t, key):\n  if t.key == key:\n    print(\"yes\")\n  elif t.key < key and t.right != None:\n    find(t.right, key)\n  elif t.key > key and t.left != None:\n    find(t.left, key)\n  else:\n    print(\"no\")\n  return 0\n\ndef in_print(t):\n  if t.left != None:\n    in_print(t.left)\n  print(\" \" + str(t), end='')\n  if t.right != None:\n    in_print(t.right)\n\ndef pre_print(t):\n  print(\" \" + str(t), end='')\n  if t.left != None:\n    pre_print(t.left)\n  if t.right != None:\n    pre_print(t.right)\n  \nTreap = None\nnum = int(input())\nfor i in range(num):\n  string = list(input().split())\n  if string[0] == \"insert\":\n    key = int(string[1])\n    priority = int(string[2])\n    Treap = insert(Treap, key, priority)\n  elif string[0] == \"find\":\n    key = int(string[1])\n    find(Treap, key)\n  elif string[0] == \"delete\":\n    key = int(string[1])\n    Treap = erase(Treap, key)\n  else:\n    in_print(Treap)\n    print()\n    pre_print(Treap)\n    print()\n    \n\n  \n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n\ntype NodeId = usize;\n\nstruct Node {\n    id: NodeId,\n    parent: Option<NodeId>,\n    left: Option<NodeId>,\n    right: Option<NodeId>,\n    key: u64,\n    priority: u64,\n}\n\nstruct Tree {\n    root: Option<NodeId>,\n    nodes: Vec<Node>,\n}\n\nimpl Tree {\n    fn new() -> Tree {\n        Tree {\n            root: None,\n            nodes: Vec::new(),\n        }\n    }\n\n    fn right_rotate(&mut self, node_id: NodeId) -> NodeId {\n        let left_node_id = self.nodes[node_id].left.unwrap();\n        self.nodes[node_id].left = self.nodes[left_node_id].right;\n        self.nodes[left_node_id].right = Some(node_id);\n        return left_node_id;\n    }\n\n    fn left_rotate(&mut self, node_id: NodeId) -> NodeId {\n        let right_node_id = self.nodes[node_id].right.unwrap();\n        self.nodes[node_id].right = self.nodes[right_node_id].left;\n        self.nodes[right_node_id].left = Some(node_id);\n        return right_node_id;\n    }\n\n    // add root\n    fn insert(&mut self, key: u64, priority: u64) {\n        let root: Option<NodeId> = self.root;\n        self.root = self._insert(root, key, priority)\n    }\n\n    fn _insert(&mut self, node_id: Option<NodeId>, key: u64, priority: u64) -> Option<NodeId> {\n        if node_id == None {\n            let id: NodeId = self.nodes.len();\n            let node = Node {\n                id: id,\n                parent: None,\n                left: None,\n                right: None,\n                key: key,\n                priority: priority,\n            };\n            self.nodes.push(node);\n            return Some(id);\n        }\n\n        let mut current_node_id = node_id.unwrap();\n\n        if key == self.nodes[current_node_id].key {\n            return Some(current_node_id);\n        }\n\n        if key < self.nodes[current_node_id].key {\n            let mut left_node_id: Option<NodeId> = self.nodes[current_node_id].left;\n            self.nodes[current_node_id].left = self._insert(left_node_id, key, priority);\n            left_node_id = self.nodes[current_node_id].left;\n            if self.nodes[current_node_id].priority < self.nodes[left_node_id.unwrap()].priority {\n                current_node_id = self.right_rotate(current_node_id);\n            }\n        } else {\n            let mut right_node_id: Option<NodeId> = self.nodes[current_node_id].right;\n            self.nodes[current_node_id].right = self._insert(right_node_id, key, priority);\n            right_node_id = self.nodes[current_node_id].right;\n            if self.nodes[current_node_id].priority < self.nodes[right_node_id.unwrap()].priority {\n                current_node_id = self.left_rotate(current_node_id);\n            }\n        }\n\n        return Some(current_node_id);\n    }\n\n    fn find(&self, key: u64) -> Option<NodeId> {\n        if self.root == None {\n            return None;\n        } else {\n            let mut node_id: Option<NodeId> = Some(self.nodes[self.root.unwrap()].id);\n            while node_id != None {\n                if self.nodes[node_id.unwrap()].key == key {\n                    return node_id;\n                } else if self.nodes[node_id.unwrap()].key < key {\n                    node_id = self.nodes[node_id.unwrap()].right;\n                } else {\n                    node_id = self.nodes[node_id.unwrap()].left;\n                }\n            }\n            return None;\n        }\n    }\n\n    fn delete(&mut self, key: u64) {\n        let root = self.root;\n        self.root = self._delete(root, key);\n    }\n\n    fn _delete(&mut self, node_id: Option<NodeId>, key: u64) -> Option<NodeId> {\n        if node_id == None {\n            return None;\n        }\n\n        let current_node_id: NodeId = node_id.unwrap();\n\n        if key < self.nodes[current_node_id].key {\n            let left_node_id: Option<NodeId> = self.nodes[current_node_id].left;\n            self.nodes[current_node_id].left = self._delete(left_node_id, key);\n        } else if key > self.nodes[current_node_id].key {\n            let right_node_id: Option<NodeId> = self.nodes[current_node_id].right;\n            self.nodes[current_node_id].right = self._delete(right_node_id, key);\n        } else {\n            return self.delete_node(current_node_id, key);\n        }\n        return Some(current_node_id);\n    }\n\n    fn delete_node(&mut self, node_id: NodeId, key: u64) -> Option<NodeId> {\n        let mut node_id: NodeId = node_id;\n        let left = self.nodes[node_id].left;\n        let right = self.nodes[node_id].right;\n        if left == None && right == None {\n            return None;\n        } else if left == None {\n            node_id = self.left_rotate(node_id)\n        } else if right == None {\n            node_id = self.right_rotate(node_id)\n        } else {\n            let left: NodeId = left.unwrap();\n            let right: NodeId = right.unwrap();\n            if self.nodes[left].priority > self.nodes[right].priority {\n                node_id = self.right_rotate(node_id);\n            } else {\n                node_id = self.left_rotate(node_id);\n            }\n        }\n        return self._delete(Some(node_id), key);\n    }\n\n    fn print(&mut self) {\n        inorder(self.root.unwrap(), &self.nodes);\n        println!();\n        preorder(self.root.unwrap(), &self.nodes);\n        println!();\n    }\n}\n\nfn preorder(node_id: NodeId, nodes: &Vec<Node>) {\n    print!(\" {}\", nodes[node_id].key);\n    if nodes[node_id].left != None {\n        preorder(nodes[node_id].left.unwrap(), nodes)\n    }\n    if nodes[node_id].right != None {\n        preorder(nodes[node_id].right.unwrap(), nodes)\n    }\n}\n\nfn inorder(node_id: NodeId, nodes: &Vec<Node>) {\n    if nodes[node_id].left != None {\n        inorder(nodes[node_id].left.unwrap(), nodes)\n    }\n    print!(\" {}\", nodes[node_id].key);\n    if nodes[node_id].right != None {\n        inorder(nodes[node_id].right.unwrap(), nodes)\n    }\n}\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nfn main() {\n    let n: usize = read();\n    let mut tree: Tree = Tree::new();\n    for _ in 0..n {\n        let command: String = read();\n        match &*command {\n            \"insert\" => {\n                let key: u64 = read();\n                let priority: u64 = read();\n                tree.insert(key, priority);\n            }\n            \"find\" => {\n                let key: u64 = read();\n                if tree.find(key) != None {\n                    println!(\"yes\");\n                } else {\n                    println!(\"no\");\n                };\n            }\n            \"delete\" => {\n                let key: u64 = read();\n                tree.delete(key);\n            }\n            _ => tree.print(),\n        }\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::{max, min};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, Read, Write};\nuse std::str::FromStr;\n\n#[derive(Default)]\nstruct Scanner<R: Read> {\n    reader: R,\n}\n\nimpl<R: Read> Scanner<R> {\n    fn new(reader: R) -> Scanner<R> {\n        Scanner {\n            reader,\n        }\n    }\n\n    fn scan<T: FromStr>(&mut self) -> Option<T> {\n        let s = self.reader.by_ref().bytes().map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        s.parse::<T>().ok()\n    }\n\n    fn next<T: FromStr>(&mut self) -> T {\n        if let Some(s) = self.scan() {\n            s\n        } else {\n            std::process::exit(1);\n        }\n    }\n}\n\nstruct Treap {\n    nodes: Vec<TreapNode>,\n    root: Option<usize>,\n}\n\nstruct TreapNode {\n    key: i32,\n    priority: i32,\n    left: Option<usize>,\n    right: Option<usize>,\n}\n\nimpl Treap {\n    fn new() -> Treap {\n        Treap { nodes: Vec::new(), root: None }\n    }\n\n    fn insert(&mut self, key: i32, priority: i32) {\n        let root = self.root;\n        self.root = self.insert_helper(root, key, priority);\n    }\n\n    fn insert_helper(&mut self, t: Option<usize>, key: i32, priority: i32) -> Option<usize> {\n        if t == None {\n            self.nodes.push(TreapNode{key, priority, left: t, right: t});\n            return Some(self.nodes.len() - 1);\n        }\n\n        let mut t = t.unwrap();\n        if key < self.nodes[t].key {\n            let mut l = self.nodes[t].left;\n            l = self.insert_helper(l, key, priority);\n            self.nodes[t].left = l;\n            let l = l.unwrap();\n            if self.nodes[t].priority < self.nodes[l].priority {\n                t = self.rotate_right(t);\n            }\n        } else {\n            let mut r = self.nodes[t].right;\n            r = self.insert_helper(r, key, priority);\n            self.nodes[t].right = r;\n            let r = r.unwrap();\n            if self.nodes[t].priority < self.nodes[r].priority {\n                t = self.rotate_left(t);\n            }           \n        }\n        Some(t)\n    }\n\n    fn rotate_right(&mut self, t: usize) -> usize {\n        let s = self.nodes[t].left.unwrap();\n        self.nodes[t].left = self.nodes[s].right;\n        self.nodes[s].right = Some(t);\n        s\n    }\n\n    fn rotate_left(&mut self, t: usize) -> usize {\n        let s = self.nodes[t].right.unwrap();\n        self.nodes[t].right = self.nodes[s].left;\n        self.nodes[s].left = Some(t);\n        s\n    }\n\n    fn find(&self, key: i32) -> Option<usize> {\n        self.find_helper(self.root, key)\n    }\n\n    fn find_helper(&self, t: Option<usize>, x: i32) -> Option<usize> {\n        if t == None {\n            return None;\n        }\n\n        let t = t.unwrap();\n        let k = self.nodes[t].key;\n        if k == x {\n            Some(t)\n        } else if x < k {\n            self.find_helper(self.nodes[t].left, x)\n        } else {\n            self.find_helper(self.nodes[t].right, x)\n        }\n    }\n\n    fn delete(&mut self, key: i32) {\n        let root = self.root;\n        self.root = self.delete_helper(root, key);\n    }\n\n    fn delete_helper(&mut self, t: Option<usize>, key: i32) -> Option<usize> {\n        if t == None {\n            return None;\n        }\n        let t = t.unwrap();\n        if key < self.nodes[t].key {\n            let l = self.nodes[t].left;\n            self.nodes[t].left = self.delete_helper(l, key);\n        } else if key > self.nodes[t].key {\n            let r = self.nodes[t].right;\n            self.nodes[t].right = self.delete_helper(r, key);\n        } else {\n            return self.delete_node(t, key);\n        }\n        Some(t)\n    }\n\n    fn delete_node(&mut self, t: usize, key: i32) -> Option<usize> {\n        let mut t = t;\n        let l = self.nodes[t].left;\n        let r = self.nodes[t].right;\n        if l == None && r == None {\n            return None;\n        } else if l == None {\n            t = self.rotate_left(t);\n        } else if r == None {\n            t = self.rotate_right(t);\n        } else {\n            let l = l.unwrap();\n            let r = r.unwrap();\n            if self.nodes[l].priority > self.nodes[r].priority {\n                t = self.rotate_right(t);\n            } else {\n                t = self.rotate_left(t);\n            }\n        }\n        self.delete_helper(Some(t), key)\n    }\n\n    fn print<T: Write>(&self, out: &mut T) {\n        self.print_inorder(self.root, out);\n        writeln!(out).ok();\n        self.print_preorder(self.root, out);\n        writeln!(out).ok();\n    }\n\n    fn print_inorder<W: Write>(&self, t: Option<usize>, out: &mut W) {\n        if let Some(i) = t {\n            self.print_inorder(self.nodes[i].left, out);\n            write!(out, \" {}\", self.nodes[i].key).ok();\n            self.print_inorder(self.nodes[i].right, out);\n        }\n    }\n\n    fn print_preorder<W: Write>(&self, t: Option<usize>, out: &mut W) {\n        if let Some(i) = t {\n            write!(out, \" {}\", self.nodes[i].key).ok();\n            self.print_preorder(self.nodes[i].left, out);\n            self.print_preorder(self.nodes[i].right, out);\n        }\n    }\n}\n\nfn main() {\n    let cin = stdin();\n    let cin = cin.lock();\n    let mut sc = Scanner::new(cin);\n    let out = stdout();\n    let mut out = out.lock();\n\n    let n = sc.next();\n    let mut t = Treap::new();\n    for _ in 0..n {\n        let op: String = sc.next();\n        match op.as_str() {\n            \"insert\" => t.insert(sc.next(), sc.next()),\n            \"print\" => t.print(&mut out),\n            \"find\" => {\n                if let Some(_) = t.find(sc.next()) {\n                    writeln!(out, \"yes\").ok();\n                } else {\n                    writeln!(out, \"no\").ok();\n                }\n            }\n            \"delete\" => t.delete(sc.next()),\n            _ => panic!(\"unknown operation {}\", op),\n        }\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::fmt;\nuse std::io::stdin;\nuse std::io::BufRead;\nuse std::str;\nuse std::str::FromStr;\n#[derive(Debug)]\npub struct Node {\n\tpub key:u32,\n\tpub priority:u64,\n\tpub left:Box<Option<Node>>,\n\tpub right:Box<Option<Node>>,\n}\nimpl Node {\n\tpub fn new(key:u32,priority:u64) -> Node {\n\t\tNode {\n\t\t\tpriority:priority,\n\t\t\tkey:key,\n\t\t\tleft:Box::new(None),\n\t\t\tright:Box::new(None),\n\t\t}\n\t}\n\n\tpub fn right_rotate(t:Node) -> Node {\n\t\tmatch *t.left {\n\t\t\tSome(left) => {\n\t\t\t\tNode {\n\t\t\t\t\tpriority: left.priority,\n\t\t\t\t\tkey: left.key,\n\t\t\t\t\tleft: left.left,\n\t\t\t\t\tright: Box::new(Some(Node {\n\t\t\t\t\t\tkey: t.key,\n\t\t\t\t\t\tpriority: t.priority,\n\t\t\t\t\t\tleft: left.right,\n\t\t\t\t\t\tright: t.right,\n\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t},\n\t\t\tNone => t\n\t\t}\n\t}\n\n\tpub fn left_rotate(t:Node) -> Node {\n\t\tmatch *t.right {\n\t\t\tSome(right) => {\n\t\t\t\tNode {\n\t\t\t\t\tpriority: right.priority,\n\t\t\t\t\tkey: right.key,\n\t\t\t\t\tright: right.right,\n\t\t\t\t\tleft: Box::new(Some(Node {\n\t\t\t\t\t\tkey: t.key,\n\t\t\t\t\t\tpriority: t.priority,\n\t\t\t\t\t\tright: right.left,\n\t\t\t\t\t\tleft: t.left,\n\t\t\t\t\t}))\n\t\t\t\t}\n\t\t\t},\n\t\t\tNone => t\n\t\t}\n\t}\n\n\tpub fn insert(t:Box<Option<Node>>, key:u32, priority:u64) -> Node {\n\t\tmatch *t {\n\t\t\tNone => Node::new(key,priority),\n\t\t\tSome(t) => {\n\t\t\t\tif key == t.key {\n\t\t\t\t\tt\n\t\t\t\t} else if key < t.key {\n\t\t\t\t\tlet left = Node::insert(t.left, key, priority);\n\n\t\t\t\t\tif t.priority < left.priority {\n\t\t\t\t\t\tNode::right_rotate(Node {\n\t\t\t\t\t\t\tkey: t.key,\n\t\t\t\t\t\t\tpriority: t.priority,\n\t\t\t\t\t\t\tleft: Box::new(Some(left)),\n\t\t\t\t\t\t\tright: t.right\n\t\t\t\t\t\t})\n\t\t\t\t\t} else {\n\t\t\t\t\t\tNode {\n\t\t\t\t\t\t\tkey: t.key,\n\t\t\t\t\t\t\tpriority: t.priority,\n\t\t\t\t\t\t\tleft: Box::new(Some(left)),\n\t\t\t\t\t\t\tright: t.right\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet right = Node::insert(t.right, key, priority);\n\n\t\t\t\t\tif t.priority < right.priority {\n\t\t\t\t\t\tNode::left_rotate(Node {\n\t\t\t\t\t\t\tkey: t.key,\n\t\t\t\t\t\t\tpriority: t.priority,\n\t\t\t\t\t\t\tleft: t.left,\n\t\t\t\t\t\t\tright: Box::new(Some(right))\n\t\t\t\t\t\t})\n\t\t\t\t\t} else {\n\t\t\t\t\t\tNode {\n\t\t\t\t\t\t\tkey: t.key,\n\t\t\t\t\t\t\tpriority: t.priority,\n\t\t\t\t\t\t\tleft: t.left,\n\t\t\t\t\t\t\tright: Box::new(Some(right))\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfn delete_at(t:Box<Option<Node>>,key:u32) -> Option<Node> {\n\t\tNode::delete(Box::new(match *t {\n\t\t\tNone => None,\n\t\t\tSome(t) => {\n\t\t\t\tif t.left.is_none() && t.right.is_none() {\n\t\t\t\t\treturn None;\n\t\t\t\t} else if t.left.is_none() {\n\t\t\t\t\tSome(Node::left_rotate(t))\n\t\t\t\t} else if t.right.is_none() {\n\t\t\t\t\tSome(Node::right_rotate(t))\n\t\t\t\t} else {\n\t\t\t\t\tlet lp = match *t.left {\n\t\t\t\t\t\tNone => 0,\n\t\t\t\t\t\tSome(ref n) => n.priority,\n\t\t\t\t\t};\n\n\t\t\t\t\tlet rp = match *t.right {\n\t\t\t\t\t\tNone => 0,\n\t\t\t\t\t\tSome(ref n) => n.priority,\n\t\t\t\t\t};\n\n\t\t\t\t\tif lp > rp {\n\t\t\t\t\t\tSome(Node::right_rotate(t))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tSome(Node::left_rotate(t))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}), key)\n\t}\n\n\tpub fn delete(t:Box<Option<Node>>,key:u32) -> Option<Node> {\n\t\tmatch *t {\n\t\t\tNone => {\n\t\t\t\treturn None;\n\t\t\t},\n\t\t\tSome(t) => {\n\t\t\t\tif key < t.key {\n\t\t\t\t\tSome(Node {\n\t\t\t\t\t\tpriority:t.priority,\n\t\t\t\t\t\tkey:t.key,\n\t\t\t\t\t\tleft:Box::new(Node::delete(t.left,key)),\n\t\t\t\t\t\tright:t.right\n\t\t\t\t\t})\n\t\t\t\t} else if key > t.key {\n\t\t\t\t\tSome(Node {\n\t\t\t\t\t\tpriority:t.priority,\n\t\t\t\t\t\tkey:t.key,\n\t\t\t\t\t\tleft:t.left,\n\t\t\t\t\t\tright:Box::new(Node::delete(t.right,key)),\n\t\t\t\t\t})\n\t\t\t\t} else {\n\t\t\t\t\tNode::delete_at(Box::new(Some(t)),key)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpub fn find(root:&Node,key:u32) -> bool {\n\t\tlet mut t = root;\n\n\t\twhile key != t.key {\n\t\t\tif key < t.key {\n\t\t\t\tmatch *t.left {\n\t\t\t\t\tNone => {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t},\n\t\t\t\t\tSome(ref n) => {\n\t\t\t\t\t\tt = n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if key > t.key {\n\t\t\t\tmatch *t.right {\n\t\t\t\t\tNone => {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t},\n\t\t\t\t\tSome(ref n) => {\n\t\t\t\t\t\tt = n;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\ttrue\n\t}\n\n\tpub fn print(root:&Node) {\n\t\tprint!(\" {}\\n\",Node::in_order(root).into_iter().map(|k| k.to_string()).collect::<Vec<String>>().join(\" \"));\n\t\tprint!(\" {}\\n\",Node::pre_order(root).into_iter().map(|k| k.to_string()).collect::<Vec<String>>().join(\" \"));\n\t}\n\n\tfn in_order(t:&Node) -> Vec<u32> {\n\t\tlet mut keys:Vec<u32> = Vec::new();\n\n\t\tif let Some(ref l) = *t.left {\n\t\t\tkeys.append(&mut Node::in_order(l));\n\t\t}\n\n\t\tkeys.push(t.key);\n\n\t\tif let Some(ref r) = *t.right {\n\t\t\tkeys.append(&mut Node::in_order(r));\n\t\t}\n\n\t\tkeys\n\t}\n\n\tfn pre_order(t:&Node) -> Vec<u32> {\n\t\tlet mut keys:Vec<u32> = Vec::new();\n\n\t\tkeys.push(t.key);\n\n\t\tif let Some(ref l) = *t.left {\n\t\t\tkeys.append(&mut Node::pre_order(l));\n\t\t}\n\n\t\tif let Some(ref r) = *t.right {\n\t\t\tkeys.append(&mut Node::pre_order(r));\n\t\t}\n\n\t\tkeys\n\t}\n}\nfn main() {\n\tlet stdin = stdin();\n\tlet mut reader = InputScanner::new(stdin.lock(),256);\n\n\tlet m:usize = reader.next();\n\tlet mut root:Box<Option<Node>> = Box::new(None);\n\n\tfor _ in 0..m {\n\t\tlet command:String = reader.next();\n\n\t\tmatch command.as_str() {\n\t\t\t\"insert\" => {\n\t\t\t\troot = Box::new(Some(Node::insert(root, reader.next(), reader.next())));\n\t\t\t},\n\t\t\t\"find\" => {\n\t\t\t\tif let Some(ref root) = *root {\n\t\t\t\t\tif Node::find(root,reader.next()) {\n\t\t\t\t\t\tprint!(\"yes\\n\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprint!(\"no\\n\");\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpanic!(\"invalid state.\");\n\t\t\t\t}\n\t\t\t},\n\t\t\t\"delete\" => {\n\t\t\t\troot = Box::new(Node::delete(root,reader.next()));\n\t\t\t},\n\t\t\t\"print\" => {\n\t\t\t\tif let Some(ref root) = *root {\n\t\t\t\t\tNode::print(root);\n\t\t\t\t}\n\t\t\t},\n\t\t\t_ => {\n\t\t\t\tpanic!(\"invalid command.\");\n\t\t\t}\n\t\t}\n\t}\n}\nstruct InputScanner<R: BufRead> {\n\treader: R,\n\tbuf: Vec<u8>, // Should never be empty\n\tpos: usize,   // Should never be out of bounds as long as the input ends with '\\n'\n}\n\nimpl<R: BufRead> InputScanner<R> {\n\tfn new(reader: R, capacity: usize) -> Self {\n\t\tInputScanner {\n\t\t\treader: reader,\n\t\t\tbuf: Vec::with_capacity(capacity),\n\t\t\tpos: 0,\n\t\t}\n\t}\n\n\t#[inline]\n\tfn next<T: FromStr>(&mut self) -> T\n\twhere\n\t\tT::Err: fmt::Debug,\n\t{\n\t\tif self.buf.is_empty() {\n\t\t\tself._read_next_line();\n\t\t}\n\t\tlet mut start = None;\n\t\tloop {\n\t\t\tmatch (self.buf[self.pos], start.is_some()) {\n\t\t\t\t(b' ', true) | (b'\\n', true) | (b'\\r', true) => break,\n\t\t\t\t(_, true) | (b' ', false) => self.pos += 1,\n\t\t\t\t(b'\\n', false) | (b'\\r', false) => self._read_next_line(),\n\t\t\t\t(_, false) => start = Some(self.pos),\n\t\t\t}\n\t\t}\n\t\tlet target = &self.buf[start.unwrap()..self.pos];\n\t\tunsafe { str::from_utf8_unchecked(target) }.parse().unwrap()\n\t}\n\n\t#[inline]\n\tfn _read_next_line(&mut self) {\n\t\tself.pos = 0;\n\t\tself.buf.clear();\n\t\tif self.reader.read_until(b'\\n', &mut self.buf).unwrap() == 0 {\n\t\t\tpanic!(\"Reached EOF\");\n\t\t}\n\t}\n}\n\n"
  }
]