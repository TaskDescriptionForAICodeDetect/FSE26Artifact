[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst int h = 19;\nconst int w = 15;\n\nstruct Data { \n  int x,y,bitmask,cost;\n  bool operator < ( const Data& data ) const { \n    if( cost != data.cost ) return cost < data.cost; \n    if( x != data.x ) return x < data.x;\n    if( y != data.y ) return y < data.y;\n    if( bitmask != data.bitmask ) return bitmask < data.bitmask;\n  }\n};\n\nchar a[20][20];\n//int mindist[1<<20][9];\nset<Data> mindist;\nint Index[20][20];\n\nbool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nvoid compute(){\n  int black = 0;\n  int sx=-1,sy=-1;\n  rep(i,h) rep(j,w) {\n    if( a[i][j] == 'X' ) Index[i][j] = black++;\n    if( a[i][j] == 'O' ) sx = j, sy = i;\n  }\n  //rep(i,(1<<black)) rep(j,9) mindist[i][j] = IINF;\n  mindist.clear();\n  //mindist[(1<<black)-1][4] = 0;\n  mindist.insert((Data){sx,sy,(1<<black)-1,0});\n  deque<Data> deq;\n  deq.push_back((Data){sx,sy,(1<<black)-1,0});\n  while( !deq.empty() ){\n    Data data = deq.front(); deq.pop_front();\n    REP(dx,-1,2){\n      REP(dy,-1,2){\n        if( dx == 0 && dy == 0 ) continue;\n        int nx = data.x + dx, ny = data.y + dy, nbitmask = data.bitmask;\n        bool valid = false;\n        while( isValid(nx,ny) && ( a[ny][nx] == 'X' && ( data.bitmask & (1<<Index[ny][nx]) ) ) ){\n          nbitmask &= ~(1<<Index[ny][nx]);\n          nx += dx, ny += dy;\n          valid = true;\n        }\n        if( !isValid(nx,ny) ) {\n          if( valid && ( ny >= h || ( ny == h-1 && isValid(nx,ny) ) ) ) {\n            //cout << mindist[data.bitmask]+1 << endl;\n            cout << data.cost+1 << endl;\n            return;\n          }\n          continue;\n        }\n        if( !valid ) continue;\n        //if( mindist[nbitmask] > mindist[data.bitmask] + 1 ) {\n        if( !mindist.count((Data){nx,ny,nbitmask,data.cost+1}) ) {\n          //mindist[nbitmask] = mindist[data.bitmask] + 1;\n          mindist.insert((Data){nx,ny,nbitmask,data.cost+1});\n          deq.push_back((Data){nx,ny,nbitmask,data.cost+1});\n        }\n      }\n    }\n  }\n  puts(\"-1\");\n}\n\nint main(){\n  rep(i,h) rep(j,w) scanf(\" %c\",&a[i][j]);\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int h = 20, w = 17;\nvector<vector<char>> c;\ntypedef tuple<pair<int, int>, vector<vector<char>>, int> T;\nqueue<T> q;\nmap<vector<vector<char>>, vector<vector<int>>> memo;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint main(){\n\tc = vector<vector<char>>(h, vector<char>(w,'.'));\n\n\tpair<int, int> s;\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tcin >> c[i][j + 1];\n\t\t\tif(c[i][j + 1] == 'O'){\n\t\t\t\ts = make_pair(i,j + 1);\n\t\t\t\tc[i][j + 1] = '.';\n\t\t\t}\n\t\t}\n\t}\n\n\tq.push(T(s,c,0));\n\n\tint ans = INF;\n\twhile(not q.empty()){\n\t\tint cost;\n\t\ttie(s,c,cost) = q.front(); q.pop();\n\n\t\tint y, x;\n\t\ttie(y,x) = s;\n\n\t\t//rep(i,h){ rep(j,w){ if(i == y and j == x) cout << 'O'; else cout << c[i][j]; } cout << endl; } cout << endl;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(i,8){\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)) continue;\n\t\t\tvector<vector<char>> pc = c;\n\t\t\tif(pc[ny][nx] == 'X'){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pc[ny][nx] == '.') break;\n\t\t\t\t\tpc[ny][nx] = '.';\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tif(memo.count(pc)){\n\t\t\t\t\tauto& it = memo[pc];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<int>> dis(h, vector<int>(w,INF));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[pc] = dis;\n\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int h = 20, w = 17;\nvector<vector<char>> c;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint main(){\n\tc = vector<vector<char>>(h, vector<char>(w,'.'));\n\n\tpair<int, int> s;\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tcin >> c[i][j + 1];\n\t\t\tif(c[i][j] == 'O') s = make_pair(i,j + 1);\n\t\t}\n\t}\n\n\ttypedef tuple<pair<int, int>, vector<vector<char>>, int> T;\n\tqueue<T> q;\n\tq.push(T(s,c,0));\n\n\tint ans = INF;\n\tmap<vector<vector<char>>, vector<vector<int>>> memo;\n\twhile(not q.empty()){\n\t\tint cost;\n\t\ttie(s,c,cost) = q.front(); q.pop();\n\n\t\tint y, x;\n\t\ttie(y,x) = s;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(i,8){\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tvector<vector<char>> pc = c;\n\t\t\tif(pc[ny][nx] == 'X'){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pc[ny][nx] == '.') break;\n\t\t\t\t\tpc[ny][nx] = '.';\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tif(memo.count(pc)){\n\t\t\t\t\tauto& it = memo[pc];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<int>> dis(h, vector<int>(w,INF));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[pc] = dis;\n\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2612&lang=jp\n#define INF 1<<30\n#define H 19\n#define W 15\ntypedef long long ll;\ntypedef pair<int, int> pii;\nint ans = INF;\nint dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nint dy[8] = { 0,-1,-1,-1,0,1,1,1 };\n\nbool check(int x, int y, vector<vector<char>>& masu,int& dir) {\n\tint nx = x + dx[dir], ny = y + dy[dir];\n\tif (masu[nx][ny] != 'X')return false;\n\twhile (true) {\n\t\tnx += dx[dir]; ny += dy[dir];\n\t\tif (masu[nx][ny] == 'X')continue;\n\t\tif (masu[nx][ny] == '#')return false;\n\t\tif (masu[nx][ny] == '.')return true;\n\t}\n\treturn false;\n}\n\nvoid erase_move(int&x, int&y, vector<vector<char>>& masu, int& dir) {\n\twhile (true) {\n\t\tx += dx[dir]; y += dy[dir];\n\t\tif (masu[x][y] == 'X') {\n\t\t\tmasu[x][y] = '.';\n\t\t\tcontinue;\n\t\t}\n\t\tif (masu[x][y] == '.')return ;\n\t}\n}\n\nvoid dfs(int x, int y,int cnt,vector<vector<char>>& masu) {\n\tif (cnt + 1 >= ans) return;\n\tfor (int dir = 0; dir < 8; dir++) {\n\t\tif (!check(x, y, masu, dir))continue;\n\t\tauto new_masu = masu;\n\t\tint new_x = x, new_y = y;\n\t\terase_move(new_x,new_y, new_masu, dir);\n\t\t\n\t\tif (new_x >= 19) {\n\t\t\tans = min(ans, cnt + 1);\n\t\t\treturn;\n\t\t}\n\n\t\tdfs(new_x, new_y, cnt + 1, new_masu);\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tvector<vector<char>> masu(H + 2, vector<char>(W + 2,'#'));\n\tint sx, sy;\n\t/* input */\n\tmasu[H + 1][0] = masu[H + 1][W + 1] = '.';\n\tfor (int i = 1; i <= H+1; i++){\n\t\tfor (int j = 1; j <= W; j++){\n\t\t\tif (i == H + 1) masu[i][j] = '.';\n\t\t\telse {\n\t\t\t\tcin >> masu[i][j];\n\t\t\t\tif (masu[i][j] == 'O') { sx = i; sy = j; masu[i][j] = '.'; }\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = sx + 1; i <= H; i++) {\n\t\tbool f = false;\n\t\tfor (int j = 1; j <= W;j++) {\n\t\t\tif (masu[i][j] == 'X') { f = true; break; }\n\t\t}\n\t\tif (!f) {\n\t\t\tcout << -1 << endl; return 0;\n\t\t}\n\t}\n\n\tdfs(sx, sy, 0, masu);\n\tcout << (ans == INF ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define inf 100000007\nusing namespace std;\n\nchar kiban[20][15];\nint X[8]={0,1,0,-1,1,-1,-1,1};\nint Y[8]={-1,0,1,0,1,-1,1,-1};\nint ans=inf;\n\nbool in(int h,int w)\n{\n  if(h<0 || w<0 || 15<=w || 21<=h)return false;\n  return true;\n}\n\nvoid move(int h,int w,int sum)\n{\n  bool check[8]={};\n  if(18<=h){\n    ans=min(ans,sum);\n    return;\n    }\n  for(int k=0;k<8;k++){\n    if(kiban[h+Y[k]][w+X[k]]=='.')continue;\n    for(int i=1;i<40;i++){\n      int a=h+Y[k]*i,b=w+X[k]*i;\n      if(a==18){\n\tans=min(ans,sum+1);\n\tcontinue;\n      }\n      if(!in(a,b))break;\n      if(kiban[a][b]=='.'){\n\tcheck[k]=true;\n\tbreak;\n      }\n    }\n  }\n  for(int k=0;k<8;k++){\n    if(!check[k])continue;\n    int a=h,b=w;\n    for(int i=1;i<20;i++){\n      a+=Y[k];\n      b+=X[k];\n      if(kiban[a][b]=='.')break;\n      kiban[a][b]='.';\n    }\n    move(a,b,sum+1);\n    int H=h,W=w;\n    for(int i=1;i<20;i++){\n      H+=Y[k];\n      W+=X[k];\n      if(H==a && W==b)break;\n      kiban[H][W]='x';\n    }\n  }\n}\n\nint main()\n{\n  int h,w;\n  for(int i=0;i<19;i++){\n    for(int j=0;j<15;j++){\n      cin>>kiban[i][j];\n      if(kiban[i][j]=='O'){\n\th=i;\n\tw=j;\n\tkiban[i][j]='.';\n      }\n    }\n  }\n  for(int i=0;i<15;i++)kiban[19][i]='.';\n  move(h,w,0);\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define inf 1000000000\n\nusing namespace std;\n\nconst int W = 15, H = 20;\nchar map[W][H];\nint sx, sy;\nconst int vx[] = {1, 1, 0, -1, -1, -1, 0, 1}, vy[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\nint dfs(int x, int y)\n{\n\tint nx, ny;\n\tint ret = inf;\n\tif(y >= H-2) return 0;\n\t\n\tfor(int d = 0; d < 8; d++){\n\t\tnx = x + vx[d], ny = y + vy[d];\n\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n\t\tif(map[nx][ny] == '.') continue;\n\t\twhile(1){\n\t\t\tnx += vx[d], ny += vy[d];\n\t\t\tif(ny >= H-1){ ret = 0; break;}\n\t\t\tif(nx < 0 || nx >= W || ny < 0) break;\n\t\t\tif(map[nx][ny] == '.'){\n\t\t\t\tfor(int k = 1; x + k*vx[d] != nx || y + k*vy[d] != ny; k++) map[x + k*vx[d]][y + k*vy[d]] = '.';\n\t\t\t\tret = min(ret, dfs(nx, ny));\n\t\t\t\tfor(int k = 1; x + k*vx[d] != nx || y + k*vy[d] != ny; k++) map[x + k*vx[d]][y + k*vy[d]] = 'X';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret + 1;\n}\n\nint main(void)\n{\n\tfor(int y = 0; y < H; y++){\n\t\tfor(int x = 0; x < W; x++){\n\t\t\tcin >> map[x][y];\n\t\t\tif(map[x][y] == 'O'){\n\t\t\t\tsx = x, sy = y;\n\t\t\t\tmap[x][y] = '.';\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x = 0; x < W; x++) map[x][H-1] = '.';\n\t\n\tint ans = dfs(sx, sy);\n\tif(ans >= inf) ans = -1;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b) : value(((a% b) + 2 * b) % b), mod(b) {\n\n    }\n    modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n#define int long long\n\nvoid solve() {\n    vector<pair<int, int>> batu;\n    queue<pair<pair<int,int>,pair<int,int>>> next;\n    REP(i, 19) {\n        string s;\n        cin >> s;\n        REP(q, s.length()) {\n            if (s[q] == 'O') {\n                next.push(mp(mp(i, q), mp(0LL, 0LL)));\n            }\n            else if (s[q] == 'X') {\n                batu.push_back(mp(i, q));\n            }\n        }\n    }\n    int grid[30][30] = {};\n    while (next.empty() == false) {\n        pair<int, int> place = next.front().first;\n        int black = next.front().second.first;\n        int cost = next.front().second.second;\n        next.pop();\n\n        if (place.first == 19||(place.first == 18&&place.second >= 0&&place.second < 15)) {\n            cout << cost<< endl;\n            return;\n        }\n        if (!(place.first >= 0&&place.first < 19&&place.second >= 0&&place.second < 15)) {\n            continue;\n        }\n        REP(i, batu.size()) {\n            if ((1 << i) & black) {\n                grid[batu[i].first][batu[i].second] = 0;\n            }\n            else {\n                grid[batu[i].first][batu[i].second] = i + 1;\n            }\n        }\n        int dx[8] = { 1,1,1,0,0,-1,-1,-1 };\n        int dy[8] = { 1,0,-1,1,-1,1,0,-1 };\n        REP(q, 8) {\n            int color = black;\n            for (int j = 1;; ++j) {\n                int x = dx[q] * j + place.first;\n                int y = dy[q] * j + place.second;\n                if ((!(x >= 0 && x < 19 && y >= 0 && y < 15)) || (grid[x][y] == 0)) {\n                    if (j == 1) break;\n                    next.push(make_pair(mp(x, y), mp(color, cost + 1)));\n                    break;\n                }\n                color += (1 << (grid[x][y] - 1));\n            }\n        }\n    }\n    cout << -1 << endl;\n}\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 19;\nconst int W = 15;\nvector<string> board(H);\nvector<int> xhs, xws;\nint d[1<<20][H][W];\n\nclass State{\npublic:\n    int xstate;\n    int h, w;\n    \n//    bool operator < (const State &r) const{\n//        int xl = xstate * H * W + h * W + w;\n//        int xr = r.xstate * H * W + r.h * W + r.w;\n//        return xl < xr;\n//    }\n};\n\ninline bool infield(int h, int w){\n    return 0<=w && w<W;\n}\n\nint bfs(int sh, int sw){\n    int xn = xhs.size();\n    map<pair<int, int>, int> ipoint;\n    for(int i=0; i<xn; i++)\n        ipoint[{xhs[i], xws[i]}] = i;\n    \n    queue<State> que;\n    State s;\n    s.xstate = (1<<xn)-1;\n    s.h = sh;\n    s.w = sw;\n    que.push(s);\n    d[s.xstate][s.h][s.w] = 0;\n    \n    while(!que.empty()){\n        auto s = que.front(); que.pop();\n        \n        for(int dh=-1; dh<=1; dh++){\n            for(int dw=-1; dw<=1; dw++) if(dh != 0 || dw != 0){\n                State ns;\n                ns.xstate = s.xstate;\n                ns.h = s.h + dh;\n                ns.w = s.w + dw;\n                \n                if(ipoint.find({ns.h, ns.w}) == ipoint.end() || ((ns.xstate>>ipoint[{ns.h, ns.w}])&1) == 0)\n                    continue;\n                \n                int count = 0;\n                while(infield(ns.h, ns.w) && ipoint.find({ns.h, ns.w})!= ipoint.end() && (ns.xstate>>ipoint[{ns.h, ns.w}])&1){\n                    ns.h += dh;\n                    ns.w += dw;\n                    count++;\n                }\n                if(!infield(ns.h, ns.w))\n                    continue;\n                \n                ns.h = s.h + dh;\n                ns.w = s.w + dw;\n                for(int i=0; i<count; i++){\n                    ns.xstate -= 1<<ipoint[{ns.h, ns.w}];\n                    ns.h += dh;\n                    ns.w += dw;\n                }\n                \n                que.push(ns);\n                d[ns.xstate][ns.h][ns.w] = d[s.xstate][s.h][s.w] + 1;\n                \n                if(H<=ns.h){\n                    return d[ns.xstate][ns.h][ns.w];\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    for(auto &s: board) cin >> s;\n    \n    int sh, sw;\n    for(int h=0; h<H; h++){\n        for(int w=0; w<W; w++){\n            if(board[h][w] == 'O')\n                sh = h, sw = w;\n            if(board[h][w] == 'X')\n                xhs.push_back(h), xws.push_back(w);\n        }\n    }\n    cout << bfs(sh, sw) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct S {\n\tint x, y, mask;\n\tll hash() {\n\t\treturn (ll)x + 15 * (ll)y + mask * (1LL << 30);\n\t}\n};\n\nint b[19][15];\n\nint dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 };\nint dy[8] = { 0, 1, 0, -1, 1, -1, 1, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < 15 && 0 <= y && y < 19;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint B = 0;\n\tint sx = -1, sy = -1;\n\tmemset(b, -1, sizeof b);\n\tfor(int i = 0; i < 19; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j < 15; j++) {\n\t\t\tif(s[j] == 'O') sx = j, sy = i;\n\t\t\tif(s[j] == 'X') {\n\t\t\t\tb[i][j] = B++;\n\t\t\t}\n\t\t}\n\t}\n\n\tunordered_map<ll, int> dp;\n\tS is = { sx, sy, 0 };\n\tdp[is.hash()] = 0;\n\n\tqueue<S> q;\n\tq.push(is);\n\twhile(q.size()) {\n\t\tint x = q.front().x, y = q.front().y, mask = q.front().mask;\n\t\tint t = dp[q.front().hash()];\n\t\tq.pop();\n\t\tfor(int k = 0; k < 8; k++) {\n\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\tif(!in(nx, ny)) continue;\n\t\t\tint id = b[ny][nx];\n\t\t\tif(id == -1) continue;\n\t\t\tif(mask >> id & 1) continue;\n\t\t\t//cerr << \"nx : \" << nx << \", ny : \" << ny << endl;\n\t\t\tint nmask = mask;\n\t\t\twhile(1) {\n\t\t\t\tnmask |= 1 << id;\n\t\t\t\tnx += dx[k], ny += dy[k];\n\t\t\t\tif(!in(nx, ny)) break;\n\t\t\t\tid = b[ny][nx];\n\t\t\t\tif(id == -1 || (mask >> id & 1)) break;\n\t\t\t}\n\t\t\tif(ny >= 18) {\n\t\t\t\tcout << t + 1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(in(nx, ny)) {\n\t\t\t\tS ns = { nx, ny, nmask };\n\t\t\t\tif(dp.count(ns.hash()) == 0) {\n\t\t\t\t\tdp[ns.hash()] = t + 1;\n\t\t\t\t\tq.push(ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nconst int W = 15, H = 19;\nconst int dx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nbool isGoal(int x, int y) {\n\treturn y >= H || (y == H-1 && inRange(x, y));\n}\n\nstruct Node {\n\tint x, y, f;\n};\n\nvector<P> v;\nmap<int, map<int, map<int, int> > > dist;\nint sid[H][W];\n\nNode Go(const Node& node, int dir) {\n\tNode res = node;\n\tint x = node.x, y = node.y, f = node.f;\n//\tcout << \"Go:\" << x << \" \" << y << \" \" << dir << \" \" << f << endl;\n\tint nx = x+dx[dir], ny = y+dy[dir];\n\tif ( isGoal(x, y) ) return res;\n\tif ( !inRange(x, y) ) return {0, 0, -1};\n\tif ( sid[y][x] < 0 || (f & (1 << sid[y][x])) ) return res;\n\tres.x = nx, res.y = ny;\n\tres.f = f | (1 << sid[y][x]);\n\treturn Go(res, dir);\n}\nNode GoFirst(const Node& node, int dir) {\n\tNode res = {0, 0, -1};\n\tint x = node.x, y = node.y, f = node.f;\n\tint nx = x+dx[dir], ny = y+dy[dir];\n\tif ( !inRange(nx, ny) ) return res;\n\tif ( sid[ny][nx] < 0 || (f & (1 << sid[ny][nx])) ) return res;\n\tres.x = nx;\n\tres.y = ny;\n\tres.f = f;\n\treturn Go(res, dir);\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tvector<string> m(H); cin >> m;\n\tint sx = -1, sy = -1;\n\tREP(y, H) REP(x, W) {\n\t\tif (m[y][x] == 'O') {\n\t\t\tsx = x, sy = y;\n\t\t}\n\t\tif (m[y][x] == 'X') {\n\t\t\tv.pb( P(x, y) );\n\t\t}\n\t}\n\tassert(sx >= 0);\n\n\tint N = v.size();\n\tfill(sid[0], sid[H], -1);\n\tREP(i, N) {\n\t\tint x = v[i].first, y = v[i].second;\n\t\tsid[y][x] = i;\n\t}\n\n\tll ans = 0;\n\tqueue<Node> Q; Q.push({sx, sy, 0});\n//\tfill(dist[0][0], dist[H-1][W], inf);\n\tdist[sy][sx][0] = 1;\n\tif (isGoal(sx, sy)) ans = 1;\n\twhile ( !Q.empty() ) {\n\t\tNode node = Q.front(); Q.pop();\n\t\tint x = node.x, y = node.y, f = node.f;\n//\t\tcout << x << \" \" << y << \" \" << f << endl;\n\t\tREP(i, 8) {\n\t\t\tNode n = GoFirst(node, i);\n\t\t\tif (n.f >= 0) {\n\t\t\t\tif ( isGoal(n.x, n.y) ) {\n\t\t\t\t\tif (ans == 0 || dist[y][x][f]+1 < ans) {\n\t\t\t\t\t\tans = dist[y][x][f]+1;\n//\t\t\t\t\tcout << \"goal\" << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (dist[n.y][n.x][n.f] == 0 || dist[y][x][f]+1 < dist[n.y][n.x][n.f]) {\n\t\t\t\t\tdist[n.y][n.x][n.f] = dist[y][x][f]+1;\n\t\t\t\t\tQ.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ans == 0) cout << -1 << endl;\n\telse cout << ans-1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int w = 15;\nconst int h = 19;\nvector<string> mp(h);\n\nbool inmp(int x,int y){return 0<=x&&0<=y&&x<w&&y<h;}\n\n\nint ans=1e9;\nvoid dfs(int x,int y,int cost){\n  if(y==h||(y==h-1&&0<=x&&x<w))ans=min(ans,cost);\n  if(!inmp(x,y)||ans<=cost) return;\n\n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      int nx = x+i;\n      int ny = y+j;\n      if(!inmp(nx,ny)||mp[ny][nx] != 'X') continue;\n      vector<string>tmp = mp;\n      while(inmp(nx,ny)&&mp[ny][nx]=='X')mp[ny][nx] = '.', nx+=i,ny+=j;\n      dfs(nx,ny,cost+1);\n      mp = tmp;\n    }\n}\n\nint main(){\n\n  for(int i=0;i<h;i++)cin>>mp[i];\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j] =='O') dfs(j,i,0);\n\n  if(ans==1e9) ans=-1;\n  cout<<ans<<endl;\n  \n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nint dy[]={-1,-1,0,1,1,1,0,-1};\nint dx[]={0,1,1,1,0,-1,-1,-1};\n \nstring s;\nint t[21][17];\nint py[20],px[20];\nint m=0,sy,sx;\n \nstruct state{\n  int y,x,S,cost;\n};\n \n \nstate calc(int dir,state s){\n  int T=0;\n \n  int ny=s.y+dy[dir],nx=s.x+dx[dir];\n \n  while(1){\n    if(t[ny][nx]==-1)break;\n    T|=(1<<t[ny][nx]);\n    ny+=dy[dir];\n    nx+=dx[dir];\n  }\n \n  if(T==0)s.cost=-2;\n  s.y=ny;\n  s.x=nx;\n  s.cost++;\n  s.S-=T;\n  return s;\n}\n \nint solve(){\n \n  queue< state > Q;\n  Q.push((state){sy,sx,(1<<m)-1,0});\n \n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    int S=s.S;\n \n    for(int i=0;i<m;i++)\n      if(S>>i&1)\n    t[py[i]][px[i]]=i;\n \n    for(int i=0;i<8;i++){\n      state next=calc(i,s);\n      if(next.cost==-1)continue;\n      if(next.y<1)continue;\n      if(next.y>19){\n    return s.cost+1;\n      }\n      if(next.y==19){\n    if(1<=next.x&&next.x<=15)return s.cost+1;\n    else continue;\n      }\n      if(next.x<1)continue;\n      if(next.x>15)continue;\n      Q.push(next);\n    }\n    for(int i=0;i<m;i++)\n      if(S>>i&1)\n    t[py[i]][px[i]]=-1;\n  }\n  return -1;\n}\n \nint main(){\n  for(int i=0;i<21;i++)\n    for(int j=0;j<17;j++)\n      t[i][j]=-1;\n \n  for(int i=0;i<19;i++){\n    cin>>s;\n    for(int j=0;j<15;j++){\n      if(s[j]=='O'){\n    sy=i+1,sx=j+1;\n      }else if(s[j]=='X'){\n    py[m]=i+1;\n    px[m]=j+1;\n    m++;\n      }\n    }\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int w = 15, h = 19;\n\ntypedef pair<int, pair<int, pii>> State;\n#define F first\n#define S second\n\nint dx[] = { 1, 1, 0,-1,-1,-1, 0, 1};\nint dy[] = { 0, 1, 1, 1, 0,-1,-1,-1};\n\nint main(void){\n    vs field(h + 2);\n\n    rep(x, w + 2) field[0].pb('#'), field[h + 1].pb('@');\n\n    pii s;\n    map<pii, int> stone_id;\n    int cnt_id = 0;\n\n    range(y, 1, h + 1){\n        cin >> field[y];\n        field[y] = \"#\" + field[y] + \"#\";\n\n        if(y == h) range(x, 1, w + 1) if(field[y][x] == '.') field[y][x] = '@';\n        rep(x, w + 2){\n            if(field[y][x] == 'O') s = mp(y, x), field[y][x] = '.';\n            if(field[y][x] == 'X'){\n                stone_id[mp(y, x)] = cnt_id++;\n            }\n        }\n    }\n\n    queue<State> q;\n    q.push(mp(0, mp(0, s)));\n\n    int res = -1;\n    while(!q.empty()){\n        int cur_stones = q.front().F; \n        pii cur_pos = q.front().S.S;\n        int cur_turn = q.front().S.F; q.pop();\n\n        if(field[cur_pos.F][cur_pos.S] == '@'){\n            res = cur_turn;\n            break;\n        }\n\n        rep(i, 8){\n            int next_stones = cur_stones;\n            pii next_pos = cur_pos;\n            int next_turn = cur_turn + 1;\n         \n            while( field[next_pos.F + dy[i]][next_pos.S + dx[i]] == 'X' &&\n                 !((next_stones >> stone_id[mp(next_pos.F + dy[i], next_pos.S + dx[i])]) & 1)){\n                next_pos.F += dy[i];\n                next_pos.S += dx[i];\n\n                int id = stone_id[next_pos];\n                next_stones |= (1 << id);\n            }\n\n            if(cur_pos == next_pos || field[next_pos.F += dy[i]][next_pos.S += dx[i]] == '#') continue;\n\n            State next = mp(next_stones, mp(next_turn, next_pos));\n            q.push(next);\n        }\n    }\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint main(void) {\n  const ll H = 19, W = 15;\n  char S[H][W];\n  REP(i, 0, H) REP(j, 0, W) cin >> S[i][j];\n\n  pll white;\n  vector<pll> black, cand;\n  REP(i, 0, H) REP(j, 0, W) {\n    if(S[i][j] == 'O') {\n      white = pll(i, j);\n      cand.push_back(pll(i, j));\n    }\n    if(S[i][j] == 'X') {\n      black.push_back(pll(i, j));\n      REP(di, -1, 2) REP(dj, -1, 2) if(di != 0 || dj != 0) {\n        ll ni = i + di, nj = j + dj;\n        if(!(0 <= ni && ni < H && 0 <= nj && nj < W)) break;\n        cand.push_back(pll(i + di, j + dj));\n      }\n    }\n  }\n  sort(black.begin(), black.end());\n  sort(cand.begin(), cand.end());\n  cand.erase(unique(cand.begin(), cand.end()), cand.end());\n\n  ll N = black.size(), M = cand.size();\n  map<pll, bool> visited;\n\n  struct state { ll s, v, d; };\n  queue<state> q;\n  q.push((state) { (1LL << N) - 1, lower_bound(cand.begin(), cand.end(), white) - cand.begin(), 0 });\n\n  while(!q.empty()) {\n    ll s = q.front().s, v = q.front().v, d = q.front().d;\n    ll y = cand[v].first, x = cand[v].second;\n    q.pop();\n\n    visited[pll(s, v)] = true;\n\n    REP(i, -1, 2) REP(j, -1, 2) if(i != 0  || j != 0) {\n      ll ns = s, ny = y + i, nx = x + j, nd = d + 1;\n      ll cnt = 0;\n\n      while(1) {\n        if(!(0 <= ny && ny < H && 0 <= nx && nx < W)) break;\n        if(S[ny][nx] != 'X') break;\n\n        ll b = lower_bound(black.begin(), black.end(), pll(ny, nx)) - black.begin();\n        if(b == N) break;\n        if(!(ns & (1LL << b))) break;\n\n        ns = ns - (1LL << b);\n        ny += i;\n        nx += j;\n        cnt++;\n      }\n\n      if(cnt > 0 && ((ny == H - 1 && 0 <= nx && nx < W) || ny >= H)) {\n        cout << nd << endl;\n        return 0;\n      } else if(cnt > 0 && 0 <= ny && ny < H && 0 <= nx && nx < W) {\n        ll nv = lower_bound(cand.begin(), cand.end(), pll(ny, nx)) - cand.begin();\n        if(!visited[pll(ns, nv)]) q.push((state) { ns, nv, nd });\n      }\n    }\n  }\n  cout << -1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nbool visited[1LL << 20][200];\n\nint main(void) {\n  const ll H = 19, W = 15;\n  char S[H][W];\n  REP(i, 0, H) REP(j, 0, W) cin >> S[i][j];\n\n  pll white;\n  vector<pll> black, cand;\n  REP(i, 0, H) REP(j, 0, W) {\n    if(S[i][j] == 'O') {\n      white = pll(i, j);\n      cand.push_back(pll(i, j));\n    }\n    if(S[i][j] == 'X') {\n      black.push_back(pll(i, j));\n      REP(di, -1, 2) REP(dj, -1, 2) if(di != 0 || dj != 0) {\n        ll ni = i + di, nj = j + dj;\n        if(!(0 <= ni && ni < H && 0 <= nj && nj < W)) break;\n        cand.push_back(pll(i + di, j + dj));\n      }\n    }\n  }\n  sort(black.begin(), black.end());\n  sort(cand.begin(), cand.end());\n  cand.erase(unique(cand.begin(), cand.end()), cand.end());\n\n  ll N = black.size(), M = cand.size();\n  REP(i, 0, 1LL << N) REP(j, 0, M) visited[i][j] = false;\n\n  struct state { ll s, v, d; };\n  queue<state> q;\n  q.push((state) { (1LL << N) - 1, lower_bound(cand.begin(), cand.end(), white) - cand.begin(), 0 });\n\n  while(!q.empty()) {\n    ll s = q.front().s, v = q.front().v, d = q.front().d;\n    ll y = cand[v].first, x = cand[v].second;\n    q.pop();\n\n    visited[s][v] = true;\n\n    REP(i, -1, 2) REP(j, -1, 2) if(i != 0  || j != 0) {\n      ll ns = s, ny = y + i, nx = x + j, nd = d + 1;\n      ll cnt = 0;\n\n      while(1) {\n        if(!(0 <= ny && ny < H && 0 <= nx && nx < W)) break;\n        if(S[ny][nx] != 'X') break;\n\n        ll b = lower_bound(black.begin(), black.end(), pll(ny, nx)) - black.begin();\n        if(b == N) break;\n        if(!(ns & (1LL << b))) break;\n\n        ns = ns & (~(1LL << b));\n        ny += i;\n        nx += j;\n        cnt++;\n      }\n\n      if(cnt > 0 && ny >= H - 1) {\n        cout << nd << endl;\n        return 0;\n      } else if(cnt > 0) {\n        ll nv = lower_bound(cand.begin(), cand.end(), pll(ny, nx)) - cand.begin();\n        if(!visited[ns][nv]) q.push((state) { ns, nv, nd });\n      }\n    }\n  }\n  cout << -1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nconst int W = 15, H = 19;\nconst int dx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nbool isGoal(int x, int y) {\n\treturn y >= H-1;\n}\n\nstruct Node {\n\tint x, y, f;\n};\n\nvector<P> v;\nmap<int, map<int, map<int, int> > > dist;\nint sid[H][W];\n\nNode Go(const Node& node, int dir) {\n\tNode res = node;\n\tint x = node.x, y = node.y, f = node.f;\n//\tcout << \"Go:\" << x << \" \" << y << \" \" << dir << \" \" << f << endl;\n\tint nx = x+dx[dir], ny = y+dy[dir];\n\tif ( isGoal(x, y) ) return res;\n\tif ( !inRange(x, y) ) return {0, 0, -1};\n\tif ( sid[y][x] < 0 || (f & (1 << sid[y][x])) ) return res;\n\tres.x = nx, res.y = ny;\n\tres.f = f | (1 << sid[y][x]);\n\treturn Go(res, dir);\n}\nNode GoFirst(const Node& node, int dir) {\n\tNode res = {0, 0, -1};\n\tint x = node.x, y = node.y, f = node.f;\n\tint nx = x+dx[dir], ny = y+dy[dir];\n\tif ( !inRange(nx, ny) ) return res;\n\tif ( sid[ny][nx] < 0 || (f & (1 << sid[ny][nx])) ) return res;\n\tres.x = nx;\n\tres.y = ny;\n\tres.f = f;\n\treturn Go(res, dir);\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tvector<string> m(H); cin >> m;\n\tint sx = -1, sy = -1;\n\tREP(y, H) REP(x, W) {\n\t\tif (m[y][x] == 'O') {\n\t\t\tsx = x, sy = y;\n\t\t}\n\t\tif (m[y][x] == 'X') {\n\t\t\tv.pb( P(x, y) );\n\t\t}\n\t}\n\tassert(sx >= 0);\n\n\tint N = v.size();\n\tfill(sid[0], sid[H], -1);\n\tREP(i, N) {\n\t\tint x = v[i].first, y = v[i].second;\n\t\tsid[y][x] = i;\n\t}\n\n\tll ans = 0;\n\tqueue<Node> Q; Q.push({sx, sy, 0});\n//\tfill(dist[0][0], dist[H-1][W], inf);\n\tdist[sy][sx][0] = 1;\n\tif (isGoal(sx, sy)) ans = 1;\n\twhile ( !Q.empty() ) {\n\t\tNode node = Q.front(); Q.pop();\n\t\tint x = node.x, y = node.y, f = node.f;\n//\t\tcout << x << \" \" << y << \" \" << f << endl;\n\t\tREP(i, 8) {\n\t\t\tNode n = GoFirst(node, i);\n\t\t\tif (n.f >= 0) {\n\t\t\t\tif ( isGoal(n.x, n.y) ) {\n\t\t\t\t\tif (ans == 0 || dist[y][x][f]+1 < ans) {\n\t\t\t\t\t\tans = dist[y][x][f]+1;\n//\t\t\t\t\tcout << \"goal\" << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (dist[n.y][n.x][n.f] == 0 || dist[y][x][f]+1 < dist[n.y][n.x][n.f]) {\n\t\t\t\t\tdist[n.y][n.x][n.f] = dist[y][x][f]+1;\n\t\t\t\t\tQ.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ans == 0) cout << -1 << endl;\n\telse cout << ans-1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <assert.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\nchar F[20][16];\nint sx, sy;\nunordered_map<int, int> umap;\n\nconstexpr int to_num(int x, int y) {\n  return x+y*16;\n}\n\nstruct state {\n  int x, y, cost, used;\n  state(int x, int y, int cost, int used) : x(x), y(y), cost(cost), used(used) {}\n  bool operator < (state const& s) const {\n    return cost > s.cost;\n  }\n};\n\nint const dx[8] = {-1, 0, 1, 0,-1, 1, 1,-1};\nint const dy[8] = {0, -1, 0, 1,-1,-1, 1, 1};\n\nint const INF = 1<<29;\n\nbool inrange(int x, int y) {\n  return 0<=x && x<16 && 0<=y && y<20;\n}\n\nbool is_used_xy(int used, int x, int y) {\n  if(umap[to_num(x, y)] == -1) { return false; }\n  return used >> umap[to_num(x, y)] & 1;\n}\n\nvoid debugger(int used, int cx, int cy) {\n  rep(i, 20) {\n    rep(j, 16) {\n      if(cx == j && cy == i) {\n        assert((F[i][j] == 'X' && is_used_xy(used, j, i)) || (F[i][j] == '.') || (F[i][j] == 'G'));\n        cout << 'O';\n      }\n      else {\n        cout << (is_used_xy(used, j, i) ? 'U' : F[i][j]);\n      }\n    }\n    cout << endl;\n  }\n}\n\nint dijkstra() {\n  int dist[22][22];\n  fill(dist[0], dist[0]+22*22, INF);\n  priority_queue<state> pq;\n  pq.emplace(sx, sy, 0, 0);\n  dist[sy][sx] = 0;\n  while(!pq.empty()) {\n    const int x = pq.top().x, y = pq.top().y, cost = pq.top().cost, used = pq.top().used;\n    pq.pop();\n    if(F[y][x] == 'G') { return cost; }\n    rep(i, 8) {\n      int nx = x+dx[i], ny = y+dy[i];\n      int nused = used;\n      if(F[ny][nx] != 'X') { continue; }\n      if(is_used_xy(used, nx, ny)) { continue; }\n      bool ng = false;\n      for(;;) {\n        if(!inrange(nx, ny)) { ng = true; break; }\n        if(F[ny][nx] != 'X') { break; }\n        if(is_used_xy(used, nx, ny)) { break; }\n        nused |= 1<<umap[to_num(nx, ny)];\n        nx += dx[i], ny += dy[i];\n      }\n      if(ng) { continue; }\n      if(F[ny][nx] == 'A') { continue; }\n\n      if(dist[ny][nx] <= cost+1) { continue; }\n      dist[ny][nx] = cost+1;\n      pq.emplace(nx, ny, dist[ny][nx], nused);\n    }\n  }\n  return -1;\n}\n\nint main() {\n\n  rep(i, 20) rep(j, 16) umap[to_num(j, i)] = -1;\n  int bcnt = 0;\n  rep(i, 19) rep(j, 15) {\n    cin >> F[i][j];\n    if(F[i][j] == 'O') {\n      F[i][j] = '.';\n      sx = j, sy = i;\n    }\n    if(F[i][j] == 'X') {\n      umap[to_num(j,i)] = bcnt++;\n    }\n  }\n\n  rep(i, 20) { F[i][15] = 'A'; }\n  rep(i, 16) { F[19][i] = 'G'; }\n\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int w = 15, h = 19;\n\ntypedef pair<vs, pair<int, pii>> State;\n#define F first\n#define S second\n\nint dx[] = { 1, 1, 0,-1,-1,-1, 0, 1};\nint dy[] = { 0, 1, 1, 1, 0,-1,-1,-1};\n\nint main(void){\n    vs origin_field(h + 2);\n\n    rep(x, w + 2) origin_field[0].pb('#'), origin_field[h + 1].pb('@');\n\n    pii s;\n    range(y, 1, h + 1){\n        cin >> origin_field[y];\n        origin_field[y] = \"#\" + origin_field[y] + \"#\";\n\n        if(y == h) range(x, 1, w + 1) if(origin_field[y][x] == '.') origin_field[y][x] = '@';\n        rep(x, w + 2) if(origin_field[y][x] == 'O') s = mp(y, x), origin_field[y][x] = '.';\n    }\n\n    queue<State> q;\n    q.push(mp(origin_field, mp(0, s)));\n\n    int res = -1;\n    while(!q.empty()){\n        vs cur_field = q.front().F; \n        pii cur_pos = q.front().S.S;\n        int cur_turn = q.front().S.F; q.pop();\n\n        if(cur_field[cur_pos.F][cur_pos.S] == '@'){\n            res = cur_turn;\n            break;\n        }\n\n        rep(i, 8){\n            vs next_field = cur_field;\n            pii next_pos = cur_pos;\n            int next_turn = cur_turn + 1;\n         \n            while(next_field[next_pos.F + dy[i]][next_pos.S + dx[i]] == 'X'){\n                next_pos.F += dy[i];\n                next_pos.S += dx[i];\n\n                next_field[next_pos.F][next_pos.S] = '.';\n            }\n\n            if(cur_pos == next_pos || next_field[next_pos.F += dy[i]][next_pos.S += dx[i]] == '#') continue;\n\n            State next = mp(next_field, mp(next_turn, next_pos));\n            q.push(next);\n        }\n    }\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n//const int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\nconst int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nconst int h = 19, w = 15;\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tvs fld(h);\n\tREP(i, h) cin >> fld[i];\n\tvector<vi> id(h, vi(w, -1));\n\tvector<pii> place;\n\tint cnt = 0;\n\tpii init;\n\tREP(i, h)REP(j, w)\n\t{\n\t\tif (fld[i][j] == '.') continue;\n\t\tif (fld[i][j] == 'O')\n\t\t{\n\t\t\tinit = pii(i, j);\n\t\t\tfld[i][j] = '.';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tid[i][j] = cnt;\n\t\t\tplace.push_back(pii(i, j));\n\t\t\tcnt++;\n\t\t}\n\t}\n\tmap<pair<int, pii>, int> mp;\n\tqueue<pair<int, pii>> que;\n\tque.emplace(0, init);\n\twhile (!que.empty())\n\t{\n\t\tauto tmp = que.front(); que.pop();\n\t\tint bit = tmp.first, tx = tmp.second.first, ty = tmp.second.second;\n\t\t//cout << bitset<20>(bit) << \" \" << tx << \" \" << ty << endl;\n\t\tif (tx >= h - 1)\n\t\t{\n\t\t\tcout << mp[tmp] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tREP(i, 8)\n\t\t{\n\t\t\tint nx = tx + dx[i], ny = ty + dy[i];\n\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '.' || (bit >> id[nx][ny]) & 1) continue;\n\t\t\tvi remove;\n\t\t\twhile (valid(nx, ny, h, w) && fld[nx][ny] != '.' && ((bit >> id[nx][ny]) & 1) == 0)\n\t\t\t{\n\t\t\t\tremove.push_back(id[nx][ny]);\n\t\t\t\tnx += dx[i], ny += dy[i];\n\t\t\t}\n\t\t\tif ((tx == h - 1 && ty == -1) || (tx == h - 1 && ty == w)) continue;\n\t\t\tint nbit = bit;\n\t\t\tfor (auto j : remove) nbit |= 1 << j;\n\t\t\tpair<int, pii> nex(nbit, pii(nx, ny));\n\t\t\tif (mp.count(nex)) continue;\n\t\t\tmp[nex] = mp[tmp] + 1;\n\t\t\tque.push(nex);\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst char h = 20, w = 17;\nvector<vector<bool>> c;\ntypedef tuple<pair<char, char>, vector<vector<bool>>, char> T;\nqueue<T> q;\nmap<vector<vector<bool>>, vector<vector<char>>> memo;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nbool impossible(int y, vector<vector<bool>>& c){\n\trange(i,y + 1,18){\n\t\tbool f = false;\n\t\trep(j,w){\n\t\t\tif(c[i][j]) f = true;\n\t\t}\n\t\tif(not f) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tc = vector<vector<bool>>(h, vector<bool>(w,0));\n\n\tpair<char, char> s;\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tchar a;\n\t\t\tcin >> a;\n\t\t\tif(a == 'X') c[i][j + 1] = 1;\n\t\t\telse c[i][j + 1] = 0;\n\t\t\tif(a == 'O'){\n\t\t\t\ts = make_pair(i,j + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tq.push(T(s,c,0));\n\n\tchar ans = 127;\n\twhile(not q.empty()){\n\t\tchar cost;\n\t\ttie(s,c,cost) = q.front(); q.pop();\n\n\t\tchar y, x;\n\t\ttie(y,x) = s;\n\n\t\t//rep(i,h){ rep(j,w){ if(i == y and j == x) cout << 'O'; else cout << c[i][j]; } cout << endl; } cout << endl;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(impossible(y, c)) continue;\n\n\t\tif(cost >= 20) continue;\n\n\t\trep(i,8){\n\t\t\tchar ny = y + dy[i];\n\t\t\tchar nx = x + dx[i];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)) continue;\n\t\t\tvector<vector<bool>> pc = c;\n\t\t\tif(pc[ny][nx] == 1){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pc[ny][nx] == 0) break;\n\t\t\t\t\tpc[ny][nx] = 0;\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tif(memo.count(pc)){\n\t\t\t\t\tauto& it = memo[pc];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<char>> dis(h, vector<char>(w,127));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[pc] = dis;\n\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == 127 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nbool in(int x, int y) {\n  return 0<=x&&x<15&&0<=y&&y<19;\n}\n\nstring S[20];\nint sx, sy;\nmap<pint, int> mp;\nint dp[1<<20];\n\nint solve(int x, int y, int bit) {\n  if(y >= 19 || y == 18 && 0 <= x && x < 15) return 0;\n  if(y < 0 || x < 0 || 15 <= x) return inf;\n  int &res = dp[bit];\n  if(~res) return res;\n  res = inf;\n  for(int dx = -1; dx < 2; dx++) {\n    for(int dy = -1; dy < 2; dy++) {\n      if(dx == 0 && dy == 0) continue;\n      int nx = x + dx, ny = y + dy, nbit = bit;\n      if(!in(nx, ny) || S[ny][nx] != 'X') continue;\n      if((bit>>mp[pint(nx, ny)])&1) continue;\n      while(in(nx, ny) && S[ny][nx] == 'X' && !(bit>>mp[pint(nx, ny)]&1)) {\n\tnbit |= 1<<mp[pint(nx, ny)];\n\tnx += dx, ny += dy;\n      }\n      res = min(res, solve(nx, ny, nbit) + 1);\n    }\n  }\n  return res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int cnt = 0;\n  rep(i, 19) {\n    cin >> S[i];\n    rep(j, 15) {\n      if(S[i][j] == 'O') sx = j, sy = i;\n      if(S[i][j] == 'X') mp[pint(j, i)] = cnt++;\n    }\n  }\n  memset(dp, -1, sizeof(dp));\n  int ans = solve(sx, sy, 0);\n  cout << (ans == inf ? -1 : ans) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\nint BFS(vector<string> v)\n{\n\tmap<vector<string>, int> d; d[v] = 1;\n\n\tqueue<pair<vector<string>, int> > que; que.push(make_pair(v, 1));\n\n\tfor (int i = 0; i < 15; i++)\n\t{\n\t\tif (v[18][i] == 'O')\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tvector<string> v1 = que.front().first;\n\n\t\tint dist = que.front().second; que.pop();\n\n\t\tint sx = -1, sy = -1;\n\n\t\tfor (int i = 0; i < 19; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 15; j++)\n\t\t\t{\n\t\t\t\tif (v1[i][j] == 'O')\n\t\t\t\t{\n\t\t\t\t\tsx = j; sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\tif (0 <= sx + dx[dir] && sx + dx[dir] < 15 && 0 <= sy + dy[dir] && sy + dy[dir] < 19)\n\t\t\t{\n\t\t\t\tif (v1[sy + dy[dir]][sx + dx[dir]] == 'X')\n\t\t\t\t{\n\t\t\t\t\tint x = sx + dx[dir] * 2;\n\t\t\t\t\tint y = sy + dy[dir] * 2;\n\n\t\t\t\t\twhile (0 <= x && x < 15 && 0 <= y)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (y > 17) { return dist; }\n\n\t\t\t\t\t\tif (v1[y][x] == '.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvector<string> v2 = v1;\n\n\t\t\t\t\t\t\tint rx = sx, ry = sy;\n\n\t\t\t\t\t\t\tfor (; x != rx || y != ry;)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tv2[ry][rx] = '.';\n\n\t\t\t\t\t\t\t\trx += dx[dir];\n\t\t\t\t\t\t\t\try += dy[dir];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tv2[y][x] = 'O';\n\n\t\t\t\t\t\t\tif (d[v2] == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\td[v2] = dist + 1;\n\n\t\t\t\t\t\t\t\tque.push(make_pair(v2, dist + 1));\n\n\t\t\t\t\t\t\t\tgoto Exit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx += dx[dir];\n\t\t\t\t\t\ty += dy[dir];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tExit:;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tvector<string> v(19);\n\n\tfor (int i = 0; i < 19; i++) { cin >> v[i]; }\n\n\tcout << BFS(v) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define H 19\n#define W 15\n\nstruct State{\n  int x,y,S;\n  State(int x,int y,int S) : x(x),y(y),S(S) {}\n  \n  bool operator < (const State &s)const{\n    if(x != s.x){\n      return x < s.x;\n    }else if(y != s.y){\n      return y < s.y;\n    }else{\n      return S < s.S;\n    }\n  }\n};\n\nint num[H][W];\nchar field[H][W];\nmap<State,int> step;\nconst int dx[8] = {-1,-1,-1,0,0,1,1,1};\nconst int dy[8] = {-1,0,1,-1,1,-1,0,1};\n\ninline bool inH(int y){\n  return (0 <= y && y < H);\n}\n\ninline bool inW(int x){\n  return (0 <= x && x < W);\n}\n\ninline bool inField(int x,int y){\n  return (inH(y) && inW(x));\n}\n\nint bfs(int sx,int sy){\n  queue<State> Q;\n  Q.push(State(sx,sy,0));\n  step[State(sx,sy,0)] = 0;\n\n  while(!Q.empty()){\n    State s = Q.front(); Q.pop();\n    int x = s.x,y = s.y,S = s.S;\n    if(y >= H){\n      return step[s];\n    }\n    for(int i = 0 ; i < 8 ; i++){\n      int nx = x+dx[i], ny = y+dy[i], nS = S;\n      if(!inField(nx,ny)){ continue; }\n      if(field[ny][nx] != 'X'){ continue; }\n      if(num[ny][nx] >= 0 && !(S >> num[ny][nx] & 1)){\n        bool can = true;\n        nS |= (1<<num[ny][nx]);\n        while(true){\n          nx += dx[i]; ny += dy[i];\n          if(ny >= H || (ny == H-1 && inW(nx))){\n            return step[s]+1;\n          }\n          if(!inW(nx) || ny < 0){ can = false; break; }\n          if(field[ny][nx] != 'X'){ break; }\n          if(nS >> num[ny][nx] & 1){ break; }\n          nS |= (1<<num[ny][nx]);\n        }\n        if(can && step.find(State(nx,ny,nS)) == step.end()){\n          step[State(nx,ny,nS)] = step[s]+1;\n          Q.push(State(nx,ny,nS));\n        }\n      }\n    }\n  }\n  return -1;\n}\n\nint main(){\n  int x,y,n = 0;\n  memset(num,-1,sizeof(num));\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> field[i][j];\n      if(field[i][j] == 'O'){\n        x = j; y = i;\n      }else if(field[i][j] == 'X'){\n        num[i][j] = n++;\n      }\n    }\n  }\n  cout << bfs(x,y) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 30;\n\nint main() {\n  vector<string> t(19);\n  vector<pair<int, int>> vb;\n  vector<vector<int>> idx(19, vector<int>(15, -1));\n  int si, sj;\n  REP(i,19) {\n    cin>>t[i];\n    REP(j,15) {\n      if (t[i][j] == 'X') {\n        idx[i][j] = vb.size();\n        vb.emplace_back(i,j);\n      } else if (t[i][j] == 'O') {\n        si = i;\n        sj = j;\n      }\n    }\n  }\n  int n = vb.size();\n  vector<vector<int8_t>> dp(1<<n, vector<int8_t>(15*19+1, INF));\n  dp[0][si*15+sj] = 0;\n  REP(i,1<<n) {\n    REP(j,15*19) {\n      if (dp[i][j] == INF) continue;\n      int oi = j/15;\n      int oj = j%15;\n      int di[8] = {1, 1, 1, 0, -1, -1, -1, 0};\n      int dj[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\n      REP(k,8) {\n        int l = 1;\n        vector<int> ei;\n        int ni;\n        int nj;\n        while (1) {\n          ni = oi + l*di[k];\n          nj = oj + l*dj[k];\n          if (ni < 0 || ni >= 19 || nj < 0 || nj >= 15) break;\n          if (idx[ni][nj] < 0 || ((i>>idx[ni][nj])&1)) break;\n          ei.push_back(idx[ni][nj]);\n          ++l;\n        }\n        if (l > 1) {\n          int pi = i;\n          for (int ix : ei) {\n            pi |= 1 << ix;\n          }\n          if (ni >= 19) {\n            dp[pi][15*19] = min(dp[pi][15*19], int8_t(dp[i][j]+1));\n          } else if (ni >= 0 && nj >= 0 && nj < 15) {\n            dp[pi][ni*15+nj] = min(dp[pi][ni*15+nj], int8_t(dp[i][j]+1));\n          }\n        }\n      }\n    }\n  }\n  int8_t res = INF;\n  REP(i,1<<n) res = min(res, dp[i][15*19]);\n  if (res < INF) {\n    cout << res << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int H = 19, W = 15;\nstring s[H];\n\nconst int INF = 19191919;\nvector<pi> black;\nmap<pi,int> b2id;\nint n;\n\nmap<pi,int> dp[1<<20];\nint dfs(int mask, pi pos){\n    if(pos.fi >=H) return 0;\n    if(pos.se<0 || W<=pos.se) return INF;\n    if(pos.fi == H-1) return 0;\n\n    if(dp[mask].count(pos)) return dp[mask][pos];\n\n    set<pi> rem;\n    rep(i,n)if(!(mask>>i&1)) rem.insert(black[i]);\n\n    int ret = INF;\n    for(int dy=-1; dy<=1; ++dy)for(int dx=-1; dx<=1; ++dx){\n        if(dy==0 && dx==0) continue;\n\n        pi nx = pos;\n        nx.fi += dy;\n        nx.se += dx;\n        if(!rem.count(nx)) continue;\n\n        int nmask = mask;\n        while(rem.count(nx)){\n            nmask |= 1<<b2id[nx];\n            nx.fi += dy;\n            nx.se += dx;\n        }\n\n        ret = min(ret, dfs(nmask, nx)+1);\n    }\n\n    return dp[mask][pos] = ret;\n}\n\nint main(){\n    rep(i,H) cin >>s[i];\n\n    pi white;\n    rep(i,H)rep(j,W){\n        if(s[i][j]=='O') white = {i,j};\n        if(s[i][j]=='X') black.pb({i,j});\n    }\n    n = black.size();\n\n    rep(i,n) b2id[black[i]] = i;\n\n    int ans = dfs(0, white);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst char h = 20, w = 17;\nvector<vector<bool>> c;\ntypedef tuple<pair<char, char>, vector<vector<bool>>, char> T;\nqueue<T> q;\nmap<vector<vector<bool>>, vector<vector<char>>> memo;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint main(){\n\tc = vector<vector<bool>>(h, vector<bool>(w,0));\n\n\tpair<char, char> s;\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tchar a;\n\t\t\tcin >> a;\n\t\t\tif(a == 'X') c[i][j + 1] = 1;\n\t\t\telse c[i][j + 1] = 0;\n\t\t\tif(a == 'O'){\n\t\t\t\ts = make_pair(i,j + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tq.push(T(s,c,0));\n\n\tchar ans = 254;\n\twhile(not q.empty()){\n\t\tchar cost;\n\t\ttie(s,c,cost) = q.front(); q.pop();\n\n\t\tchar y, x;\n\t\ttie(y,x) = s;\n\n\t\t//rep(i,h){ rep(j,w){ if(i == y and j == x) cout << 'O'; else cout << c[i][j]; } cout << endl; } cout << endl;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(i,8){\n\t\t\tchar ny = y + dy[i];\n\t\t\tchar nx = x + dx[i];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)) continue;\n\t\t\tvector<vector<bool>> pc = c;\n\t\t\tif(pc[ny][nx] == 1){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pc[ny][nx] == 0) break;\n\t\t\t\t\tpc[ny][nx] = 0;\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tif(memo.count(pc)){\n\t\t\t\t\tauto& it = memo[pc];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<char>> dis(h, vector<char>(w,254));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[pc] = dis;\n\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == 254 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H=19,W=15;\n\nenum DIR{\n    Left_Up,\n    Up,\n    Right_Up,\n    Left,\n    Right,\n    Left_Down,\n    Down,\n    Right_Down,\n};\n\nDIR dir[8] = {Left_Up,Up,Right_Up,Left,Right,Left_Down,Down,Right_Down};\n\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\n\nstruct BlackStone{\n    short row,col;\n    bool erased;\n};\n\nstruct Info{\n    BlackStone black_stone[20];\n    short row,col,black_num,count;\n};\n\nbool rangeCheck(int row,int col){\n    if(row <= 17){\n        if(col < 0 || col > 14){\n            return false;\n        }else{\n            return true;\n        }\n    }else{ //row >= 18\n        if(row == 18 && (col < 0 || col > 14)){\n            return false;\n        }else{\n            return true;\n        }\n    }\n}\n\nInfo move(Info info,DIR dir){\n    Info ret;\n\n    char map[19][15];\n    for(int i = 0; i < H; i++){\n        for(int k = 0; k < W; k++)map[i][k] = '.';\n    }\n\n    for(int i = 0; i < info.black_num; i++){\n        if(info.black_stone[i].erased == false){\n            map[info.black_stone[i].row][info.black_stone[i].col] = 'X';\n        }\n        ret.black_stone[i].row = info.black_stone[i].row;\n        ret.black_stone[i].col = info.black_stone[i].col;\n        ret.black_stone[i].erased = info.black_stone[i].erased;\n    }\n    ret.black_num = info.black_num;\n    ret.count = info.count+1;\n\n    int next_row,next_col,index;\n\n    switch(dir){\n    case Left_Up:\n        index = 0;\n        break;\n    case Up:\n        index = 1;\n        break;\n    case Right_Up:\n        index = 2;\n        break;\n    case Left:\n        index = 3;\n        break;\n    case Right:\n        index = 4;\n        break;\n    case Left_Down:\n        index = 5;\n        break;\n    case Down:\n        index = 6;\n        break;\n    case Right_Down:\n        index = 7;\n        break;\n    }\n\n    next_row = info.row+diff_row[index];\n    next_col = info.col+diff_col[index];\n\n    while(rangeCheck(next_row,next_col) == true && map[next_row][next_col] == 'X'){\n        next_row += diff_row[index];\n        next_col += diff_col[index];\n    }\n\n\n    if(next_row == info.row+diff_row[index] && next_col == info.col+diff_col[index]){\n        ret.row = 1;\n        ret.col = -1;\n    }else{\n        int tmp_row,tmp_col;\n\n        tmp_row = info.row+diff_row[index];\n        tmp_col = info.col+diff_col[index];\n\n        while(tmp_row != next_row || tmp_col != next_col){\n            for(int i = 0; i < ret.black_num;i++){\n                if(ret.black_stone[i].erased == false && ret.black_stone[i].row == tmp_row && ret.black_stone[i].col == tmp_col){\n                    ret.black_stone[i].erased = true;\n                    break;\n                }\n            }\n            tmp_row += diff_row[index];\n            tmp_col += diff_col[index];\n        }\n\n        ret.row = next_row;\n        ret.col = next_col;\n    }\n\n    return ret;\n}\n\nint main(){\n\n    Info first;\n\n    for(int i = 0; i < 20; i++)first.black_stone[i].erased = true;\n    first.black_num = 0;\n    char buf[15];\n    int minimum = BIG_NUM,start_row,start_col;\n\n    for(int i = 0; i < H; i++){\n        scanf(\"%s\",buf);\n        for(int k = 0; k < W; k++){\n            if(buf[k] == 'O'){\n                start_row = i;\n                start_col = k;\n            }else if(buf[k] == 'X'){\n                first.black_stone[first.black_num].erased = false;\n                first.black_stone[first.black_num].row = i;\n                first.black_stone[first.black_num++].col = k;\n            }\n        }\n    }\n\n    first.row = start_row;\n    first.col = start_col;\n    first.count = 0;\n\n    queue<Info> Q;\n    Q.push(first);\n\n    while(!Q.empty()){\n\n        if(Q.front().row >= 18){\n            minimum = Q.front().count;\n            break;\n        }else{\n\n            for(int i = 0; i < 8; i++){\n                Info next = move(Q.front(),dir[i]);\n\n                if(rangeCheck(next.row,next.col)){\n                    Q.push(next);\n                }\n            }\n\n            Q.pop();\n        }\n    }\n\n    if(minimum == BIG_NUM){\n        printf(\"-1\\n\");\n    }else{\n        printf(\"%d\\n\",minimum);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst long long int MOD = 1000000007;\nconst int INF = 1000000000;\n\nchar bo[19][15];\nint h = 19, w = 15;\nint y, x;\nint ans = INF;\n\nint dy[8] = {1,0,-1,1,-1,1,0,-1};\nint dx[8] = {1,1,1,0,0,-1,-1,-1};\n\nvoid dfs(int yy, int xx, int dep){\n    rep(i,8){\n        int nowy = yy, nowx = xx;\n        for(int j = 0;;j++){\n            nowy += dy[i];\n            nowx += dx[i];\n            if(nowy >= h){\n                ans = min(ans,dep+1);\n                return;\n            }\n            if(0>nowy||0>nowx||nowx>=w){\n                break;\n            }\n            if(bo[nowy][nowx] == '.'){\n                if(j == 0) break;\n                if(nowy == h-1){\n                    ans = min(ans,dep+1);\n                    return;\n                }\n                int prey = nowy, prex = nowx;\n                prey -= dy[i];\n                prex -= dx[i];\n                while(prey != yy || prex != xx){\n                    bo[prey][prex] = '.';\n                    prey -= dy[i];\n                    prex -= dx[i];\n                }\n                dfs(nowy,nowx,dep+1);\n                prey += dy[i];\n                prex += dx[i];\n                while(prey != nowy || prex != nowx){\n                    bo[prey][prex] = 'X';\n                    prey += dy[i];\n                    prex += dx[i];\n                }\n                break;\n            }\n        }\n    }\n}\n\nint main(){\n    rep(i,h) rep(j,w) cin >> bo[i][j];\n    rep(i,h) rep(j,w){\n        if(bo[i][j] == 'O'){\n            y = i;\n            x = j;\n            bo[i][j] = '.';\n        }\n    }\n    dfs(y,x,0);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint main(){\n  vector<string> vec(19);\n  rep(i,19) cin>>vec[i];\n  int n = 0;\n  map<pair<int,int>,int> p2i;\n  rep(i,19)rep(j,15) if(vec[i][j]=='X'){\n    p2i[mp(i,j)] = n++;\n  }\n  int sx,sy;\n  rep(i,19)rep(j,15) if(vec[i][j]=='O') sx=i, sy=j;\n\n  using state = pair<int,pair<int,int>>;\n\n  auto ok = [&](int i, int j){\n    return i>=0 && i<19 && j>=0 && j<15;\n  };\n\n  set<state> prev;\n  prev.insert(mp(0,mp(sx,sy)));\n\n  rep(i,20){\n    set<state> nxt;\n    for(const state & s : prev){\n      int mask = s.fi;\n      int x = s.se.fi, y = s.se.se;\n      for(int dx=-1; dx<=1; dx++){\n        for(int dy=-1; dy<=1; dy++) if(dx*dx+dy*dy>0){\n          int nmask = mask;\n          int d = 1;\n          while(ok(x+dx*d,y+dy*d) && vec[x+dx*d][y+dy*d]=='X'){\n            int idx = p2i[mp(x+dx*d, y+dy*d)];\n            if(! (mask & (1<<idx)) ){\n              nmask |= (1<<idx);\n              d++;\n            }\n            else {\n              break;\n            }\n          }\n          if(d==1) continue;\n          int nx=x+dx*d, ny=y+dy*d;\n          if(nx>=18){\n            cout << i+1 << endl;\n            return 0;\n          }\n          if(ok(nx,ny)) nxt.insert(mp(nmask,mp(nx,ny)));\n        }\n      }\n    }\n    swap(nxt, prev);\n  }\n\n  cout << -1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <assert.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\nchar F[20][16];\nint sx, sy;\nunordered_map<int, int> umap;\n\nconstexpr int to_num(int x, int y) {\n  return x+y*16;\n}\n\nstruct state {\n  int x, y, cost, used;\n  state(int x, int y, int cost, int used) : x(x), y(y), cost(cost), used(used) {}\n  bool operator < (state const& s) const {\n    return cost > s.cost;\n  }\n};\n\nint const dx[8] = {-1, 0, 1, 0,-1, 1, 1,-1};\nint const dy[8] = {0, -1, 0, 1,-1,-1, 1, 1};\n\nint const INF = 1<<29;\n\nbool inrange(int x, int y) {\n  return 0<=x && x<16 && 0<=y && y<20;\n}\n\nbool is_used_xy(int used, int x, int y) {\n  if(umap[to_num(x, y)] == -1) { return false; }\n  return used >> umap[to_num(x, y)] & 1;\n}\n\nvoid debugger(int used, int cx, int cy) {\n  rep(i, 20) {\n    rep(j, 16) {\n      if(cx == j && cy == i) {\n        assert((F[i][j] == 'X' && is_used_xy(used, j, i)) || (F[i][j] == '.') || (F[i][j] == 'G'));\n        cout << 'O';\n      }\n      else {\n        cout << (is_used_xy(used, j, i) ? 'U' : F[i][j]);\n      }\n    }\n    cout << endl;\n  }\n}\n\nint dijkstra() {\n  int dist[22][22];\n  fill(dist[0], dist[0]+22*22, INF);\n  priority_queue<state> pq;\n  pq.emplace(sx, sy, 0, 0);\n  dist[sy][sx] = 0;\n  while(!pq.empty()) {\n    const int x = pq.top().x, y = pq.top().y, cost = pq.top().cost, used = pq.top().used;\n    pq.pop();\n    if(x == -1 && y == 19) { return cost; }\n    if(F[y][x] == 'G') { return cost; }\n    rep(i, 8) {\n      int nx = x+dx[i], ny = y+dy[i];\n      int nused = used;\n      if(!inrange(nx, ny)) { continue; }\n      if(F[ny][nx] != 'X') { continue; }\n      if(is_used_xy(used, nx, ny)) { continue; }\n      bool ng = false;\n      for(;;) {\n        if(!inrange(nx, ny)) { ng = true; break; }\n        if(F[ny][nx] != 'X') { break; }\n        if(is_used_xy(used, nx, ny)) { break; }\n        nused |= 1<<umap[to_num(nx, ny)];\n        nx += dx[i], ny += dy[i];\n      }\n      if(ng && nx == -1 && ny == 19) { pq.emplace(-1,19,cost+1, nused); continue; }\n      if(ng) { continue; }\n      if(F[ny][nx] == 'A') { continue; }\n\n      if(dist[ny][nx] <= cost+1) { continue; }\n      dist[ny][nx] = cost+1;\n      pq.emplace(nx, ny, dist[ny][nx], nused);\n    }\n  }\n  return -1;\n}\n\nint main() {\n\n  rep(i, 20) rep(j, 16) umap[to_num(j, i)] = -1;\n  int bcnt = 0;\n  rep(i, 19) rep(j, 15) {\n    cin >> F[i][j];\n    if(F[i][j] == 'O') {\n      F[i][j] = '.';\n      sx = j, sy = i;\n    }\n    if(F[i][j] == 'X') {\n      umap[to_num(j,i)] = bcnt++;\n    }\n  }\n\n  rep(i, 20) { F[i][15] = 'A'; }\n  rep(i, 16) {\n    if(i < 15 && F[18][i] != 'X') { F[18][i] = 'G'; }\n    F[19][i] = 'G';\n  }\n\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nint field[19][15];\nstruct aa {\n\tint x;\n\tint y;\n\tbitset<20>bs;\n\tint turn;\n};\nbool operator<(const aa&l, const aa&r) {\n\treturn l.x == r.x ? l.y == r.y ? l.bs.to_ulong() < r.bs.to_ulong() : l.y < r.y : l.x < r.x;\n}bool operator==(const aa&l, const aa&r) {\n\treturn l.x == r.x && l.y == r.y && l.bs.to_ulong();\n}\n\nint dx8[8] = { -1,-1,-1, 0, 1, 1, 1, 0 };\nint dy8[8] = { -1, 0, 1, 1, 1, 0,-1,-1 };\npair<int, int> amove(const int way,const int fx, const int fy, bitset<20>&bs) {\n\tint nx = fx+dx8[way];\n\tint ny = fy + dy8[way];\n\tbool ok = false;\n\twhile (1) {\n\t\tif (ny >= 18 && ok) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nx < 0 || nx >= 15 || ny < 0)return make_pair(-1, -1);\n\t\tif (field[ny][nx] && bs[field[ny][nx] - 1]) {\n\t\t\tbs[field[ny][nx] - 1] = false;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\tif (ny >= 18&&ok) {\n\t\t\tbreak;\n\t\t}\n\t\tok = true;\n\t\tny += dy8[way];\n\t\tnx += dx8[way];\n\t}\n\tif (!ok) {\n\t\treturn make_pair(-100, -100);\n\t}\n\telse {\n\t\treturn make_pair(nx, ny);\n\t}\n}\n\nint main() {\n\tint num = 1;\n\tint sx = 0, sy = 0;\n\tfor (int i = 0; i < 19; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < 15; ++j) {\n\t\t\tif (st[j] == 'X') {\n\t\t\t\tfield[i][j] = num;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\telse if (st[j] == 'O') {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<aa>que;\n\tque.push(aa{ sx,sy,bitset<20>((1 << (num-1)) - 1),0 });\n\tmap<aa,int>mp;\n\tmp[que.front()]=0;\n\tint ans = -1;\n\twhile (!que.empty()) {\n\t\taa atop(que.front());\n\t\tque.pop();\n\t\tif (atop.y >= 18) {\n\t\t\tans = atop.turn;\n\t\t\tbreak;\n\t\t}\n\t\tfor (int way = 0; way < 8; ++way) {\n\t\t\tbitset<20>bs(atop.bs);\n\t\t\tpair<int, int>p(amove(way, atop.x, atop.y, bs));\n\t\t\tif (p.first != -100) {\n\t\t\t\tif (mp.find(aa{ p.first,p.second,bs, 0 }) == mp.end()) {\n\t\t\t\t\tmp[aa{ p.first,p.second,bs,0 }] = atop.turn + 1;\n\t\t\t\t\tque.push(aa{ p.first,p.second,bs,atop.turn + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<queue>\n#include<cassert>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 20, T = (1<<N), H = 19, W = 15;\n\nset<int> memo[T];\nint board[H][W];\nint stx,sty;\n\nclass Q{\npublic:\n\tint x,y,cnt,state;\n\tQ(int x,int y,int cnt, int state):x(x),y(y),cnt(cnt),state(state){}\n};\n\nvoid input(){\n\tstring a[H];\n\n\trep(i,H)cin>>a[i];\n\tint cnt = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tboard[i][j] = -1;\n\t\t\tif(a[i][j] == 'X'){\n\t\t\t\tboard[i][j] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(a[i][j] == 'O'){\n\t\t\t\tstx = j; sty = i;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint zahyo(int x,int y){\n\treturn x + y * W;\n}\n\nbool hasmemo(Q u){\n\treturn memo[u.state].find(zahyo(u.x,u.y)) != memo[u.state].end();\n}\n\nvoid setmemo(Q u){\n\tmemo[u.state].insert(zahyo(u.x,u.y));\n}\n\nbool hasbit(int state, int i){\n\treturn (state&(1<<i))>0;\n}\n\nbool isblack(int x,int y,int state){\n\tint n = board[y][x];\n\tif(n<0)return false;\n\treturn !hasbit(state,n);\n}\n\nbool isout(int x,int y){\n\tif(y<0)return true;\n\tif(y<H){\n\t\tif(x<0 || x>=W)return true;\n\t}\n\treturn false;\n}\n\nbool isgoal(int x,int y){\n\tif(y>=H) return true;\n\treturn false;\n}\n\n\nint minblack(int x,int y,int state){\n\tint n = board[y][x];\n\tif(n<0)assert(0);\n\tif(hasbit(state,n))assert(0);\n\n\treturn state + (1<<n);\n}\n\nint solve(){\n\t\n\tqueue<Q> que;\n\tque.push(Q(stx,sty,0,0));\n\n\twhile(!que.empty()){\n\t\tQ u = que.front(); que.pop();\n\t\tif(hasmemo(u))continue;\n\t\tsetmemo(u);\n\n\t\t//printf(\"%d %d\\n\",u.x,u.y);\n\n\t\tint dx[] = {-1,0,1,-1,1,-1,0,1};\n\t\tint dy[] = {-1,-1,-1,0,0,1,1,1};\n\n\t\trep(p,8){\n\t\t\tint st = u.state;\n\t\t\treps(i,1,100){\n\t\t\t\tint nx = u.x + dx[p]*i;\n\t\t\t\tint ny = u.y + dy[p]*i;\n\n\n\t\t\t\tif(i==1){\n\t\t\t\t\tif(isout(nx,ny) || isgoal(nx,ny))break;\n\t\t\t\t\tif(!isblack(nx,ny,st))break;\n\t\t\t\t}\n\t\t\t\tif(i!=1){\n\t\t\t\t\tif(isout(nx,ny))break;\n\t\t\t\t\tif(isgoal(nx,ny))return u.cnt+1;\n\t\t\t\t\tif(!isblack(nx,ny,st)){\n\t\t\t\t\t\tque.push(Q(nx,ny,u.cnt+1,st));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tst = minblack(nx,ny,st);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tinput();\n\tcout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 19\n#define M 15\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nint sy,sx,cnt;\nmap<P1,int> memo;\nmap<P,int> num;\nstring s[N];\nint dy[8]={-1,-1,-1,0,0,1,1,1};\nint dx[8]={-1,0,1,-1,1,-1,0,1};\n\nint dfs(int A,int y,int x){\n  if(memo.count(P1(A,P(y,x))))return memo[P1(A,P(y,x))];\n  if(N-1<=y)return 1;\n  if(y<0||x<0||N<=y||M<=x)return INF;\n  int res=INF;\n  for(int i=0;i<8;i++){\n    int ny=y+dy[i],nx=x+dx[i],nA=A;\n    if(ny<0||nx<0||N<=ny||M<=nx||s[ny][nx]!='X')continue;\n    while(0<=ny&&ny<N&&0<=nx&&nx<M&&s[ny][nx]=='X'){\n      nA|=(1<<num[P(ny,nx)]);\n      s[ny][nx]='.';\n      ny+=dy[i]; nx+=dx[i];\n    }\n    res=min(res,dfs(nA,ny,nx));\n    while(ny!=y||nx!=x){\n      ny-=dy[i]; nx-=dx[i];\n      s[ny][nx]='X';\n    }\n    s[y][x]='.';\n  }\n  return memo[P1(A,P(y,x))]=res+1;\n}\n\nint main(){\n  for(int i=0;i<N;i++){\n    cin>>s[i];\n    for(int j=0;j<M;j++){\n      if(s[i][j]=='O'){\n\tsy=i,sx=j;\n\ts[i][j]='.';\n      }\n      if(s[i][j]=='X')\n\tnum[P(i,j)]=cnt++;\n    }\n  }\n  int ans=dfs(0,sy,sx);\n  cout<<(ans==INF+1?-1:ans-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nstring s[19];\nint sx = -1, sy = -1, ans,\n\tvx[8] = {-1, -1, 0, 1, 1, 1, 0, -1},\n\tvy[8] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ninline bool check(int x, int y) {\n\treturn (0 <= x && x < 19 && 0 <= y && y < 15);\n}\n\nint search(int x, int y, int cnt) {\n\tint ret = (int)1e9;\n\n\t//cout << \"now is\" << x << \" \" << y << endl;\n\n\tfor (int i = 0; i < 8; ++i) {\n\t\tint nx = x + vx[i], ny = y + vy[i], nnx, nny;\n\t\t//cout << \"nx, ny \" << nx << \" \" << ny << endl;\n\n\t\tif (check(nx, ny)) {\n\t\t\tif (s[nx][ny] == 'X') {\n\t\t\t\tnnx = nx + vx[i], nny = ny + vy[i];\n\n\t\t\t\tfor (int j = 1; ; ++j) {\n\t\t\t\t\t//cout << \"nnx, nny \" << nnx << \" \" << nny << endl;\n\t\t\t\t\tif (nnx > 18) {\n\t\t\t\t\t\t//cout << \"now : \" << x << \" \" << y << endl;\n\t\t\t\t\t\t//cout << \"goal: \" << ret << \" \" << j << endl;\n\t\t\t\t\t\tret = min(ret, cnt);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!check(nnx, nny)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (check(nnx, nny) && s[nnx][nny] == '.') {\n\t\t\t\t\t\tstring tmp[19];\n\t\t\t\t\t\tint xx = nx, yy = ny;\n\t\t\t\t\t\tfor (int k = 0; k < 19; ++k) tmp[k] = s[k];\n\n\t\t\t\t\t\t//for (int z = 0; z < 19; ++z) cout << s[z] << endl;\n\t\t\t\t\t\twhile ((xx != nnx || yy != nny)) {\n\t\t\t\t\t\t\ts[xx][yy] = '.';\n\t\t\t\t\t\t\txx += vx[i], yy += vy[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//cout << \"nnx,nny\" << nnx << ' ' << nny << endl;\n\t\t\t\t\t\t//for (int z = 0; z < 19; ++z) cout << s[z] << endl;\n\n\t\t\t\t\t\tint ret_s = search(nnx, nny, cnt + 1);\n\t\t\t\t\t\tif (ret_s != -1) {\n\t\t\t\t\t\t\t//cout << \"ret, j + ret_s \"<< ret << \" \" << j + ret_s << endl;\n\t\t\t\t\t\t\t//cout << \"ret_s : \" << ret_s << endl;\n\t\t\t\t\t\t\tret = min(ret, ret_s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (int k = 0; k < 19; ++k) {\n\t\t\t\t\t\t\ts[k] = tmp[k];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tnnx += vx[i], nny += vy[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (nnx == 19) {\n\t\t\tret = min(ret, cnt);\n\t\t}\n\t}\n\n\tif (ret == (int)1e9) return -1;\n\n\t//cout << \"return \" << x << \", \" << y << \" = \" << ret << endl;\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor (int i = 0; i < 19; ++i) {\n\t\tcin >> s[i];\n\n\t\tif (sx == -1) {\n\t\t\tfor (int j = 0; j < 15; ++j) {\n\t\t\t\tif (s[i][j] == 'O') {\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tans = search(sx, sy, 1);\n\n\tif (ans == -1) cout << -1 << endl;\n\telse cout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>P2;\n\nstring s[21];\nint h=21,w=17,sx,sy;\nint dx[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={-1,-1,0,1,1,1,0,-1};\nbool d[21][19][1<<20];\n\nmap<pair<int,int>,int>M1;\nmap<int,pair<int,int> >M2;\nint cnt;\n\nint main(){\n  s[0]=s[20]=\".................\";\n  r(i,h-2){\n    cin>>s[i+1];\n    s[i+1]=\".\"+s[i+1]+\".\";\n  }\n  r(i,h)r(j,w)if(s[i][j]=='O'){\n    sx=j;\n    sy=i;\n    s[i][j]='.';\n  }else if(s[i][j]=='X'){\n    M2[cnt]=P(i,j);\n    M1[P(i,j)]=cnt++;\n  }\n  queue<P2>q;\n  d[sy][sx][0]=1;\n  q.push(P2(P(sy*1000+sx,0),0));\n  while(!q.empty()){\n    P2 p=q.front();q.pop();\n    int y=p.first.first/1000;\n    int x=p.first.first%1000;\n    int cost=p.first.second;\n    int bit=p.second;\n    r(i,8){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      int b=bit;\n      if(ny<=0||nx<=0||ny>=h||nx>=w-1)continue;\n      if(s[ny][nx]=='.')continue;\n      if((1<<M1[P(ny,nx)])&b)continue;\n      while(s[ny][nx]=='X'){\n\tint c=M1[P(ny,nx)];\n\tif((1<<c)&b)break;\n\tb+=(1<<c);\n\tny+=dy[i];\n\tnx+=dx[i];\n      }\n      if(ny<19&&(nx==0||nx==w-1))continue;\n      if(d[ny][nx][b]==1)continue;\n      d[ny][nx][b]=1;\n      q.push(P2(P(ny*1000+nx,cost+1),b));\n      if(ny>=19){\n\tcout<<cost+1<<endl;\n\treturn 0;\n      }\n    }\n  }\n  cout<<-1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct S {\n\tint x, y, mask;\n\tll hash() {\n\t\treturn (ll)x + 15 * (ll)y + (ll)mask * (20 * 20);\n\t}\n};\n\nint b[19][15];\n\nint dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 };\nint dy[8] = { 0, 1, 0, -1, 1, -1, 1, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < 15 && 0 <= y && y < 19;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint B = 0;\n\tint sx = -1, sy = -1;\n\tmemset(b, -1, sizeof b);\n\tfor(int i = 0; i < 19; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j < 15; j++) {\n\t\t\tif(s[j] == 'O') sx = j, sy = i;\n\t\t\tif(s[j] == 'X') {\n\t\t\t\tb[i][j] = B++;\n\t\t\t}\n\t\t}\n\t}\n\n\tmap<ll, int> dp;\n\tS is = { sx, sy, 0 };\n\tdp[is.hash()] = 0;\n\n\tqueue<S> q;\n\tq.push(is);\n\twhile(q.size()) {\n\t\tint x = q.front().x, y = q.front().y, mask = q.front().mask;\n\t\tint t = dp[q.front().hash()];\n\t\tq.pop();\n\t\tfor(int k = 0; k < 8; k++) {\n\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\tif(!in(nx, ny)) continue;\n\t\t\tint id = b[ny][nx];\n\t\t\tif(id == -1) continue;\n\t\t\tif(mask >> id & 1) continue;\n\t\t\tint nmask = mask;\n\t\t\twhile(1) {\n\t\t\t\tnmask |= 1 << id;\n\t\t\t\tnx += dx[k], ny += dy[k];\n\t\t\t\tif(!in(nx, ny)) break;\n\t\t\t\tid = b[ny][nx];\n\t\t\t\tif(id == -1 || (mask >> id & 1)) break;\n\t\t\t}\n\t\t\tif(ny >= 18) {\n\t\t\t\tcerr << \"nx : \" << nx << \", ny : \" << ny << endl;\n\t\t\t\tcout << t + 1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(in(nx, ny)) {\n\t\t\t\tS ns = { nx, ny, nmask };\n\t\t\t\tif(dp.count(ns.hash()) == 0) {\n\t\t\t\t\tdp[ns.hash()] = t + 1;\n\t\t\t\t\tq.push(ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>P2;\n\nstring s[21];\nint h=21,w=17,sx,sy;\nint dx[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={-1,-1,0,1,1,1,0,-1};\nbool d[21][19][1<<20];\n\nmap<pair<int,int>,int>M1;\nmap<int,pair<int,int> >M2;\nint cnt;\n\nint main(){\n  s[0]=s[20]=\".................\";\n  r(i,h-2){\n    cin>>s[i+1];\n    s[i+1]=\".\"+s[i+1]+\".\";\n  }\n  r(i,h)r(j,w)if(s[i][j]=='O'){\n    sx=j;\n    sy=i;\n    s[i][j]='.';\n  }else if(s[i][j]=='X'){\n    M2[cnt]=P(i,j);\n    M1[P(i,j)]=cnt++;\n  }\n  queue<P2>q;\n  d[sy][sx][0]=1;\n  q.push(P2(P(sy*1000+sx,0),0));\n  while(!q.empty()){\n    P2 p=q.front();q.pop();\n    int y=p.first.first/1000;\n    int x=p.first.first%1000;\n    int cost=p.first.second;\n    int bit=p.second;\n    r(i,8){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      int b=bit;\n      if(ny<0||nx<0||ny>=h||nx>=w)continue;\n      if(s[ny][nx]=='.')continue;\n      if((1<<M1[P(ny,nx)])&b)continue;\n      while(s[ny][nx]=='X'){\n\tint c=M1[P(ny,nx)];\n\tif((1<<c)&b)break;\n\tb|=(1<<c);\n\tny+=dy[i];\n\tnx+=dx[i];\n      }\n      if(d[ny][nx][b]==1)continue;\n      d[ny][nx][b]=1;\n      q.push(P2(P(ny*1000+nx,cost+1),b));\n      if(ny>=19){\n\tcout<<cost+1<<endl;\n\treturn 0;\n      }\n    }\n  }\n  cout<<-1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>P2;\n\nstring s[21];\nint h=21,w=17,sx,sy;\nint dx[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={-1,-1,0,1,1,1,0,-1};\nbool d[21][19][1<<20];\n\nmap<pair<int,int>,int>M1;\nmap<int,pair<int,int> >M2;\nint cnt;\n\nint main(){\n  s[0]=s[20]=\".................\";\n  r(i,h-2){\n    cin>>s[i+1];\n    s[i+1]=\".\"+s[i+1]+\".\";\n  }\n  r(i,h)r(j,w)if(s[i][j]=='O'){\n    sx=j;\n    sy=i;\n    s[i][j]='.';\n  }else if(s[i][j]=='X'){\n    M2[cnt]=P(i,j);\n    M1[P(i,j)]=cnt++;\n  }\n  queue<P2>q;\n  d[sy][sx][0]=1;\n  q.push(P2(P(sy*1000+sx,0),0));\n  while(!q.empty()){\n    P2 p=q.front();q.pop();\n    int y=p.first.first/1000;\n    int x=p.first.first%1000;\n    int cost=p.first.second;\n    int bit=p.second;\n    r(i,8){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      int b=bit;\n      if(ny<=0||nx<=0||ny>=h||nx>=w-1)continue;\n      if(s[ny][nx]=='.')continue;\n      if((1<<M1[P(ny,nx)])&b)continue;\n      while(s[ny][nx]=='X'){\n\tint c=M1[P(ny,nx)];\n\tif((1<<c)&b)break;\n\tb+=(1<<c);\n\tny+=dy[i];\n\tnx+=dx[i];\n      }\n      if(ny<19&&(nx==0||nx==w-1))continue;\n      if(d[ny][nx][b]==1)continue;\n      d[ny][nx][b]=1;\n      q.push(P2(P(ny*1000+nx,cost+1),b));\n      if(ny>=19&&!(ny==19&&nx==14)){\n\tcout<<cost+1<<endl;\n\treturn 0;\n      }\n    }\n  }\n  cout<<-1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst int h = 19;\nconst int w = 15;\n\nstruct Data { \n  int x,y,bitmask,cost;\n  bool operator < ( const Data& data ) const { \n    if( cost != data.cost ) return cost < data.cost; \n    if( x != data.x ) return x < data.x;\n    if( y != data.y ) return y < data.y;\n    if( bitmask != data.bitmask ) return bitmask < data.bitmask;\n  }\n};\n\nchar a[20][20];\n//int mindist[1<<20][9];\nset<Data> mindist;\nint Index[20][20];\n\nbool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nvoid compute(){\n  int black = 0;\n  int sx=-1,sy=-1;\n  rep(i,h) rep(j,w) {\n    if( a[i][j] == 'X' ) Index[i][j] = black++;\n    if( a[i][j] == 'O' ) sx = j, sy = i;\n  }\n  //rep(i,(1<<black)) rep(j,9) mindist[i][j] = IINF;\n  mindist.clear();\n  //mindist[(1<<black)-1][4] = 0;\n  mindist.insert((Data){sx,sy,(1<<black)-1,0});\n  deque<Data> deq;\n  deq.push_back((Data){sx,sy,(1<<black)-1,0});\n  while( !deq.empty() ){\n    Data data = deq.front(); deq.pop_front();\n    REP(dx,-1,2){\n      REP(dy,-1,2){\n        if( dx == 0 && dy == 0 ) continue;\n        int nx = data.x + dx, ny = data.y + dy, nbitmask = data.bitmask;\n        bool valid = false;\n        while( isValid(nx,ny) && ( a[ny][nx] == 'X' && ( data.bitmask & (1<<Index[ny][nx]) ) ) ){\n          nbitmask &= ~(1<<Index[ny][nx]);\n          nx += dx, ny += dy;\n          valid = true;\n        }\n        if( valid && ( ny >= h || ( ny == h-1 && isValid(nx,ny) ) ) ) {\n          //cout << mindist[data.bitmask]+1 << endl;\n          cout << data.cost+1 << endl;\n          return;\n        } else if( !isValid(nx,ny) ) {\n          continue;\n        }\n        if( !valid ) continue;\n        //if( mindist[nbitmask] > mindist[data.bitmask] + 1 ) {\n        if( !mindist.count((Data){nx,ny,nbitmask,data.cost+1}) ) {\n          //mindist[nbitmask] = mindist[data.bitmask] + 1;\n          mindist.insert((Data){nx,ny,nbitmask,data.cost+1});\n          deq.push_back((Data){nx,ny,nbitmask,data.cost+1});\n        }\n      }\n    }\n  }\n  puts(\"-1\");\n}\n\nint main(){\n  rep(i,h) rep(j,w) scanf(\" %c\",&a[i][j]);\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nstruct state{\n  int S;\n  int i,j;\n  int d;\n};\n\nconst int w=15;\nconst int h=19;\nstring s[20];\nint idx[22][22];\nint N=0;\nint si,sj;\nint dist[1<<20];\n\nint di[]={-1,-1,-1,0,0,1,1,1};\nint dj[]={-1,0,1,-1,1,-1,0,1};\n\nint main(){\n  rep(i,h)cin>>s[i];\n  memset(idx,-1,sizeof(idx));\n  rep(i,h)rep(j,w){\n    if(s[i][j]=='X'){\n      idx[i][j]=N++;\n    }\n    if(s[i][j]=='O'){\n      si=i;sj=j;\n    }\n  }\n\n  rep(i,1<<N)dist[i]=INF;\n  queue<state> que;\n  que.push((state){(1<<N)-1,si,sj,0});\n  dist[(1<<N)-1]=0;\n  while(que.size()){\n    state cs=que.front(); que.pop();\n    rep(dir,8){\n      int ni=cs.i+di[dir],nj=cs.j+dj[dir];\n      if(ni<0||ni>=h||nj<0||nj>=w)continue;\n      if(idx[ni][nj]==-1||((cs.S>>idx[ni][nj])&1)==0)continue;\n      vector<int> uidxs;\n      while(idx[ni][nj]!=-1&&((cs.S>>idx[ni][nj])&1)){\n        uidxs.push_back(idx[ni][nj]);\n        ni+=di[dir];\n        nj+=dj[dir];\n      }\n      if(ni==h){\n        cout<<cs.d+1<<endl;\n        return 0;\n      }\n      if(ni<0||nj<0||nj>=w)continue;\n      int nxtS=cs.S;\n      rep(i,uidxs.size())nxtS^=(1<<uidxs[i]);\n      if(dist[nxtS]!=INF)continue;\n      que.push((state){nxtS,ni,nj,cs.d+1});\n      dist[nxtS]=cs.d+1;\n    }\n  }\n  cout<<-1<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> Q;\n\nconst int INF = 100000000;\n\nchar d[19][16];\n\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\n\nbool out(int x, int y) {\n  return x < 0 || y < 0 || x >= 15 || y >= 19;\n}\n\nbool goal(int x, int y) {\n  return y >= 19;\n}\n\nbool black(int x, int y) {\n  return d[y][x] == 'X';\n}\n\nint solve(int X, int Y, int counter) {\n  counter++;\n  int ans = INF;\n  for (int i = 0; i < 8; i++) {\n    int x = X + dx[i], y = Y + dy[i];\n    if (out(x, y)) continue;\n    if (!black(x, y)) continue;\n    while (!out(x, y) && black(x, y)) {\n      d[y][x] = '.';\n      x += dx[i], y += dy[i];\n    }\n    if (goal(x, y)) return counter;\n    if (out(x, y)) continue;\n    ans = min(ans, solve(x, y, counter));\n    int j = (i + 4) % 8;\n    x += dx[j], y += dy[j];\n    while (!(x == X && y == Y)) {\n      d[y][x] = 'X';\n      x += dx[j], y += dy[j];\n    }\n  }\n  return ans;\n}\n\nint main() {\n  for (int i = 0; i < 19; i++) scanf(\"%s\", d[i]);\n  int x, y;\n  for (int i = 0; i < 19; i++) {\n    for (int j = 0; j < 15; j++) {\n      if (d[i][j] == 'O') {\n        d[i][j] = '.';\n        x = j, y = i;\n        i = 19,j = 16;\n      }\n    }\n  }\n  int ans = solve(x, y, 0);\n  if (ans == INF) ans = -1;\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nstruct state{\n  int bi,a,b;\n  bool operator<(const state& s) const {\n    if( bi == s.bi ){\n      if( a == s.a ) return b < s.b;\n      return a < s.a;\n    }\n    return bi < s.bi;\n  }\n};\n \nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};\n \n \nmap<state,int> dp;\nchar cie[55][55];\nint fie[55][55];\nint N,W,H;\nbool check( int bi,int x,int y,int d,int &nst,int &nx,int &ny ){\n  bool f = false;\n  nst = bi;\n  nx = x + dx[d];\n  ny = y + dy[d]; \n  if( nx < 0 || nx >= W || ny < 0 || ny >= H ) return false;\n  if( cie[nx][ny] == 'X' && !(nst & (1<<fie[nx][ny])) ){\n    f = true;     \n    nst |= (1<<fie[nx][ny]);\n  }\n \n  while( f ){\n    nx = nx + dx[d];\n    ny = ny + dy[d]; \n    if( ny > H-1 || ( ny == H-1 && 0 <= nx && nx < W ) ) return true;\n    if( nx < 0 || nx >= W || ny < 0 ) return false;\n    if( cie[nx][ny] == 'X' && !(nst & (1<<fie[nx][ny])) ){\n      nst |= (1<<fie[nx][ny]);\n    } else\n      break;\n  }\n  return f;\n}\n \nint solve(int bi,int x,int y){\n  if( dp.find((state){bi,x,y}) != dp.end() ) return dp[(state){bi,x,y}];\n  // cout << bitset<20>(bi) << \" \"<< x << \" \"<< y << endl;\n  if( y > H-1 || ( y == H-1 && 0 <= x && x < W ) ) return dp[(state){bi,x,y}] = 0;\n  int ret = (1<<29);\n  for(int i=0;i<8;i++){\n    int nx,ny,nst;\n    if( check(bi,x,y,i,nst,nx,ny) ){\n      ret = min( ret, solve(nst,nx,ny)+1);\n    }\n  }\n  return dp[(state){bi,x,y}] = ret;\n}\n \nint main(){\n  N = 0;\n  W=15;H=19;\n  int x,y;\n  for(int i=0;i<19;i++){\n    for(int j=0;j<15;j++){\n      cin >> cie[j][i];\n      if( cie[j][i] == 'X')\n    fie[j][i] = N++;\n      if( cie[j][i] == 'O' ){\n    x = j; y = i;\n      }\n    }\n  }\n  int res = solve(0,x,y);\n  if( res == (1<<29) )\n    cout << -1 << endl;\n  else\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dy[]={-1,-1,0,1,1,1,0,-1};\nint dx[]={0,1,1,1,0,-1,-1,-1};\n\nstring s;\nint t[21][17];\nint py[20],px[20];\nint m=0,sy,sx;\n\nstruct state{\n  int y,x,S,cost;\n};\n\n\nstate calc(int dir,state s){\n  int T=0;\n\n  int ny=s.y+dy[dir],nx=s.x+dx[dir];\n\n  while(1){\n    if(t[ny][nx]==-1)break;\n    T|=(1<<t[ny][nx]);\n    ny+=dy[dir];\n    nx+=dx[dir];\n  }\n\n  if(T==0)s.cost=-2;\n  s.y=ny;\n  s.x=nx;\n  s.cost++;\n  s.S-=T;\n  return s;\n}\n\nint solve(){\n\n  queue< state > Q;\n  Q.push((state){sy,sx,(1<<m)-1,0});\n\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    int S=s.S;\n\n    for(int i=0;i<m;i++)\n      if(S>>i&1)\n\tt[py[i]][px[i]]=i;\n\n    for(int i=0;i<8;i++){\n      state next=calc(i,s);\n      if(next.cost==-1)continue;\n      if(next.y<1)continue;\n      if(next.y>19){\n\treturn s.cost+1;\n      }\n      if(next.y==19){\n\tif(1<=next.x&&next.x<=15)return s.cost+1;\n\telse continue;\n      }\n      if(next.x<1)continue;\n      if(next.x>15)continue;\n      Q.push(next);\n    }\n    for(int i=0;i<m;i++)\n      if(S>>i&1)\n\tt[py[i]][px[i]]=-1;\n  }\n  return -1;\n}\n\nint main(){\n  for(int i=0;i<21;i++)\n    for(int j=0;j<17;j++)\n      t[i][j]=-1;\n\n  for(int i=0;i<19;i++){\n    cin>>s;\n    for(int j=0;j<15;j++){\n      if(s[j]=='O'){\n\tsy=i+1,sx=j+1;\n      }else if(s[j]=='X'){\n\tpy[m]=i+1;\n\tpx[m]=j+1;\n\tm++;\n      }\n    }\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dy[]={-1,-1,0,1,1,1,0,-1};\nint dx[]={0,1,1,1,0,-1,-1,-1};\n\nstring s;\nint t[21][17];\nint py[20],px[20];\nint m=0,sy,sx;\n\nstruct state{\n  int y,x,S,cost;\n};\n\n\nstate calc(int dir,state s){\n  int T=0;\n\n  int ny=s.y+dy[dir],nx=s.x+dx[dir];\n\n  while(1){\n    if(t[ny][nx]==-1)break;\n    T|=(1<<t[ny][nx]);\n    ny+=dy[dir];\n    nx+=dx[dir];\n  }\n\n  if(T==0)s.cost=-2;\n  s.y=ny;\n  s.x=nx;\n  s.cost++;\n  s.S-=T;\n  return s;\n}\n\nint solve(){\n\n  queue< state > Q;\n  Q.push((state){sy,sx,(1<<m)-1,0});\n\n  while(!Q.empty()){\n    state s=Q.front();Q.pop();\n    int S=s.S;\n\n    for(int i=0;i<m;i++)\n      if(S>>i&1)\n\tt[py[i]][px[i]]=i;\n\n    for(int i=0;i<8;i++){\n      state next=calc(i,s);\n      if(next.cost==-1)continue;\n      if(next.y<1)continue;\n      if(next.y>=19)return s.cost+1;\n      if(next.x<1)continue;\n      if(next.x>15)continue;\n      Q.push(next);\n    }\n    for(int i=0;i<m;i++)\n      if(S>>i&1)\n\tt[py[i]][px[i]]=-1;\n  }\n  return -1;\n}\n\nint main(){\n  for(int i=0;i<21;i++)\n    for(int j=0;j<17;j++)\n      t[i][j]=-1;\n\n  for(int i=0;i<19;i++){\n    cin>>s;\n    for(int j=0;j<15;j++){\n      if(s[j]=='O'){\n\tsy=i+1,sx=j+1;\n      }else if(s[j]=='X'){\n\tpy[m]=i+1;\n\tpx[m]=j+1;\n\tm++;\n      }\n    }\n  }\n  cout<<solve()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<queue>\n#include<cassert>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 20, T = (1<<N), H = 19, W = 15;\n\nset<int> memo[T];\nint board[H][W];\nint stx,sty;\n\nclass Q{\npublic:\n\tint x,y,cnt,state;\n\tQ(int x,int y,int cnt, int state):x(x),y(y),cnt(cnt),state(state){}\n};\n\nvoid input(){\n\tstring a[H];\n\n\trep(i,H)cin>>a[i];\n\tint cnt = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tboard[i][j] = -1;\n\t\t\tif(a[i][j] == 'X'){\n\t\t\t\tboard[i][j] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(a[i][j] == 'O'){\n\t\t\t\tstx = j; sty = i;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint zahyo(int x,int y){\n\treturn x + y * W;\n}\n\nbool hasmemo(Q u){\n\treturn memo[u.state].find(zahyo(u.x,u.y)) != memo[u.state].end();\n}\n\nvoid setmemo(Q u){\n\tmemo[u.state].insert(zahyo(u.x,u.y));\n}\n\nbool hasbit(int state, int i){\n\treturn (state&(1<<i))>0;\n}\n\nbool isblack(int x,int y,int state){\n\tint n = board[y][x];\n\tif(n<0)return false;\n\treturn !hasbit(state,n);\n}\n\nbool isout(int x,int y){\n\tif(y<0)return true;\n\tif(y<H){\n\t\tif(x<0 || x>=W)return true;\n\t}\n\treturn false;\n}\n\nbool isgoal(int x,int y){\n\tif(y==H-1 && (x>=0 && x<=W-1))return true;\n\tif(y>=H) return true;\n\treturn false;\n}\n\n\nint minblack(int x,int y,int state){\n\tint n = board[y][x];\n\tif(n<0)assert(0);\n\tif(hasbit(state,n))assert(0);\n\n\treturn state + (1<<n);\n}\n\nint solve(){\n\t\n\tqueue<Q> que;\n\tque.push(Q(stx,sty,0,0));\n\n\twhile(!que.empty()){\n\t\tQ u = que.front(); que.pop();\n\t\tif(hasmemo(u))continue;\n\t\tsetmemo(u);\n\n\t\t//printf(\"%d %d\\n\",u.x,u.y);\n\n\t\tint dx[] = {-1,0,1,-1,1,-1,0,1};\n\t\tint dy[] = {-1,-1,-1,0,0,1,1,1};\n\n\t\trep(p,8){\n\t\t\tint st = u.state;\n\t\t\treps(i,1,100){\n\t\t\t\tint nx = u.x + dx[p]*i;\n\t\t\t\tint ny = u.y + dy[p]*i;\n\n\n\t\t\t\tif(i==1){\n\t\t\t\t\tif(isout(nx,ny) || isgoal(nx,ny))break;\n\t\t\t\t\tif(!isblack(nx,ny,st))break;\n\t\t\t\t}\n\t\t\t\tif(i!=1){\n\t\t\t\t\tif(isout(nx,ny))break;\n\t\t\t\t\tif(isgoal(nx,ny))return u.cnt+1;\n\t\t\t\t\tif(!isblack(nx,ny,st)){\n\t\t\t\t\t\tque.push(Q(nx,ny,u.cnt+1,st));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tst = minblack(nx,ny,st);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tinput();\n\tcout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int vx[] = {-1, 0, 1, 1, 1, 0, -1, -1};\n\nstring S[19];\nint sx, sy;\n\nbool isgoal(int y, int x)\n{\n  return ((y == 18 && 0 <= x && x <= 14) || y == 19);\n}\n\nint bfs()\n{\n  map< tuple< int, int, int >, int > v;\n  queue< tuple< int, int, int > > que;\n  que.emplace(0, sy, sx);\n  v[que.front()] = 0;\n  while(!que.empty()) {\n    auto p = que.front();\n    int bit, y, x;\n    tie(bit, y, x) = p;\n    que.pop();\n    for(int i = 0; i < 8; i++) {\n      int ny = vy[i] + y, nx = vx[i] + x, bb = bit;\n      while(nx >= 0 && nx < 15 && ny >= 0 && ny < 19 && S[ny][nx] < 20) {\n        if((bit >> S[ny][nx]) & 1) break;\n        bb |= 1 << S[ny][nx];\n        ny += vy[i], nx += vx[i];\n      }\n      if(ny == vy[i] + y && nx == vx[i] + x) continue;\n      if(isgoal(ny, nx)) return (v[p] + 1);\n      if(ny >= 0 && nx < 15 && ny >= 0 && ny < 19) {\n        auto nxt = make_tuple(bb, ny, nx);\n        if(v.count(nxt) && v[nxt] <= v[p] + 1)continue;\n        v[nxt] = v[p] + 1;\n        que.emplace(nxt);\n      }\n    }\n  }\n  return (-1);\n}\n\nint main()\n{\n  int pad = 0;\n  for(int i = 0; i < 19; i++) {\n    cin >> S[i];\n    for(int j = 0; j < 15; j++) {\n      if(S[i][j] == 'X') S[i][j] = pad++;\n      else if(S[i][j] == 'O') sy = i, sx = j;\n    }\n  }\n  cout << bfs() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 19\n#define M 15\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nint sy,sx,cnt;\nmap<P1,int> memo;\nmap<P,int> num;\nstring s[N];\nint dy[8]={-1,-1,-1,0,0,1,1,1};\nint dx[8]={-1,0,1,-1,1,-1,0,1};\n\nint dfs(int A,int y,int x){\n  if(memo.count(P1(A,P(y,x))))return memo[P1(A,P(y,x))];\n  if(N-1<=y)return 1;\n  if(y<0||x<0||N<=y||M<=x)return INF;\n  cout<<endl;\n  for(int i=0;i<N;i++){\n    for(int j=0;j<M;j++){\n      if(y==i&&x==j)cout<<'O';\n      else cout<<s[y][x];\n    }\n    cout<<endl;\n  }\n  cout<<endl;\n  int res=INF;\n  for(int i=0;i<8;i++){\n    int ny=y+dy[i],nx=x+dx[i],nA=A;\n    if(ny<0||nx<0||N<=ny||M<=nx||s[ny][nx]!='X')continue;\n    while(0<=ny&&ny<N&&0<=nx&&nx<M&&s[ny][nx]=='X'){\n      nA|=(1<<num[P(ny,nx)]);\n      s[ny][nx]='.';\n      ny+=dy[i]; nx+=dx[i];\n    }\n    res=min(res,dfs(nA,ny,nx));\n    while(ny!=y||nx!=x){\n      ny-=dy[i]; nx-=dx[i];\n      s[ny][nx]='X';\n    }\n    s[y][x]='.';\n  }\n  return memo[P1(A,P(y,x))]=res+1;\n}\n\nint main(){\n  for(int i=0;i<N;i++){\n    cin>>s[i];\n    for(int j=0;j<M;j++){\n      if(s[i][j]=='O'){\n\tsy=i,sx=j;\n\ts[i][j]='.';\n      }\n      if(s[i][j]=='X')\n\tnum[P(i,j)]=cnt++;\n    }\n  }\n  int ans=dfs(0,sy,sx);\n  cout<<(ans>=INF?-1:ans-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\nstruct State { int x[19][15]; };\nState S;\nint dx[8] = { 1,1,1,0,-1,-1,-1,0 }, dy[8] = { -1,0,1,1,1,0,-1,-1 };\nint solve(State p) {\n\tint cx = 0, cy = 0;\n\tfor (int i = 0; i < 285; i++) {\n\t\tif (p.x[i / 15][i % 15] == 2) { cx = i / 15; cy = i % 15; }\n\t}\n\tvector<int>vec;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\tif (ex < 0 || ey < 0 || ex >= 19 || ey >= 15)continue;\n\t\tif (p.x[ex][ey] == 0)continue;\n\t\tvec.push_back(i);\n\t}\n\tif (vec.size() == 0)return 999999;\n\tint minx = 999999;\n\tfor (int i = 0; i < 8; i++) {\n\t\tbool OK2 = false; for (int j = 0; j < vec.size(); j++) { if (vec[j] == i)OK2 = true; }\n\t\tif (OK2 == false)continue;\n\t\tState T = p;\n\t\tint ex = cx, ey = cy;\n\t\tbool flag = true;\n\t\twhile (true) {\n\t\t\tex += dx[i]; ey += dy[i];\n\t\t\tif (ex >= 19)break;\n\t\t\tif (ex < 0 || ey < 0 || ey >= 15) { flag = false; break; }\n\t\t\tif (T.x[ex][ey] == 0)break;\n\t\t\tT.x[ex][ey] = 0;\n\t\t}\n\t\tif (flag == false)continue;\n\n\t\tif (abs(ex - cx) <= 1 && abs(ey - cy) <= 1)continue;\n\t\tif (ex == 18 || ex == 19)minx = min(minx, 1);\n\t\telse {\n\t\t\tT.x[cx][cy] = 0; T.x[ex][ey] = 2;\n\t\t\tminx = min(minx, solve(T) + 1);\n\t\t}\n\t}\n\treturn minx;\n}\nint main() {\n\tfor (int i = 0; i < 19; i++) {\n\t\tfor (int j = 0; j < 15; j++) {\n\t\t\tchar p; cin >> p;\n\t\t\tif (p == 'O')S.x[i][j] = 2;\n\t\t\tif (p == 'X')S.x[i][j] = 1;\n\t\t\tif (p == '.')S.x[i][j] = 0;\n\t\t}\n\t}\n\tint R = solve(S); if (R >= 100000)R = -1;\n\tcout << R << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nconst int H = 19;\nconst int W = 15;\nstring bd[H];\nint id[H][W];\nint dx[] = {1,1,0,-1,-1,-1,0,1};\nint dy[] = {0,1,1,1,0,-1,-1,-1};\n\nstruct PH{\n  template<class T, class U>\n  size_t operator()(const pair<T,U>& x) const{\n\tsize_t seed = 0;\n\tseed ^= hash<T>{}(x.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\tseed ^= hash<U>{}(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\treturn seed;\n  }\n};\n\nusing D = pair<PII,int>;\nnamespace std{\ntemplate<> struct hash<D>{\n  size_t operator()(const D& d) const{\n\treturn PH{}(MP(PH{}(d.FF), d.SS));\n  }\n};\n}\n\nbool isin(const PII& p){\n  return (0 <= p.FF && p.FF < H && 0 <= p.SS && p.SS < W);\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  REP(i,19) cin >> bd[i];\n  PII w;\n  int gid = 0;\n  REP(y,H) REP(x,W){\n\tif(bd[y][x] == 'O')\n\t  w = MP(y,x);\n\telse if(bd[y][x] == 'X')\n\t  id[y][x] = gid++;\n  }\n\n  int ans = -1;\n  unordered_map<D,int> memo;\n  queue<D> q;\n  q.push(D(w,(1<<21)-1));\n  memo[D(w,(1<<21)-1)] = 0;\n  while(!q.empty()){\n\tD d = q.front();\n\tq.pop();\n\tPII p = d.FF;\n\tif(p.FF >= H-1){\n\t  ans = memo[d];\n\t  break;\n\t}\n\tif(p.FF < 0 || p.SS < 0 || p.SS >= W)\n\t  continue;\n\tREP(dir,8){\n\t  int nb = d.SS;\n\t  PII np(p.FF+dy[dir], p.SS+dx[dir]);\n\t  while(isin(np) && bd[np.FF][np.SS] == 'X' && (nb>>id[np.FF][np.SS]&1)){\n\t\tnb ^= 1 << id[np.FF][np.SS];\n\t\tnp.FF += dy[dir];\n\t\tnp.SS += dx[dir];\n\t  }\n\t  if(nb == d.SS) continue;\n\t  if(!memo.count(D(np,nb))){\n\t\t memo[D(np,nb)] = memo[d] + 1;\n\t\t q.push(D(np,nb));\n\t  }\n\t}\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct state{\n  int bi,a,b;\n  bool operator<(const state& s) const {\n    if( bi == s.bi ){\n      if( a == s.a ) return b < s.b;\n      return a < s.a;\n    }\n    return bi < s.bi;\n  }\n};\n\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};\n\nmap<state,int> dp;\nchar cie[55][55];\nint fie[55][55];\nint N,W,H;\nbool check( int bi,int x,int y,int d,int &nst,int &nx,int &ny ){\n  bool f = false;\n  nst = bi;\n  nx = x + dx[d];\n  ny = y + dy[d];  \n  if( nx < 0 || nx >= W || ny < 0 || ny >= H ) return false;\n  if( cie[nx][ny] == 'X' && !(nst & (1<<fie[nx][ny])) ){\n    f = true;      \n    nst |= (1<<fie[nx][ny]);\n  }\n\n  while( f ){\n    nx = nx + dx[d];\n    ny = ny + dy[d];  \n    if( ny > H-1 || ( ny == H-1 && 0 < nx && nx < W ) ) return true;\n    if( nx < 0 || nx >= W || ny < 0 ) return false;\n    if( cie[nx][ny] == 'X' && !(nst & (1<<fie[nx][ny])) ){\n      nst |= (1<<fie[nx][ny]);\n    } else\n      break;\n  }\n  return f;\n}\n\nint solve(int bi,int x,int y){\n  if( dp.count((state){bi,x,y}) != 0 ) return dp[(state){bi,x,y}];\n  // cout << bitset<20>(bi) << \" \"<< x << \" \"<< y << endl;\n  if( y > H-1 || ( y == H-1 && 0 < x && x < W ) ) return dp[(state){bi,x,y}] = 0;\n  int ret = (1<<29);\n  for(int i=0;i<8;i++){\n    int nx,ny,nst;\n    if( check(bi,x,y,i,nst,nx,ny) ){\n      ret = min( ret, solve(nst,nx,ny)+1);\n    }\n  }\n  return dp[(state){bi,x,y}] = ret;\n}\n\nint main(){\n  N = 0;\n  W=15;H=19;\n  int x,y;\n  for(int i=0;i<19;i++){\n    for(int j=0;j<15;j++){\n      cin >> cie[j][i];\n      if( cie[j][i] == 'X')\n\tfie[j][i] = N++;\n      if( cie[j][i] == 'O' ){\n\tx = j; y = i;\n      }\t\n    }\n  }\n  int res = solve(0,x,y);\n  if( res == (1<<29) )\n    cout << -1 << endl;\n  else \n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nint Search(vector<string>&s, int y, int x) {\n\tint ret = MOD;\n\tfor (int i = -1; i <= 1; i++) {\n\t\tfor (int j = -1; j <= 1; j++) {\n\t\t\tif (i == 0 && j == 0)continue;\n\t\t\tbool flag = false;\n\t\t\tint ny = y + i, nx = x + j;\n\t\t\twhile (ny >= 0 && ny < H&&nx >= 0 && nx < W&&s[ny][nx] == 'X') {\n\t\t\t\tflag = true;\n\t\t\t\ts[ny][nx] = '.';\n\t\t\t\tny += i, nx += j;\n\t\t\t}\n\t\t\tif (flag&&ny >= 0 && ny < H&& nx >= 0 && nx < W) {\n\t\t\t\tret = min(ret, Search(s, ny, nx));\n\t\t\t}\n\t\t\tif (flag&&(ny + 1 > H||(ny+1==H&&nx>=0&&nx<W))) {\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t\tny -= i, nx -= j;\n\t\t\twhile (ny != y || nx != x) {\n\t\t\t\ts[ny][nx] = 'X';\n\t\t\t\tny -= i, nx -= j;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret + 1;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tH = 19, W = 15;\n\tvector<string>s(H);\n\tfor (auto &i : s)cin >> i;\n\tint sy, sx;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (s[i][j] == 'O') {\n\t\t\t\tsy = i,sx = j, s[i][j] = '.';\n\t\t\t}\n\t\t}\n\t}\n\tint ans = Search(s, sy, sx);\n\tif (ans >= MOD)ans = -1;\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nconst int H = 19;\nconst int W = 15;\nstring bd[H];\nint id[H][W];\nint dx[] = {1,1,0,-1,-1,-1,0,1};\nint dy[] = {0,1,1,1,0,-1,-1,-1};\n\nstruct PH{\n  template<class T, class U>\n  size_t operator()(const pair<T,U>& x) const{\n\tsize_t seed = 0;\n\tseed ^= hash<T>{}(x.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\tseed ^= hash<U>{}(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\treturn seed;\n  }\n};\n\nusing D = pair<PII,int>;\nnamespace std{\ntemplate<> struct hash<D>{\n  size_t operator()(const D& d) const{\n\treturn PH{}(MP(PH{}(d.FF), d.SS));\n  }\n};\n}\n\nbool isin(const PII& p){\n  return (0 <= p.FF && p.FF < H && 0 <= p.SS && p.SS < W);\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  REP(i,19) cin >> bd[i];\n  PII w;\n  int gid = 0;\n  REP(y,H) REP(x,W){\n\tif(bd[y][x] == 'O')\n\t  w = MP(y,x);\n\telse if(bd[y][x] == 'X')\n\t  id[y][x] = gid++;\n  }\n\n  int ans = -1;\n  unordered_map<D,int> memo;\n  queue<D> q;\n  q.push(D(w,(1<<21)-1));\n  memo[D(w,(1<<21)-1)] = 0;\n  while(!q.empty()){\n\tD d = q.front();\n\tq.pop();\n\tPII p = d.FF;\n\tif(p.FF >= H-1){\n\t  ans = memo[d];\n\t  break;\n\t}\n\tif(p.FF < 0 || p.SS < 0 || p.SS >= W)\n\t  continue;\n\tREP(dir,8){\n\t  int nb = d.SS;\n\t  PII np(p.FF+dy[dir], p.SS+dx[dir]);\n\t  while(isin(np) && bd[np.FF][np.SS] == 'X' && (nb>>id[np.FF][np.SS]&1)){\n\t\tnb ^= 1 << id[np.FF][np.SS];\n\t\tnp.FF += dy[dir];\n\t\tnp.SS += dx[dir];\n\t  }\n\t  if(nb == d.SS) continue;\n\t  if(!memo.count(D(np,nb))){\n\t\t memo[D(np,nb)] = memo[d] + 1;\n\t\t q.push(D(np,nb));\n\t  }\n\t}\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = i64(1e18) + 7;\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\n\nbool solve(){\n\n    const int h = 19, w = 15;\n    vector<string> s(h);\n    for(int i = 0; i < h; ++i)\n        cin >> s[i];\n    vector<vector<char>> v(h, vector<char>(w, -1));\n    int st = 0, en = 0;\n    int cnt = 0;\n    for(int i = 0; i < h; ++i)\n        for(int j = 0; j < w; ++j){\n            if(s[i][j] == 'O')\n                st = i, en = j;\n            if(s[i][j] == 'X'){\n                v[i][j] = cnt++;\n            }\n        }\n\n    vector<int> dx{-1, 0, 1, 1, 1, 0, -1, -1};\n    vector<int> dy{1, 1, 1, 0, -1, -1, -1, 0};\n\n    vector<map<pair<int,int>, int>> dp(1 << cnt);\n    char ans = 100;\n    dp[0][make_pair(st, en)] = 0;\n    for(int mask = 0; mask < (1 << cnt); ++mask){\n        for(auto& p : dp[mask]){\n            int i, j;\n            tie(i, j) = p.first;\n            int val = p.second;\n            for(int d = 0; d < 8; ++d){\n                int ma = 0;\n                bool fl = true;\n                int dist = 1;\n                int nx, ny;\n                for(;; ++dist){\n                    nx = i + dist * dx[d];\n                    ny = j + dist * dy[d];\n                    if(nx >= h)\n                        break;\n                    if(nx < 0 || ny < 0 || ny >= w){\n                        fl = false;\n                        break;\n                    }\n                    if(v[nx][ny] == -1 || mask & (1 << v[nx][ny]))\n                        break;\n                    ma |= (1 << v[nx][ny]);\n                }\n                if(!fl || dist == 1)\n                    continue;\n                if(nx >= h - 1){\n                    chmin(ans, char(val + 1));\n                    continue;\n                }\n                if(dp[mask | ma].find(make_pair(nx, ny)) == dp[mask | ma].end() || dp[mask | ma][make_pair(nx, ny)] > char(val + 1)){\n                    dp[mask | ma][make_pair(nx, ny)] = char(val + 1);\n                }\n            }\n        }\n    }\n    cout << (ans == 100 ? -1 : ans) << endl;\n\n    return false;\n}\n\nsigned main(){\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int w = 15;\nconst int h = 19;\nvector<string> mp(h);\n\nbool inmp(int x,int y){return 0<=x&&0<=y&&x<w&&y<h;}\n\n\nint ans=1e9;\nvoid dfs(int x,int y,int cost){\n  if((y==h-1||y==h)&&0<=x&&x<w)ans=min(ans,cost);\n  if(!inmp(x,y)||ans<=cost) return;\n\n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      int nx = x+i;\n      int ny = y+j;\n      if(!inmp(nx,ny)||mp[ny][nx] != 'X') continue;\n      vector<string>tmp = mp;\n      while(inmp(nx,ny)&&mp[ny][nx]=='X')mp[ny][nx] = '.', nx+=i,ny+=j;\n      dfs(nx,ny,cost+1);\n      mp = tmp;\n    }\n}\n\nint main(){\n\n  for(int i=0;i<h;i++)cin>>mp[i];\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j] =='O') dfs(j,i,0);\n\n  if(ans==1e9) ans=-1;\n  cout<<ans<<endl;\n  \n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\n#define H 19\n#define W 15\nbool banmen[H+1][W];\nint dirs[8][2];\n\nint solve(int x, int y, int te) {\n  //printf(\"%d,%d,%d\\n\",x,y,te);\n  if(y>=H-1) return te;\n  int ans = 9999;\n  for(int dir_index = 0; dir_index < 8; dir_index++) {\n    int dx = dirs[dir_index][0];\n    int dy = dirs[dir_index][1];\n    int count = 0;\n    int ax = x+dx;\n    int ay = y+dy;\n    //printf(\"(%d,%d,%d,%d,%d)\\n\",ax>0,ax+dx<W,ay>0,ay+dy<=H,banmen[ax][ay]);\n    while(((ay+dy==H&&ax>=0&&ax<W&&ax+dx>=-1&&ax+dx<=W)||(ax>=0&&ax<W&&ax+dx>=0&&ax+dx<W))&&ay>0&&ay<H&&ay+dy>=0&&ay+dy<=H && banmen[ay][ax]) {\n      banmen[ay][ax] = false;\n      ax+=dx;\n      ay+=dy;\n      count++;\n    }\n    //printf(\"(x,y,c)=(%d,%d,%d)\\n\",dx,dy,count);\n    if(count>0) {\n      int ret = solve(ax,ay,te+1);\n      if(ret!=-1) {\n        ans = min(ans,ret);\n      }\n    }\n    for(int i = 1; i <= count; i++) {\n      banmen[y+dy*i][x+dx*i] = true;\n    }\n  }\n  return (ans==9999)?-1:ans;\n}\n\nint main() {\n  int x,y;\n  for(int i = 0; i < H; i++) {\n    char row[W+1];\n    scanf(\"%s\",row);\n    for(int j = 0; j < W; j++) {\n      banmen[i][j] = (row[j]=='X');\n      if(row[j]=='O') {\n        y = i;\n        x = j;\n      }\n    }\n  }\n  /*\n  for(int i = 0; i < H+1; i++) {\n    for(int j = 0; j < W; j++) {\n      printf(\"%d \",banmen[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  */\n  for(int j = 0; j < W; j++) {\n    banmen[H][j] = false;\n  }\n\n  dirs[0][0] = 1;\n  dirs[0][1] = 1;\n  dirs[1][0] = 1;\n  dirs[1][1] = 0;\n  dirs[2][0] = 1;\n  dirs[2][1] = -1;\n  dirs[3][0] = 0;\n  dirs[3][1] = -1;\n  dirs[4][0] = -1;\n  dirs[4][1] = -1;\n  dirs[5][0] = -1;\n  dirs[5][1] = 0;\n  dirs[6][0] = -1;\n  dirs[6][1] = 1;\n  dirs[7][0] = 0;\n  dirs[7][1] = 1;\n\n  printf(\"%d\\n\",solve(x,y,0));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H=19,W=15;\n\nenum DIR{\n    Left_Up,\n    Up,\n    Right_Up,\n    Left,\n    Right,\n    Left_Down,\n    Down,\n    Right_Down,\n};\n\nDIR dir[8] = {Left_Up,Up,Right_Up,Left,Right,Left_Down,Down,Right_Down};\n\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\n\nstruct BlackStone{\n    short row,col;\n    bool erased;\n};\n\nstruct Info{\n    BlackStone black_stone[20];\n    short row,col,black_num,count;\n};\n\nbool rangeCheck(int row,int col){\n    if(row <= 17){\n        if(col < 0 || col > 14){\n            return false;\n        }else{\n            return true;\n        }\n    }else{ //row >= 18\n        if(row == 18 && (col < 0 || col > 14)){\n            return false;\n        }else{\n            return true;\n        }\n    }\n}\n\nInfo move(Info info,DIR dir){\n    Info ret;\n\n    char map[19][15];\n    for(int i = 0; i < H; i++){\n        for(int k = 0; k < W; k++)map[i][k] = '.';\n    }\n\n    for(int i = 0; i < info.black_num; i++){\n        if(info.black_stone[i].erased == false){\n            map[info.black_stone[i].row][info.black_stone[i].col] = 'X';\n        }\n        ret.black_stone[i].row = info.black_stone[i].row;\n        ret.black_stone[i].col = info.black_stone[i].col;\n        ret.black_stone[i].erased = info.black_stone[i].erased;\n    }\n    ret.black_num = info.black_num;\n    ret.count = info.count+1;\n\n    int next_row,next_col,index;\n\n    switch(dir){\n    case Left_Up:\n        index = 0;\n        break;\n    case Up:\n        index = 1;\n        break;\n    case Right_Up:\n        index = 2;\n        break;\n    case Left:\n        index = 3;\n        break;\n    case Right:\n        index = 4;\n        break;\n    case Left_Down:\n        index = 5;\n        break;\n    case Down:\n        index = 6;\n        break;\n    case Right_Down:\n        index = 7;\n        break;\n    }\n\n    next_row = info.row+diff_row[index];\n    next_col = info.col+diff_col[index];\n\n    while(rangeCheck(next_row,next_col) == true && map[next_row][next_col] == 'X'){\n        next_row += diff_row[index];\n        next_col += diff_col[index];\n    }\n\n\n    if(next_row == info.row+diff_row[index] && next_col == info.col+diff_col[index]){\n        ret.row = 1;\n        ret.col = -1;\n    }else{\n        int tmp_row,tmp_col;\n\n        tmp_row = info.row+diff_row[index];\n        tmp_col = info.col+diff_col[index];\n\n        while(tmp_row != next_row || tmp_col != next_col){\n            for(int i = 0; i < ret.black_num;i++){\n                if(ret.black_stone[i].erased == false && ret.black_stone[i].row == tmp_row && ret.black_stone[i].col == tmp_col){\n                    ret.black_stone[i].erased = true;\n                    break;\n                }\n            }\n            tmp_row += diff_row[index];\n            tmp_col += diff_col[index];\n        }\n\n        ret.row = next_row;\n        ret.col = next_col;\n    }\n\n    return ret;\n}\n\nint main(){\n\n    Info first;\n\n    for(int i = 0; i < 20; i++)first.black_stone[i].erased = true;\n    first.black_num = 0;\n    char buf[15];\n    int minimum = BIG_NUM,start_row,start_col;\n\n    for(int i = 0; i < H; i++){\n        scanf(\"%s\",buf);\n        for(int k = 0; k < W; k++){\n            if(buf[k] == 'O'){\n                start_row = i;\n                start_col = k;\n            }else if(buf[k] == 'X'){\n                first.black_stone[first.black_num].erased = false;\n                first.black_stone[first.black_num++].row = i;\n                first.black_stone[first.black_num++].col = k;\n            }\n        }\n    }\n\n    first.row = start_row;\n    first.col = start_col;\n    first.count = 0;\n\n    queue<Info> Q;\n    Q.push(first);\n\n    while(!Q.empty()){\n\n        if(Q.front().row >= 18){\n            minimum = Q.front().count;\n            break;\n        }else{\n\n            for(int i = 0; i < 8; i++){\n                Info next = move(Q.front(),dir[i]);\n\n                if(rangeCheck(next.row,next.col)){\n                    Q.push(next);\n                }\n            }\n\n            Q.pop();\n        }\n    }\n\n    if(minimum == BIG_NUM){\n        printf(\"-1\\n\");\n    }else{\n        printf(\"%d\\n\",minimum);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef queue<P> Q;\n\n#define _CRT_SECURE_NO_WARNINGS\nconst int INF = 10000;\nint N = 0;\nchar c[20][20];\nint dp[20][20];\nbool checked[20][20];\nstruct Node {\n\tint h, w;\n\tint cost;\n\tbool operator < (const Node & _n)const {\n\t\treturn cost < _n.cost;\n\t}\n};\npriority_queue<Node> PQ;\nvoid Calc(int h,int w,int temp) {\n\tint nowH, nowW;\n\tint dh[8] = { -1,-1,-1, 0, 1, 1, 1, 0 };\n\tint dw[8] = { -1, 0, 1, 1, 1, 0,-1,-1 };\n\tbool flag = false;\n\tfor (int i = 0; i < 8;i++) {\n\t\tnowH = h+dh[i]; nowW = w+dw[i];\n\t\tflag = false;\n\t\twhile (c[nowH][nowW] == 'X') {\n\t\t\tnowH += dh[i]; nowW += dw[i];\n\t\t\tflag = true;\n\t\t}\n\t\tif (0<= nowH && nowH<=18 && 0<=nowW && nowW<=14 && flag) {\n\t\t\tif (dp[nowH][nowW] > temp + 1) {\n\t\t\t\tdp[nowH][nowW] = temp + 1;\n\t\t\t\tNode n = { nowH,nowW , temp+1};\n\t\t\t\tPQ.push(n);\n\t\t\t}\n\t\t}\n\t}\n}\nP g;\nint main() {\n\tfor (int i = 0; i < 19;i++) {\n\t\tscanf(\"%s\", c[i]);\n\t\tfor (int j = 0; j < 15;j++) {\n\t\t\tif (c[i][j] == 'O') {\n\t\t\t\tg = make_pair(i, j);\n\t\t\t}\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < 15;i++) {\n\t\tc[19][i] = '.';\n\t\tdp[19][i] = 0;\n\t\tNode n = { 19,i,0 };\n\t\tPQ.push( n );\n\t\tCalc(19, -1, 0);\n\t\tCalc(19, 15, 0);\n\t}\n\twhile (!PQ.empty()) {\n\t\tNode now = PQ.top(); PQ.pop();\n\t\tCalc(now.h, now.w, now.cost);\n\t}\n\tint ans = dp[g.first][g.second];\n\tif (ans>=INF) {\n\t\tprintf(\"-1\\n\");\n\t}\n\telse {\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};\nint n=19,m=15;\nvs in(n);\nint t=inf;\nvoid dfs(int x,int y,int c){\n\trep(i,8){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tint co=0;\n\t\twhile(nx>=0&&nx<19&&ny>=0&&ny<15&&in[nx][ny]=='X'){\n\t\t\tin[nx][ny]='.';\n\t\t\tco++;\n\t\t\tnx+=dx[i];\n\t\t\tny+=dy[i];\n\t\t}\n//\t\tcout<<c<<\" \"<<nx<<\" \"<<ny<<endl;\n\t\tif(co&&nx<18&&ny>=0&&ny<=14)dfs(nx,ny,c+1);\n\t\t\n\t\tif(co&&nx>=18){\n\t\t\tt=min(t,c+1);\n\t\t}\n\t\tnx-=dx[i],ny-=dy[i];\n\t\twhile(nx!=x||ny!=y){\n\t\t\tin[nx][ny]='X';\n\t\t\tnx-=dx[i];ny-=dy[i];\n\t\t}\n\t}\n}\nint main(){\n\trep(i,n)cin>>in[i];\n\trep(i,n)rep(j,m)if(in[i][j]=='O'){\n\t\tdfs(i,j,0);\n\t\tin[i][j]='.';\n\t\tif(t==inf)t=-1;\n\t\tcout<<t<<endl;\n\t\treturn 0;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <assert.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\nchar F[20][16];\nint sx, sy;\nunordered_map<int, int> umap;\n\nconstexpr int to_num(int x, int y) {\n  return x+y*16;\n}\n\nstruct state {\n  int x, y, used;\n  state(int x, int y, int used) : x(x), y(y), used(used) {}\n  bool operator == (state const& s) const { return x==s.x && y==s.y && used==s.used; }\n};\n\nstruct state_hash\n{\n  size_t operator()(state const& s) const {\n    return hash<int>()(to_num(s.x, s.y)) ^ hash<int>()(s.used);\n  }\n};\n\n\nconstexpr int dx[8] = {-1, 0, 1, 0,-1, 1, 1,-1};\nconstexpr int dy[8] = {0, -1, 0, 1,-1,-1, 1, 1};\n\nconstexpr bool inrange(int x, int y) {\n  return 0<=x && x<16 && 0<=y && y<20;\n}\n\nbool is_used_xy(int used, int x, int y) {\n  if(umap[to_num(x, y)] == -1) { return false; }\n  return used >> umap[to_num(x, y)] & 1;\n}\n\nvoid debugger(int used, int cx, int cy) {\n  rep(i, 20) {\n    rep(j, 16) {\n      if(cx == j && cy == i) {\n        assert((F[i][j] == 'X' && is_used_xy(used, j, i)) || (F[i][j] == '.') || (F[i][j] == 'G'));\n        cout << 'O';\n      }\n      else {\n        cout << (is_used_xy(used, j, i) ? 'U' : F[i][j]);\n      }\n    }\n    cout << endl;\n  }\n}\n\nint dijkstra() {\n  unordered_map<state, int, state_hash> dist;\n  queue<state> q;\n  q.emplace(sx, sy, 0);\n  dist[state{sx, sy, 0}] = 0;\n  while(!q.empty()) {\n    int const x = q.front().x, y = q.front().y, used = q.front().used;\n    int& cost = dist[state{x,y,used}];\n    q.pop();\n    if(x == -1 && y == 19) { return cost; }\n    if(F[y][x] == 'G') { return cost; }\n    rep(i, 8) {\n      int nx = x+dx[i], ny = y+dy[i];\n      int nused = used;\n      if(!inrange(nx, ny)) { continue; }\n      if(F[ny][nx] != 'X') { continue; }\n      if(is_used_xy(used, nx, ny)) { continue; }\n      bool ng = false;\n      for(;;) {\n        if(!inrange(nx, ny)) { ng = true; break; }\n        if(F[ny][nx] != 'X') { break; }\n        if(is_used_xy(used, nx, ny)) { break; }\n        nused |= 1<<umap[to_num(nx, ny)];\n        nx += dx[i], ny += dy[i];\n      }\n      if(ng && !(nx == -1 && ny == 19)) { continue; }\n      if(inrange(nx, ny) && F[ny][nx] == 'A') { continue; }\n      if(dist.find(state{nx, ny, nused})!=dist.end()) { continue; }\n      dist[state{nx, ny, nused}] = cost+1;\n      q.emplace(nx, ny, nused);\n    }\n  }\n  return -1;\n}\n\nint main() {\n\n  rep(i, 20) rep(j, 16) umap[to_num(j, i)] = -1;\n  int bcnt = 0;\n  rep(i, 19) rep(j, 15) {\n    cin >> F[i][j];\n    if(F[i][j] == 'O') {\n      F[i][j] = '.';\n      sx = j, sy = i;\n    }\n    if(F[i][j] == 'X') {\n      umap[to_num(j,i)] = bcnt++;\n    }\n  }\n\n  rep(i, 20) { F[i][15] = 'A'; }\n  rep(i, 16) {\n    if(i < 15 && F[18][i] != 'X') { F[18][i] = 'G'; }\n    F[19][i] = 'G';\n  }\n\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst int h = 19;\nconst int w = 15;\n\nstruct Data { int x,y,bitmask; };\n\nchar a[20][20];\nint mindist[1<<20][20][20];\nint Index[20][20];\n\nbool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nvoid compute(){\n  int black = 0;\n  int sx=-1,sy=-1;\n  rep(i,h) rep(j,w) {\n    if( a[i][j] == 'X' ) Index[i][j] = black++;\n    if( a[i][j] == 'O' ) sx = j, sy = i;\n  }\n  rep(i,(1<<black)) rep(j,h) rep(k,w) mindist[i][j][k] = IINF;\n  mindist[(1<<black)-1][sy][sx] = 0;\n  deque<Data> deq;\n  deq.push_back((Data){sx,sy,(1<<black)-1});\n  while( !deq.empty() ){\n    Data data = deq.front(); deq.pop_front();\n    REP(dx,-1,2){\n      REP(dy,-1,2){\n        if( dx == 0 && dy == 0 ) continue;\n        int nx = data.x + dx, ny = data.y + dy, nbitmask = data.bitmask;\n        bool valid = false;\n        while( isValid(nx,ny) && ( a[ny][nx] == 'X' && ( data.bitmask & (1<<Index[ny][nx]) ) ) ){\n          nbitmask &= ~(1<<Index[ny][nx]);\n          nx += dx, ny += dy;\n          valid = true;\n        }\n        if( !isValid(nx,ny) ) {\n          if( valid && ( 0 <= nx && nx < w ) && ny >= h ) {\n            cout << mindist[data.bitmask][data.y][data.x]+1 << endl;\n            return;\n          }\n          continue;\n        }\n        if( !valid ) continue;\n        if( mindist[nbitmask][ny][nx] > mindist[data.bitmask][data.y][data.x] + 1 ) {\n          mindist[nbitmask][ny][nx] = mindist[data.bitmask][data.y][data.x] + 1;\n          deq.push_back((Data){nx,ny,nbitmask});\n        }\n      }\n    }\n  }\n  puts(\"-1\");\n}\n\nint main(){\n  rep(i,h) rep(j,w) scanf(\" %c\",&a[i][j]);\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nstring s[19];\nint sx = -1, sy = -1, ans,\n\tvx[8] = {-1, -1, 0, 1, 1, 1, 0, -1},\n\tvy[8] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ninline bool check(int x, int y) {\n\treturn (0 <= x && x < 19 && 0 <= y && y < 15);\n}\n\nint search(int x, int y, int cnt) {\n\tint ret = (int)1e9;\n\n\t//cout << \"now is\" << x << \" \" << y << endl;\n\n\tfor (int i = 0; i < 8; ++i) {\n\t\tint nx = x + vx[i], ny = y + vy[i], nnx, nny;\n\t\t//cout << \"nx, ny \" << nx << \" \" << ny << endl;\n\n\t\tif (check(nx, ny)) {\n\t\t\tif (s[nx][ny] == 'X') {\n\t\t\t\tnnx = nx + vx[i], nny = ny + vy[i];\n\n\t\t\t\tfor (int j = 1; ; ++j) {\n\t\t\t\t\t//cout << \"nnx, nny \" << nnx << \" \" << nny << endl;\n\t\t\t\t\tif (nnx >= 18) {\n\t\t\t\t\t\t//cout << \"now : \" << x << \" \" << y << endl;\n\t\t\t\t\t\t//cout << \"goal: \" << ret << \" \" << j << endl;\n\t\t\t\t\t\tret = min(ret, cnt);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!check(nnx, nny)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (check(nnx, nny) && s[nnx][nny] == '.') {\n\t\t\t\t\t\tstring tmp[19];\n\t\t\t\t\t\tint xx = nx, yy = ny;\n\t\t\t\t\t\tfor (int k = 0; k < 19; ++k) tmp[k] = s[k];\n\n\t\t\t\t\t\t//for (int z = 0; z < 19; ++z) cout << s[z] << endl;\n\t\t\t\t\t\twhile ((xx != nnx || yy != nny)) {\n\t\t\t\t\t\t\ts[xx][yy] = '.';\n\t\t\t\t\t\t\txx += vx[i], yy += vy[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//cout << \"nnx,nny\" << nnx << ' ' << nny << endl;\n\t\t\t\t\t\t//for (int z = 0; z < 19; ++z) cout << s[z] << endl;\n\n\t\t\t\t\t\tint ret_s = search(nnx, nny, cnt + 1);\n\t\t\t\t\t\tif (ret_s != -1) {\n\t\t\t\t\t\t\t//cout << \"ret, j + ret_s \"<< ret << \" \" << j + ret_s << endl;\n\t\t\t\t\t\t\t//cout << \"ret_s : \" << ret_s << endl;\n\t\t\t\t\t\t\tret = min(ret, ret_s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (int k = 0; k < 19; ++k) {\n\t\t\t\t\t\t\ts[k] = tmp[k];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tnnx += vx[i], nny += vy[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (nnx == 19) {\n\t\t\tret = min(ret, cnt);\n\t\t}\n\t}\n\n\tif (ret == (int)1e9) return -1;\n\n\t//cout << \"return \" << x << \", \" << y << \" = \" << ret << endl;\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor (int i = 0; i < 19; ++i) {\n\t\tcin >> s[i];\n\n\t\tif (sx == -1) {\n\t\t\tfor (int j = 0; j < 15; ++j) {\n\t\t\t\tif (s[i][j] == 'O') {\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tans = search(sx, sy, 1);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H=19,W=15;\n\nenum DIR{\n\tLeft_Up,\n\tUp,\n\tRight_Up,\n\tLeft,\n\tRight,\n\tLeft_Down,\n\tDown,\n\tRight_Down,\n};\n\nDIR dir[8] = {Left_Up,Up,Right_Up,Left,Right,Left_Down,Down,Right_Down};\n\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\n\nstruct BlackStone{\n\tBlackStone(){\n\t\trow = col = 0;\n\t}\n\n\tBlackStone(short arg_row,short arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tshort row,col;\n};\n\nstruct Info{\n\tvector<BlackStone> BLACK_STONE;\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn row < arg.row;\n\t};\n\tshort row,col,count;\n};\n\nbool rangeCheck(short row,short col){\n\tif(row <= 17){\n\t\tif(col < 0 || col > 14){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}else{ //row >= 18\n\t\tif(row == 18 && (col < 0 || col > 14)){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\nInfo move(Info info,DIR dir){\n\tInfo ret;\n\n\tchar map[19][15];\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)map[i][k] = '.';\n\t}\n\n\tfor(int i = 0; i < info.BLACK_STONE.size(); i++){\n\t\tmap[info.BLACK_STONE[i].row][info.BLACK_STONE[i].col] = 'X';\n\t\tBlackStone new_stone;\n\t\tnew_stone.row = info.BLACK_STONE[i].row;\n\t\tnew_stone.col = info.BLACK_STONE[i].col;\n\t\tret.BLACK_STONE.push_back(new_stone);\n\t}\n\tret.count = info.count+1;\n\n\tint next_row,next_col,index;\n\n\tswitch(dir){\n\tcase Left_Up:\n\t\tindex = 0;\n\t\tbreak;\n\tcase Up:\n\t\tindex = 1;\n\t\tbreak;\n\tcase Right_Up:\n\t\tindex = 2;\n\t\tbreak;\n\tcase Left:\n\t\tindex = 3;\n\t\tbreak;\n\tcase Right:\n\t\tindex = 4;\n\t\tbreak;\n\tcase Left_Down:\n\t\tindex = 5;\n\t\tbreak;\n\tcase Down:\n\t\tindex = 6;\n\t\tbreak;\n\tcase Right_Down:\n\t\tindex = 7;\n\t\tbreak;\n\t}\n\n\tnext_row = info.row+diff_row[index];\n\tnext_col = info.col+diff_col[index];\n\n\twhile(rangeCheck(next_row,next_col) == true && map[next_row][next_col] == 'X'){\n\t\tnext_row += diff_row[index];\n\t\tnext_col += diff_col[index];\n\t}\n\n\n\tif(next_row == info.row+diff_row[index] && next_col == info.col+diff_col[index]){\n\t\tret.row = 1;\n\t\tret.col = -1;\n\t}else{\n\n\t\tif(rangeCheck(next_row,next_col) == true && next_row <= 18){ //?§?????????????????????§????????´????????§????????´???\n\n\t\t\tint tmp_row,tmp_col;\n\n\t\t\ttmp_row = info.row+diff_row[index];\n\t\t\ttmp_col = info.col+diff_col[index];\n\n\t\t\twhile(tmp_row != next_row || tmp_col != next_col){\n\t\t\t\tfor(int i = 0; i < ret.BLACK_STONE.size();i++){\n\t\t\t\t\tif(ret.BLACK_STONE[i].row == tmp_row && ret.BLACK_STONE[i].col == tmp_col){\n\t\t\t\t\t\tret.BLACK_STONE.erase(ret.BLACK_STONE.begin()+i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp_row += diff_row[index];\n\t\t\t\ttmp_col += diff_col[index];\n\t\t\t}\n\t\t}\n\n\t\tret.row = next_row;\n\t\tret.col = next_col;\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\n\tInfo first;\n\n\tchar buf[15];\n\tint minimum = BIG_NUM,start_row,start_col;\n\n\tfor(short i = 0; i < H; i++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(short k = 0; k < W; k++){\n\t\t\tif(buf[k] == 'O'){\n\t\t\t\tstart_row = i;\n\t\t\t\tstart_col = k;\n\t\t\t}else if(buf[k] == 'X'){\n\t\t\t\tfirst.BLACK_STONE.push_back(BlackStone(i,k));\n\t\t\t}\n\t\t}\n\t}\n\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.count = 0;\n\n\tpriority_queue<Info> Q;\n\tQ.push(first);\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().row >= 18){\n\t\t\tminimum = Q.top().count;\n\t\t\tbreak;\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 8; i++){\n\t\t\t\tInfo next = move(Q.top(),dir[i]);\n\n\t\t\t\tif(rangeCheck(next.row,next.col)){\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(minimum == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    const int INF = 1<<28;\n\n    vector<string> F;\n    void input() {\n        F.resize(19);\n        for (int i = 0; i < 19; i++) cin >> F[i];\n    }\n\n    int sy, sx;\n    int c;\n    vector<vector<int>> N;\n    map<int,pair<int,int>> M;\n\n    int memo[19][15][1<<20];\n\n    void init() {\n        c = 0;\n        sy = sx = -1;\n        N.clear(); N.resize(19, vector<int>(15, -1));\n        M.clear();\n        for (int i = 0; i < 19; i++) {\n            for (int j = 0; j < 15; j++) {\n                if (F[i][j] == 'O') {\n                    sy = i;\n                    sx = j;\n                }\n                if (F[i][j] == 'X') {\n                    N[i][j] = c;\n                    M[c] = make_pair(i, j);\n                    c++;\n                }\n            }\n        }\n\n        memset(memo, -1, sizeof(memo));\n    }\n\n    struct NextPos {\n        int y, x;\n        int used;\n        NextPos(int y, int x, int used) : y(y), x(x), used(used) {}\n    };\n\n    NextPos findNextPos(int y, int x, int dy, int dx, int used) {\n        int nused = used;\n        while (true) {\n            int ny = y + dy;\n            int nx = x + dx;\n            if (ny < 0 || ny >= 19 || nx < 0 || nx >= 15) return NextPos(ny, nx, nused);\n            if (F[ny][nx] == 'X') {\n                int id = N[ny][nx];\n                if (nused & (1 << id)) {\n                    return NextPos(ny, nx, nused);\n                } else {\n                    nused |= (1 << id);\n                }\n            } else {\n                return NextPos(ny, nx, nused);\n            }\n            y = ny;\n            x = nx;\n        }\n    }\n\n    bool movable(int y, int x, int dy, int dx, int used) {\n        int ny = y + dy;\n        int nx = x + dx;\n        if (ny < 0 || ny >= 19 || nx < 0 || nx >= 15) return false;\n        if (F[ny][nx] != 'X') return false;\n        int id = N[ny][nx];\n        if (used & (1 << id)) return false;\n        return true;\n    }\n\n    int dfs(int y, int x, int used) {\n        //cout << \"dfs: \" << y << \" \" << x << \" \" << used << endl;\n        if (y >= 18) return 0;\n        if (y < 0 || x < 0 || x >= 15) return INF;\n        int& cache = memo[y][x][used];\n        if (cache >= 0) return cache;\n        int ans = INF;\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                if (not movable(y, x, dy, dx, used)) continue;\n                NextPos next = findNextPos(y, x, dy, dx, used);\n                ans = min(ans, dfs(next.y, next.x, next.used) + 1);\n            }\n        }\n        return cache = ans;\n    }\n\n    void solve() {\n        init();\n        int ans = dfs(sy, sx, 0);\n        if (ans >= INF) ans = -1;\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input();\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int w = 15;\nconst int h = 19;\nvector<string> mp(h);\n\nbool inmp(int x,int y){return 0<=x&&0<=y&&x<w&&y<h;}\n\n\nint ans=1e9;\nvoid dfs(int x,int y,int cost){\n    if(y==h-1||(y==h&&0<=x&&x<w))ans=min(ans,cost);\n  if(!inmp(x,y)||ans<=cost) return;\n\n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      int nx = x+i;\n      int ny = y+j;\n      if(!inmp(nx,ny)||mp[ny][nx] != 'X') continue;\n      vector<string>tmp = mp;\n      while(inmp(nx,ny)&&mp[ny][nx]=='X')mp[ny][nx] = '.', nx+=i,ny+=j;\n      dfs(nx,ny,cost+1);\n      mp = tmp;\n    }\n}\n\nint main(){\n\n  for(int i=0;i<h;i++)cin>>mp[i];\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j] =='O') dfs(j,i,0);\n\n  if(ans==1e9) ans=-1;\n  cout<<ans<<endl;\n  \n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int vx[] = {-1, 0, 1, 1, 1, 0, -1, -1};\n\nstring S[19];\nint sx, sy;\n\nbool isgoal(int y, int x)\n{\n  return ((y == 18 && 0 < x && x < 14) || y == 19);\n}\n\nint bfs()\n{\n  map< tuple< int, int, int >, int > v;\n  queue< tuple< int, int, int > > que;\n  que.emplace(0, sy, sx);\n  v[que.front()] = 0;\n  while(!que.empty()) {\n    auto p = que.front();\n    int bit, y, x;\n    tie(bit, y, x) = p;\n    que.pop();\n    for(int i = 0; i < 8; i++) {\n      int ny = vy[i] + y, nx = vx[i] + x, bb = bit;\n      while(ny >= 0 && nx < 15 && ny >= 0 && ny < 19 && S[ny][nx] < 20) {\n        if((bit >> S[ny][nx]) & 1) break;\n        bb |= 1 << S[ny][nx];\n        ny += vy[i], nx += vx[i];\n      }\n      if(ny == vy[i] + y && nx == vx[i] + x) continue;\n      if(isgoal(ny, nx)) return (v[p] + 1);\n      if(ny >= 0 && nx < 15 && ny >= 0 && ny < 19) {\n        auto nxt = make_tuple(bb, ny, nx);\n        if(v.count(nxt) && v[nxt] <= v[p] + 1)continue;\n        v[nxt] = v[p] + 1;\n        que.emplace(nxt);\n      }\n    }\n  }\n  return (-1);\n}\n\nint main()\n{\n  int pad = 0;\n  for(int i = 0; i < 19; i++) {\n    cin >> S[i];\n    for(int j = 0; j < 15; j++) {\n      if(S[i][j] == 'X') S[i][j] = pad++;\n      else if(S[i][j] == 'O') sy = i, sx = j;\n    }\n  }\n  cout << bfs() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct S {\n\tint x, y, mask;\n\tll hash() {\n\t\treturn x + 15 * y + mask * (1LL << 30);\n\t}\n};\n\nint b[19][15];\n\nint dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 };\nint dy[8] = { 0, 1, 0, -1, 1, -1, 1, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < 15 && 0 <= y && y < 19;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint B = 0;\n\tint sx = -1, sy = -1;\n\tmemset(b, -1, sizeof b);\n\tfor(int i = 0; i < 19; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j < 15; j++) {\n\t\t\tif(s[j] == 'O') sx = j, sy = i;\n\t\t\tif(s[j] == 'X') {\n\t\t\t\tb[i][j] = B++;\n\t\t\t}\n\t\t}\n\t}\n\n\tunordered_map<ll, int> dp;\n\tS is = { sx, sy, 0 };\n\tdp[is.hash()] = 0;\n\n\tqueue<S> q;\n\tq.push(is);\n\twhile(q.size()) {\n\t\tint x = q.front().x, y = q.front().y, mask = q.front().mask;\n\t\tint t = dp[q.front().hash()];\n\t\tq.pop();\n\t\tfor(int k = 0; k < 8; k++) {\n\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\tif(!in(nx, ny)) continue;\n\t\t\tint id = b[ny][nx];\n\t\t\tif(id == -1) continue;\n\t\t\tif(mask >> id & 1) continue;\n\t\t\t//cerr << \"nx : \" << nx << \", ny : \" << ny << endl;\n\t\t\tint nmask = mask;\n\t\t\twhile(1) {\n\t\t\t\tnmask |= 1 << id;\n\t\t\t\tnx += dx[k], ny += dy[k];\n\t\t\t\tif(!in(nx, ny)) break;\n\t\t\t\tid = b[ny][nx];\n\t\t\t\tif(id == -1 || (mask >> id & 1)) break;\n\t\t\t}\n\t\t\tif(ny >= 18) {\n\t\t\t\tcout << t + 1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(in(nx, ny)) {\n\t\t\t\tS ns = { nx, ny, nmask };\n\t\t\t\tif(dp.count(ns.hash()) == 0) {\n\t\t\t\t\tdp[ns.hash()] = t + 1;\n\t\t\t\t\tq.push(ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint main(){\n  vector<string> vec(19);\n  rep(i,19) cin>>vec[i];\n  int n = 0;\n  // vector<int> x,y;\n  map<pair<int,int>,int> p2i;\n  rep(i,19)rep(j,15) if(vec[i][j]=='X'){\n    // x.pb(i);\n    // y.pb(j);\n    p2i[mp(i,j)] = n++;\n  }\n  int sx,sy;\n  rep(i,19)rep(j,15) if(vec[i][j]=='O') sx=i, sy=j;\n\n  using state = pair<int,pair<int,int>>;\n\n  auto ok = [&](int i, int j){\n    return i>=0 && i<19 && j>=0 && j<15;\n  };\n\n  set<state> prev;\n  prev.insert(mp(0,mp(sx,sy)));\n\n  rep(i,20){\n    set<state> nxt;\n    for(const state & s : prev){\n      int mask = s.fi;\n      int x = s.se.fi, y = s.se.se;\n      for(int dx=-1; dx<=1; dx++){\n        for(int dy=-1; dy<=1; dy++) if(dx*dx+dy*dy>0){\n          int nmask = mask;\n          int d = 1;\n          while(ok(x+dx*d,y+dy*d) && vec[x+dx*d][y+dy*d]=='X'){\n            int idx = p2i[mp(x+dx*d, y+dy*d)];\n            if(! (mask & (1<<idx)) ){\n              nmask |= (1<<idx);\n              d++;\n            }\n            else {\n              break;\n            }\n          }\n          if(d==1) continue;\n          int nx=x+dx*d, ny=y+dy*d;\n          if(nx==19){\n            cout << i+1 << endl;\n            return 0;\n          }\n          if(ok(nx,ny)) nxt.insert(mp(nmask,mp(nx,ny)));\n        }\n      }\n    }\n    swap(nxt, prev);\n  }\n\n  cout << -1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nstruct State { int x[19][15]; };\nState S;\nint dx[8] = { 1,1,1,0,-1,-1,-1,0 }, dy[8] = { -1,0,1,1,1,0,-1,-1 };\nint solve(State p) {\n\tint cx = 0, cy = 0;\n\tfor (int i = 0; i < 285; i++) {\n\t\tif (p.x[i / 15][i % 15] == 2) { cx = i / 15; cy = i % 15; }\n\t}\n\tint minx = 999999;\n\tfor (int i = 0; i < 8; i++) {\n\t\tState T = p;\n\t\tint ex = cx, ey = cy;\n\t\tbool flag = true;\n\t\twhile (true) {\n\t\t\tif (ex < 0 || ey < 0 || ey >= 15) { flag = false; }\n\t\t\tex += dx[i]; ey += dy[i];\n\t\t\tif (ex == 19 || T.x[ex][ey] == 0)break;\n\t\t\tT.x[ex][ey] = 0;\n\t\t}\n\t\tif (flag == false)continue;\n\n\t\tif (abs(ex - cx) <= 1 && abs(ey - cy) <= 1)continue;\n\t\tif (ex == 18 || ex == 19)minx = min(minx, 1);\n\t\telse {\n\t\t\tT.x[cx][cy] = 0; T.x[ex][ey] = 2;\n\t\t\tminx = min(minx, solve(T) + 1);\n\t\t}\n\t}\n\treturn minx;\n}\nint main() {\n\tfor (int i = 0; i < 19; i++) {\n\t\tfor (int j = 0; j < 15; j++) {\n\t\t\tchar p; cin >> p;\n\t\t\tif (p == 'O')S.x[i][j] = 2;\n\t\t\tif (p == 'X')S.x[i][j] = 1;\n\t\t\tif (p == '.')S.x[i][j] = 0;\n\t\t}\n\t}\n\tint R = solve(S); if (R >= 100000)R = -1;\n\tcout << R << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <deque>\n#include <tuple>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;//B,x,y\ntypedef tuple<int,int,int,int> T4;//d,B,x,y\nvector<P> B;\nint board[15][20];\n\nint main(){\n    fill(board[0],board[20],-1);\n    int ox,oy;\n    for(int i=0;i<19;i++){\n        for(int j=0;j<15;j++){\n            char c;\n            cin>>c;\n            if(c=='O'){\n                oy=i; ox=j;\n            }else if(c=='X'){\n                board[j][i]=B.size();\n                B.emplace_back(j,i);\n            }\n        }\n    }\n    /*\n    for(int i=0;i<20;i++){\n        for(int j=0;j<15;j++){\n            if(board[j][i]==-1) cout<<'.';\n            else cout<<board[j][i];\n        }\n        cout<<endl;\n    }\n    */\n    map<T,int> M;\n    deque<T4> que;\n    que.emplace_back(0,(1<<B.size())-1,ox,oy);\n    while(!que.empty()){\n        int d,bb,x,y;\n        tie(d,bb,x,y)=que.front(); que.pop_front();\n        // cout<<d<<' '<<bb<<' '<<x<<' '<<y<<endl;\n        if(y>=18){\n            cout<<d<<endl;\n            return 0;\n        }\n        if(x<0||x==15) continue;\n        for(int dy=-1;dy<=1;dy++){\n            for(int dx=-1;dx<=1;dx++){\n                if(!dx&&!dy)continue;\n                if(x+dx<0||x+dx>=15) continue;\n                if(y+dy<0||y+dy>=19) continue;\n                if(board[x+dx][y+dy]==-1) continue;\n                else{\n                    if(bb&(1<<board[x+dx][y+dy])){\n                        int l=2;\n                        int bbb=bb^(1<<board[x+dx][y+dy]);\n                        while(true){\n                            if(x+dx*l<0||x+dx*l>=15||y+dy*l<0||y+dy*l>=19){\n                                break;\n                            }else{\n                                if(board[x+dx*l][y+dy*l]==-1){\n                                    break;\n                                }else{\n                                    if((1<<board[x+dx*l][y+dy*l])&bbb){\n                                        bbb^=1<<board[x+dx*l][y+dy*l];\n                                        l++;\n                                        continue;\n                                    }else{\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        if(M.find(T(bbb,x+dx*l,y+dy*l))==M.end()){\n                            M[T(bbb,x+dx*l,y+dy*l)]=d+1;\n                            que.emplace_back(d+1,bbb,x+dx*l,y+dy*l);\n                        }else if(M[T(bbb,x+dx*l,y+dy*l)]>d+1){\n                            M[T(bbb,x+dx*l,y+dy*l)]=d+1;\n                            que.emplace_back(d+1,bbb,x+dx*l,y+dy*l);\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n    cout<<-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\n#define H 19\n#define W 15\nbool banmen[H+1][W];\nint dirs[8][2];\n\nint solve(int x, int y, int te) {\n  //printf(\"%d,%d,%d\\n\",x,y,te);\n  if(y>=H-1) return te;\n  int ans = 9999;\n  for(int dir_index = 0; dir_index < 8; dir_index++) {\n    int dx = dirs[dir_index][0];\n    int dy = dirs[dir_index][1];\n    int count = 0;\n    int ax = x+dx;\n    int ay = y+dy;\n    //printf(\"(%d,%d,%d,%d,%d)\\n\",ax>0,ax+dx<W,ay>0,ay+dy<=H,banmen[ax][ay]);\n    while(ax>0&&ax+dx<W&&ay>0&&ay+dy<=H && banmen[ay][ax]) {\n      banmen[ay][ax] = false;\n      ax+=dx;\n      ay+=dy;\n      count++;\n    }\n    //printf(\"(x,y,c)=(%d,%d,%d)\\n\",dx,dy,count);\n    if(count>0) {\n      int ret = solve(ax,ay,te+1);\n      if(ret!=-1) {\n        ans = min(ans,ret);\n      }\n    }\n    for(int i = 1; i <= count; i++) {\n      banmen[y+dy*i][x+dx*i] = true;\n    }\n  }\n  return (ans==9999)?-1:ans;\n}\n\nint main() {\n  int x,y;\n  for(int i = 0; i < H; i++) {\n    char row[W+1];\n    scanf(\"%s\",row);\n    for(int j = 0; j < W; j++) {\n      banmen[i][j] = (row[j]=='X');\n      if(row[j]=='O') {\n        y = i;\n        x = j;\n      }\n    }\n  }\n  /*\n  for(int i = 0; i < H+1; i++) {\n    for(int j = 0; j < W; j++) {\n      printf(\"%d \",banmen[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  */\n  for(int j = 0; j < W; j++) {\n    banmen[H][j] = false;\n  }\n\n  dirs[0][0] = 1;\n  dirs[0][1] = 1;\n  dirs[1][0] = 1;\n  dirs[1][1] = 0;\n  dirs[2][0] = 1;\n  dirs[2][1] = -1;\n  dirs[3][0] = 0;\n  dirs[3][1] = -1;\n  dirs[4][0] = -1;\n  dirs[4][1] = -1;\n  dirs[5][0] = -1;\n  dirs[5][1] = 0;\n  dirs[6][0] = -1;\n  dirs[6][1] = 1;\n  dirs[7][0] = 0;\n  dirs[7][1] = 1;\n\n  printf(\"%d\\n\",solve(x,y,0));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define P(T1,T2) pair<T1,T2>\n#define MP(a,b) make_pair((a),(b))\n#define NUM_Y 19\n#define NUM_X 15\n\nchar MAP[NUM_Y][NUM_X] = {};\nint TMP_X[8] = { 1,1,1,0,0,-1,-1,-1 };\nint TMP_Y[8] = { -1,0,1,-1,1,-1,0,1 };\nint goal_cnt = 99999;\n\nvoid show()\n{\n\tREP(i, NUM_Y)\n\t{\n\t\tREP(j, NUM_X)\n\t\t{\n\t\t\tcout << MAP[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid BFS(int _sy, int _sx)\n{\n\n\tstruct Data\n\t{\n\t\tData(int _x, int _y, int _c, bool _j) :x(_x), y(_y), c(_c), j(_j) {};\n\t\tint x = 0, y = 0;\n\t\tint c = 0;\n\t\tbool j = false;\n\t};\n\n\tstack<Data> que;\n\tque.push(Data(_sx, _sy, 0, false));\n\n\twhile (que.empty() == false)\n\t{\n\t\tint y = que.top().y;\n\t\tint x = que.top().x;\n\t\tint c = que.top().c;\n\t\tbool j = que.top().j;\n\t\tque.pop();\n\t\t\n\t\tREP(i, 8)\n\t\t{\n\t\t\tint xx = x + TMP_X[i];\n\t\t\tint yy = y + TMP_Y[i];\n\n\t\t\tif (yy < 0 || yy >= NUM_Y || xx < 0 || xx >= NUM_X)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\telse if (MAP[yy][xx] == '.')\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\telse if (MAP[yy][xx] == 'X')\n\t\t\t{\n\t\t\t\tMAP[y][x] = '.';\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tyy += TMP_Y[i];\n\t\t\t\t\txx += TMP_X[i];\n\t\t\t\t\tif (yy >= NUM_Y)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (goal_cnt > c+1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgoal_cnt = c+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (yy < 0 || xx < 0 || xx >= NUM_X)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (MAP[yy][xx] == 'X')\n\t\t\t\t\t{\n\t\t\t\t\t\tMAP[yy - TMP_Y[i]][xx - TMP_X[i]] = '.';\n\t\t\t\t\t}\n\t\t\t\t\telse if(MAP[yy][xx]=='.')\n\t\t\t\t\t{\n\t\t\t\t\t\tMAP[yy - TMP_Y[i]][xx - TMP_X[i]] = '.';\n\t\t\t\t\t\tMAP[yy][xx] = 'O';\n\t\t\t\t\t\tque.push(Data(xx, yy, c+1, false));\n\t\t\t\t\t\ti = 999;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//show();\n\t}\n}\n\nint main()\n{\n\tint sx, sy;\n\tREP(y, 19)\n\t{\n\t\tREP(x, 15)\n\t\t{\n\t\t\tcin >> MAP[y][x];\n\t\t\tif (MAP[y][x] == 'O')\n\t\t\t{\n\t\t\t\tsy = y;\n\t\t\t\tsx = x;\n\t\t\t}\n\t\t}\n\t}\n\n\tBFS(sy, sx);\n\n\tif (goal_cnt == 99999)cout << -1 << endl;\n\telse cout << goal_cnt << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint main(void) {\n  const ll H = 19, W = 15;\n  char S[H][W];\n  REP(i, 0, H) REP(j, 0, W) cin >> S[i][j];\n\n  pll white;\n  vector<pll> black, cand;\n  REP(i, 0, H) REP(j, 0, W) {\n    if(S[i][j] == 'O') {\n      white = pll(i, j);\n      cand.push_back(pll(i, j));\n    }\n    if(S[i][j] == 'X') {\n      black.push_back(pll(i, j));\n      REP(di, -1, 2) REP(dj, -1, 2) if(di != 0 || dj != 0) {\n        cand.push_back(pll(i + di, j + dj));\n      }\n    }\n  }\n  sort(black.begin(), black.end());\n  sort(cand.begin(), cand.end());\n  cand.erase(unique(cand.begin(), cand.end()), cand.end());\n\n  ll N = black.size(), M = cand.size();\n  bool visited[1LL << N][M];\n  REP(i, 0, 1LL << N) REP(j, 0, M) visited[i][j] = false;\n\n  struct state { ll s, v, d; };\n  queue<state> q;\n  q.push((state) { (1LL << N) - 1, lower_bound(cand.begin(), cand.end(), white) - cand.begin(), 0 });\n\n  while(!q.empty()) {\n    ll s = q.front().s, v = q.front().v, d = q.front().d;\n    ll y = cand[v].first, x = cand[v].second;\n    q.pop();\n\n    visited[s][v] = true;\n\n    REP(i, -1, 2) REP(j, -1, 2) if(i != 0  || j != 0) {\n      ll ns = s, ny = y + i, nx = x + j, nd = d + 1;\n      ll cnt = 0;\n\n      while(1) {\n        if(!(0 <= ny && ny < H && 0 <= nx && nx < W)) break;\n        if(S[ny][nx] != 'X') break;\n\n        ll b = lower_bound(black.begin(), black.end(), pll(ny, nx)) - black.begin();\n        if(b == N) break;\n        if(!(ns & (1LL << b))) break;\n\n        ns = ns & (~(1LL << b));\n        ny += i;\n        nx += j;\n        cnt++;\n      }\n\n      if(cnt > 0 && ny >= H - 1) {\n        cout << nd << endl;\n        return 0;\n      } else if(cnt > 0) {\n        ll nv = lower_bound(cand.begin(), cand.end(), pll(ny, nx)) - cand.begin();\n        if(!visited[ns][nv]) q.push((state) { ns, nv, nd });\n      }\n    }\n  }\n  cout << -1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int vx[] = {-1, 0, 1, 1, 1, 0, -1, -1};\n\nstring S[19];\nint sx, sy;\n\nbool isgoal(int y, int x)\n{\n  return ((y == 18 && 0 <= x && x <= 14) || y == 19);\n}\n\nint bfs()\n{\n  unordered_map< int, int > v[19][15];\n  queue< tuple< int, int, int > > que;\n  que.emplace(0, sy, sx);\n  v[sy][sx][0] = 0;\n  while(!que.empty()) {\n    int bit, y, x;\n    tie(bit, y, x) = que.front();\n    que.pop();\n    for(int i = 0; i < 8; i++) {\n      int ny = vy[i] + y, nx = vx[i] + x, bb = bit;\n      while(nx >= 0 && nx < 15 && ny >= 0 && ny < 19 && S[ny][nx] < 20) {\n        if((bit >> S[ny][nx]) & 1) break;\n        bb |= 1 << S[ny][nx];\n        ny += vy[i], nx += vx[i];\n      }\n      if(ny == vy[i] + y && nx == vx[i] + x) continue;\n      if(isgoal(ny, nx)) return (v[y][x][bit] + 1);\n      if(ny >= 0 && nx < 15 && ny >= 0 && ny < 19) {\n        auto nxt = make_tuple(bb, ny, nx);\n        if(v[ny][nx].count(bb) && v[ny][nx][bb] <= v[y][x][bit] + 1)continue;\n        v[ny][nx][bb] = v[y][x][bit] + 1;\n        que.emplace(nxt);\n      }\n    }\n  }\n  return (-1);\n}\n\nint main()\n{\n  int pad = 0;\n  for(int i = 0; i < 19; i++) {\n    cin >> S[i];\n    for(int j = 0; j < 15; j++) {\n      if(S[i][j] == 'X') S[i][j] = pad++;\n      else if(S[i][j] == 'O') sy = i, sx = j;\n    }\n  }\n  cout << bfs() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 19;\nconst int W = 15;\nvector<string> board(H);\nvector<int> xhs, xws;\nint d[1<<20][H][W];\n\nclass State{\npublic:\n    int xstate;\n    int h, w;\n    \n//    bool operator < (const State &r) const{\n//        int xl = xstate * H * W + h * W + w;\n//        int xr = r.xstate * H * W + r.h * W + r.w;\n//        return xl < xr;\n//    }\n};\n\ninline bool infield(int h, int w){\n    if(h == H)\n        return true;\n    else\n        return 0<=w && w<W;\n}\n\nint bfs(int sh, int sw){\n    int xn = xhs.size();\n    map<pair<int, int>, int> ipoint;\n    for(int i=0; i<xn; i++)\n        ipoint[{xhs[i], xws[i]}] = i;\n    \n    queue<State> que;\n    State s;\n    s.xstate = (1<<xn)-1;\n    s.h = sh;\n    s.w = sw;\n    que.push(s);\n    d[s.xstate][s.h][s.w] = 0;\n    \n    while(!que.empty()){\n        auto s = que.front(); que.pop();\n        \n        for(int dh=-1; dh<=1; dh++){\n            for(int dw=-1; dw<=1; dw++) if(dh != 0 || dw != 0){\n                State ns;\n                ns.xstate = s.xstate;\n                ns.h = s.h + dh;\n                ns.w = s.w + dw;\n                \n                if(ipoint.find({ns.h, ns.w}) == ipoint.end() || ((ns.xstate>>ipoint[{ns.h, ns.w}])&1) == 0)\n                    continue;\n                \n                int count = 0;\n                while(infield(ns.h, ns.w) && ipoint.find({ns.h, ns.w})!= ipoint.end() && (ns.xstate>>ipoint[{ns.h, ns.w}])&1){\n                    ns.h += dh;\n                    ns.w += dw;\n                    count++;\n                }\n                if(!infield(ns.h, ns.w))\n                    continue;\n                \n                ns.h = s.h + dh;\n                ns.w = s.w + dw;\n                for(int i=0; i<count; i++){\n                    ns.xstate -= 1<<ipoint[{ns.h, ns.w}];\n                    ns.h += dh;\n                    ns.w += dw;\n                }\n                \n                que.push(ns);\n                d[ns.xstate][ns.h][ns.w] = d[s.xstate][s.h][s.w] + 1;\n                \n                if(H-1<=ns.h){\n                    return d[ns.xstate][ns.h][ns.w];\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    for(auto &s: board) cin >> s;\n    \n    int sh, sw;\n    for(int h=0; h<H; h++){\n        for(int w=0; w<W; w++){\n            if(board[h][w] == 'O')\n                sh = h, sw = w;\n            if(board[h][w] == 'X')\n                xhs.push_back(h), xws.push_back(w);\n        }\n    }\n    cout << bfs(sh, sw) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H=19,W=15;\n\nenum DIR{\n\tLeft_Up,\n\tUp,\n\tRight_Up,\n\tLeft,\n\tRight,\n\tLeft_Down,\n\tDown,\n\tRight_Down,\n};\n\nDIR dir[8] = {Left_Up,Up,Right_Up,Left,Right,Left_Down,Down,Right_Down};\n\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\n\nstruct BlackStone{\n\tvoid set(short arg_row,short arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tshort row,col;\n\tbool erased;\n};\n\nstruct Info{\n\tBlackStone black_stone[20];\n\tshort row,col,black_num;\n\tint count;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row <= 17){\n\t\tif(col < 0 || col > 14){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}else{ //row >= 18\n\t\tif(row == 18 && (col < 0 || col > 14)){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\nInfo move(Info info,DIR dir){\n\tInfo ret;\n\n\tchar map[19][15];\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)map[i][k] = '.';\n\t}\n\n\tfor(int i = 0; i < info.black_num; i++){\n\t\tif(info.black_stone[i].erased == false){\n\t\t\tmap[info.black_stone[i].row][info.black_stone[i].col] = 'X';\n\t\t}\n\t\tret.black_stone[i].set(info.black_stone[i].row,info.black_stone[i].col);\n\t\tret.black_stone[i].erased = info.black_stone[i].erased;\n\t}\n\tret.black_num = info.black_num;\n\tret.count = info.count+1;\n\n\tint next_row,next_col,index;\n\n\tswitch(dir){\n\tcase Left_Up:\n\t\tindex = 0;\n\t\tbreak;\n\tcase Up:\n\t\tindex = 1;\n\t\tbreak;\n\tcase Right_Up:\n\t\tindex = 2;\n\t\tbreak;\n\tcase Left:\n\t\tindex = 3;\n\t\tbreak;\n\tcase Right:\n\t\tindex = 4;\n\t\tbreak;\n\tcase Left_Down:\n\t\tindex = 5;\n\t\tbreak;\n\tcase Down:\n\t\tindex = 6;\n\t\tbreak;\n\tcase Right_Down:\n\t\tindex = 7;\n\t\tbreak;\n\t}\n\n\tnext_row = info.row+diff_row[index];\n\tnext_col = info.col+diff_col[index];\n\n\twhile(rangeCheck(next_row,next_col) == true && map[next_row][next_col] == 'X'){\n\t\tnext_row += diff_row[index];\n\t\tnext_col += diff_col[index];\n\t}\n\n\n\tif(next_row == info.row+diff_row[index] && next_col == info.col+diff_col[index]){\n\t\tret.row = 1;\n\t\tret.col = -1;\n\t}else{\n\t\tint tmp_row,tmp_col;\n\n\t\ttmp_row = info.row+diff_row[index];\n\t\ttmp_col = info.col+diff_col[index];\n\n\t\twhile(tmp_row != next_row || tmp_col != next_col){\n\t\t\tfor(int i = 0; i < ret.black_num;i++){\n\t\t\t\tif(ret.black_stone[i].erased == false && ret.black_stone[i].row == tmp_row && ret.black_stone[i].col == tmp_col){\n\t\t\t\t\tret.black_stone[i].erased = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp_row += diff_row[index];\n\t\t\ttmp_col += diff_col[index];\n\t\t}\n\n\t\tret.row = next_row;\n\t\tret.col = next_col;\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\n\tInfo first;\n\tfirst.black_num = 0;\n\tchar buf[15];\n\tint minimum = BIG_NUM,start_row,start_col;\n\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tif(buf[k] == 'O'){\n\t\t\t\tstart_row = i;\n\t\t\t\tstart_col = k;\n\t\t\t}else if(buf[k] == 'X'){\n\t\t\t\tfirst.black_stone[first.black_num++].set(i,k);\n\t\t\t}\n\t\t}\n\t}\n\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.count = 0;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().row >= 18){\n\t\t\tminimum = Q.front().count;\n\t\t\tbreak;\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 8; i++){\n\t\t\t\tInfo next = move(Q.front(),dir[i]);\n\n\t\t\t\tif(rangeCheck(next.row,next.col)){\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(minimum == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2612&lang=jp\n#define INF 1<<30\n#define H 19\n#define W 15\ntypedef long long ll;\ntypedef pair<int, int> pii;\nint ans = INF;\nint dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nint dy[8] = { 0,-1,-1,-1,0,1,1,1 };\n\nbool check(int x, int y, vector<vector<char>>& masu,int& dir) {\n\tint nx = x + dx[dir], ny = y + dy[dir];\n\tif (masu[nx][ny] != 'X')return false;\n\twhile (true) {\n\t\tnx += dx[dir]; ny += dy[dir];\n\t\tif (masu[nx][ny] == 'X')continue;\n\t\tif (masu[nx][ny] == '#')return false;\n\t\tif (masu[nx][ny] == '.')return true;\n\t}\n\treturn false;\n}\n\nvoid erase_move(int&x, int&y, vector<vector<char>>& masu, int& dir) {\n\twhile (true) {\n\t\tx += dx[dir]; y += dy[dir];\n\t\tif (masu[x][y] == 'X') {\n\t\t\tmasu[x][y] = '.';\n\t\t\tcontinue;\n\t\t}\n\t\tif (masu[x][y] == '.')return ;\n\t}\n}\n\nvoid dfs(int x, int y,int cnt,vector<vector<char>>& masu) {\n\tif (cnt + 1 >= ans) return;\n\tfor (int dir = 0; dir < 8; dir++) {\n\t\tif (!check(x, y, masu, dir))continue;\n\t\tauto new_masu = masu;\n\t\tint new_x = x, new_y = y;\n\t\terase_move(new_x,new_y, new_masu, dir);\n\t\t\n\t\tif (new_x >= 19) {\n\t\t\tans = min(ans, cnt + 1);\n\t\t\treturn;\n\t\t}\n\n\t\tdfs(new_x, new_y, cnt + 1, new_masu);\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tvector<vector<char>> masu(H + 2, vector<char>(W + 2,'#'));\n\tint sx, sy;\n\t/* input */\n\tmasu[H + 1][0] = masu[H + 1][W + 1] = '.';\n\tfor (int i = 1; i <= H+1; i++){\n\t\tfor (int j = 1; j <= W; j++){\n\t\t\tif (i == H + 1) masu[i][j] = '.';\n\t\t\telse {\n\t\t\t\tcin >> masu[i][j];\n\t\t\t\tif (masu[i][j] == 'O') { sx = i; sy = j; masu[i][j] = '.'; }\n\t\t\t}\n\t\t}\n\t}\n\tdfs(sx, sy, 0, masu);\n\tcout << (ans == INF ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<array>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n//変数\nconstexpr int H = 19;\nconstexpr int W = 15;\nint ans = INF;\n\n\nbool out(const int& count, const pair<int,int>& next)\n{\n\tint y = next.first;\n\tint x = next.second;\n\n\tif (x < 0)return true;\n\tif (y < 0)return true;\n\tif (14 < x)return true;\n\tif (18 < y) {\n\t\tans = min(ans, count);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint gap(pair<int, int> l, pair<int, int> r)\n{\n\tint a = abs(l.first - r.first);\n\tint b = abs(l.second - r.second);\n\treturn max(a, b);\n}\n\nbool goal(const pair<int, int> now)\n{\n\tif (now.first == H)return true;\n\tif (now.first == H - 1\n\t\t&& 0 <= now.second\n\t\t&& now.second < W)return true;\n\treturn false;\n}\n\nvoid step(\n\tconst array<array<bool,W>,H>& goban,\n\tconst pair<int,int>& now,\n\tconst int& count)\n{\n\tconstexpr int dirSiz = 8;\n\tconstexpr int dh[] = { -1,0,1,1,1,0,-1,-1 };\n\tconstexpr int dw[] = { 1,1,1,0,-1,-1,-1,0 };\n\tif (ans <= count)return;\n\n\t//visualize(goban, now);\n\n\tREP(i, dirSiz) {\n\t\tauto nextGoban = goban;\n\t\tauto next = now;\n\n\t\twhile (true) {\n\t\t\tnext.first += dh[i];\n\t\t\tnext.second += dw[i];\n\t\t\tif (out(count, next))break;\n\n\t\t\tif (nextGoban[next.first][next.second]) {\n\t\t\t\tnextGoban[next.first][next.second] = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (gap(now, next) <= 1) {\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tif (goal(next)) {\n\t\t\t\tans = min(ans, count);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!out(count, next)) {\n\t\t\t\t\t//visualize(goban, now);\n\t\t\t\t\tstep(nextGoban, next, count + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin >> N;\n}\n\n\n//メイン関数\nint main()\n{\n\tpair<int, int> start;\n\tarray<array<bool, W>, H> goban;\n\tREP(i, H) {\n\t\tstring tmp;\n\t\tarray<bool,W> row;\n\t\tcin >> tmp;\n\t\tREP(j,W){\n\t\t\tchar c = tmp[j];\n\t\t\trow[j] = (c == 'X');\n\t\t\tif (c == 'O')start = { i,j };\n\t\t}\n\t\tgoban[i] = row;\n\t}\n\n\tstep(goban, start, 1);\n\tif (ans == INF)ans = -1;\n\tcout << ans << endl;\n\n\tdebug();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nstring s[19];\nint bx[20],by[20];\nint id[19][15];\nint dx[8]={-1,-1,-1,0,1,1,1,0};\nint dy[8]={-1,0,1,1,1,0,-1,-1};\nint B;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nset<PP> st;\nbool is(int x,int y){\n\treturn 0<=x&&x<19&&0<=y&&y<15;\n}\nbool isX(int x,int y,int b){\n\treturn is(x,y)&&id[x][y]>=0&& ((b>>id[x][y])&1);\n}\nbool goal(int x,int y){\n\treturn x==19||(x==18&&is(x,y));\n}\nint main(){\n\trep(i,19) rep(j,15) id[i][j]=-1;\n\trep(i,19) cin>>s[i];\n\tint sx,sy;\n\trep(i,19) rep(j,15){\n\t\tif(s[i][j]=='O') sx=i,sy=j;\n\t\tif(s[i][j]=='X') bx[B]=i,by[B]=j,id[i][j]=B++;\n\t}\n\tqueue<int> qx,qy,qb,qd;\n\tqx.push(sx),qy.push(sy),qb.push((1<<B)-1),qd.push(0);\n\tst.insert(PP(P(sx,sy),(1<<B)-1));\n\twhile(!qx.empty()){\n\t\tint x=qx.front(),y=qy.front(),b=qb.front(),d=qd.front();\n\t\tqx.pop(),qy.pop(),qb.pop(),qd.pop();\n\t\trep(di,8){\n\t\t\tint nx=x+dx[di],ny=y+dy[di],nb=b,nd=d+1;\n\t\t\tif(!isX(nx,ny,nb)) continue;\n\t\t\twhile(isX(nx,ny,nb)){\n\t\t\t\tnb^=(1<<id[nx][ny]);\n\t\t\t\tnx+=dx[di],ny+=dy[di];\n\t\t\t}\n\t\t\tif(goal(nx,ny)){\n\t\t\t\tcout<<nd<<endl;\n\t\t\t\treturn 0;\n\t\t\t}else if(is(nx,ny)&&st.find(PP(P(nx,ny),nb))==st.end()){\n\t\t\t\tqx.push(nx),qy.push(ny),qb.push(nb),qd.push(nd);\n\t\t\t\tst.insert(PP(P(nx,ny),nb));\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> Q;\n\nconst int INF = 100000000;\n\nchar d[19][16];\n\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\n\nbool out(int x, int y) {\n  return x < 0 || y < 0 || x >= 15 || y >= 19;\n}\n\nbool goal(int x, int y) {\n  return y >= 19;\n}\n\nbool black(int x, int y) {\n  return d[y][x] == 'X';\n}\n\nvoid ret(int x, int y, int X, int Y, int j) {\n  x += dx[j], y += dy[j];\n  while (!(x == X && y == Y)) {\n    d[y][x] = 'X';\n    x += dx[j], y += dy[j];\n  }\n}\n\nint solve(int X, int Y, int counter) {\n  counter++;\n  int ans = INF;\n  for (int i = 0; i < 8; i++) {\n    int x = X + dx[i], y = Y + dy[i];\n    if (out(x, y)) continue;\n    if (!black(x, y)) continue;\n    while (!out(x, y) && black(x, y)) {\n      d[y][x] = '.';\n      x += dx[i], y += dy[i];\n    }\n    if (goal(x, y)) {\n      ret(x, y, X, Y, (i + 4) % 8);\n      return counter;\n    }\n    if (out(x, y)) {\n      ret(x, y, X, Y, (i + 4) % 8);\n      continue;\n    }\n    ans = min(ans, solve(x, y, counter));\n    ret(x, y, X, Y, (i + 4) % 8);\n  }\n  return ans;\n}\n\nint main() {\n  for (int i = 0; i < 19; i++) scanf(\"%s\", d[i]);\n  int x, y;\n  for (int i = 0; i < 19; i++) {\n    for (int j = 0; j < 15; j++) {\n      if (d[i][j] == 'O') {\n        d[i][j] = '.';\n        x = j, y = i;\n        i = 19,j = 16;\n      }\n    }\n  }\n  int ans = solve(x, y, 0);\n  if (ans == INF) ans = -1;\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<=(b);i++)\n#define P(T1,T2) pair<T1,T2>\n#define MP(a,b) make_pair((a),(b))\n#define NUM_Y 19\n#define NUM_X 15\n\nchar MAP[NUM_Y][NUM_X] = {};\nint TMP_X[8] = { 1,1,1,0,0,-1,-1,-1 };\nint TMP_Y[8] = { -1,0,1,-1,1,-1,0,1 };\nint goal_cnt = 99999;\n\nvoid show()\n{\n\tREP(i, NUM_Y)\n\t{\n\t\tREP(j, NUM_X)\n\t\t{\n\t\t\tcout << MAP[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nvoid BFS(int _sy, int _sx)\n{\n\n\tstruct Data\n\t{\n\t\tData(int _x, int _y, int _c, bool _j) :x(_x), y(_y), c(_c), j(_j) {};\n\t\tint x = 0, y = 0;\n\t\tint c = 0;\n\t\tbool j = false;\n\t};\n\n\tstack<Data> que;\n\tque.push(Data(_sx, _sy, 0, false));\n\n\twhile (que.empty() == false)\n\t{\n\t\tint y = que.top().y;\n\t\tint x = que.top().x;\n\t\tint c = que.top().c;\n\t\tbool j = que.top().j;\n\t\tque.pop();\n\t\t\n\t\tREP(i, 8)\n\t\t{\n\t\t\tint xx = x + TMP_X[i];\n\t\t\tint yy = y + TMP_Y[i];\n\n\t\t\tif (yy < 0 || yy >= NUM_Y || xx < 0 || xx >= NUM_X)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\telse if (MAP[yy][xx] == '.')\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\telse if (MAP[yy][xx] == 'X')\n\t\t\t{\n\t\t\t\tMAP[y][x] = '.';\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tyy += TMP_Y[i];\n\t\t\t\t\txx += TMP_X[i];\n\t\t\t\t\tif (yy >= NUM_Y)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (goal_cnt > c+1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgoal_cnt = c+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (yy < 0 || xx < 0 || xx >= NUM_X)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (MAP[yy][xx] == 'X')\n\t\t\t\t\t{\n\t\t\t\t\t\tMAP[yy - TMP_Y[i]][xx - TMP_X[i]] = '.';\n\t\t\t\t\t}\n\t\t\t\t\telse if(MAP[yy][xx]=='.')\n\t\t\t\t\t{\n\t\t\t\t\t\tMAP[yy - TMP_Y[i]][xx - TMP_X[i]] = '.';\n\t\t\t\t\t\tMAP[yy][xx] = 'O';\n\t\t\t\t\t\tque.push(Data(xx, yy, c+1, false));\n\t\t\t\t\t\ti = 999;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tshow();\n\t}\n}\n\nint main()\n{\n\tint sx, sy;\n\tREP(y, 19)\n\t{\n\t\tREP(x, 15)\n\t\t{\n\t\t\tcin >> MAP[y][x];\n\t\t\tif (MAP[y][x] == 'O')\n\t\t\t{\n\t\t\t\tsy = y;\n\t\t\t\tsx = x;\n\t\t\t}\n\t\t}\n\t}\n\n\tBFS(sy, sx);\n\n\tif (goal_cnt == 99999)cout << -1 << endl;\n\telse cout << goal_cnt << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst char h = 20, w = 17;\nvector<vector<bool>> c;\ntypedef tuple<pair<char, char>, vector<vector<bool>>, char> T;\nqueue<T> q;\nmap<vector<vector<bool>>, vector<vector<char>>> memo;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint main(){\n\tc = vector<vector<bool>>(h, vector<bool>(w,0));\n\n\tpair<char, char> s;\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tchar a;\n\t\t\tcin >> a;\n\t\t\tif(a == 'X') c[i][j + 1] = 1;\n\t\t\telse c[i][j + 1] = 0;\n\t\t\tif(a == 'O'){\n\t\t\t\ts = make_pair(i,j + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tq.push(T(s,c,0));\n\n\tchar ans = 127;\n\twhile(not q.empty()){\n\t\tchar cost;\n\t\ttie(s,c,cost) = q.front(); q.pop();\n\n\t\tchar y, x;\n\t\ttie(y,x) = s;\n\n\t\t//rep(i,h){ rep(j,w){ if(i == y and j == x) cout << 'O'; else cout << c[i][j]; } cout << endl; } cout << endl;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(cost >= 20) continue;\n\n\t\trep(i,8){\n\t\t\tchar ny = y + dy[i];\n\t\t\tchar nx = x + dx[i];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)) continue;\n\t\t\tvector<vector<bool>> pc = c;\n\t\t\tif(pc[ny][nx] == 1){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pc[ny][nx] == 0) break;\n\t\t\t\t\tpc[ny][nx] = 0;\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tif(memo.count(pc)){\n\t\t\t\t\tauto& it = memo[pc];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<char>> dis(h, vector<char>(w,127));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[pc] = dis;\n\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == 127 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 19;\nconst int W = 15;\nvector<string> board(H);\nvector<int> xhs, xws;\nint d[1<<20][H][W];\n\nstruct State{\n    int xstate;\n    unsigned char h, w;\n    \n//    bool operator < (const State &r) const{\n//        int xl = xstate * H * W + h * W + w;\n//        int xr = r.xstate * H * W + r.h * W + r.w;\n//        return xl < xr;\n//    }\n};\n\ninline bool infield(int h, int w){\n    if(h == H)\n        return true;\n    else\n        return 0<=w && w<W;\n}\n\nint bfs(int sh, int sw){\n    int xn = xhs.size();\n    map<pair<int, int>, int> ipoint;\n    for(int i=0; i<xn; i++)\n        ipoint[{xhs[i], xws[i]}] = i;\n    \n    queue<State> que;\n    State s;\n    s.xstate = (1<<xn)-1;\n    s.h = sh;\n    s.w = sw;\n    que.push(s);\n    \n    memset(d, -1, sizeof(d));\n    d[s.xstate][s.h][s.w] = 0;\n    \n    while(!que.empty()){\n        auto s = que.front(); que.pop();\n        \n        for(int dh=-1; dh<=1; dh++){\n            for(int dw=-1; dw<=1; dw++) if(dh != 0 || dw != 0){\n                State ns;\n                ns.xstate = s.xstate;\n                ns.h = s.h + dh;\n                ns.w = s.w + dw;\n                \n                if(ipoint.find({ns.h, ns.w}) == ipoint.end() || ((ns.xstate>>ipoint[{ns.h, ns.w}])&1) == 0)\n                    continue;\n                \n                int count = 0;\n                while(infield(ns.h, ns.w) && ipoint.find({ns.h, ns.w})!= ipoint.end() && (ns.xstate>>ipoint[{ns.h, ns.w}])&1){\n                    ns.h += dh;\n                    ns.w += dw;\n                    count++;\n                }\n                if(!infield(ns.h, ns.w))\n                    continue;\n                \n                ns.h = s.h + dh;\n                ns.w = s.w + dw;\n                for(int i=0; i<count; i++){\n                    ns.xstate -= 1<<ipoint[{ns.h, ns.w}];\n                    ns.h += dh;\n                    ns.w += dw;\n                }\n                \n                if(d[ns.xstate][ns.h][ns.w] >= 0)\n                    continue;\n                \n                que.push(ns);\n                d[ns.xstate][ns.h][ns.w] = d[s.xstate][s.h][s.w] + 1;\n                \n                if(H-1<=ns.h){\n                    return d[ns.xstate][ns.h][ns.w];\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    for(auto &s: board) cin >> s;\n    \n    int sh, sw;\n    for(int h=0; h<H; h++){\n        for(int w=0; w<W; w++){\n            if(board[h][w] == 'O')\n                sh = h, sw = w;\n            if(board[h][w] == 'X')\n                xhs.push_back(h), xws.push_back(w);\n        }\n    }\n    cout << bfs(sh, sw) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H=19,W=15;\n\nenum DIR{\n    Left_Up,\n    Up,\n    Right_Up,\n    Left,\n    Right,\n    Left_Down,\n    Down,\n    Right_Down,\n};\n\nDIR dir[8] = {Left_Up,Up,Right_Up,Left,Right,Left_Down,Down,Right_Down};\n\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\n\nstruct BlackStone{\n    BlackStone(){\n        row = col = 0;\n    }\n\n    BlackStone(short arg_row,short arg_col){\n        row = arg_row;\n        col = arg_col;\n    }\n    short row,col;\n};\n\nstruct Info{\n    vector<BlackStone> BLACK_STONE;\n    short row,col,count;\n};\n\nbool rangeCheck(short row,short col){\n    if(row <= 17){\n        if(col < 0 || col > 14){\n            return false;\n        }else{\n            return true;\n        }\n    }else{ //row >= 18\n        if(row == 18 && (col < 0 || col > 14)){\n            return false;\n        }else{\n            return true;\n        }\n    }\n}\n\nInfo move(Info info,DIR dir){\n    Info ret;\n\n    char map[19][15];\n    for(int i = 0; i < H; i++){\n        for(int k = 0; k < W; k++)map[i][k] = '.';\n    }\n\n    for(int i = 0; i < info.BLACK_STONE.size(); i++){\n        map[info.BLACK_STONE[i].row][info.BLACK_STONE[i].col] = 'X';\n    }\n    ret.count = info.count+1;\n\n    int next_row,next_col,index;\n\n    switch(dir){\n    case Left_Up:\n        index = 0;\n        break;\n    case Up:\n        index = 1;\n        break;\n    case Right_Up:\n        index = 2;\n        break;\n    case Left:\n        index = 3;\n        break;\n    case Right:\n        index = 4;\n        break;\n    case Left_Down:\n        index = 5;\n        break;\n    case Down:\n        index = 6;\n        break;\n    case Right_Down:\n        index = 7;\n        break;\n    }\n\n    next_row = info.row+diff_row[index];\n    next_col = info.col+diff_col[index];\n\n    while(rangeCheck(next_row,next_col) == true && map[next_row][next_col] == 'X'){\n        next_row += diff_row[index];\n        next_col += diff_col[index];\n    }\n\n\n    if(next_row == info.row+diff_row[index] && next_col == info.col+diff_col[index]){\n        ret.row = 1;\n        ret.col = -1;\n    }else{\n\n        if(rangeCheck(next_row,next_col) == true && next_row <= 18){\n\n        \tfor(int i = 0; i < info.BLACK_STONE.size();i++){\n        \t\tret.BLACK_STONE.push_back(info.BLACK_STONE[i]);\n        \t}\n\n            int tmp_row,tmp_col;\n\n            tmp_row = info.row+diff_row[index];\n            tmp_col = info.col+diff_col[index];\n\n            while(tmp_row != next_row || tmp_col != next_col){\n                for(int i = 0; i < ret.BLACK_STONE.size();i++){\n                    if(ret.BLACK_STONE[i].row == tmp_row && ret.BLACK_STONE[i].col == tmp_col){\n                        ret.BLACK_STONE.erase(ret.BLACK_STONE.begin()+i);\n                        break;\n                    }\n                }\n                tmp_row += diff_row[index];\n                tmp_col += diff_col[index];\n            }\n        }\n\n        ret.row = next_row;\n        ret.col = next_col;\n    }\n\n    return ret;\n}\n\nint main(){\n\n    Info first;\n\n    char buf[15];\n    int minimum = BIG_NUM,start_row,start_col,num;\n    bool FLG = true;\n\n    for(short i = 0; i < H; i++){\n        scanf(\"%s\",buf);\n        if(i == 17){\n        \tnum = 0;\n        }\n        for(short k = 0; k < W; k++){\n            if(buf[k] == 'O'){\n                start_row = i;\n                start_col = k;\n            }else if(buf[k] == 'X'){\n                first.BLACK_STONE.push_back(BlackStone(i,k));\n            }\n            if((i == 17 || i == 18) && buf[k] == 'X')num++;\n        }\n        if(i == 18 && num == 0){\n        \tFLG = false;\n        }\n    }\n\n    if(!FLG){\n    \tprintf(\"-1\\n\");\n    \treturn 0;\n    }\n\n    first.row = start_row;\n    first.col = start_col;\n    first.count = 0;\n\n    queue<Info> Q;\n    Q.push(first);\n\n    while(!Q.empty()){\n\n        if(Q.front().row >= 18){\n            minimum = Q.front().count;\n            break;\n        }else{\n\n            for(int i = 0; i < 8; i++){\n            \tInfo next = move(Q.front(),dir[i]);\n\n                if(rangeCheck(next.row,next.col)){\n                    Q.push(next);\n                }\n            }\n\n            Q.pop();\n        }\n    }\n\n    if(minimum == BIG_NUM){\n        printf(\"-1\\n\");\n    }else{\n        printf(\"%d\\n\",minimum);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<map>\nusing namespace std;\nchar str[31][31];\nint dx[]={1,1,1,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nmap<pair<int,pair<int,int> > ,int> m;\nint x[21];\nint y[21];\nint fi[31][31];\nint sz;\nint solve(int bit,int row,int col){\n\tif(row>=18)return 0;\n\tif(m.count(make_pair(bit,make_pair(row,col))))return m[make_pair(bit,make_pair(row,col))];\n\tint ret=99999999;\n\tfor(int i=0;i<8;i++){\n\t\tint nr=row+dx[i];\n\t\tint nc=col+dy[i];\n\t\tint tb=bit;\n\t\twhile(0<=nr&&nr<=18&&0<=nc&&nc<=14){\n\t\t\tif(!~fi[nr][nc]||!(bit&(1<<fi[nr][nc])))break;\n\t\t\ttb-=(1<<(fi[nr][nc]));\n\t\t\tnr+=dx[i];nc+=dy[i];\n\t\t}\n\t\tif(nr-dx[i]==row&&nc-dy[i]==col)continue;\n\t\tif(nr<19&&(nc<0||nc>=15))continue;\n\t\tret=min(ret,solve(tb,nr,nc)+1);\n\t}\n\treturn m[make_pair(bit,make_pair(row,col))]=ret;\n}\nint main(){\n\tfor(int i=0;i<19;i++)scanf(\"%s\",str[i]);\n\tint row=0;\n\tint col=0;\n\tfor(int i=0;i<31;i++)for(int j=0;j<31;j++)fi[i][j]=-1;\n\tfor(int i=0;i<19;i++)for(int j=0;j<15;j++){\n\t\tif(str[i][j]=='O'){row=i;col=j;}\n\t\tif(str[i][j]=='X'){\n\t\t\tfi[i][j]=sz;\n\t\t\tx[sz]=i;y[sz]=j;sz++;\n\t\t}\n\t}\n\tint ret=solve((1<<sz)-1,row,col);\n\tif(ret>99999)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst char h = 20, w = 17;\nvector<vector<bool>> c;\ntypedef tuple<pair<char, char>, vector<vector<bool>>, char> T;\nqueue<T> q;\nmap<vector<vector<bool>>, vector<vector<char>>> memo;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint main(){\n\tc = vector<vector<bool>>(h, vector<bool>(w,0));\n\n\tpair<char, char> s;\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tchar a;\n\t\t\tcin >> a;\n\t\t\tif(a == 'X') c[i][j + 1] = 1;\n\t\t\telse c[i][j + 1] = 0;\n\t\t\tif(a == 'O'){\n\t\t\t\ts = make_pair(i,j + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tq.push(T(s,c,0));\n\n\tchar ans = 127;\n\twhile(not q.empty()){\n\t\tchar cost;\n\t\ttie(s,c,cost) = q.front(); q.pop();\n\n\t\tchar y, x;\n\t\ttie(y,x) = s;\n\n\t\t//rep(i,h){ rep(j,w){ if(i == y and j == x) cout << 'O'; else cout << c[i][j]; } cout << endl; } cout << endl;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(i,8){\n\t\t\tchar ny = y + dy[i];\n\t\t\tchar nx = x + dx[i];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)) continue;\n\t\t\tvector<vector<bool>> pc = c;\n\t\t\tif(pc[ny][nx] == 1){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pc[ny][nx] == 0) break;\n\t\t\t\t\tpc[ny][nx] = 0;\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tif(memo.count(pc)){\n\t\t\t\t\tauto& it = memo[pc];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<char>> dis(h, vector<char>(w,127));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[pc] = dis;\n\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == 127 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct S {\n\tint x, y, mask;\n\tll hash() {\n\t\treturn x + 15 * y + mask * (1LL << 30);\n\t}\n};\n\nint b[19][15];\n\nint dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 };\nint dy[8] = { 0, 1, 0, -1, 1, -1, 1, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < 15 && 0 <= y && y < 19;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint B = 0;\n\tint sx = -1, sy = -1;\n\tmemset(b, -1, sizeof b);\n\tfor(int i = 0; i < 19; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j < 15; j++) {\n\t\t\tif(s[j] == 'O') sx = j, sy = i;\n\t\t\tif(s[j] == 'X') {\n\t\t\t\tb[i][j] = B++;\n\t\t\t}\n\t\t}\n\t}\n\n\tunordered_map<ll, int> dp;\n\tS is = { sx, sy, 0 };\n\tdp[is.hash()] = 0;\n\n\tqueue<S> q;\n\tq.push(is);\n\twhile(q.size()) {\n\t\tint x = q.front().x, y = q.front().y, mask = q.front().mask;\n\t\tint t = dp[q.front().hash()];\n\t\tq.pop();\n\t\tfor(int k = 0; k < 8; k++) {\n\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\tif(!in(nx, ny)) continue;\n\t\t\tint id = b[ny][nx];\n\t\t\tif(id == -1) continue;\n\t\t\tif(mask >> id & 1) continue;\n\t\t\t//cerr << \"nx : \" << nx << \", ny : \" << ny << endl;\n\t\t\tint nmask = mask;\n\t\t\twhile(1) {\n\t\t\t\tnmask |= 1 << id;\n\t\t\t\tnx += dx[k], ny += dy[k];\n\t\t\t\tif(!in(nx, ny)) break;\n\t\t\t\tid = b[ny][nx];\n\t\t\t\tif(id == -1 || (mask >> id & 1)) break;\n\t\t\t}\n\t\t\tif(ny >= 19) {\n\t\t\t\tcout << t + 1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(in(nx, ny)) {\n\t\t\t\tS ns = { nx, ny, nmask };\n\t\t\t\tif(dp.count(ns.hash()) == 0) {\n\t\t\t\t\tdp[ns.hash()] = t + 1;\n\t\t\t\t\tq.push(ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nsigned main(){\n  string s[19];\n  for(int i=0;i<19;i++) cin>>s[i];\n\n  int sy,sx;\n  vector<int> v;\n  for(int i=0;i<19;i++){\n    for(int j=0;j<15;j++){\n      if(s[i][j]=='O') sy=i,sx=j;\n      if(s[i][j]=='X') v.push_back(i*15+j);\n    }\n  }\n  \n  int n=v.size();\n  int sb=(sy*15+sx)<<n;\n  \n  map<int,int> m;\n  for(int i=0;i<n;i++) m[v[i]]=i;\n\n  int ax[]={-1,-1,-1,0,0,1,1,1};\n  int ay[]={-1,0,1,-1,1,-1,0,1};\n  \n  int ans=-1,mask=(1<<n)-1;\n  priority_queue<P> q;\n  q.push(P(0,sb));\n  map<int,int> ms;\n  ms[sb]=0;\n  \n  while(!q.empty()){\n    P p=q.top();q.pop();\n    int d=-p.first,b=p.second;\n    int cy=(b>>n)/15,cx=(b>>n)%15;\n    //cout<<(b>>n)<<\" \"<<cy<<\" \"<<cx<<\" \"<<d<<endl;\n    if(ms[b]<d) continue;\n    for(int k=0;k<8;k++){\n      int ny=cy+ay[k],nx=cx+ax[k],nb=b&mask,nd=d+1;\n      if(!m.count(ny*15+nx)) continue;\n      //cout<<ny<<\" \"<<nx<<\" \"<<nb<<\" \"<<nd<<endl;\n      if(nb&(1<<m[ny*15+nx])) continue;\n      while(m.count(ny*15+nx)){\n\tif(nb&(1<<m[ny*15+nx])) break;\n\t//cout<<n<<\":\"<<m[ny*15+nx]<<\" \"<<nb<<\" \"<<(1<<m[ny*15+nx])<<endl;\n\tnb+=1<<m[ny*15+nx];\n\tny+=ay[k];\n\tnx+=ax[k];\n      }\n      //cout<<ny<<\" \"<<nx<<\" \"<<ny*15+nx<<\" \"<<nb<<endl;\n      if(ny>=18){\n\tans=nd;\n\tgoto END;\n      }\n      if(ny<0||nx<0||nx>=15) continue;\n      nb+=(ny*15+nx)<<n;\n      //cout<<nb<<\" \"<<(nb&mask)<<\" \"<<(nb>>n)<<endl;\n      if(ms.count(nb)&&ms[nb]<=nd) continue;\n      ms[nb]=nd;\n      q.push(P(-nd,nb));\n    }\n  }\n END:\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\n//const int dx[] = { -1, 0, 0, 1 }, dy[] = { 0, -1, 1, 0 };\nconst int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }, dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\nconst int h = 19, w = 15;\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tvs fld(h);\n\tREP(i, h) cin >> fld[i];\n\tvector<vi> id(h, vi(w, -1));\n\tvector<pii> place;\n\tint cnt = 0;\n\tpii init;\n\tREP(i, h)REP(j, w)\n\t{\n\t\tif (fld[i][j] == '.') continue;\n\t\tif (fld[i][j] == 'O')\n\t\t{\n\t\t\tinit = pii(i, j);\n\t\t\tfld[i][j] = '.';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tid[i][j] = cnt;\n\t\t\tplace.push_back(pii(i, j));\n\t\t\tcnt++;\n\t\t}\n\t}\n\tmap<pair<int, pii>, int> mp;\n\tqueue<pair<int, pii>> que;\n\tque.emplace(0, init);\n\twhile (!que.empty())\n\t{\n\t\tauto tmp = que.front(); que.pop();\n\t\tint bit = tmp.first, tx = tmp.second.first, ty = tmp.second.second;\n\t\t//cout << bitset<20>(bit) << \" \" << tx << \" \" << ty << endl;\n\t\tif (tx >= h - 1)\n\t\t{\n\t\t\tcout << mp[tmp] << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tREP(i, 8)\n\t\t{\n\t\t\tint nx = tx + dx[i], ny = ty + dy[i];\n\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny] == '.' || (bit >> id[nx][ny]) & 1) continue;\n\t\t\tvi remove;\n\t\t\twhile (valid(nx, ny, h, w) && fld[nx][ny] != '.' && ((bit >> id[nx][ny]) & 1) == 0)\n\t\t\t{\n\t\t\t\tremove.push_back(id[nx][ny]);\n\t\t\t\tnx += dx[i], ny += dy[i];\n\t\t\t}\n\t\t\tif (!valid(nx,ny,h,w) && nx != h) continue;\n\t\t\tint nbit = bit;\n\t\t\tfor (auto j : remove) nbit |= 1 << j;\n\t\t\tpair<int, pii> nex(nbit, pii(nx, ny));\n\t\t\tif (mp.count(nex)) continue;\n\t\t\tmp[nex] = mp[tmp] + 1;\n\t\t\tque.push(nex);\n\t\t}\n\t}\n\tcout << -1 << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=55,INF=1<<30;\nint ans=-1;\nint H=20,W=17;\n\nvector<int> dh={-1,0,1,1,1,0,-1,-1},dw={1,1,1,0,-1,-1,-1,0};\n\nset<vector<pair<int,int>>> SE;\n\nvoid BFS(vector<pair<int,int>> &s){\n    queue<pair<vector<pair<int,int>>,int>> Q;\n    Q.push(mp(s,0));\n    \n    while(!Q.empty()){\n        auto a=Q.front();Q.pop();\n        \n        if(SE.count(a.fi)) continue;\n        SE.insert(a.fi);\n        \n        vector<string> S(H,string(W,'.'));\n        \n        int sh,sw;\n        \n        for(auto x:a.fi){\n            if(x.fi>=100){\n                S[x.fi-100][x.se-100]='O';\n                sh=x.fi-100;\n                sw=x.se-100;\n            }\n            else S[x.fi][x.se]='X';\n        }\n        \n        for(int j=0;j<W;j++){\n            if(S[H-1][j]=='O'){\n                ans=a.se;\n                while(!Q.empty()) Q.pop();\n            }\n            if(j>=1&&j<=15&&S[H-2][j]=='O'){\n                ans=a.se;\n                while(!Q.empty()) Q.pop();\n            }\n        }\n        if(ans!=-1) break;\n        \n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(S[i][j]=='O'){\n                    sh=i;\n                    sw=j;\n                }\n            }\n        }\n        \n        if(sw==0||sw==W-1) continue;\n        \n        for(int k=0;k<8;k++){\n            int toh=sh+dh[k],tow=sw+dw[k];\n            while(toh>=0&&toh<H&&tow>=0&&tow<W&&S[toh][tow]=='X'){\n                toh+=dh[k];\n                tow+=dw[k];\n            }\n            if(toh==sh+dh[k]&&tow==sw+dw[k]) continue;\n            \n            vector<string> T=S;\n            T[sh][sw]='.';\n            toh=sh+dh[k];tow=sw+dw[k];\n            while(toh>=0&&toh<H&&tow>=0&&tow<W&&S[toh][tow]=='X'){\n                T[toh][tow]='.';\n                toh+=dh[k];\n                tow+=dw[k];\n            }\n            T[toh][tow]='O';\n            \n            vector<pair<int,int>> to;\n            \n            for(int i=0;i<H;i++){\n                for(int j=0;j<W;j++){\n                    char c=T[i][j];\n                    if(c=='O') to.push_back(mp(100+i,100+j));\n                    if(c=='X') to.push_back(mp(i,j));\n                }\n            }\n            \n            Q.push(mp(to,a.se+1));\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    vector<pair<int,int>> s;\n    for(int i=0;i<19;i++){\n        for(int j=1;j<=15;j++){\n            char c;cin>>c;\n            if(c=='O') s.push_back(mp(100+i,100+j));\n            if(c=='X') s.push_back(mp(i,j));\n        }\n    }\n    \n    BFS(s);\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nsigned main(){\n  string s[19];\n  for(int i=0;i<19;i++) cin>>s[i];\n\n  int sy,sx;\n  vector<int> v;\n  for(int i=0;i<19;i++){\n    for(int j=0;j<15;j++){\n      if(s[i][j]=='O') sy=i,sx=j;\n      if(s[i][j]=='X') v.push_back(i*15+j);\n    }\n  }\n  \n  int n=v.size();\n  int sb=(sy*15+sx)<<n;\n  \n  map<int,int> m;\n  for(int i=0;i<n;i++) m[v[i]]=i;\n\n  int ax[]={-1,-1,-1,0,0,1,1,1};\n  int ay[]={-1,0,1,-1,1,-1,0,1};\n  \n  int ans=-1,mask=(1<<n)-1;\n  priority_queue<P> q;\n  q.push(P(0,sb));\n  map<int,int> ms;\n  ms[sb]=0;\n  \n  while(!q.empty()){\n    P p=q.top();q.pop();\n    int d=-p.first,b=p.second;\n    int cy=(b>>n)/15,cx=(b>>n)%15;\n    //cout<<(b>>n)<<\" \"<<cy<<\" \"<<cx<<\" \"<<d<<endl;\n    if(ms[b]<d) continue;\n    for(int k=0;k<8;k++){\n      int ny=cy+ay[k],nx=cx+ax[k],nb=b&mask,nd=d+1;\n      if(!m.count(ny*15+nx)) continue;\n      //cout<<ny<<\" \"<<nx<<\" \"<<nb<<\" \"<<nd<<endl;\n      if(nb&(1<<m[ny*15+nx])) continue;\n      while(m.count(ny*15+nx)){\n\tif(nb&(1<<m[ny*15+nx])) break;\n\t//cout<<n<<\":\"<<m[ny*15+nx]<<\" \"<<nb<<\" \"<<(1<<m[ny*15+nx])<<endl;\n\tnb+=1<<m[ny*15+nx];\n\tny+=ay[k];\n\tnx+=ax[k];\n      }\n      //cout<<ny<<\" \"<<nx<<\" \"<<ny*15+nx<<\" \"<<nb<<endl;\n      if(ny>=19){\n\tans=nd;\n\tgoto END;\n      }\n      if(ny<0||nx<0||nx>=15) continue;\n      nb+=(ny*15+nx)<<n;\n      //cout<<nb<<\" \"<<(nb&mask)<<\" \"<<(nb>>n)<<endl;\n      if(ms.count(nb)&&ms[nb]<=nd) continue;\n      ms[nb]=nd;\n      q.push(P(-nd,nb));\n    }\n  }\n END:\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n//変数\nconstexpr int H = 19;\nconstexpr int W = 15;\nint ans = INF;\n\n\nvoid visualize(const vector<vector<bool>>& goban, pair<int, int> now)\n{\n\tcerr << \"===================\" << endl;\n\tcerr << now.first << \":::\" << now.second << endl;\n\tREP(i, H){\n\t\tREP(j, W) {\n\t\t\tif (now.first == i && now.second == j)cerr << \"o\";\n\t\t\telse cerr << (goban[i][j] ? \"X\" : \".\");\n\t\t}\n\t\tcerr << endl;\n\t}\n\tcerr << \"===================\" << endl;\n}\n\nbool out(const int& count, const pair<int,int>& next)\n{\n\tint y = next.first;\n\tint x = next.second;\n\n\tif (x < 0)return true;\n\tif (y < 0)return true;\n\tif (14 < x)return true;\n\tif (18 < y) {\n\t\tans = min(ans, count);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint gap(pair<int, int> l, pair<int, int> r)\n{\n\tint a = abs(l.first - r.first);\n\tint b = abs(l.second - r.second);\n\treturn max(a, b);\n}\n\nbool goal(const pair<int, int> now)\n{\n\tif (now.first == H)return true;\n\tif (now.first == H - 1\n\t\t&& 0 <= now.second\n\t\t&& now.second < W)return true;\n\treturn false;\n}\n\nvoid step(\n\tconst vector<vector<bool>>& goban,\n\tconst pair<int,int>& now,\n\tconst int& count)\n{\n\tconstexpr int dirSiz = 8;\n\tconstexpr int dh[] = { -1,0,1,1,1,0,-1,-1 };\n\tconstexpr int dw[] = { 1,1,1,0,-1,-1,-1,0 };\n\tif (ans <= count)return;\n\n\t//visualize(goban, now);\n\n\tREP(i, dirSiz) {\n\t\tauto nextGoban = goban;\n\t\tauto next = now;\n\n\t\twhile (true) {\n\t\t\tnext.first += dh[i];\n\t\t\tnext.second += dw[i];\n\t\t\tif (out(count, next))break;\n\n\t\t\tif (nextGoban[next.first][next.second]) {\n\t\t\t\tnextGoban[next.first][next.second] = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (gap(now, next) <= 1) {\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tif (goal(next)) {\n\t\t\t\tans = min(ans, count);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!out(count, next)) {\n\t\t\t\t\t//visualize(goban, now);\n\t\t\t\t\tstep(nextGoban, next, count + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin >> N;\n}\n\n\n//メイン関数\nint main()\n{\n\tpair<int, int> start;\n\tvector<vector<bool>> goban;\n\tREP(i, H) {\n\t\tstring tmp;\n\t\tvector<bool> row;\n\t\tcin >> tmp;\n\t\tREP(j,W){\n\t\t\tchar c = tmp[j];\n\t\t\trow.push_back(c == 'X');\n\t\t\tif (c == 'O')start = { i,j };\n\t\t}\n\t\tgoban.push_back(row);\n\t}\n\n\tstep(goban, start, 1);\n\tif (ans == INF)ans = -1;\n\tcout << ans << endl;\n\n\tdebug();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <deque>\n#include <tuple>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;//B,x,y\ntypedef tuple<int,int,int,int> T4;//d,B,x,y\n\nint main(){\n    int board[15][20];\n    fill(board[0],board[15],-1);\n    int ox,oy,B=0;\n    for(int i=0;i<19;i++){\n        for(int j=0;j<15;j++){\n            char c;\n            cin>>c;\n            if(c=='O'){\n                oy=i; ox=j;\n            }else if(c=='X'){\n                board[j][i]=B++;\n            }\n        }\n    }\n    /*\n    for(int i=0;i<20;i++){\n        for(int j=0;j<15;j++){\n            if(board[j][i]==-1) cout<<'.';\n            else cout<<board[j][i];\n        }\n        cout<<endl;\n    }\n    */\n    deque<T4> que;\n    que.emplace_back(0,(1<<B)-1,ox,oy);\n    while(!que.empty()){\n        int d,bb,x,y;\n        tie(d,bb,x,y)=que.front(); que.pop_front();\n        // cout<<d<<' '<<bb<<' '<<x<<' '<<y<<endl;\n        if(y>=18){\n            cout<<d<<endl;\n            return 0;\n        }\n        if(y<-1||x<0||x>=15) continue;\n        for(int dy=-1;dy<=1;dy++){\n            for(int dx=-1;dx<=1;dx++){\n                if(!dx&&!dy)continue;\n                if(x+dx<0||x+dx>=15||y+dy<0||y+dy>=19) continue;\n                if(board[x+dx][y+dy]==-1) continue;\n                else{\n                    if(bb&(1<<board[x+dx][y+dy])){\n                        int l=2;\n                        int bbb=bb^(1<<board[x+dx][y+dy]);\n                        while(true){\n                            if(x+dx*l<0||x+dx*l>=15||y+dy*l<0||y+dy*l>=19){\n                                break;\n                            }else{\n                                if(board[x+dx*l][y+dy*l]==-1){\n                                    break;\n                                }else{\n                                    if((1<<board[x+dx*l][y+dy*l])&bbb){\n                                        bbb^=1<<board[x+dx*l][y+dy*l];\n                                        l++;\n                                        continue;\n                                    }else{\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        que.emplace_back(d+1,bbb,x+dx*l,y+dy*l);\n                    }\n                }\n            }\n        }\n\n    }\n    cout<<-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 30;\n\nmap<pair<int,int>, int8_t> memo;\n\nint8_t dfs(const vector<vector<int>> &idx, int i, int j) {\n  auto itr = memo.find(make_pair(i, j));\n  if (itr != end(memo)) return itr->second;\n  if (j == 15*19) return 0;\n  int oi = j/15;\n  int oj = j%15;\n  int di[8] = {1, 1, 1, 0, -1, -1, -1, 0};\n  int dj[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\n  int8_t res = INF;\n  REP(k,8) {\n    int l = 1;\n    vector<int> ei;\n    int ni;\n    int nj;\n    while (1) {\n      ni = oi + l*di[k];\n      nj = oj + l*dj[k];\n      if (ni < 0 || ni >= 19 || nj < 0 || nj >= 15) break;\n      if (idx[ni][nj] < 0 || ((i>>idx[ni][nj])&1)) break;\n      ei.push_back(idx[ni][nj]);\n      ++l;\n    }\n    if (l > 1) {\n      int pi = i;\n      for (int ix : ei) {\n        pi |= 1 << ix;\n      }\n      if (ni >= 19) {\n        res = min(res, int8_t(dfs(idx, pi, 15*19)+1));\n      } else if (ni >= 0 && nj >= 0 && nj < 15) {\n        res = min(res, int8_t(dfs(idx, pi, ni*15+nj)+1));\n      }\n    }\n  }\n  memo[make_pair(i,j)] = res;\n  return res;\n}\n\nint main() {\n  vector<string> t(19);\n  vector<pair<int, int>> vb;\n  vector<vector<int>> idx(19, vector<int>(15, -1));\n  int si, sj;\n  REP(i,19) {\n    cin>>t[i];\n    REP(j,15) {\n      if (t[i][j] == 'X') {\n        idx[i][j] = vb.size();\n        vb.emplace_back(i,j);\n      } else if (t[i][j] == 'O') {\n        si = i;\n        sj = j;\n      }\n    }\n  }\n  int res = dfs(idx, 0, si*15+sj);\n  if (res < INF) {\n    cout << (int)res << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};\nint n=19,m=15;\nvs in(n);\nint t=inf;\nvoid dfs(int x,int y,int c){\n\trep(i,8){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tint co=0;\n\t\twhile(nx>=0&&nx<19&&ny>=0&&ny<15&&in[nx][ny]=='X'){\n\t\t\tin[nx][ny]='.';\n\t\t\tco++;\n\t\t\tnx+=dx[i];\n\t\t\tny+=dy[i];\n\t\t}\n\t\tif(co&&nx<=18&&ny>=0&&ny<=14)dfs(nx,ny,c+1);\n\t\t\n\t\tif(co&&(nx==18&&ny>=0&&ny<15)||ny>18){\n\t\t\tt=min(t,c+1);\n\t\t}\n\t\tnx-=dx[i],ny-=dy[i];\n\t\twhile(nx!=x||ny!=y){\n\t\t\tin[nx][ny]='X';\n\t\t\tnx-=dx[i];ny-=dy[i];\n\t\t}\n\t}\n}\nint main(){\n\trep(i,n)cin>>in[i];\n\trep(i,n)rep(j,m)if(in[i][j]=='O'){\n\t\tdfs(i,j,0);\n\t\tin[i][j]='.';\n\t\tif(t==inf)t=-1;\n\t\tcout<<t<<endl;\n\t\treturn 0;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <deque>\n#include <tuple>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;//B,x,y\ntypedef tuple<int,int,int,int> T4;//d,B,x,y\nvector<P> B;\nint board[15][20];\n\nint main(){\n    fill(board[0],board[15],-1);\n    int ox,oy;\n    for(int i=0;i<19;i++){\n        for(int j=0;j<15;j++){\n            char c;\n            cin>>c;\n            if(c=='O'){\n                oy=i; ox=j;\n            }else if(c=='X'){\n                board[j][i]=B.size();\n                B.emplace_back(j,i);\n            }\n        }\n    }\n    /*\n    for(int i=0;i<20;i++){\n        for(int j=0;j<15;j++){\n            if(board[j][i]==-1) cout<<'.';\n            else cout<<board[j][i];\n        }\n        cout<<endl;\n    }\n    */\n    deque<T4> que;\n    que.emplace_back(0,(1<<B.size())-1,ox,oy);\n    while(!que.empty()){\n        int d,bb,x,y;\n        tie(d,bb,x,y)=que.front(); que.pop_front();\n        // cout<<d<<' '<<bb<<' '<<x<<' '<<y<<endl;\n        if(y>=18){\n            cout<<d<<endl;\n            return 0;\n        }\n        if(y<0||x<0||x>=15) continue;\n        for(int dy=-1;dy<=1;dy++){\n            for(int dx=-1;dx<=1;dx++){\n                if(!dx&&!dy)continue;\n                if(x+dx<0||x+dx>=15||y+dy<0||y+dy>=19) continue;\n                if(board[x+dx][y+dy]==-1) continue;\n                else{\n                    if(bb&(1<<board[x+dx][y+dy])){\n                        int l=2;\n                        int bbb=bb^(1<<board[x+dx][y+dy]);\n                        while(true){\n                            if(x+dx*l<0||x+dx*l>=15||y+dy*l<0||y+dy*l>=19){\n                                break;\n                            }else{\n                                if(board[x+dx*l][y+dy*l]==-1){\n                                    break;\n                                }else{\n                                    if((1<<board[x+dx*l][y+dy*l])&bbb){\n                                        bbb^=1<<board[x+dx*l][y+dy*l];\n                                        l++;\n                                        continue;\n                                    }else{\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        que.emplace_back(d+1,bbb,x+dx*l,y+dy*l);\n                    }\n                }\n            }\n        }\n\n    }\n    cout<<-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100\nusing namespace std;\nconst int w = 15;\nconst int h = 19;\ntypedef pair<int,int> P;\nvector<string> mp(h);\nmap<P,int>M;\nbool inmp(int x,int y){return 0<=x&&0<=y&&x<w&&y<h;}\nbool goal(int x,int y){return (y==h||(y==h-1&&0<=x&&x<w));}\n\nint mem[1<<20],used[1<<20];\nint dfs(int x,int y,int bit){\n  if(goal(x,y)) return 0;\n  if(!inmp(x,y)) return INF;\n  if(used[bit]++) return mem[bit];\n  \n  int res = INF;\n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      int nx = x+i;\n      int ny = y+j;\n      int nbit = bit;\n      if(!inmp(nx,ny)||mp[ny][nx] != 'X') continue;\n\n      vector<string>tmp = mp;\n      while(inmp(nx,ny)&&mp[ny][nx]=='X'){\n\tmp[ny][nx] = '.';\n\tnbit |=1<<M[P(nx,ny)];\n\tnx+=i,ny+=j;\n      }\n      res=min(res,1+dfs(nx,ny,nbit));\n      mp = tmp;\n    }\n  return mem[bit]=res;\n}\n\nint main(){\n\n  for(int i=0;i<h;i++)cin>>mp[i];\n\n  for(int i=0,c=0;i<h;i++)\n    for(int j=0;j<w;j++) if(mp[i][j]=='X') M[P(j,i)] = c++;\n\n  int ans; \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j] =='O') ans=dfs(j,i,0);\n  if(ans==INF) ans=-1;\n  cout<<ans<<endl;\n\t\t\t   \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst char h = 20, w = 17;\nvector<vector<bool>> c;\ntypedef tuple<pair<char, char>, vector<vector<bool>>, char> T;\nqueue<T> q;\nmap<vector<vector<bool>>, vector<vector<char>>> memo;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nbool impossible(int y, vector<vector<bool>>& c){\n\trange(i,y + 1,18){\n\t\tbool f = false;\n\t\trep(j,w){\n\t\t\tif(c[i][j]) f = true;\n\t\t}\n\t\tif(not f) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tc = vector<vector<bool>>(h, vector<bool>(w,0));\n\n\tpair<char, char> s;\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tchar a;\n\t\t\tcin >> a;\n\t\t\tif(a == 'X') c[i][j + 1] = 1;\n\t\t\telse c[i][j + 1] = 0;\n\t\t\tif(a == 'O'){\n\t\t\t\ts = make_pair(i,j + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tq.push(T(s,c,0));\n\n\tchar ans = 127;\n\twhile(not q.empty()){\n\t\tchar cost;\n\t\ttie(s,c,cost) = q.front(); q.pop();\n\n\t\tchar y, x;\n\t\ttie(y,x) = s;\n\n\t\t//rep(i,h){ rep(j,w){ if(i == y and j == x) cout << 'O'; else cout << c[i][j]; } cout << endl; } cout << endl;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(impossible(y, c)) continue;\n\n\t\tshow(q.size())\n\t\tif(cost >= 20) continue;\n\n\t\trep(i,8){\n\t\t\tchar ny = y + dy[i];\n\t\t\tchar nx = x + dx[i];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)) continue;\n\t\t\tvector<vector<bool>> pc = c;\n\t\t\tif(pc[ny][nx] == 1){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pc[ny][nx] == 0) break;\n\t\t\t\t\tpc[ny][nx] = 0;\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tif(memo.count(pc)){\n\t\t\t\t\tauto& it = memo[pc];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<char>> dis(h, vector<char>(w,127));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[pc] = dis;\n\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == 127 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst char h = 20, w = 17;\nvector<vector<bool>> c;\n\ntypedef tuple<char, pair<char, char>, vector<vector<bool>>> T;\n\n//queue<T> q;\npriority_queue<T, vector<T>, greater<T>> q;\nmap<vector<vector<bool>>, vector<vector<char>>> memo;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nbool impossible(int y, vector<vector<bool>>& c){\n\tvector<bool> no(h,0);\n\trange(i,y + 1,18){\n\t\tbool f = false;\n\t\trep(j,w){\n\t\t\tif(c[i][j]) f = true;\n\t\t}\n\t\tif(not f) no[i] = true;\n\t}\n\trep(i,h - 1){\n\t\tif(no[i] and no[i + 1]) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tc = vector<vector<bool>>(h, vector<bool>(w,0));\n\n\tpair<char, char> s;\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tchar a;\n\t\t\tcin >> a;\n\t\t\tif(a == 'X') c[i][j + 1] = 1;\n\t\t\telse c[i][j + 1] = 0;\n\t\t\tif(a == 'O'){\n\t\t\t\ts = make_pair(i,j + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tq.push(T(0,s,c));\n\n\tchar ans = 127;\n\twhile(not q.empty()){\n\t\tchar cost;\n\t\ttie(cost,s,c) = q.top(); q.pop();\n\n\t\tchar y, x;\n\t\ttie(y,x) = s;\n\n\t\t//rep(i,h){ rep(j,w){ if(i == y and j == x) cout << 'O'; else cout << c[i][j]; } cout << endl; } cout << endl;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(impossible(y, c)) continue;\n\n\t\tif(cost >= 15) continue;\n\n\t\trep(i,8){\n\t\t\tchar ny = y + dy[i];\n\t\t\tchar nx = x + dx[i];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)) continue;\n\t\t\tvector<vector<bool>> pc = c;\n\t\t\tif(pc[ny][nx] == 1){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pc[ny][nx] == 0) break;\n\t\t\t\t\tpc[ny][nx] = 0;\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tif(memo.count(pc)){\n\t\t\t\t\tauto& it = memo[pc];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(cost + 1, make_pair(ny,nx), pc));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<char>> dis(h, vector<char>(w,127));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[pc] = dis;\n\t\t\t\t\tq.push(T(cost + 1, make_pair(ny,nx), pc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == 127 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int vy[] = {-1, -1, -1, 0, 1, 1, 1, 0};\nconst int vx[] = {-1, 0, 1, 1, 1, 0, -1, -1};\n\nstring S[19];\nint sx, sy;\n\nbool isgoal(int y, int x)\n{\n  return ((y == 18 && 0 <= x && x < 15) || y == 19);\n}\n\nint bfs()\n{\n  map< tuple< int, int, int >, int > v;\n  queue< tuple< int, int, int > > que;\n  que.emplace(0, sy, sx);\n  v[que.front()] = 0;\n  while(!que.empty()) {\n    auto p = que.front();\n    int bit, y, x;\n    tie(bit, y, x) = p;\n    que.pop();\n    for(int i = 0; i < 8; i++) {\n      int ny = vy[i] + y, nx = vx[i] + x, bb = bit;\n      while(ny >= 0 && nx < 15 && ny >= 0 && ny < 19 && S[ny][nx] < 20) {\n        if((bit >> S[ny][nx]) & 1) break;\n        bb |= 1 << S[ny][nx];\n        ny += vy[i], nx += vx[i];\n      }\n      if(ny == vy[i] + y && nx == vx[i] + x) continue;\n      if(isgoal(ny, nx)) return (v[p] + 1);\n      if(ny >= 0 && nx < 15 && ny >= 0 && ny < 19) {\n        auto nxt = make_tuple(bb, ny, nx);\n        if(v.count(nxt) && v[nxt] <= v[p] + 1)continue;\n        v[nxt] = v[p] + 1;\n        que.emplace(nxt);\n      }\n    }\n  }\n  return (-1);\n}\n\nint main()\n{\n  int pad = 0;\n  for(int i = 0; i < 19; i++) {\n    cin >> S[i];\n    for(int j = 0; j < 15; j++) {\n      if(S[i][j] == 'X') S[i][j] = pad++;\n      else if(S[i][j] == 'O') sy = i, sx = j;\n    }\n  }\n  cout << bfs() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef vector<vector<bool>> Map;\ntypedef tuple<pair<int, int>, Map, int> T;\n\nconst int h = 20, w = 17;\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint ans;\nMap c;\n\nbool impossible(int y, Map& c){\n\tvector<bool> no(h,0);\n\trange(i,y + 1,18){\n\t\tbool f = false;\n\t\trep(j,w){\n\t\t\tif(c[i][j]) f = true;\n\t\t}\n\t\tif(not f) no[i] = true;\n\t}\n\trep(i,h - 1){\n\t\tif(no[i] and no[i + 1]) return true;\n\t}\n\treturn false;\n}\n\nmap<Map, map<pair<int, int>, int>> memo;\n\nvoid dfs(int y, int x, int cost){\n\tif(ans <= cost) return;\n\tif(memo.count(c) and memo[c].count(make_pair(y,x)) and memo[c][make_pair(y,x)] <= cost) return;\n\tmemo[c][make_pair(y,x)] = cost;\n\n\tif(y == 18 or y == 19){\n\t\tans = min(ans, cost);\n\t\treturn;\n\t}\n\n\tif(impossible(y, c)) return;\n\n\trep(i,8){\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)) continue;\n\t\tif(c[ny][nx] == 1){\n\t\t\tvector<pair<int, int>> tmp;\n\t\t\twhile(true){\n\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\tny = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\tny = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(c[ny][nx] == 0) break;\n\t\t\t\ttmp.emplace_back(ny,nx);\n\t\t\t\t//pc[ny][nx] = 0;\n\t\t\t\tny = ny + dy[i];\n\t\t\t\tnx = nx + dx[i];\n\t\t\t}\n\t\t\tif(ny == -1) continue;\n\n\t\t\tfor(auto i : tmp) c[i.first][i.second] = 0;\n\t\t\tdfs(ny, nx, cost + 1);\n\t\t\tfor(auto i : tmp) c[i.first][i.second] = 1;\n\t\t}\n\t}\n}\n\nint main(){\n\tpair<int, int> s;\n\tc = Map(h, vector<bool>(w));\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tchar a;\n\t\t\tcin >> a;\n\t\t\tif(a == 'X') c[i][j + 1] = 1;\n\t\t\telse c[i][j + 1] = 0;\n\t\t\tif(a == 'O'){\n\t\t\t\ts = make_pair(i,j + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tans = 1e9;\n\tdfs(s.first, s.second, 0);\n\tcout << (ans == 1e9 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>P2;\n\nstring s[21];\nint h=21,w=17,sx,sy;\nint dx[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={-1,-1,0,1,1,1,0,-1};\nshort d[21][19][1<<20];\n\nmap<pair<int,int>,int>M1;\nmap<int,pair<int,int> >M2;\nint cnt;\n\nint main(){\n  s[0]=s[20]=\".................\";\n  r(i,h-2){\n    cin>>s[i+1];\n    s[i+1]=\".\"+s[i+1]+\".\";\n  }\n  r(i,h)r(j,w)if(s[i][j]=='O'){\n    sx=j;\n    sy=i;\n    s[i][j]='.';\n  }else if(s[i][j]=='X'){\n    M2[cnt]=P(i,j);\n    M1[P(i,j)]=cnt++;\n  }\n  queue<P2>q;\n  memset(d,-1,sizeof(d));\n  d[sy][sx][0]=0;\n  q.push(P2(P(sy*1000+sx,0),0));\n  while(!q.empty()){\n    P2 p=q.front();q.pop();\n    int y=p.first.first/1000;\n    int x=p.first.first%1000;\n    int cost=p.first.second;\n    int bit=p.second;\n    r(i,8){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      int b=bit;\n      if(ny<0||nx<0||ny>=h||nx>=w)continue;\n      if(s[ny][nx]=='.')continue;\n      if((1<<M1[P(ny,nx)])&b)continue;\n      while(s[ny][nx]=='X'){\n\tint c=M1[P(ny,nx)];\n\tif((1<<c)&b)break;\n\tb|=(1<<c);\n\tny+=dy[i];\n\tnx+=dx[i];\n      }\n      if(d[ny][nx][b]!=-1)continue;\n      d[ny][nx][b]=cost+1;\n      q.push(P2(P(ny*1000+nx,cost+1),b));\n      if(ny==20){\n\tcout<<b<<endl;\n\tcout<<cost+1<<endl;\n\treturn 0;\n      }\n    }\n  }\n  cout<<-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nint ans = INF;\nint h = 19,w = 15;\nint dx[] = {0,1,0,-1,1,1,-1,-1};\nint dy[] = {1,0,-1,0,1,-1,1,-1};\nvs s(19);\n\nvoid dfs(int x, int y, int cnt){\n    if(cnt > 20)return;\n    //cout << x << \" \" << y << \" \" << cnt << endl;\n    //rep(i,h)cout << s[i]<<endl;\n    if(x == h-1){\n        ans = min(ans,cnt);\n        return;\n    }\n    rep(i,8){\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if(nx < 0 || nx >= h || ny < 0 || ny >= w)continue;\n        if(s[nx][ny] != 'X')continue;\n        bool c = true;\n        while(c && s[nx][ny] == 'X'){\n            s[nx][ny] = '.';\n            nx += dx[i];\n            ny += dy[i];\n            if(nx < 0 || nx >= h || ny < 0 || ny >= w){\n                if(nx >= h)ans = min(ans, cnt+1);\n                c = false;\n            }\n        }\n        if(c)dfs(nx,ny,cnt+1);\n        while(nx != x || ny != y){\n            nx -= dx[i];\n            ny -= dy[i];\n            s[nx][ny] = 'X';\n        }\n        s[x][y] = '.';\n    }\n}\n\nsigned main(void) {\n    rep(i,h)cin >> s[i];\n    int sx,sy;\n    rep(i,h)rep(j,w)if(s[i][j] == 'O'){\n        sx = i, sy = j;\n        s[i][j] = '.';\n    }\n    dfs(sx,sy,0);\n    if(ans == INF)cout << -1 << endl;\n    else cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\nusing namespace std;\nstruct State { int x[19][15]; };\nState S;\nint dx[8] = { 1,1,1,0,-1,-1,-1,0 }, dy[8] = { -1,0,1,1,1,0,-1,-1 };\nint solve(State p) {\n\tbool OK3 = false;\n\tfor (int i = 0; i < 15; i++) { if (p.x[18][i] == 1 || p.x[17][i] == 1)OK3 = true; }\n\tif (OK3 == false)return 999999;\n\tint cx = 0, cy = 0;\n\tfor (int i = 0; i < 285; i++) {\n\t\tif (p.x[i / 15][i % 15] == 2) { cx = i / 15; cy = i % 15; }\n\t}\n\tvector<int>vec;\n\tfor (int i = 0; i < 8; i++) {\n\t\tint ex = cx + dx[i], ey = cy + dy[i];\n\t\tif (ex < 0 || ey < 0 || ex >= 19 || ey >= 15)continue;\n\t\tif (p.x[ex][ey] == 0)continue;\n\t\tvec.push_back(i);\n\t}\n\tif (vec.size() == 0)return 999999;\n\tint minx = 999999;\n\tfor (int i = 0; i < 8; i++) {\n\t\tbool OK2 = false; for (int j = 0; j < vec.size(); j++) { if (vec[j] == i)OK2 = true; }\n\t\tif (OK2 == false)continue;\n\t\tState T = p;\n\t\tint ex = cx, ey = cy;\n\t\tbool flag = true;\n\t\twhile (true) {\n\t\t\tex += dx[i]; ey += dy[i];\n\t\t\tif (ex >= 19)break;\n\t\t\tif (ex < 0 || ey < 0 || ey >= 15) { flag = false; break; }\n\t\t\tif (T.x[ex][ey] == 0)break;\n\t\t\tT.x[ex][ey] = 0;\n\t\t}\n\t\tif (flag == false)continue;\n\n\t\tif (abs(ex - cx) <= 1 && abs(ey - cy) <= 1)continue;\n\t\tif (ex == 18 || ex == 19)minx = min(minx, 1);\n\t\telse {\n\t\t\tT.x[cx][cy] = 0; T.x[ex][ey] = 2;\n\t\t\tminx = min(minx, solve(T) + 1);\n\t\t}\n\t}\n\treturn minx;\n}\nint main() {\n\tfor (int i = 0; i < 19; i++) {\n\t\tfor (int j = 0; j < 15; j++) {\n\t\t\tchar p; cin >> p;\n\t\t\tif (p == 'O')S.x[i][j] = 2;\n\t\t\tif (p == 'X')S.x[i][j] = 1;\n\t\t\tif (p == '.')S.x[i][j] = 0;\n\t\t}\n\t}\n\tint R = solve(S); if (R >= 100000)R = -1;\n\tcout << R << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define vi vector<int>\n#define vii vector<vi>\n\n#define ll long long\n#define vl vector<ll>\n#define vll vector<vl>\n#define pii pair<int, int>\n\nconst ll INF = 1e18;\n\nint h = 19, w = 15;\nvector<map<pii, int> > dp;\nvi dx = {0, 1, 1, 1, 0, -1, -1, -1}, dy = {-1, -1, 0, 1, 1, 1, 0, -1};\n\nbool in(int x, int a, int b) {\n\treturn a <= x and x < b;\n}\n\nint main() {\n\tint n = 0;\n\tvii a(h, vi(w, -1));\n\tpii start;\n\trep (i, h) {\n\t\trep (j, w) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'O') {\n\t\t\t\tstart = pii(i, j);\n\t\t\t}\n\t\t\tif (c == 'X') {\n\t\t\t\ta[i][j] = n;\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t}\n\tint m = 1 << n;\n\tdp.resize(m);\n\tdp[m - 1][start] = 0;\n\n\tint ans = 1e9;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tfor (auto itr = dp[i].begin(); itr != dp[i].end(); itr++) {\n\t\t\tint y = itr->first.first, x = itr->first.second;\n\t\t\tint cost = itr->second;\n\t\t\trep (k, 8) {\n\t\t\t\tint ny = y + dy[k], nx = x + dx[k];\n\t\t\t\tvi use;\n\t\t\t\tbool is_black = false;\n\t\t\t\twhile (in(ny, 0, h) and in(nx, 0, w)) {\n\t\t\t\t\tif (a[ny][nx] == -1) break;\n\t\t\t\t\tif ((i & (1 << a[ny][nx])) == 0) break;\n\t\t\t\t\tis_black = true;\n\t\t\t\t\tuse.push_back(a[ny][nx]);\n\t\t\t\t\tny += dy[k];\n\t\t\t\t\tnx += dx[k];\n\t\t\t\t}\n\t\t\t\tif (not is_black) continue;\n\t\t\t\tif (ny == h or (ny == h - 1 and in(nx, 0, w))) {\n\t\t\t\t\tans = min(ans, cost + 1);\n\t\t\t\t}\n\t\t\t\telse if (ny == -1 or not in(nx, 0, w)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint ni = i;\n\t\t\t\t\trep (k, use.size()) {\n\t\t\t\t\t\tni -= (1 << use[k]);\n\t\t\t\t\t}\n\t\t\t\t\tif (dp[ni][pii(ny, nx)] == 0) {\n\t\t\t\t\t\tdp[ni][pii(ny, nx)] = cost + 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[ni][pii(ny, nx)] = min(dp[ni][pii(ny, nx)], cost + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ans >= 1e8) {\n\t\tcout << -1 << endl;\n\t}\n\telse{\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nstruct State { int x[21][17]; };\nState S;\nint dx[8] = { 1,1,1,0,-1,-1,-1,0 }, dy[8] = { -1,0,1,1,1,0,-1,-1 };\nint solve(State p) {\n\tint cx = 0, cy = 0;\n\tfor (int i = 0; i < 285; i++) {\n\t\tif (p.x[i / 15][i % 15] == 2) { cx = i / 15; cy = i % 15; }\n\t}\n\tint minx = 999999;\n\tfor (int i = 0; i < 8; i++) {\n\t\tState T = p;\n\t\tint ex = cx, ey = cy;\n\t\tbool flag = true;\n\t\twhile (true) {\n\t\t\tif (ex < 0 || ey < 0 || ey >= 15) { flag = false; }\n\t\t\tex += dx[i]; ey += dy[i];\n\t\t\tif (ex == 19 || T.x[ex][ey] == 0)break;\n\t\t\tT.x[ex][ey] = 0;\n\t\t}\n\t\tif (flag == false)continue;\n\n\t\tif (ex < 0 || ey < 0 || ex >= 20 || ey >= 15)continue;\n\n\t\tif (abs(ex - cx) <= 1 && abs(ey - cy) <= 1)continue;\n\t\tif (ex == 18 || ex == 19)minx = min(minx, 1);\n\t\telse {\n\t\t\tT.x[cx][cy] = 0; T.x[ex][ey] = 2;\n\t\t\tminx = min(minx, solve(T) + 1);\n\t\t}\n\t}\n\treturn minx;\n}\nint main() {\n\tfor (int i = 0; i < 19; i++) {\n\t\tfor (int j = 0; j < 15; j++) {\n\t\t\tchar p; cin >> p;\n\t\t\tif (p == 'O')S.x[i][j] = 2;\n\t\t\tif (p == 'X')S.x[i][j] = 1;\n\t\t\tif (p == '.')S.x[i][j] = 0;\n\t\t}\n\t}\n\tint R = solve(S); if (R >= 100000)R = -1;\n\tcout << R << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nsigned main(){\n  string s[19];\n  for(int i=0;i<19;i++) cin>>s[i];\n\n  int sy,sx;\n  vector<int> v;\n  for(int i=0;i<19;i++){\n    for(int j=0;j<15;j++){\n      if(s[i][j]=='O') sy=i,sx=j;\n      if(s[i][j]=='X') v.push_back(i*15+j);\n    }\n  }\n  \n  int n=v.size();\n  int sb=(sy*15+sx)<<n;\n  \n  map<int,int> m;\n  for(int i=0;i<n;i++) m[v[i]]=i;\n\n  int ax[]={-1,-1,-1,0,0,1,1,1};\n  int ay[]={-1,0,1,-1,1,-1,0,1};\n  \n  int ans=-1,mask=(1<<n)-1;\n  priority_queue<P> q;\n  q.push(P(0,sb));\n  map<int,int> ms;\n  ms[sb]=0;\n  \n  while(!q.empty()){\n    P p=q.top();q.pop();\n    int d=-p.first,b=p.second;\n    int cy=(b>>n)/15,cx=(b>>n)%15;\n    //cout<<(b>>n)<<\" \"<<cy<<\" \"<<cx<<\" \"<<d<<endl;\n    if(ms[b]<d) continue;\n    if(cy>=19){\n      ans=d;\n      break;\n    }\n    if(cy<0||cx<0||cx>=15) continue;\n    for(int k=0;k<8;k++){\n      int ny=cy+ay[k],nx=cx+ax[k],nb=b&mask,nd=d+1;\n      if(!m.count(ny*15+nx)) continue;\n      //cout<<ny<<\" \"<<nx<<\" \"<<nb<<\" \"<<nd<<endl;\n      if(nb&(1<<m[ny*15+nx])) continue;\n      while(m.count(ny*15+nx)){\n\tif(nb&(1<<m[ny*15+nx])) break;\n\t//cout<<n<<\":\"<<m[ny*15+nx]<<\" \"<<nb<<\" \"<<(1<<m[ny*15+nx])<<endl;\n\tnb+=1<<m[ny*15+nx];\n\tny+=ay[k];\n\tnx+=ax[k];\n      }\n      //cout<<ny<<\" \"<<nx<<\" \"<<ny*15+nx<<\" \"<<nb<<endl;\n      nb+=(ny*15+nx)<<n;\n      //cout<<nb<<\" \"<<(nb&mask)<<\" \"<<(nb>>n)<<endl;\n      if(ms.count(nb)&&ms[nb]<nd) continue;\n      ms[nb]=nd;\n      q.push(P(-nd,nb));\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <deque>\n#include <tuple>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int,int> T;//B,x,y\ntypedef tuple<int,int,int,int> T4;//d,B,x,y\nvector<P> B;\nint board[15][20];\n\nint main(){\n    fill(board[0],board[20],-1);\n    int ox,oy;\n    for(int i=0;i<19;i++){\n        for(int j=0;j<15;j++){\n            char c;\n            cin>>c;\n            if(c=='O'){\n                oy=i; ox=j;\n            }else if(c=='X'){\n                board[j][i]=B.size();\n                B.emplace_back(j,i);\n            }\n        }\n    }\n    /*\n    for(int i=0;i<20;i++){\n        for(int j=0;j<15;j++){\n            if(board[j][i]==-1) cout<<'.';\n            else cout<<board[j][i];\n        }\n        cout<<endl;\n    }\n    */\n    map<T,int> M;\n    deque<T> que;\n    que.emplace_back(0,(1<<B.size())-1,ox,oy);\n    int ans = 10000;\n    while(!que.empty()){\n        int d,bb,x,y;\n        tie(d,bb,x,y)=que.front(); que.pop_front();\n        // cout<<d<<' '<<bb<<' '<<x<<' '<<y<<endl;\n        if(y>=18){\n            cout<<d<<endl;\n            return 0;\n        }\n        if(x<0||x==15) continue;\n        for(int dy=-1;dy<=1;dy++){\n            for(int dx=-1;dx<=1;dx++){\n                if(!dx&&!dy)continue;\n                if(x+dx<0||x+dx>=15) continue;\n                if(y+dy<0||y+dy>=19) continue;\n                if(board[x+dx][y+dy]==-1) continue;\n                else{\n                    if(bb&(1<<board[x+dx][y+dy])){\n                        int l=2;\n                        int bbb=bb^(1<<board[x+dx][y+dy]);\n                        while(true){\n                            if(x+dx*l<0||x+dx*l>=15||y+dy*l<0||y+dy*l>=19){\n                                break;\n                            }else{\n                                if(board[x+dx*l][y+dy*l]==-1){\n                                    break;\n                                }else{\n                                    if((1<<board[x+dx*l][y+dy*l])&bbb){\n                                        bbb^=1<<board[x+dx*l][y+dy*l];\n                                        l++;\n                                        continue;\n                                    }else{\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        if(M.find(T(bbb,x+dx*l,y+dy*l))==M.end()){\n                            M[T(bbb,x+dx*l,y+dy*l)]=d+1;\n                            que.emplace_back(d+1,bbb,x+dx*l,y+dy*l);\n                        }else if(M[T(bbb,x+dx*l,y+dy*l)]>d+1){\n                            M[T(bbb,x+dx*l,y+dy*l)]=d+1;\n                            que.emplace_back(d+1,bbb,x+dx*l,y+dy*l);\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n    cout<<-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 30;\n\nint main() {\n  vector<string> t(19);\n  vector<pair<int, int>> vb;\n  vector<vector<int>> idx(19, vector<int>(15, -1));\n  int si, sj;\n  REP(i,19) {\n    cin>>t[i];\n    REP(j,15) {\n      if (t[i][j] == 'X') {\n        idx[i][j] = vb.size();\n        vb.emplace_back(i,j);\n      } else if (t[i][j] == 'O') {\n        si = i;\n        sj = j;\n      }\n    }\n  }\n  int n = vb.size();\n  vector<vector<int>> dp(1<<n, vector<int>(15*19+1, INF));\n  dp[0][si*15+sj] = 0;\n  REP(i,1<<n) {\n    REP(j,15*19) {\n      if (dp[i][j] == INF) continue;\n      int oi = j/15;\n      int oj = j%15;\n      int di[8] = {1, 1, 1, 0, -1, -1, -1, 0};\n      int dj[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\n      REP(k,8) {\n        int l = 1;\n        vector<int> ei;\n        int ni;\n        int nj;\n        while (1) {\n          ni = oi + l*di[k];\n          nj = oj + l*dj[k];\n          if (ni < 0 || ni >= 19 || nj < 0 || nj >= 15) break;\n          if (idx[ni][nj] < 0 || ((i>>idx[ni][nj])&1)) break;\n          ei.push_back(idx[ni][nj]);\n          ++l;\n        }\n        if (l > 1) {\n          int pi = i;\n          for (int ix : ei) {\n            pi |= 1 << ix;\n          }\n          if (ni >= 19) {\n            dp[pi][15*19] = min(dp[pi][15*19], dp[i][j]+1);\n          } else if (ni >= 0 && nj >= 0 && nj < 15) {\n            dp[pi][ni*15+nj] = min(dp[pi][ni*15+nj], dp[i][j]+1);\n          }\n        }\n      }\n    }\n  }\n  int res = INF;\n  REP(i,1<<n) res = min(res, dp[i][15*19]);\n  if (res < INF) {\n    cout << res << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nchar mp[19][15];\n\nint dx[8] = { 1,1,1,0,-1,-1,-1,0 };\nint dy[8] = { 1,0,-1,-1,-1,0,1,1 };\n\nint ans = mod;\nvoid dfs(int x, int y, int k) {\n\tif (x >= 19||(x==18&&0<=y&&y<15)) {\n\t\tans = min(ans, k);\n\t\treturn;\n\t}\n\tif (x < 0 || y < 0 || y >= 15)return;\n\trep(j, 8) {\n\t\tint nx = x + dx[j], ny = y + dy[j];\n\t\tif (nx < 0 || ny < 0 || nx >= 19 || ny >= 15)continue;\n\t\tif (mp[nx][ny] == 'X') {\n\t\t\tvector<P> memo;\n\t\t\twhile (true) {\n\t\t\t\tmp[nx][ny] = '.';\n\t\t\t\tmemo.push_back({ nx,ny });\n\t\t\t\tnx += dx[j]; ny += dy[j];\n\t\t\t\tif (nx < 0 || ny < 0 || nx >= 19|| ny >= 15)break;\n\t\t\t\tif (mp[nx][ny] != 'X')break;\n\t\t\t}\n\t\t\tdfs(nx, ny, k + 1);\n\t\t\trep(i, memo.size()) {\n\t\t\t\tmp[memo[i].first][memo[i].second] = 'X';\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve() {\n\tint sx, sy;\n\trep(i, 19) {\n\t\trep(j, 15) {\n\t\t\tcin >> mp[i][j];\n\t\t\tif (mp[i][j] == 'O') {\n\t\t\t\tsx = i, sy = j;\n\t\t\t\tmp[i][j] = '.';\n\t\t\t}\n\t\t}\n\t}\n\tdfs(sx, sy, 0);\n\tif (ans == mod)ans = -1;\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ntypedef tuple<int,int,int,int> state;\n\n\nstring board[19];\nint stone[19][15];\n\nint num=0;\n\nint dx[8]={1,1,1,0,-1,-1,-1,0};\nint dy[8]={1,0,-1,-1,-1,0,1,1};\n\nint bfs(){\n\tint wx=-1,wy=-1;\n\trep(i,19)rep(j,15) stone[i][j]=-1;\n\trep(i,19)rep(j,15){\n\t\tif(board[i][j]=='X')\n\t\t\tstone[i][j]=num++;\n\t\tif(board[i][j]=='O')\n\t\t\twx=i,wy=j;\n\t}\n\tstate init(0,wx,wy,(1<<20)-1);\n\tqueue<state> q;\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tstate cur=q.front();q.pop();\n\t\tint cost,cx,cy,mask;\n\t\ttie(cost,cx,cy,mask)=cur;\n\t\tif(cx>=18)\n\t\t\treturn cost;\n\t\trep(i,8){\n\t\t\tint nx=cx,ny=cy,nmask=mask;\n\t\t\twhile(0<=nx+dx[i]&&nx+dx[i]<19&&0<=ny+dy[i]&&ny+dy[i]<15){\n\t\t\t\tint index=stone[nx+dx[i]][ny+dy[i]];\n\t\t\t\tif(index!=-1&&(nmask&(1<<index))){\n\t\t\t\t\tnmask&=(~(1<<index));\n\t\t\t\t\tnx+=dx[i],ny+=dy[i];\n\t\t\t\t}else\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(nx==cx&&ny==cy) continue;\n\t\t\tstate nexts(cost+1,nx+dx[i],ny+dy[i],nmask);\n\t\t\tq.push(nexts);\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint main(void){\n\trep(i,19) cin >> board[i];\n\tcout << bfs() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nstruct state{\n  int S;\n  int i,j;\n  int d;\n};\n\nconst int w=15;\nconst int h=19;\nstring s[22];\nint idx[22][22];\nint N=0;\nint si,sj;\nint dist[1<<21];\n\nint di[]={-1,-1,-1,0,0,1,1,1};\nint dj[]={-1,0,1,-1,1,-1,0,1};\n\nint main(){\n  rep(i,h)cin>>s[i];\n  memset(idx,-1,sizeof(idx));\n  rep(i,h)rep(j,w){\n    if(s[i][j]=='X'){\n      idx[i][j]=N++;\n    }\n    if(s[i][j]=='O'){\n      si=i;sj=j;\n    }\n  }\n\n  rep(i,1<<N)dist[i]=INF;\n  queue<state> que;\n  que.push((state){(1<<N)-1,si,sj,0});\n  dist[(1<<N)-1]=0;\n  while(que.size()){\n    state cs=que.front(); que.pop();\n    rep(dir,8){\n      int ni=cs.i+di[dir],nj=cs.j+dj[dir];\n      if(ni<0||ni>=h||nj<0||nj>=w)continue;\n      if(idx[ni][nj]==-1||((cs.S>>idx[ni][nj])&1)==0)continue;\n      vector<int> uidxs;\n      while(ni>=0&&ni<h&&nj>=0&&nj<w&&idx[ni][nj]!=-1&&((cs.S>>idx[ni][nj])&1)){\n        uidxs.push_back(idx[ni][nj]);\n        ni+=di[dir];\n        nj+=dj[dir];\n      }\n      if(ni==h||ni==h-1){\n        cout<<cs.d+1<<endl;\n        return 0;\n      }\n      if(ni<0||nj<0||nj>=w)continue;\n      int nxtS=cs.S;\n      rep(i,uidxs.size())nxtS^=(1<<uidxs[i]);\n      if(dist[nxtS]!=INF)continue;\n      que.push((state){nxtS,ni,nj,cs.d+1});\n      dist[nxtS]=cs.d+1;\n    }\n  }\n  cout<<-1<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst int h = 19;\nconst int w = 15;\n\nstruct Data { \n  int x,y,bitmask,cost;\n  bool operator < ( const Data& data ) const { \n    if( cost != data.cost ) return cost < data.cost; \n    if( x != data.x ) return x < data.x;\n    if( y != data.y ) return y < data.y;\n    if( bitmask != data.bitmask ) return bitmask < data.bitmask;\n  }\n};\n\nchar a[20][20];\n//int mindist[1<<20][9];\nset<Data> mindist;\nint Index[20][20];\n\nbool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nvoid compute(){\n  int black = 0;\n  int sx=-1,sy=-1;\n  rep(i,h) rep(j,w) {\n    if( a[i][j] == 'X' ) Index[i][j] = black++;\n    if( a[i][j] == 'O' ) sx = j, sy = i;\n  }\n  //rep(i,(1<<black)) rep(j,9) mindist[i][j] = IINF;\n  mindist.clear();\n  //mindist[(1<<black)-1][4] = 0;\n  mindist.insert((Data){sx,sy,(1<<black)-1,0});\n  deque<Data> deq;\n  deq.push_back((Data){sx,sy,(1<<black)-1,0});\n  while( !deq.empty() ){\n    Data data = deq.front(); deq.pop_front();\n    REP(dx,-1,2){\n      REP(dy,-1,2){\n        if( dx == 0 && dy == 0 ) continue;\n        int nx = data.x + dx, ny = data.y + dy, nbitmask = data.bitmask;\n        bool valid = false;\n        while( isValid(nx,ny) && ( a[ny][nx] == 'X' && ( data.bitmask & (1<<Index[ny][nx]) ) ) ){\n          nbitmask &= ~(1<<Index[ny][nx]);\n          nx += dx, ny += dy;\n          valid = true;\n        }\n        if( !isValid(nx,ny) ) {\n          if( valid && ( -1 <= nx && nx <= w ) && ny >= h ) {\n            //cout << mindist[data.bitmask]+1 << endl;\n            cout << data.cost+1 << endl;\n            return;\n          }\n          continue;\n        }\n        if( !valid ) continue;\n        //if( mindist[nbitmask] > mindist[data.bitmask] + 1 ) {\n        if( !mindist.count((Data){nx,ny,nbitmask,data.cost+1}) ) {\n          //mindist[nbitmask] = mindist[data.bitmask] + 1;\n          mindist.insert((Data){nx,ny,nbitmask,data.cost+1});\n          deq.push_back((Data){nx,ny,nbitmask,data.cost+1});\n        }\n      }\n    }\n  }\n  puts(\"-1\");\n}\n\nint main(){\n  rep(i,h) rep(j,w) scanf(\" %c\",&a[i][j]);\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst int h = 19;\nconst int w = 15;\n\nstruct Data { \n  int x,y,bitmask,cost;\n  bool operator < ( const Data& data ) const { \n    if( cost != data.cost ) return cost < data.cost; \n    if( x != data.x ) return x < data.x;\n    if( y != data.y ) return y < data.y;\n    if( bitmask != data.bitmask ) return bitmask < data.bitmask;\n  }\n};\n\nchar a[20][20];\n//int mindist[1<<20][9];\nset<Data> mindist;\nint Index[20][20];\n\nbool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nvoid compute(){\n  int black = 0;\n  int sx=-1,sy=-1;\n  rep(i,h) rep(j,w) {\n    if( a[i][j] == 'X' ) Index[i][j] = black++;\n    if( a[i][j] == 'O' ) sx = j, sy = i;\n  }\n  //rep(i,(1<<black)) rep(j,9) mindist[i][j] = IINF;\n  mindist.clear();\n  //mindist[(1<<black)-1][4] = 0;\n  mindist.insert((Data){sx,sy,(1<<black)-1,0});\n  deque<Data> deq;\n  deq.push_back((Data){sx,sy,(1<<black)-1,0});\n  while( !deq.empty() ){\n    Data data = deq.front(); deq.pop_front();\n    REP(dx,-1,2){\n      REP(dy,-1,2){\n        if( dx == 0 && dy == 0 ) continue;\n        int nx = data.x + dx, ny = data.y + dy, nbitmask = data.bitmask;\n        bool valid = false;\n        while( isValid(nx,ny) && ( a[ny][nx] == 'X' && ( data.bitmask & (1<<Index[ny][nx]) ) ) ){\n          nbitmask &= ~(1<<Index[ny][nx]);\n          nx += dx, ny += dy;\n          valid = true;\n        }\n        if( valid && ( ny >= h || ( ny == h-1 && isValid(nx,ny) ) ) ) {\n          //cout << mindist[data.bitmask]+1 << endl;\n          cout << data.cost+1 << endl;\n          return;\n        } else if( !inValid(nx,ny) ) {\n          continue;\n        }\n        if( !valid ) continue;\n        //if( mindist[nbitmask] > mindist[data.bitmask] + 1 ) {\n        if( !mindist.count((Data){nx,ny,nbitmask,data.cost+1}) ) {\n          //mindist[nbitmask] = mindist[data.bitmask] + 1;\n          mindist.insert((Data){nx,ny,nbitmask,data.cost+1});\n          deq.push_back((Data){nx,ny,nbitmask,data.cost+1});\n        }\n      }\n    }\n  }\n  puts(\"-1\");\n}\n\nint main(){\n  rep(i,h) rep(j,w) scanf(\" %c\",&a[i][j]);\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n#include<queue>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> P2;\n\nconst int dy[] = {-1,-1,0,1,1,1,0,-1}, dx[] = {0,1,1,1,0,-1,-1,-1};\nint sy,sx;\nstring b[20];\nmap<P,int> stone;\n\nstring bin(int x){\n  string res;\n  for(int i=0;i<20;i++){\n    if(x&1)res += \"1\";\n    else res += \"0\";\n    x/=2;\n  }\n  return res;\n}\n\nint main(){\n  for(int i=0;i<19;i++)cin >> b[i];\n\n  int cnt = 0;\n  for(int i=0;i<19;i++){\n    for(int j=0;j<15;j++){\n      if(b[i][j] == 'O'){sy = i; sx = j;}\n      if(b[i][j] == 'X'){\n\tstone[P(i,j)] = cnt++;\n      }\n    }\n  }\n\n  P2 cur = P2(P(sy,sx),0);\n  map<P2,int> d;\n  d[cur] = 0;\n  queue<P2> q;\n  q.push(cur);\n\n  int res = -1;\n  while(q.size()){\n    cur = q.front(); q.pop();\n    int state = cur.sc;\n\n    for(int i=0;i<8;i++){\n      int ny = cur.fs.fs+dy[i], nx = cur.fs.sc+dx[i];\n      int nstate = state;\n\n      if(ny<0 || nx<0 || ny>=19 || nx>=15)continue;\n      while(b[ny][nx] == 'X'){\n\tint id = stone[P(ny,nx)];\n\n\tif((nstate>>id)&1)break;\n\n\tnstate |= 1<<id;\n        ny = ny+dy[i], nx = nx+dx[i];\n\n\tif(ny<0 || nx<0 || ny>=19 || nx>=15)break;\n      }\n      if(ny==cur.fs.fs+dy[i] && nx==cur.fs.sc+dx[i])continue;\n\n      if(ny>=19){\n\tres = d[cur]+1;\n\tgoto END;\n      }\n      \n      if(ny<0 || nx<0 || nx>=15)continue;\n      if(ny>=18){\n\tres = d[cur]+1;\n\tgoto END;\n      }\n\n      P2 nxt = P2(P(ny,nx),nstate);\n      if(d.find(nxt) == d.end()){\n\tq.push(nxt);\n\td[nxt] = d[cur]+1;\n      }\n    }\n  }\n END: cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H=19,W=15;\n\nenum DIR{\n\tLeft_Up,\n\tUp,\n\tRight_Up,\n\tLeft,\n\tRight,\n\tLeft_Down,\n\tDown,\n\tRight_Down,\n};\n\nDIR dir[8] = {Left_Up,Up,Right_Up,Left,Right,Left_Down,Down,Right_Down};\n\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\n\nstruct BlackStone{\n\tBlackStone(){\n\t\trow = col = 0;\n\t}\n\n\tBlackStone(short arg_row,short arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tshort row,col;\n};\n\nstruct Info{\n\tvector<BlackStone> BLACK_STONE;\n\tshort row,col,count;\n};\n\nbool rangeCheck(short row,short col){\n\tif(row <= 17){\n\t\tif(col < 0 || col > 14){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}else{ //row >= 18\n\t\tif(row == 18 && (col < 0 || col > 14)){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\nInfo move(Info info,DIR dir){\n\tInfo ret;\n\n\tchar map[19][15];\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)map[i][k] = '.';\n\t}\n\n\tfor(int i = 0; i < info.BLACK_STONE.size(); i++){\n\t\tmap[info.BLACK_STONE[i].row][info.BLACK_STONE[i].col] = 'X';\n\t\tBlackStone new_stone;\n\t\tnew_stone.row = info.BLACK_STONE[i].row;\n\t\tnew_stone.col = info.BLACK_STONE[i].col;\n\t\tret.BLACK_STONE.push_back(new_stone);\n\t}\n\tret.count = info.count+1;\n\n\tint next_row,next_col,index;\n\n\tswitch(dir){\n\tcase Left_Up:\n\t\tindex = 0;\n\t\tbreak;\n\tcase Up:\n\t\tindex = 1;\n\t\tbreak;\n\tcase Right_Up:\n\t\tindex = 2;\n\t\tbreak;\n\tcase Left:\n\t\tindex = 3;\n\t\tbreak;\n\tcase Right:\n\t\tindex = 4;\n\t\tbreak;\n\tcase Left_Down:\n\t\tindex = 5;\n\t\tbreak;\n\tcase Down:\n\t\tindex = 6;\n\t\tbreak;\n\tcase Right_Down:\n\t\tindex = 7;\n\t\tbreak;\n\t}\n\n\tnext_row = info.row+diff_row[index];\n\tnext_col = info.col+diff_col[index];\n\n\twhile(rangeCheck(next_row,next_col) == true && map[next_row][next_col] == 'X'){\n\t\tnext_row += diff_row[index];\n\t\tnext_col += diff_col[index];\n\t}\n\n\n\tif(next_row == info.row+diff_row[index] && next_col == info.col+diff_col[index]){\n\t\tret.row = 1;\n\t\tret.col = -1;\n\t}else{\n\t\tint tmp_row,tmp_col;\n\n\t\ttmp_row = info.row+diff_row[index];\n\t\ttmp_col = info.col+diff_col[index];\n\n\t\twhile(tmp_row != next_row || tmp_col != next_col){\n\t\t\tfor(int i = 0; i < ret.BLACK_STONE.size();i++){\n\t\t\t\tif(ret.BLACK_STONE[i].row == tmp_row && ret.BLACK_STONE[i].col == tmp_col){\n\t\t\t\t\tret.BLACK_STONE.erase(ret.BLACK_STONE.begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp_row += diff_row[index];\n\t\t\ttmp_col += diff_col[index];\n\t\t}\n\n\t\tret.row = next_row;\n\t\tret.col = next_col;\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\n\tInfo first;\n\n\tchar buf[15];\n\tint minimum = BIG_NUM,start_row,start_col;\n\n\tfor(short i = 0; i < H; i++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(short k = 0; k < W; k++){\n\t\t\tif(buf[k] == 'O'){\n\t\t\t\tstart_row = i;\n\t\t\t\tstart_col = k;\n\t\t\t}else if(buf[k] == 'X'){\n\t\t\t\tfirst.BLACK_STONE.push_back(BlackStone(i,k));\n\t\t\t}\n\t\t}\n\t}\n\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.count = 0;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().row >= 18){\n\t\t\tminimum = Q.front().count;\n\t\t\tbreak;\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 8; i++){\n\t\t\t\tInfo next = move(Q.front(),dir[i]);\n\n\t\t\t\tif(rangeCheck(next.row,next.col)){\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(minimum == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};\nint n=19,m=15;\nvs in(n);\nint t=inf;\nvoid dfs(int x,int y,int c){\n\trep(i,8){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tint co=0;\n\t\twhile(nx>=0&&nx<19&&ny>=0&&ny<15&&in[nx][ny]=='X'){\n\t\t\tin[nx][ny]='.';\n\t\t\tco++;\n\t\t\tnx+=dx[i];\n\t\t\tny+=dy[i];\n\t\t}\n\t\tif(co==0)continue;\n\t\tif(nx>=18){\n\t\t\tt=min(t,c+1);\n\t\t\tcontinue;\n\t\t}\n\t\tif(ny<0||ny>14)continue;\n\t\tdfs(nx,ny,c+1);\n\t\tnx-=dx[i],ny-=dy[i];\n\t\twhile(nx!=x||ny!=y){\n\t\t\tin[nx][ny]='X';\n\t\t\tnx-=dx[i];ny-=dy[i];\n\t\t}\n\t}\n}\nint main(){\n\trep(i,n)cin>>in[i];\n\trep(i,n)rep(j,m)if(in[i][j]=='O'){\n\t\tdfs(i,j,0);\n\t\tin[i][j]='.';\n\t\tif(t==inf)t=-1;\n\t\tcout<<t<<endl;\n\t\treturn 0;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct S {\n\tint x, y, mask;\n\tll hash() {\n\t\treturn (ll)x + 15 * (ll)y + (ll)mask * (20 * 20);\n\t}\n};\n\nint b[19][15];\n\nint dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 };\nint dy[8] = { 0, 1, 0, -1, 1, -1, 1, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < 15 && 0 <= y && y < 19;\n}\n\nmap<ll, int> dp;\n\nint main() {\n\tint B = 0;\n\tint sx = -1, sy = -1;\n\n\tmemset(b, -1, sizeof b);\n\tfor(int i = 0; i < 19; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j < 15; j++) {\n\t\t\tif(s[j] == 'O') sx = j, sy = i;\n\t\t\tif(s[j] == 'X') {\n\t\t\t\tb[i][j] = B++;\n\t\t\t}\n\t\t}\n\t}\n\n\tS is = { sx, sy, 0 };\n\tdp[is.hash()] = 0;\n\n\tqueue<S> q;\n\tq.push(is);\n\twhile(q.size()) {\n\t\tint x = q.front().x, y = q.front().y, mask = q.front().mask;\n\t\tint t = dp[q.front().hash()];\n\t\tq.pop();\n\t\tfor(int k = 0; k < 8; k++) {\n\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\tif(!in(nx, ny)) continue;\n\t\t\tint id = b[ny][nx];\n\t\t\tif(id == -1) continue;\n\t\t\tif(mask >> id & 1) continue;\n\t\t\tint nmask = mask;\n\t\t\twhile(1) {\n\t\t\t\tnmask |= 1 << id;\n\t\t\t\tnx += dx[k], ny += dy[k];\n\t\t\t\tif(!in(nx, ny)) break;\n\t\t\t\tid = b[ny][nx];\n\t\t\t\tif(id == -1 || (mask >> id & 1)) break;\n\t\t\t}\n\t\t\tif(in(nx, ny) && ny == 18 || ny == 19) {\n\t\t\t\tprintf(\"%d\\n\", t + 1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(in(nx, ny)) {\n\t\t\t\tS ns = { nx, ny, nmask };\n\t\t\t\tif(dp.count(ns.hash()) == 0) {\n\t\t\t\t\tdp[ns.hash()] = t + 1;\n\t\t\t\t\tq.push(ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<queue>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 20, T = (1<<N), H = 19, W = 15;\n\nset<int> memo[T];\nint board[H][W];\nint stx,sty;\n\nclass Q{\npublic:\n\tint x,y,cnt,state;\n\tQ(int x,int y,int cnt, int state):x(x),y(y),cnt(cnt),state(state){}\n};\n\nvoid input(){\n\tstring a[H];\n\n\trep(i,H)cin>>a[i];\n\tint cnt = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tboard[i][j] = -1;\n\t\t\tif(a[i][j] == 'X'){\n\t\t\t\tboard[i][j] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(a[i][j] == 'O'){\n\t\t\t\tstx = j; sty = i;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint zahyo(int x,int y){\n\treturn x + y * W;\n}\n\nbool hasmemo(Q u){\n\treturn memo[u.state].find(zahyo(u.x,u.y)) != memo[u.state].end();\n}\n\nvoid setmemo(Q u){\n\tmemo[u.state].insert(zahyo(u.x,u.y));\n}\n\nbool hasbit(int state, int i){\n\treturn (state&(1<<i))>0;\n}\n\nbool isblack(int x,int y,int state){\n\tint n = board[y][x];\n\tif(n<0)return false;\n\treturn !hasbit(state,n);\n}\n\nbool isout(int x,int y){\n\tif(y<0)return true;\n\tif(y<H){\n\t\tif(x<0 || x>=W)return true;\n\t}\n\treturn false;\n}\n\nbool isgoal(int x,int y){\n\tif(y>=H) return true;\n\treturn false;\n}\n\n\nint minblack(int x,int y,int state){\n\tint n = board[y][x];\n\tif(n<0)puts(\"hoooo\");\n\tif(hasbit(state,n))puts(\"hhahah\");\n\n\treturn state + (1<<n);\n}\n\nint solve(){\n\t\n\tqueue<Q> que;\n\tque.push(Q(stx,sty,0,0));\n\n\twhile(!que.empty()){\n\t\tQ u = que.front(); que.pop();\n\t\tif(hasmemo(u))continue;\n\t\tsetmemo(u);\n\n\t\t//printf(\"%d %d\\n\",u.x,u.y);\n\n\t\tint dx[] = {-1,0,1,-1,1,-1,0,1};\n\t\tint dy[] = {-1,-1,-1,0,0,1,1,1};\n\n\t\trep(p,8){\n\t\t\tint st = u.state;\n\t\t\treps(i,1,100){\n\t\t\t\tint nx = u.x + dx[p]*i;\n\t\t\t\tint ny = u.y + dy[p]*i;\n\n\n\t\t\t\tif(i==1){\n\t\t\t\t\tif(isout(nx,ny) || isgoal(nx,ny))break;\n\t\t\t\t\tif(!isblack(nx,ny,st))break;\n\t\t\t\t}\n\t\t\t\tif(i!=1){\n\t\t\t\t\tif(isout(nx,ny))break;\n\t\t\t\t\tif(isgoal(nx,ny))return u.cnt+1;\n\t\t\t\t\tif(!isblack(nx,ny,st)){\n\t\t\t\t\t\tque.push(Q(nx,ny,u.cnt+1,st));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tst = minblack(nx,ny,st);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tinput();\n\tcout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nconst int dx2[] = { -1,-1, 0, 1,1,1, 0,-1 }; const int dy2[] = { 0, 1,1,1, 0,-1,-1, -1 };\n\nvector<string> now;\nint ans = 10000;\nvvi visited(21, vi(17, 10000));\nvoid dfs(int y, int x, int step) {\n\tif (y == 20 || (y == 19 && 0 < x&&x < 16)) {\n\t\tans = min(ans, step);\n\t\treturn;\n\t}\n\tREP(i, 8) {\n\t\tvector<string> now2=now;\n\t\tint my = dy2[i];\n\t\tint mx = dx2[i];\n\t\tif (now[y + my][x + mx] == 'X') {\n\t\t\twhile(now[y + my][x + mx] == 'X') {\n\t\t\t\tnow[y + my][x + mx] = '.';\n\t\t\t\tmy += dy2[i];\n\t\t\t\tmx += dx2[i];\n\t\t\t} x;\n\t\t\t//if (step + 1 < visited[y + my][x + mx]) {\n\t\t\t\tif ((y + my == 20 || (y + my > 0 && 0 < x + mx&&x + mx < 16))) {\n\t\t\t\t\tvisited[y + my][x + mx] = min(visited[y + my][x + mx],step+1);\n\t\t\t\t\tdfs(y + my, x + mx, step + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t//}\n\t\tnow = now2;\n\t}\n}\n\nint main() {\n\tvector<string> ban(21,\".................\");\n\tint sy=-1, sx=-1;\n\tREP(i, 19) {\n\t\tcin >> ban[i+1];\n\t\tban[i + 1] = \".\" + ban[i + 1] + \".\";\n\t\tREP(j, 17)\n\t\t\tif (ban[i+1][j] == 'O') {\n\t\t\t\tsy = i+1;\n\t\t\t\tsx = j;\n\t\t\t\tban[i + 1][j] = '.';\n\t\t\t\tvisited[i+1][j] = 0;\n\t\t\t}\n\t}\n\tnow = ban;\n\tdfs(sy,sx,0);\n\tif (ans == 10000)\n\t\tans = -1;\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define inf 100000007\nusing namespace std;\n\nchar kiban[20][15];\nint X[8]={0,1,0,-1,1,-1,-1,1};\nint Y[8]={-1,0,1,0,1,-1,1,-1};\nint ans=inf;\n\nbool in(int h,int w)\n{\n  if(h<0 || w<0 || 15<=w || 21<=h)return false;\n  return true;\n}\n\nvoid move(int h,int w,int sum)\n{\n  bool check[8]={};\n  if(18<=h){\n    ans=min(ans,sum);\n    return;\n    }\n  for(int k=0;k<8;k++){\n    if(kiban[h+Y[k]][w+X[k]]=='.')continue;\n    for(int i=1;i<40;i++){\n      int a=h+Y[k]*i,b=w+X[k]*i;\n      if(a==19){\n\tans=min(ans,sum+1);\n\tcontinue;\n      }\n      if(!in(a,b))break;\n      if(kiban[a][b]=='.'){\n\tcheck[k]=true;\n\tbreak;\n      }\n    }\n  }\n  for(int k=0;k<8;k++){\n    if(!check[k])continue;\n    int a=h,b=w;\n    for(int i=1;i<20;i++){\n      a+=Y[k];\n      b+=X[k];\n      if(kiban[a][b]=='.')break;\n      kiban[a][b]='.';\n    }\n    move(a,b,sum+1);\n    int H=h,W=w;\n    for(int i=1;i<20;i++){\n      H+=Y[k];\n      W+=X[k];\n      if(H==a && W==b)break;\n      kiban[H][W]='x';\n    }\n  }\n}\n\nint main()\n{\n  int h,w;\n  for(int i=0;i<19;i++){\n    for(int j=0;j<15;j++){\n      cin>>kiban[i][j];\n      if(kiban[i][j]=='O'){\n\th=i;\n\tw=j;\n\tkiban[i][j]='.';\n      }\n    }\n  }\n  for(int i=0;i<15;i++)kiban[19][i]='.';\n  move(h,w,0);\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct S {\n\tint x, y, mask;\n\tll hash() {\n\t\treturn (ll)x + 15 * (ll)y + (ll)mask * (20 * 20);\n\t}\n};\n\nint b[19][15];\n\nint dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 };\nint dy[8] = { 0, 1, 0, -1, 1, -1, 1, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < 15 && 0 <= y && y < 19;\n}\n\nmap<ll, int> dp;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint B = 0;\n\tint sx = -1, sy = -1;\n\tmemset(b, -1, sizeof b);\n\tfor(int i = 0; i < 19; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j < 15; j++) {\n\t\t\tif(s[j] == 'O') sx = j, sy = i;\n\t\t\tif(s[j] == 'X') {\n\t\t\t\tb[i][j] = B++;\n\t\t\t}\n\t\t}\n\t}\n\n\tS is = { sx, sy, 0 };\n\tdp[is.hash()] = 0;\n\n\tqueue<S> q;\n\tq.push(is);\n\twhile(q.size()) {\n\t\tint x = q.front().x, y = q.front().y, mask = q.front().mask;\n\t\tint t = dp[q.front().hash()];\n\t\tq.pop();\n\t\tfor(int k = 0; k < 8; k++) {\n\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\tif(!in(nx, ny)) continue;\n\t\t\tint id = b[ny][nx];\n\t\t\tif(id == -1) continue;\n\t\t\tif(mask >> id & 1) continue;\n\t\t\tint nmask = mask;\n\t\t\twhile(1) {\n\t\t\t\tnmask |= 1 << id;\n\t\t\t\tnx += dx[k], ny += dy[k];\n\t\t\t\tif(!in(nx, ny)) break;\n\t\t\t\tid = b[ny][nx];\n\t\t\t\tif(id == -1 || (mask >> id & 1)) break;\n\t\t\t}\n\t\t\tif(ny >= 18) {\n\t\t\t\tcout << t + 1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(in(nx, ny)) {\n\t\t\t\tS ns = { nx, ny, nmask };\n\t\t\t\tif(dp.count(ns.hash()) == 0) {\n\t\t\t\t\tdp[ns.hash()] = t + 1;\n\t\t\t\t\tq.push(ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <deque>\n#include <tuple>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int,int> T;//B,x,y\ntypedef tuple<int,int,int,int> T4;//d,B,x,y\nvector<P> B;\nint board[15][20];\n\nint main(){\n    fill(board[0],board[20],-1);\n    int ox,oy;\n    for(int i=0;i<19;i++){\n        for(int j=0;j<15;j++){\n            char c;\n            cin>>c;\n            if(c=='O'){\n                oy=i; ox=j;\n            }else if(c=='X'){\n                board[j][i]=B.size();\n                B.emplace_back(j,i);\n            }\n        }\n    }\n    /*\n    for(int i=0;i<20;i++){\n        for(int j=0;j<15;j++){\n            if(board[j][i]==-1) cout<<'.';\n            else cout<<board[j][i];\n        }\n        cout<<endl;\n    }\n    */\n    map<T,int> M;\n    deque<T> que;\n    que.emplace_back(0,(1<<B.size())-1,ox,oy);\n    int ans = 10000;\n    while(!que.empty()){\n        int d,bb,x,y;\n        tie(d,bb,x,y)=que.front(); que.pop_front();\n        // cout<<d<<' '<<bb<<' '<<x<<' '<<y<<endl;\n        if(y>=18){\n            cout<<d<<endl;\n            return 0;\n        }\n        if(x<0||x==15) continue;\n        for(int dy=-1;dy<=1;dy++){\n            for(int dx=-1;dx<=1;dx++){\n                if(!dx&&!dy)continue;\n                if(x+dx<0||x+dx>=15) continue;\n                if(y+dy<0||y+dy>=19) continue;\n                if(board[x+dx][y+dy]==-1) continue;\n                else{\n                    if(bb&(1<<board[x+dx][y+dy])){\n                        int l=2;\n                        int bbb=bb^(1<<board[x+dx][y+dy]);\n                        while(true){\n                            if(x+dx*l<0||x+dx*l>=15||y+dy*l<0||y+dy*l>=19){\n                                break;\n                            }else{\n                                if(board[x+dx*l][y+dy*l]==-1){\n                                    break;\n                                }else{\n                                    if((1<<board[x+dx*l][y+dy*l])&bbb){\n                                        bbb^=1<<board[x+dx*l][y+dy*l];\n                                        l++;\n                                        continue;\n                                    }else{\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        if(M.find(T(bbb,x+dx*l,y+dy*l))==M.end()){\n                            M[T(bbb,x+dx*l,y+dy*l)]=d+1;\n                            que.emplace_back(d+1,bbb,x+dx*l,y+dy*l);\n                        }else if(M[T(bbb,x+dx*l,y+dy*l)]>d+1){\n                            M[T(bbb,x+dx*l,y+dy*l)]=d+1;\n                            que.emplace_back(d+1,bbb,x+dx*l,y+dy*l);\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n    cout<<-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nconst int H = 19;\nconst int W = 15;\nstring bd[H];\nint id[H][W];\nint dx[] = {1,1,0,-1,-1,-1,0,1};\nint dy[] = {0,1,1,1,0,-1,-1,-1};\n\nstruct PH{\n  template<class T, class U>\n  size_t operator()(const pair<T,U>& x) const{\n\tsize_t seed = 0;\n\tseed ^= hash<T>{}(x.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\tseed ^= hash<U>{}(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\treturn seed;\n  }\n};\n\nusing D = pair<PII,int>;\nnamespace std{\ntemplate<> struct hash<D>{\n  size_t operator()(const D& d) const{\n\treturn PH{}(MP(PH{}(d.FF), d.SS));\n  }\n};\n}\n\nbool isin(const PII& p){\n  return (0 <= p.FF && p.FF < H && 0 <= p.SS && p.SS < W);\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  REP(i,19) cin >> bd[i];\n  PII w;\n  int gid = 0;\n  REP(y,H) REP(x,W){\n\tif(bd[y][x] == 'O')\n\t  w = MP(y,x);\n\telse if(bd[y][x] == 'X')\n\t  id[y][x] = gid++;\n  }\n\n  int ans = -1;\n  unordered_map<D,int> memo;\n  queue<D> q;\n  q.push(D(w,(1<<21)-1));\n  memo[D(w,(1<<21)-1)] = 0;\n  while(!q.empty()){\n\tD d = q.front();\n\tq.pop();\n\tPII p = d.FF;\n\tif(p.FF >= H){\n\t  ans = memo[d];\n\t  break;\n\t}\n\tif(p.FF < 0 || p.SS < 0 || p.SS >= W)\n\t  continue;\n\tREP(dir,8){\n\t  int nb = d.SS;\n\t  PII np(p.FF+dy[dir], p.SS+dx[dir]);\n\t  while(isin(np) && bd[np.FF][np.SS] == 'X' && (nb>>id[np.FF][np.SS]&1)){\n\t\tnb ^= 1 << id[np.FF][np.SS];\n\t\tnp.FF += dy[dir];\n\t\tnp.SS += dx[dir];\n\t  }\n\t  if(nb == d.SS) continue;\n\t  if(!memo.count(D(np,nb))){\n\t\t memo[D(np,nb)] = memo[d] + 1;\n\t\t q.push(D(np,nb));\n\t  }\n\t}\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n//変数\nconstexpr int H = 19;\nconstexpr int W = 15;\nint ans = INF;\n\n\nvoid visualize(const vector<vector<bool>>& goban, pair<int, int> now)\n{\n\tcerr << \"===================\" << endl;\n\tcerr << now.first << \":::\" << now.second << endl;\n\tREP(i, H){\n\t\tREP(j, W) {\n\t\t\tif (now.first == i && now.second == j)cerr << \"o\";\n\t\t\telse cerr << (goban[i][j] ? \"X\" : \".\");\n\t\t}\n\t\tcerr << endl;\n\t}\n\tcerr << \"===================\" << endl;\n}\n\nbool out(const int& count, const pair<int,int>& next)\n{\n\tint y = next.first;\n\tint x = next.second;\n\n\tif (x < 0)return true;\n\tif (y < 0)return true;\n\tif (14 < x)return true;\n\tif (18 < y) {\n\t\tans = min(ans, count);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint gap(pair<int, int> l, pair<int, int> r)\n{\n\tint a = abs(l.first - r.first);\n\tint b = abs(l.second - r.second);\n\treturn max(a, b);\n}\n\nvoid step(\n\tconst vector<vector<bool>>& goban,\n\tconst pair<int,int>& now,\n\tconst int& count)\n{\n\tconstexpr int dirSiz = 8;\n\tconstexpr int dh[] = { -1,0,1,1,1,0,-1,-1 };\n\tconstexpr int dw[] = { 1,1,1,0,-1,-1,-1,0 };\n\tif (ans <= count)return;\n\n\t//visualize(goban, now);\n\n\tREP(i, dirSiz) {\n\t\tauto nextGoban = goban;\n\t\tauto next = now;\n\n\t\twhile (true) {\n\t\t\tnext.first += dh[i];\n\t\t\tnext.second += dw[i];\n\t\t\tif (out(count, next))break;\n\n\t\t\tif (nextGoban[next.first][next.second]) {\n\t\t\t\tnextGoban[next.first][next.second] = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (gap(now, next) <= 1) {\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tif (18 <= next.first && 0 <= next.second && next.second < W) {\n\t\t\t\tans = min(ans, count);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!out(count, next)) {\n\t\t\t\t\t//visualize(goban, now);\n\t\t\t\t\tstep(nextGoban, next, count + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin >> N;\n}\n\n\n//メイン関数\nint main()\n{\n\tpair<int, int> start;\n\tvector<vector<bool>> goban;\n\tREP(i, H) {\n\t\tstring tmp;\n\t\tvector<bool> row;\n\t\tcin >> tmp;\n\t\tREP(j,W){\n\t\t\tchar c = tmp[j];\n\t\t\trow.push_back(c == 'X');\n\t\t\tif (c == 'O')start = { i,j };\n\t\t}\n\t\tgoban.push_back(row);\n\t}\n\n\tstep(goban, start, 1);\n\tif (ans == INF)ans = -1;\n\tcout << ans << endl;\n\n\tdebug();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <deque>\n#include <tuple>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int,int> T;//B,x,y\ntypedef tuple<int,int,int,int> T4;//d,B,x,y\nvector<P> B;\nint board[15][20];\n\nint main(){\n    fill(board[0],board[20],-1);\n    int ox,oy;\n    for(int i=0;i<19;i++){\n        for(int j=0;j<15;j++){\n            char c;\n            cin>>c;\n            if(c=='O'){\n                oy=i; ox=j;\n            }else if(c=='X'){\n                board[j][i]=B.size();\n                B.emplace_back(j,i);\n            }\n        }\n    }\n    /*\n    for(int i=0;i<20;i++){\n        for(int j=0;j<15;j++){\n            if(board[j][i]==-1) cout<<'.';\n            else cout<<board[j][i];\n        }\n        cout<<endl;\n    }\n    */\n    map<T,int> M;\n    deque<T> que;\n    que.emplace_back(0,(1<<B.size())-1,ox,oy);\n    while(!que.empty()){\n        int d,bb,x,y;\n        tie(d,bb,x,y)=que.front(); que.pop_front();\n        // cout<<d<<' '<<bb<<' '<<x<<' '<<y<<endl;\n        if(y>=18){\n            cout<<d<<endl;\n            return 0;\n        }\n        if(x<0||x==15) continue;\n        for(int dy=-1;dy<=1;dy++){\n            for(int dx=-1;dx<=1;dx++){\n                if(!dx&&!dy)continue;\n                if(x+dx<0||x+dx>=15) continue;\n                if(y+dy<0||y+dy>=19) continue;\n                if(board[x+dx][y+dy]==-1) continue;\n                else{\n                    if(bb&(1<<board[x+dx][y+dy])){\n                        int l=2;\n                        int bbb=bb^(1<<board[x+dx][y+dy]);\n                        while(true){\n                            if(x+dx*l<0||x+dx*l>=15||y+dy*l<0||y+dy*l>=19){\n                                break;\n                            }else{\n                                if(board[x+dx*l][y+dy*l]==-1){\n                                    break;\n                                }else{\n                                    if((1<<board[x+dx*l][y+dy*l])&bbb){\n                                        bbb^=1<<board[x+dx*l][y+dy*l];\n                                        l++;\n                                        continue;\n                                    }else{\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        if(M.find(T(bbb,x+dx*l,y+dy*l))==M.end()){\n                            M[T(bbb,x+dx*l,y+dy*l)]=d+1;\n                            que.emplace_back(d+1,bbb,x+dx*l,y+dy*l);\n                        }else if(M[T(bbb,x+dx*l,y+dy*l)]>d+1){\n                            M[T(bbb,x+dx*l,y+dy*l)]=d+1;\n                            que.emplace_back(d+1,bbb,x+dx*l,y+dy*l);\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n    cout<<-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define inf 100000007\nusing namespace std;\n\nchar kiban[20][15];\nint X[8]={0,1,0,-1,1,-1,-1,1};\nint Y[8]={-1,0,1,0,1,-1,1,-1};\nint ans=inf;\n\nbool in(int h,int w)\n{\n  if(h<0 || w<0 || 15<=w || 21<=h)return false;\n  return true;\n}\n\nvoid move(int h,int w,int sum)\n{\n  bool check[8]={};\n  if(18<=h){\n    ans=min(ans,sum);\n    return;\n    }\n  for(int k=0;k<8;k++){\n    if(kiban[h+Y[k]][w+X[k]]=='.')continue;\n    for(int i=1;i<20;i++){\n      int a=h+Y[k]*i,b=w+X[k]*i;\n      if(!in(a,b))break;\n      if(kiban[a][b]=='.'){\n\tcheck[k]=true;\n\tbreak;\n      }\n    }\n  }\n  for(int k=0;k<8;k++){\n    if(!check[k])continue;\n    int a=h,b=w;\n    for(int i=1;i<20;i++){\n      a+=Y[k];\n      b+=X[k];\n      if(kiban[a][b]=='.')break;\n      kiban[a][b]='.';\n    }\n    move(a,b,sum+1);\n    int H=h,W=w;\n    for(int i=1;i<20;i++){\n      H+=Y[k];\n      W+=X[k];\n      if(H==a && W==b)break;\n      kiban[H][W]='x';\n    }\n  }\n}\n\nint main()\n{\n  int h,w;\n  for(int i=0;i<19;i++){\n    for(int j=0;j<15;j++){\n      cin>>kiban[i][j];\n      if(kiban[i][j]=='O'){\n\th=i;\n\tw=j;\n\tkiban[i][j]='.';\n      }\n    }\n  }\n  for(int i=0;i<15;i++)kiban[19][i]='.';\n  move(h,w,0);\n  if(ans==inf)cout<<-1<<endl;\n  else cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ntypedef tuple<int,int,int,int> state;\n\n\nstring board[19];\nint stone[19][15];\n\nint num=0;\n\nint dx[8]={1,1,1,0,-1,-1,-1,0};\nint dy[8]={1,0,-1,-1,-1,0,1,1};\n\nint bfs(){\n\tint wx=-1,wy=-1;\n\trep(i,19)rep(j,15) stone[i][j]=-1;\n\trep(i,19)rep(j,15){\n\t\tif(board[i][j]=='X')\n\t\t\tstone[i][j]=num++;\n\t\tif(board[i][j]=='O')\n\t\t\twx=i,wy=j;\n\t}\n\tstate init(0,wx,wy,(1<<20)-1);\n\tqueue<state> q;\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tstate cur=q.front();q.pop();\n\t\tint cost,cx,cy,mask;\n\t\ttie(cost,cx,cy,mask)=cur;\n\t\tif(cx>=18)\n\t\t\treturn cost;\n\t\tif(cx<0||19<=cx||cy<0||15<=cy) continue;\n\t\trep(i,8){\n\t\t\tint nx=cx,ny=cy,nmask=mask;\n\t\t\twhile(0<=nx+dx[i]&&nx+dx[i]<19&&0<=ny+dy[i]&&ny+dy[i]<15){\n\t\t\t\tint index=stone[nx+dx[i]][ny+dy[i]];\n\t\t\t\tif(index!=-1&&(nmask&(1<<index))){\n\t\t\t\t\tnmask&=(~(1<<index));\n\t\t\t\t\tnx+=dx[i],ny+=dy[i];\n\t\t\t\t}else\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(nx==cx&&ny==cy) continue;\n\t\t\tstate nexts(cost+1,nx+dx[i],ny+dy[i],nmask);\n\t\t\tq.push(nexts);\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint main(void){\n\trep(i,19) cin >> board[i];\n\tcout << bfs() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <assert.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\nchar F[20][16];\nint sx, sy;\nunordered_map<int, int> umap;\n\nconstexpr int to_num(int x, int y) {\n  return x+y*16;\n}\n\nstruct state {\n  int x, y, cost, used;\n  state(int x, int y, int cost, int used) : x(x), y(y), cost(cost), used(used) {}\n  bool operator < (state const& s) const {\n    return cost > s.cost;\n  }\n};\n\nint const dx[8] = {-1, 0, 1, 0,-1, 1, 1,-1};\nint const dy[8] = {0, -1, 0, 1,-1,-1, 1, 1};\n\nint const INF = 1<<29;\n\nbool inrange(int x, int y) {\n  return 0<=x && x<16 && 0<=y && y<20;\n}\n\nbool is_used_xy(int used, int x, int y) {\n  if(umap[to_num(x, y)] == -1) { return false; }\n  return used >> umap[to_num(x, y)] & 1;\n}\n\nvoid debugger(int used, int cx, int cy) {\n  rep(i, 20) {\n    rep(j, 16) {\n      if(cx == j && cy == i) {\n        assert((F[i][j] == 'X' && is_used_xy(used, j, i)) || (F[i][j] == '.') || (F[i][j] == 'G'));\n        cout << 'O';\n      }\n      else {\n        cout << (is_used_xy(used, j, i) ? 'U' : F[i][j]);\n      }\n    }\n    cout << endl;\n  }\n}\n\nint dijkstra() {\n  int dist[22][22];\n  fill(dist[0], dist[0]+22*22, INF);\n  priority_queue<state> pq;\n  pq.emplace(sx, sy, 0, 0);\n  dist[sy][sx] = 0;\n  while(!pq.empty()) {\n    const int x = pq.top().x, y = pq.top().y, cost = pq.top().cost, used = pq.top().used;\n    pq.pop();\n    if(F[y][x] == 'G') { return cost; }\n    rep(i, 8) {\n      int nx = x+dx[i], ny = y+dy[i];\n      int nused = used;\n      if(F[ny][nx] != 'X') { continue; }\n      if(is_used_xy(used, nx, ny)) { continue; }\n      bool ng = false;\n      for(;;) {\n        if(!inrange(nx, ny)) { ng = true; break; }\n        if(F[ny][nx] != 'X') { break; }\n        if(is_used_xy(used, nx, ny)) { break; }\n        nused |= 1<<umap[to_num(nx, ny)];\n        nx += dx[i], ny += dy[i];\n      }\n      if(ng) { continue; }\n      if(F[ny][nx] == 'A') { continue; }\n\n      if(dist[ny][nx] <= cost+1) { continue; }\n      dist[ny][nx] = cost+1;\n      pq.emplace(nx, ny, dist[ny][nx], nused);\n    }\n  }\n  return -1;\n}\n\nint main() {\n\n  rep(i, 20) rep(j, 16) umap[to_num(j, i)] = -1;\n  int bcnt = 0;\n  rep(i, 19) rep(j, 15) {\n    cin >> F[i][j];\n    if(F[i][j] == 'O') {\n      F[i][j] = '.';\n      sx = j, sy = i;\n    }\n    if(F[i][j] == 'X') {\n      umap[to_num(j,i)] = bcnt++;\n    }\n  }\n\n  rep(i, 20) { F[i][15] = 'A'; }\n  rep(i, 16) {\n    if(i < 15 && F[18][i] != 'X') { F[18][i] = 'G'; }\n    F[19][i] = 'G';\n  }\n\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int h = 20, w = 17;\nvector<vector<char>> c;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint main(){\n\tc = vector<vector<char>>(h, vector<char>(w,'.'));\n\n\tpair<int, int> s;\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tcin >> c[i][j + 1];\n\t\t\tif(c[i][j + 1] == 'O') s = make_pair(i,j + 1);\n\t\t}\n\t}\n\n\ttypedef tuple<pair<int, int>, vector<vector<char>>, int> T;\n\tqueue<T> q;\n\tq.push(T(s,c,0));\n\n\tint ans = INF;\n\tmap<vector<vector<char>>, vector<vector<int>>> memo;\n\twhile(not q.empty()){\n\t\tint cost;\n\t\ttie(s,c,cost) = q.front(); q.pop();\n\n\t\tint y, x;\n\t\ttie(y,x) = s;\n\n\t\t//rep(i,h){ rep(j,w){ if(i == y and j == x) cout << 'O'; else cout << c[i][j]; } cout << endl; } cout << endl;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(i,8){\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tvector<vector<char>> pc = c;\n\t\t\tif(pc[ny][nx] == 'X'){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pc[ny][nx] == '.') break;\n\t\t\t\t\tpc[ny][nx] = '.';\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tif(memo.count(pc)){\n\t\t\t\t\tauto& it = memo[pc];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<int>> dis(h, vector<int>(w,INF));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[pc] = dis;\n\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100\nusing namespace std;\nconst int w = 15;\nconst int h = 19;\ntypedef pair<int,int> P;\nvector<string> mp(h);\nmap<P,int>M;\nbool inmp(int x,int y){return 0<=x&&0<=y&&x<w&&y<h;}\nbool goal(int x,int y){return (y==h||(y==h-1&&0<=x&&x<w));}\n\nint mem[1<<20],used[1<<20];\nint dfs(int x,int y,int bit){\n  if(goal(x,y)) return 0;\n  if(!inmp(x,y)) return INF;\n  if(used[bit]++) return mem[bit];\n  \n  int res = INF;\n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      int nx = x+i;\n      int ny = y+j;\n      int nbit = bit;\n      if(!inmp(nx,ny)||mp[ny][nx] != 'X') continue;\n\n      vector<string>tmp = mp;\n      while(inmp(nx,ny)&&mp[ny][nx]=='X'){\n\tmp[ny][nx] = '.';\n\tnbit |=1<<M[P(nx,ny)];\n\tnx+=i,ny+=j;\n      }\n      res=min(res,1+dfs(nx,ny,nbit));\n      mp = tmp;\n    }\n  return mem[bit]=res;\n}\n\nint main(){\n\n  for(int i=0;i<h;i++)cin>>mp[i];\n\n  for(int i=0,c=0;i<h;i++)\n    for(int j=0;j<w;j++) if(mp[i][j]=='X') M[P(j,i)] = c++;\n\n  int ans; \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) if(mp[i][j] =='O') ans=dfs(j,i,0);\n\n  cout<<(ans<INF? ans:-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int h = 20, w = 17;\nvector<vector<char>> c;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint main(){\n\tc = vector<vector<char>>(h, vector<char>(w,'.'));\n\n\tpair<int, int> s;\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tcin >> c[i][j + 1];\n\t\t\tif(c[i][j + 1] == 'O') s = make_pair(i,j + 1);\n\t\t}\n\t}\n\n\ttypedef tuple<pair<int, int>, vector<vector<char>>, int> T;\n\tqueue<T> q;\n\tq.push(T(s,c,0));\n\n\tint ans = INF;\n\tmap<vector<vector<char>>, vector<vector<int>>> memo;\n\twhile(not q.empty()){\n\t\tint cost;\n\t\ttie(s,c,cost) = q.front(); q.pop();\n\n\t\tint y, x;\n\t\ttie(y,x) = s;\n\n\t\t//rep(i,h){ rep(j,w){ if(i == y and j == x) cout << 'O'; else cout << c[i][j]; } cout << endl; } cout << endl;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(i,8){\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tvector<vector<char>> pc = c;\n\t\t\tif(pc[ny][nx] == 'X'){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((nx == 0 && ny <= 18) and (nx == w - 1 && ny <= 18)){\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pc[ny][nx] == '.') break;\n\t\t\t\t\tpc[ny][nx] = '.';\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tif(memo.count(pc)){\n\t\t\t\t\tauto& it = memo[pc];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<int>> dis(h, vector<int>(w,INF));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[pc] = dis;\n\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>P2;\n\nstring s[21];\nint h=21,w=17,sx,sy;\nint dx[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={-1,-1,0,1,1,1,0,-1};\nint d[21][19][1<<20];\n\nmap<pair<int,int>,int>M1;\nmap<int,pair<int,int> >M2;\nint cnt;\n\nint main(){\n  s[0]=s[20]=\".................\";\n  r(i,h-2){\n    cin>>s[i+1];\n    s[i+1]=\".\"+s[i+1]+\".\";\n  }\n  r(i,h)r(j,w)if(s[i][j]=='O'){\n    sx=j;\n    sy=i;\n    s[i][j]='.';\n  }else if(s[i][j]=='X'){\n    M2[cnt]=P(i,j);\n    M1[P(i,j)]=cnt++;\n  }\n  queue<P2>q;\n  memset(d,-1,sizeof(d));\n  d[sy][sx][0]=0;\n  q.push(P2(P(sy*1000+sx,0),0));\n  while(!q.empty()){\n    P2 p=q.front();q.pop();\n    int y=p.first.first/1000;\n    int x=p.first.first%1000;\n    int cost=p.first.second;\n    int bit=p.second;\n    r(i,8){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      int b=bit;\n      if(ny<0||nx<0||ny>=h||nx>=w)continue;\n      if(s[ny][nx]=='.')continue;\n      if((1<<M1[P(ny,nx)])&b)continue;\n      while(s[ny][nx]=='X'){\n\tint c=M1[P(ny,nx)];\n\tif((1<<c)&b)break;\n\tb|=(1<<c);\n\tny+=dy[i];\n\tnx+=dx[i];\n      }\n      if(d[ny][nx][b]!=-1)continue;\n      d[ny][nx][b]=cost+1;\n      q.push(P2(P(ny*1000+nx,cost+1),b));\n      if(ny==20){\n\tcout<<b<<endl;\n\tcout<<cost+1<<endl;\n\treturn 0;\n      }\n    }\n  }\n  cout<<-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>P2;\n\nstring s[21];\nint h=21,w=17,sx,sy;\nint dx[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={-1,-1,0,1,1,1,0,-1};\nbool d[21][19][1<<20];\n\nmap<pair<int,int>,int>M1;\nmap<int,pair<int,int> >M2;\nint cnt;\n\nint main(){\n  s[0]=s[20]=\".................\";\n  r(i,h-2){\n    cin>>s[i+1];\n    s[i+1]=\".\"+s[i+1]+\".\";\n  }\n  r(i,h)r(j,w)if(s[i][j]=='O'){\n    sx=j;\n    sy=i;\n    s[i][j]='.';\n  }else if(s[i][j]=='X'){\n    M2[cnt]=P(i,j);\n    M1[P(i,j)]=cnt++;\n  }\n  queue<P2>q;\n  d[sy][sx][0]=1;\n  q.push(P2(P(sy*1000+sx,0),0));\n  while(!q.empty()){\n    P2 p=q.front();q.pop();\n    int y=p.first.first/1000;\n    int x=p.first.first%1000;\n    int cost=p.first.second;\n    int bit=p.second;\n    r(i,8){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      int b=bit;\n      if(ny<0||nx<0||ny>=h||nx>=w)continue;\n      if(s[ny][nx]=='.')continue;\n      if((1<<M1[P(ny,nx)])&b)continue;\n      while(s[ny][nx]=='X'){\n\tint c=M1[P(ny,nx)];\n\tif((1<<c)&b)break;\n\tb|=(1<<c);\n\tny+=dy[i];\n\tnx+=dx[i];\n      }\n      if(d[ny][nx][b]==1)continue;\n      d[ny][nx][b]=1;\n      q.push(P2(P(ny*1000+nx,cost+1),b));\n      if(ny==20){\n\tcout<<cost+1<<endl;\n\treturn 0;\n      }\n    }\n  }\n  cout<<-1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nint dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nconst int H = 19;\nconst int W = 15;\nchar board[H+2][W+2];\n\nint solve(int x, int y) {\n    if(x == H - 1 and 0 <= y and y < W) return 0;\n    if(x > H - 1) return 0;\n    if(y < 0 or y >= W or x < 0) return INF;\n    assert(board[x][y] == '.');\n    \n    int ans = INF;\n    for(int k=0; k<8; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        if(nx < 0 or nx >= H or ny < 0 or ny >= W) continue;\n        if(board[nx][ny] != 'X') continue;\n        \n        vector< pair<int, int> > black_pos;\n        while(nx >= 0 and nx < H and ny >= 0 and ny < W and board[nx][ny] == 'X') {\n            black_pos.emplace_back(nx, ny);\n            board[nx][ny] = '.';\n            nx += dx[k];\n            ny += dy[k];\n        }\n\n        int nxt_val = solve(nx, ny);\n        for(auto b : black_pos) {\n            int bx, by; tie(bx, by) = b;\n            board[bx][by] = 'X';\n        }\n        \n        if(nxt_val == INF) continue;\n        ans = min(ans, nxt_val + 1);\n    }\n    return ans;\n}\n\nsigned main() {\n    int x = -1, y = -1;\n    for(int i=0; i<H; i++) {\n        for(int j=0; j<W; j++) {\n            cin >> board[i][j];\n            if(board[i][j] == 'O') {\n                x = i, y = j;\n                board[i][j] = '.';\n            }\n        }\n    }\n\n    int ans = solve(x, y);\n    if(ans >= INF) ans = -1;\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ntypedef tuple<int,int,int,int> state;\n\n\nstring board[19];\nint stone[19][15];\n\nint num=0;\n\nint dx[8]={1,1,1,0,-1,-1,-1,0};\nint dy[8]={1,0,-1,-1,-1,0,1,1};\n\nint bfs(){\n\tint wx=-1,wy=-1;\n\trep(i,19)rep(j,15) stone[i][j]=-1;\n\trep(i,19)rep(j,15){\n\t\tif(board[i][j]=='X')\n\t\t\tstone[i][j]=num++;\n\t\tif(board[i][j]=='O')\n\t\t\twx=i,wy=j;\n\t}\n\tstate init(0,wx,wy,(1<<20)-1);\n\tqueue<state> q;\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tstate cur=q.front();q.pop();\n\t\tint cost,cx,cy,mask;\n\t\ttie(cost,cx,cy,mask)=cur;\n\t\tif(cx==19)\n\t\t\treturn cost;\n\t\trep(i,8){\n\t\t\tint nx=cx,ny=cy,nmask=mask;\n\t\t\twhile(0<=nx+dx[i]&&nx+dx[i]<19&&0<=ny+dy[i]&&ny+dy[i]<15){\n\t\t\t\tint index=stone[nx+dx[i]][ny+dy[i]];\n\t\t\t\tif(index!=-1&&(nmask&(1<<index))){\n\t\t\t\t\tnmask&=(~(1<<index));\n\t\t\t\t\tnx+=dx[i],ny+=dy[i];\n\t\t\t\t}else\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(nx==cx&&ny==cy) continue;\n\t\t\tstate nexts(cost+1,nx+dx[i],ny+dy[i],nmask);\n\t\t\tq.push(nexts);\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint main(void){\n\trep(i,19) cin >> board[i];\n\tcout << bfs() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint main(){\n  vector<string> vec(19);\n  rep(i,19) cin>>vec[i];\n  int n = 0;\n  map<pair<int,int>,int> p2i;\n  rep(i,19)rep(j,15) if(vec[i][j]=='X'){\n    p2i[mp(i,j)] = n++;\n  }\n  int sx,sy;\n  rep(i,19)rep(j,15) if(vec[i][j]=='O') sx=i, sy=j;\n\n  using state = pair<int,pair<int,int>>;\n\n  auto ok = [&](int i, int j){\n    return i>=0 && i<19 && j>=0 && j<15;\n  };\n\n  set<state> prev;\n  prev.insert(mp(0,mp(sx,sy)));\n\n  rep(i,20){\n    set<state> nxt;\n    for(const state & s : prev){\n      int mask = s.fi;\n      int x = s.se.fi, y = s.se.se;\n      for(int dx=-1; dx<=1; dx++){\n        for(int dy=-1; dy<=1; dy++) if(dx*dx+dy*dy>0){\n          int nmask = mask;\n          int d = 1;\n          while(ok(x+dx*d,y+dy*d) && vec[x+dx*d][y+dy*d]=='X'){\n            int idx = p2i[mp(x+dx*d, y+dy*d)];\n            if(! (mask & (1<<idx)) ){\n              nmask |= (1<<idx);\n              d++;\n            }\n            else {\n              break;\n            }\n          }\n          if(d==1) continue;\n          int nx=x+dx*d, ny=y+dy*d;\n          if(nx==19 || (ok(nx,ny) && nx==18)){\n            cout << i+1 << endl;\n            return 0;\n          }\n          if(ok(nx,ny)) nxt.insert(mp(nmask,mp(nx,ny)));\n        }\n      }\n    }\n    swap(nxt, prev);\n  }\n\n  cout << -1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 19\n#define M 15\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nint sy,sx,cnt;\nmap<P1,int> memo;\nmap<P,int> num;\nstring s[N];\nint dy[8]={-1,-1,-1,0,0,1,1,1};\nint dx[8]={-1,0,1,-1,1,-1,0,1};\n\nint dfs(int A,int y,int x){\n  if(memo.count(P1(A,P(y,x))))return memo[P1(A,P(y,x))];\n  if(N-1<=y)return 1;\n  if(y<0||x<0||N<=y||M<=x)return INF;\n  int res=INF;\n  memo[P1(A,P(y,x))]=INF;\n  for(int i=0;i<8;i++){\n    int ny=y+dy[i],nx=x+dx[i],nA=A;\n    if(ny<0||nx<0||N<=ny||M<=nx)continue;\n    if(s[ny][nx]!='X')continue;\n    while(0<=ny&&ny<N&&0<=nx&&nx<M&&s[ny][nx]=='X'){\n      nA|=(1<<num[P(ny,nx)]);\n      s[ny][nx]='.';\n      ny+=dy[i]; nx+=dx[i];\n    }\n    res=min(res,dfs(nA,ny,nx));\n    while(ny!=y||nx!=x){\n      ny-=dy[i]; nx-=dx[i];\n      s[ny][nx]='X';\n    }\n  }\n  return memo[P1(A,P(y,x))]=res+1;\n}\n\nint main(){\n  for(int i=0;i<N;i++){\n    cin>>s[i];\n    for(int j=0;j<M;j++){\n      if(s[i][j]=='O'){\n\tsy=i,sx=j;\n\ts[i][j]='.';\n      }\n      if(s[i][j]=='X')\n\tnum[P(i,j)]=cnt++;\n    }\n  }\n  int ans=dfs(0,sy,sx);\n  cout<<(ans==INF+1?-1:ans-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct state{\n  int bi,a,b;\n  bool operator<(const state& s) const {\n    if( bi == s.bi ){\n      if( a == s.a ) return b < s.b;\n      return a < s.a;\n    }\n    return bi < s.bi;\n  }\n};\n\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};\n\nmap<state,int> dp;\nchar cie[55][55];\nint fie[55][55];\nint N,W,H;\nbool check( int bi,int x,int y,int d,int &nst,int &nx,int &ny ){\n  bool f = false;\n  nst = bi;\n  nx = x + dx[d];\n  ny = y + dy[d];  \n  if( nx < 0 || nx >= W || ny < 0 || ny >= H ) return false;\n  if( cie[nx][ny] == 'X' && !(nst & (1<<fie[nx][ny])) ){\n    f = true;      \n    nst |= (1<<fie[nx][ny]);\n  }\n\n  while( f ){\n    nx = nx + dx[d];\n    ny = ny + dy[d];  \n    if( y > H-1 || ( y==H-1 && W > x && x > 0 ) ) return true;\n    if( nx < 0 || nx >= W || ny < 0 ) return false;\n    if( cie[nx][ny] == 'X' && !(nst & (1<<fie[nx][ny])) ){\n      nst |= (1<<fie[nx][ny]);\n    } else\n      break;\n  }\n  return f;\n}\n\nint solve(int bi,int x,int y){\n  if( dp.count((state){bi,x,y}) != 0 ) return dp[(state){bi,x,y}];\n  // cout << bitset<20>(bi) << \" \"<< x << \" \"<< y << endl;\n  if( y > H-1 || ( y==H-1 && W > x && x > 0 ) ) return dp[(state){bi,x,y}] = 0;\n  int ret = (1<<29);\n  for(int i=0;i<8;i++){\n    int nx,ny,nst;\n    if( check(bi,x,y,i,nst,nx,ny) ){\n      ret = min( ret, solve(nst,nx,ny)+1);\n    }\n  }\n  return dp[(state){bi,x,y}] = ret;\n}\n\nint main(){\n  N = 0;\n  W=15;H=19;\n  int x,y;\n  for(int i=0;i<19;i++){\n    for(int j=0;j<15;j++){\n      cin >> cie[j][i];\n      if( cie[j][i] == 'X')\n\tfie[j][i] = N++;\n      if( cie[j][i] == 'O' ){\n\tx = j; y = i;\n      }\t\n    }\n  }\n  int res = solve(0,x,y);\n  if( res == (1<<29) )\n    cout << -1 << endl;\n  else \n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H=19,W=15;\n\nenum DIR{\n    Left_Up,\n    Up,\n    Right_Up,\n    Left,\n    Right,\n    Left_Down,\n    Down,\n    Right_Down,\n};\n\nDIR dir[8] = {Left_Up,Up,Right_Up,Left,Right,Left_Down,Down,Right_Down};\n\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\n\nstruct BlackStone{\n    BlackStone(){\n        row = col = 0;\n    }\n\n    BlackStone(short arg_row,short arg_col){\n        row = arg_row;\n        col = arg_col;\n    }\n    short row,col;\n};\n\nstruct Info{\n    vector<BlackStone> BLACK_STONE;\n    short row,col,count;\n};\n\nbool rangeCheck(short row,short col){\n    if(row <= 17){\n        if(col < 0 || col > 14){\n            return false;\n        }else{\n            return true;\n        }\n    }else{ //row >= 18\n        if(row == 18 && (col < 0 || col > 14)){\n            return false;\n        }else{\n            return true;\n        }\n    }\n}\n\nInfo move(Info info,DIR dir){\n    Info ret;\n\n    char map[19][15];\n    for(int i = 0; i < H; i++){\n        for(int k = 0; k < W; k++)map[i][k] = '.';\n    }\n\n    for(int i = 0; i < info.BLACK_STONE.size(); i++){\n        map[info.BLACK_STONE[i].row][info.BLACK_STONE[i].col] = 'X';\n    }\n    ret.count = info.count+1;\n\n    int next_row,next_col,index;\n\n    switch(dir){\n    case Left_Up:\n        index = 0;\n        break;\n    case Up:\n        index = 1;\n        break;\n    case Right_Up:\n        index = 2;\n        break;\n    case Left:\n        index = 3;\n        break;\n    case Right:\n        index = 4;\n        break;\n    case Left_Down:\n        index = 5;\n        break;\n    case Down:\n        index = 6;\n        break;\n    case Right_Down:\n        index = 7;\n        break;\n    }\n\n    next_row = info.row+diff_row[index];\n    next_col = info.col+diff_col[index];\n\n    while(rangeCheck(next_row,next_col) == true && map[next_row][next_col] == 'X'){\n        next_row += diff_row[index];\n        next_col += diff_col[index];\n    }\n\n\n    if(next_row == info.row+diff_row[index] && next_col == info.col+diff_col[index]){\n        ret.row = 1;\n        ret.col = -1;\n    }else{\n\n        if(rangeCheck(next_row,next_col) == true && next_row <= 18){\n\n        \tfor(int i = 0; i < info.BLACK_STONE.size();i++){\n        \t\tret.BLACK_STONE.push_back(info.BLACK_STONE[i]);\n        \t}\n\n            int tmp_row,tmp_col;\n\n            tmp_row = info.row+diff_row[index];\n            tmp_col = info.col+diff_col[index];\n\n            while(tmp_row != next_row || tmp_col != next_col){\n                for(int i = 0; i < ret.BLACK_STONE.size();i++){\n                    if(ret.BLACK_STONE[i].row == tmp_row && ret.BLACK_STONE[i].col == tmp_col){\n                        ret.BLACK_STONE.erase(ret.BLACK_STONE.begin()+i);\n                        break;\n                    }\n                }\n                tmp_row += diff_row[index];\n                tmp_col += diff_col[index];\n            }\n        }\n\n        ret.row = next_row;\n        ret.col = next_col;\n    }\n\n    return ret;\n}\n\nint main(){\n\n    Info first;\n\n    char buf[15];\n    int minimum = BIG_NUM,start_row,start_col,num;\n    bool FLG = true;\n\n    for(short i = 0; i < H; i++){\n        scanf(\"%s\",buf);\n        if(i == 18){\n        \tnum = 0;\n        }\n        for(short k = 0; k < W; k++){\n            if(buf[k] == 'O'){\n                start_row = i;\n                start_col = k;\n            }else if(buf[k] == 'X'){\n                first.BLACK_STONE.push_back(BlackStone(i,k));\n            }\n            if((i == 18) && buf[k] == 'X')num++;\n        }\n        if(i == 18 && num == 0){\n        \tFLG = false;\n        }\n    }\n\n    if(!FLG){\n    \tprintf(\"-1\\n\");\n    \treturn 0;\n    }\n\n    first.row = start_row;\n    first.col = start_col;\n    first.count = 0;\n\n    queue<Info> Q;\n    Q.push(first);\n\n    while(!Q.empty()){\n\n        if(Q.front().row >= 18){\n            minimum = Q.front().count;\n            break;\n        }else{\n\n            for(int i = 0; i < 8; i++){\n            \tInfo next = move(Q.front(),dir[i]);\n\n                if(rangeCheck(next.row,next.col)){\n                    Q.push(next);\n                }\n            }\n\n            Q.pop();\n        }\n    }\n\n    if(minimum == BIG_NUM){\n        printf(\"-1\\n\");\n    }else{\n        printf(\"%d\\n\",minimum);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H=19,W=15;\n\nenum DIR{\n    Left_Up,\n    Up,\n    Right_Up,\n    Left,\n    Right,\n    Left_Down,\n    Down,\n    Right_Down,\n};\n\nDIR dir[8] = {Left_Up,Up,Right_Up,Left,Right,Left_Down,Down,Right_Down};\n\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\n\nstruct BlackStone{\n    BlackStone(){\n        row = col = 0;\n    }\n\n    BlackStone(short arg_row,short arg_col){\n        row = arg_row;\n        col = arg_col;\n    }\n    short row,col;\n};\n\nstruct Info{\n    vector<BlackStone> BLACK_STONE;\n    short row,col,count;\n};\n\nbool rangeCheck(short row,short col){\n    if(row <= 17){\n        if(col < 0 || col > 14){\n            return false;\n        }else{\n            return true;\n        }\n    }else{ //row >= 18\n        if(row == 18 && (col < 0 || col > 14)){\n            return false;\n        }else{\n            return true;\n        }\n    }\n}\n\nInfo move(Info info,DIR dir){\n    Info ret;\n\n    char map[19][15];\n    for(int i = 0; i < H; i++){\n        for(int k = 0; k < W; k++)map[i][k] = '.';\n    }\n\n    for(int i = 0; i < info.BLACK_STONE.size(); i++){\n        map[info.BLACK_STONE[i].row][info.BLACK_STONE[i].col] = 'X';\n    }\n    ret.count = info.count+1;\n\n    int next_row,next_col,index;\n\n    switch(dir){\n    case Left_Up:\n        index = 0;\n        break;\n    case Up:\n        index = 1;\n        break;\n    case Right_Up:\n        index = 2;\n        break;\n    case Left:\n        index = 3;\n        break;\n    case Right:\n        index = 4;\n        break;\n    case Left_Down:\n        index = 5;\n        break;\n    case Down:\n        index = 6;\n        break;\n    case Right_Down:\n        index = 7;\n        break;\n    }\n\n    next_row = info.row+diff_row[index];\n    next_col = info.col+diff_col[index];\n\n    while(rangeCheck(next_row,next_col) == true && map[next_row][next_col] == 'X'){\n        next_row += diff_row[index];\n        next_col += diff_col[index];\n    }\n\n\n    if(next_row == info.row+diff_row[index] && next_col == info.col+diff_col[index]){\n        ret.row = 1;\n        ret.col = -1;\n    }else{\n\n        if(rangeCheck(next_row,next_col) == true && next_row <= 18){ //???????????§??????????????¢??????????????´???\n\n        \tfor(int i = 0; i < info.BLACK_STONE.size();i++){\n        \t\tret.BLACK_STONE.push_back(info.BLACK_STONE[i]);\n        \t}\n\n            int tmp_row,tmp_col;\n\n            tmp_row = info.row+diff_row[index];\n            tmp_col = info.col+diff_col[index];\n\n            while(tmp_row != next_row || tmp_col != next_col){\n                for(int i = 0; i < ret.BLACK_STONE.size();i++){\n                    if(ret.BLACK_STONE[i].row == tmp_row && ret.BLACK_STONE[i].col == tmp_col){\n                        ret.BLACK_STONE.erase(ret.BLACK_STONE.begin()+i);\n                        break;\n                    }\n                }\n                tmp_row += diff_row[index];\n                tmp_col += diff_col[index];\n            }\n        }\n\n        ret.row = next_row;\n        ret.col = next_col;\n    }\n\n    return ret;\n}\n\nint main(){\n\n    Info first;\n\n    char buf[15];\n    int minimum = BIG_NUM,start_row,start_col,num;\n    bool FLG = true;\n\n    for(short i = 0; i < H; i++){\n        scanf(\"%s\",buf);\n        if(i == 17){\n        \tnum = 0;\n        }\n        for(short k = 0; k < W; k++){\n            if(buf[k] == 'O'){\n                start_row = i;\n                start_col = k;\n            }else if(buf[k] == 'X'){\n                first.BLACK_STONE.push_back(BlackStone(i,k));\n            }\n            if((i == 17 || i == 18) && buf[k] == 'X')num++;\n        }\n        if(i == 18 && num == 0){\n        \tFLG = false;\n        }\n    }\n\n    if(!FLG){\n    \tprintf(\"-1\\n\");\n    \treturn 0;\n    }\n\n    first.row = start_row;\n    first.col = start_col;\n    first.count = 0;\n\n    queue<Info> Q;\n    Q.push(first);\n\n    while(!Q.empty()){\n\n        if(Q.front().row >= 18){\n            minimum = Q.front().count;\n            break;\n        }else{\n\n            for(int i = 0; i < 8; i++){\n            \tInfo next = move(Q.front(),dir[i]);\n\n                if(rangeCheck(next.row,next.col)){\n                    Q.push(next);\n                }\n            }\n\n            Q.pop();\n        }\n    }\n\n    if(minimum == BIG_NUM){\n        printf(\"-1\\n\");\n    }else{\n        printf(\"%d\\n\",minimum);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct state{\n  int bi,a,b;\n  bool operator<(const state& s) const {\n    if( bi == s.bi ){\n      if( a == s.a ) return b < s.b;\n      return a < s.a;\n    }\n    return bi < s.bi;\n  }\n};\n\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};\n\nmap<state,int> dp;\nchar cie[55][55];\nint fie[55][55];\nint N,W,H;\nbool check( int bi,int x,int y,int d,int &nst,int &nx,int &ny ){\n  bool f = false;\n  nst = bi;\n  nx = x + dx[d];\n  ny = y + dy[d];  \n  if( nx < 0 || nx >= W || ny < 0 || ny >= H ) return false;\n  if( cie[nx][ny] == 'X' && !(nst & (1<<fie[nx][ny])) ){\n    f = true;      \n    nst |= (1<<fie[nx][ny]);\n  }\n\n  while( f ){\n    nx = nx + dx[d];\n    ny = ny + dy[d];  \n    if( ny >= H-1 ) return true;\n    if( nx < 0 || nx >= W || ny < 0 ) return false;\n    if( cie[nx][ny] == 'X' && !(nst & (1<<fie[nx][ny])) ){\n      nst |= (1<<fie[nx][ny]);\n    } else\n      break;\n  }\n  return f;\n}\n\nint solve(int bi,int x,int y){\n  if( dp.count((state){bi,x,y}) != 0 ) return dp[(state){bi,x,y}];\n  // cout << bitset<20>(bi) << \" \"<< x << \" \"<< y << endl;\n  if( y >= H-1 ) return dp[(state){bi,x,y}] = 0;\n  int ret = (1<<29);\n  for(int i=0;i<8;i++){\n    int nx,ny,nst;\n    if( check(bi,x,y,i,nst,nx,ny) ){\n      ret = min( ret, solve(nst,nx,ny)+1);\n    }\n  }\n  return dp[(state){bi,x,y}] = ret;\n}\n\nint main(){\n  N = 0;\n  W=15;H=19;\n  int x,y;\n  for(int i=0;i<19;i++){\n    for(int j=0;j<15;j++){\n      cin >> cie[j][i];\n      if( cie[j][i] == 'X')\n\tfie[j][i] = N++;\n      if( cie[j][i] == 'O' ){\n\tx = j; y = i;\n      }\t\n    }\n  }\n  int res = solve(0,x,y);\n  if( res == (1<<29) )\n    cout << -1 << endl;\n  else \n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint bit,x,y;\n\tdata(){}\n\tdata(int bb,int yy,int xx){\n\t\tbit=bb;\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn bit<d.bit;\n\t}\n};\n\nint h,w;\nstring str[20];\nint fie[19][15];\nmap<data,int> mp;\nint bsize=0;\nP black[20];\nint sx,sy;\n\nint bfs(){\n\tqueue<data> que;\n\tque.push(data((1<<bsize)-1,sy,sx));\n\tmp[data((1<<bsize)-1,sy,sx)]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tfor(int i=-1;i<=1;i++){\n\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\tif(i==0 && j==0)continue;\n\t\t\t\tfor(int k=0;k<bsize;k++){\n\t\t\t\t\tif(d.bit>>k & 1){\n\t\t\t\t\t\tfie[black[k].first][black[k].second]=k+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfie[black[k].first][black[k].second]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint cnt=0;\n\t\t\t\tint nx=d.x;\n\t\t\t\tint ny=d.y;\n\t\t\t\tint nbit=d.bit;\n\t\t\t\tif(nx+j>=0 && nx+j<w && ny+i>=0 && ny+i<h){\n\t\t\t\t\tif(fie[ny+i][nx+j]==0)continue;\n\t\t\t\t\tnx+=j;\n\t\t\t\t\tny+=i;\n\t\t\t\t\twhile(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\t\t\t\t\tif(fie[ny][nx]==0)break;\n\t\t\t\t\t\tnbit-=1<<(fie[ny][nx]-1);\n\t\t\t\t\t\tnx+=j;\n\t\t\t\t\t\tny+=i;\n\t\t\t\t\t}\n\t\t\t\t\tif(ny>=h-1){\n\t\t\t\t\t\treturn mp[data(d.bit,d.y,d.x)]+1;\n\t\t\t\t\t}else if(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\t\t\t\t\tif(mp.find(data(nbit,ny,nx))==mp.end()){\n\t\t\t\t\t\t\tmp[data(nbit,ny,nx)]=mp[data(d.bit,d.y,d.x)]+1;\n\t\t\t\t\t\t\tque.push(data(nbit,ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\th=19;\n\tw=15;\n\tfor(int i=0;i<h;i++){\n\t\tcin >> str[i];\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(str[i][j]=='X'){\n\t\t\t\tblack[bsize++]=P(i,j);\n\t\t\t}\n\t\t\tif(str[i][j]=='O'){\n\t\t\t\tsy=i;\n\t\t\t\tsx=j;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",bfs());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H=19,W=15;\n\nenum DIR{\n\tLeft_Up,\n\tUp,\n\tRight_Up,\n\tLeft,\n\tRight,\n\tLeft_Down,\n\tDown,\n\tRight_Down,\n};\n\nDIR dir[8] = {Left_Up,Up,Right_Up,Left,Right,Left_Down,Down,Right_Down};\n\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\n\nstruct BlackStone{\n\tBlackStone(){\n\t\trow = col = 0;\n\t}\n\n\tBlackStone(short arg_row,short arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tshort row,col;\n};\n\nstruct Info{\n\tvector<BlackStone> BLACK_STONE;\n\tbool operator<(const struct Info &arg) const{\n\t\t\treturn row > arg.row;\n\t};\n\tshort row,col,count;\n};\n\nbool rangeCheck(short row,short col){\n\tif(row <= 17){\n\t\tif(col < 0 || col > 14){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}else{ //row >= 18\n\t\tif(row == 18 && (col < 0 || col > 14)){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\nInfo move(Info info,DIR dir){\n\tInfo ret;\n\n\tchar map[19][15];\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)map[i][k] = '.';\n\t}\n\n\tfor(int i = 0; i < info.BLACK_STONE.size(); i++){\n\t\tmap[info.BLACK_STONE[i].row][info.BLACK_STONE[i].col] = 'X';\n\t\tBlackStone new_stone;\n\t\tnew_stone.row = info.BLACK_STONE[i].row;\n\t\tnew_stone.col = info.BLACK_STONE[i].col;\n\t\tret.BLACK_STONE.push_back(new_stone);\n\t}\n\tret.count = info.count+1;\n\n\tint next_row,next_col,index;\n\n\tswitch(dir){\n\tcase Left_Up:\n\t\tindex = 0;\n\t\tbreak;\n\tcase Up:\n\t\tindex = 1;\n\t\tbreak;\n\tcase Right_Up:\n\t\tindex = 2;\n\t\tbreak;\n\tcase Left:\n\t\tindex = 3;\n\t\tbreak;\n\tcase Right:\n\t\tindex = 4;\n\t\tbreak;\n\tcase Left_Down:\n\t\tindex = 5;\n\t\tbreak;\n\tcase Down:\n\t\tindex = 6;\n\t\tbreak;\n\tcase Right_Down:\n\t\tindex = 7;\n\t\tbreak;\n\t}\n\n\tnext_row = info.row+diff_row[index];\n\tnext_col = info.col+diff_col[index];\n\n\twhile(rangeCheck(next_row,next_col) == true && map[next_row][next_col] == 'X'){\n\t\tnext_row += diff_row[index];\n\t\tnext_col += diff_col[index];\n\t}\n\n\tif(next_row == info.row+diff_row[index] && next_col == info.col+diff_col[index]){\n\t\tret.row = 1;\n\t\tret.col = -1;\n\t}else{\n\n\t\tint tmp_row,tmp_col;\n\n\t\ttmp_row = info.row+diff_row[index];\n\t\ttmp_col = info.col+diff_col[index];\n\n\t\twhile(tmp_row != next_row || tmp_col != next_col){\n\t\t\tfor(int i = 0; i < ret.BLACK_STONE.size();i++){\n\t\t\t\tif(ret.BLACK_STONE[i].row == tmp_row && ret.BLACK_STONE[i].col == tmp_col){\n\t\t\t\t\tret.BLACK_STONE.erase(ret.BLACK_STONE.begin()+i);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp_row += diff_row[index];\n\t\t\ttmp_col += diff_col[index];\n\t\t}\n\n\t\tret.row = next_row;\n\t\tret.col = next_col;\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\n\tInfo first;\n\n\tchar buf[15];\n\tint minimum = BIG_NUM,start_row,start_col;\n\n\tfor(short i = 0; i < H; i++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(short k = 0; k < W; k++){\n\t\t\tif(buf[k] == 'O'){\n\t\t\t\tstart_row = i;\n\t\t\t\tstart_col = k;\n\t\t\t}else if(buf[k] == 'X'){\n\t\t\t\tfirst.BLACK_STONE.push_back(BlackStone(i,k));\n\t\t\t}\n\t\t}\n\t}\n\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.count = 0;\n\n\tpriority_queue<Info> Q;\n\tQ.push(first);\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().row >= 18){\n\t\t\tminimum = Q.top().count;\n\t\t\tbreak;\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 8; i++){\n\t\t\t\tInfo next = move(Q.top(),dir[i]);\n\n\t\t\t\tif(rangeCheck(next.row,next.col)){\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(minimum == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n\nint main(){\n  vector<string> vec(19);\n  rep(i,19) cin>>vec[i];\n  int n = 0;\n  // vector<int> x,y;\n  map<pair<int,int>,int> p2i;\n  rep(i,19)rep(j,15) if(vec[i][j]=='X'){\n    // x.pb(i);\n    // y.pb(j);\n    p2i[mp(i,j)] = n++;\n  }\n  int sx,sy;\n  rep(i,19)rep(j,15) if(vec[i][j]=='O') sx=i, sy=j;\n\n  using state = pair<int,pair<int,int>>;\n\n  auto ok = [&](int i, int j){\n    return i>=0 && i<19 && j>=0 && j<15;\n  };\n\n  set<state> prev;\n  prev.insert(mp(0,mp(sx,sy)));\n\n  rep(i,20){\n    set<state> nxt;\n    for(const state & s : prev){\n      int mask = s.fi;\n      int x = s.se.fi, y = s.se.se;\n      for(int dx=-1; dx<=1; dx++){\n        for(int dy=-1; dy<=1; dy++) if(dx*dx+dy*dy>0){\n          int nmask = mask;\n          int d = 1;\n          while(ok(x+dx*d,y+dy*d) && vec[x+dx*d][y+dy*d]=='X'){\n            int idx = p2i[mp(x+dx*d, y+dy*d)];\n            if(! (mask & (1<<idx)) ){\n              nmask |= (1<<idx);\n              d++;\n            }\n            else {\n              break;\n            }\n          }\n          if(d==1) continue;\n          int nx=x+dx*d, ny=y+dy*d;\n          if(nx>=18){\n            cout << i+1 << endl;\n            return 0;\n          }\n          if(ok(nx,ny)) nxt.insert(mp(nmask,mp(nx,ny)));\n        }\n      }\n    }\n    swap(nxt, prev);\n  }\n\n  cout << -1 << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef vector<vector<bool>> Map;\ntypedef tuple<pair<int, int>, Map, int> T;\n\nconst int h = 20, w = 17;\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint ans;\nMap c;\n\nbool impossible(int y, Map& c){\n\tvector<bool> no(h,0);\n\trange(i,y + 1,18){\n\t\tbool f = false;\n\t\trep(j,w){\n\t\t\tif(c[i][j]) f = true;\n\t\t}\n\t\tif(not f) no[i] = true;\n\t}\n\trep(i,h - 1){\n\t\tif(no[i] and no[i + 1]) return true;\n\t}\n\treturn false;\n}\n\nmap<Map, map<pair<int, int>, int>> memo;\n\nvoid dfs(int y, int x, int cost){\n\tif(memo.count(c) and memo[c].count(make_pair(y,x)) and memo[c][make_pair(y,x)] <= cost) return;\n\tmemo[c][make_pair(y,x)] = cost;\n\n\tif(y == 18 or y == 19){\n\t\tans = min(ans, cost);\n\t\treturn;\n\t}\n\n\tif(impossible(y, c)) return;\n\n\trep(i,8){\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)) continue;\n\t\tif(c[ny][nx] == 1){\n\t\t\tvector<pair<int, int>> tmp;\n\t\t\twhile(true){\n\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\tny = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\tny = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(c[ny][nx] == 0) break;\n\t\t\t\ttmp.emplace_back(ny,nx);\n\t\t\t\t//pc[ny][nx] = 0;\n\t\t\t\tny = ny + dy[i];\n\t\t\t\tnx = nx + dx[i];\n\t\t\t}\n\t\t\tif(ny == -1) continue;\n\n\t\t\tfor(auto i : tmp) c[i.first][i.second] = 0;\n\t\t\tdfs(ny, nx, cost + 1);\n\t\t\tfor(auto i : tmp) c[i.first][i.second] = 1;\n\t\t}\n\t}\n}\n\nint main(){\n\tpair<int, int> s;\n\tc = Map(h, vector<bool>(w));\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tchar a;\n\t\t\tcin >> a;\n\t\t\tif(a == 'X') c[i][j + 1] = 1;\n\t\t\telse c[i][j + 1] = 0;\n\t\t\tif(a == 'O'){\n\t\t\t\ts = make_pair(i,j + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tans = 1e9;\n\tdfs(s.first, s.second, 0);\n\tcout << (ans == 1e9 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\nint BFS(vector<string> v)\n{\n\tmap<vector<string>, int> d; d[v] = 1;\n\n\tqueue<pair<vector<string>, int> > que; que.push(make_pair(v, 1));\n\n\tfor (int i = 0; i < 15; i++)\n\t{\n\t\tif (v[18][i] == 'O')\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tvector<string> v1 = que.front().first;\n\n\t\tint dist = que.front().second; que.pop();\n\n\t\tint sx = -1, sy = -1;\n\n\t\tfor (int i = 0; i < 19; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 15; j++)\n\t\t\t{\n\t\t\t\tif (v1[i][j] == 'O')\n\t\t\t\t{\n\t\t\t\t\tsx = j; sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\tif (0 <= sx + dx[dir] && sx + dx[dir] < 15 && 0 <= sy + dy[dir] && sy + dy[dir] < 19)\n\t\t\t{\n\t\t\t\tif (v1[sy + dy[dir]][sx + dx[dir]] == 'X')\n\t\t\t\t{\n\t\t\t\t\tif (sx == 3 && sy == 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tint a = 3;\n\t\t\t\t\t}\n\t\t\t\t\tint x = sx + dx[dir] * 2;\n\t\t\t\t\tint y = sy + dy[dir] * 2;\n\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (y > 18) { return dist; }\n\n\t\t\t\t\t\tif (x < 0 || 15 <= x || y < 0) { break; }\n\n\t\t\t\t\t\tif (y > 17) { return dist; }\n\n\t\t\t\t\t\tif (v1[y][x] == '.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvector<string> v2 = v1;\n\n\t\t\t\t\t\t\tint rx = sx, ry = sy;\n\n\t\t\t\t\t\t\tfor (; x != rx || y != ry;)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tv2[ry][rx] = '.';\n\n\t\t\t\t\t\t\t\trx += dx[dir];\n\t\t\t\t\t\t\t\try += dy[dir];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tv2[y][x] = 'O';\n\n\t\t\t\t\t\t\tif (d[v2] == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\td[v2] = dist + 1;\n\n\t\t\t\t\t\t\t\tque.push(make_pair(v2, dist + 1));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgoto Exit;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx += dx[dir];\n\t\t\t\t\t\ty += dy[dir];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tExit:;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tvector<string> v(19);\n\n\tfor (int i = 0; i < 19; i++) { cin >> v[i]; }\n\n\tcout << BFS(v) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n//変数\nconstexpr int H = 19;\nconstexpr int W = 15;\nint ans = INF;\n\n\nbool out(const int& count, const pair<int,int>& next)\n{\n\tint y = next.first;\n\tint x = next.second;\n\n\tif (x < 0)return true;\n\tif (y < 0)return true;\n\tif (14 < x)return true;\n\tif (18 < y) {\n\t\tans = min(ans, count);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint gap(pair<int, int> l, pair<int, int> r)\n{\n\tint a = abs(l.first - r.first);\n\tint b = abs(l.second - r.second);\n\treturn max(a, b);\n}\n\nvoid step(\n\tconst vector<vector<bool>>& goban,\n\tconst pair<int,int>& now,\n\tconst int& count)\n{\n\tconstexpr int dirSiz = 8;\n\tconstexpr int dh[] = { -1,0,1,1,1,0,-1,-1 };\n\tconstexpr int dw[] = { 1,1,1,0,-1,-1,-1,0 };\n\tif (ans <= count)return;\n\n\tREP(i, dirSiz) {\n\t\tauto nextGoban = goban;\n\t\tauto next = now;\n\n\t\twhile (true) {\n\t\t\tnext.first += dh[i];\n\t\t\tnext.second += dw[i];\n\t\t\tif (out(count, next))break;\n\n\t\t\tif (nextGoban[next.first][next.second]) {\n\t\t\t\tnextGoban[next.first][next.second] = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (gap(now, next) <= 1) {\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tif (18 <= next.first) {\n\t\t\t\tans = min(ans, count);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstep(nextGoban, next, count + 1);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin >> N;\n}\n\n\n//メイン関数\nint main()\n{\n\tpair<int, int> start;\n\tvector<vector<bool>> goban;\n\tREP(i, H) {\n\t\tstring tmp;\n\t\tvector<bool> row;\n\t\tcin >> tmp;\n\t\tREP(j,W){\n\t\t\tchar c = tmp[j];\n\t\t\trow.push_back(c == 'X');\n\t\t\tif (c == 'O')start = { i,j };\n\t\t}\n\t\tgoban.push_back(row);\n\t}\n\n\tstep(goban, start, 1);\n\tif (ans == INF)ans = -1;\n\tcout << ans << endl;\n\n\tdebug();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint bit,x,y;\n\tdata(){}\n\tdata(int bb,int yy,int xx){\n\t\tbit=bb;\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn bit<d.bit;\n\t}\n};\n\nint h,w;\nstring str[20];\nint fie[19][15];\nmap<data,int> mp;\nint bsize=0;\nP black[20];\nint sx,sy;\n\nint bfs(){\n\tqueue<data> que;\n\tque.push(data((1<<bsize)-1,sy,sx));\n\tmp[data((1<<bsize)-1,sy,sx)]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tfor(int i=-1;i<=1;i++){\n\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\tif(i==0 && j==0)continue;\n\t\t\t\tfor(int k=0;k<bsize;k++){\n\t\t\t\t\tif(d.bit>>k & 1){\n\t\t\t\t\t\tfie[black[k].first][black[k].second]=k+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfie[black[k].first][black[k].second]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint cnt=0;\n\t\t\t\tint nx=d.x;\n\t\t\t\tint ny=d.y;\n\t\t\t\tint nbit=d.bit;\n\t\t\t\tif(nx+j>=0 && nx+j<w && ny+i>=0 && ny+i<h){\n\t\t\t\t\tif(fie[ny+i][nx+j]==0)continue;\n\t\t\t\t\tnx+=j;\n\t\t\t\t\tny+=i;\n\t\t\t\t\twhile(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\t\t\t\t\tif(fie[ny][nx]==0)break;\n\t\t\t\t\t\tnbit-=1<<(fie[ny][nx]-1);\n\t\t\t\t\t\tnx+=j;\n\t\t\t\t\t\tny+=i;\n\t\t\t\t\t}\n\t\t\t\t\tif(ny>=h){\n\t\t\t\t\t\treturn mp[data(d.bit,d.y,d.x)]+1;\n\t\t\t\t\t}else if(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\t\t\t\t\tif(mp.find(data(nbit,ny,nx))==mp.end()){\n\t\t\t\t\t\t\tmp[data(nbit,ny,nx)]=mp[data(d.bit,d.y,d.x)]+1;\n\t\t\t\t\t\t\tque.push(data(nbit,ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\th=19;\n\tw=15;\n\tfor(int i=0;i<h;i++){\n\t\tcin >> str[i];\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(str[i][j]=='X'){\n\t\t\t\tblack[bsize++]=P(i,j);\n\t\t\t}\n\t\t\tif(str[i][j]=='O'){\n\t\t\t\tsy=i;\n\t\t\t\tsx=j;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",bfs());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nstring s[19];\nint sx = -1, sy = -1, ans,\n\tvx[8] = {-1, -1, 0, 1, 1, 1, 0, -1},\n\tvy[8] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ninline bool check(int x, int y) {\n\treturn (0 <= x && x < 19 && 0 <= y && y < 15);\n}\n\nint search(int x, int y, int cnt) {\n\tint ret = (int)1e9;\n\n\t//cout << \"now is\" << x << \" \" << y << endl;\n\n\tfor (int i = 0; i < 8; ++i) {\n\t\tint nx = x + vx[i], ny = y + vy[i], nnx, nny;\n\n\t\tif (check(nx, ny)) {\n\t\t\tif (s[nx][ny] == 'X') {\n\t\t\t\tnnx = nx + vx[i], nny = ny + vy[i];\n\n\t\t\t\tfor (int j = 1; ; ++j) {\n\t\t\t\t\tif (nnx > 18) {\n\t\t\t\t\t\t//cout << \"now : \" << x << \" \" << y << endl;\n\t\t\t\t\t\t//cout << \"goal: \" << ret << \" \" << j << endl;\n\t\t\t\t\t\tret = min(ret, cnt + 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!check(nnx, nny)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (check(nnx, nny) && s[nnx][nny] == '.') {\n\t\t\t\t\t\tstring tmp[19];\n\t\t\t\t\t\tint xx = nx, yy = ny;\n\t\t\t\t\t\tfor (int k = 0; k < 19; ++k) tmp[k] = s[k];\n\n\t\t\t\t\t\t//for (int z = 0; z < 19; ++z) cout << s[z] << endl;\n\t\t\t\t\t\twhile ((xx != nnx || yy != nny)) {\n\t\t\t\t\t\t\ts[xx][yy] = '.';\n\t\t\t\t\t\t\txx += vx[i], yy += vy[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//cout << \"nnx,nny\" << nnx << ' ' << nny << endl;\n\t\t\t\t\t\t//for (int z = 0; z < 19; ++z) cout << s[z] << endl;\n\n\t\t\t\t\t\tint ret_s = search(nnx, nny, cnt + 1);\n\t\t\t\t\t\tif (ret_s != -1) {\n\t\t\t\t\t\t\t//cout << \"ret, j + ret_s \"<< ret << \" \" << j + ret_s << endl;\n\t\t\t\t\t\t\t//cout << \"ret_s : \" << ret_s << endl;\n\t\t\t\t\t\t\tret = min(ret, ret_s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (int k = 0; k < 19; ++k) {\n\t\t\t\t\t\t\ts[k] = tmp[k];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tnnx += vx[i], nny += vy[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ret == (int)1e9) return -1;\n\n\t//cout << \"return \" << x << \", \" << y << \" = \" << ret << endl;\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor (int i = 0; i < 19; ++i) {\n\t\tcin >> s[i];\n\n\t\tif (sx == -1) {\n\t\t\tfor (int j = 0; j < 15; ++j) {\n\t\t\t\tif (s[i][j] == 'O') {\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tans = search(sx, sy, 0);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> Q;\n\nconst int INF = 100000000;\n\nchar d[19][16];\n\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\n\nbool out(int x, int y) {\n  return x < 0 || y < 0 || x >= 15 || y >= 19;\n}\n\nbool goal(int x, int y) {\n  return y >= 18;\n}\n\nbool black(int x, int y) {\n  return d[y][x] == 'X';\n}\n\nvoid ret(int x, int y, int X, int Y, int j) {\n  x += dx[j], y += dy[j];\n  while (!(x == X && y == Y)) {\n    d[y][x] = 'X';\n    x += dx[j], y += dy[j];\n  }\n}\n\nint solve(int X, int Y, int counter) {\n  counter++;\n  int ans = INF;\n  for (int i = 0; i < 8; i++) {\n    int x = X + dx[i], y = Y + dy[i];\n    if (out(x, y)) continue;\n    if (!black(x, y)) continue;\n    while (!out(x, y) && black(x, y)) {\n      d[y][x] = '.';\n      x += dx[i], y += dy[i];\n    }\n    if (goal(x, y)) {\n      ret(x, y, X, Y, (i + 4) % 8);\n      return counter;\n    }\n    if (out(x, y)) {\n      ret(x, y, X, Y, (i + 4) % 8);\n      continue;\n    }\n    ans = min(ans, solve(x, y, counter));\n    ret(x, y, X, Y, (i + 4) % 8);\n  }\n  return ans;\n}\n\nint main() {\n  for (int i = 0; i < 19; i++) scanf(\"%s\", d[i]);\n  int x, y;\n  for (int i = 0; i < 19; i++) {\n    for (int j = 0; j < 15; j++) {\n      if (d[i][j] == 'O') {\n        d[i][j] = '.';\n        x = j, y = i;\n        i = 19,j = 16;\n      }\n    }\n  }\n  int ans = solve(x, y, 0);\n  if (ans == INF) ans = -1;\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\nint BFS(vector<string> v)\n{\n\tmap<vector<string>, int> d; d[v] = 1;\n\n\tqueue<pair<vector<string>, int> > que; que.push(make_pair(v, 1));\n\n\tfor (int i = 0; i < 15; i++)\n\t{\n\t\tif (v[18][i] == 'O')\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tvector<string> v1 = que.front().first;\n\n\t\tint dist = que.front().second; que.pop();\n\n\t\tint sx = -1, sy = -1;\n\n\t\tfor (int i = 0; i < 19; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 15; j++)\n\t\t\t{\n\t\t\t\tif (v1[i][j] == 'O')\n\t\t\t\t{\n\t\t\t\t\tsx = j; sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\tif (0 <= sx + dx[dir] && sx + dx[dir] < 15 && 0 <= sy + dy[dir] && sy + dy[dir] < 19)\n\t\t\t{\n\t\t\t\tif (v1[sy + dy[dir]][sx + dx[dir]] == 'X')\n\t\t\t\t{\n\t\t\t\t\tint x = sx + dx[dir] * 2;\n\t\t\t\t\tint y = sy + dy[dir] * 2;\n\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (y > 18) { return dist; }\n\n\t\t\t\t\t\tif (x < 0 || 15 <= x || y < 0) { break; }\n\n\t\t\t\t\t\tif (y > 17) { return dist; }\n\n\t\t\t\t\t\tif (v1[y][x] == '.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvector<string> v2 = v1;\n\n\t\t\t\t\t\t\tint rx = sx, ry = sy;\n\n\t\t\t\t\t\t\tfor (; x != rx || y != ry;)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tv2[ry][rx] = '.';\n\n\t\t\t\t\t\t\t\trx += dx[dir];\n\t\t\t\t\t\t\t\try += dy[dir];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tv2[y][x] = 'O';\n\n\t\t\t\t\t\t\tif (d[v2] == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\td[v2] = dist + 1;\n\n\t\t\t\t\t\t\t\tque.push(make_pair(v2, dist + 1));\n\n\t\t\t\t\t\t\t\tgoto Exit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx += dx[dir];\n\t\t\t\t\t\ty += dy[dir];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tExit:;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tvector<string> v(19);\n\n\tfor (int i = 0; i < 19; i++) { cin >> v[i]; }\n\n\tcout << BFS(v) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <deque>\n#include <tuple>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> T;//B,x,y\ntypedef tuple<int,int,int,int> T4;//d,B,x,y\nvector<P> B;\nint board[15][20];\n\nint main(){\n    fill(board[0],board[20],-1);\n    int ox,oy;\n    for(int i=0;i<19;i++){\n        for(int j=0;j<15;j++){\n            char c;\n            cin>>c;\n            if(c=='O'){\n                oy=i; ox=j;\n            }else if(c=='X'){\n                board[j][i]=B.size();\n                B.emplace_back(j,i);\n            }\n        }\n    }\n    /*\n    for(int i=0;i<20;i++){\n        for(int j=0;j<15;j++){\n            if(board[j][i]==-1) cout<<'.';\n            else cout<<board[j][i];\n        }\n        cout<<endl;\n    }\n    */\n    deque<T4> que;\n    que.emplace_back(0,(1<<B.size())-1,ox,oy);\n    while(!que.empty()){\n        int d,bb,x,y;\n        tie(d,bb,x,y)=que.front(); que.pop_front();\n        // cout<<d<<' '<<bb<<' '<<x<<' '<<y<<endl;\n        if(y>=18){\n            cout<<d<<endl;\n            return 0;\n        }\n        if(y<0||x<0||x==15) continue;\n        for(int dy=-1;dy<=1;dy++){\n            for(int dx=-1;dx<=1;dx++){\n                if(!dx&&!dy)continue;\n                if(x+dx<0||x+dx>=15) continue;\n                if(y+dy<0||y+dy>=19) continue;\n                if(board[x+dx][y+dy]==-1) continue;\n                else{\n                    if(bb&(1<<board[x+dx][y+dy])){\n                        int l=2;\n                        int bbb=bb^(1<<board[x+dx][y+dy]);\n                        while(true){\n                            if(x+dx*l<0||x+dx*l>=15||y+dy*l<0||y+dy*l>=19){\n                                break;\n                            }else{\n                                if(board[x+dx*l][y+dy*l]==-1){\n                                    break;\n                                }else{\n                                    if((1<<board[x+dx*l][y+dy*l])&bbb){\n                                        bbb^=1<<board[x+dx*l][y+dy*l];\n                                        l++;\n                                        continue;\n                                    }else{\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        que.emplace_back(d+1,bbb,x+dx*l,y+dy*l);\n                    }\n                }\n            }\n        }\n\n    }\n    cout<<-1<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct state{\n  int bi,a,b;\n  bool operator<(const state& s) const {\n    if( bi == s.bi ){\n      if( a == s.a ) return b < s.b;\n      return a < s.a;\n    }\n    return bi < s.bi;\n  }\n};\n\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};\n\n\nmap<state,int> dp;\nchar cie[55][55];\nint fie[55][55];\nint N,W,H;\nbool check( int bi,int x,int y,int d,int &nst,int &nx,int &ny ){\n  bool f = false;\n  nst = bi;\n  nx = x + dx[d];\n  ny = y + dy[d];  \n  if( nx < 0 || nx >= W || ny < 0 || ny >= H ) return false;\n  if( cie[nx][ny] == 'X' && !(nst & (1<<fie[nx][ny])) ){\n    f = true;      \n    nst |= (1<<fie[nx][ny]);\n  }\n\n  while( f ){\n    nx = nx + dx[d];\n    ny = ny + dy[d];  \n    if( ny > H-1 || ( ny == H-1 && 0 <= nx && nx < W ) ) return true;\n    if( nx < 0 || nx >= W || ny < 0 ) return false;\n    if( cie[nx][ny] == 'X' && !(nst & (1<<fie[nx][ny])) ){\n      nst |= (1<<fie[nx][ny]);\n    } else\n      break;\n  }\n  return f;\n}\n\nint solve(int bi,int x,int y){\n  if( dp.find((state){bi,x,y}) != dp.end() ) return dp[(state){bi,x,y}];\n  // cout << bitset<20>(bi) << \" \"<< x << \" \"<< y << endl;\n  if( y > H-1 || ( y == H-1 && 0 <= x && x < W ) ) return dp[(state){bi,x,y}] = 0;\n  int ret = (1<<29);\n  for(int i=0;i<8;i++){\n    int nx,ny,nst;\n    if( check(bi,x,y,i,nst,nx,ny) ){\n      ret = min( ret, solve(nst,nx,ny)+1);\n    }\n  }\n  return dp[(state){bi,x,y}] = ret;\n}\n\nint main(){\n  N = 0;\n  W=15;H=19;\n  int x,y;\n  for(int i=0;i<19;i++){\n    for(int j=0;j<15;j++){\n      cin >> cie[j][i];\n      if( cie[j][i] == 'X')\n\tfie[j][i] = N++;\n      if( cie[j][i] == 'O' ){\n\tx = j; y = i;\n      }\t\n    }\n  }\n  int res = solve(0,x,y);\n  if( res == (1<<29) )\n    cout << -1 << endl;\n  else \n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconst int INF = (1 << 30);\n\n//変数\nconstexpr int H = 19;\nconstexpr int W = 15;\nint ans = INF;\n\n\nvoid visualize(const vector<vector<bool>>& goban, pair<int, int> now)\n{\n\tcerr << \"===================\" << endl;\n\tcerr << now.first << \":::\" << now.second << endl;\n\tREP(i, H){\n\t\tREP(j, W) {\n\t\t\tif (now.first == i && now.second == j)cerr << \"o\";\n\t\t\telse cerr << (goban[i][j] ? \"X\" : \".\");\n\t\t}\n\t\tcerr << endl;\n\t}\n\tcerr << \"===================\" << endl;\n}\n\nbool out(const int& count, const pair<int,int>& next)\n{\n\tint y = next.first;\n\tint x = next.second;\n\n\tif (x < 0)return true;\n\tif (y < 0)return true;\n\tif (14 < x)return true;\n\tif (18 < y) {\n\t\tans = min(ans, count);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint gap(pair<int, int> l, pair<int, int> r)\n{\n\tint a = abs(l.first - r.first);\n\tint b = abs(l.second - r.second);\n\treturn max(a, b);\n}\n\nvoid step(\n\tconst vector<vector<bool>>& goban,\n\tconst pair<int,int>& now,\n\tconst int& count)\n{\n\tconstexpr int dirSiz = 8;\n\tconstexpr int dh[] = { -1,0,1,1,1,0,-1,-1 };\n\tconstexpr int dw[] = { 1,1,1,0,-1,-1,-1,0 };\n\tif (ans <= count)return;\n\n\t//visualize(goban, now);\n\n\tREP(i, dirSiz) {\n\t\tauto nextGoban = goban;\n\t\tauto next = now;\n\n\t\twhile (true) {\n\t\t\tnext.first += dh[i];\n\t\t\tnext.second += dw[i];\n\t\t\tif (out(count, next))break;\n\n\t\t\tif (nextGoban[next.first][next.second]) {\n\t\t\t\tnextGoban[next.first][next.second] = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (gap(now, next) <= 1) {\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tif (18 <= next.first) {\n\t\t\t\tans = min(ans, count);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!out(count, next)) {\n\t\t\t\t\tstep(nextGoban, next, count + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin >> N;\n}\n\n\n//メイン関数\nint main()\n{\n\tpair<int, int> start;\n\tvector<vector<bool>> goban;\n\tREP(i, H) {\n\t\tstring tmp;\n\t\tvector<bool> row;\n\t\tcin >> tmp;\n\t\tREP(j,W){\n\t\t\tchar c = tmp[j];\n\t\t\trow.push_back(c == 'X');\n\t\t\tif (c == 'O')start = { i,j };\n\t\t}\n\t\tgoban.push_back(row);\n\t}\n\n\tstep(goban, start, 1);\n\tif (ans == INF)ans = -1;\n\tcout << ans << endl;\n\n\tdebug();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <tuple>\n#include <string>\n#include <queue>\n\nsize_t H = 19;\nsize_t W = 15;\n\nconstexpr size_t m1 = -1;\nconstexpr size_t di[] = {m1, m1, m1, 0, 0, 1, 1, 1};\nconstexpr size_t dj[] = {m1, 0, 1, m1, 1, m1, 0, 1};\n\ntemplate <class Tp>\nconstexpr Tp inf = Tp(1) << (8*sizeof(Tp)-3);\n\nint dfs(std::vector<std::string>& s, size_t i, size_t j) {\n  // char tmp = s[i][j];\n  // s[i][j] = '@';\n  // for (const auto& si: s)\n  //   fprintf(stderr, \"%s\\n\", si.c_str());\n  // fprintf(stderr, \"---\\n\");\n  // s[i][j] = tmp;\n\n  int res = inf<int>;\n  for (int k = 0; k < 8; ++k) {\n    size_t ni = i + di[k];\n    size_t nj = j + dj[k];\n    if (!(ni < H && nj < W && s[ni][nj] == 'X')) continue;\n\n    std::vector<std::pair<size_t, size_t>> jmp;\n    do {\n      jmp.emplace_back(ni, nj);\n      ni += di[k];\n      nj += dj[k];\n      if (ni == H) return 1;\n      if (ni+1 == H && nj < W) return 1;\n      if (!(ni < H && nj < W)) break;  // cannot jump\n      if (s[ni][nj] != 'X') {\n        for (const auto& p: jmp) {\n          size_t ji, jj;\n          std::tie(ji, jj) = p;\n          s[ji][jj] = '.';\n        }\n        res = std::min(res, 1 + dfs(s, ni, nj));\n        for (const auto& p: jmp) {\n          size_t ji, jj;\n          std::tie(ji, jj) = p;\n          s[ji][jj] = 'X';\n        }\n        break;\n      }\n    } while (true);\n  }\n  return res;\n}\n\nint main() {\n  std::vector<std::string> s(H);\n  size_t si = -1;\n  size_t sj = -1;\n  for (size_t i = 0; i < H; ++i) {\n    char buf[16];\n    scanf(\"%s\", buf);\n    s[i] = buf;\n    for (size_t j = 0; j < W; ++j) {\n      if (s[i][j] == 'O') {\n        si = i;\n        sj = j;\n      }\n    }\n  }\n  // s.insert(s.begin(), std::string(W, '.'));\n  // ++H;\n  // ++si;\n\n  int res = dfs(s, si, sj);\n  if (res == inf<int>) return puts(\"-1\"), 0;\n  printf(\"%d\\n\", res);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst int h = 19;\nconst int w = 15;\n\nstruct Data { int x,y,bitmask; };\n\nchar a[20][20];\nint mindist[1<<20];\nint Index[20][20];\n\nbool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nvoid compute(){\n  int black = 0;\n  int sx=-1,sy=-1;\n  rep(i,h) rep(j,w) {\n    if( a[i][j] == 'X' ) Index[i][j] = black++;\n    if( a[i][j] == 'O' ) sx = j, sy = i;\n  }\n  rep(i,(1<<black)) mindist[i] = IINF;\n  mindist[(1<<black)-1] = 0;\n  deque<Data> deq;\n  deq.push_back((Data){sx,sy,(1<<black)-1});\n  while( !deq.empty() ){\n    Data data = deq.front(); deq.pop_front();\n    REP(dx,-1,2){\n      REP(dy,-1,2){\n        if( dx == 0 && dy == 0 ) continue;\n        int nx = data.x + dx, ny = data.y + dy, nbitmask = data.bitmask;\n        bool valid = false;\n        while( isValid(nx,ny) && ( a[ny][nx] == 'X' && ( data.bitmask & (1<<Index[ny][nx]) ) ) ){\n          nbitmask &= ~(1<<Index[ny][nx]);\n          nx += dx, ny += dy;\n          valid = true;\n        }\n        if( !isValid(nx,ny) ) {\n          if( valid && ( 0 <= nx && nx < w ) && ny >= h ) {\n            cout << mindist[data.bitmask]+1 << endl;\n            return;\n          }\n          continue;\n        }\n        if( !valid ) continue;\n        if( mindist[nbitmask] > mindist[data.bitmask] + 1 ) {\n          mindist[nbitmask] = mindist[data.bitmask] + 1;\n          deq.push_back((Data){nx,ny,nbitmask});\n        }\n      }\n    }\n  }\n  puts(\"-1\");\n}\n\nint main(){\n  rep(i,h) rep(j,w) scanf(\" %c\",&a[i][j]);\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 19;\nconst int W = 15;\nvector<string> board(H);\nvector<int> xhs, xws;\nint d[1<<20][H][W];\n\nclass State{\npublic:\n    int xstate;\n    int h, w;\n    \n//    bool operator < (const State &r) const{\n//        int xl = xstate * H * W + h * W + w;\n//        int xr = r.xstate * H * W + r.h * W + r.w;\n//        return xl < xr;\n//    }\n};\n\ninline bool infield(int h, int w){\n    if(h == H)\n        return true;\n    else\n        return 0<=w && w<W;\n}\n\nint bfs(int sh, int sw){\n    int xn = xhs.size();\n    map<pair<int, int>, int> ipoint;\n    for(int i=0; i<xn; i++)\n        ipoint[{xhs[i], xws[i]}] = i;\n    \n    queue<State> que;\n    State s;\n    s.xstate = (1<<xn)-1;\n    s.h = sh;\n    s.w = sw;\n    que.push(s);\n    \n    memset(d, -1, sizeof(d));\n    d[s.xstate][s.h][s.w] = 0;\n    \n    while(!que.empty()){\n        auto s = que.front(); que.pop();\n        \n        for(int dh=-1; dh<=1; dh++){\n            for(int dw=-1; dw<=1; dw++) if(dh != 0 || dw != 0){\n                State ns;\n                ns.xstate = s.xstate;\n                ns.h = s.h + dh;\n                ns.w = s.w + dw;\n                \n                if(ipoint.find({ns.h, ns.w}) == ipoint.end() || ((ns.xstate>>ipoint[{ns.h, ns.w}])&1) == 0)\n                    continue;\n                \n                int count = 0;\n                while(infield(ns.h, ns.w) && ipoint.find({ns.h, ns.w})!= ipoint.end() && (ns.xstate>>ipoint[{ns.h, ns.w}])&1){\n                    ns.h += dh;\n                    ns.w += dw;\n                    count++;\n                }\n                if(!infield(ns.h, ns.w))\n                    continue;\n                \n                ns.h = s.h + dh;\n                ns.w = s.w + dw;\n                for(int i=0; i<count; i++){\n                    ns.xstate -= 1<<ipoint[{ns.h, ns.w}];\n                    ns.h += dh;\n                    ns.w += dw;\n                }\n                \n                if(d[ns.xstate][ns.h][ns.w] >= 0)\n                    continue;\n                \n                que.push(ns);\n                d[ns.xstate][ns.h][ns.w] = d[s.xstate][s.h][s.w] + 1;\n                \n                if(H-1<=ns.h){\n                    return d[ns.xstate][ns.h][ns.w];\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    for(auto &s: board) cin >> s;\n    \n    int sh, sw;\n    for(int h=0; h<H; h++){\n        for(int w=0; w<W; w++){\n            if(board[h][w] == 'O')\n                sh = h, sw = w;\n            if(board[h][w] == 'X')\n                xhs.push_back(h), xws.push_back(w);\n        }\n    }\n    cout << bfs(sh, sw) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\nint BFS(vector<string> v)\n{\n\tmap<vector<string>, int> d; d[v] = 1;\n\n\tqueue<pair<vector<string>, int> > que; que.push(make_pair(v, 1));\n\n\tfor (int i = 0; i < 19; i++)\n\t{\n\t\tif (v[14][i] == 'O')\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tvector<string> v1 = que.front().first;\n\n\t\tint dist = que.front().second; que.pop();\n\n\t\tint sx = -1, sy = -1;\n\n\t\tfor (int i = 0; i < 15; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 19; j++)\n\t\t\t{\n\t\t\t\tif (v1[i][j] == 'O')\n\t\t\t\t{\n\t\t\t\t\tsx = j; sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\tif (0 <= sx + dx[dir] && sx + dx[dir] < 19 && 0 <= sy + dy[dir] && sy + dy[dir] < 15)\n\t\t\t{\n\t\t\t\tif (v1[sy + dy[dir]][sx + dx[dir]] == 'X')\n\t\t\t\t{\n\t\t\t\t\tint x = sx + dx[dir] * 2;\n\t\t\t\t\tint y = sy + dy[dir] * 2;\n\n\t\t\t\t\twhile (0 <= x && x < 19 && 0 <= y)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (y > 13) { return dist; }\n\n\t\t\t\t\t\tif (v1[y][x] == '.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvector<string> v2 = v1;\n\n\t\t\t\t\t\t\tint rx = sx, ry = sy;\n\n\t\t\t\t\t\t\tfor (; x != rx || y != ry;)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tv2[ry][rx] = '.';\n\n\t\t\t\t\t\t\t\trx += dx[dir];\n\t\t\t\t\t\t\t\try += dy[dir];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (d[v2] == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\td[v2] = dist + 1;\n\n\t\t\t\t\t\t\t\tque.push(make_pair(v2, dist + 1));\n\n\t\t\t\t\t\t\t\tgoto Exit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx += dx[dir];\n\t\t\t\t\t\ty += dy[dir];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tExit:;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tvector<string> v(15);\n\n\tfor (int i = 0; i < 15; i++) { cin >> v[i]; }\n\n\tcout << BFS(v) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<map>\nusing namespace std;\nchar str[31][31];\nint dx[]={1,1,1,0,0,-1,-1,-1};\nint dy[]={1,0,-1,1,-1,1,0,-1};\nmap<pair<int,pair<int,int> > ,int> m;\nint x[21];\nint y[21];\nint fi[31][31];\nint sz;\nint solve(int bit,int row,int col){\n\tif(row>=18)return 0;\n\tif(m.count(make_pair(bit,make_pair(row,col))))return m[make_pair(bit,make_pair(row,col))];\n\tint ret=99999999;\n\tfor(int i=0;i<8;i++){\n\t\tint nr=row+dx[i];\n\t\tint nc=col+dy[i];\n\t\tint tb=bit;\n\t\twhile(0<=nr&&nr<=18&&0<=nc&&nc<=14){\n\t\t\tif(!~fi[nr][nc]||!(bit&(1<<fi[nr][nc])))break;\n\t\t\ttb-=(1<<(fi[nr][nc]));\n\t\t\tnr+=dx[i];nc+=dy[i];\n\t\t}\n\t\tif(nr-dx[i]==row&&nc-dy[i]==col)continue;\n\t\tif(nr<18&&(nc<0||nc>=15))continue;\n\t\tret=min(ret,solve(tb,nr,nc)+1);\n\t}\n\treturn m[make_pair(bit,make_pair(row,col))]=ret;\n}\nint main(){\n\tfor(int i=0;i<19;i++)scanf(\"%s\",str[i]);\n\tint row=0;\n\tint col=0;\n\tfor(int i=0;i<31;i++)for(int j=0;j<31;j++)fi[i][j]=-1;\n\tfor(int i=0;i<19;i++)for(int j=0;j<15;j++){\n\t\tif(str[i][j]=='O'){row=i;col=j;}\n\t\tif(str[i][j]=='X'){\n\t\t\tfi[i][j]=sz;\n\t\t\tx[sz]=i;y[sz]=j;sz++;\n\t\t}\n\t}\n\tint ret=solve((1<<sz)-1,row,col);\n\tif(ret>99999)printf(\"-1\\n\");\n\telse printf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst char h = 20, w = 17;\nvector<vector<bool>> c;\ntypedef tuple<pair<char, char>, vector<vector<bool>>, char> T;\nqueue<T> q;\nmap<vector<vector<bool>>, vector<vector<char>>> memo;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nbool impossible(int y, vector<vector<bool>>& c){\n\tvector<bool> no(h,0);\n\trange(i,y + 1,18){\n\t\tbool f = false;\n\t\trep(j,w){\n\t\t\tif(c[i][j]) f = true;\n\t\t}\n\t\tif(not f) no[i] = true;\n\t}\n\trep(i,h - 1){\n\t\tif(no[i] and no[i + 1]) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tc = vector<vector<bool>>(h, vector<bool>(w,0));\n\n\tpair<char, char> s;\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tchar a;\n\t\t\tcin >> a;\n\t\t\tif(a == 'X') c[i][j + 1] = 1;\n\t\t\telse c[i][j + 1] = 0;\n\t\t\tif(a == 'O'){\n\t\t\t\ts = make_pair(i,j + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tq.push(T(s,c,0));\n\n\tchar ans = 127;\n\twhile(not q.empty()){\n\t\tchar cost;\n\t\ttie(s,c,cost) = q.front(); q.pop();\n\n\t\tchar y, x;\n\t\ttie(y,x) = s;\n\n\t\t//rep(i,h){ rep(j,w){ if(i == y and j == x) cout << 'O'; else cout << c[i][j]; } cout << endl; } cout << endl;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(impossible(y, c)) continue;\n\n\t\tif(cost >= 20) continue;\n\n\t\trep(i,8){\n\t\t\tchar ny = y + dy[i];\n\t\t\tchar nx = x + dx[i];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)) continue;\n\t\t\tif(c[ny][nx] == 1){\n\t\t\t\tvector<pair<int, int>> tmp;\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(c[ny][nx] == 0) break;\n\t\t\t\t\ttmp.emplace_back(ny,nx);\n\t\t\t\t\t//pc[ny][nx] = 0;\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tfor(auto i : tmp) c[i.first][i.second] = 0;\n\t\t\t\tif(memo.count(c)){\n\t\t\t\t\tauto& it = memo[c];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(make_pair(ny,nx), c, cost + 1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<char>> dis(h, vector<char>(w,127));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[c] = dis;\n\t\t\t\t\tq.push(T(make_pair(ny,nx), c, cost + 1));\n\t\t\t\t}\n\t\t\t\tfor(auto i : tmp) c[i.first][i.second] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == 127 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nint field[19][15];\nstruct aa {\n\tint x;\n\tint y;\n\tbitset<20>bs;\n\tint turn;\n};\nbool operator<(const aa&l, const aa&r) {\n\treturn l.x == r.x ? l.y == r.y ? l.bs.to_ulong() < r.bs.to_ulong() : l.y < r.y : l.x < r.x;\n}bool operator==(const aa&l, const aa&r) {\n\treturn l.x == r.x && l.y == r.y && l.bs.to_ulong();\n}\n\nint dx8[8] = { -1,-1,-1, 0, 1, 1, 1, 0 };\nint dy8[8] = { -1, 0, 1, 1, 1, 0,-1,-1 };\npair<int, int> amove(const int way,const int fx, const int fy, bitset<20>&bs) {\n\tint nx = fx+dx8[way];\n\tint ny = fy + dy8[way];\n\tbool ok = false;\n\twhile (1) {\n\t\tif (ny >= 18 && ok) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nx < 0 || nx >= 15 || ny < 0)return make_pair(-1, -1);\n\t\tif (field[ny][nx] && bs[field[ny][nx] - 1]) {\n\t\t\tbs[field[ny][nx] - 1] = false;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\tif (ny >= 18&&ok) {\n\t\t\tbreak;\n\t\t}\n\t\tok = true;\n\t\tny += dy8[way];\n\t\tnx += dx8[way];\n\t}\n\tif (!ok) {\n\t\treturn make_pair(-100, -100);\n\t}\n\telse {\n\t\treturn make_pair(nx, ny);\n\t}\n}\n\nint main() {\n\tint num = 1;\n\tint sx = 0, sy = 0;\n\tfor (int i = 0; i < 19; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < 15; ++j) {\n\t\t\tif (st[j] == 'X') {\n\t\t\t\tfield[i][j] = num;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\telse if (st[j] == 'O') {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<aa>que;\n\tque.push(aa{ sx,sy,bitset<20>((1 << (num-1)) - 1),0 });\n\tmap<aa,int>mp;\n\tmp[que.front()]=0;\n\tint ans = -1;\n\twhile (!que.empty()) {\n\t\taa atop(que.front());\n\t\tque.pop();\n\t\tif (atop.y >= 18) {\n\t\t\tif (atop.y == 18) {\n\t\t\t\tif (atop.x < 0 || atop.x >= 15)continue;\n\t\t\t}\n\t\t\tans = atop.turn;\n\t\t\tbreak;\n\t\t}\n\t\tfor (int way = 0; way < 8; ++way) {\n\t\t\tbitset<20>bs(atop.bs);\n\t\t\tpair<int, int>p(amove(way, atop.x, atop.y, bs));\n\t\t\tif (p.first != -100) {\n\t\t\t\tif (mp.find(aa{ p.first,p.second,bs, 0 }) == mp.end()) {\n\t\t\t\t\tmp[aa{ p.first,p.second,bs,0 }] = atop.turn + 1;\n\t\t\t\t\tque.push(aa{ p.first,p.second,bs,atop.turn + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nstruct state{\n  int S;\n  int i,j;\n  int d;\n};\n\nconst int w=15;\nconst int h=19;\nstring s[22];\nint idx[22][22];\nint N=0;\nint si,sj;\nint dist[1<<21];\n\nint di[]={-1,-1,-1,0,0,1,1,1};\nint dj[]={-1,0,1,-1,1,-1,0,1};\n\nint main(){\n  rep(i,h)cin>>s[i];\n  memset(idx,-1,sizeof(idx));\n  rep(i,h)rep(j,w){\n    if(s[i][j]=='X'){\n      idx[i][j]=N++;\n    }\n    if(s[i][j]=='O'){\n      si=i;sj=j;\n    }\n  }\n\n  rep(i,1<<N)dist[i]=INF;\n  queue<state> que;\n  que.push((state){(1<<N)-1,si,sj,0});\n  dist[(1<<N)-1]=0;\n  while(que.size()){\n    state cs=que.front(); que.pop();\n    rep(dir,8){\n      int ni=cs.i+di[dir],nj=cs.j+dj[dir];\n      if(ni<0||ni>=h||nj<0||nj>=w)continue;\n      if(idx[ni][nj]==-1||((cs.S>>idx[ni][nj])&1)==0)continue;\n      vector<int> uidxs;\n      while(ni>=0&&ni<h&&nj>=0&&nj<w&&idx[ni][nj]!=-1&&((cs.S>>idx[ni][nj])&1)){\n        uidxs.push_back(idx[ni][nj]);\n        ni+=di[dir];\n        nj+=dj[dir];\n      }\n      if(ni==h||(ni==h-1&&nj>=0&&nj<w)){\n        cout<<cs.d+1<<endl;\n        return 0;\n      }\n      if(ni<0||nj<0||nj>=w)continue;\n      int nxtS=cs.S;\n      rep(i,uidxs.size())nxtS^=(1<<uidxs[i]);\n      if(dist[nxtS]!=INF)continue;\n      que.push((state){nxtS,ni,nj,cs.d+1});\n      dist[nxtS]=cs.d+1;\n    }\n  }\n  cout<<-1<<endl;\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nconst int H = 19;\nconst int W = 15;\nstring bd[H];\nint id[H][W];\nint dx[] = {1,1,0,-1,-1,-1,0,1};\nint dy[] = {0,1,1,1,0,-1,-1,-1};\n\nstruct PH{\n  template<class T, class U>\n  size_t operator()(const pair<T,U>& x) const{\n\tsize_t seed = 0;\n\tseed ^= hash<T>{}(x.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\tseed ^= hash<U>{}(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\treturn seed;\n  }\n};\n\nusing D = pair<PII,int>;\nnamespace std{\ntemplate<> struct hash<D>{\n  size_t operator()(const D& d) const{\n\treturn PH{}(MP(PH{}(d.FF), d.SS));\n  }\n};\n}\n\nbool isin(const PII& p){\n  return (0 <= p.FF && p.FF < H && 0 <= p.SS && p.SS < W);\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  REP(i,19) cin >> bd[i];\n  PII w;\n  int gid = 0;\n  REP(y,H) REP(x,W){\n\tif(bd[y][x] == 'O')\n\t  w = MP(y,x);\n\telse if(bd[y][x] == 'X')\n\t  id[y][x] = gid++;\n  }\n\n  int ans = -1;\n  map<D,int> memo;\n  queue<D> q;\n  q.push(D(w,(1<<21)-1));\n  memo[D(w,(1<<21)-1)] = 0;\n  while(!q.empty()){\n\tD d = q.front();\n\tq.pop();\n\tPII p = d.FF;\n\tif(p.FF >= H || (p.FF == H-1 && isin(p))){\n\t  ans = memo[d];\n\t  break;\n\t}\n\tif(p.FF < 0 || p.SS < 0 || p.SS >= W)\n\t  continue;\n\tREP(dir,8){\n\t  int nb = d.SS;\n\t  PII np(p.FF+dy[dir], p.SS+dx[dir]);\n\t  while(isin(np) && bd[np.FF][np.SS] == 'X' && (nb>>id[np.FF][np.SS]&1)){\n\t\tnb ^= 1 << id[np.FF][np.SS];\n\t\tnp.FF += dy[dir];\n\t\tnp.SS += dx[dir];\n\t  }\n\t  if(nb == d.SS) continue;\n\t  if(!memo.count(D(np,nb))){\n\t\t memo[D(np,nb)] = memo[d] + 1;\n\t\t q.push(D(np,nb));\n\t  }\n\t}\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\nstruct state{\n  int S;\n  int i,j;\n  int d;\n};\n\nconst int w=15;\nconst int h=19;\nstring s[20];\nint idx[22][22];\nint N=0;\nint si,sj;\nint dist[1<<20];\n\nint di[]={-1,-1,-1,0,0,1,1,1};\nint dj[]={-1,0,1,-1,1,-1,0,1};\n\nint main(){\n  rep(i,h)cin>>s[i];\n  memset(idx,-1,sizeof(idx));\n  rep(i,h)rep(j,w){\n    if(s[i][j]=='X'){\n      idx[i][j]=N++;\n    }\n    if(s[i][j]=='O'){\n      si=i;sj=j;\n    }\n  }\n\n  rep(i,1<<N)dist[i]=INF;\n  queue<state> que;\n  que.push((state){(1<<N)-1,si,sj,0});\n  dist[(1<<N)-1]=0;\n  while(que.size()){\n    state cs=que.front(); que.pop();\n    rep(dir,8){\n      int ni=cs.i+di[dir],nj=cs.j+dj[dir];\n      if(ni<0||ni>=h||nj<0||nj>=w)continue;\n      if(idx[ni][nj]==-1||((cs.S>>idx[ni][nj])&1)==0)continue;\n      vector<int> uidxs;\n      while(idx[ni][nj]!=-1&&((cs.S>>idx[ni][nj])&1)){\n        uidxs.push_back(idx[ni][nj]);\n        ni+=di[dir];\n        nj+=dj[dir];\n      }\n      if(ni<0||nj<0||nj>=w)continue;\n      if(ni==h){\n        cout<<cs.d+1<<endl;\n        return 0;\n      }\n      int nxtS=cs.S;\n      rep(i,uidxs.size())nxtS^=(1<<uidxs[i]);\n      if(dist[nxtS]!=INF)continue;\n      que.push((state){nxtS,ni,nj,cs.d+1});\n      dist[nxtS]=cs.d+1;\n    }\n  }\n  cout<<-1<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nstring s[19];\nint sx = -1, sy = -1, ans,\n\tvx[8] = {-1, -1, 0, 1, 1, 1, 0, -1},\n\tvy[8] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ninline bool check(int x, int y) {\n\treturn (0 <= x && x < 19 && 0 <= y && y < 15);\n}\n\nint search(int x, int y, int cnt) {\n\tint ret = (int)1e9;\n\n\t//cout << \"now is\" << x << \" \" << y << endl;\n\n\tfor (int i = 0; i < 8; ++i) {\n\t\tint nx = x + vx[i], ny = y + vy[i], nnx, nny;\n\t\t//cout << \"nx, ny \" << nx << \" \" << ny << endl;\n\n\t\tif (check(nx, ny)) {\n\t\t\tif (s[nx][ny] == 'X') {\n\t\t\t\tnnx = nx + vx[i], nny = ny + vy[i];\n\n\t\t\t\tfor (int j = 1; ; ++j) {\n\t\t\t\t\t//cout << \"nnx, nny \" << nnx << \" \" << nny << endl;\n\t\t\t\t\tif (nnx > 18 || (nnx == 18 && 0 <= nny && nny < 15)) {\n\t\t\t\t\t\t//cout << \"now : \" << x << \" \" << y << endl;\n\t\t\t\t\t\t//cout << \"goal: \" << ret << \" \" << j << endl;\n\t\t\t\t\t\tret = min(ret, cnt);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!check(nnx, nny)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (check(nnx, nny) && s[nnx][nny] == '.') {\n\t\t\t\t\t\tstring tmp[19];\n\t\t\t\t\t\tint xx = nx, yy = ny;\n\t\t\t\t\t\tfor (int k = 0; k < 19; ++k) tmp[k] = s[k];\n\n\t\t\t\t\t\t//for (int z = 0; z < 19; ++z) cout << s[z] << endl;\n\t\t\t\t\t\twhile ((xx != nnx || yy != nny)) {\n\t\t\t\t\t\t\ts[xx][yy] = '.';\n\t\t\t\t\t\t\txx += vx[i], yy += vy[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//cout << \"nnx,nny\" << nnx << ' ' << nny << endl;\n\t\t\t\t\t\t//for (int z = 0; z < 19; ++z) cout << s[z] << endl;\n\n\t\t\t\t\t\tint ret_s = search(nnx, nny, cnt + 1);\n\t\t\t\t\t\tif (ret_s != -1) {\n\t\t\t\t\t\t\t//cout << \"ret, j + ret_s \"<< ret << \" \" << j + ret_s << endl;\n\t\t\t\t\t\t\t//cout << \"ret_s : \" << ret_s << endl;\n\t\t\t\t\t\t\tret = min(ret, ret_s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (int k = 0; k < 19; ++k) {\n\t\t\t\t\t\t\ts[k] = tmp[k];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tnnx += vx[i], nny += vy[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (nnx > 18) {\n\t\t\tret = min(ret, cnt);\n\t\t}\n\t}\n\n\tif (ret == (int)1e9) return -1;\n\n\t//cout << \"return \" << x << \", \" << y << \" = \" << ret << endl;\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor (int i = 0; i < 19; ++i) {\n\t\tcin >> s[i];\n\n\t\tif (sx == -1) {\n\t\t\tfor (int j = 0; j < 15; ++j) {\n\t\t\t\tif (s[i][j] == 'O') {\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tans = search(sx, sy, 1);\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nconst int H = 19;\nconst int W = 15;\nstring bd[H];\nint id[H][W];\nint dx[] = {1,1,0,-1,-1,-1,0,1};\nint dy[] = {0,1,1,1,0,-1,-1,-1};\n\nstruct PH{\n  template<class T, class U>\n  size_t operator()(const pair<T,U>& x) const{\n\tsize_t seed = 0;\n\tseed ^= hash<T>{}(x.first) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\tseed ^= hash<U>{}(x.second) + 0x9e3779b9 + (seed<<6) + (seed>>2);\n\treturn seed;\n  }\n};\n\nusing D = pair<PII,int>;\nnamespace std{\ntemplate<> struct hash<D>{\n  size_t operator()(const D& d) const{\n\treturn PH{}(MP(PH{}(d.FF), d.SS));\n  }\n};\n}\n\nbool isin(const PII& p){\n  return (0 <= p.FF && p.FF < H && 0 <= p.SS && p.SS < W);\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  REP(i,19) cin >> bd[i];\n  PII w;\n  int gid = 0;\n  REP(y,H) REP(x,W){\n\tif(bd[y][x] == 'O')\n\t  w = MP(y,x);\n\telse if(bd[y][x] == 'X')\n\t  id[y][x] = gid++;\n  }\n\n  int ans = -1;\n  map<D,int> memo;\n  queue<D> q;\n  q.push(D(w,(1<<21)-1));\n  memo[D(w,(1<<21)-1)] = 0;\n  while(!q.empty()){\n\tD d = q.front();\n\tq.pop();\n\tPII p = d.FF;\n\tif(p.FF >= H){\n\t  ans = memo[d];\n\t  break;\n\t}\n\tif(p.FF < 0 || p.SS < 0 || p.SS >= W)\n\t  continue;\n\tREP(dir,8){\n\t  int nb = d.SS;\n\t  PII np(p.FF+dy[dir], p.SS+dx[dir]);\n\t  while(isin(np) && bd[np.FF][np.SS] == 'X' && (nb>>id[np.FF][np.SS]&1)){\n\t\tnb ^= 1 << id[np.FF][np.SS];\n\t\tnp.FF += dy[dir];\n\t\tnp.SS += dx[dir];\n\t  }\n\t  if(nb == d.SS) continue;\n\t  if(!memo.count(D(np,nb))){\n\t\t memo[D(np,nb)] = memo[d] + 1;\n\t\t q.push(D(np,nb));\n\t  }\n\t}\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\nusing namespace std;\n\nstring s[19];\nint sx = -1, sy = -1, ans,\n\tvx[8] = {-1, -1, 0, 1, 1, 1, 0, -1},\n\tvy[8] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ninline bool check(int x, int y) {\n\treturn (0 <= x && x < 19 && 0 <= y && y < 15);\n}\n\nint search(int x, int y, int cnt) {\n\tint ret = (int)1e9;\n\n\t//cout << \"now is\" << x << \" \" << y << endl;\n\n\tfor (int i = 0; i < 8; ++i) {\n\t\tint nx = x + vx[i], ny = y + vy[i], nnx, nny;\n\n\t\tif (check(nx, ny)) {\n\t\t\tif (s[nx][ny] == 'X') {\n\t\t\t\tnnx = nx + vx[i], nny = ny + vy[i];\n\n\t\t\t\tfor (int j = 1; ; ++j) {\n\t\t\t\t\tif (nnx > 18 || (nnx == 18 && 0 <= nny && nny < 19)) {\n\t\t\t\t\t\t//cout << \"now : \" << x << \" \" << y << endl;\n\t\t\t\t\t\t//cout << \"goal: \" << ret << \" \" << j << endl;\n\t\t\t\t\t\tret = min(ret, cnt);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!check(nnx, nny)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (check(nnx, nny) && s[nnx][nny] == '.') {\n\t\t\t\t\t\tstring tmp[19];\n\t\t\t\t\t\tint xx = nx, yy = ny;\n\t\t\t\t\t\tfor (int k = 0; k < 19; ++k) tmp[k] = s[k];\n\n\t\t\t\t\t\t//for (int z = 0; z < 19; ++z) cout << s[z] << endl;\n\t\t\t\t\t\twhile ((xx != nnx || yy != nny)) {\n\t\t\t\t\t\t\ts[xx][yy] = '.';\n\t\t\t\t\t\t\txx += vx[i], yy += vy[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//cout << \"nnx,nny\" << nnx << ' ' << nny << endl;\n\t\t\t\t\t\t//for (int z = 0; z < 19; ++z) cout << s[z] << endl;\n\n\t\t\t\t\t\tint ret_s = search(nnx, nny, cnt + 1);\n\t\t\t\t\t\tif (ret_s != -1) {\n\t\t\t\t\t\t\t//cout << \"ret, j + ret_s \"<< ret << \" \" << j + ret_s << endl;\n\t\t\t\t\t\t\t//cout << \"ret_s : \" << ret_s << endl;\n\t\t\t\t\t\t\tret = min(ret, ret_s);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (int k = 0; k < 19; ++k) {\n\t\t\t\t\t\t\ts[k] = tmp[k];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tnnx += vx[i], nny += vy[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ret == (int)1e9) return -1;\n\n\t//cout << \"return \" << x << \", \" << y << \" = \" << ret << endl;\n\treturn ret;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor (int i = 0; i < 19; ++i) {\n\t\tcin >> s[i];\n\n\t\tif (sx == -1) {\n\t\t\tfor (int j = 0; j < 15; ++j) {\n\t\t\t\tif (s[i][j] == 'O') {\n\t\t\t\t\tsx = i;\n\t\t\t\t\tsy = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tans = search(sx, sy, 0);\n\n\tif (ans == -1) cout << -1 << endl;\n\telse cout << ans + 1 << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint main(void) {\n  const ll H = 19, W = 15;\n  char S[H][W];\n  REP(i, 0, H) REP(j, 0, W) cin >> S[i][j];\n\n  pll white;\n  vector<pll> black, cand;\n  REP(i, 0, H) REP(j, 0, W) {\n    if(S[i][j] == 'O') {\n      white = pll(i, j);\n      cand.push_back(pll(i, j));\n    }\n    if(S[i][j] == 'X') {\n      black.push_back(pll(i, j));\n      REP(di, -1, 2) REP(dj, -1, 2) if(di != 0 || dj != 0) {\n        ll ni = i + di, nj = j + dj;\n        if(!(0 <= ni && ni < H && 0 <= nj && nj < W)) break;\n        cand.push_back(pll(i + di, j + dj));\n      }\n    }\n  }\n  sort(black.begin(), black.end());\n  sort(cand.begin(), cand.end());\n  cand.erase(unique(cand.begin(), cand.end()), cand.end());\n\n  ll N = black.size(), M = cand.size();\n  map<pll, bool> visited;\n\n  struct state { ll s, v, d; };\n  queue<state> q;\n  q.push((state) { (1LL << N) - 1, lower_bound(cand.begin(), cand.end(), white) - cand.begin(), 0 });\n\n  while(!q.empty()) {\n    ll s = q.front().s, v = q.front().v, d = q.front().d;\n    ll y = cand[v].first, x = cand[v].second;\n    q.pop();\n\n    visited[pll(s, v)] = true;\n\n    REP(i, -1, 2) REP(j, -1, 2) if(i != 0  || j != 0) {\n      ll ns = s, ny = y + i, nx = x + j, nd = d + 1;\n      ll cnt = 0;\n\n      while(1) {\n        if(!(0 <= ny && ny < H && 0 <= nx && nx < W)) break;\n        if(S[ny][nx] != 'X') break;\n\n        ll b = lower_bound(black.begin(), black.end(), pll(ny, nx)) - black.begin();\n        if(b == N) break;\n        if(!(ns & (1LL << b))) break;\n\n        ns = ns - (1LL << b);\n        ny += i;\n        nx += j;\n        cnt++;\n      }\n\n      if(cnt > 0 && ny >= H - 1) {\n        cout << nd << endl;\n        return 0;\n      } else if(cnt > 0 && 0 <= ny && ny < H && 0 <= nx && nx < W) {\n        ll nv = lower_bound(cand.begin(), cand.end(), pll(ny, nx)) - cand.begin();\n        if(!visited[pll(ns, nv)]) q.push((state) { ns, nv, nd });\n      }\n    }\n  }\n  cout << -1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 19;\nconst int W = 15;\n\nstruct State{\n    int xstate;\n    unsigned char h, w;\n    \n    bool operator < (const State &r) const{\n        int xl = xstate * H * W + h * W + w;\n        int xr = r.xstate * H * W + r.h * W + r.w;\n        return xl < xr;\n    }\n};\n\nvector<string> board(H);\nvector<int> xhs, xws;\nmap<State, int> d;\n\nbool infield(int h, int w){\n    if(h == H)\n        return true;\n    else\n        return 0<=w && w<W;\n}\n\nint bfs(int sh, int sw){\n    int xn = xhs.size();\n    map<pair<int, int>, int> ipoint;\n    for(int i=0; i<xn; i++)\n        ipoint[{xhs[i], xws[i]}] = i;\n    \n    queue<State> que;\n    State s;\n    s.xstate = (1<<xn)-1;\n    s.h = sh;\n    s.w = sw;\n    que.push(s);\n    \n    d[s] = 0;\n    \n    int maxq = 0;\n    \n    while(!que.empty()){\n        maxq = max(maxq, (int)que.size());\n        auto s = que.front(); que.pop();\n        //cout << que.size() << endl;\n        \n        for(int dh=-1; dh<=1; dh++){\n            for(int dw=-1; dw<=1; dw++) if(dh != 0 || dw != 0){\n                State ns;\n                ns.xstate = s.xstate;\n                ns.h = s.h + dh;\n                ns.w = s.w + dw;\n                \n                if(ipoint.find({ns.h, ns.w}) == ipoint.end() || ((ns.xstate>>ipoint[{ns.h, ns.w}])&1) == 0)\n                    continue;\n                \n                int count = 0;\n                while(infield(ns.h, ns.w) && ipoint.find({ns.h, ns.w})!= ipoint.end() && (ns.xstate>>ipoint[{ns.h, ns.w}])&1){\n                    ns.h += dh;\n                    ns.w += dw;\n                    count++;\n                }\n                if(!infield(ns.h, ns.w))\n                    continue;\n                \n                ns.h = s.h + dh;\n                ns.w = s.w + dw;\n                for(int i=0; i<count; i++){\n                    ns.xstate -= 1<<ipoint[{ns.h, ns.w}];\n                    ns.h += dh;\n                    ns.w += dw;\n                }\n                \n                if(d.find(ns) != d.end())\n                    continue;\n                \n                que.push(ns);\n                d[ns] = d[s] + 1;\n                \n                if(H-1<=ns.h){\n                    return d[ns];\n                }\n            }\n        }\n    }\n    //cout << maxq << endl;\n    return -1;\n}\n\nint main(){\n    for(auto &s: board) cin >> s;\n    \n    int sh, sw;\n    for(int h=0; h<H; h++){\n        for(int w=0; w<W; w++){\n            if(board[h][w] == 'O')\n                sh = h, sw = w;\n            if(board[h][w] == 'X')\n                xhs.push_back(h), xws.push_back(w);\n        }\n    }\n    cout << bfs(sh, sw) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct data{\n\tint bit,x,y;\n\tdata(){}\n\tdata(int bb,int yy,int xx){\n\t\tbit=bb;\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tbool operator<(const data &d)const{\n\t\treturn bit<d.bit;\n\t}\n};\n\nint h,w;\nstring str[20];\nint fie[19][15];\nmap<data,int> mp;\nint bsize=0;\nP black[20];\nint sx,sy;\n\nint bfs(){\n\tqueue<data> que;\n\tque.push(data((1<<bsize)-1,sy,sx));\n\tmp[data((1<<bsize)-1,sy,sx)]=0;\n\twhile(que.size()){\n\t\tdata d=que.front();\n\t\tque.pop();\n\t\tfor(int i=-1;i<=1;i++){\n\t\t\tfor(int j=-1;j<=1;j++){\n\t\t\t\tif(i==0 && j==0)continue;\n\t\t\t\tfor(int k=0;k<bsize;k++){\n\t\t\t\t\tif(d.bit>>k & 1){\n\t\t\t\t\t\tfie[black[k].first][black[k].second]=k+1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfie[black[k].first][black[k].second]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint cnt=0;\n\t\t\t\tint nx=d.x;\n\t\t\t\tint ny=d.y;\n\t\t\t\tint nbit=d.bit;\n\t\t\t\tif(nx+j>=0 && nx+j<w && ny+i>=0 && ny+i<h){\n\t\t\t\t\tif(fie[ny+i][nx+j]==0)continue;\n\t\t\t\t\tnx+=j;\n\t\t\t\t\tny+=i;\n\t\t\t\t\twhile(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\t\t\t\t\tif(fie[ny][nx]==0)break;\n\t\t\t\t\t\tnbit-=1<<(fie[ny][nx]-1);\n\t\t\t\t\t\tnx+=j;\n\t\t\t\t\t\tny+=i;\n\t\t\t\t\t}\n\t\t\t\t\tif(ny>=h || (ny==h-1 && nx>=0 && nx<=w-1)){\n\t\t\t\t\t\treturn mp[data(d.bit,d.y,d.x)]+1;\n\t\t\t\t\t}else if(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\t\t\t\t\tif(mp.find(data(nbit,ny,nx))==mp.end()){\n\t\t\t\t\t\t\tmp[data(nbit,ny,nx)]=mp[data(d.bit,d.y,d.x)]+1;\n\t\t\t\t\t\t\tque.push(data(nbit,ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void){\n\th=19;\n\tw=15;\n\tfor(int i=0;i<h;i++){\n\t\tcin >> str[i];\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(str[i][j]=='X'){\n\t\t\t\tblack[bsize++]=P(i,j);\n\t\t\t}\n\t\t\tif(str[i][j]=='O'){\n\t\t\t\tsy=i;\n\t\t\t\tsx=j;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",bfs());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint main(void) {\n  const ll H = 19, W = 15;\n  char S[H][W];\n  REP(i, 0, H) REP(j, 0, W) cin >> S[i][j];\n\n  pll white;\n  vector<pll> black, cand;\n  REP(i, 0, H) REP(j, 0, W) {\n    if(S[i][j] == 'O') {\n      white = pll(i, j);\n      cand.push_back(pll(i, j));\n    }\n    if(S[i][j] == 'X') {\n      black.push_back(pll(i, j));\n      REP(di, -1, 2) REP(dj, -1, 2) if(di != 0 || dj != 0) {\n        ll ni = i + di, nj = j + dj;\n        if(!(0 <= ni && ni < H && 0 <= nj && nj < W)) break;\n        cand.push_back(pll(i + di, j + dj));\n      }\n    }\n  }\n  sort(black.begin(), black.end());\n  sort(cand.begin(), cand.end());\n  cand.erase(unique(cand.begin(), cand.end()), cand.end());\n\n  ll N = black.size(), M = cand.size();\n  map<pll, bool> visited;\n\n  struct state { ll s, v, d; };\n  queue<state> q;\n  q.push((state) { (1LL << N) - 1, lower_bound(cand.begin(), cand.end(), white) - cand.begin(), 0 });\n\n  while(!q.empty()) {\n    ll s = q.front().s, v = q.front().v, d = q.front().d;\n    ll y = cand[v].first, x = cand[v].second;\n    q.pop();\n\n    visited[pll(s, v)] = true;\n\n    REP(i, -1, 2) REP(j, -1, 2) if(i != 0  || j != 0) {\n      ll ns = s, ny = y + i, nx = x + j, nd = d + 1;\n      ll cnt = 0;\n\n      while(1) {\n        if(!(0 <= ny && ny < H && 0 <= nx && nx < W)) break;\n        if(S[ny][nx] != 'X') break;\n\n        ll b = lower_bound(black.begin(), black.end(), pll(ny, nx)) - black.begin();\n        if(b == N) break;\n        if(!(ns & (1LL << b))) break;\n\n        ns = ns & (~(1LL << b));\n        ny += i;\n        nx += j;\n        cnt++;\n      }\n\n      if(cnt > 0 && ny >= H - 1) {\n        cout << nd << endl;\n        return 0;\n      } else if(cnt > 0) {\n        ll nv = lower_bound(cand.begin(), cand.end(), pll(ny, nx)) - cand.begin();\n        if(!visited[pll(ns, nv)]) q.push((state) { ns, nv, nd });\n      }\n    }\n  }\n  cout << -1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\n#define H 19\n#define W 15\nbool banmen[H+1][W];\nint dirs[8][2];\n\nint solve(int x, int y, int te) {\n  //printf(\"%d,%d,%d\\n\",x,y,te);\n  if(y>=H-1) return te;\n  int ans = 9999;\n  for(int dir_index = 0; dir_index < 8; dir_index++) {\n    int dx = dirs[dir_index][0];\n    int dy = dirs[dir_index][1];\n    int count = 0;\n    int ax = x+dx;\n    int ay = y+dy;\n    //printf(\"(%d,%d,%d,%d,%d)\\n\",ax>0,ax+dx<W,ay>0,ay+dy<=H,banmen[ax][ay]);\n    while(ax>=0&&ax<W&&ax+dx>=-1&&ax+dx<=W&&ay>0&&ay<H&&ay+dy>=0&&ay+dy<=H && banmen[ay][ax]) {\n      banmen[ay][ax] = false;\n      ax+=dx;\n      ay+=dy;\n      count++;\n    }\n    //printf(\"(x,y,c)=(%d,%d,%d)\\n\",dx,dy,count);\n    if(count>0) {\n      int ret = solve(ax,ay,te+1);\n      if(ret!=-1) {\n        ans = min(ans,ret);\n      }\n    }\n    for(int i = 1; i <= count; i++) {\n      banmen[y+dy*i][x+dx*i] = true;\n    }\n  }\n  return (ans==9999)?-1:ans;\n}\n\nint main() {\n  int x,y;\n  for(int i = 0; i < H; i++) {\n    char row[W+1];\n    scanf(\"%s\",row);\n    for(int j = 0; j < W; j++) {\n      banmen[i][j] = (row[j]=='X');\n      if(row[j]=='O') {\n        y = i;\n        x = j;\n      }\n    }\n  }\n  /*\n  for(int i = 0; i < H+1; i++) {\n    for(int j = 0; j < W; j++) {\n      printf(\"%d \",banmen[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  */\n  for(int j = 0; j < W; j++) {\n    banmen[H][j] = false;\n  }\n\n  dirs[0][0] = 1;\n  dirs[0][1] = 1;\n  dirs[1][0] = 1;\n  dirs[1][1] = 0;\n  dirs[2][0] = 1;\n  dirs[2][1] = -1;\n  dirs[3][0] = 0;\n  dirs[3][1] = -1;\n  dirs[4][0] = -1;\n  dirs[4][1] = -1;\n  dirs[5][0] = -1;\n  dirs[5][1] = 0;\n  dirs[6][0] = -1;\n  dirs[6][1] = 1;\n  dirs[7][0] = 0;\n  dirs[7][1] = 1;\n\n  printf(\"%d\\n\",solve(x,y,0));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct S {\n\tint x, y, mask;\n\tll hash() {\n\t\treturn x + 15 * y + mask * (1LL << 30);\n\t}\n};\n\nint b[19][15];\n\nint dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 };\nint dy[8] = { 0, 1, 0, -1, 1, -1, 1, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < 15 && 0 <= y && y < 18;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint B = 0;\n\tint sx = -1, sy = -1;\n\tmemset(b, -1, sizeof b);\n\tfor(int i = 0; i < 19; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j < 15; j++) {\n\t\t\tif(s[j] == 'O') sx = j, sy = i;\n\t\t\tif(s[j] == 'X') {\n\t\t\t\tb[i][j] = B++;\n\t\t\t}\n\t\t}\n\t}\n\n\tunordered_map<ll, int> dp;\n\tS is = { sx, sy, 0 };\n\tdp[is.hash()] = 0;\n\n\tqueue<S> q;\n\tq.push(is);\n\twhile(q.size()) {\n\t\tint x = q.front().x, y = q.front().y, mask = q.front().mask;\n\t\tint t = dp[q.front().hash()];\n\t\tq.pop();\n\t\tfor(int k = 0; k < 8; k++) {\n\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\tif(!in(nx, ny)) continue;\n\t\t\tint id = b[ny][nx];\n\t\t\tif(id == -1) continue;\n\t\t\tif(mask >> id & 1) continue;\n\t\t\t//cerr << \"nx : \" << nx << \", ny : \" << ny << endl;\n\t\t\tint nmask = mask;\n\t\t\twhile(1) {\n\t\t\t\tnmask |= 1 << id;\n\t\t\t\tnx += dx[k], ny += dy[k];\n\t\t\t\tif(!in(nx, ny)) break;\n\t\t\t\tid = b[ny][nx];\n\t\t\t\tif(id == -1 || (mask >> id & 1)) break;\n\t\t\t}\n\t\t\tif(ny >= 18) {\n\t\t\t\tcout << t + 1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(in(nx, ny)) {\n\t\t\t\tS ns = { nx, ny, nmask };\n\t\t\t\tif(dp.count(ns.hash()) == 0) {\n\t\t\t\t\tdp[ns.hash()] = t + 1;\n\t\t\t\t\tq.push(ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define inf 1000000000\n\nusing namespace std;\n\nconst int W = 15, H = 20;\nchar map[W][H];\nint sx, sy;\nconst int vx[] = {1, 1, 0, -1, -1, -1, 0, 1}, vy[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\nint dfs(int x, int y)\n{\n\tint nx, ny;\n\tint ret = inf;\n\tif(y >= H-2) return 0;\n\t\n\tfor(int d = 0; d < 8; d++){\n\t\tnx = x + vx[d], ny = y + vy[d];\n\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n\t\tif(map[nx][ny] == '.') continue;\n\t\twhile(1){\n\t\t\tnx += vx[d], ny += vy[d];\n\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H) break;\n\t\t\tif(map[nx][ny] == '.'){\n\t\t\t\tfor(int k = 1; x + k*vx[d] != nx || y + k*vy[d] != ny; k++) map[x + k*vx[d]][y + k*vy[d]] = '.';\n\t\t\t\tret = min(ret, dfs(nx, ny));\n\t\t\t\tfor(int k = 1; x + k*vx[d] != nx || y + k*vy[d] != ny; k++) map[x + k*vx[d]][y + k*vy[d]] = 'X';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret + 1;\n}\n\nint main(void)\n{\n\tfor(int y = 0; y < H; y++){\n\t\tfor(int x = 0; x < W; x++){\n\t\t\tcin >> map[x][y];\n\t\t\tif(map[x][y] == 'O'){\n\t\t\t\tsx = x, sy = y;\n\t\t\t\tmap[x][y] = '.';\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x = 0; x < W; x++) map[x][H-1] = '.';\n\t\n\tint ans = dfs(sx, sy);\n\tif(ans >= inf) ans = -1;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define inf 1000000000\n\nusing namespace std;\n\nconst int W = 15, H = 20;\nchar map[W][H];\nint sx, sy;\nconst int vx[] = {1, 1, 0, -1, -1, -1, 0, 1}, vy[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\nint dfs(int x, int y)\n{\n\tint nx, ny;\n\tint ret = inf;\n\tif(y >= H-2) return 0;\n\t\n\tfor(int d = 0; d < 8; d++){\n\t\tnx = x + vx[d], ny = y + vy[d];\n\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n\t\tif(map[nx][ny] == '.') continue;\n\t\twhile(1){\n\t\t\tnx += vx[d], ny += vy[d];\n\t\t\tif(nx < 0 || nx >= W || ny < 0 || ny >= H) continue;\n\t\t\tif(map[nx][ny] == '.'){\n\t\t\t\tfor(int k = 1; x + k*vx[d] != nx || y + k*vy[d] != ny; k++) map[x + k*vx[d]][y + k*vy[d]] = '.';\n\t\t\t\tret = min(ret, dfs(nx, ny));\n\t\t\t\tfor(int k = 1; x + k*vx[d] != nx || y + k*vy[d] != ny; k++) map[x + k*vx[d]][y + k*vy[d]] = 'X';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret + 1;\n}\n\nint main(void)\n{\n\tfor(int y = 0; y < H; y++){\n\t\tfor(int x = 0; x < W; x++){\n\t\t\tcin >> map[x][y];\n\t\t\tif(map[x][y] == 'O'){\n\t\t\t\tsx = x, sy = y;\n\t\t\t\tmap[x][y] = '.';\n\t\t\t}\n\t\t}\n\t}\n\tfor(int x = 0; x < W; x++) map[x][H-1] = '.';\n\t\n\tint ans = dfs(sx, sy);\n\tif(ans >= inf) ans = -1;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst short IINF = 126;\nconst int h = 19;\nconst int w = 15;\n\nstruct Data { int x,y,bitmask; };\n\nchar a[20][20];\nshort mindist[1<<20][19][15];\nint Index[20][20];\n\nbool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nvoid compute(){\n  int black = 0;\n  int sx=-1,sy=-1;\n  rep(i,h) rep(j,w) {\n    if( a[i][j] == 'X' ) Index[i][j] = black++;\n    if( a[i][j] == 'O' ) sx = j, sy = i;\n  }\n  rep(i,(1<<black)) rep(j,h) rep(k,w) mindist[i][j][k] = IINF;\n  mindist[(1<<black)-1][sy][sx] = 0;\n  deque<Data> deq;\n  deq.push_back((Data){sx,sy,(1<<black)-1});\n  while( !deq.empty() ){\n    Data data = deq.front(); deq.pop_front();\n    REP(dx,-1,2){\n      REP(dy,-1,2){\n        if( dx == 0 && dy == 0 ) continue;\n        int nx = data.x + dx, ny = data.y + dy, nbitmask = data.bitmask;\n        bool valid = false;\n        while( isValid(nx,ny) && ( a[ny][nx] == 'X' && ( data.bitmask & (1<<Index[ny][nx]) ) ) ){\n          nbitmask &= ~(1<<Index[ny][nx]);\n          nx += dx, ny += dy;\n          valid = true;\n        }\n        if( !isValid(nx,ny) ) {\n          if( valid && ( 0 <= nx && nx < w ) && ny >= h ) {\n            cout << mindist[data.bitmask][data.y][data.x]+1 << endl;\n            return;\n          }\n          continue;\n        }\n        if( !valid ) continue;\n        if( mindist[nbitmask][ny][nx] > mindist[data.bitmask][data.y][data.x] + 1 ) {\n          mindist[nbitmask][ny][nx] = mindist[data.bitmask][data.y][data.x] + 1;\n          deq.push_back((Data){nx,ny,nbitmask});\n        }\n      }\n    }\n  }\n  puts(\"-1\");\n}\n\nint main(){\n  rep(i,h) rep(j,w) scanf(\" %c\",&a[i][j]);\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nstruct State { int x[19][15]; };\nState S;\nint dx[8] = { 1,1,1,0,-1,-1,-1,0 }, dy[8] = { -1,0,1,1,1,0,-1,-1 };\nint solve(State p) {\n\tint cx = 0, cy = 0;\n\tfor (int i = 0; i < 285; i++) {\n\t\tif (p.x[i / 15][i % 15] == 2) { cx = i / 15; cy = i % 15; }\n\t}\n\tint minx = 999999;\n\tfor (int i = 0; i < 8; i++) {\n\t\tState T = p;\n\t\tint ex = cx, ey = cy;\n\t\tbool flag = true;\n\t\twhile (true) {\n\t\t\tex += dx[i]; ey += dy[i];\n\t\t\tif (ex >= 19)break;\n\t\t\tif (ex < 0 || ey < 0 || ey >= 15) { flag = false; break; }\n\t\t\tif (T.x[ex][ey] == 0)break;\n\t\t\tT.x[ex][ey] = 0;\n\t\t}\n\t\tif (flag == false)continue;\n\n\t\tif (abs(ex - cx) <= 1 && abs(ey - cy) <= 1)continue;\n\t\tif (ex == 18 || ex == 19)minx = min(minx, 1);\n\t\telse {\n\t\t\tT.x[cx][cy] = 0; T.x[ex][ey] = 2;\n\t\t\tminx = min(minx, solve(T) + 1);\n\t\t}\n\t}\n\treturn minx;\n}\nint main() {\n\tfor (int i = 0; i < 19; i++) {\n\t\tfor (int j = 0; j < 15; j++) {\n\t\t\tchar p; cin >> p;\n\t\t\tif (p == 'O')S.x[i][j] = 2;\n\t\t\tif (p == 'X')S.x[i][j] = 1;\n\t\t\tif (p == '.')S.x[i][j] = 0;\n\t\t}\n\t}\n\tint R = solve(S); if (R >= 100000)R = -1;\n\tcout << R << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst long long int MOD = 1000000007;\nconst int INF = 1000000000;\n\nchar bo[19][15];\nint h = 19, w = 15;\nint y, x;\nint ans = INF;\n\nint dy[8] = {1,0,-1,1,-1,1,0,-1};\nint dx[8] = {1,1,1,0,0,-1,-1,-1};\n\nvoid dfs(int yy, int xx, int dep){\n    rep(i,8){\n        int nowy = yy, nowx = xx;\n        for(int j = 0;;j++){\n            nowy += dy[i];\n            nowx += dx[i];\n            if(0>nowy||0>nowx||nowx>=w){\n                break;\n            }\n            if(nowy >= h){\n                ans = min(ans,dep+1);\n                return;\n            }\n            if(bo[nowy][nowx] == '.'){\n                if(j == 0) break;\n                if(nowy == h-1){\n                    ans = min(ans,dep+1);\n                    return;\n                }\n                int prey = nowy, prex = nowx;\n                prey -= dy[i];\n                prex -= dx[i];\n                while(prey != yy || prex != xx){\n                    bo[prey][prex] = '.';\n                    prey -= dy[i];\n                    prex -= dx[i];\n                }\n                dfs(nowy,nowx,dep+1);\n                prey += dy[i];\n                prex += dx[i];\n                while(prey != nowy || prex != nowx){\n                    bo[prey][prex] = 'X';\n                    prey += dy[i];\n                    prex += dx[i];\n                }\n                break;\n            }\n        }\n    }\n}\n\nint main(){\n    rep(i,h) rep(j,w) cin >> bo[i][j];\n    rep(i,h) rep(j,w){\n        if(bo[i][j] == 'O'){\n            y = i;\n            x = j;\n            bo[i][j] = '.';\n        }\n    }\n    dfs(y,x,0);\n    if(ans == INF) ans = -1;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nsigned main(){\n  string s[19];\n  for(int i=0;i<19;i++) cin>>s[i];\n\n  int sy,sx;\n  vector<int> v;\n  for(int i=0;i<19;i++){\n    for(int j=0;j<15;j++){\n      if(s[i][j]=='O') sy=i,sx=j;\n      if(s[i][j]=='X') v.push_back(i*15+j);\n    }\n  }\n  \n  int n=v.size();\n  int sb=(sy*15+sx)<<n;\n  \n  map<int,int> m;\n  for(int i=0;i<n;i++) m[v[i]]=i;\n\n  int ax[]={-1,-1,-1,0,0,1,1,1};\n  int ay[]={-1,0,1,-1,1,-1,0,1};\n  \n  int ans=-1,mask=(1<<n)-1;\n  priority_queue<P> q;\n  q.push(P(0,sb));\n  map<int,int> ms;\n  ms[sb]=0;\n  \n  while(!q.empty()){\n    P p=q.top();q.pop();\n    int d=-p.first,b=p.second;\n    int cy=(b>>n)/15,cx=(b>>n)%15;\n    //cout<<(b>>n)<<\" \"<<cy<<\" \"<<cx<<\" \"<<d<<endl;\n    if(ms[b]<d) continue;\n    for(int k=0;k<8;k++){\n      int ny=cy+ay[k],nx=cx+ax[k],nb=b&mask,nd=d+1;\n      if(!m.count(ny*15+nx)) continue;\n      //cout<<ny<<\" \"<<nx<<\" \"<<nb<<\" \"<<nd<<endl;\n      if(nb&(1<<m[ny*15+nx])) continue;\n      while(m.count(ny*15+nx)){\n\tif(nb&(1<<m[ny*15+nx])) break;\n\t//cout<<n<<\":\"<<m[ny*15+nx]<<\" \"<<nb<<\" \"<<(1<<m[ny*15+nx])<<endl;\n\tnb+=1<<m[ny*15+nx];\n\tny+=ay[k];\n\tnx+=ax[k];\n      }\n      //cout<<ny<<\" \"<<nx<<\" \"<<ny*15+nx<<\" \"<<nb<<endl;\n      if(ny==18&&0<=nx&&nx<15){\n\tans=nd;\n\tgoto END;\n      }\n      if(ny>18){\n\tans=nd;\n\tgoto END;\n      }\n      if(ny<0||nx<0||nx>=15) continue;\n      nb+=(ny*15+nx)<<n;\n      //cout<<nb<<\" \"<<(nb&mask)<<\" \"<<(nb>>n)<<endl;\n      if(ms.count(nb)&&ms[nb]<=nd) continue;\n      ms[nb]=nd;\n      q.push(P(-nd,nb));\n    }\n  }\n END:\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 19;\nconst int W = 15;\nvector<string> board(H);\nvector<int> xhs, xws;\nint d[1<<20][H][W];\n\nclass State{\npublic:\n    int xstate;\n    unsigned char h, w;\n    \n//    bool operator < (const State &r) const{\n//        int xl = xstate * H * W + h * W + w;\n//        int xr = r.xstate * H * W + r.h * W + r.w;\n//        return xl < xr;\n//    }\n};\n\ninline bool infield(int h, int w){\n    if(h == H)\n        return true;\n    else\n        return 0<=w && w<W;\n}\n\nint bfs(int sh, int sw){\n    int xn = xhs.size();\n    map<pair<int, int>, int> ipoint;\n    for(int i=0; i<xn; i++)\n        ipoint[{xhs[i], xws[i]}] = i;\n    \n    queue<State> que;\n    State s;\n    s.xstate = (1<<xn)-1;\n    s.h = sh;\n    s.w = sw;\n    que.push(s);\n    \n    memset(d, -1, sizeof(d));\n    d[s.xstate][s.h][s.w] = 0;\n    \n    while(!que.empty()){\n        auto s = que.front(); que.pop();\n        \n        for(int dh=-1; dh<=1; dh++){\n            for(int dw=-1; dw<=1; dw++) if(dh != 0 || dw != 0){\n                State ns;\n                ns.xstate = s.xstate;\n                ns.h = s.h + dh;\n                ns.w = s.w + dw;\n                \n                if(ipoint.find({ns.h, ns.w}) == ipoint.end() || ((ns.xstate>>ipoint[{ns.h, ns.w}])&1) == 0)\n                    continue;\n                \n                int count = 0;\n                while(infield(ns.h, ns.w) && ipoint.find({ns.h, ns.w})!= ipoint.end() && (ns.xstate>>ipoint[{ns.h, ns.w}])&1){\n                    ns.h += dh;\n                    ns.w += dw;\n                    count++;\n                }\n                if(!infield(ns.h, ns.w))\n                    continue;\n                \n                ns.h = s.h + dh;\n                ns.w = s.w + dw;\n                for(int i=0; i<count; i++){\n                    ns.xstate -= 1<<ipoint[{ns.h, ns.w}];\n                    ns.h += dh;\n                    ns.w += dw;\n                }\n                \n                if(d[ns.xstate][ns.h][ns.w] >= 0)\n                    continue;\n                \n                que.push(ns);\n                d[ns.xstate][ns.h][ns.w] = d[s.xstate][s.h][s.w] + 1;\n                \n                if(H-1<=ns.h){\n                    return d[ns.xstate][ns.h][ns.w];\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    for(auto &s: board) cin >> s;\n    \n    int sh, sw;\n    for(int h=0; h<H; h++){\n        for(int w=0; w<W; w++){\n            if(board[h][w] == 'O')\n                sh = h, sw = w;\n            if(board[h][w] == 'X')\n                xhs.push_back(h), xws.push_back(w);\n        }\n    }\n    cout << bfs(sh, sw) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2612&lang=jp\n#define INF 1<<30\n#define H 19\n#define W 15\ntypedef long long ll;\ntypedef pair<int, int> pii;\nint ans = INF;\nint dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nint dy[8] = { 0,-1,-1,-1,0,1,1,1 };\n\nbool check(int x, int y, vector<vector<char>>& masu,int& dir) {\n\tint nx = x + dx[dir], ny = y + dy[dir];\n\tif (masu[nx][ny] != 'X')return false;\n\twhile (true) {\n\t\tnx += dx[dir]; ny += dy[dir];\n\t\tif (masu[nx][ny] == 'X')continue;\n\t\tif (masu[nx][ny] == '#')return false;\n\t\tif (masu[nx][ny] == '.')return true;\n\t}\n\treturn false;\n}\n\nvoid erase_move(int&x, int&y, vector<vector<char>>& masu, int& dir) {\n\twhile (true) {\n\t\tx += dx[dir]; y += dy[dir];\n\t\tif (masu[x][y] == 'X') {\n\t\t\tmasu[x][y] = '.';\n\t\t\tcontinue;\n\t\t}\n\t\tif (masu[x][y] == '.')return ;\n\t}\n}\n\nvoid dfs(int x, int y,int cnt,vector<vector<char>>& masu) {\n\tif (cnt + 1 >= ans) return;\n\tfor (int dir = 0; dir < 8; dir++) {\n\t\tif (!check(x, y, masu, dir))continue;\n\t\tauto new_masu = masu;\n\t\tint new_x = x, new_y = y;\n\t\terase_move(new_x,new_y, new_masu, dir);\n\t\t\n\t\tif (new_x >= 19) {\n\t\t\tans = min(ans, cnt + 1);\n\t\t\treturn;\n\t\t}\n\n\t\tdfs(new_x, new_y, cnt + 1, new_masu);\n\t}\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tvector<vector<char>> masu(H + 2, vector<char>(W + 2,'#'));\n\tint sx, sy;\n\t/* input */\n\tmasu[H + 1][0] = masu[H + 1][W + 1] = '.';\n\tfor (int i = 1; i <= H+1; i++){\n\t\tfor (int j = 1; j <= W; j++){\n\t\t\tif (i == H + 1) masu[i][j] = '.';\n\t\t\telse {\n\t\t\t\tcin >> masu[i][j];\n\t\t\t\tif (masu[i][j] == 'O') { sx = i; sy = j; masu[i][j] = '.'; }\n\t\t\t}\n\t\t}\n\t}\n\n\tint f = 0;\n\tfor (int i = sx + 1; i <= H; i++) {\n\t\tfor (int j = 1; j <= W;j++) {\n\t\t\tif (masu[i][j] == 'X') { f = 0; break; }\n\t\t\tif(j == W)f++;\n\t\t}\n\t\tif (f == 2) {\n\t\t\tcout << -1 << endl; return 0;\n\t\t}\n\t}\n\n\tdfs(sx, sy, 0, masu);\n\tcout << (ans == INF ? -1 : ans) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nconst int W = 15, H = 19;\nconst int dx[] = {0, 1, 1, 1, 0, -1, -1, -1};\nconst int dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nbool isGoal(int x, int y) {\n\treturn y >= H;\n}\n\nstruct Node {\n\tint x, y, f;\n};\n\nvector<P> v;\nmap<int, map<int, map<int, int> > > dist;\nint sid[H][W];\n\nNode Go(const Node& node, int dir) {\n\tNode res = node;\n\tint x = node.x, y = node.y, f = node.f;\n//\tcout << \"Go:\" << x << \" \" << y << \" \" << dir << \" \" << f << endl;\n\tint nx = x+dx[dir], ny = y+dy[dir];\n\tif ( isGoal(x, y) ) return res;\n\tif ( !inRange(x, y) ) return {0, 0, -1};\n\tif ( sid[y][x] < 0 || (f & (1 << sid[y][x])) ) return res;\n\tres.x = nx, res.y = ny;\n\tres.f = f | (1 << sid[y][x]);\n\treturn Go(res, dir);\n}\nNode GoFirst(const Node& node, int dir) {\n\tNode res = {0, 0, -1};\n\tint x = node.x, y = node.y, f = node.f;\n\tint nx = x+dx[dir], ny = y+dy[dir];\n\tif ( !inRange(nx, ny) ) return res;\n\tif ( sid[ny][nx] < 0 || (f & (1 << sid[ny][nx])) ) return res;\n\tres.x = nx;\n\tres.y = ny;\n\tres.f = f;\n\treturn Go(res, dir);\n}\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tvector<string> m(H); cin >> m;\n\tint sx = -1, sy = -1;\n\tREP(y, H) REP(x, W) {\n\t\tif (m[y][x] == 'O') {\n\t\t\tsx = x, sy = y;\n\t\t}\n\t\tif (m[y][x] == 'X') {\n\t\t\tv.pb( P(x, y) );\n\t\t}\n\t}\n\tassert(sx >= 0);\n\n\tint N = v.size();\n\tfill(sid[0], sid[H], -1);\n\tREP(i, N) {\n\t\tint x = v[i].first, y = v[i].second;\n\t\tsid[y][x] = i;\n\t}\n\n\tll ans = 0;\n\tqueue<Node> Q; Q.push({sx, sy, 0});\n//\tfill(dist[0][0], dist[H-1][W], inf);\n\tdist[sy][sx][0] = 1;\n\twhile ( !Q.empty() ) {\n\t\tNode node = Q.front(); Q.pop();\n\t\tint x = node.x, y = node.y, f = node.f;\n//\t\tcout << x << \" \" << y << \" \" << f << endl;\n\t\tREP(i, 8) {\n\t\t\tNode n = GoFirst(node, i);\n\t\t\tif (n.f >= 0) {\n\t\t\t\tif ( isGoal(n.x, n.y) ) {\n\t\t\t\t\tif (ans == 0 || dist[y][x][f]+1 < ans) {\n\t\t\t\t\t\tans = dist[y][x][f]+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (dist[n.y][n.x][n.f] == 0 || dist[y][x][f]+1 < dist[n.y][n.x][n.f]) {\n\t\t\t\t\tdist[n.y][n.x][n.f] = dist[y][x][f]+1;\n\t\t\t\t\tQ.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (ans == 0) cout << -1 << endl;\n\telse cout << ans-1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<queue>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 20, T = (1<<N), H = 19, W = 15;\n\nset<int> memo[T];\nint board[H][W];\nint stx,sty;\n\nclass Q{\npublic:\n\tint x,y,cnt,state;\n\tQ(int x,int y,int cnt, int state):x(x),y(y),cnt(cnt),state(state){}\n};\n\nvoid input(){\n\tstring a[H];\n\n\trep(i,H)cin>>a[i];\n\tint cnt = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tboard[i][j] = -1;\n\t\t\tif(a[i][j] == 'X'){\n\t\t\t\tboard[i][j] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(a[i][j] == 'O'){\n\t\t\t\tstx = j; sty = i;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint zahyo(int x,int y){\n\treturn x + y * W;\n}\n\nbool hasmemo(Q u){\n\treturn memo[u.state].find(zahyo(u.x,u.y)) != memo[u.state].end();\n}\n\nvoid setmemo(Q u){\n\tmemo[u.state].insert(zahyo(u.x,u.y));\n}\n\nbool hasbit(int state, int i){\n\treturn (state&(1<<i))>0;\n}\n\nbool isblack(int x,int y,int state){\n\tint n = board[y][x];\n\tif(n<0)return false;\n\treturn !hasbit(state,n);\n}\n\nbool isout(int x,int y){\n\tif(y<0)return true;\n\tif(y<H){\n\t\tif(x<0 || x>=W)return true;\n\t}\n\treturn false;\n}\n\nbool isgoal(int x,int y){\n\tif(y>=H) return true;\n\treturn false;\n}\n\n\nint minblack(int x,int y,int state){\n\tint n = board[y][x];\n\t//if(n<0)puts(\"hoooo\");\n\t//if(hasbit(state,n))puts(\"hhahah\");\n\n\treturn state + (1<<n);\n}\n\nint solve(){\n\t\n\tqueue<Q> que;\n\tque.push(Q(stx,sty,0,0));\n\n\twhile(!que.empty()){\n\t\tQ u = que.front(); que.pop();\n\t\tif(hasmemo(u))continue;\n\t\tsetmemo(u);\n\n\t\t//printf(\"%d %d\\n\",u.x,u.y);\n\n\t\tint dx[] = {-1,0,1,-1,1,-1,0,1};\n\t\tint dy[] = {-1,-1,-1,0,0,1,1,1};\n\n\t\trep(p,8){\n\t\t\tint st = u.state;\n\t\t\treps(i,1,100){\n\t\t\t\tint nx = u.x + dx[p]*i;\n\t\t\t\tint ny = u.y + dy[p]*i;\n\n\n\t\t\t\tif(i==1){\n\t\t\t\t\tif(isout(nx,ny) || isgoal(nx,ny))break;\n\t\t\t\t\tif(!isblack(nx,ny,st))break;\n\t\t\t\t}\n\t\t\t\tif(i!=1){\n\t\t\t\t\tif(isout(nx,ny))break;\n\t\t\t\t\tif(isgoal(nx,ny))return u.cnt+1;\n\t\t\t\t\tif(!isblack(nx,ny,st)){\n\t\t\t\t\t\tque.push(Q(nx,ny,u.cnt+1,st));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tst = minblack(nx,ny,st);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tinput();\n\tcout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nint main(void) {\n  const ll H = 19, W = 15;\n  char S[H][W];\n  REP(i, 0, H) REP(j, 0, W) cin >> S[i][j];\n\n  pll white;\n  vector<pll> black, cand;\n  REP(i, 0, H) REP(j, 0, W) {\n    if(S[i][j] == 'O') {\n      white = pll(i, j);\n      cand.push_back(pll(i, j));\n    }\n    if(S[i][j] == 'X') {\n      black.push_back(pll(i, j));\n      REP(di, -1, 2) REP(dj, -1, 2) if(di != 0 || dj != 0) {\n        ll ni = i + di, nj = j + dj;\n        if(!(0 <= ni && ni < H && 0 <= nj && nj < W)) break;\n        cand.push_back(pll(i + di, j + dj));\n      }\n    }\n  }\n  sort(black.begin(), black.end());\n  sort(cand.begin(), cand.end());\n  cand.erase(unique(cand.begin(), cand.end()), cand.end());\n\n  ll N = black.size(), M = cand.size();\n  map<pll, bool> visited;\n\n  struct state { ll s, v, d; };\n  queue<state> q;\n  q.push((state) { (1LL << N) - 1, lower_bound(cand.begin(), cand.end(), white) - cand.begin(), 0 });\n\n  while(!q.empty()) {\n    ll s = q.front().s, v = q.front().v, d = q.front().d;\n    ll y = cand[v].first, x = cand[v].second;\n    q.pop();\n\n    visited[pll(s, v)] = true;\n    REP(i, 0, N) cout << (s & (1LL << i) ? 1 : 0);\n\n    REP(i, -1, 2) REP(j, -1, 2) if(i != 0  || j != 0) {\n      ll ns = s, ny = y + i, nx = x + j, nd = d + 1;\n      ll cnt = 0;\n\n      while(1) {\n        if(!(0 <= ny && ny < H && 0 <= nx && nx < W)) break;\n        if(S[ny][nx] != 'X') break;\n\n        ll b = lower_bound(black.begin(), black.end(), pll(ny, nx)) - black.begin();\n        if(b == N) break;\n        if(!(ns & (1LL << b))) break;\n\n        ns = ns - (1LL << b);\n        ny += i;\n        nx += j;\n        cnt++;\n      }\n\n      if(cnt > 0 && ny >= H - 1) {\n        cout << nd << endl;\n        return 0;\n      } else if(cnt > 0 && 0 <= ny && ny < H && 0 <= nx && nx < W) {\n        ll nv = lower_bound(cand.begin(), cand.end(), pll(ny, nx)) - cand.begin();\n        if(!visited[pll(ns, nv)]) q.push((state) { ns, nv, nd });\n      }\n    }\n  }\n  cout << -1 << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define r(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>P2;\n\nstring s[21];\nint h=21,w=17,sx,sy;\nint dx[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={-1,-1,0,1,1,1,0,-1};\nbool d[21][19][1<<20];\n\nmap<pair<int,int>,int>M1;\nmap<int,pair<int,int> >M2;\nint cnt;\n\nint main(){\n  s[0]=s[20]=\".................\";\n  r(i,h-2){\n    cin>>s[i+1];\n    s[i+1]=\".\"+s[i+1]+\".\";\n  }\n  r(i,h)r(j,w)if(s[i][j]=='O'){\n    sx=j;\n    sy=i;\n    s[i][j]='.';\n  }else if(s[i][j]=='X'){\n    M2[cnt]=P(i,j);\n    M1[P(i,j)]=cnt++;\n  }\n  queue<P2>q;\n  d[sy][sx][0]=1;\n  q.push(P2(P(sy*1000+sx,0),0));\n  while(!q.empty()){\n    P2 p=q.front();q.pop();\n    int y=p.first.first/1000;\n    int x=p.first.first%1000;\n    int cost=p.first.second;\n    int bit=p.second;\n    r(i,8){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      int b=bit;\n      if(ny<=0||nx<=0||ny>=h||nx>=w-1)continue;\n      if(s[ny][nx]=='.')continue;\n      if((1<<M1[P(ny,nx)])&b)continue;\n      while(s[ny][nx]=='X'){\n\tint c=M1[P(ny,nx)];\n\tif((1<<c)&b)break;\n\tb|=(1<<c);\n\tny+=dy[i];\n\tnx+=dx[i];\n      }\n      if(d[ny][nx][b]==1)continue;\n      d[ny][nx][b]=1;\n      q.push(P2(P(ny*1000+nx,cost+1),b));\n      if(ny>=19){\n\tcout<<cost+1<<endl;\n\treturn 0;\n      }\n    }\n  }\n  cout<<-1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\nint BFS(vector<string> v)\n{\n\tmap<vector<string>, int> d; d[v] = 1;\n\n\tqueue<pair<vector<string>, int> > que; que.push(make_pair(v, 1));\n\n\tfor (int i = 0; i < 15; i++)\n\t{\n\t\tif (v[18][i] == 'O')\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tvector<string> v1 = que.front().first;\n\n\t\tint dist = que.front().second; que.pop();\n\n\t\tint sx = -1, sy = -1;\n\n\t\tfor (int i = 0; i < 19; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 15; j++)\n\t\t\t{\n\t\t\t\tif (v1[i][j] == 'O')\n\t\t\t\t{\n\t\t\t\t\tsx = j; sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\tif (0 <= sx + dx[dir] && sx + dx[dir] < 15 && 0 <= sy + dy[dir] && sy + dy[dir] < 19)\n\t\t\t{\n\t\t\t\tif (v1[sy + dy[dir]][sx + dx[dir]] == 'X')\n\t\t\t\t{\n\t\t\t\t\tint x = sx + dx[dir] * 2;\n\t\t\t\t\tint y = sy + dy[dir] * 2;\n\n\t\t\t\t\twhile (0 <= x && x < 15 && 0 <= y)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (y > 17) { return dist; }\n\n\t\t\t\t\t\tif (v1[y][x] == '.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvector<string> v2 = v1;\n\n\t\t\t\t\t\t\tint rx = sx, ry = sy;\n\n\t\t\t\t\t\t\tfor (; x != rx || y != ry;)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tv2[ry][rx] = '.';\n\n\t\t\t\t\t\t\t\trx += dx[dir];\n\t\t\t\t\t\t\t\try += dy[dir];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tv2[y][x] = 'O'\n\n\t\t\t\t\t\t\tif (d[v2] == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\td[v2] = dist + 1;\n\n\t\t\t\t\t\t\t\tque.push(make_pair(v2, dist + 1));\n\n\t\t\t\t\t\t\t\tgoto Exit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx += dx[dir];\n\t\t\t\t\t\ty += dy[dir];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tExit:;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tvector<string> v(19);\n\n\tfor (int i = 0; i < 19; i++) { cin >> v[i]; }\n\n\tcout << BFS(v) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int h = 20, w = 17;\nvector<vector<char>> c;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint main(){\n\tc = vector<vector<char>>(h, vector<char>(w,'.'));\n\n\tpair<int, int> s;\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tcin >> c[i][j + 1];\n\t\t\tif(c[i][j + 1] == 'O') s = make_pair(i,j + 1);\n\t\t}\n\t}\n\n\ttypedef tuple<pair<int, int>, vector<vector<char>>, int> T;\n\tqueue<T> q;\n\tq.push(T(s,c,0));\n\n\tint ans = INF;\n\tmap<vector<vector<char>>, vector<vector<int>>> memo;\n\twhile(not q.empty()){\n\t\tint cost;\n\t\ttie(s,c,cost) = q.front(); q.pop();\n\n\t\tint y, x;\n\t\ttie(y,x) = s;\n\n\t\t//rep(i,h){ rep(j,w){ if(i == y and j == x) cout << 'O'; else cout << c[i][j]; } cout << endl; } cout << endl;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(i,8){\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)) continue;\n\t\t\tvector<vector<char>> pc = c;\n\t\t\tif(pc[ny][nx] == 'X'){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pc[ny][nx] == '.') break;\n\t\t\t\t\tpc[ny][nx] = '.';\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tif(memo.count(pc)){\n\t\t\t\t\tauto& it = memo[pc];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<int>> dis(h, vector<int>(w,INF));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[pc] = dis;\n\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 30;\n\nmap<pair<int,int>, int8_t> memo;\n\nint8_t dfs(const vector<vector<int>> &idx, int i, int j) {\n  auto itr = memo.find(make_pair(i, j));\n  if (itr != end(memo)) return itr->second;\n  if (j == 15*19) return 0;\n  int oi = j/15;\n  int oj = j%15;\n  int di[8] = {1, 1, 1, 0, -1, -1, -1, 0};\n  int dj[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\n  int8_t res = INF;\n  REP(k,8) {\n    int l = 1;\n    vector<int> ei;\n    int ni;\n    int nj;\n    while (1) {\n      ni = oi + l*di[k];\n      nj = oj + l*dj[k];\n      if (ni < 0 || ni >= 19 || nj < 0 || nj >= 15) break;\n      if (idx[ni][nj] < 0 || ((i>>idx[ni][nj])&1)) break;\n      ei.push_back(idx[ni][nj]);\n      ++l;\n    }\n    if (l > 1) {\n      int pi = i;\n      for (int ix : ei) {\n        pi |= 1 << ix;\n      }\n      if (ni >= 19 || (ni == 18 && nj >= 0 && nj < 15)) {\n        res = min(res, int8_t(dfs(idx, pi, 15*19)+1));\n      } else if (ni >= 0 && nj >= 0 && nj < 15) {\n        res = min(res, int8_t(dfs(idx, pi, ni*15+nj)+1));\n      }\n    }\n  }\n  memo[make_pair(i,j)] = res;\n  return res;\n}\n\nint main() {\n  vector<string> t(19);\n  vector<pair<int, int>> vb;\n  vector<vector<int>> idx(19, vector<int>(15, -1));\n  int si, sj;\n  REP(i,19) {\n    cin>>t[i];\n    REP(j,15) {\n      if (t[i][j] == 'X') {\n        idx[i][j] = vb.size();\n        vb.emplace_back(i,j);\n      } else if (t[i][j] == 'O') {\n        si = i;\n        sj = j;\n      }\n    }\n  }\n  int res = dfs(idx, 0, si*15+sj);\n  if (res < INF) {\n    cout << (int)res << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nstruct State { int x[19][15]; };\nState S;\nint dx[8] = { 1,1,1,0,-1,-1,-1,0 }, dy[8] = { -1,0,1,1,1,0,-1,-1 };\nint solve(State p) {\n\tint cx = 0, cy = 0;\n\tfor (int i = 0; i < 285; i++) {\n\t\tif (p.x[i / 15][i % 15] == 2) { cx = i / 15; cy = i % 15; }\n\t}\n\tint minx = 999999;\n\tfor (int i = 0; i < 8; i++) {\n\t\tState T = p;\n\t\tint ex = cx, ey = cy;\n\t\tbool flag = true;\n\t\twhile (true) {\n\t\t\tex += dx[i]; ey += dy[i];\n\t\t\tif (ex < 0 || ey < 0 || ey >= 15) { flag = false; break; }\n\t\t\tif (ex >= 19)break;\n\t\t\tif (T.x[ex][ey] == 0)break;\n\t\t\tT.x[ex][ey] = 0;\n\t\t}\n\t\tif (flag == false)continue;\n\n\t\tif (abs(ex - cx) <= 1 && abs(ey - cy) <= 1)continue;\n\t\tif (ex == 18 || ex == 19)minx = min(minx, 1);\n\t\telse {\n\t\t\tT.x[cx][cy] = 0; T.x[ex][ey] = 2;\n\t\t\tminx = min(minx, solve(T) + 1);\n\t\t}\n\t}\n\treturn minx;\n}\nint main() {\n\tfor (int i = 0; i < 19; i++) {\n\t\tfor (int j = 0; j < 15; j++) {\n\t\t\tchar p; cin >> p;\n\t\t\tif (p == 'O')S.x[i][j] = 2;\n\t\t\tif (p == 'X')S.x[i][j] = 1;\n\t\t\tif (p == '.')S.x[i][j] = 0;\n\t\t}\n\t}\n\tint R = solve(S); if (R >= 100000)R = -1;\n\tcout << R << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nstring s[19];\nint bx[20],by[20];\nint id[19][15];\nint dx[8]={-1,-1,-1,0,1,1,1,0};\nint dy[8]={-1,0,1,1,1,0,-1,-1};\nint B;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nset<PP> st;\nbool is(int x,int y){\n\treturn 0<=x&&x<19&&0<=y&&y<15;\n}\nbool isX(int x,int y,int b){\n\treturn is(x,y)&&id[x][y]>=0&& ((b>>id[x][y])&1);\n}\nbool goal(int x,int y){\n\treturn x>=18;\n}\nint main(){\n\trep(i,19) rep(j,15) id[i][j]=-1;\n\trep(i,19) cin>>s[i];\n\tint sx,sy;\n\trep(i,19) rep(j,15){\n\t\tif(s[i][j]=='O') sx=i,sy=j;\n\t\tif(s[i][j]=='X') bx[B]=i,by[B]=j,id[i][j]=B++;\n\t}\n\tqueue<int> qx,qy,qb,qd;\n\tqx.push(sx),qy.push(sy),qb.push((1<<B)-1),qd.push(0);\n\tst.insert(PP(P(sx,sy),(1<<B)-1));\n\twhile(!qx.empty()){\n\t\tint x=qx.front(),y=qy.front(),b=qb.front(),d=qd.front();\n\t\tqx.pop(),qy.pop(),qb.pop(),qd.pop();\n\t\trep(di,8){\n\t\t\tint nx=x+dx[di],ny=y+dy[di],nb=b,nd=d+1;\n\t\t\tif(!isX(nx,ny,nb)) continue;\n\t\t\twhile(isX(nx,ny,nb)){\n\t\t\t\tnb^=(1<<id[nx][ny]);\n\t\t\t\tnx+=dx[di],ny+=dy[di];\n\t\t\t}\n\t\t\tif(goal(nx,ny)){\n\t\t\t\tcout<<nd<<endl;\n\t\t\t\treturn 0;\n\t\t\t}else if(is(nx,ny)&&st.find(PP(P(nx,ny),nb))==st.end()){\n\t\t\t\tqx.push(nx),qy.push(ny),qb.push(nb),qd.push(nd);\n\t\t\t\tst.insert(PP(P(nx,ny),nb));\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<queue>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 20, T = (1<<N), H = 19, W = 15;\n\nset<int> memo[T];\nint board[H][W];\nint stx,sty;\n\nclass Q{\npublic:\n\tint x,y,cnt,state;\n\tQ(int x,int y,int cnt, int state):x(x),y(y),cnt(cnt),state(state){}\n};\n\nvoid input(){\n\tstring a[H];\n\n\trep(i,H)cin>>a[i];\n\tint cnt = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tboard[i][j] = -1;\n\t\t\tif(a[i][j] == 'X'){\n\t\t\t\tboard[i][j] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(a[i][j] == 'O'){\n\t\t\t\tstx = j; sty = i;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint zahyo(int x,int y){\n\treturn x * W + y;\n}\n\nbool hasmemo(Q u){\n\treturn memo[u.state].find(zahyo(u.x,u.y)) != memo[u.state].end();\n}\n\nvoid setmemo(Q u){\n\tmemo[u.state].insert(zahyo(u.x,u.y));\n}\n\nbool hasbit(int state, int i){\n\treturn (state&(1<<i))>0;\n}\n\nbool isblack(int x,int y,int state){\n\tint n = board[y][x];\n\tif(n<0)return false;\n\treturn !hasbit(state,n);\n}\n\nbool isout(int x,int y){\n\tif(y<0)return true;\n\tif(y<H){\n\t\tif(x<0 || x>=W)return true;\n\t}\n\treturn false;\n}\n\nbool isgoal(int x,int y){\n\tif(y>=H) return true;\n\treturn false;\n}\n\n\nint minblack(int x,int y,int state){\n\tint n = board[y][x];\n\tif(n<0)puts(\"hoooo\");\n\tif(hasbit(state,n))puts(\"hhahah\");\n\n\treturn state + (1<<n);\n}\n\nint solve(){\n\t\n\tqueue<Q> que;\n\tque.push(Q(stx,sty,0,0));\n\n\twhile(!que.empty()){\n\t\tQ u = que.front(); que.pop();\n\t\tif(hasmemo(u))continue;\n\t\tsetmemo(u);\n\n\t\t//printf(\"%d %d\\n\",u.x,u.y);\n\n\t\tint dx[] = {-1,0,1,-1,1,-1,0,1};\n\t\tint dy[] = {-1,-1,-1,0,0,1,1,1};\n\n\t\trep(p,8){\n\t\t\tint st = u.state;\n\t\t\treps(i,1,100){\n\t\t\t\tint nx = u.x + dx[p]*i;\n\t\t\t\tint ny = u.y + dy[p]*i;\n\n\n\t\t\t\tif(i==1){\n\t\t\t\t\tif(isout(nx,ny) || isgoal(nx,ny))break;\n\t\t\t\t\tif(!isblack(nx,ny,st))break;\n\t\t\t\t}\n\t\t\t\tif(i!=1){\n\t\t\t\t\tif(isout(nx,ny))break;\n\t\t\t\t\tif(isgoal(nx,ny))return u.cnt+1;\n\t\t\t\t\tif(!isblack(nx,ny,st)){\n\t\t\t\t\t\tque.push(Q(nx,ny,u.cnt+1,st));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tst = minblack(nx,ny,st);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tinput();\n\tcout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct S {\n\tint x, y, mask;\n};\n\nint b[19][15];\nint dp[19][15][1 << 20];\n\nint dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 };\nint dy[8] = { 0, 1, 0, -1, 1, -1, 1, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < 15 && 0 <= y && y < 19;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint B = 0;\n\tint sx = -1, sy = -1;\n\tmemset(b, -1, sizeof b);\n\tfor(int i = 0; i < 19; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j < 15; j++) {\n\t\t\tif(s[j] == 'O') sx = j, sy = i;\n\t\t\tif(s[j] == 'X') {\n\t\t\t\tb[i][j] = B++;\n\t\t\t}\n\t\t}\n\t}\n\n\tconst int INF = 1 << 25;\n\tfill((int*)begin(dp), (int*)end(dp), INF);\n\tdp[sy][sx][0] = 0;\n\n\tqueue<S> q;\n\tq.push({ sx, sy, 0 });\n\twhile(q.size()) {\n\t\tint x = q.front().x, y = q.front().y, mask = q.front().mask;\n\t\tint t = dp[y][x][mask];\n\t\tq.pop();\n\t\tfor(int k = 0; k < 8; k++) {\n\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\tif(!in(nx, ny)) continue;\n\t\t\tint id = b[ny][nx];\n\t\t\tif(id == -1) continue;\n\t\t\tif(mask >> id & 1) continue;\n\t\t\t//cerr << \"nx : \" << nx << \", ny : \" << ny << endl;\n\t\t\tint nmask = mask;\n\t\t\twhile(1) {\n\t\t\t\tnmask |= 1 << id;\n\t\t\t\tnx += dx[k], ny += dy[k];\n\t\t\t\tif(!in(nx, ny)) break;\n\t\t\t\tid = b[ny][nx];\n\t\t\t\tif(id == -1 || (mask >> id & 1)) break;\n\t\t\t}\n\t\t\tif(ny >= 19) {\n\t\t\t\tcout << t + 1 << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(in(nx, ny)) {\n\t\t\t\tif(dp[ny][nx][nmask] > t + 1) {\n\t\t\t\t\tdp[ny][nx][nmask] = t + 1;\n\t\t\t\t\tq.push({ nx, ny, nmask });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << -1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int h = 20, w = 17;\nvector<vector<char>> c;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint main(){\n\tc = vector<vector<char>>(h, vector<char>(w,'.'));\n\n\tpair<int, int> s;\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tcin >> c[i][j + 1];\n\t\t\tif(c[i][j + 1] == 'O'){\n\t\t\t\ts = make_pair(i,j + 1);\n\t\t\t\tc[i][j + 1] = '.';\n\t\t\t}\n\t\t}\n\t}\n\n\ttypedef tuple<pair<int, int>, vector<vector<char>>, int> T;\n\tqueue<T> q;\n\tq.push(T(s,c,0));\n\n\tint ans = INF;\n\tmap<vector<vector<char>>, vector<vector<int>>> memo;\n\twhile(not q.empty()){\n\t\tint cost;\n\t\ttie(s,c,cost) = q.front(); q.pop();\n\n\t\tint y, x;\n\t\ttie(y,x) = s;\n\n\t\t//rep(i,h){ rep(j,w){ if(i == y and j == x) cout << 'O'; else cout << c[i][j]; } cout << endl; } cout << endl;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(i,8){\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)) continue;\n\t\t\tvector<vector<char>> pc = c;\n\t\t\tif(pc[ny][nx] == 'X'){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pc[ny][nx] == '.') break;\n\t\t\t\t\tpc[ny][nx] = '.';\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tif(memo.count(pc)){\n\t\t\t\t\tauto& it = memo[pc];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<int>> dis(h, vector<int>(w,INF));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[pc] = dis;\n\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\nint BFS(vector<string> v)\n{\n\tmap<vector<string>, int> d; d[v] = 1;\n\n\tqueue<pair<vector<string>, int> > que; que.push(make_pair(v, 1));\n\n\tfor (int i = 0; i < 15; i++)\n\t{\n\t\tif (v[18][i] == 'O')\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tvector<string> v1 = que.front().first;\n\n\t\tint dist = que.front().second; que.pop();\n\n\t\tint sx = -1, sy = -1;\n\n\t\tfor (int i = 0; i < 19; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 15; j++)\n\t\t\t{\n\t\t\t\tif (v1[i][j] == 'O')\n\t\t\t\t{\n\t\t\t\t\tsx = j; sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\tif (0 <= sx + dx[dir] && sx + dx[dir] < 15 && 0 <= sy + dy[dir] && sy + dy[dir] < 19)\n\t\t\t{\n\t\t\t\tif (v1[sy + dy[dir]][sx + dx[dir]] == 'X')\n\t\t\t\t{\n\t\t\t\t\tif (sx == 3 && sy == 8)\n\t\t\t\t\t{\n\t\t\t\t\t\tint a = 3;\n\t\t\t\t\t}\n\t\t\t\t\tint x = sx + dx[dir] * 2;\n\t\t\t\t\tint y = sy + dy[dir] * 2;\n\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (y > 18) { return dist; }\n\n\t\t\t\t\t\tif (x < 0 || 15 <= x || y < 0) { break; }\n\n\t\t\t\t\t\tif (y > 17) { return dist; }\n\n\t\t\t\t\t\tif (v1[y][x] == '.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvector<string> v2 = v1;\n\n\t\t\t\t\t\t\tint rx = sx, ry = sy;\n\n\t\t\t\t\t\t\tfor (; x != rx || y != ry;)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tv2[ry][rx] = '.';\n\n\t\t\t\t\t\t\t\trx += dx[dir];\n\t\t\t\t\t\t\t\try += dy[dir];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tv2[y][x] = 'O';\n\n\t\t\t\t\t\t\tif (d[v2] == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\td[v2] = dist + 1;\n\n\t\t\t\t\t\t\t\tque.push(make_pair(v2, dist + 1));\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tgoto Exit;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx += dx[dir];\n\t\t\t\t\t\ty += dy[dir];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tExit:;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tvector<string> v(19);\n\n\tfor (int i = 0; i < 19; i++) { cin >> v[i]; }\n\n\tbool ok = false;\n\n\tfor (int i = 17; i < 19; i++)\n\t{\n\t\tfor (int j = 0; j < 15; j++)\n\t\t{\n\t\t\tif (v[i][j] == 'X')\n\t\t\t{\n\t\t\t\tok = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ok)\n\t{\n\t\tcout << BFS(v) << endl;\n\t}\n\telse\n\t{\n\t\tcout << -1 << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\nint BFS(vector<string> v)\n{\n\tmap<vector<string>, int> d; d[v] = 1;\n\n\tqueue<pair<vector<string>, int> > que; que.push(make_pair(v, 1));\n\n\tfor (int i = 0; i < 15; i++)\n\t{\n\t\tif (v[18][i] == 'O')\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tvector<string> v1 = que.front().first;\n\n\t\tint dist = que.front().second; que.pop();\n\n\t\tint sx = -1, sy = -1;\n\n\t\tfor (int i = 0; i < 19; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 15; j++)\n\t\t\t{\n\t\t\t\tif (v1[i][j] == 'O')\n\t\t\t\t{\n\t\t\t\t\tsx = j; sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\tif (0 <= sx + dx[dir] && sx + dx[dir] < 15 && 0 <= sy + dy[dir] && sy + dy[dir] < 19)\n\t\t\t{\n\t\t\t\tif (v1[sy + dy[dir]][sx + dx[dir]] == 'X')\n\t\t\t\t{\n\t\t\t\t\tint x = sx + dx[dir] * 2;\n\t\t\t\t\tint y = sy + dy[dir] * 2;\n\n\t\t\t\t\twhile (0 <= x && x < 15 && 0 <= y)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (y > 17) { return dist; }\n\n\t\t\t\t\t\tif (v1[y][x] == '.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvector<string> v2 = v1;\n\n\t\t\t\t\t\t\tint rx = sx, ry = sy;\n\n\t\t\t\t\t\t\tfor (; x != rx || y != ry;)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tv2[ry][rx] = '.';\n\n\t\t\t\t\t\t\t\trx += dx[dir];\n\t\t\t\t\t\t\t\try += dy[dir];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (d[v2] == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\td[v2] = dist + 1;\n\n\t\t\t\t\t\t\t\tque.push(make_pair(v2, dist + 1));\n\n\t\t\t\t\t\t\t\tgoto Exit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx += dx[dir];\n\t\t\t\t\t\ty += dy[dir];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tExit:;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tvector<string> v(19);\n\n\tfor (int i = 0; i < 19; i++) { cin >> v[i]; }\n\n\tcout << BFS(v) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H=19,W=15;\n\nenum DIR{\n    Left_Up,\n    Up,\n    Right_Up,\n    Left,\n    Right,\n    Left_Down,\n    Down,\n    Right_Down,\n};\n\nDIR dir[8] = {Left_Up,Up,Right_Up,Left,Right,Left_Down,Down,Right_Down};\n\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\n\nstruct BlackStone{\n    BlackStone(){\n        row = col = 0;\n    }\n\n    BlackStone(short arg_row,short arg_col){\n        row = arg_row;\n        col = arg_col;\n    }\n    short row,col;\n};\n\nstruct Info{\n    vector<BlackStone> BLACK_STONE;\n    short row,col,count;\n};\n\nbool rangeCheck(short row,short col){\n    if(row <= 17){\n        if(col < 0 || col > 14){\n            return false;\n        }else{\n            return true;\n        }\n    }else{ //row >= 18\n        if(row == 18 && (col < 0 || col > 14)){\n            return false;\n        }else{\n            return true;\n        }\n    }\n}\n\nInfo move(Info info,DIR dir){\n    Info ret;\n\n    char map[19][15];\n    for(int i = 0; i < H; i++){\n        for(int k = 0; k < W; k++)map[i][k] = '.';\n    }\n\n    for(int i = 0; i < info.BLACK_STONE.size(); i++){\n        map[info.BLACK_STONE[i].row][info.BLACK_STONE[i].col] = 'X';\n    }\n    ret.count = info.count+1;\n\n    int next_row,next_col,index;\n\n    switch(dir){\n    case Left_Up:\n        index = 0;\n        break;\n    case Up:\n        index = 1;\n        break;\n    case Right_Up:\n        index = 2;\n        break;\n    case Left:\n        index = 3;\n        break;\n    case Right:\n        index = 4;\n        break;\n    case Left_Down:\n        index = 5;\n        break;\n    case Down:\n        index = 6;\n        break;\n    case Right_Down:\n        index = 7;\n        break;\n    }\n\n    next_row = info.row+diff_row[index];\n    next_col = info.col+diff_col[index];\n\n    while(rangeCheck(next_row,next_col) == true && map[next_row][next_col] == 'X'){\n        next_row += diff_row[index];\n        next_col += diff_col[index];\n    }\n\n\n    if(next_row == info.row+diff_row[index] && next_col == info.col+diff_col[index]){\n        ret.row = 1;\n        ret.col = -1;\n    }else{\n\n        if(rangeCheck(next_row,next_col) == true && next_row <= 18){ //???????????§??????????????¢??????????????´???\n\n        \tfor(int i = 0; i < info.BLACK_STONE.size();i++){\n        \t\tret.BLACK_STONE.push_back(info.BLACK_STONE[i]);\n        \t}\n\n            int tmp_row,tmp_col;\n\n            tmp_row = info.row+diff_row[index];\n            tmp_col = info.col+diff_col[index];\n\n            while(tmp_row != next_row || tmp_col != next_col){\n                for(int i = 0; i < ret.BLACK_STONE.size();i++){\n                    if(ret.BLACK_STONE[i].row == tmp_row && ret.BLACK_STONE[i].col == tmp_col){\n                        ret.BLACK_STONE.erase(ret.BLACK_STONE.begin()+i);\n                        break;\n                    }\n                }\n                tmp_row += diff_row[index];\n                tmp_col += diff_col[index];\n            }\n        }\n\n        ret.row = next_row;\n        ret.col = next_col;\n    }\n\n    return ret;\n}\n\nint main(){\n\n    Info first;\n\n    char buf[15];\n    int minimum = BIG_NUM,start_row,start_col,num;\n    bool FLG = true;\n\n    for(short i = 0; i < H; i++){\n        scanf(\"%s\",buf);\n        if(i == 17 || i == 18){\n        \tnum = 0;\n        }\n        for(short k = 0; k < W; k++){\n            if(buf[k] == 'O'){\n                start_row = i;\n                start_col = k;\n            }else if(buf[k] == 'X'){\n                first.BLACK_STONE.push_back(BlackStone(i,k));\n            }\n            if((i == 17 || i == 18) && buf[k] == 'X')num++;\n        }\n        if((i == 17 || i == 18) && num == 0){\n        \tFLG = false;\n        }\n    }\n\n    if(!FLG){\n    \tprintf(\"-1\\n\");\n    \treturn 0;\n    }\n\n    first.row = start_row;\n    first.col = start_col;\n    first.count = 0;\n\n    queue<Info> Q;\n    Q.push(first);\n\n    while(!Q.empty()){\n\n        if(Q.front().row >= 18){\n            minimum = Q.front().count;\n            break;\n        }else{\n\n            for(int i = 0; i < 8; i++){\n            \tInfo next = move(Q.front(),dir[i]);\n\n                if(rangeCheck(next.row,next.col)){\n                    Q.push(next);\n                }\n            }\n\n            Q.pop();\n        }\n    }\n\n    if(minimum == BIG_NUM){\n        printf(\"-1\\n\");\n    }else{\n        printf(\"%d\\n\",minimum);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 19;\nconst int W = 15;\nvector<string> board(H);\nvector<int> xhs, xws;\nint d[1<<20][H][W];\n\nclass State{\npublic:\n    int xstate;\n    int h, w;\n    \n//    bool operator < (const State &r) const{\n//        int xl = xstate * H * W + h * W + w;\n//        int xr = r.xstate * H * W + r.h * W + r.w;\n//        return xl < xr;\n//    }\n};\n\ninline bool infield(int h, int w){\n    if(h == H)\n        return true;\n    else\n        return 0<=w && w<W;\n}\n\nint bfs(int sh, int sw){\n    int xn = xhs.size();\n    map<pair<int, int>, int> ipoint;\n    for(int i=0; i<xn; i++)\n        ipoint[{xhs[i], xws[i]}] = i;\n    \n    queue<State> que;\n    State s;\n    s.xstate = (1<<xn)-1;\n    s.h = sh;\n    s.w = sw;\n    que.push(s);\n    d[s.xstate][s.h][s.w] = 0;\n    \n    while(!que.empty()){\n        auto s = que.front(); que.pop();\n        \n        for(int dh=-1; dh<=1; dh++){\n            for(int dw=-1; dw<=1; dw++) if(dh != 0 || dw != 0){\n                State ns;\n                ns.xstate = s.xstate;\n                ns.h = s.h + dh;\n                ns.w = s.w + dw;\n                \n                if(ipoint.find({ns.h, ns.w}) == ipoint.end() || ((ns.xstate>>ipoint[{ns.h, ns.w}])&1) == 0)\n                    continue;\n                \n                int count = 0;\n                while(infield(ns.h, ns.w) && ipoint.find({ns.h, ns.w})!= ipoint.end() && (ns.xstate>>ipoint[{ns.h, ns.w}])&1){\n                    ns.h += dh;\n                    ns.w += dw;\n                    count++;\n                }\n                if(!infield(ns.h, ns.w))\n                    continue;\n                \n                ns.h = s.h + dh;\n                ns.w = s.w + dw;\n                for(int i=0; i<count; i++){\n                    ns.xstate -= 1<<ipoint[{ns.h, ns.w}];\n                    ns.h += dh;\n                    ns.w += dw;\n                }\n                \n                que.push(ns);\n                d[ns.xstate][ns.h][ns.w] = d[s.xstate][s.h][s.w] + 1;\n                \n                if(H<=ns.h){\n                    return d[ns.xstate][ns.h][ns.w];\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    for(auto &s: board) cin >> s;\n    \n    int sh, sw;\n    for(int h=0; h<H; h++){\n        for(int w=0; w<W; w++){\n            if(board[h][w] == 'O')\n                sh = h, sw = w;\n            if(board[h][w] == 'X')\n                xhs.push_back(h), xws.push_back(w);\n        }\n    }\n    cout << bfs(sh, sw) << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<int(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nconstexpr int INF = 30;\n\nint main() {\n  vector<string> t(19);\n  vector<pair<int, int>> vb;\n  vector<vector<int>> idx(19, vector<int>(15, -1));\n  int si, sj;\n  REP(i,19) {\n    cin>>t[i];\n    REP(j,15) {\n      if (t[i][j] == 'X') {\n        idx[i][j] = vb.size();\n        vb.emplace_back(i,j);\n      } else if (t[i][j] == 'O') {\n        si = i;\n        sj = j;\n      }\n    }\n  }\n  int n = vb.size();\n  vector<vector<int8_t>> dp(1<<n, vector<int8_t>(15*19+1, INF));\n  dp[0][si*15+sj] = 0;\n  REP(i,1<<n) {\n    REP(j,15*19) {\n      if (dp[i][j] == INF) continue;\n      int oi = j/15;\n      int oj = j%15;\n      int di[8] = {1, 1, 1, 0, -1, -1, -1, 0};\n      int dj[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\n      REP(k,8) {\n        int l = 1;\n        vector<int> ei;\n        int ni;\n        int nj;\n        while (1) {\n          ni = oi + l*di[k];\n          nj = oj + l*dj[k];\n          if (ni < 0 || ni >= 19 || nj < 0 || nj >= 15) break;\n          if (idx[ni][nj] < 0 || ((i>>idx[ni][nj])&1)) break;\n          ei.push_back(idx[ni][nj]);\n          ++l;\n        }\n        if (l > 1) {\n          int pi = i;\n          for (int ix : ei) {\n            pi |= 1 << ix;\n          }\n          if (ni >= 19) {\n            dp[pi][15*19] = min(dp[pi][15*19], int8_t(dp[i][j]+1));\n          } else if (ni >= 0 && nj >= 0 && nj < 15) {\n            dp[pi][ni*15+nj] = min(dp[pi][ni*15+nj], int8_t(dp[i][j]+1));\n          }\n        }\n      }\n    }\n  }\n  int8_t res = INF;\n  REP(i,1<<n) res = min(res, dp[i][15*19]);\n  if (res < INF) {\n    cout << (int)res << endl;\n  } else {\n    cout << -1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100\nusing namespace std;\nconst int w = 15;\nconst int h = 19;\ntypedef pair<int,int> P;\nvector<string> mp(h);\nmap<P,int>M;\nbool inmp(int x,int y){return 0<=x&&0<=y&&x<w&&y<h;}\nbool goal(int x,int y){return (y==h||(y==h-1&&0<=x&&x<w));}\n\nint mem[1<<20],used[1<<20];\nint dfs(int x,int y,int bit){\n  if(goal(x,y)) return 0;\n  if(!inmp(x,y)) return INF;\n  if(used[bit]++) return mem[bit];\n  \n  int res = INF;\n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      int nx = x+i;\n      int ny = y+j;\n      int nbit = bit;\n      if(!inmp(nx,ny)||mp[ny][nx] != 'X') continue;\n\n      vector<string>tmp = mp;\n      while(inmp(nx,ny)&&mp[ny][nx]=='X'){\n\tmp[ny][nx] = '.';\n\tnbit |=1<<M[P(nx,ny)];\n\tnx+=i,ny+=j;\n      }\n      res=min(res,1+dfs(nx,ny,nbit));\n      mp = tmp;\n    }\n  return mem[bit]=res;\n}\n\nint main(){\n\n  for(int i=0;i<h;i++)cin>>mp[i];\n\n  for(int i=0,c=0;i<h;i++)\n    for(int j=0;j<w;j++) if(mp[i][j]=='X') M[P(j,i)] = c++;\n\n  int ans; \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) if(mp[i][j] =='O') ans=dfs(j,i,0);\n\n  cout<<(ans<INF? ans:-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\nint dx[8] = {1, 1, 1, 0, 0,-1,-1,-1};\nint dy[8] = {1, 0,-1, 1,-1, 1, 0,-1};\nvector<vector<char> > field(21, vector<char>(17, '.'));\nint solve(int sy, int sx){\n    if(sy == 20 || (sy == 19 && 1 <= sx && sx <= 15)){\n        return 0;\n    }\n    if(sy <= 0 || 20 <= sy || sx <= 0 || 16 <= sx){\n        return inf;\n    }\n    int ret = inf;\n    for(int i=0; i<8; i++){\n        int ny = sy +dy[i];\n        int nx = sx +dx[i];\n        if(field[ny][nx] != 'X') continue;\n        while(field[ny][nx] == 'X'){\n            field[ny][nx] = '.';\n            ny += dy[i];\n            nx += dx[i];\n        }\n        ret = min(ret, solve(ny, nx));\n        while(ny != sy || nx != sx){\n            ny -= dy[i];\n            nx -= dx[i];\n            field[ny][nx] = 'X';\n        }\n        field[sy][sx] = '.';\n    }\n    return ret+1;\n}\n\nint main(){\n    int sy, sx;\n    for(int i=1; i<=19; i++){\n        for(int j=1; j<=15; j++){\n            cin >> field[i][j];\n            if(field[i][j] == 'O'){\n                sy = i;\n                sx = j;\n            }\n        }\n    }\n    int ans = solve(sy, sx);\n    if(ans >= inf){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nld eps=1e-9;\n\nint field[19][15];\nstruct aa {\n\tint x;\n\tint y;\n\tbitset<20>bs;\n\tint turn;\n};\nbool operator<(const aa&l, const aa&r) {\n\treturn l.x == r.x ? l.y == r.y ? l.bs.to_ulong() < r.bs.to_ulong() : l.y < r.y : l.x < r.x;\n}bool operator==(const aa&l, const aa&r) {\n\treturn l.x == r.x && l.y == r.y && l.bs.to_ulong();\n}\n\nint dx8[8] = { -1,-1,-1, 0, 1, 1, 1, 0 };\nint dy8[8] = { -1, 0, 1, 1, 1, 0,-1,-1 };\npair<int, int> amove(const int way,const int fx, const int fy, bitset<20>&bs) {\n\tint nx = fx+dx8[way];\n\tint ny = fy + dy8[way];\n\tbool ok = false;\n\twhile (1) {\n\t\tif (ny >= 18 && ok) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nx < 0 || nx >= 15 || ny < 0)return make_pair(-1, -1);\n\t\tif (field[ny][nx] && bs[field[ny][nx] - 1]) {\n\t\t\tbs[field[ny][nx] - 1] = false;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t\tif (ny >= 18&&ok) {\n\t\t\tbreak;\n\t\t}\n\t\tok = true;\n\t\tny += dy8[way];\n\t\tnx += dx8[way];\n\t}\n\tif (!ok) {\n\t\treturn make_pair(-1, -1);\n\t}\n\telse {\n\t\treturn make_pair(nx, ny);\n\t}\n}\n\nint main() {\n\tint num = 1;\n\tint sx = 0, sy = 0;\n\tfor (int i = 0; i < 19; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 0; j < 15; ++j) {\n\t\t\tif (st[j] == 'X') {\n\t\t\t\tfield[i][j] = num;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\telse if (st[j] == 'O') {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t\tsx = j;\n\t\t\t\tsy = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<aa>que;\n\tque.push(aa{ sx,sy,bitset<20>((1 << (num)) - 1),0 });\n\tmap<aa,int>mp;\n\tmp[que.front()]=0;\n\tint ans = -1;\n\twhile (!que.empty()) {\n\t\taa atop(que.front());\n\t\tque.pop();\n\t\tif (atop.y >= 18) {\n\t\t\tans = atop.turn;\n\t\t\tbreak;\n\t\t}\n\t\tfor (int way = 0; way < 8; ++way) {\n\t\t\tbitset<20>bs(atop.bs);\n\t\t\tpair<int, int>p(amove(way, atop.x, atop.y, bs));\n\t\t\tif (p.first != -1) {\n\t\t\t\tif (mp.find(aa{ p.first,p.second,bs, 0 }) == mp.end()) {\n\t\t\t\t\tmp[aa{ p.first,p.second,bs,0 }] = atop.turn + 1;\n\t\t\t\t\tque.push(aa{ p.first,p.second,bs,atop.turn + 1 });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <assert.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\nchar F[20][16];\nint sx, sy;\nunordered_map<int, int> umap;\n\nconstexpr int to_num(int x, int y) {\n  return x+y*16;\n}\n\nstruct state {\n  int x, y, used;\n  state(int x, int y, int used) : x(x), y(y), used(used) {}\n  bool operator == (state const& s) const { return x==s.x && y==s.y && used==s.used; }\n};\n\nstruct state_hash\n{\n  size_t operator()(state const& s) const {\n    return hash<int>()(to_num(s.x, s.y)) ^ hash<int>()(s.used);\n  }\n};\n\n\nconstexpr int dx[8] = {-1, 0, 1, 0,-1, 1, 1,-1};\nconstexpr int dy[8] = {0, -1, 0, 1,-1,-1, 1, 1};\n\nconstexpr bool inrange(int x, int y) {\n  return 0<=x && x<16 && 0<=y && y<20;\n}\n\nbool is_used_xy(int used, int x, int y) {\n  if(umap[to_num(x, y)] == -1) { return false; }\n  return used >> umap[to_num(x, y)] & 1;\n}\n\nvoid debugger(int used, int cx, int cy) {\n  rep(i, 20) {\n    rep(j, 16) {\n      if(cx == j && cy == i) {\n        assert((F[i][j] == 'X' && is_used_xy(used, j, i)) || (F[i][j] == '.') || (F[i][j] == 'G'));\n        cout << 'O';\n      }\n      else {\n        cout << (is_used_xy(used, j, i) ? 'U' : F[i][j]);\n      }\n    }\n    cout << endl;\n  }\n}\n\nint dijkstra() {\n  unordered_map<state, int, state_hash> dist;\n  queue<state> q;\n  q.emplace(sx, sy, 0);\n  dist[state{sx, sy, 0}] = 0;\n  while(!q.empty()) {\n    int const x = q.front().x, y = q.front().y, used = q.front().used;\n    int& cost = dist[state{x,y,used}];\n    q.pop();\n    if(x == -1 && y == 19) { return cost; }\n    if(F[y][x] == 'G') { return cost; }\n    rep(i, 8) {\n      int nx = x+dx[i], ny = y+dy[i];\n      int nused = used;\n      if(!inrange(nx, ny)) { continue; }\n      if(F[ny][nx] != 'X') { continue; }\n      if(is_used_xy(used, nx, ny)) { continue; }\n      bool ng = false;\n      for(;;) {\n        if(!inrange(nx, ny)) { ng = true; break; }\n        if(F[ny][nx] != 'X') { break; }\n        if(is_used_xy(used, nx, ny)) { break; }\n        nused |= 1<<umap[to_num(nx, ny)];\n        nx += dx[i], ny += dy[i];\n      }\n      if(ng && !(nx == -1 && ny == 19)) { continue; }\n      if(inrange(nx, ny) && F[ny][nx] == 'A') { continue; }\n      if(dist.find(state{nx, ny, nused})!=dist.end()) { continue; }\n      dist[state{nx, ny, nused}] = cost+1;\n      q.emplace(nx, ny, nused);\n    }\n  }\n  return -1;\n}\n\nint main() {\n\n  rep(i, 20) rep(j, 16) umap[to_num(j, i)] = -1;\n  int bcnt = 0;\n  rep(i, 19) rep(j, 15) {\n    cin >> F[i][j];\n    if(F[i][j] == 'O') {\n      F[i][j] = '.';\n      sx = j, sy = i;\n    }\n    if(F[i][j] == 'X') {\n      umap[to_num(j,i)] = bcnt++;\n    }\n  }\n\n  rep(i, 20) { F[i][15] = 'A'; }\n  rep(i, 16) {\n    if(i < 15 && F[18][i] != 'X') { F[18][i] = 'G'; }\n    F[19][i] = 'G';\n  }\n\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<queue>\n#include<cassert>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\nconst int N = 20, T = (1<<N), H = 19, W = 15;\n\nset<int> memo[T];\nint board[H][W];\nint stx,sty;\n\nclass Q{\npublic:\n\tint x,y,cnt,state;\n\tQ(int x,int y,int cnt, int state):x(x),y(y),cnt(cnt),state(state){}\n};\n\nvoid input(){\n\tstring a[H];\n\n\trep(i,H)cin>>a[i];\n\tint cnt = 0;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tboard[i][j] = -1;\n\t\t\tif(a[i][j] == 'X'){\n\t\t\t\tboard[i][j] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tif(a[i][j] == 'O'){\n\t\t\t\tstx = j; sty = i;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint zahyo(int x,int y){\n\treturn x + y * W;\n}\n\nbool hasmemo(Q u){\n\treturn memo[u.state].find(zahyo(u.x,u.y)) != memo[u.state].end();\n}\n\nvoid setmemo(Q u){\n\tmemo[u.state].insert(zahyo(u.x,u.y));\n}\n\nbool hasbit(int state, int i){\n\treturn (state&(1<<i))>0;\n}\n\nbool isblack(int x,int y,int state){\n\tint n = board[y][x];\n\tif(n<0)return false;\n\treturn !hasbit(state,n);\n}\n\nbool isout(int x,int y){\n\tif(y<0)return true;\n\tif(y<H){\n\t\tif(x<0 || x>=W)return true;\n\t}\n\treturn false;\n}\n\n\nbool isgoal1(int x,int y){\n\tif(y>=H) return true;\n\treturn false;\n}\n\nbool isgoal2(int x,int y){\n\tif(y==H-1 && (x>=0 && x<=W-1))return true;\n\treturn false;\n}\n\n\nint minblack(int x,int y,int state){\n\tint n = board[y][x];\n\tif(n<0)assert(0);\n\tif(hasbit(state,n))assert(0);\n\n\treturn state + (1<<n);\n}\n\nint solve(){\n\t\n\tqueue<Q> que;\n\tque.push(Q(stx,sty,0,0));\n\n\twhile(!que.empty()){\n\t\tQ u = que.front(); que.pop();\n\t\tif(hasmemo(u))continue;\n\t\tsetmemo(u);\n\n\t\t//printf(\"%d %d\\n\",u.x,u.y);\n\n\t\tint dx[] = {-1,0,1,-1,1,-1,0,1};\n\t\tint dy[] = {-1,-1,-1,0,0,1,1,1};\n\n\t\trep(p,8){\n\t\t\tint st = u.state;\n\t\t\treps(i,1,100){\n\t\t\t\tint nx = u.x + dx[p]*i;\n\t\t\t\tint ny = u.y + dy[p]*i;\n\n\n\t\t\t\tif(i==1){\n\t\t\t\t\tif(isout(nx,ny))break;\n\t\t\t\t\tif(isgoal1(nx,ny))break;\n\t\t\t\t\tif(!isblack(nx,ny,st))break;\n\t\t\t\t}\n\t\t\t\tif(i!=1){\n\t\t\t\t\tif(isout(nx,ny))break;\n\t\t\t\t\tif(isgoal1(nx,ny) || isgoal2(nx,ny))return u.cnt+1;\n\t\t\t\t\tif(!isblack(nx,ny,st)){\n\t\t\t\t\t\tque.push(Q(nx,ny,u.cnt+1,st));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tst = minblack(nx,ny,st);\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tinput();\n\tcout<<solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\nconst int h = 20, w = 15;\nvector<vector<char>> c;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint main(){\n\tc = vector<vector<char>>(h, vector<char>(w,'.'));\n\n\tpair<int, int> s;\n\trep(i,h - 1){\n\t\trep(j,w){\n\t\t\tcin >> c[i][j];\n\t\t\tif(c[i][j] == 'O') s = make_pair(i,j);\n\t\t}\n\t}\n\n\ttypedef tuple<pair<int, int>, vector<vector<char>>, int> T;\n\tqueue<T> q;\n\tq.push(T(s,c,0));\n\n\tint ans = INF;\n\tmap<vector<vector<char>>, vector<vector<int>>> memo;\n\twhile(not q.empty()){\n\t\tint cost;\n\t\ttie(s,c,cost) = q.front(); q.pop();\n\n\t\tint y, x;\n\t\ttie(y,x) = s;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\trep(i,8){\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\t\t\tvector<vector<char>> pc = c;\n\t\t\tif(pc[ny][nx] == 'X'){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(pc[ny][nx] == '.') break;\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tpc[ny][nx] = '.';\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tif(memo.count(pc)){\n\t\t\t\t\tauto& it = memo[pc];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<int>> dis(h, vector<int>(w,INF));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[pc] = dis;\n\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == INF ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nstruct State { int x[19][15]; };\nState S;\nint dx[8] = { 1,1,1,0,-1,-1,-1,0 }, dy[8] = { -1,0,1,1,1,0,-1,-1 };\nint solve(State p) {\n\tint cx = 0, cy = 0;\n\tfor (int i = 0; i < 285; i++) {\n\t\tif (p.x[i / 15][i % 15] == 2) { cx = i / 15; cy = i % 15; }\n\t}\n\tint minx = 999999;\n\tfor (int i = 0; i < 8; i++) {\n\t\tState T = p;\n\t\tint ex = cx, ey = cy;\n\t\tbool flag = true;\n\t\twhile (true) {\n\t\t\tif (ex < 0 || ey < 0 || ey >= 15) { flag = false; }\n\t\t\tex += dx[i]; ey += dy[i];\n\t\t\tif (ex == 19)break;\n\t\t\tif (T.x[ex][ey] == 0)break;\n\t\t\tT.x[ex][ey] = 0;\n\t\t}\n\t\tif (flag == false)continue;\n\n\t\tif (abs(ex - cx) <= 1 && abs(ey - cy) <= 1)continue;\n\t\tif (ex == 18 || ex == 19)minx = min(minx, 1);\n\t\telse {\n\t\t\tT.x[cx][cy] = 0; T.x[ex][ey] = 2;\n\t\t\tminx = min(minx, solve(T) + 1);\n\t\t}\n\t}\n\treturn minx;\n}\nint main() {\n\tfor (int i = 0; i < 19; i++) {\n\t\tfor (int j = 0; j < 15; j++) {\n\t\t\tchar p; cin >> p;\n\t\t\tif (p == 'O')S.x[i][j] = 2;\n\t\t\tif (p == 'X')S.x[i][j] = 1;\n\t\t\tif (p == '.')S.x[i][j] = 0;\n\t\t}\n\t}\n\tint R = solve(S); if (R >= 100000)R = -1;\n\tcout << R << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H=19,W=15;\n\nenum DIR{\n\tLeft_Up,\n\tUp,\n\tRight_Up,\n\tLeft,\n\tRight,\n\tLeft_Down,\n\tDown,\n\tRight_Down,\n};\n\nDIR dir[8] = {Left_Up,Up,Right_Up,Left,Right,Left_Down,Down,Right_Down};\n\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\n\nstruct Info{\n\tchar map[19][15];\n\tint row,col,count;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row <= 17){\n\t\tif(col < 0 || col > 14){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}else{ //row >= 18\n\t\tif(row == 18 && (col < 0 || col > 14)){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\n\nInfo move(Info info,DIR dir){\n\tInfo ret;\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tret.map[i][k] = info.map[i][k];\n\t\t}\n\t}\n\tret.count = info.count+1;\n\n\tint next_row,next_col,index;\n\n\tswitch(dir){\n\tcase Left_Up:\n\t\tindex = 0;\n\t\tbreak;\n\tcase Up:\n\t\tindex = 1;\n\t\tbreak;\n\tcase Right_Up:\n\t\tindex = 2;\n\t\tbreak;\n\tcase Left:\n\t\tindex = 3;\n\t\tbreak;\n\tcase Right:\n\t\tindex = 4;\n\t\tbreak;\n\tcase Left_Down:\n\t\tindex = 5;\n\t\tbreak;\n\tcase Down:\n\t\tindex = 6;\n\t\tbreak;\n\tcase Right_Down:\n\t\tindex = 7;\n\t\tbreak;\n\t}\n\n\tnext_row = info.row+diff_row[index];\n\tnext_col = info.col+diff_col[index];\n\n\twhile(rangeCheck(next_row,next_col) && info.map[next_row][next_col] == 'X'){\n\t\tnext_row += diff_row[index];\n\t\tnext_col += diff_col[index];\n\t}\n\n\n\tif(next_row == info.row+diff_row[index] && next_col == info.col+diff_col[index]){\n\t\tret.row = 1;\n\t\tret.col = -1;\n\t}else{\n\t\tint tmp_row,tmp_col;\n\n\t\ttmp_row = info.row+diff_row[index];\n\t\ttmp_col = info.col+diff_col[index];\n\n\t\twhile(tmp_row != next_row || tmp_col != next_col){\n\t\t\tret.map[tmp_row][tmp_col] = '.';\n\t\t\ttmp_row += diff_row[index];\n\t\t\ttmp_col += diff_col[index];\n\t\t}\n\n\t\tret.row = next_row;\n\t\tret.col = next_col;\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\n\tInfo first;\n\tint minimum = BIG_NUM,start_row,start_col;\n\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",first.map[i]);\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tif(first.map[i][k] == 'O'){\n\t\t\t\tfirst.map[i][k] = '.';\n\t\t\t\tstart_row = i;\n\t\t\t\tstart_col = k;\n\t\t\t}\n\t\t}\n\t}\n\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.count = 0;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().row >= 18){\n\t\t\tminimum = Q.front().count;\n\t\t\tbreak;\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 8; i++){\n\t\t\t\tInfo next = move(Q.front(),dir[i]);\n\n\t\t\t\tif(rangeCheck(next.row,next.col)){\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(minimum == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int h=19;\nconst int w=15;\nconst int INF=30;\n\nint dh[]={0,-1,-1,-1, 0, 1,1,1};\nint dw[]={1, 1, 0,-1,-1,-1,0,1};\nbool isRange(int i,int j){\n    return 0<=i && i<h && 0<=j && j<w;\n}\nint dfs(int nh,int nw,vector<string> &f){\n    if(nh>=h || isRange(nh,nw) && nh==h-1) return 0;\n    if(!isRange(nh,nw)) return INF;\n    int res=INF;\n    for(int i=0;i<8;i++){\n        int toh=nh+dh[i];\n        int tow=nw+dw[i];\n        if(isRange(toh,tow) && f[toh][tow]=='X'){\n            stack<pair<int,int>> st;\n            while(isRange(toh,tow) && f[toh][tow]=='X'){\n                f[toh][tow]='.';\n                st.push({toh,tow});\n                toh+=dh[i];\n                tow+=dw[i];\n            }\n            res=min(res,dfs(toh,tow,f)+1);\n            while(!st.empty()){\n                auto ret=st.top(); st.pop();\n                f[ret.first][ret.second]='X';\n            }\n        }\n    }\n    return res;\n}\nint main(){\n    vector<string> f(h);\n    for(int i=0;i<h;i++) cin>>f[i];\n    int inih=-1,iniw=-1;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(f[i][j]=='O'){\n                inih=i,iniw=j;\n                f[i][j]='.';\n            }\n        }\n    }\n    \n    int res=dfs(inih,iniw,f);\n    cout<<(res>=INF ? -1 : res)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst char h = 20, w = 17;\nvector<vector<bool>> c;\ntypedef tuple<pair<char, char>, vector<vector<bool>>, char> T;\nqueue<T> q;\nmap<vector<vector<bool>>, vector<vector<char>>> memo;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nbool impossible(int y, vector<vector<bool>>& c){\n\tvector<bool> no(h,0);\n\trange(i,y + 1,18){\n\t\tbool f = false;\n\t\trep(j,w){\n\t\t\tif(c[i][j]) f = true;\n\t\t}\n\t\tif(not f) no[i] = true;\n\t}\n\trep(i,h - 1){\n\t\tif(no[i] and no[i + 1]) return false;\n\t}\n\treturn false;\n}\n\nint main(){\n\tc = vector<vector<bool>>(h, vector<bool>(w,0));\n\n\tpair<char, char> s;\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tchar a;\n\t\t\tcin >> a;\n\t\t\tif(a == 'X') c[i][j + 1] = 1;\n\t\t\telse c[i][j + 1] = 0;\n\t\t\tif(a == 'O'){\n\t\t\t\ts = make_pair(i,j + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tq.push(T(s,c,0));\n\n\tchar ans = 127;\n\twhile(not q.empty()){\n\t\tchar cost;\n\t\ttie(s,c,cost) = q.front(); q.pop();\n\n\t\tchar y, x;\n\t\ttie(y,x) = s;\n\n\t\t//rep(i,h){ rep(j,w){ if(i == y and j == x) cout << 'O'; else cout << c[i][j]; } cout << endl; } cout << endl;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(impossible(y, c)) continue;\n\n\t\tif(cost >= 20) continue;\n\n\t\trep(i,8){\n\t\t\tchar ny = y + dy[i];\n\t\t\tchar nx = x + dx[i];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)) continue;\n\t\t\tvector<vector<bool>> pc = c;\n\t\t\tif(pc[ny][nx] == 1){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pc[ny][nx] == 0) break;\n\t\t\t\t\tpc[ny][nx] = 0;\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tif(memo.count(pc)){\n\t\t\t\t\tauto& it = memo[pc];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<char>> dis(h, vector<char>(w,127));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[pc] = dis;\n\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == 127 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define H 19\n#define W 15\n \nstruct State{\n    int x,y,S;\n    State(int x,int y,int S) : x(x),y(y),S(S) {}\n   \n    bool operator < (const State &s)const{\n\tif(x != s.x){\n\t    return x < s.x;\n\t}else if(y != s.y){\n\t    return y < s.y;\n\t}else{\n\t    return S < s.S;\n\t}\n    }\n};\n \nint num[H][W];\nchar field[H][W];\nmap<State,int> step;\nconst int dx[8] = {-1,-1,-1,0,0,1,1,1};\nconst int dy[8] = {-1,0,1,-1,1,-1,0,1};\n \ninline bool inH(int y){\n    return (0 <= y && y < H);\n}\n \ninline bool inW(int x){\n    return (0 <= x && x < W);\n}\n \ninline bool inField(int x,int y){\n    return (inH(y) && inW(x));\n}\n \nint bfs(int sx,int sy){\n    queue<State> Q;\n    Q.push(State(sx,sy,0));\n    step[State(sx,sy,0)] = 0;\n \n    while(!Q.empty()){\n\tState s = Q.front(); Q.pop();\n\tint x = s.x,y = s.y,S = s.S;\n\tif(y >= H){\n\t    return step[s];\n\t}\n\tfor(int i = 0 ; i < 8 ; i++){\n\t    int nx = x+dx[i], ny = y+dy[i], nS = S;\n\t    if(!inField(nx,ny)) continue;\n\t    if(field[ny][nx] != 'X') continue;\n\t    if(num[ny][nx] >= 0 && !(S >> num[ny][nx] & 1)){\n\t\tbool can = true;\n\t\tnS |= (1<<num[ny][nx]);\n\t\twhile(true){\n\t\t    nx += dx[i]; ny += dy[i];\n\t\t    if(ny >= H || (ny == H-1 && inW(nx))){\n\t\t\treturn step[s]+1;\n\t\t    }\n\t\t    if(!inW(nx) || ny < 0){ can = false; break; }\n\t\t    if(field[ny][nx] != 'X') break; \n\t\t    if(nS >> num[ny][nx] & 1) break; \n\t\t    nS |= (1<<num[ny][nx]);\n\t\t}\n\t\tif(can && step.find(State(nx,ny,nS)) == step.end()){\n\t\t    step[State(nx,ny,nS)] = step[s]+1;\n\t\t    Q.push(State(nx,ny,nS));\n\t\t}\n\t    }\n\t}\n    }\n    return -1;\n}\n \nint main(){\n    int x,y,n = 0;\n    memset(num,-1,sizeof(num));\n    for(int i = 0 ; i < H ; i++){\n\tfor(int j = 0 ; j < W ; j++){\n\t    cin >> field[i][j];\n\t    if(field[i][j] == 'O'){\n\t\tx = j; y = i;\n\t    }else if(field[i][j] == 'X'){\n\t\tnum[i][j] = n++;\n\t    }\n\t}\n    }\n    cout << bfs(x,y) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\nint dx[8] = {1, 1, 1, 0, 0,-1,-1,-1};\nint dy[8] = {1, 0,-1, 1,-1, 1, 0,-1};\nvector<vector<char> > field(21, vector<char>(17, '.'));\nint solve(int sy, int sx){\n    if(sy >= 19){\n        return 0;\n    }\n    if(sy <= 0 || 20 <= sy || sx <= 0 || 16 <= sx){\n        return inf;\n    }\n    int ret = inf;\n    for(int i=0; i<8; i++){\n        int ny = sy +dy[i];\n        int nx = sx +dx[i];\n        if(field[ny][nx] != 'X') continue;\n        while(field[ny][nx] == 'X'){\n            field[ny][nx] = '.';\n            ny += dy[i];\n            nx += dx[i];\n        }\n        field[sy][sx] = '.';\n        field[ny][nx] = 'O';\n        ret = min(ret, solve(ny, nx));      \n        while(ny != sy && nx != sx){\n            field[ny][nx] = 'X';\n            ny -= dy[i];\n            nx -= dx[i];\n        }\n        field[ny][nx] = '.';\n        field[sy][sx] = 'O';\n    }\n    return ret+1;\n}\n\nint main(){\n    int sy, sx;\n    for(int i=1; i<=19; i++){\n        for(int j=1; j<=15; j++){\n            cin >> field[i][j];\n            if(field[i][j] == 'O'){\n                sy = i;\n                sx = j;\n            }\n        }\n    }\n    int ans = solve(sy, sx);\n    if(ans >= inf){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <assert.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\n\nchar F[20][16];\nint sx, sy;\nunordered_map<int, int> umap;\n\nconstexpr int to_num(int x, int y) {\n  return x+y*16;\n}\n\nstruct state {\n  int x, y, used;\n  state(int x, int y, int used) : x(x), y(y), used(used) {}\n  bool operator == (state const& s) const { return x==s.x && y==s.y && used==s.used; }\n};\n\nstruct state_hash\n{\n  size_t operator()(state const& s) const {\n    return hash<int>()(to_num(s.x, s.y)) ^ hash<int>()(s.used);\n  }\n};\n\n\nconstexpr int dx[8] = {-1, 0, 1, 0,-1, 1, 1,-1};\nconstexpr int dy[8] = {0, -1, 0, 1,-1,-1, 1, 1};\n\nconstexpr bool inrange(int x, int y) {\n  return 0<=x && x<16 && 0<=y && y<20;\n}\n\nbool is_used_xy(int used, int x, int y) {\n  if(umap[to_num(x, y)] == -1) { return false; }\n  return used >> umap[to_num(x, y)] & 1;\n}\n\nint dijkstra() {\n  unordered_map<state, int, state_hash> dist;\n  queue<state> q;\n  q.emplace(sx, sy, 0);\n  dist[{sx, sy, 0}] = 0;\n  while(!q.empty()) {\n    int const x = q.front().x, y = q.front().y, used = q.front().used;\n    int& cost = dist[{x,y,used}];\n    q.pop();\n    if(x == -1 && y == 19) { return cost; }\n    if(F[y][x] == 'G') { return cost; }\n    rep(i, 8) {\n      int nx = x+dx[i], ny = y+dy[i];\n      int nused = used;\n      if(!inrange(nx, ny)) { continue; }\n      if(F[ny][nx] != 'X') { continue; }\n      if(is_used_xy(used, nx, ny)) { continue; }\n      bool ng = false;\n      for(;;) {\n        if(!inrange(nx, ny)) { ng = true; break; }\n        if(F[ny][nx] != 'X') { break; }\n        if(is_used_xy(used, nx, ny)) { break; }\n        nused |= 1<<umap[to_num(nx, ny)];\n        nx += dx[i], ny += dy[i];\n      }\n      if(ng && !(nx == -1 && ny == 19)) { continue; }\n      if(inrange(nx, ny) && F[ny][nx] == 'A') { continue; }\n      if(dist.find({nx, ny, nused})!=dist.end()) { continue; }\n      dist[{nx, ny, nused}] = cost+1;\n      q.emplace(nx, ny, nused);\n    }\n  }\n  return -1;\n}\n\nint main() {\n\n  rep(i, 20) rep(j, 16) umap[to_num(j, i)] = -1;\n  int bcnt = 0;\n  rep(i, 19) rep(j, 15) {\n    cin >> F[i][j];\n    if(F[i][j] == 'O') {\n      F[i][j] = '.';\n      sx = j, sy = i;\n    }\n    if(F[i][j] == 'X') {\n      umap[to_num(j,i)] = bcnt++;\n    }\n  }\n\n  rep(i, 20) { F[i][15] = 'A'; }\n  rep(i, 16) {\n    if(i < 15 && F[18][i] != 'X') { F[18][i] = 'G'; }\n    F[19][i] = 'G';\n  }\n\n  cout << dijkstra() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n#include <utility>\n#include <iostream>\n\nusing namespace std;\n\nconst int dx[8] = { 0, 1, 1, 1, 0, -1, -1, -1 };\nconst int dy[8] = { 1, 1, 0, -1, -1, -1, 0, 1 };\n\nint BFS(vector<string> v)\n{\n\tmap<vector<string>, int> d; d[v] = 1;\n\n\tqueue<pair<vector<string>, int> > que; que.push(make_pair(v, 1));\n\n\tfor (int i = 0; i < 15; i++)\n\t{\n\t\tif (v[18][i] == 'O')\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\twhile (!que.empty())\n\t{\n\t\tvector<string> v1 = que.front().first;\n\n\t\tint dist = que.front().second; que.pop();\n\n\t\tint sx = -1, sy = -1;\n\n\t\tfor (int i = 0; i < 19; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < 15; j++)\n\t\t\t{\n\t\t\t\tif (v1[i][j] == 'O')\n\t\t\t\t{\n\t\t\t\t\tsx = j; sy = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int dir = 0; dir < 8; dir++)\n\t\t{\n\t\t\tif (0 <= sx + dx[dir] && sx + dx[dir] < 15 && 0 <= sy + dy[dir] && sy + dy[dir] < 19)\n\t\t\t{\n\t\t\t\tif (v1[sy + dy[dir]][sx + dx[dir]] == 'X')\n\t\t\t\t{\n\t\t\t\t\tint x = sx + dx[dir] * 2;\n\t\t\t\t\tint y = sy + dy[dir] * 2;\n\n\t\t\t\t\twhile (true)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (y > 17) { return dist; }\n\n\t\t\t\t\t\tif (x < 0 || 15 <= x || y < 0) { break; }\n\n\t\t\t\t\t\tif (v1[y][x] == '.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvector<string> v2 = v1;\n\n\t\t\t\t\t\t\tint rx = sx, ry = sy;\n\n\t\t\t\t\t\t\tfor (; x != rx || y != ry;)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tv2[ry][rx] = '.';\n\n\t\t\t\t\t\t\t\trx += dx[dir];\n\t\t\t\t\t\t\t\try += dy[dir];\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tv2[y][x] = 'O';\n\n\t\t\t\t\t\t\tif (d[v2] == 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\td[v2] = dist + 1;\n\n\t\t\t\t\t\t\t\tque.push(make_pair(v2, dist + 1));\n\n\t\t\t\t\t\t\t\tgoto Exit;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tx += dx[dir];\n\t\t\t\t\t\ty += dy[dir];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tExit:;\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nint main()\n{\n\tvector<string> v(19);\n\n\tfor (int i = 0; i < 19; i++) { cin >> v[i]; }\n\n\tcout << BFS(v) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst char h = 20, w = 17;\nvector<vector<bool>> c;\ntypedef tuple<char, pair<char, char>, vector<vector<bool>>> T;\n//queue<T> q;\npriority_queue<T, vector<T>, greater<T>> q;\nmap<vector<vector<bool>>, vector<vector<char>>> memo;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nbool impossible(int y, vector<vector<bool>>& c){\n\tvector<bool> no(h,0);\n\trange(i,y + 1,18){\n\t\tbool f = false;\n\t\trep(j,w){\n\t\t\tif(c[i][j]) f = true;\n\t\t}\n\t\tif(not f) no[i] = true;\n\t}\n\trep(i,h - 1){\n\t\tif(no[i] and no[i + 1]) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tc = vector<vector<bool>>(h, vector<bool>(w,0));\n\n\tpair<char, char> s;\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tchar a;\n\t\t\tcin >> a;\n\t\t\tif(a == 'X') c[i][j + 1] = 1;\n\t\t\telse c[i][j + 1] = 0;\n\t\t\tif(a == 'O'){\n\t\t\t\ts = make_pair(i,j + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tq.push(T(0,s,c));\n\n\tchar ans = 127;\n\twhile(not q.empty()){\n\t\tchar cost;\n\t\ttie(cost,s,c) = q.top(); q.pop();\n\n\t\tchar y, x;\n\t\ttie(y,x) = s;\n\n\t\t//rep(i,h){ rep(j,w){ if(i == y and j == x) cout << 'O'; else cout << c[i][j]; } cout << endl; } cout << endl;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(impossible(y, c)) continue;\n\n\t\tif(cost >= 20) continue;\n\n\t\trep(i,8){\n\t\t\tchar ny = y + dy[i];\n\t\t\tchar nx = x + dx[i];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)) continue;\n\t\t\tvector<vector<bool>> pc = c;\n\t\t\tif(pc[ny][nx] == 1){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pc[ny][nx] == 0) break;\n\t\t\t\t\tpc[ny][nx] = 0;\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tif(memo.count(pc)){\n\t\t\t\t\tauto& it = memo[pc];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(cost + 1, make_pair(ny,nx), pc));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<char>> dis(h, vector<char>(w,127));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[pc] = dis;\n\t\t\t\t\tq.push(T(cost + 1, make_pair(ny,nx), pc));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == 127 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int w = 15, h = 19;\n\ntypedef pair<int, pair<int, pii>> State;\n#define F first\n#define S second\n\nint dx[] = { 1, 1, 0,-1,-1,-1, 0, 1};\nint dy[] = { 0, 1, 1, 1, 0,-1,-1,-1};\n\nint main(void){\n    vs origin_field(h + 2);\n\n    rep(x, w + 2) origin_field[0].pb('#'), origin_field[h + 1].pb('@');\n\n    pii s;\n    map<pii, int> stone_id;\n    int cnt_id = 0;\n\n    range(y, 1, h + 1){\n        cin >> origin_field[y];\n        origin_field[y] = \"#\" + origin_field[y] + \"#\";\n\n        if(y == h) range(x, 1, w + 1) if(origin_field[y][x] == '.') origin_field[y][x] = '@';\n        rep(x, w + 2){\n            if(origin_field[y][x] == 'O') s = mp(y, x), origin_field[y][x] = '.';\n            if(origin_field[y][x] == 'X'){\n                stone_id[mp(y, x)] = cnt_id++;\n            }\n        }\n    }\n\n    queue<State> q;\n    q.push(mp(0, mp(0, s)));\n\n    int res = -1;\n    while(!q.empty()){\n        int cur_stones = q.front().F; \n        pii cur_pos = q.front().S.S;\n        int cur_turn = q.front().S.F; q.pop();\n\n        vs cur_field = origin_field;\n        rep(y, h + 2) rep(x, w + 2){\n            if(origin_field[y][x] == 'X'){\n                int id = stone_id[mp(y, x)];\n\n                if((cur_stones >> id) & 1) cur_field[y][x] = '.';\n            }\n        }\n\n        if(cur_field[cur_pos.F][cur_pos.S] == '@'){\n            res = cur_turn;\n            break;\n        }\n\n        rep(i, 8){\n            int next_stones = cur_stones;\n            pii next_pos = cur_pos;\n            int next_turn = cur_turn + 1;\n         \n            while(cur_field[next_pos.F + dy[i]][next_pos.S + dx[i]] == 'X'){\n                next_pos.F += dy[i];\n                next_pos.S += dx[i];\n\n                int id = stone_id[next_pos];\n                next_stones |= (1 << id);\n            }\n\n            if(cur_pos == next_pos || cur_field[next_pos.F += dy[i]][next_pos.S += dx[i]] == '#') continue;\n\n            State next = mp(next_stones, mp(next_turn, next_pos));\n            q.push(next);\n        }\n    }\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#define r(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>P2;\n\nstring s[21];\nint h=21,w=17,sx,sy;\nint dx[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={-1,-1,0,1,1,1,0,-1};\nint d[21][19][1<<20];\n\nmap<pair<int,int>,int>M1;\nmap<int,pair<int,int> >M2;\nint cnt;\n\nint main(){\n  s[0]=s[20]=\".................\";\n  r(i,h-2){\n    cin>>s[i+1];\n    s[i+1]=\".\"+s[i+1]+\".\";\n  }\n  r(i,h)r(j,w)if(s[i][j]=='O'){\n    sx=j;\n    sy=i;\n    s[i][j]='.';\n  }else if(s[i][j]=='X'){\n    M2[cnt]=P(i,j);\n    M1[P(i,j)]=cnt++;\n  }\n  queue<P2>q;\n  memset(d,-1,sizeof(d));\n  d[sy][sx][0]=0;\n  q.push(P2(P(sy*1000+sx,0),0));\n  while(!q.empty()){\n    P2 p=q.front();q.pop();\n    int y=p.first.first/1000;\n    int x=p.first.first%1000;\n    int cost=p.first.second;\n    int bit=p.second;\n    r(i,8){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      int b=bit;\n      if(ny<0||nx<0||ny>=h||nx>=w)continue;\n      if(s[ny][nx]=='.')continue;\n      if((1<<M1[P(ny,nx)])&b)continue;\n      while(s[ny][nx]=='X'){\n\tint c=M1[P(ny,nx)];\n\tif((1<<c)&b)break;\n\tb|=(1<<c);\n\tny+=dy[i];\n\tnx+=dx[i];\n      }\n      if(d[ny][nx][b]!=-1)continue;\n      d[ny][nx][b]=cost+1;\n      q.push(P2(P(ny*1000+nx,cost+1),b));\n      if(ny==20){\n\tcout<<b<<endl;\n\tcout<<cost+1<<endl;\n\treturn 0;\n      }\n    }\n  }\n  cout<<-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nconst int w = 15, h = 19;\n\ntypedef pair<int, pair<int, pii>> State;\n#define F first\n#define S second\n\nint dx[] = { 1, 1, 0,-1,-1,-1, 0, 1};\nint dy[] = { 0, 1, 1, 1, 0,-1,-1,-1};\n\nint main(void){\n    vs field(h + 2);\n\n    rep(x, w + 2) field[0].pb('#'), field[h + 1].pb('@');\n\n    pii s;\n    map<pii, int> stone_id;\n    int cnt_id = 0;\n\n    range(y, 1, h + 1){\n        cin >> field[y];\n        field[y] = \"#\" + field[y] + \"#\";\n\n        if(y == h) range(x, 1, w + 1) if(field[y][x] == '.') field[y][x] = '@';\n        rep(x, w + 2){\n            if(field[y][x] == 'O') s = mp(y, x), field[y][x] = '.';\n            if(field[y][x] == 'X'){\n                stone_id[mp(y, x)] = cnt_id++;\n            }\n        }\n    }\n\n    queue<State> q;\n    q.push(mp(0, mp(0, s)));\n\n    int res = -1;\n    while(!q.empty()){\n        int cur_stones = q.front().F; \n        pii cur_pos = q.front().S.S;\n        int cur_turn = q.front().S.F; q.pop();\n\n        if(field[cur_pos.F][cur_pos.S] == '@'){\n            res = cur_turn;\n            break;\n        }\n\n        rep(i, 8){\n            int next_stones = cur_stones;\n            pii next_pos = cur_pos;\n            int next_turn = cur_turn + 1;\n         \n            while( field[next_pos.F + dy[i]][next_pos.S + dx[i]] == 'X' &&\n                 !((next_stones >> stone_id[mp(next_pos.F + dy[i], next_pos.S + dx[i])]) & 1)){\n                next_pos.F += dy[i];\n                next_pos.S += dx[i];\n\n                int id = stone_id[next_pos];\n                next_stones |= (1 << id);\n            }\n\n            if(cur_pos == next_pos || field[next_pos.F += dy[i]][next_pos.S += dx[i]] == '#') continue;\n\n            State next = mp(next_stones, mp(next_turn, next_pos));\n            q.push(next);\n        }\n    }\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 19\n#define M 15\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nint sy,sx,cnt;\nmap<P1,int> memo;\nmap<P,int> num;\nstring s[N];\nint dy[8]={-1,-1,-1,0,0,1,1,1};\nint dx[8]={-1,0,1,-1,1,-1,0,1};\n\nint dfs(int A,int y,int x){\n  if(memo.count(P1(A,P(y,x))))return memo[P1(A,P(y,x))];\n  if((N-1==y&&0<=x&&x<M)||N<=y)return 1;\n  if(y<0||x<0||N<=y||M<=x)return INF;\n  int res=INF;\n  for(int i=0;i<8;i++){\n    int ny=y+dy[i],nx=x+dx[i],nA=A;\n    if(ny<0||nx<0||N<=ny||M<=nx||s[ny][nx]!='X')continue;\n    while(0<=ny&&ny<N&&0<=nx&&nx<M&&s[ny][nx]=='X'){\n      nA|=(1<<num[P(ny,nx)]);\n      s[ny][nx]='.';\n      ny+=dy[i]; nx+=dx[i];\n    }\n    res=min(res,dfs(nA,ny,nx));\n    while(ny!=y||nx!=x){\n      ny-=dy[i]; nx-=dx[i];\n      s[ny][nx]='X';\n    }\n    s[y][x]='.';\n  }\n  return memo[P1(A,P(y,x))]=res+1;\n}\n\nint main(){\n  for(int i=0;i<N;i++){\n    cin>>s[i];\n    for(int j=0;j<M;j++){\n      if(s[i][j]=='O'){\n\tsy=i,sx=j;\n\ts[i][j]='.';\n      }\n      if(s[i][j]=='X')\n\tnum[P(i,j)]=cnt++;\n    }\n  }\n  int ans=dfs(0,sy,sx);\n  cout<<(ans>=INF?-1:ans-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<map>\nusing namespace std;\nint dx[8]={0,1,0,-1,1,1,-1,-1};\nint dy[8]={1,0,-1,0,1,-1,1,-1};\nmain()\n{\n\tmap<string,int>M;\n\tqueue<string>P;\n\tstring start=\"\";\n\tfor(int i=0;i<19;i++)\n\t{\n\t\tstring s;cin>>s;\n\t\tstart+=s;\n\t}\n\tM[start]=0;\n\tP.push(start);\n\twhile(!P.empty())\n\t{\n\t\tstring now=P.front();P.pop();\n\t\tint cost=M[now];\n\t\tint nx,ny;\n\t\tfor(int i=0;i<now.size();i++)\n\t\t{\n\t\t\tif(now[i]=='O')\n\t\t\t{\n\t\t\t\tnx=i/15;\n\t\t\t\tny=i%15;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int r=0;r<8;r++)\n\t\t{\n\t\t\tint tx=nx+dx[r],ty=ny+dy[r];\n\t\t\tif(tx<0||ty<0||tx>=19||ty>=15||now[tx*15+ty]!='X')continue;\n\t\t\tstring nxt=now;\n\t\t\twhile(0<=tx&&tx<19&&0<=ty&&ty<15&&nxt[tx*15+ty]=='X')\n\t\t\t{\n\t\t\t\tnxt[tx*15+ty]='.';\n\t\t\t\ttx+=dx[r];\n\t\t\t\tty+=dy[r];\n\t\t\t}\n\t\t\tif(tx>=19||tx==18&&0<=ty&&ty<15)\n\t\t\t{\n\t\t\t\tcout<<cost+1<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse if(0<=tx&&tx<19&&0<=ty&&ty<15)\n\t\t\t{\n\t\t\t\tnxt[nx*15+ny]='.';\n\t\t\t\tnxt[tx*15+ty]='O';\n\t\t\t\tif(M.find(nxt)==M.end())\n\t\t\t\t{\n\t\t\t\t\tM[nxt]=cost+1;\n\t\t\t\t\tP.push(nxt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<-1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H=19,W=15;\n\nenum DIR{\n\tLeft_Up,\n\tUp,\n\tRight_Up,\n\tLeft,\n\tRight,\n\tLeft_Down,\n\tDown,\n\tRight_Down,\n};\n\nDIR dir[8] = {Left_Up,Up,Right_Up,Left,Right,Left_Down,Down,Right_Down};\n\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\n\nstruct BlackStone{\n\tBlackStone(){\n\t\trow = col = 0;\n\t}\n\n\tBlackStone(short arg_row,short arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tshort row,col;\n};\n\nstruct Info{\n\tvector<BlackStone> BLACK_STONE;\n\tshort row,col,count;\n};\n\nbool rangeCheck(short row,short col){\n\tif(row <= 17){\n\t\tif(col < 0 || col > 14){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}else{ //row >= 18\n\t\tif(row == 18 && (col < 0 || col > 14)){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\nInfo move(Info info,DIR dir){\n\tInfo ret;\n\n\tchar map[19][15];\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)map[i][k] = '.';\n\t}\n\n\tfor(int i = 0; i < info.BLACK_STONE.size(); i++){\n\t\tmap[info.BLACK_STONE[i].row][info.BLACK_STONE[i].col] = 'X';\n\t\tBlackStone new_stone;\n\t\tnew_stone.row = info.BLACK_STONE[i].row;\n\t\tnew_stone.col = info.BLACK_STONE[i].col;\n\t\tret.BLACK_STONE.push_back(new_stone);\n\t}\n\tret.count = info.count+1;\n\n\tint next_row,next_col,index;\n\n\tswitch(dir){\n\tcase Left_Up:\n\t\tindex = 0;\n\t\tbreak;\n\tcase Up:\n\t\tindex = 1;\n\t\tbreak;\n\tcase Right_Up:\n\t\tindex = 2;\n\t\tbreak;\n\tcase Left:\n\t\tindex = 3;\n\t\tbreak;\n\tcase Right:\n\t\tindex = 4;\n\t\tbreak;\n\tcase Left_Down:\n\t\tindex = 5;\n\t\tbreak;\n\tcase Down:\n\t\tindex = 6;\n\t\tbreak;\n\tcase Right_Down:\n\t\tindex = 7;\n\t\tbreak;\n\t}\n\n\tnext_row = info.row+diff_row[index];\n\tnext_col = info.col+diff_col[index];\n\n\twhile(rangeCheck(next_row,next_col) == true && map[next_row][next_col] == 'X'){\n\t\tnext_row += diff_row[index];\n\t\tnext_col += diff_col[index];\n\t}\n\n\n\tif(next_row == info.row+diff_row[index] && next_col == info.col+diff_col[index]){\n\t\tret.row = 1;\n\t\tret.col = -1;\n\t}else{\n\n\t\tif(rangeCheck(next_row,next_col) == true && next_row <= 18){ //?§?????????????????????§????????´????????§????????´???\n\n\t\t\tint tmp_row,tmp_col;\n\n\t\t\ttmp_row = info.row+diff_row[index];\n\t\t\ttmp_col = info.col+diff_col[index];\n\n\t\t\twhile(tmp_row != next_row || tmp_col != next_col){\n\t\t\t\tfor(int i = 0; i < ret.BLACK_STONE.size();i++){\n\t\t\t\t\tif(ret.BLACK_STONE[i].row == tmp_row && ret.BLACK_STONE[i].col == tmp_col){\n\t\t\t\t\t\tret.BLACK_STONE.erase(ret.BLACK_STONE.begin()+i);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp_row += diff_row[index];\n\t\t\t\ttmp_col += diff_col[index];\n\t\t\t}\n\t\t}\n\n\t\tret.row = next_row;\n\t\tret.col = next_col;\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\n\tInfo first;\n\n\tchar buf[15];\n\tint minimum = BIG_NUM,start_row,start_col;\n\n\tfor(short i = 0; i < H; i++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(short k = 0; k < W; k++){\n\t\t\tif(buf[k] == 'O'){\n\t\t\t\tstart_row = i;\n\t\t\t\tstart_col = k;\n\t\t\t}else if(buf[k] == 'X'){\n\t\t\t\tfirst.BLACK_STONE.push_back(BlackStone(i,k));\n\t\t\t}\n\t\t}\n\t}\n\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.count = 0;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().row >= 18){\n\t\t\tminimum = Q.front().count;\n\t\t\tbreak;\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 8; i++){\n\t\t\t\tInfo next = move(Q.front(),dir[i]);\n\n\t\t\t\tif(rangeCheck(next.row,next.col)){\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(minimum == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>P2;\n\nstring s[21];\nint h=21,w=17,sx,sy;\nint dx[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={-1,-1,0,1,1,1,0,-1};\nbool d[21][19][1<<20];\n\nmap<pair<int,int>,int>M1;\nmap<int,pair<int,int> >M2;\nint cnt;\n\nint main(){\n  s[0]=s[20]=\".................\";\n  r(i,h-2){\n    cin>>s[i+1];\n    s[i+1]=\".\"+s[i+1]+\".\";\n  }\n  r(i,h)r(j,w)if(s[i][j]=='O'){\n    sx=j;\n    sy=i;\n    s[i][j]='.';\n  }else if(s[i][j]=='X'){\n    M2[cnt]=P(i,j);\n    M1[P(i,j)]=cnt++;\n  }\n  queue<P2>q;\n  d[sy][sx][0]=1;\n  q.push(P2(P(sy*1000+sx,0),0));\n  while(!q.empty()){\n    P2 p=q.front();q.pop();\n    int y=p.first.first/1000;\n    int x=p.first.first%1000;\n    int cost=p.first.second;\n    int bit=p.second;\n    r(i,8){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      int b=bit;\n      if(ny<=0||nx<=0||ny>=h||nx>=w-1)continue;\n      if(s[ny][nx]=='.')continue;\n      if((1<<M1[P(ny,nx)])&b)continue;\n      while(s[ny][nx]=='X'){\n\tint c=M1[P(ny,nx)];\n\tif((1<<c)&b)break;\n\tb+=(1<<c);\n\tny+=dy[i];\n\tnx+=dx[i];\n      \n      if(ny<19&&(nx==0||nx==w-1))continue;\n      if(d[ny][nx][b]==1)continue;\n      d[ny][nx][b]=1;\n      q.push(P2(P(ny*1000+nx,cost+1),b));\n      if(ny>=19){\n\tcout<<cost+1<<endl;\n\treturn 0;\n      }\n    }\n  }\n  cout<<-1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\nusing namespace std;\n\n#define H 19\n#define W 15\nbool banmen[H+1][W];\nint dirs[8][2];\n\nint solve(int x, int y, int te) {\n  //printf(\"%d,%d,%d\\n\",x,y,te);\n  if(y>=H-1) return te;\n  int ans = 9999;\n  for(int dir_index = 0; dir_index < 8; dir_index++) {\n    int dx = dirs[dir_index][0];\n    int dy = dirs[dir_index][1];\n    int count = 0;\n    int ax = x+dx;\n    int ay = y+dy;\n    //printf(\"(%d,%d,%d,%d,%d)\\n\",ax>0,ax+dx<W,ay>0,ay+dy<=H,banmen[ax][ay]);\n    while(((ay+dy==H&&ax>=0&&ax<W&&ax+dx>=-1&&ax+dx<=W)||(ay+dy!=H&&ax>=0&&ax<W&&ax+dx>=-1&&ax+dx<=W))&&ay>0&&ay<H&&ay+dy>=0&&ay+dy<=H && banmen[ay][ax]) {\n      banmen[ay][ax] = false;\n      ax+=dx;\n      ay+=dy;\n      count++;\n    }\n    //printf(\"(x,y,c)=(%d,%d,%d)\\n\",dx,dy,count);\n    if(count>0 && (ay>=H||(ax>=0&&ax<W))) {\n      int ret = solve(ax,ay,te+1);\n      if(ret!=-1) {\n        ans = min(ans,ret);\n      }\n    }\n    for(int i = 1; i <= count; i++) {\n      banmen[y+dy*i][x+dx*i] = true;\n    }\n  }\n  return (ans==9999)?-1:ans;\n}\n\nint main() {\n  int x,y;\n  for(int i = 0; i < H; i++) {\n    char row[W+1];\n    scanf(\"%s\",row);\n    for(int j = 0; j < W; j++) {\n      banmen[i][j] = (row[j]=='X');\n      if(row[j]=='O') {\n        y = i;\n        x = j;\n      }\n    }\n  }\n  /*\n  for(int i = 0; i < H+1; i++) {\n    for(int j = 0; j < W; j++) {\n      printf(\"%d \",banmen[i][j]);\n    }\n    printf(\"\\n\");\n  }\n  */\n  for(int j = 0; j < W; j++) {\n    banmen[H][j] = false;\n  }\n\n  dirs[0][0] = 1;\n  dirs[0][1] = 1;\n  dirs[1][0] = 1;\n  dirs[1][1] = 0;\n  dirs[2][0] = 1;\n  dirs[2][1] = -1;\n  dirs[3][0] = 0;\n  dirs[3][1] = -1;\n  dirs[4][0] = -1;\n  dirs[4][1] = -1;\n  dirs[5][0] = -1;\n  dirs[5][1] = 0;\n  dirs[6][0] = -1;\n  dirs[6][1] = 1;\n  dirs[7][0] = 0;\n  dirs[7][1] = 1;\n\n  printf(\"%d\\n\",solve(x,y,0));\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct S {\n\tint x, y, mask;\n\tll hash() {\n\t\treturn (ll)x + 15 * (ll)y + (ll)mask * (20 * 20);\n\t}\n};\n\nint b[19][15];\n\nint dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 };\nint dy[8] = { 0, 1, 0, -1, 1, -1, 1, -1 };\n\nbool in(int x, int y) {\n\treturn 0 <= x && x < 15 && 0 <= y && y < 19;\n}\n\nmap<ll, int> dp;\n\nint main() {\n\tint B = 0;\n\tint sx = -1, sy = -1;\n\n\tmemset(b, -1, sizeof b);\n\tfor(int i = 0; i < 19; i++) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tfor(int j = 0; j < 15; j++) {\n\t\t\tif(s[j] == 'O') sx = j, sy = i;\n\t\t\tif(s[j] == 'X') {\n\t\t\t\tb[i][j] = B++;\n\t\t\t}\n\t\t}\n\t}\n\n\tS is = { sx, sy, 0 };\n\tdp[is.hash()] = 0;\n\n\tqueue<S> q;\n\tq.push(is);\n\twhile(q.size()) {\n\t\tint x = q.front().x, y = q.front().y, mask = q.front().mask;\n\t\tint t = dp[q.front().hash()];\n\t\tq.pop();\n\t\tfor(int k = 0; k < 8; k++) {\n\t\t\tint nx = x + dx[k], ny = y + dy[k];\n\t\t\tif(!in(nx, ny)) continue;\n\t\t\tint id = b[ny][nx];\n\t\t\tif(id == -1) continue;\n\t\t\tif(mask >> id & 1) continue;\n\t\t\tint nmask = mask;\n\t\t\twhile(1) {\n\t\t\t\tnmask |= 1 << id;\n\t\t\t\tnx += dx[k], ny += dy[k];\n\t\t\t\tif(!in(nx, ny)) break;\n\t\t\t\tid = b[ny][nx];\n\t\t\t\tif(id == -1 || (mask >> id & 1)) break;\n\t\t\t}\n\t\t\tif(ny >= 18) {\n\t\t\t\tprintf(\"%d\\n\", t + 1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(in(nx, ny)) {\n\t\t\t\tS ns = { nx, ny, nmask };\n\t\t\t\tif(dp.count(ns.hash()) == 0) {\n\t\t\t\t\tdp[ns.hash()] = t + 1;\n\t\t\t\t\tq.push(ns);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\nconst int dx2[] = { -1,-1, 0, 1,1,1, 0,-1 }; const int dy2[] = { 0, 1,1,1, 0,-1,-1, -1 };\n\nvector<string> now;\nint ans = 10000;\nvvi visited(21, vi(17, 10000));\nvoid dfs(int y, int x, int step) {\n\tif (y == 20 || (y == 19 && 0 < x&&x < 16)) {\n\t\tans = min(ans, step);\n\t\treturn;\n\t}\n\tREP(i, 8) {\n\t\tvector<string> now2=now;\n\t\tint my = 0;\n\t\tint mx = 0;\n\t\tif (now[y + dy2[i]][x + dx2[i]] == 'X') {\n\t\t\tdo {\n\t\t\t\tnow[y + my][x + mx] = '.';\n\t\t\t\tmy += dy2[i];\n\t\t\t\tmx += dx2[i];\n\t\t\t} while (now[y + my][x + mx] == 'X');\n\t\t\tif (step + 1 < visited[y + my][x + mx]) {\n\t\t\t\tdfs(y + my, x + mx, step + 1);\n\t\t\t}\n\t\t}\n\t\tnow = now2;\n\t}\n}\n\nint main() {\n\tvector<string> ban(21,\".................\");\n\tint sy=-1, sx=-1;\n\tREP(i, 19) {\n\t\tcin >> ban[i+1];\n\t\tban[i + 1] = \".\" + ban[i + 1] + \".\";\n\t\tREP(j, 17)\n\t\t\tif (ban[i+1][j] == 'O') {\n\t\t\t\tsy = i+1;\n\t\t\t\tsx = j;\n\t\t\t\tvisited[i+1][j] = true;\n\t\t\t}\n\t}\n\tnow = ban;\n\tdfs(sy,sx,0);\n\tif (ans == 10000)\n\t\tans = -1;\n\tcout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef vector<vector<bool>> Map;\ntypedef tuple<pair<int, int>, Map, int> T;\n\nconst int h = 20, w = 17;\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint ans;\nMap c;\n\nmap<Map, map<pair<int, int>, int>> memo;\n\nvoid dfs(int y, int x, int cost){\n\tif(ans <= cost) return;\n\tif(memo.count(c) and memo[c].count(make_pair(y,x)) and memo[c][make_pair(y,x)] <= cost) return;\n\tmemo[c][make_pair(y,x)] = cost;\n\n\tif(y == 18 or y == 19){\n\t\tans = min(ans, cost);\n\t\treturn;\n\t}\n\n\trep(i,8){\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)) continue;\n\t\tif(c[ny][nx] == 1){\n\t\t\tvector<pair<int, int>> tmp;\n\t\t\twhile(true){\n\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\tny = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\tny = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(c[ny][nx] == 0) break;\n\t\t\t\ttmp.emplace_back(ny,nx);\n\t\t\t\t//pc[ny][nx] = 0;\n\t\t\t\tny = ny + dy[i];\n\t\t\t\tnx = nx + dx[i];\n\t\t\t}\n\t\t\tif(ny == -1) continue;\n\n\t\t\tfor(auto i : tmp) c[i.first][i.second] = 0;\n\t\t\tdfs(ny, nx, cost + 1);\n\t\t\tfor(auto i : tmp) c[i.first][i.second] = 1;\n\t\t}\n\t}\n}\n\nint main(){\n\tpair<int, int> s;\n\tc = Map(h, vector<bool>(w));\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tchar a;\n\t\t\tcin >> a;\n\t\t\tif(a == 'X') c[i][j + 1] = 1;\n\t\t\telse c[i][j + 1] = 0;\n\t\t\tif(a == 'O'){\n\t\t\t\ts = make_pair(i,j + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tans = 1e9;\n\tdfs(s.first, s.second, 0);\n\tcout << (ans == 1e9 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\nint dx[8] = {1, 1, 1, 0, 0,-1,-1,-1};\nint dy[8] = {1, 0,-1, 1,-1, 1, 0,-1};\nvector<vector<char> > field(21, vector<char>(17, '.'));\n\nint solve(int sy, int sx){\n    if(sy >= 19){\n        return 0;\n    }\n    if(sy <= 0 || 20 <= sy || sx <= 0 || 16 <= sx){\n        return inf;\n    }\n    int ret = inf;\n    for(int i=0; i<8; i++){\n        int ny = sy +dy[i];\n        int nx = sx +dx[i];\n        if(field[ny][nx] != 'X') continue;\n        while(field[ny][nx] == 'X'){\n            field[ny][nx] = '.';\n            ny += dy[i];\n            nx += dx[i];\n        }\n        ret = min(ret, solve(ny, nx));\n        while(ny != sy || nx != sx){\n            ny -= dy[i];\n            nx -= dx[i];\n            field[ny][nx] = 'X';\n        }\n        field[sy][sx] = '.';\n    }\n    return ret+1;\n}\n\nint main(){\n    int sy, sx;\n    for(int i=1; i<=19; i++){\n        for(int j=1; j<=15; j++){\n            cin >> field[i][j];\n            if(field[i][j] == 'O'){\n                sy = i;\n                sx = j;\n            }\n        }\n    }\n    int ans = solve(sy, sx);\n    if(ans >= inf){\n        cout << -1 << endl;\n    }else{\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\n//typedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};\nint n=19,m=15;\nvs in(n);\nint t=inf;\nvoid dfs(int x,int y,int c){\n\trep(i,8){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tint co=0;\n\t\twhile(nx>=0&&nx<19&&ny>=0&&ny<15&&in[nx][ny]=='X'){\n\t\t\tin[nx][ny]='.';\n\t\t\tco++;\n\t\t\tnx+=dx[i];\n\t\t\tny+=dy[i];\n\t\t}\n\t\tif(co&&nx<=18&&ny>=0&&ny<=14)dfs(nx,ny,c+1);\n\t\t\n\t\tif(co&&(nx==18&&ny>=0&&ny<15)||nx>18){\n\t\t\tt=min(t,c+1);\n\t\t}\n\t\tnx-=dx[i],ny-=dy[i];\n\t\twhile(nx!=x||ny!=y){\n\t\t\tin[nx][ny]='X';\n\t\t\tnx-=dx[i];ny-=dy[i];\n\t\t}\n\t}\n}\nint main(){\n\trep(i,n)cin>>in[i];\n\trep(i,n)rep(j,m)if(in[i][j]=='O'){\n\t\tdfs(i,j,0);\n\t\tin[i][j]='.';\n\t\tif(t==inf)t=-1;\n\t\tcout<<t<<endl;\n\t\treturn 0;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nusing pii = pair<int, int>;\n\nconstexpr int dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nconstexpr int dy[8] = {1, 1, 0, -1, -1, -1, 0, 1};\n\nint main() {\n    vector<string> v(21, \".................\");\n    int sx, sy;\n    for(int i=1; i<=19; ++i) {\n        string s;\n        cin >> s;\n        v[i] = \".\" + s + \".\";\n        for(int j=1; j<=15; ++j) {\n            if(v[i][j] == 'O') {\n                sy = i;\n                sx = j;\n            }\n        }\n    }\n    map<vector<string>, int> d;\n    using state = tuple<int, int, vector<string>>;\n    d[v] = 0;\n    queue<state> que;\n    que.push(make_tuple(sy, sx, v));\n    int res = INF;\n    while(!que.empty()) {\n        int y, x;\n        vector<string> now;\n        tie(y, x, now) = que.front();\n        que.pop();\n        //cout << \"y: \" << y << \"  x: \" << x << endl;\n        //cout << \"map: \" << endl;\n        //for(auto& s : now) {\n        //    cout << s << endl;\n        //}\n        //cout << endl;\n        for(int i=0; i<8; ++i) {\n            auto next = now;\n            int ny = y + dy[i], nx = x + dx[i];\n            bool ok = false;\n            while(next[ny][nx] == 'X') {\n                ny += dy[i];\n                nx += dx[i];\n                ok = true;\n            }\n            if(!ok) {\n                continue;\n            }\n            int ty = y, tx = x;\n            while(ty != ny || tx != nx) {\n                next[ty][tx] = '.';\n                ty += dy[i];\n                tx += dx[i];\n            }\n            next[ny][nx] = 'O';\n            if(d.count(next) == 0) {\n                d[next] = d[now] + 1;\n                if(ny == 19 && 1 <= nx && nx <= 15 || ny == 20) {\n                    res = min(res, d[next]);\n                }\n                if(1 <= ny && ny <= 19 && 1 <= nx && nx <= 15) {\n                    que.push(make_tuple(ny, nx, next));\n                }\n            }\n        }\n    }\n    cout << (res == INF ? -1 : res) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>P2;\n\nstring s[21];\nint h=21,w=17,sx,sy;\nint dx[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={-1,-1,0,1,1,1,0,-1};\nbool d[21][19][1<<20];\n\nmap<pair<int,int>,int>M1;\nmap<int,pair<int,int> >M2;\nint cnt;\n\nint main(){\n  s[0]=s[20]=\".................\";\n  r(i,h-2){\n    cin>>s[i+1];\n    s[i+1]=\".\"+s[i+1]+\".\";\n  }\n  r(i,h)r(j,w)if(s[i][j]=='O'){\n    sx=j;\n    sy=i;\n    s[i][j]='.';\n  }else if(s[i][j]=='X'){\n    M2[cnt]=P(i,j);\n    M1[P(i,j)]=cnt++;\n  }\n  queue<P2>q;\n  d[sy][sx][0]=1;\n  q.push(P2(P(sy*1000+sx,0),0));\n  while(!q.empty()){\n    P2 p=q.front();q.pop();\n    int y=p.first.first/1000;\n    int x=p.first.first%1000;\n    int cost=p.first.second;\n    int bit=p.second;\n    r(i,8){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      int b=bit;\n      if(ny<=0||nx<=0||ny>=h||nx>=w-1)continue;\n      if(s[ny][nx]=='.')continue;\n      if((1<<M1[P(ny,nx)])&b)continue;\n      while(s[ny][nx]=='X'){\n\tint c=M1[P(ny,nx)];\n\tif((1<<c)&b)break;\n\tb+=(1<<c);\n\tny+=dy[i];\n\tnx+=dx[i];\n      \n      if(ny<19&&(nx==0||nx==w-1))continue;\n      if(d[ny][nx][b]==1)continue;\n      d[ny][nx][b]=1;\n      q.push(P2(P(ny*1000+nx,cost+1),b));\n      if(ny>=19&&!(ny==19&&nx==14)){\n\tcout<<cost+1<<endl;\n\treturn 0;\n      }\n    }\n  }\n  cout<<-1<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct state{\n  int bi,a,b;\n  bool operator<(const state& s) const {\n    if( bi == s.bi ){\n      if( a == s.a ) return b < s.b;\n      return a < s.a;\n    }\n    return bi < s.bi;\n  }\n};\n\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};\n\nmap<state,int> dp;\nchar cie[55][55];\nint fie[55][55];\nint N,W,H;\nbool check( int bi,int x,int y,int d,int &nst,int &nx,int &ny ){\n  bool f = false;\n  nst = bi;\n  nx = x + dx[d];\n  ny = y + dy[d];  \n  if( nx < 0 || nx >= W || ny < 0 || ny >= H ) return false;\n  if( cie[nx][ny] == 'X' && !(nst & (1<<fie[nx][ny])) ){\n    f = true;      \n    nst |= (1<<fie[nx][ny]);\n  }\n\n  while( f ){\n    nx = nx + dx[d];\n    ny = ny + dy[d];  \n    if( ny >= H-1 ) return true;\n    if( nx < 0 || nx >= W || ny < 0 ) return false;\n    if( cie[nx][ny] == 'X' && !(nst & (1<<fie[nx][ny])) ){\n      nst |= (1<<fie[nx][ny]);\n    } else\n      break;\n  }\n  return f;\n}\n\nint solve(int bi,int x,int y){\n  if( dp.count((state){bi,x,y}) != 0 ) return dp[(state){bi,x,y}];\n  // cout << bitset<20>(bi) << \" \"<< x << \" \"<< y << endl;\n  if( y >= H-1 ) return dp[(state){bi,x,y}] = 0;\n  int ret = (1<<29);\n  for(int i=0;i<8;i++){\n    int nx,ny,nst;\n    if( check(bi,x,y,i,nst,nx,ny) ){\n      ret = min( ret, solve(nst,nx,ny)+1);\n    }\n  }\n  return dp[(state){bi,x,y}] = ret;\n}\n\nint main(){\n  N = 0;\n  W=15;H=19;\n  int x,y;\n  for(int i=0;i<19;i++){\n    for(int j=0;j<15;j++){\n      cin >> cie[j][i];\n      if( cie[j][i] == 'X')\n\tfie[j][i] = N++;\n      if( cie[j][i] == 'O' ){\n\tx = j; y = i;\n      }\t\n    }\n  }\n  int res = solve(0,x,y);\n  if( res == (1<<29) )\n    cout << -1 << endl;\n  else \n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 19\n#define M 15\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nint sy,sx,cnt;\nmap<P1,int> memo;\nmap<P,int> num;\nstring s[N];\nint dy[8]={-1,-1,-1,0,0,1,1,1};\nint dx[8]={-1,0,1,-1,1,-1,0,1};\n\nint dfs(int A,int y,int x){\n  if(memo.count(P1(A,P(y,x))))return memo[P1(A,P(y,x))];\n  if(N-1<=y)return 1;\n  if(y<0||x<0||N<=y||M<=x)return INF;\n  int res=INF;\n  memo[P1(A,P(y,x))]=INF;\n  for(int i=0;i<8;i++){\n    int ny=y+dy[i],nx=x+dx[i],nA=A;\n    if(s[ny][nx]!='X')continue;\n    while(0<=ny&&ny<N&&0<=nx&&nx<M&&s[ny][nx]=='X'){\n      nA|=(1<<num[P(ny,nx)]);\n      s[ny][nx]='.';\n      ny+=dy[i]; nx+=dx[i];\n    }\n    res=min(res,dfs(nA,ny,nx));\n    while(ny!=y||nx!=x){\n      ny-=dy[i]; nx-=dx[i];\n      s[ny][nx]='X';\n    }\n  }\n  return memo[P1(A,P(y,x))]=res+1;\n}\n\nint main(){\n  for(int i=0;i<N;i++){\n    cin>>s[i];\n    for(int j=0;j<M;j++){\n      if(s[i][j]=='O'){\n\tsy=i,sx=j;\n\ts[i][j]='.';\n      }\n      if(s[i][j]=='X')\n\tnum[P(i,j)]=cnt++;\n    }\n  }\n  int ans=dfs(0,sy,sx);\n  cout<<(ans==INF+1?-1:ans-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\nconst int h = 19;\nconst int w = 15;\n\nstruct Data { \n  int x,y,bitmask,cost;\n  bool operator < ( const Data& data ) const { \n    if( cost != data.cost ) return cost < data.cost; \n    if( x != data.x ) return x < data.x;\n    if( y != data.y ) return y < data.y;\n    if( bitmask != data.bitmask ) return bitmask < data.bitmask;\n  }\n};\n\nchar a[20][20];\n//int mindist[1<<20][9];\nset<Data> mindist;\nint Index[20][20];\n\nbool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\nvoid compute(){\n  int black = 0;\n  int sx=-1,sy=-1;\n  rep(i,h) rep(j,w) {\n    if( a[i][j] == 'X' ) Index[i][j] = black++;\n    if( a[i][j] == 'O' ) sx = j, sy = i;\n  }\n  //rep(i,(1<<black)) rep(j,9) mindist[i][j] = IINF;\n  mindist.clear();\n  //mindist[(1<<black)-1][4] = 0;\n  mindist.insert((Data){sx,sy,(1<<black)-1,0});\n  deque<Data> deq;\n  deq.push_back((Data){sx,sy,(1<<black)-1,0});\n  while( !deq.empty() ){\n    Data data = deq.front(); deq.pop_front();\n    REP(dx,-1,2){\n      REP(dy,-1,2){\n        if( dx == 0 && dy == 0 ) continue;\n        int nx = data.x + dx, ny = data.y + dy, nbitmask = data.bitmask;\n        bool valid = false;\n        while( isValid(nx,ny) && ( a[ny][nx] == 'X' && ( data.bitmask & (1<<Index[ny][nx]) ) ) ){\n          nbitmask &= ~(1<<Index[ny][nx]);\n          nx += dx, ny += dy;\n          valid = true;\n        }\n        if( !isValid(nx,ny) ) {\n          if( valid && ( 0 <= nx && nx < w ) && ny >= h ) {\n            //cout << mindist[data.bitmask]+1 << endl;\n            cout << data.cost+1 << endl;\n            return;\n          }\n          continue;\n        }\n        if( !valid ) continue;\n        //if( mindist[nbitmask] > mindist[data.bitmask] + 1 ) {\n        if( !mindist.count((Data){nx,ny,nbitmask,data.cost+1}) ) {\n          //mindist[nbitmask] = mindist[data.bitmask] + 1;\n          mindist.insert((Data){nx,ny,nbitmask,data.cost+1});\n          deq.push_back((Data){nx,ny,nbitmask,data.cost+1});\n        }\n      }\n    }\n  }\n  puts(\"-1\");\n}\n\nint main(){\n  rep(i,h) rep(j,w) scanf(\" %c\",&a[i][j]);\n  compute();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, int> Q;\n\nconst int INF = 100000000;\n\nchar d[19][16];\n\nint dx[8] = {0, 1, 1, 1, 0, -1, -1, -1};\nint dy[8] = {-1, -1, 0, 1, 1, 1, 0, -1};\n\nbool out(int x, int y) {\n  return x < 0 || y < 0 || x >= 15 || y >= 19;\n}\n\nbool goal(int x, int y) {\n  if (y == 18 && !out(x, y)) return true;\n  return y >= 19;\n}\n\nbool black(int x, int y) {\n  return d[y][x] == 'X';\n}\n\nvoid ret(int x, int y, int X, int Y, int j) {\n  x += dx[j], y += dy[j];\n  while (!(x == X && y == Y)) {\n    d[y][x] = 'X';\n    x += dx[j], y += dy[j];\n  }\n}\n\nint solve(int X, int Y, int counter) {\n  counter++;\n  int ans = INF;\n  for (int i = 0; i < 8; i++) {\n    int x = X + dx[i], y = Y + dy[i];\n    if (out(x, y)) continue;\n    if (!black(x, y)) continue;\n    while (!out(x, y) && black(x, y)) {\n      d[y][x] = '.';\n      x += dx[i], y += dy[i];\n    }\n    if (goal(x, y)) {\n      ret(x, y, X, Y, (i + 4) % 8);\n      return counter;\n    }\n    if (out(x, y)) {\n      ret(x, y, X, Y, (i + 4) % 8);\n      continue;\n    }\n    ans = min(ans, solve(x, y, counter));\n    ret(x, y, X, Y, (i + 4) % 8);\n  }\n  return ans;\n}\n\nint main() {\n  for (int i = 0; i < 19; i++) scanf(\"%s\", d[i]);\n  int x, y;\n  for (int i = 0; i < 19; i++) {\n    for (int j = 0; j < 15; j++) {\n      if (d[i][j] == 'O') {\n        d[i][j] = '.';\n        x = j, y = i;\n        i = 19,j = 16;\n      }\n    }\n  }\n  int ans = solve(x, y, 0);\n  if (ans == INF) ans = -1;\n  printf(\"%d\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string.h>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H=19,W=15;\n\nenum DIR{\n\tLeft_Up,\n\tUp,\n\tRight_Up,\n\tLeft,\n\tRight,\n\tLeft_Down,\n\tDown,\n\tRight_Down,\n};\n\nDIR dir[8] = {Left_Up,Up,Right_Up,Left,Right,Left_Down,Down,Right_Down};\n\nint diff_row[8] = {-1,-1,-1,0,0,1,1,1},diff_col[8] = {-1,0,1,-1,1,-1,0,1};\n\nstruct BlackStone{\n\tvoid set(short arg_row,short arg_col){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t}\n\tshort row,col;\n\tbool erased;\n};\n\nstruct Info{\n\tBlackStone black_stone[20];\n\tshort row,col,black_num;\n\tint count;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row <= 17){\n\t\tif(col < 0 || col > 14){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}else{ //row >= 18\n\t\tif(row == 18 && (col < 0 || col > 14)){\n\t\t\treturn false;\n\t\t}else{\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\nInfo move(Info info,DIR dir){\n\tInfo ret;\n\n\tchar map[19][15];\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)map[i][k] = '.';\n\t}\n\n\tfor(int i = 0; i < info.black_num; i++){\n\t\tif(info.black_stone[i].erased == false){\n\t\t\tmap[info.black_stone[i].row][info.black_stone[i].col] = 'X';\n\t\t}\n\t\tret.black_stone[i].set(info.black_stone[i].row,info.black_stone[i].col);\n\t\tret.black_stone[i].erased = info.black_stone[i].erased;\n\t}\n\tret.black_num = info.black_num;\n\tret.count = info.count+1;\n\n\tint next_row,next_col,index;\n\n\tswitch(dir){\n\tcase Left_Up:\n\t\tindex = 0;\n\t\tbreak;\n\tcase Up:\n\t\tindex = 1;\n\t\tbreak;\n\tcase Right_Up:\n\t\tindex = 2;\n\t\tbreak;\n\tcase Left:\n\t\tindex = 3;\n\t\tbreak;\n\tcase Right:\n\t\tindex = 4;\n\t\tbreak;\n\tcase Left_Down:\n\t\tindex = 5;\n\t\tbreak;\n\tcase Down:\n\t\tindex = 6;\n\t\tbreak;\n\tcase Right_Down:\n\t\tindex = 7;\n\t\tbreak;\n\t}\n\n\tnext_row = info.row+diff_row[index];\n\tnext_col = info.col+diff_col[index];\n\n\twhile(rangeCheck(next_row,next_col) == true && map[next_row][next_col] == 'X'){\n\t\tnext_row += diff_row[index];\n\t\tnext_col += diff_col[index];\n\t}\n\n\n\tif(next_row == info.row+diff_row[index] && next_col == info.col+diff_col[index]){\n\t\tret.row = 1;\n\t\tret.col = -1;\n\t}else{\n\t\tint tmp_row,tmp_col;\n\n\t\ttmp_row = info.row+diff_row[index];\n\t\ttmp_col = info.col+diff_col[index];\n\n\t\twhile(tmp_row != next_row || tmp_col != next_col){\n\t\t\tfor(int i = 0; i < ret.black_num;i++){\n\t\t\t\tif(ret.black_stone[i].erased == false && ret.black_stone[i].row == tmp_row && ret.black_stone[i].col == tmp_col){\n\t\t\t\t\tret.black_stone[i].erased = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttmp_row += diff_row[index];\n\t\t\ttmp_col += diff_col[index];\n\t\t}\n\n\t\tret.row = next_row;\n\t\tret.col = next_col;\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\n\tInfo first;\n\n\tfor(int i = 0; i < 20; i++)first.black_stone[i].erased = true;\n\tfirst.black_num = 0;\n\tchar buf[15];\n\tint minimum = BIG_NUM,start_row,start_col;\n\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",buf);\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tif(buf[k] == 'O'){\n\t\t\t\tstart_row = i;\n\t\t\t\tstart_col = k;\n\t\t\t}else if(buf[k] == 'X'){\n\t\t\t\tfirst.black_stone[first.black_num].erased = false;\n\t\t\t\tfirst.black_stone[first.black_num++].set(i,k);\n\t\t\t}\n\t\t}\n\t}\n\n\tfirst.row = start_row;\n\tfirst.col = start_col;\n\tfirst.count = 0;\n\n\tqueue<Info> Q;\n\tQ.push(first);\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.front().row >= 18){\n\t\t\tminimum = Q.front().count;\n\t\t\tbreak;\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < 8; i++){\n\t\t\t\tInfo next = move(Q.front(),dir[i]);\n\n\t\t\t\tif(rangeCheck(next.row,next.col)){\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n\n\tif(minimum == BIG_NUM){\n\t\tprintf(\"-1\\n\");\n\t}else{\n\t\tprintf(\"%d\\n\",minimum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int w = 15;\nconst int h = 19;\nvector<string> mp(h);\n\nbool inmp(int x,int y){return 0<=x&&0<=y&&x<w&&y<h;}\n\n\nint ans=1e9;\nvoid dfs(int x,int y,int cost){\n  if(y==h-1||y==h)ans=min(ans,cost);\n  if(!inmp(x,y)||ans<=cost) return;\n\n  for(int i=-1;i<=1;i++)\n    for(int j=-1;j<=1;j++){\n      int nx = x+i;\n      int ny = y+j;\n      if(!inmp(nx,ny)||mp[ny][nx] != 'X') continue;\n      vector<string>tmp = mp;\n      while(inmp(nx,ny)&&mp[ny][nx]=='X')mp[ny][nx] = '.', nx+=i,ny+=j;\n      dfs(nx,ny,cost+1);\n      mp = tmp;\n    }\n}\n\nint main(){\n\n  for(int i=0;i<h;i++)cin>>mp[i];\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)\n      if(mp[i][j] =='O') dfs(j,i,0);\n\n  if(ans==1e9) ans=-1;\n  cout<<ans<<endl;\n  \n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>P2;\n\nstring s[21];\nint h=21,w=17,sx,sy;\nint dx[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={-1,-1,0,1,1,1,0,-1};\nbool d[21][19][1<<20];\n\nmap<pair<int,int>,int>M1;\nmap<int,pair<int,int> >M2;\nint cnt;\n\nint main(){\n  s[0]=s[20]=\".................\";\n  r(i,h-2){\n    cin>>s[i+1];\n    s[i+1]=\".\"+s[i+1]+\".\";\n  }\n  r(i,h)r(j,w)if(s[i][j]=='O'){\n    sx=j;\n    sy=i;\n    s[i][j]='.';\n  }else if(s[i][j]=='X'){\n    M2[cnt]=P(i,j);\n    M1[P(i,j)]=cnt++;\n  }\n  queue<P2>q;\n  d[sy][sx][0]=0;\n  q.push(P2(P(sy*1000+sx,0),0));\n  while(!q.empty()){\n    P2 p=q.front();q.pop();\n    int y=p.first.first/1000;\n    int x=p.first.first%1000;\n    int cost=p.first.second;\n    int bit=p.second;\n    r(i,8){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      int b=bit;\n      if(ny<0||nx<0||ny>=h||nx>=w)continue;\n      if(s[ny][nx]=='.')continue;\n      if((1<<M1[P(ny,nx)])&b)continue;\n      while(s[ny][nx]=='X'){\n\tint c=M1[P(ny,nx)];\n\tif((1<<c)&b)break;\n\tb|=(1<<c);\n\tny+=dy[i];\n\tnx+=dx[i];\n      }\n      if(d[ny][nx][b]!=false)continue;\n      d[ny][nx][b]=1;\n      q.push(P2(P(ny*1000+nx,cost+1),b));\n      if(ny==20){\n\tcout<<b<<endl;\n\tcout<<cost+1<<endl;\n\treturn 0;\n      }\n    }\n  }\n  cout<<-1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cstdio>\n#include <ctime>\n#include <assert.h>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n    return (ull)rng() % B;\n}\n\nint dx[]={-1,0,1,1,1,0,-1,-1};\nint dy[]={-1,-1,-1,0,1,1,1,0};\n\nint h=19,w=15;\nint n;\n\nchar fi[19][15];\nvector<pair<int,int>> v;\nmap<pair<int,int>,int> mp;\n\nbool is_in(int x,int y){\n\treturn 0<=x&&x<h&&0<=y&&y<w;\n}\n\nint solve(){\n\tqueue<pair<pair<int,int>,pair<int,int>>> q;\n\tvector<bool> used(1<<n,false);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<8;j++){\n\t\t\tauto now=v[i];\n\t\t\tnow.first+=dx[j];\n\t\t\tnow.second+=dy[j];\n\t\t\tint nx=now.first,ny=now.second;\n\t\t\tif(is_in(nx,ny)&&fi[nx][ny]=='O'&&!used[(1<<n)-1]){\n\t\t\t\tq.push(make_pair(make_pair((1<<n)-1,0),make_pair(i,j)));\n\t\t\t\tused[(1<<n)-1]=1;\n\t\t\t}\n\t\t}\n\t}\n\twhile(q.size()){\n\t\tauto p=q.front(); q.pop();\n\t\tfor(int i=0;i<8;i++){\n\t\t\tbool jump=0;\n\t\t\tauto now=p;\n\t\t\tnow.first.second++;\n\t\t\tint nx=v[now.second.first].first+dx[now.second.second];\n\t\t\tint ny=v[now.second.first].second+dy[now.second.second];\n\t\t\tnow.second.second=i;\n\t\t\twhile(is_in(nx,ny)){\n\t\t\t\tnx+=dx[i],ny+=dy[i];\n\t\t\t\tif(!is_in(nx,ny)||mp.find(make_pair(nx,ny))==mp.end()||!(now.first.first>>mp[make_pair(nx,ny)]&1)){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tjump=true;\n\t\t\t\tnow.second.first=mp[make_pair(nx,ny)];\n\t\t\t\tnow.first.first-=(1<<now.second.first);\n\t\t\t}\n\t\t\tif(!jump)continue;\n\t\t\tif(nx==19||(nx==18&&is_in(nx,ny))){\n\t\t\t\treturn now.first.second;\n\t\t\t}\n\t\t\tif(!is_in(nx,ny))continue;\n\t\t\tif(!used[now.first.first]){\n\t\t\t\tq.push(now);\n\t\t\t\tused[now.first.first]=1;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin >> fi[i][j];\n\t\t\tif(fi[i][j]=='X'){\n\t\t\t\tmp[make_pair(i,j)]=v.size();\n\t\t\t\tv.push_back(make_pair(i,j));\n\t\t\t}\n\t\t}\n\t}\n\tn=v.size();\n\tcout << solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\nconst char h = 20, w = 17;\nvector<vector<bool>> c;\ntypedef tuple<pair<char, char>, vector<vector<bool>>, char> T;\nqueue<T> q;\nmap<vector<vector<bool>>, vector<vector<char>>> memo;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nbool impossible(int y, vector<vector<bool>>& c){\n\tvector<bool> no(h,0);\n\trange(i,y + 1,18){\n\t\tbool f = false;\n\t\trep(j,w){\n\t\t\tif(c[i][j]) f = true;\n\t\t}\n\t\tif(not f) no[i] = true;\n\t}\n\trep(i,h - 1){\n\t\tif(no[i] and no[i + 1]) return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tc = vector<vector<bool>>(h, vector<bool>(w,0));\n\n\tpair<char, char> s;\n\trep(i,h - 1){\n\t\trep(j,w - 2){\n\t\t\tchar a;\n\t\t\tcin >> a;\n\t\t\tif(a == 'X') c[i][j + 1] = 1;\n\t\t\telse c[i][j + 1] = 0;\n\t\t\tif(a == 'O'){\n\t\t\t\ts = make_pair(i,j + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tq.push(T(s,c,0));\n\n\tchar ans = 127;\n\twhile(not q.empty()){\n\t\tchar cost;\n\t\ttie(s,c,cost) = q.front(); q.pop();\n\n\t\tchar y, x;\n\t\ttie(y,x) = s;\n\n\t\t//rep(i,h){ rep(j,w){ if(i == y and j == x) cout << 'O'; else cout << c[i][j]; } cout << endl; } cout << endl;\n\n\t\tif(y == 18 or y == 19){\n\t\t\tans = min(ans, cost);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif(impossible(y, c)) continue;\n\n\t\tif(cost >= 20) continue;\n\n\t\trep(i,8){\n\t\t\tchar ny = y + dy[i];\n\t\t\tchar nx = x + dx[i];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)) continue;\n\t\t\tvector<vector<bool>> pc = c;\n\t\t\tif(pc[ny][nx] == 1){\n\t\t\t\twhile(true){\n\t\t\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) {\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif((nx == 0 && ny <= 18) or (nx == w - 1 && ny <= 18)){\n\t\t\t\t\t\tny = -1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(pc[ny][nx] == 0) break;\n\t\t\t\t\tpc[ny][nx] = 0;\n\t\t\t\t\tny = ny + dy[i];\n\t\t\t\t\tnx = nx + dx[i];\n\t\t\t\t}\n\t\t\t\tif(ny == -1) continue;\n\n\t\t\t\tif(memo.count(pc)){\n\t\t\t\t\tauto& it = memo[pc];\n\t\t\t\t\tif(it[ny][nx] > cost + 1){\n\t\t\t\t\t\tit[ny][nx] = cost + 1;\n\t\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tvector<vector<char>> dis(h, vector<char>(w,127));\n\t\t\t\t\tdis[ny][nx] = cost + 1;\n\t\t\t\t\tmemo[pc] = dis;\n\t\t\t\t\tq.push(T(make_pair(ny,nx), pc, cost + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << (ans == 127 ? -1 : ans) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nstruct State { int x[19][15]; };\nState S;\nint dx[8] = { 1,1,1,0,-1,-1,-1,0 }, dy[8] = { -1,0,1,1,1,0,-1,-1 };\nint solve(State p) {\n\tint cx = 0, cy = 0;\n\tfor (int i = 0; i < 285; i++) {\n\t\tif (p.x[i / 15][i % 15] == 2) { cx = i / 15; cy = i % 15; }\n\t}\n\tint minx = 999999;\n\tfor (int i = 0; i < 8; i++) {\n\t\tState T = p;\n\t\tint ex = cx, ey = cy;\n\t\twhile (true) {\n\t\t\tif (ex < 0 || ey < 0 || ey >= 15)continue;\n\t\t\tex += dx[i]; ey += dy[i];\n\t\t\tif (ex == 19 || T.x[ex][ey] == 0)break;\n\t\t\tT.x[ex][ey] = 0;\n\t\t}\n\t\tif (abs(ex - cx) <= 1 && abs(ey - cy) <= 1)continue;\n\t\tif (ex == 18 || ex == 19)minx = min(minx, 1);\n\t\telse {\n\t\t\tT.x[cx][cy] = 0; T.x[ex][ey] = 2;\n\t\t\tminx = min(minx, solve(T) + 1);\n\t\t}\n\t}\n\treturn minx;\n}\nint main() {\n\tfor (int i = 0; i < 19; i++) {\n\t\tfor (int j = 0; j < 15; j++) {\n\t\t\tchar p; cin >> p;\n\t\t\tif (p == 'O')S.x[i][j] = 2;\n\t\t\tif (p == 'X')S.x[i][j] = 1;\n\t\t\tif (p == '.')S.x[i][j] = 0;\n\t\t}\n\t}\n\tint R = solve(S); if (R >= 100000)R = -1;\n\tcout << R << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\ntypedef tuple<int,int,int,int> state;\n\n\nstring board[19];\nint stone[19][15];\n\nint num=0;\n\nint dx[8]={1,1,1,0,-1,-1,-1,0};\nint dy[8]={1,0,-1,-1,-1,0,1,1};\n\nint bfs(){\n\tint wx=-1,wy=-1;\n\trep(i,19)rep(j,15) stone[i][j]=-1;\n\trep(i,19)rep(j,15){\n\t\tif(board[i][j]=='X')\n\t\t\tstone[i][j]=num++;\n\t\tif(board[i][j]=='O')\n\t\t\twx=i,wy=j;\n\t}\n\tstate init(0,wx,wy,(1<<20)-1);\n\tqueue<state> q;\n\tq.push(init);\n\twhile(!q.empty()){\n\t\tstate cur=q.front();q.pop();\n\t\tint cost,cx,cy,mask;\n\t\ttie(cost,cx,cy,mask)=cur;\n\t\tif(cx>=19||(cx==18&&0<=cy&&cy<15))\n\t\t\treturn cost;\n\t\tif(cx<0||19<=cx||cy<0||15<=cy) continue;\n\t\trep(i,8){\n\t\t\tint nx=cx,ny=cy,nmask=mask;\n\t\t\twhile(0<=nx+dx[i]&&nx+dx[i]<19&&0<=ny+dy[i]&&ny+dy[i]<15){\n\t\t\t\tint index=stone[nx+dx[i]][ny+dy[i]];\n\t\t\t\tif(index!=-1&&(nmask&(1<<index))){\n\t\t\t\t\tnmask&=(~(1<<index));\n\t\t\t\t\tnx+=dx[i],ny+=dy[i];\n\t\t\t\t}else\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(nx==cx&&ny==cy) continue;\n\t\t\tstate nexts(cost+1,nx+dx[i],ny+dy[i],nmask);\n\t\t\tq.push(nexts);\n\t\t}\n\t}\n\treturn -1;\n}\n\n\nint main(void){\n\trep(i,19) cin >> board[i];\n\tcout << bfs() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (long long)1e9\nusing namespace std;\n\nstruct data {\n  int x, y;\n};\nbool operator<(const data &l, const data &r) {\n  if(l.x != r.x) return l.x < r.x;\n  return l.y < r.y;\n}\n\nstruct cod {\n  int s, b, d, c;\n};\n\nint x[8] = {-1, 0, 1, 1, 1, 0, -1, -1};\nint y[8] = {-1, -1, -1, 0, 1, 1, 1, 0};\n\nint n;\nvector<string> s;\nvector<data> v;\nvector<bool> ch;\nmap<data, int> mp;\n\nlong long solve();\nbool isvalid(data now) {\n  return now.x >= 0 && now.x < 19 && now.y >= 0 &&\n         now.y < 15;\n}\n\nint main() {\n  s.resize(19);\n  for(int i = 0; i < 19; ++i) cin >> s[i];\n  for(int i = 0; i < 19; ++i)\n    for(int j = 0; j < 15; ++j)\n      if(s[i][j] == 'X') {\n        mp[{i, j}] = v.size();\n        v.push_back({i, j});\n      }\n  n = v.size();\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  queue<cod> qu;\n  ch.assign((1 << n), 0);\n  for(int i = 0; i < n; ++i)\n    for(int j = 0; j < 8; ++j) {\n      data now = v[i];\n      now.x += x[j];\n      now.y += y[j];\n      if(!isvalid(now)) continue;\n      if(s[now.x][now.y] == 'O' && !(ch[(1 << n) - 1])) {\n        qu.push({(1 << n) - 1, i, j, 0});\n        ch[(1 << n) - 1] = 1;\n      }\n    }\n  while(!qu.empty()) {\n    cod now = qu.front();\n    qu.pop();\n    for(int i = 0; i < 8; ++i) {\n      bool jumped = 0;\n      cod nextc = now;\n      ++nextc.c;\n      int nowx = v[nextc.b].x + x[nextc.d],\n          nowy = v[nextc.b].y + y[nextc.d];\n      nextc.d = i;\n      while(nowx >= 0 && nowy >= 0 && nowx < 19 &&\n            nowy < 15) {\n        nowx += x[i];\n        nowy += y[i];\n        if(!isvalid({nowx, nowy}) ||\n           mp.find({nowx, nowy}) == mp.end() ||\n           !(nextc.s >> mp[{nowx, nowy}] & 1))\n          break;\n        nextc.b = mp[{nowx, nowy}];\n        nextc.s -= 1 << nextc.b;\n        jumped = 1;\n      }\n      if(!jumped) continue;\n      if(nowx == 19 ||\n         (nowx == 18 && isvalid({nowx, nowy})))\n        return nextc.c;\n      if(nowy == 15 || nowy == -1 || nowx == -1) continue;\n      if(!ch[nextc.s]) {\n        qu.push(nextc);\n        ch[nextc.s] = 1;\n      }\n    }\n  }\n  return -1;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    const int INF = 1<<28;\n\n    vector<string> F;\n    void input() {\n        F.resize(19);\n        for (int i = 0; i < 19; i++) cin >> F[i];\n    }\n\n    int sy, sx;\n    int c;\n    vector<vector<int>> N;\n    map<int,pair<int,int>> M;\n\n    void init() {\n        c = 0;\n        sy = sx = -1;\n        N.clear(); N.resize(19, vector<int>(15, -1));\n        M.clear();\n        for (int i = 0; i < 19; i++) {\n            for (int j = 0; j < 15; j++) {\n                if (F[i][j] == 'O') {\n                    sy = i;\n                    sx = j;\n                }\n                if (F[i][j] == 'X') {\n                    N[i][j] = c;\n                    M[c] = make_pair(i, j);\n                    c++;\n                }\n            }\n        }\n    }\n\n    struct Pos {\n        int y, x;\n        int used;\n        Pos(int y, int x, int used) : y(y), x(x), used(used) {}\n        Pos() {}\n    };\n    bool operator<(const Pos& a, const Pos& b) {\n        if (a.y == b.y) {\n            if (a.x == b.x) return a.used < b.used;\n            else return a.x < b.x;\n        } else {\n            return a.y < b.y;\n        }\n    }\n    map<Pos,int> memo;\n\n    Pos findNextPos(int y, int x, int dy, int dx, int used) {\n        int nused = used;\n        while (true) {\n            int ny = y + dy;\n            int nx = x + dx;\n            if (ny < 0 || ny >= 19 || nx < 0 || nx >= 15) return Pos(ny, nx, nused);\n            if (F[ny][nx] == 'X') {\n                int id = N[ny][nx];\n                if (nused & (1 << id)) {\n                    return Pos(ny, nx, nused);\n                } else {\n                    nused |= (1 << id);\n                }\n            } else {\n                return Pos(ny, nx, nused);\n            }\n            y = ny;\n            x = nx;\n        }\n    }\n\n    bool movable(int y, int x, int dy, int dx, int used) {\n        int ny = y + dy;\n        int nx = x + dx;\n        if (ny < 0 || ny >= 19 || nx < 0 || nx >= 15) return false;\n        if (F[ny][nx] != 'X') return false;\n        int id = N[ny][nx];\n        if (used & (1 << id)) return false;\n        return true;\n    }\n\n    int dfs(int y, int x, int used) {\n        //cout << \"dfs: \" << y << \" \" << x << \" \" << used << endl;\n        if (y >= 18) return 0;\n        if (y < 0 || x < 0 || x >= 15) return INF;\n        Pos key(y, x, used);\n        if (memo.count(key)) return memo[key];\n        int ans = INF;\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                if (not movable(y, x, dy, dx, used)) continue;\n                Pos next = findNextPos(y, x, dy, dx, used);\n                ans = min(ans, dfs(next.y, next.x, next.used) + 1);\n            }\n        }\n        return memo[key] = ans;\n    }\n\n    void solve() {\n        init();\n        int ans = dfs(sy, sx, 0);\n        if (ans >= INF) ans = -1;\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input();\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\ntypedef pair<P,int>P2;\n\nstring s[21];\nint h=21,w=17,sx,sy;\nint dx[]={0,1,1,1,0,-1,-1,-1};\nint dy[]={-1,-1,0,1,1,1,0,-1};\nbool d[21][19][1<<20];\n\nmap<pair<int,int>,int>M1;\nmap<int,pair<int,int> >M2;\nint cnt;\n\nint main(){\n  s[0]=s[20]=\".................\";\n  r(i,h-2){\n    cin>>s[i+1];\n    s[i+1]=\".\"+s[i+1]+\".\";\n  }\n  r(i,h)r(j,w)if(s[i][j]=='O'){\n    sx=j;\n    sy=i;\n    s[i][j]='.';\n  }else if(s[i][j]=='X'){\n    M2[cnt]=P(i,j);\n    M1[P(i,j)]=cnt++;\n  }\n  queue<P2>q;\n  d[sy][sx][0]=1;\n  q.push(P2(P(sy*1000+sx,0),0));\n  while(!q.empty()){\n    P2 p=q.front();q.pop();\n    int y=p.first.first/1000;\n    int x=p.first.first%1000;\n    int cost=p.first.second;\n    int bit=p.second;\n    r(i,8){\n      int ny=y+dy[i];\n      int nx=x+dx[i];\n      int b=bit;\n      if(ny<=0||nx<=0||ny>=h||nx>=w-1)continue;\n      if(s[ny][nx]=='.')continue;\n      if((1<<M1[P(ny,nx)])&b)continue;\n      while(s[ny][nx]=='X'){\n\tint c=M1[P(ny,nx)];\n\tif((1<<c)&b)break;\n\tb+=(1<<c);\n\tny+=dy[i];\n\tnx+=dx[i];\n      }\n      if(ny<20&&(nx==0||nx==w-1))continue;\n      if(d[ny][nx][b]==1)continue;\n      d[ny][nx][b]=1;\n      q.push(P2(P(ny*1000+nx,cost+1),b));\n      if(ny>=19){\n\tcout<<cost+1<<endl;\n\treturn 0;\n      }\n    }\n  }\n  cout<<-1<<endl;\n}\n\n"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2612\n  Title:\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n#define W 15\n#define H 19\n\nchar ban[H+1][W+1];\nchar line[W+1];\nint dir[3]={-1,0,1};\nint dirx[8]={1,1,0,-1,-1,-1, 0, 1};\nint diry[8]={0,1,1, 1, 0,-1,-1,-1};\n\nvoid white_stone(char ban[][W+1],int *yp,int *xp)\n{\n  int i,j;\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(ban[i][j]=='O')\n\t{ *yp=i,*xp=j;\n\t  return;\n\t}\n}\n\nint direct_goal(char ban[][W+1])\n{\n  int x,y,i,k,l;\n\n  white_stone(ban,&y,&x);\n  if(y==H-1)\n    return(0);\n  for(i=0;i<3;i++)\n    {\n      for(k=y+1,l=x+dir[i];k<H-1;k++,l+=dir[i])\n\t{\n\t  if(l<0 || l>W-1 || ban[k][l]!='X')\n\t    goto NEXT;\n\t}\n      return(1);\n    NEXT: ;\n    }\n  return(0);\n}\n\nint can_jump(char ban[][W+1],int d)\n{\n  int x,y,k,l,ren;\n\n  white_stone(ban,&y,&x);\n  ren=0;\n  for(k=y+diry[d],l=x+dirx[d];;k+=diry[d],l+=dirx[d])\n    {\n      if(l<0 || l>W-1 || k<0 || k> H-1)\n\treturn(0);\n      else if(ban[k][l]!='X')\n\tbreak;\n      else\n\tren++;\n    }\n  if(ren)\n    return(1);\n\n  return(0);\n}\n\nvoid jump(char ban[][W+1],int d)\n{\n  int x,y,k,l;\n\n  white_stone(ban,&y,&x);\n  //printf(\" j w s=%d %d|\",y,x);\n\n  ban[y][x]='.';\n  for(k=y+diry[d],l=x+dirx[d];;k+=diry[d],l+=dirx[d])\n    {\n      if(ban[k][l]=='X')\n\tban[k][l]='.';\n      else\n\t{\n\t  ban[k][l]='O';\n\t  break;\n\t}\n    }\n  \n}\n\nint solve(char ban[][W+1])\n{\n  int i,min_,d;\n  char my_ban[H+1][W+1];\n\n  if(direct_goal(ban))\n    return(1);\n\n  min_=1000;\n  for(d=0;d<8;d++)\n    if(can_jump(ban,d))\n      {\n\tmemcpy(my_ban,ban,sizeof(my_ban));\n\tjump(my_ban,d);\n\tmin_=min(min_,1+solve(my_ban));\n      }\n  return(min_);\n}\n\n\nmain()\n{\n  int i,ret;\n  \n  for(i=0;i<H;i++)\n    scanf(\"%s\",&ban[i][0]);\n  ret=solve(ban);\n\n  if(ret==1000)\n    printf(\"-1\\n\");\n  else\n    printf(\"%d\\n\",ret);\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2612\n  Title:\n  @kankichi573\n  2015/9/14 WA 38/93\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n#define W 15\n#define H 19\n\nchar ban[H+1][W+1];\nchar line[W+1];\nint dir[3]={-1,0,1};\nint dirx[8]={1,1,0,-1,-1,-1, 0, 1};\nint diry[8]={0,1,1, 1, 0,-1,-1,-1};\n\nvoid white_stone(char ban[][W+1],int *yp,int *xp)\n{\n  int i,j;\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(ban[i][j]=='O')\n\t{ *yp=i,*xp=j;\n\t  return;\n\t}\n}\n\nint direct_goal(char ban[][W+1],int y,int x)\n{\n  int i,k,l,ret;\n\n  if(y==H-2)\n    if((x>0 && ban[y+1][x-1]=='X')||ban[y+1][x]=='X'||\n       (x<W-1 && ban[y+1][x+1]=='X'))\n      return(1);\n    else\n      return(0);\n\n  for(i=0;i<3;i++)\n    {\n    for(k=y+1,l=x+dir[i];;k++,l+=dir[i])\n      {\n\tif(k >= H-1)\n\t  return(1);\n\tif((k==H-2 && (l<=0 && i==0)||(l>=W-1 && i==2)) || ban[k][l] != 'X')\n\t  goto NEXT;\n      }\n    NEXT: ;\n    }\n  return(0);\n}\n\nint can_jump(char ban[][W+1],int d,int y,int x)\n{\n  int k,l,ren;\n\n\n  ren=0;\n  for(k=y+diry[d],l=x+dirx[d];;k+=diry[d],l+=dirx[d])\n    {\n\n      if(l<0 || l>W-1 || k<0 || k> H-1)\n\treturn(0);\n      else if(ban[k][l]!='X')\n\tbreak;\n      else\n\tren++;\n    }\n  if(ren)\n    return(1);\n\n  return(0);\n}\n\nvoid jump(char ban[][W+1],int d,int *yp,int *xp)\n{\n  int k,l,y,x;\n\n  y=*yp,x=*xp;\n  ban[y][x]='.';\n  for(k=y+diry[d],l=x+dirx[d];;k+=diry[d],l+=dirx[d])\n    {\n      if(ban[k][l]=='X')\n\tban[k][l]='.';\n      else\n\t{\n\t  ban[k][l]='O';\n\t  break;\n\t}\n    }\n  *yp=k,*xp=l;\n}\nvoid print_ban(char ban[][W+1])\n{\n  int i;\n  printf(\"\\n\");\n  for(i=0;i<H;i++)\n    printf(\"%s\\n\",&ban[i][0]);\n  printf(\"\\n\");\n}\n\nint solve(char ban[][W+1],int y,int x)\n{\n  int i,min_,d,y0,x0;\n  char my_ban[H+1][W+1];\n\n  if(direct_goal(ban,y,x))\n    return(1);\n\n  min_=1000;\n  for(d=0;d<8;d++)\n    {\n      \n      if(can_jump(ban,d,y,x))\n      {\n\tmemcpy(my_ban,ban,sizeof(my_ban));\n\ty0=y,x0=x;\n\tjump(my_ban,d,&y0,&x0);\n\t//print_ban(my_ban);\n\tmin_=min(min_,1+solve(my_ban,y0,x0));\n      }\n    }\n  return(min_);\n}\n\n\nmain()\n{\n  int i,ret,y,x;\n  \n  for(i=0;i<H;i++)\n    scanf(\"%s\",&ban[i][0]);\n\n\n  white_stone(ban,&y,&x);\n\n  ret=solve(ban,y,x);\n    \n  if(ret==1000)\n    printf(\"-1\\n\");\n  else\n    printf(\"%d\\n\",ret);\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2612\n  Title:\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n#define W 15\n#define H 19\n\nchar ban[H+1][W+1];\nchar line[W+1];\nint dir[3]={-1,0,1};\nint dirx[8]={1,1,0,-1,-1,-1, 0, 1};\nint diry[8]={0,1,1, 1, 0,-1,-1,-1};\n\nvoid white_stone(char ban[][W+1],int *yp,int *xp)\n{\n  int i,j;\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(ban[i][j]=='O')\n\t{ *yp=i,*xp=j;\n\t  return;\n\t}\n}\n\nint direct_goal(char ban[][W+1])\n{\n  int x,y,i,k,l;\n\n  white_stone(ban,&y,&x);\n\n  //printf(\"w s=%d %d\\n\",y,x);\n\n  if(y==H-1)\n    return(0);\n  if(y==H-2 && ban[y+1][x-1]!='X' && ban[y+1][x]!='X' && ban[y+1][x+1]!='X')\n    return(0);\n  for(i=0;i<3;i++)\n    {\n      for(k=y+1,l=x+dir[i];k<H-1;k++,l+=dir[i])\n\t{\n\t  //printf(\"y x s=%d %d %c|\",k,l,ban[k][l]);\n\t  if(l<0 || l>W-1 || ban[k][l]!='X')\n\t    goto NEXT;\n\t}\n      return(1);\n    NEXT: ;\n    }\n  return(0);\n}\n\nint can_jump(char ban[][W+1],int d)\n{\n  int x,y,k,l,ren;\n\n  white_stone(ban,&y,&x);\n  //printf(\"w s=%d %d|\",y,x);\n  ren=0;\n  for(k=y+diry[d],l=x+dirx[d];;k+=diry[d],l+=dirx[d])\n    {\n      //printf(\"y x s=%d %d %c|\",k,l,ban[k][l]);\n      if(l<0 || l>W-1 || k<0 || k> H-1)\n\treturn(0);\n      else if(ban[k][l]!='X')\n\tbreak;\n      else\n\tren++;\n    }\n  if(ren)\n    return(1);\n\n  return(0);\n}\n\nvoid jump(char ban[][W+1],int d)\n{\n  int x,y,k,l;\n\n  white_stone(ban,&y,&x);\n  //printf(\" j w s=%d %d|\",y,x);\n\n  ban[y][x]='.';\n  for(k=y+diry[d],l=x+dirx[d];;k+=diry[d],l+=dirx[d])\n    {\n      //printf(\"y x s=%d %d %c|\",k,l,ban[k][l]);\n\n      if(ban[k][l]=='X')\n\tban[k][l]='.';\n      else\n\t{\n\t  ban[k][l]='O';\n\t  break;\n\t}\n    }\n  \n}\nvoid print_ban(char ban[][W+1])\n{\n  int i;\n  printf(\"\\n\");\n  for(i=0;i<H;i++)\n    printf(\"%s\\n\",&ban[i][0]);\n  printf(\"\\n\");\n}\nint solve(char ban[][W+1])\n{\n  int i,min_,d;\n  char my_ban[H+1][W+1];\n\n  if(direct_goal(ban))\n    return(1);\n\n  min_=1000;\n  for(d=0;d<8;d++)\n    if(can_jump(ban,d))\n      {\n\t//printf(\"dir =%d OK\\n\",d);\n\tmemcpy(my_ban,ban,sizeof(my_ban));\n\tjump(my_ban,d);\n\t//print_ban(my_ban);\n\t\n\tmin_=min(min_,1+solve(my_ban));\n\t  \n      }\n  //else\n  //    printf(\"dir =%d NG\\n\",d);\n  return(min_);\n}\n\n\nmain()\n{\n  int i,ret;\n  \n  for(i=0;i<H;i++)\n    scanf(\"%s\",&ban[i][0]);\n\n  ret=solve(ban);\n\n  //printf(\"%d\\n\",direct_goal(ban));\n  \n  if(ret==1000)\n    printf(\"-1\\n\");\n  else\n    printf(\"%d\\n\",ret);\n  \n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2612\n  Title:Phutball\n  @kankichi573\n  2015/9/14 WA 38/93\n  2015/9/15 TLE 91/93\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n#define W 15\n#define H 19\n\nchar ban[H+1][W+1];\nchar line[W+1];\nint dir[3]={-1,0,1};\nint dirx[8]={1,1,0,-1,-1,-1, 0, 1};\nint diry[8]={0,1,1, 1, 0,-1,-1,-1};\nint min_;\n\nvoid white_stone(char ban[][W+1],int *yp,int *xp)\n{\n  int i,j;\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(ban[i][j]=='O')\n\t{ *yp=i,*xp=j;\n\t  return;\n\t}\n}\n\nint direct_goal(char ban[][W+1],int y,int x)\n{\n  int i,k,l,ret;\n\n  if(y==H-2)\n    if((x>0 && ban[y+1][x-1]=='X')||ban[y+1][x]=='X'||\n       (x<W-1 && ban[y+1][x+1]=='X'))\n      return(1);\n    else\n      return(0);\n\n  for(i=0;i<3;i++)\n    {\n    for(k=y+1,l=x+dir[i];;k++,l+=dir[i])\n      {\n\tif(k >= H-1)\n\t  return(1);\n\tif((k==H-2 && (l<=0 && i==0)||(l>=W-1 && i==2)) || ban[k][l] != 'X')\n\t  goto NEXT;\n      }\n    NEXT: ;\n    }\n  return(0);\n}\n\nint can_jump(char ban[][W+1],int d,int y,int x)\n{\n  int k,l,ren;\n\n\n  ren=0;\n  for(k=y+diry[d],l=x+dirx[d];;k+=diry[d],l+=dirx[d])\n    {\n\n      if(l<0 || l>W-1 || k<0 || k> H-1)\n\treturn(0);\n      else if(ban[k][l]!='X')\n\tbreak;\n      else\n\tren++;\n    }\n  if(ren)\n    return(1);\n\n  return(0);\n}\n\nvoid jump(char ban[][W+1],int d,int *yp,int *xp)\n{\n  int k,l,y,x;\n\n  y=*yp,x=*xp;\n  ban[y][x]='.';\n  for(k=y+diry[d],l=x+dirx[d];;k+=diry[d],l+=dirx[d])\n    {\n      if(ban[k][l]=='X')\n\tban[k][l]='.';\n      else\n\t{\n\t  ban[k][l]='O';\n\t  break;\n\t}\n    }\n  *yp=k,*xp=l;\n}\nvoid print_ban(char ban[][W+1])\n{\n  int i;\n  printf(\"\\n\");\n  for(i=0;i<H;i++)\n    printf(\"%s\\n\",&ban[i][0]);\n  printf(\"\\n\");\n}\n\nvoid solve(char ban[][W+1],int y,int x,int lv)\n{\n  int i,d,y0,x0;\n  char my_ban[H+1][W+1];\n\n  if(lv+1 >= min_)\n    return;\n\n  if(direct_goal(ban,y,x))\n    min_=min(min_,lv+1);\n\n  for(d=0;d<8;d++)\n    {\n      \n      if(can_jump(ban,d,y,x))\n      {\n\tmemcpy(my_ban,ban,sizeof(my_ban));\n\ty0=y,x0=x;\n\tjump(my_ban,d,&y0,&x0);\n\t//print_ban(my_ban);\n\tsolve(my_ban,y0,x0,lv+1);\n      }\n    }\n}\n\n\nmain()\n{\n  int i,y,x;\n  \n  for(i=0;i<H;i++)\n    scanf(\"%s\",&ban[i][0]);\n  white_stone(ban,&y,&x);\n\n  min_=1000;\n  solve(ban,y,x,0);\n    \n  if(min_==1000)\n    printf(\"-1\\n\");\n  else\n    printf(\"%d\\n\",min_);\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2612\n  Title:Phutball\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n#define W 15\n#define H 19\n\nchar ban[H+1][W+1];\nchar line[W+1];\nint dir[3]={-1,0,1};\nint dirx[8]={1,1,0,-1,-1,-1, 0, 1};\nint diry[8]={0,1,1, 1, 0,-1,-1,-1};\n\nvoid white_stone(char ban[][W+1],int *yp,int *xp)\n{\n  int i,j;\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(ban[i][j]=='O')\n\t{ *yp=i,*xp=j;\n\t  return;\n\t}\n}\n\nint direct_goal(char ban[][W+1])\n{\n  int x,y,i,k,l;\n\n  white_stone(ban,&y,&x);\n  if(y==H-1)\n    return(0);\n  for(i=0;i<3;i++)\n    {\n      for(k=y+1,l=x+dir[i];k<H;k++,l+=dir[i])\n\t{\n\t  if(l<0 || l>W-1 || ban[k][l]!='X')\n\t    goto NEXT;\n\t}\n      return(1);\n    NEXT: ;\n    }\n  return(0);\n}\n\nint can_jump(char ban[][W+1],int d)\n{\n  int x,y,k,l,ren;\n\n  white_stone(ban,&y,&x);\n  ren=0;\n  for(k=y+diry[d],l=x+dirx[d];;k+=diry[d],l+=dirx[d])\n    {\n      if(l<0 || l>W-1 || k<0 || k> H-1)\n\treturn(0);\n      else if(ban[k][l]!='X')\n\tbreak;\n      else\n\tren++;\n    }\n  if(ren)\n    return(1);\n\n  return(0);\n}\n\nvoid jump(char ban[][W+1],int d)\n{\n  int x,y,k,l;\n\n  white_stone(ban,&y,&x);\n  //printf(\" j w s=%d %d|\",y,x);\n\n  ban[y][x]='.';\n  for(k=y+diry[d],l=x+dirx[d];;k+=diry[d],l+=dirx[d])\n    {\n      if(ban[k][l]=='X')\n\tban[k][l]='.';\n      else\n\t{\n\t  ban[k][l]='O';\n\t  break;\n\t}\n    }\n  \n}\n\nint solve(char ban[][W+1])\n{\n  int i,min_,d;\n  char my_ban[H+1][W+1];\n\n  if(direct_goal(ban))\n    return(1);\n\n  min_=1000;\n  for(d=0;d<8;d++)\n    if(can_jump(ban,d))\n      {\n\tmemcpy(my_ban,ban,sizeof(my_ban));\n\tjump(my_ban,d);\n\tmin_=min(min_,1+solve(my_ban));\n      }\n  return(min_);\n}\n\n\nmain()\n{\n  int i,ret;\n  \n  for(i=0;i<H;i++)\n    scanf(\"%s\",&ban[i][0]);\n  ret=solve(ban);\n\n  if(ret==1000)\n    printf(\"-1\\n\");\n  else\n    printf(\"%d\\n\",ret);\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2612\n  Title:\n  @kankichi573\n  2015/9/14 WA 38/93\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\n#define W 15\n#define H 19\n\nchar ban[H+1][W+1];\nchar line[W+1];\nint dir[3]={-1,0,1};\nint dirx[8]={1,1,0,-1,-1,-1, 0, 1};\nint diry[8]={0,1,1, 1, 0,-1,-1,-1};\n\nvoid white_stone(char ban[][W+1],int *yp,int *xp)\n{\n  int i,j;\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(ban[i][j]=='O')\n\t{ *yp=i,*xp=j;\n\t  return;\n\t}\n}\n\nint direct_goal(char ban[][W+1],int y,int x)\n{\n  int i,k,l,ret;\n\n  if(y==H-2)\n    if((x>0 && ban[y+1][x-1]=='X')||ban[y+1][x]=='X'||\n       (x<W-1 && ban[y+1][x+1]=='X'))\n      return(1);\n    else\n      return(0);\n\n  for(i=0;i<3;i++)\n    {\n    for(k=y+1,l=x+dir[i];;k++,l+=dir[i])\n      {\n\tif(k >= H-1)\n\t  return(1);\n\tif((k==H-2 && (l<=0 || l>=W-1)) || ban[k][l] != 'X')\n\t  goto NEXT;\n      }\n    NEXT: ;\n    }\n  return(0);\n}\n\nint can_jump(char ban[][W+1],int d,int y,int x)\n{\n  int k,l,ren;\n\n\n  ren=0;\n  for(k=y+diry[d],l=x+dirx[d];;k+=diry[d],l+=dirx[d])\n    {\n\n      if(l<0 || l>W-1 || k<0 || k> H-1)\n\treturn(0);\n      else if(ban[k][l]!='X')\n\tbreak;\n      else\n\tren++;\n    }\n  if(ren)\n    return(1);\n\n  return(0);\n}\n\nvoid jump(char ban[][W+1],int d,int *yp,int *xp)\n{\n  int k,l,y,x;\n\n  y=*yp,x=*xp;\n  ban[y][x]='.';\n  for(k=y+diry[d],l=x+dirx[d];;k+=diry[d],l+=dirx[d])\n    {\n      if(ban[k][l]=='X')\n\tban[k][l]='.';\n      else\n\t{\n\t  ban[k][l]='O';\n\t  break;\n\t}\n    }\n  *yp=k,*xp=l;\n}\nvoid print_ban(char ban[][W+1])\n{\n  int i;\n  printf(\"\\n\");\n  for(i=0;i<H;i++)\n    printf(\"%s\\n\",&ban[i][0]);\n  printf(\"\\n\");\n}\n\nint solve(char ban[][W+1],int y,int x)\n{\n  int i,min_,d,y0,x0;\n  char my_ban[H+1][W+1];\n\n  if(direct_goal(ban,y,x))\n    return(1);\n\n  min_=1000;\n  for(d=0;d<8;d++)\n    {\n      \n      if(can_jump(ban,d,y,x))\n      {\n\t//printf(\"dir=%d OK|\",d);\n\tmemcpy(my_ban,ban,sizeof(my_ban));\n\ty0=y,x0=x;\n\tjump(my_ban,d,&y0,&x0);\n\t//print_ban(my_ban);\n\tmin_=min(min_,1+solve(my_ban,y0,x0));\n      }\n    }\n  return(min_);\n}\n\n\nmain()\n{\n  int i,ret,y,x;\n  \n  for(i=0;i<H;i++)\n    scanf(\"%s\",&ban[i][0]);\n\n\n  white_stone(ban,&y,&x);\n\n  ret=solve(ban,y,x);\n    \n  if(ret==1000)\n    printf(\"-1\\n\");\n  else\n    printf(\"%d\\n\",ret);\n  return(0);\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  //  int[][][] memo = new int[19][15][1 << 20];\n//  boolean[][][] done = new boolean[19][15][1 << 20];\n  char[][] field = new char[19][15];\n  int[][] index = new int[19][15];\n\n  int[][] ofs = {\n      {0, 1},\n      {0, -1},\n      {1, 0},\n      {-1, 0},\n      {1, 1},\n      {1, -1},\n      {-1, 1},\n      {-1, -1}\n  };\n\n  int dfs(int x, int y, int bits) {\n//    debug(x, y, Integer.toBinaryString(bits));\n    if (y >= 19) {\n      return 0;\n    }\n    if (x < 0 || 15 <= x || y < 0) {\n      return INF;\n    }\n    if (y >= 18) {\n      return 0;\n    }\n//    if (done[y][x][bits]) {\n//      return memo[y][x][bits];\n//    }\n    int min = INF;\n    for (int[] d : ofs) {\n      int nx = x;\n      int ny = y;\n      int nbits = bits;\n      boolean flag = false;\n      for (; ; ) {\n        nx += d[0];\n        ny += d[1];\n        if (nx < 0 || 15 <= nx || ny < 0 || 19 <= ny) {\n          break;\n        }\n        if (field[ny][nx] != 'X' || ((bits >> index[ny][nx]) & 1) == 0) {\n          break;\n        }\n        flag |= true;\n        nbits &= ~(1 << index[ny][nx]);\n      }\n      if (flag) {\n        min = Math.min(min, dfs(nx, ny, nbits) + 1);\n      }\n    }\n//    done[y][x][bits] = true;\n//    return memo[y][x][bits] = min;\n    return min;\n  }\n\n  void run() {\n    for (int[] a : index) Arrays.fill(a, -1);\n    int count = 0;\n    int sx = -1, sy = -1;\n    for (int i = 0; i < 19; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 15; ++j) {\n        field[i][j] = str.charAt(j);\n        if (field[i][j] == 'X') {\n          index[i][j] = count++;\n        }\n        if (field[i][j] == 'O') {\n          sx = j;\n          sy = i;\n        }\n      }\n    }\n    int v = dfs(sx, sy, (1 << count) - 1);\n    System.out.println(v == INF ? -1 : v);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n//  int[][][] memo = new int[19][15][1 << 20];\n//  boolean[][][] done = new boolean[19][15][1 << 20];\n  char[][] field = new char[19][15];\n  int[][] index = new int[19][15];\n\n  int[][] ofs = {\n      {0, 1},\n      {0, -1},\n      {1, 0},\n      {-1, 0},\n      {1, 1},\n      {1, -1},\n      {-1, 1},\n      {-1, -1}\n  };\n\n  int dfs(int x, int y, int bits) {\n//    debug(x, y, Integer.toBinaryString(bits));\n    if (y >= 19) {\n      return 0;\n    }\n    if (x < 0 || 15 <= x || y < 0) {\n      return INF;\n    }\n//    if (done[y][x][bits]) {\n//      return memo[y][x][bits];\n//    }\n    int min = INF;\n    for (int[] d : ofs) {\n      int nx = x;\n      int ny = y;\n      int nbits = bits;\n      boolean flag = false;\n      for (; ; ) {\n        nx += d[0];\n        ny += d[1];\n        if (nx < 0 || 15 <= nx || ny < 0 || 19 <= ny) {\n          break;\n        }\n        if (field[ny][nx] != 'X' || ((bits >> index[ny][nx]) & 1) == 0) {\n          break;\n        }\n        flag |= true;\n        nbits &= ~(1 << index[ny][nx]);\n      }\n      if (flag) {\n        min = Math.min(min, dfs(nx, ny, nbits) + 1);\n      }\n    }\n//    done[y][x][bits] = true;\n//    return memo[y][x][bits] = min;\n    return min;\n  }\n\n  void run() {\n    for (int[] a : index) Arrays.fill(a, -1);\n    int count = 0;\n    int sx = -1, sy = -1;\n    for (int i = 0; i < 19; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 15; ++j) {\n        field[i][j] = str.charAt(j);\n        if (field[i][j] == 'X') {\n          index[i][j] = count++;\n        }\n        if (field[i][j] == 'O') {\n          sx = j;\n          sy = i;\n        }\n      }\n    }\n    int v = dfs(sx, sy, (1 << count) - 1);\n    System.out.println(v == INF ? -1 : v);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int[][][] memo = new int[19][15][1 << 20];\n  boolean[][][] done = new boolean[19][15][1 << 20];\n  char[][] field = new char[19][15];\n  int[][] index = new int[19][15];\n\n  int[][] ofs = {\n      {0, 1},\n      {0, -1},\n      {1, 0},\n      {-1, 0},\n      {1, 1},\n      {1, -1},\n      {-1, 1},\n      {-1, -1}\n  };\n\n  int dfs(int x, int y, int bits) {\n//    debug(x, y, Integer.toBinaryString(bits));\n    if (y >= 19) {\n      return 0;\n    }\n    if (x < 0 || 15 <= x || y < 0) {\n      return INF;\n    }\n    if (done[y][x][bits]) {\n      return memo[y][x][bits];\n    }\n    int min = INF;\n    for (int[] d : ofs) {\n      int nx = x;\n      int ny = y;\n      int nbits = bits;\n      boolean flag = false;\n      for (; ; ) {\n        nx += d[0];\n        ny += d[1];\n        if (nx < 0 || 15 <= nx || ny < 0 || 19 <= ny) {\n          break;\n        }\n        if (field[ny][nx] != 'X' || ((bits >> index[ny][nx]) & 1) == 0) {\n          break;\n        }\n        flag |= true;\n        nbits &= ~(1 << index[ny][nx]);\n      }\n      if (flag) {\n        min = Math.min(min, dfs(nx, ny, nbits) + 1);\n      }\n    }\n    done[y][x][bits] = true;\n    return memo[y][x][bits] = min;\n  }\n\n  void run() {\n    for (int[] a : index) Arrays.fill(a, -1);\n    int count = 0;\n    int sx = -1, sy = -1;\n    for (int i = 0; i < 19; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 15; ++j) {\n        field[i][j] = str.charAt(j);\n        if (field[i][j] == 'X') {\n          index[i][j] = count++;\n        }\n        if (field[i][j] == 'O') {\n          sx = j;\n          sy = i;\n        }\n      }\n    }\n    int v = dfs(sx, sy, (1 << count) - 1);\n    System.out.println(v == INF ? -1 : v);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n//  int[][][] memo = new int[19][15][1 << 20];\n//  boolean[][][] done = new boolean[19][15][1 << 20];\n  char[][] field = new char[19][15];\n  int[][] index = new int[19][15];\n\n  int[][] ofs = {\n      {0, 1},\n      {0, -1},\n      {1, 0},\n      {-1, 0},\n      {1, 1},\n      {1, -1},\n      {-1, 1},\n      {-1, -1}\n  };\n\n  int dfs(int x, int y, int bits) {\n//    debug(x, y, Integer.toBinaryString(bits));\n    if (y >= 18) {\n      return 0;\n    }\n    if (x < 0 || 15 <= x || y < 0) {\n      return INF;\n    }\n//    if (done[y][x][bits]) {\n//      return memo[y][x][bits];\n//    }\n    int min = INF;\n    for (int[] d : ofs) {\n      int nx = x;\n      int ny = y;\n      int nbits = bits;\n      boolean flag = false;\n      for (; ; ) {\n        nx += d[0];\n        ny += d[1];\n        if (nx < 0 || 15 <= nx || ny < 0 || 19 <= ny) {\n          break;\n        }\n        if (field[ny][nx] != 'X' || ((bits >> index[ny][nx]) & 1) == 0) {\n          break;\n        }\n        flag |= true;\n        nbits &= ~(1 << index[ny][nx]);\n      }\n      if (flag) {\n        min = Math.min(min, dfs(nx, ny, nbits) + 1);\n      }\n    }\n//    done[y][x][bits] = true;\n//    return memo[y][x][bits] = min;\n    return min;\n  }\n\n  void run() {\n    for (int[] a : index) Arrays.fill(a, -1);\n    int count = 0;\n    int sx = -1, sy = -1;\n    for (int i = 0; i < 19; ++i) {\n      String str = sc.next();\n      for (int j = 0; j < 15; ++j) {\n        field[i][j] = str.charAt(j);\n        if (field[i][j] == 'X') {\n          index[i][j] = count++;\n        }\n        if (field[i][j] == 'O') {\n          sx = j;\n          sy = i;\n        }\n      }\n    }\n    int v = dfs(sx, sy, (1 << count) - 1);\n    System.out.println(v == INF ? -1 : v);\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nW = 15\nH = 19\nBLACK = 1\nEMPTY = 0\nOUT = -1\nGOAL = -2\n\nclass Board\n    def initialize\n        @bits = 0\n        y_max = 0\n        H.times do |i|\n            s = gets.chomp\n            (0..W-1).each do |j|\n                if s[j] == ?O\n                    @y = i\n                    @x = j\n                end\n                if s[j] == ?X\n                    y_max = i\n                end\n            end\n            s.reverse!\n            x = s.gsub(/./) {|c| c == ?X ? ?1 : ?0}.to_i(2)\n            @bits += (x << W * i)\n        end\n        if y_max <= H - 3 && @y <= H - 2\n            puts -1\n            exit\n        end\n        @depth = 0\n    end\n\n    def jump(dx, dy)\n        return unless get(@x+dx, @y+dy) == BLACK\n        loop do\n            @x += dx\n            @y += dy\n            break if get(@x, @y) != BLACK\n            @bits -= (1 << @y * W + @x)\n        end\n        @depth += 1\n    end\n\n    def get(x, y)\n        return OUT if x < 0 or x >= W or y < 0 or y >= H\n        return @bits[y * W + x]\n    end\n\n    def hash\n        (@bits << 10) + (@y << 5) + @x\n    end\n\n    def eql?(other)\n        hash == other.hash\n    end\n\n    def goal?\n        @y >= H or (@y == H-1 && @x >= 0 && y <= W-1)\n    end\n\n    def out?\n        get(@x, @y) == OUT\n    end\n\n    def inspect\n        super.inspect + (0..H-1).map {|i| (0..W-1).map {|j| @x == j && @y == i ? ?X : @bits[i*W+j].to_s}.join + \"\\n\"}.join\n    end\n\n    attr_reader :depth\nend\n\nb = Board.new\nqueue = [b]\nreached = Set[b]\n\nuntil queue.empty?\n    b0 = queue.shift\n    [-1, 0, 1].repeated_permutation(2).each do |dx, dy|\n        next if dx == 0 && dy == 0\n        b = b0.dup\n        b.jump(dx, dy)\n        next if reached.include?(b)\n        if b.goal?\n            puts b.depth\n            exit\n        end\n        next if b.out?\n        reached << b\n        queue << b\n    end\nend\n\nputs -1"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nW = 15\nH = 19\nBLACK = 1\nEMPTY = 0\nOUT = -1\nGOAL = -2\n\nclass Board\n    def initialize\n        @bits = 0\n        H.times do |i|\n            s = gets.chomp\n            (0..W-1).each do |j|\n                if s[j] == ?O\n                    @y = i\n                    @x = j\n                end\n            end\n            s.reverse!\n            x = s.gsub(/./) {|c| c == ?X ? ?1 : ?0}.to_i(2)\n            @bits += (x << W * i)\n        end\n        @depth = 0\n    end\n\n    def jump(dx, dy)\n        return unless get(@x+dx, @y+dy) == BLACK\n        loop do\n            @x += dx\n            @y += dy\n            break if get(@x, @y) != BLACK\n            @bits -= (1 << @y * W + @x)\n        end\n        @depth += 1\n    end\n\n    def get(x, y)\n        return GOAL if y >= H\n        return OUT if x < 0 or x >= W or y < 0\n        return @bits[y * W + x]\n    end\n\n    def hash\n        (@bits << 10) + (@x << 5) + @y\n    end\n\n    def eql?(other)\n        hash == other.hash\n    end\n\n    def goal?\n        get(@x, @y) == GOAL\n    end\n\n    def out?\n        get(@x, @y) == OUT\n    end\n\n    attr_reader :depth\nend\n\nb = Board.new\nqueue = [b]\nreached = Set[b]\n\nuntil queue.empty?\n    b0 = queue.shift\n    [-1, 0, 1].repeated_permutation(2).each do |dx, dy|\n        next if dx == 0 && dy == 0\n        b = b0.dup\n        b.jump(dx, dy)\n        next if reached.include?(b) or b.out?\n        if b.goal?\n            puts b.depth\n            exit\n        end\n        reached << b\n        queue << b\n    end\nend\nputs -1"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nW = 15\nH = 19\nBLACK = 1\nEMPTY = 0\nOUT = -1\nGOAL = -2\n\nclass Board\n    def initialize\n        @bits = 0\n        H.times do |i|\n            s = gets.chomp\n            (0..W-1).each do |j|\n                if s[j] == ?O\n                    @y = i\n                    @x = j\n                end\n            end\n            s.reverse!\n            x = s.gsub(/./) {|c| c == ?X ? ?1 : ?0}.to_i(2)\n            @bits += (x << W * i)\n        end\n        @depth = 0\n    end\n\n    def jump(dx, dy)\n        return unless get(@x+dx, @y+dy) == BLACK\n        loop do\n            @x += dx\n            @y += dy\n            break if get(@x, @y) != BLACK\n            @bits -= (1 << @y * W + @x)\n        end\n        @depth += 1\n    end\n\n    def get(x, y)\n        return GOAL if y >= H\n        return OUT if x < 0 or x >= W or y < 0\n        return @bits[y * W + x]\n    end\n\n    def hash\n        (@bits << 10) + (@x << 5) + @y\n    end\n\n    def eql?(other)\n        hash == other.hash\n    end\n\n    def goal?\n        get(@x, @y) == GOAL\n    end\n\n    def out?\n        get(@x, @y) == OUT\n    end\n\n    attr_reader :depth\nend\n\nb = Board.new\nqueue = [b]\nreached = Set[b]\n\nuntil queue.empty?\n    b0 = queue.shift\n    [-1, 0, 1].repeated_permutation(2).each do |dx, dy|\n        next if dx == 0 && dy == 0\n        b = b0.dup\n        b.jump(dx, dy)\n        next if reached.include?(b) or b.out?\n        if b.goal?\n            puts b.depth\n            exit\n        end\n        reached << b\n        queue << b\n    end\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nW = 15\nH = 19\nBLACK = 1\nEMPTY = 0\nOUT = -1\nGOAL = -2\n\nclass Board\n    def initialize\n        @bits = 0\n        y_max = 0\n        H.times do |i|\n            s = gets.chomp\n            (0..W-1).each do |j|\n                if s[j] == ?O\n                    @y = i\n                    @x = j\n                end\n                if s[j] == ?X\n                    y_max = i\n                end\n            end\n            s.reverse!\n            x = s.gsub(/./) {|c| c == ?X ? ?1 : ?0}.to_i(2)\n            @bits += (x << W * i)\n        end\n        if y_max <= H - 3 && @y <= H - 2\n            puts -1\n            exit\n        end\n        @depth = 0\n    end\n\n    def jump(dx, dy)\n        return unless get(@x+dx, @y+dy) == BLACK\n        loop do\n            @x += dx\n            @y += dy\n            break if get(@x, @y) != BLACK\n            @bits -= (1 << @y * W + @x)\n        end\n        @depth += 1\n    end\n\n    def get(x, y)\n        return OUT if x < 0 or x >= W or y < 0 or y >= H\n        return @bits[y * W + x]\n    end\n\n    def hash\n        (@bits << 9) + (@y << 4) + @x\n    end\n\n    def eql?(other)\n        hash == other.hash\n    end\n\n    def goal?\n        @y >= H - 1\n    end\n\n    def out?\n        get(@x, @y) == OUT\n    end\n\n    attr_reader :depth\nend\n\nb = Board.new\nqueue = [b]\nreached = Set[b]\n\nuntil queue.empty?\n    b0 = queue.shift\n    [-1, 0, 1].repeated_permutation(2).each do |dx, dy|\n        next if dx == 0 && dy == 0\n        b = b0.dup\n        b.jump(dx, dy)\n        next if reached.include?(b)\n        if b.goal?\n            puts b.depth\n            exit\n        end\n        next if b.out?\n        reached << b\n        queue << b\n    end\nend\n\nputs -1"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nW = 15\nH = 19\nBLACK = 1\nEMPTY = 0\nOUT = -1\nGOAL = -2\n\nclass Board\n    def initialize\n        @bits = 0\n        H.times do |i|\n            s = gets.chomp\n            (0..W-1).each do |j|\n                if s[j] == ?O\n                    @y = i\n                    @x = j\n                end\n            end\n            s.reverse!\n            x = s.gsub(/./) {|c| c == ?X ? ?1 : ?0}.to_i(2)\n            @bits += (x << W * i)\n        end\n        @depth = 0\n    end\n\n    def jump(dx, dy)\n        return unless get(@x+dx, @y+dy) == BLACK\n        loop do\n            @x += dx\n            @y += dy\n            break if get(@x, @y) != BLACK\n            @bits -= (1 << @y * W + @x)\n        end\n        @depth += 1\n    end\n\n    def get(x, y)\n        return GOAL if y >= H\n        return OUT if x < 0 or x >= W or y < 0\n        return @bits[y * W + x]\n    end\n\n    def hash\n        (@x << 5) + @y\n    end\n\n    def eql?(other)\n        hash == other.hash\n    end\n\n    def goal?\n        @y >= H - 1\n    end\n\n    def out?\n        get(@x, @y) == OUT\n    end\n\n    attr_reader :depth\nend\n\nb = Board.new\nqueue = [b]\nreached = Set[b]\n\nuntil queue.empty?\n    b0 = queue.shift\n    [-1, 0, 1].repeated_permutation(2).each do |dx, dy|\n        next if dx == 0 && dy == 0\n        b = b0.dup\n        b.jump(dx, dy)\n        next if reached.include?(b) or b.out?\n        if b.goal?\n            puts b.depth\n            exit\n        end\n        reached << b\n        queue << b\n    end\nend\nputs -1"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nW = 15\nH = 19\nBLACK = 1\nEMPTY = 0\nOUT = -1\nGOAL = -2\n\nclass Board\n    def initialize\n        @bits = 0\n        H.times do |i|\n            s = gets.chomp\n            (0..W-1).each do |j|\n                if s[j] == ?O\n                    @y = i\n                    @x = j\n                end\n            end\n            s.reverse!\n            x = s.gsub(/./) {|c| c == ?X ? ?1 : ?0}.to_i(2)\n            @bits += (x << W * i)\n        end\n        @depth = 0\n    end\n\n    def jump(dx, dy)\n        return unless get(@x+dx, @y+dy) == BLACK\n        loop do\n            @x += dx\n            @y += dy\n            break if get(@x, @y) != BLACK\n            @bits -= (1 << @y * W + @x)\n        end\n        @depth += 1\n    end\n\n    def get(x, y)\n        return GOAL if y >= H-1\n        return OUT if x < 0 or x >= W or y < 0\n        return @bits[y * W + x]\n    end\n\n    def hash\n        (@bits << 10) + (@x << 5) + @y\n    end\n\n    def eql?(other)\n        hash == other.hash\n    end\n\n    def goal?\n        get(@x, @y) == GOAL\n    end\n\n    def out?\n        get(@x, @y) == OUT\n    end\n\n    attr_reader :depth\nend\n\nb = Board.new\nqueue = [b]\nreached = Set[b]\n\nuntil queue.empty?\n    b0 = queue.shift\n    [-1, 0, 1].repeated_permutation(2).each do |dx, dy|\n        next if dx == 0 && dy == 0\n        b = b0.dup\n        b.jump(dx, dy)\n        next if reached.include?(b) or b.out?\n        if b.goal?\n            puts b.depth\n            exit\n        end\n        reached << b\n        queue << b\n    end\nend\nputs -1"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nW = 15\nH = 19\nBLACK = 1\nEMPTY = 0\nOUT = -1\nGOAL = -2\n\nclass Board\n    def initialize\n        @bits = 0\n        H.times do |i|\n            s = gets.chomp\n            (0..W-1).each do |j|\n                if s[j] == ?O\n                    @y = i\n                    @x = j\n                end\n            end\n            s.reverse!\n            x = s.gsub(/./) {|c| c == ?X ? ?1 : ?0}.to_i(2)\n            @bits += (x << W * i)\n        end\n        @depth = 0\n    end\n\n    def jump(dx, dy)\n        return unless get(@x+dx, @y+dy) == BLACK\n        loop do\n            @x += dx\n            @y += dy\n            break if get(@x, @y) != BLACK\n            @bits -= (1 << @y * W + @x)\n        end\n        @depth += 1\n    end\n\n    def get(x, y)\n        return GOAL if y >= H\n        return OUT if x < 0 or x >= W or y < 0\n        return @bits[y * W + x]\n    end\n\n    def hash\n        (@bits << 10) + (@x << 5) + @y\n    end\n\n    def eql?(other)\n        hash == other.hash\n    end\n\n    def goal?\n        @y >= H - 1\n    end\n\n    def out?\n        get(@x, @y) == OUT\n    end\n\n    attr_reader :depth\nend\n\nb = Board.new\nqueue = [b]\nreached = Set[b]\n\nuntil queue.empty?\n    b0 = queue.shift\n    [-1, 0, 1].repeated_permutation(2).each do |dx, dy|\n        next if dx == 0 && dy == 0\n        b = b0.dup\n        b.jump(dx, dy)\n        next if reached.include?(b) or b.out?\n        if b.goal?\n            puts b.depth\n            exit\n        end\n        reached << b\n        queue << b\n    end\nend\nputs -1"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nW = 15\nH = 19\nBLACK = 1\nEMPTY = 0\nOUT = -1\nGOAL = -2\n\nclass Board\n    def initialize\n        @bits = 0\n        H.times do |i|\n            s = gets.chomp\n            (0..W-1).each do |j|\n                if s[j] == ?O\n                    @y = i\n                    @x = j\n                end\n            end\n            s.reverse!\n            x = s.gsub(/./) {|c| c == ?X ? ?1 : ?0}.to_i(2)\n            @bits += (x << W * i)\n        end\n        @depth = 0\n    end\n\n    def jump(dx, dy)\n        return unless get(@x+dx, @y+dy) == BLACK\n        loop do\n            @x += dx\n            @y += dy\n            break if get(@x, @y) != BLACK\n            @bits -= (1 << @y * W + @x)\n        end\n        @depth += 1\n    end\n\n    def get(x, y)\n        return GOAL if y >= H\n        return OUT if x < 0 or x >= W or y < 0\n        return @bits[y * W + x]\n    end\n\n    def hash\n        (@bits << 9) + (@y << 4) + @x\n    end\n\n    def eql?(other)\n        hash == other.hash\n    end\n\n    def goal?\n        @y >= H - 1\n    end\n\n    def out?\n        get(@x, @y) == OUT\n    end\n\n    attr_reader :depth\nend\n\nb = Board.new\nqueue = [b]\nreached = Set[b]\n\nuntil queue.empty?\n    b0 = queue.shift\n    [-1, 0, 1].repeated_permutation(2).each do |dx, dy|\n        next if dx == 0 && dy == 0\n        b = b0.dup\n        b.jump(dx, dy)\n        next if reached.include?(b) or b.out?\n        if b.goal?\n            puts b.depth\n            exit\n        end\n        reached << b\n        queue << b\n    end\nend\nputs -1"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nW = 15\nH = 19\nBLACK = 1\nEMPTY = 0\nOUT = -1\nGOAL = -2\n\nclass Board\n    def initialize\n        @bits = 0\ny_max = 0        \nH.times do |i|\n            s = gets.chomp\n            (0..W-1).each do |j|\n                if s[j] == ?O\n                    @y = i\n                    @x = j\n                end\n            end\n            s.reverse!\n            x = s.gsub(/./) {|c| c == ?X ? ?1 : ?0}.to_i(2)\n            @bits += (x << W * i)\n        end\n        if y_max <= H - 3 && @y <= H - 2\n            puts -1\n            exit\n        end\n        @depth = 0\n    end\n\n    def jump(dx, dy)\n        return unless get(@x+dx, @y+dy) == BLACK\n        loop do\n            @x += dx\n            @y += dy\n            break if get(@x, @y) != BLACK\n            @bits -= (1 << @y * W + @x)\n        end\n        @depth += 1\n    end\n\n    def get(x, y)\n        return GOAL if y >= H\n        return OUT if x < 0 or x >= W or y < 0\n        return @bits[y * W + x]\n    end\n\n    def hash\n        (@bits << 9) + (@y << 4) + @x\n    end\n\n    def eql?(other)\n        hash == other.hash\n    end\n\n    def goal?\n        @y >= H - 1\n    end\n\n    def out?\n        get(@x, @y) == OUT\n    end\n\n    attr_reader :depth\nend\n\nb = Board.new\nqueue = [b]\nreached = Set[b]\n\nuntil queue.empty?\n    b0 = queue.shift\n    [-1, 0, 1].repeated_permutation(2).each do |dx, dy|\n        next if dx == 0 && dy == 0\n        b = b0.dup\n        b.jump(dx, dy)\n        next if reached.include?(b) or b.out?\n        if b.goal?\n            puts b.depth\n            exit\n        end\n        reached << b\n        queue << b\n    end\nend\nputs -1"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nW = 15\nH = 19\nBLACK = 1\nEMPTY = 0\nOUT = -1\nGOAL = -2\n\nclass Board\n    def initialize\n        @bits = 0\n        y_max = 0\n        H.times do |i|\n            s = gets.chomp\n            (0..W-1).each do |j|\n                if s[j] == ?O\n                    @y = i\n                    @x = j\n                end\n                if s[j] == ?X\n                    y_max = i\n                end\n            end\n            s.reverse!\n            x = s.gsub(/./) {|c| c == ?X ? ?1 : ?0}.to_i(2)\n            @bits += (x << W * i)\n        end\n        if y_max <= H - 3 && @y <= H - 2\n            puts -1\n            exit\n        end\n        @depth = 0\n    end\n\n    def jump(dx, dy)\n        return unless get(@x+dx, @y+dy) == BLACK\n        loop do\n            @x += dx\n            @y += dy\n            break if get(@x, @y) != BLACK\n            @bits -= (1 << @y * W + @x)\n        end\n        @depth += 1\n    end\n\n    def get(x, y)\n        return OUT if x < 0 or x >= W or y < 0 or y >= H\n        return @bits[y * W + x]\n    end\n\n    def hash\n        (@bits << 10) + (@y << 5) + @x\n    end\n\n    def eql?(other)\n        hash == other.hash\n    end\n\n    def goal?\n        @y >= H or (@y == H-1 && @x >= 0 && @y <= W-1)\n    end\n\n    def out?\n        get(@x, @y) == OUT\n    end\n\n    def inspect\n        super.inspect + (0..H-1).map {|i| (0..W-1).map {|j| @x == j && @y == i ? ?X : @bits[i*W+j].to_s}.join + \"\\n\"}.join\n    end\n\n    attr_reader :depth\nend\n\nb = Board.new\nqueue = [b]\nreached = Set[b]\n\nuntil queue.empty?\n    b0 = queue.shift\n    [-1, 0, 1].repeated_permutation(2).each do |dx, dy|\n        next if dx == 0 && dy == 0\n        b = b0.dup\n        b.jump(dx, dy)\n        next if reached.include?(b)\n        if b.goal?\n            puts b.depth\n            exit\n        end\n        next if b.out?\n        reached << b\n        queue << b\n    end\nend\n\nputs -1"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nW = 15\nH = 19\nBLACK = 1\nEMPTY = 0\nOUT = -1\nGOAL = -2\n\nclass Board\n    def initialize\n        @bits = 0\n        y_max = 0\n        H.times do |i|\n            s = gets.chomp\n            (0..W-1).each do |j|\n                if s[j] == ?O\n                    @y = i\n                    @x = j\n                end\n                if s[j] == ?X\n                    y_max = i\n                end\n            end\n            s.reverse!\n            x = s.gsub(/./) {|c| c == ?X ? ?1 : ?0}.to_i(2)\n            @bits += (x << W * i)\n        end\n        if y_max <= H - 3 && @y <= H - 2\n            puts -1\n            exit\n        end\n        @depth = 0\n    end\n\n    def jump(dx, dy)\n        return unless get(@x+dx, @y+dy) == BLACK\n        loop do\n            @x += dx\n            @y += dy\n            break if get(@x, @y) != BLACK\n            @bits -= (1 << @y * W + @x)\n        end\n        @depth += 1\n    end\n\n    def get(x, y)\n        return OUT if x < 0 or x >= W or y < 0 or y >= H\n        return @bits[y * W + x]\n    end\n\n    def hash\n        (@bits << 10) + (@y << 5) + @x\n    end\n\n    def eql?(other)\n        hash == other.hash\n    end\n\n    def goal?\n        @y >= H or (@y == H-1 && @x >= 0 && @x <= W-1)\n    end\n\n    def out?\n        get(@x, @y) == OUT\n    end\n\n    def inspect\n        super.inspect + (0..H-1).map {|i| (0..W-1).map {|j| @x == j && @y == i ? ?X : @bits[i*W+j].to_s}.join + \"\\n\"}.join\n    end\n\n    attr_reader :depth\nend\n\nb = Board.new\nqueue = [b]\nreached = Set[b]\n\nuntil queue.empty?\n    b0 = queue.shift\n    [-1, 0, 1].repeated_permutation(2).each do |dx, dy|\n        next if dx == 0 && dy == 0\n        b = b0.dup\n        b.jump(dx, dy)\n        next if reached.include?(b)\n        if b.goal?\n            puts b.depth\n            exit\n        end\n        next if b.out?\n        reached << b\n        queue << b\n    end\nend\n\nputs -1"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\nconst H = 19;\nconst W = 15;\nconst INF = int.max / 2;\n\nvoid main() {\n    auto F = new string[19];\n    foreach (ref L; F) L = readln.chomp;\n    int sy, sx;\n    void find_init_pos() {\n        foreach (i; 0 .. H) {\n            foreach (j; 0 .. W) {\n                if (F[i][j] == 'O') {\n                    sy = i;\n                    sx = j;\n                    return;\n                }\n            }\n        }\n    }\n    find_init_pos();\n\n    bool[W][H] used;\n    bool dfs(int cy, int cx, int t, int d) {\n        if (t == d) return false;\n        //log([cy, cx, t, d]);\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int y = cy + dy, x = cx + dx;\n                import core.stdc.string;\n                bool[W][H] backup; memcpy(backup.ptr, used.ptr, used.sizeof);\n                if (! (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x])) continue;\n                while (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x]) {\n                    used[y][x] = true;\n                    y += dy;\n                    x += dx;\n                }\n                if (y >= H - 1) {\n                    return true;\n                }\n                if (dfs(y, x, t + 1, d)) return true;\n                used = backup;\n            }\n        }\n        return false;\n    }\n\n    for (int d = 1; d <= 21; d++) {\n        if (dfs(sy, sx, 0, d)) {\n            writeln(d);\n            return;\n        }\n    }\n    writeln(-1);\n\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\nconst H = 19;\nconst W = 15;\nconst INF = int.max / 2;\n\nvoid main() {\n    auto F = new string[19];\n    foreach (ref L; F) L = readln.chomp;\n    int sy, sx;\n    void find_init_pos() {\n        foreach (i; 0 .. H) {\n            foreach (j; 0 .. W) {\n                if (F[i][j] == 'O') {\n                    sy = i;\n                    sx = j;\n                    return;\n                }\n            }\n        }\n    }\n    find_init_pos();\n\n    bool[W][H] used;\n    bool dfs(int cy, int cx, int t, int d) {\n        if (t == d) return false;\n        //log([cy, cx, t, d]);\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int y = cy + dy, x = cx + dx;\n                auto backup = used;\n                if (! (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x])) continue;\n                while (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x]) {\n                    used[y][x] = true;\n                    y += dy;\n                    x += dx;\n                }\n                if (x < 0 || x >= W) continue;\n                if (y >= H - 1) {\n                    return true;\n                }\n                if (dfs(y, x, t + 1, d)) return true;\n                used = backup;\n            }\n        }\n        return false;\n    }\n\n    for (int d = 1; d <= 21; d++) {\n        if (dfs(sy, sx, 0, d)) {\n            writeln(d);\n            return;\n        }\n    }\n    writeln(-1);\n\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\nconst H = 19;\nconst W = 15;\nconst INF = int.max / 2;\n\nvoid main() {\n    auto F = new string[19];\n    foreach (ref L; F) L = readln.chomp;\n    int sy, sx;\n    void find_init_pos() {\n        foreach (i; 0 .. H) {\n            foreach (j; 0 .. W) {\n                if (F[i][j] == 'O') {\n                    sy = i;\n                    sx = j;\n                    return;\n                }\n            }\n        }\n    }\n    find_init_pos();\n\n    bool[W][H] used;\n    bool dfs(int cy, int cx, int t, int d) {\n        if (t == d) return false;\n        //log([cy, cx, t, d]);\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int y = cy + dy, x = cx + dx;\n                if (! (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x])) continue;\n                auto backup = used.dup;\n                while (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x]) {\n                    used[y][x] = true;\n                    y += dy;\n                    x += dx;\n                }\n                if (y >= H - 1) {\n                    return true;\n                }\n                if (dfs(y, x, t + 1, d)) return true;\n                used = backup;\n            }\n        }\n        return false;\n    }\n\n    for (int d = 1; d <= 21; d++) {\n        if (dfs(sy, sx, 0, d)) {\n            writeln(d);\n            return;\n        }\n    }\n    writeln(-1);\n\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\nconst H = 19;\nconst W = 15;\nconst INF = int.max / 2;\n\nvoid main() {\n    auto F = new string[19];\n    foreach (ref L; F) L = readln.chomp;\n    int sy, sx;\n    void find_init_pos() {\n        foreach (i; 0 .. H) {\n            foreach (j; 0 .. W) {\n                if (F[i][j] == 'O') {\n                    sy = i;\n                    sx = j;\n                    return;\n                }\n            }\n        }\n    }\n    find_init_pos();\n\n    bool[W][H] used;\n    bool dfs(int cy, int cx, int t, int d) {\n        if (t == d) return false;\n        //log([cy, cx, t, d]);\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int y = cy + dy, x = cx + dx;\n                auto backup = used;\n                if (! (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x])) continue;\n                while (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x]) {\n                    y += dy;\n                    x += dx;\n                }\n                if (y == H - 1 && 0 <= x && x < W) return true;\n                if (y >= H) return true;\n                if (x < 0 || x >= W) continue;\n                scope(exit) used = backup;\n                y = cy + dy, x = cx + dx;\n                while (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x]) {\n                    used[y][x] = true;\n                    y += dy;\n                    x += dx;\n                }\n                if (dfs(y, x, t + 1, d)) return true;\n            }\n        }\n        return false;\n    }\n\n    for (int d = 1; d <= 21; d++) {\n        if (dfs(sy, sx, 0, d)) {\n            writeln(d);\n            return;\n        }\n    }\n    writeln(-1);\n\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\nconst H = 19;\nconst W = 15;\nconst INF = int.max / 2;\n\nvoid main() {\n    auto F = new string[19];\n    foreach (ref L; F) L = readln.chomp;\n    int sy, sx;\n    void find_init_pos() {\n        foreach (i; 0 .. H) {\n            foreach (j; 0 .. W) {\n                if (F[i][j] == 'O') {\n                    sy = i;\n                    sx = j;\n                    return;\n                }\n            }\n        }\n    }\n    find_init_pos();\n\n    if (! (F[H - 2].any!((c) => c == 'X') || F[H - 1].any!((c) => c == 'X'))) {\n        writeln(-1);\n        return;\n    }\n\n    bool[W][H] used;\n    bool dfs(int cy, int cx, int d) {\n        if (d == 0) return false;\n        //log([cy, cx, t, d]);\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int y = cy + dy, x = cx + dx;\n                if (! (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x])) continue;\n                while (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x]) {\n                    y += dy;\n                    x += dx;\n                }\n                if (y == H - 1 && 0 <= x && x < W) return true;\n                if (y >= H) return true;\n                if (x < 0 || x >= W) continue;\n                y = cy + dy, x = cx + dx;\n                while (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x]) {\n                    used[y][x] = true;\n                    y += dy;\n                    x += dx;\n                }\n                if (dfs(y, x, d - 1)) return true;\n                y -= dy, x -= dx;\n                while (y != cy || x != cx) {\n                    used[y][x] = false;\n                    y -= dy;\n                    x -= dx;\n                }\n            }\n        }\n        return false;\n    }\n\n    for (int d = 1; d <= 20; d++) {\n        if (dfs(sy, sx, d)) {\n            writeln(d);\n            return;\n        }\n    }\n    writeln(-1);\n\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\nconst H = 19;\nconst W = 15;\nconst INF = int.max / 2;\n\nvoid main() {\n    auto F = new string[19];\n    foreach (ref L; F) L = readln.chomp;\n    int sy, sx;\n    void find_init_pos() {\n        foreach (i; 0 .. H) {\n            foreach (j; 0 .. W) {\n                if (F[i][j] == 'O') {\n                    sy = i;\n                    sx = j;\n                    return;\n                }\n            }\n        }\n    }\n    find_init_pos();\n\n    bool[W][H] used;\n    bool dfs(int cy, int cx, int d) {\n        if (d == 0) return false;\n        //log([cy, cx, t, d]);\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int y = cy + dy, x = cx + dx;\n                if (! (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x])) continue;\n                while (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x]) {\n                    y += dy;\n                    x += dx;\n                }\n                if (y == H - 1 && 0 <= x && x < W) return true;\n                if (y >= H) return true;\n                if (x < 0 || x >= W) continue;\n                auto backup = used;\n                scope(exit) used = backup;\n                y = cy + dy, x = cx + dx;\n                while (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x]) {\n                    used[y][x] = true;\n                    y += dy;\n                    x += dx;\n                }\n                if (dfs(y, x, d - 1)) return true;\n            }\n        }\n        return false;\n    }\n\n    for (int d = 1; d <= 20; d++) {\n        if (dfs(sy, sx, d)) {\n            writeln(d);\n            return;\n        }\n    }\n    writeln(-1);\n\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\nconst H = 19;\nconst W = 15;\nconst INF = int.max / 2;\n\nvoid main() {\n    auto F = new string[19];\n    foreach (ref L; F) L = readln.chomp;\n    int sy, sx;\n    void find_init_pos() {\n        foreach (i; 0 .. H) {\n            foreach (j; 0 .. W) {\n                if (F[i][j] == 'O') {\n                    sy = i;\n                    sx = j;\n                    return;\n                }\n            }\n        }\n    }\n    find_init_pos();\n\n    bool[W][H] used;\n    bool dfs(int cy, int cx, int d) {\n        if (d == 0) return false;\n        //log([cy, cx, t, d]);\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int y = cy + dy, x = cx + dx;\n                if (! (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x])) continue;\n                while (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x]) {\n                    y += dy;\n                    x += dx;\n                }\n                if (y == H - 1 && 0 <= x && x < W) return true;\n                if (y >= H) return true;\n                if (x < 0 || x >= W) continue;\n                y = cy + dy, x = cx + dx;\n                while (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x]) {\n                    used[y][x] = true;\n                    y += dy;\n                    x += dx;\n                }\n                if (dfs(y, x, d - 1)) return true;\n                y -= dy, x -= dx;\n                while (y != cy || x != cx) {\n                    used[y][x] = false;\n                    y -= dy;\n                    x -= dx;\n                }\n            }\n        }\n        return false;\n    }\n\n    for (int d = 1; d <= 20; d++) {\n        if (dfs(sy, sx, d)) {\n            writeln(d);\n            return;\n        }\n    }\n    writeln(-1);\n\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\nconst H = 19;\nconst W = 15;\nconst INF = int.max / 2;\n\nvoid main() {\n    auto F = new string[19];\n    foreach (ref L; F) L = readln.chomp;\n    int sy, sx;\n    void find_init_pos() {\n        foreach (i; 0 .. H) {\n            foreach (j; 0 .. W) {\n                if (F[i][j] == 'O') {\n                    sy = i;\n                    sx = j;\n                    return;\n                }\n            }\n        }\n    }\n    find_init_pos();\n\n    bool[W][H] used;\n    bool dfs(int cy, int cx, int t, int d) {\n        if (t == d) return false;\n        //log([cy, cx, t, d]);\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int y = cy + dy, x = cx + dx;\n                auto backup = used;\n                scope(exit) used = backup;\n                if (! (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x])) continue;\n                while (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x]) {\n                    used[y][x] = true;\n                    y += dy;\n                    x += dx;\n                }\n                if (y == H - 1 && 0 <= x && x < W) return true;\n                if (y >= H) return true;\n                if (x < 0 || x >= W) continue;\n                if (dfs(y, x, t + 1, d)) return true;\n            }\n        }\n        return false;\n    }\n\n    for (int d = 1; d <= 21; d++) {\n        if (dfs(sy, sx, 0, d)) {\n            writeln(d);\n            return;\n        }\n    }\n    writeln(-1);\n\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\nconst H = 19;\nconst W = 15;\nconst INF = int.max / 2;\n\nvoid main() {\n    auto F = new string[19];\n    foreach (ref L; F) L = readln.chomp;\n    int sy, sx;\n    void find_init_pos() {\n        foreach (i; 0 .. H) {\n            foreach (j; 0 .. W) {\n                if (F[i][j] == 'O') {\n                    sy = i;\n                    sx = j;\n                    return;\n                }\n            }\n        }\n    }\n    find_init_pos();\n\n    bool[W][H] used;\n    bool dfs(int cy, int cx, int t, int d) {\n        if (t == d) return false;\n        //log([cy, cx, t, d]);\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int y = cy + dy, x = cx + dx;\n                auto backup = used;\n                if (! (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x])) continue;\n                while (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x]) {\n                    used[y][x] = true;\n                    y += dy;\n                    x += dx;\n                }\n                if (y >= H - 1) {\n                    return true;\n                }\n                if (x < 0 || x >= W) continue;\n                if (dfs(y, x, t + 1, d)) return true;\n                used = backup;\n            }\n        }\n        return false;\n    }\n\n    for (int d = 1; d <= 21; d++) {\n        if (dfs(sy, sx, 0, d)) {\n            writeln(d);\n            return;\n        }\n    }\n    writeln(-1);\n\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\nconst H = 19;\nconst W = 15;\nconst INF = int.max / 2;\n\nvoid main() {\n    auto F = new string[19];\n    foreach (ref L; F) L = readln.chomp;\n    int sy, sx;\n    void find_init_pos() {\n        foreach (i; 0 .. H) {\n            foreach (j; 0 .. W) {\n                if (F[i][j] == 'O') {\n                    sy = i;\n                    sx = j;\n                    return;\n                }\n            }\n        }\n    }\n    find_init_pos();\n\n    bool[W][H] used;\n    bool dfs(int cy, int cx, int t, int d) {\n        if (t == d) return false;\n        //log([cy, cx, t, d]);\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int y = cy + dy, x = cx + dx;\n                auto backup = used;\n                scope(exit) used = backup;\n                if (! (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x])) continue;\n                while (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x]) {\n                    used[y][x] = true;\n                    y += dy;\n                    x += dx;\n                }\n                if (y >= H - 1) {\n                    return true;\n                }\n                if (x < 0 || x >= W) continue;\n                if (dfs(y, x, t + 1, d)) return true;\n            }\n        }\n        return false;\n    }\n\n    for (int d = 1; d <= 21; d++) {\n        if (dfs(sy, sx, 0, d)) {\n            writeln(d);\n            return;\n        }\n    }\n    writeln(-1);\n\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\nconst H = 19;\nconst W = 15;\nconst INF = int.max / 2;\n\nvoid main() {\n    auto F = new string[19];\n    foreach (ref L; F) L = readln.chomp;\n    int sy, sx;\n    void find_init_pos() {\n        foreach (i; 0 .. H) {\n            foreach (j; 0 .. W) {\n                if (F[i][j] == 'O') {\n                    sy = i;\n                    sx = j;\n                    return;\n                }\n            }\n        }\n    }\n    find_init_pos();\n\n    bool[W][H] used;\n    bool dfs(int cy, int cx, int d) {\n        if (d == 0) return false;\n        //log([cy, cx, t, d]);\n        for (int dy = -1; dy <= 1; dy++) {\n            for (int dx = -1; dx <= 1; dx++) {\n                if (dy == 0 && dx == 0) continue;\n                int y = cy + dy, x = cx + dx;\n                auto backup = used;\n                if (! (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x])) continue;\n                while (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x]) {\n                    y += dy;\n                    x += dx;\n                }\n                if (y == H - 1 && 0 <= x && x < W) return true;\n                if (y >= H) return true;\n                if (x < 0 || x >= W) continue;\n                scope(exit) used = backup;\n                y = cy + dy, x = cx + dx;\n                while (0 <= y && y < H && 0 <= x && x < W && F[y][x] == 'X' && !used[y][x]) {\n                    used[y][x] = true;\n                    y += dy;\n                    x += dx;\n                }\n                if (dfs(y, x, d - 1)) return true;\n            }\n        }\n        return false;\n    }\n\n    for (int d = 1; d <= 20; d++) {\n        if (dfs(sy, sx, d)) {\n            writeln(d);\n            return;\n        }\n    }\n    writeln(-1);\n\n}"
  },
  {
    "language": "Python",
    "code": "INF = 100\nmp = [list(\"#\" * 17)] + [list(\"#\" + input() + \"#\") for _ in range(19)] + [list(\"G\" * 17)]\nfor y in range(1, 20):\n  for x in range(1, 16):\n    if mp[y][x] == \"O\":\n      sx, sy = x, y\n      mp[y][x] = \".\"\n\nvec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1))\nans = INF\ndef search(x, y, score):\n  global ans\n  if score >= ans:return\n  for dx, dy in vec:\n    nx, ny = x, y\n    use = []\n    while mp[ny + dy][nx + dx] == \"X\":\n      nx += dx\n      ny += dy\n      use.append((nx, ny))\n    if mp[ny + dy][nx + dx] == \"G\":\n      ans = score + 1\n      return\n    if mp[ny + dy][nx + dx] == \"#\":\n      continue\n    if mp[ny + dy][nx + dx] == \".\" and use:\n      for ux, uy in use:\n        mp[uy][ux] = \".\"\n      search(nx + dx, ny + dy, score + 1)\n      for ux, uy in use:\n        mp[uy][ux] = \"X\"\n\nsearch(sx, sy, 0)\nif ans == INF:print(-1)\nelse:print(ans)\n"
  },
  {
    "language": "Python",
    "code": "INF = 100\nmp = [list(\"#\" * 17)] + [list(\"#\" + input() + \"#\") for _ in range(19)] + [list(\"G\" * 17)]\nfor y in range(1, 20):\n  for x in range(1, 16):\n    if mp[y][x] == \"O\":\n      sx, sy = x, y\n      mp[y][x] = \".\"\nfor x in range(1, 16):\n  if mp[19][x] != \"X\":mp[19][x] = \"G\"\n\nvec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1))\nans = INF\ndef search(x, y, score):\n  global ans\n  if score >= ans:return\n  for dx, dy in vec:\n    nx, ny = x, y\n    use = []\n    while mp[ny + dy][nx + dx] == \"X\":\n      nx += dx\n      ny += dy\n      use.append((nx, ny))\n    if not use:continue\n    if mp[ny + dy][nx + dx] == \"G\":\n      ans = score + 1\n      return\n    if mp[ny + dy][nx + dx] == \"#\":\n      continue\n    if mp[ny + dy][nx + dx] == \".\":\n      for ux, uy in use:\n        mp[uy][ux] = \".\" if uy < 19 else \"G\"\n      search(nx + dx, ny + dy, score + 1)\n      for ux, uy in use:\n        mp[uy][ux] = \"X\"\n\nsearch(sx, sy, 0)\nif ans == INF:print(-1)\nelse:print(ans)\n"
  },
  {
    "language": "Python",
    "code": "INF = 100\nmp = [list(\"#\" * 17)] + [list(\"#\" + input() + \"#\") for _ in range(19)] + [list(\"G\" * 17)]\nfor y in range(1, 20):\n  for x in range(1, 16):\n    if mp[y][x] == \"O\":\n      sx, sy = x, y\n      mp[y][x] = \".\"\nfor x in range(17):\n  if mp[19][x] != \"X\":mp[19][x] = \"G\"\n\nvec = ((1, 0), (1, -1), (0, -1), (-1, -1), (-1, 0), (-1, 1), (0, 1), (1, 1))\nans = INF\ndef search(x, y, score):\n  global ans\n  if score >= ans:return\n  for dx, dy in vec:\n    nx, ny = x, y\n    use = []\n    while mp[ny + dy][nx + dx] == \"X\":\n      nx += dx\n      ny += dy\n      use.append((nx, ny))\n    if not use:continue\n    if mp[ny + dy][nx + dx] == \"G\":\n      ans = score + 1\n      return\n    if mp[ny + dy][nx + dx] == \"#\":\n      continue\n    if mp[ny + dy][nx + dx] == \".\":\n      for ux, uy in use:\n        mp[uy][ux] = \".\"\n      search(nx + dx, ny + dy, score + 1)\n      for ux, uy in use:\n        mp[uy][ux] = \"X\"\n\nsearch(sx, sy, 0)\nif ans == INF:print(-1)\nelse:print(ans)\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    N = 20; M = 15\n    MP = [[-1]*M for i in range(N)]\n    L = 0\n    for i in range(N-1):\n        s = input()\n        for j in range(M):\n            c = s[j]\n            if c == 'O':\n                sx = j; sy = i\n            elif c == 'X':\n                MP[i][j] = L\n                L += 1\n\n    dd = ((-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1))\n\n    INF = 30\n    D = {}\n    def dfs(state, x, y):\n        key = (state, x, y)\n        if key in D:\n            return D[key]\n        if y >= N-2:\n            return 0\n        r = INF\n        for dx, dy in dd:\n            nx = x + dx; ny = y + dy\n            if not 0 <= nx < M or not 0 <= ny < N:\n                continue\n            k = MP[ny][nx]\n            if k == -1 or state & (1 << k) == 0:\n                continue\n            n_state = state ^ (1 << k)\n            nx += dx; ny += dy\n            while 0 <= nx < M and 0 <= ny < N:\n                k = MP[ny][nx]\n                if k == -1 or state & (1 << k) == 0:\n                    break\n                n_state ^= (1 << k)\n                nx += dx; ny += dy\n            else:\n                if (nx == -1 or nx == M) and ny == N-1:\n                    return 1\n                continue\n            r = min(r, dfs(n_state, nx, ny) + 1)\n        D[key] = r\n        return D[key]\n    r = dfs(2**L-1, sx, sy)\n    print(r if r < INF else -1)\nmain()\n\n"
  }
]