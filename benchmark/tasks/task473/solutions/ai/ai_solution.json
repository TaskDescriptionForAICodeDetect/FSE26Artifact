[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <limits.h>\n\n#define BOARD_HEIGHT 19\n#define BOARD_WIDTH 15\n#define MAX_BLACK_STONES 100\n\ntypedef struct {\n    int x, y;\n} Position;\n\ntypedef struct {\n    char board[BOARD_HEIGHT][BOARD_WIDTH];\n    Position white_stone;\n    Position black_stones[MAX_BLACK_STONES];\n    int black_stone_count;\n} GameState;\n\nint dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nint dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nbool is_valid_position(int x, int y) {\n    return x >= 0 && x < BOARD_HEIGHT && y >= 0 && y < BOARD_WIDTH;\n}\n\nbool can_jump(GameState* state, int dx, int dy) {\n    int nx = state->white_stone.x + dx;\n    int ny = state->white_stone.y + dy;\n    \n    while (is_valid_position(nx, ny)) {\n        bool black_stone_found = false;\n        for (int i = 0; i < state->black_stone_count; i++) {\n            if (state->black_stones[i].x == nx && state->black_stones[i].y == ny) {\n                black_stone_found = true;\n                break;\n            }\n        }\n        \n        if (!black_stone_found) {\n            break;\n        }\n        \n        nx += dx;\n        ny += dy;\n    }\n    \n    return is_valid_position(nx, ny) && nx == state->white_stone.x + dx && ny == state->white_stone.y + dy;\n}\n\nint solve(GameState* state) {\n    int min_jumps = INT_MAX;\n    \n    for (int dir = 0; dir < 8; dir++) {\n        GameState current_state = *state;\n        int jumps = 0;\n        bool goal_reached = false;\n        \n        while (can_jump(&current_state, dx[dir], dy[dir])) {\n            int jump_x = current_state.white_stone.x + dx[dir];\n            int jump_y = current_state.white_stone.y + dy[dir];\n            \n            while (is_valid_position(jump_x, jump_y)) {\n                bool black_stone_found = false;\n                for (int i = 0; i < current_state.black_stone_count; i++) {\n                    if (current_state.black_stones[i].x == jump_x && current_state.black_stones[i].y == jump_y) {\n                        current_state.black_stones[i] = current_state.black_stones[current_state.black_stone_count - 1];\n                        current_state.black_stone_count--;\n                        black_stone_found = true;\n                        break;\n                    }\n                }\n                \n                if (!black_stone_found) {\n                    break;\n                }\n                \n                jump_x += dx[dir];\n                jump_y += dy[dir];\n            }\n            \n            current_state.white_stone.x = jump_x - dx[dir];\n            current_state.white_stone.y = jump_y - dy[dir];\n            jumps++;\n            \n            if (current_state.white_stone.x >= BOARD_HEIGHT - 1) {\n                goal_reached = true;\n                break;\n            }\n        }\n        \n        if (goal_reached) {\n            min_jumps = (jumps < min_jumps) ? jumps : min_jumps;\n        }\n    }\n    \n    return (min_jumps == INT_MAX) ? -1 : min_jumps;\n}\n\nint main() {\n    GameState state;\n    \n    // Input board state\n    scanf(\"%d\", &state.black_stone_count);\n    \n    for (int i = 0; i < state.black_stone_count; i++) {\n        scanf(\"%d %d\", &state.black_stones[i].x, &state.black_stones[i].y);\n    }\n    \n    scanf(\"%d %d\", &state.white_stone.x, &state.white_stone.y);\n    \n    int result = solve(&state);\n    \n    if (result == -1) {\n        printf(\"Cannot reach the goal\\n\");\n    } else {\n        printf(\"Minimum jumps to reach the goal: %d\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:49:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define ROWS 19\n#define COLS 15\n#define MAX_QUEUE 1000000\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point pos;\n    int jumps;\n} State;\n\nint dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nint dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nint min_jumps_to_goal(char board[ROWS][COLS], Point white_stone) {\n    int visited[ROWS][COLS];\n    memset(visited, -1, sizeof(visited));\n    \n    State queue[MAX_QUEUE];\n    int front = 0, rear = 0;\n    \n    queue[rear].pos = white_stone;\n    queue[rear].jumps = 0;\n    rear++;\n    \n    visited[white_stone.x][white_stone.y] = 0;\n    \n    while (front < rear) {\n        State current = queue[front];\n        front++;\n        \n        if (current.pos.x == ROWS - 1) {\n            return current.jumps;\n        }\n        \n        for (int d = 0; d < 8; d++) {\n            int nx = current.pos.x + dx[d];\n            int ny = current.pos.y + dy[d];\n            \n            if (nx >= 0 && nx < ROWS && ny >= 0 && ny < COLS && board[nx][ny] == 'B') {\n                int jx = nx + dx[d];\n                int jy = ny + dy[d];\n                \n                if (jx >= 0 && jx < ROWS && jy >= 0 && jy < COLS && board[jx][jy] != 'B') {\n                    if (visited[jx][jy] == -1 || current.jumps + 1 < visited[jx][jy]) {\n                        visited[jx][jy] = current.jumps + 1;\n                        State next;\n                        next.pos.x = jx;\n                        next.pos.y = jy;\n                        next.jumps = current.jumps + 1;\n                        queue[rear] = next;\n                        rear++;\n                    }\n                }\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    char board[ROWS][COLS];\n    Point white_stone;\n    int black_count;\n    \n    for (int i = 0; i < ROWS; i++) {\n        for (int j = 0; j < COLS; j++) {\n            board[i][j] = '.';\n        }\n    }\n    \n    scanf(\"%d %d\", &white_stone.x, &white_stone.y);\n    board[white_stone.x][white_stone.y] = 'W';\n    \n    scanf(\"%d\", &black_count);\n    for (int i = 0; i < black_count; i++) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        board[x][y] = 'B';\n    }\n    \n    int result = min_jumps_to_goal(board, white_stone);\n    if (result != -1) {\n        printf(\"%d\\n\", result);\n    } else {\n        printf(\"-1\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:50:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Position {\n    int x, y;\n    Position(int x = 0, int y = 0) : x(x), y(y) {}\n    bool operator==(const Position &other) const {\n        return x == other.x && y == other.y;\n    }\n};\n\nnamespace std {\n    template<>\n    struct hash<Position> {\n        size_t operator()(const Position &p) const {\n            return p.x * 19 + p.y;\n        }\n    };\n}\n\nint main() {\n    int w_x, w_y, n;\n    cin >> w_x >> w_y >> n;\n    \n    unordered_set<Position> black_stones;\n    for (int i = 0; i < n; ++i) {\n        int x, y;\n        cin >> x >> y;\n        black_stones.insert(Position(x, y));\n    }\n    \n    const int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\n    const int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n    \n    queue<pair<Position, int>> q;\n    unordered_set<Position> visited;\n    Position start(w_x, w_y);\n    q.push({start, 0});\n    visited.insert(start);\n    \n    int min_jumps = INT_MAX;\n    \n    while (!q.empty()) {\n        auto current = q.front();\n        q.pop();\n        Position pos = current.first;\n        int jumps = current.second;\n        \n        if (pos.y <= 0) {\n            min_jumps = min(min_jumps, jumps);\n            continue;\n        }\n        \n        for (int dir = 0; dir < 8; ++dir) {\n            int nx = pos.x + dx[dir];\n            int ny = pos.y + dy[dir];\n            Position mid(nx, ny);\n            \n            if (black_stones.count(mid)) {\n                int jx = nx + dx[dir];\n                int jy = ny + dy[dir];\n                Position jump_pos(jx, jy);\n                \n                if (jy > 15) continue; // Assuming board is 19x15, but y is up to 15\n                if (black_stones.count(jump_pos)) continue;\n                if (visited.count(jump_pos)) continue;\n                \n                unordered_set<Position> new_black_stones = black_stones;\n                new_black_stones.erase(mid);\n                \n                visited.insert(jump_pos);\n                q.push({jump_pos, jumps + 1});\n            }\n        }\n    }\n    \n    if (min_jumps != INT_MAX) {\n        cout << min_jumps << endl;\n    } else {\n        cout << -1 << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:50:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Phutball {\n    static class State {\n        int x, y;\n        Set<String> blacks;\n        int jumps;\n\n        State(int x, int y, Set<String> blacks, int jumps) {\n            this.x = x;\n            this.y = y;\n            this.blacks = new HashSet<>(blacks);\n            this.jumps = jumps;\n        }\n\n        String getKey() {\n            return x + \",\" + y + \":\" + blacks.toString();\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int wx = -1, wy = -1;\n        Set<String> blacks = new HashSet<>();\n\n        for (int i = 0; i < 19; i++) {\n            String line = scanner.nextLine().trim();\n            for (int j = 0; j < 15; j++) {\n                char c = line.charAt(j);\n                if (c == 'W') {\n                    wx = i;\n                    wy = j;\n                } else if (c == 'B') {\n                    blacks.add(i + \",\" + j);\n                }\n            }\n        }\n\n        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n        Queue<State> queue = new LinkedList<>();\n        queue.add(new State(wx, wy, blacks, 0));\n        Set<String> visited = new HashSet<>();\n        visited.add(queue.peek().getKey());\n\n        int minJumps = -1;\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (current.y >= 14) {\n                minJumps = current.jumps;\n                break;\n            }\n\n            for (int[] dir : dirs) {\n                int nx = current.x + dir[0];\n                int ny = current.y + dir[1];\n                String jumpOver = nx + \",\" + ny;\n                if (current.blacks.contains(jumpOver)) {\n                    int landX = nx + dir[0];\n                    int landY = ny + dir[1];\n                    String landPos = landX + \",\" + landY;\n                    if (landX >= 0 && landX < 19 && landY >= 0 && landY < 15 && !current.blacks.contains(landPos)) {\n                        Set<String> newBlacks = new HashSet<>(current.blacks);\n                        newBlacks.remove(jumpOver);\n                        State newState = new State(landX, landY, newBlacks, current.jumps + 1);\n                        String key = newState.getKey();\n                        if (!visited.contains(key)) {\n                            visited.add(key);\n                            queue.add(newState);\n                        }\n                    }\n                }\n            }\n        }\n\n        System.out.println(minJumps);\n    }\n}",
    "timestamp": "2025-08-05 21:51:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Phutball {\n    static int rows = 19;\n    static int cols = 15;\n    static int[][] directions = {{-1,0}, {1,0}, {0,-1}, {0,1}, {-1,-1}, {-1,1}, {1,-1}, {1,1}};\n\n    static class State {\n        int row, col;\n        Set<String> blackStones;\n        int jumps;\n\n        State(int row, int col, Set<String> blackStones, int jumps) {\n            this.row = row;\n            this.col = col;\n            this.blackStones = blackStones;\n            this.jumps = jumps;\n        }\n    }\n\n    static int solve(int whiteRow, int whiteCol, Set<String> blackStones) {\n        Queue<State> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.offer(new State(whiteRow, whiteCol, blackStones, 0));\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (current.row >= rows) return current.jumps;\n\n            String key = current.row + \",\" + current.col;\n            if (visited.contains(key)) continue;\n            visited.add(key);\n\n            for (int[] dir : directions) {\n                int newRow = current.row + dir[0];\n                int newCol = current.col + dir[1];\n                String stoneKey = newRow + \",\" + newCol;\n\n                if (current.blackStones.contains(stoneKey)) {\n                    int jumpRow = newRow + dir[0];\n                    int jumpCol = newCol + dir[1];\n                    String jumpKey = jumpRow + \",\" + jumpCol;\n\n                    while (current.blackStones.contains(jumpKey)) {\n                        jumpRow += dir[0];\n                        jumpCol += dir[1];\n                        jumpKey = jumpRow + \",\" + jumpCol;\n                    }\n\n                    if (!current.blackStones.contains(jumpKey)) {\n                        Set<String> newBlackStones = new HashSet<>(current.blackStones);\n                        newBlackStones.remove(stoneKey);\n                        queue.offer(new State(jumpRow, jumpCol, newBlackStones, current.jumps + 1));\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int whiteRow = scanner.nextInt();\n        int whiteCol = scanner.nextInt();\n        int blackCount = scanner.nextInt();\n\n        Set<String> blackStones = new HashSet<>();\n        for (int i = 0; i < blackCount; i++) {\n            int row = scanner.nextInt();\n            int col = scanner.nextInt();\n            blackStones.add(row + \",\" + col);\n        }\n\n        int result = solve(whiteRow, whiteCol, blackStones);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-05 21:51:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <limits>\n\nusing namespace std;\n\nconst int ROWS = 19;\nconst int COLS = 15;\nconst int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1};\nconst int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1};\n\nbool isValidPosition(int x, int y) {\n    return x >= 0 && x < ROWS && y >= 0 && y < COLS;\n}\n\nbool canReachGoal(vector<vector<char>>& board, int startX, int startY) {\n    vector<vector<bool>> visited(ROWS, vector<bool>(COLS, false));\n    queue<tuple<int, int, int>> q;\n    q.push({startX, startY, 0});\n    visited[startX][startY] = true;\n\n    while (!q.empty()) {\n        auto [x, y, jumps] = q.front();\n        q.pop();\n\n        if (x == ROWS - 1) return true;\n\n        for (int d = 0; d < 8; ++d) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n            \n            if (!isValidPosition(nx, ny) || board[nx][ny] != 'B') continue;\n\n            int jumpX = nx + dx[d];\n            int jumpY = ny + dy[d];\n\n            while (isValidPosition(jumpX, jumpY) && board[jumpX][jumpY] == 'B') {\n                jumpX += dx[d];\n                jumpY += dy[d];\n            }\n\n            if (!isValidPosition(jumpX, jumpY) || board[jumpX][jumpY] != '.') continue;\n\n            if (!visited[jumpX][jumpY]) {\n                vector<vector<char>> newBoard = board;\n                newBoard[x][y] = '.';\n                newBoard[nx][ny] = '.';\n                newBoard[jumpX][jumpY] = 'W';\n\n                q.push({jumpX, jumpY, jumps + 1});\n                visited[jumpX][jumpY] = true;\n            }\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int blackStones;\n    cin >> blackStones;\n\n    vector<vector<char>> board(ROWS, vector<char>(COLS, '.'));\n    int whiteX, whiteY;\n\n    for (int i = 0; i < blackStones; ++i) {\n        int x, y;\n        cin >> x >> y;\n        board[x][y] = 'B';\n    }\n\n    cin >> whiteX >> whiteY;\n    board[whiteX][whiteY] = 'W';\n\n    if (canReachGoal(board, whiteX, whiteY)) {\n        cout << \"Yes\" << endl;\n    } else {\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:51:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\n# Direction vectors for 8 possible directions\ndirections = [(-1, 0), (1, 0), (0, -1), (0, 1), \n              (-1, -1), (-1, 1), (1, -1), (1, 1)]\n\ndef can_reach_goal(board, white_pos):\n    rows, cols = len(board), len(board[0])\n    queue = deque([(white_pos, 0)])\n    visited = set([white_pos])\n\n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols\n\n    def perform_jump(r, c, dr, dc):\n        steps = 0\n        # Count number of consecutive black stones in the direction\n        while is_valid(r + dr, c + dc) and board[r + dr][c + dc] == 'B':\n            r += dr\n            c += dc\n            steps += 1\n        # Check landing position after the jump\n        if steps > 0 and is_valid(r + dr, c + dc) and board[r + dr][c + dc] == '.':\n            return (r + dr, c + dc)\n        return None\n\n    while queue:\n        (x, y), jumps = queue.popleft()\n        \n        # Check if reached goal\n        if x == rows - 1:\n            return jumps\n        \n        # Try all possible jumps\n        for dr, dc in directions:\n            new_pos = perform_jump(x, y, dr, dc)\n            if new_pos and new_pos not in visited:\n                visited.add(new_pos)\n                queue.append((new_pos, jumps + 1))\n\n    return -1\n\n# Example board state\nboard = [\n    \"...............\",\n    \"...............\",\n    \"...............\",\n    \"...............\",\n    \"...............\",\n    \"...............\",\n    \"...............\",\n    \"...............\",\n    \"...............\",\n    \"...............\",\n    \".......B.......\",\n    \".......W.......\",\n    \".......B.......\",\n    \"...............\",\n    \"...............\",\n    \"...............\",\n    \"......B........\",\n    \"...............\",\n    \"...............\"\n]\n\n# Initial position of the white stone (x, y)\ninitial_white_pos = (11, 7)\n\n# Convert board to a list of lists\nboard_list = [list(row) for row in board]\n\n# Determine if the goal can be reached\nresult = can_reach_goal(board_list, initial_white_pos)\n\n# Print result\nprint(\"Minimum jumps to reach goal:\", result if result != -1 else \"Impossible\")",
    "timestamp": "2025-08-13 07:42:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Phutball {\n    private static final int BOARD_WIDTH = 19;\n    private static final int BOARD_HEIGHT = 15;\n    private static final int[] DX = {-1, -1, -1, 0, 0, 1, 1, 1};\n    private static final int[] DY = {-1, 0, 1, -1, 1, -1, 0, 1};\n\n    static class State {\n        int x, y, jumps;\n        State(int x, int y, int jumps) {\n            this.x = x;\n            this.y = y;\n            this.jumps = jumps;\n        }\n    }\n\n    public static int minJumpsToGoal(int whiteX, int whiteY, Set<int[]> blackStones) {\n        Queue<State> queue = new LinkedList<>();\n        queue.offer(new State(whiteX, whiteY, 0));\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n\n            if (current.y >= BOARD_HEIGHT) {\n                return current.jumps;\n            }\n\n            for (int direction = 0; direction < 8; direction++) {\n                int nx = current.x + DX[direction];\n                int ny = current.y + DY[direction];\n\n                while (blackStones.contains(new int[]{nx, ny})) {\n                    nx += DX[direction];\n                    ny += DY[direction];\n                }\n\n                if (!blackStones.contains(new int[]{nx, ny}) && nx >= 0 && ny >= 0 && nx < BOARD_WIDTH && ny < BOARD_HEIGHT + 1) {\n                    Set<int[]> newBlackStones = new HashSet<>(blackStones);\n                    newBlackStones.removeIf(stone -> isBetween(current.x, current.y, nx, ny, stone[0], stone[1]));\n                    queue.offer(new State(nx, ny, current.jumps + 1));\n                }\n            }\n        }\n        return -1;\n    }\n\n    private static boolean isBetween(int x1, int y1, int x2, int y2, int x, int y) {\n        return (x == x1 || x == x2 || y == y1 || y == y2) && (x >= Math.min(x1, x2) && x <= Math.max(x1, x2) && y >= Math.min(y1, y2) && y <= Math.max(y1, y2));\n    }\n\n    public static void main(String[] args) {\n        Set<int[]> blackStones = new HashSet<>();\n        blackStones.add(new int[]{1, 2});\n        blackStones.add(new int[]{2, 3});\n        blackStones.add(new int[]{5, 7}); // Add black stone positions\n        \n        int whiteX = 0; // Initial white stone position X\n        int whiteY = 0; // Initial white stone position Y\n\n        int result = minJumpsToGoal(whiteX, whiteY, blackStones);\n        System.out.println(result);\n    }\n}",
    "timestamp": "2025-08-13 07:42:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define BOARD_ROWS 19\n#define BOARD_COLS 15\n\ntypedef struct {\n    int row;\n    int col;\n} Position;\n\nint directions[8][2] = {\n    {-1, 0}, {1, 0}, {0, -1}, {0, 1}, // up, down, left, right\n    {-1, -1}, {-1, 1}, {1, -1}, {1, 1} // diagonals\n};\n\nbool is_valid_position(int row, int col, bool black_stones[BOARD_ROWS][BOARD_COLS]) {\n    return (row >= 0 && row < BOARD_ROWS && col >= 0 && col < BOARD_COLS && !black_stones[row][col]);\n}\n\nbool can_jumps(Position white, bool black_stones[BOARD_ROWS][BOARD_COLS], int *min_jumps, int current_jumps) {\n    if (white.row >= BOARD_ROWS) {\n        if (*min_jumps == -1 || current_jumps < *min_jumps) {\n            *min_jumps = current_jumps;\n        }\n        return true;\n    }\n    \n    bool reached_goal = false;\n\n    for (int d = 0; d < 8; d++) {\n        int new_row = white.row + directions[d][0];\n        int new_col = white.col + directions[d][1];\n\n        if (new_row >= 0 && new_row < BOARD_ROWS && new_col >= 0 && new_col < BOARD_COLS && black_stones[new_row][new_col]) {\n            int jump_row = new_row + directions[d][0];\n            int jump_col = new_col + directions[d][1];\n\n            if (is_valid_position(jump_row, jump_col, black_stones)) {\n                black_stones[new_row][new_col] = false;\n                reached_goal |= can_jumps((Position){jump_row, jump_col}, black_stones, min_jumps, current_jumps + 1);\n                black_stones[new_row][new_col] = true;\n            }\n        }\n    }\n\n    return reached_goal;\n}\n\nint main() {\n    bool black_stones[BOARD_ROWS][BOARD_COLS] = {false}; // Initialize as needed\n    Position white_position = {0, 0}; // Initialize with white stone position\n\n    int min_jumps = -1;\n    if (can_jumps(white_position, black_stones, &min_jumps, 0)) {\n        printf(\"Minimum jumps required: %d\\n\", min_jumps);\n    } else {\n        printf(\"Cannot reach the goal.\\n\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:42:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\n\ndef solve_phutball(board: List[List[str]], white_pos: Tuple[int, int]) -> int:\n    rows, cols = len(board), len(board[0])\n    \n    def is_valid(r, c):\n        return 0 <= r < rows and 0 <= c < cols\n    \n    def get_jump_directions():\n        return [\n            (-1, 0), (1, 0), (0, -1), (0, 1),\n            (-1, -1), (-1, 1), (1, -1), (1, 1)\n        ]\n    \n    def can_jump(board, start_r, start_c, dr, dc):\n        r, c = start_r + dr, start_c + dc\n        jumped_stones = 0\n        \n        while is_valid(r, c) and board[r][c] == 'B':\n            r += dr\n            c += dc\n            jumped_stones += 1\n        \n        if not is_valid(r, c) or board[r][c] != '.':\n            return None\n        \n        return (r, c, jumped_stones)\n    \n    def dfs(board, white_r, white_c, jumps):\n        if white_r == rows - 1:\n            return jumps\n        \n        min_jumps = float('inf')\n        \n        for dr, dc in get_jump_directions():\n            jump_result = can_jump(board, white_r, white_c, dr, dc)\n            \n            if jump_result:\n                new_r, new_c, stones_jumped = jump_result\n                new_board = [row[:] for row in board]\n                \n                # Remove jumped stones\n                r, c = white_r + dr, white_c + dc\n                for _ in range(stones_jumped):\n                    new_board[r][c] = '.'\n                    r += dr\n                    c += dc\n                \n                new_board[white_r][white_c] = '.'\n                new_board[new_r][new_c] = 'W'\n                \n                result = dfs(new_board, new_r, new_c, jumps + 1)\n                min_jumps = min(min_jumps, result) if result is not None else min_jumps\n        \n        return min_jumps if min_jumps != float('inf') else None\n    \n    result = dfs(board, white_pos[0], white_pos[1], 0)\n    return result if result is not None else -1\n\n# Example usage\ndef main():\n    board = [\n        ['B', '.', '.', 'B', '.'],\n        ['.', 'W', 'B', '.', '.'],\n        ['.', '.', '.', '.', '.']\n    ]\n    white_pos = (1, 1)\n    \n    result = solve_phutball(board, white_pos)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 07:43:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve():\n    # Directions: 8 possible moves (up, down, left, right, diagonals)\n    directions = [(-1, -1), (-1, 0), (-1, 1),\n                  (0, -1),          (0, 1),\n                  (1, -1),  (1, 0), (1, 1)]\n    \n    # Read input\n    white_pos = None\n    black_stones = set()\n    for i in range(19):\n        line = input().strip()\n        for j, c in enumerate(line):\n            if c == 'W':\n                white_pos = (i, j)\n            elif c == 'B':\n                black_stones.add((i, j))\n    \n    # BFS setup\n    queue = deque()\n    queue.append((white_pos[0], white_pos[1], 0, frozenset(black_stones)))\n    visited = set()\n    visited.add((white_pos[0], white_pos[1], frozenset(black_stones)))\n    \n    while queue:\n        x, y, jumps, stones = queue.popleft()\n        \n        # Check if current position is goal (y >= 15 or x >= 19?)\n        if x >= 19:\n            print(jumps)\n            return\n        \n        # Explore all possible jumps\n        for dx, dy in directions:\n            nx = x + dx\n            ny = y + dy\n            if (nx, ny) in stones:\n                # Check landing position after jump\n                lx = x + 2*dx\n                ly = y + 2*dy\n                # Check if landing is valid (not on another black stone and within bounds or goal)\n                if (lx, ly) not in stones and (lx >= 0 and ly >= 0 and ly < 15):\n                    new_stones = set(stones)\n                    new_stones.remove((nx, ny))\n                    frozen_new_stones = frozenset(new_stones)\n                    if (lx, ly, frozen_new_stones) not in visited:\n                        visited.add((lx, ly, frozen_new_stones))\n                        queue.append((lx, ly, jumps + 1, frozen_new_stones))\n                elif lx >= 19:\n                    print(jumps + 1)\n                    return\n    \n    print(-1)\n\nsolve()",
    "timestamp": "2025-08-13 07:43:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconst int ROWS = 19;\nconst int COLS = 15;\nconst int GOAL_ROW = 19;\n\nstruct Stone {\n    int x, y, jumps;\n    Stone(int x, int y, int jumps) : x(x), y(y), jumps(jumps) {}\n};\n\nbool isValidPosition(int x, int y, const vector<vector<bool>>& black_stones) {\n    return x >= 0 && x < ROWS && y >= 0 && y < COLS && !black_stones[x][y];\n}\n\nbool canReachGoal(int start_x, int start_y, vector<vector<bool>>& black_stones) {\n    vector<vector<bool>> visited(ROWS, vector<bool>(COLS, false));\n    queue<Stone> q;\n\n    q.push(Stone(start_x, start_y, 0));\n    visited[start_x][start_y] = true;\n\n    int dx[] = {-1, 1, 0, 0, -1, -1, 1, 1};\n    int dy[] = {0, 0, -1, 1, -1, 1, -1, 1};\n\n    while (!q.empty()) {\n        Stone current = q.front();\n        q.pop();\n\n        if (current.x >= GOAL_ROW) {\n            cout << current.jumps << endl;\n            return true;\n        }\n\n        for (int d = 0; d < 8; ++d) {\n            int adj_x = current.x + dx[d];\n            int adj_y = current.y + dy[d];\n\n            if (isValidPosition(adj_x, adj_y, black_stones)) {\n                int new_x = adj_x + dx[d];\n                int new_y = adj_y + dy[d];\n                if (isValidPosition(new_x, new_y, black_stones) && !visited[new_x][new_y]) {\n                    black_stones[adj_x][adj_y] = false;\n                    q.push(Stone(new_x, new_y, current.jumps + 1));\n                    visited[new_x][new_y] = true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    vector<vector<bool>> black_stones(ROWS, vector<bool>(COLS, false));\n    int white_x, white_y;\n    cin >> white_x >> white_y;\n\n    int num_black;\n    cin >> num_black;\n    for (int i = 0; i < num_black; ++i) {\n        int x, y;\n        cin >> x >> y;\n        black_stones[x][y] = true;\n    }\n\n    if (!canReachGoal(white_x, white_y, black_stones)) {\n        cout << -1 << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:40:23"
  }
]